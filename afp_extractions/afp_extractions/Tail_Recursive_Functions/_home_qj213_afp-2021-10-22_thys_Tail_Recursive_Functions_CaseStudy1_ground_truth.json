{"file_name": "/home/qj213/afp-2021-10-22/thys/Tail_Recursive_Functions/CaseStudy1.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Tail_Recursive_Functions", "problem_names": ["theorem \"l_sorted (l_sort_naive xs [] [])\"", "lemma l_sort_subset:\n  assumes XY: \"Y \\<in> l_sort_set X\"\n  shows \"l_sort_set Y \\<subseteq> l_sort_set X\"", "lemma l_sort_aux_set: \"l_sort_aux X \\<in> l_sort_set X\"", "lemma \"l_sort_aux X \\<in> l_sort_set X\"", "lemma l_sort_input_1: \"l_sort_inv_1 (xs, [], [])\"", "lemma l_sort_input_2: \"l_sort_inv_2 x xs (xs, [], [])\"", "lemma l_sort_intro_1:\n \"l_sort_inv_1 X \\<Longrightarrow> l_sorted (l_sort_out X)\"", "lemma l_sort_intro_2:\n \"\\<lbrakk>l_sort_inv_2 x xs X; l_sort_form X\\<rbrakk> \\<Longrightarrow>\n  l_count x (l_sort_out X) = l_count x xs\"", "lemma l_sort_form_aux_all: \"l_sort_form (l_sort_aux X)\"", "lemma l_sort_form_aux: \"l_sort_form (l_sort_aux (xs, [], []))\"", "lemma l_sorted_app [rule_format]:\n \"l_sorted xs \\<longrightarrow> l_sorted ys \\<longrightarrow> last xs \\<le> hd ys \\<longrightarrow> l_sorted (xs @ ys)\"", "lemma l_sort_invariance_1:\n  assumes XY: \"Y \\<in> l_sort_set X\" and X: \"l_sort_inv_1 X\"\n  shows \"l_sort_inv_1 Y\"", "lemma l_count_cons: \"l_count x (y # ys) = l_count x [y] + l_count x ys\"", "lemma l_count_app: \"l_count x (ys @ zs) = l_count x ys + l_count x zs\"", "lemma l_sort_invariance_2:\n  assumes XY: \"Y \\<in> l_sort_set X\" and X: \"l_sort_inv_2 w ws X\"\n  shows \"l_sort_inv_2 w ws Y\"", "theorem \"l_sorted (l_sort xs)\"", "theorem \"l_count x (l_sort xs) = l_count x xs\""], "translations": [["", "theorem \"l_sorted (l_sort_naive xs [] [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sorted (l_sort_naive xs [] [])", "proof (rule l_sort_naive.induct [of \"\\<lambda>xs ys zs. l_sorted (l_sort_naive xs ys zs)\"],\n simp_all del: l_sort_naive.simps(3))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys zs. l_sorted (l_sort_naive [] ys zs)", "txt \\<open>\n\\null\n\nSimplification deletes all the subgoals generated by recursive equations.\nHowever, the following subgoal arises from the non-recursive one:\n\n\\null\n\n@{subgoals [display]}\n\n\\null\n\nwhich is hopeless as the formula is false for any unsorted list \\<open>zs\\<close>.\n\n\\null\n\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys zs. l_sorted (l_sort_naive [] ys zs)", "oops"], ["", "subsection \"Step 1\""], ["", "type_synonym 'a l_type = \"'a list \\<times> 'a list \\<times> 'a list\""], ["", "fun l_sort_aux :: \"'a::linorder l_type \\<Rightarrow> 'a l_type\" where\n\"l_sort_aux (x # xs, ys, []) = l_sort_aux (xs, [], ys @ [x])\" |\n\"l_sort_aux (x # xs, ys, z # zs) = (if x \\<le> z\n  then l_sort_aux (xs, [], ys @ x # z # zs)\n  else l_sort_aux (x # xs, ys @ [z], zs))\" |\n\"l_sort_aux ([], ys, zs) = ([], ys, zs)\""], ["", "text \\<open>\n\\null\n\nObserve that the Cartesian product of the input types has been implemented as a\nproduct type.\n\\<close>"], ["", "subsection \"Step 2\""], ["", "definition l_sort_in :: \"'a list \\<Rightarrow> 'a l_type\" where\n\"l_sort_in xs \\<equiv> (xs, [], [])\""], ["", "definition l_sort_out :: \"'a l_type \\<Rightarrow> 'a list\" where\n\"l_sort_out X \\<equiv> snd (snd X)\""], ["", "definition l_sort :: \"'a::linorder list \\<Rightarrow> 'a list\" where\n\"l_sort xs \\<equiv> l_sort_out (l_sort_aux (l_sort_in xs))\""], ["", "text \\<open>\n\\null\n\nSince the significant inputs of function \\<open>l_sort_naive\\<close> match pattern\n\\<open>_\\<close>, \\<open>[]\\<close>, \\<open>[]\\<close>, those of function \\<open>l_sort_aux\\<close>\nmatch pattern \\<open>(_, [], [])\\<close>, thus being in a one-to-one correspondence\nwith the type of the first component.\n\nThe target correctness theorems can then be put into the following equivalent\nform:\n\n\\null\n\n\\<open>l_sorted (l_sort xs)\\<close>\n\n\\null\n\n\\<open>l_count x (l_sort xs) = l_count x xs\\<close>\n\\<close>"], ["", "subsection \"Step 3\""], ["", "text \\<open>\nThe conditional recursive equation in the definition of function\n\\<open>l_sort_aux\\<close> will equivalently be associated to two distinct introduction\nrules in the definition of the inductive set \\<open>l_sort_set\\<close>, one for either\ntruth value of the Boolean condition, handled as an additional assumption. The\nadvantage is twofold: simpler introduction rules are obtained, and case\ndistinctions are saved as rule induction is applied.\n\n\\null\n\\<close>"], ["", "inductive_set l_sort_set :: \"'a::linorder l_type \\<Rightarrow> 'a l_type set\"\nfor X :: \"'a l_type\" where\nR0: \"X \\<in> l_sort_set X\" |\nR1: \"(x # xs, ys, []) \\<in> l_sort_set X \\<Longrightarrow> (xs, [], ys @ [x]) \\<in> l_sort_set X\" |\nR2: \"\\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X; x \\<le> z\\<rbrakk> \\<Longrightarrow>\n     (xs, [], ys @ x # z # zs) \\<in> l_sort_set X\" |\nR3: \"\\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X; \\<not> x \\<le> z\\<rbrakk> \\<Longrightarrow>\n     (x # xs, ys @ [z], zs) \\<in> l_sort_set X\""], ["", "subsection \"Step 4\""], ["", "lemma l_sort_subset:\n  assumes XY: \"Y \\<in> l_sort_set X\"\n  shows \"l_sort_set Y \\<subseteq> l_sort_set X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sort_set Y \\<subseteq> l_sort_set X", "proof (rule subsetI, erule l_sort_set.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. Y \\<in> l_sort_set X\n 2. \\<And>x xa xs ys.\n       \\<lbrakk>(xa # xs, ys, []) \\<in> l_sort_set Y;\n        (xa # xs, ys, []) \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> (xs, [], ys @ [xa]) \\<in> l_sort_set X\n 3. \\<And>x xa xs ys z zs.\n       \\<lbrakk>(xa # xs, ys, z # zs) \\<in> l_sort_set Y;\n        (xa # xs, ys, z # zs) \\<in> l_sort_set X; xa \\<le> z\\<rbrakk>\n       \\<Longrightarrow> (xs, [], ys @ xa # z # zs) \\<in> l_sort_set X\n 4. \\<And>x xa xs ys z zs.\n       \\<lbrakk>(xa # xs, ys, z # zs) \\<in> l_sort_set Y;\n        (xa # xs, ys, z # zs) \\<in> l_sort_set X; \\<not> xa \\<le> z\\<rbrakk>\n       \\<Longrightarrow> (xa # xs, ys @ [z], zs) \\<in> l_sort_set X", "show \"Y \\<in> l_sort_set X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<in> l_sort_set X", "using XY"], ["proof (prove)\nusing this:\n  Y \\<in> l_sort_set X\n\ngoal (1 subgoal):\n 1. Y \\<in> l_sort_set X", "."], ["proof (state)\nthis:\n  Y \\<in> l_sort_set X\n\ngoal (3 subgoals):\n 1. \\<And>x xa xs ys.\n       \\<lbrakk>(xa # xs, ys, []) \\<in> l_sort_set Y;\n        (xa # xs, ys, []) \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> (xs, [], ys @ [xa]) \\<in> l_sort_set X\n 2. \\<And>x xa xs ys z zs.\n       \\<lbrakk>(xa # xs, ys, z # zs) \\<in> l_sort_set Y;\n        (xa # xs, ys, z # zs) \\<in> l_sort_set X; xa \\<le> z\\<rbrakk>\n       \\<Longrightarrow> (xs, [], ys @ xa # z # zs) \\<in> l_sort_set X\n 3. \\<And>x xa xs ys z zs.\n       \\<lbrakk>(xa # xs, ys, z # zs) \\<in> l_sort_set Y;\n        (xa # xs, ys, z # zs) \\<in> l_sort_set X; \\<not> xa \\<le> z\\<rbrakk>\n       \\<Longrightarrow> (xa # xs, ys @ [z], zs) \\<in> l_sort_set X", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xa xs ys.\n       \\<lbrakk>(xa # xs, ys, []) \\<in> l_sort_set Y;\n        (xa # xs, ys, []) \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> (xs, [], ys @ [xa]) \\<in> l_sort_set X\n 2. \\<And>x xa xs ys z zs.\n       \\<lbrakk>(xa # xs, ys, z # zs) \\<in> l_sort_set Y;\n        (xa # xs, ys, z # zs) \\<in> l_sort_set X; xa \\<le> z\\<rbrakk>\n       \\<Longrightarrow> (xs, [], ys @ xa # z # zs) \\<in> l_sort_set X\n 3. \\<And>x xa xs ys z zs.\n       \\<lbrakk>(xa # xs, ys, z # zs) \\<in> l_sort_set Y;\n        (xa # xs, ys, z # zs) \\<in> l_sort_set X; \\<not> xa \\<le> z\\<rbrakk>\n       \\<Longrightarrow> (xa # xs, ys @ [z], zs) \\<in> l_sort_set X", "fix x xs ys"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xa xs ys.\n       \\<lbrakk>(xa # xs, ys, []) \\<in> l_sort_set Y;\n        (xa # xs, ys, []) \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> (xs, [], ys @ [xa]) \\<in> l_sort_set X\n 2. \\<And>x xa xs ys z zs.\n       \\<lbrakk>(xa # xs, ys, z # zs) \\<in> l_sort_set Y;\n        (xa # xs, ys, z # zs) \\<in> l_sort_set X; xa \\<le> z\\<rbrakk>\n       \\<Longrightarrow> (xs, [], ys @ xa # z # zs) \\<in> l_sort_set X\n 3. \\<And>x xa xs ys z zs.\n       \\<lbrakk>(xa # xs, ys, z # zs) \\<in> l_sort_set Y;\n        (xa # xs, ys, z # zs) \\<in> l_sort_set X; \\<not> xa \\<le> z\\<rbrakk>\n       \\<Longrightarrow> (xa # xs, ys @ [z], zs) \\<in> l_sort_set X", "assume \"(x # xs, ys, []) \\<in> l_sort_set X\""], ["proof (state)\nthis:\n  (x # xs, ys, []) \\<in> l_sort_set X\n\ngoal (3 subgoals):\n 1. \\<And>x xa xs ys.\n       \\<lbrakk>(xa # xs, ys, []) \\<in> l_sort_set Y;\n        (xa # xs, ys, []) \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> (xs, [], ys @ [xa]) \\<in> l_sort_set X\n 2. \\<And>x xa xs ys z zs.\n       \\<lbrakk>(xa # xs, ys, z # zs) \\<in> l_sort_set Y;\n        (xa # xs, ys, z # zs) \\<in> l_sort_set X; xa \\<le> z\\<rbrakk>\n       \\<Longrightarrow> (xs, [], ys @ xa # z # zs) \\<in> l_sort_set X\n 3. \\<And>x xa xs ys z zs.\n       \\<lbrakk>(xa # xs, ys, z # zs) \\<in> l_sort_set Y;\n        (xa # xs, ys, z # zs) \\<in> l_sort_set X; \\<not> xa \\<le> z\\<rbrakk>\n       \\<Longrightarrow> (xa # xs, ys @ [z], zs) \\<in> l_sort_set X", "thus \"(xs, [], ys @ [x]) \\<in> l_sort_set X\""], ["proof (prove)\nusing this:\n  (x # xs, ys, []) \\<in> l_sort_set X\n\ngoal (1 subgoal):\n 1. (xs, [], ys @ [x]) \\<in> l_sort_set X", "by (rule R1)"], ["proof (state)\nthis:\n  (xs, [], ys @ [x]) \\<in> l_sort_set X\n\ngoal (2 subgoals):\n 1. \\<And>x xa xs ys z zs.\n       \\<lbrakk>(xa # xs, ys, z # zs) \\<in> l_sort_set Y;\n        (xa # xs, ys, z # zs) \\<in> l_sort_set X; xa \\<le> z\\<rbrakk>\n       \\<Longrightarrow> (xs, [], ys @ xa # z # zs) \\<in> l_sort_set X\n 2. \\<And>x xa xs ys z zs.\n       \\<lbrakk>(xa # xs, ys, z # zs) \\<in> l_sort_set Y;\n        (xa # xs, ys, z # zs) \\<in> l_sort_set X; \\<not> xa \\<le> z\\<rbrakk>\n       \\<Longrightarrow> (xa # xs, ys @ [z], zs) \\<in> l_sort_set X", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xs ys z zs.\n       \\<lbrakk>(xa # xs, ys, z # zs) \\<in> l_sort_set Y;\n        (xa # xs, ys, z # zs) \\<in> l_sort_set X; xa \\<le> z\\<rbrakk>\n       \\<Longrightarrow> (xs, [], ys @ xa # z # zs) \\<in> l_sort_set X\n 2. \\<And>x xa xs ys z zs.\n       \\<lbrakk>(xa # xs, ys, z # zs) \\<in> l_sort_set Y;\n        (xa # xs, ys, z # zs) \\<in> l_sort_set X; \\<not> xa \\<le> z\\<rbrakk>\n       \\<Longrightarrow> (xa # xs, ys @ [z], zs) \\<in> l_sort_set X", "fix x xs ys z zs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa xs ys z zs.\n       \\<lbrakk>(xa # xs, ys, z # zs) \\<in> l_sort_set Y;\n        (xa # xs, ys, z # zs) \\<in> l_sort_set X; xa \\<le> z\\<rbrakk>\n       \\<Longrightarrow> (xs, [], ys @ xa # z # zs) \\<in> l_sort_set X\n 2. \\<And>x xa xs ys z zs.\n       \\<lbrakk>(xa # xs, ys, z # zs) \\<in> l_sort_set Y;\n        (xa # xs, ys, z # zs) \\<in> l_sort_set X; \\<not> xa \\<le> z\\<rbrakk>\n       \\<Longrightarrow> (xa # xs, ys @ [z], zs) \\<in> l_sort_set X", "assume \"(x # xs, ys, z # zs) \\<in> l_sort_set X\" and \"x \\<le> z\""], ["proof (state)\nthis:\n  (x # xs, ys, z # zs) \\<in> l_sort_set X\n  x \\<le> z\n\ngoal (2 subgoals):\n 1. \\<And>x xa xs ys z zs.\n       \\<lbrakk>(xa # xs, ys, z # zs) \\<in> l_sort_set Y;\n        (xa # xs, ys, z # zs) \\<in> l_sort_set X; xa \\<le> z\\<rbrakk>\n       \\<Longrightarrow> (xs, [], ys @ xa # z # zs) \\<in> l_sort_set X\n 2. \\<And>x xa xs ys z zs.\n       \\<lbrakk>(xa # xs, ys, z # zs) \\<in> l_sort_set Y;\n        (xa # xs, ys, z # zs) \\<in> l_sort_set X; \\<not> xa \\<le> z\\<rbrakk>\n       \\<Longrightarrow> (xa # xs, ys @ [z], zs) \\<in> l_sort_set X", "thus \"(xs, [], ys @ x # z # zs) \\<in> l_sort_set X\""], ["proof (prove)\nusing this:\n  (x # xs, ys, z # zs) \\<in> l_sort_set X\n  x \\<le> z\n\ngoal (1 subgoal):\n 1. (xs, [], ys @ x # z # zs) \\<in> l_sort_set X", "by (rule R2)"], ["proof (state)\nthis:\n  (xs, [], ys @ x # z # zs) \\<in> l_sort_set X\n\ngoal (1 subgoal):\n 1. \\<And>x xa xs ys z zs.\n       \\<lbrakk>(xa # xs, ys, z # zs) \\<in> l_sort_set Y;\n        (xa # xs, ys, z # zs) \\<in> l_sort_set X; \\<not> xa \\<le> z\\<rbrakk>\n       \\<Longrightarrow> (xa # xs, ys @ [z], zs) \\<in> l_sort_set X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xs ys z zs.\n       \\<lbrakk>(xa # xs, ys, z # zs) \\<in> l_sort_set Y;\n        (xa # xs, ys, z # zs) \\<in> l_sort_set X; \\<not> xa \\<le> z\\<rbrakk>\n       \\<Longrightarrow> (xa # xs, ys @ [z], zs) \\<in> l_sort_set X", "fix x xs ys z zs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xs ys z zs.\n       \\<lbrakk>(xa # xs, ys, z # zs) \\<in> l_sort_set Y;\n        (xa # xs, ys, z # zs) \\<in> l_sort_set X; \\<not> xa \\<le> z\\<rbrakk>\n       \\<Longrightarrow> (xa # xs, ys @ [z], zs) \\<in> l_sort_set X", "assume \"(x # xs, ys, z # zs) \\<in> l_sort_set X\" and \"\\<not> x \\<le> z\""], ["proof (state)\nthis:\n  (x # xs, ys, z # zs) \\<in> l_sort_set X\n  \\<not> x \\<le> z\n\ngoal (1 subgoal):\n 1. \\<And>x xa xs ys z zs.\n       \\<lbrakk>(xa # xs, ys, z # zs) \\<in> l_sort_set Y;\n        (xa # xs, ys, z # zs) \\<in> l_sort_set X; \\<not> xa \\<le> z\\<rbrakk>\n       \\<Longrightarrow> (xa # xs, ys @ [z], zs) \\<in> l_sort_set X", "thus \"(x # xs, ys @ [z], zs) \\<in> l_sort_set X\""], ["proof (prove)\nusing this:\n  (x # xs, ys, z # zs) \\<in> l_sort_set X\n  \\<not> x \\<le> z\n\ngoal (1 subgoal):\n 1. (x # xs, ys @ [z], zs) \\<in> l_sort_set X", "by (rule R3)"], ["proof (state)\nthis:\n  (x # xs, ys @ [z], zs) \\<in> l_sort_set X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma l_sort_aux_set: \"l_sort_aux X \\<in> l_sort_set X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sort_aux X \\<in> l_sort_set X", "proof (induction rule: l_sort_aux.induct, simp_all del: l_sort_aux.simps(2))"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xs ys.\n       l_sort_aux (xs, [], ys @ [x])\n       \\<in> l_sort_set (xs, [], ys @ [x]) \\<Longrightarrow>\n       l_sort_aux (xs, [], ys @ [x]) \\<in> l_sort_set (x # xs, ys, [])\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>x \\<le> z \\<Longrightarrow>\n                l_sort_aux (xs, [], ys @ x # z # zs)\n                \\<in> l_sort_set (xs, [], ys @ x # z # zs);\n        \\<not> x \\<le> z \\<Longrightarrow>\n        l_sort_aux (x # xs, ys @ [z], zs)\n        \\<in> l_sort_set (x # xs, ys @ [z], zs)\\<rbrakk>\n       \\<Longrightarrow> l_sort_aux (x # xs, ys, z # zs)\n                         \\<in> l_sort_set (x # xs, ys, z # zs)\n 3. \\<And>ys zs. ([], ys, zs) \\<in> l_sort_set ([], ys, zs)", "fix ys :: \"'a list\" and zs"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xs ys.\n       l_sort_aux (xs, [], ys @ [x])\n       \\<in> l_sort_set (xs, [], ys @ [x]) \\<Longrightarrow>\n       l_sort_aux (xs, [], ys @ [x]) \\<in> l_sort_set (x # xs, ys, [])\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>x \\<le> z \\<Longrightarrow>\n                l_sort_aux (xs, [], ys @ x # z # zs)\n                \\<in> l_sort_set (xs, [], ys @ x # z # zs);\n        \\<not> x \\<le> z \\<Longrightarrow>\n        l_sort_aux (x # xs, ys @ [z], zs)\n        \\<in> l_sort_set (x # xs, ys @ [z], zs)\\<rbrakk>\n       \\<Longrightarrow> l_sort_aux (x # xs, ys, z # zs)\n                         \\<in> l_sort_set (x # xs, ys, z # zs)\n 3. \\<And>ys zs. ([], ys, zs) \\<in> l_sort_set ([], ys, zs)", "show \"([], ys, zs) \\<in> l_sort_set ([], ys, zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([], ys, zs) \\<in> l_sort_set ([], ys, zs)", "by (rule R0)"], ["proof (state)\nthis:\n  ([], ys, zs) \\<in> l_sort_set ([], ys, zs)\n\ngoal (2 subgoals):\n 1. \\<And>x xs ys.\n       l_sort_aux (xs, [], ys @ [x])\n       \\<in> l_sort_set (xs, [], ys @ [x]) \\<Longrightarrow>\n       l_sort_aux (xs, [], ys @ [x]) \\<in> l_sort_set (x # xs, ys, [])\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>x \\<le> z \\<Longrightarrow>\n                l_sort_aux (xs, [], ys @ x # z # zs)\n                \\<in> l_sort_set (xs, [], ys @ x # z # zs);\n        \\<not> x \\<le> z \\<Longrightarrow>\n        l_sort_aux (x # xs, ys @ [z], zs)\n        \\<in> l_sort_set (x # xs, ys @ [z], zs)\\<rbrakk>\n       \\<Longrightarrow> l_sort_aux (x # xs, ys, z # zs)\n                         \\<in> l_sort_set (x # xs, ys, z # zs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xs ys.\n       l_sort_aux (xs, [], ys @ [x])\n       \\<in> l_sort_set (xs, [], ys @ [x]) \\<Longrightarrow>\n       l_sort_aux (xs, [], ys @ [x]) \\<in> l_sort_set (x # xs, ys, [])\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>x \\<le> z \\<Longrightarrow>\n                l_sort_aux (xs, [], ys @ x # z # zs)\n                \\<in> l_sort_set (xs, [], ys @ x # z # zs);\n        \\<not> x \\<le> z \\<Longrightarrow>\n        l_sort_aux (x # xs, ys @ [z], zs)\n        \\<in> l_sort_set (x # xs, ys @ [z], zs)\\<rbrakk>\n       \\<Longrightarrow> l_sort_aux (x # xs, ys, z # zs)\n                         \\<in> l_sort_set (x # xs, ys, z # zs)", "fix x :: 'a and xs ys"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xs ys.\n       l_sort_aux (xs, [], ys @ [x])\n       \\<in> l_sort_set (xs, [], ys @ [x]) \\<Longrightarrow>\n       l_sort_aux (xs, [], ys @ [x]) \\<in> l_sort_set (x # xs, ys, [])\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>x \\<le> z \\<Longrightarrow>\n                l_sort_aux (xs, [], ys @ x # z # zs)\n                \\<in> l_sort_set (xs, [], ys @ x # z # zs);\n        \\<not> x \\<le> z \\<Longrightarrow>\n        l_sort_aux (x # xs, ys @ [z], zs)\n        \\<in> l_sort_set (x # xs, ys @ [z], zs)\\<rbrakk>\n       \\<Longrightarrow> l_sort_aux (x # xs, ys, z # zs)\n                         \\<in> l_sort_set (x # xs, ys, z # zs)", "have \"(x # xs, ys, []) \\<in> l_sort_set (x # xs, ys, [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x # xs, ys, []) \\<in> l_sort_set (x # xs, ys, [])", "by (rule R0)"], ["proof (state)\nthis:\n  (x # xs, ys, []) \\<in> l_sort_set (x # xs, ys, [])\n\ngoal (2 subgoals):\n 1. \\<And>x xs ys.\n       l_sort_aux (xs, [], ys @ [x])\n       \\<in> l_sort_set (xs, [], ys @ [x]) \\<Longrightarrow>\n       l_sort_aux (xs, [], ys @ [x]) \\<in> l_sort_set (x # xs, ys, [])\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>x \\<le> z \\<Longrightarrow>\n                l_sort_aux (xs, [], ys @ x # z # zs)\n                \\<in> l_sort_set (xs, [], ys @ x # z # zs);\n        \\<not> x \\<le> z \\<Longrightarrow>\n        l_sort_aux (x # xs, ys @ [z], zs)\n        \\<in> l_sort_set (x # xs, ys @ [z], zs)\\<rbrakk>\n       \\<Longrightarrow> l_sort_aux (x # xs, ys, z # zs)\n                         \\<in> l_sort_set (x # xs, ys, z # zs)", "hence \"(xs, [], ys @ [x]) \\<in> l_sort_set (x # xs, ys, [])\""], ["proof (prove)\nusing this:\n  (x # xs, ys, []) \\<in> l_sort_set (x # xs, ys, [])\n\ngoal (1 subgoal):\n 1. (xs, [], ys @ [x]) \\<in> l_sort_set (x # xs, ys, [])", "by (rule R1)"], ["proof (state)\nthis:\n  (xs, [], ys @ [x]) \\<in> l_sort_set (x # xs, ys, [])\n\ngoal (2 subgoals):\n 1. \\<And>x xs ys.\n       l_sort_aux (xs, [], ys @ [x])\n       \\<in> l_sort_set (xs, [], ys @ [x]) \\<Longrightarrow>\n       l_sort_aux (xs, [], ys @ [x]) \\<in> l_sort_set (x # xs, ys, [])\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>x \\<le> z \\<Longrightarrow>\n                l_sort_aux (xs, [], ys @ x # z # zs)\n                \\<in> l_sort_set (xs, [], ys @ x # z # zs);\n        \\<not> x \\<le> z \\<Longrightarrow>\n        l_sort_aux (x # xs, ys @ [z], zs)\n        \\<in> l_sort_set (x # xs, ys @ [z], zs)\\<rbrakk>\n       \\<Longrightarrow> l_sort_aux (x # xs, ys, z # zs)\n                         \\<in> l_sort_set (x # xs, ys, z # zs)", "hence \"l_sort_set (xs, [], ys @ [x]) \\<subseteq> l_sort_set (x # xs, ys, [])\""], ["proof (prove)\nusing this:\n  (xs, [], ys @ [x]) \\<in> l_sort_set (x # xs, ys, [])\n\ngoal (1 subgoal):\n 1. l_sort_set (xs, [], ys @ [x]) \\<subseteq> l_sort_set (x # xs, ys, [])", "by (rule l_sort_subset)"], ["proof (state)\nthis:\n  l_sort_set (xs, [], ys @ [x]) \\<subseteq> l_sort_set (x # xs, ys, [])\n\ngoal (2 subgoals):\n 1. \\<And>x xs ys.\n       l_sort_aux (xs, [], ys @ [x])\n       \\<in> l_sort_set (xs, [], ys @ [x]) \\<Longrightarrow>\n       l_sort_aux (xs, [], ys @ [x]) \\<in> l_sort_set (x # xs, ys, [])\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>x \\<le> z \\<Longrightarrow>\n                l_sort_aux (xs, [], ys @ x # z # zs)\n                \\<in> l_sort_set (xs, [], ys @ x # z # zs);\n        \\<not> x \\<le> z \\<Longrightarrow>\n        l_sort_aux (x # xs, ys @ [z], zs)\n        \\<in> l_sort_set (x # xs, ys @ [z], zs)\\<rbrakk>\n       \\<Longrightarrow> l_sort_aux (x # xs, ys, z # zs)\n                         \\<in> l_sort_set (x # xs, ys, z # zs)", "moreover"], ["proof (state)\nthis:\n  l_sort_set (xs, [], ys @ [x]) \\<subseteq> l_sort_set (x # xs, ys, [])\n\ngoal (2 subgoals):\n 1. \\<And>x xs ys.\n       l_sort_aux (xs, [], ys @ [x])\n       \\<in> l_sort_set (xs, [], ys @ [x]) \\<Longrightarrow>\n       l_sort_aux (xs, [], ys @ [x]) \\<in> l_sort_set (x # xs, ys, [])\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>x \\<le> z \\<Longrightarrow>\n                l_sort_aux (xs, [], ys @ x # z # zs)\n                \\<in> l_sort_set (xs, [], ys @ x # z # zs);\n        \\<not> x \\<le> z \\<Longrightarrow>\n        l_sort_aux (x # xs, ys @ [z], zs)\n        \\<in> l_sort_set (x # xs, ys @ [z], zs)\\<rbrakk>\n       \\<Longrightarrow> l_sort_aux (x # xs, ys, z # zs)\n                         \\<in> l_sort_set (x # xs, ys, z # zs)", "assume \"l_sort_aux (xs, [], ys @ [x]) \\<in> l_sort_set (xs, [], ys @ [x])\""], ["proof (state)\nthis:\n  l_sort_aux (xs, [], ys @ [x]) \\<in> l_sort_set (xs, [], ys @ [x])\n\ngoal (2 subgoals):\n 1. \\<And>x xs ys.\n       l_sort_aux (xs, [], ys @ [x])\n       \\<in> l_sort_set (xs, [], ys @ [x]) \\<Longrightarrow>\n       l_sort_aux (xs, [], ys @ [x]) \\<in> l_sort_set (x # xs, ys, [])\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>x \\<le> z \\<Longrightarrow>\n                l_sort_aux (xs, [], ys @ x # z # zs)\n                \\<in> l_sort_set (xs, [], ys @ x # z # zs);\n        \\<not> x \\<le> z \\<Longrightarrow>\n        l_sort_aux (x # xs, ys @ [z], zs)\n        \\<in> l_sort_set (x # xs, ys @ [z], zs)\\<rbrakk>\n       \\<Longrightarrow> l_sort_aux (x # xs, ys, z # zs)\n                         \\<in> l_sort_set (x # xs, ys, z # zs)", "ultimately"], ["proof (chain)\npicking this:\n  l_sort_set (xs, [], ys @ [x]) \\<subseteq> l_sort_set (x # xs, ys, [])\n  l_sort_aux (xs, [], ys @ [x]) \\<in> l_sort_set (xs, [], ys @ [x])", "show \"l_sort_aux (xs, [], ys @ [x]) \\<in> l_sort_set (x # xs, ys, [])\""], ["proof (prove)\nusing this:\n  l_sort_set (xs, [], ys @ [x]) \\<subseteq> l_sort_set (x # xs, ys, [])\n  l_sort_aux (xs, [], ys @ [x]) \\<in> l_sort_set (xs, [], ys @ [x])\n\ngoal (1 subgoal):\n 1. l_sort_aux (xs, [], ys @ [x]) \\<in> l_sort_set (x # xs, ys, [])", "by (rule subsetD)"], ["proof (state)\nthis:\n  l_sort_aux (xs, [], ys @ [x]) \\<in> l_sort_set (x # xs, ys, [])\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys z zs.\n       \\<lbrakk>x \\<le> z \\<Longrightarrow>\n                l_sort_aux (xs, [], ys @ x # z # zs)\n                \\<in> l_sort_set (xs, [], ys @ x # z # zs);\n        \\<not> x \\<le> z \\<Longrightarrow>\n        l_sort_aux (x # xs, ys @ [z], zs)\n        \\<in> l_sort_set (x # xs, ys @ [z], zs)\\<rbrakk>\n       \\<Longrightarrow> l_sort_aux (x # xs, ys, z # zs)\n                         \\<in> l_sort_set (x # xs, ys, z # zs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs ys z zs.\n       \\<lbrakk>x \\<le> z \\<Longrightarrow>\n                l_sort_aux (xs, [], ys @ x # z # zs)\n                \\<in> l_sort_set (xs, [], ys @ x # z # zs);\n        \\<not> x \\<le> z \\<Longrightarrow>\n        l_sort_aux (x # xs, ys @ [z], zs)\n        \\<in> l_sort_set (x # xs, ys @ [z], zs)\\<rbrakk>\n       \\<Longrightarrow> l_sort_aux (x # xs, ys, z # zs)\n                         \\<in> l_sort_set (x # xs, ys, z # zs)", "fix x :: 'a and xs ys z zs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs ys z zs.\n       \\<lbrakk>x \\<le> z \\<Longrightarrow>\n                l_sort_aux (xs, [], ys @ x # z # zs)\n                \\<in> l_sort_set (xs, [], ys @ x # z # zs);\n        \\<not> x \\<le> z \\<Longrightarrow>\n        l_sort_aux (x # xs, ys @ [z], zs)\n        \\<in> l_sort_set (x # xs, ys @ [z], zs)\\<rbrakk>\n       \\<Longrightarrow> l_sort_aux (x # xs, ys, z # zs)\n                         \\<in> l_sort_set (x # xs, ys, z # zs)", "assume\n   case1: \"x \\<le> z \\<Longrightarrow>\n    l_sort_aux (xs, [], ys @ x # z # zs) \\<in> l_sort_set (xs, [], ys @ x # z # zs)\"\n  and\n   case2: \"\\<not> x \\<le> z \\<Longrightarrow>\n    l_sort_aux (x # xs, ys @ [z], zs) \\<in> l_sort_set (x # xs, ys @ [z], zs)\""], ["proof (state)\nthis:\n  x \\<le> z \\<Longrightarrow>\n  l_sort_aux (xs, [], ys @ x # z # zs)\n  \\<in> l_sort_set (xs, [], ys @ x # z # zs)\n  \\<not> x \\<le> z \\<Longrightarrow>\n  l_sort_aux (x # xs, ys @ [z], zs) \\<in> l_sort_set (x # xs, ys @ [z], zs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys z zs.\n       \\<lbrakk>x \\<le> z \\<Longrightarrow>\n                l_sort_aux (xs, [], ys @ x # z # zs)\n                \\<in> l_sort_set (xs, [], ys @ x # z # zs);\n        \\<not> x \\<le> z \\<Longrightarrow>\n        l_sort_aux (x # xs, ys @ [z], zs)\n        \\<in> l_sort_set (x # xs, ys @ [z], zs)\\<rbrakk>\n       \\<Longrightarrow> l_sort_aux (x # xs, ys, z # zs)\n                         \\<in> l_sort_set (x # xs, ys, z # zs)", "have 0: \"(x # xs, ys, z # zs) \\<in> l_sort_set (x # xs, ys, z # zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x # xs, ys, z # zs) \\<in> l_sort_set (x # xs, ys, z # zs)", "by (rule R0)"], ["proof (state)\nthis:\n  (x # xs, ys, z # zs) \\<in> l_sort_set (x # xs, ys, z # zs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys z zs.\n       \\<lbrakk>x \\<le> z \\<Longrightarrow>\n                l_sort_aux (xs, [], ys @ x # z # zs)\n                \\<in> l_sort_set (xs, [], ys @ x # z # zs);\n        \\<not> x \\<le> z \\<Longrightarrow>\n        l_sort_aux (x # xs, ys @ [z], zs)\n        \\<in> l_sort_set (x # xs, ys @ [z], zs)\\<rbrakk>\n       \\<Longrightarrow> l_sort_aux (x # xs, ys, z # zs)\n                         \\<in> l_sort_set (x # xs, ys, z # zs)", "show \"l_sort_aux (x # xs, ys, z # zs) \\<in> l_sort_set (x # xs, ys, z # zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sort_aux (x # xs, ys, z # zs) \\<in> l_sort_set (x # xs, ys, z # zs)", "proof (cases \"x \\<le> z\", simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<le> z \\<Longrightarrow>\n    l_sort_aux (xs, [], ys @ x # z # zs)\n    \\<in> l_sort_set (x # xs, ys, z # zs)\n 2. \\<not> x \\<le> z \\<Longrightarrow>\n    l_sort_aux (x # xs, ys @ [z], zs) \\<in> l_sort_set (x # xs, ys, z # zs)", "assume \"x \\<le> z\""], ["proof (state)\nthis:\n  x \\<le> z\n\ngoal (2 subgoals):\n 1. x \\<le> z \\<Longrightarrow>\n    l_sort_aux (xs, [], ys @ x # z # zs)\n    \\<in> l_sort_set (x # xs, ys, z # zs)\n 2. \\<not> x \\<le> z \\<Longrightarrow>\n    l_sort_aux (x # xs, ys @ [z], zs) \\<in> l_sort_set (x # xs, ys, z # zs)", "with 0"], ["proof (chain)\npicking this:\n  (x # xs, ys, z # zs) \\<in> l_sort_set (x # xs, ys, z # zs)\n  x \\<le> z", "have \"(xs, [], ys @ x # z # zs) \\<in> l_sort_set (x # xs, ys, z # zs)\""], ["proof (prove)\nusing this:\n  (x # xs, ys, z # zs) \\<in> l_sort_set (x # xs, ys, z # zs)\n  x \\<le> z\n\ngoal (1 subgoal):\n 1. (xs, [], ys @ x # z # zs) \\<in> l_sort_set (x # xs, ys, z # zs)", "by (rule R2)"], ["proof (state)\nthis:\n  (xs, [], ys @ x # z # zs) \\<in> l_sort_set (x # xs, ys, z # zs)\n\ngoal (2 subgoals):\n 1. x \\<le> z \\<Longrightarrow>\n    l_sort_aux (xs, [], ys @ x # z # zs)\n    \\<in> l_sort_set (x # xs, ys, z # zs)\n 2. \\<not> x \\<le> z \\<Longrightarrow>\n    l_sort_aux (x # xs, ys @ [z], zs) \\<in> l_sort_set (x # xs, ys, z # zs)", "hence \"l_sort_set (xs, [], ys @ x # z # zs) \\<subseteq> l_sort_set (x # xs, ys, z # zs)\""], ["proof (prove)\nusing this:\n  (xs, [], ys @ x # z # zs) \\<in> l_sort_set (x # xs, ys, z # zs)\n\ngoal (1 subgoal):\n 1. l_sort_set (xs, [], ys @ x # z # zs)\n    \\<subseteq> l_sort_set (x # xs, ys, z # zs)", "by (rule l_sort_subset)"], ["proof (state)\nthis:\n  l_sort_set (xs, [], ys @ x # z # zs)\n  \\<subseteq> l_sort_set (x # xs, ys, z # zs)\n\ngoal (2 subgoals):\n 1. x \\<le> z \\<Longrightarrow>\n    l_sort_aux (xs, [], ys @ x # z # zs)\n    \\<in> l_sort_set (x # xs, ys, z # zs)\n 2. \\<not> x \\<le> z \\<Longrightarrow>\n    l_sort_aux (x # xs, ys @ [z], zs) \\<in> l_sort_set (x # xs, ys, z # zs)", "moreover"], ["proof (state)\nthis:\n  l_sort_set (xs, [], ys @ x # z # zs)\n  \\<subseteq> l_sort_set (x # xs, ys, z # zs)\n\ngoal (2 subgoals):\n 1. x \\<le> z \\<Longrightarrow>\n    l_sort_aux (xs, [], ys @ x # z # zs)\n    \\<in> l_sort_set (x # xs, ys, z # zs)\n 2. \\<not> x \\<le> z \\<Longrightarrow>\n    l_sort_aux (x # xs, ys @ [z], zs) \\<in> l_sort_set (x # xs, ys, z # zs)", "have \"l_sort_aux (xs, [], ys @ x # z # zs) \\<in>\n     l_sort_set (xs, [], ys @ x # z # zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sort_aux (xs, [], ys @ x # z # zs)\n    \\<in> l_sort_set (xs, [], ys @ x # z # zs)", "using case1 and \\<open>x \\<le> z\\<close>"], ["proof (prove)\nusing this:\n  x \\<le> z \\<Longrightarrow>\n  l_sort_aux (xs, [], ys @ x # z # zs)\n  \\<in> l_sort_set (xs, [], ys @ x # z # zs)\n  x \\<le> z\n\ngoal (1 subgoal):\n 1. l_sort_aux (xs, [], ys @ x # z # zs)\n    \\<in> l_sort_set (xs, [], ys @ x # z # zs)", "by simp"], ["proof (state)\nthis:\n  l_sort_aux (xs, [], ys @ x # z # zs)\n  \\<in> l_sort_set (xs, [], ys @ x # z # zs)\n\ngoal (2 subgoals):\n 1. x \\<le> z \\<Longrightarrow>\n    l_sort_aux (xs, [], ys @ x # z # zs)\n    \\<in> l_sort_set (x # xs, ys, z # zs)\n 2. \\<not> x \\<le> z \\<Longrightarrow>\n    l_sort_aux (x # xs, ys @ [z], zs) \\<in> l_sort_set (x # xs, ys, z # zs)", "ultimately"], ["proof (chain)\npicking this:\n  l_sort_set (xs, [], ys @ x # z # zs)\n  \\<subseteq> l_sort_set (x # xs, ys, z # zs)\n  l_sort_aux (xs, [], ys @ x # z # zs)\n  \\<in> l_sort_set (xs, [], ys @ x # z # zs)", "show \"l_sort_aux (xs, [], ys @ x # z # zs) \\<in>\n     l_sort_set (x # xs, ys, z # zs)\""], ["proof (prove)\nusing this:\n  l_sort_set (xs, [], ys @ x # z # zs)\n  \\<subseteq> l_sort_set (x # xs, ys, z # zs)\n  l_sort_aux (xs, [], ys @ x # z # zs)\n  \\<in> l_sort_set (xs, [], ys @ x # z # zs)\n\ngoal (1 subgoal):\n 1. l_sort_aux (xs, [], ys @ x # z # zs)\n    \\<in> l_sort_set (x # xs, ys, z # zs)", "by (rule subsetD)"], ["proof (state)\nthis:\n  l_sort_aux (xs, [], ys @ x # z # zs) \\<in> l_sort_set (x # xs, ys, z # zs)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> z \\<Longrightarrow>\n    l_sort_aux (x # xs, ys @ [z], zs) \\<in> l_sort_set (x # xs, ys, z # zs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x \\<le> z \\<Longrightarrow>\n    l_sort_aux (x # xs, ys @ [z], zs) \\<in> l_sort_set (x # xs, ys, z # zs)", "assume \"\\<not> x \\<le> z\""], ["proof (state)\nthis:\n  \\<not> x \\<le> z\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> z \\<Longrightarrow>\n    l_sort_aux (x # xs, ys @ [z], zs) \\<in> l_sort_set (x # xs, ys, z # zs)", "with 0"], ["proof (chain)\npicking this:\n  (x # xs, ys, z # zs) \\<in> l_sort_set (x # xs, ys, z # zs)\n  \\<not> x \\<le> z", "have \"(x # xs, ys @ [z], zs) \\<in> l_sort_set (x # xs, ys, z # zs)\""], ["proof (prove)\nusing this:\n  (x # xs, ys, z # zs) \\<in> l_sort_set (x # xs, ys, z # zs)\n  \\<not> x \\<le> z\n\ngoal (1 subgoal):\n 1. (x # xs, ys @ [z], zs) \\<in> l_sort_set (x # xs, ys, z # zs)", "by (rule R3)"], ["proof (state)\nthis:\n  (x # xs, ys @ [z], zs) \\<in> l_sort_set (x # xs, ys, z # zs)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> z \\<Longrightarrow>\n    l_sort_aux (x # xs, ys @ [z], zs) \\<in> l_sort_set (x # xs, ys, z # zs)", "hence \"l_sort_set (x # xs, ys @ [z], zs) \\<subseteq> l_sort_set (x # xs, ys, z # zs)\""], ["proof (prove)\nusing this:\n  (x # xs, ys @ [z], zs) \\<in> l_sort_set (x # xs, ys, z # zs)\n\ngoal (1 subgoal):\n 1. l_sort_set (x # xs, ys @ [z], zs)\n    \\<subseteq> l_sort_set (x # xs, ys, z # zs)", "by (rule l_sort_subset)"], ["proof (state)\nthis:\n  l_sort_set (x # xs, ys @ [z], zs)\n  \\<subseteq> l_sort_set (x # xs, ys, z # zs)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> z \\<Longrightarrow>\n    l_sort_aux (x # xs, ys @ [z], zs) \\<in> l_sort_set (x # xs, ys, z # zs)", "moreover"], ["proof (state)\nthis:\n  l_sort_set (x # xs, ys @ [z], zs)\n  \\<subseteq> l_sort_set (x # xs, ys, z # zs)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> z \\<Longrightarrow>\n    l_sort_aux (x # xs, ys @ [z], zs) \\<in> l_sort_set (x # xs, ys, z # zs)", "have \"l_sort_aux (x # xs, ys @ [z], zs) \\<in>\n     l_sort_set (x # xs, ys @ [z], zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sort_aux (x # xs, ys @ [z], zs)\n    \\<in> l_sort_set (x # xs, ys @ [z], zs)", "using case2 and \\<open>\\<not> x \\<le> z\\<close>"], ["proof (prove)\nusing this:\n  \\<not> x \\<le> z \\<Longrightarrow>\n  l_sort_aux (x # xs, ys @ [z], zs) \\<in> l_sort_set (x # xs, ys @ [z], zs)\n  \\<not> x \\<le> z\n\ngoal (1 subgoal):\n 1. l_sort_aux (x # xs, ys @ [z], zs)\n    \\<in> l_sort_set (x # xs, ys @ [z], zs)", "by simp"], ["proof (state)\nthis:\n  l_sort_aux (x # xs, ys @ [z], zs) \\<in> l_sort_set (x # xs, ys @ [z], zs)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> z \\<Longrightarrow>\n    l_sort_aux (x # xs, ys @ [z], zs) \\<in> l_sort_set (x # xs, ys, z # zs)", "ultimately"], ["proof (chain)\npicking this:\n  l_sort_set (x # xs, ys @ [z], zs)\n  \\<subseteq> l_sort_set (x # xs, ys, z # zs)\n  l_sort_aux (x # xs, ys @ [z], zs) \\<in> l_sort_set (x # xs, ys @ [z], zs)", "show \"l_sort_aux (x # xs, ys @ [z], zs) \\<in>\n     l_sort_set (x # xs, ys, z # zs)\""], ["proof (prove)\nusing this:\n  l_sort_set (x # xs, ys @ [z], zs)\n  \\<subseteq> l_sort_set (x # xs, ys, z # zs)\n  l_sort_aux (x # xs, ys @ [z], zs) \\<in> l_sort_set (x # xs, ys @ [z], zs)\n\ngoal (1 subgoal):\n 1. l_sort_aux (x # xs, ys @ [z], zs) \\<in> l_sort_set (x # xs, ys, z # zs)", "by (rule subsetD)"], ["proof (state)\nthis:\n  l_sort_aux (x # xs, ys @ [z], zs) \\<in> l_sort_set (x # xs, ys, z # zs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l_sort_aux (x # xs, ys, z # zs) \\<in> l_sort_set (x # xs, ys, z # zs)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n\\null\n\nThe reader will have observed that the simplification rule arising from the\nsecond equation in the definition of function \\<open>l_sort_aux\\<close>, i.e. the one\nwhose right-hand side contains a conditional, has been ignored in the initial\nbackward steps of the previous proof. The reason is that it would actually make\nmore complex the conclusion of the corresponding subgoal, as can easily be\nverified by trying to leave it enabled.\n\n\\null\n\\<close>"], ["", "lemma \"l_sort_aux X \\<in> l_sort_set X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sort_aux X \\<in> l_sort_set X", "proof (induction rule: l_sort_aux.induct, simp_all)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xs ys.\n       l_sort_aux (xs, [], ys @ [x])\n       \\<in> l_sort_set (xs, [], ys @ [x]) \\<Longrightarrow>\n       l_sort_aux (xs, [], ys @ [x]) \\<in> l_sort_set (x # xs, ys, [])\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>x \\<le> z \\<Longrightarrow>\n                l_sort_aux (xs, [], ys @ x # z # zs)\n                \\<in> l_sort_set (xs, [], ys @ x # z # zs);\n        \\<not> x \\<le> z \\<Longrightarrow>\n        l_sort_aux (x # xs, ys @ [z], zs)\n        \\<in> l_sort_set (x # xs, ys @ [z], zs)\\<rbrakk>\n       \\<Longrightarrow> (x \\<le> z \\<longrightarrow>\n                          l_sort_aux (xs, [], ys @ x # z # zs)\n                          \\<in> l_sort_set (x # xs, ys, z # zs)) \\<and>\n                         (\\<not> x \\<le> z \\<longrightarrow>\n                          l_sort_aux (x # xs, ys @ [z], zs)\n                          \\<in> l_sort_set (x # xs, ys, z # zs))\n 3. \\<And>ys zs. ([], ys, zs) \\<in> l_sort_set ([], ys, zs)", "(*<*)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xs ys.\n       l_sort_aux (xs, [], ys @ [x])\n       \\<in> l_sort_set (xs, [], ys @ [x]) \\<Longrightarrow>\n       l_sort_aux (xs, [], ys @ [x]) \\<in> l_sort_set (x # xs, ys, [])\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>x \\<le> z \\<Longrightarrow>\n                l_sort_aux (xs, [], ys @ x # z # zs)\n                \\<in> l_sort_set (xs, [], ys @ x # z # zs);\n        \\<not> x \\<le> z \\<Longrightarrow>\n        l_sort_aux (x # xs, ys @ [z], zs)\n        \\<in> l_sort_set (x # xs, ys @ [z], zs)\\<rbrakk>\n       \\<Longrightarrow> (x \\<le> z \\<longrightarrow>\n                          l_sort_aux (xs, [], ys @ x # z # zs)\n                          \\<in> l_sort_set (x # xs, ys, z # zs)) \\<and>\n                         (\\<not> x \\<le> z \\<longrightarrow>\n                          l_sort_aux (x # xs, ys @ [z], zs)\n                          \\<in> l_sort_set (x # xs, ys, z # zs))\n 3. \\<And>ys zs. ([], ys, zs) \\<in> l_sort_set ([], ys, zs)", "prefer 2"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xs ys z zs.\n       \\<lbrakk>x \\<le> z \\<Longrightarrow>\n                l_sort_aux (xs, [], ys @ x # z # zs)\n                \\<in> l_sort_set (xs, [], ys @ x # z # zs);\n        \\<not> x \\<le> z \\<Longrightarrow>\n        l_sort_aux (x # xs, ys @ [z], zs)\n        \\<in> l_sort_set (x # xs, ys @ [z], zs)\\<rbrakk>\n       \\<Longrightarrow> (x \\<le> z \\<longrightarrow>\n                          l_sort_aux (xs, [], ys @ x # z # zs)\n                          \\<in> l_sort_set (x # xs, ys, z # zs)) \\<and>\n                         (\\<not> x \\<le> z \\<longrightarrow>\n                          l_sort_aux (x # xs, ys @ [z], zs)\n                          \\<in> l_sort_set (x # xs, ys, z # zs))\n 2. \\<And>x xs ys.\n       l_sort_aux (xs, [], ys @ [x])\n       \\<in> l_sort_set (xs, [], ys @ [x]) \\<Longrightarrow>\n       l_sort_aux (xs, [], ys @ [x]) \\<in> l_sort_set (x # xs, ys, [])\n 3. \\<And>ys zs. ([], ys, zs) \\<in> l_sort_set ([], ys, zs)", "(*>*)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xs ys z zs.\n       \\<lbrakk>x \\<le> z \\<Longrightarrow>\n                l_sort_aux (xs, [], ys @ x # z # zs)\n                \\<in> l_sort_set (xs, [], ys @ x # z # zs);\n        \\<not> x \\<le> z \\<Longrightarrow>\n        l_sort_aux (x # xs, ys @ [z], zs)\n        \\<in> l_sort_set (x # xs, ys @ [z], zs)\\<rbrakk>\n       \\<Longrightarrow> (x \\<le> z \\<longrightarrow>\n                          l_sort_aux (xs, [], ys @ x # z # zs)\n                          \\<in> l_sort_set (x # xs, ys, z # zs)) \\<and>\n                         (\\<not> x \\<le> z \\<longrightarrow>\n                          l_sort_aux (x # xs, ys @ [z], zs)\n                          \\<in> l_sort_set (x # xs, ys, z # zs))\n 2. \\<And>x xs ys.\n       l_sort_aux (xs, [], ys @ [x])\n       \\<in> l_sort_set (xs, [], ys @ [x]) \\<Longrightarrow>\n       l_sort_aux (xs, [], ys @ [x]) \\<in> l_sort_set (x # xs, ys, [])\n 3. \\<And>ys zs. ([], ys, zs) \\<in> l_sort_set ([], ys, zs)", "txt \\<open>\n\\null\n\nAs a result of the application of the rule, the related subgoal takes the\nfollowing form:\n\n\\null\n\n@{subgoals [display, goals_limit = 1]}\n\n\\null\n\nNow the conclusion is comprised of a conjunction of two implications. This is\npointless, since case distinction is faster than the application of conjunction\nand implication introduction rules in providing sufficient assumptions for the\nsimplification of both the induction hypotheses and the conclusion.\n\n\\null\n\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xs ys z zs.\n       \\<lbrakk>x \\<le> z \\<Longrightarrow>\n                l_sort_aux (xs, [], ys @ x # z # zs)\n                \\<in> l_sort_set (xs, [], ys @ x # z # zs);\n        \\<not> x \\<le> z \\<Longrightarrow>\n        l_sort_aux (x # xs, ys @ [z], zs)\n        \\<in> l_sort_set (x # xs, ys @ [z], zs)\\<rbrakk>\n       \\<Longrightarrow> (x \\<le> z \\<longrightarrow>\n                          l_sort_aux (xs, [], ys @ x # z # zs)\n                          \\<in> l_sort_set (x # xs, ys, z # zs)) \\<and>\n                         (\\<not> x \\<le> z \\<longrightarrow>\n                          l_sort_aux (x # xs, ys @ [z], zs)\n                          \\<in> l_sort_set (x # xs, ys, z # zs))\n 2. \\<And>x xs ys.\n       l_sort_aux (xs, [], ys @ [x])\n       \\<in> l_sort_set (xs, [], ys @ [x]) \\<Longrightarrow>\n       l_sort_aux (xs, [], ys @ [x]) \\<in> l_sort_set (x # xs, ys, [])\n 3. \\<And>ys zs. ([], ys, zs) \\<in> l_sort_set ([], ys, zs)", "oops"], ["", "text \\<open>\n\\null\n\nThese considerations clearly do not depend on the particular function under\nscrutiny, so that postponing the application of conditional simplification rules\nto case distinction turns out to be a generally advisable strategy for the\naccomplishment of step 4.\n\\<close>"], ["", "subsection \"Step 5\""], ["", "text \\<open>\nTwo invariants are defined here below, one for each of the target correctness\ntheorems:\n\n\\null\n\\<close>"], ["", "fun l_sort_inv_1 :: \"'a::linorder l_type \\<Rightarrow> bool\" where\n\"l_sort_inv_1 (x # xs, y # ys, z # zs) =\n  (l_sorted (y # ys) \\<and> l_sorted (z # zs) \\<and>\n  last (y # ys) \\<le> x \\<and> last (y # ys) \\<le> z)\" |\n\"l_sort_inv_1 (x # xs, y # ys, []) =\n  (l_sorted (y # ys) \\<and> last (y # ys) \\<le> x)\" |\n\"l_sort_inv_1 (_, _, zs) =\n  l_sorted zs\""], ["", "definition l_sort_inv_2 :: \"'a \\<Rightarrow> 'a list \\<Rightarrow> 'a l_type \\<Rightarrow> bool\" where\n\"l_sort_inv_2 x xs X \\<equiv> (fst X = [] \\<longrightarrow> fst (snd X) = []) \\<and>\n  l_count x (fst X) + l_count x (fst (snd X)) + l_count x (snd (snd X)) =\n  l_count x xs\""], ["", "text \\<open>\n\\null\n\nMore precisely, the second invariant, whose type has to match\n\\<open>'a l_type \\<Rightarrow> bool\\<close> according to the method specification, shall be\ncomprised of function \\<open>l_sort_inv_2 x xs\\<close>, where \\<open>x\\<close>, \\<open>xs\\<close>\nare the free variables appearing in the latter target theorem.\n\nBoth of the above definitions are non-recursive; command \\<open>fun\\<close> is used in\nthe former for the sole purpose of taking advantage of pattern matching.\n\\<close>"], ["", "subsection \"Step 6\""], ["", "lemma l_sort_input_1: \"l_sort_inv_1 (xs, [], [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sort_inv_1 (xs, [], [])", "by simp"], ["", "lemma l_sort_input_2: \"l_sort_inv_2 x xs (xs, [], [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sort_inv_2 x xs (xs, [], [])", "by (simp add: l_sort_inv_2_def l_count_def)"], ["", "subsection \"Step 7\""], ["", "definition l_sort_form :: \"'a l_type \\<Rightarrow> bool\" where\n\"l_sort_form X \\<equiv> fst X = []\""], ["", "lemma l_sort_intro_1:\n \"l_sort_inv_1 X \\<Longrightarrow> l_sorted (l_sort_out X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sort_inv_1 X \\<Longrightarrow> l_sorted (l_sort_out X)", "by (rule l_sort_inv_1.cases [of X], simp_all add: l_sort_out_def)"], ["", "lemma l_sort_intro_2:\n \"\\<lbrakk>l_sort_inv_2 x xs X; l_sort_form X\\<rbrakk> \\<Longrightarrow>\n  l_count x (l_sort_out X) = l_count x xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l_sort_inv_2 x xs X; l_sort_form X\\<rbrakk>\n    \\<Longrightarrow> l_count x (l_sort_out X) = l_count x xs", "by (simp add: l_sort_inv_2_def, (erule conjE)+,\n simp add: l_sort_form_def l_sort_out_def l_count_def)"], ["", "subsection \"Step 8\""], ["", "lemma l_sort_form_aux_all: \"l_sort_form (l_sort_aux X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sort_form (l_sort_aux X)", "by (rule l_sort_aux.induct [of \"\\<lambda>X. l_sort_form (l_sort_aux X)\"],\n simp_all add: l_sort_form_def)"], ["", "lemma l_sort_form_aux: \"l_sort_form (l_sort_aux (xs, [], []))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sort_form (l_sort_aux (xs, [], []))", "by (rule l_sort_form_aux_all)"], ["", "subsection \"Step 9\""], ["", "text \\<open>\nThe proof of the first invariance property requires the following lemma, stating\nthat in case two lists are sorted, their concatenation still is such as long as\nthe last item of the former is not greater than the first one of the latter.\n\n\\null\n\\<close>"], ["", "lemma l_sorted_app [rule_format]:\n \"l_sorted xs \\<longrightarrow> l_sorted ys \\<longrightarrow> last xs \\<le> hd ys \\<longrightarrow> l_sorted (xs @ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sorted xs \\<longrightarrow>\n    l_sorted ys \\<longrightarrow>\n    last xs \\<le> hd ys \\<longrightarrow> l_sorted (xs @ ys)", "proof (induction xs rule: l_sorted.induct, simp_all, (rule impI)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>l_sorted ys; v \\<le> hd ys\\<rbrakk>\n       \\<Longrightarrow> l_sorted (v # ys)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>l_sorted ys; v \\<le> hd ys\\<rbrakk>\n       \\<Longrightarrow> l_sorted (v # ys)", "assume \"l_sorted ys\" and \"x \\<le> hd ys\""], ["proof (state)\nthis:\n  l_sorted ys\n  x \\<le> hd ys\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>l_sorted ys; v \\<le> hd ys\\<rbrakk>\n       \\<Longrightarrow> l_sorted (v # ys)", "thus \"l_sorted (x # ys)\""], ["proof (prove)\nusing this:\n  l_sorted ys\n  x \\<le> hd ys\n\ngoal (1 subgoal):\n 1. l_sorted (x # ys)", "by (cases ys, simp_all)"], ["proof (state)\nthis:\n  l_sorted (x # ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma l_sort_invariance_1:\n  assumes XY: \"Y \\<in> l_sort_set X\" and X: \"l_sort_inv_1 X\"\n  shows \"l_sort_inv_1 Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sort_inv_1 Y", "using XY"], ["proof (prove)\nusing this:\n  Y \\<in> l_sort_set X\n\ngoal (1 subgoal):\n 1. l_sort_inv_1 Y", "proof (rule l_sort_set.induct, simp_all)"], ["proof (state)\ngoal (4 subgoals):\n 1. Y \\<in> l_sort_set X \\<Longrightarrow> l_sort_inv_1 X\n 2. \\<And>x xs ys.\n       \\<lbrakk>(x # xs, ys, []) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, []); Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sorted (ys @ [x])\n 3. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, z # zs); x \\<le> z;\n        Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sorted (ys @ x # z # zs)\n 4. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, z # zs); \\<not> x \\<le> z;\n        Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "show \"l_sort_inv_1 X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sort_inv_1 X", "using X"], ["proof (prove)\nusing this:\n  l_sort_inv_1 X\n\ngoal (1 subgoal):\n 1. l_sort_inv_1 X", "."], ["proof (state)\nthis:\n  l_sort_inv_1 X\n\ngoal (3 subgoals):\n 1. \\<And>x xs ys.\n       \\<lbrakk>(x # xs, ys, []) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, []); Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sorted (ys @ [x])\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, z # zs); x \\<le> z;\n        Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sorted (ys @ x # z # zs)\n 3. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, z # zs); \\<not> x \\<le> z;\n        Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xs ys.\n       \\<lbrakk>(x # xs, ys, []) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, []); Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sorted (ys @ [x])\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, z # zs); x \\<le> z;\n        Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sorted (ys @ x # z # zs)\n 3. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, z # zs); \\<not> x \\<le> z;\n        Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "fix x :: 'a and xs ys"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xs ys.\n       \\<lbrakk>(x # xs, ys, []) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, []); Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sorted (ys @ [x])\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, z # zs); x \\<le> z;\n        Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sorted (ys @ x # z # zs)\n 3. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, z # zs); \\<not> x \\<le> z;\n        Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "assume I: \"l_sort_inv_1 (x # xs, ys, [])\""], ["proof (state)\nthis:\n  l_sort_inv_1 (x # xs, ys, [])\n\ngoal (3 subgoals):\n 1. \\<And>x xs ys.\n       \\<lbrakk>(x # xs, ys, []) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, []); Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sorted (ys @ [x])\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, z # zs); x \\<le> z;\n        Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sorted (ys @ x # z # zs)\n 3. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, z # zs); \\<not> x \\<le> z;\n        Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "show \"l_sorted (ys @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sorted (ys @ [x])", "proof (cases ys, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. ys = a # list \\<Longrightarrow> l_sorted (ys @ [x])", "fix a as"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. ys = a # list \\<Longrightarrow> l_sorted (ys @ [x])", "assume \"ys = a # as\""], ["proof (state)\nthis:\n  ys = a # as\n\ngoal (1 subgoal):\n 1. \\<And>a list. ys = a # list \\<Longrightarrow> l_sorted (ys @ [x])", "hence \"l_sorted ys \\<and> last ys \\<le> x\""], ["proof (prove)\nusing this:\n  ys = a # as\n\ngoal (1 subgoal):\n 1. l_sorted ys \\<and> last ys \\<le> x", "using I"], ["proof (prove)\nusing this:\n  ys = a # as\n  l_sort_inv_1 (x # xs, ys, [])\n\ngoal (1 subgoal):\n 1. l_sorted ys \\<and> last ys \\<le> x", "by simp"], ["proof (state)\nthis:\n  l_sorted ys \\<and> last ys \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>a list. ys = a # list \\<Longrightarrow> l_sorted (ys @ [x])", "moreover"], ["proof (state)\nthis:\n  l_sorted ys \\<and> last ys \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>a list. ys = a # list \\<Longrightarrow> l_sorted (ys @ [x])", "have \"l_sorted [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sorted [x]", "by simp"], ["proof (state)\nthis:\n  l_sorted [x]\n\ngoal (1 subgoal):\n 1. \\<And>a list. ys = a # list \\<Longrightarrow> l_sorted (ys @ [x])", "ultimately"], ["proof (chain)\npicking this:\n  l_sorted ys \\<and> last ys \\<le> x\n  l_sorted [x]", "show ?thesis"], ["proof (prove)\nusing this:\n  l_sorted ys \\<and> last ys \\<le> x\n  l_sorted [x]\n\ngoal (1 subgoal):\n 1. l_sorted (ys @ [x])", "by (simp add: l_sorted_app)"], ["proof (state)\nthis:\n  l_sorted (ys @ [x])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l_sorted (ys @ [x])\n\ngoal (2 subgoals):\n 1. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, z # zs); x \\<le> z;\n        Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sorted (ys @ x # z # zs)\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, z # zs); \\<not> x \\<le> z;\n        Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, z # zs); x \\<le> z;\n        Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sorted (ys @ x # z # zs)\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, z # zs); \\<not> x \\<le> z;\n        Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "fix x :: 'a and xs ys z zs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, z # zs); x \\<le> z;\n        Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sorted (ys @ x # z # zs)\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, z # zs); \\<not> x \\<le> z;\n        Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "assume XZ: \"x \\<le> z\" and I: \"l_sort_inv_1 (x # xs, ys, z # zs)\""], ["proof (state)\nthis:\n  x \\<le> z\n  l_sort_inv_1 (x # xs, ys, z # zs)\n\ngoal (2 subgoals):\n 1. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, z # zs); x \\<le> z;\n        Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sorted (ys @ x # z # zs)\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, z # zs); \\<not> x \\<le> z;\n        Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "thus \"l_sorted (ys @ x # z # zs)\""], ["proof (prove)\nusing this:\n  x \\<le> z\n  l_sort_inv_1 (x # xs, ys, z # zs)\n\ngoal (1 subgoal):\n 1. l_sorted (ys @ x # z # zs)", "proof (cases ys, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>x \\<le> z; l_sort_inv_1 (x # xs, ys, z # zs);\n        ys = a # list\\<rbrakk>\n       \\<Longrightarrow> l_sorted (ys @ x # z # zs)", "fix a as"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>x \\<le> z; l_sort_inv_1 (x # xs, ys, z # zs);\n        ys = a # list\\<rbrakk>\n       \\<Longrightarrow> l_sorted (ys @ x # z # zs)", "assume \"ys = a # as\""], ["proof (state)\nthis:\n  ys = a # as\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>x \\<le> z; l_sort_inv_1 (x # xs, ys, z # zs);\n        ys = a # list\\<rbrakk>\n       \\<Longrightarrow> l_sorted (ys @ x # z # zs)", "hence *: \"l_sorted ys \\<and> l_sorted (z # zs) \\<and> last ys \\<le> x\""], ["proof (prove)\nusing this:\n  ys = a # as\n\ngoal (1 subgoal):\n 1. l_sorted ys \\<and> l_sorted (z # zs) \\<and> last ys \\<le> x", "using I"], ["proof (prove)\nusing this:\n  ys = a # as\n  l_sort_inv_1 (x # xs, ys, z # zs)\n\ngoal (1 subgoal):\n 1. l_sorted ys \\<and> l_sorted (z # zs) \\<and> last ys \\<le> x", "by simp"], ["proof (state)\nthis:\n  l_sorted ys \\<and> l_sorted (z # zs) \\<and> last ys \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>x \\<le> z; l_sort_inv_1 (x # xs, ys, z # zs);\n        ys = a # list\\<rbrakk>\n       \\<Longrightarrow> l_sorted (ys @ x # z # zs)", "with XZ"], ["proof (chain)\npicking this:\n  x \\<le> z\n  l_sorted ys \\<and> l_sorted (z # zs) \\<and> last ys \\<le> x", "have \"l_sorted (x # z # zs)\""], ["proof (prove)\nusing this:\n  x \\<le> z\n  l_sorted ys \\<and> l_sorted (z # zs) \\<and> last ys \\<le> x\n\ngoal (1 subgoal):\n 1. l_sorted (x # z # zs)", "by simp"], ["proof (state)\nthis:\n  l_sorted (x # z # zs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>x \\<le> z; l_sort_inv_1 (x # xs, ys, z # zs);\n        ys = a # list\\<rbrakk>\n       \\<Longrightarrow> l_sorted (ys @ x # z # zs)", "with *"], ["proof (chain)\npicking this:\n  l_sorted ys \\<and> l_sorted (z # zs) \\<and> last ys \\<le> x\n  l_sorted (x # z # zs)", "show ?thesis"], ["proof (prove)\nusing this:\n  l_sorted ys \\<and> l_sorted (z # zs) \\<and> last ys \\<le> x\n  l_sorted (x # z # zs)\n\ngoal (1 subgoal):\n 1. l_sorted (ys @ x # z # zs)", "by (simp add: l_sorted_app)"], ["proof (state)\nthis:\n  l_sorted (ys @ x # z # zs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l_sorted (ys @ x # z # zs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, z # zs); \\<not> x \\<le> z;\n        Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, z # zs); \\<not> x \\<le> z;\n        Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "fix x :: 'a and xs ys z zs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, z # zs); \\<not> x \\<le> z;\n        Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "assume \"\\<not> x \\<le> z\""], ["proof (state)\nthis:\n  \\<not> x \\<le> z\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, z # zs); \\<not> x \\<le> z;\n        Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "hence XZ: \"z \\<le> x\""], ["proof (prove)\nusing this:\n  \\<not> x \\<le> z\n\ngoal (1 subgoal):\n 1. z \\<le> x", "by simp"], ["proof (state)\nthis:\n  z \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, z # zs); \\<not> x \\<le> z;\n        Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "assume \"l_sort_inv_1 (x # xs, ys, z # zs)\""], ["proof (state)\nthis:\n  l_sort_inv_1 (x # xs, ys, z # zs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_1 (x # xs, ys, z # zs); \\<not> x \\<le> z;\n        Y \\<in> l_sort_set X\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "thus \"l_sort_inv_1 (x # xs, ys @ [z], zs)\""], ["proof (prove)\nusing this:\n  l_sort_inv_1 (x # xs, ys, z # zs)\n\ngoal (1 subgoal):\n 1. l_sort_inv_1 (x # xs, ys @ [z], zs)", "proof (cases ys, simp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>l_sorted (z # zs); ys = []\\<rbrakk>\n    \\<Longrightarrow> l_sort_inv_1 (x # xs, [z], zs)\n 2. \\<And>a list.\n       \\<lbrakk>l_sort_inv_1 (x # xs, ys, z # zs); ys = a # list\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "assume I: \"l_sorted (z # zs)\""], ["proof (state)\nthis:\n  l_sorted (z # zs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>l_sorted (z # zs); ys = []\\<rbrakk>\n    \\<Longrightarrow> l_sort_inv_1 (x # xs, [z], zs)\n 2. \\<And>a list.\n       \\<lbrakk>l_sort_inv_1 (x # xs, ys, z # zs); ys = a # list\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "show \"l_sort_inv_1 (x # xs, [z], zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sort_inv_1 (x # xs, [z], zs)", "proof (cases zs, simp)"], ["proof (state)\ngoal (2 subgoals):\n 1. zs = [] \\<Longrightarrow> z \\<le> x\n 2. \\<And>a list.\n       zs = a # list \\<Longrightarrow> l_sort_inv_1 (x # xs, [z], zs)", "show \"z \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<le> x", "using XZ"], ["proof (prove)\nusing this:\n  z \\<le> x\n\ngoal (1 subgoal):\n 1. z \\<le> x", "."], ["proof (state)\nthis:\n  z \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       zs = a # list \\<Longrightarrow> l_sort_inv_1 (x # xs, [z], zs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       zs = a # list \\<Longrightarrow> l_sort_inv_1 (x # xs, [z], zs)", "fix a as"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       zs = a # list \\<Longrightarrow> l_sort_inv_1 (x # xs, [z], zs)", "assume zs: \"zs = a # as\""], ["proof (state)\nthis:\n  zs = a # as\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       zs = a # list \\<Longrightarrow> l_sort_inv_1 (x # xs, [z], zs)", "then"], ["proof (chain)\npicking this:\n  zs = a # as", "have *: \"z \\<le> a \\<and> l_sorted zs\""], ["proof (prove)\nusing this:\n  zs = a # as\n\ngoal (1 subgoal):\n 1. z \\<le> a \\<and> l_sorted zs", "using I"], ["proof (prove)\nusing this:\n  zs = a # as\n  l_sorted (z # zs)\n\ngoal (1 subgoal):\n 1. z \\<le> a \\<and> l_sorted zs", "by simp"], ["proof (state)\nthis:\n  z \\<le> a \\<and> l_sorted zs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       zs = a # list \\<Longrightarrow> l_sort_inv_1 (x # xs, [z], zs)", "have \"l_sorted [z]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sorted [z]", "by simp"], ["proof (state)\nthis:\n  l_sorted [z]\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       zs = a # list \\<Longrightarrow> l_sort_inv_1 (x # xs, [z], zs)", "with zs *"], ["proof (chain)\npicking this:\n  zs = a # as\n  z \\<le> a \\<and> l_sorted zs\n  l_sorted [z]", "show ?thesis"], ["proof (prove)\nusing this:\n  zs = a # as\n  z \\<le> a \\<and> l_sorted zs\n  l_sorted [z]\n\ngoal (1 subgoal):\n 1. l_sort_inv_1 (x # xs, [z], zs)", "using XZ"], ["proof (prove)\nusing this:\n  zs = a # as\n  z \\<le> a \\<and> l_sorted zs\n  l_sorted [z]\n  z \\<le> x\n\ngoal (1 subgoal):\n 1. l_sort_inv_1 (x # xs, [z], zs)", "by simp"], ["proof (state)\nthis:\n  l_sort_inv_1 (x # xs, [z], zs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l_sort_inv_1 (x # xs, [z], zs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>l_sort_inv_1 (x # xs, ys, z # zs); ys = a # list\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>l_sort_inv_1 (x # xs, ys, z # zs); ys = a # list\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "fix a as"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>l_sort_inv_1 (x # xs, ys, z # zs); ys = a # list\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "assume YS: \"ys = a # as\" and \"l_sort_inv_1 (x # xs, ys, z # zs)\""], ["proof (state)\nthis:\n  ys = a # as\n  l_sort_inv_1 (x # xs, ys, z # zs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>l_sort_inv_1 (x # xs, ys, z # zs); ys = a # list\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "hence I: \"l_sorted ys \\<and> l_sorted (z # zs) \\<and> last ys \\<le> z\""], ["proof (prove)\nusing this:\n  ys = a # as\n  l_sort_inv_1 (x # xs, ys, z # zs)\n\ngoal (1 subgoal):\n 1. l_sorted ys \\<and> l_sorted (z # zs) \\<and> last ys \\<le> z", "by simp"], ["proof (state)\nthis:\n  l_sorted ys \\<and> l_sorted (z # zs) \\<and> last ys \\<le> z\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>l_sort_inv_1 (x # xs, ys, z # zs); ys = a # list\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "have \"l_sorted [z]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sorted [z]", "by simp"], ["proof (state)\nthis:\n  l_sorted [z]\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>l_sort_inv_1 (x # xs, ys, z # zs); ys = a # list\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "hence I': \"l_sorted (ys @ [z])\""], ["proof (prove)\nusing this:\n  l_sorted [z]\n\ngoal (1 subgoal):\n 1. l_sorted (ys @ [z])", "using I"], ["proof (prove)\nusing this:\n  l_sorted [z]\n  l_sorted ys \\<and> l_sorted (z # zs) \\<and> last ys \\<le> z\n\ngoal (1 subgoal):\n 1. l_sorted (ys @ [z])", "by (simp add: l_sorted_app)"], ["proof (state)\nthis:\n  l_sorted (ys @ [z])\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>l_sort_inv_1 (x # xs, ys, z # zs); ys = a # list\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sort_inv_1 (x # xs, ys @ [z], zs)", "proof (cases zs, simp)"], ["proof (state)\ngoal (2 subgoals):\n 1. zs = [] \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], [])\n 2. \\<And>a list.\n       zs = a # list \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "show \"l_sort_inv_1 (x # xs, ys @ [z], [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sort_inv_1 (x # xs, ys @ [z], [])", "using I' and XZ and YS"], ["proof (prove)\nusing this:\n  l_sorted (ys @ [z])\n  z \\<le> x\n  ys = a # as\n\ngoal (1 subgoal):\n 1. l_sort_inv_1 (x # xs, ys @ [z], [])", "by simp"], ["proof (state)\nthis:\n  l_sort_inv_1 (x # xs, ys @ [z], [])\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       zs = a # list \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       zs = a # list \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "fix b bs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       zs = a # list \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "assume zs: \"zs = b # bs\""], ["proof (state)\nthis:\n  zs = b # bs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       zs = a # list \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "then"], ["proof (chain)\npicking this:\n  zs = b # bs", "have \"z \\<le> b \\<and> l_sorted zs\""], ["proof (prove)\nusing this:\n  zs = b # bs\n\ngoal (1 subgoal):\n 1. z \\<le> b \\<and> l_sorted zs", "using I"], ["proof (prove)\nusing this:\n  zs = b # bs\n  l_sorted ys \\<and> l_sorted (z # zs) \\<and> last ys \\<le> z\n\ngoal (1 subgoal):\n 1. z \\<le> b \\<and> l_sorted zs", "by simp"], ["proof (state)\nthis:\n  z \\<le> b \\<and> l_sorted zs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       zs = a # list \\<Longrightarrow> l_sort_inv_1 (x # xs, ys @ [z], zs)", "with zs"], ["proof (chain)\npicking this:\n  zs = b # bs\n  z \\<le> b \\<and> l_sorted zs", "show ?thesis"], ["proof (prove)\nusing this:\n  zs = b # bs\n  z \\<le> b \\<and> l_sorted zs\n\ngoal (1 subgoal):\n 1. l_sort_inv_1 (x # xs, ys @ [z], zs)", "using I and I' and XZ and YS"], ["proof (prove)\nusing this:\n  zs = b # bs\n  z \\<le> b \\<and> l_sorted zs\n  l_sorted ys \\<and> l_sorted (z # zs) \\<and> last ys \\<le> z\n  l_sorted (ys @ [z])\n  z \\<le> x\n  ys = a # as\n\ngoal (1 subgoal):\n 1. l_sort_inv_1 (x # xs, ys @ [z], zs)", "by simp"], ["proof (state)\nthis:\n  l_sort_inv_1 (x # xs, ys @ [z], zs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l_sort_inv_1 (x # xs, ys @ [z], zs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l_sort_inv_1 (x # xs, ys @ [z], zs)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n\\null\n\nLikewise, the proof of the second invariance property calls for the following\nlemmas, stating that the number of occurrences of a value in a list is\nadditive with respect to both item prepending and list concatenation.\n\n\\null\n\\<close>"], ["", "lemma l_count_cons: \"l_count x (y # ys) = l_count x [y] + l_count x ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_count x (y # ys) = l_count x [y] + l_count x ys", "by (simp add: l_count_def)"], ["", "lemma l_count_app: \"l_count x (ys @ zs) = l_count x ys + l_count x zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_count x (ys @ zs) = l_count x ys + l_count x zs", "by (simp add: l_count_def)"], ["", "lemma l_sort_invariance_2:\n  assumes XY: \"Y \\<in> l_sort_set X\" and X: \"l_sort_inv_2 w ws X\"\n  shows \"l_sort_inv_2 w ws Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sort_inv_2 w ws Y", "using XY"], ["proof (prove)\nusing this:\n  Y \\<in> l_sort_set X\n\ngoal (1 subgoal):\n 1. l_sort_inv_2 w ws Y", "proof (rule l_sort_set.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. l_sort_inv_2 w ws X\n 2. \\<And>x xs ys.\n       \\<lbrakk>(x # xs, ys, []) \\<in> l_sort_set X;\n        l_sort_inv_2 w ws (x # xs, ys, [])\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_2 w ws (xs, [], ys @ [x])\n 3. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_2 w ws (x # xs, ys, z # zs); x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_2 w ws (xs, [], ys @ x # z # zs)\n 4. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_2 w ws (x # xs, ys, z # zs); \\<not> x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_2 w ws (x # xs, ys @ [z], zs)", "show \"l_sort_inv_2 w ws X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sort_inv_2 w ws X", "using X"], ["proof (prove)\nusing this:\n  l_sort_inv_2 w ws X\n\ngoal (1 subgoal):\n 1. l_sort_inv_2 w ws X", "."], ["proof (state)\nthis:\n  l_sort_inv_2 w ws X\n\ngoal (3 subgoals):\n 1. \\<And>x xs ys.\n       \\<lbrakk>(x # xs, ys, []) \\<in> l_sort_set X;\n        l_sort_inv_2 w ws (x # xs, ys, [])\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_2 w ws (xs, [], ys @ [x])\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_2 w ws (x # xs, ys, z # zs); x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_2 w ws (xs, [], ys @ x # z # zs)\n 3. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_2 w ws (x # xs, ys, z # zs); \\<not> x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_2 w ws (x # xs, ys @ [z], zs)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xs ys.\n       \\<lbrakk>(x # xs, ys, []) \\<in> l_sort_set X;\n        l_sort_inv_2 w ws (x # xs, ys, [])\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_2 w ws (xs, [], ys @ [x])\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_2 w ws (x # xs, ys, z # zs); x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_2 w ws (xs, [], ys @ x # z # zs)\n 3. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_2 w ws (x # xs, ys, z # zs); \\<not> x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_2 w ws (x # xs, ys @ [z], zs)", "fix x xs ys"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xs ys.\n       \\<lbrakk>(x # xs, ys, []) \\<in> l_sort_set X;\n        l_sort_inv_2 w ws (x # xs, ys, [])\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_2 w ws (xs, [], ys @ [x])\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_2 w ws (x # xs, ys, z # zs); x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_2 w ws (xs, [], ys @ x # z # zs)\n 3. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_2 w ws (x # xs, ys, z # zs); \\<not> x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_2 w ws (x # xs, ys @ [z], zs)", "assume \"l_sort_inv_2 w ws (x # xs, ys, [])\""], ["proof (state)\nthis:\n  l_sort_inv_2 w ws (x # xs, ys, [])\n\ngoal (3 subgoals):\n 1. \\<And>x xs ys.\n       \\<lbrakk>(x # xs, ys, []) \\<in> l_sort_set X;\n        l_sort_inv_2 w ws (x # xs, ys, [])\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_2 w ws (xs, [], ys @ [x])\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_2 w ws (x # xs, ys, z # zs); x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_2 w ws (xs, [], ys @ x # z # zs)\n 3. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_2 w ws (x # xs, ys, z # zs); \\<not> x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_2 w ws (x # xs, ys @ [z], zs)", "thus \"l_sort_inv_2 w ws (xs, [], ys @ [x])\""], ["proof (prove)\nusing this:\n  l_sort_inv_2 w ws (x # xs, ys, [])\n\ngoal (1 subgoal):\n 1. l_sort_inv_2 w ws (xs, [], ys @ [x])", "proof (simp add: l_sort_inv_2_def, subst (asm) l_count_cons, subst l_count_app)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>l_count w [x] + l_count w xs + l_count w ys + l_count w [] =\n             l_count w ws;\n     l_sort_inv_2 w ws (x # xs, ys, []);\n     l_sort_inv_2 w ws (x # xs, ys, [])\\<rbrakk>\n    \\<Longrightarrow> l_count w xs + l_count w [] +\n                      (l_count w ys + l_count w [x]) =\n                      l_count w ws", "qed (simp add: l_count_def ac_simps)"], ["proof (state)\nthis:\n  l_sort_inv_2 w ws (xs, [], ys @ [x])\n\ngoal (2 subgoals):\n 1. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_2 w ws (x # xs, ys, z # zs); x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_2 w ws (xs, [], ys @ x # z # zs)\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_2 w ws (x # xs, ys, z # zs); \\<not> x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_2 w ws (x # xs, ys @ [z], zs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_2 w ws (x # xs, ys, z # zs); x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_2 w ws (xs, [], ys @ x # z # zs)\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_2 w ws (x # xs, ys, z # zs); \\<not> x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_2 w ws (x # xs, ys @ [z], zs)", "fix x xs ys z zs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_2 w ws (x # xs, ys, z # zs); x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_2 w ws (xs, [], ys @ x # z # zs)\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_2 w ws (x # xs, ys, z # zs); \\<not> x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_2 w ws (x # xs, ys @ [z], zs)", "assume \"l_sort_inv_2 w ws (x # xs, ys, z # zs)\""], ["proof (state)\nthis:\n  l_sort_inv_2 w ws (x # xs, ys, z # zs)\n\ngoal (2 subgoals):\n 1. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_2 w ws (x # xs, ys, z # zs); x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_2 w ws (xs, [], ys @ x # z # zs)\n 2. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_2 w ws (x # xs, ys, z # zs); \\<not> x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_2 w ws (x # xs, ys @ [z], zs)", "thus \"l_sort_inv_2 w ws (xs, [], ys @ x # z # zs)\""], ["proof (prove)\nusing this:\n  l_sort_inv_2 w ws (x # xs, ys, z # zs)\n\ngoal (1 subgoal):\n 1. l_sort_inv_2 w ws (xs, [], ys @ x # z # zs)", "proof (simp add: l_sort_inv_2_def, subst (asm) l_count_cons, subst l_count_app,\n   subst l_count_cons)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>l_count w [x] + l_count w xs + l_count w ys +\n             l_count w (z # zs) =\n             l_count w ws;\n     l_sort_inv_2 w ws (x # xs, ys, z # zs);\n     l_sort_inv_2 w ws (x # xs, ys, z # zs);\n     l_sort_inv_2 w ws (x # xs, ys, z # zs)\\<rbrakk>\n    \\<Longrightarrow> l_count w xs + l_count w [] +\n                      (l_count w ys +\n                       (l_count w [x] + l_count w (z # zs))) =\n                      l_count w ws", "qed (simp add: l_count_def ac_simps)"], ["proof (state)\nthis:\n  l_sort_inv_2 w ws (xs, [], ys @ x # z # zs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_2 w ws (x # xs, ys, z # zs); \\<not> x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_2 w ws (x # xs, ys @ [z], zs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_2 w ws (x # xs, ys, z # zs); \\<not> x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_2 w ws (x # xs, ys @ [z], zs)", "fix x xs ys z zs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_2 w ws (x # xs, ys, z # zs); \\<not> x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_2 w ws (x # xs, ys @ [z], zs)", "assume \"l_sort_inv_2 w ws (x # xs, ys, z # zs)\""], ["proof (state)\nthis:\n  l_sort_inv_2 w ws (x # xs, ys, z # zs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys z zs.\n       \\<lbrakk>(x # xs, ys, z # zs) \\<in> l_sort_set X;\n        l_sort_inv_2 w ws (x # xs, ys, z # zs); \\<not> x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> l_sort_inv_2 w ws (x # xs, ys @ [z], zs)", "thus \"l_sort_inv_2 w ws (x # xs, ys @ [z], zs)\""], ["proof (prove)\nusing this:\n  l_sort_inv_2 w ws (x # xs, ys, z # zs)\n\ngoal (1 subgoal):\n 1. l_sort_inv_2 w ws (x # xs, ys @ [z], zs)", "proof (simp add: l_sort_inv_2_def, subst (asm) (2) l_count_cons,\n   subst l_count_app)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>l_count w (x # xs) + l_count w ys +\n             (l_count w [z] + l_count w zs) =\n             l_count w ws;\n     l_sort_inv_2 w ws (x # xs, ys, z # zs);\n     l_sort_inv_2 w ws (x # xs, ys, z # zs)\\<rbrakk>\n    \\<Longrightarrow> l_count w (x # xs) + (l_count w ys + l_count w [z]) +\n                      l_count w zs =\n                      l_count w ws", "qed (simp add: l_count_def ac_simps)"], ["proof (state)\nthis:\n  l_sort_inv_2 w ws (x # xs, ys @ [z], zs)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Step 10\""], ["", "theorem \"l_sorted (l_sort xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sorted (l_sort xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. l_sorted (l_sort xs)", "let ?X = \"(xs, [], [])\""], ["proof (state)\ngoal (1 subgoal):\n 1. l_sorted (l_sort xs)", "have \"l_sort_aux ?X \\<in> l_sort_set ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sort_aux (xs, [], []) \\<in> l_sort_set (xs, [], [])", "by (rule l_sort_aux_set)"], ["proof (state)\nthis:\n  l_sort_aux (xs, [], []) \\<in> l_sort_set (xs, [], [])\n\ngoal (1 subgoal):\n 1. l_sorted (l_sort xs)", "moreover"], ["proof (state)\nthis:\n  l_sort_aux (xs, [], []) \\<in> l_sort_set (xs, [], [])\n\ngoal (1 subgoal):\n 1. l_sorted (l_sort xs)", "have \"l_sort_inv_1 ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sort_inv_1 (xs, [], [])", "by (rule l_sort_input_1)"], ["proof (state)\nthis:\n  l_sort_inv_1 (xs, [], [])\n\ngoal (1 subgoal):\n 1. l_sorted (l_sort xs)", "ultimately"], ["proof (chain)\npicking this:\n  l_sort_aux (xs, [], []) \\<in> l_sort_set (xs, [], [])\n  l_sort_inv_1 (xs, [], [])", "have \"l_sort_inv_1 (l_sort_aux ?X)\""], ["proof (prove)\nusing this:\n  l_sort_aux (xs, [], []) \\<in> l_sort_set (xs, [], [])\n  l_sort_inv_1 (xs, [], [])\n\ngoal (1 subgoal):\n 1. l_sort_inv_1 (l_sort_aux (xs, [], []))", "by (rule l_sort_invariance_1)"], ["proof (state)\nthis:\n  l_sort_inv_1 (l_sort_aux (xs, [], []))\n\ngoal (1 subgoal):\n 1. l_sorted (l_sort xs)", "hence \"l_sorted (l_sort_out (l_sort_aux ?X))\""], ["proof (prove)\nusing this:\n  l_sort_inv_1 (l_sort_aux (xs, [], []))\n\ngoal (1 subgoal):\n 1. l_sorted (l_sort_out (l_sort_aux (xs, [], [])))", "by (rule l_sort_intro_1)"], ["proof (state)\nthis:\n  l_sorted (l_sort_out (l_sort_aux (xs, [], [])))\n\ngoal (1 subgoal):\n 1. l_sorted (l_sort xs)", "moreover"], ["proof (state)\nthis:\n  l_sorted (l_sort_out (l_sort_aux (xs, [], [])))\n\ngoal (1 subgoal):\n 1. l_sorted (l_sort xs)", "have \"?X = l_sort_in xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs, [], []) = l_sort_in xs", "by (simp add: l_sort_in_def)"], ["proof (state)\nthis:\n  (xs, [], []) = l_sort_in xs\n\ngoal (1 subgoal):\n 1. l_sorted (l_sort xs)", "ultimately"], ["proof (chain)\npicking this:\n  l_sorted (l_sort_out (l_sort_aux (xs, [], [])))\n  (xs, [], []) = l_sort_in xs", "show ?thesis"], ["proof (prove)\nusing this:\n  l_sorted (l_sort_out (l_sort_aux (xs, [], [])))\n  (xs, [], []) = l_sort_in xs\n\ngoal (1 subgoal):\n 1. l_sorted (l_sort xs)", "by (simp add: l_sort_def)"], ["proof (state)\nthis:\n  l_sorted (l_sort xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem \"l_count x (l_sort xs) = l_count x xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_count x (l_sort xs) = l_count x xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. l_count x (l_sort xs) = l_count x xs", "let ?X = \"(xs, [], [])\""], ["proof (state)\ngoal (1 subgoal):\n 1. l_count x (l_sort xs) = l_count x xs", "have \"l_sort_aux ?X \\<in> l_sort_set ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sort_aux (xs, [], []) \\<in> l_sort_set (xs, [], [])", "by (rule l_sort_aux_set)"], ["proof (state)\nthis:\n  l_sort_aux (xs, [], []) \\<in> l_sort_set (xs, [], [])\n\ngoal (1 subgoal):\n 1. l_count x (l_sort xs) = l_count x xs", "moreover"], ["proof (state)\nthis:\n  l_sort_aux (xs, [], []) \\<in> l_sort_set (xs, [], [])\n\ngoal (1 subgoal):\n 1. l_count x (l_sort xs) = l_count x xs", "have \"l_sort_inv_2 x xs ?X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sort_inv_2 x xs (xs, [], [])", "by (rule l_sort_input_2)"], ["proof (state)\nthis:\n  l_sort_inv_2 x xs (xs, [], [])\n\ngoal (1 subgoal):\n 1. l_count x (l_sort xs) = l_count x xs", "ultimately"], ["proof (chain)\npicking this:\n  l_sort_aux (xs, [], []) \\<in> l_sort_set (xs, [], [])\n  l_sort_inv_2 x xs (xs, [], [])", "have \"l_sort_inv_2 x xs (l_sort_aux ?X)\""], ["proof (prove)\nusing this:\n  l_sort_aux (xs, [], []) \\<in> l_sort_set (xs, [], [])\n  l_sort_inv_2 x xs (xs, [], [])\n\ngoal (1 subgoal):\n 1. l_sort_inv_2 x xs (l_sort_aux (xs, [], []))", "by (rule l_sort_invariance_2)"], ["proof (state)\nthis:\n  l_sort_inv_2 x xs (l_sort_aux (xs, [], []))\n\ngoal (1 subgoal):\n 1. l_count x (l_sort xs) = l_count x xs", "moreover"], ["proof (state)\nthis:\n  l_sort_inv_2 x xs (l_sort_aux (xs, [], []))\n\ngoal (1 subgoal):\n 1. l_count x (l_sort xs) = l_count x xs", "have \"l_sort_form (l_sort_aux ?X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_sort_form (l_sort_aux (xs, [], []))", "by (rule l_sort_form_aux)"], ["proof (state)\nthis:\n  l_sort_form (l_sort_aux (xs, [], []))\n\ngoal (1 subgoal):\n 1. l_count x (l_sort xs) = l_count x xs", "ultimately"], ["proof (chain)\npicking this:\n  l_sort_inv_2 x xs (l_sort_aux (xs, [], []))\n  l_sort_form (l_sort_aux (xs, [], []))", "have \"l_count x (l_sort_out (l_sort_aux ?X)) = l_count x xs\""], ["proof (prove)\nusing this:\n  l_sort_inv_2 x xs (l_sort_aux (xs, [], []))\n  l_sort_form (l_sort_aux (xs, [], []))\n\ngoal (1 subgoal):\n 1. l_count x (l_sort_out (l_sort_aux (xs, [], []))) = l_count x xs", "by (rule l_sort_intro_2)"], ["proof (state)\nthis:\n  l_count x (l_sort_out (l_sort_aux (xs, [], []))) = l_count x xs\n\ngoal (1 subgoal):\n 1. l_count x (l_sort xs) = l_count x xs", "moreover"], ["proof (state)\nthis:\n  l_count x (l_sort_out (l_sort_aux (xs, [], []))) = l_count x xs\n\ngoal (1 subgoal):\n 1. l_count x (l_sort xs) = l_count x xs", "have \"?X = l_sort_in xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs, [], []) = l_sort_in xs", "by (simp add: l_sort_in_def)"], ["proof (state)\nthis:\n  (xs, [], []) = l_sort_in xs\n\ngoal (1 subgoal):\n 1. l_count x (l_sort xs) = l_count x xs", "ultimately"], ["proof (chain)\npicking this:\n  l_count x (l_sort_out (l_sort_aux (xs, [], []))) = l_count x xs\n  (xs, [], []) = l_sort_in xs", "show ?thesis"], ["proof (prove)\nusing this:\n  l_count x (l_sort_out (l_sort_aux (xs, [], []))) = l_count x xs\n  (xs, [], []) = l_sort_in xs\n\ngoal (1 subgoal):\n 1. l_count x (l_sort xs) = l_count x xs", "by (simp add: l_sort_def)"], ["proof (state)\nthis:\n  l_count x (l_sort xs) = l_count x xs\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}