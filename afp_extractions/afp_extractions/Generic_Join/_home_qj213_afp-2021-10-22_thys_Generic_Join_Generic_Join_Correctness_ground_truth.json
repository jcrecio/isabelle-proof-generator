{"file_name": "/home/qj213/afp-2021-10-22/thys/Generic_Join/Generic_Join_Correctness.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Generic_Join", "problem_names": ["lemma wf_tuple_empty: \"wf_tuple n {} v \\<longleftrightarrow> v = replicate n None\"", "lemma table_empty: \"table n {} X \\<longleftrightarrow> (X = empty_table \\<or> X = unit_table n)\"", "lemma isSame_equi_dev:\n  assumes \"wf_set n V\"\n  assumes \"wf_tuple n A t1\"\n  assumes \"wf_tuple n B t2\"\n  assumes \"s \\<subseteq> A\"\n  assumes \"s \\<subseteq> B\"\n  assumes \"A \\<subseteq> V\"\n  assumes \"B \\<subseteq> V\"\n  shows \"isSameIntersection t1 s t2 = (restrict s t1 = restrict s t2)\"", "lemma wf_getIJ:\n  assumes \"card V \\<ge> 2\"\n  assumes \"wf_set n V\"\n  assumes \"(I, J) = getIJ Q_pos Q_neg V\"\n  shows \"wf_set n I\" and \"wf_set n J\"", "lemma wf_projectTable:\n  assumes \"wf_atable n X\"\n  shows \"wf_atable n (projectTable I X) \\<and> (fst (projectTable I X) = (fst X \\<inter> I))\"", "lemma set_filterQuery:\n  assumes \"QQ = filterQuery I Q\"\n  assumes \"non_empty_query Q\"\n  shows \"\\<forall>X\\<in>Q. (card (fst X \\<inter> I) \\<ge> 1 \\<longleftrightarrow> X \\<in> QQ)\"", "lemma wf_filterQuery:\n  assumes \"I \\<subseteq> V\"\n  assumes \"card I \\<ge> 1\"\n  assumes \"rwf_query n V Qp Qn\"\n  assumes \"QQp = filterQuery I Qp\"\n  assumes \"QQn = filterQueryNeg I Qn\"\n  shows \"wf_query n I QQp QQn\" \"non_empty_query QQp\" \"covering I QQp\"", "lemma wf_set_subset:\n  assumes \"I \\<subseteq> V\"\n  assumes \"card I \\<ge> 1\"\n  assumes \"wf_set n V\"\n  shows \"wf_set n I\"", "lemma wf_projectQuery:\n  assumes \"card I \\<ge> 1\"\n  assumes \"wf_query n I Q Qn\"\n  assumes \"non_empty_query Q\"\n  assumes \"covering I Q\"\n  assumes \"\\<forall>X\\<in>Q. card (fst X \\<inter> I) \\<ge> 1\"\n  assumes \"QQ = projectQuery I Q\"\n  assumes \"included I Qn\"\n  assumes \"non_empty_query Qn\"\n  shows \"rwf_query n I QQ Qn\"", "lemma wf_firstRecursiveCall:\n  assumes \"rwf_query n V Qp Qn\"\n  assumes \"card V \\<ge> 2\"\n  assumes \"(I, J) = getIJ Qp Qn V\"\n  assumes \"Q_I_pos = projectQuery I (filterQuery I Qp)\"\n  assumes \"Q_I_neg = filterQueryNeg I Qn\"\n  shows \"rwf_query n I Q_I_pos Q_I_neg\"", "lemma wf_atable_subset:\n  assumes \"table n V X\"\n  assumes \"Y \\<subseteq> X\"\n  shows \"table n V Y\"", "lemma same_set_semiJoin:\n  \"fst (semiJoin x other) = fst x\"", "lemma wf_semiJoin:\n  assumes \"card J \\<ge> 1\"\n  assumes \"wf_query n J Q Qn\"\n  assumes \"non_empty_query Q\"\n  assumes \"covering J Q\"\n  assumes \"\\<forall>X\\<in>Q. card (fst X \\<inter> J) \\<ge> 1\"\n  assumes \"QQ = (Set.image (\\<lambda>tab. semiJoin tab (st, t)) Q)\"\n  shows \"wf_query n J QQ Qn\" \"non_empty_query QQ\" \"covering J QQ\"", "lemma newQuery_equiv_def:\n  \"newQuery V Q (st, t) = projectQuery V (Set.image (\\<lambda>tab. semiJoin tab (st, t)) Q)\"", "lemma included_project:\n  \"included V (projectQuery V Q)\"", "lemma non_empty_newQuery:\n  assumes \"Q1 = filterQuery J Q0\"\n  assumes \"Q2 = newQuery J Q1 (I, t)\"\n  assumes \"\\<forall>X\\<in>Q0. wf_atable n X\"\n  shows \"non_empty_query Q2\"", "lemma wf_newQuery:\n  assumes \"card J \\<ge> 1\"\n  assumes \"wf_query n J Q Qn0\"\n  assumes \"non_empty_query Q\"\n  assumes \"covering J Q\"\n  assumes \"\\<forall>X\\<in>Q. card (fst X \\<inter> J) \\<ge> 1\"\n  assumes \"QQ = newQuery J Q t\"\n  assumes \"QQn = newQuery J Qn t\"\n  assumes \"non_empty_query Qn\"\n  assumes \"Qn = filterQuery J Qn0\"\n  shows \"rwf_query n J QQ QQn\"", "lemma subset_Q_neg:\n  assumes \"rwf_query n V Q Qn\"\n  assumes \"QQn \\<subseteq> Qn\"\n  shows \"rwf_query n V Q QQn\"", "lemma wf_secondRecursiveCalls:\n  assumes \"card V \\<ge> 2\"\n  assumes \"rwf_query n V Q Qn\"\n  assumes \"(I, J) = getIJ Q Qn V\"\n  assumes \"Qns \\<subseteq> Qn\"\n  assumes \"Q_J_neg = filterQuery J Qns\"\n  assumes \"Q_J_pos = filterQuery J Q\"\n  shows \"rwf_query n J (newQuery J Q_J_pos t) (newQuery J Q_J_neg t)\"", "lemma simple_merge_option:\n  \"merge_option (a, b) = None \\<longleftrightarrow> (a = None \\<and> b = None)\"", "lemma wf_merge:\n  assumes \"wf_tuple n I t1\"\n  assumes \"wf_tuple n J t2\"\n  assumes \"V = I \\<union> J\"\n  assumes \"t = merge t1 t2\"\n  shows \"wf_tuple n V t\"", "lemma wf_inter:\n  assumes \"rwf_query n {i} Q Qn\"\n  assumes \"(sa, a) \\<in> Q\"\n  assumes \"(sb, b) \\<in> Q\"\n  shows \"table n {i} (a \\<inter> b)\"", "lemma table_subset:\n  assumes \"table n V T\"\n  assumes \"S \\<subseteq> T\"\n  shows \"table n V S\"", "lemma wf_base_case:\n  assumes \"card V = 1\"\n  assumes \"rwf_query n V Q Qn\"\n  assumes \"R = genericJoin V Q Qn\"\n  shows \"table n V R\"", "lemma filter_Q_J_neg_same:\n  assumes \"card V \\<ge> 2\"\n  assumes \"(I, J) = getIJ Q Qn V\"\n  assumes \"Q_I_neg = filterQueryNeg I Qn\"\n  assumes \"rwf_query n V Q Qn\"\n  shows \"filterQuery J (Qn - Q_I_neg) = Qn - Q_I_neg\" (is \"?A = ?B\")", "lemma vars_genericJoin:\n  assumes \"card V \\<ge> 2\"\n  assumes \"(I, J) = getIJ Q Qn V\"\n  assumes \"Q_I_pos = projectQuery I (filterQuery I Q)\"\n  assumes \"Q_I_neg = filterQueryNeg I Qn\"\n  assumes \"R_I = genericJoin I Q_I_pos Q_I_neg\"\n  assumes \"Q_J_neg = filterQuery J (Qn - Q_I_neg)\"\n  assumes \"Q_J_pos = filterQuery J Q\"\n  assumes \"X = {(t, genericJoin J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t))) | t . t \\<in> R_I}\"\n  assumes \"R = (\\<Union>(t, x) \\<in> X. {merge xx t | xx . xx \\<in> x})\"\n  assumes \"rwf_query n V Q Qn\"\n  shows \"R = genericJoin V Q Qn\"", "lemma base_genericJoin:\n  assumes \"card V \\<le> 1\"\n  shows \"genericJoin V Q Qn =  (\\<Inter>(_, x) \\<in> Q. x) - (\\<Union>(_, x) \\<in> Qn. x)\"", "lemma wf_genericJoin:\n  \"\\<lbrakk>rwf_query n V Q Qn; card V \\<ge> 1\\<rbrakk> \\<Longrightarrow> table n V (genericJoin V Q Qn)\"", "lemma base_correctness:\n  assumes \"card V = 1\"\n  assumes \"rwf_query n V Q Qn\"\n  assumes \"R = genericJoin V Q Qn\"\n  shows \"z \\<in> genericJoin V Q Qn \\<longleftrightarrow> wf_tuple n V z \\<and> (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\"", "lemma simple_list_index_equality:\n  assumes \"length a = n\"\n  assumes \"length b = n\"\n  assumes \"\\<forall>i < n. a!i = b!i\"\n  shows \"a = b\"", "lemma simple_restrict_none:\n  assumes \"i < length X\"\n  assumes \"i \\<notin> A\"\n  shows \"(restrict A X)!i = None\"", "lemma simple_restrict_some:\n  assumes \"i < length X\"\n  assumes \"i \\<in> A\"\n  shows \"(restrict A X)!i = X!i\"", "lemma merge_restrict:\n  assumes \"A \\<inter> J = {}\"\n  assumes \"A \\<subseteq> I\"\n  assumes \"length xx = n\"\n  assumes \"length t = n\"\n  assumes \"restrict J xx = xx\"\n  shows \"restrict A (merge xx t) = restrict A t\"", "lemma restrict_idle_include:\n  assumes \"wf_tuple n A v\"\n  assumes \"A \\<subseteq> I\"\n  shows \"restrict I v = v\"", "lemma merge_index:\n  assumes \"I \\<inter> J = {}\"\n  assumes \"wf_tuple n I tI\"\n  assumes \"wf_tuple n J tJ\"\n  assumes \"t = merge tI tJ\"\n  assumes \"i < n\"\n  shows \"(i \\<in> I \\<and> t!i = tI!i) \\<or> (i \\<in> J \\<and> t!i = tJ!i) \\<or> (i \\<notin> I \\<and> i \\<notin> J \\<and> t!i = None)\"", "lemma restrict_index_in:\n  assumes \"i < length X\"\n  assumes \"i \\<in> I\"\n  shows \"(restrict I X)!i = X!i\"", "lemma restrict_index_out:\n  assumes \"i < length X\"\n  assumes \"i \\<notin> I\"\n  shows \"(restrict I X)!i = None\"", "lemma merge_length:\n  assumes \"length a = n\"\n  assumes \"length b = n\"\n  shows \"length (merge a b) = n\"", "lemma real_restrict_merge:\n  assumes \"I \\<inter> J = {}\"\n  assumes \"wf_tuple n I tI\"\n  assumes \"wf_tuple n J tJ\"\n  shows \"restrict I (merge tI tJ) = restrict I tI \\<and> restrict J (merge tI tJ) = restrict J tJ\"", "lemma simple_set_image_id:\n  assumes \"\\<forall>x\\<in>X. f x = x\"\n  shows \"Set.image f X = X\"", "lemma nested_include_restrict:\n  assumes \"restrict I z = t\"\n  assumes \"A \\<subseteq> I\"\n  shows \"restrict A z = restrict A t\"", "lemma restrict_nested:\n  \"restrict A (restrict B x) = restrict (A \\<inter> B) x\" (is \"?lhs = ?rhs\")", "lemma newQuery_equi_dev:\n  \"newQuery V Q (I, t) = Set.image (projectTable V) (Set.image (\\<lambda>tab. semiJoin tab (I, t)) Q)\"", "lemma projectTable_idle:\n  assumes \"table n A X\"\n  assumes \"A \\<subseteq> I\"\n  shows \"projectTable I (A, X) = (A, X)\"", "lemma restrict_partition_merge:\n  assumes \"I \\<union> J = V\"\n  assumes \"wf_tuple n V z\"\n  assumes \"xx = restrict J z\"\n  assumes \"t = restrict I z\"\n  assumes \"Set.is_empty (I \\<inter> J)\"\n  shows \"z = merge xx t\"", "lemma restrict_merge:\n  assumes \"zI = restrict I z\"\n  assumes \"zJ = restrict J z\"\n  assumes \"restrict (A \\<inter> I) zI \\<in> Set.image (restrict I) X\"\n  assumes \"restrict (A \\<inter> J) zJ \\<in> Set.image (restrict J) (Set.filter (isSameIntersection zI (A \\<inter> I)) X)\"\n  assumes \"z = merge zJ zI\"\n  assumes \"table n A X\"\n  assumes \"A \\<subseteq> I \\<union> J\"\n  assumes \"card (A \\<inter> I) \\<ge> 1\"\n  assumes \"wf_set n (I \\<union> J)\"\n  assumes \"wf_tuple n (I \\<union> J) z\"\n  shows \"restrict A z \\<in> X\"", "lemma partial_correctness:\n  assumes \"V = I \\<union> J\"\n  assumes \"Set.is_empty (I \\<inter> J)\"\n  assumes \"card I \\<ge> 1\"\n  assumes \"card J \\<ge> 1\"\n  assumes \"Q_I_pos = projectQuery I (filterQuery I Q)\"\n  assumes \"Q_J_pos = filterQuery J Q\"\n  assumes \"Q_I_neg = filterQueryNeg I Qn\"\n  assumes \"Q_J_neg = filterQuery J (Qn - Q_I_neg)\"\n  assumes \"NQ_pos = newQuery J Q_J_pos (I, t)\"\n  assumes \"NQ_neg = newQuery J Q_J_neg (I, t)\"\n  assumes \"R_NQ = genericJoin J NQ_pos NQ_neg\"\n  assumes \"\\<forall>x. (x \\<in> R_I \\<longleftrightarrow> wf_tuple n I x \\<and> (\\<forall>(A, X)\\<in>Q_I_pos. restrict A x \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Q_I_neg. restrict A x \\<notin> X))\"\n  assumes \"\\<forall>y. (y \\<in> R_NQ \\<longleftrightarrow> wf_tuple n J y \\<and> (\\<forall>(A, X)\\<in>NQ_pos. restrict A y \\<in> X) \\<and> (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X))\"\n  assumes \"z = merge xx t\"\n  assumes \"t \\<in> R_I\"\n  assumes \"xx \\<in> R_NQ\"\n  assumes \"rwf_query n V Q Qn\"\n  shows \"wf_tuple n V z \\<and> (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\"", "lemma simple_set_inter:\n  assumes \"I \\<subseteq> (\\<Union>X\\<in>A. f X)\"\n  shows \"I \\<subseteq> (\\<Union>X\\<in>A. (f X) \\<inter> I)\"", "lemma union_restrict:\n  assumes \"restrict I z1 = restrict I z2\"\n  assumes \"restrict J z1 = restrict J z2\"\n  shows \"restrict (I \\<union> J) z1 = restrict (I \\<union> J) z2\"", "lemma partial_correctness_direct:\n  assumes \"V = I \\<union> J\"\n  assumes \"Set.is_empty (I \\<inter> J)\"\n  assumes \"card I \\<ge> 1\"\n  assumes \"card J \\<ge> 1\"\n  assumes \"Q_I_pos = projectQuery I (filterQuery I Q)\"\n  assumes \"Q_J_pos = filterQuery J Q\"\n  assumes \"Q_I_neg = filterQueryNeg I Qn\"\n  assumes \"Q_J_neg = filterQuery J (Qn - Q_I_neg)\"\n  assumes \"R_I = genericJoin I Q_I_pos Q_I_neg\"\n  assumes \"X = {(t, genericJoin J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t))) | t . t \\<in> R_I}\"\n  assumes \"R = (\\<Union>(t, x) \\<in> X. {merge xx t | xx . xx \\<in> x})\"\n  assumes \"R_NQ = genericJoin J NQ_pos NQ_neg\"\n  assumes \"\\<forall>x. (x \\<in> R_I \\<longleftrightarrow> wf_tuple n I x \\<and> (\\<forall>(A, X)\\<in>Q_I_pos. restrict A x \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Q_I_neg. restrict A x \\<notin> X))\"\n  assumes \"\\<forall>t\\<in>R_I. (\\<forall>y. (y \\<in> genericJoin J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t)) \\<longleftrightarrow> wf_tuple n J y \\<and>\n  (\\<forall>(A, X)\\<in>(newQuery J Q_J_pos (I, t)). restrict A y \\<in> X) \\<and> (\\<forall>(A, X)\\<in>(newQuery J Q_J_neg (I, t)). restrict A y \\<notin> X)))\"\n  assumes \"wf_tuple n V z \\<and> (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\"\n  assumes \"rwf_query n V Q Qn\"\n  shows \"z \\<in> R\"", "lemma obvious_forall:\n  assumes \"\\<forall>x\\<in>X. P x\"\n  assumes \"x\\<in>X\"\n  shows \"P x\"", "lemma correctness:\n  \"\\<lbrakk>rwf_query n V Q Qn; card V \\<ge> 1\\<rbrakk> \\<Longrightarrow> (z \\<in> genericJoin V Q Qn \\<longleftrightarrow> wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))\"", "lemma wf_set_finite:\n  assumes \"wf_set n A\"\n  shows \"finite A\"", "lemma vars_wrapperGenericJoin:\n  fixes Q :: \"'a query\" and Q_pos :: \"'a query\" and Q_neg :: \"'a query\"\n  and V :: \"nat set\" and Qn :: \"'a query\"\n  assumes \"Q = Set.filter (\\<lambda>(A, _). \\<not> Set.is_empty A) Q_pos\"\n      and \"V = (\\<Union>(A, X)\\<in>Q. A)\"\n      and \"Qn = Set.filter (\\<lambda>(A, _). A \\<subseteq> V \\<and> card A \\<ge> 1) Q_neg\"\n      and \"\\<not> Set.is_empty Q\"\n      and \"\\<not>((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or> (\\<exists>(A, X)\\<in>Q_neg. Set.is_empty A \\<and> \\<not> Set.is_empty X))\"\n    shows \"wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn\"", "lemma wrapper_correctness:\n  assumes \"card Q_pos \\<ge>1\"\n  assumes \"\\<forall>(A, X)\\<in>(Q_pos \\<union> Q_neg). table n A X \\<and> wf_set n A\"\n  shows \"z \\<in> wrapperGenericJoin Q_pos Q_neg \\<longleftrightarrow> wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and> (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)\""], "translations": [["", "lemma wf_tuple_empty: \"wf_tuple n {} v \\<longleftrightarrow> v = replicate n None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple n {} v = (v = replicate n None)", "by (auto intro!: replicate_eqI simp add: wf_tuple_def in_set_conv_nth)"], ["", "lemma table_empty: \"table n {} X \\<longleftrightarrow> (X = empty_table \\<or> X = unit_table n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. table n {} X = (X = empty_table \\<or> X = unit_table n)", "by (auto simp add: wf_tuple_empty unit_table_def table_def)"], ["", "context getIJ begin"], ["", "lemma isSame_equi_dev:\n  assumes \"wf_set n V\"\n  assumes \"wf_tuple n A t1\"\n  assumes \"wf_tuple n B t2\"\n  assumes \"s \\<subseteq> A\"\n  assumes \"s \\<subseteq> B\"\n  assumes \"A \\<subseteq> V\"\n  assumes \"B \\<subseteq> V\"\n  shows \"isSameIntersection t1 s t2 = (restrict s t1 = restrict s t2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isSameIntersection t1 s t2 = (restrict s t1 = restrict s t2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. isSameIntersection t1 s t2 = (restrict s t1 = restrict s t2)", "have \"(\\<forall>i\\<in>s. t1!i = t2!i) \\<longleftrightarrow> (restrict s t1 = restrict s t2)\" (is \"?A \\<longleftrightarrow> ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i\\<in>s. t1 ! i = t2 ! i) = (restrict s t1 = restrict s t2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>i\\<in>s. t1 ! i = t2 ! i) = (restrict s t1 = restrict s t2)", "have \"?B \\<Longrightarrow> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict s t1 = restrict s t2 \\<Longrightarrow>\n    \\<forall>i\\<in>s. t1 ! i = t2 ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. restrict s t1 = restrict s t2 \\<Longrightarrow>\n    \\<forall>i\\<in>s. t1 ! i = t2 ! i", "assume \"?B\""], ["proof (state)\nthis:\n  restrict s t1 = restrict s t2\n\ngoal (1 subgoal):\n 1. restrict s t1 = restrict s t2 \\<Longrightarrow>\n    \\<forall>i\\<in>s. t1 ! i = t2 ! i", "have \"\\<And>i. i\\<in>s \\<Longrightarrow> t1!i = t2!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> s \\<Longrightarrow> t1 ! i = t2 ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> s \\<Longrightarrow> t1 ! i = t2 ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> s \\<Longrightarrow> t1 ! i = t2 ! i", "assume \"i \\<in> s\""], ["proof (state)\nthis:\n  i \\<in> s\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> s \\<Longrightarrow> t1 ! i = t2 ! i", "then"], ["proof (chain)\npicking this:\n  i \\<in> s", "have \"i \\<in> A\""], ["proof (prove)\nusing this:\n  i \\<in> s\n\ngoal (1 subgoal):\n 1. i \\<in> A", "using assms(4)"], ["proof (prove)\nusing this:\n  i \\<in> s\n  s \\<subseteq> A\n\ngoal (1 subgoal):\n 1. i \\<in> A", "by blast"], ["proof (state)\nthis:\n  i \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> s \\<Longrightarrow> t1 ! i = t2 ! i", "then"], ["proof (chain)\npicking this:\n  i \\<in> A", "have \"i < n\""], ["proof (prove)\nusing this:\n  i \\<in> A\n\ngoal (1 subgoal):\n 1. i < n", "using assms(1) assms(6) wf_set_def"], ["proof (prove)\nusing this:\n  i \\<in> A\n  wf_set n V\n  A \\<subseteq> V\n  wf_set ?n ?V = (\\<forall>x\\<in>?V. x < ?n)\n\ngoal (1 subgoal):\n 1. i < n", "by auto"], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> s \\<Longrightarrow> t1 ! i = t2 ! i", "then"], ["proof (chain)\npicking this:\n  i < n", "show \"t1!i = t2!i\""], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. t1 ! i = t2 ! i", "by (metis (no_types, lifting) \\<open>i \\<in> s\\<close> \\<open>restrict s t1 = restrict s t2\\<close>\n              assms(2) length_restrict nth_restrict wf_tuple_length)"], ["proof (state)\nthis:\n  t1 ! i = t2 ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i \\<in> s \\<Longrightarrow> t1 ! ?i = t2 ! ?i\n\ngoal (1 subgoal):\n 1. restrict s t1 = restrict s t2 \\<Longrightarrow>\n    \\<forall>i\\<in>s. t1 ! i = t2 ! i", "then"], ["proof (chain)\npicking this:\n  ?i \\<in> s \\<Longrightarrow> t1 ! ?i = t2 ! ?i", "show \"?A\""], ["proof (prove)\nusing this:\n  ?i \\<in> s \\<Longrightarrow> t1 ! ?i = t2 ! ?i\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>s. t1 ! i = t2 ! i", "by blast"], ["proof (state)\nthis:\n  \\<forall>i\\<in>s. t1 ! i = t2 ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict s t1 = restrict s t2 \\<Longrightarrow>\n  \\<forall>i\\<in>s. t1 ! i = t2 ! i\n\ngoal (1 subgoal):\n 1. (\\<forall>i\\<in>s. t1 ! i = t2 ! i) = (restrict s t1 = restrict s t2)", "moreover"], ["proof (state)\nthis:\n  restrict s t1 = restrict s t2 \\<Longrightarrow>\n  \\<forall>i\\<in>s. t1 ! i = t2 ! i\n\ngoal (1 subgoal):\n 1. (\\<forall>i\\<in>s. t1 ! i = t2 ! i) = (restrict s t1 = restrict s t2)", "have \"?A \\<Longrightarrow> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>s. t1 ! i = t2 ! i \\<Longrightarrow>\n    restrict s t1 = restrict s t2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>s. t1 ! i = t2 ! i \\<Longrightarrow>\n    restrict s t1 = restrict s t2", "assume \"?A\""], ["proof (state)\nthis:\n  \\<forall>i\\<in>s. t1 ! i = t2 ! i\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>s. t1 ! i = t2 ! i \\<Longrightarrow>\n    restrict s t1 = restrict s t2", "obtain \"length (restrict s t1) = n\" \"length (restrict s t2) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>length (restrict s t1) = n;\n      length (restrict s t2) = n\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2) assms(3) length_restrict wf_tuple_length"], ["proof (prove)\nusing this:\n  wf_tuple n A t1\n  wf_tuple n B t2\n  length (restrict ?A ?v) = length ?v\n  wf_tuple ?n ?V ?x \\<Longrightarrow> length ?x = ?n\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>length (restrict s t1) = n;\n      length (restrict s t2) = n\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  length (restrict s t1) = n\n  length (restrict s t2) = n\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>s. t1 ! i = t2 ! i \\<Longrightarrow>\n    restrict s t1 = restrict s t2", "then"], ["proof (chain)\npicking this:\n  length (restrict s t1) = n\n  length (restrict s t2) = n", "have \"\\<And>i. i < n \\<Longrightarrow> (restrict s t1)!i = (restrict s t2)!i\""], ["proof (prove)\nusing this:\n  length (restrict s t1) = n\n  length (restrict s t2) = n\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> restrict s t1 ! i = restrict s t2 ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < n; length (restrict s t1) = n;\n        length (restrict s t2) = n\\<rbrakk>\n       \\<Longrightarrow> restrict s t1 ! i = restrict s t2 ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < n; length (restrict s t1) = n;\n        length (restrict s t2) = n\\<rbrakk>\n       \\<Longrightarrow> restrict s t1 ! i = restrict s t2 ! i", "assume \"i < n\""], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < n; length (restrict s t1) = n;\n        length (restrict s t2) = n\\<rbrakk>\n       \\<Longrightarrow> restrict s t1 ! i = restrict s t2 ! i", "then"], ["proof (chain)\npicking this:\n  i < n", "show \"(restrict s t1)!i = (restrict s t2)!i\""], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. restrict s t1 ! i = restrict s t2 ! i", "proof (cases \"i \\<in> s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < n; i \\<in> s\\<rbrakk>\n    \\<Longrightarrow> restrict s t1 ! i = restrict s t2 ! i\n 2. \\<lbrakk>i < n; i \\<notin> s\\<rbrakk>\n    \\<Longrightarrow> restrict s t1 ! i = restrict s t2 ! i", "case True"], ["proof (state)\nthis:\n  i \\<in> s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i < n; i \\<in> s\\<rbrakk>\n    \\<Longrightarrow> restrict s t1 ! i = restrict s t2 ! i\n 2. \\<lbrakk>i < n; i \\<notin> s\\<rbrakk>\n    \\<Longrightarrow> restrict s t1 ! i = restrict s t2 ! i", "then"], ["proof (chain)\npicking this:\n  i \\<in> s", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<in> s\n\ngoal (1 subgoal):\n 1. restrict s t1 ! i = restrict s t2 ! i", "by (metis \\<open>\\<forall>i\\<in>s. t1 ! i = t2 ! i\\<close> \\<open>i < n\\<close> \\<open>length (restrict s t1) = n\\<close>\n                \\<open>length (restrict s t2) = n\\<close> length_restrict nth_restrict)"], ["proof (state)\nthis:\n  restrict s t1 ! i = restrict s t2 ! i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < n; i \\<notin> s\\<rbrakk>\n    \\<Longrightarrow> restrict s t1 ! i = restrict s t2 ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < n; i \\<notin> s\\<rbrakk>\n    \\<Longrightarrow> restrict s t1 ! i = restrict s t2 ! i", "case False"], ["proof (state)\nthis:\n  i \\<notin> s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < n; i \\<notin> s\\<rbrakk>\n    \\<Longrightarrow> restrict s t1 ! i = restrict s t2 ! i", "then"], ["proof (chain)\npicking this:\n  i \\<notin> s", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<notin> s\n\ngoal (1 subgoal):\n 1. restrict s t1 ! i = restrict s t2 ! i", "by (metis (no_types, hide_lams) \\<open>i < n\\<close> assms(2) assms(3) assms(4) assms(5) wf_tuple_def\n                wf_tuple_restrict_simple)"], ["proof (state)\nthis:\n  restrict s t1 ! i = restrict s t2 ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict s t1 ! i = restrict s t2 ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> restrict s t1 ! ?i = restrict s t2 ! ?i\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>s. t1 ! i = t2 ! i \\<Longrightarrow>\n    restrict s t1 = restrict s t2", "then"], ["proof (chain)\npicking this:\n  ?i < n \\<Longrightarrow> restrict s t1 ! ?i = restrict s t2 ! ?i", "show \"?B\""], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow> restrict s t1 ! ?i = restrict s t2 ! ?i\n\ngoal (1 subgoal):\n 1. restrict s t1 = restrict s t2", "by (metis \\<open>length (restrict s t1) = n\\<close> \\<open>length (restrict s t2) = n\\<close> nth_equalityI)"], ["proof (state)\nthis:\n  restrict s t1 = restrict s t2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i\\<in>s. t1 ! i = t2 ! i \\<Longrightarrow>\n  restrict s t1 = restrict s t2\n\ngoal (1 subgoal):\n 1. (\\<forall>i\\<in>s. t1 ! i = t2 ! i) = (restrict s t1 = restrict s t2)", "then"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>s. t1 ! i = t2 ! i \\<Longrightarrow>\n  restrict s t1 = restrict s t2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>s. t1 ! i = t2 ! i \\<Longrightarrow>\n  restrict s t1 = restrict s t2\n\ngoal (1 subgoal):\n 1. (\\<forall>i\\<in>s. t1 ! i = t2 ! i) = (restrict s t1 = restrict s t2)", "using calculation"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>s. t1 ! i = t2 ! i \\<Longrightarrow>\n  restrict s t1 = restrict s t2\n  restrict s t1 = restrict s t2 \\<Longrightarrow>\n  \\<forall>i\\<in>s. t1 ! i = t2 ! i\n\ngoal (1 subgoal):\n 1. (\\<forall>i\\<in>s. t1 ! i = t2 ! i) = (restrict s t1 = restrict s t2)", "by linarith"], ["proof (state)\nthis:\n  (\\<forall>i\\<in>s. t1 ! i = t2 ! i) = (restrict s t1 = restrict s t2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>i\\<in>s. t1 ! i = t2 ! i) = (restrict s t1 = restrict s t2)\n\ngoal (1 subgoal):\n 1. isSameIntersection t1 s t2 = (restrict s t1 = restrict s t2)", "then"], ["proof (chain)\npicking this:\n  (\\<forall>i\\<in>s. t1 ! i = t2 ! i) = (restrict s t1 = restrict s t2)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<forall>i\\<in>s. t1 ! i = t2 ! i) = (restrict s t1 = restrict s t2)\n\ngoal (1 subgoal):\n 1. isSameIntersection t1 s t2 = (restrict s t1 = restrict s t2)", "by simp"], ["proof (state)\nthis:\n  isSameIntersection t1 s t2 = (restrict s t1 = restrict s t2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_getIJ:\n  assumes \"card V \\<ge> 2\"\n  assumes \"wf_set n V\"\n  assumes \"(I, J) = getIJ Q_pos Q_neg V\"\n  shows \"wf_set n I\" and \"wf_set n J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_set n I &&& wf_set n J", "using assms"], ["proof (prove)\nusing this:\n  2 \\<le> card V\n  wf_set n V\n  (I, J) = getIJ Q_pos Q_neg V\n\ngoal (1 subgoal):\n 1. wf_set n I &&& wf_set n J", "unfolding wf_set_def"], ["proof (prove)\nusing this:\n  2 \\<le> card V\n  \\<forall>x\\<in>V. x < n\n  (I, J) = getIJ Q_pos Q_neg V\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>I. x < n &&& \\<forall>x\\<in>J. x < n", "by (metis Un_iff coreProperties)+"], ["", "lemma wf_projectTable:\n  assumes \"wf_atable n X\"\n  shows \"wf_atable n (projectTable I X) \\<and> (fst (projectTable I X) = (fst X \\<inter> I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_atable n (projectTable I X) \\<and>\n    fst (projectTable I X) = fst X \\<inter> I", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_atable n (projectTable I X) \\<and>\n    fst (projectTable I X) = fst X \\<inter> I", "obtain Y where \"Y = projectTable I X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        Y = projectTable I X \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  Y = projectTable I X\n\ngoal (1 subgoal):\n 1. wf_atable n (projectTable I X) \\<and>\n    fst (projectTable I X) = fst X \\<inter> I", "obtain sX tX where \"(sX, tX) = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sX tX. (sX, tX) = X \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis surj_pair)"], ["proof (state)\nthis:\n  (sX, tX) = X\n\ngoal (1 subgoal):\n 1. wf_atable n (projectTable I X) \\<and>\n    fst (projectTable I X) = fst X \\<inter> I", "moreover"], ["proof (state)\nthis:\n  (sX, tX) = X\n\ngoal (1 subgoal):\n 1. wf_atable n (projectTable I X) \\<and>\n    fst (projectTable I X) = fst X \\<inter> I", "obtain S where \"S = I \\<inter> sX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>S. S = I \\<inter> sX \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  S = I \\<inter> sX\n\ngoal (1 subgoal):\n 1. wf_atable n (projectTable I X) \\<and>\n    fst (projectTable I X) = fst X \\<inter> I", "moreover"], ["proof (state)\nthis:\n  S = I \\<inter> sX\n\ngoal (1 subgoal):\n 1. wf_atable n (projectTable I X) \\<and>\n    fst (projectTable I X) = fst X \\<inter> I", "obtain sY tY where \"(sY, tY) = Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sY tY. (sY, tY) = Y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis surj_pair)"], ["proof (state)\nthis:\n  (sY, tY) = Y\n\ngoal (1 subgoal):\n 1. wf_atable n (projectTable I X) \\<and>\n    fst (projectTable I X) = fst X \\<inter> I", "then"], ["proof (chain)\npicking this:\n  (sY, tY) = Y", "have \"sY = S\""], ["proof (prove)\nusing this:\n  (sY, tY) = Y\n\ngoal (1 subgoal):\n 1. sY = S", "using calculation(1) calculation(2) \\<open>Y = projectTable I X\\<close>"], ["proof (prove)\nusing this:\n  (sY, tY) = Y\n  (sX, tX) = X\n  S = I \\<inter> sX\n  Y = projectTable I X\n\ngoal (1 subgoal):\n 1. sY = S", "by auto"], ["proof (state)\nthis:\n  sY = S\n\ngoal (1 subgoal):\n 1. wf_atable n (projectTable I X) \\<and>\n    fst (projectTable I X) = fst X \\<inter> I", "then"], ["proof (chain)\npicking this:\n  sY = S", "have \"\\<And>t. t \\<in> tY \\<Longrightarrow> wf_tuple n S t\""], ["proof (prove)\nusing this:\n  sY = S\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> tY \\<Longrightarrow> wf_tuple n S t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>t \\<in> tY; sY = S\\<rbrakk> \\<Longrightarrow> wf_tuple n S t", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>t \\<in> tY; sY = S\\<rbrakk> \\<Longrightarrow> wf_tuple n S t", "assume \"t \\<in> tY\""], ["proof (state)\nthis:\n  t \\<in> tY\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>t \\<in> tY; sY = S\\<rbrakk> \\<Longrightarrow> wf_tuple n S t", "obtain x where \"x \\<in> tX\" \"t = restrict I x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> tX; t = restrict I x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>(sY, tY) = Y\\<close> \\<open>t \\<in> tY\\<close> \\<open>Y = projectTable I X\\<close> calculation(1)"], ["proof (prove)\nusing this:\n  (sY, tY) = Y\n  t \\<in> tY\n  Y = projectTable I X\n  (sX, tX) = X\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> tX; t = restrict I x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> tX\n  t = restrict I x\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>t \\<in> tY; sY = S\\<rbrakk> \\<Longrightarrow> wf_tuple n S t", "then"], ["proof (chain)\npicking this:\n  x \\<in> tX\n  t = restrict I x", "have \"wf_tuple n sX x\""], ["proof (prove)\nusing this:\n  x \\<in> tX\n  t = restrict I x\n\ngoal (1 subgoal):\n 1. wf_tuple n sX x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> tX; t = restrict I x\\<rbrakk>\n    \\<Longrightarrow> wf_tuple n sX x", "have \"table n sX tX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. table n sX tX", "using assms(1) calculation(1) wf_atable_def"], ["proof (prove)\nusing this:\n  wf_atable n X\n  (sX, tX) = X\n  wf_atable ?n ?X = (table ?n (fst ?X) (snd ?X) \\<and> finite (fst ?X))\n\ngoal (1 subgoal):\n 1. table n sX tX", "by fastforce"], ["proof (state)\nthis:\n  table n sX tX\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> tX; t = restrict I x\\<rbrakk>\n    \\<Longrightarrow> wf_tuple n sX x", "then"], ["proof (chain)\npicking this:\n  table n sX tX", "show ?thesis"], ["proof (prove)\nusing this:\n  table n sX tX\n\ngoal (1 subgoal):\n 1. wf_tuple n sX x", "using \\<open>x \\<in> tX\\<close> table_def"], ["proof (prove)\nusing this:\n  table n sX tX\n  x \\<in> tX\n  table ?n ?V ?X = (\\<forall>x\\<in>?X. wf_tuple ?n ?V x)\n\ngoal (1 subgoal):\n 1. wf_tuple n sX x", "by blast"], ["proof (state)\nthis:\n  wf_tuple n sX x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf_tuple n sX x\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>t \\<in> tY; sY = S\\<rbrakk> \\<Longrightarrow> wf_tuple n S t", "then"], ["proof (chain)\npicking this:\n  wf_tuple n sX x", "show \"wf_tuple n S t\""], ["proof (prove)\nusing this:\n  wf_tuple n sX x\n\ngoal (1 subgoal):\n 1. wf_tuple n S t", "using \\<open>t = restrict I x\\<close> calculation(2) wf_tuple_restrict"], ["proof (prove)\nusing this:\n  wf_tuple n sX x\n  t = restrict I x\n  S = I \\<inter> sX\n  \\<lbrakk>wf_tuple ?n ?B ?v; ?A \\<inter> ?B = ?C\\<rbrakk>\n  \\<Longrightarrow> wf_tuple ?n ?C (restrict ?A ?v)\n\ngoal (1 subgoal):\n 1. wf_tuple n S t", "by blast"], ["proof (state)\nthis:\n  wf_tuple n S t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?t \\<in> tY \\<Longrightarrow> wf_tuple n S ?t\n\ngoal (1 subgoal):\n 1. wf_atable n (projectTable I X) \\<and>\n    fst (projectTable I X) = fst X \\<inter> I", "then"], ["proof (chain)\npicking this:\n  ?t \\<in> tY \\<Longrightarrow> wf_tuple n S ?t", "have \"\\<forall>t \\<in> tY. wf_tuple n S t\""], ["proof (prove)\nusing this:\n  ?t \\<in> tY \\<Longrightarrow> wf_tuple n S ?t\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>tY. wf_tuple n S t", "by blast"], ["proof (state)\nthis:\n  \\<forall>t\\<in>tY. wf_tuple n S t\n\ngoal (1 subgoal):\n 1. wf_atable n (projectTable I X) \\<and>\n    fst (projectTable I X) = fst X \\<inter> I", "then"], ["proof (chain)\npicking this:\n  \\<forall>t\\<in>tY. wf_tuple n S t", "have \"table n S tY\""], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>tY. wf_tuple n S t\n\ngoal (1 subgoal):\n 1. table n S tY", "using table_def"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>tY. wf_tuple n S t\n  table ?n ?V ?X = (\\<forall>x\\<in>?X. wf_tuple ?n ?V x)\n\ngoal (1 subgoal):\n 1. table n S tY", "by blast"], ["proof (state)\nthis:\n  table n S tY\n\ngoal (1 subgoal):\n 1. wf_atable n (projectTable I X) \\<and>\n    fst (projectTable I X) = fst X \\<inter> I", "then"], ["proof (chain)\npicking this:\n  table n S tY", "show ?thesis"], ["proof (prove)\nusing this:\n  table n S tY\n\ngoal (1 subgoal):\n 1. wf_atable n (projectTable I X) \\<and>\n    fst (projectTable I X) = fst X \\<inter> I", "by (metis \\<open>(sY, tY) = Y\\<close> \\<open>Y = projectTable I X\\<close> \\<open>sY = S\\<close> assms calculation(1) calculation(2) finite_Int fst_conv inf_commute snd_conv wf_atable_def)"], ["proof (state)\nthis:\n  wf_atable n (projectTable I X) \\<and>\n  fst (projectTable I X) = fst X \\<inter> I\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_filterQuery:\n  assumes \"QQ = filterQuery I Q\"\n  assumes \"non_empty_query Q\"\n  shows \"\\<forall>X\\<in>Q. (card (fst X \\<inter> I) \\<ge> 1 \\<longleftrightarrow> X \\<in> QQ)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>Q. (1 \\<le> card (fst X \\<inter> I)) = (X \\<in> QQ)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>Q. (1 \\<le> card (fst X \\<inter> I)) = (X \\<in> QQ)", "have \"\\<And>X. X \\<in> Q \\<Longrightarrow> (card (fst X \\<inter> I) \\<ge> 1 \\<longleftrightarrow> X \\<in> QQ)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X.\n       X \\<in> Q \\<Longrightarrow>\n       (1 \\<le> card (fst X \\<inter> I)) = (X \\<in> QQ)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X.\n       X \\<in> Q \\<Longrightarrow>\n       (1 \\<le> card (fst X \\<inter> I)) = (X \\<in> QQ)", "fix X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X.\n       X \\<in> Q \\<Longrightarrow>\n       (1 \\<le> card (fst X \\<inter> I)) = (X \\<in> QQ)", "assume \"X \\<in> Q\""], ["proof (state)\nthis:\n  X \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>X.\n       X \\<in> Q \\<Longrightarrow>\n       (1 \\<le> card (fst X \\<inter> I)) = (X \\<in> QQ)", "have \"card (fst X \\<inter> I) \\<ge> 1 \\<Longrightarrow> X \\<in> QQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> card (fst X \\<inter> I) \\<Longrightarrow> X \\<in> QQ", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 \\<le> card (fst X \\<inter> I) \\<Longrightarrow> X \\<in> QQ", "assume \"card (fst X \\<inter> I) \\<ge> 1\""], ["proof (state)\nthis:\n  1 \\<le> card (fst X \\<inter> I)\n\ngoal (1 subgoal):\n 1. 1 \\<le> card (fst X \\<inter> I) \\<Longrightarrow> X \\<in> QQ", "then"], ["proof (chain)\npicking this:\n  1 \\<le> card (fst X \\<inter> I)", "have \"(\\<lambda>(s, _). s \\<inter> I \\<noteq> {}) X\""], ["proof (prove)\nusing this:\n  1 \\<le> card (fst X \\<inter> I)\n\ngoal (1 subgoal):\n 1. case X of (s, uu_) \\<Rightarrow> s \\<inter> I \\<noteq> {}", "by force"], ["proof (state)\nthis:\n  case X of (s, uu_) \\<Rightarrow> s \\<inter> I \\<noteq> {}\n\ngoal (1 subgoal):\n 1. 1 \\<le> card (fst X \\<inter> I) \\<Longrightarrow> X \\<in> QQ", "then"], ["proof (chain)\npicking this:\n  case X of (s, uu_) \\<Rightarrow> s \\<inter> I \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  case X of (s, uu_) \\<Rightarrow> s \\<inter> I \\<noteq> {}\n\ngoal (1 subgoal):\n 1. X \\<in> QQ", "by (simp add: \\<open>case X of (s, uu_) \\<Rightarrow> s \\<inter> I \\<noteq> {}\\<close> Set.is_empty_def \\<open>X \\<in> Q\\<close> assms(1))"], ["proof (state)\nthis:\n  X \\<in> QQ\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 \\<le> card (fst X \\<inter> I) \\<Longrightarrow> X \\<in> QQ\n\ngoal (1 subgoal):\n 1. \\<And>X.\n       X \\<in> Q \\<Longrightarrow>\n       (1 \\<le> card (fst X \\<inter> I)) = (X \\<in> QQ)", "moreover"], ["proof (state)\nthis:\n  1 \\<le> card (fst X \\<inter> I) \\<Longrightarrow> X \\<in> QQ\n\ngoal (1 subgoal):\n 1. \\<And>X.\n       X \\<in> Q \\<Longrightarrow>\n       (1 \\<le> card (fst X \\<inter> I)) = (X \\<in> QQ)", "have \"X \\<in> QQ \\<Longrightarrow> card (fst X \\<inter> I) \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> QQ \\<Longrightarrow> 1 \\<le> card (fst X \\<inter> I)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. X \\<in> QQ \\<Longrightarrow> 1 \\<le> card (fst X \\<inter> I)", "assume \"X \\<in> QQ\""], ["proof (state)\nthis:\n  X \\<in> QQ\n\ngoal (1 subgoal):\n 1. X \\<in> QQ \\<Longrightarrow> 1 \\<le> card (fst X \\<inter> I)", "have \"(\\<lambda>(s, _). s \\<inter> I \\<noteq> {}) X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case X of (s, uu_) \\<Rightarrow> s \\<inter> I \\<noteq> {}", "using Set.is_empty_def \\<open>X \\<in> QQ\\<close> assms(1)"], ["proof (prove)\nusing this:\n  Set.is_empty ?A = (?A = {})\n  X \\<in> QQ\n  QQ = filterQuery I Q\n\ngoal (1 subgoal):\n 1. case X of (s, uu_) \\<Rightarrow> s \\<inter> I \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  case X of (s, uu_) \\<Rightarrow> s \\<inter> I \\<noteq> {}\n\ngoal (1 subgoal):\n 1. X \\<in> QQ \\<Longrightarrow> 1 \\<le> card (fst X \\<inter> I)", "then"], ["proof (chain)\npicking this:\n  case X of (s, uu_) \\<Rightarrow> s \\<inter> I \\<noteq> {}", "have \"fst X \\<inter> I \\<noteq> {}\""], ["proof (prove)\nusing this:\n  case X of (s, uu_) \\<Rightarrow> s \\<inter> I \\<noteq> {}\n\ngoal (1 subgoal):\n 1. fst X \\<inter> I \\<noteq> {}", "by (simp add: case_prod_beta')"], ["proof (state)\nthis:\n  fst X \\<inter> I \\<noteq> {}\n\ngoal (1 subgoal):\n 1. X \\<in> QQ \\<Longrightarrow> 1 \\<le> card (fst X \\<inter> I)", "then"], ["proof (chain)\npicking this:\n  fst X \\<inter> I \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  fst X \\<inter> I \\<noteq> {}\n\ngoal (1 subgoal):\n 1. 1 \\<le> card (fst X \\<inter> I)", "by (metis One_nat_def Suc_leI \\<open>X \\<in> Q\\<close> assms(2) card.infinite card_gt_0_iff finite_Int non_empty_query_def)"], ["proof (state)\nthis:\n  1 \\<le> card (fst X \\<inter> I)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  X \\<in> QQ \\<Longrightarrow> 1 \\<le> card (fst X \\<inter> I)\n\ngoal (1 subgoal):\n 1. \\<And>X.\n       X \\<in> Q \\<Longrightarrow>\n       (1 \\<le> card (fst X \\<inter> I)) = (X \\<in> QQ)", "then"], ["proof (chain)\npicking this:\n  X \\<in> QQ \\<Longrightarrow> 1 \\<le> card (fst X \\<inter> I)", "show \"(card (fst X \\<inter> I) \\<ge> 1 \\<longleftrightarrow> X \\<in> QQ)\""], ["proof (prove)\nusing this:\n  X \\<in> QQ \\<Longrightarrow> 1 \\<le> card (fst X \\<inter> I)\n\ngoal (1 subgoal):\n 1. (1 \\<le> card (fst X \\<inter> I)) = (X \\<in> QQ)", "using calculation"], ["proof (prove)\nusing this:\n  X \\<in> QQ \\<Longrightarrow> 1 \\<le> card (fst X \\<inter> I)\n  1 \\<le> card (fst X \\<inter> I) \\<Longrightarrow> X \\<in> QQ\n\ngoal (1 subgoal):\n 1. (1 \\<le> card (fst X \\<inter> I)) = (X \\<in> QQ)", "by blast"], ["proof (state)\nthis:\n  (1 \\<le> card (fst X \\<inter> I)) = (X \\<in> QQ)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?X \\<in> Q \\<Longrightarrow>\n  (1 \\<le> card (fst ?X \\<inter> I)) = (?X \\<in> QQ)\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>Q. (1 \\<le> card (fst X \\<inter> I)) = (X \\<in> QQ)", "then"], ["proof (chain)\npicking this:\n  ?X \\<in> Q \\<Longrightarrow>\n  (1 \\<le> card (fst ?X \\<inter> I)) = (?X \\<in> QQ)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?X \\<in> Q \\<Longrightarrow>\n  (1 \\<le> card (fst ?X \\<inter> I)) = (?X \\<in> QQ)\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>Q. (1 \\<le> card (fst X \\<inter> I)) = (X \\<in> QQ)", "by blast"], ["proof (state)\nthis:\n  \\<forall>X\\<in>Q. (1 \\<le> card (fst X \\<inter> I)) = (X \\<in> QQ)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_filterQuery:\n  assumes \"I \\<subseteq> V\"\n  assumes \"card I \\<ge> 1\"\n  assumes \"rwf_query n V Qp Qn\"\n  assumes \"QQp = filterQuery I Qp\"\n  assumes \"QQn = filterQueryNeg I Qn\"\n  shows \"wf_query n I QQp QQn\" \"non_empty_query QQp\" \"covering I QQp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_query n I QQp QQn &&& non_empty_query QQp &&& covering I QQp", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. wf_query n I QQp QQn\n 2. non_empty_query QQp\n 3. covering I QQp", "show \"non_empty_query QQp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_empty_query QQp", "by (metis assms(3) assms(4) filterQuery.simps member_filter non_empty_query_def rwf_query_def)"], ["proof (state)\nthis:\n  non_empty_query QQp\n\ngoal (2 subgoals):\n 1. wf_query n I QQp QQn\n 2. covering I QQp", "show \"covering I QQp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. covering I QQp", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. covering I QQp", "have \"\\<forall>X\\<in>Qp. (card (fst X \\<inter> I) \\<ge> 1 \\<longleftrightarrow> X \\<in> QQp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>Qp. (1 \\<le> card (fst X \\<inter> I)) = (X \\<in> QQp)", "using set_filterQuery assms(3) assms(4) rwf_query_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?QQ = filterQuery ?I ?Q; non_empty_query ?Q\\<rbrakk>\n  \\<Longrightarrow> \\<forall>X\\<in>?Q.\n                       (1 \\<le> card (fst X \\<inter> ?I)) = (X \\<in> ?QQ)\n  rwf_query n V Qp Qn\n  QQp = filterQuery I Qp\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>Qp. (1 \\<le> card (fst X \\<inter> I)) = (X \\<in> QQp)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>X\\<in>Qp. (1 \\<le> card (fst X \\<inter> I)) = (X \\<in> QQp)\n\ngoal (1 subgoal):\n 1. covering I QQp", "have \"(\\<Union>(S, X)\\<in>Qp. S) \\<inter> I \\<subseteq> (\\<Union>(S, _)\\<in>QQp. S)\" (is \"?A \\<inter> I \\<subseteq> ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>(S, X)\\<in>Qp. S) \\<inter> I\n    \\<subseteq> (\\<Union>(S, uu_)\\<in>QQp. S)", "proof (rule subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>(S, X)\\<in>Qp. S) \\<inter> I \\<Longrightarrow>\n       x \\<in> (\\<Union>(S, uu_)\\<in>QQp. S)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>(S, X)\\<in>Qp. S) \\<inter> I \\<Longrightarrow>\n       x \\<in> (\\<Union>(S, uu_)\\<in>QQp. S)", "assume \"x \\<in> ?A \\<inter> I\""], ["proof (state)\nthis:\n  x \\<in> (\\<Union>(S, X)\\<in>Qp. S) \\<inter> I\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>(S, X)\\<in>Qp. S) \\<inter> I \\<Longrightarrow>\n       x \\<in> (\\<Union>(S, uu_)\\<in>QQp. S)", "have \"x \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>(S, X)\\<in>Qp. S)", "using \\<open>x \\<in> (\\<Union>(S, X)\\<in>Qp. S) \\<inter> I\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> (\\<Union>(S, X)\\<in>Qp. S) \\<inter> I\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>(S, X)\\<in>Qp. S)", "by blast"], ["proof (state)\nthis:\n  x \\<in> (\\<Union>(S, X)\\<in>Qp. S)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>(S, X)\\<in>Qp. S) \\<inter> I \\<Longrightarrow>\n       x \\<in> (\\<Union>(S, uu_)\\<in>QQp. S)", "then"], ["proof (chain)\npicking this:\n  x \\<in> (\\<Union>(S, X)\\<in>Qp. S)", "obtain S X where \"(S, X) \\<in> Qp\" and \"x \\<in> S\""], ["proof (prove)\nusing this:\n  x \\<in> (\\<Union>(S, X)\\<in>Qp. S)\n\ngoal (1 subgoal):\n 1. (\\<And>S X.\n        \\<lbrakk>(S, X) \\<in> Qp; x \\<in> S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (S, X) \\<in> Qp\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>(S, X)\\<in>Qp. S) \\<inter> I \\<Longrightarrow>\n       x \\<in> (\\<Union>(S, uu_)\\<in>QQp. S)", "moreover"], ["proof (state)\nthis:\n  (S, X) \\<in> Qp\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>(S, X)\\<in>Qp. S) \\<inter> I \\<Longrightarrow>\n       x \\<in> (\\<Union>(S, uu_)\\<in>QQp. S)", "have \"(S, X) \\<in> QQp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S, X) \\<in> QQp", "by (metis Int_iff One_nat_def Suc_le_eq\n            \\<open>\\<forall>X\\<in>Qp. (1 \\<le> card (fst X \\<inter> I)) = (X \\<in> QQp)\\<close> \\<open>x \\<in> (\\<Union>(S, X)\\<in>Qp. S) \\<inter> I\\<close> assms(2)\n            calculation(1) calculation(2) card_gt_0_iff empty_iff finite_Int fst_conv)"], ["proof (state)\nthis:\n  (S, X) \\<in> QQp\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>(S, X)\\<in>Qp. S) \\<inter> I \\<Longrightarrow>\n       x \\<in> (\\<Union>(S, uu_)\\<in>QQp. S)", "ultimately"], ["proof (chain)\npicking this:\n  (S, X) \\<in> Qp\n  x \\<in> S\n  (S, X) \\<in> QQp", "show \"x \\<in> ?B\""], ["proof (prove)\nusing this:\n  (S, X) \\<in> Qp\n  x \\<in> S\n  (S, X) \\<in> QQp\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>(S, uu_)\\<in>QQp. S)", "by auto"], ["proof (state)\nthis:\n  x \\<in> (\\<Union>(S, uu_)\\<in>QQp. S)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Union>(S, X)\\<in>Qp. S) \\<inter> I\n  \\<subseteq> (\\<Union>(S, uu_)\\<in>QQp. S)\n\ngoal (1 subgoal):\n 1. covering I QQp", "then"], ["proof (chain)\npicking this:\n  (\\<Union>(S, X)\\<in>Qp. S) \\<inter> I\n  \\<subseteq> (\\<Union>(S, uu_)\\<in>QQp. S)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Union>(S, X)\\<in>Qp. S) \\<inter> I\n  \\<subseteq> (\\<Union>(S, uu_)\\<in>QQp. S)\n\ngoal (1 subgoal):\n 1. covering I QQp", "by (metis (mono_tags, lifting) assms(1) assms(3) covering_def inf.absorb_iff2 le_infI1 rwf_query_def)"], ["proof (state)\nthis:\n  covering I QQp\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  covering I QQp\n\ngoal (1 subgoal):\n 1. wf_query n I QQp QQn", "show \"wf_query n I QQp QQn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_query n I QQp QQn", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_query n I QQp QQn", "have \"(\\<forall>X\\<in>QQp. wf_atable n X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>QQp. wf_atable n X", "using assms(3) assms(4) rwf_query_def wf_query_def"], ["proof (prove)\nusing this:\n  rwf_query n V Qp Qn\n  QQp = filterQuery I Qp\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n  wf_query ?n ?V ?Q_pos ?Q_neg =\n  ((\\<forall>X\\<in>?Q_pos \\<union> ?Q_neg. wf_atable ?n X) \\<and>\n   wf_set ?n ?V \\<and> 1 \\<le> card ?Q_pos)\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>QQp. wf_atable n X", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>X\\<in>QQp. wf_atable n X\n\ngoal (1 subgoal):\n 1. wf_query n I QQp QQn", "moreover"], ["proof (state)\nthis:\n  \\<forall>X\\<in>QQp. wf_atable n X\n\ngoal (1 subgoal):\n 1. wf_query n I QQp QQn", "have \"(wf_set n I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_set n I", "by (meson assms(1) assms(3) rwf_query_def subsetD wf_query_def wf_set_def)"], ["proof (state)\nthis:\n  wf_set n I\n\ngoal (1 subgoal):\n 1. wf_query n I QQp QQn", "moreover"], ["proof (state)\nthis:\n  wf_set n I\n\ngoal (1 subgoal):\n 1. wf_query n I QQp QQn", "have \"card QQp \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> card QQp", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 \\<le> card QQp", "have \"covering I QQp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. covering I QQp", "by (simp add: \\<open>covering I QQp\\<close>)"], ["proof (state)\nthis:\n  covering I QQp\n\ngoal (1 subgoal):\n 1. 1 \\<le> card QQp", "have \"\\<not> (Set.is_empty QQp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Set.is_empty QQp", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<not> Set.is_empty QQp \\<Longrightarrow> False", "assume \"\\<not> (\\<not> (Set.is_empty QQp))\""], ["proof (state)\nthis:\n  \\<not> \\<not> Set.is_empty QQp\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> Set.is_empty QQp \\<Longrightarrow> False", "have \"Set.is_empty QQp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set.is_empty QQp", "using \\<open>\\<not> \\<not> Set.is_empty QQp\\<close>"], ["proof (prove)\nusing this:\n  \\<not> \\<not> Set.is_empty QQp\n\ngoal (1 subgoal):\n 1. Set.is_empty QQp", "by auto"], ["proof (state)\nthis:\n  Set.is_empty QQp\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> Set.is_empty QQp \\<Longrightarrow> False", "have \"(\\<Union>(S, X)\\<in>QQp. S) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>(S, X)\\<in>QQp. S) = {}", "by (metis SUP_empty Set.is_empty_def \\<open>Set.is_empty QQp\\<close>)"], ["proof (state)\nthis:\n  (\\<Union>(S, X)\\<in>QQp. S) = {}\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> Set.is_empty QQp \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (\\<Union>(S, X)\\<in>QQp. S) = {}", "show \"False\""], ["proof (prove)\nusing this:\n  (\\<Union>(S, X)\\<in>QQp. S) = {}\n\ngoal (1 subgoal):\n 1. False", "by (metis \\<open>covering I QQp\\<close> assms(2) card_eq_0_iff covering_def not_one_le_zero subset_empty)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> Set.is_empty QQp\n\ngoal (1 subgoal):\n 1. 1 \\<le> card QQp", "moreover"], ["proof (state)\nthis:\n  \\<not> Set.is_empty QQp\n\ngoal (1 subgoal):\n 1. 1 \\<le> card QQp", "have \"finite QQp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite QQp", "by (metis assms(3) assms(4) card.infinite filterQuery.simps finite_filter not_one_le_zero rwf_query_def wf_query_def)"], ["proof (state)\nthis:\n  finite QQp\n\ngoal (1 subgoal):\n 1. 1 \\<le> card QQp", "then"], ["proof (chain)\npicking this:\n  finite QQp", "show ?thesis"], ["proof (prove)\nusing this:\n  finite QQp\n\ngoal (1 subgoal):\n 1. 1 \\<le> card QQp", "by (metis One_nat_def Set.is_empty_def Suc_leI calculation card_gt_0_iff)"], ["proof (state)\nthis:\n  1 \\<le> card QQp\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 \\<le> card QQp\n\ngoal (1 subgoal):\n 1. wf_query n I QQp QQn", "moreover"], ["proof (state)\nthis:\n  1 \\<le> card QQp\n\ngoal (1 subgoal):\n 1. wf_query n I QQp QQn", "have \"QQn \\<subseteq> Qn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. QQn \\<subseteq> Qn", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. QQn \\<subseteq> Qn", "have \"QQn = filterQueryNeg I Qn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. QQn = filterQueryNeg I Qn", "by (simp add: assms(5))"], ["proof (state)\nthis:\n  QQn = filterQueryNeg I Qn\n\ngoal (1 subgoal):\n 1. QQn \\<subseteq> Qn", "then"], ["proof (chain)\npicking this:\n  QQn = filterQueryNeg I Qn", "show ?thesis"], ["proof (prove)\nusing this:\n  QQn = filterQueryNeg I Qn\n\ngoal (1 subgoal):\n 1. QQn \\<subseteq> Qn", "by auto"], ["proof (state)\nthis:\n  QQn \\<subseteq> Qn\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  QQn \\<subseteq> Qn\n\ngoal (1 subgoal):\n 1. wf_query n I QQp QQn", "moreover"], ["proof (state)\nthis:\n  QQn \\<subseteq> Qn\n\ngoal (1 subgoal):\n 1. wf_query n I QQp QQn", "have \"wf_query n I QQp Qn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_query n I QQp Qn", "by (meson Un_iff assms(3) calculation(1) calculation(2) calculation(3) rwf_query_def wf_query_def)"], ["proof (state)\nthis:\n  wf_query n I QQp Qn\n\ngoal (1 subgoal):\n 1. wf_query n I QQp QQn", "then"], ["proof (chain)\npicking this:\n  wf_query n I QQp Qn", "have \"(\\<forall>X\\<in>Qn. wf_atable n X)\""], ["proof (prove)\nusing this:\n  wf_query n I QQp Qn\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>Qn. wf_atable n X", "by (simp add: wf_query_def)"], ["proof (state)\nthis:\n  \\<forall>X\\<in>Qn. wf_atable n X\n\ngoal (1 subgoal):\n 1. wf_query n I QQp QQn", "then"], ["proof (chain)\npicking this:\n  \\<forall>X\\<in>Qn. wf_atable n X", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>Qn. wf_atable n X\n\ngoal (1 subgoal):\n 1. wf_query n I QQp QQn", "by (meson \\<open>wf_query n I QQp Qn\\<close> calculation(4) subset_eq sup_mono wf_query_def)"], ["proof (state)\nthis:\n  wf_query n I QQp QQn\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf_query n I QQp QQn\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_set_subset:\n  assumes \"I \\<subseteq> V\"\n  assumes \"card I \\<ge> 1\"\n  assumes \"wf_set n V\"\n  shows \"wf_set n I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_set n I", "using assms(1) assms(3) wf_set_def"], ["proof (prove)\nusing this:\n  I \\<subseteq> V\n  wf_set n V\n  wf_set ?n ?V = (\\<forall>x\\<in>?V. x < ?n)\n\ngoal (1 subgoal):\n 1. wf_set n I", "by auto"], ["", "lemma wf_projectQuery:\n  assumes \"card I \\<ge> 1\"\n  assumes \"wf_query n I Q Qn\"\n  assumes \"non_empty_query Q\"\n  assumes \"covering I Q\"\n  assumes \"\\<forall>X\\<in>Q. card (fst X \\<inter> I) \\<ge> 1\"\n  assumes \"QQ = projectQuery I Q\"\n  assumes \"included I Qn\"\n  assumes \"non_empty_query Qn\"\n  shows \"rwf_query n I QQ Qn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rwf_query n I QQ Qn", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rwf_query n I QQ Qn", "have \"wf_query n I QQ Qn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_query n I QQ Qn", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_query n I QQ Qn", "have \"\\<forall>X\\<in>QQ. wf_atable n X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>QQ. wf_atable n X", "using assms(2) assms(6) wf_query_def"], ["proof (prove)\nusing this:\n  wf_query n I Q Qn\n  QQ = projectQuery I Q\n  wf_query ?n ?V ?Q_pos ?Q_neg =\n  ((\\<forall>X\\<in>?Q_pos \\<union> ?Q_neg. wf_atable ?n X) \\<and>\n   wf_set ?n ?V \\<and> 1 \\<le> card ?Q_pos)\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>QQ. wf_atable n X", "by (simp add: wf_projectTable wf_query_def)"], ["proof (state)\nthis:\n  \\<forall>X\\<in>QQ. wf_atable n X\n\ngoal (1 subgoal):\n 1. wf_query n I QQ Qn", "moreover"], ["proof (state)\nthis:\n  \\<forall>X\\<in>QQ. wf_atable n X\n\ngoal (1 subgoal):\n 1. wf_query n I QQ Qn", "have \"wf_set n I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_set n I", "using assms(2) wf_query_def"], ["proof (prove)\nusing this:\n  wf_query n I Q Qn\n  wf_query ?n ?V ?Q_pos ?Q_neg =\n  ((\\<forall>X\\<in>?Q_pos \\<union> ?Q_neg. wf_atable ?n X) \\<and>\n   wf_set ?n ?V \\<and> 1 \\<le> card ?Q_pos)\n\ngoal (1 subgoal):\n 1. wf_set n I", "by blast"], ["proof (state)\nthis:\n  wf_set n I\n\ngoal (1 subgoal):\n 1. wf_query n I QQ Qn", "moreover"], ["proof (state)\nthis:\n  wf_set n I\n\ngoal (1 subgoal):\n 1. wf_query n I QQ Qn", "have \"card QQ \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> card QQ", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 \\<le> card QQ", "have \"card QQ = card (Set.image (projectTable I) Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card QQ = card (projectTable I ` Q)", "by (simp add: assms(6))"], ["proof (state)\nthis:\n  card QQ = card (projectTable I ` Q)\n\ngoal (1 subgoal):\n 1. 1 \\<le> card QQ", "then"], ["proof (chain)\npicking this:\n  card QQ = card (projectTable I ` Q)", "show ?thesis"], ["proof (prove)\nusing this:\n  card QQ = card (projectTable I ` Q)\n\ngoal (1 subgoal):\n 1. 1 \\<le> card QQ", "by (metis One_nat_def Suc_le_eq assms(2) card_gt_0_iff finite_imageI image_is_empty wf_query_def)"], ["proof (state)\nthis:\n  1 \\<le> card QQ\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 \\<le> card QQ\n\ngoal (1 subgoal):\n 1. wf_query n I QQ Qn", "then"], ["proof (chain)\npicking this:\n  1 \\<le> card QQ", "show ?thesis"], ["proof (prove)\nusing this:\n  1 \\<le> card QQ\n\ngoal (1 subgoal):\n 1. wf_query n I QQ Qn", "by (metis Un_iff assms(2) calculation(1) wf_query_def)"], ["proof (state)\nthis:\n  wf_query n I QQ Qn\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf_query n I QQ Qn\n\ngoal (1 subgoal):\n 1. rwf_query n I QQ Qn", "moreover"], ["proof (state)\nthis:\n  wf_query n I QQ Qn\n\ngoal (1 subgoal):\n 1. rwf_query n I QQ Qn", "have \"covering I QQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. covering I QQ", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. covering I QQ", "have \"I \\<subseteq> (\\<Union>(S, X)\\<in>Q. S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<subseteq> (\\<Union>(S, X)\\<in>Q. S)", "using assms(4) covering_def"], ["proof (prove)\nusing this:\n  covering I Q\n  covering ?V ?Q = (?V \\<subseteq> (\\<Union>(S, X)\\<in>?Q. S))\n\ngoal (1 subgoal):\n 1. I \\<subseteq> (\\<Union>(S, X)\\<in>Q. S)", "by auto"], ["proof (state)\nthis:\n  I \\<subseteq> (\\<Union>(S, X)\\<in>Q. S)\n\ngoal (1 subgoal):\n 1. covering I QQ", "moreover"], ["proof (state)\nthis:\n  I \\<subseteq> (\\<Union>(S, X)\\<in>Q. S)\n\ngoal (1 subgoal):\n 1. covering I QQ", "have \"(\\<Union>(S, X)\\<in>Q. S \\<inter> I) \\<subseteq> (\\<Union>(S, X)\\<in>QQ. S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>(S, X)\\<in>Q. S \\<inter> I)\n    \\<subseteq> (\\<Union>(S, X)\\<in>QQ. S)", "proof (rule subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>(S, X)\\<in>Q. S \\<inter> I) \\<Longrightarrow>\n       x \\<in> (\\<Union>(S, X)\\<in>QQ. S)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>(S, X)\\<in>Q. S \\<inter> I) \\<Longrightarrow>\n       x \\<in> (\\<Union>(S, X)\\<in>QQ. S)", "assume \"x \\<in> (\\<Union>(S, X)\\<in>Q. S \\<inter> I)\""], ["proof (state)\nthis:\n  x \\<in> (\\<Union>(S, X)\\<in>Q. S \\<inter> I)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>(S, X)\\<in>Q. S \\<inter> I) \\<Longrightarrow>\n       x \\<in> (\\<Union>(S, X)\\<in>QQ. S)", "obtain S X where \"(S, X) \\<in> Q\" and \"x \\<in> S \\<inter> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>S X.\n        \\<lbrakk>(S, X) \\<in> Q; x \\<in> S \\<inter> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>x \\<in> (\\<Union>(S, X)\\<in>Q. S \\<inter> I)\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> (\\<Union>(S, X)\\<in>Q. S \\<inter> I)\n\ngoal (1 subgoal):\n 1. (\\<And>S X.\n        \\<lbrakk>(S, X) \\<in> Q; x \\<in> S \\<inter> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (S, X) \\<in> Q\n  x \\<in> S \\<inter> I\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>(S, X)\\<in>Q. S \\<inter> I) \\<Longrightarrow>\n       x \\<in> (\\<Union>(S, X)\\<in>QQ. S)", "then"], ["proof (chain)\npicking this:\n  (S, X) \\<in> Q\n  x \\<in> S \\<inter> I", "have \"fst (projectTable I (S, X)) = S \\<inter> I\""], ["proof (prove)\nusing this:\n  (S, X) \\<in> Q\n  x \\<in> S \\<inter> I\n\ngoal (1 subgoal):\n 1. fst (projectTable I (S, X)) = S \\<inter> I", "by simp"], ["proof (state)\nthis:\n  fst (projectTable I (S, X)) = S \\<inter> I\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>(S, X)\\<in>Q. S \\<inter> I) \\<Longrightarrow>\n       x \\<in> (\\<Union>(S, X)\\<in>QQ. S)", "have \"wf_atable n (S, X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_atable n (S, X)", "using \\<open>(S, X) \\<in> Q\\<close> assms(2) wf_query_def"], ["proof (prove)\nusing this:\n  (S, X) \\<in> Q\n  wf_query n I Q Qn\n  wf_query ?n ?V ?Q_pos ?Q_neg =\n  ((\\<forall>X\\<in>?Q_pos \\<union> ?Q_neg. wf_atable ?n X) \\<and>\n   wf_set ?n ?V \\<and> 1 \\<le> card ?Q_pos)\n\ngoal (1 subgoal):\n 1. wf_atable n (S, X)", "by blast"], ["proof (state)\nthis:\n  wf_atable n (S, X)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>(S, X)\\<in>Q. S \\<inter> I) \\<Longrightarrow>\n       x \\<in> (\\<Union>(S, X)\\<in>QQ. S)", "then"], ["proof (chain)\npicking this:\n  wf_atable n (S, X)", "have \"wf_atable n (projectTable I (S, X))\""], ["proof (prove)\nusing this:\n  wf_atable n (S, X)\n\ngoal (1 subgoal):\n 1. wf_atable n (projectTable I (S, X))", "using wf_projectTable"], ["proof (prove)\nusing this:\n  wf_atable n (S, X)\n  wf_atable ?n ?X \\<Longrightarrow>\n  wf_atable ?n (projectTable ?I ?X) \\<and>\n  fst (projectTable ?I ?X) = fst ?X \\<inter> ?I\n\ngoal (1 subgoal):\n 1. wf_atable n (projectTable I (S, X))", "by blast"], ["proof (state)\nthis:\n  wf_atable n (projectTable I (S, X))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> (\\<Union>(S, X)\\<in>Q. S \\<inter> I) \\<Longrightarrow>\n       x \\<in> (\\<Union>(S, X)\\<in>QQ. S)", "then"], ["proof (chain)\npicking this:\n  wf_atable n (projectTable I (S, X))", "show \"x \\<in> (\\<Union>(S, X)\\<in>QQ. S)\""], ["proof (prove)\nusing this:\n  wf_atable n (projectTable I (S, X))\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>(S, X)\\<in>QQ. S)", "using \\<open>(S, X) \\<in> Q\\<close> \\<open>x \\<in> S \\<inter> I\\<close> assms(6)"], ["proof (prove)\nusing this:\n  wf_atable n (projectTable I (S, X))\n  (S, X) \\<in> Q\n  x \\<in> S \\<inter> I\n  QQ = projectQuery I Q\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>(S, X)\\<in>QQ. S)", "by fastforce"], ["proof (state)\nthis:\n  x \\<in> (\\<Union>(S, X)\\<in>QQ. S)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Union>(S, X)\\<in>Q. S \\<inter> I)\n  \\<subseteq> (\\<Union>(S, X)\\<in>QQ. S)\n\ngoal (1 subgoal):\n 1. covering I QQ", "moreover"], ["proof (state)\nthis:\n  (\\<Union>(S, X)\\<in>Q. S \\<inter> I)\n  \\<subseteq> (\\<Union>(S, X)\\<in>QQ. S)\n\ngoal (1 subgoal):\n 1. covering I QQ", "have \"(\\<Union>(S, X)\\<in>Q. S \\<inter> I) = (\\<Union>(S, X)\\<in>Q. S) \\<inter> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>(S, X)\\<in>Q. S \\<inter> I) =\n    (\\<Union>(S, X)\\<in>Q. S) \\<inter> I", "by blast"], ["proof (state)\nthis:\n  (\\<Union>(S, X)\\<in>Q. S \\<inter> I) =\n  (\\<Union>(S, X)\\<in>Q. S) \\<inter> I\n\ngoal (1 subgoal):\n 1. covering I QQ", "then"], ["proof (chain)\npicking this:\n  (\\<Union>(S, X)\\<in>Q. S \\<inter> I) =\n  (\\<Union>(S, X)\\<in>Q. S) \\<inter> I", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Union>(S, X)\\<in>Q. S \\<inter> I) =\n  (\\<Union>(S, X)\\<in>Q. S) \\<inter> I\n\ngoal (1 subgoal):\n 1. covering I QQ", "using calculation(1) calculation(2) covering_def inf_absorb2"], ["proof (prove)\nusing this:\n  (\\<Union>(S, X)\\<in>Q. S \\<inter> I) =\n  (\\<Union>(S, X)\\<in>Q. S) \\<inter> I\n  I \\<subseteq> (\\<Union>(S, X)\\<in>Q. S)\n  (\\<Union>(S, X)\\<in>Q. S \\<inter> I)\n  \\<subseteq> (\\<Union>(S, X)\\<in>QQ. S)\n  covering ?V ?Q = (?V \\<subseteq> (\\<Union>(S, X)\\<in>?Q. S))\n  ?y \\<le> ?x \\<Longrightarrow> inf ?x ?y = ?y\n\ngoal (1 subgoal):\n 1. covering I QQ", "by fastforce"], ["proof (state)\nthis:\n  covering I QQ\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  covering I QQ\n\ngoal (1 subgoal):\n 1. rwf_query n I QQ Qn", "moreover"], ["proof (state)\nthis:\n  covering I QQ\n\ngoal (1 subgoal):\n 1. rwf_query n I QQ Qn", "have \"included I QQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. included I QQ", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. included I QQ", "have \"\\<And>S X. (S, X) \\<in> QQ \\<Longrightarrow> S \\<subseteq> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S X. (S, X) \\<in> QQ \\<Longrightarrow> S \\<subseteq> I", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S X. (S, X) \\<in> QQ \\<Longrightarrow> S \\<subseteq> I", "fix S X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S X. (S, X) \\<in> QQ \\<Longrightarrow> S \\<subseteq> I", "assume \"(S, X) \\<in> QQ\""], ["proof (state)\nthis:\n  (S, X) \\<in> QQ\n\ngoal (1 subgoal):\n 1. \\<And>S X. (S, X) \\<in> QQ \\<Longrightarrow> S \\<subseteq> I", "have \"(S, X) \\<in> Set.image (projectTable I) Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S, X) \\<in> projectTable I ` Q", "using \\<open>(S, X) \\<in> QQ\\<close> assms(6)"], ["proof (prove)\nusing this:\n  (S, X) \\<in> QQ\n  QQ = projectQuery I Q\n\ngoal (1 subgoal):\n 1. (S, X) \\<in> projectTable I ` Q", "by simp"], ["proof (state)\nthis:\n  (S, X) \\<in> projectTable I ` Q\n\ngoal (1 subgoal):\n 1. \\<And>S X. (S, X) \\<in> QQ \\<Longrightarrow> S \\<subseteq> I", "obtain XX where \"XX \\<in> Q\" and \"(S, X) = projectTable I XX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>XX.\n        \\<lbrakk>XX \\<in> Q; (S, X) = projectTable I XX\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>(S, X) \\<in> projectTable I ` Q\\<close>"], ["proof (prove)\nusing this:\n  (S, X) \\<in> projectTable I ` Q\n\ngoal (1 subgoal):\n 1. (\\<And>XX.\n        \\<lbrakk>XX \\<in> Q; (S, X) = projectTable I XX\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  XX \\<in> Q\n  (S, X) = projectTable I XX\n\ngoal (1 subgoal):\n 1. \\<And>S X. (S, X) \\<in> QQ \\<Longrightarrow> S \\<subseteq> I", "then"], ["proof (chain)\npicking this:\n  XX \\<in> Q\n  (S, X) = projectTable I XX", "have \"S = I \\<inter> (fst XX)\""], ["proof (prove)\nusing this:\n  XX \\<in> Q\n  (S, X) = projectTable I XX\n\ngoal (1 subgoal):\n 1. S = I \\<inter> fst XX", "by (metis projectTable.simps fst_conv inf_commute prod.collapse)"], ["proof (state)\nthis:\n  S = I \\<inter> fst XX\n\ngoal (1 subgoal):\n 1. \\<And>S X. (S, X) \\<in> QQ \\<Longrightarrow> S \\<subseteq> I", "then"], ["proof (chain)\npicking this:\n  S = I \\<inter> fst XX", "show \"S \\<subseteq> I\""], ["proof (prove)\nusing this:\n  S = I \\<inter> fst XX\n\ngoal (1 subgoal):\n 1. S \\<subseteq> I", "by simp"], ["proof (state)\nthis:\n  S \\<subseteq> I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?S, ?X) \\<in> QQ \\<Longrightarrow> ?S \\<subseteq> I\n\ngoal (1 subgoal):\n 1. included I QQ", "then"], ["proof (chain)\npicking this:\n  (?S, ?X) \\<in> QQ \\<Longrightarrow> ?S \\<subseteq> I", "have \"(\\<forall>(S, X)\\<in>QQ. S \\<subseteq> I)\""], ["proof (prove)\nusing this:\n  (?S, ?X) \\<in> QQ \\<Longrightarrow> ?S \\<subseteq> I\n\ngoal (1 subgoal):\n 1. \\<forall>(S, X)\\<in>QQ. S \\<subseteq> I", "by blast"], ["proof (state)\nthis:\n  \\<forall>(S, X)\\<in>QQ. S \\<subseteq> I\n\ngoal (1 subgoal):\n 1. included I QQ", "then"], ["proof (chain)\npicking this:\n  \\<forall>(S, X)\\<in>QQ. S \\<subseteq> I", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>(S, X)\\<in>QQ. S \\<subseteq> I\n\ngoal (1 subgoal):\n 1. included I QQ", "by (simp add: included_def)"], ["proof (state)\nthis:\n  included I QQ\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  included I QQ\n\ngoal (1 subgoal):\n 1. rwf_query n I QQ Qn", "moreover"], ["proof (state)\nthis:\n  included I QQ\n\ngoal (1 subgoal):\n 1. rwf_query n I QQ Qn", "have \"non_empty_query QQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_empty_query QQ", "using assms(5) assms(6) non_empty_query_def"], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>Q. 1 \\<le> card (fst X \\<inter> I)\n  QQ = projectQuery I Q\n  non_empty_query ?Q = (\\<forall>X\\<in>?Q. 1 \\<le> card (fst X))\n\ngoal (1 subgoal):\n 1. non_empty_query QQ", "by fastforce"], ["proof (state)\nthis:\n  non_empty_query QQ\n\ngoal (1 subgoal):\n 1. rwf_query n I QQ Qn", "then"], ["proof (chain)\npicking this:\n  non_empty_query QQ", "show ?thesis"], ["proof (prove)\nusing this:\n  non_empty_query QQ\n\ngoal (1 subgoal):\n 1. rwf_query n I QQ Qn", "by (simp add: assms(7) assms(8) calculation(1) calculation(2) calculation(3) rwf_query_def)"], ["proof (state)\nthis:\n  rwf_query n I QQ Qn\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_firstRecursiveCall:\n  assumes \"rwf_query n V Qp Qn\"\n  assumes \"card V \\<ge> 2\"\n  assumes \"(I, J) = getIJ Qp Qn V\"\n  assumes \"Q_I_pos = projectQuery I (filterQuery I Qp)\"\n  assumes \"Q_I_neg = filterQueryNeg I Qn\"\n  shows \"rwf_query n I Q_I_pos Q_I_neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rwf_query n I Q_I_pos Q_I_neg", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rwf_query n I Q_I_pos Q_I_neg", "obtain \"I \\<subseteq> V\" \"card I \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>I \\<subseteq> V; 1 \\<le> card I\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2) assms(3) getIJProperties(5) getIJProperties(1)"], ["proof (prove)\nusing this:\n  2 \\<le> card V\n  (I, J) = getIJ Qp Qn V\n  \\<lbrakk>2 \\<le> card ?V; (?I, ?J) = getIJ ?Q_pos ?Q_neg ?V\\<rbrakk>\n  \\<Longrightarrow> ?V = ?I \\<union> ?J\n  \\<lbrakk>2 \\<le> card ?V; (?I, ?J) = getIJ ?Q_pos ?Q_neg ?V\\<rbrakk>\n  \\<Longrightarrow> 1 \\<le> card ?I\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>I \\<subseteq> V; 1 \\<le> card I\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  I \\<subseteq> V\n  1 \\<le> card I\n\ngoal (1 subgoal):\n 1. rwf_query n I Q_I_pos Q_I_neg", "define tQ where \"tQ = filterQuery I Qp\""], ["proof (state)\nthis:\n  tQ = filterQuery I Qp\n\ngoal (1 subgoal):\n 1. rwf_query n I Q_I_pos Q_I_neg", "obtain \"wf_query n I tQ Q_I_neg\" \"non_empty_query tQ\" \"covering I tQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>wf_query n I tQ Q_I_neg; non_empty_query tQ;\n      covering I tQ\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis wf_filterQuery(1) wf_filterQuery(2) wf_filterQuery(3)\n        \\<open>1 \\<le> card I\\<close> \\<open>I \\<subseteq> V\\<close> assms(1) assms(5) tQ_def)"], ["proof (state)\nthis:\n  wf_query n I tQ Q_I_neg\n  non_empty_query tQ\n  covering I tQ\n\ngoal (1 subgoal):\n 1. rwf_query n I Q_I_pos Q_I_neg", "moreover"], ["proof (state)\nthis:\n  wf_query n I tQ Q_I_neg\n  non_empty_query tQ\n  covering I tQ\n\ngoal (1 subgoal):\n 1. rwf_query n I Q_I_pos Q_I_neg", "obtain \"card I \\<ge> 1\" and \"\\<forall>X\\<in>tQ. card (fst X \\<inter> I) \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>1 \\<le> card I;\n      \\<forall>X\\<in>tQ. 1 \\<le> card (fst X \\<inter> I)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using set_filterQuery \\<open>1 \\<le> card I\\<close> assms(1) rwf_query_def tQ_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?QQ = filterQuery ?I ?Q; non_empty_query ?Q\\<rbrakk>\n  \\<Longrightarrow> \\<forall>X\\<in>?Q.\n                       (1 \\<le> card (fst X \\<inter> ?I)) = (X \\<in> ?QQ)\n  1 \\<le> card I\n  rwf_query n V Qp Qn\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n  tQ = filterQuery I Qp\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>1 \\<le> card I;\n      \\<forall>X\\<in>tQ. 1 \\<le> card (fst X \\<inter> I)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  1 \\<le> card I\n  \\<forall>X\\<in>tQ. 1 \\<le> card (fst X \\<inter> I)\n\ngoal (1 subgoal):\n 1. rwf_query n I Q_I_pos Q_I_neg", "moreover"], ["proof (state)\nthis:\n  1 \\<le> card I\n  \\<forall>X\\<in>tQ. 1 \\<le> card (fst X \\<inter> I)\n\ngoal (1 subgoal):\n 1. rwf_query n I Q_I_pos Q_I_neg", "have \"included I Q_I_neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. included I Q_I_neg", "by (simp add: assms(5) included_def)"], ["proof (state)\nthis:\n  included I Q_I_neg\n\ngoal (1 subgoal):\n 1. rwf_query n I Q_I_pos Q_I_neg", "then"], ["proof (chain)\npicking this:\n  included I Q_I_neg", "show ?thesis"], ["proof (prove)\nusing this:\n  included I Q_I_neg\n\ngoal (1 subgoal):\n 1. rwf_query n I Q_I_pos Q_I_neg", "by (metis wf_projectQuery \\<open>\\<And>thesis. (\\<lbrakk>wf_query n I tQ Q_I_neg; non_empty_query tQ; covering I tQ\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\\<close>\n        assms(1) assms(4) assms(5) calculation(4) calculation(5) filterQueryNeg.simps member_filter non_empty_query_def rwf_query_def tQ_def)"], ["proof (state)\nthis:\n  rwf_query n I Q_I_pos Q_I_neg\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_atable_subset:\n  assumes \"table n V X\"\n  assumes \"Y \\<subseteq> X\"\n  shows \"table n V Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. table n V Y", "by (meson assms(1) assms(2) subsetD table_def)"], ["", "lemma same_set_semiJoin:\n  \"fst (semiJoin x other) = fst x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (semiJoin x other) = fst x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (semiJoin x other) = fst x", "obtain sx tx where \"x = (sx, tx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sx tx. x = (sx, tx) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis surj_pair)"], ["proof (state)\nthis:\n  x = (sx, tx)\n\ngoal (1 subgoal):\n 1. fst (semiJoin x other) = fst x", "obtain so to where \"other = (so, to)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>so to.\n        other = (so, to) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis surj_pair)"], ["proof (state)\nthis:\n  other = (so, to)\n\ngoal (1 subgoal):\n 1. fst (semiJoin x other) = fst x", "then"], ["proof (chain)\npicking this:\n  other = (so, to)", "show ?thesis"], ["proof (prove)\nusing this:\n  other = (so, to)\n\ngoal (1 subgoal):\n 1. fst (semiJoin x other) = fst x", "by (simp add: \\<open>x = (sx, tx)\\<close>)"], ["proof (state)\nthis:\n  fst (semiJoin x other) = fst x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_semiJoin:\n  assumes \"card J \\<ge> 1\"\n  assumes \"wf_query n J Q Qn\"\n  assumes \"non_empty_query Q\"\n  assumes \"covering J Q\"\n  assumes \"\\<forall>X\\<in>Q. card (fst X \\<inter> J) \\<ge> 1\"\n  assumes \"QQ = (Set.image (\\<lambda>tab. semiJoin tab (st, t)) Q)\"\n  shows \"wf_query n J QQ Qn\" \"non_empty_query QQ\" \"covering J QQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_query n J QQ Qn &&& non_empty_query QQ &&& covering J QQ", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. wf_query n J QQ Qn\n 2. non_empty_query QQ\n 3. covering J QQ", "show \"wf_query n J QQ Qn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_query n J QQ Qn", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_query n J QQ Qn", "have \"\\<forall>X\\<in>QQ. wf_atable n X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>QQ. wf_atable n X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>QQ. wf_atable n X", "have \"\\<And>X. X\\<in>QQ \\<Longrightarrow> wf_atable n X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X. X \\<in> QQ \\<Longrightarrow> wf_atable n X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X. X \\<in> QQ \\<Longrightarrow> wf_atable n X", "fix X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X. X \\<in> QQ \\<Longrightarrow> wf_atable n X", "assume \"X \\<in> QQ\""], ["proof (state)\nthis:\n  X \\<in> QQ\n\ngoal (1 subgoal):\n 1. \\<And>X. X \\<in> QQ \\<Longrightarrow> wf_atable n X", "obtain Y where \"Y \\<in> Q\" and \"X = semiJoin Y (st, t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>Y \\<in> Q; X = semiJoin Y (st, t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>X \\<in> QQ\\<close> assms(6)"], ["proof (prove)\nusing this:\n  X \\<in> QQ\n  QQ = (\\<lambda>tab. semiJoin tab (st, t)) ` Q\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>Y \\<in> Q; X = semiJoin Y (st, t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Y \\<in> Q\n  X = semiJoin Y (st, t)\n\ngoal (1 subgoal):\n 1. \\<And>X. X \\<in> QQ \\<Longrightarrow> wf_atable n X", "then"], ["proof (chain)\npicking this:\n  Y \\<in> Q\n  X = semiJoin Y (st, t)", "have \"wf_atable n Y\""], ["proof (prove)\nusing this:\n  Y \\<in> Q\n  X = semiJoin Y (st, t)\n\ngoal (1 subgoal):\n 1. wf_atable n Y", "using assms(2) wf_query_def"], ["proof (prove)\nusing this:\n  Y \\<in> Q\n  X = semiJoin Y (st, t)\n  wf_query n J Q Qn\n  wf_query ?n ?V ?Q_pos ?Q_neg =\n  ((\\<forall>X\\<in>?Q_pos \\<union> ?Q_neg. wf_atable ?n X) \\<and>\n   wf_set ?n ?V \\<and> 1 \\<le> card ?Q_pos)\n\ngoal (1 subgoal):\n 1. wf_atable n Y", "by blast"], ["proof (state)\nthis:\n  wf_atable n Y\n\ngoal (1 subgoal):\n 1. \\<And>X. X \\<in> QQ \\<Longrightarrow> wf_atable n X", "then"], ["proof (chain)\npicking this:\n  wf_atable n Y", "show \"wf_atable n X\""], ["proof (prove)\nusing this:\n  wf_atable n Y\n\ngoal (1 subgoal):\n 1. wf_atable n X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_atable n Y \\<Longrightarrow> wf_atable n X", "have \"fst X = fst Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst X = fst Y", "by (metis \\<open>X = semiJoin Y (st, t)\\<close> fst_conv prod.collapse semiJoin.simps)"], ["proof (state)\nthis:\n  fst X = fst Y\n\ngoal (1 subgoal):\n 1. wf_atable n Y \\<Longrightarrow> wf_atable n X", "moreover"], ["proof (state)\nthis:\n  fst X = fst Y\n\ngoal (1 subgoal):\n 1. wf_atable n Y \\<Longrightarrow> wf_atable n X", "have \"snd X \\<subseteq> snd Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd X \\<subseteq> snd Y", "by (metis \\<open>X = semiJoin Y (st, t)\\<close> member_filter prod.collapse semiJoin.simps snd_conv subsetI)"], ["proof (state)\nthis:\n  snd X \\<subseteq> snd Y\n\ngoal (1 subgoal):\n 1. wf_atable n Y \\<Longrightarrow> wf_atable n X", "then"], ["proof (chain)\npicking this:\n  snd X \\<subseteq> snd Y", "have \"table n (fst X) (snd X)\""], ["proof (prove)\nusing this:\n  snd X \\<subseteq> snd Y\n\ngoal (1 subgoal):\n 1. table n (fst X) (snd X)", "by (metis \\<open>wf_atable n Y\\<close> calculation wf_atable_def wf_atable_subset)"], ["proof (state)\nthis:\n  table n (fst X) (snd X)\n\ngoal (1 subgoal):\n 1. wf_atable n Y \\<Longrightarrow> wf_atable n X", "moreover"], ["proof (state)\nthis:\n  table n (fst X) (snd X)\n\ngoal (1 subgoal):\n 1. wf_atable n Y \\<Longrightarrow> wf_atable n X", "have \"finite (fst X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (fst X)", "by (metis \\<open>wf_atable n Y\\<close> calculation(1) wf_atable_def)"], ["proof (state)\nthis:\n  finite (fst X)\n\ngoal (1 subgoal):\n 1. wf_atable n Y \\<Longrightarrow> wf_atable n X", "then"], ["proof (chain)\npicking this:\n  finite (fst X)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (fst X)\n\ngoal (1 subgoal):\n 1. wf_atable n X", "by (simp add: calculation(2) wf_atable_def)"], ["proof (state)\nthis:\n  wf_atable n X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf_atable n X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?X \\<in> QQ \\<Longrightarrow> wf_atable n ?X\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>QQ. wf_atable n X", "then"], ["proof (chain)\npicking this:\n  ?X \\<in> QQ \\<Longrightarrow> wf_atable n ?X", "show ?thesis"], ["proof (prove)\nusing this:\n  ?X \\<in> QQ \\<Longrightarrow> wf_atable n ?X\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>QQ. wf_atable n X", "by blast"], ["proof (state)\nthis:\n  \\<forall>X\\<in>QQ. wf_atable n X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>X\\<in>QQ. wf_atable n X\n\ngoal (1 subgoal):\n 1. wf_query n J QQ Qn", "moreover"], ["proof (state)\nthis:\n  \\<forall>X\\<in>QQ. wf_atable n X\n\ngoal (1 subgoal):\n 1. wf_query n J QQ Qn", "have \"wf_set n J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_set n J", "using assms(2) wf_query_def"], ["proof (prove)\nusing this:\n  wf_query n J Q Qn\n  wf_query ?n ?V ?Q_pos ?Q_neg =\n  ((\\<forall>X\\<in>?Q_pos \\<union> ?Q_neg. wf_atable ?n X) \\<and>\n   wf_set ?n ?V \\<and> 1 \\<le> card ?Q_pos)\n\ngoal (1 subgoal):\n 1. wf_set n J", "by blast"], ["proof (state)\nthis:\n  wf_set n J\n\ngoal (1 subgoal):\n 1. wf_query n J QQ Qn", "moreover"], ["proof (state)\nthis:\n  wf_set n J\n\ngoal (1 subgoal):\n 1. wf_query n J QQ Qn", "have \"card QQ \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> card QQ", "by (metis One_nat_def Suc_leI assms(2) assms(6) card.infinite card_gt_0_iff finite_imageI image_is_empty wf_query_def)"], ["proof (state)\nthis:\n  1 \\<le> card QQ\n\ngoal (1 subgoal):\n 1. wf_query n J QQ Qn", "then"], ["proof (chain)\npicking this:\n  1 \\<le> card QQ", "show ?thesis"], ["proof (prove)\nusing this:\n  1 \\<le> card QQ\n\ngoal (1 subgoal):\n 1. wf_query n J QQ Qn", "using calculation(1) calculation(2) wf_query_def Un_iff assms(2)"], ["proof (prove)\nusing this:\n  1 \\<le> card QQ\n  \\<forall>X\\<in>QQ. wf_atable n X\n  wf_set n J\n  wf_query ?n ?V ?Q_pos ?Q_neg =\n  ((\\<forall>X\\<in>?Q_pos \\<union> ?Q_neg. wf_atable ?n X) \\<and>\n   wf_set ?n ?V \\<and> 1 \\<le> card ?Q_pos)\n  (?c \\<in> ?A \\<union> ?B) = (?c \\<in> ?A \\<or> ?c \\<in> ?B)\n  wf_query n J Q Qn\n\ngoal (1 subgoal):\n 1. wf_query n J QQ Qn", "by metis"], ["proof (state)\nthis:\n  wf_query n J QQ Qn\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf_query n J QQ Qn\n\ngoal (2 subgoals):\n 1. non_empty_query QQ\n 2. covering J QQ", "show \"non_empty_query QQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_empty_query QQ", "by (metis (no_types, lifting) assms(3) assms(6) image_iff non_empty_query_def same_set_semiJoin)"], ["proof (state)\nthis:\n  non_empty_query QQ\n\ngoal (1 subgoal):\n 1. covering J QQ", "show \"covering J QQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. covering J QQ", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. covering J QQ", "have \"(\\<Union>(S, X)\\<in>Q. S) = (\\<Union>(S, X)\\<in>QQ. S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>(S, X)\\<in>Q. S) = (\\<Union>(S, X)\\<in>QQ. S)", "using assms(6) same_set_semiJoin"], ["proof (prove)\nusing this:\n  QQ = (\\<lambda>tab. semiJoin tab (st, t)) ` Q\n  fst (semiJoin ?x ?other) = fst ?x\n\ngoal (1 subgoal):\n 1. (\\<Union>(S, X)\\<in>Q. S) = (\\<Union>(S, X)\\<in>QQ. S)", "by auto"], ["proof (state)\nthis:\n  (\\<Union>(S, X)\\<in>Q. S) = (\\<Union>(S, X)\\<in>QQ. S)\n\ngoal (1 subgoal):\n 1. covering J QQ", "then"], ["proof (chain)\npicking this:\n  (\\<Union>(S, X)\\<in>Q. S) = (\\<Union>(S, X)\\<in>QQ. S)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Union>(S, X)\\<in>Q. S) = (\\<Union>(S, X)\\<in>QQ. S)\n\ngoal (1 subgoal):\n 1. covering J QQ", "by (metis assms(4) covering_def)"], ["proof (state)\nthis:\n  covering J QQ\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  covering J QQ\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma newQuery_equiv_def:\n  \"newQuery V Q (st, t) = projectQuery V (Set.image (\\<lambda>tab. semiJoin tab (st, t)) Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. newQuery V Q (st, t) =\n    projectQuery V ((\\<lambda>tab. semiJoin tab (st, t)) ` Q)", "by (metis image_image newQuery.simps projectQuery.elims)"], ["", "lemma included_project:\n  \"included V (projectQuery V Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. included V (projectQuery V Q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. included V (projectQuery V Q)", "have \"\\<And>S X. (S, X)\\<in>(projectQuery V Q) \\<Longrightarrow> S \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S X.\n       (S, X) \\<in> projectQuery V Q \\<Longrightarrow> S \\<subseteq> V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S X.\n       (S, X) \\<in> projectQuery V Q \\<Longrightarrow> S \\<subseteq> V", "fix S X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S X.\n       (S, X) \\<in> projectQuery V Q \\<Longrightarrow> S \\<subseteq> V", "assume \"(S, X)\\<in>(projectQuery V Q)\""], ["proof (state)\nthis:\n  (S, X) \\<in> projectQuery V Q\n\ngoal (1 subgoal):\n 1. \\<And>S X.\n       (S, X) \\<in> projectQuery V Q \\<Longrightarrow> S \\<subseteq> V", "obtain SS XX where \"(S, X) = projectTable V (SS, XX)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>SS XX.\n        (S, X) = projectTable V (SS, XX) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>(S, X) \\<in> projectQuery V Q\\<close>"], ["proof (prove)\nusing this:\n  (S, X) \\<in> projectQuery V Q\n\ngoal (1 subgoal):\n 1. (\\<And>SS XX.\n        (S, X) = projectTable V (SS, XX) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (S, X) = projectTable V (SS, XX)\n\ngoal (1 subgoal):\n 1. \\<And>S X.\n       (S, X) \\<in> projectQuery V Q \\<Longrightarrow> S \\<subseteq> V", "then"], ["proof (chain)\npicking this:\n  (S, X) = projectTable V (SS, XX)", "have \"S = SS \\<inter> V\""], ["proof (prove)\nusing this:\n  (S, X) = projectTable V (SS, XX)\n\ngoal (1 subgoal):\n 1. S = SS \\<inter> V", "by auto"], ["proof (state)\nthis:\n  S = SS \\<inter> V\n\ngoal (1 subgoal):\n 1. \\<And>S X.\n       (S, X) \\<in> projectQuery V Q \\<Longrightarrow> S \\<subseteq> V", "then"], ["proof (chain)\npicking this:\n  S = SS \\<inter> V", "show \"S \\<subseteq> V\""], ["proof (prove)\nusing this:\n  S = SS \\<inter> V\n\ngoal (1 subgoal):\n 1. S \\<subseteq> V", "by simp"], ["proof (state)\nthis:\n  S \\<subseteq> V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?S, ?X) \\<in> projectQuery V Q \\<Longrightarrow> ?S \\<subseteq> V\n\ngoal (1 subgoal):\n 1. included V (projectQuery V Q)", "then"], ["proof (chain)\npicking this:\n  (?S, ?X) \\<in> projectQuery V Q \\<Longrightarrow> ?S \\<subseteq> V", "show ?thesis"], ["proof (prove)\nusing this:\n  (?S, ?X) \\<in> projectQuery V Q \\<Longrightarrow> ?S \\<subseteq> V\n\ngoal (1 subgoal):\n 1. included V (projectQuery V Q)", "by (metis case_prodI2 included_def)"], ["proof (state)\nthis:\n  included V (projectQuery V Q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma non_empty_newQuery:\n  assumes \"Q1 = filterQuery J Q0\"\n  assumes \"Q2 = newQuery J Q1 (I, t)\"\n  assumes \"\\<forall>X\\<in>Q0. wf_atable n X\"\n  shows \"non_empty_query Q2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_empty_query Q2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. non_empty_query Q2", "have \"\\<And>X. X\\<in>Q2 \\<Longrightarrow> card (fst X) \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X. X \\<in> Q2 \\<Longrightarrow> 1 \\<le> card (fst X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X. X \\<in> Q2 \\<Longrightarrow> 1 \\<le> card (fst X)", "fix X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X. X \\<in> Q2 \\<Longrightarrow> 1 \\<le> card (fst X)", "assume \"X \\<in> Q2\""], ["proof (state)\nthis:\n  X \\<in> Q2\n\ngoal (1 subgoal):\n 1. \\<And>X. X \\<in> Q2 \\<Longrightarrow> 1 \\<le> card (fst X)", "obtain X2 where \"X = projectTable J X2\" and \"X2 \\<in> Set.image (\\<lambda>tab. semiJoin tab (I, t)) Q1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X2.\n        \\<lbrakk>X = projectTable J X2;\n         X2 \\<in> (\\<lambda>tab. semiJoin tab (I, t)) ` Q1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (mono_tags, lifting) newQuery.simps \\<open>X \\<in> Q2\\<close> assms(2) image_iff)"], ["proof (state)\nthis:\n  X = projectTable J X2\n  X2 \\<in> (\\<lambda>tab. semiJoin tab (I, t)) ` Q1\n\ngoal (1 subgoal):\n 1. \\<And>X. X \\<in> Q2 \\<Longrightarrow> 1 \\<le> card (fst X)", "then"], ["proof (chain)\npicking this:\n  X = projectTable J X2\n  X2 \\<in> (\\<lambda>tab. semiJoin tab (I, t)) ` Q1", "have \"card (fst X2 \\<inter> J) \\<ge> 1\""], ["proof (prove)\nusing this:\n  X = projectTable J X2\n  X2 \\<in> (\\<lambda>tab. semiJoin tab (I, t)) ` Q1\n\ngoal (1 subgoal):\n 1. 1 \\<le> card (fst X2 \\<inter> J)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>X = projectTable J X2;\n     X2 \\<in> (\\<lambda>tab. semiJoin tab (I, t)) ` Q1\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> card (fst X2 \\<inter> J)", "obtain X1 where \"X1 \\<in> Q1\" and \"X2 = semiJoin X1 (I, t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X1.\n        \\<lbrakk>X1 \\<in> Q1; X2 = semiJoin X1 (I, t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>X2 \\<in> (\\<lambda>tab. semiJoin tab (I, t)) ` Q1\\<close>"], ["proof (prove)\nusing this:\n  X2 \\<in> (\\<lambda>tab. semiJoin tab (I, t)) ` Q1\n\ngoal (1 subgoal):\n 1. (\\<And>X1.\n        \\<lbrakk>X1 \\<in> Q1; X2 = semiJoin X1 (I, t)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  X1 \\<in> Q1\n  X2 = semiJoin X1 (I, t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X = projectTable J X2;\n     X2 \\<in> (\\<lambda>tab. semiJoin tab (I, t)) ` Q1\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> card (fst X2 \\<inter> J)", "then"], ["proof (chain)\npicking this:\n  X1 \\<in> Q1\n  X2 = semiJoin X1 (I, t)", "have \"fst X1 = fst X2\""], ["proof (prove)\nusing this:\n  X1 \\<in> Q1\n  X2 = semiJoin X1 (I, t)\n\ngoal (1 subgoal):\n 1. fst X1 = fst X2", "by (simp add: same_set_semiJoin)"], ["proof (state)\nthis:\n  fst X1 = fst X2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X = projectTable J X2;\n     X2 \\<in> (\\<lambda>tab. semiJoin tab (I, t)) ` Q1\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> card (fst X2 \\<inter> J)", "moreover"], ["proof (state)\nthis:\n  fst X1 = fst X2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X = projectTable J X2;\n     X2 \\<in> (\\<lambda>tab. semiJoin tab (I, t)) ` Q1\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> card (fst X2 \\<inter> J)", "have \"X1 \\<in> filterQuery J Q0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X1 \\<in> filterQuery J Q0", "using \\<open>X1 \\<in> Q1\\<close> assms(1)"], ["proof (prove)\nusing this:\n  X1 \\<in> Q1\n  Q1 = filterQuery J Q0\n\ngoal (1 subgoal):\n 1. X1 \\<in> filterQuery J Q0", "by blast"], ["proof (state)\nthis:\n  X1 \\<in> filterQuery J Q0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X = projectTable J X2;\n     X2 \\<in> (\\<lambda>tab. semiJoin tab (I, t)) ` Q1\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> card (fst X2 \\<inter> J)", "then"], ["proof (chain)\npicking this:\n  X1 \\<in> filterQuery J Q0", "have \"(\\<lambda>(s, _). s \\<inter> J \\<noteq> {}) X1\""], ["proof (prove)\nusing this:\n  X1 \\<in> filterQuery J Q0\n\ngoal (1 subgoal):\n 1. case X1 of (s, uu_) \\<Rightarrow> s \\<inter> J \\<noteq> {}", "using Set.is_empty_def"], ["proof (prove)\nusing this:\n  X1 \\<in> filterQuery J Q0\n  Set.is_empty ?A = (?A = {})\n\ngoal (1 subgoal):\n 1. case X1 of (s, uu_) \\<Rightarrow> s \\<inter> J \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  case X1 of (s, uu_) \\<Rightarrow> s \\<inter> J \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X = projectTable J X2;\n     X2 \\<in> (\\<lambda>tab. semiJoin tab (I, t)) ` Q1\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> card (fst X2 \\<inter> J)", "then"], ["proof (chain)\npicking this:\n  case X1 of (s, uu_) \\<Rightarrow> s \\<inter> J \\<noteq> {}", "have \"\\<not> (Set.is_empty (fst X1 \\<inter> J))\""], ["proof (prove)\nusing this:\n  case X1 of (s, uu_) \\<Rightarrow> s \\<inter> J \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> Set.is_empty (fst X1 \\<inter> J)", "by (simp add: Set.is_empty_def case_prod_beta')"], ["proof (state)\nthis:\n  \\<not> Set.is_empty (fst X1 \\<inter> J)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>X = projectTable J X2;\n     X2 \\<in> (\\<lambda>tab. semiJoin tab (I, t)) ` Q1\\<rbrakk>\n    \\<Longrightarrow> 1 \\<le> card (fst X2 \\<inter> J)", "then"], ["proof (chain)\npicking this:\n  \\<not> Set.is_empty (fst X1 \\<inter> J)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> Set.is_empty (fst X1 \\<inter> J)\n\ngoal (1 subgoal):\n 1. 1 \\<le> card (fst X2 \\<inter> J)", "by (metis filterQuery.elims One_nat_def Set.is_empty_def Suc_leI \\<open>X1 \\<in> Q1\\<close> assms(1)\n            assms(3) calculation card_gt_0_iff finite_Int member_filter wf_atable_def)"], ["proof (state)\nthis:\n  1 \\<le> card (fst X2 \\<inter> J)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 \\<le> card (fst X2 \\<inter> J)\n\ngoal (1 subgoal):\n 1. \\<And>X. X \\<in> Q2 \\<Longrightarrow> 1 \\<le> card (fst X)", "then"], ["proof (chain)\npicking this:\n  1 \\<le> card (fst X2 \\<inter> J)", "show \"card (fst X) \\<ge> 1\""], ["proof (prove)\nusing this:\n  1 \\<le> card (fst X2 \\<inter> J)\n\ngoal (1 subgoal):\n 1. 1 \\<le> card (fst X)", "by (metis projectTable.simps \\<open>X = projectTable J X2\\<close> fst_conv prod.collapse)"], ["proof (state)\nthis:\n  1 \\<le> card (fst X)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?X \\<in> Q2 \\<Longrightarrow> 1 \\<le> card (fst ?X)\n\ngoal (1 subgoal):\n 1. non_empty_query Q2", "then"], ["proof (chain)\npicking this:\n  ?X \\<in> Q2 \\<Longrightarrow> 1 \\<le> card (fst ?X)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?X \\<in> Q2 \\<Longrightarrow> 1 \\<le> card (fst ?X)\n\ngoal (1 subgoal):\n 1. non_empty_query Q2", "by (simp add: non_empty_query_def)"], ["proof (state)\nthis:\n  non_empty_query Q2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_newQuery:\n  assumes \"card J \\<ge> 1\"\n  assumes \"wf_query n J Q Qn0\"\n  assumes \"non_empty_query Q\"\n  assumes \"covering J Q\"\n  assumes \"\\<forall>X\\<in>Q. card (fst X \\<inter> J) \\<ge> 1\"\n  assumes \"QQ = newQuery J Q t\"\n  assumes \"QQn = newQuery J Qn t\"\n  assumes \"non_empty_query Qn\"\n  assumes \"Qn = filterQuery J Qn0\"\n  shows \"rwf_query n J QQ QQn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rwf_query n J QQ QQn", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rwf_query n J QQ QQn", "obtain tt st where \"(st, tt) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>st tt. (st, tt) = t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis surj_pair)"], ["proof (state)\nthis:\n  (st, tt) = t\n\ngoal (1 subgoal):\n 1. rwf_query n J QQ QQn", "have \"QQ = projectQuery J (Set.image (\\<lambda>tab. semiJoin tab (st, tt)) Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. QQ = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Q)", "by (metis \\<open>(st, tt) = t\\<close> assms(6) newQuery_equiv_def)"], ["proof (state)\nthis:\n  QQ = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Q)\n\ngoal (1 subgoal):\n 1. rwf_query n J QQ QQn", "define QS where \"QS = Set.image (\\<lambda>tab. semiJoin tab (st, tt)) Q\""], ["proof (state)\nthis:\n  QS = (\\<lambda>tab. semiJoin tab (st, tt)) ` Q\n\ngoal (1 subgoal):\n 1. rwf_query n J QQ QQn", "obtain \"wf_query n J QS Qn0\" \"non_empty_query QS\" \"covering J QS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>wf_query n J QS Qn0; non_empty_query QS;\n      covering J QS\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis wf_semiJoin(1) wf_semiJoin(2) wf_semiJoin(3) QS_def\n        assms(1) assms(2) assms(3) assms(4) assms(5))"], ["proof (state)\nthis:\n  wf_query n J QS Qn0\n  non_empty_query QS\n  covering J QS\n\ngoal (1 subgoal):\n 1. rwf_query n J QQ QQn", "moreover"], ["proof (state)\nthis:\n  wf_query n J QS Qn0\n  non_empty_query QS\n  covering J QS\n\ngoal (1 subgoal):\n 1. rwf_query n J QQ QQn", "have \"\\<forall>X\\<in>QS. card (fst X \\<inter> J) \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>QS. 1 \\<le> card (fst X \\<inter> J)", "using QS_def assms(5)"], ["proof (prove)\nusing this:\n  QS = (\\<lambda>tab. semiJoin tab (st, tt)) ` Q\n  \\<forall>X\\<in>Q. 1 \\<le> card (fst X \\<inter> J)\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>QS. 1 \\<le> card (fst X \\<inter> J)", "by auto"], ["proof (state)\nthis:\n  \\<forall>X\\<in>QS. 1 \\<le> card (fst X \\<inter> J)\n\ngoal (1 subgoal):\n 1. rwf_query n J QQ QQn", "then"], ["proof (chain)\npicking this:\n  \\<forall>X\\<in>QS. 1 \\<le> card (fst X \\<inter> J)", "have \"\\<forall>X\\<in>(projectQuery J QS). wf_atable n X\""], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>QS. 1 \\<le> card (fst X \\<inter> J)\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>projectQuery J QS. wf_atable n X", "by (metis (no_types, lifting) projectQuery.simps Un_iff calculation(1) image_iff\n        wf_projectTable wf_query_def)"], ["proof (state)\nthis:\n  \\<forall>X\\<in>projectQuery J QS. wf_atable n X\n\ngoal (1 subgoal):\n 1. rwf_query n J QQ QQn", "then"], ["proof (chain)\npicking this:\n  \\<forall>X\\<in>projectQuery J QS. wf_atable n X", "have \"wf_query n J QQ QQn\""], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>projectQuery J QS. wf_atable n X\n\ngoal (1 subgoal):\n 1. wf_query n J QQ QQn", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>projectQuery J QS. wf_atable n X \\<Longrightarrow>\n    wf_query n J QQ QQn", "have \"\\<And>X. X\\<in>QQn \\<Longrightarrow> wf_atable n X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X. X \\<in> QQn \\<Longrightarrow> wf_atable n X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X. X \\<in> QQn \\<Longrightarrow> wf_atable n X", "fix X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X. X \\<in> QQn \\<Longrightarrow> wf_atable n X", "assume \"X \\<in> QQn\""], ["proof (state)\nthis:\n  X \\<in> QQn\n\ngoal (1 subgoal):\n 1. \\<And>X. X \\<in> QQn \\<Longrightarrow> wf_atable n X", "have \"QQn = projectQuery J (Set.image (\\<lambda>tab. semiJoin tab (st, tt)) Qn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. QQn = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Qn)", "using newQuery_equiv_def \\<open>(st, tt) = t\\<close> assms(7)"], ["proof (prove)\nusing this:\n  newQuery ?V ?Q (?st, ?t) =\n  projectQuery ?V ((\\<lambda>tab. semiJoin tab (?st, ?t)) ` ?Q)\n  (st, tt) = t\n  QQn = newQuery J Qn t\n\ngoal (1 subgoal):\n 1. QQn = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Qn)", "by blast"], ["proof (state)\nthis:\n  QQn = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Qn)\n\ngoal (1 subgoal):\n 1. \\<And>X. X \\<in> QQn \\<Longrightarrow> wf_atable n X", "then"], ["proof (chain)\npicking this:\n  QQn = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Qn)", "obtain XX where \"X = projectTable J XX\" \"XX \\<in> (Set.image (\\<lambda>tab. semiJoin tab (st, tt)) Qn)\""], ["proof (prove)\nusing this:\n  QQn = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Qn)\n\ngoal (1 subgoal):\n 1. (\\<And>XX.\n        \\<lbrakk>X = projectTable J XX;\n         XX \\<in> (\\<lambda>tab. semiJoin tab (st, tt)) ` Qn\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>X \\<in> QQn\\<close>"], ["proof (prove)\nusing this:\n  QQn = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Qn)\n  X \\<in> QQn\n\ngoal (1 subgoal):\n 1. (\\<And>XX.\n        \\<lbrakk>X = projectTable J XX;\n         XX \\<in> (\\<lambda>tab. semiJoin tab (st, tt)) ` Qn\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  X = projectTable J XX\n  XX \\<in> (\\<lambda>tab. semiJoin tab (st, tt)) ` Qn\n\ngoal (1 subgoal):\n 1. \\<And>X. X \\<in> QQn \\<Longrightarrow> wf_atable n X", "then"], ["proof (chain)\npicking this:\n  X = projectTable J XX\n  XX \\<in> (\\<lambda>tab. semiJoin tab (st, tt)) ` Qn", "obtain XXX where \"XX = semiJoin XXX (st, tt)\" \"XXX \\<in> Qn\""], ["proof (prove)\nusing this:\n  X = projectTable J XX\n  XX \\<in> (\\<lambda>tab. semiJoin tab (st, tt)) ` Qn\n\ngoal (1 subgoal):\n 1. (\\<And>XXX.\n        \\<lbrakk>XX = semiJoin XXX (st, tt); XXX \\<in> Qn\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  XX = semiJoin XXX (st, tt)\n  XXX \\<in> Qn\n\ngoal (1 subgoal):\n 1. \\<And>X. X \\<in> QQn \\<Longrightarrow> wf_atable n X", "then"], ["proof (chain)\npicking this:\n  XX = semiJoin XXX (st, tt)\n  XXX \\<in> Qn", "have \"wf_atable n XXX\""], ["proof (prove)\nusing this:\n  XX = semiJoin XXX (st, tt)\n  XXX \\<in> Qn\n\ngoal (1 subgoal):\n 1. wf_atable n XXX", "by (metis filterQuery.elims Un_iff assms(2) assms(9) member_filter wf_query_def)"], ["proof (state)\nthis:\n  wf_atable n XXX\n\ngoal (1 subgoal):\n 1. \\<And>X. X \\<in> QQn \\<Longrightarrow> wf_atable n X", "then"], ["proof (chain)\npicking this:\n  wf_atable n XXX", "have \"wf_atable n XX\""], ["proof (prove)\nusing this:\n  wf_atable n XXX\n\ngoal (1 subgoal):\n 1. wf_atable n XX", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_atable n XXX \\<Longrightarrow> wf_atable n XX", "have \"fst XX = fst XXX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst XX = fst XXX", "by (simp add: same_set_semiJoin \\<open>XX = semiJoin XXX (st, tt)\\<close>)"], ["proof (state)\nthis:\n  fst XX = fst XXX\n\ngoal (1 subgoal):\n 1. wf_atable n XXX \\<Longrightarrow> wf_atable n XX", "moreover"], ["proof (state)\nthis:\n  fst XX = fst XXX\n\ngoal (1 subgoal):\n 1. wf_atable n XXX \\<Longrightarrow> wf_atable n XX", "have \"snd XX = Set.filter (isSameIntersection tt (fst XX \\<inter> st)) (snd XXX)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd XX =\n    Set.filter (isSameIntersection tt (fst XX \\<inter> st)) (snd XXX)", "by (metis semiJoin.simps \\<open>XX = semiJoin XXX (st, tt)\\<close> calculation prod.collapse snd_conv)"], ["proof (state)\nthis:\n  snd XX = Set.filter (isSameIntersection tt (fst XX \\<inter> st)) (snd XXX)\n\ngoal (1 subgoal):\n 1. wf_atable n XXX \\<Longrightarrow> wf_atable n XX", "moreover"], ["proof (state)\nthis:\n  snd XX = Set.filter (isSameIntersection tt (fst XX \\<inter> st)) (snd XXX)\n\ngoal (1 subgoal):\n 1. wf_atable n XXX \\<Longrightarrow> wf_atable n XX", "have \"snd XX \\<subseteq> snd XXX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd XX \\<subseteq> snd XXX", "using calculation(2)"], ["proof (prove)\nusing this:\n  snd XX = Set.filter (isSameIntersection tt (fst XX \\<inter> st)) (snd XXX)\n\ngoal (1 subgoal):\n 1. snd XX \\<subseteq> snd XXX", "by auto"], ["proof (state)\nthis:\n  snd XX \\<subseteq> snd XXX\n\ngoal (1 subgoal):\n 1. wf_atable n XXX \\<Longrightarrow> wf_atable n XX", "then"], ["proof (chain)\npicking this:\n  snd XX \\<subseteq> snd XXX", "show ?thesis"], ["proof (prove)\nusing this:\n  snd XX \\<subseteq> snd XXX\n\ngoal (1 subgoal):\n 1. wf_atable n XX", "by (metis wf_atable_subset \\<open>wf_atable n XXX\\<close> calculation(1) wf_atable_def)"], ["proof (state)\nthis:\n  wf_atable n XX\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf_atable n XX\n\ngoal (1 subgoal):\n 1. \\<And>X. X \\<in> QQn \\<Longrightarrow> wf_atable n X", "then"], ["proof (chain)\npicking this:\n  wf_atable n XX", "show \"wf_atable n X\""], ["proof (prove)\nusing this:\n  wf_atable n XX\n\ngoal (1 subgoal):\n 1. wf_atable n X", "by (simp add: wf_projectTable \\<open>X = projectTable J XX\\<close>)"], ["proof (state)\nthis:\n  wf_atable n X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?X \\<in> QQn \\<Longrightarrow> wf_atable n ?X\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>projectQuery J QS. wf_atable n X \\<Longrightarrow>\n    wf_query n J QQ QQn", "then"], ["proof (chain)\npicking this:\n  ?X \\<in> QQn \\<Longrightarrow> wf_atable n ?X", "have \"\\<forall>X\\<in>QQn. wf_atable n X\""], ["proof (prove)\nusing this:\n  ?X \\<in> QQn \\<Longrightarrow> wf_atable n ?X\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>QQn. wf_atable n X", "by blast"], ["proof (state)\nthis:\n  \\<forall>X\\<in>QQn. wf_atable n X\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>projectQuery J QS. wf_atable n X \\<Longrightarrow>\n    wf_query n J QQ QQn", "then"], ["proof (chain)\npicking this:\n  \\<forall>X\\<in>QQn. wf_atable n X", "have \"\\<forall>X\\<in>(QQ \\<union> QQn). wf_atable n X\""], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>QQn. wf_atable n X\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>QQ \\<union> QQn. wf_atable n X", "using QS_def \\<open>QQ = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Q)\\<close> \\<open>\\<forall>X\\<in>projectQuery J QS. wf_atable n X\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>QQn. wf_atable n X\n  QS = (\\<lambda>tab. semiJoin tab (st, tt)) ` Q\n  QQ = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Q)\n  \\<forall>X\\<in>projectQuery J QS. wf_atable n X\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>QQ \\<union> QQn. wf_atable n X", "by blast"], ["proof (state)\nthis:\n  \\<forall>X\\<in>QQ \\<union> QQn. wf_atable n X\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>projectQuery J QS. wf_atable n X \\<Longrightarrow>\n    wf_query n J QQ QQn", "moreover"], ["proof (state)\nthis:\n  \\<forall>X\\<in>QQ \\<union> QQn. wf_atable n X\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>projectQuery J QS. wf_atable n X \\<Longrightarrow>\n    wf_query n J QQ QQn", "have \"card QQ \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> card QQ", "by (metis (no_types, lifting) newQuery.simps One_nat_def Suc_leI \\<open>(st, tt) = t\\<close> assms(2)\n          assms(6) card.infinite card_gt_0_iff finite_imageI image_is_empty wf_query_def)"], ["proof (state)\nthis:\n  1 \\<le> card QQ\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>projectQuery J QS. wf_atable n X \\<Longrightarrow>\n    wf_query n J QQ QQn", "then"], ["proof (chain)\npicking this:\n  1 \\<le> card QQ", "show ?thesis"], ["proof (prove)\nusing this:\n  1 \\<le> card QQ\n\ngoal (1 subgoal):\n 1. wf_query n J QQ QQn", "using assms(2) calculation wf_query_def"], ["proof (prove)\nusing this:\n  1 \\<le> card QQ\n  wf_query n J Q Qn0\n  \\<forall>X\\<in>QQ \\<union> QQn. wf_atable n X\n  wf_query ?n ?V ?Q_pos ?Q_neg =\n  ((\\<forall>X\\<in>?Q_pos \\<union> ?Q_neg. wf_atable ?n X) \\<and>\n   wf_set ?n ?V \\<and> 1 \\<le> card ?Q_pos)\n\ngoal (1 subgoal):\n 1. wf_query n J QQ QQn", "by blast"], ["proof (state)\nthis:\n  wf_query n J QQ QQn\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf_query n J QQ QQn\n\ngoal (1 subgoal):\n 1. rwf_query n J QQ QQn", "moreover"], ["proof (state)\nthis:\n  wf_query n J QQ QQn\n\ngoal (1 subgoal):\n 1. rwf_query n J QQ QQn", "have \"included J QQn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. included J QQn", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. included J QQn", "have \"QQn = projectQuery J (Set.image (\\<lambda>tab. semiJoin tab (st, tt)) Qn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. QQn = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Qn)", "using newQuery_equiv_def \\<open>(st, tt) = t\\<close> assms(7)"], ["proof (prove)\nusing this:\n  newQuery ?V ?Q (?st, ?t) =\n  projectQuery ?V ((\\<lambda>tab. semiJoin tab (?st, ?t)) ` ?Q)\n  (st, tt) = t\n  QQn = newQuery J Qn t\n\ngoal (1 subgoal):\n 1. QQn = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Qn)", "by blast"], ["proof (state)\nthis:\n  QQn = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Qn)\n\ngoal (1 subgoal):\n 1. included J QQn", "then"], ["proof (chain)\npicking this:\n  QQn = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Qn)", "show ?thesis"], ["proof (prove)\nusing this:\n  QQn = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Qn)\n\ngoal (1 subgoal):\n 1. included J QQn", "using included_project"], ["proof (prove)\nusing this:\n  QQn = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Qn)\n  included ?V (projectQuery ?V ?Q)\n\ngoal (1 subgoal):\n 1. included J QQn", "by blast"], ["proof (state)\nthis:\n  included J QQn\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  included J QQn\n\ngoal (1 subgoal):\n 1. rwf_query n J QQ QQn", "moreover"], ["proof (state)\nthis:\n  included J QQn\n\ngoal (1 subgoal):\n 1. rwf_query n J QQ QQn", "have \"covering J QQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. covering J QQ", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. covering J QQ", "have \"QQ = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) `Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. QQ = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Q)", "using \\<open>QQ = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Q)\\<close>"], ["proof (prove)\nusing this:\n  QQ = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Q)\n\ngoal (1 subgoal):\n 1. QQ = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Q)", "by blast"], ["proof (state)\nthis:\n  QQ = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Q)\n\ngoal (1 subgoal):\n 1. covering J QQ", "then"], ["proof (chain)\npicking this:\n  QQ = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Q)", "have \"covering J ((\\<lambda>tab. semiJoin tab (st, tt)) `Q)\""], ["proof (prove)\nusing this:\n  QQ = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Q)\n\ngoal (1 subgoal):\n 1. covering J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Q)", "using QS_def calculation(3)"], ["proof (prove)\nusing this:\n  QQ = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Q)\n  QS = (\\<lambda>tab. semiJoin tab (st, tt)) ` Q\n  covering J QS\n\ngoal (1 subgoal):\n 1. covering J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Q)", "by blast"], ["proof (state)\nthis:\n  covering J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Q)\n\ngoal (1 subgoal):\n 1. covering J QQ", "then"], ["proof (chain)\npicking this:\n  covering J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Q)", "have \"J \\<subseteq> (\\<Union>(S, X)\\<in>(((\\<lambda>tab. semiJoin tab (st, tt)) `Q)). S)\""], ["proof (prove)\nusing this:\n  covering J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Q)\n\ngoal (1 subgoal):\n 1. J \\<subseteq> (\\<Union>(S,\n                      X)\\<in>(\\<lambda>tab. semiJoin tab (st, tt)) ` Q. S)", "by (simp add: covering_def)"], ["proof (state)\nthis:\n  J \\<subseteq> (\\<Union>(S,\n                    X)\\<in>(\\<lambda>tab. semiJoin tab (st, tt)) ` Q. S)\n\ngoal (1 subgoal):\n 1. covering J QQ", "then"], ["proof (chain)\npicking this:\n  J \\<subseteq> (\\<Union>(S,\n                    X)\\<in>(\\<lambda>tab. semiJoin tab (st, tt)) ` Q. S)", "have \"J \\<subseteq> (\\<Union>(S, X)\\<in>(((\\<lambda>tab. semiJoin tab (st, tt)) `Q)). S) \\<inter> J\""], ["proof (prove)\nusing this:\n  J \\<subseteq> (\\<Union>(S,\n                    X)\\<in>(\\<lambda>tab. semiJoin tab (st, tt)) ` Q. S)\n\ngoal (1 subgoal):\n 1. J \\<subseteq> (\\<Union>(S,\n                      X)\\<in>(\\<lambda>tab. semiJoin tab (st, tt)) ` Q.\n                      S) \\<inter>\n                  J", "by blast"], ["proof (state)\nthis:\n  J \\<subseteq> (\\<Union>(S,\n                    X)\\<in>(\\<lambda>tab. semiJoin tab (st, tt)) ` Q.\n                    S) \\<inter>\n                J\n\ngoal (1 subgoal):\n 1. covering J QQ", "moreover"], ["proof (state)\nthis:\n  J \\<subseteq> (\\<Union>(S,\n                    X)\\<in>(\\<lambda>tab. semiJoin tab (st, tt)) ` Q.\n                    S) \\<inter>\n                J\n\ngoal (1 subgoal):\n 1. covering J QQ", "have \"(\\<Union>(S, X)\\<in>(((\\<lambda>tab. semiJoin tab (st, tt)) `Q)). S) \\<inter> J  \\<subseteq> (\\<Union>(S, X)\\<in>(((\\<lambda>tab. semiJoin tab (st, tt)) `Q)). S \\<inter> J)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>(S, X)\\<in>(\\<lambda>tab. semiJoin tab (st, tt)) ` Q.\n        S) \\<inter>\n    J\n    \\<subseteq> (\\<Union>(S,\n                    X)\\<in>(\\<lambda>tab. semiJoin tab (st, tt)) ` Q.\n                    S \\<inter> J)", "using image_cong"], ["proof (prove)\nusing this:\n  \\<lbrakk>?M = ?N;\n   \\<And>x. x \\<in> ?N \\<Longrightarrow> ?f x = ?g x\\<rbrakk>\n  \\<Longrightarrow> ?f ` ?M = ?g ` ?N\n\ngoal (1 subgoal):\n 1. (\\<Union>(S, X)\\<in>(\\<lambda>tab. semiJoin tab (st, tt)) ` Q.\n        S) \\<inter>\n    J\n    \\<subseteq> (\\<Union>(S,\n                    X)\\<in>(\\<lambda>tab. semiJoin tab (st, tt)) ` Q.\n                    S \\<inter> J)", "by auto"], ["proof (state)\nthis:\n  (\\<Union>(S, X)\\<in>(\\<lambda>tab. semiJoin tab (st, tt)) ` Q. S) \\<inter>\n  J\n  \\<subseteq> (\\<Union>(S, X)\\<in>(\\<lambda>tab. semiJoin tab (st, tt)) ` Q.\n                  S \\<inter> J)\n\ngoal (1 subgoal):\n 1. covering J QQ", "then"], ["proof (chain)\npicking this:\n  (\\<Union>(S, X)\\<in>(\\<lambda>tab. semiJoin tab (st, tt)) ` Q. S) \\<inter>\n  J\n  \\<subseteq> (\\<Union>(S, X)\\<in>(\\<lambda>tab. semiJoin tab (st, tt)) ` Q.\n                  S \\<inter> J)", "have \"(\\<Union>(S, X)\\<in>((\\<lambda>tab. semiJoin tab (st, tt)) `Q). S) \\<inter> J  \\<subseteq> (\\<Union>(S, X)\\<in>(projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) `Q)). S)\""], ["proof (prove)\nusing this:\n  (\\<Union>(S, X)\\<in>(\\<lambda>tab. semiJoin tab (st, tt)) ` Q. S) \\<inter>\n  J\n  \\<subseteq> (\\<Union>(S, X)\\<in>(\\<lambda>tab. semiJoin tab (st, tt)) ` Q.\n                  S \\<inter> J)\n\ngoal (1 subgoal):\n 1. (\\<Union>(S, X)\\<in>(\\<lambda>tab. semiJoin tab (st, tt)) ` Q.\n        S) \\<inter>\n    J\n    \\<subseteq> (\\<Union>(S,\n                    X)\\<in>projectQuery J\n                            ((\\<lambda>tab. semiJoin tab (st, tt)) ` Q).\n                    S)", "by auto"], ["proof (state)\nthis:\n  (\\<Union>(S, X)\\<in>(\\<lambda>tab. semiJoin tab (st, tt)) ` Q. S) \\<inter>\n  J\n  \\<subseteq> (\\<Union>(S,\n                  X)\\<in>projectQuery J\n                          ((\\<lambda>tab. semiJoin tab (st, tt)) ` Q).\n                  S)\n\ngoal (1 subgoal):\n 1. covering J QQ", "then"], ["proof (chain)\npicking this:\n  (\\<Union>(S, X)\\<in>(\\<lambda>tab. semiJoin tab (st, tt)) ` Q. S) \\<inter>\n  J\n  \\<subseteq> (\\<Union>(S,\n                  X)\\<in>projectQuery J\n                          ((\\<lambda>tab. semiJoin tab (st, tt)) ` Q).\n                  S)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Union>(S, X)\\<in>(\\<lambda>tab. semiJoin tab (st, tt)) ` Q. S) \\<inter>\n  J\n  \\<subseteq> (\\<Union>(S,\n                  X)\\<in>projectQuery J\n                          ((\\<lambda>tab. semiJoin tab (st, tt)) ` Q).\n                  S)\n\ngoal (1 subgoal):\n 1. covering J QQ", "by (metis \\<open>J \\<subseteq> (\\<Union>(S, X)\\<in>(\\<lambda>tab. semiJoin tab (st, tt)) ` Q. S)\\<close> \\<open>QQ = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Q)\\<close> covering_def inf_absorb2)"], ["proof (state)\nthis:\n  covering J QQ\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  covering J QQ\n\ngoal (1 subgoal):\n 1. rwf_query n J QQ QQn", "moreover"], ["proof (state)\nthis:\n  covering J QQ\n\ngoal (1 subgoal):\n 1. rwf_query n J QQ QQn", "have \"non_empty_query QQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_empty_query QQ", "using QS_def \\<open>QQ = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Q)\\<close>\n      \\<open>\\<forall>X\\<in>QS. 1 \\<le> card (fst X \\<inter> J)\\<close> non_empty_query_def"], ["proof (prove)\nusing this:\n  QS = (\\<lambda>tab. semiJoin tab (st, tt)) ` Q\n  QQ = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Q)\n  \\<forall>X\\<in>QS. 1 \\<le> card (fst X \\<inter> J)\n  non_empty_query ?Q = (\\<forall>X\\<in>?Q. 1 \\<le> card (fst X))\n\ngoal (1 subgoal):\n 1. non_empty_query QQ", "by fastforce"], ["proof (state)\nthis:\n  non_empty_query QQ\n\ngoal (1 subgoal):\n 1. rwf_query n J QQ QQn", "moreover"], ["proof (state)\nthis:\n  non_empty_query QQ\n\ngoal (1 subgoal):\n 1. rwf_query n J QQ QQn", "have \"non_empty_query QQn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_empty_query QQn", "by (metis non_empty_newQuery Un_iff \\<open>(st, tt) = t\\<close> assms(7) assms(9) calculation(1) wf_query_def)"], ["proof (state)\nthis:\n  non_empty_query QQn\n\ngoal (1 subgoal):\n 1. rwf_query n J QQ QQn", "then"], ["proof (chain)\npicking this:\n  non_empty_query QQn", "show ?thesis"], ["proof (prove)\nusing this:\n  non_empty_query QQn\n\ngoal (1 subgoal):\n 1. rwf_query n J QQ QQn", "using included_project \\<open>QQ = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Q)\\<close>\n      calculation(4) calculation(5) calculation(6) calculation(7) rwf_query_def"], ["proof (prove)\nusing this:\n  non_empty_query QQn\n  included ?V (projectQuery ?V ?Q)\n  QQ = projectQuery J ((\\<lambda>tab. semiJoin tab (st, tt)) ` Q)\n  wf_query n J QQ QQn\n  included J QQn\n  covering J QQ\n  non_empty_query QQ\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n\ngoal (1 subgoal):\n 1. rwf_query n J QQ QQn", "by blast"], ["proof (state)\nthis:\n  rwf_query n J QQ QQn\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subset_Q_neg:\n  assumes \"rwf_query n V Q Qn\"\n  assumes \"QQn \\<subseteq> Qn\"\n  shows \"rwf_query n V Q QQn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rwf_query n V Q QQn", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rwf_query n V Q QQn", "have \"wf_query n V Q QQn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_query n V Q QQn", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_query n V Q QQn", "have \"\\<forall>X\\<in>QQn. wf_atable n X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>QQn. wf_atable n X", "by (meson Un_iff assms(1) assms(2) rwf_query_def subsetD wf_query_def)"], ["proof (state)\nthis:\n  \\<forall>X\\<in>QQn. wf_atable n X\n\ngoal (1 subgoal):\n 1. wf_query n V Q QQn", "then"], ["proof (chain)\npicking this:\n  \\<forall>X\\<in>QQn. wf_atable n X", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>X\\<in>QQn. wf_atable n X\n\ngoal (1 subgoal):\n 1. wf_query n V Q QQn", "by (meson UnE UnI1 assms(1) rwf_query_def wf_query_def)"], ["proof (state)\nthis:\n  wf_query n V Q QQn\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf_query n V Q QQn\n\ngoal (1 subgoal):\n 1. rwf_query n V Q QQn", "moreover"], ["proof (state)\nthis:\n  wf_query n V Q QQn\n\ngoal (1 subgoal):\n 1. rwf_query n V Q QQn", "have \"included V QQn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. included V QQn", "by (meson assms(1) assms(2) included_def rwf_query_def subsetD)"], ["proof (state)\nthis:\n  included V QQn\n\ngoal (1 subgoal):\n 1. rwf_query n V Q QQn", "then"], ["proof (chain)\npicking this:\n  included V QQn", "show ?thesis"], ["proof (prove)\nusing this:\n  included V QQn\n\ngoal (1 subgoal):\n 1. rwf_query n V Q QQn", "by (metis (full_types) assms(2) non_empty_query_def subsetD assms(1) calculation rwf_query_def)"], ["proof (state)\nthis:\n  rwf_query n V Q QQn\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_secondRecursiveCalls:\n  assumes \"card V \\<ge> 2\"\n  assumes \"rwf_query n V Q Qn\"\n  assumes \"(I, J) = getIJ Q Qn V\"\n  assumes \"Qns \\<subseteq> Qn\"\n  assumes \"Q_J_neg = filterQuery J Qns\"\n  assumes \"Q_J_pos = filterQuery J Q\"\n  shows \"rwf_query n J (newQuery J Q_J_pos t) (newQuery J Q_J_neg t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rwf_query n J (newQuery J Q_J_pos t) (newQuery J Q_J_neg t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rwf_query n J (newQuery J Q_J_pos t) (newQuery J Q_J_neg t)", "have \"\\<forall>X\\<in>Q_J_pos. card (fst X \\<inter> J) \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>Q_J_pos. 1 \\<le> card (fst X \\<inter> J)", "using set_filterQuery assms(2) assms(6) rwf_query_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?QQ = filterQuery ?I ?Q; non_empty_query ?Q\\<rbrakk>\n  \\<Longrightarrow> \\<forall>X\\<in>?Q.\n                       (1 \\<le> card (fst X \\<inter> ?I)) = (X \\<in> ?QQ)\n  rwf_query n V Q Qn\n  Q_J_pos = filterQuery J Q\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>Q_J_pos. 1 \\<le> card (fst X \\<inter> J)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>X\\<in>Q_J_pos. 1 \\<le> card (fst X \\<inter> J)\n\ngoal (1 subgoal):\n 1. rwf_query n J (newQuery J Q_J_pos t) (newQuery J Q_J_neg t)", "moreover"], ["proof (state)\nthis:\n  \\<forall>X\\<in>Q_J_pos. 1 \\<le> card (fst X \\<inter> J)\n\ngoal (1 subgoal):\n 1. rwf_query n J (newQuery J Q_J_pos t) (newQuery J Q_J_neg t)", "have \"card J \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> card J", "by (metis assms(1) assms(3) getIJ.coreProperties getIJ_axioms)"], ["proof (state)\nthis:\n  1 \\<le> card J\n\ngoal (1 subgoal):\n 1. rwf_query n J (newQuery J Q_J_pos t) (newQuery J Q_J_neg t)", "moreover"], ["proof (state)\nthis:\n  1 \\<le> card J\n\ngoal (1 subgoal):\n 1. rwf_query n J (newQuery J Q_J_pos t) (newQuery J Q_J_neg t)", "have \"wf_query n J Q_J_pos Qns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_query n J Q_J_pos Qns", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_query n J Q_J_pos Qns", "have \"wf_query n J Q Qns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_query n J Q Qns", "by (metis subset_Q_neg wf_set_subset assms(1) assms(2) assms(3) assms(4)\n          getIJ.coreProperties getIJ_axioms rwf_query_def sup_ge2 wf_query_def)"], ["proof (state)\nthis:\n  wf_query n J Q Qns\n\ngoal (1 subgoal):\n 1. wf_query n J Q_J_pos Qns", "moreover"], ["proof (state)\nthis:\n  wf_query n J Q Qns\n\ngoal (1 subgoal):\n 1. wf_query n J Q_J_pos Qns", "have \"Q_J_pos \\<subseteq> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q_J_pos \\<subseteq> Q", "using assms(6)"], ["proof (prove)\nusing this:\n  Q_J_pos = filterQuery J Q\n\ngoal (1 subgoal):\n 1. Q_J_pos \\<subseteq> Q", "by auto"], ["proof (state)\nthis:\n  Q_J_pos \\<subseteq> Q\n\ngoal (1 subgoal):\n 1. wf_query n J Q_J_pos Qns", "then"], ["proof (chain)\npicking this:\n  Q_J_pos \\<subseteq> Q", "have \"\\<forall>X\\<in>(Q_J_pos \\<union> Qns). wf_atable n X\""], ["proof (prove)\nusing this:\n  Q_J_pos \\<subseteq> Q\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>Q_J_pos \\<union> Qns. wf_atable n X", "using calculation wf_query_def"], ["proof (prove)\nusing this:\n  Q_J_pos \\<subseteq> Q\n  wf_query n J Q Qns\n  wf_query ?n ?V ?Q_pos ?Q_neg =\n  ((\\<forall>X\\<in>?Q_pos \\<union> ?Q_neg. wf_atable ?n X) \\<and>\n   wf_set ?n ?V \\<and> 1 \\<le> card ?Q_pos)\n\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>Q_J_pos \\<union> Qns. wf_atable n X", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>X\\<in>Q_J_pos \\<union> Qns. wf_atable n X\n\ngoal (1 subgoal):\n 1. wf_query n J Q_J_pos Qns", "moreover"], ["proof (state)\nthis:\n  \\<forall>X\\<in>Q_J_pos \\<union> Qns. wf_atable n X\n\ngoal (1 subgoal):\n 1. wf_query n J Q_J_pos Qns", "have \"card Q_J_pos \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> card Q_J_pos", "by (metis wf_filterQuery(1) assms(1) assms(2) assms(3) assms(6) getIJ.coreProperties\n          getIJ_axioms sup_ge2 wf_query_def)"], ["proof (state)\nthis:\n  1 \\<le> card Q_J_pos\n\ngoal (1 subgoal):\n 1. wf_query n J Q_J_pos Qns", "then"], ["proof (chain)\npicking this:\n  1 \\<le> card Q_J_pos", "show ?thesis"], ["proof (prove)\nusing this:\n  1 \\<le> card Q_J_pos\n\ngoal (1 subgoal):\n 1. wf_query n J Q_J_pos Qns", "using calculation(1) calculation(2) wf_query_def"], ["proof (prove)\nusing this:\n  1 \\<le> card Q_J_pos\n  wf_query n J Q Qns\n  \\<forall>X\\<in>Q_J_pos \\<union> Qns. wf_atable n X\n  wf_query ?n ?V ?Q_pos ?Q_neg =\n  ((\\<forall>X\\<in>?Q_pos \\<union> ?Q_neg. wf_atable ?n X) \\<and>\n   wf_set ?n ?V \\<and> 1 \\<le> card ?Q_pos)\n\ngoal (1 subgoal):\n 1. wf_query n J Q_J_pos Qns", "by blast"], ["proof (state)\nthis:\n  wf_query n J Q_J_pos Qns\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf_query n J Q_J_pos Qns\n\ngoal (1 subgoal):\n 1. rwf_query n J (newQuery J Q_J_pos t) (newQuery J Q_J_neg t)", "moreover"], ["proof (state)\nthis:\n  wf_query n J Q_J_pos Qns\n\ngoal (1 subgoal):\n 1. rwf_query n J (newQuery J Q_J_pos t) (newQuery J Q_J_neg t)", "have \"non_empty_query Q_J_pos\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_empty_query Q_J_pos", "by (metis wf_filterQuery(2) assms(1) assms(2) assms(3) assms(6) getIJ.coreProperties\n        getIJ_axioms sup_ge2)"], ["proof (state)\nthis:\n  non_empty_query Q_J_pos\n\ngoal (1 subgoal):\n 1. rwf_query n J (newQuery J Q_J_pos t) (newQuery J Q_J_neg t)", "moreover"], ["proof (state)\nthis:\n  non_empty_query Q_J_pos\n\ngoal (1 subgoal):\n 1. rwf_query n J (newQuery J Q_J_pos t) (newQuery J Q_J_neg t)", "have  \"covering J Q_J_pos\""], ["proof (prove)\ngoal (1 subgoal):\n 1. covering J Q_J_pos", "by (metis wf_filterQuery(3) assms(1) assms(2) assms(3) assms(6) getIJ.coreProperties\n        getIJ_axioms sup_ge2)"], ["proof (state)\nthis:\n  covering J Q_J_pos\n\ngoal (1 subgoal):\n 1. rwf_query n J (newQuery J Q_J_pos t) (newQuery J Q_J_neg t)", "moreover"], ["proof (state)\nthis:\n  covering J Q_J_pos\n\ngoal (1 subgoal):\n 1. rwf_query n J (newQuery J Q_J_pos t) (newQuery J Q_J_neg t)", "have \"non_empty_query Q_J_neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_empty_query Q_J_neg", "by (metis (no_types, lifting) filterQuery.elims assms(2) assms(4) assms(5) member_filter\n        non_empty_query_def rwf_query_def subsetD)"], ["proof (state)\nthis:\n  non_empty_query Q_J_neg\n\ngoal (1 subgoal):\n 1. rwf_query n J (newQuery J Q_J_pos t) (newQuery J Q_J_neg t)", "then"], ["proof (chain)\npicking this:\n  non_empty_query Q_J_neg", "show ?thesis"], ["proof (prove)\nusing this:\n  non_empty_query Q_J_neg\n\ngoal (1 subgoal):\n 1. rwf_query n J (newQuery J Q_J_pos t) (newQuery J Q_J_neg t)", "using wf_newQuery assms(5) calculation(1) calculation(2) calculation(3) calculation(4)\n      calculation(5)"], ["proof (prove)\nusing this:\n  non_empty_query Q_J_neg\n  \\<lbrakk>1 \\<le> card ?J; wf_query ?n ?J ?Q ?Qn0.0; non_empty_query ?Q;\n   covering ?J ?Q; \\<forall>X\\<in>?Q. 1 \\<le> card (fst X \\<inter> ?J);\n   ?QQ = newQuery ?J ?Q ?t; ?QQn = newQuery ?J ?Qn ?t; non_empty_query ?Qn;\n   ?Qn = filterQuery ?J ?Qn0.0\\<rbrakk>\n  \\<Longrightarrow> rwf_query ?n ?J ?QQ ?QQn\n  Q_J_neg = filterQuery J Qns\n  \\<forall>X\\<in>Q_J_pos. 1 \\<le> card (fst X \\<inter> J)\n  1 \\<le> card J\n  wf_query n J Q_J_pos Qns\n  non_empty_query Q_J_pos\n  covering J Q_J_pos\n\ngoal (1 subgoal):\n 1. rwf_query n J (newQuery J Q_J_pos t) (newQuery J Q_J_neg t)", "by blast"], ["proof (state)\nthis:\n  rwf_query n J (newQuery J Q_J_pos t) (newQuery J Q_J_neg t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simple_merge_option:\n  \"merge_option (a, b) = None \\<longleftrightarrow> (a = None \\<and> b = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (merge_option (a, b) = None) = (a = None \\<and> b = None)", "using merge_option.elims"], ["proof (prove)\nusing this:\n  \\<lbrakk>merge_option ?x = ?y;\n   \\<lbrakk>?x = (None, None); ?y = None\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>x.\n      \\<lbrakk>?x = (Some x, None); ?y = Some x\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>x.\n      \\<lbrakk>?x = (None, Some x); ?y = Some x\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>a b.\n      \\<lbrakk>?x = (Some a, Some b); ?y = Some a\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (merge_option (a, b) = None) = (a = None \\<and> b = None)", "by blast"], ["", "lemma wf_merge:\n  assumes \"wf_tuple n I t1\"\n  assumes \"wf_tuple n J t2\"\n  assumes \"V = I \\<union> J\"\n  assumes \"t = merge t1 t2\"\n  shows \"wf_tuple n V t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple n V t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_tuple n V t", "have \"\\<And>i. i < n \\<Longrightarrow> (t ! i = None \\<longleftrightarrow> i \\<notin> V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> (t ! i = None) = (i \\<notin> V)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> (t ! i = None) = (i \\<notin> V)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> (t ! i = None) = (i \\<notin> V)", "assume \"i < n\""], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> (t ! i = None) = (i \\<notin> V)", "show \"t ! i = None \\<longleftrightarrow> i \\<notin> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t ! i = None) = (i \\<notin> V)", "proof (cases \"t ! i = None\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t ! i = None \\<Longrightarrow> (t ! i = None) = (i \\<notin> V)\n 2. t ! i \\<noteq> None \\<Longrightarrow> (t ! i = None) = (i \\<notin> V)", "case True"], ["proof (state)\nthis:\n  t ! i = None\n\ngoal (2 subgoals):\n 1. t ! i = None \\<Longrightarrow> (t ! i = None) = (i \\<notin> V)\n 2. t ! i \\<noteq> None \\<Longrightarrow> (t ! i = None) = (i \\<notin> V)", "have \"t = merge t1 t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = merge t1 t2", "by (simp add: assms(4))"], ["proof (state)\nthis:\n  t = merge t1 t2\n\ngoal (2 subgoals):\n 1. t ! i = None \\<Longrightarrow> (t ! i = None) = (i \\<notin> V)\n 2. t ! i \\<noteq> None \\<Longrightarrow> (t ! i = None) = (i \\<notin> V)", "then"], ["proof (chain)\npicking this:\n  t = merge t1 t2", "have \"... = map merge_option (zip t1 t2)\""], ["proof (prove)\nusing this:\n  t = merge t1 t2\n\ngoal (1 subgoal):\n 1. merge t1 t2 = map merge_option (zip t1 t2)", "by simp"], ["proof (state)\nthis:\n  merge t1 t2 = map merge_option (zip t1 t2)\n\ngoal (2 subgoals):\n 1. t ! i = None \\<Longrightarrow> (t ! i = None) = (i \\<notin> V)\n 2. t ! i \\<noteq> None \\<Longrightarrow> (t ! i = None) = (i \\<notin> V)", "then"], ["proof (chain)\npicking this:\n  merge t1 t2 = map merge_option (zip t1 t2)", "have \"merge_option (t1 ! i, t2 ! i) = None\""], ["proof (prove)\nusing this:\n  merge t1 t2 = map merge_option (zip t1 t2)\n\ngoal (1 subgoal):\n 1. merge_option (t1 ! i, t2 ! i) = None", "by (metis True \\<open>i < n\\<close> assms(1) assms(2) assms(4) length_zip min_less_iff_conj nth_map nth_zip wf_tuple_def)"], ["proof (state)\nthis:\n  merge_option (t1 ! i, t2 ! i) = None\n\ngoal (2 subgoals):\n 1. t ! i = None \\<Longrightarrow> (t ! i = None) = (i \\<notin> V)\n 2. t ! i \\<noteq> None \\<Longrightarrow> (t ! i = None) = (i \\<notin> V)", "obtain \"t1 ! i = None\" and \"t2 ! i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>t1 ! i = None; t2 ! i = None\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson \\<open>merge_option (t1 ! i, t2 ! i) = None\\<close> simple_merge_option)"], ["proof (state)\nthis:\n  t1 ! i = None\n  t2 ! i = None\n\ngoal (2 subgoals):\n 1. t ! i = None \\<Longrightarrow> (t ! i = None) = (i \\<notin> V)\n 2. t ! i \\<noteq> None \\<Longrightarrow> (t ! i = None) = (i \\<notin> V)", "then"], ["proof (chain)\npicking this:\n  t1 ! i = None\n  t2 ! i = None", "show ?thesis"], ["proof (prove)\nusing this:\n  t1 ! i = None\n  t2 ! i = None\n\ngoal (1 subgoal):\n 1. (t ! i = None) = (i \\<notin> V)", "using True \\<open>i < n\\<close> assms(1) assms(2) assms(3) wf_tuple_def"], ["proof (prove)\nusing this:\n  t1 ! i = None\n  t2 ! i = None\n  t ! i = None\n  i < n\n  wf_tuple n I t1\n  wf_tuple n J t2\n  V = I \\<union> J\n  wf_tuple ?n ?V ?x =\n  (length ?x = ?n \\<and> (\\<forall>i<?n. (?x ! i = None) = (i \\<notin> ?V)))\n\ngoal (1 subgoal):\n 1. (t ! i = None) = (i \\<notin> V)", "by auto"], ["proof (state)\nthis:\n  (t ! i = None) = (i \\<notin> V)\n\ngoal (1 subgoal):\n 1. t ! i \\<noteq> None \\<Longrightarrow> (t ! i = None) = (i \\<notin> V)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t ! i \\<noteq> None \\<Longrightarrow> (t ! i = None) = (i \\<notin> V)", "case False"], ["proof (state)\nthis:\n  t ! i \\<noteq> None\n\ngoal (1 subgoal):\n 1. t ! i \\<noteq> None \\<Longrightarrow> (t ! i = None) = (i \\<notin> V)", "have \"t = map merge_option (zip t1 t2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = map merge_option (zip t1 t2)", "by (simp add: assms(4))"], ["proof (state)\nthis:\n  t = map merge_option (zip t1 t2)\n\ngoal (1 subgoal):\n 1. t ! i \\<noteq> None \\<Longrightarrow> (t ! i = None) = (i \\<notin> V)", "then"], ["proof (chain)\npicking this:\n  t = map merge_option (zip t1 t2)", "obtain x where \"merge_option (t1 ! i, t2 ! i) = Some x\""], ["proof (prove)\nusing this:\n  t = map merge_option (zip t1 t2)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        merge_option (t1 ! i, t2 ! i) = Some x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis False \\<open>i < n\\<close> assms(1) assms(2) length_zip merge_option.elims min_less_iff_conj nth_map nth_zip wf_tuple_def)"], ["proof (state)\nthis:\n  merge_option (t1 ! i, t2 ! i) = Some x\n\ngoal (1 subgoal):\n 1. t ! i \\<noteq> None \\<Longrightarrow> (t ! i = None) = (i \\<notin> V)", "then"], ["proof (chain)\npicking this:\n  merge_option (t1 ! i, t2 ! i) = Some x", "show ?thesis"], ["proof (prove)\nusing this:\n  merge_option (t1 ! i, t2 ! i) = Some x\n\ngoal (1 subgoal):\n 1. (t ! i = None) = (i \\<notin> V)", "by (metis False UnI1 UnI2 \\<open>i < n\\<close> assms(1) assms(2) assms(3) option.distinct(1) simple_merge_option wf_tuple_def)"], ["proof (state)\nthis:\n  (t ! i = None) = (i \\<notin> V)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (t ! i = None) = (i \\<notin> V)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> (t ! ?i = None) = (?i \\<notin> V)\n\ngoal (1 subgoal):\n 1. wf_tuple n V t", "moreover"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> (t ! ?i = None) = (?i \\<notin> V)\n\ngoal (1 subgoal):\n 1. wf_tuple n V t", "have \"length t = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length t = n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length t = n", "obtain \"length t1 = n\" and \"length t2 = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>length t1 = n; length t2 = n\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1) assms(2) wf_tuple_def"], ["proof (prove)\nusing this:\n  wf_tuple n I t1\n  wf_tuple n J t2\n  wf_tuple ?n ?V ?x =\n  (length ?x = ?n \\<and> (\\<forall>i<?n. (?x ! i = None) = (i \\<notin> ?V)))\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>length t1 = n; length t2 = n\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  length t1 = n\n  length t2 = n\n\ngoal (1 subgoal):\n 1. length t = n", "then"], ["proof (chain)\npicking this:\n  length t1 = n\n  length t2 = n", "have \"length (zip t1 t2) = n\""], ["proof (prove)\nusing this:\n  length t1 = n\n  length t2 = n\n\ngoal (1 subgoal):\n 1. length (zip t1 t2) = n", "by simp"], ["proof (state)\nthis:\n  length (zip t1 t2) = n\n\ngoal (1 subgoal):\n 1. length t = n", "then"], ["proof (chain)\npicking this:\n  length (zip t1 t2) = n", "show ?thesis"], ["proof (prove)\nusing this:\n  length (zip t1 t2) = n\n\ngoal (1 subgoal):\n 1. length t = n", "by (simp add: assms(4))"], ["proof (state)\nthis:\n  length t = n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length t = n\n\ngoal (1 subgoal):\n 1. wf_tuple n V t", "then"], ["proof (chain)\npicking this:\n  length t = n", "show ?thesis"], ["proof (prove)\nusing this:\n  length t = n\n\ngoal (1 subgoal):\n 1. wf_tuple n V t", "by (simp add: calculation wf_tuple_def)"], ["proof (state)\nthis:\n  wf_tuple n V t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_inter:\n  assumes \"rwf_query n {i} Q Qn\"\n  assumes \"(sa, a) \\<in> Q\"\n  assumes \"(sb, b) \\<in> Q\"\n  shows \"table n {i} (a \\<inter> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. table n {i} (a \\<inter> b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. table n {i} (a \\<inter> b)", "obtain \"card sa \\<ge> 1\" \"card sb \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>1 \\<le> card sa; 1 \\<le> card sb\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis assms(1) assms(2) assms(3) fst_conv non_empty_query_def rwf_query_def)"], ["proof (state)\nthis:\n  1 \\<le> card sa\n  1 \\<le> card sb\n\ngoal (1 subgoal):\n 1. table n {i} (a \\<inter> b)", "have \"included {i} Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. included {i} Q", "using assms(1) rwf_query_def"], ["proof (prove)\nusing this:\n  rwf_query n {i} Q Qn\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n\ngoal (1 subgoal):\n 1. included {i} Q", "by blast"], ["proof (state)\nthis:\n  included {i} Q\n\ngoal (1 subgoal):\n 1. table n {i} (a \\<inter> b)", "then"], ["proof (chain)\npicking this:\n  included {i} Q", "have \"(\\<forall>(S, X)\\<in>Q. S \\<subseteq> {i})\""], ["proof (prove)\nusing this:\n  included {i} Q\n\ngoal (1 subgoal):\n 1. \\<forall>(S, X)\\<in>Q. S \\<subseteq> {i}", "by (simp add: included_def)"], ["proof (state)\nthis:\n  \\<forall>(S, X)\\<in>Q. S \\<subseteq> {i}\n\ngoal (1 subgoal):\n 1. table n {i} (a \\<inter> b)", "then"], ["proof (chain)\npicking this:\n  \\<forall>(S, X)\\<in>Q. S \\<subseteq> {i}", "obtain \"sa \\<subseteq> {i}\" \"sb \\<subseteq> {i}\""], ["proof (prove)\nusing this:\n  \\<forall>(S, X)\\<in>Q. S \\<subseteq> {i}\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>sa \\<subseteq> {i}; sb \\<subseteq> {i}\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2) assms(3)"], ["proof (prove)\nusing this:\n  \\<forall>(S, X)\\<in>Q. S \\<subseteq> {i}\n  (sa, a) \\<in> Q\n  (sb, b) \\<in> Q\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>sa \\<subseteq> {i}; sb \\<subseteq> {i}\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  sa \\<subseteq> {i}\n  sb \\<subseteq> {i}\n\ngoal (1 subgoal):\n 1. table n {i} (a \\<inter> b)", "then"], ["proof (chain)\npicking this:\n  sa \\<subseteq> {i}\n  sb \\<subseteq> {i}", "obtain \"sa = {i}\" \"sb = {i}\""], ["proof (prove)\nusing this:\n  sa \\<subseteq> {i}\n  sb \\<subseteq> {i}\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>sa = {i}; sb = {i}\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \\<open>1 \\<le> card sa\\<close> \\<open>1 \\<le> card sb\\<close> card.empty not_one_le_zero subset_singletonD)"], ["proof (state)\nthis:\n  sa = {i}\n  sb = {i}\n\ngoal (1 subgoal):\n 1. table n {i} (a \\<inter> b)", "then"], ["proof (chain)\npicking this:\n  sa = {i}\n  sb = {i}", "show ?thesis"], ["proof (prove)\nusing this:\n  sa = {i}\n  sb = {i}\n\ngoal (1 subgoal):\n 1. table n {i} (a \\<inter> b)", "using assms(1) assms(2) inf_le1 prod.sel(1) prod.sel(2) rwf_query_def wf_atable_def\n      wf_atable_subset wf_query_def Un_iff"], ["proof (prove)\nusing this:\n  sa = {i}\n  sb = {i}\n  rwf_query n {i} Q Qn\n  (sa, a) \\<in> Q\n  inf ?x ?y \\<le> ?x\n  fst (?x1.0, ?x2.0) = ?x1.0\n  snd (?x1.0, ?x2.0) = ?x2.0\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n  wf_atable ?n ?X = (table ?n (fst ?X) (snd ?X) \\<and> finite (fst ?X))\n  \\<lbrakk>table ?n ?V ?X; ?Y \\<subseteq> ?X\\<rbrakk>\n  \\<Longrightarrow> table ?n ?V ?Y\n  wf_query ?n ?V ?Q_pos ?Q_neg =\n  ((\\<forall>X\\<in>?Q_pos \\<union> ?Q_neg. wf_atable ?n X) \\<and>\n   wf_set ?n ?V \\<and> 1 \\<le> card ?Q_pos)\n  (?c \\<in> ?A \\<union> ?B) = (?c \\<in> ?A \\<or> ?c \\<in> ?B)\n\ngoal (1 subgoal):\n 1. table n {i} (a \\<inter> b)", "by metis"], ["proof (state)\nthis:\n  table n {i} (a \\<inter> b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma table_subset:\n  assumes \"table n V T\"\n  assumes \"S \\<subseteq> T\"\n  shows \"table n V S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. table n V S", "using wf_atable_subset assms(1) assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>table ?n ?V ?X; ?Y \\<subseteq> ?X\\<rbrakk>\n  \\<Longrightarrow> table ?n ?V ?Y\n  table n V T\n  S \\<subseteq> T\n\ngoal (1 subgoal):\n 1. table n V S", "by blast"], ["", "lemma wf_base_case:\n  assumes \"card V = 1\"\n  assumes \"rwf_query n V Q Qn\"\n  assumes \"R = genericJoin V Q Qn\"\n  shows \"table n V R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. table n V R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. table n V R", "have \"wf_query n V Q Qn \\<and> included V Q \\<and> non_empty_query Q \\<Longrightarrow> table n V ((\\<Inter>(_, x) \\<in> Q. x) - (\\<Union>(_, x) \\<in> Qn. x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_query n V Q Qn \\<and>\n    included V Q \\<and> non_empty_query Q \\<Longrightarrow>\n    table n V ((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x))", "proof (induction \"card Q - 1\" arbitrary: Q)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q.\n       \\<lbrakk>0 = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))\n 2. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "case 0"], ["proof (state)\nthis:\n  0 = card Q - 1\n  wf_query n V Q Qn \\<and> included V Q \\<and> non_empty_query Q\n\ngoal (2 subgoals):\n 1. \\<And>Q.\n       \\<lbrakk>0 = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))\n 2. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "have \"card Q = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card Q = 1", "by (metis \"0.hyps\" \"0.prems\" One_nat_def le_add_diff_inverse plus_1_eq_Suc wf_query_def)"], ["proof (state)\nthis:\n  card Q = 1\n\ngoal (2 subgoals):\n 1. \\<And>Q.\n       \\<lbrakk>0 = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))\n 2. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "obtain s x where \"Q = {(s, x)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s x. Q = {(s, x)} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis One_nat_def \\<open>card Q = 1\\<close> card_eq_0_iff card_eq_SucD card_mono finite_insert insertE\n          nat.simps(3) not_one_le_zero subrelI)"], ["proof (state)\nthis:\n  Q = {(s, x)}\n\ngoal (2 subgoals):\n 1. \\<And>Q.\n       \\<lbrakk>0 = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))\n 2. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "moreover"], ["proof (state)\nthis:\n  Q = {(s, x)}\n\ngoal (2 subgoals):\n 1. \\<And>Q.\n       \\<lbrakk>0 = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))\n 2. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "obtain i where \"V = {i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. V = {i} \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using assms(1) card_1_singletonE"], ["proof (prove)\nusing this:\n  card V = 1\n  \\<lbrakk>card ?A = 1; \\<And>x. ?A = {x} \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>i. V = {i} \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  V = {i}\n\ngoal (2 subgoals):\n 1. \\<And>Q.\n       \\<lbrakk>0 = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))\n 2. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "then"], ["proof (chain)\npicking this:\n  V = {i}", "have \"card s \\<ge> 1\""], ["proof (prove)\nusing this:\n  V = {i}\n\ngoal (1 subgoal):\n 1. 1 \\<le> card s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. V = {i} \\<Longrightarrow> 1 \\<le> card s", "have \"(s, x) \\<in> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, x) \\<in> Q", "by (simp add: calculation)"], ["proof (state)\nthis:\n  (s, x) \\<in> Q\n\ngoal (1 subgoal):\n 1. V = {i} \\<Longrightarrow> 1 \\<le> card s", "moreover"], ["proof (state)\nthis:\n  (s, x) \\<in> Q\n\ngoal (1 subgoal):\n 1. V = {i} \\<Longrightarrow> 1 \\<le> card s", "obtain X where \"X = (s, x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X. X = (s, x) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by simp"], ["proof (state)\nthis:\n  X = (s, x)\n\ngoal (1 subgoal):\n 1. V = {i} \\<Longrightarrow> 1 \\<le> card s", "then"], ["proof (chain)\npicking this:\n  X = (s, x)", "show ?thesis"], ["proof (prove)\nusing this:\n  X = (s, x)\n\ngoal (1 subgoal):\n 1. 1 \\<le> card s", "using \"0.prems\" calculation non_empty_query_def rwf_query_def"], ["proof (prove)\nusing this:\n  X = (s, x)\n  wf_query n V Q Qn \\<and> included V Q \\<and> non_empty_query Q\n  (s, x) \\<in> Q\n  non_empty_query ?Q = (\\<forall>X\\<in>?Q. 1 \\<le> card (fst X))\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n\ngoal (1 subgoal):\n 1. 1 \\<le> card s", "by fastforce"], ["proof (state)\nthis:\n  1 \\<le> card s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 \\<le> card s\n\ngoal (2 subgoals):\n 1. \\<And>Q.\n       \\<lbrakk>0 = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))\n 2. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "moreover"], ["proof (state)\nthis:\n  1 \\<le> card s\n\ngoal (2 subgoals):\n 1. \\<And>Q.\n       \\<lbrakk>0 = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))\n 2. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "obtain i where \"V = {i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. V = {i} \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using \\<open>\\<And>thesis. (\\<And>i. V = {i} \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\\<close>"], ["proof (prove)\nusing this:\n  (\\<And>i. V = {i} \\<Longrightarrow> ?thesis) \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>i. V = {i} \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  V = {i}\n\ngoal (2 subgoals):\n 1. \\<And>Q.\n       \\<lbrakk>0 = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))\n 2. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "then"], ["proof (chain)\npicking this:\n  V = {i}", "have \"s = {i}\""], ["proof (prove)\nusing this:\n  V = {i}\n\ngoal (1 subgoal):\n 1. s = {i}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. V = {i} \\<Longrightarrow> s = {i}", "have \"included {i} Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. included {i} Q", "using \"0.prems\" \\<open>V = {i}\\<close> rwf_query_def"], ["proof (prove)\nusing this:\n  wf_query n V Q Qn \\<and> included V Q \\<and> non_empty_query Q\n  V = {i}\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n\ngoal (1 subgoal):\n 1. included {i} Q", "by simp"], ["proof (state)\nthis:\n  included {i} Q\n\ngoal (1 subgoal):\n 1. V = {i} \\<Longrightarrow> s = {i}", "then"], ["proof (chain)\npicking this:\n  included {i} Q", "show ?thesis"], ["proof (prove)\nusing this:\n  included {i} Q\n\ngoal (1 subgoal):\n 1. s = {i}", "by (metis \\<open>V = {i}\\<close> assms(1) calculation(1) calculation(2) card_seteq case_prodD finite.emptyI finite.insertI included_def singletonI)"], ["proof (state)\nthis:\n  s = {i}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s = {i}\n\ngoal (2 subgoals):\n 1. \\<And>Q.\n       \\<lbrakk>0 = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))\n 2. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "moreover"], ["proof (state)\nthis:\n  s = {i}\n\ngoal (2 subgoals):\n 1. \\<And>Q.\n       \\<lbrakk>0 = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))\n 2. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "have \"table n s x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. table n s x", "using \"0.prems\" calculation(1) rwf_query_def wf_atable_def wf_query_def"], ["proof (prove)\nusing this:\n  wf_query n V Q Qn \\<and> included V Q \\<and> non_empty_query Q\n  Q = {(s, x)}\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n  wf_atable ?n ?X = (table ?n (fst ?X) (snd ?X) \\<and> finite (fst ?X))\n  wf_query ?n ?V ?Q_pos ?Q_neg =\n  ((\\<forall>X\\<in>?Q_pos \\<union> ?Q_neg. wf_atable ?n X) \\<and>\n   wf_set ?n ?V \\<and> 1 \\<le> card ?Q_pos)\n\ngoal (1 subgoal):\n 1. table n s x", "by (simp add: rwf_query_def wf_atable_def wf_query_def)"], ["proof (state)\nthis:\n  table n s x\n\ngoal (2 subgoals):\n 1. \\<And>Q.\n       \\<lbrakk>0 = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))\n 2. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "then"], ["proof (chain)\npicking this:\n  table n s x", "show ?case"], ["proof (prove)\nusing this:\n  table n s x\n\ngoal (1 subgoal):\n 1. table n V\n     ((\\<Inter>a\\<in>Q. case a of (uu_, x) \\<Rightarrow> x) -\n      (\\<Union>a\\<in>Qn. case a of (uu_, x) \\<Rightarrow> x))", "by (simp add: wf_atable_subset \\<open>V = {i}\\<close> calculation(1) calculation(3))"], ["proof (state)\nthis:\n  table n V\n   ((\\<Inter>a\\<in>Q. case a of (uu_, x) \\<Rightarrow> x) -\n    (\\<Union>a\\<in>Qn. case a of (uu_, x) \\<Rightarrow> x))\n\ngoal (1 subgoal):\n 1. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "case (Suc y)"], ["proof (state)\nthis:\n  \\<lbrakk>y = card ?Q - 1;\n   wf_query n V ?Q Qn \\<and>\n   included V ?Q \\<and> non_empty_query ?Q\\<rbrakk>\n  \\<Longrightarrow> table n V\n                     ((\\<Inter>(uu_, x)\\<in>?Q. x) -\n                      (\\<Union>(uu_, x)\\<in>Qn. x))\n  Suc y = card Q - 1\n  wf_query n V Q Qn \\<and> included V Q \\<and> non_empty_query Q\n\ngoal (1 subgoal):\n 1. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "obtain xx where \"xx \\<in> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xx. xx \\<in> Q \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (metis Suc.hyps(2) all_not_in_conv card.empty nat.simps(3) zero_diff)"], ["proof (state)\nthis:\n  xx \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "moreover"], ["proof (state)\nthis:\n  xx \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "obtain H where \"H = Q - {xx}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>H. H = Q - {xx} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  H = Q - {xx}\n\ngoal (1 subgoal):\n 1. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "then"], ["proof (chain)\npicking this:\n  H = Q - {xx}", "have \"card H - 1 = y\""], ["proof (prove)\nusing this:\n  H = Q - {xx}\n\ngoal (1 subgoal):\n 1. card H - 1 = y", "by (metis Suc.hyps(2) calculation card_Diff_singleton card.infinite diff_Suc_1 less_imp_le not_one_le_zero zero_less_Suc zero_less_diff)"], ["proof (state)\nthis:\n  card H - 1 = y\n\ngoal (1 subgoal):\n 1. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "moreover"], ["proof (state)\nthis:\n  card H - 1 = y\n\ngoal (1 subgoal):\n 1. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "have \"wf_query n V H Qn \\<and> included V H \\<and> non_empty_query H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_query n V H Qn \\<and> included V H \\<and> non_empty_query H", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_query n V H Qn \\<and> included V H \\<and> non_empty_query H", "have \"wf_query n V H Qn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_query n V H Qn", "using DiffD1 Suc.hyps(2) Suc.prems \\<open>H = Q - {xx}\\<close> calculation(1) card_Diff_singleton\n          card.infinite le_add1 not_one_le_zero plus_1_eq_Suc wf_query_def"], ["proof (prove)\nusing this:\n  ?c \\<in> ?A - ?B \\<Longrightarrow> ?c \\<in> ?A\n  Suc y = card Q - 1\n  wf_query n V Q Qn \\<and> included V Q \\<and> non_empty_query Q\n  H = Q - {xx}\n  xx \\<in> Q\n  \\<lbrakk>finite ?A; ?x \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> card (?A - {?x}) = card ?A - 1\n  infinite ?A \\<Longrightarrow> card ?A = 0\n  ?n \\<le> ?n + ?m\n  \\<not> (1::?'a) \\<le> (0::?'a)\n  (+) 1 = Suc\n  wf_query ?n ?V ?Q_pos ?Q_neg =\n  ((\\<forall>X\\<in>?Q_pos \\<union> ?Q_neg. wf_atable ?n X) \\<and>\n   wf_set ?n ?V \\<and> 1 \\<le> card ?Q_pos)\n\ngoal (1 subgoal):\n 1. wf_query n V H Qn", "by (metis (no_types, lifting) Un_iff)"], ["proof (state)\nthis:\n  wf_query n V H Qn\n\ngoal (1 subgoal):\n 1. wf_query n V H Qn \\<and> included V H \\<and> non_empty_query H", "then"], ["proof (chain)\npicking this:\n  wf_query n V H Qn", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_query n V H Qn\n\ngoal (1 subgoal):\n 1. wf_query n V H Qn \\<and> included V H \\<and> non_empty_query H", "using DiffD1 Suc.prems \\<open>H = Q - {xx}\\<close> included_def non_empty_query_def"], ["proof (prove)\nusing this:\n  wf_query n V H Qn\n  ?c \\<in> ?A - ?B \\<Longrightarrow> ?c \\<in> ?A\n  wf_query n V Q Qn \\<and> included V Q \\<and> non_empty_query Q\n  H = Q - {xx}\n  included ?V ?Q = (\\<forall>(S, X)\\<in>?Q. S \\<subseteq> ?V)\n  non_empty_query ?Q = (\\<forall>X\\<in>?Q. 1 \\<le> card (fst X))\n\ngoal (1 subgoal):\n 1. wf_query n V H Qn \\<and> included V H \\<and> non_empty_query H", "by fastforce"], ["proof (state)\nthis:\n  wf_query n V H Qn \\<and> included V H \\<and> non_empty_query H\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf_query n V H Qn \\<and> included V H \\<and> non_empty_query H\n\ngoal (1 subgoal):\n 1. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "then"], ["proof (chain)\npicking this:\n  wf_query n V H Qn \\<and> included V H \\<and> non_empty_query H", "have \"wf_query n V H Qn \\<and> included V H \\<and> non_empty_query H\""], ["proof (prove)\nusing this:\n  wf_query n V H Qn \\<and> included V H \\<and> non_empty_query H\n\ngoal (1 subgoal):\n 1. wf_query n V H Qn \\<and> included V H \\<and> non_empty_query H", "by simp"], ["proof (state)\nthis:\n  wf_query n V H Qn \\<and> included V H \\<and> non_empty_query H\n\ngoal (1 subgoal):\n 1. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "then"], ["proof (chain)\npicking this:\n  wf_query n V H Qn \\<and> included V H \\<and> non_empty_query H", "have \"table n V ((\\<Inter>(_, x)\\<in>H. x) - (\\<Union>(_, x)\\<in>Qn. x))\""], ["proof (prove)\nusing this:\n  wf_query n V H Qn \\<and> included V H \\<and> non_empty_query H\n\ngoal (1 subgoal):\n 1. table n V ((\\<Inter>(uu_, x)\\<in>H. x) - (\\<Union>(uu_, x)\\<in>Qn. x))", "using Suc.hyps(1) calculation(2)"], ["proof (prove)\nusing this:\n  wf_query n V H Qn \\<and> included V H \\<and> non_empty_query H\n  \\<lbrakk>y = card ?Q - 1;\n   wf_query n V ?Q Qn \\<and>\n   included V ?Q \\<and> non_empty_query ?Q\\<rbrakk>\n  \\<Longrightarrow> table n V\n                     ((\\<Inter>(uu_, x)\\<in>?Q. x) -\n                      (\\<Union>(uu_, x)\\<in>Qn. x))\n  card H - 1 = y\n\ngoal (1 subgoal):\n 1. table n V ((\\<Inter>(uu_, x)\\<in>H. x) - (\\<Union>(uu_, x)\\<in>Qn. x))", "by simp"], ["proof (state)\nthis:\n  table n V ((\\<Inter>(uu_, x)\\<in>H. x) - (\\<Union>(uu_, x)\\<in>Qn. x))\n\ngoal (1 subgoal):\n 1. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "moreover"], ["proof (state)\nthis:\n  table n V ((\\<Inter>(uu_, x)\\<in>H. x) - (\\<Union>(uu_, x)\\<in>Qn. x))\n\ngoal (1 subgoal):\n 1. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "obtain sa a where \"(sa, a) \\<in> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sa a. (sa, a) \\<in> H \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis One_nat_def Suc.hyps(2) \\<open>H = Q - {xx}\\<close> calculation(1) calculation(2) card.empty card_eq_0_iff card_le_Suc0_iff_eq diff_is_0_eq' equals0I insert_Diff le0 nat.simps(3) prod.collapse singletonD)"], ["proof (state)\nthis:\n  (sa, a) \\<in> H\n\ngoal (1 subgoal):\n 1. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "moreover"], ["proof (state)\nthis:\n  (sa, a) \\<in> H\n\ngoal (1 subgoal):\n 1. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "have \"\\<not> (Set.is_empty sa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Set.is_empty sa", "by (metis Set.is_empty_def \\<open>wf_query n V H Qn \\<and> included V H \\<and> non_empty_query H\\<close> calculation(4)\n          card.empty non_empty_query_def not_one_le_zero prod.sel(1))"], ["proof (state)\nthis:\n  \\<not> Set.is_empty sa\n\ngoal (1 subgoal):\n 1. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "then"], ["proof (chain)\npicking this:\n  \\<not> Set.is_empty sa", "have \"table n V (((\\<Inter>(_, x) \\<in> H. x) \\<inter> (snd xx)) - (\\<Union>(_, x)\\<in>Qn. x))\""], ["proof (prove)\nusing this:\n  \\<not> Set.is_empty sa\n\ngoal (1 subgoal):\n 1. table n V\n     ((\\<Inter>(uu_, x)\\<in>H. x) \\<inter> snd xx -\n      (\\<Union>(uu_, x)\\<in>Qn. x))", "by (metis Diff_Int2 Diff_Int_distrib2 IntE calculation(3) table_def)"], ["proof (state)\nthis:\n  table n V\n   ((\\<Inter>(uu_, x)\\<in>H. x) \\<inter> snd xx -\n    (\\<Union>(uu_, x)\\<in>Qn. x))\n\ngoal (1 subgoal):\n 1. \\<And>x Q.\n       \\<lbrakk>\\<And>Q.\n                   \\<lbrakk>x = card Q - 1;\n                    wf_query n V Q Qn \\<and>\n                    included V Q \\<and> non_empty_query Q\\<rbrakk>\n                   \\<Longrightarrow> table n V\n((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x));\n        Suc x = card Q - 1;\n        wf_query n V Q Qn \\<and>\n        included V Q \\<and> non_empty_query Q\\<rbrakk>\n       \\<Longrightarrow> table n V\n                          ((\\<Inter>(uu_, x)\\<in>Q. x) -\n                           (\\<Union>(uu_, x)\\<in>Qn. x))", "then"], ["proof (chain)\npicking this:\n  table n V\n   ((\\<Inter>(uu_, x)\\<in>H. x) \\<inter> snd xx -\n    (\\<Union>(uu_, x)\\<in>Qn. x))", "show ?case"], ["proof (prove)\nusing this:\n  table n V\n   ((\\<Inter>(uu_, x)\\<in>H. x) \\<inter> snd xx -\n    (\\<Union>(uu_, x)\\<in>Qn. x))\n\ngoal (1 subgoal):\n 1. table n V ((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x))", "using INF_insert Int_commute \\<open>H = Q - {xx}\\<close> calculation(1) insert_Diff snd_def"], ["proof (prove)\nusing this:\n  table n V\n   ((\\<Inter>(uu_, x)\\<in>H. x) \\<inter> snd xx -\n    (\\<Union>(uu_, x)\\<in>Qn. x))\n  Inf (?f ` insert ?a ?A) = inf (?f ?a) (Inf (?f ` ?A))\n  ?A \\<inter> ?B = ?B \\<inter> ?A\n  H = Q - {xx}\n  xx \\<in> Q\n  ?a \\<in> ?A \\<Longrightarrow> insert ?a (?A - {?a}) = ?A\n  snd ?prod = (case ?prod of (x1, x2) \\<Rightarrow> x2)\n\ngoal (1 subgoal):\n 1. table n V ((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x))", "by metis"], ["proof (state)\nthis:\n  table n V ((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf_query n V Q Qn \\<and>\n  included V Q \\<and> non_empty_query Q \\<Longrightarrow>\n  table n V ((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x))\n\ngoal (1 subgoal):\n 1. table n V R", "then"], ["proof (chain)\npicking this:\n  wf_query n V Q Qn \\<and>\n  included V Q \\<and> non_empty_query Q \\<Longrightarrow>\n  table n V ((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x))", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_query n V Q Qn \\<and>\n  included V Q \\<and> non_empty_query Q \\<Longrightarrow>\n  table n V ((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x))\n\ngoal (1 subgoal):\n 1. table n V R", "using assms(1) assms(2) assms(3) genericJoin.simps le_numeral_extra(4) rwf_query_def"], ["proof (prove)\nusing this:\n  wf_query n V Q Qn \\<and>\n  included V Q \\<and> non_empty_query Q \\<Longrightarrow>\n  table n V ((\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x))\n  card V = 1\n  rwf_query n V Q Qn\n  R = genericJoin V Q Qn\n  genericJoin ?V ?Q_pos ?Q_neg =\n  (if card ?V \\<le> 1\n   then (\\<Inter>(uu_, x)\\<in>?Q_pos. x) - (\\<Union>(uu_, x)\\<in>?Q_neg. x)\n   else let (I, J) = getIJ ?Q_pos ?Q_neg ?V;\n            Q_I_pos = projectQuery I (filterQuery I ?Q_pos);\n            Q_I_neg = filterQueryNeg I ?Q_neg;\n            R_I = genericJoin I Q_I_pos Q_I_neg; Q_J_neg = ?Q_neg - Q_I_neg;\n            Q_J_pos = filterQuery J ?Q_pos;\n            X = {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n                      (newQuery J Q_J_neg (I, t))) |\n                 t. t \\<in> R_I}\n        in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})\n  (1::?'a) \\<le> (1::?'a)\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n\ngoal (1 subgoal):\n 1. table n V R", "by auto"], ["proof (state)\nthis:\n  table n V R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filter_Q_J_neg_same:\n  assumes \"card V \\<ge> 2\"\n  assumes \"(I, J) = getIJ Q Qn V\"\n  assumes \"Q_I_neg = filterQueryNeg I Qn\"\n  assumes \"rwf_query n V Q Qn\"\n  shows \"filterQuery J (Qn - Q_I_neg) = Qn - Q_I_neg\" (is \"?A = ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. filterQuery J (Qn - Q_I_neg) = Qn - Q_I_neg", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. filterQuery J (Qn - Q_I_neg) = Qn - Q_I_neg", "have \"?A \\<subseteq> ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterQuery J (Qn - Q_I_neg) \\<subseteq> Qn - Q_I_neg", "by (simp add: subset_iff)"], ["proof (state)\nthis:\n  filterQuery J (Qn - Q_I_neg) \\<subseteq> Qn - Q_I_neg\n\ngoal (1 subgoal):\n 1. filterQuery J (Qn - Q_I_neg) = Qn - Q_I_neg", "moreover"], ["proof (state)\nthis:\n  filterQuery J (Qn - Q_I_neg) \\<subseteq> Qn - Q_I_neg\n\ngoal (1 subgoal):\n 1. filterQuery J (Qn - Q_I_neg) = Qn - Q_I_neg", "have \"?B \\<subseteq> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Qn - Q_I_neg \\<subseteq> filterQuery J (Qn - Q_I_neg)", "proof (rule subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Qn - Q_I_neg \\<Longrightarrow>\n       x \\<in> filterQuery J (Qn - Q_I_neg)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Qn - Q_I_neg \\<Longrightarrow>\n       x \\<in> filterQuery J (Qn - Q_I_neg)", "assume \"x \\<in> Qn - Q_I_neg\""], ["proof (state)\nthis:\n  x \\<in> Qn - Q_I_neg\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Qn - Q_I_neg \\<Longrightarrow>\n       x \\<in> filterQuery J (Qn - Q_I_neg)", "obtain A X where \"(A, X) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A X. (A, X) = x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis surj_pair)"], ["proof (state)\nthis:\n  (A, X) = x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Qn - Q_I_neg \\<Longrightarrow>\n       x \\<in> filterQuery J (Qn - Q_I_neg)", "have \"card (A \\<inter> J) \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> card (A \\<inter> J)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 1 \\<le> card (A \\<inter> J) \\<Longrightarrow> False", "assume \"\\<not> (card (A \\<inter> J) \\<ge> 1)\""], ["proof (state)\nthis:\n  \\<not> 1 \\<le> card (A \\<inter> J)\n\ngoal (1 subgoal):\n 1. \\<not> 1 \\<le> card (A \\<inter> J) \\<Longrightarrow> False", "have \"Set.is_empty (A \\<inter> J)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set.is_empty (A \\<inter> J)", "by (metis One_nat_def Set.is_empty_def Suc_leI Suc_le_lessD \\<open>\\<not> 1 \\<le> card (A \\<inter> J)\\<close> assms(1)\n            assms(2) card_gt_0_iff finite_Int getIJ.coreProperties getIJ_axioms)"], ["proof (state)\nthis:\n  Set.is_empty (A \\<inter> J)\n\ngoal (1 subgoal):\n 1. \\<not> 1 \\<le> card (A \\<inter> J) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Set.is_empty (A \\<inter> J)\n\ngoal (1 subgoal):\n 1. \\<not> 1 \\<le> card (A \\<inter> J) \\<Longrightarrow> False", "have \"A \\<subseteq> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> I", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<subseteq> I", "have \"(A, X) \\<in> Qn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A, X) \\<in> Qn", "using \\<open>(A, X) = x\\<close> \\<open>x \\<in> Qn - Q_I_neg\\<close>"], ["proof (prove)\nusing this:\n  (A, X) = x\n  x \\<in> Qn - Q_I_neg\n\ngoal (1 subgoal):\n 1. (A, X) \\<in> Qn", "by auto"], ["proof (state)\nthis:\n  (A, X) \\<in> Qn\n\ngoal (1 subgoal):\n 1. A \\<subseteq> I", "then"], ["proof (chain)\npicking this:\n  (A, X) \\<in> Qn", "have \"included V Qn\""], ["proof (prove)\nusing this:\n  (A, X) \\<in> Qn\n\ngoal (1 subgoal):\n 1. included V Qn", "using assms(4) rwf_query_def"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Qn\n  rwf_query n V Q Qn\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n\ngoal (1 subgoal):\n 1. included V Qn", "by blast"], ["proof (state)\nthis:\n  included V Qn\n\ngoal (1 subgoal):\n 1. A \\<subseteq> I", "then"], ["proof (chain)\npicking this:\n  included V Qn", "have \"A \\<subseteq> V\""], ["proof (prove)\nusing this:\n  included V Qn\n\ngoal (1 subgoal):\n 1. A \\<subseteq> V", "using \\<open>(A, X) \\<in> Qn\\<close> included_def"], ["proof (prove)\nusing this:\n  included V Qn\n  (A, X) \\<in> Qn\n  included ?V ?Q = (\\<forall>(S, X)\\<in>?Q. S \\<subseteq> ?V)\n\ngoal (1 subgoal):\n 1. A \\<subseteq> V", "by fastforce"], ["proof (state)\nthis:\n  A \\<subseteq> V\n\ngoal (1 subgoal):\n 1. A \\<subseteq> I", "then"], ["proof (chain)\npicking this:\n  A \\<subseteq> V", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<subseteq> V\n\ngoal (1 subgoal):\n 1. A \\<subseteq> I", "by (metis Set.is_empty_def UnE assms(1) assms(2) calculation disjoint_iff_not_equal\n              getIJProperties(5) subsetD subsetI)"], ["proof (state)\nthis:\n  A \\<subseteq> I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A \\<subseteq> I\n\ngoal (1 subgoal):\n 1. \\<not> 1 \\<le> card (A \\<inter> J) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  A \\<subseteq> I", "have \"(A, X) \\<in> Q_I_neg\""], ["proof (prove)\nusing this:\n  A \\<subseteq> I\n\ngoal (1 subgoal):\n 1. (A, X) \\<in> Q_I_neg", "using \\<open>(A, X) = x\\<close> \\<open>x \\<in> Qn - Q_I_neg\\<close> assms(3)"], ["proof (prove)\nusing this:\n  A \\<subseteq> I\n  (A, X) = x\n  x \\<in> Qn - Q_I_neg\n  Q_I_neg = filterQueryNeg I Qn\n\ngoal (1 subgoal):\n 1. (A, X) \\<in> Q_I_neg", "by auto"], ["proof (state)\nthis:\n  (A, X) \\<in> Q_I_neg\n\ngoal (1 subgoal):\n 1. \\<not> 1 \\<le> card (A \\<inter> J) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (A, X) \\<in> Q_I_neg", "show \"False\""], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q_I_neg\n\ngoal (1 subgoal):\n 1. False", "using \\<open>(A, X) = x\\<close> \\<open>x \\<in> Qn - Q_I_neg\\<close>"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q_I_neg\n  (A, X) = x\n  x \\<in> Qn - Q_I_neg\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 \\<le> card (A \\<inter> J)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Qn - Q_I_neg \\<Longrightarrow>\n       x \\<in> filterQuery J (Qn - Q_I_neg)", "then"], ["proof (chain)\npicking this:\n  1 \\<le> card (A \\<inter> J)", "show \"x \\<in> ?A\""], ["proof (prove)\nusing this:\n  1 \\<le> card (A \\<inter> J)\n\ngoal (1 subgoal):\n 1. x \\<in> filterQuery J (Qn - Q_I_neg)", "using \\<open>(A, X) = x\\<close> \\<open>x \\<in> Qn - Q_I_neg\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> card (A \\<inter> J)\n  (A, X) = x\n  x \\<in> Qn - Q_I_neg\n\ngoal (1 subgoal):\n 1. x \\<in> filterQuery J (Qn - Q_I_neg)", "by (metis Diff_subset subset_Q_neg assms(4) fst_conv rwf_query_def set_filterQuery)"], ["proof (state)\nthis:\n  x \\<in> filterQuery J (Qn - Q_I_neg)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Qn - Q_I_neg \\<subseteq> filterQuery J (Qn - Q_I_neg)\n\ngoal (1 subgoal):\n 1. filterQuery J (Qn - Q_I_neg) = Qn - Q_I_neg", "then"], ["proof (chain)\npicking this:\n  Qn - Q_I_neg \\<subseteq> filterQuery J (Qn - Q_I_neg)", "show ?thesis"], ["proof (prove)\nusing this:\n  Qn - Q_I_neg \\<subseteq> filterQuery J (Qn - Q_I_neg)\n\ngoal (1 subgoal):\n 1. filterQuery J (Qn - Q_I_neg) = Qn - Q_I_neg", "by auto"], ["proof (state)\nthis:\n  filterQuery J (Qn - Q_I_neg) = Qn - Q_I_neg\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vars_genericJoin:\n  assumes \"card V \\<ge> 2\"\n  assumes \"(I, J) = getIJ Q Qn V\"\n  assumes \"Q_I_pos = projectQuery I (filterQuery I Q)\"\n  assumes \"Q_I_neg = filterQueryNeg I Qn\"\n  assumes \"R_I = genericJoin I Q_I_pos Q_I_neg\"\n  assumes \"Q_J_neg = filterQuery J (Qn - Q_I_neg)\"\n  assumes \"Q_J_pos = filterQuery J Q\"\n  assumes \"X = {(t, genericJoin J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t))) | t . t \\<in> R_I}\"\n  assumes \"R = (\\<Union>(t, x) \\<in> X. {merge xx t | xx . xx \\<in> x})\"\n  assumes \"rwf_query n V Q Qn\"\n  shows \"R = genericJoin V Q Qn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R = genericJoin V Q Qn", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. R = genericJoin V Q Qn", "have \"filterQuery J (Qn - Q_I_neg) = Qn - Q_I_neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filterQuery J (Qn - Q_I_neg) = Qn - Q_I_neg", "using assms(1) assms(10) assms(2) assms(4) filter_Q_J_neg_same"], ["proof (prove)\nusing this:\n  2 \\<le> card V\n  rwf_query n V Q Qn\n  (I, J) = getIJ Q Qn V\n  Q_I_neg = filterQueryNeg I Qn\n  \\<lbrakk>2 \\<le> card ?V; (?I, ?J) = getIJ ?Q ?Qn ?V;\n   ?Q_I_neg = filterQueryNeg ?I ?Qn; rwf_query ?n ?V ?Q ?Qn\\<rbrakk>\n  \\<Longrightarrow> filterQuery ?J (?Qn - ?Q_I_neg) = ?Qn - ?Q_I_neg\n\ngoal (1 subgoal):\n 1. filterQuery J (Qn - Q_I_neg) = Qn - Q_I_neg", "by blast"], ["proof (state)\nthis:\n  filterQuery J (Qn - Q_I_neg) = Qn - Q_I_neg\n\ngoal (1 subgoal):\n 1. R = genericJoin V Q Qn", "then"], ["proof (chain)\npicking this:\n  filterQuery J (Qn - Q_I_neg) = Qn - Q_I_neg", "have \"Q_J_neg = Qn - Q_I_neg\""], ["proof (prove)\nusing this:\n  filterQuery J (Qn - Q_I_neg) = Qn - Q_I_neg\n\ngoal (1 subgoal):\n 1. Q_J_neg = Qn - Q_I_neg", "by (simp add: assms(6))"], ["proof (state)\nthis:\n  Q_J_neg = Qn - Q_I_neg\n\ngoal (1 subgoal):\n 1. R = genericJoin V Q Qn", "moreover"], ["proof (state)\nthis:\n  Q_J_neg = Qn - Q_I_neg\n\ngoal (1 subgoal):\n 1. R = genericJoin V Q Qn", "have \"genericJoin V Q Qn =\n    (if card V \\<le> 1 then\n      (\\<Inter>(_, x) \\<in> Q. x) - (\\<Union>(_, x) \\<in> Qn. x)\n    else\n      let (I, J) = getIJ Q Qn V in\n      let Q_I_pos = projectQuery I (filterQuery I Q) in\n      let Q_I_neg = filterQueryNeg I Qn in\n      let R_I = genericJoin I Q_I_pos Q_I_neg in\n      let Q_J_neg = Qn - Q_I_neg in\n      let Q_J_pos = filterQuery J Q in\n      let X = {(t, genericJoin J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t))) | t . t \\<in> R_I} in\n      (\\<Union>(t, x) \\<in> X. {merge xx t | xx . xx \\<in> x}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. genericJoin V Q Qn =\n    (if card V \\<le> 1\n     then (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x)\n     else let (I, J) = getIJ Q Qn V;\n              Q_I_pos = projectQuery I (filterQuery I Q);\n              Q_I_neg = filterQueryNeg I Qn;\n              R_I = genericJoin I Q_I_pos Q_I_neg; Q_J_neg = Qn - Q_I_neg;\n              Q_J_pos = filterQuery J Q;\n              X = {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n                        (newQuery J Q_J_neg (I, t))) |\n                   t. t \\<in> R_I}\n          in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})", "by simp"], ["proof (state)\nthis:\n  genericJoin V Q Qn =\n  (if card V \\<le> 1\n   then (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x)\n   else let (I, J) = getIJ Q Qn V;\n            Q_I_pos = projectQuery I (filterQuery I Q);\n            Q_I_neg = filterQueryNeg I Qn;\n            R_I = genericJoin I Q_I_pos Q_I_neg; Q_J_neg = Qn - Q_I_neg;\n            Q_J_pos = filterQuery J Q;\n            X = {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n                      (newQuery J Q_J_neg (I, t))) |\n                 t. t \\<in> R_I}\n        in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})\n\ngoal (1 subgoal):\n 1. R = genericJoin V Q Qn", "moreover"], ["proof (state)\nthis:\n  genericJoin V Q Qn =\n  (if card V \\<le> 1\n   then (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x)\n   else let (I, J) = getIJ Q Qn V;\n            Q_I_pos = projectQuery I (filterQuery I Q);\n            Q_I_neg = filterQueryNeg I Qn;\n            R_I = genericJoin I Q_I_pos Q_I_neg; Q_J_neg = Qn - Q_I_neg;\n            Q_J_pos = filterQuery J Q;\n            X = {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n                      (newQuery J Q_J_neg (I, t))) |\n                 t. t \\<in> R_I}\n        in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})\n\ngoal (1 subgoal):\n 1. R = genericJoin V Q Qn", "have \"\\<not> (card V \\<le> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> card V \\<le> 1", "using assms(1)"], ["proof (prove)\nusing this:\n  2 \\<le> card V\n\ngoal (1 subgoal):\n 1. \\<not> card V \\<le> 1", "by linarith"], ["proof (state)\nthis:\n  \\<not> card V \\<le> 1\n\ngoal (1 subgoal):\n 1. R = genericJoin V Q Qn", "then"], ["proof (chain)\npicking this:\n  \\<not> card V \\<le> 1", "have gen: \"genericJoin V Q Qn = (let (I, J) = getIJ Q Qn V in\n      let Q_I_pos = projectQuery I (filterQuery I Q) in\n      let Q_I_neg = filterQueryNeg I Qn in\n      let R_I = genericJoin I Q_I_pos Q_I_neg in\n      let Q_J_neg = Qn - Q_I_neg in\n      let Q_J_pos = filterQuery J Q in\n      let X = {(t, genericJoin J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t))) | t . t \\<in> R_I} in\n      (\\<Union>(t, x) \\<in> X. {merge xx t | xx . xx \\<in> x}))\""], ["proof (prove)\nusing this:\n  \\<not> card V \\<le> 1\n\ngoal (1 subgoal):\n 1. genericJoin V Q Qn =\n    (let (I, J) = getIJ Q Qn V; Q_I_pos = projectQuery I (filterQuery I Q);\n         Q_I_neg = filterQueryNeg I Qn; R_I = genericJoin I Q_I_pos Q_I_neg;\n         Q_J_neg = Qn - Q_I_neg; Q_J_pos = filterQuery J Q;\n         X = {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n                   (newQuery J Q_J_neg (I, t))) |\n              t. t \\<in> R_I}\n     in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})", "using assms"], ["proof (prove)\nusing this:\n  \\<not> card V \\<le> 1\n  2 \\<le> card V\n  (I, J) = getIJ Q Qn V\n  Q_I_pos = projectQuery I (filterQuery I Q)\n  Q_I_neg = filterQueryNeg I Qn\n  R_I = genericJoin I Q_I_pos Q_I_neg\n  Q_J_neg = filterQuery J (Qn - Q_I_neg)\n  Q_J_pos = filterQuery J Q\n  X =\n  {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n        (newQuery J Q_J_neg (I, t))) |\n   t. t \\<in> R_I}\n  R = (\\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})\n  rwf_query n V Q Qn\n\ngoal (1 subgoal):\n 1. genericJoin V Q Qn =\n    (let (I, J) = getIJ Q Qn V; Q_I_pos = projectQuery I (filterQuery I Q);\n         Q_I_neg = filterQueryNeg I Qn; R_I = genericJoin I Q_I_pos Q_I_neg;\n         Q_J_neg = Qn - Q_I_neg; Q_J_pos = filterQuery J Q;\n         X = {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n                   (newQuery J Q_J_neg (I, t))) |\n              t. t \\<in> R_I}\n     in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})", "by simp"], ["proof (state)\nthis:\n  genericJoin V Q Qn =\n  (let (I, J) = getIJ Q Qn V; Q_I_pos = projectQuery I (filterQuery I Q);\n       Q_I_neg = filterQueryNeg I Qn; R_I = genericJoin I Q_I_pos Q_I_neg;\n       Q_J_neg = Qn - Q_I_neg; Q_J_pos = filterQuery J Q;\n       X = {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n                 (newQuery J Q_J_neg (I, t))) |\n            t. t \\<in> R_I}\n   in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})\n\ngoal (1 subgoal):\n 1. R = genericJoin V Q Qn", "then"], ["proof (chain)\npicking this:\n  genericJoin V Q Qn =\n  (let (I, J) = getIJ Q Qn V; Q_I_pos = projectQuery I (filterQuery I Q);\n       Q_I_neg = filterQueryNeg I Qn; R_I = genericJoin I Q_I_pos Q_I_neg;\n       Q_J_neg = Qn - Q_I_neg; Q_J_pos = filterQuery J Q;\n       X = {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n                 (newQuery J Q_J_neg (I, t))) |\n            t. t \\<in> R_I}\n   in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})", "have \"... = (\n      let Q_I_pos = projectQuery I (filterQuery I Q) in\n      let Q_I_neg = filterQueryNeg I Qn in\n      let R_I = genericJoin I Q_I_pos Q_I_neg in\n      let Q_J_neg = Qn - Q_I_neg in\n      let Q_J_pos = filterQuery J Q in\n      let X = {(t, genericJoin J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t))) | t . t \\<in> R_I} in\n      (\\<Union>(t, x) \\<in> X. {merge xx t | xx . xx \\<in> x}))\""], ["proof (prove)\nusing this:\n  genericJoin V Q Qn =\n  (let (I, J) = getIJ Q Qn V; Q_I_pos = projectQuery I (filterQuery I Q);\n       Q_I_neg = filterQueryNeg I Qn; R_I = genericJoin I Q_I_pos Q_I_neg;\n       Q_J_neg = Qn - Q_I_neg; Q_J_pos = filterQuery J Q;\n       X = {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n                 (newQuery J Q_J_neg (I, t))) |\n            t. t \\<in> R_I}\n   in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})\n\ngoal (1 subgoal):\n 1. (let (I, J) = getIJ Q Qn V; Q_I_pos = projectQuery I (filterQuery I Q);\n         Q_I_neg = filterQueryNeg I Qn; R_I = genericJoin I Q_I_pos Q_I_neg;\n         Q_J_neg = Qn - Q_I_neg; Q_J_pos = filterQuery J Q;\n         X = {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n                   (newQuery J Q_J_neg (I, t))) |\n              t. t \\<in> R_I}\n     in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x}) =\n    (let Q_I_pos = projectQuery I (filterQuery I Q);\n         Q_I_neg = filterQueryNeg I Qn; R_I = genericJoin I Q_I_pos Q_I_neg;\n         Q_J_neg = Qn - Q_I_neg; Q_J_pos = filterQuery J Q;\n         X = {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n                   (newQuery J Q_J_neg (I, t))) |\n              t. t \\<in> R_I}\n     in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})", "using assms(2)"], ["proof (prove)\nusing this:\n  genericJoin V Q Qn =\n  (let (I, J) = getIJ Q Qn V; Q_I_pos = projectQuery I (filterQuery I Q);\n       Q_I_neg = filterQueryNeg I Qn; R_I = genericJoin I Q_I_pos Q_I_neg;\n       Q_J_neg = Qn - Q_I_neg; Q_J_pos = filterQuery J Q;\n       X = {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n                 (newQuery J Q_J_neg (I, t))) |\n            t. t \\<in> R_I}\n   in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})\n  (I, J) = getIJ Q Qn V\n\ngoal (1 subgoal):\n 1. (let (I, J) = getIJ Q Qn V; Q_I_pos = projectQuery I (filterQuery I Q);\n         Q_I_neg = filterQueryNeg I Qn; R_I = genericJoin I Q_I_pos Q_I_neg;\n         Q_J_neg = Qn - Q_I_neg; Q_J_pos = filterQuery J Q;\n         X = {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n                   (newQuery J Q_J_neg (I, t))) |\n              t. t \\<in> R_I}\n     in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x}) =\n    (let Q_I_pos = projectQuery I (filterQuery I Q);\n         Q_I_neg = filterQueryNeg I Qn; R_I = genericJoin I Q_I_pos Q_I_neg;\n         Q_J_neg = Qn - Q_I_neg; Q_J_pos = filterQuery J Q;\n         X = {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n                   (newQuery J Q_J_neg (I, t))) |\n              t. t \\<in> R_I}\n     in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})", "by (metis (no_types, lifting) case_prod_conv)"], ["proof (state)\nthis:\n  (let (I, J) = getIJ Q Qn V; Q_I_pos = projectQuery I (filterQuery I Q);\n       Q_I_neg = filterQueryNeg I Qn; R_I = genericJoin I Q_I_pos Q_I_neg;\n       Q_J_neg = Qn - Q_I_neg; Q_J_pos = filterQuery J Q;\n       X = {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n                 (newQuery J Q_J_neg (I, t))) |\n            t. t \\<in> R_I}\n   in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x}) =\n  (let Q_I_pos = projectQuery I (filterQuery I Q);\n       Q_I_neg = filterQueryNeg I Qn; R_I = genericJoin I Q_I_pos Q_I_neg;\n       Q_J_neg = Qn - Q_I_neg; Q_J_pos = filterQuery J Q;\n       X = {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n                 (newQuery J Q_J_neg (I, t))) |\n            t. t \\<in> R_I}\n   in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})\n\ngoal (1 subgoal):\n 1. R = genericJoin V Q Qn", "then"], ["proof (chain)\npicking this:\n  (let (I, J) = getIJ Q Qn V; Q_I_pos = projectQuery I (filterQuery I Q);\n       Q_I_neg = filterQueryNeg I Qn; R_I = genericJoin I Q_I_pos Q_I_neg;\n       Q_J_neg = Qn - Q_I_neg; Q_J_pos = filterQuery J Q;\n       X = {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n                 (newQuery J Q_J_neg (I, t))) |\n            t. t \\<in> R_I}\n   in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x}) =\n  (let Q_I_pos = projectQuery I (filterQuery I Q);\n       Q_I_neg = filterQueryNeg I Qn; R_I = genericJoin I Q_I_pos Q_I_neg;\n       Q_J_neg = Qn - Q_I_neg; Q_J_pos = filterQuery J Q;\n       X = {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n                 (newQuery J Q_J_neg (I, t))) |\n            t. t \\<in> R_I}\n   in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})", "show ?thesis"], ["proof (prove)\nusing this:\n  (let (I, J) = getIJ Q Qn V; Q_I_pos = projectQuery I (filterQuery I Q);\n       Q_I_neg = filterQueryNeg I Qn; R_I = genericJoin I Q_I_pos Q_I_neg;\n       Q_J_neg = Qn - Q_I_neg; Q_J_pos = filterQuery J Q;\n       X = {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n                 (newQuery J Q_J_neg (I, t))) |\n            t. t \\<in> R_I}\n   in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x}) =\n  (let Q_I_pos = projectQuery I (filterQuery I Q);\n       Q_I_neg = filterQueryNeg I Qn; R_I = genericJoin I Q_I_pos Q_I_neg;\n       Q_J_neg = Qn - Q_I_neg; Q_J_pos = filterQuery J Q;\n       X = {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n                 (newQuery J Q_J_neg (I, t))) |\n            t. t \\<in> R_I}\n   in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})\n\ngoal (1 subgoal):\n 1. R = genericJoin V Q Qn", "using assms"], ["proof (prove)\nusing this:\n  (let (I, J) = getIJ Q Qn V; Q_I_pos = projectQuery I (filterQuery I Q);\n       Q_I_neg = filterQueryNeg I Qn; R_I = genericJoin I Q_I_pos Q_I_neg;\n       Q_J_neg = Qn - Q_I_neg; Q_J_pos = filterQuery J Q;\n       X = {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n                 (newQuery J Q_J_neg (I, t))) |\n            t. t \\<in> R_I}\n   in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x}) =\n  (let Q_I_pos = projectQuery I (filterQuery I Q);\n       Q_I_neg = filterQueryNeg I Qn; R_I = genericJoin I Q_I_pos Q_I_neg;\n       Q_J_neg = Qn - Q_I_neg; Q_J_pos = filterQuery J Q;\n       X = {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n                 (newQuery J Q_J_neg (I, t))) |\n            t. t \\<in> R_I}\n   in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})\n  2 \\<le> card V\n  (I, J) = getIJ Q Qn V\n  Q_I_pos = projectQuery I (filterQuery I Q)\n  Q_I_neg = filterQueryNeg I Qn\n  R_I = genericJoin I Q_I_pos Q_I_neg\n  Q_J_neg = filterQuery J (Qn - Q_I_neg)\n  Q_J_pos = filterQuery J Q\n  X =\n  {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n        (newQuery J Q_J_neg (I, t))) |\n   t. t \\<in> R_I}\n  R = (\\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})\n  rwf_query n V Q Qn\n\ngoal (1 subgoal):\n 1. R = genericJoin V Q Qn", "by (metis calculation(1) gen)"], ["proof (state)\nthis:\n  R = genericJoin V Q Qn\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma base_genericJoin:\n  assumes \"card V \\<le> 1\"\n  shows \"genericJoin V Q Qn =  (\\<Inter>(_, x) \\<in> Q. x) - (\\<Union>(_, x) \\<in> Qn. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. genericJoin V Q Qn =\n    (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. genericJoin V Q Qn =\n    (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x)", "have \"genericJoin V Q Qn =\n    (if card V \\<le> 1 then\n      (\\<Inter>(_, x) \\<in> Q. x) - (\\<Union>(_, x) \\<in> Qn. x)\n    else\n      let (I, J) = getIJ Q Qn V in\n      let Q_I_pos = projectQuery I (filterQuery I Q) in\n      let Q_I_neg = filterQueryNeg I Qn in\n      let R_I = genericJoin I Q_I_pos Q_I_neg in\n\n      let Q_J_neg = Qn - Q_I_neg in\n      let Q_J_pos = filterQuery J Q in\n      let X = {(t, genericJoin J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t))) | t . t \\<in> R_I} in\n      (\\<Union>(t, x) \\<in> X. {merge xx t | xx . xx \\<in> x}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. genericJoin V Q Qn =\n    (if card V \\<le> 1\n     then (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x)\n     else let (I, J) = getIJ Q Qn V;\n              Q_I_pos = projectQuery I (filterQuery I Q);\n              Q_I_neg = filterQueryNeg I Qn;\n              R_I = genericJoin I Q_I_pos Q_I_neg; Q_J_neg = Qn - Q_I_neg;\n              Q_J_pos = filterQuery J Q;\n              X = {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n                        (newQuery J Q_J_neg (I, t))) |\n                   t. t \\<in> R_I}\n          in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})", "by simp"], ["proof (state)\nthis:\n  genericJoin V Q Qn =\n  (if card V \\<le> 1\n   then (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x)\n   else let (I, J) = getIJ Q Qn V;\n            Q_I_pos = projectQuery I (filterQuery I Q);\n            Q_I_neg = filterQueryNeg I Qn;\n            R_I = genericJoin I Q_I_pos Q_I_neg; Q_J_neg = Qn - Q_I_neg;\n            Q_J_pos = filterQuery J Q;\n            X = {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n                      (newQuery J Q_J_neg (I, t))) |\n                 t. t \\<in> R_I}\n        in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})\n\ngoal (1 subgoal):\n 1. genericJoin V Q Qn =\n    (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x)", "then"], ["proof (chain)\npicking this:\n  genericJoin V Q Qn =\n  (if card V \\<le> 1\n   then (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x)\n   else let (I, J) = getIJ Q Qn V;\n            Q_I_pos = projectQuery I (filterQuery I Q);\n            Q_I_neg = filterQueryNeg I Qn;\n            R_I = genericJoin I Q_I_pos Q_I_neg; Q_J_neg = Qn - Q_I_neg;\n            Q_J_pos = filterQuery J Q;\n            X = {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n                      (newQuery J Q_J_neg (I, t))) |\n                 t. t \\<in> R_I}\n        in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})", "show ?thesis"], ["proof (prove)\nusing this:\n  genericJoin V Q Qn =\n  (if card V \\<le> 1\n   then (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x)\n   else let (I, J) = getIJ Q Qn V;\n            Q_I_pos = projectQuery I (filterQuery I Q);\n            Q_I_neg = filterQueryNeg I Qn;\n            R_I = genericJoin I Q_I_pos Q_I_neg; Q_J_neg = Qn - Q_I_neg;\n            Q_J_pos = filterQuery J Q;\n            X = {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n                      (newQuery J Q_J_neg (I, t))) |\n                 t. t \\<in> R_I}\n        in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})\n\ngoal (1 subgoal):\n 1. genericJoin V Q Qn =\n    (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x)", "using assms"], ["proof (prove)\nusing this:\n  genericJoin V Q Qn =\n  (if card V \\<le> 1\n   then (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x)\n   else let (I, J) = getIJ Q Qn V;\n            Q_I_pos = projectQuery I (filterQuery I Q);\n            Q_I_neg = filterQueryNeg I Qn;\n            R_I = genericJoin I Q_I_pos Q_I_neg; Q_J_neg = Qn - Q_I_neg;\n            Q_J_pos = filterQuery J Q;\n            X = {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n                      (newQuery J Q_J_neg (I, t))) |\n                 t. t \\<in> R_I}\n        in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})\n  card V \\<le> 1\n\ngoal (1 subgoal):\n 1. genericJoin V Q Qn =\n    (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x)", "by auto"], ["proof (state)\nthis:\n  genericJoin V Q Qn =\n  (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_genericJoin:\n  \"\\<lbrakk>rwf_query n V Q Qn; card V \\<ge> 1\\<rbrakk> \\<Longrightarrow> table n V (genericJoin V Q Qn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rwf_query n V Q Qn; 1 \\<le> card V\\<rbrakk>\n    \\<Longrightarrow> table n V (genericJoin V Q Qn)", "proof (induction V Q Qn rule: genericJoin.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V Q_pos Q_neg.\n       \\<lbrakk>\\<And>x xa y xb xc.\n                   \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q_pos Q_neg V;\n                    (xa, y) = x;\n                    xb = projectQuery xa (filterQuery xa Q_pos);\n                    xc = filterQueryNeg xa Q_neg; rwf_query n xa xb xc;\n                    1 \\<le> card xa\\<rbrakk>\n                   \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n        \\<And>x xa y xb xc xd xe xf xg xh.\n           \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q_pos Q_neg V;\n            (xa, y) = x; xb = projectQuery xa (filterQuery xa Q_pos);\n            xc = filterQueryNeg xa Q_neg; xd = genericJoin xa xb xc;\n            xe = Q_neg - xc; xf = filterQuery y Q_pos;\n            rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n            1 \\<le> card y\\<rbrakk>\n           \\<Longrightarrow> table n y\n                              (genericJoin y (newQuery y xf (xa, xh))\n                                (newQuery y xe (xa, xh)));\n        rwf_query n V Q_pos Q_neg; 1 \\<le> card V\\<rbrakk>\n       \\<Longrightarrow> table n V (genericJoin V Q_pos Q_neg)", "case (1 V Q Qn)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> card V \\<le> 1; ?x = getIJ Q Qn V; (?xa, ?y) = ?x;\n   ?xb = projectQuery ?xa (filterQuery ?xa Q); ?xc = filterQueryNeg ?xa Qn;\n   rwf_query n ?xa ?xb ?xc; 1 \\<le> card ?xa\\<rbrakk>\n  \\<Longrightarrow> table n ?xa (genericJoin ?xa ?xb ?xc)\n  \\<lbrakk>\\<not> card V \\<le> 1; ?x = getIJ Q Qn V; (?xa, ?y) = ?x;\n   ?xb = projectQuery ?xa (filterQuery ?xa Q); ?xc = filterQueryNeg ?xa Qn;\n   ?xd = genericJoin ?xa ?xb ?xc; ?xe = Qn - ?xc; ?xf = filterQuery ?y Q;\n   rwf_query n ?y (newQuery ?y ?xf (?xa, ?xh)) (newQuery ?y ?xe (?xa, ?xh));\n   1 \\<le> card ?y\\<rbrakk>\n  \\<Longrightarrow> table n ?y\n                     (genericJoin ?y (newQuery ?y ?xf (?xa, ?xh))\n                       (newQuery ?y ?xe (?xa, ?xh)))\n  rwf_query n V Q Qn\n  1 \\<le> card V\n\ngoal (1 subgoal):\n 1. \\<And>V Q_pos Q_neg.\n       \\<lbrakk>\\<And>x xa y xb xc.\n                   \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q_pos Q_neg V;\n                    (xa, y) = x;\n                    xb = projectQuery xa (filterQuery xa Q_pos);\n                    xc = filterQueryNeg xa Q_neg; rwf_query n xa xb xc;\n                    1 \\<le> card xa\\<rbrakk>\n                   \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n        \\<And>x xa y xb xc xd xe xf xg xh.\n           \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q_pos Q_neg V;\n            (xa, y) = x; xb = projectQuery xa (filterQuery xa Q_pos);\n            xc = filterQueryNeg xa Q_neg; xd = genericJoin xa xb xc;\n            xe = Q_neg - xc; xf = filterQuery y Q_pos;\n            rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n            1 \\<le> card y\\<rbrakk>\n           \\<Longrightarrow> table n y\n                              (genericJoin y (newQuery y xf (xa, xh))\n                                (newQuery y xe (xa, xh)));\n        rwf_query n V Q_pos Q_neg; 1 \\<le> card V\\<rbrakk>\n       \\<Longrightarrow> table n V (genericJoin V Q_pos Q_neg)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> card V \\<le> 1; ?x = getIJ Q Qn V; (?xa, ?y) = ?x;\n   ?xb = projectQuery ?xa (filterQuery ?xa Q); ?xc = filterQueryNeg ?xa Qn;\n   rwf_query n ?xa ?xb ?xc; 1 \\<le> card ?xa\\<rbrakk>\n  \\<Longrightarrow> table n ?xa (genericJoin ?xa ?xb ?xc)\n  \\<lbrakk>\\<not> card V \\<le> 1; ?x = getIJ Q Qn V; (?xa, ?y) = ?x;\n   ?xb = projectQuery ?xa (filterQuery ?xa Q); ?xc = filterQueryNeg ?xa Qn;\n   ?xd = genericJoin ?xa ?xb ?xc; ?xe = Qn - ?xc; ?xf = filterQuery ?y Q;\n   rwf_query n ?y (newQuery ?y ?xf (?xa, ?xh)) (newQuery ?y ?xe (?xa, ?xh));\n   1 \\<le> card ?y\\<rbrakk>\n  \\<Longrightarrow> table n ?y\n                     (genericJoin ?y (newQuery ?y ?xf (?xa, ?xh))\n                       (newQuery ?y ?xe (?xa, ?xh)))\n  rwf_query n V Q Qn\n  1 \\<le> card V", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> card V \\<le> 1; ?x = getIJ Q Qn V; (?xa, ?y) = ?x;\n   ?xb = projectQuery ?xa (filterQuery ?xa Q); ?xc = filterQueryNeg ?xa Qn;\n   rwf_query n ?xa ?xb ?xc; 1 \\<le> card ?xa\\<rbrakk>\n  \\<Longrightarrow> table n ?xa (genericJoin ?xa ?xb ?xc)\n  \\<lbrakk>\\<not> card V \\<le> 1; ?x = getIJ Q Qn V; (?xa, ?y) = ?x;\n   ?xb = projectQuery ?xa (filterQuery ?xa Q); ?xc = filterQueryNeg ?xa Qn;\n   ?xd = genericJoin ?xa ?xb ?xc; ?xe = Qn - ?xc; ?xf = filterQuery ?y Q;\n   rwf_query n ?y (newQuery ?y ?xf (?xa, ?xh)) (newQuery ?y ?xe (?xa, ?xh));\n   1 \\<le> card ?y\\<rbrakk>\n  \\<Longrightarrow> table n ?y\n                     (genericJoin ?y (newQuery ?y ?xf (?xa, ?xh))\n                       (newQuery ?y ?xe (?xa, ?xh)))\n  rwf_query n V Q Qn\n  1 \\<le> card V\n\ngoal (1 subgoal):\n 1. table n V (genericJoin V Q Qn)", "proof (cases \"card V \\<le> 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x xa y xb xc.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n     \\<And>x xa y xb xc xd xe xf xh.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> table n y\n                           (genericJoin y (newQuery y xf (xa, xh))\n                             (newQuery y xe (xa, xh)));\n     rwf_query n V Q Qn; 1 \\<le> card V; card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> table n V (genericJoin V Q Qn)\n 2. \\<lbrakk>\\<And>x xa y xb xc.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n     \\<And>x xa y xb xc xd xe xf xh.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> table n y\n                           (genericJoin y (newQuery y xf (xa, xh))\n                             (newQuery y xe (xa, xh)));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> table n V (genericJoin V Q Qn)", "case True"], ["proof (state)\nthis:\n  card V \\<le> 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x xa y xb xc.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n     \\<And>x xa y xb xc xd xe xf xh.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> table n y\n                           (genericJoin y (newQuery y xf (xa, xh))\n                             (newQuery y xe (xa, xh)));\n     rwf_query n V Q Qn; 1 \\<le> card V; card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> table n V (genericJoin V Q Qn)\n 2. \\<lbrakk>\\<And>x xa y xb xc.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n     \\<And>x xa y xb xc xd xe xf xh.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> table n y\n                           (genericJoin y (newQuery y xf (xa, xh))\n                             (newQuery y xe (xa, xh)));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> table n V (genericJoin V Q Qn)", "then"], ["proof (chain)\npicking this:\n  card V \\<le> 1", "show ?thesis"], ["proof (prove)\nusing this:\n  card V \\<le> 1\n\ngoal (1 subgoal):\n 1. table n V (genericJoin V Q Qn)", "using \"1.prems\"(1) \"1.prems\"(2) le_antisym wf_base_case"], ["proof (prove)\nusing this:\n  card V \\<le> 1\n  rwf_query n V Q Qn\n  1 \\<le> card V\n  \\<lbrakk>?m \\<le> ?n; ?n \\<le> ?m\\<rbrakk> \\<Longrightarrow> ?m = ?n\n  \\<lbrakk>card ?V = 1; rwf_query ?n ?V ?Q ?Qn;\n   ?R = genericJoin ?V ?Q ?Qn\\<rbrakk>\n  \\<Longrightarrow> table ?n ?V ?R\n\ngoal (1 subgoal):\n 1. table n V (genericJoin V Q Qn)", "by blast"], ["proof (state)\nthis:\n  table n V (genericJoin V Q Qn)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n     \\<And>x xa y xb xc xd xe xf xh.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> table n y\n                           (genericJoin y (newQuery y xf (xa, xh))\n                             (newQuery y xe (xa, xh)));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> table n V (genericJoin V Q Qn)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n     \\<And>x xa y xb xc xd xe xf xh.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> table n y\n                           (genericJoin y (newQuery y xf (xa, xh))\n                             (newQuery y xe (xa, xh)));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> table n V (genericJoin V Q Qn)", "case False"], ["proof (state)\nthis:\n  \\<not> card V \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n     \\<And>x xa y xb xc xd xe xf xh.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> table n y\n                           (genericJoin y (newQuery y xf (xa, xh))\n                             (newQuery y xe (xa, xh)));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> table n V (genericJoin V Q Qn)", "obtain I J where \"(I, J) = getIJ Q Qn V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>I J.\n        (I, J) = getIJ Q Qn V \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis surj_pair)"], ["proof (state)\nthis:\n  (I, J) = getIJ Q Qn V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n     \\<And>x xa y xb xc xd xe xf xh.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> table n y\n                           (genericJoin y (newQuery y xf (xa, xh))\n                             (newQuery y xe (xa, xh)));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> table n V (genericJoin V Q Qn)", "define Q_I_pos where \"Q_I_pos = projectQuery I (filterQuery I Q)\""], ["proof (state)\nthis:\n  Q_I_pos = projectQuery I (filterQuery I Q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n     \\<And>x xa y xb xc xd xe xf xh.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> table n y\n                           (genericJoin y (newQuery y xf (xa, xh))\n                             (newQuery y xe (xa, xh)));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> table n V (genericJoin V Q Qn)", "define Q_I_neg where \"Q_I_neg = filterQueryNeg I Qn\""], ["proof (state)\nthis:\n  Q_I_neg = filterQueryNeg I Qn\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n     \\<And>x xa y xb xc xd xe xf xh.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> table n y\n                           (genericJoin y (newQuery y xf (xa, xh))\n                             (newQuery y xe (xa, xh)));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> table n V (genericJoin V Q Qn)", "define R_I where \"R_I = genericJoin I Q_I_pos Q_I_neg\""], ["proof (state)\nthis:\n  R_I = genericJoin I Q_I_pos Q_I_neg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n     \\<And>x xa y xb xc xd xe xf xh.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> table n y\n                           (genericJoin y (newQuery y xf (xa, xh))\n                             (newQuery y xe (xa, xh)));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> table n V (genericJoin V Q Qn)", "define Q_J_neg where \"Q_J_neg = filterQuery J (Qn - Q_I_neg)\""], ["proof (state)\nthis:\n  Q_J_neg = filterQuery J (Qn - Q_I_neg)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n     \\<And>x xa y xb xc xd xe xf xh.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> table n y\n                           (genericJoin y (newQuery y xf (xa, xh))\n                             (newQuery y xe (xa, xh)));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> table n V (genericJoin V Q Qn)", "define Q_J_pos where \"Q_J_pos = filterQuery J Q\""], ["proof (state)\nthis:\n  Q_J_pos = filterQuery J Q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n     \\<And>x xa y xb xc xd xe xf xh.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> table n y\n                           (genericJoin y (newQuery y xf (xa, xh))\n                             (newQuery y xe (xa, xh)));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> table n V (genericJoin V Q Qn)", "define X where \"X = {(t, genericJoin J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t))) | t . t \\<in> R_I}\""], ["proof (state)\nthis:\n  X =\n  {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n        (newQuery J Q_J_neg (I, t))) |\n   t. t \\<in> R_I}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n     \\<And>x xa y xb xc xd xe xf xh.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> table n y\n                           (genericJoin y (newQuery y xf (xa, xh))\n                             (newQuery y xe (xa, xh)));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> table n V (genericJoin V Q Qn)", "define R where \"R = (\\<Union>(t, x) \\<in> X. {merge xx t | xx . xx \\<in> x})\""], ["proof (state)\nthis:\n  R = (\\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n     \\<And>x xa y xb xc xd xe xf xh.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> table n y\n                           (genericJoin y (newQuery y xf (xa, xh))\n                             (newQuery y xe (xa, xh)));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> table n V (genericJoin V Q Qn)", "moreover"], ["proof (state)\nthis:\n  R = (\\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n     \\<And>x xa y xb xc xd xe xf xh.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> table n y\n                           (genericJoin y (newQuery y xf (xa, xh))\n                             (newQuery y xe (xa, xh)));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> table n V (genericJoin V Q Qn)", "have \"card V \\<ge> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> card V", "using False"], ["proof (prove)\nusing this:\n  \\<not> card V \\<le> 1\n\ngoal (1 subgoal):\n 1. 2 \\<le> card V", "by auto"], ["proof (state)\nthis:\n  2 \\<le> card V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n     \\<And>x xa y xb xc xd xe xf xh.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> table n y\n                           (genericJoin y (newQuery y xf (xa, xh))\n                             (newQuery y xe (xa, xh)));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> table n V (genericJoin V Q Qn)", "then"], ["proof (chain)\npicking this:\n  2 \\<le> card V", "have \"R = genericJoin V Q Qn\""], ["proof (prove)\nusing this:\n  2 \\<le> card V\n\ngoal (1 subgoal):\n 1. R = genericJoin V Q Qn", "using vars_genericJoin[where ?V=V and ?I=I and ?J=J and ?Q_I_pos=Q_I_pos and ?Q=Q and ?Qn=Qn and\n        ?Q_I_neg=Q_I_neg and ?R_I=R_I and ?Q_J_neg=Q_J_neg and ?Q_J_pos=Q_J_pos]"], ["proof (prove)\nusing this:\n  2 \\<le> card V\n  \\<lbrakk>2 \\<le> card V; (I, J) = getIJ Q Qn V;\n   Q_I_pos = projectQuery I (filterQuery I Q);\n   Q_I_neg = filterQueryNeg I Qn; R_I = genericJoin I Q_I_pos Q_I_neg;\n   Q_J_neg = filterQuery J (Qn - Q_I_neg); Q_J_pos = filterQuery J Q;\n   ?X =\n   {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n         (newQuery J Q_J_neg (I, t))) |\n    t. t \\<in> R_I};\n   ?R = (\\<Union>(t, x)\\<in>?X. {merge xx t |xx. xx \\<in> x});\n   rwf_query ?n V Q Qn\\<rbrakk>\n  \\<Longrightarrow> ?R = genericJoin V Q Qn\n\ngoal (1 subgoal):\n 1. R = genericJoin V Q Qn", "using \"1.prems\"(1) Q_I_neg_def Q_I_pos_def Q_J_neg_def Q_J_pos_def R_I_def X_def \\<open>(I, J) = getIJ Q Qn V\\<close> calculation"], ["proof (prove)\nusing this:\n  2 \\<le> card V\n  \\<lbrakk>2 \\<le> card V; (I, J) = getIJ Q Qn V;\n   Q_I_pos = projectQuery I (filterQuery I Q);\n   Q_I_neg = filterQueryNeg I Qn; R_I = genericJoin I Q_I_pos Q_I_neg;\n   Q_J_neg = filterQuery J (Qn - Q_I_neg); Q_J_pos = filterQuery J Q;\n   ?X =\n   {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n         (newQuery J Q_J_neg (I, t))) |\n    t. t \\<in> R_I};\n   ?R = (\\<Union>(t, x)\\<in>?X. {merge xx t |xx. xx \\<in> x});\n   rwf_query ?n V Q Qn\\<rbrakk>\n  \\<Longrightarrow> ?R = genericJoin V Q Qn\n  rwf_query n V Q Qn\n  Q_I_neg = filterQueryNeg I Qn\n  Q_I_pos = projectQuery I (filterQuery I Q)\n  Q_J_neg = filterQuery J (Qn - Q_I_neg)\n  Q_J_pos = filterQuery J Q\n  R_I = genericJoin I Q_I_pos Q_I_neg\n  X =\n  {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n        (newQuery J Q_J_neg (I, t))) |\n   t. t \\<in> R_I}\n  (I, J) = getIJ Q Qn V\n  R = (\\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})\n\ngoal (1 subgoal):\n 1. R = genericJoin V Q Qn", "by blast"], ["proof (state)\nthis:\n  R = genericJoin V Q Qn\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n     \\<And>x xa y xb xc xd xe xf xh.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> table n y\n                           (genericJoin y (newQuery y xf (xa, xh))\n                             (newQuery y xe (xa, xh)));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> table n V (genericJoin V Q Qn)", "obtain \"card I \\<ge> 1\" \"card J \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>1 \\<le> card I; 1 \\<le> card J\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>(I, J) = getIJ Q Qn V\\<close> \\<open>2 \\<le> card V\\<close> getIJ.getIJProperties(1) getIJProperties(2) getIJ_axioms"], ["proof (prove)\nusing this:\n  (I, J) = getIJ Q Qn V\n  2 \\<le> card V\n  \\<lbrakk>getIJ ?getIJ; 2 \\<le> card ?V;\n   (?I, ?J) = ?getIJ ?Q_pos ?Q_neg ?V\\<rbrakk>\n  \\<Longrightarrow> 1 \\<le> card ?I\n  \\<lbrakk>2 \\<le> card ?V; (?I, ?J) = getIJ ?Q_pos ?Q_neg ?V\\<rbrakk>\n  \\<Longrightarrow> 1 \\<le> card ?J\n  getIJ getIJ\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>1 \\<le> card I; 1 \\<le> card J\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  1 \\<le> card I\n  1 \\<le> card J\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n     \\<And>x xa y xb xc xd xe xf xh.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> table n y\n                           (genericJoin y (newQuery y xf (xa, xh))\n                             (newQuery y xe (xa, xh)));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> table n V (genericJoin V Q Qn)", "moreover"], ["proof (state)\nthis:\n  1 \\<le> card I\n  1 \\<le> card J\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n     \\<And>x xa y xb xc xd xe xf xh.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> table n y\n                           (genericJoin y (newQuery y xf (xa, xh))\n                             (newQuery y xe (xa, xh)));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> table n V (genericJoin V Q Qn)", "have \"rwf_query n I Q_I_pos Q_I_neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rwf_query n I Q_I_pos Q_I_neg", "using \"1.prems\"(1) Q_I_neg_def Q_I_pos_def \\<open>(I, J) = getIJ Q Qn V\\<close> \\<open>2 \\<le> card V\\<close> getIJ.wf_firstRecursiveCall getIJ_axioms"], ["proof (prove)\nusing this:\n  rwf_query n V Q Qn\n  Q_I_neg = filterQueryNeg I Qn\n  Q_I_pos = projectQuery I (filterQuery I Q)\n  (I, J) = getIJ Q Qn V\n  2 \\<le> card V\n  \\<lbrakk>getIJ ?getIJ; rwf_query ?n ?V ?Qp ?Qn; 2 \\<le> card ?V;\n   (?I, ?J) = ?getIJ ?Qp ?Qn ?V;\n   ?Q_I_pos = New_max.projectQuery ?I (New_max.filterQuery ?I ?Qp);\n   ?Q_I_neg = New_max.filterQueryNeg ?I ?Qn\\<rbrakk>\n  \\<Longrightarrow> rwf_query ?n ?I ?Q_I_pos ?Q_I_neg\n  getIJ getIJ\n\ngoal (1 subgoal):\n 1. rwf_query n I Q_I_pos Q_I_neg", "by blast"], ["proof (state)\nthis:\n  rwf_query n I Q_I_pos Q_I_neg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n     \\<And>x xa y xb xc xd xe xf xh.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> table n y\n                           (genericJoin y (newQuery y xf (xa, xh))\n                             (newQuery y xe (xa, xh)));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> table n V (genericJoin V Q Qn)", "moreover"], ["proof (state)\nthis:\n  rwf_query n I Q_I_pos Q_I_neg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n     \\<And>x xa y xb xc xd xe xf xh.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> table n y\n                           (genericJoin y (newQuery y xf (xa, xh))\n                             (newQuery y xe (xa, xh)));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> table n V (genericJoin V Q Qn)", "have \"\\<And>t. t\\<in>R_I \\<Longrightarrow> table n J (genericJoin J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> R_I \\<Longrightarrow>\n       table n J\n        (genericJoin J (newQuery J Q_J_pos (I, t))\n          (newQuery J Q_J_neg (I, t)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> R_I \\<Longrightarrow>\n       table n J\n        (genericJoin J (newQuery J Q_J_pos (I, t))\n          (newQuery J Q_J_neg (I, t)))", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> R_I \\<Longrightarrow>\n       table n J\n        (genericJoin J (newQuery J Q_J_pos (I, t))\n          (newQuery J Q_J_neg (I, t)))", "assume \"t \\<in> R_I\""], ["proof (state)\nthis:\n  t \\<in> R_I\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> R_I \\<Longrightarrow>\n       table n J\n        (genericJoin J (newQuery J Q_J_pos (I, t))\n          (newQuery J Q_J_neg (I, t)))", "have \"rwf_query n J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rwf_query n J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t))", "using \"1.prems\"(1) Q_J_neg_def Q_J_pos_def \\<open>(I, J) = getIJ Q Qn V\\<close> \\<open>2 \\<le> card V\\<close>\n          getIJ.wf_secondRecursiveCalls getIJ_axioms"], ["proof (prove)\nusing this:\n  rwf_query n V Q Qn\n  Q_J_neg = filterQuery J (Qn - Q_I_neg)\n  Q_J_pos = filterQuery J Q\n  (I, J) = getIJ Q Qn V\n  2 \\<le> card V\n  \\<lbrakk>getIJ ?getIJ; 2 \\<le> card ?V; rwf_query ?n ?V ?Q ?Qn;\n   (?I, ?J) = ?getIJ ?Q ?Qn ?V; ?Qns \\<subseteq> ?Qn;\n   ?Q_J_neg = New_max.filterQuery ?J ?Qns;\n   ?Q_J_pos = New_max.filterQuery ?J ?Q\\<rbrakk>\n  \\<Longrightarrow> rwf_query ?n ?J (New_max.newQuery ?J ?Q_J_pos ?t)\n                     (New_max.newQuery ?J ?Q_J_neg ?t)\n  getIJ getIJ\n\ngoal (1 subgoal):\n 1. rwf_query n J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t))", "by fastforce"], ["proof (state)\nthis:\n  rwf_query n J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> R_I \\<Longrightarrow>\n       table n J\n        (genericJoin J (newQuery J Q_J_pos (I, t))\n          (newQuery J Q_J_neg (I, t)))", "then"], ["proof (chain)\npicking this:\n  rwf_query n J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t))", "show \"table n J (genericJoin J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t)))\""], ["proof (prove)\nusing this:\n  rwf_query n J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t))\n\ngoal (1 subgoal):\n 1. table n J\n     (genericJoin J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t)))", "by (metis \"1.IH\"(2) \"1.prems\"(1) False Q_I_neg_def Q_J_neg_def Q_J_pos_def \\<open>(I, J) = getIJ Q Qn V\\<close>\n            \\<open>2 \\<le> card V\\<close> calculation(3) filter_Q_J_neg_same)"], ["proof (state)\nthis:\n  table n J\n   (genericJoin J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?t \\<in> R_I \\<Longrightarrow>\n  table n J\n   (genericJoin J (newQuery J Q_J_pos (I, ?t)) (newQuery J Q_J_neg (I, ?t)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n     \\<And>x xa y xb xc xd xe xf xh.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> table n y\n                           (genericJoin y (newQuery y xf (xa, xh))\n                             (newQuery y xe (xa, xh)));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> table n V (genericJoin V Q Qn)", "then"], ["proof (chain)\npicking this:\n  ?t \\<in> R_I \\<Longrightarrow>\n  table n J\n   (genericJoin J (newQuery J Q_J_pos (I, ?t)) (newQuery J Q_J_neg (I, ?t)))", "have \"\\<And>t xx. t \\<in> R_I \\<and> xx \\<in> (genericJoin J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t)))\n               \\<Longrightarrow> wf_tuple n V (merge xx t)\""], ["proof (prove)\nusing this:\n  ?t \\<in> R_I \\<Longrightarrow>\n  table n J\n   (genericJoin J (newQuery J Q_J_pos (I, ?t)) (newQuery J Q_J_neg (I, ?t)))\n\ngoal (1 subgoal):\n 1. \\<And>t xx.\n       t \\<in> R_I \\<and>\n       xx \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                 (newQuery J Q_J_neg (I, t)) \\<Longrightarrow>\n       wf_tuple n V (merge xx t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t xx.\n       \\<lbrakk>t \\<in> R_I \\<and>\n                xx \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                          (newQuery J Q_J_neg (I, t));\n        \\<And>t.\n           t \\<in> R_I \\<Longrightarrow>\n           table n J\n            (genericJoin J (newQuery J Q_J_pos (I, t))\n              (newQuery J Q_J_neg (I, t)))\\<rbrakk>\n       \\<Longrightarrow> wf_tuple n V (merge xx t)", "fix t xx"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t xx.\n       \\<lbrakk>t \\<in> R_I \\<and>\n                xx \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                          (newQuery J Q_J_neg (I, t));\n        \\<And>t.\n           t \\<in> R_I \\<Longrightarrow>\n           table n J\n            (genericJoin J (newQuery J Q_J_pos (I, t))\n              (newQuery J Q_J_neg (I, t)))\\<rbrakk>\n       \\<Longrightarrow> wf_tuple n V (merge xx t)", "assume \"t \\<in> R_I \\<and> xx \\<in> genericJoin J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t))\""], ["proof (state)\nthis:\n  t \\<in> R_I \\<and>\n  xx \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n            (newQuery J Q_J_neg (I, t))\n\ngoal (1 subgoal):\n 1. \\<And>t xx.\n       \\<lbrakk>t \\<in> R_I \\<and>\n                xx \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                          (newQuery J Q_J_neg (I, t));\n        \\<And>t.\n           t \\<in> R_I \\<Longrightarrow>\n           table n J\n            (genericJoin J (newQuery J Q_J_pos (I, t))\n              (newQuery J Q_J_neg (I, t)))\\<rbrakk>\n       \\<Longrightarrow> wf_tuple n V (merge xx t)", "have \"V = I \\<union> J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V = I \\<union> J", "using \\<open>(I, J) = getIJ Q Qn V\\<close> \\<open>2 \\<le> card V\\<close> getIJ.coreProperties getIJ_axioms"], ["proof (prove)\nusing this:\n  (I, J) = getIJ Q Qn V\n  2 \\<le> card V\n  \\<lbrakk>getIJ ?getIJ; 2 \\<le> card ?V;\n   ?getIJ ?Q_pos ?Q_neg ?V = (?I, ?J)\\<rbrakk>\n  \\<Longrightarrow> 1 \\<le> card ?I \\<and>\n                    1 \\<le> card ?J \\<and>\n                    ?V = ?I \\<union> ?J \\<and> ?I \\<inter> ?J = {}\n  getIJ getIJ\n\ngoal (1 subgoal):\n 1. V = I \\<union> J", "by metis"], ["proof (state)\nthis:\n  V = I \\<union> J\n\ngoal (1 subgoal):\n 1. \\<And>t xx.\n       \\<lbrakk>t \\<in> R_I \\<and>\n                xx \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                          (newQuery J Q_J_neg (I, t));\n        \\<And>t.\n           t \\<in> R_I \\<Longrightarrow>\n           table n J\n            (genericJoin J (newQuery J Q_J_pos (I, t))\n              (newQuery J Q_J_neg (I, t)))\\<rbrakk>\n       \\<Longrightarrow> wf_tuple n V (merge xx t)", "moreover"], ["proof (state)\nthis:\n  V = I \\<union> J\n\ngoal (1 subgoal):\n 1. \\<And>t xx.\n       \\<lbrakk>t \\<in> R_I \\<and>\n                xx \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                          (newQuery J Q_J_neg (I, t));\n        \\<And>t.\n           t \\<in> R_I \\<Longrightarrow>\n           table n J\n            (genericJoin J (newQuery J Q_J_pos (I, t))\n              (newQuery J Q_J_neg (I, t)))\\<rbrakk>\n       \\<Longrightarrow> wf_tuple n V (merge xx t)", "have \"wf_tuple n J xx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple n J xx", "using \\<open>\\<And>t. t \\<in> R_I \\<Longrightarrow> table n J (genericJoin J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t)))\\<close>\n          \\<open>t \\<in> R_I \\<and> xx \\<in> genericJoin J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t))\\<close> table_def"], ["proof (prove)\nusing this:\n  ?t \\<in> R_I \\<Longrightarrow>\n  table n J\n   (genericJoin J (newQuery J Q_J_pos (I, ?t)) (newQuery J Q_J_neg (I, ?t)))\n  t \\<in> R_I \\<and>\n  xx \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n            (newQuery J Q_J_neg (I, t))\n  table ?n ?V ?X = (\\<forall>x\\<in>?X. wf_tuple ?n ?V x)\n\ngoal (1 subgoal):\n 1. wf_tuple n J xx", "by blast"], ["proof (state)\nthis:\n  wf_tuple n J xx\n\ngoal (1 subgoal):\n 1. \\<And>t xx.\n       \\<lbrakk>t \\<in> R_I \\<and>\n                xx \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                          (newQuery J Q_J_neg (I, t));\n        \\<And>t.\n           t \\<in> R_I \\<Longrightarrow>\n           table n J\n            (genericJoin J (newQuery J Q_J_pos (I, t))\n              (newQuery J Q_J_neg (I, t)))\\<rbrakk>\n       \\<Longrightarrow> wf_tuple n V (merge xx t)", "moreover"], ["proof (state)\nthis:\n  wf_tuple n J xx\n\ngoal (1 subgoal):\n 1. \\<And>t xx.\n       \\<lbrakk>t \\<in> R_I \\<and>\n                xx \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                          (newQuery J Q_J_neg (I, t));\n        \\<And>t.\n           t \\<in> R_I \\<Longrightarrow>\n           table n J\n            (genericJoin J (newQuery J Q_J_pos (I, t))\n              (newQuery J Q_J_neg (I, t)))\\<rbrakk>\n       \\<Longrightarrow> wf_tuple n V (merge xx t)", "have \"wf_tuple n I t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple n I t", "by (metis \"1.IH\"(1) False Q_I_neg_def Q_I_pos_def\n            R_I_def \\<open>(I, J) = getIJ Q Qn V\\<close> \\<open>\\<And>thesis. (\\<lbrakk>1 \\<le> card I; 1 \\<le> card J\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\\<close>\n            \\<open>rwf_query n I Q_I_pos Q_I_neg\\<close> \\<open>t \\<in> R_I \\<and> xx \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n            (newQuery J Q_J_neg (I, t))\\<close> table_def)"], ["proof (state)\nthis:\n  wf_tuple n I t\n\ngoal (1 subgoal):\n 1. \\<And>t xx.\n       \\<lbrakk>t \\<in> R_I \\<and>\n                xx \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                          (newQuery J Q_J_neg (I, t));\n        \\<And>t.\n           t \\<in> R_I \\<Longrightarrow>\n           table n J\n            (genericJoin J (newQuery J Q_J_pos (I, t))\n              (newQuery J Q_J_neg (I, t)))\\<rbrakk>\n       \\<Longrightarrow> wf_tuple n V (merge xx t)", "then"], ["proof (chain)\npicking this:\n  wf_tuple n I t", "show \"wf_tuple n V (merge xx t)\""], ["proof (prove)\nusing this:\n  wf_tuple n I t\n\ngoal (1 subgoal):\n 1. wf_tuple n V (merge xx t)", "by (metis calculation(1) calculation(2) sup_commute wf_merge)"], ["proof (state)\nthis:\n  wf_tuple n V (merge xx t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?t \\<in> R_I \\<and>\n  ?xx\n  \\<in> genericJoin J (newQuery J Q_J_pos (I, ?t))\n         (newQuery J Q_J_neg (I, ?t)) \\<Longrightarrow>\n  wf_tuple n V (merge ?xx ?t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n     \\<And>x xa y xb xc xd xe xf xh.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> table n y\n                           (genericJoin y (newQuery y xf (xa, xh))\n                             (newQuery y xe (xa, xh)));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> table n V (genericJoin V Q Qn)", "then"], ["proof (chain)\npicking this:\n  ?t \\<in> R_I \\<and>\n  ?xx\n  \\<in> genericJoin J (newQuery J Q_J_pos (I, ?t))\n         (newQuery J Q_J_neg (I, ?t)) \\<Longrightarrow>\n  wf_tuple n V (merge ?xx ?t)", "have \"\\<forall>t\\<in>R_I. \\<forall>xx \\<in> (genericJoin J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t))).\n                wf_tuple n V (merge xx t)\""], ["proof (prove)\nusing this:\n  ?t \\<in> R_I \\<and>\n  ?xx\n  \\<in> genericJoin J (newQuery J Q_J_pos (I, ?t))\n         (newQuery J Q_J_neg (I, ?t)) \\<Longrightarrow>\n  wf_tuple n V (merge ?xx ?t)\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>R_I.\n       \\<forall>xx\\<in>genericJoin J (newQuery J Q_J_pos (I, t))\n                        (newQuery J Q_J_neg (I, t)).\n          wf_tuple n V (merge xx t)", "by blast"], ["proof (state)\nthis:\n  \\<forall>t\\<in>R_I.\n     \\<forall>xx\\<in>genericJoin J (newQuery J Q_J_pos (I, t))\n                      (newQuery J Q_J_neg (I, t)).\n        wf_tuple n V (merge xx t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n     \\<And>x xa y xb xc xd xe xf xh.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> table n y\n                           (genericJoin y (newQuery y xf (xa, xh))\n                             (newQuery y xe (xa, xh)));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> table n V (genericJoin V Q Qn)", "then"], ["proof (chain)\npicking this:\n  \\<forall>t\\<in>R_I.\n     \\<forall>xx\\<in>genericJoin J (newQuery J Q_J_pos (I, t))\n                      (newQuery J Q_J_neg (I, t)).\n        wf_tuple n V (merge xx t)", "have \"\\<forall>x\\<in>R. wf_tuple n V x\""], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>R_I.\n     \\<forall>xx\\<in>genericJoin J (newQuery J Q_J_pos (I, t))\n                      (newQuery J Q_J_neg (I, t)).\n        wf_tuple n V (merge xx t)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>R. wf_tuple n V x", "using R_def X_def"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>R_I.\n     \\<forall>xx\\<in>genericJoin J (newQuery J Q_J_pos (I, t))\n                      (newQuery J Q_J_neg (I, t)).\n        wf_tuple n V (merge xx t)\n  R = (\\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})\n  X =\n  {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n        (newQuery J Q_J_neg (I, t))) |\n   t. t \\<in> R_I}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>R. wf_tuple n V x", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>R. wf_tuple n V x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> table n xa (genericJoin xa xb xc);\n     \\<And>x xa y xb xc xd xe xf xh.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> table n y\n                           (genericJoin y (newQuery y xf (xa, xh))\n                             (newQuery y xe (xa, xh)));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> table n V (genericJoin V Q Qn)", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>R. wf_tuple n V x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>R. wf_tuple n V x\n\ngoal (1 subgoal):\n 1. table n V (genericJoin V Q Qn)", "using \\<open>R = genericJoin V Q Qn\\<close> table_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>R. wf_tuple n V x\n  R = genericJoin V Q Qn\n  table ?n ?V ?X = (\\<forall>x\\<in>?X. wf_tuple ?n ?V x)\n\ngoal (1 subgoal):\n 1. table n V (genericJoin V Q Qn)", "by blast"], ["proof (state)\nthis:\n  table n V (genericJoin V Q Qn)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  table n V (genericJoin V Q Qn)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Correctness\\<close>"], ["", "lemma base_correctness:\n  assumes \"card V = 1\"\n  assumes \"rwf_query n V Q Qn\"\n  assumes \"R = genericJoin V Q Qn\"\n  shows \"z \\<in> genericJoin V Q Qn \\<longleftrightarrow> wf_tuple n V z \\<and> (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<in> genericJoin V Q Qn) =\n    (wf_tuple n V z \\<and>\n     (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (z \\<in> genericJoin V Q Qn) =\n    (wf_tuple n V z \\<and>\n     (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))", "have \"z \\<in> genericJoin V Q Qn \\<Longrightarrow> wf_tuple n V z \\<and> (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> genericJoin V Q Qn \\<Longrightarrow>\n    wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<in> genericJoin V Q Qn \\<Longrightarrow>\n    wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<in> genericJoin V Q Qn \\<Longrightarrow>\n    wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)", "assume \"z \\<in> genericJoin V Q Qn\""], ["proof (state)\nthis:\n  z \\<in> genericJoin V Q Qn\n\ngoal (1 subgoal):\n 1. z \\<in> genericJoin V Q Qn \\<Longrightarrow>\n    wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)", "have \"wf_tuple n V z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple n V z", "by (meson \\<open>z \\<in> genericJoin V Q Qn\\<close> assms(1) assms(2) table_def wf_base_case)"], ["proof (state)\nthis:\n  wf_tuple n V z\n\ngoal (1 subgoal):\n 1. z \\<in> genericJoin V Q Qn \\<Longrightarrow>\n    wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)", "moreover"], ["proof (state)\nthis:\n  wf_tuple n V z\n\ngoal (1 subgoal):\n 1. z \\<in> genericJoin V Q Qn \\<Longrightarrow>\n    wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)", "have \"\\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X", "fix A X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X", "assume \"(A, X) \\<in> Q\""], ["proof (state)\nthis:\n  (A, X) \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X", "have \"A = V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A = V", "have \"card A \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> card A", "using \\<open>(A, X) \\<in> Q\\<close> assms(2) non_empty_query_def rwf_query_def"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q\n  rwf_query n V Q Qn\n  non_empty_query ?Q = (\\<forall>X\\<in>?Q. 1 \\<le> card (fst X))\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n\ngoal (1 subgoal):\n 1. 1 \\<le> card A", "by fastforce"], ["proof (state)\nthis:\n  1 \\<le> card A\n\ngoal (1 subgoal):\n 1. A = V", "moreover"], ["proof (state)\nthis:\n  1 \\<le> card A\n\ngoal (1 subgoal):\n 1. A = V", "have \"A \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> V", "using \\<open>(A, X) \\<in> Q\\<close> assms(2) included_def rwf_query_def"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q\n  rwf_query n V Q Qn\n  included ?V ?Q = (\\<forall>(S, X)\\<in>?Q. S \\<subseteq> ?V)\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n\ngoal (1 subgoal):\n 1. A \\<subseteq> V", "by fastforce"], ["proof (state)\nthis:\n  A \\<subseteq> V\n\ngoal (1 subgoal):\n 1. A = V", "then"], ["proof (chain)\npicking this:\n  A \\<subseteq> V", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<subseteq> V\n\ngoal (1 subgoal):\n 1. A = V", "by (metis One_nat_def assms(1) calculation card.infinite card_seteq nat.simps(3))"], ["proof (state)\nthis:\n  A = V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A = V\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  A = V", "have \"restrict A z = z\""], ["proof (prove)\nusing this:\n  A = V\n\ngoal (1 subgoal):\n 1. restrict A z = z", "using calculation restrict_idle"], ["proof (prove)\nusing this:\n  A = V\n  wf_tuple n V z\n  wf_tuple ?n ?A ?v \\<Longrightarrow> restrict ?A ?v = ?v\n\ngoal (1 subgoal):\n 1. restrict A z = z", "by blast"], ["proof (state)\nthis:\n  restrict A z = z\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X", "moreover"], ["proof (state)\nthis:\n  restrict A z = z\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X", "have \"z \\<in> (\\<Inter>(_, x) \\<in> Q. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> (\\<Inter>(uu_, x)\\<in>Q. x)", "using \\<open>z \\<in> genericJoin V Q Qn\\<close> assms(1)"], ["proof (prove)\nusing this:\n  z \\<in> genericJoin V Q Qn\n  card V = 1\n\ngoal (1 subgoal):\n 1. z \\<in> (\\<Inter>(uu_, x)\\<in>Q. x)", "by auto"], ["proof (state)\nthis:\n  z \\<in> (\\<Inter>(uu_, x)\\<in>Q. x)\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  z \\<in> (\\<Inter>(uu_, x)\\<in>Q. x)", "have \"z \\<in> X\""], ["proof (prove)\nusing this:\n  z \\<in> (\\<Inter>(uu_, x)\\<in>Q. x)\n\ngoal (1 subgoal):\n 1. z \\<in> X", "using INT_D \\<open>(A, X) \\<in> Q\\<close> case_prod_conv"], ["proof (prove)\nusing this:\n  z \\<in> (\\<Inter>(uu_, x)\\<in>Q. x)\n  \\<lbrakk>?b \\<in> \\<Inter> (?B ` ?A); ?a \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?b \\<in> ?B ?a\n  (A, X) \\<in> Q\n  (case (?a, ?b) of (c, d) \\<Rightarrow> ?f c d) = ?f ?a ?b\n\ngoal (1 subgoal):\n 1. z \\<in> X", "by auto"], ["proof (state)\nthis:\n  z \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  z \\<in> X", "show \"restrict A z \\<in> X\""], ["proof (prove)\nusing this:\n  z \\<in> X\n\ngoal (1 subgoal):\n 1. restrict A z \\<in> X", "using calculation"], ["proof (prove)\nusing this:\n  z \\<in> X\n  restrict A z = z\n\ngoal (1 subgoal):\n 1. restrict A z \\<in> X", "by auto"], ["proof (state)\nthis:\n  restrict A z \\<in> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?A, ?X) \\<in> Q \\<Longrightarrow> restrict ?A z \\<in> ?X\n\ngoal (1 subgoal):\n 1. z \\<in> genericJoin V Q Qn \\<Longrightarrow>\n    wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)", "moreover"], ["proof (state)\nthis:\n  (?A, ?X) \\<in> Q \\<Longrightarrow> restrict ?A z \\<in> ?X\n\ngoal (1 subgoal):\n 1. z \\<in> genericJoin V Q Qn \\<Longrightarrow>\n    wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)", "have \"\\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "fix A X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "assume \"(A, X) \\<in> Qn\""], ["proof (state)\nthis:\n  (A, X) \\<in> Qn\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "have \"card A \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> card A", "using \\<open>(A, X) \\<in> Qn\\<close> assms(2) non_empty_query_def rwf_query_def"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Qn\n  rwf_query n V Q Qn\n  non_empty_query ?Q = (\\<forall>X\\<in>?Q. 1 \\<le> card (fst X))\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n\ngoal (1 subgoal):\n 1. 1 \\<le> card A", "by fastforce"], ["proof (state)\nthis:\n  1 \\<le> card A\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "moreover"], ["proof (state)\nthis:\n  1 \\<le> card A\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "have \"A \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> V", "using \\<open>(A, X) \\<in> Qn\\<close> assms(2) included_def rwf_query_def"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Qn\n  rwf_query n V Q Qn\n  included ?V ?Q = (\\<forall>(S, X)\\<in>?Q. S \\<subseteq> ?V)\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n\ngoal (1 subgoal):\n 1. A \\<subseteq> V", "by blast"], ["proof (state)\nthis:\n  A \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "then"], ["proof (chain)\npicking this:\n  A \\<subseteq> V", "have \"A = V\""], ["proof (prove)\nusing this:\n  A \\<subseteq> V\n\ngoal (1 subgoal):\n 1. A = V", "by (metis assms(1) calculation card_gt_0_iff card_seteq zero_less_one)"], ["proof (state)\nthis:\n  A = V\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "then"], ["proof (chain)\npicking this:\n  A = V", "have \"restrict A z = z\""], ["proof (prove)\nusing this:\n  A = V\n\ngoal (1 subgoal):\n 1. restrict A z = z", "using \\<open>wf_tuple n V z\\<close> restrict_idle"], ["proof (prove)\nusing this:\n  A = V\n  wf_tuple n V z\n  wf_tuple ?n ?A ?v \\<Longrightarrow> restrict ?A ?v = ?v\n\ngoal (1 subgoal):\n 1. restrict A z = z", "by blast"], ["proof (state)\nthis:\n  restrict A z = z\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "moreover"], ["proof (state)\nthis:\n  restrict A z = z\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "have \"z \\<notin> (\\<Union>(_, x) \\<in> Qn. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> (\\<Union>(uu_, x)\\<in>Qn. x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<notin> (\\<Union>(uu_, x)\\<in>Qn. x)", "have \"z \\<in> (\\<Inter>(_, x) \\<in> Q. x) - (\\<Union>(_, x) \\<in> Qn. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x)", "using \\<open>z \\<in> genericJoin V Q Qn\\<close> assms(1)"], ["proof (prove)\nusing this:\n  z \\<in> genericJoin V Q Qn\n  card V = 1\n\ngoal (1 subgoal):\n 1. z \\<in> (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x)", "by auto"], ["proof (state)\nthis:\n  z \\<in> (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x)\n\ngoal (1 subgoal):\n 1. z \\<notin> (\\<Union>(uu_, x)\\<in>Qn. x)", "then"], ["proof (chain)\npicking this:\n  z \\<in> (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x)", "show ?thesis"], ["proof (prove)\nusing this:\n  z \\<in> (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x)\n\ngoal (1 subgoal):\n 1. z \\<notin> (\\<Union>(uu_, x)\\<in>Qn. x)", "by (metis DiffD2)"], ["proof (state)\nthis:\n  z \\<notin> (\\<Union>(uu_, x)\\<in>Qn. x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z \\<notin> (\\<Union>(uu_, x)\\<in>Qn. x)\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "then"], ["proof (chain)\npicking this:\n  z \\<notin> (\\<Union>(uu_, x)\\<in>Qn. x)", "show \"restrict A z \\<notin> X\""], ["proof (prove)\nusing this:\n  z \\<notin> (\\<Union>(uu_, x)\\<in>Qn. x)\n\ngoal (1 subgoal):\n 1. restrict A z \\<notin> X", "using UN_iff \\<open>(A, X) \\<in> Qn\\<close> calculation(2) prod.sel(2) snd_def"], ["proof (prove)\nusing this:\n  z \\<notin> (\\<Union>(uu_, x)\\<in>Qn. x)\n  (?b \\<in> \\<Union> (?B ` ?A)) = (\\<exists>x\\<in>?A. ?b \\<in> ?B x)\n  (A, X) \\<in> Qn\n  restrict A z = z\n  snd (?x1.0, ?x2.0) = ?x2.0\n  snd ?prod = (case ?prod of (x1, x2) \\<Rightarrow> x2)\n\ngoal (1 subgoal):\n 1. restrict A z \\<notin> X", "by auto"], ["proof (state)\nthis:\n  restrict A z \\<notin> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?A, ?X) \\<in> Qn \\<Longrightarrow> restrict ?A z \\<notin> ?X\n\ngoal (1 subgoal):\n 1. z \\<in> genericJoin V Q Qn \\<Longrightarrow>\n    wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)", "then"], ["proof (chain)\npicking this:\n  (?A, ?X) \\<in> Qn \\<Longrightarrow> restrict ?A z \\<notin> ?X", "show \"wf_tuple n V z \\<and> (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\""], ["proof (prove)\nusing this:\n  (?A, ?X) \\<in> Qn \\<Longrightarrow> restrict ?A z \\<notin> ?X\n\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)", "using calculation(1) calculation(2)"], ["proof (prove)\nusing this:\n  (?A, ?X) \\<in> Qn \\<Longrightarrow> restrict ?A z \\<notin> ?X\n  wf_tuple n V z\n  (?A, ?X) \\<in> Q \\<Longrightarrow> restrict ?A z \\<in> ?X\n\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)", "by blast"], ["proof (state)\nthis:\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z \\<in> genericJoin V Q Qn \\<Longrightarrow>\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\n\ngoal (1 subgoal):\n 1. (z \\<in> genericJoin V Q Qn) =\n    (wf_tuple n V z \\<and>\n     (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))", "moreover"], ["proof (state)\nthis:\n  z \\<in> genericJoin V Q Qn \\<Longrightarrow>\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\n\ngoal (1 subgoal):\n 1. (z \\<in> genericJoin V Q Qn) =\n    (wf_tuple n V z \\<and>\n     (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))", "have \"wf_tuple n V z \\<and> (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X) \\<Longrightarrow> z \\<in> genericJoin V Q Qn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X) \\<Longrightarrow>\n    z \\<in> genericJoin V Q Qn", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X) \\<Longrightarrow>\n    z \\<in> genericJoin V Q Qn", "assume \"wf_tuple n V z \\<and> (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\""], ["proof (state)\nthis:\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\n\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X) \\<Longrightarrow>\n    z \\<in> genericJoin V Q Qn", "have \"genericJoin V Q Qn = (\\<Inter>(_, x) \\<in> Q. x) - (\\<Union>(_, x) \\<in> Qn. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. genericJoin V Q Qn =\n    (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x)", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  genericJoin V Q Qn =\n  (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x)\n\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X) \\<Longrightarrow>\n    z \\<in> genericJoin V Q Qn", "moreover"], ["proof (state)\nthis:\n  genericJoin V Q Qn =\n  (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x)\n\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X) \\<Longrightarrow>\n    z \\<in> genericJoin V Q Qn", "have \"\\<forall>(A, X)\\<in>Q. restrict A z = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(A, X)\\<in>Q. restrict A z = z", "by (metis (mono_tags, lifting) One_nat_def \\<open>wf_tuple n V z \\<and> (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\\<close>\n          assms(1) assms(2) card.infinite card_seteq case_prod_beta' included_def nat.simps(3)\n          non_empty_query_def restrict_idle rwf_query_def)"], ["proof (state)\nthis:\n  \\<forall>(A, X)\\<in>Q. restrict A z = z\n\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X) \\<Longrightarrow>\n    z \\<in> genericJoin V Q Qn", "moreover"], ["proof (state)\nthis:\n  \\<forall>(A, X)\\<in>Q. restrict A z = z\n\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X) \\<Longrightarrow>\n    z \\<in> genericJoin V Q Qn", "have \"card Q \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> card Q", "using assms(2) rwf_query_def wf_query_def"], ["proof (prove)\nusing this:\n  rwf_query n V Q Qn\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n  wf_query ?n ?V ?Q_pos ?Q_neg =\n  ((\\<forall>X\\<in>?Q_pos \\<union> ?Q_neg. wf_atable ?n X) \\<and>\n   wf_set ?n ?V \\<and> 1 \\<le> card ?Q_pos)\n\ngoal (1 subgoal):\n 1. 1 \\<le> card Q", "by blast"], ["proof (state)\nthis:\n  1 \\<le> card Q\n\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X) \\<Longrightarrow>\n    z \\<in> genericJoin V Q Qn", "moreover"], ["proof (state)\nthis:\n  1 \\<le> card Q\n\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X) \\<Longrightarrow>\n    z \\<in> genericJoin V Q Qn", "have \"z \\<notin> (\\<Union>(_, x) \\<in> Qn. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> (\\<Union>(uu_, x)\\<in>Qn. x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<notin> (\\<Union>(uu_, x)\\<in>Qn. x)", "have \"\\<forall>(_, x) \\<in> Qn. z \\<notin> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(uu_, x)\\<in>Qn. z \\<notin> x", "by (metis (mono_tags, lifting) One_nat_def \\<open>wf_tuple n V z \\<and> (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\\<close>\n            assms(1) assms(2) card.infinite card_seteq case_prod_beta' included_def nat.simps(3)\n            non_empty_query_def restrict_idle rwf_query_def)"], ["proof (state)\nthis:\n  \\<forall>(uu_, x)\\<in>Qn. z \\<notin> x\n\ngoal (1 subgoal):\n 1. z \\<notin> (\\<Union>(uu_, x)\\<in>Qn. x)", "then"], ["proof (chain)\npicking this:\n  \\<forall>(uu_, x)\\<in>Qn. z \\<notin> x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>(uu_, x)\\<in>Qn. z \\<notin> x\n\ngoal (1 subgoal):\n 1. z \\<notin> (\\<Union>(uu_, x)\\<in>Qn. x)", "using UN_iff case_prod_beta'"], ["proof (prove)\nusing this:\n  \\<forall>(uu_, x)\\<in>Qn. z \\<notin> x\n  (?b \\<in> \\<Union> (?B ` ?A)) = (\\<exists>x\\<in>?A. ?b \\<in> ?B x)\n  (\\<lambda>(x, y). ?f x y) = (\\<lambda>x. ?f (fst x) (snd x))\n\ngoal (1 subgoal):\n 1. z \\<notin> (\\<Union>(uu_, x)\\<in>Qn. x)", "by auto"], ["proof (state)\nthis:\n  z \\<notin> (\\<Union>(uu_, x)\\<in>Qn. x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z \\<notin> (\\<Union>(uu_, x)\\<in>Qn. x)\n\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X) \\<Longrightarrow>\n    z \\<in> genericJoin V Q Qn", "moreover"], ["proof (state)\nthis:\n  z \\<notin> (\\<Union>(uu_, x)\\<in>Qn. x)\n\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X) \\<Longrightarrow>\n    z \\<in> genericJoin V Q Qn", "have \"z \\<in> (\\<Inter>(_, x) \\<in> Q. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> (\\<Inter>(uu_, x)\\<in>Q. x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<in> (\\<Inter>(uu_, x)\\<in>Q. x)", "have \"\\<forall>(_, x) \\<in> Q. z \\<in> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(uu_, x)\\<in>Q. z \\<in> x", "using \\<open>wf_tuple n V z \\<and> (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\\<close> calculation(2)"], ["proof (prove)\nusing this:\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\n  \\<forall>(A, X)\\<in>Q. restrict A z = z\n\ngoal (1 subgoal):\n 1. \\<forall>(uu_, x)\\<in>Q. z \\<in> x", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>(uu_, x)\\<in>Q. z \\<in> x\n\ngoal (1 subgoal):\n 1. z \\<in> (\\<Inter>(uu_, x)\\<in>Q. x)", "then"], ["proof (chain)\npicking this:\n  \\<forall>(uu_, x)\\<in>Q. z \\<in> x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>(uu_, x)\\<in>Q. z \\<in> x\n\ngoal (1 subgoal):\n 1. z \\<in> (\\<Inter>(uu_, x)\\<in>Q. x)", "using INT_I case_prod_beta'"], ["proof (prove)\nusing this:\n  \\<forall>(uu_, x)\\<in>Q. z \\<in> x\n  (\\<And>x. x \\<in> ?A \\<Longrightarrow> ?b \\<in> ?B x) \\<Longrightarrow>\n  ?b \\<in> \\<Inter> (?B ` ?A)\n  (\\<lambda>(x, y). ?f x y) = (\\<lambda>x. ?f (fst x) (snd x))\n\ngoal (1 subgoal):\n 1. z \\<in> (\\<Inter>(uu_, x)\\<in>Q. x)", "by auto"], ["proof (state)\nthis:\n  z \\<in> (\\<Inter>(uu_, x)\\<in>Q. x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z \\<in> (\\<Inter>(uu_, x)\\<in>Q. x)\n\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X) \\<Longrightarrow>\n    z \\<in> genericJoin V Q Qn", "ultimately"], ["proof (chain)\npicking this:\n  genericJoin V Q Qn =\n  (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x)\n  \\<forall>(A, X)\\<in>Q. restrict A z = z\n  1 \\<le> card Q\n  z \\<notin> (\\<Union>(uu_, x)\\<in>Qn. x)\n  z \\<in> (\\<Inter>(uu_, x)\\<in>Q. x)", "show ?thesis"], ["proof (prove)\nusing this:\n  genericJoin V Q Qn =\n  (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x)\n  \\<forall>(A, X)\\<in>Q. restrict A z = z\n  1 \\<le> card Q\n  z \\<notin> (\\<Union>(uu_, x)\\<in>Qn. x)\n  z \\<in> (\\<Inter>(uu_, x)\\<in>Q. x)\n\ngoal (1 subgoal):\n 1. z \\<in> genericJoin V Q Qn", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>genericJoin V Q Qn =\n             (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x);\n     \\<forall>(A, X)\\<in>Q. restrict A z = z; 1 \\<le> card Q;\n     z \\<notin> (\\<Union>(uu_, x)\\<in>Qn. x);\n     z \\<in> (\\<Inter>(uu_, x)\\<in>Q. x)\\<rbrakk>\n    \\<Longrightarrow> z \\<in> genericJoin V Q Qn", "have \"genericJoin V Q Qn \\<subseteq> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. genericJoin V Q Qn \\<subseteq> R", "using assms(3)"], ["proof (prove)\nusing this:\n  R = genericJoin V Q Qn\n\ngoal (1 subgoal):\n 1. genericJoin V Q Qn \\<subseteq> R", "by blast"], ["proof (state)\nthis:\n  genericJoin V Q Qn \\<subseteq> R\n\ngoal (1 subgoal):\n 1. \\<lbrakk>genericJoin V Q Qn =\n             (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x);\n     \\<forall>(A, X)\\<in>Q. restrict A z = z; 1 \\<le> card Q;\n     z \\<notin> (\\<Union>(uu_, x)\\<in>Qn. x);\n     z \\<in> (\\<Inter>(uu_, x)\\<in>Q. x)\\<rbrakk>\n    \\<Longrightarrow> z \\<in> genericJoin V Q Qn", "then"], ["proof (chain)\npicking this:\n  genericJoin V Q Qn \\<subseteq> R", "have \"(\\<Inter>(N, Z)\\<in>Q. Z) - (\\<Union>(N, Z)\\<in>Qn. Z) \\<subseteq> R\""], ["proof (prove)\nusing this:\n  genericJoin V Q Qn \\<subseteq> R\n\ngoal (1 subgoal):\n 1. (\\<Inter>(N, Z)\\<in>Q. Z) - (\\<Union>(N, Z)\\<in>Qn. Z) \\<subseteq> R", "by (metis \\<open>genericJoin V Q Qn = (\\<Inter>(_, x)\\<in>Q. x) - (\\<Union>(_, x)\\<in>Qn. x)\\<close>)"], ["proof (state)\nthis:\n  (\\<Inter>(N, Z)\\<in>Q. Z) - (\\<Union>(N, Z)\\<in>Qn. Z) \\<subseteq> R\n\ngoal (1 subgoal):\n 1. \\<lbrakk>genericJoin V Q Qn =\n             (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x);\n     \\<forall>(A, X)\\<in>Q. restrict A z = z; 1 \\<le> card Q;\n     z \\<notin> (\\<Union>(uu_, x)\\<in>Qn. x);\n     z \\<in> (\\<Inter>(uu_, x)\\<in>Q. x)\\<rbrakk>\n    \\<Longrightarrow> z \\<in> genericJoin V Q Qn", "then"], ["proof (chain)\npicking this:\n  (\\<Inter>(N, Z)\\<in>Q. Z) - (\\<Union>(N, Z)\\<in>Qn. Z) \\<subseteq> R", "have \"\\<exists>Z Za. Z - Za \\<subseteq> R \\<and> z \\<notin> Za \\<and> z \\<in> Z\""], ["proof (prove)\nusing this:\n  (\\<Inter>(N, Z)\\<in>Q. Z) - (\\<Union>(N, Z)\\<in>Qn. Z) \\<subseteq> R\n\ngoal (1 subgoal):\n 1. \\<exists>Z Za.\n       Z - Za \\<subseteq> R \\<and> z \\<notin> Za \\<and> z \\<in> Z", "by (metis \\<open>z \\<in> (\\<Inter>(_, x)\\<in>Q. x)\\<close> \\<open>z \\<notin> (\\<Union>(_, x)\\<in>Qn. x)\\<close>)"], ["proof (state)\nthis:\n  \\<exists>Z Za. Z - Za \\<subseteq> R \\<and> z \\<notin> Za \\<and> z \\<in> Z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>genericJoin V Q Qn =\n             (\\<Inter>(uu_, x)\\<in>Q. x) - (\\<Union>(uu_, x)\\<in>Qn. x);\n     \\<forall>(A, X)\\<in>Q. restrict A z = z; 1 \\<le> card Q;\n     z \\<notin> (\\<Union>(uu_, x)\\<in>Qn. x);\n     z \\<in> (\\<Inter>(uu_, x)\\<in>Q. x)\\<rbrakk>\n    \\<Longrightarrow> z \\<in> genericJoin V Q Qn", "then"], ["proof (chain)\npicking this:\n  \\<exists>Z Za. Z - Za \\<subseteq> R \\<and> z \\<notin> Za \\<and> z \\<in> Z", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>Z Za. Z - Za \\<subseteq> R \\<and> z \\<notin> Za \\<and> z \\<in> Z\n\ngoal (1 subgoal):\n 1. z \\<in> genericJoin V Q Qn", "using assms(3)"], ["proof (prove)\nusing this:\n  \\<exists>Z Za. Z - Za \\<subseteq> R \\<and> z \\<notin> Za \\<and> z \\<in> Z\n  R = genericJoin V Q Qn\n\ngoal (1 subgoal):\n 1. z \\<in> genericJoin V Q Qn", "by blast"], ["proof (state)\nthis:\n  z \\<in> genericJoin V Q Qn\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z \\<in> genericJoin V Q Qn\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X) \\<Longrightarrow>\n  z \\<in> genericJoin V Q Qn\n\ngoal (1 subgoal):\n 1. (z \\<in> genericJoin V Q Qn) =\n    (wf_tuple n V z \\<and>\n     (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))", "then"], ["proof (chain)\npicking this:\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X) \\<Longrightarrow>\n  z \\<in> genericJoin V Q Qn", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X) \\<Longrightarrow>\n  z \\<in> genericJoin V Q Qn\n\ngoal (1 subgoal):\n 1. (z \\<in> genericJoin V Q Qn) =\n    (wf_tuple n V z \\<and>\n     (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))", "using calculation"], ["proof (prove)\nusing this:\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X) \\<Longrightarrow>\n  z \\<in> genericJoin V Q Qn\n  z \\<in> genericJoin V Q Qn \\<Longrightarrow>\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\n\ngoal (1 subgoal):\n 1. (z \\<in> genericJoin V Q Qn) =\n    (wf_tuple n V z \\<and>\n     (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))", "by linarith"], ["proof (state)\nthis:\n  (z \\<in> genericJoin V Q Qn) =\n  (wf_tuple n V z \\<and>\n   (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simple_list_index_equality:\n  assumes \"length a = n\"\n  assumes \"length b = n\"\n  assumes \"\\<forall>i < n. a!i = b!i\"\n  shows \"a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = b", "using assms(1) assms(2) assms(3) nth_equalityI"], ["proof (prove)\nusing this:\n  length a = n\n  length b = n\n  \\<forall>i<n. a ! i = b ! i\n  \\<lbrakk>length ?xs = length ?ys;\n   \\<And>i. i < length ?xs \\<Longrightarrow> ?xs ! i = ?ys ! i\\<rbrakk>\n  \\<Longrightarrow> ?xs = ?ys\n\ngoal (1 subgoal):\n 1. a = b", "by force"], ["", "lemma simple_restrict_none:\n  assumes \"i < length X\"\n  assumes \"i \\<notin> A\"\n  shows \"(restrict A X)!i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict A X ! i = None", "by (simp add: assms(1) assms(2) restrict_def)"], ["", "lemma simple_restrict_some:\n  assumes \"i < length X\"\n  assumes \"i \\<in> A\"\n  shows \"(restrict A X)!i = X!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict A X ! i = X ! i", "by (simp add: assms(1) assms(2) restrict_def)"], ["", "lemma merge_restrict:\n  assumes \"A \\<inter> J = {}\"\n  assumes \"A \\<subseteq> I\"\n  assumes \"length xx = n\"\n  assumes \"length t = n\"\n  assumes \"restrict J xx = xx\"\n  shows \"restrict A (merge xx t) = restrict A t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict A (merge xx t) = restrict A t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. restrict A (merge xx t) = restrict A t", "have \"\\<And>i. i < n \\<Longrightarrow> (restrict A (merge xx t))!i = (restrict A t)!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       restrict A (merge xx t) ! i = restrict A t ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       restrict A (merge xx t) ! i = restrict A t ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       restrict A (merge xx t) ! i = restrict A t ! i", "assume \"i < n\""], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       restrict A (merge xx t) ! i = restrict A t ! i", "show \"(restrict A (merge xx t))!i = (restrict A t)!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict A (merge xx t) ! i = restrict A t ! i", "proof (cases \"i \\<in> A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<in> A \\<Longrightarrow>\n    restrict A (merge xx t) ! i = restrict A t ! i\n 2. i \\<notin> A \\<Longrightarrow>\n    restrict A (merge xx t) ! i = restrict A t ! i", "case True"], ["proof (state)\nthis:\n  i \\<in> A\n\ngoal (2 subgoals):\n 1. i \\<in> A \\<Longrightarrow>\n    restrict A (merge xx t) ! i = restrict A t ! i\n 2. i \\<notin> A \\<Longrightarrow>\n    restrict A (merge xx t) ! i = restrict A t ! i", "have \"(restrict A t)!i = t!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict A t ! i = t ! i", "by (simp add: True \\<open>i < n\\<close> assms(4) nth_restrict)"], ["proof (state)\nthis:\n  restrict A t ! i = t ! i\n\ngoal (2 subgoals):\n 1. i \\<in> A \\<Longrightarrow>\n    restrict A (merge xx t) ! i = restrict A t ! i\n 2. i \\<notin> A \\<Longrightarrow>\n    restrict A (merge xx t) ! i = restrict A t ! i", "moreover"], ["proof (state)\nthis:\n  restrict A t ! i = t ! i\n\ngoal (2 subgoals):\n 1. i \\<in> A \\<Longrightarrow>\n    restrict A (merge xx t) ! i = restrict A t ! i\n 2. i \\<notin> A \\<Longrightarrow>\n    restrict A (merge xx t) ! i = restrict A t ! i", "have \"(restrict A (merge xx t))!i = t!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict A (merge xx t) ! i = t ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. restrict A (merge xx t) ! i = t ! i", "have \"xx!i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xx ! i = None", "by (metis True \\<open>i < n\\<close> assms(1) assms(3) assms(5) disjoint_iff_not_equal simple_restrict_none)"], ["proof (state)\nthis:\n  xx ! i = None\n\ngoal (1 subgoal):\n 1. restrict A (merge xx t) ! i = t ! i", "obtain \"length xx = length t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (length xx = length t \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (simp add: assms(3) assms(4))"], ["proof (state)\nthis:\n  length xx = length t\n\ngoal (1 subgoal):\n 1. restrict A (merge xx t) ! i = t ! i", "moreover"], ["proof (state)\nthis:\n  length xx = length t\n\ngoal (1 subgoal):\n 1. restrict A (merge xx t) ! i = t ! i", "have \"(merge xx t)!i = merge_option (xx!i, t!i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge xx t ! i = merge_option (xx ! i, t ! i)", "using \\<open>i < n\\<close> \\<open>length xx = length t\\<close> assms(3)"], ["proof (prove)\nusing this:\n  i < n\n  length xx = length t\n  length xx = n\n\ngoal (1 subgoal):\n 1. merge xx t ! i = merge_option (xx ! i, t ! i)", "by auto"], ["proof (state)\nthis:\n  merge xx t ! i = merge_option (xx ! i, t ! i)\n\ngoal (1 subgoal):\n 1. restrict A (merge xx t) ! i = t ! i", "moreover"], ["proof (state)\nthis:\n  merge xx t ! i = merge_option (xx ! i, t ! i)\n\ngoal (1 subgoal):\n 1. restrict A (merge xx t) ! i = t ! i", "have \"merge_option (None, t!i) = t!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_option (None, t ! i) = t ! i", "by (metis merge_option.simps(1) merge_option.simps(3) option.exhaust)"], ["proof (state)\nthis:\n  merge_option (None, t ! i) = t ! i\n\ngoal (1 subgoal):\n 1. restrict A (merge xx t) ! i = t ! i", "then"], ["proof (chain)\npicking this:\n  merge_option (None, t ! i) = t ! i", "have \"(merge xx t)!i = t!i\""], ["proof (prove)\nusing this:\n  merge_option (None, t ! i) = t ! i\n\ngoal (1 subgoal):\n 1. merge xx t ! i = t ! i", "using \\<open>xx ! i = None\\<close> calculation(2)"], ["proof (prove)\nusing this:\n  merge_option (None, t ! i) = t ! i\n  xx ! i = None\n  merge xx t ! i = merge_option (xx ! i, t ! i)\n\ngoal (1 subgoal):\n 1. merge xx t ! i = t ! i", "by auto"], ["proof (state)\nthis:\n  merge xx t ! i = t ! i\n\ngoal (1 subgoal):\n 1. restrict A (merge xx t) ! i = t ! i", "moreover"], ["proof (state)\nthis:\n  merge xx t ! i = t ! i\n\ngoal (1 subgoal):\n 1. restrict A (merge xx t) ! i = t ! i", "have \"(restrict A (merge xx t))!i = (merge xx t)!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict A (merge xx t) ! i = merge xx t ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. restrict A (merge xx t) ! i = merge xx t ! i", "have \"length (zip xx t) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (zip xx t) = n", "using assms(3) calculation(1)"], ["proof (prove)\nusing this:\n  length xx = n\n  length xx = length t\n\ngoal (1 subgoal):\n 1. length (zip xx t) = n", "by auto"], ["proof (state)\nthis:\n  length (zip xx t) = n\n\ngoal (1 subgoal):\n 1. restrict A (merge xx t) ! i = merge xx t ! i", "then"], ["proof (chain)\npicking this:\n  length (zip xx t) = n", "have \"length (merge xx t) = n\""], ["proof (prove)\nusing this:\n  length (zip xx t) = n\n\ngoal (1 subgoal):\n 1. length (merge xx t) = n", "by simp"], ["proof (state)\nthis:\n  length (merge xx t) = n\n\ngoal (1 subgoal):\n 1. restrict A (merge xx t) ! i = merge xx t ! i", "then"], ["proof (chain)\npicking this:\n  length (merge xx t) = n", "show ?thesis"], ["proof (prove)\nusing this:\n  length (merge xx t) = n\n\ngoal (1 subgoal):\n 1. restrict A (merge xx t) ! i = merge xx t ! i", "by (simp add: True \\<open>i < n\\<close> nth_restrict)"], ["proof (state)\nthis:\n  restrict A (merge xx t) ! i = merge xx t ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict A (merge xx t) ! i = merge xx t ! i\n\ngoal (1 subgoal):\n 1. restrict A (merge xx t) ! i = t ! i", "then"], ["proof (chain)\npicking this:\n  restrict A (merge xx t) ! i = merge xx t ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  restrict A (merge xx t) ! i = merge xx t ! i\n\ngoal (1 subgoal):\n 1. restrict A (merge xx t) ! i = t ! i", "using calculation(3)"], ["proof (prove)\nusing this:\n  restrict A (merge xx t) ! i = merge xx t ! i\n  merge xx t ! i = t ! i\n\ngoal (1 subgoal):\n 1. restrict A (merge xx t) ! i = t ! i", "by auto"], ["proof (state)\nthis:\n  restrict A (merge xx t) ! i = t ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict A (merge xx t) ! i = t ! i\n\ngoal (2 subgoals):\n 1. i \\<in> A \\<Longrightarrow>\n    restrict A (merge xx t) ! i = restrict A t ! i\n 2. i \\<notin> A \\<Longrightarrow>\n    restrict A (merge xx t) ! i = restrict A t ! i", "then"], ["proof (chain)\npicking this:\n  restrict A (merge xx t) ! i = t ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  restrict A (merge xx t) ! i = t ! i\n\ngoal (1 subgoal):\n 1. restrict A (merge xx t) ! i = restrict A t ! i", "by (simp add: calculation)"], ["proof (state)\nthis:\n  restrict A (merge xx t) ! i = restrict A t ! i\n\ngoal (1 subgoal):\n 1. i \\<notin> A \\<Longrightarrow>\n    restrict A (merge xx t) ! i = restrict A t ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<notin> A \\<Longrightarrow>\n    restrict A (merge xx t) ! i = restrict A t ! i", "case False"], ["proof (state)\nthis:\n  i \\<notin> A\n\ngoal (1 subgoal):\n 1. i \\<notin> A \\<Longrightarrow>\n    restrict A (merge xx t) ! i = restrict A t ! i", "have \"(restrict A t)!i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict A t ! i = None", "by (simp add: False \\<open>i < n\\<close> assms(4) restrict_def)"], ["proof (state)\nthis:\n  restrict A t ! i = None\n\ngoal (1 subgoal):\n 1. i \\<notin> A \\<Longrightarrow>\n    restrict A (merge xx t) ! i = restrict A t ! i", "obtain \"length xx = n\" and \"length t = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>length xx = n; length t = n\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: assms(3) assms(4))"], ["proof (state)\nthis:\n  length xx = n\n  length t = n\n\ngoal (1 subgoal):\n 1. i \\<notin> A \\<Longrightarrow>\n    restrict A (merge xx t) ! i = restrict A t ! i", "then"], ["proof (chain)\npicking this:\n  length xx = n\n  length t = n", "have \"length (merge xx t) = n\""], ["proof (prove)\nusing this:\n  length xx = n\n  length t = n\n\ngoal (1 subgoal):\n 1. length (merge xx t) = n", "by simp"], ["proof (state)\nthis:\n  length (merge xx t) = n\n\ngoal (1 subgoal):\n 1. i \\<notin> A \\<Longrightarrow>\n    restrict A (merge xx t) ! i = restrict A t ! i", "moreover"], ["proof (state)\nthis:\n  length (merge xx t) = n\n\ngoal (1 subgoal):\n 1. i \\<notin> A \\<Longrightarrow>\n    restrict A (merge xx t) ! i = restrict A t ! i", "have \"(restrict A (merge xx t))!i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict A (merge xx t) ! i = None", "using False \\<open>i < n\\<close> calculation simple_restrict_none"], ["proof (prove)\nusing this:\n  i \\<notin> A\n  i < n\n  length (merge xx t) = n\n  \\<lbrakk>?i < length ?X; ?i \\<notin> ?A\\<rbrakk>\n  \\<Longrightarrow> restrict ?A ?X ! ?i = None\n\ngoal (1 subgoal):\n 1. restrict A (merge xx t) ! i = None", "by blast"], ["proof (state)\nthis:\n  restrict A (merge xx t) ! i = None\n\ngoal (1 subgoal):\n 1. i \\<notin> A \\<Longrightarrow>\n    restrict A (merge xx t) ! i = restrict A t ! i", "then"], ["proof (chain)\npicking this:\n  restrict A (merge xx t) ! i = None", "show ?thesis"], ["proof (prove)\nusing this:\n  restrict A (merge xx t) ! i = None\n\ngoal (1 subgoal):\n 1. restrict A (merge xx t) ! i = restrict A t ! i", "by (simp add: \\<open>restrict A t ! i = None\\<close>)"], ["proof (state)\nthis:\n  restrict A (merge xx t) ! i = restrict A t ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict A (merge xx t) ! i = restrict A t ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> restrict A (merge xx t) ! ?i = restrict A t ! ?i\n\ngoal (1 subgoal):\n 1. restrict A (merge xx t) = restrict A t", "then"], ["proof (chain)\npicking this:\n  ?i < n \\<Longrightarrow> restrict A (merge xx t) ! ?i = restrict A t ! ?i", "have \"\\<forall>i < n. (restrict A (merge xx t))!i = (restrict A t)!i\""], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow> restrict A (merge xx t) ! ?i = restrict A t ! ?i\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. restrict A (merge xx t) ! i = restrict A t ! i", "by blast"], ["proof (state)\nthis:\n  \\<forall>i<n. restrict A (merge xx t) ! i = restrict A t ! i\n\ngoal (1 subgoal):\n 1. restrict A (merge xx t) = restrict A t", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<n. restrict A (merge xx t) ! i = restrict A t ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i<n. restrict A (merge xx t) ! i = restrict A t ! i\n\ngoal (1 subgoal):\n 1. restrict A (merge xx t) = restrict A t", "using simple_list_index_equality[where ?a=\"restrict A (merge xx t)\" and ?b=\"restrict A t\" and ?n=\"n\"]\n      assms(3) assms(4)"], ["proof (prove)\nusing this:\n  \\<forall>i<n. restrict A (merge xx t) ! i = restrict A t ! i\n  \\<lbrakk>length (restrict A (merge xx t)) = n; length (restrict A t) = n;\n   \\<forall>i<n. restrict A (merge xx t) ! i = restrict A t ! i\\<rbrakk>\n  \\<Longrightarrow> restrict A (merge xx t) = restrict A t\n  length xx = n\n  length t = n\n\ngoal (1 subgoal):\n 1. restrict A (merge xx t) = restrict A t", "by simp"], ["proof (state)\nthis:\n  restrict A (merge xx t) = restrict A t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma restrict_idle_include:\n  assumes \"wf_tuple n A v\"\n  assumes \"A \\<subseteq> I\"\n  shows \"restrict I v = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict I v = v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. restrict I v = v", "have \"\\<And>i. i < length v \\<Longrightarrow> (restrict I v)!i = v!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i < length v \\<Longrightarrow> restrict I v ! i = v ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length v \\<Longrightarrow> restrict I v ! i = v ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length v \\<Longrightarrow> restrict I v ! i = v ! i", "assume \"i < length v\""], ["proof (state)\nthis:\n  i < length v\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length v \\<Longrightarrow> restrict I v ! i = v ! i", "show \"(restrict I v)!i = v!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict I v ! i = v ! i", "proof (cases \"i \\<in> A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<in> A \\<Longrightarrow> restrict I v ! i = v ! i\n 2. i \\<notin> A \\<Longrightarrow> restrict I v ! i = v ! i", "case True"], ["proof (state)\nthis:\n  i \\<in> A\n\ngoal (2 subgoals):\n 1. i \\<in> A \\<Longrightarrow> restrict I v ! i = v ! i\n 2. i \\<notin> A \\<Longrightarrow> restrict I v ! i = v ! i", "then"], ["proof (chain)\npicking this:\n  i \\<in> A", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<in> A\n\ngoal (1 subgoal):\n 1. restrict I v ! i = v ! i", "using \\<open>i < length v\\<close> assms(2) nth_restrict"], ["proof (prove)\nusing this:\n  i \\<in> A\n  i < length v\n  A \\<subseteq> I\n  \\<lbrakk>?i \\<in> ?A; ?i < length ?v\\<rbrakk>\n  \\<Longrightarrow> restrict ?A ?v ! ?i = ?v ! ?i\n\ngoal (1 subgoal):\n 1. restrict I v ! i = v ! i", "by blast"], ["proof (state)\nthis:\n  restrict I v ! i = v ! i\n\ngoal (1 subgoal):\n 1. i \\<notin> A \\<Longrightarrow> restrict I v ! i = v ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<notin> A \\<Longrightarrow> restrict I v ! i = v ! i", "case False"], ["proof (state)\nthis:\n  i \\<notin> A\n\ngoal (1 subgoal):\n 1. i \\<notin> A \\<Longrightarrow> restrict I v ! i = v ! i", "then"], ["proof (chain)\npicking this:\n  i \\<notin> A", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<notin> A\n\ngoal (1 subgoal):\n 1. restrict I v ! i = v ! i", "by (metis \\<open>i < length v\\<close> assms(1) nth_restrict simple_restrict_none wf_tuple_def)"], ["proof (state)\nthis:\n  restrict I v ! i = v ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict I v ! i = v ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < length v \\<Longrightarrow> restrict I v ! ?i = v ! ?i\n\ngoal (1 subgoal):\n 1. restrict I v = v", "then"], ["proof (chain)\npicking this:\n  ?i < length v \\<Longrightarrow> restrict I v ! ?i = v ! ?i", "show ?thesis"], ["proof (prove)\nusing this:\n  ?i < length v \\<Longrightarrow> restrict I v ! ?i = v ! ?i\n\ngoal (1 subgoal):\n 1. restrict I v = v", "by (simp add: list_eq_iff_nth_eq)"], ["proof (state)\nthis:\n  restrict I v = v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma merge_index:\n  assumes \"I \\<inter> J = {}\"\n  assumes \"wf_tuple n I tI\"\n  assumes \"wf_tuple n J tJ\"\n  assumes \"t = merge tI tJ\"\n  assumes \"i < n\"\n  shows \"(i \\<in> I \\<and> t!i = tI!i) \\<or> (i \\<in> J \\<and> t!i = tJ!i) \\<or> (i \\<notin> I \\<and> i \\<notin> J \\<and> t!i = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> I \\<and> t ! i = tI ! i \\<or>\n    i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n    i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<in> I \\<and> t ! i = tI ! i \\<or>\n    i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n    i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None", "have \"t!i = merge_option ((zip tI tJ)!i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t ! i = merge_option (zip tI tJ ! i)", "by (metis (full_types) assms(2) assms(3) assms(4) assms(5) length_zip merge.simps\n        min_less_iff_conj nth_map wf_tuple_def)"], ["proof (state)\nthis:\n  t ! i = merge_option (zip tI tJ ! i)\n\ngoal (1 subgoal):\n 1. i \\<in> I \\<and> t ! i = tI ! i \\<or>\n    i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n    i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None", "then"], ["proof (chain)\npicking this:\n  t ! i = merge_option (zip tI tJ ! i)", "have \"t!i = merge_option (tI!i, tJ!i)\""], ["proof (prove)\nusing this:\n  t ! i = merge_option (zip tI tJ ! i)\n\ngoal (1 subgoal):\n 1. t ! i = merge_option (tI ! i, tJ ! i)", "by (metis assms(2) assms(3) assms(5) nth_zip wf_tuple_def)"], ["proof (state)\nthis:\n  t ! i = merge_option (tI ! i, tJ ! i)\n\ngoal (1 subgoal):\n 1. i \\<in> I \\<and> t ! i = tI ! i \\<or>\n    i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n    i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None", "then"], ["proof (chain)\npicking this:\n  t ! i = merge_option (tI ! i, tJ ! i)", "show ?thesis"], ["proof (prove)\nusing this:\n  t ! i = merge_option (tI ! i, tJ ! i)\n\ngoal (1 subgoal):\n 1. i \\<in> I \\<and> t ! i = tI ! i \\<or>\n    i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n    i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None", "proof (cases \"i \\<in> I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>t ! i = merge_option (tI ! i, tJ ! i); i \\<in> I\\<rbrakk>\n    \\<Longrightarrow> i \\<in> I \\<and> t ! i = tI ! i \\<or>\n                      i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n                      i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None\n 2. \\<lbrakk>t ! i = merge_option (tI ! i, tJ ! i); i \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> i \\<in> I \\<and> t ! i = tI ! i \\<or>\n                      i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n                      i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None", "case True"], ["proof (state)\nthis:\n  i \\<in> I\n\ngoal (2 subgoals):\n 1. \\<lbrakk>t ! i = merge_option (tI ! i, tJ ! i); i \\<in> I\\<rbrakk>\n    \\<Longrightarrow> i \\<in> I \\<and> t ! i = tI ! i \\<or>\n                      i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n                      i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None\n 2. \\<lbrakk>t ! i = merge_option (tI ! i, tJ ! i); i \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> i \\<in> I \\<and> t ! i = tI ! i \\<or>\n                      i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n                      i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None", "have \"t!i = tI!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t ! i = tI ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t ! i = tI ! i", "have \"tJ!i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tJ ! i = None", "by (meson True assms(1) assms(3) assms(5) disjoint_iff_not_equal wf_tuple_def)"], ["proof (state)\nthis:\n  tJ ! i = None\n\ngoal (1 subgoal):\n 1. t ! i = tI ! i", "moreover"], ["proof (state)\nthis:\n  tJ ! i = None\n\ngoal (1 subgoal):\n 1. t ! i = tI ! i", "have \"merge_option (tI!i, None) = tI!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_option (tI ! i, None) = tI ! i", "by (metis True assms(2) assms(5) merge_option.simps(2) option.exhaust wf_tuple_def)"], ["proof (state)\nthis:\n  merge_option (tI ! i, None) = tI ! i\n\ngoal (1 subgoal):\n 1. t ! i = tI ! i", "then"], ["proof (chain)\npicking this:\n  merge_option (tI ! i, None) = tI ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  merge_option (tI ! i, None) = tI ! i\n\ngoal (1 subgoal):\n 1. t ! i = tI ! i", "by (simp add: \\<open>t ! i = merge_option (tI ! i, tJ ! i)\\<close> calculation)"], ["proof (state)\nthis:\n  t ! i = tI ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t ! i = tI ! i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>t ! i = merge_option (tI ! i, tJ ! i); i \\<in> I\\<rbrakk>\n    \\<Longrightarrow> i \\<in> I \\<and> t ! i = tI ! i \\<or>\n                      i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n                      i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None\n 2. \\<lbrakk>t ! i = merge_option (tI ! i, tJ ! i); i \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> i \\<in> I \\<and> t ! i = tI ! i \\<or>\n                      i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n                      i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None", "then"], ["proof (chain)\npicking this:\n  t ! i = tI ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  t ! i = tI ! i\n\ngoal (1 subgoal):\n 1. i \\<in> I \\<and> t ! i = tI ! i \\<or>\n    i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n    i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None", "using True"], ["proof (prove)\nusing this:\n  t ! i = tI ! i\n  i \\<in> I\n\ngoal (1 subgoal):\n 1. i \\<in> I \\<and> t ! i = tI ! i \\<or>\n    i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n    i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None", "by blast"], ["proof (state)\nthis:\n  i \\<in> I \\<and> t ! i = tI ! i \\<or>\n  i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n  i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t ! i = merge_option (tI ! i, tJ ! i); i \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> i \\<in> I \\<and> t ! i = tI ! i \\<or>\n                      i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n                      i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>t ! i = merge_option (tI ! i, tJ ! i); i \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> i \\<in> I \\<and> t ! i = tI ! i \\<or>\n                      i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n                      i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None", "case False"], ["proof (state)\nthis:\n  i \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t ! i = merge_option (tI ! i, tJ ! i); i \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> i \\<in> I \\<and> t ! i = tI ! i \\<or>\n                      i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n                      i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None", "have \"i \\<notin> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<notin> I", "by (simp add: False)"], ["proof (state)\nthis:\n  i \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t ! i = merge_option (tI ! i, tJ ! i); i \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> i \\<in> I \\<and> t ! i = tI ! i \\<or>\n                      i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n                      i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None", "then"], ["proof (chain)\npicking this:\n  i \\<notin> I", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<notin> I\n\ngoal (1 subgoal):\n 1. i \\<in> I \\<and> t ! i = tI ! i \\<or>\n    i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n    i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None", "proof (cases \"i \\<in> J\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<notin> I; i \\<in> J\\<rbrakk>\n    \\<Longrightarrow> i \\<in> I \\<and> t ! i = tI ! i \\<or>\n                      i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n                      i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None\n 2. \\<lbrakk>i \\<notin> I; i \\<notin> J\\<rbrakk>\n    \\<Longrightarrow> i \\<in> I \\<and> t ! i = tI ! i \\<or>\n                      i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n                      i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None", "case True"], ["proof (state)\nthis:\n  i \\<in> J\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<notin> I; i \\<in> J\\<rbrakk>\n    \\<Longrightarrow> i \\<in> I \\<and> t ! i = tI ! i \\<or>\n                      i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n                      i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None\n 2. \\<lbrakk>i \\<notin> I; i \\<notin> J\\<rbrakk>\n    \\<Longrightarrow> i \\<in> I \\<and> t ! i = tI ! i \\<or>\n                      i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n                      i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None", "have \"t!i = tJ!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t ! i = tJ ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t ! i = tJ ! i", "have \"tI!i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tI ! i = None", "using False assms(2) assms(5) wf_tuple_def"], ["proof (prove)\nusing this:\n  i \\<notin> I\n  wf_tuple n I tI\n  i < n\n  wf_tuple ?n ?V ?x =\n  (length ?x = ?n \\<and> (\\<forall>i<?n. (?x ! i = None) = (i \\<notin> ?V)))\n\ngoal (1 subgoal):\n 1. tI ! i = None", "by blast"], ["proof (state)\nthis:\n  tI ! i = None\n\ngoal (1 subgoal):\n 1. t ! i = tJ ! i", "moreover"], ["proof (state)\nthis:\n  tI ! i = None\n\ngoal (1 subgoal):\n 1. t ! i = tJ ! i", "have \"merge_option (None, tJ!i) = tJ!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_option (None, tJ ! i) = tJ ! i", "by (metis True assms(3) assms(5) merge_option.simps(3) option.exhaust wf_tuple_def)"], ["proof (state)\nthis:\n  merge_option (None, tJ ! i) = tJ ! i\n\ngoal (1 subgoal):\n 1. t ! i = tJ ! i", "then"], ["proof (chain)\npicking this:\n  merge_option (None, tJ ! i) = tJ ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  merge_option (None, tJ ! i) = tJ ! i\n\ngoal (1 subgoal):\n 1. t ! i = tJ ! i", "by (simp add: \\<open>t ! i = merge_option (tI ! i, tJ ! i)\\<close> calculation)"], ["proof (state)\nthis:\n  t ! i = tJ ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t ! i = tJ ! i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<notin> I; i \\<in> J\\<rbrakk>\n    \\<Longrightarrow> i \\<in> I \\<and> t ! i = tI ! i \\<or>\n                      i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n                      i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None\n 2. \\<lbrakk>i \\<notin> I; i \\<notin> J\\<rbrakk>\n    \\<Longrightarrow> i \\<in> I \\<and> t ! i = tI ! i \\<or>\n                      i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n                      i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None", "then"], ["proof (chain)\npicking this:\n  t ! i = tJ ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  t ! i = tJ ! i\n\ngoal (1 subgoal):\n 1. i \\<in> I \\<and> t ! i = tI ! i \\<or>\n    i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n    i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None", "using True"], ["proof (prove)\nusing this:\n  t ! i = tJ ! i\n  i \\<in> J\n\ngoal (1 subgoal):\n 1. i \\<in> I \\<and> t ! i = tI ! i \\<or>\n    i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n    i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None", "by blast"], ["proof (state)\nthis:\n  i \\<in> I \\<and> t ! i = tI ! i \\<or>\n  i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n  i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> I; i \\<notin> J\\<rbrakk>\n    \\<Longrightarrow> i \\<in> I \\<and> t ! i = tI ! i \\<or>\n                      i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n                      i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> I; i \\<notin> J\\<rbrakk>\n    \\<Longrightarrow> i \\<in> I \\<and> t ! i = tI ! i \\<or>\n                      i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n                      i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None", "case False"], ["proof (state)\nthis:\n  i \\<notin> J\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> I; i \\<notin> J\\<rbrakk>\n    \\<Longrightarrow> i \\<in> I \\<and> t ! i = tI ! i \\<or>\n                      i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n                      i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None", "obtain \"tI!i = None\" and \"tJ!i = None \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>tI ! i = None; tJ ! i = None\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson False \\<open>i \\<notin> I\\<close> assms(2) assms(3) assms(5) wf_tuple_def)"], ["proof (state)\nthis:\n  tI ! i = None\n  tJ ! i = None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> I; i \\<notin> J\\<rbrakk>\n    \\<Longrightarrow> i \\<in> I \\<and> t ! i = tI ! i \\<or>\n                      i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n                      i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None", "have \"t!i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t ! i = None", "by (simp add: \\<open>t ! i = merge_option (tI ! i, tJ ! i)\\<close> \\<open>tI ! i = None\\<close> \\<open>tJ ! i = None\\<close>)"], ["proof (state)\nthis:\n  t ! i = None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> I; i \\<notin> J\\<rbrakk>\n    \\<Longrightarrow> i \\<in> I \\<and> t ! i = tI ! i \\<or>\n                      i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n                      i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None", "then"], ["proof (chain)\npicking this:\n  t ! i = None", "show ?thesis"], ["proof (prove)\nusing this:\n  t ! i = None\n\ngoal (1 subgoal):\n 1. i \\<in> I \\<and> t ! i = tI ! i \\<or>\n    i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n    i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None", "using False \\<open>i \\<notin> I\\<close>"], ["proof (prove)\nusing this:\n  t ! i = None\n  i \\<notin> J\n  i \\<notin> I\n\ngoal (1 subgoal):\n 1. i \\<in> I \\<and> t ! i = tI ! i \\<or>\n    i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n    i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None", "by blast"], ["proof (state)\nthis:\n  i \\<in> I \\<and> t ! i = tI ! i \\<or>\n  i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n  i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i \\<in> I \\<and> t ! i = tI ! i \\<or>\n  i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n  i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i \\<in> I \\<and> t ! i = tI ! i \\<or>\n  i \\<in> J \\<and> t ! i = tJ ! i \\<or>\n  i \\<notin> I \\<and> i \\<notin> J \\<and> t ! i = None\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma restrict_index_in:\n  assumes \"i < length X\"\n  assumes \"i \\<in> I\"\n  shows \"(restrict I X)!i = X!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict I X ! i = X ! i", "by (simp add: assms(1) assms(2) nth_restrict)"], ["", "lemma restrict_index_out:\n  assumes \"i < length X\"\n  assumes \"i \\<notin> I\"\n  shows \"(restrict I X)!i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict I X ! i = None", "by (simp add: assms(1) assms(2) simple_restrict_none)"], ["", "lemma merge_length:\n  assumes \"length a = n\"\n  assumes \"length b = n\"\n  shows \"length (merge a b) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (merge a b) = n", "by (simp add: assms(1) assms(2))"], ["", "lemma real_restrict_merge:\n  assumes \"I \\<inter> J = {}\"\n  assumes \"wf_tuple n I tI\"\n  assumes \"wf_tuple n J tJ\"\n  shows \"restrict I (merge tI tJ) = restrict I tI \\<and> restrict J (merge tI tJ) = restrict J tJ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict I (merge tI tJ) = restrict I tI \\<and>\n    restrict J (merge tI tJ) = restrict J tJ", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. restrict I (merge tI tJ) = restrict I tI \\<and>\n    restrict J (merge tI tJ) = restrict J tJ", "have \"length (merge tI tJ) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (merge tI tJ) = n", "using assms(2) assms(3) merge_length wf_tuple_def"], ["proof (prove)\nusing this:\n  wf_tuple n I tI\n  wf_tuple n J tJ\n  \\<lbrakk>length ?a = ?n; length ?b = ?n\\<rbrakk>\n  \\<Longrightarrow> length (merge ?a ?b) = ?n\n  wf_tuple ?n ?V ?x =\n  (length ?x = ?n \\<and> (\\<forall>i<?n. (?x ! i = None) = (i \\<notin> ?V)))\n\ngoal (1 subgoal):\n 1. length (merge tI tJ) = n", "by blast"], ["proof (state)\nthis:\n  length (merge tI tJ) = n\n\ngoal (1 subgoal):\n 1. restrict I (merge tI tJ) = restrict I tI \\<and>\n    restrict J (merge tI tJ) = restrict J tJ", "have \"\\<And>i. i < n \\<Longrightarrow> (restrict I (merge tI tJ))!i = (restrict I tI)!i\n                     \\<and> (restrict J (merge tI tJ))!i = (restrict J tJ)!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       restrict I (merge tI tJ) ! i = restrict I tI ! i \\<and>\n       restrict J (merge tI tJ) ! i = restrict J tJ ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       restrict I (merge tI tJ) ! i = restrict I tI ! i \\<and>\n       restrict J (merge tI tJ) ! i = restrict J tJ ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       restrict I (merge tI tJ) ! i = restrict I tI ! i \\<and>\n       restrict J (merge tI tJ) ! i = restrict J tJ ! i", "assume \"i < n\""], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < n \\<Longrightarrow>\n       restrict I (merge tI tJ) ! i = restrict I tI ! i \\<and>\n       restrict J (merge tI tJ) ! i = restrict J tJ ! i", "show \"(restrict I (merge tI tJ))!i = (restrict I tI)!i \\<and> (restrict J (merge tI tJ))!i = (restrict J tJ)!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict I (merge tI tJ) ! i = restrict I tI ! i \\<and>\n    restrict J (merge tI tJ) ! i = restrict J tJ ! i", "proof (cases \"i \\<in> I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<in> I \\<Longrightarrow>\n    restrict I (merge tI tJ) ! i = restrict I tI ! i \\<and>\n    restrict J (merge tI tJ) ! i = restrict J tJ ! i\n 2. i \\<notin> I \\<Longrightarrow>\n    restrict I (merge tI tJ) ! i = restrict I tI ! i \\<and>\n    restrict J (merge tI tJ) ! i = restrict J tJ ! i", "case True"], ["proof (state)\nthis:\n  i \\<in> I\n\ngoal (2 subgoals):\n 1. i \\<in> I \\<Longrightarrow>\n    restrict I (merge tI tJ) ! i = restrict I tI ! i \\<and>\n    restrict J (merge tI tJ) ! i = restrict J tJ ! i\n 2. i \\<notin> I \\<Longrightarrow>\n    restrict I (merge tI tJ) ! i = restrict I tI ! i \\<and>\n    restrict J (merge tI tJ) ! i = restrict J tJ ! i", "have \"(merge tI tJ)!i = tI!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge tI tJ ! i = tI ! i", "by (meson True \\<open>i < n\\<close> assms(1) assms(2) assms(3) disjoint_iff_not_equal merge_index)"], ["proof (state)\nthis:\n  merge tI tJ ! i = tI ! i\n\ngoal (2 subgoals):\n 1. i \\<in> I \\<Longrightarrow>\n    restrict I (merge tI tJ) ! i = restrict I tI ! i \\<and>\n    restrict J (merge tI tJ) ! i = restrict J tJ ! i\n 2. i \\<notin> I \\<Longrightarrow>\n    restrict I (merge tI tJ) ! i = restrict I tI ! i \\<and>\n    restrict J (merge tI tJ) ! i = restrict J tJ ! i", "then"], ["proof (chain)\npicking this:\n  merge tI tJ ! i = tI ! i", "have \"(restrict I (merge tI tJ))!i = tI!i\""], ["proof (prove)\nusing this:\n  merge tI tJ ! i = tI ! i\n\ngoal (1 subgoal):\n 1. restrict I (merge tI tJ) ! i = tI ! i", "by (metis True \\<open>i < n\\<close> \\<open>length (merge tI tJ) = n\\<close> simple_restrict_some)"], ["proof (state)\nthis:\n  restrict I (merge tI tJ) ! i = tI ! i\n\ngoal (2 subgoals):\n 1. i \\<in> I \\<Longrightarrow>\n    restrict I (merge tI tJ) ! i = restrict I tI ! i \\<and>\n    restrict J (merge tI tJ) ! i = restrict J tJ ! i\n 2. i \\<notin> I \\<Longrightarrow>\n    restrict I (merge tI tJ) ! i = restrict I tI ! i \\<and>\n    restrict J (merge tI tJ) ! i = restrict J tJ ! i", "then"], ["proof (chain)\npicking this:\n  restrict I (merge tI tJ) ! i = tI ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  restrict I (merge tI tJ) ! i = tI ! i\n\ngoal (1 subgoal):\n 1. restrict I (merge tI tJ) ! i = restrict I tI ! i \\<and>\n    restrict J (merge tI tJ) ! i = restrict J tJ ! i", "by (metis True \\<open>i < n\\<close> \\<open>length (merge tI tJ) = n\\<close> assms(1) assms(2) assms(3) disjoint_iff_not_equal restrict_idle simple_restrict_none wf_tuple_def)"], ["proof (state)\nthis:\n  restrict I (merge tI tJ) ! i = restrict I tI ! i \\<and>\n  restrict J (merge tI tJ) ! i = restrict J tJ ! i\n\ngoal (1 subgoal):\n 1. i \\<notin> I \\<Longrightarrow>\n    restrict I (merge tI tJ) ! i = restrict I tI ! i \\<and>\n    restrict J (merge tI tJ) ! i = restrict J tJ ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<notin> I \\<Longrightarrow>\n    restrict I (merge tI tJ) ! i = restrict I tI ! i \\<and>\n    restrict J (merge tI tJ) ! i = restrict J tJ ! i", "case False"], ["proof (state)\nthis:\n  i \\<notin> I\n\ngoal (1 subgoal):\n 1. i \\<notin> I \\<Longrightarrow>\n    restrict I (merge tI tJ) ! i = restrict I tI ! i \\<and>\n    restrict J (merge tI tJ) ! i = restrict J tJ ! i", "have \"i \\<notin> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<notin> I", "by (simp add: False)"], ["proof (state)\nthis:\n  i \\<notin> I\n\ngoal (1 subgoal):\n 1. i \\<notin> I \\<Longrightarrow>\n    restrict I (merge tI tJ) ! i = restrict I tI ! i \\<and>\n    restrict J (merge tI tJ) ! i = restrict J tJ ! i", "then"], ["proof (chain)\npicking this:\n  i \\<notin> I", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<notin> I\n\ngoal (1 subgoal):\n 1. restrict I (merge tI tJ) ! i = restrict I tI ! i \\<and>\n    restrict J (merge tI tJ) ! i = restrict J tJ ! i", "proof (cases \"i \\<in> J\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<notin> I; i \\<in> J\\<rbrakk>\n    \\<Longrightarrow> restrict I (merge tI tJ) ! i =\n                      restrict I tI ! i \\<and>\n                      restrict J (merge tI tJ) ! i = restrict J tJ ! i\n 2. \\<lbrakk>i \\<notin> I; i \\<notin> J\\<rbrakk>\n    \\<Longrightarrow> restrict I (merge tI tJ) ! i =\n                      restrict I tI ! i \\<and>\n                      restrict J (merge tI tJ) ! i = restrict J tJ ! i", "case True"], ["proof (state)\nthis:\n  i \\<in> J\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<notin> I; i \\<in> J\\<rbrakk>\n    \\<Longrightarrow> restrict I (merge tI tJ) ! i =\n                      restrict I tI ! i \\<and>\n                      restrict J (merge tI tJ) ! i = restrict J tJ ! i\n 2. \\<lbrakk>i \\<notin> I; i \\<notin> J\\<rbrakk>\n    \\<Longrightarrow> restrict I (merge tI tJ) ! i =\n                      restrict I tI ! i \\<and>\n                      restrict J (merge tI tJ) ! i = restrict J tJ ! i", "have \"(merge tI tJ)!i = tJ!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge tI tJ ! i = tJ ! i", "using True \\<open>i < n\\<close> assms(1) assms(2) assms(3) merge_index"], ["proof (prove)\nusing this:\n  i \\<in> J\n  i < n\n  I \\<inter> J = {}\n  wf_tuple n I tI\n  wf_tuple n J tJ\n  \\<lbrakk>?I \\<inter> ?J = {}; wf_tuple ?n ?I ?tI; wf_tuple ?n ?J ?tJ;\n   ?t = merge ?tI ?tJ; ?i < ?n\\<rbrakk>\n  \\<Longrightarrow> ?i \\<in> ?I \\<and> ?t ! ?i = ?tI ! ?i \\<or>\n                    ?i \\<in> ?J \\<and> ?t ! ?i = ?tJ ! ?i \\<or>\n                    ?i \\<notin> ?I \\<and>\n                    ?i \\<notin> ?J \\<and> ?t ! ?i = None\n\ngoal (1 subgoal):\n 1. merge tI tJ ! i = tJ ! i", "by blast"], ["proof (state)\nthis:\n  merge tI tJ ! i = tJ ! i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<notin> I; i \\<in> J\\<rbrakk>\n    \\<Longrightarrow> restrict I (merge tI tJ) ! i =\n                      restrict I tI ! i \\<and>\n                      restrict J (merge tI tJ) ! i = restrict J tJ ! i\n 2. \\<lbrakk>i \\<notin> I; i \\<notin> J\\<rbrakk>\n    \\<Longrightarrow> restrict I (merge tI tJ) ! i =\n                      restrict I tI ! i \\<and>\n                      restrict J (merge tI tJ) ! i = restrict J tJ ! i", "then"], ["proof (chain)\npicking this:\n  merge tI tJ ! i = tJ ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  merge tI tJ ! i = tJ ! i\n\ngoal (1 subgoal):\n 1. restrict I (merge tI tJ) ! i = restrict I tI ! i \\<and>\n    restrict J (merge tI tJ) ! i = restrict J tJ ! i", "by (metis (no_types, lifting) False \\<open>i < n\\<close> \\<open>length (merge tI tJ) = n\\<close> assms(2) assms(3) simple_restrict_none simple_restrict_some wf_tuple_def)"], ["proof (state)\nthis:\n  restrict I (merge tI tJ) ! i = restrict I tI ! i \\<and>\n  restrict J (merge tI tJ) ! i = restrict J tJ ! i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> I; i \\<notin> J\\<rbrakk>\n    \\<Longrightarrow> restrict I (merge tI tJ) ! i =\n                      restrict I tI ! i \\<and>\n                      restrict J (merge tI tJ) ! i = restrict J tJ ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> I; i \\<notin> J\\<rbrakk>\n    \\<Longrightarrow> restrict I (merge tI tJ) ! i =\n                      restrict I tI ! i \\<and>\n                      restrict J (merge tI tJ) ! i = restrict J tJ ! i", "case False"], ["proof (state)\nthis:\n  i \\<notin> J\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> I; i \\<notin> J\\<rbrakk>\n    \\<Longrightarrow> restrict I (merge tI tJ) ! i =\n                      restrict I tI ! i \\<and>\n                      restrict J (merge tI tJ) ! i = restrict J tJ ! i", "have \"(merge tI tJ)!i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge tI tJ ! i = None", "using False \\<open>i < n\\<close> \\<open>i \\<notin> I\\<close> assms(1) assms(2) assms(3) merge_index"], ["proof (prove)\nusing this:\n  i \\<notin> J\n  i < n\n  i \\<notin> I\n  I \\<inter> J = {}\n  wf_tuple n I tI\n  wf_tuple n J tJ\n  \\<lbrakk>?I \\<inter> ?J = {}; wf_tuple ?n ?I ?tI; wf_tuple ?n ?J ?tJ;\n   ?t = merge ?tI ?tJ; ?i < ?n\\<rbrakk>\n  \\<Longrightarrow> ?i \\<in> ?I \\<and> ?t ! ?i = ?tI ! ?i \\<or>\n                    ?i \\<in> ?J \\<and> ?t ! ?i = ?tJ ! ?i \\<or>\n                    ?i \\<notin> ?I \\<and>\n                    ?i \\<notin> ?J \\<and> ?t ! ?i = None\n\ngoal (1 subgoal):\n 1. merge tI tJ ! i = None", "by blast"], ["proof (state)\nthis:\n  merge tI tJ ! i = None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> I; i \\<notin> J\\<rbrakk>\n    \\<Longrightarrow> restrict I (merge tI tJ) ! i =\n                      restrict I tI ! i \\<and>\n                      restrict J (merge tI tJ) ! i = restrict J tJ ! i", "then"], ["proof (chain)\npicking this:\n  merge tI tJ ! i = None", "show ?thesis"], ["proof (prove)\nusing this:\n  merge tI tJ ! i = None\n\ngoal (1 subgoal):\n 1. restrict I (merge tI tJ) ! i = restrict I tI ! i \\<and>\n    restrict J (merge tI tJ) ! i = restrict J tJ ! i", "by (metis False \\<open>i < n\\<close> \\<open>i \\<notin> I\\<close> \\<open>length (merge tI tJ) = n\\<close> assms(2) assms(3) eq_iff equalityD1 restrict_idle_include simple_restrict_none wf_tuple_def wf_tuple_restrict_simple)"], ["proof (state)\nthis:\n  restrict I (merge tI tJ) ! i = restrict I tI ! i \\<and>\n  restrict J (merge tI tJ) ! i = restrict J tJ ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict I (merge tI tJ) ! i = restrict I tI ! i \\<and>\n  restrict J (merge tI tJ) ! i = restrict J tJ ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict I (merge tI tJ) ! i = restrict I tI ! i \\<and>\n  restrict J (merge tI tJ) ! i = restrict J tJ ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow>\n  restrict I (merge tI tJ) ! ?i = restrict I tI ! ?i \\<and>\n  restrict J (merge tI tJ) ! ?i = restrict J tJ ! ?i\n\ngoal (1 subgoal):\n 1. restrict I (merge tI tJ) = restrict I tI \\<and>\n    restrict J (merge tI tJ) = restrict J tJ", "then"], ["proof (chain)\npicking this:\n  ?i < n \\<Longrightarrow>\n  restrict I (merge tI tJ) ! ?i = restrict I tI ! ?i \\<and>\n  restrict J (merge tI tJ) ! ?i = restrict J tJ ! ?i", "obtain \"\\<forall>i < n. (restrict I (merge tI tJ))!i = (restrict I tI)!i\" \n          and \"\\<forall>i < n. (restrict J (merge tI tJ))!i = (restrict J tJ)!i\""], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow>\n  restrict I (merge tI tJ) ! ?i = restrict I tI ! ?i \\<and>\n  restrict J (merge tI tJ) ! ?i = restrict J tJ ! ?i\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<forall>i<n.\n                 restrict I (merge tI tJ) ! i = restrict I tI ! i;\n      \\<forall>i<n.\n         restrict J (merge tI tJ) ! i = restrict J tJ ! i\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>i<n. restrict I (merge tI tJ) ! i = restrict I tI ! i\n  \\<forall>i<n. restrict J (merge tI tJ) ! i = restrict J tJ ! i\n\ngoal (1 subgoal):\n 1. restrict I (merge tI tJ) = restrict I tI \\<and>\n    restrict J (merge tI tJ) = restrict J tJ", "moreover"], ["proof (state)\nthis:\n  \\<forall>i<n. restrict I (merge tI tJ) ! i = restrict I tI ! i\n  \\<forall>i<n. restrict J (merge tI tJ) ! i = restrict J tJ ! i\n\ngoal (1 subgoal):\n 1. restrict I (merge tI tJ) = restrict I tI \\<and>\n    restrict J (merge tI tJ) = restrict J tJ", "have \"length (merge tI tJ) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (merge tI tJ) = n", "by (meson assms(2) assms(3) wf_merge wf_tuple_def)"], ["proof (state)\nthis:\n  length (merge tI tJ) = n\n\ngoal (1 subgoal):\n 1. restrict I (merge tI tJ) = restrict I tI \\<and>\n    restrict J (merge tI tJ) = restrict J tJ", "moreover"], ["proof (state)\nthis:\n  length (merge tI tJ) = n\n\ngoal (1 subgoal):\n 1. restrict I (merge tI tJ) = restrict I tI \\<and>\n    restrict J (merge tI tJ) = restrict J tJ", "obtain \"length (restrict I tI) = n\" and \"length (restrict J tJ) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>length (restrict I tI) = n;\n      length (restrict J tJ) = n\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2) assms(3) wf_tuple_def"], ["proof (prove)\nusing this:\n  wf_tuple n I tI\n  wf_tuple n J tJ\n  wf_tuple ?n ?V ?x =\n  (length ?x = ?n \\<and> (\\<forall>i<?n. (?x ! i = None) = (i \\<notin> ?V)))\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>length (restrict I tI) = n;\n      length (restrict J tJ) = n\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  length (restrict I tI) = n\n  length (restrict J tJ) = n\n\ngoal (1 subgoal):\n 1. restrict I (merge tI tJ) = restrict I tI \\<and>\n    restrict J (merge tI tJ) = restrict J tJ", "then"], ["proof (chain)\npicking this:\n  length (restrict I tI) = n\n  length (restrict J tJ) = n", "show ?thesis"], ["proof (prove)\nusing this:\n  length (restrict I tI) = n\n  length (restrict J tJ) = n\n\ngoal (1 subgoal):\n 1. restrict I (merge tI tJ) = restrict I tI \\<and>\n    restrict J (merge tI tJ) = restrict J tJ", "by (metis \\<open>\\<And>i. i < n \\<Longrightarrow> restrict I (merge tI tJ) ! i = restrict I tI ! i \\<and> restrict J (merge tI tJ) ! i = restrict J tJ ! i\\<close> calculation(3) length_restrict simple_list_index_equality)"], ["proof (state)\nthis:\n  restrict I (merge tI tJ) = restrict I tI \\<and>\n  restrict J (merge tI tJ) = restrict J tJ\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simple_set_image_id:\n  assumes \"\\<forall>x\\<in>X. f x = x\"\n  shows \"Set.image f X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` X = X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f ` X = X", "have \"Set.image f X = {f x |x. x \\<in> X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` X = {f x |x. x \\<in> X}", "by (simp add: Setcompr_eq_image)"], ["proof (state)\nthis:\n  f ` X = {f x |x. x \\<in> X}\n\ngoal (1 subgoal):\n 1. f ` X = X", "then"], ["proof (chain)\npicking this:\n  f ` X = {f x |x. x \\<in> X}", "have \"... = {x |x. x \\<in> X}\""], ["proof (prove)\nusing this:\n  f ` X = {f x |x. x \\<in> X}\n\ngoal (1 subgoal):\n 1. {f x |x. x \\<in> X} = {x |x. x \\<in> X}", "by (simp add: assms)"], ["proof (state)\nthis:\n  {f x |x. x \\<in> X} = {x |x. x \\<in> X}\n\ngoal (1 subgoal):\n 1. f ` X = X", "moreover"], ["proof (state)\nthis:\n  {f x |x. x \\<in> X} = {x |x. x \\<in> X}\n\ngoal (1 subgoal):\n 1. f ` X = X", "have \"... = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x |x. x \\<in> X} = X", "by simp"], ["proof (state)\nthis:\n  {x |x. x \\<in> X} = X\n\ngoal (1 subgoal):\n 1. f ` X = X", "then"], ["proof (chain)\npicking this:\n  {x |x. x \\<in> X} = X", "show ?thesis"], ["proof (prove)\nusing this:\n  {x |x. x \\<in> X} = X\n\ngoal (1 subgoal):\n 1. f ` X = X", "by (simp add: \\<open>f ` X = {f x |x. x \\<in> X}\\<close> calculation)"], ["proof (state)\nthis:\n  f ` X = X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nested_include_restrict:\n  assumes \"restrict I z = t\"\n  assumes \"A \\<subseteq> I\"\n  shows \"restrict A z = restrict A t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict A z = restrict A t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. restrict A z = restrict A t", "have \"length (restrict A z) = length (restrict A t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (restrict A z) = length (restrict A t)", "using assms(1)"], ["proof (prove)\nusing this:\n  restrict I z = t\n\ngoal (1 subgoal):\n 1. length (restrict A z) = length (restrict A t)", "by auto"], ["proof (state)\nthis:\n  length (restrict A z) = length (restrict A t)\n\ngoal (1 subgoal):\n 1. restrict A z = restrict A t", "moreover"], ["proof (state)\nthis:\n  length (restrict A z) = length (restrict A t)\n\ngoal (1 subgoal):\n 1. restrict A z = restrict A t", "have \"\\<And>i. i < length (restrict A z) \\<Longrightarrow> (restrict A z) ! i = (restrict A t) ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (restrict A z) \\<Longrightarrow>\n       restrict A z ! i = restrict A t ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (restrict A z) \\<Longrightarrow>\n       restrict A z ! i = restrict A t ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (restrict A z) \\<Longrightarrow>\n       restrict A z ! i = restrict A t ! i", "assume \"i < length (restrict A z)\""], ["proof (state)\nthis:\n  i < length (restrict A z)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length (restrict A z) \\<Longrightarrow>\n       restrict A z ! i = restrict A t ! i", "then"], ["proof (chain)\npicking this:\n  i < length (restrict A z)", "show \"(restrict A z) ! i = (restrict A t) ! i\""], ["proof (prove)\nusing this:\n  i < length (restrict A z)\n\ngoal (1 subgoal):\n 1. restrict A z ! i = restrict A t ! i", "proof (cases \"i \\<in> A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < length (restrict A z); i \\<in> A\\<rbrakk>\n    \\<Longrightarrow> restrict A z ! i = restrict A t ! i\n 2. \\<lbrakk>i < length (restrict A z); i \\<notin> A\\<rbrakk>\n    \\<Longrightarrow> restrict A z ! i = restrict A t ! i", "case True"], ["proof (state)\nthis:\n  i \\<in> A\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i < length (restrict A z); i \\<in> A\\<rbrakk>\n    \\<Longrightarrow> restrict A z ! i = restrict A t ! i\n 2. \\<lbrakk>i < length (restrict A z); i \\<notin> A\\<rbrakk>\n    \\<Longrightarrow> restrict A z ! i = restrict A t ! i", "then"], ["proof (chain)\npicking this:\n  i \\<in> A", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<in> A\n\ngoal (1 subgoal):\n 1. restrict A z ! i = restrict A t ! i", "by (metis restrict_index_in \\<open>i < length (restrict A z)\\<close> assms(1) assms(2) length_restrict subsetD)"], ["proof (state)\nthis:\n  restrict A z ! i = restrict A t ! i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length (restrict A z); i \\<notin> A\\<rbrakk>\n    \\<Longrightarrow> restrict A z ! i = restrict A t ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length (restrict A z); i \\<notin> A\\<rbrakk>\n    \\<Longrightarrow> restrict A z ! i = restrict A t ! i", "case False"], ["proof (state)\nthis:\n  i \\<notin> A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length (restrict A z); i \\<notin> A\\<rbrakk>\n    \\<Longrightarrow> restrict A z ! i = restrict A t ! i", "then"], ["proof (chain)\npicking this:\n  i \\<notin> A", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<notin> A\n\ngoal (1 subgoal):\n 1. restrict A z ! i = restrict A t ! i", "by (metis simple_restrict_none \\<open>i < length (restrict A z)\\<close> calculation length_restrict)"], ["proof (state)\nthis:\n  restrict A z ! i = restrict A t ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict A z ! i = restrict A t ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < length (restrict A z) \\<Longrightarrow>\n  restrict A z ! ?i = restrict A t ! ?i\n\ngoal (1 subgoal):\n 1. restrict A z = restrict A t", "ultimately"], ["proof (chain)\npicking this:\n  length (restrict A z) = length (restrict A t)\n  ?i < length (restrict A z) \\<Longrightarrow>\n  restrict A z ! ?i = restrict A t ! ?i", "show ?thesis"], ["proof (prove)\nusing this:\n  length (restrict A z) = length (restrict A t)\n  ?i < length (restrict A z) \\<Longrightarrow>\n  restrict A z ! ?i = restrict A t ! ?i\n\ngoal (1 subgoal):\n 1. restrict A z = restrict A t", "by (simp add: list_eq_iff_nth_eq)"], ["proof (state)\nthis:\n  restrict A z = restrict A t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma restrict_nested:\n  \"restrict A (restrict B x) = restrict (A \\<inter> B) x\" (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict A (restrict B x) = restrict (A \\<inter> B) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. restrict A (restrict B x) = restrict (A \\<inter> B) x", "have \"\\<And>i. i < length x \\<Longrightarrow> ?lhs!i = ?rhs!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length x \\<Longrightarrow>\n       restrict A (restrict B x) ! i = restrict (A \\<inter> B) x ! i", "by (metis Int_iff length_restrict restrict_index_in simple_restrict_none)"], ["proof (state)\nthis:\n  ?i < length x \\<Longrightarrow>\n  restrict A (restrict B x) ! ?i = restrict (A \\<inter> B) x ! ?i\n\ngoal (1 subgoal):\n 1. restrict A (restrict B x) = restrict (A \\<inter> B) x", "then"], ["proof (chain)\npicking this:\n  ?i < length x \\<Longrightarrow>\n  restrict A (restrict B x) ! ?i = restrict (A \\<inter> B) x ! ?i", "show ?thesis"], ["proof (prove)\nusing this:\n  ?i < length x \\<Longrightarrow>\n  restrict A (restrict B x) ! ?i = restrict (A \\<inter> B) x ! ?i\n\ngoal (1 subgoal):\n 1. restrict A (restrict B x) = restrict (A \\<inter> B) x", "by (simp add: simple_list_index_equality)"], ["proof (state)\nthis:\n  restrict A (restrict B x) = restrict (A \\<inter> B) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma newQuery_equi_dev:\n  \"newQuery V Q (I, t) = Set.image (projectTable V) (Set.image (\\<lambda>tab. semiJoin tab (I, t)) Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. newQuery V Q (I, t) =\n    projectTable V ` (\\<lambda>tab. semiJoin tab (I, t)) ` Q", "by (metis newQuery_equiv_def projectQuery.elims)"], ["", "lemma projectTable_idle:\n  assumes \"table n A X\"\n  assumes \"A \\<subseteq> I\"\n  shows \"projectTable I (A, X) = (A, X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. projectTable I (A, X) = (A, X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. projectTable I (A, X) = (A, X)", "have \"projectTable I (A, X) = (A \\<inter> I, Set.image (restrict I) X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. projectTable I (A, X) = (A \\<inter> I, restrict I ` X)", "using projectTable.simps"], ["proof (prove)\nusing this:\n  projectTable ?V (?s, ?t) = (?s \\<inter> ?V, restrict ?V ` ?t)\n\ngoal (1 subgoal):\n 1. projectTable I (A, X) = (A \\<inter> I, restrict I ` X)", "by blast"], ["proof (state)\nthis:\n  projectTable I (A, X) = (A \\<inter> I, restrict I ` X)\n\ngoal (1 subgoal):\n 1. projectTable I (A, X) = (A, X)", "then"], ["proof (chain)\npicking this:\n  projectTable I (A, X) = (A \\<inter> I, restrict I ` X)", "have \"A \\<inter> I = A\""], ["proof (prove)\nusing this:\n  projectTable I (A, X) = (A \\<inter> I, restrict I ` X)\n\ngoal (1 subgoal):\n 1. A \\<inter> I = A", "using assms(2)"], ["proof (prove)\nusing this:\n  projectTable I (A, X) = (A \\<inter> I, restrict I ` X)\n  A \\<subseteq> I\n\ngoal (1 subgoal):\n 1. A \\<inter> I = A", "by blast"], ["proof (state)\nthis:\n  A \\<inter> I = A\n\ngoal (1 subgoal):\n 1. projectTable I (A, X) = (A, X)", "have \"\\<And>x. x \\<in> X \\<Longrightarrow> (restrict I) x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> restrict I x = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> restrict I x = x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> restrict I x = x", "assume \"x \\<in> X\""], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> restrict I x = x", "have \"wf_tuple n A x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple n A x", "using \\<open>x \\<in> X\\<close> assms(1) table_def"], ["proof (prove)\nusing this:\n  x \\<in> X\n  table n A X\n  table ?n ?V ?X = (\\<forall>x\\<in>?X. wf_tuple ?n ?V x)\n\ngoal (1 subgoal):\n 1. wf_tuple n A x", "by blast"], ["proof (state)\nthis:\n  wf_tuple n A x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> restrict I x = x", "then"], ["proof (chain)\npicking this:\n  wf_tuple n A x", "show \"(restrict I) x = x\""], ["proof (prove)\nusing this:\n  wf_tuple n A x\n\ngoal (1 subgoal):\n 1. restrict I x = x", "using assms(2) restrict_idle_include"], ["proof (prove)\nusing this:\n  wf_tuple n A x\n  A \\<subseteq> I\n  \\<lbrakk>wf_tuple ?n ?A ?v; ?A \\<subseteq> ?I\\<rbrakk>\n  \\<Longrightarrow> restrict ?I ?v = ?v\n\ngoal (1 subgoal):\n 1. restrict I x = x", "by blast"], ["proof (state)\nthis:\n  restrict I x = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> X \\<Longrightarrow> restrict I ?x = ?x\n\ngoal (1 subgoal):\n 1. projectTable I (A, X) = (A, X)", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> X \\<Longrightarrow> restrict I ?x = ?x", "have \"\\<forall>x \\<in> X. (restrict I) x = x\""], ["proof (prove)\nusing this:\n  ?x \\<in> X \\<Longrightarrow> restrict I ?x = ?x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>X. restrict I x = x", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>X. restrict I x = x\n\ngoal (1 subgoal):\n 1. projectTable I (A, X) = (A, X)", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<in>X. restrict I x = x\n\ngoal (1 subgoal):\n 1. projectTable I (A, X) = (A, X)", "have \"Set.image (restrict I) X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict I ` X = X", "by (simp add: \\<open>\\<And>x. x \\<in> X \\<Longrightarrow> restrict I x = x\\<close>)"], ["proof (state)\nthis:\n  restrict I ` X = X\n\ngoal (1 subgoal):\n 1. projectTable I (A, X) = (A, X)", "then"], ["proof (chain)\npicking this:\n  restrict I ` X = X", "show ?thesis"], ["proof (prove)\nusing this:\n  restrict I ` X = X\n\ngoal (1 subgoal):\n 1. projectTable I (A, X) = (A, X)", "by (simp add: \\<open>A \\<inter> I = A\\<close>)"], ["proof (state)\nthis:\n  projectTable I (A, X) = (A, X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma restrict_partition_merge:\n  assumes \"I \\<union> J = V\"\n  assumes \"wf_tuple n V z\"\n  assumes \"xx = restrict J z\"\n  assumes \"t = restrict I z\"\n  assumes \"Set.is_empty (I \\<inter> J)\"\n  shows \"z = merge xx t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z = merge xx t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. z = merge xx t", "have \"\\<And>i. i < n \\<Longrightarrow> z!i = (merge xx t)!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> z ! i = merge xx t ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> z ! i = merge xx t ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> z ! i = merge xx t ! i", "assume \"i < n\""], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> z ! i = merge xx t ! i", "show \"z!i = (merge xx t)!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z ! i = merge xx t ! i", "proof (cases \"i \\<in> I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<in> I \\<Longrightarrow> z ! i = merge xx t ! i\n 2. i \\<notin> I \\<Longrightarrow> z ! i = merge xx t ! i", "case True"], ["proof (state)\nthis:\n  i \\<in> I\n\ngoal (2 subgoals):\n 1. i \\<in> I \\<Longrightarrow> z ! i = merge xx t ! i\n 2. i \\<notin> I \\<Longrightarrow> z ! i = merge xx t ! i", "have \"z!i = t!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z ! i = t ! i", "by (metis True \\<open>i < n\\<close> assms(2) assms(4) nth_restrict wf_tuple_def)"], ["proof (state)\nthis:\n  z ! i = t ! i\n\ngoal (2 subgoals):\n 1. i \\<in> I \\<Longrightarrow> z ! i = merge xx t ! i\n 2. i \\<notin> I \\<Longrightarrow> z ! i = merge xx t ! i", "moreover"], ["proof (state)\nthis:\n  z ! i = t ! i\n\ngoal (2 subgoals):\n 1. i \\<in> I \\<Longrightarrow> z ! i = merge xx t ! i\n 2. i \\<notin> I \\<Longrightarrow> z ! i = merge xx t ! i", "have \"(merge xx t)!i = t!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge xx t ! i = t ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. merge xx t ! i = t ! i", "have \"xx ! i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xx ! i = None", "by (metis simple_restrict_none Set.is_empty_def True \\<open>i < n\\<close> assms(2) assms(3) assms(5) disjoint_iff_not_equal wf_tuple_length)"], ["proof (state)\nthis:\n  xx ! i = None\n\ngoal (1 subgoal):\n 1. merge xx t ! i = t ! i", "moreover"], ["proof (state)\nthis:\n  xx ! i = None\n\ngoal (1 subgoal):\n 1. merge xx t ! i = t ! i", "have \"(merge xx t) ! i = merge_option (xx ! i, t ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge xx t ! i = merge_option (xx ! i, t ! i)", "using \\<open>i < n\\<close> assms(2) assms(3) assms(4) wf_tuple_length"], ["proof (prove)\nusing this:\n  i < n\n  wf_tuple n V z\n  xx = restrict J z\n  t = restrict I z\n  wf_tuple ?n ?V ?x \\<Longrightarrow> length ?x = ?n\n\ngoal (1 subgoal):\n 1. merge xx t ! i = merge_option (xx ! i, t ! i)", "by fastforce"], ["proof (state)\nthis:\n  merge xx t ! i = merge_option (xx ! i, t ! i)\n\ngoal (1 subgoal):\n 1. merge xx t ! i = t ! i", "ultimately"], ["proof (chain)\npicking this:\n  xx ! i = None\n  merge xx t ! i = merge_option (xx ! i, t ! i)", "show ?thesis"], ["proof (prove)\nusing this:\n  xx ! i = None\n  merge xx t ! i = merge_option (xx ! i, t ! i)\n\ngoal (1 subgoal):\n 1. merge xx t ! i = t ! i", "proof (cases \"t ! i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>xx ! i = None; merge xx t ! i = merge_option (xx ! i, t ! i);\n     t ! i = None\\<rbrakk>\n    \\<Longrightarrow> merge xx t ! i = t ! i\n 2. \\<And>a.\n       \\<lbrakk>xx ! i = None;\n        merge xx t ! i = merge_option (xx ! i, t ! i);\n        t ! i = Some a\\<rbrakk>\n       \\<Longrightarrow> merge xx t ! i = t ! i", "case None"], ["proof (state)\nthis:\n  t ! i = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>xx ! i = None; merge xx t ! i = merge_option (xx ! i, t ! i);\n     t ! i = None\\<rbrakk>\n    \\<Longrightarrow> merge xx t ! i = t ! i\n 2. \\<And>a.\n       \\<lbrakk>xx ! i = None;\n        merge xx t ! i = merge_option (xx ! i, t ! i);\n        t ! i = Some a\\<rbrakk>\n       \\<Longrightarrow> merge xx t ! i = t ! i", "then"], ["proof (chain)\npicking this:\n  t ! i = None", "show ?thesis"], ["proof (prove)\nusing this:\n  t ! i = None\n\ngoal (1 subgoal):\n 1. merge xx t ! i = t ! i", "using \\<open>merge xx t ! i = merge_option (xx ! i, t ! i)\\<close> \\<open>xx ! i = None\\<close>"], ["proof (prove)\nusing this:\n  t ! i = None\n  merge xx t ! i = merge_option (xx ! i, t ! i)\n  xx ! i = None\n\ngoal (1 subgoal):\n 1. merge xx t ! i = t ! i", "by auto"], ["proof (state)\nthis:\n  merge xx t ! i = t ! i\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>xx ! i = None;\n        merge xx t ! i = merge_option (xx ! i, t ! i);\n        t ! i = Some a\\<rbrakk>\n       \\<Longrightarrow> merge xx t ! i = t ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>xx ! i = None;\n        merge xx t ! i = merge_option (xx ! i, t ! i);\n        t ! i = Some a\\<rbrakk>\n       \\<Longrightarrow> merge xx t ! i = t ! i", "case (Some a)"], ["proof (state)\nthis:\n  t ! i = Some a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>xx ! i = None;\n        merge xx t ! i = merge_option (xx ! i, t ! i);\n        t ! i = Some a\\<rbrakk>\n       \\<Longrightarrow> merge xx t ! i = t ! i", "then"], ["proof (chain)\npicking this:\n  t ! i = Some a", "show ?thesis"], ["proof (prove)\nusing this:\n  t ! i = Some a\n\ngoal (1 subgoal):\n 1. merge xx t ! i = t ! i", "using \\<open>merge xx t ! i = merge_option (xx ! i, t ! i)\\<close> \\<open>xx ! i = None\\<close>"], ["proof (prove)\nusing this:\n  t ! i = Some a\n  merge xx t ! i = merge_option (xx ! i, t ! i)\n  xx ! i = None\n\ngoal (1 subgoal):\n 1. merge xx t ! i = t ! i", "by auto"], ["proof (state)\nthis:\n  merge xx t ! i = t ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  merge xx t ! i = t ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  merge xx t ! i = t ! i\n\ngoal (2 subgoals):\n 1. i \\<in> I \\<Longrightarrow> z ! i = merge xx t ! i\n 2. i \\<notin> I \\<Longrightarrow> z ! i = merge xx t ! i", "then"], ["proof (chain)\npicking this:\n  merge xx t ! i = t ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  merge xx t ! i = t ! i\n\ngoal (1 subgoal):\n 1. z ! i = merge xx t ! i", "by (simp add: calculation)"], ["proof (state)\nthis:\n  z ! i = merge xx t ! i\n\ngoal (1 subgoal):\n 1. i \\<notin> I \\<Longrightarrow> z ! i = merge xx t ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<notin> I \\<Longrightarrow> z ! i = merge xx t ! i", "case False"], ["proof (state)\nthis:\n  i \\<notin> I\n\ngoal (1 subgoal):\n 1. i \\<notin> I \\<Longrightarrow> z ! i = merge xx t ! i", "have \"i \\<notin> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<notin> I", "by (simp add: False)"], ["proof (state)\nthis:\n  i \\<notin> I\n\ngoal (1 subgoal):\n 1. i \\<notin> I \\<Longrightarrow> z ! i = merge xx t ! i", "then"], ["proof (chain)\npicking this:\n  i \\<notin> I", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<notin> I\n\ngoal (1 subgoal):\n 1. z ! i = merge xx t ! i", "proof (cases \"i \\<in> J\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<notin> I; i \\<in> J\\<rbrakk>\n    \\<Longrightarrow> z ! i = merge xx t ! i\n 2. \\<lbrakk>i \\<notin> I; i \\<notin> J\\<rbrakk>\n    \\<Longrightarrow> z ! i = merge xx t ! i", "case True"], ["proof (state)\nthis:\n  i \\<in> J\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<notin> I; i \\<in> J\\<rbrakk>\n    \\<Longrightarrow> z ! i = merge xx t ! i\n 2. \\<lbrakk>i \\<notin> I; i \\<notin> J\\<rbrakk>\n    \\<Longrightarrow> z ! i = merge xx t ! i", "have \"z!i = xx!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z ! i = xx ! i", "by (metis True \\<open>i < n\\<close> assms(2) assms(3) nth_restrict wf_tuple_def)"], ["proof (state)\nthis:\n  z ! i = xx ! i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<notin> I; i \\<in> J\\<rbrakk>\n    \\<Longrightarrow> z ! i = merge xx t ! i\n 2. \\<lbrakk>i \\<notin> I; i \\<notin> J\\<rbrakk>\n    \\<Longrightarrow> z ! i = merge xx t ! i", "moreover"], ["proof (state)\nthis:\n  z ! i = xx ! i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<notin> I; i \\<in> J\\<rbrakk>\n    \\<Longrightarrow> z ! i = merge xx t ! i\n 2. \\<lbrakk>i \\<notin> I; i \\<notin> J\\<rbrakk>\n    \\<Longrightarrow> z ! i = merge xx t ! i", "have \"(merge xx t)!i = xx!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge xx t ! i = xx ! i", "proof (cases \"xx ! i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xx ! i = None \\<Longrightarrow> merge xx t ! i = xx ! i\n 2. \\<And>a. xx ! i = Some a \\<Longrightarrow> merge xx t ! i = xx ! i", "case None"], ["proof (state)\nthis:\n  xx ! i = None\n\ngoal (2 subgoals):\n 1. xx ! i = None \\<Longrightarrow> merge xx t ! i = xx ! i\n 2. \\<And>a. xx ! i = Some a \\<Longrightarrow> merge xx t ! i = xx ! i", "then"], ["proof (chain)\npicking this:\n  xx ! i = None", "show ?thesis"], ["proof (prove)\nusing this:\n  xx ! i = None\n\ngoal (1 subgoal):\n 1. merge xx t ! i = xx ! i", "by (metis True UnI1 \\<open>i < n\\<close> assms(1) assms(2) calculation sup_commute wf_tuple_def)"], ["proof (state)\nthis:\n  merge xx t ! i = xx ! i\n\ngoal (1 subgoal):\n 1. \\<And>a. xx ! i = Some a \\<Longrightarrow> merge xx t ! i = xx ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. xx ! i = Some a \\<Longrightarrow> merge xx t ! i = xx ! i", "case (Some a)"], ["proof (state)\nthis:\n  xx ! i = Some a\n\ngoal (1 subgoal):\n 1. \\<And>a. xx ! i = Some a \\<Longrightarrow> merge xx t ! i = xx ! i", "have \"t ! i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t ! i = None", "by (metis False simple_restrict_none \\<open>i < n\\<close> assms(2) assms(4) wf_tuple_length)"], ["proof (state)\nthis:\n  t ! i = None\n\ngoal (1 subgoal):\n 1. \\<And>a. xx ! i = Some a \\<Longrightarrow> merge xx t ! i = xx ! i", "then"], ["proof (chain)\npicking this:\n  t ! i = None", "show ?thesis"], ["proof (prove)\nusing this:\n  t ! i = None\n\ngoal (1 subgoal):\n 1. merge xx t ! i = xx ! i", "using Some \\<open>i < n\\<close> assms(2) assms(3) assms(4) wf_tuple_length"], ["proof (prove)\nusing this:\n  t ! i = None\n  xx ! i = Some a\n  i < n\n  wf_tuple n V z\n  xx = restrict J z\n  t = restrict I z\n  wf_tuple ?n ?V ?x \\<Longrightarrow> length ?x = ?n\n\ngoal (1 subgoal):\n 1. merge xx t ! i = xx ! i", "by fastforce"], ["proof (state)\nthis:\n  merge xx t ! i = xx ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  merge xx t ! i = xx ! i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<notin> I; i \\<in> J\\<rbrakk>\n    \\<Longrightarrow> z ! i = merge xx t ! i\n 2. \\<lbrakk>i \\<notin> I; i \\<notin> J\\<rbrakk>\n    \\<Longrightarrow> z ! i = merge xx t ! i", "then"], ["proof (chain)\npicking this:\n  merge xx t ! i = xx ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  merge xx t ! i = xx ! i\n\ngoal (1 subgoal):\n 1. z ! i = merge xx t ! i", "by (simp add: calculation)"], ["proof (state)\nthis:\n  z ! i = merge xx t ! i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> I; i \\<notin> J\\<rbrakk>\n    \\<Longrightarrow> z ! i = merge xx t ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> I; i \\<notin> J\\<rbrakk>\n    \\<Longrightarrow> z ! i = merge xx t ! i", "case False"], ["proof (state)\nthis:\n  i \\<notin> J\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> I; i \\<notin> J\\<rbrakk>\n    \\<Longrightarrow> z ! i = merge xx t ! i", "have \"z!i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z ! i = None", "by (metis False UnE \\<open>i < n\\<close> \\<open>i \\<notin> I\\<close> assms(1) assms(2) wf_tuple_def)"], ["proof (state)\nthis:\n  z ! i = None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> I; i \\<notin> J\\<rbrakk>\n    \\<Longrightarrow> z ! i = merge xx t ! i", "moreover"], ["proof (state)\nthis:\n  z ! i = None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> I; i \\<notin> J\\<rbrakk>\n    \\<Longrightarrow> z ! i = merge xx t ! i", "have \"(merge xx t)!i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge xx t ! i = None", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. merge xx t ! i = None", "have \"xx ! i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xx ! i = None", "by (metis False New_max.simple_restrict_none \\<open>i < n\\<close> assms(2) assms(3) wf_tuple_length)"], ["proof (state)\nthis:\n  xx ! i = None\n\ngoal (1 subgoal):\n 1. merge xx t ! i = None", "moreover"], ["proof (state)\nthis:\n  xx ! i = None\n\ngoal (1 subgoal):\n 1. merge xx t ! i = None", "have \"t ! i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t ! i = None", "by (metis New_max.simple_restrict_none \\<open>i < n\\<close> \\<open>i \\<notin> I\\<close> assms(2) assms(4) wf_tuple_length)"], ["proof (state)\nthis:\n  t ! i = None\n\ngoal (1 subgoal):\n 1. merge xx t ! i = None", "ultimately"], ["proof (chain)\npicking this:\n  xx ! i = None\n  t ! i = None", "show ?thesis"], ["proof (prove)\nusing this:\n  xx ! i = None\n  t ! i = None\n\ngoal (1 subgoal):\n 1. merge xx t ! i = None", "using \\<open>i < n\\<close> assms(2) assms(3) assms(4) wf_tuple_length"], ["proof (prove)\nusing this:\n  xx ! i = None\n  t ! i = None\n  i < n\n  wf_tuple n V z\n  xx = restrict J z\n  t = restrict I z\n  wf_tuple ?n ?V ?x \\<Longrightarrow> length ?x = ?n\n\ngoal (1 subgoal):\n 1. merge xx t ! i = None", "by fastforce"], ["proof (state)\nthis:\n  merge xx t ! i = None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  merge xx t ! i = None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> I; i \\<notin> J\\<rbrakk>\n    \\<Longrightarrow> z ! i = merge xx t ! i", "then"], ["proof (chain)\npicking this:\n  merge xx t ! i = None", "show ?thesis"], ["proof (prove)\nusing this:\n  merge xx t ! i = None\n\ngoal (1 subgoal):\n 1. z ! i = merge xx t ! i", "by (simp add: calculation)"], ["proof (state)\nthis:\n  z ! i = merge xx t ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z ! i = merge xx t ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z ! i = merge xx t ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> z ! ?i = merge xx t ! ?i\n\ngoal (1 subgoal):\n 1. z = merge xx t", "moreover"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> z ! ?i = merge xx t ! ?i\n\ngoal (1 subgoal):\n 1. z = merge xx t", "have \"length z = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length z = n", "using assms(2) wf_tuple_def"], ["proof (prove)\nusing this:\n  wf_tuple n V z\n  wf_tuple ?n ?V ?x =\n  (length ?x = ?n \\<and> (\\<forall>i<?n. (?x ! i = None) = (i \\<notin> ?V)))\n\ngoal (1 subgoal):\n 1. length z = n", "by blast"], ["proof (state)\nthis:\n  length z = n\n\ngoal (1 subgoal):\n 1. z = merge xx t", "then"], ["proof (chain)\npicking this:\n  length z = n", "show ?thesis"], ["proof (prove)\nusing this:\n  length z = n\n\ngoal (1 subgoal):\n 1. z = merge xx t", "by (simp add: assms(3) assms(4) calculation simple_list_index_equality)"], ["proof (state)\nthis:\n  z = merge xx t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma restrict_merge:\n  assumes \"zI = restrict I z\"\n  assumes \"zJ = restrict J z\"\n  assumes \"restrict (A \\<inter> I) zI \\<in> Set.image (restrict I) X\"\n  assumes \"restrict (A \\<inter> J) zJ \\<in> Set.image (restrict J) (Set.filter (isSameIntersection zI (A \\<inter> I)) X)\"\n  assumes \"z = merge zJ zI\"\n  assumes \"table n A X\"\n  assumes \"A \\<subseteq> I \\<union> J\"\n  assumes \"card (A \\<inter> I) \\<ge> 1\"\n  assumes \"wf_set n (I \\<union> J)\"\n  assumes \"wf_tuple n (I \\<union> J) z\"\n  shows \"restrict A z \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict A z \\<in> X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. restrict A z \\<in> X", "define zAJ where \"zAJ = restrict (A \\<inter> J) zJ\""], ["proof (state)\nthis:\n  zAJ = restrict (A \\<inter> J) zJ\n\ngoal (1 subgoal):\n 1. restrict A z \\<in> X", "obtain zz where \"zAJ = restrict J zz\" \"isSameIntersection zI (A \\<inter> I) zz\" \"zz \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>zz.\n        \\<lbrakk>zAJ = restrict J zz;\n         isSameIntersection zI (A \\<inter> I) zz; zz \\<in> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(4) zAJ_def"], ["proof (prove)\nusing this:\n  restrict (A \\<inter> J) zJ\n  \\<in> restrict J ` Set.filter (isSameIntersection zI (A \\<inter> I)) X\n  zAJ = restrict (A \\<inter> J) zJ\n\ngoal (1 subgoal):\n 1. (\\<And>zz.\n        \\<lbrakk>zAJ = restrict J zz;\n         isSameIntersection zI (A \\<inter> I) zz; zz \\<in> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  zAJ = restrict J zz\n  isSameIntersection zI (A \\<inter> I) zz\n  zz \\<in> X\n\ngoal (1 subgoal):\n 1. restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  zAJ = restrict J zz\n  isSameIntersection zI (A \\<inter> I) zz\n  zz \\<in> X", "have \"restrict (A \\<inter> I) zz = restrict A zI\""], ["proof (prove)\nusing this:\n  zAJ = restrict J zz\n  isSameIntersection zI (A \\<inter> I) zz\n  zz \\<in> X\n\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zz = restrict A zI", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>zAJ = restrict J zz; isSameIntersection zI (A \\<inter> I) zz;\n     zz \\<in> X\\<rbrakk>\n    \\<Longrightarrow> restrict (A \\<inter> I) zz = restrict A zI", "have \"restrict (A \\<inter> I) zI = restrict (A \\<inter> I) zz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zI = restrict (A \\<inter> I) zz", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zI = restrict (A \\<inter> I) zz", "have \"wf_set n A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_set n A", "using assms(7) assms(9) wf_set_def"], ["proof (prove)\nusing this:\n  A \\<subseteq> I \\<union> J\n  wf_set n (I \\<union> J)\n  wf_set ?n ?V = (\\<forall>x\\<in>?V. x < ?n)\n\ngoal (1 subgoal):\n 1. wf_set n A", "by auto"], ["proof (state)\nthis:\n  wf_set n A\n\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zI = restrict (A \\<inter> I) zz", "moreover"], ["proof (state)\nthis:\n  wf_set n A\n\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zI = restrict (A \\<inter> I) zz", "have \"wf_tuple n I zI\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple n I zI", "using assms(1) assms(10) wf_tuple_restrict_simple"], ["proof (prove)\nusing this:\n  zI = restrict I z\n  wf_tuple n (I \\<union> J) z\n  \\<lbrakk>wf_tuple ?n ?B ?v; ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> wf_tuple ?n ?A (restrict ?A ?v)\n\ngoal (1 subgoal):\n 1. wf_tuple n I zI", "by auto"], ["proof (state)\nthis:\n  wf_tuple n I zI\n\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zI = restrict (A \\<inter> I) zz", "moreover"], ["proof (state)\nthis:\n  wf_tuple n I zI\n\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zI = restrict (A \\<inter> I) zz", "have \"wf_tuple n A zz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple n A zz", "using \\<open>zz \\<in> X\\<close> assms(6) table_def"], ["proof (prove)\nusing this:\n  zz \\<in> X\n  table n A X\n  table ?n ?V ?X = (\\<forall>x\\<in>?X. wf_tuple ?n ?V x)\n\ngoal (1 subgoal):\n 1. wf_tuple n A zz", "by blast"], ["proof (state)\nthis:\n  wf_tuple n A zz\n\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zI = restrict (A \\<inter> I) zz", "moreover"], ["proof (state)\nthis:\n  wf_tuple n A zz\n\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zI = restrict (A \\<inter> I) zz", "obtain \"A \\<inter> I \\<subseteq> A\" \"A \\<inter> I \\<subseteq> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>A \\<inter> I \\<subseteq> A;\n      A \\<inter> I \\<subseteq> I\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  A \\<inter> I \\<subseteq> A\n  A \\<inter> I \\<subseteq> I\n\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zI = restrict (A \\<inter> I) zz", "then"], ["proof (chain)\npicking this:\n  A \\<inter> I \\<subseteq> A\n  A \\<inter> I \\<subseteq> I", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<inter> I \\<subseteq> A\n  A \\<inter> I \\<subseteq> I\n\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zI = restrict (A \\<inter> I) zz", "using isSame_equi_dev[of n _ I zI A zz \"A \\<inter> I\"]"], ["proof (prove)\nusing this:\n  A \\<inter> I \\<subseteq> A\n  A \\<inter> I \\<subseteq> I\n  \\<lbrakk>wf_set n ?V; wf_tuple n I zI; wf_tuple n A zz;\n   A \\<inter> I \\<subseteq> I; A \\<inter> I \\<subseteq> A; I \\<subseteq> ?V;\n   A \\<subseteq> ?V\\<rbrakk>\n  \\<Longrightarrow> isSameIntersection zI (A \\<inter> I) zz =\n                    (restrict (A \\<inter> I) zI =\n                     restrict (A \\<inter> I) zz)\n\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zI = restrict (A \\<inter> I) zz", "using \\<open>isSameIntersection zI (A \\<inter> I) zz\\<close> assms(7) assms(9) calculation(2) calculation(3)"], ["proof (prove)\nusing this:\n  A \\<inter> I \\<subseteq> A\n  A \\<inter> I \\<subseteq> I\n  \\<lbrakk>wf_set n ?V; wf_tuple n I zI; wf_tuple n A zz;\n   A \\<inter> I \\<subseteq> I; A \\<inter> I \\<subseteq> A; I \\<subseteq> ?V;\n   A \\<subseteq> ?V\\<rbrakk>\n  \\<Longrightarrow> isSameIntersection zI (A \\<inter> I) zz =\n                    (restrict (A \\<inter> I) zI =\n                     restrict (A \\<inter> I) zz)\n  isSameIntersection zI (A \\<inter> I) zz\n  A \\<subseteq> I \\<union> J\n  wf_set n (I \\<union> J)\n  wf_tuple n I zI\n  wf_tuple n A zz\n\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zI = restrict (A \\<inter> I) zz", "by blast"], ["proof (state)\nthis:\n  restrict (A \\<inter> I) zI = restrict (A \\<inter> I) zz\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict (A \\<inter> I) zI = restrict (A \\<inter> I) zz\n\ngoal (1 subgoal):\n 1. \\<lbrakk>zAJ = restrict J zz; isSameIntersection zI (A \\<inter> I) zz;\n     zz \\<in> X\\<rbrakk>\n    \\<Longrightarrow> restrict (A \\<inter> I) zz = restrict A zI", "then"], ["proof (chain)\npicking this:\n  restrict (A \\<inter> I) zI = restrict (A \\<inter> I) zz", "show ?thesis"], ["proof (prove)\nusing this:\n  restrict (A \\<inter> I) zI = restrict (A \\<inter> I) zz\n\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zz = restrict A zI", "by (simp add: restrict_nested assms(1))"], ["proof (state)\nthis:\n  restrict (A \\<inter> I) zz = restrict A zI\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict (A \\<inter> I) zz = restrict A zI\n\ngoal (1 subgoal):\n 1. restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  restrict (A \\<inter> I) zz = restrict A zI", "have \"zz = restrict A z\""], ["proof (prove)\nusing this:\n  restrict (A \\<inter> I) zz = restrict A zI\n\ngoal (1 subgoal):\n 1. zz = restrict A z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zz = restrict A zI \\<Longrightarrow>\n    zz = restrict A z", "have \"length zz = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length zz = n", "using \\<open>zz \\<in> X\\<close> assms(6) table_def wf_tuple_def"], ["proof (prove)\nusing this:\n  zz \\<in> X\n  table n A X\n  table ?n ?V ?X = (\\<forall>x\\<in>?X. wf_tuple ?n ?V x)\n  wf_tuple ?n ?V ?x =\n  (length ?x = ?n \\<and> (\\<forall>i<?n. (?x ! i = None) = (i \\<notin> ?V)))\n\ngoal (1 subgoal):\n 1. length zz = n", "by blast"], ["proof (state)\nthis:\n  length zz = n\n\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zz = restrict A zI \\<Longrightarrow>\n    zz = restrict A z", "moreover"], ["proof (state)\nthis:\n  length zz = n\n\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zz = restrict A zI \\<Longrightarrow>\n    zz = restrict A z", "have \"length (restrict A z) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (restrict A z) = n", "by (metis \\<open>restrict (A \\<inter> I) zz = restrict A zI\\<close> assms(1) calculation length_restrict)"], ["proof (state)\nthis:\n  length (restrict A z) = n\n\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zz = restrict A zI \\<Longrightarrow>\n    zz = restrict A z", "moreover"], ["proof (state)\nthis:\n  length (restrict A z) = n\n\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zz = restrict A zI \\<Longrightarrow>\n    zz = restrict A z", "have \"\\<And>i. i < n \\<Longrightarrow> zz!i = (restrict A z)!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> zz ! i = restrict A z ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> zz ! i = restrict A z ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> zz ! i = restrict A z ! i", "assume \"i < n\""], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<And>i. i < n \\<Longrightarrow> zz ! i = restrict A z ! i", "show \"zz!i = (restrict A z)!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zz ! i = restrict A z ! i", "proof (cases \"i \\<in> A\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<in> A \\<Longrightarrow> zz ! i = restrict A z ! i\n 2. i \\<notin> A \\<Longrightarrow> zz ! i = restrict A z ! i", "case True"], ["proof (state)\nthis:\n  i \\<in> A\n\ngoal (2 subgoals):\n 1. i \\<in> A \\<Longrightarrow> zz ! i = restrict A z ! i\n 2. i \\<notin> A \\<Longrightarrow> zz ! i = restrict A z ! i", "have \"i \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> A", "using True"], ["proof (prove)\nusing this:\n  i \\<in> A\n\ngoal (1 subgoal):\n 1. i \\<in> A", "by simp"], ["proof (state)\nthis:\n  i \\<in> A\n\ngoal (2 subgoals):\n 1. i \\<in> A \\<Longrightarrow> zz ! i = restrict A z ! i\n 2. i \\<notin> A \\<Longrightarrow> zz ! i = restrict A z ! i", "then"], ["proof (chain)\npicking this:\n  i \\<in> A", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<in> A\n\ngoal (1 subgoal):\n 1. zz ! i = restrict A z ! i", "proof (cases \"i \\<in> I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<in> A; i \\<in> I\\<rbrakk>\n    \\<Longrightarrow> zz ! i = restrict A z ! i\n 2. \\<lbrakk>i \\<in> A; i \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> zz ! i = restrict A z ! i", "case True"], ["proof (state)\nthis:\n  i \\<in> I\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<in> A; i \\<in> I\\<rbrakk>\n    \\<Longrightarrow> zz ! i = restrict A z ! i\n 2. \\<lbrakk>i \\<in> A; i \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> zz ! i = restrict A z ! i", "have \"zz!i = (restrict (A \\<inter> I) zz)!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zz ! i = restrict (A \\<inter> I) zz ! i", "by (simp add: True \\<open>i < n\\<close> \\<open>i \\<in> A\\<close> calculation(1) restrict_index_in)"], ["proof (state)\nthis:\n  zz ! i = restrict (A \\<inter> I) zz ! i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<in> A; i \\<in> I\\<rbrakk>\n    \\<Longrightarrow> zz ! i = restrict A z ! i\n 2. \\<lbrakk>i \\<in> A; i \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> zz ! i = restrict A z ! i", "then"], ["proof (chain)\npicking this:\n  zz ! i = restrict (A \\<inter> I) zz ! i", "have \"... = (restrict A zI)!i\""], ["proof (prove)\nusing this:\n  zz ! i = restrict (A \\<inter> I) zz ! i\n\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zz ! i = restrict A zI ! i", "by (simp add: \\<open>restrict (A \\<inter> I) zz = restrict A zI\\<close>)"], ["proof (state)\nthis:\n  restrict (A \\<inter> I) zz ! i = restrict A zI ! i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<in> A; i \\<in> I\\<rbrakk>\n    \\<Longrightarrow> zz ! i = restrict A z ! i\n 2. \\<lbrakk>i \\<in> A; i \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> zz ! i = restrict A z ! i", "then"], ["proof (chain)\npicking this:\n  restrict (A \\<inter> I) zz ! i = restrict A zI ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  restrict (A \\<inter> I) zz ! i = restrict A zI ! i\n\ngoal (1 subgoal):\n 1. zz ! i = restrict A z ! i", "by (metis True \\<open>i < n\\<close> \\<open>i \\<in> A\\<close> \\<open>zz ! i = restrict (A \\<inter> I) zz ! i\\<close> assms(1) calculation(2)\n                length_restrict restrict_index_in)"], ["proof (state)\nthis:\n  zz ! i = restrict A z ! i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<in> A; i \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> zz ! i = restrict A z ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<in> A; i \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> zz ! i = restrict A z ! i", "case False"], ["proof (state)\nthis:\n  i \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<in> A; i \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> zz ! i = restrict A z ! i", "have \"zz!i = (restrict (A \\<inter> J) zJ)!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zz ! i = restrict (A \\<inter> J) zJ ! i", "by (metis False True UnE \\<open>i < n\\<close> \\<open>zAJ = restrict J zz\\<close> assms(7) calculation(1)\n                restrict_index_in subsetD zAJ_def)"], ["proof (state)\nthis:\n  zz ! i = restrict (A \\<inter> J) zJ ! i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<in> A; i \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> zz ! i = restrict A z ! i", "then"], ["proof (chain)\npicking this:\n  zz ! i = restrict (A \\<inter> J) zJ ! i", "have \"... = (restrict A zJ)!i\""], ["proof (prove)\nusing this:\n  zz ! i = restrict (A \\<inter> J) zJ ! i\n\ngoal (1 subgoal):\n 1. restrict (A \\<inter> J) zJ ! i = restrict A zJ ! i", "by (simp add: assms(2) restrict_nested)"], ["proof (state)\nthis:\n  restrict (A \\<inter> J) zJ ! i = restrict A zJ ! i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<in> A; i \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> zz ! i = restrict A z ! i", "then"], ["proof (chain)\npicking this:\n  restrict (A \\<inter> J) zJ ! i = restrict A zJ ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  restrict (A \\<inter> J) zJ ! i = restrict A zJ ! i\n\ngoal (1 subgoal):\n 1. zz ! i = restrict A z ! i", "by (metis False True UnE \\<open>i < n\\<close> \\<open>zz ! i = restrict (A \\<inter> J) zJ ! i\\<close> assms(2) assms(7)\n                calculation(2) length_restrict restrict_index_in subsetD)"], ["proof (state)\nthis:\n  zz ! i = restrict A z ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  zz ! i = restrict A z ! i\n\ngoal (1 subgoal):\n 1. i \\<notin> A \\<Longrightarrow> zz ! i = restrict A z ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<notin> A \\<Longrightarrow> zz ! i = restrict A z ! i", "case False"], ["proof (state)\nthis:\n  i \\<notin> A\n\ngoal (1 subgoal):\n 1. i \\<notin> A \\<Longrightarrow> zz ! i = restrict A z ! i", "then"], ["proof (chain)\npicking this:\n  i \\<notin> A", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<notin> A\n\ngoal (1 subgoal):\n 1. zz ! i = restrict A z ! i", "by (metis \\<open>i < n\\<close> \\<open>zz \\<in> X\\<close> assms(6) calculation(2) length_restrict simple_restrict_none table_def wf_tuple_def)"], ["proof (state)\nthis:\n  zz ! i = restrict A z ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  zz ! i = restrict A z ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> zz ! ?i = restrict A z ! ?i\n\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zz = restrict A zI \\<Longrightarrow>\n    zz = restrict A z", "then"], ["proof (chain)\npicking this:\n  ?i < n \\<Longrightarrow> zz ! ?i = restrict A z ! ?i", "show ?thesis"], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow> zz ! ?i = restrict A z ! ?i\n\ngoal (1 subgoal):\n 1. zz = restrict A z", "using calculation(1) calculation(2) simple_list_index_equality"], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow> zz ! ?i = restrict A z ! ?i\n  length zz = n\n  length (restrict A z) = n\n  \\<lbrakk>length ?a = ?n; length ?b = ?n;\n   \\<forall>i<?n. ?a ! i = ?b ! i\\<rbrakk>\n  \\<Longrightarrow> ?a = ?b\n\ngoal (1 subgoal):\n 1. zz = restrict A z", "by blast"], ["proof (state)\nthis:\n  zz = restrict A z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  zz = restrict A z\n\ngoal (1 subgoal):\n 1. restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  zz = restrict A z", "show ?thesis"], ["proof (prove)\nusing this:\n  zz = restrict A z\n\ngoal (1 subgoal):\n 1. restrict A z \\<in> X", "using \\<open>zz \\<in> X\\<close>"], ["proof (prove)\nusing this:\n  zz = restrict A z\n  zz \\<in> X\n\ngoal (1 subgoal):\n 1. restrict A z \\<in> X", "by auto"], ["proof (state)\nthis:\n  restrict A z \\<in> X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma partial_correctness:\n  assumes \"V = I \\<union> J\"\n  assumes \"Set.is_empty (I \\<inter> J)\"\n  assumes \"card I \\<ge> 1\"\n  assumes \"card J \\<ge> 1\"\n  assumes \"Q_I_pos = projectQuery I (filterQuery I Q)\"\n  assumes \"Q_J_pos = filterQuery J Q\"\n  assumes \"Q_I_neg = filterQueryNeg I Qn\"\n  assumes \"Q_J_neg = filterQuery J (Qn - Q_I_neg)\"\n  assumes \"NQ_pos = newQuery J Q_J_pos (I, t)\"\n  assumes \"NQ_neg = newQuery J Q_J_neg (I, t)\"\n  assumes \"R_NQ = genericJoin J NQ_pos NQ_neg\"\n  assumes \"\\<forall>x. (x \\<in> R_I \\<longleftrightarrow> wf_tuple n I x \\<and> (\\<forall>(A, X)\\<in>Q_I_pos. restrict A x \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Q_I_neg. restrict A x \\<notin> X))\"\n  assumes \"\\<forall>y. (y \\<in> R_NQ \\<longleftrightarrow> wf_tuple n J y \\<and> (\\<forall>(A, X)\\<in>NQ_pos. restrict A y \\<in> X) \\<and> (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X))\"\n  assumes \"z = merge xx t\"\n  assumes \"t \\<in> R_I\"\n  assumes \"xx \\<in> R_NQ\"\n  assumes \"rwf_query n V Q Qn\"\n  shows \"wf_tuple n V z \\<and> (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)", "obtain \"wf_tuple n I t\" \"wf_tuple n J xx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>wf_tuple n I t; wf_tuple n J xx\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(12) assms(13) assms(15) assms(16)"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     (x \\<in> R_I) =\n     (wf_tuple n I x \\<and>\n      (\\<forall>(A, X)\\<in>Q_I_pos. restrict A x \\<in> X) \\<and>\n      (\\<forall>(A, X)\\<in>Q_I_neg. restrict A x \\<notin> X))\n  \\<forall>y.\n     (y \\<in> R_NQ) =\n     (wf_tuple n J y \\<and>\n      (\\<forall>(A, X)\\<in>NQ_pos. restrict A y \\<in> X) \\<and>\n      (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X))\n  t \\<in> R_I\n  xx \\<in> R_NQ\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>wf_tuple n I t; wf_tuple n J xx\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  wf_tuple n I t\n  wf_tuple n J xx\n\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)", "then"], ["proof (chain)\npicking this:\n  wf_tuple n I t\n  wf_tuple n J xx", "have \"wf_tuple n V z\""], ["proof (prove)\nusing this:\n  wf_tuple n I t\n  wf_tuple n J xx\n\ngoal (1 subgoal):\n 1. wf_tuple n V z", "by (metis wf_merge assms(1) assms(14) sup_commute)"], ["proof (state)\nthis:\n  wf_tuple n V z\n\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)", "moreover"], ["proof (state)\nthis:\n  wf_tuple n V z\n\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)", "have \"\\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "fix A X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "assume \"(A, X) \\<in> Qn\""], ["proof (state)\nthis:\n  (A, X) \\<in> Qn\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "have \"restrict I (merge xx t) = restrict I t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict I (merge xx t) = restrict I t", "by (metis (no_types, lifting) Set.is_empty_def \\<open>\\<And>thesis. (\\<lbrakk>wf_tuple n I t; wf_tuple n J xx\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\\<close>\n          assms(2) merge_restrict restrict_idle sup.cobounded1 wf_tuple_def)"], ["proof (state)\nthis:\n  restrict I (merge xx t) = restrict I t\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "moreover"], ["proof (state)\nthis:\n  restrict I (merge xx t) = restrict I t\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "have \"restrict J (merge xx t) = restrict J xx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict J (merge xx t) = restrict J xx", "by (metis Set.is_empty_def \\<open>\\<And>thesis. (\\<lbrakk>wf_tuple n I t; wf_tuple n J xx\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\\<close>\n          assms(2) inf_commute real_restrict_merge)"], ["proof (state)\nthis:\n  restrict J (merge xx t) = restrict J xx\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "moreover"], ["proof (state)\nthis:\n  restrict J (merge xx t) = restrict J xx\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "have \"restrict J xx = xx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict J xx = xx", "using \\<open>wf_tuple n J xx\\<close> restrict_idle"], ["proof (prove)\nusing this:\n  wf_tuple n J xx\n  wf_tuple ?n ?A ?v \\<Longrightarrow> restrict ?A ?v = ?v\n\ngoal (1 subgoal):\n 1. restrict J xx = xx", "by auto"], ["proof (state)\nthis:\n  restrict J xx = xx\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "moreover"], ["proof (state)\nthis:\n  restrict J xx = xx\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "have \"restrict I t = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict I t = t", "using \\<open>wf_tuple n I t\\<close> restrict_idle"], ["proof (prove)\nusing this:\n  wf_tuple n I t\n  wf_tuple ?n ?A ?v \\<Longrightarrow> restrict ?A ?v = ?v\n\ngoal (1 subgoal):\n 1. restrict I t = t", "by auto"], ["proof (state)\nthis:\n  restrict I t = t\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "then"], ["proof (chain)\npicking this:\n  restrict I t = t", "obtain \"restrict I z = t\" \"restrict J z = xx\""], ["proof (prove)\nusing this:\n  restrict I t = t\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>restrict I z = t; restrict J z = xx\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(14) calculation(1) calculation(2) calculation(3)"], ["proof (prove)\nusing this:\n  restrict I t = t\n  z = merge xx t\n  restrict I (merge xx t) = restrict I t\n  restrict J (merge xx t) = restrict J xx\n  restrict J xx = xx\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>restrict I z = t; restrict J z = xx\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  restrict I z = t\n  restrict J z = xx\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "moreover"], ["proof (state)\nthis:\n  restrict I z = t\n  restrict J z = xx\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "have \"\\<forall>(A, X)\\<in>Q_I_pos. restrict A t \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(A, X)\\<in>Q_I_pos. restrict A t \\<in> X", "using assms(12) assms(15)"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     (x \\<in> R_I) =\n     (wf_tuple n I x \\<and>\n      (\\<forall>(A, X)\\<in>Q_I_pos. restrict A x \\<in> X) \\<and>\n      (\\<forall>(A, X)\\<in>Q_I_neg. restrict A x \\<notin> X))\n  t \\<in> R_I\n\ngoal (1 subgoal):\n 1. \\<forall>(A, X)\\<in>Q_I_pos. restrict A t \\<in> X", "by blast"], ["proof (state)\nthis:\n  \\<forall>(A, X)\\<in>Q_I_pos. restrict A t \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "moreover"], ["proof (state)\nthis:\n  \\<forall>(A, X)\\<in>Q_I_pos. restrict A t \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "have \"\\<forall>(A, X)\\<in>NQ_pos. restrict A xx \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(A, X)\\<in>NQ_pos. restrict A xx \\<in> X", "using assms(13) assms(16)"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y \\<in> R_NQ) =\n     (wf_tuple n J y \\<and>\n      (\\<forall>(A, X)\\<in>NQ_pos. restrict A y \\<in> X) \\<and>\n      (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X))\n  xx \\<in> R_NQ\n\ngoal (1 subgoal):\n 1. \\<forall>(A, X)\\<in>NQ_pos. restrict A xx \\<in> X", "by blast"], ["proof (state)\nthis:\n  \\<forall>(A, X)\\<in>NQ_pos. restrict A xx \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "moreover"], ["proof (state)\nthis:\n  \\<forall>(A, X)\\<in>NQ_pos. restrict A xx \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "have \"card A \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> card A", "using \\<open>(A, X) \\<in> Qn\\<close> assms(17) non_empty_query_def rwf_query_def"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Qn\n  rwf_query n V Q Qn\n  non_empty_query ?Q = (\\<forall>X\\<in>?Q. 1 \\<le> card (fst X))\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n\ngoal (1 subgoal):\n 1. 1 \\<le> card A", "by fastforce"], ["proof (state)\nthis:\n  1 \\<le> card A\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Qn \\<Longrightarrow> restrict A z \\<notin> X", "then"], ["proof (chain)\npicking this:\n  1 \\<le> card A", "show \"restrict A z \\<notin> X\""], ["proof (prove)\nusing this:\n  1 \\<le> card A\n\ngoal (1 subgoal):\n 1. restrict A z \\<notin> X", "proof (cases \"A \\<subseteq> I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card A; A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X\n 2. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "case True"], ["proof (state)\nthis:\n  A \\<subseteq> I\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card A; A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X\n 2. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "have \"(A, X) \\<in> Q_I_neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A, X) \\<in> Q_I_neg", "by (simp add: True \\<open>(A, X) \\<in> Qn\\<close> assms(7))"], ["proof (state)\nthis:\n  (A, X) \\<in> Q_I_neg\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card A; A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X\n 2. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "have \"table n A X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. table n A X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. table n A X", "have \"wf_query n V Q Qn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_query n V Q Qn", "using assms(17) rwf_query_def"], ["proof (prove)\nusing this:\n  rwf_query n V Q Qn\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n\ngoal (1 subgoal):\n 1. wf_query n V Q Qn", "by blast"], ["proof (state)\nthis:\n  wf_query n V Q Qn\n\ngoal (1 subgoal):\n 1. table n A X", "moreover"], ["proof (state)\nthis:\n  wf_query n V Q Qn\n\ngoal (1 subgoal):\n 1. table n A X", "have \"(A, X) \\<in> (Q \\<union> Qn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A, X) \\<in> Q \\<union> Qn", "by (simp add: \\<open>(A, X) \\<in> Qn\\<close>)"], ["proof (state)\nthis:\n  (A, X) \\<in> Q \\<union> Qn\n\ngoal (1 subgoal):\n 1. table n A X", "then"], ["proof (chain)\npicking this:\n  (A, X) \\<in> Q \\<union> Qn", "show ?thesis"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q \\<union> Qn\n\ngoal (1 subgoal):\n 1. table n A X", "by (metis calculation fst_conv snd_conv wf_atable_def wf_query_def)"], ["proof (state)\nthis:\n  table n A X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  table n A X\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card A; A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X\n 2. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "then"], ["proof (chain)\npicking this:\n  table n A X", "have \"restrict A t \\<notin> X\""], ["proof (prove)\nusing this:\n  table n A X\n\ngoal (1 subgoal):\n 1. restrict A t \\<notin> X", "using \\<open>(A, X) \\<in> Q_I_neg\\<close> assms(12) assms(15)"], ["proof (prove)\nusing this:\n  table n A X\n  (A, X) \\<in> Q_I_neg\n  \\<forall>x.\n     (x \\<in> R_I) =\n     (wf_tuple n I x \\<and>\n      (\\<forall>(A, X)\\<in>Q_I_pos. restrict A x \\<in> X) \\<and>\n      (\\<forall>(A, X)\\<in>Q_I_neg. restrict A x \\<notin> X))\n  t \\<in> R_I\n\ngoal (1 subgoal):\n 1. restrict A t \\<notin> X", "by blast"], ["proof (state)\nthis:\n  restrict A t \\<notin> X\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card A; A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X\n 2. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "moreover"], ["proof (state)\nthis:\n  restrict A t \\<notin> X\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card A; A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X\n 2. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "have \"restrict A z = restrict A t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict A z = restrict A t", "using True \\<open>restrict I z = t\\<close> nested_include_restrict"], ["proof (prove)\nusing this:\n  A \\<subseteq> I\n  restrict I z = t\n  \\<lbrakk>restrict ?I ?z = ?t; ?A \\<subseteq> ?I\\<rbrakk>\n  \\<Longrightarrow> restrict ?A ?z = restrict ?A ?t\n\ngoal (1 subgoal):\n 1. restrict A z = restrict A t", "by blast"], ["proof (state)\nthis:\n  restrict A z = restrict A t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card A; A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X\n 2. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "then"], ["proof (chain)\npicking this:\n  restrict A z = restrict A t", "show ?thesis"], ["proof (prove)\nusing this:\n  restrict A z = restrict A t\n\ngoal (1 subgoal):\n 1. restrict A z \\<notin> X", "by (simp add: calculation)"], ["proof (state)\nthis:\n  restrict A z \\<notin> X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "case False"], ["proof (state)\nthis:\n  \\<not> A \\<subseteq> I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "have \"(A, X) \\<in> Q_J_neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A, X) \\<in> Q_J_neg", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (A, X) \\<in> Q_J_neg", "have \"(A, X) \\<in> Qn - Q_I_neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A, X) \\<in> Qn - Q_I_neg", "using False \\<open>(A, X) \\<in> Qn\\<close> assms(7)"], ["proof (prove)\nusing this:\n  \\<not> A \\<subseteq> I\n  (A, X) \\<in> Qn\n  Q_I_neg = filterQueryNeg I Qn\n\ngoal (1 subgoal):\n 1. (A, X) \\<in> Qn - Q_I_neg", "by auto"], ["proof (state)\nthis:\n  (A, X) \\<in> Qn - Q_I_neg\n\ngoal (1 subgoal):\n 1. (A, X) \\<in> Q_J_neg", "moreover"], ["proof (state)\nthis:\n  (A, X) \\<in> Qn - Q_I_neg\n\ngoal (1 subgoal):\n 1. (A, X) \\<in> Q_J_neg", "have \"card (A \\<inter> J) \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> card (A \\<inter> J)", "by (metis (no_types, lifting) False Int_greatest One_nat_def Set.is_empty_def Suc_leI\n              Suc_le_lessD \\<open>(A, X) \\<in> Qn\\<close> assms(1) assms(17) assms(2) assms(4) card_gt_0_iff case_prodD\n              finite_Int included_def rwf_query_def sup_ge2 sup_inf_absorb sup_inf_distrib1)"], ["proof (state)\nthis:\n  1 \\<le> card (A \\<inter> J)\n\ngoal (1 subgoal):\n 1. (A, X) \\<in> Q_J_neg", "then"], ["proof (chain)\npicking this:\n  1 \\<le> card (A \\<inter> J)", "show ?thesis"], ["proof (prove)\nusing this:\n  1 \\<le> card (A \\<inter> J)\n\ngoal (1 subgoal):\n 1. (A, X) \\<in> Q_J_neg", "using assms(8) calculation"], ["proof (prove)\nusing this:\n  1 \\<le> card (A \\<inter> J)\n  Q_J_neg = filterQuery J (Qn - Q_I_neg)\n  (A, X) \\<in> Qn - Q_I_neg\n\ngoal (1 subgoal):\n 1. (A, X) \\<in> Q_J_neg", "by (metis Diff_subset subset_Q_neg assms(17) fst_conv rwf_query_def set_filterQuery)"], ["proof (state)\nthis:\n  (A, X) \\<in> Q_J_neg\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (A, X) \\<in> Q_J_neg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "define AI where \"AI = A \\<inter> I\""], ["proof (state)\nthis:\n  AI = A \\<inter> I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "define AJ where \"AJ = A \\<inter> J\""], ["proof (state)\nthis:\n  AJ = A \\<inter> J\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "then"], ["proof (chain)\npicking this:\n  AJ = A \\<inter> J", "have \"NQ_neg = projectQuery J (Set.image (\\<lambda>tab. semiJoin tab (I, t)) Q_J_neg)\""], ["proof (prove)\nusing this:\n  AJ = A \\<inter> J\n\ngoal (1 subgoal):\n 1. NQ_neg = projectQuery J ((\\<lambda>tab. semiJoin tab (I, t)) ` Q_J_neg)", "by (metis newQuery_equi_dev projectQuery.simps assms(10))"], ["proof (state)\nthis:\n  NQ_neg = projectQuery J ((\\<lambda>tab. semiJoin tab (I, t)) ` Q_J_neg)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "then"], ["proof (chain)\npicking this:\n  NQ_neg = projectQuery J ((\\<lambda>tab. semiJoin tab (I, t)) ` Q_J_neg)", "obtain XX where \"(A, XX) = (\\<lambda>tab. semiJoin tab (I, t)) (A, X)\""], ["proof (prove)\nusing this:\n  NQ_neg = projectQuery J ((\\<lambda>tab. semiJoin tab (I, t)) ` Q_J_neg)\n\ngoal (1 subgoal):\n 1. (\\<And>XX.\n        (A, XX) = semiJoin (A, X) (I, t) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  (A, XX) = semiJoin (A, X) (I, t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "then"], ["proof (chain)\npicking this:\n  (A, XX) = semiJoin (A, X) (I, t)", "obtain XXX where \"(AJ, XXX) \\<in> NQ_neg\" and \"(AJ, XXX) = projectTable J (A, XX)\""], ["proof (prove)\nusing this:\n  (A, XX) = semiJoin (A, X) (I, t)\n\ngoal (1 subgoal):\n 1. (\\<And>XXX.\n        \\<lbrakk>(AJ, XXX) \\<in> NQ_neg;\n         (AJ, XXX) = projectTable J (A, XX)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis AJ_def newQuery.simps projectTable.simps \\<open>(A, X) \\<in> Q_J_neg\\<close> assms(10) image_eqI)"], ["proof (state)\nthis:\n  (AJ, XXX) \\<in> NQ_neg\n  (AJ, XXX) = projectTable J (A, XX)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "then"], ["proof (chain)\npicking this:\n  (AJ, XXX) \\<in> NQ_neg\n  (AJ, XXX) = projectTable J (A, XX)", "have \"restrict AJ xx \\<notin> XXX\""], ["proof (prove)\nusing this:\n  (AJ, XXX) \\<in> NQ_neg\n  (AJ, XXX) = projectTable J (A, XX)\n\ngoal (1 subgoal):\n 1. restrict AJ xx \\<notin> XXX", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(AJ, XXX) \\<in> NQ_neg;\n     (AJ, XXX) = projectTable J (A, XX)\\<rbrakk>\n    \\<Longrightarrow> restrict AJ xx \\<notin> XXX", "have \"xx \\<in> R_NQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xx \\<in> R_NQ", "by (simp add: assms(16))"], ["proof (state)\nthis:\n  xx \\<in> R_NQ\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(AJ, XXX) \\<in> NQ_neg;\n     (AJ, XXX) = projectTable J (A, XX)\\<rbrakk>\n    \\<Longrightarrow> restrict AJ xx \\<notin> XXX", "then"], ["proof (chain)\npicking this:\n  xx \\<in> R_NQ", "have \"wf_tuple n J xx \\<and> (\\<forall>(A, X)\\<in>NQ_pos. restrict A xx \\<in> X) \\<and> (\\<forall>(A, X)\\<in>NQ_neg. restrict A xx \\<notin> X)\""], ["proof (prove)\nusing this:\n  xx \\<in> R_NQ\n\ngoal (1 subgoal):\n 1. wf_tuple n J xx \\<and>\n    (\\<forall>(A, X)\\<in>NQ_pos. restrict A xx \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>NQ_neg. restrict A xx \\<notin> X)", "by (simp add: assms(13))"], ["proof (state)\nthis:\n  wf_tuple n J xx \\<and>\n  (\\<forall>(A, X)\\<in>NQ_pos. restrict A xx \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>NQ_neg. restrict A xx \\<notin> X)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(AJ, XXX) \\<in> NQ_neg;\n     (AJ, XXX) = projectTable J (A, XX)\\<rbrakk>\n    \\<Longrightarrow> restrict AJ xx \\<notin> XXX", "then"], ["proof (chain)\npicking this:\n  wf_tuple n J xx \\<and>\n  (\\<forall>(A, X)\\<in>NQ_pos. restrict A xx \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>NQ_neg. restrict A xx \\<notin> X)", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_tuple n J xx \\<and>\n  (\\<forall>(A, X)\\<in>NQ_pos. restrict A xx \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>NQ_neg. restrict A xx \\<notin> X)\n\ngoal (1 subgoal):\n 1. restrict AJ xx \\<notin> XXX", "using \\<open>(AJ, XXX) \\<in> NQ_neg\\<close>"], ["proof (prove)\nusing this:\n  wf_tuple n J xx \\<and>\n  (\\<forall>(A, X)\\<in>NQ_pos. restrict A xx \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>NQ_neg. restrict A xx \\<notin> X)\n  (AJ, XXX) \\<in> NQ_neg\n\ngoal (1 subgoal):\n 1. restrict AJ xx \\<notin> XXX", "by blast"], ["proof (state)\nthis:\n  restrict AJ xx \\<notin> XXX\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict AJ xx \\<notin> XXX\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "define zA where \"zA = restrict A z\""], ["proof (state)\nthis:\n  zA = restrict A z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "have \"zA \\<notin> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zA \\<notin> X", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> zA \\<notin> X \\<Longrightarrow> False", "assume \"\\<not> (zA \\<notin> X)\""], ["proof (state)\nthis:\n  \\<not> zA \\<notin> X\n\ngoal (1 subgoal):\n 1. \\<not> zA \\<notin> X \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> zA \\<notin> X", "have \"zA \\<in> X\""], ["proof (prove)\nusing this:\n  \\<not> zA \\<notin> X\n\ngoal (1 subgoal):\n 1. zA \\<in> X", "by simp"], ["proof (state)\nthis:\n  zA \\<in> X\n\ngoal (1 subgoal):\n 1. \\<not> zA \\<notin> X \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  zA \\<in> X\n\ngoal (1 subgoal):\n 1. \\<not> zA \\<notin> X \\<Longrightarrow> False", "have \"restrict (A \\<inter> I) zA = restrict (A \\<inter> I) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zA = restrict (A \\<inter> I) t", "by (metis nested_include_restrict \\<open>restrict I z = t\\<close> inf_le1 inf_le2 zA_def)"], ["proof (state)\nthis:\n  restrict (A \\<inter> I) zA = restrict (A \\<inter> I) t\n\ngoal (1 subgoal):\n 1. \\<not> zA \\<notin> X \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  restrict (A \\<inter> I) zA = restrict (A \\<inter> I) t", "have \"isSameIntersection t (A \\<inter> I) zA\""], ["proof (prove)\nusing this:\n  restrict (A \\<inter> I) zA = restrict (A \\<inter> I) t\n\ngoal (1 subgoal):\n 1. isSameIntersection t (A \\<inter> I) zA", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zA = restrict (A \\<inter> I) t \\<Longrightarrow>\n    isSameIntersection t (A \\<inter> I) zA", "have \"wf_set n V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_set n V", "using assms(17) rwf_query_def wf_query_def"], ["proof (prove)\nusing this:\n  rwf_query n V Q Qn\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n  wf_query ?n ?V ?Q_pos ?Q_neg =\n  ((\\<forall>X\\<in>?Q_pos \\<union> ?Q_neg. wf_atable ?n X) \\<and>\n   wf_set ?n ?V \\<and> 1 \\<le> card ?Q_pos)\n\ngoal (1 subgoal):\n 1. wf_set n V", "by blast"], ["proof (state)\nthis:\n  wf_set n V\n\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zA = restrict (A \\<inter> I) t \\<Longrightarrow>\n    isSameIntersection t (A \\<inter> I) zA", "moreover"], ["proof (state)\nthis:\n  wf_set n V\n\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zA = restrict (A \\<inter> I) t \\<Longrightarrow>\n    isSameIntersection t (A \\<inter> I) zA", "obtain \"A \\<inter> I \\<subseteq> A\" \"A \\<inter> I \\<subseteq> I\" \"I \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>A \\<inter> I \\<subseteq> A; A \\<inter> I \\<subseteq> I;\n      I \\<subseteq> V\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1)"], ["proof (prove)\nusing this:\n  V = I \\<union> J\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>A \\<inter> I \\<subseteq> A; A \\<inter> I \\<subseteq> I;\n      I \\<subseteq> V\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  A \\<inter> I \\<subseteq> A\n  A \\<inter> I \\<subseteq> I\n  I \\<subseteq> V\n\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zA = restrict (A \\<inter> I) t \\<Longrightarrow>\n    isSameIntersection t (A \\<inter> I) zA", "moreover"], ["proof (state)\nthis:\n  A \\<inter> I \\<subseteq> A\n  A \\<inter> I \\<subseteq> I\n  I \\<subseteq> V\n\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zA = restrict (A \\<inter> I) t \\<Longrightarrow>\n    isSameIntersection t (A \\<inter> I) zA", "have \"A \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> V", "using \\<open>(A, X) \\<in> Qn\\<close> assms(17) included_def rwf_query_def"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Qn\n  rwf_query n V Q Qn\n  included ?V ?Q = (\\<forall>(S, X)\\<in>?Q. S \\<subseteq> ?V)\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n\ngoal (1 subgoal):\n 1. A \\<subseteq> V", "by fastforce"], ["proof (state)\nthis:\n  A \\<subseteq> V\n\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zA = restrict (A \\<inter> I) t \\<Longrightarrow>\n    isSameIntersection t (A \\<inter> I) zA", "moreover"], ["proof (state)\nthis:\n  A \\<subseteq> V\n\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zA = restrict (A \\<inter> I) t \\<Longrightarrow>\n    isSameIntersection t (A \\<inter> I) zA", "have \"wf_tuple n A zA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple n A zA", "using \\<open>wf_tuple n V z\\<close> calculation(5) wf_tuple_restrict_simple zA_def"], ["proof (prove)\nusing this:\n  wf_tuple n V z\n  A \\<subseteq> V\n  \\<lbrakk>wf_tuple ?n ?B ?v; ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> wf_tuple ?n ?A (restrict ?A ?v)\n  zA = restrict A z\n\ngoal (1 subgoal):\n 1. wf_tuple n A zA", "by blast"], ["proof (state)\nthis:\n  wf_tuple n A zA\n\ngoal (1 subgoal):\n 1. restrict (A \\<inter> I) zA = restrict (A \\<inter> I) t \\<Longrightarrow>\n    isSameIntersection t (A \\<inter> I) zA", "then"], ["proof (chain)\npicking this:\n  wf_tuple n A zA", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_tuple n A zA\n\ngoal (1 subgoal):\n 1. isSameIntersection t (A \\<inter> I) zA", "using isSame_equi_dev[of n V A zA I t \"A \\<inter> I\"]"], ["proof (prove)\nusing this:\n  wf_tuple n A zA\n  \\<lbrakk>wf_set n V; wf_tuple n A zA; wf_tuple n I t;\n   A \\<inter> I \\<subseteq> A; A \\<inter> I \\<subseteq> I; A \\<subseteq> V;\n   I \\<subseteq> V\\<rbrakk>\n  \\<Longrightarrow> isSameIntersection zA (A \\<inter> I) t =\n                    (restrict (A \\<inter> I) zA = restrict (A \\<inter> I) t)\n\ngoal (1 subgoal):\n 1. isSameIntersection t (A \\<inter> I) zA", "by (simp add: \\<open>restrict (A \\<inter> I) zA = restrict (A \\<inter> I) t\\<close> \\<open>wf_tuple n I t\\<close> calculation(1) calculation(4) calculation(5))"], ["proof (state)\nthis:\n  isSameIntersection t (A \\<inter> I) zA\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  isSameIntersection t (A \\<inter> I) zA\n\ngoal (1 subgoal):\n 1. \\<not> zA \\<notin> X \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  isSameIntersection t (A \\<inter> I) zA", "have \"zA \\<in> XX\""], ["proof (prove)\nusing this:\n  isSameIntersection t (A \\<inter> I) zA\n\ngoal (1 subgoal):\n 1. zA \\<in> XX", "using \\<open>(A, XX) = semiJoin (A, X) (I, t)\\<close> calculation"], ["proof (prove)\nusing this:\n  isSameIntersection t (A \\<inter> I) zA\n  (A, XX) = semiJoin (A, X) (I, t)\n  zA \\<in> X\n\ngoal (1 subgoal):\n 1. zA \\<in> XX", "by auto"], ["proof (state)\nthis:\n  zA \\<in> XX\n\ngoal (1 subgoal):\n 1. \\<not> zA \\<notin> X \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  zA \\<in> XX", "have \"restrict J zA \\<in> XXX\""], ["proof (prove)\nusing this:\n  zA \\<in> XX\n\ngoal (1 subgoal):\n 1. restrict J zA \\<in> XXX", "using \\<open>(AJ, XXX) = projectTable J (A, XX)\\<close>"], ["proof (prove)\nusing this:\n  zA \\<in> XX\n  (AJ, XXX) = projectTable J (A, XX)\n\ngoal (1 subgoal):\n 1. restrict J zA \\<in> XXX", "by auto"], ["proof (state)\nthis:\n  restrict J zA \\<in> XXX\n\ngoal (1 subgoal):\n 1. \\<not> zA \\<notin> X \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  restrict J zA \\<in> XXX\n\ngoal (1 subgoal):\n 1. \\<not> zA \\<notin> X \\<Longrightarrow> False", "have \"restrict AJ xx = restrict J zA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict AJ xx = restrict J zA", "by (metis AJ_def restrict_nested \\<open>restrict J z = xx\\<close> inf.right_idem inf_commute zA_def)"], ["proof (state)\nthis:\n  restrict AJ xx = restrict J zA\n\ngoal (1 subgoal):\n 1. \\<not> zA \\<notin> X \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  restrict AJ xx = restrict J zA", "show \"False\""], ["proof (prove)\nusing this:\n  restrict AJ xx = restrict J zA\n\ngoal (1 subgoal):\n 1. False", "using \\<open>restrict AJ xx \\<notin> XXX\\<close> calculation(2)"], ["proof (prove)\nusing this:\n  restrict AJ xx = restrict J zA\n  restrict AJ xx \\<notin> XXX\n  restrict J zA \\<in> XXX\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  zA \\<notin> X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "then"], ["proof (chain)\npicking this:\n  zA \\<notin> X", "show ?thesis"], ["proof (prove)\nusing this:\n  zA \\<notin> X\n\ngoal (1 subgoal):\n 1. restrict A z \\<notin> X", "using zA_def"], ["proof (prove)\nusing this:\n  zA \\<notin> X\n  zA = restrict A z\n\ngoal (1 subgoal):\n 1. restrict A z \\<notin> X", "by auto"], ["proof (state)\nthis:\n  restrict A z \\<notin> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict A z \\<notin> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?A, ?X) \\<in> Qn \\<Longrightarrow> restrict ?A z \\<notin> ?X\n\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)", "moreover"], ["proof (state)\nthis:\n  (?A, ?X) \\<in> Qn \\<Longrightarrow> restrict ?A z \\<notin> ?X\n\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)", "have \"\\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X", "fix A X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X", "assume \"(A, X) \\<in> Q\""], ["proof (state)\nthis:\n  (A, X) \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X", "have \"restrict I (merge xx t) = restrict I t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict I (merge xx t) = restrict I t", "by (metis (no_types, lifting) Set.is_empty_def \\<open>\\<And>thesis. (\\<lbrakk>wf_tuple n I t; wf_tuple n J xx\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\\<close>\n          assms(2) merge_restrict restrict_idle sup.cobounded1 wf_tuple_def)"], ["proof (state)\nthis:\n  restrict I (merge xx t) = restrict I t\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X", "moreover"], ["proof (state)\nthis:\n  restrict I (merge xx t) = restrict I t\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X", "have \"restrict J (merge xx t) = restrict J xx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict J (merge xx t) = restrict J xx", "by (metis Set.is_empty_def \\<open>\\<And>thesis. (\\<lbrakk>wf_tuple n I t; wf_tuple n J xx\\<rbrakk> \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\\<close>\n          assms(2) inf_commute real_restrict_merge)"], ["proof (state)\nthis:\n  restrict J (merge xx t) = restrict J xx\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X", "moreover"], ["proof (state)\nthis:\n  restrict J (merge xx t) = restrict J xx\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X", "have \"restrict J xx = xx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict J xx = xx", "using \\<open>wf_tuple n J xx\\<close> restrict_idle"], ["proof (prove)\nusing this:\n  wf_tuple n J xx\n  wf_tuple ?n ?A ?v \\<Longrightarrow> restrict ?A ?v = ?v\n\ngoal (1 subgoal):\n 1. restrict J xx = xx", "by auto"], ["proof (state)\nthis:\n  restrict J xx = xx\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X", "moreover"], ["proof (state)\nthis:\n  restrict J xx = xx\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X", "have \"restrict I t = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict I t = t", "using \\<open>wf_tuple n I t\\<close> restrict_idle"], ["proof (prove)\nusing this:\n  wf_tuple n I t\n  wf_tuple ?n ?A ?v \\<Longrightarrow> restrict ?A ?v = ?v\n\ngoal (1 subgoal):\n 1. restrict I t = t", "by auto"], ["proof (state)\nthis:\n  restrict I t = t\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  restrict I t = t", "obtain \"restrict I z = t\" \"restrict J z = xx\""], ["proof (prove)\nusing this:\n  restrict I t = t\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>restrict I z = t; restrict J z = xx\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(14) calculation(1) calculation(2) calculation(3)"], ["proof (prove)\nusing this:\n  restrict I t = t\n  z = merge xx t\n  restrict I (merge xx t) = restrict I t\n  restrict J (merge xx t) = restrict J xx\n  restrict J xx = xx\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>restrict I z = t; restrict J z = xx\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  restrict I z = t\n  restrict J z = xx\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X", "moreover"], ["proof (state)\nthis:\n  restrict I z = t\n  restrict J z = xx\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X", "have \"\\<forall>(A, X)\\<in>Q_I_pos. restrict A t \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(A, X)\\<in>Q_I_pos. restrict A t \\<in> X", "using assms(12) assms(15)"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     (x \\<in> R_I) =\n     (wf_tuple n I x \\<and>\n      (\\<forall>(A, X)\\<in>Q_I_pos. restrict A x \\<in> X) \\<and>\n      (\\<forall>(A, X)\\<in>Q_I_neg. restrict A x \\<notin> X))\n  t \\<in> R_I\n\ngoal (1 subgoal):\n 1. \\<forall>(A, X)\\<in>Q_I_pos. restrict A t \\<in> X", "by blast"], ["proof (state)\nthis:\n  \\<forall>(A, X)\\<in>Q_I_pos. restrict A t \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X", "moreover"], ["proof (state)\nthis:\n  \\<forall>(A, X)\\<in>Q_I_pos. restrict A t \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X", "have \"\\<forall>(A, X)\\<in>NQ_pos. restrict A xx \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(A, X)\\<in>NQ_pos. restrict A xx \\<in> X", "using assms(13) assms(16)"], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y \\<in> R_NQ) =\n     (wf_tuple n J y \\<and>\n      (\\<forall>(A, X)\\<in>NQ_pos. restrict A y \\<in> X) \\<and>\n      (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X))\n  xx \\<in> R_NQ\n\ngoal (1 subgoal):\n 1. \\<forall>(A, X)\\<in>NQ_pos. restrict A xx \\<in> X", "by blast"], ["proof (state)\nthis:\n  \\<forall>(A, X)\\<in>NQ_pos. restrict A xx \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X", "moreover"], ["proof (state)\nthis:\n  \\<forall>(A, X)\\<in>NQ_pos. restrict A xx \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X", "have \"card A \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> card A", "using \\<open>(A, X) \\<in> Q\\<close> assms(17) non_empty_query_def rwf_query_def"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q\n  rwf_query n V Q Qn\n  non_empty_query ?Q = (\\<forall>X\\<in>?Q. 1 \\<le> card (fst X))\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n\ngoal (1 subgoal):\n 1. 1 \\<le> card A", "by fastforce"], ["proof (state)\nthis:\n  1 \\<le> card A\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  1 \\<le> card A", "show \"restrict A z \\<in> X\""], ["proof (prove)\nusing this:\n  1 \\<le> card A\n\ngoal (1 subgoal):\n 1. restrict A z \\<in> X", "proof (cases \"A \\<subseteq> I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card A; A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "case True"], ["proof (state)\nthis:\n  A \\<subseteq> I\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card A; A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "have \"(A, X) \\<in> filterQuery I Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A, X) \\<in> filterQuery I Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (A, X) \\<in> filterQuery I Q", "have \"A \\<inter> I = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<inter> I = A", "using True"], ["proof (prove)\nusing this:\n  A \\<subseteq> I\n\ngoal (1 subgoal):\n 1. A \\<inter> I = A", "by auto"], ["proof (state)\nthis:\n  A \\<inter> I = A\n\ngoal (1 subgoal):\n 1. (A, X) \\<in> filterQuery I Q", "then"], ["proof (chain)\npicking this:\n  A \\<inter> I = A", "have \"A \\<inter> I \\<noteq> {}\""], ["proof (prove)\nusing this:\n  A \\<inter> I = A\n\ngoal (1 subgoal):\n 1. A \\<inter> I \\<noteq> {}", "using \\<open>1 \\<le> card A\\<close>"], ["proof (prove)\nusing this:\n  A \\<inter> I = A\n  1 \\<le> card A\n\ngoal (1 subgoal):\n 1. A \\<inter> I \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  A \\<inter> I \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (A, X) \\<in> filterQuery I Q", "then"], ["proof (chain)\npicking this:\n  A \\<inter> I \\<noteq> {}", "have \"(\\<lambda>(s, _). s \\<inter> V \\<noteq> {}) (A, X)\""], ["proof (prove)\nusing this:\n  A \\<inter> I \\<noteq> {}\n\ngoal (1 subgoal):\n 1. case (A, X) of (s, uu_) \\<Rightarrow> s \\<inter> V \\<noteq> {}", "using assms(1)"], ["proof (prove)\nusing this:\n  A \\<inter> I \\<noteq> {}\n  V = I \\<union> J\n\ngoal (1 subgoal):\n 1. case (A, X) of (s, uu_) \\<Rightarrow> s \\<inter> V \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  case (A, X) of (s, uu_) \\<Rightarrow> s \\<inter> V \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (A, X) \\<in> filterQuery I Q", "then"], ["proof (chain)\npicking this:\n  case (A, X) of (s, uu_) \\<Rightarrow> s \\<inter> V \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  case (A, X) of (s, uu_) \\<Rightarrow> s \\<inter> V \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (A, X) \\<in> filterQuery I Q", "by (metis \\<open>(A, X) \\<in> Q\\<close> \\<open>1 \\<le> card A\\<close> \\<open>A \\<inter> I = A\\<close> assms(17) fst_conv rwf_query_def set_filterQuery)"], ["proof (state)\nthis:\n  (A, X) \\<in> filterQuery I Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (A, X) \\<in> filterQuery I Q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card A; A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "have \"table n A X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. table n A X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. table n A X", "have \"wf_query n V Q Qn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_query n V Q Qn", "using assms(17) rwf_query_def"], ["proof (prove)\nusing this:\n  rwf_query n V Q Qn\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n\ngoal (1 subgoal):\n 1. wf_query n V Q Qn", "by blast"], ["proof (state)\nthis:\n  wf_query n V Q Qn\n\ngoal (1 subgoal):\n 1. table n A X", "moreover"], ["proof (state)\nthis:\n  wf_query n V Q Qn\n\ngoal (1 subgoal):\n 1. table n A X", "have \"(A, X) \\<in> (Q \\<union> Qn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A, X) \\<in> Q \\<union> Qn", "by (simp add: \\<open>(A, X) \\<in> Q\\<close>)"], ["proof (state)\nthis:\n  (A, X) \\<in> Q \\<union> Qn\n\ngoal (1 subgoal):\n 1. table n A X", "then"], ["proof (chain)\npicking this:\n  (A, X) \\<in> Q \\<union> Qn", "show ?thesis"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q \\<union> Qn\n\ngoal (1 subgoal):\n 1. table n A X", "by (metis calculation fst_conv snd_conv wf_atable_def wf_query_def)"], ["proof (state)\nthis:\n  table n A X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  table n A X\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card A; A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "moreover"], ["proof (state)\nthis:\n  table n A X\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card A; A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "have \"projectTable I (A, X) = (A, X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. projectTable I (A, X) = (A, X)", "using True calculation projectTable_idle"], ["proof (prove)\nusing this:\n  A \\<subseteq> I\n  table n A X\n  \\<lbrakk>table ?n ?A ?X; ?A \\<subseteq> ?I\\<rbrakk>\n  \\<Longrightarrow> projectTable ?I (?A, ?X) = (?A, ?X)\n\ngoal (1 subgoal):\n 1. projectTable I (A, X) = (A, X)", "by blast"], ["proof (state)\nthis:\n  projectTable I (A, X) = (A, X)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card A; A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  projectTable I (A, X) = (A, X)", "have \"(A, X) \\<in> Q_I_pos\""], ["proof (prove)\nusing this:\n  projectTable I (A, X) = (A, X)\n\ngoal (1 subgoal):\n 1. (A, X) \\<in> Q_I_pos", "by (metis \\<open>(A, X) \\<in> filterQuery I Q\\<close> assms(5) image_eqI projectQuery.elims)"], ["proof (state)\nthis:\n  (A, X) \\<in> Q_I_pos\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card A; A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  (A, X) \\<in> Q_I_pos", "have \"restrict A t \\<in> X\""], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q_I_pos\n\ngoal (1 subgoal):\n 1. restrict A t \\<in> X", "using \\<open>\\<forall>(A, X)\\<in>Q_I_pos. restrict A t \\<in> X\\<close>"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q_I_pos\n  \\<forall>(A, X)\\<in>Q_I_pos. restrict A t \\<in> X\n\ngoal (1 subgoal):\n 1. restrict A t \\<in> X", "by blast"], ["proof (state)\nthis:\n  restrict A t \\<in> X\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card A; A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "moreover"], ["proof (state)\nthis:\n  restrict A t \\<in> X\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card A; A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "have \"restrict A z = restrict A t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict A z = restrict A t", "using True \\<open>restrict I z = t\\<close> nested_include_restrict"], ["proof (prove)\nusing this:\n  A \\<subseteq> I\n  restrict I z = t\n  \\<lbrakk>restrict ?I ?z = ?t; ?A \\<subseteq> ?I\\<rbrakk>\n  \\<Longrightarrow> restrict ?A ?z = restrict ?A ?t\n\ngoal (1 subgoal):\n 1. restrict A z = restrict A t", "by blast"], ["proof (state)\nthis:\n  restrict A z = restrict A t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card A; A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  restrict A z = restrict A t", "show ?thesis"], ["proof (prove)\nusing this:\n  restrict A z = restrict A t\n\ngoal (1 subgoal):\n 1. restrict A z \\<in> X", "by (simp add: calculation(2))"], ["proof (state)\nthis:\n  restrict A z \\<in> X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "case False"], ["proof (state)\nthis:\n  \\<not> A \\<subseteq> I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "have \"A \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<subseteq> V", "have \"included V Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. included V Q", "using assms(17) rwf_query_def"], ["proof (prove)\nusing this:\n  rwf_query n V Q Qn\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n\ngoal (1 subgoal):\n 1. included V Q", "by blast"], ["proof (state)\nthis:\n  included V Q\n\ngoal (1 subgoal):\n 1. A \\<subseteq> V", "then"], ["proof (chain)\npicking this:\n  included V Q", "show ?thesis"], ["proof (prove)\nusing this:\n  included V Q\n\ngoal (1 subgoal):\n 1. A \\<subseteq> V", "using \\<open>(A, X) \\<in> Q\\<close> included_def"], ["proof (prove)\nusing this:\n  included V Q\n  (A, X) \\<in> Q\n  included ?V ?Q = (\\<forall>(S, X)\\<in>?Q. S \\<subseteq> ?V)\n\ngoal (1 subgoal):\n 1. A \\<subseteq> V", "by fastforce"], ["proof (state)\nthis:\n  A \\<subseteq> V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  A \\<subseteq> V", "have \"card (A \\<inter> J) \\<ge> 1\""], ["proof (prove)\nusing this:\n  A \\<subseteq> V\n\ngoal (1 subgoal):\n 1. 1 \\<le> card (A \\<inter> J)", "by (metis False One_nat_def Suc_leI Suc_le_lessD UnE assms(1) \n            assms(4) card_gt_0_iff disjoint_iff_not_equal finite_Int subsetD subsetI)"], ["proof (state)\nthis:\n  1 \\<le> card (A \\<inter> J)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card A; \\<not> A \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  1 \\<le> card (A \\<inter> J)", "show ?thesis"], ["proof (prove)\nusing this:\n  1 \\<le> card (A \\<inter> J)\n\ngoal (1 subgoal):\n 1. restrict A z \\<in> X", "proof (cases \"card (A \\<inter> I) \\<ge> 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "case True"], ["proof (state)\nthis:\n  1 \\<le> card (A \\<inter> I)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "define zI where \"zI = restrict I z\""], ["proof (state)\nthis:\n  zI = restrict I z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "define zJ where \"zJ = restrict J z\""], ["proof (state)\nthis:\n  zJ = restrict J z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "obtain \"zI = t\" \"zJ = xx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>zI = t; zJ = xx\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: calculation(4) calculation(5) zI_def zJ_def)"], ["proof (state)\nthis:\n  zI = t\n  zJ = xx\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  zI = t\n  zJ = xx", "have \"wf_tuple n I zI \\<and> (\\<forall>(A, X)\\<in>Q_I_pos. restrict A zI \\<in> X)\""], ["proof (prove)\nusing this:\n  zI = t\n  zJ = xx\n\ngoal (1 subgoal):\n 1. wf_tuple n I zI \\<and>\n    (\\<forall>(A, X)\\<in>Q_I_pos. restrict A zI \\<in> X)", "using \\<open>wf_tuple n I t\\<close> calculation(6)"], ["proof (prove)\nusing this:\n  zI = t\n  zJ = xx\n  wf_tuple n I t\n  \\<forall>(A, X)\\<in>Q_I_pos. restrict A t \\<in> X\n\ngoal (1 subgoal):\n 1. wf_tuple n I zI \\<and>\n    (\\<forall>(A, X)\\<in>Q_I_pos. restrict A zI \\<in> X)", "by blast"], ["proof (state)\nthis:\n  wf_tuple n I zI \\<and>\n  (\\<forall>(A, X)\\<in>Q_I_pos. restrict A zI \\<in> X)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "moreover"], ["proof (state)\nthis:\n  wf_tuple n I zI \\<and>\n  (\\<forall>(A, X)\\<in>Q_I_pos. restrict A zI \\<in> X)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "have \"wf_tuple n J zJ \\<and> (\\<forall>(A, X)\\<in>NQ_pos. restrict A zJ \\<in> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple n J zJ \\<and>\n    (\\<forall>(A, X)\\<in>NQ_pos. restrict A zJ \\<in> X)", "using \\<open>\\<forall>(A, X)\\<in>NQ_pos. restrict A xx \\<in> X\\<close> \\<open>wf_tuple n J xx\\<close> \\<open>zJ = xx\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>(A, X)\\<in>NQ_pos. restrict A xx \\<in> X\n  wf_tuple n J xx\n  zJ = xx\n\ngoal (1 subgoal):\n 1. wf_tuple n J zJ \\<and>\n    (\\<forall>(A, X)\\<in>NQ_pos. restrict A zJ \\<in> X)", "by blast"], ["proof (state)\nthis:\n  wf_tuple n J zJ \\<and> (\\<forall>(A, X)\\<in>NQ_pos. restrict A zJ \\<in> X)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "obtain \"(A, X) \\<in> (filterQuery I Q)\" \"(A, X) \\<in> Q_J_pos\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>(A, X) \\<in> filterQuery I Q; (A, X) \\<in> Q_J_pos\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using True \\<open>(A, X) \\<in> Q\\<close> \\<open>1 \\<le> card (A \\<inter> J)\\<close> assms(6) assms(17) rwf_query_def set_filterQuery"], ["proof (prove)\nusing this:\n  1 \\<le> card (A \\<inter> I)\n  (A, X) \\<in> Q\n  1 \\<le> card (A \\<inter> J)\n  Q_J_pos = filterQuery J Q\n  rwf_query n V Q Qn\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n  \\<lbrakk>?QQ = filterQuery ?I ?Q; non_empty_query ?Q\\<rbrakk>\n  \\<Longrightarrow> \\<forall>X\\<in>?Q.\n                       (1 \\<le> card (fst X \\<inter> ?I)) = (X \\<in> ?QQ)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>(A, X) \\<in> filterQuery I Q; (A, X) \\<in> Q_J_pos\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  (A, X) \\<in> filterQuery I Q\n  (A, X) \\<in> Q_J_pos\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "define AI where \"AI = A\\<inter>I\""], ["proof (state)\nthis:\n  AI = A \\<inter> I\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "define XI where \"XI = Set.image (restrict I) X\""], ["proof (state)\nthis:\n  XI = restrict I ` X\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  XI = restrict I ` X", "have \"(AI, XI) = projectTable I (A, X)\""], ["proof (prove)\nusing this:\n  XI = restrict I ` X\n\ngoal (1 subgoal):\n 1. (AI, XI) = projectTable I (A, X)", "using AI_def XI_def"], ["proof (prove)\nusing this:\n  XI = restrict I ` X\n  AI = A \\<inter> I\n  XI = restrict I ` X\n\ngoal (1 subgoal):\n 1. (AI, XI) = projectTable I (A, X)", "by simp"], ["proof (state)\nthis:\n  (AI, XI) = projectTable I (A, X)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  (AI, XI) = projectTable I (A, X)", "have \"(AI, XI) \\<in> Q_I_pos\""], ["proof (prove)\nusing this:\n  (AI, XI) = projectTable I (A, X)\n\ngoal (1 subgoal):\n 1. (AI, XI) \\<in> Q_I_pos", "by (metis \\<open>(A, X) \\<in> filterQuery I Q\\<close> assms(5) image_eqI projectQuery.elims)"], ["proof (state)\nthis:\n  (AI, XI) \\<in> Q_I_pos\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  (AI, XI) \\<in> Q_I_pos", "have \"restrict AI zI \\<in> XI\""], ["proof (prove)\nusing this:\n  (AI, XI) \\<in> Q_I_pos\n\ngoal (1 subgoal):\n 1. restrict AI zI \\<in> XI", "using \\<open>wf_tuple n I zI \\<and> (\\<forall>(A, X)\\<in>Q_I_pos. restrict A zI \\<in> X)\\<close>"], ["proof (prove)\nusing this:\n  (AI, XI) \\<in> Q_I_pos\n  wf_tuple n I zI \\<and>\n  (\\<forall>(A, X)\\<in>Q_I_pos. restrict A zI \\<in> X)\n\ngoal (1 subgoal):\n 1. restrict AI zI \\<in> XI", "by blast"], ["proof (state)\nthis:\n  restrict AI zI \\<in> XI\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "obtain AJ XJ where \"(AJ, XJ) = projectTable J (semiJoin (A, X) (I, zI))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>AJ XJ.\n        (AJ, XJ) =\n        projectTable J (semiJoin (A, X) (I, zI)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  (AJ, XJ) = projectTable J (semiJoin (A, X) (I, zI))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  (AJ, XJ) = projectTable J (semiJoin (A, X) (I, zI))", "have \"AJ = A \\<inter> J\""], ["proof (prove)\nusing this:\n  (AJ, XJ) = projectTable J (semiJoin (A, X) (I, zI))\n\ngoal (1 subgoal):\n 1. AJ = A \\<inter> J", "by auto"], ["proof (state)\nthis:\n  AJ = A \\<inter> J\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  AJ = A \\<inter> J", "have \"(AJ, XJ) \\<in> NQ_pos\""], ["proof (prove)\nusing this:\n  AJ = A \\<inter> J\n\ngoal (1 subgoal):\n 1. (AJ, XJ) \\<in> NQ_pos", "using \\<open>(A, X) \\<in> Q_J_pos\\<close> \\<open>(AJ, XJ) = projectTable J (semiJoin (A, X) (I, zI))\\<close> \\<open>zI = t\\<close> image_iff"], ["proof (prove)\nusing this:\n  AJ = A \\<inter> J\n  (A, X) \\<in> Q_J_pos\n  (AJ, XJ) = projectTable J (semiJoin (A, X) (I, zI))\n  zI = t\n  (?z \\<in> ?f ` ?A) = (\\<exists>x\\<in>?A. ?z = ?f x)\n\ngoal (1 subgoal):\n 1. (AJ, XJ) \\<in> NQ_pos", "using assms(9)"], ["proof (prove)\nusing this:\n  AJ = A \\<inter> J\n  (A, X) \\<in> Q_J_pos\n  (AJ, XJ) = projectTable J (semiJoin (A, X) (I, zI))\n  zI = t\n  (?z \\<in> ?f ` ?A) = (\\<exists>x\\<in>?A. ?z = ?f x)\n  NQ_pos = newQuery J Q_J_pos (I, t)\n\ngoal (1 subgoal):\n 1. (AJ, XJ) \\<in> NQ_pos", "by fastforce"], ["proof (state)\nthis:\n  (AJ, XJ) \\<in> NQ_pos\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  (AJ, XJ) \\<in> NQ_pos", "have \"restrict AJ zJ \\<in> XJ\""], ["proof (prove)\nusing this:\n  (AJ, XJ) \\<in> NQ_pos\n\ngoal (1 subgoal):\n 1. restrict AJ zJ \\<in> XJ", "using \\<open>wf_tuple n J zJ \\<and> (\\<forall>(A, X)\\<in>NQ_pos. restrict A zJ \\<in> X)\\<close>"], ["proof (prove)\nusing this:\n  (AJ, XJ) \\<in> NQ_pos\n  wf_tuple n J zJ \\<and> (\\<forall>(A, X)\\<in>NQ_pos. restrict A zJ \\<in> X)\n\ngoal (1 subgoal):\n 1. restrict AJ zJ \\<in> XJ", "by blast"], ["proof (state)\nthis:\n  restrict AJ zJ \\<in> XJ\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "have \"XJ = Set.image (restrict J) (Set.filter (isSameIntersection zI (A \\<inter> I)) X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. XJ = restrict J ` Set.filter (isSameIntersection zI (A \\<inter> I)) X", "using \\<open>(AJ, XJ) = projectTable J (semiJoin (A, X) (I, zI))\\<close>"], ["proof (prove)\nusing this:\n  (AJ, XJ) = projectTable J (semiJoin (A, X) (I, zI))\n\ngoal (1 subgoal):\n 1. XJ = restrict J ` Set.filter (isSameIntersection zI (A \\<inter> I)) X", "by auto"], ["proof (state)\nthis:\n  XJ = restrict J ` Set.filter (isSameIntersection zI (A \\<inter> I)) X\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  XJ = restrict J ` Set.filter (isSameIntersection zI (A \\<inter> I)) X", "have \"restrict AJ zJ \\<in> Set.image (restrict J) (Set.filter (isSameIntersection zI (A \\<inter> I)) X)\""], ["proof (prove)\nusing this:\n  XJ = restrict J ` Set.filter (isSameIntersection zI (A \\<inter> I)) X\n\ngoal (1 subgoal):\n 1. restrict AJ zJ\n    \\<in> restrict J ` Set.filter (isSameIntersection zI (A \\<inter> I)) X", "using \\<open>restrict AJ zJ \\<in> XJ\\<close>"], ["proof (prove)\nusing this:\n  XJ = restrict J ` Set.filter (isSameIntersection zI (A \\<inter> I)) X\n  restrict AJ zJ \\<in> XJ\n\ngoal (1 subgoal):\n 1. restrict AJ zJ\n    \\<in> restrict J ` Set.filter (isSameIntersection zI (A \\<inter> I)) X", "by blast"], ["proof (state)\nthis:\n  restrict AJ zJ\n  \\<in> restrict J ` Set.filter (isSameIntersection zI (A \\<inter> I)) X\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "moreover"], ["proof (state)\nthis:\n  restrict AJ zJ\n  \\<in> restrict J ` Set.filter (isSameIntersection zI (A \\<inter> I)) X\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "have \"table n A X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. table n A X", "using \\<open>(A, X) \\<in> Q\\<close> assms(17) rwf_query_def wf_atable_def wf_query_def"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q\n  rwf_query n V Q Qn\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n  wf_atable ?n ?X = (table ?n (fst ?X) (snd ?X) \\<and> finite (fst ?X))\n  wf_query ?n ?V ?Q_pos ?Q_neg =\n  ((\\<forall>X\\<in>?Q_pos \\<union> ?Q_neg. wf_atable ?n X) \\<and>\n   wf_set ?n ?V \\<and> 1 \\<le> card ?Q_pos)\n\ngoal (1 subgoal):\n 1. table n A X", "by fastforce"], ["proof (state)\nthis:\n  table n A X\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "moreover"], ["proof (state)\nthis:\n  table n A X\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "have \"A \\<subseteq> I \\<union> J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> I \\<union> J", "using \\<open>A \\<subseteq> V\\<close> assms(1)"], ["proof (prove)\nusing this:\n  A \\<subseteq> V\n  V = I \\<union> J\n\ngoal (1 subgoal):\n 1. A \\<subseteq> I \\<union> J", "by auto"], ["proof (state)\nthis:\n  A \\<subseteq> I \\<union> J\n\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X\n 2. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  A \\<subseteq> I \\<union> J", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<subseteq> I \\<union> J\n\ngoal (1 subgoal):\n 1. restrict A z \\<in> X", "using restrict_merge[of zI I z zJ J A X n] AI_def True XI_def \\<open>AJ = A \\<inter> J\\<close>\n            \\<open>restrict AI zI \\<in> XI\\<close> \\<open>restrict I z = t\\<close> \\<open>restrict J z = xx\\<close> \\<open>wf_tuple n V z\\<close> assms(1)\n            assms(14) assms(17) calculation(2) calculation(3) rwf_query_def wf_query_def zI_def zJ_def"], ["proof (prove)\nusing this:\n  A \\<subseteq> I \\<union> J\n  \\<lbrakk>zI = restrict I z; zJ = restrict J z;\n   restrict (A \\<inter> I) zI \\<in> restrict I ` X;\n   restrict (A \\<inter> J) zJ\n   \\<in> restrict J ` Set.filter (isSameIntersection zI (A \\<inter> I)) X;\n   z = merge zJ zI; table n A X; A \\<subseteq> I \\<union> J;\n   1 \\<le> card (A \\<inter> I); wf_set n (I \\<union> J);\n   wf_tuple n (I \\<union> J) z\\<rbrakk>\n  \\<Longrightarrow> restrict A z \\<in> X\n  AI = A \\<inter> I\n  1 \\<le> card (A \\<inter> I)\n  XI = restrict I ` X\n  AJ = A \\<inter> J\n  restrict AI zI \\<in> XI\n  restrict I z = t\n  restrict J z = xx\n  wf_tuple n V z\n  V = I \\<union> J\n  z = merge xx t\n  rwf_query n V Q Qn\n  restrict AJ zJ\n  \\<in> restrict J ` Set.filter (isSameIntersection zI (A \\<inter> I)) X\n  table n A X\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n  wf_query ?n ?V ?Q_pos ?Q_neg =\n  ((\\<forall>X\\<in>?Q_pos \\<union> ?Q_neg. wf_atable ?n X) \\<and>\n   wf_set ?n ?V \\<and> 1 \\<le> card ?Q_pos)\n  zI = restrict I z\n  zJ = restrict J z\n\ngoal (1 subgoal):\n 1. restrict A z \\<in> X", "by blast"], ["proof (state)\nthis:\n  restrict A z \\<in> X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "case False"], ["proof (state)\nthis:\n  \\<not> 1 \\<le> card (A \\<inter> I)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "have \"(A, X) \\<in> Q_J_pos\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A, X) \\<in> Q_J_pos", "using \\<open>(A, X) \\<in> Q\\<close> \\<open>1 \\<le> card (A \\<inter> J)\\<close> assms(6) assms(17)\n            rwf_query_def set_filterQuery"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q\n  1 \\<le> card (A \\<inter> J)\n  Q_J_pos = filterQuery J Q\n  rwf_query n V Q Qn\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n  \\<lbrakk>?QQ = filterQuery ?I ?Q; non_empty_query ?Q\\<rbrakk>\n  \\<Longrightarrow> \\<forall>X\\<in>?Q.\n                       (1 \\<le> card (fst X \\<inter> ?I)) = (X \\<in> ?QQ)\n\ngoal (1 subgoal):\n 1. (A, X) \\<in> Q_J_pos", "by fastforce"], ["proof (state)\nthis:\n  (A, X) \\<in> Q_J_pos\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "moreover"], ["proof (state)\nthis:\n  (A, X) \\<in> Q_J_pos\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "have \"A \\<subseteq> J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> J", "by (metis False One_nat_def Set.is_empty_def Suc_leI Suc_le_lessD \\<open>1 \\<le> card A\\<close> \\<open>A \\<subseteq> V\\<close>\n              assms(1) assms(2) card_gt_0_iff finite_Int inf.absorb_iff2 inf_commute sup_commute sup_inf_absorb sup_inf_distrib1)"], ["proof (state)\nthis:\n  A \\<subseteq> J\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  A \\<subseteq> J", "have \"restrict A z = restrict A xx\""], ["proof (prove)\nusing this:\n  A \\<subseteq> J\n\ngoal (1 subgoal):\n 1. restrict A z = restrict A xx", "using \\<open>restrict J z = xx\\<close> nested_include_restrict"], ["proof (prove)\nusing this:\n  A \\<subseteq> J\n  restrict J z = xx\n  \\<lbrakk>restrict ?I ?z = ?t; ?A \\<subseteq> ?I\\<rbrakk>\n  \\<Longrightarrow> restrict ?A ?z = restrict ?A ?t\n\ngoal (1 subgoal):\n 1. restrict A z = restrict A xx", "by blast"], ["proof (state)\nthis:\n  restrict A z = restrict A xx\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "define zI where \"zI = restrict I z\""], ["proof (state)\nthis:\n  zI = restrict I z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "define zJ where \"zJ = restrict J z\""], ["proof (state)\nthis:\n  zJ = restrict J z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "have \"zJ = xx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zJ = xx", "by (simp add: \\<open>restrict J z = xx\\<close> zJ_def)"], ["proof (state)\nthis:\n  zJ = xx\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "have \"zI = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zI = t", "by (simp add: \\<open>restrict I z = t\\<close> zI_def)"], ["proof (state)\nthis:\n  zI = t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "have \"z = merge zJ zI\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z = merge zJ zI", "by (simp add: \\<open>zI = t\\<close> \\<open>zJ = xx\\<close> assms(14))"], ["proof (state)\nthis:\n  z = merge zJ zI\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "obtain AA XX where \"(AA, XX) = projectTable J (semiJoin (A, X) (I, t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>AA XX.\n        (AA, XX) = projectTable J (semiJoin (A, X) (I, t)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  (AA, XX) = projectTable J (semiJoin (A, X) (I, t))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "have \"AA = A \\<inter> J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AA = A \\<inter> J", "using \\<open>(AA, XX) = projectTable J (semiJoin (A, X) (I, t))\\<close>"], ["proof (prove)\nusing this:\n  (AA, XX) = projectTable J (semiJoin (A, X) (I, t))\n\ngoal (1 subgoal):\n 1. AA = A \\<inter> J", "by auto"], ["proof (state)\nthis:\n  AA = A \\<inter> J\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "have \"(AA, XX) \\<in> NQ_pos\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (AA, XX) \\<in> NQ_pos", "using \\<open>(AA, XX) = projectTable J (semiJoin (A, X) (I, t))\\<close> calculation image_iff assms(9)"], ["proof (prove)\nusing this:\n  (AA, XX) = projectTable J (semiJoin (A, X) (I, t))\n  (A, X) \\<in> Q_J_pos\n  (?z \\<in> ?f ` ?A) = (\\<exists>x\\<in>?A. ?z = ?f x)\n  NQ_pos = newQuery J Q_J_pos (I, t)\n\ngoal (1 subgoal):\n 1. (AA, XX) \\<in> NQ_pos", "by fastforce"], ["proof (state)\nthis:\n  (AA, XX) \\<in> NQ_pos\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  (AA, XX) \\<in> NQ_pos", "have \"restrict AA zJ \\<in> XX\""], ["proof (prove)\nusing this:\n  (AA, XX) \\<in> NQ_pos\n\ngoal (1 subgoal):\n 1. restrict AA zJ \\<in> XX", "using \\<open>(AA, XX) \\<in> NQ_pos\\<close> \\<open>\\<forall>(A, X)\\<in>NQ_pos. restrict A xx \\<in> X\\<close> \\<open>zJ = xx\\<close>"], ["proof (prove)\nusing this:\n  (AA, XX) \\<in> NQ_pos\n  (AA, XX) \\<in> NQ_pos\n  \\<forall>(A, X)\\<in>NQ_pos. restrict A xx \\<in> X\n  zJ = xx\n\ngoal (1 subgoal):\n 1. restrict AA zJ \\<in> XX", "by blast"], ["proof (state)\nthis:\n  restrict AA zJ \\<in> XX\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  restrict AA zJ \\<in> XX", "have \"restrict A z = restrict A zJ\""], ["proof (prove)\nusing this:\n  restrict AA zJ \\<in> XX\n\ngoal (1 subgoal):\n 1. restrict A z = restrict A zJ", "by (simp add: \\<open>restrict A z = restrict A xx\\<close> \\<open>zJ = xx\\<close>)"], ["proof (state)\nthis:\n  restrict A z = restrict A zJ\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "moreover"], ["proof (state)\nthis:\n  restrict A z = restrict A zJ\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "have \"restrict AA zJ = restrict A zJ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict AA zJ = restrict A zJ", "by (simp add: \\<open>A \\<subseteq> J\\<close> \\<open>AA = A \\<inter> J\\<close> inf.absorb1)"], ["proof (state)\nthis:\n  restrict AA zJ = restrict A zJ\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  restrict AA zJ = restrict A zJ", "have \"restrict A z \\<in> XX\""], ["proof (prove)\nusing this:\n  restrict AA zJ = restrict A zJ\n\ngoal (1 subgoal):\n 1. restrict A z \\<in> XX", "using \\<open>restrict AA zJ \\<in> XX\\<close> calculation(2)"], ["proof (prove)\nusing this:\n  restrict AA zJ = restrict A zJ\n  restrict AA zJ \\<in> XX\n  restrict A z = restrict A zJ\n\ngoal (1 subgoal):\n 1. restrict A z \\<in> XX", "by auto"], ["proof (state)\nthis:\n  restrict A z \\<in> XX\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "moreover"], ["proof (state)\nthis:\n  restrict A z \\<in> XX\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "have \"XX \\<subseteq> Set.image (restrict J) X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. XX \\<subseteq> restrict J ` X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. XX \\<subseteq> restrict J ` X", "obtain AAA XXX where \"(AAA, XXX) = semiJoin (A, X) (I, t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>AAA XXX.\n        (AAA, XXX) = semiJoin (A, X) (I, t) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  (AAA, XXX) = semiJoin (A, X) (I, t)\n\ngoal (1 subgoal):\n 1. XX \\<subseteq> restrict J ` X", "then"], ["proof (chain)\npicking this:\n  (AAA, XXX) = semiJoin (A, X) (I, t)", "have \"XXX \\<subseteq> X\""], ["proof (prove)\nusing this:\n  (AAA, XXX) = semiJoin (A, X) (I, t)\n\ngoal (1 subgoal):\n 1. XXX \\<subseteq> X", "by auto"], ["proof (state)\nthis:\n  XXX \\<subseteq> X\n\ngoal (1 subgoal):\n 1. XX \\<subseteq> restrict J ` X", "then"], ["proof (chain)\npicking this:\n  XXX \\<subseteq> X", "have \"XX = Set.image (restrict J) XXX\""], ["proof (prove)\nusing this:\n  XXX \\<subseteq> X\n\ngoal (1 subgoal):\n 1. XX = restrict J ` XXX", "using \\<open>(AA, XX) = projectTable J (semiJoin (A, X) (I, t))\\<close> \\<open>(AAA, XXX) = semiJoin (A, X) (I, t)\\<close>"], ["proof (prove)\nusing this:\n  XXX \\<subseteq> X\n  (AA, XX) = projectTable J (semiJoin (A, X) (I, t))\n  (AAA, XXX) = semiJoin (A, X) (I, t)\n\ngoal (1 subgoal):\n 1. XX = restrict J ` XXX", "by auto"], ["proof (state)\nthis:\n  XX = restrict J ` XXX\n\ngoal (1 subgoal):\n 1. XX \\<subseteq> restrict J ` X", "then"], ["proof (chain)\npicking this:\n  XX = restrict J ` XXX", "show ?thesis"], ["proof (prove)\nusing this:\n  XX = restrict J ` XXX\n\ngoal (1 subgoal):\n 1. XX \\<subseteq> restrict J ` X", "by (simp add: \\<open>XXX \\<subseteq> X\\<close> image_mono)"], ["proof (state)\nthis:\n  XX \\<subseteq> restrict J ` X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  XX \\<subseteq> restrict J ` X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  XX \\<subseteq> restrict J ` X", "have \"restrict A z \\<in> Set.image (restrict J) X\""], ["proof (prove)\nusing this:\n  XX \\<subseteq> restrict J ` X\n\ngoal (1 subgoal):\n 1. restrict A z \\<in> restrict J ` X", "using calculation(3)"], ["proof (prove)\nusing this:\n  XX \\<subseteq> restrict J ` X\n  restrict A z \\<in> XX\n\ngoal (1 subgoal):\n 1. restrict A z \\<in> restrict J ` X", "by blast"], ["proof (state)\nthis:\n  restrict A z \\<in> restrict J ` X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "obtain zz where \"restrict A z = restrict J zz\" \"zz \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>zz.\n        \\<lbrakk>restrict A z = restrict J zz; zz \\<in> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>restrict A z \\<in> restrict J ` X\\<close>"], ["proof (prove)\nusing this:\n  restrict A z \\<in> restrict J ` X\n\ngoal (1 subgoal):\n 1. (\\<And>zz.\n        \\<lbrakk>restrict A z = restrict J zz; zz \\<in> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  restrict A z = restrict J zz\n  zz \\<in> X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  restrict A z = restrict J zz\n  zz \\<in> X", "have \"restrict A z = restrict A zz\""], ["proof (prove)\nusing this:\n  restrict A z = restrict J zz\n  zz \\<in> X\n\ngoal (1 subgoal):\n 1. restrict A z = restrict A zz", "by (metis Int_absorb2 \\<open>A \\<subseteq> J\\<close> restrict_nested subset_refl)"], ["proof (state)\nthis:\n  restrict A z = restrict A zz\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "moreover"], ["proof (state)\nthis:\n  restrict A z = restrict A zz\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "have \"restrict A zz = zz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict A zz = zz", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. restrict A zz = zz", "have \"(A, X) \\<in> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A, X) \\<in> Q", "by (simp add: \\<open>(A, X) \\<in> Q\\<close>)"], ["proof (state)\nthis:\n  (A, X) \\<in> Q\n\ngoal (1 subgoal):\n 1. restrict A zz = zz", "then"], ["proof (chain)\npicking this:\n  (A, X) \\<in> Q", "have \"table n A X\""], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q\n\ngoal (1 subgoal):\n 1. table n A X", "using assms(17) rwf_query_def wf_atable_def wf_query_def"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q\n  rwf_query n V Q Qn\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n  wf_atable ?n ?X = (table ?n (fst ?X) (snd ?X) \\<and> finite (fst ?X))\n  wf_query ?n ?V ?Q_pos ?Q_neg =\n  ((\\<forall>X\\<in>?Q_pos \\<union> ?Q_neg. wf_atable ?n X) \\<and>\n   wf_set ?n ?V \\<and> 1 \\<le> card ?Q_pos)\n\ngoal (1 subgoal):\n 1. table n A X", "by fastforce"], ["proof (state)\nthis:\n  table n A X\n\ngoal (1 subgoal):\n 1. restrict A zz = zz", "then"], ["proof (chain)\npicking this:\n  table n A X", "have \"wf_tuple n A zz\""], ["proof (prove)\nusing this:\n  table n A X\n\ngoal (1 subgoal):\n 1. wf_tuple n A zz", "using \\<open>zz \\<in> X\\<close> table_def"], ["proof (prove)\nusing this:\n  table n A X\n  zz \\<in> X\n  table ?n ?V ?X = (\\<forall>x\\<in>?X. wf_tuple ?n ?V x)\n\ngoal (1 subgoal):\n 1. wf_tuple n A zz", "by blast"], ["proof (state)\nthis:\n  wf_tuple n A zz\n\ngoal (1 subgoal):\n 1. restrict A zz = zz", "then"], ["proof (chain)\npicking this:\n  wf_tuple n A zz", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_tuple n A zz\n\ngoal (1 subgoal):\n 1. restrict A zz = zz", "using restrict_idle"], ["proof (prove)\nusing this:\n  wf_tuple n A zz\n  wf_tuple ?n ?A ?v \\<Longrightarrow> restrict ?A ?v = ?v\n\ngoal (1 subgoal):\n 1. restrict A zz = zz", "by blast"], ["proof (state)\nthis:\n  restrict A zz = zz\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict A zz = zz\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  restrict A zz = zz", "have \"restrict A zz = zz\""], ["proof (prove)\nusing this:\n  restrict A zz = zz\n\ngoal (1 subgoal):\n 1. restrict A zz = zz", "using \\<open>restrict A z = restrict J zz\\<close> calculation(4)"], ["proof (prove)\nusing this:\n  restrict A zz = zz\n  restrict A z = restrict J zz\n  restrict A z = restrict A zz\n\ngoal (1 subgoal):\n 1. restrict A zz = zz", "by auto"], ["proof (state)\nthis:\n  restrict A zz = zz\n\ngoal (1 subgoal):\n 1. \\<lbrakk>1 \\<le> card (A \\<inter> J);\n     \\<not> 1 \\<le> card (A \\<inter> I)\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  restrict A zz = zz", "show ?thesis"], ["proof (prove)\nusing this:\n  restrict A zz = zz\n\ngoal (1 subgoal):\n 1. restrict A z \\<in> X", "by (simp add: \\<open>zz \\<in> X\\<close> calculation(4))"], ["proof (state)\nthis:\n  restrict A z \\<in> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict A z \\<in> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict A z \\<in> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?A, ?X) \\<in> Q \\<Longrightarrow> restrict ?A z \\<in> ?X\n\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)", "then"], ["proof (chain)\npicking this:\n  (?A, ?X) \\<in> Q \\<Longrightarrow> restrict ?A z \\<in> ?X", "show ?thesis"], ["proof (prove)\nusing this:\n  (?A, ?X) \\<in> Q \\<Longrightarrow> restrict ?A z \\<in> ?X\n\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)", "using calculation"], ["proof (prove)\nusing this:\n  (?A, ?X) \\<in> Q \\<Longrightarrow> restrict ?A z \\<in> ?X\n  wf_tuple n V z\n  (?A, ?X) \\<in> Qn \\<Longrightarrow> restrict ?A z \\<notin> ?X\n\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)", "by blast"], ["proof (state)\nthis:\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simple_set_inter:\n  assumes \"I \\<subseteq> (\\<Union>X\\<in>A. f X)\"\n  shows \"I \\<subseteq> (\\<Union>X\\<in>A. (f X) \\<inter> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<subseteq> (\\<Union>X\\<in>A. f X \\<inter> I)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. I \\<subseteq> (\\<Union>X\\<in>A. f X \\<inter> I)", "have \"\\<And>x. x \\<in> I \\<Longrightarrow> x \\<in> (\\<Union>X\\<in>A. (f X) \\<inter> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> I \\<Longrightarrow> x \\<in> (\\<Union>X\\<in>A. f X \\<inter> I)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> I \\<Longrightarrow> x \\<in> (\\<Union>X\\<in>A. f X \\<inter> I)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> I \\<Longrightarrow> x \\<in> (\\<Union>X\\<in>A. f X \\<inter> I)", "assume \"x \\<in> I\""], ["proof (state)\nthis:\n  x \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> I \\<Longrightarrow> x \\<in> (\\<Union>X\\<in>A. f X \\<inter> I)", "obtain X where \"X \\<in> A\" \"x \\<in> f X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<in> A; x \\<in> f X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>x \\<in> I\\<close> assms"], ["proof (prove)\nusing this:\n  x \\<in> I\n  I \\<subseteq> \\<Union> (f ` A)\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<in> A; x \\<in> f X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  X \\<in> A\n  x \\<in> f X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> I \\<Longrightarrow> x \\<in> (\\<Union>X\\<in>A. f X \\<inter> I)", "then"], ["proof (chain)\npicking this:\n  X \\<in> A\n  x \\<in> f X", "show \"x \\<in> (\\<Union>X\\<in>A. (f X) \\<inter> I)\""], ["proof (prove)\nusing this:\n  X \\<in> A\n  x \\<in> f X\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>X\\<in>A. f X \\<inter> I)", "using \\<open>x \\<in> I\\<close>"], ["proof (prove)\nusing this:\n  X \\<in> A\n  x \\<in> f X\n  x \\<in> I\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>X\\<in>A. f X \\<inter> I)", "by blast"], ["proof (state)\nthis:\n  x \\<in> (\\<Union>X\\<in>A. f X \\<inter> I)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> I \\<Longrightarrow> ?x \\<in> (\\<Union>X\\<in>A. f X \\<inter> I)\n\ngoal (1 subgoal):\n 1. I \\<subseteq> (\\<Union>X\\<in>A. f X \\<inter> I)", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> I \\<Longrightarrow> ?x \\<in> (\\<Union>X\\<in>A. f X \\<inter> I)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> I \\<Longrightarrow> ?x \\<in> (\\<Union>X\\<in>A. f X \\<inter> I)\n\ngoal (1 subgoal):\n 1. I \\<subseteq> (\\<Union>X\\<in>A. f X \\<inter> I)", "by (simp add: subsetI)"], ["proof (state)\nthis:\n  I \\<subseteq> (\\<Union>X\\<in>A. f X \\<inter> I)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma union_restrict:\n  assumes \"restrict I z1 = restrict I z2\"\n  assumes \"restrict J z1 = restrict J z2\"\n  shows \"restrict (I \\<union> J) z1 = restrict (I \\<union> J) z2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict (I \\<union> J) z1 = restrict (I \\<union> J) z2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. restrict (I \\<union> J) z1 = restrict (I \\<union> J) z2", "define zz1 where \"zz1 = restrict (I \\<union> J) z1\""], ["proof (state)\nthis:\n  zz1 = restrict (I \\<union> J) z1\n\ngoal (1 subgoal):\n 1. restrict (I \\<union> J) z1 = restrict (I \\<union> J) z2", "define zz2 where \"zz2 = restrict (I \\<union> J) z2\""], ["proof (state)\nthis:\n  zz2 = restrict (I \\<union> J) z2\n\ngoal (1 subgoal):\n 1. restrict (I \\<union> J) z1 = restrict (I \\<union> J) z2", "have \"length z1 = length z2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length z1 = length z2", "by (metis assms(2) length_restrict)"], ["proof (state)\nthis:\n  length z1 = length z2\n\ngoal (1 subgoal):\n 1. restrict (I \\<union> J) z1 = restrict (I \\<union> J) z2", "have \"\\<And>i. i < length z1 \\<Longrightarrow> zz1!i = zz2!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i < length z1 \\<Longrightarrow> zz1 ! i = zz2 ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length z1 \\<Longrightarrow> zz1 ! i = zz2 ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length z1 \\<Longrightarrow> zz1 ! i = zz2 ! i", "assume \"i < length z1\""], ["proof (state)\nthis:\n  i < length z1\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length z1 \\<Longrightarrow> zz1 ! i = zz2 ! i", "then"], ["proof (chain)\npicking this:\n  i < length z1", "show \"zz1!i = zz2!i\""], ["proof (prove)\nusing this:\n  i < length z1\n\ngoal (1 subgoal):\n 1. zz1 ! i = zz2 ! i", "proof (cases \"i \\<in> I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < length z1; i \\<in> I\\<rbrakk>\n    \\<Longrightarrow> zz1 ! i = zz2 ! i\n 2. \\<lbrakk>i < length z1; i \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> zz1 ! i = zz2 ! i", "case True"], ["proof (state)\nthis:\n  i \\<in> I\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i < length z1; i \\<in> I\\<rbrakk>\n    \\<Longrightarrow> zz1 ! i = zz2 ! i\n 2. \\<lbrakk>i < length z1; i \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> zz1 ! i = zz2 ! i", "then"], ["proof (chain)\npicking this:\n  i \\<in> I", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<in> I\n\ngoal (1 subgoal):\n 1. zz1 ! i = zz2 ! i", "by (metis simple_restrict_none \\<open>i < length z1\\<close> \\<open>length z1 = length z2\\<close> assms(1)\n            nth_restrict zz1_def zz2_def)"], ["proof (state)\nthis:\n  zz1 ! i = zz2 ! i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length z1; i \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> zz1 ! i = zz2 ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length z1; i \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> zz1 ! i = zz2 ! i", "case False"], ["proof (state)\nthis:\n  i \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length z1; i \\<notin> I\\<rbrakk>\n    \\<Longrightarrow> zz1 ! i = zz2 ! i", "then"], ["proof (chain)\npicking this:\n  i \\<notin> I", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<notin> I\n\ngoal (1 subgoal):\n 1. zz1 ! i = zz2 ! i", "by (metis simple_restrict_none UnE \\<open>i < length z1\\<close> \\<open>length z1 = length z2\\<close> assms(2)\n            nth_restrict zz1_def zz2_def)"], ["proof (state)\nthis:\n  zz1 ! i = zz2 ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  zz1 ! i = zz2 ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < length z1 \\<Longrightarrow> zz1 ! ?i = zz2 ! ?i\n\ngoal (1 subgoal):\n 1. restrict (I \\<union> J) z1 = restrict (I \\<union> J) z2", "then"], ["proof (chain)\npicking this:\n  ?i < length z1 \\<Longrightarrow> zz1 ! ?i = zz2 ! ?i", "have \"\\<forall>i < length z1. (restrict (I \\<union> J) z1)!i = (restrict (I \\<union> J) z2)!i\""], ["proof (prove)\nusing this:\n  ?i < length z1 \\<Longrightarrow> zz1 ! ?i = zz2 ! ?i\n\ngoal (1 subgoal):\n 1. \\<forall>i<length z1.\n       restrict (I \\<union> J) z1 ! i = restrict (I \\<union> J) z2 ! i", "using zz1_def zz2_def"], ["proof (prove)\nusing this:\n  ?i < length z1 \\<Longrightarrow> zz1 ! ?i = zz2 ! ?i\n  zz1 = restrict (I \\<union> J) z1\n  zz2 = restrict (I \\<union> J) z2\n\ngoal (1 subgoal):\n 1. \\<forall>i<length z1.\n       restrict (I \\<union> J) z1 ! i = restrict (I \\<union> J) z2 ! i", "by blast"], ["proof (state)\nthis:\n  \\<forall>i<length z1.\n     restrict (I \\<union> J) z1 ! i = restrict (I \\<union> J) z2 ! i\n\ngoal (1 subgoal):\n 1. restrict (I \\<union> J) z1 = restrict (I \\<union> J) z2", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<length z1.\n     restrict (I \\<union> J) z1 ! i = restrict (I \\<union> J) z2 ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i<length z1.\n     restrict (I \\<union> J) z1 ! i = restrict (I \\<union> J) z2 ! i\n\ngoal (1 subgoal):\n 1. restrict (I \\<union> J) z1 = restrict (I \\<union> J) z2", "by (simp add: simple_list_index_equality \\<open>length z1 = length z2\\<close>)"], ["proof (state)\nthis:\n  restrict (I \\<union> J) z1 = restrict (I \\<union> J) z2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma partial_correctness_direct:\n  assumes \"V = I \\<union> J\"\n  assumes \"Set.is_empty (I \\<inter> J)\"\n  assumes \"card I \\<ge> 1\"\n  assumes \"card J \\<ge> 1\"\n  assumes \"Q_I_pos = projectQuery I (filterQuery I Q)\"\n  assumes \"Q_J_pos = filterQuery J Q\"\n  assumes \"Q_I_neg = filterQueryNeg I Qn\"\n  assumes \"Q_J_neg = filterQuery J (Qn - Q_I_neg)\"\n  assumes \"R_I = genericJoin I Q_I_pos Q_I_neg\"\n  assumes \"X = {(t, genericJoin J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t))) | t . t \\<in> R_I}\"\n  assumes \"R = (\\<Union>(t, x) \\<in> X. {merge xx t | xx . xx \\<in> x})\"\n  assumes \"R_NQ = genericJoin J NQ_pos NQ_neg\"\n  assumes \"\\<forall>x. (x \\<in> R_I \\<longleftrightarrow> wf_tuple n I x \\<and> (\\<forall>(A, X)\\<in>Q_I_pos. restrict A x \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Q_I_neg. restrict A x \\<notin> X))\"\n  assumes \"\\<forall>t\\<in>R_I. (\\<forall>y. (y \\<in> genericJoin J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t)) \\<longleftrightarrow> wf_tuple n J y \\<and>\n  (\\<forall>(A, X)\\<in>(newQuery J Q_J_pos (I, t)). restrict A y \\<in> X) \\<and> (\\<forall>(A, X)\\<in>(newQuery J Q_J_neg (I, t)). restrict A y \\<notin> X)))\"\n  assumes \"wf_tuple n V z \\<and> (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\"\n  assumes \"rwf_query n V Q Qn\"\n  shows \"z \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<in> R", "define CI where \"CI = filterQuery I Q\""], ["proof (state)\nthis:\n  CI = filterQuery I Q\n\ngoal (1 subgoal):\n 1. z \\<in> R", "define zI where \"zI = restrict I z\""], ["proof (state)\nthis:\n  zI = restrict I z\n\ngoal (1 subgoal):\n 1. z \\<in> R", "have \"wf_tuple n I zI\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple n I zI", "using assms(1) assms(15) wf_tuple_restrict_simple zI_def"], ["proof (prove)\nusing this:\n  V = I \\<union> J\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\n  \\<lbrakk>wf_tuple ?n ?B ?v; ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> wf_tuple ?n ?A (restrict ?A ?v)\n  zI = restrict I z\n\ngoal (1 subgoal):\n 1. wf_tuple n I zI", "by auto"], ["proof (state)\nthis:\n  wf_tuple n I zI\n\ngoal (1 subgoal):\n 1. z \\<in> R", "have \"\\<And>A X. ((A, X)\\<in>Q_I_pos \\<Longrightarrow> restrict A zI \\<in> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q_I_pos \\<Longrightarrow> restrict A zI \\<in> X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q_I_pos \\<Longrightarrow> restrict A zI \\<in> X", "fix A X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q_I_pos \\<Longrightarrow> restrict A zI \\<in> X", "assume \"(A, X)\\<in>Q_I_pos\""], ["proof (state)\nthis:\n  (A, X) \\<in> Q_I_pos\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q_I_pos \\<Longrightarrow> restrict A zI \\<in> X", "have \"(A, X) \\<in> projectQuery I Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A, X) \\<in> projectQuery I Q", "using \\<open>(A, X) \\<in> Q_I_pos\\<close> assms(5)"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q_I_pos\n  Q_I_pos = projectQuery I (filterQuery I Q)\n\ngoal (1 subgoal):\n 1. (A, X) \\<in> projectQuery I Q", "by auto"], ["proof (state)\nthis:\n  (A, X) \\<in> projectQuery I Q\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q_I_pos \\<Longrightarrow> restrict A zI \\<in> X", "then"], ["proof (chain)\npicking this:\n  (A, X) \\<in> projectQuery I Q", "obtain AA XX where \"X = Set.image (restrict I) XX\" \"(AA, XX) \\<in> Q\" \"A = AA \\<inter> I\""], ["proof (prove)\nusing this:\n  (A, X) \\<in> projectQuery I Q\n\ngoal (1 subgoal):\n 1. (\\<And>XX AA.\n        \\<lbrakk>X = restrict I ` XX; (AA, XX) \\<in> Q;\n         A = AA \\<inter> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  X = restrict I ` XX\n  (AA, XX) \\<in> Q\n  A = AA \\<inter> I\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q_I_pos \\<Longrightarrow> restrict A zI \\<in> X", "moreover"], ["proof (state)\nthis:\n  X = restrict I ` XX\n  (AA, XX) \\<in> Q\n  A = AA \\<inter> I\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q_I_pos \\<Longrightarrow> restrict A zI \\<in> X", "have \"(restrict AA z) \\<in> XX\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict AA z \\<in> XX", "using assms(15) calculation(2)"], ["proof (prove)\nusing this:\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\n  (AA, XX) \\<in> Q\n\ngoal (1 subgoal):\n 1. restrict AA z \\<in> XX", "by blast"], ["proof (state)\nthis:\n  restrict AA z \\<in> XX\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q_I_pos \\<Longrightarrow> restrict A zI \\<in> X", "then"], ["proof (chain)\npicking this:\n  restrict AA z \\<in> XX", "have \"restrict I (restrict AA z) \\<in> X\""], ["proof (prove)\nusing this:\n  restrict AA z \\<in> XX\n\ngoal (1 subgoal):\n 1. restrict I (restrict AA z) \\<in> X", "by (simp add: calculation(1))"], ["proof (state)\nthis:\n  restrict I (restrict AA z) \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q_I_pos \\<Longrightarrow> restrict A zI \\<in> X", "then"], ["proof (chain)\npicking this:\n  restrict I (restrict AA z) \\<in> X", "show \"restrict A zI \\<in> X\""], ["proof (prove)\nusing this:\n  restrict I (restrict AA z) \\<in> X\n\ngoal (1 subgoal):\n 1. restrict A zI \\<in> X", "by (metis calculation(3) inf.right_idem inf_commute restrict_nested zI_def)"], ["proof (state)\nthis:\n  restrict A zI \\<in> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?A, ?X) \\<in> Q_I_pos \\<Longrightarrow> restrict ?A zI \\<in> ?X\n\ngoal (1 subgoal):\n 1. z \\<in> R", "moreover"], ["proof (state)\nthis:\n  (?A, ?X) \\<in> Q_I_pos \\<Longrightarrow> restrict ?A zI \\<in> ?X\n\ngoal (1 subgoal):\n 1. z \\<in> R", "have \"\\<And>A X. ((A, X)\\<in>Q_I_neg \\<Longrightarrow> restrict A zI \\<notin> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_I_neg \\<Longrightarrow> restrict A zI \\<notin> X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_I_neg \\<Longrightarrow> restrict A zI \\<notin> X", "fix A X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_I_neg \\<Longrightarrow> restrict A zI \\<notin> X", "assume \"(A, X)\\<in>Q_I_neg\""], ["proof (state)\nthis:\n  (A, X) \\<in> Q_I_neg\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_I_neg \\<Longrightarrow> restrict A zI \\<notin> X", "then"], ["proof (chain)\npicking this:\n  (A, X) \\<in> Q_I_neg", "have \"(A, X) \\<in> Qn\""], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q_I_neg\n\ngoal (1 subgoal):\n 1. (A, X) \\<in> Qn", "by (simp add: assms(7))"], ["proof (state)\nthis:\n  (A, X) \\<in> Qn\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_I_neg \\<Longrightarrow> restrict A zI \\<notin> X", "then"], ["proof (chain)\npicking this:\n  (A, X) \\<in> Qn", "have \"restrict A z \\<notin> X\""], ["proof (prove)\nusing this:\n  (A, X) \\<in> Qn\n\ngoal (1 subgoal):\n 1. restrict A z \\<notin> X", "using assms(15)"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Qn\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\n\ngoal (1 subgoal):\n 1. restrict A z \\<notin> X", "by blast"], ["proof (state)\nthis:\n  restrict A z \\<notin> X\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_I_neg \\<Longrightarrow> restrict A zI \\<notin> X", "moreover"], ["proof (state)\nthis:\n  restrict A z \\<notin> X\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_I_neg \\<Longrightarrow> restrict A zI \\<notin> X", "have \"A \\<subseteq> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> I", "using \\<open>(A, X) \\<in> Q_I_neg\\<close> assms(7)"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q_I_neg\n  Q_I_neg = filterQueryNeg I Qn\n\ngoal (1 subgoal):\n 1. A \\<subseteq> I", "by auto"], ["proof (state)\nthis:\n  A \\<subseteq> I\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_I_neg \\<Longrightarrow> restrict A zI \\<notin> X", "then"], ["proof (chain)\npicking this:\n  A \\<subseteq> I", "have \"restrict A z = restrict A zI\""], ["proof (prove)\nusing this:\n  A \\<subseteq> I\n\ngoal (1 subgoal):\n 1. restrict A z = restrict A zI", "using nested_include_restrict zI_def"], ["proof (prove)\nusing this:\n  A \\<subseteq> I\n  \\<lbrakk>restrict ?I ?z = ?t; ?A \\<subseteq> ?I\\<rbrakk>\n  \\<Longrightarrow> restrict ?A ?z = restrict ?A ?t\n  zI = restrict I z\n\ngoal (1 subgoal):\n 1. restrict A z = restrict A zI", "by metis"], ["proof (state)\nthis:\n  restrict A z = restrict A zI\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_I_neg \\<Longrightarrow> restrict A zI \\<notin> X", "then"], ["proof (chain)\npicking this:\n  restrict A z = restrict A zI", "show \"restrict A zI \\<notin> X\""], ["proof (prove)\nusing this:\n  restrict A z = restrict A zI\n\ngoal (1 subgoal):\n 1. restrict A zI \\<notin> X", "using calculation"], ["proof (prove)\nusing this:\n  restrict A z = restrict A zI\n  restrict A z \\<notin> X\n\ngoal (1 subgoal):\n 1. restrict A zI \\<notin> X", "by auto"], ["proof (state)\nthis:\n  restrict A zI \\<notin> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?A, ?X) \\<in> Q_I_neg \\<Longrightarrow> restrict ?A zI \\<notin> ?X\n\ngoal (1 subgoal):\n 1. z \\<in> R", "then"], ["proof (chain)\npicking this:\n  (?A, ?X) \\<in> Q_I_neg \\<Longrightarrow> restrict ?A zI \\<notin> ?X", "have \"zI \\<in> R_I\""], ["proof (prove)\nusing this:\n  (?A, ?X) \\<in> Q_I_neg \\<Longrightarrow> restrict ?A zI \\<notin> ?X\n\ngoal (1 subgoal):\n 1. zI \\<in> R_I", "using \\<open>wf_tuple n I zI\\<close> assms(13) calculation"], ["proof (prove)\nusing this:\n  (?A, ?X) \\<in> Q_I_neg \\<Longrightarrow> restrict ?A zI \\<notin> ?X\n  wf_tuple n I zI\n  \\<forall>x.\n     (x \\<in> R_I) =\n     (wf_tuple n I x \\<and>\n      (\\<forall>(A, X)\\<in>Q_I_pos. restrict A x \\<in> X) \\<and>\n      (\\<forall>(A, X)\\<in>Q_I_neg. restrict A x \\<notin> X))\n  (?A, ?X) \\<in> Q_I_pos \\<Longrightarrow> restrict ?A zI \\<in> ?X\n\ngoal (1 subgoal):\n 1. zI \\<in> R_I", "by auto"], ["proof (state)\nthis:\n  zI \\<in> R_I\n\ngoal (1 subgoal):\n 1. z \\<in> R", "define zJ where \"zJ = restrict J z\""], ["proof (state)\nthis:\n  zJ = restrict J z\n\ngoal (1 subgoal):\n 1. z \\<in> R", "have \"wf_tuple n J zJ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple n J zJ", "using assms(1) assms(15) wf_tuple_restrict_simple zJ_def"], ["proof (prove)\nusing this:\n  V = I \\<union> J\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\n  \\<lbrakk>wf_tuple ?n ?B ?v; ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> wf_tuple ?n ?A (restrict ?A ?v)\n  zJ = restrict J z\n\ngoal (1 subgoal):\n 1. wf_tuple n J zJ", "by auto"], ["proof (state)\nthis:\n  wf_tuple n J zJ\n\ngoal (1 subgoal):\n 1. z \\<in> R", "have \"\\<And>A X. ((A, X)\\<in>Q_J_pos \\<Longrightarrow> restrict A z \\<in> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q_J_pos \\<Longrightarrow> restrict A z \\<in> X", "using assms(15) assms(6)"], ["proof (prove)\nusing this:\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\n  Q_J_pos = filterQuery J Q\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q_J_pos \\<Longrightarrow> restrict A z \\<in> X", "by auto"], ["proof (state)\nthis:\n  (?A, ?X) \\<in> Q_J_pos \\<Longrightarrow> restrict ?A z \\<in> ?X\n\ngoal (1 subgoal):\n 1. z \\<in> R", "define NQ where \"NQ = newQuery J Q_J_pos (I, zI)\""], ["proof (state)\nthis:\n  NQ = newQuery J Q_J_pos (I, zI)\n\ngoal (1 subgoal):\n 1. z \\<in> R", "have \"\\<And>A X. ((A, X)\\<in>Q_J_pos \\<Longrightarrow> (isSameIntersection zI (A \\<inter> I) (restrict A z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_J_pos \\<Longrightarrow>\n       isSameIntersection zI (A \\<inter> I) (restrict A z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_J_pos \\<Longrightarrow>\n       isSameIntersection zI (A \\<inter> I) (restrict A z)", "fix A X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_J_pos \\<Longrightarrow>\n       isSameIntersection zI (A \\<inter> I) (restrict A z)", "assume \"(A, X) \\<in> Q_J_pos\""], ["proof (state)\nthis:\n  (A, X) \\<in> Q_J_pos\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_J_pos \\<Longrightarrow>\n       isSameIntersection zI (A \\<inter> I) (restrict A z)", "obtain \"wf_set n V\" \"wf_tuple n I zI\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>wf_set n V; wf_tuple n I zI\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>wf_tuple n I zI\\<close> assms(16) rwf_query_def wf_query_def"], ["proof (prove)\nusing this:\n  wf_tuple n I zI\n  rwf_query n V Q Qn\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n  wf_query ?n ?V ?Q_pos ?Q_neg =\n  ((\\<forall>X\\<in>?Q_pos \\<union> ?Q_neg. wf_atable ?n X) \\<and>\n   wf_set ?n ?V \\<and> 1 \\<le> card ?Q_pos)\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>wf_set n V; wf_tuple n I zI\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  wf_set n V\n  wf_tuple n I zI\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_J_pos \\<Longrightarrow>\n       isSameIntersection zI (A \\<inter> I) (restrict A z)", "moreover"], ["proof (state)\nthis:\n  wf_set n V\n  wf_tuple n I zI\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_J_pos \\<Longrightarrow>\n       isSameIntersection zI (A \\<inter> I) (restrict A z)", "have \"A \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<subseteq> V", "have \"included V Q_J_pos\""], ["proof (prove)\ngoal (1 subgoal):\n 1. included V Q_J_pos", "by (metis filterQuery.elims assms(16) assms(6) included_def member_filter rwf_query_def)"], ["proof (state)\nthis:\n  included V Q_J_pos\n\ngoal (1 subgoal):\n 1. A \\<subseteq> V", "then"], ["proof (chain)\npicking this:\n  included V Q_J_pos", "show ?thesis"], ["proof (prove)\nusing this:\n  included V Q_J_pos\n\ngoal (1 subgoal):\n 1. A \\<subseteq> V", "using \\<open>(A, X) \\<in> Q_J_pos\\<close> included_def"], ["proof (prove)\nusing this:\n  included V Q_J_pos\n  (A, X) \\<in> Q_J_pos\n  included ?V ?Q = (\\<forall>(S, X)\\<in>?Q. S \\<subseteq> ?V)\n\ngoal (1 subgoal):\n 1. A \\<subseteq> V", "by fastforce"], ["proof (state)\nthis:\n  A \\<subseteq> V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_J_pos \\<Longrightarrow>\n       isSameIntersection zI (A \\<inter> I) (restrict A z)", "moreover"], ["proof (state)\nthis:\n  A \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_J_pos \\<Longrightarrow>\n       isSameIntersection zI (A \\<inter> I) (restrict A z)", "have \"wf_tuple n A (restrict A z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple n A (restrict A z)", "by (meson assms(15) calculation(3) wf_tuple_restrict_simple)"], ["proof (state)\nthis:\n  wf_tuple n A (restrict A z)\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_J_pos \\<Longrightarrow>\n       isSameIntersection zI (A \\<inter> I) (restrict A z)", "then"], ["proof (chain)\npicking this:\n  wf_tuple n A (restrict A z)", "show \"isSameIntersection zI (A \\<inter> I) (restrict A z)\""], ["proof (prove)\nusing this:\n  wf_tuple n A (restrict A z)\n\ngoal (1 subgoal):\n 1. isSameIntersection zI (A \\<inter> I) (restrict A z)", "using isSame_equi_dev[of n V I zI A \"restrict A z\" \"A \\<inter> I\"]"], ["proof (prove)\nusing this:\n  wf_tuple n A (restrict A z)\n  \\<lbrakk>wf_set n V; wf_tuple n I zI; wf_tuple n A (restrict A z);\n   A \\<inter> I \\<subseteq> I; A \\<inter> I \\<subseteq> A; I \\<subseteq> V;\n   A \\<subseteq> V\\<rbrakk>\n  \\<Longrightarrow> isSameIntersection zI (A \\<inter> I) (restrict A z) =\n                    (restrict (A \\<inter> I) zI =\n                     restrict (A \\<inter> I) (restrict A z))\n\ngoal (1 subgoal):\n 1. isSameIntersection zI (A \\<inter> I) (restrict A z)", "by (metis nested_include_restrict assms(1) calculation(1) calculation(2) calculation(3) inf_le1 inf_le2 sup_ge1 zI_def)"], ["proof (state)\nthis:\n  isSameIntersection zI (A \\<inter> I) (restrict A z)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?A, ?X) \\<in> Q_J_pos \\<Longrightarrow>\n  isSameIntersection zI (?A \\<inter> I) (restrict ?A z)\n\ngoal (1 subgoal):\n 1. z \\<in> R", "then"], ["proof (chain)\npicking this:\n  (?A, ?X) \\<in> Q_J_pos \\<Longrightarrow>\n  isSameIntersection zI (?A \\<inter> I) (restrict ?A z)", "have \"\\<And>A X. ((A, X)\\<in>NQ \\<Longrightarrow> restrict A zJ \\<in> X)\""], ["proof (prove)\nusing this:\n  (?A, ?X) \\<in> Q_J_pos \\<Longrightarrow>\n  isSameIntersection zI (?A \\<inter> I) (restrict ?A z)\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> NQ \\<Longrightarrow> restrict A zJ \\<in> X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A X.\n       \\<lbrakk>(A, X) \\<in> NQ;\n        \\<And>A X.\n           (A, X) \\<in> Q_J_pos \\<Longrightarrow>\n           isSameIntersection zI (A \\<inter> I) (restrict A z)\\<rbrakk>\n       \\<Longrightarrow> restrict A zJ \\<in> X", "fix A X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A X.\n       \\<lbrakk>(A, X) \\<in> NQ;\n        \\<And>A X.\n           (A, X) \\<in> Q_J_pos \\<Longrightarrow>\n           isSameIntersection zI (A \\<inter> I) (restrict A z)\\<rbrakk>\n       \\<Longrightarrow> restrict A zJ \\<in> X", "assume \"(A, X)\\<in>NQ\""], ["proof (state)\nthis:\n  (A, X) \\<in> NQ\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       \\<lbrakk>(A, X) \\<in> NQ;\n        \\<And>A X.\n           (A, X) \\<in> Q_J_pos \\<Longrightarrow>\n           isSameIntersection zI (A \\<inter> I) (restrict A z)\\<rbrakk>\n       \\<Longrightarrow> restrict A zJ \\<in> X", "obtain AA XX where \"(A, X) = projectTable J (semiJoin (AA, XX) (I, zI))\" \"(AA, XX) \\<in> Q_J_pos\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>AA XX.\n        \\<lbrakk>(A, X) = projectTable J (semiJoin (AA, XX) (I, zI));\n         (AA, XX) \\<in> Q_J_pos\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using NQ_def \\<open>(A, X) \\<in> NQ\\<close>"], ["proof (prove)\nusing this:\n  NQ = newQuery J Q_J_pos (I, zI)\n  (A, X) \\<in> NQ\n\ngoal (1 subgoal):\n 1. (\\<And>AA XX.\n        \\<lbrakk>(A, X) = projectTable J (semiJoin (AA, XX) (I, zI));\n         (AA, XX) \\<in> Q_J_pos\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (A, X) = projectTable J (semiJoin (AA, XX) (I, zI))\n  (AA, XX) \\<in> Q_J_pos\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       \\<lbrakk>(A, X) \\<in> NQ;\n        \\<And>A X.\n           (A, X) \\<in> Q_J_pos \\<Longrightarrow>\n           isSameIntersection zI (A \\<inter> I) (restrict A z)\\<rbrakk>\n       \\<Longrightarrow> restrict A zJ \\<in> X", "then"], ["proof (chain)\npicking this:\n  (A, X) = projectTable J (semiJoin (AA, XX) (I, zI))\n  (AA, XX) \\<in> Q_J_pos", "have \"restrict AA z \\<in> XX\""], ["proof (prove)\nusing this:\n  (A, X) = projectTable J (semiJoin (AA, XX) (I, zI))\n  (AA, XX) \\<in> Q_J_pos\n\ngoal (1 subgoal):\n 1. restrict AA z \\<in> XX", "using \\<open>\\<And>X A. (A, X) \\<in> Q_J_pos \\<Longrightarrow> restrict A z \\<in> X\\<close>"], ["proof (prove)\nusing this:\n  (A, X) = projectTable J (semiJoin (AA, XX) (I, zI))\n  (AA, XX) \\<in> Q_J_pos\n  (?A, ?X) \\<in> Q_J_pos \\<Longrightarrow> restrict ?A z \\<in> ?X\n\ngoal (1 subgoal):\n 1. restrict AA z \\<in> XX", "by blast"], ["proof (state)\nthis:\n  restrict AA z \\<in> XX\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       \\<lbrakk>(A, X) \\<in> NQ;\n        \\<And>A X.\n           (A, X) \\<in> Q_J_pos \\<Longrightarrow>\n           isSameIntersection zI (A \\<inter> I) (restrict A z)\\<rbrakk>\n       \\<Longrightarrow> restrict A zJ \\<in> X", "then"], ["proof (chain)\npicking this:\n  restrict AA z \\<in> XX", "have \"restrict AA z \\<in> snd (semiJoin (AA, XX) (I, zI))\""], ["proof (prove)\nusing this:\n  restrict AA z \\<in> XX\n\ngoal (1 subgoal):\n 1. restrict AA z \\<in> snd (semiJoin (AA, XX) (I, zI))", "using \\<open>(AA, XX) \\<in> Q_J_pos\\<close> \\<open>\\<And>X A. (A, X) \\<in> Q_J_pos \\<Longrightarrow> isSameIntersection zI (A \\<inter> I) (restrict A z)\\<close>"], ["proof (prove)\nusing this:\n  restrict AA z \\<in> XX\n  (AA, XX) \\<in> Q_J_pos\n  (?A, ?X) \\<in> Q_J_pos \\<Longrightarrow>\n  isSameIntersection zI (?A \\<inter> I) (restrict ?A z)\n\ngoal (1 subgoal):\n 1. restrict AA z \\<in> snd (semiJoin (AA, XX) (I, zI))", "by auto"], ["proof (state)\nthis:\n  restrict AA z \\<in> snd (semiJoin (AA, XX) (I, zI))\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       \\<lbrakk>(A, X) \\<in> NQ;\n        \\<And>A X.\n           (A, X) \\<in> Q_J_pos \\<Longrightarrow>\n           isSameIntersection zI (A \\<inter> I) (restrict A z)\\<rbrakk>\n       \\<Longrightarrow> restrict A zJ \\<in> X", "then"], ["proof (chain)\npicking this:\n  restrict AA z \\<in> snd (semiJoin (AA, XX) (I, zI))", "have \"restrict J (restrict AA z) \\<in> X\""], ["proof (prove)\nusing this:\n  restrict AA z \\<in> snd (semiJoin (AA, XX) (I, zI))\n\ngoal (1 subgoal):\n 1. restrict J (restrict AA z) \\<in> X", "using \\<open>(A, X) = projectTable J (semiJoin (AA, XX) (I, zI))\\<close>"], ["proof (prove)\nusing this:\n  restrict AA z \\<in> snd (semiJoin (AA, XX) (I, zI))\n  (A, X) = projectTable J (semiJoin (AA, XX) (I, zI))\n\ngoal (1 subgoal):\n 1. restrict J (restrict AA z) \\<in> X", "by auto"], ["proof (state)\nthis:\n  restrict J (restrict AA z) \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       \\<lbrakk>(A, X) \\<in> NQ;\n        \\<And>A X.\n           (A, X) \\<in> Q_J_pos \\<Longrightarrow>\n           isSameIntersection zI (A \\<inter> I) (restrict A z)\\<rbrakk>\n       \\<Longrightarrow> restrict A zJ \\<in> X", "then"], ["proof (chain)\npicking this:\n  restrict J (restrict AA z) \\<in> X", "show \"restrict A zJ \\<in> X\""], ["proof (prove)\nusing this:\n  restrict J (restrict AA z) \\<in> X\n\ngoal (1 subgoal):\n 1. restrict A zJ \\<in> X", "by (metis \\<open>(A, X) = projectTable J (semiJoin (AA, XX) (I, zI))\\<close> fst_conv inf.idem inf_commute\n          projectTable.simps restrict_nested semiJoin.simps zJ_def)"], ["proof (state)\nthis:\n  restrict A zJ \\<in> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?A, ?X) \\<in> NQ \\<Longrightarrow> restrict ?A zJ \\<in> ?X\n\ngoal (1 subgoal):\n 1. z \\<in> R", "moreover"], ["proof (state)\nthis:\n  (?A, ?X) \\<in> NQ \\<Longrightarrow> restrict ?A zJ \\<in> ?X\n\ngoal (1 subgoal):\n 1. z \\<in> R", "have \"\\<forall>y. (y \\<in> genericJoin J (newQuery J Q_J_pos (I, zI)) (newQuery J Q_J_neg (I, zI)) \\<longleftrightarrow> wf_tuple n J y \\<and>\n  (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, zI). restrict A y \\<in> X) \\<and> (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, zI). restrict A y \\<notin> X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y.\n       (y \\<in> genericJoin J (newQuery J Q_J_pos (I, zI))\n                 (newQuery J Q_J_neg (I, zI))) =\n       (wf_tuple n J y \\<and>\n        (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, zI).\n            restrict A y \\<in> X) \\<and>\n        (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, zI).\n            restrict A y \\<notin> X))", "using \\<open>zI \\<in> R_I\\<close> assms(14)"], ["proof (prove)\nusing this:\n  zI \\<in> R_I\n  \\<forall>t\\<in>R_I.\n     \\<forall>y.\n        (y \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                  (newQuery J Q_J_neg (I, t))) =\n        (wf_tuple n J y \\<and>\n         (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, t).\n             restrict A y \\<in> X) \\<and>\n         (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, t).\n             restrict A y \\<notin> X))\n\ngoal (1 subgoal):\n 1. \\<forall>y.\n       (y \\<in> genericJoin J (newQuery J Q_J_pos (I, zI))\n                 (newQuery J Q_J_neg (I, zI))) =\n       (wf_tuple n J y \\<and>\n        (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, zI).\n            restrict A y \\<in> X) \\<and>\n        (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, zI).\n            restrict A y \\<notin> X))", "by auto"], ["proof (state)\nthis:\n  \\<forall>y.\n     (y \\<in> genericJoin J (newQuery J Q_J_pos (I, zI))\n               (newQuery J Q_J_neg (I, zI))) =\n     (wf_tuple n J y \\<and>\n      (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, zI).\n          restrict A y \\<in> X) \\<and>\n      (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, zI).\n          restrict A y \\<notin> X))\n\ngoal (1 subgoal):\n 1. z \\<in> R", "then"], ["proof (chain)\npicking this:\n  \\<forall>y.\n     (y \\<in> genericJoin J (newQuery J Q_J_pos (I, zI))\n               (newQuery J Q_J_neg (I, zI))) =\n     (wf_tuple n J y \\<and>\n      (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, zI).\n          restrict A y \\<in> X) \\<and>\n      (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, zI).\n          restrict A y \\<notin> X))", "have \"zJ \\<in> genericJoin J (newQuery J Q_J_pos (I, zI)) (newQuery J Q_J_neg (I, zI))\n                     \\<longleftrightarrow> wf_tuple n J zJ \\<and> (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, zI). restrict A zJ \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, zI). restrict A zJ \\<notin> X)\""], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y \\<in> genericJoin J (newQuery J Q_J_pos (I, zI))\n               (newQuery J Q_J_neg (I, zI))) =\n     (wf_tuple n J y \\<and>\n      (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, zI).\n          restrict A y \\<in> X) \\<and>\n      (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, zI).\n          restrict A y \\<notin> X))\n\ngoal (1 subgoal):\n 1. (zJ \\<in> genericJoin J (newQuery J Q_J_pos (I, zI))\n               (newQuery J Q_J_neg (I, zI))) =\n    (wf_tuple n J zJ \\<and>\n     (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, zI).\n         restrict A zJ \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, zI).\n         restrict A zJ \\<notin> X))", "by blast"], ["proof (state)\nthis:\n  (zJ \\<in> genericJoin J (newQuery J Q_J_pos (I, zI))\n             (newQuery J Q_J_neg (I, zI))) =\n  (wf_tuple n J zJ \\<and>\n   (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, zI).\n       restrict A zJ \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, zI).\n       restrict A zJ \\<notin> X))\n\ngoal (1 subgoal):\n 1. z \\<in> R", "moreover"], ["proof (state)\nthis:\n  (zJ \\<in> genericJoin J (newQuery J Q_J_pos (I, zI))\n             (newQuery J Q_J_neg (I, zI))) =\n  (wf_tuple n J zJ \\<and>\n   (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, zI).\n       restrict A zJ \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, zI).\n       restrict A zJ \\<notin> X))\n\ngoal (1 subgoal):\n 1. z \\<in> R", "have \"\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, zI). restrict A zJ \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, zI). restrict A zJ \\<in> X", "using NQ_def calculation(2)"], ["proof (prove)\nusing this:\n  NQ = newQuery J Q_J_pos (I, zI)\n  (?A, ?X) \\<in> NQ \\<Longrightarrow> restrict ?A zJ \\<in> ?X\n\ngoal (1 subgoal):\n 1. \\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, zI). restrict A zJ \\<in> X", "by blast"], ["proof (state)\nthis:\n  \\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, zI). restrict A zJ \\<in> X\n\ngoal (1 subgoal):\n 1. z \\<in> R", "moreover"], ["proof (state)\nthis:\n  \\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, zI). restrict A zJ \\<in> X\n\ngoal (1 subgoal):\n 1. z \\<in> R", "have \"\\<And>A X. (A, X)\\<in>newQuery J Q_J_neg (I, zI) \\<Longrightarrow> restrict A zJ \\<notin> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> newQuery J Q_J_neg (I, zI) \\<Longrightarrow>\n       restrict A zJ \\<notin> X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> newQuery J Q_J_neg (I, zI) \\<Longrightarrow>\n       restrict A zJ \\<notin> X", "fix A X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> newQuery J Q_J_neg (I, zI) \\<Longrightarrow>\n       restrict A zJ \\<notin> X", "assume \"(A, X) \\<in> newQuery J Q_J_neg (I, zI)\""], ["proof (state)\nthis:\n  (A, X) \\<in> newQuery J Q_J_neg (I, zI)\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> newQuery J Q_J_neg (I, zI) \\<Longrightarrow>\n       restrict A zJ \\<notin> X", "then"], ["proof (chain)\npicking this:\n  (A, X) \\<in> newQuery J Q_J_neg (I, zI)", "have \"(A, X) \\<in> (Set.image (\\<lambda>tab. projectTable J (semiJoin tab (I, zI))) Q_J_neg)\""], ["proof (prove)\nusing this:\n  (A, X) \\<in> newQuery J Q_J_neg (I, zI)\n\ngoal (1 subgoal):\n 1. (A, X)\n    \\<in> (\\<lambda>tab. projectTable J (semiJoin tab (I, zI))) ` Q_J_neg", "using newQuery.simps"], ["proof (prove)\nusing this:\n  (A, X) \\<in> newQuery J Q_J_neg (I, zI)\n  newQuery ?V ?Q (?st, ?t) =\n  (\\<lambda>tab. projectTable ?V (semiJoin tab (?st, ?t))) ` ?Q\n\ngoal (1 subgoal):\n 1. (A, X)\n    \\<in> (\\<lambda>tab. projectTable J (semiJoin tab (I, zI))) ` Q_J_neg", "by blast"], ["proof (state)\nthis:\n  (A, X)\n  \\<in> (\\<lambda>tab. projectTable J (semiJoin tab (I, zI))) ` Q_J_neg\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> newQuery J Q_J_neg (I, zI) \\<Longrightarrow>\n       restrict A zJ \\<notin> X", "then"], ["proof (chain)\npicking this:\n  (A, X)\n  \\<in> (\\<lambda>tab. projectTable J (semiJoin tab (I, zI))) ` Q_J_neg", "obtain AA XX where \"(A, X) = projectTable J (semiJoin (AA, XX) (I, zI))\" and \"(AA, XX) \\<in> Q_J_neg\""], ["proof (prove)\nusing this:\n  (A, X)\n  \\<in> (\\<lambda>tab. projectTable J (semiJoin tab (I, zI))) ` Q_J_neg\n\ngoal (1 subgoal):\n 1. (\\<And>AA XX.\n        \\<lbrakk>(A, X) = projectTable J (semiJoin (AA, XX) (I, zI));\n         (AA, XX) \\<in> Q_J_neg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (A, X) = projectTable J (semiJoin (AA, XX) (I, zI))\n  (AA, XX) \\<in> Q_J_neg\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> newQuery J Q_J_neg (I, zI) \\<Longrightarrow>\n       restrict A zJ \\<notin> X", "then"], ["proof (chain)\npicking this:\n  (A, X) = projectTable J (semiJoin (AA, XX) (I, zI))\n  (AA, XX) \\<in> Q_J_neg", "have \"A = AA \\<inter> J\""], ["proof (prove)\nusing this:\n  (A, X) = projectTable J (semiJoin (AA, XX) (I, zI))\n  (AA, XX) \\<in> Q_J_neg\n\ngoal (1 subgoal):\n 1. A = AA \\<inter> J", "by auto"], ["proof (state)\nthis:\n  A = AA \\<inter> J\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> newQuery J Q_J_neg (I, zI) \\<Longrightarrow>\n       restrict A zJ \\<notin> X", "then"], ["proof (chain)\npicking this:\n  A = AA \\<inter> J", "have \"(AA, XX) \\<in> Qn\""], ["proof (prove)\nusing this:\n  A = AA \\<inter> J\n\ngoal (1 subgoal):\n 1. (AA, XX) \\<in> Qn", "using \\<open>(AA, XX) \\<in> Q_J_neg\\<close> assms(8)"], ["proof (prove)\nusing this:\n  A = AA \\<inter> J\n  (AA, XX) \\<in> Q_J_neg\n  Q_J_neg = filterQuery J (Qn - Q_I_neg)\n\ngoal (1 subgoal):\n 1. (AA, XX) \\<in> Qn", "by auto"], ["proof (state)\nthis:\n  (AA, XX) \\<in> Qn\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> newQuery J Q_J_neg (I, zI) \\<Longrightarrow>\n       restrict A zJ \\<notin> X", "then"], ["proof (chain)\npicking this:\n  (AA, XX) \\<in> Qn", "have \"restrict AA z \\<notin> XX\""], ["proof (prove)\nusing this:\n  (AA, XX) \\<in> Qn\n\ngoal (1 subgoal):\n 1. restrict AA z \\<notin> XX", "using assms(15)"], ["proof (prove)\nusing this:\n  (AA, XX) \\<in> Qn\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\n\ngoal (1 subgoal):\n 1. restrict AA z \\<notin> XX", "by blast"], ["proof (state)\nthis:\n  restrict AA z \\<notin> XX\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> newQuery J Q_J_neg (I, zI) \\<Longrightarrow>\n       restrict A zJ \\<notin> X", "show \"restrict A zJ \\<notin> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict A zJ \\<notin> X", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> restrict A zJ \\<notin> X \\<Longrightarrow> False", "assume \"\\<not> (restrict A zJ \\<notin> X)\""], ["proof (state)\nthis:\n  \\<not> restrict A zJ \\<notin> X\n\ngoal (1 subgoal):\n 1. \\<not> restrict A zJ \\<notin> X \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> restrict A zJ \\<notin> X", "have \"restrict A zJ \\<in> X\""], ["proof (prove)\nusing this:\n  \\<not> restrict A zJ \\<notin> X\n\ngoal (1 subgoal):\n 1. restrict A zJ \\<in> X", "by simp"], ["proof (state)\nthis:\n  restrict A zJ \\<in> X\n\ngoal (1 subgoal):\n 1. \\<not> restrict A zJ \\<notin> X \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  restrict A zJ \\<in> X", "have \"restrict A zJ \\<in> Set.image (restrict J) (Set.filter (isSameIntersection zI (I \\<inter> AA)) XX)\""], ["proof (prove)\nusing this:\n  restrict A zJ \\<in> X\n\ngoal (1 subgoal):\n 1. restrict A zJ\n    \\<in> restrict J ` Set.filter (isSameIntersection zI (I \\<inter> AA)) XX", "by (metis projectTable.simps semiJoin.simps \\<open>(A, X) = projectTable J (semiJoin (AA, XX) (I, zI))\\<close>\n            inf_commute snd_conv)"], ["proof (state)\nthis:\n  restrict A zJ\n  \\<in> restrict J ` Set.filter (isSameIntersection zI (I \\<inter> AA)) XX\n\ngoal (1 subgoal):\n 1. \\<not> restrict A zJ \\<notin> X \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  restrict A zJ\n  \\<in> restrict J ` Set.filter (isSameIntersection zI (I \\<inter> AA)) XX", "obtain zz where \"restrict A zJ = restrict J zz\" and \"zz \\<in> (Set.filter (isSameIntersection zI (I \\<inter> AA)) XX)\""], ["proof (prove)\nusing this:\n  restrict A zJ\n  \\<in> restrict J ` Set.filter (isSameIntersection zI (I \\<inter> AA)) XX\n\ngoal (1 subgoal):\n 1. (\\<And>zz.\n        \\<lbrakk>restrict A zJ = restrict J zz;\n         zz \\<in> Set.filter (isSameIntersection zI (I \\<inter> AA))\n                   XX\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  restrict A zJ = restrict J zz\n  zz \\<in> Set.filter (isSameIntersection zI (I \\<inter> AA)) XX\n\ngoal (1 subgoal):\n 1. \\<not> restrict A zJ \\<notin> X \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  restrict A zJ = restrict J zz\n  zz \\<in> Set.filter (isSameIntersection zI (I \\<inter> AA)) XX\n\ngoal (1 subgoal):\n 1. \\<not> restrict A zJ \\<notin> X \\<Longrightarrow> False", "have \"restrict A zJ = restrict AA zJ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict A zJ = restrict AA zJ", "by (simp add: restrict_nested \\<open>A = AA \\<inter> J\\<close> zJ_def)"], ["proof (state)\nthis:\n  restrict A zJ = restrict AA zJ\n\ngoal (1 subgoal):\n 1. \\<not> restrict A zJ \\<notin> X \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  restrict A zJ = restrict AA zJ", "have \"restrict AA z = zz\""], ["proof (prove)\nusing this:\n  restrict A zJ = restrict AA zJ\n\ngoal (1 subgoal):\n 1. restrict AA z = zz", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. restrict A zJ = restrict AA zJ \\<Longrightarrow> restrict AA z = zz", "have \"restrict J (restrict AA zz) = restrict J (restrict AA z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict J (restrict AA zz) = restrict J (restrict AA z)", "by (metis (no_types, lifting) restrict_nested \\<open>restrict A zJ = restrict AA zJ\\<close>\n              calculation(1) inf_commute inf_left_idem zJ_def)"], ["proof (state)\nthis:\n  restrict J (restrict AA zz) = restrict J (restrict AA z)\n\ngoal (1 subgoal):\n 1. restrict A zJ = restrict AA zJ \\<Longrightarrow> restrict AA z = zz", "moreover"], ["proof (state)\nthis:\n  restrict J (restrict AA zz) = restrict J (restrict AA z)\n\ngoal (1 subgoal):\n 1. restrict A zJ = restrict AA zJ \\<Longrightarrow> restrict AA z = zz", "have \"isSameIntersection zI (I \\<inter> AA) zz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isSameIntersection zI (I \\<inter> AA) zz", "using \\<open>zz \\<in> Set.filter (isSameIntersection zI (I \\<inter> AA)) XX\\<close>"], ["proof (prove)\nusing this:\n  zz \\<in> Set.filter (isSameIntersection zI (I \\<inter> AA)) XX\n\ngoal (1 subgoal):\n 1. isSameIntersection zI (I \\<inter> AA) zz", "by auto"], ["proof (state)\nthis:\n  isSameIntersection zI (I \\<inter> AA) zz\n\ngoal (1 subgoal):\n 1. restrict A zJ = restrict AA zJ \\<Longrightarrow> restrict AA z = zz", "moreover"], ["proof (state)\nthis:\n  isSameIntersection zI (I \\<inter> AA) zz\n\ngoal (1 subgoal):\n 1. restrict A zJ = restrict AA zJ \\<Longrightarrow> restrict AA z = zz", "have \"wf_tuple n AA zz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple n AA zz", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_tuple n AA zz", "have \"rwf_query n V Q Qn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rwf_query n V Q Qn", "by (simp add: assms(16))"], ["proof (state)\nthis:\n  rwf_query n V Q Qn\n\ngoal (1 subgoal):\n 1. wf_tuple n AA zz", "moreover"], ["proof (state)\nthis:\n  rwf_query n V Q Qn\n\ngoal (1 subgoal):\n 1. wf_tuple n AA zz", "have \"(AA, XX) \\<in> Q \\<union> Qn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (AA, XX) \\<in> Q \\<union> Qn", "by (simp add: \\<open>(AA, XX) \\<in> Qn\\<close>)"], ["proof (state)\nthis:\n  (AA, XX) \\<in> Q \\<union> Qn\n\ngoal (1 subgoal):\n 1. wf_tuple n AA zz", "then"], ["proof (chain)\npicking this:\n  (AA, XX) \\<in> Q \\<union> Qn", "have \"wf_atable n (AA, XX)\""], ["proof (prove)\nusing this:\n  (AA, XX) \\<in> Q \\<union> Qn\n\ngoal (1 subgoal):\n 1. wf_atable n (AA, XX)", "using calculation rwf_query_def wf_query_def"], ["proof (prove)\nusing this:\n  (AA, XX) \\<in> Q \\<union> Qn\n  rwf_query n V Q Qn\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n  wf_query ?n ?V ?Q_pos ?Q_neg =\n  ((\\<forall>X\\<in>?Q_pos \\<union> ?Q_neg. wf_atable ?n X) \\<and>\n   wf_set ?n ?V \\<and> 1 \\<le> card ?Q_pos)\n\ngoal (1 subgoal):\n 1. wf_atable n (AA, XX)", "by blast"], ["proof (state)\nthis:\n  wf_atable n (AA, XX)\n\ngoal (1 subgoal):\n 1. wf_tuple n AA zz", "then"], ["proof (chain)\npicking this:\n  wf_atable n (AA, XX)", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_atable n (AA, XX)\n\ngoal (1 subgoal):\n 1. wf_tuple n AA zz", "using \\<open>zz \\<in> Set.filter (isSameIntersection zI (I \\<inter> AA)) XX\\<close> table_def wf_atable_def"], ["proof (prove)\nusing this:\n  wf_atable n (AA, XX)\n  zz \\<in> Set.filter (isSameIntersection zI (I \\<inter> AA)) XX\n  table ?n ?V ?X = (\\<forall>x\\<in>?X. wf_tuple ?n ?V x)\n  wf_atable ?n ?X = (table ?n (fst ?X) (snd ?X) \\<and> finite (fst ?X))\n\ngoal (1 subgoal):\n 1. wf_tuple n AA zz", "by fastforce"], ["proof (state)\nthis:\n  wf_tuple n AA zz\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf_tuple n AA zz\n\ngoal (1 subgoal):\n 1. restrict A zJ = restrict AA zJ \\<Longrightarrow> restrict AA z = zz", "moreover"], ["proof (state)\nthis:\n  wf_tuple n AA zz\n\ngoal (1 subgoal):\n 1. restrict A zJ = restrict AA zJ \\<Longrightarrow> restrict AA z = zz", "have \"restrict AA zz = zz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict AA zz = zz", "using calculation(3) restrict_idle"], ["proof (prove)\nusing this:\n  wf_tuple n AA zz\n  wf_tuple ?n ?A ?v \\<Longrightarrow> restrict ?A ?v = ?v\n\ngoal (1 subgoal):\n 1. restrict AA zz = zz", "by blast"], ["proof (state)\nthis:\n  restrict AA zz = zz\n\ngoal (1 subgoal):\n 1. restrict A zJ = restrict AA zJ \\<Longrightarrow> restrict AA z = zz", "moreover"], ["proof (state)\nthis:\n  restrict AA zz = zz\n\ngoal (1 subgoal):\n 1. restrict A zJ = restrict AA zJ \\<Longrightarrow> restrict AA z = zz", "have \"AA \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AA \\<subseteq> V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. AA \\<subseteq> V", "have \"included V Qn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. included V Qn", "using assms(16) rwf_query_def"], ["proof (prove)\nusing this:\n  rwf_query n V Q Qn\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n\ngoal (1 subgoal):\n 1. included V Qn", "by blast"], ["proof (state)\nthis:\n  included V Qn\n\ngoal (1 subgoal):\n 1. AA \\<subseteq> V", "then"], ["proof (chain)\npicking this:\n  included V Qn", "show ?thesis"], ["proof (prove)\nusing this:\n  included V Qn\n\ngoal (1 subgoal):\n 1. AA \\<subseteq> V", "using \\<open>(AA, XX) \\<in> Qn\\<close> included_def"], ["proof (prove)\nusing this:\n  included V Qn\n  (AA, XX) \\<in> Qn\n  included ?V ?Q = (\\<forall>(S, X)\\<in>?Q. S \\<subseteq> ?V)\n\ngoal (1 subgoal):\n 1. AA \\<subseteq> V", "by fastforce"], ["proof (state)\nthis:\n  AA \\<subseteq> V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  AA \\<subseteq> V\n\ngoal (1 subgoal):\n 1. restrict A zJ = restrict AA zJ \\<Longrightarrow> restrict AA z = zz", "moreover"], ["proof (state)\nthis:\n  AA \\<subseteq> V\n\ngoal (1 subgoal):\n 1. restrict A zJ = restrict AA zJ \\<Longrightarrow> restrict AA z = zz", "have \"wf_set n V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_set n V", "using assms(16) rwf_query_def wf_query_def"], ["proof (prove)\nusing this:\n  rwf_query n V Q Qn\n  rwf_query ?n ?V ?Qp ?Qn =\n  (wf_query ?n ?V ?Qp ?Qn \\<and>\n   covering ?V ?Qp \\<and>\n   included ?V ?Qp \\<and>\n   included ?V ?Qn \\<and> non_empty_query ?Qp \\<and> non_empty_query ?Qn)\n  wf_query ?n ?V ?Q_pos ?Q_neg =\n  ((\\<forall>X\\<in>?Q_pos \\<union> ?Q_neg. wf_atable ?n X) \\<and>\n   wf_set ?n ?V \\<and> 1 \\<le> card ?Q_pos)\n\ngoal (1 subgoal):\n 1. wf_set n V", "by blast"], ["proof (state)\nthis:\n  wf_set n V\n\ngoal (1 subgoal):\n 1. restrict A zJ = restrict AA zJ \\<Longrightarrow> restrict AA z = zz", "moreover"], ["proof (state)\nthis:\n  wf_set n V\n\ngoal (1 subgoal):\n 1. restrict A zJ = restrict AA zJ \\<Longrightarrow> restrict AA z = zz", "have \"restrict (I \\<inter> AA) zz = restrict (I \\<inter> AA) zI\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict (I \\<inter> AA) zz = restrict (I \\<inter> AA) zI", "using isSame_equi_dev[of n V AA zz V z \"I \\<inter> AA\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_set n V; wf_tuple n AA zz; wf_tuple n V z;\n   I \\<inter> AA \\<subseteq> AA; I \\<inter> AA \\<subseteq> V;\n   AA \\<subseteq> V; V \\<subseteq> V\\<rbrakk>\n  \\<Longrightarrow> isSameIntersection zz (I \\<inter> AA) z =\n                    (restrict (I \\<inter> AA) zz =\n                     restrict (I \\<inter> AA) z)\n\ngoal (1 subgoal):\n 1. restrict (I \\<inter> AA) zz = restrict (I \\<inter> AA) zI", "by (metis (mono_tags, lifting) isSame_equi_dev \\<open>wf_tuple n I zI\\<close> assms(1)\n              calculation(2) calculation(3) calculation(5) calculation(6) inf_le1 inf_le2 sup_ge1)"], ["proof (state)\nthis:\n  restrict (I \\<inter> AA) zz = restrict (I \\<inter> AA) zI\n\ngoal (1 subgoal):\n 1. restrict A zJ = restrict AA zJ \\<Longrightarrow> restrict AA z = zz", "then"], ["proof (chain)\npicking this:\n  restrict (I \\<inter> AA) zz = restrict (I \\<inter> AA) zI", "have \"restrict I (restrict AA zz) = restrict I (restrict AA z)\""], ["proof (prove)\nusing this:\n  restrict (I \\<inter> AA) zz = restrict (I \\<inter> AA) zI\n\ngoal (1 subgoal):\n 1. restrict I (restrict AA zz) = restrict I (restrict AA z)", "by (metis (mono_tags, lifting) restrict_nested inf_le1 nested_include_restrict zI_def)"], ["proof (state)\nthis:\n  restrict I (restrict AA zz) = restrict I (restrict AA z)\n\ngoal (1 subgoal):\n 1. restrict A zJ = restrict AA zJ \\<Longrightarrow> restrict AA z = zz", "then"], ["proof (chain)\npicking this:\n  restrict I (restrict AA zz) = restrict I (restrict AA z)", "have \"restrict (I \\<union> J) (restrict AA z) = restrict (I \\<union> J) (restrict AA zz)\""], ["proof (prove)\nusing this:\n  restrict I (restrict AA zz) = restrict I (restrict AA z)\n\ngoal (1 subgoal):\n 1. restrict (I \\<union> J) (restrict AA z) =\n    restrict (I \\<union> J) (restrict AA zz)", "using union_restrict calculation(1)"], ["proof (prove)\nusing this:\n  restrict I (restrict AA zz) = restrict I (restrict AA z)\n  \\<lbrakk>restrict ?I ?z1.0 = restrict ?I ?z2.0;\n   restrict ?J ?z1.0 = restrict ?J ?z2.0\\<rbrakk>\n  \\<Longrightarrow> restrict (?I \\<union> ?J) ?z1.0 =\n                    restrict (?I \\<union> ?J) ?z2.0\n  restrict J (restrict AA zz) = restrict J (restrict AA z)\n\ngoal (1 subgoal):\n 1. restrict (I \\<union> J) (restrict AA z) =\n    restrict (I \\<union> J) (restrict AA zz)", "by fastforce"], ["proof (state)\nthis:\n  restrict (I \\<union> J) (restrict AA z) =\n  restrict (I \\<union> J) (restrict AA zz)\n\ngoal (1 subgoal):\n 1. restrict A zJ = restrict AA zJ \\<Longrightarrow> restrict AA z = zz", "moreover"], ["proof (state)\nthis:\n  restrict (I \\<union> J) (restrict AA z) =\n  restrict (I \\<union> J) (restrict AA zz)\n\ngoal (1 subgoal):\n 1. restrict A zJ = restrict AA zJ \\<Longrightarrow> restrict AA z = zz", "have \"AA \\<subseteq> I \\<union> J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AA \\<subseteq> I \\<union> J", "by (metis \\<open>(AA, XX) \\<in> Qn\\<close> assms(1) assms(16) case_prodD included_def rwf_query_def)"], ["proof (state)\nthis:\n  AA \\<subseteq> I \\<union> J\n\ngoal (1 subgoal):\n 1. restrict A zJ = restrict AA zJ \\<Longrightarrow> restrict AA z = zz", "then"], ["proof (chain)\npicking this:\n  AA \\<subseteq> I \\<union> J", "show ?thesis"], ["proof (prove)\nusing this:\n  AA \\<subseteq> I \\<union> J\n\ngoal (1 subgoal):\n 1. restrict AA z = zz", "by (metis restrict_nested calculation(4) calculation(7) inf.absorb_iff2)"], ["proof (state)\nthis:\n  restrict AA z = zz\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict AA z = zz\n\ngoal (1 subgoal):\n 1. \\<not> restrict A zJ \\<notin> X \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  restrict AA z = zz", "show \"False\""], ["proof (prove)\nusing this:\n  restrict AA z = zz\n\ngoal (1 subgoal):\n 1. False", "using \\<open>restrict AA z \\<notin> XX\\<close> calculation(2)"], ["proof (prove)\nusing this:\n  restrict AA z = zz\n  restrict AA z \\<notin> XX\n  zz \\<in> Set.filter (isSameIntersection zI (I \\<inter> AA)) XX\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict A zJ \\<notin> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?A, ?X) \\<in> newQuery J Q_J_neg (I, zI) \\<Longrightarrow>\n  restrict ?A zJ \\<notin> ?X\n\ngoal (1 subgoal):\n 1. z \\<in> R", "then"], ["proof (chain)\npicking this:\n  (?A, ?X) \\<in> newQuery J Q_J_neg (I, zI) \\<Longrightarrow>\n  restrict ?A zJ \\<notin> ?X", "have \"zJ \\<in> genericJoin J (newQuery J Q_J_pos (I, zI)) (newQuery J Q_J_neg (I, zI))\""], ["proof (prove)\nusing this:\n  (?A, ?X) \\<in> newQuery J Q_J_neg (I, zI) \\<Longrightarrow>\n  restrict ?A zJ \\<notin> ?X\n\ngoal (1 subgoal):\n 1. zJ \\<in> genericJoin J (newQuery J Q_J_pos (I, zI))\n              (newQuery J Q_J_neg (I, zI))", "using \\<open>wf_tuple n J zJ\\<close> calculation(3) calculation(4)"], ["proof (prove)\nusing this:\n  (?A, ?X) \\<in> newQuery J Q_J_neg (I, zI) \\<Longrightarrow>\n  restrict ?A zJ \\<notin> ?X\n  wf_tuple n J zJ\n  (zJ \\<in> genericJoin J (newQuery J Q_J_pos (I, zI))\n             (newQuery J Q_J_neg (I, zI))) =\n  (wf_tuple n J zJ \\<and>\n   (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, zI).\n       restrict A zJ \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, zI).\n       restrict A zJ \\<notin> X))\n  \\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, zI). restrict A zJ \\<in> X\n\ngoal (1 subgoal):\n 1. zJ \\<in> genericJoin J (newQuery J Q_J_pos (I, zI))\n              (newQuery J Q_J_neg (I, zI))", "by blast"], ["proof (state)\nthis:\n  zJ \\<in> genericJoin J (newQuery J Q_J_pos (I, zI))\n            (newQuery J Q_J_neg (I, zI))\n\ngoal (1 subgoal):\n 1. z \\<in> R", "have \"z = merge zJ zI\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z = merge zJ zI", "using restrict_partition_merge assms(1) assms(15) assms(2) zI_def zJ_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?I \\<union> ?J = ?V; wf_tuple ?n ?V ?z; ?xx = restrict ?J ?z;\n   ?t = restrict ?I ?z; Set.is_empty (?I \\<inter> ?J)\\<rbrakk>\n  \\<Longrightarrow> ?z = merge ?xx ?t\n  V = I \\<union> J\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\n  Set.is_empty (I \\<inter> J)\n  zI = restrict I z\n  zJ = restrict J z\n\ngoal (1 subgoal):\n 1. z = merge zJ zI", "by fastforce"], ["proof (state)\nthis:\n  z = merge zJ zI\n\ngoal (1 subgoal):\n 1. z \\<in> R", "moreover"], ["proof (state)\nthis:\n  z = merge zJ zI\n\ngoal (1 subgoal):\n 1. z \\<in> R", "have \"(zI, genericJoin J (newQuery J Q_J_pos (I, zI)) (newQuery J Q_J_neg (I, zI))) \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (zI,\n     genericJoin J (newQuery J Q_J_pos (I, zI))\n      (newQuery J Q_J_neg (I, zI)))\n    \\<in> X", "using \\<open>zI \\<in> R_I\\<close> assms(10)"], ["proof (prove)\nusing this:\n  zI \\<in> R_I\n  X =\n  {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n        (newQuery J Q_J_neg (I, t))) |\n   t. t \\<in> R_I}\n\ngoal (1 subgoal):\n 1. (zI,\n     genericJoin J (newQuery J Q_J_pos (I, zI))\n      (newQuery J Q_J_neg (I, zI)))\n    \\<in> X", "by blast"], ["proof (state)\nthis:\n  (zI,\n   genericJoin J (newQuery J Q_J_pos (I, zI)) (newQuery J Q_J_neg (I, zI)))\n  \\<in> X\n\ngoal (1 subgoal):\n 1. z \\<in> R", "then"], ["proof (chain)\npicking this:\n  (zI,\n   genericJoin J (newQuery J Q_J_pos (I, zI)) (newQuery J Q_J_neg (I, zI)))\n  \\<in> X", "show ?thesis"], ["proof (prove)\nusing this:\n  (zI,\n   genericJoin J (newQuery J Q_J_pos (I, zI)) (newQuery J Q_J_neg (I, zI)))\n  \\<in> X\n\ngoal (1 subgoal):\n 1. z \\<in> R", "using \\<open>zJ \\<in> genericJoin J (newQuery J Q_J_pos (I, zI)) (newQuery J Q_J_neg (I, zI))\\<close> assms(11)\n      calculation(5)"], ["proof (prove)\nusing this:\n  (zI,\n   genericJoin J (newQuery J Q_J_pos (I, zI)) (newQuery J Q_J_neg (I, zI)))\n  \\<in> X\n  zJ \\<in> genericJoin J (newQuery J Q_J_pos (I, zI))\n            (newQuery J Q_J_neg (I, zI))\n  R = (\\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})\n  z = merge zJ zI\n\ngoal (1 subgoal):\n 1. z \\<in> R", "by blast"], ["proof (state)\nthis:\n  z \\<in> R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma obvious_forall:\n  assumes \"\\<forall>x\\<in>X. P x\"\n  assumes \"x\\<in>X\"\n  shows \"P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P x", "by (simp add: assms(1) assms(2))"], ["", "lemma correctness:\n  \"\\<lbrakk>rwf_query n V Q Qn; card V \\<ge> 1\\<rbrakk> \\<Longrightarrow> (z \\<in> genericJoin V Q Qn \\<longleftrightarrow> wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rwf_query n V Q Qn; 1 \\<le> card V\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                      (wf_tuple n V z \\<and>\n                       (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n                       (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))", "proof (induction V Q Qn arbitrary: z rule: genericJoin.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V Q_pos Q_neg z.\n       \\<lbrakk>\\<And>x xa y xb xc z.\n                   \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q_pos Q_neg V;\n                    (xa, y) = x;\n                    xb = projectQuery xa (filterQuery xa Q_pos);\n                    xc = filterQueryNeg xa Q_neg; rwf_query n xa xb xc;\n                    1 \\<le> card xa\\<rbrakk>\n                   \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                     (wf_tuple n xa z \\<and>\n(\\<forall>(A, y)\\<in>xb. restrict A z \\<in> y) \\<and>\n(\\<forall>(A, X)\\<in>xc. restrict A z \\<notin> X));\n        \\<And>x xa y xb xc xd xe xf xg xh z.\n           \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q_pos Q_neg V;\n            (xa, y) = x; xb = projectQuery xa (filterQuery xa Q_pos);\n            xc = filterQueryNeg xa Q_neg; xd = genericJoin xa xb xc;\n            xe = Q_neg - xc; xf = filterQuery y Q_pos;\n            rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n            1 \\<le> card y\\<rbrakk>\n           \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n (newQuery y xe (xa, xh))) =\n                             (wf_tuple n y z \\<and>\n                              (\\<forall>(A, y)\\<in>newQuery y xf (xa, xh).\n                                  restrict A z \\<in> y) \\<and>\n                              (\\<forall>(A, X)\\<in>newQuery y xe (xa, xh).\n                                  restrict A z \\<notin> X));\n        rwf_query n V Q_pos Q_neg; 1 \\<le> card V\\<rbrakk>\n       \\<Longrightarrow> (z \\<in> genericJoin V Q_pos Q_neg) =\n                         (wf_tuple n V z \\<and>\n                          (\\<forall>(A, y)\\<in>Q_pos.\n                              restrict A z \\<in> y) \\<and>\n                          (\\<forall>(A, X)\\<in>Q_neg.\n                              restrict A z \\<notin> X))", "case (1 V Q Qn)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> card V \\<le> 1; ?x = getIJ Q Qn V; (?xa, ?y) = ?x;\n   ?xb = projectQuery ?xa (filterQuery ?xa Q); ?xc = filterQueryNeg ?xa Qn;\n   rwf_query n ?xa ?xb ?xc; 1 \\<le> card ?xa\\<rbrakk>\n  \\<Longrightarrow> (?z \\<in> genericJoin ?xa ?xb ?xc) =\n                    (wf_tuple n ?xa ?z \\<and>\n                     (\\<forall>a\\<in>?xb.\n                         case a of\n                         (A, a) \\<Rightarrow> restrict A ?z \\<in> a) \\<and>\n                     (\\<forall>a\\<in>?xc.\n                         case a of\n                         (A, X) \\<Rightarrow> restrict A ?z \\<notin> X))\n  \\<lbrakk>\\<not> card V \\<le> 1; ?x = getIJ Q Qn V; (?xa, ?y) = ?x;\n   ?xb = projectQuery ?xa (filterQuery ?xa Q); ?xc = filterQueryNeg ?xa Qn;\n   ?xd = genericJoin ?xa ?xb ?xc; ?xe = Qn - ?xc; ?xf = filterQuery ?y Q;\n   rwf_query n ?y (newQuery ?y ?xf (?xa, ?xh)) (newQuery ?y ?xe (?xa, ?xh));\n   1 \\<le> card ?y\\<rbrakk>\n  \\<Longrightarrow> (?z \\<in> genericJoin ?y (newQuery ?y ?xf (?xa, ?xh))\n                               (newQuery ?y ?xe (?xa, ?xh))) =\n                    (wf_tuple n ?y ?z \\<and>\n                     (\\<forall>a\\<in>newQuery ?y ?xf (?xa, ?xh).\n                         case a of\n                         (A, a) \\<Rightarrow> restrict A ?z \\<in> a) \\<and>\n                     (\\<forall>a\\<in>newQuery ?y ?xe (?xa, ?xh).\n                         case a of\n                         (A, X) \\<Rightarrow> restrict A ?z \\<notin> X))\n  rwf_query n V Q Qn\n  1 \\<le> card V\n\ngoal (1 subgoal):\n 1. \\<And>V Q_pos Q_neg z.\n       \\<lbrakk>\\<And>x xa y xb xc z.\n                   \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q_pos Q_neg V;\n                    (xa, y) = x;\n                    xb = projectQuery xa (filterQuery xa Q_pos);\n                    xc = filterQueryNeg xa Q_neg; rwf_query n xa xb xc;\n                    1 \\<le> card xa\\<rbrakk>\n                   \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                     (wf_tuple n xa z \\<and>\n(\\<forall>(A, y)\\<in>xb. restrict A z \\<in> y) \\<and>\n(\\<forall>(A, X)\\<in>xc. restrict A z \\<notin> X));\n        \\<And>x xa y xb xc xd xe xf xg xh z.\n           \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q_pos Q_neg V;\n            (xa, y) = x; xb = projectQuery xa (filterQuery xa Q_pos);\n            xc = filterQueryNeg xa Q_neg; xd = genericJoin xa xb xc;\n            xe = Q_neg - xc; xf = filterQuery y Q_pos;\n            rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n            1 \\<le> card y\\<rbrakk>\n           \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n (newQuery y xe (xa, xh))) =\n                             (wf_tuple n y z \\<and>\n                              (\\<forall>(A, y)\\<in>newQuery y xf (xa, xh).\n                                  restrict A z \\<in> y) \\<and>\n                              (\\<forall>(A, X)\\<in>newQuery y xe (xa, xh).\n                                  restrict A z \\<notin> X));\n        rwf_query n V Q_pos Q_neg; 1 \\<le> card V\\<rbrakk>\n       \\<Longrightarrow> (z \\<in> genericJoin V Q_pos Q_neg) =\n                         (wf_tuple n V z \\<and>\n                          (\\<forall>(A, y)\\<in>Q_pos.\n                              restrict A z \\<in> y) \\<and>\n                          (\\<forall>(A, X)\\<in>Q_neg.\n                              restrict A z \\<notin> X))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<not> card V \\<le> 1; ?x = getIJ Q Qn V; (?xa, ?y) = ?x;\n   ?xb = projectQuery ?xa (filterQuery ?xa Q); ?xc = filterQueryNeg ?xa Qn;\n   rwf_query n ?xa ?xb ?xc; 1 \\<le> card ?xa\\<rbrakk>\n  \\<Longrightarrow> (?z \\<in> genericJoin ?xa ?xb ?xc) =\n                    (wf_tuple n ?xa ?z \\<and>\n                     (\\<forall>a\\<in>?xb.\n                         case a of\n                         (A, a) \\<Rightarrow> restrict A ?z \\<in> a) \\<and>\n                     (\\<forall>a\\<in>?xc.\n                         case a of\n                         (A, X) \\<Rightarrow> restrict A ?z \\<notin> X))\n  \\<lbrakk>\\<not> card V \\<le> 1; ?x = getIJ Q Qn V; (?xa, ?y) = ?x;\n   ?xb = projectQuery ?xa (filterQuery ?xa Q); ?xc = filterQueryNeg ?xa Qn;\n   ?xd = genericJoin ?xa ?xb ?xc; ?xe = Qn - ?xc; ?xf = filterQuery ?y Q;\n   rwf_query n ?y (newQuery ?y ?xf (?xa, ?xh)) (newQuery ?y ?xe (?xa, ?xh));\n   1 \\<le> card ?y\\<rbrakk>\n  \\<Longrightarrow> (?z \\<in> genericJoin ?y (newQuery ?y ?xf (?xa, ?xh))\n                               (newQuery ?y ?xe (?xa, ?xh))) =\n                    (wf_tuple n ?y ?z \\<and>\n                     (\\<forall>a\\<in>newQuery ?y ?xf (?xa, ?xh).\n                         case a of\n                         (A, a) \\<Rightarrow> restrict A ?z \\<in> a) \\<and>\n                     (\\<forall>a\\<in>newQuery ?y ?xe (?xa, ?xh).\n                         case a of\n                         (A, X) \\<Rightarrow> restrict A ?z \\<notin> X))\n  rwf_query n V Q Qn\n  1 \\<le> card V", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> card V \\<le> 1; ?x = getIJ Q Qn V; (?xa, ?y) = ?x;\n   ?xb = projectQuery ?xa (filterQuery ?xa Q); ?xc = filterQueryNeg ?xa Qn;\n   rwf_query n ?xa ?xb ?xc; 1 \\<le> card ?xa\\<rbrakk>\n  \\<Longrightarrow> (?z \\<in> genericJoin ?xa ?xb ?xc) =\n                    (wf_tuple n ?xa ?z \\<and>\n                     (\\<forall>a\\<in>?xb.\n                         case a of\n                         (A, a) \\<Rightarrow> restrict A ?z \\<in> a) \\<and>\n                     (\\<forall>a\\<in>?xc.\n                         case a of\n                         (A, X) \\<Rightarrow> restrict A ?z \\<notin> X))\n  \\<lbrakk>\\<not> card V \\<le> 1; ?x = getIJ Q Qn V; (?xa, ?y) = ?x;\n   ?xb = projectQuery ?xa (filterQuery ?xa Q); ?xc = filterQueryNeg ?xa Qn;\n   ?xd = genericJoin ?xa ?xb ?xc; ?xe = Qn - ?xc; ?xf = filterQuery ?y Q;\n   rwf_query n ?y (newQuery ?y ?xf (?xa, ?xh)) (newQuery ?y ?xe (?xa, ?xh));\n   1 \\<le> card ?y\\<rbrakk>\n  \\<Longrightarrow> (?z \\<in> genericJoin ?y (newQuery ?y ?xf (?xa, ?xh))\n                               (newQuery ?y ?xe (?xa, ?xh))) =\n                    (wf_tuple n ?y ?z \\<and>\n                     (\\<forall>a\\<in>newQuery ?y ?xf (?xa, ?xh).\n                         case a of\n                         (A, a) \\<Rightarrow> restrict A ?z \\<in> a) \\<and>\n                     (\\<forall>a\\<in>newQuery ?y ?xe (?xa, ?xh).\n                         case a of\n                         (A, X) \\<Rightarrow> restrict A ?z \\<notin> X))\n  rwf_query n V Q Qn\n  1 \\<le> card V\n\ngoal (1 subgoal):\n 1. (z \\<in> genericJoin V Q Qn) =\n    (wf_tuple n V z \\<and>\n     (\\<forall>a\\<in>Q.\n         case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n     (\\<forall>a\\<in>Qn.\n         case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "proof (cases \"card V \\<le> 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x xa y xb xc z.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                  (wf_tuple n xa z \\<and>\n                                   (\\<forall>a\\<in>xb.\n case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                                   (\\<forall>a\\<in>xc.\n case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X));\n     \\<And>x xa y xb xc xd xe xf xh z.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n                                    (newQuery y xe (xa, xh))) =\n                          (wf_tuple n y z \\<and>\n                           (\\<forall>a\\<in>newQuery y xf (xa, xh).\n                               case a of\n                               (A, a) \\<Rightarrow>\n                                 restrict A z \\<in> a) \\<and>\n                           (\\<forall>a\\<in>newQuery y xe (xa, xh).\n                               case a of\n                               (A, X) \\<Rightarrow>\n                                 restrict A z \\<notin> X));\n     rwf_query n V Q Qn; 1 \\<le> card V; card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                      (wf_tuple n V z \\<and>\n                       (\\<forall>a\\<in>Q.\n                           case a of\n                           (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                       (\\<forall>a\\<in>Qn.\n                           case a of\n                           (A, X) \\<Rightarrow> restrict A z \\<notin> X))\n 2. \\<lbrakk>\\<And>x xa y xb xc z.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                  (wf_tuple n xa z \\<and>\n                                   (\\<forall>a\\<in>xb.\n case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                                   (\\<forall>a\\<in>xc.\n case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X));\n     \\<And>x xa y xb xc xd xe xf xh z.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n                                    (newQuery y xe (xa, xh))) =\n                          (wf_tuple n y z \\<and>\n                           (\\<forall>a\\<in>newQuery y xf (xa, xh).\n                               case a of\n                               (A, a) \\<Rightarrow>\n                                 restrict A z \\<in> a) \\<and>\n                           (\\<forall>a\\<in>newQuery y xe (xa, xh).\n                               case a of\n                               (A, X) \\<Rightarrow>\n                                 restrict A z \\<notin> X));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                      (wf_tuple n V z \\<and>\n                       (\\<forall>a\\<in>Q.\n                           case a of\n                           (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                       (\\<forall>a\\<in>Qn.\n                           case a of\n                           (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "case True"], ["proof (state)\nthis:\n  card V \\<le> 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x xa y xb xc z.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                  (wf_tuple n xa z \\<and>\n                                   (\\<forall>a\\<in>xb.\n case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                                   (\\<forall>a\\<in>xc.\n case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X));\n     \\<And>x xa y xb xc xd xe xf xh z.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n                                    (newQuery y xe (xa, xh))) =\n                          (wf_tuple n y z \\<and>\n                           (\\<forall>a\\<in>newQuery y xf (xa, xh).\n                               case a of\n                               (A, a) \\<Rightarrow>\n                                 restrict A z \\<in> a) \\<and>\n                           (\\<forall>a\\<in>newQuery y xe (xa, xh).\n                               case a of\n                               (A, X) \\<Rightarrow>\n                                 restrict A z \\<notin> X));\n     rwf_query n V Q Qn; 1 \\<le> card V; card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                      (wf_tuple n V z \\<and>\n                       (\\<forall>a\\<in>Q.\n                           case a of\n                           (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                       (\\<forall>a\\<in>Qn.\n                           case a of\n                           (A, X) \\<Rightarrow> restrict A z \\<notin> X))\n 2. \\<lbrakk>\\<And>x xa y xb xc z.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                  (wf_tuple n xa z \\<and>\n                                   (\\<forall>a\\<in>xb.\n case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                                   (\\<forall>a\\<in>xc.\n case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X));\n     \\<And>x xa y xb xc xd xe xf xh z.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n                                    (newQuery y xe (xa, xh))) =\n                          (wf_tuple n y z \\<and>\n                           (\\<forall>a\\<in>newQuery y xf (xa, xh).\n                               case a of\n                               (A, a) \\<Rightarrow>\n                                 restrict A z \\<in> a) \\<and>\n                           (\\<forall>a\\<in>newQuery y xe (xa, xh).\n                               case a of\n                               (A, X) \\<Rightarrow>\n                                 restrict A z \\<notin> X));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                      (wf_tuple n V z \\<and>\n                       (\\<forall>a\\<in>Q.\n                           case a of\n                           (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                       (\\<forall>a\\<in>Qn.\n                           case a of\n                           (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "have \"card V = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card V = 1", "using \"1.prems\"(2) True le_antisym"], ["proof (prove)\nusing this:\n  1 \\<le> card V\n  card V \\<le> 1\n  \\<lbrakk>?m \\<le> ?n; ?n \\<le> ?m\\<rbrakk> \\<Longrightarrow> ?m = ?n\n\ngoal (1 subgoal):\n 1. card V = 1", "by blast"], ["proof (state)\nthis:\n  card V = 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x xa y xb xc z.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                  (wf_tuple n xa z \\<and>\n                                   (\\<forall>a\\<in>xb.\n case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                                   (\\<forall>a\\<in>xc.\n case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X));\n     \\<And>x xa y xb xc xd xe xf xh z.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n                                    (newQuery y xe (xa, xh))) =\n                          (wf_tuple n y z \\<and>\n                           (\\<forall>a\\<in>newQuery y xf (xa, xh).\n                               case a of\n                               (A, a) \\<Rightarrow>\n                                 restrict A z \\<in> a) \\<and>\n                           (\\<forall>a\\<in>newQuery y xe (xa, xh).\n                               case a of\n                               (A, X) \\<Rightarrow>\n                                 restrict A z \\<notin> X));\n     rwf_query n V Q Qn; 1 \\<le> card V; card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                      (wf_tuple n V z \\<and>\n                       (\\<forall>a\\<in>Q.\n                           case a of\n                           (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                       (\\<forall>a\\<in>Qn.\n                           case a of\n                           (A, X) \\<Rightarrow> restrict A z \\<notin> X))\n 2. \\<lbrakk>\\<And>x xa y xb xc z.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                  (wf_tuple n xa z \\<and>\n                                   (\\<forall>a\\<in>xb.\n case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                                   (\\<forall>a\\<in>xc.\n case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X));\n     \\<And>x xa y xb xc xd xe xf xh z.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n                                    (newQuery y xe (xa, xh))) =\n                          (wf_tuple n y z \\<and>\n                           (\\<forall>a\\<in>newQuery y xf (xa, xh).\n                               case a of\n                               (A, a) \\<Rightarrow>\n                                 restrict A z \\<in> a) \\<and>\n                           (\\<forall>a\\<in>newQuery y xe (xa, xh).\n                               case a of\n                               (A, X) \\<Rightarrow>\n                                 restrict A z \\<notin> X));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                      (wf_tuple n V z \\<and>\n                       (\\<forall>a\\<in>Q.\n                           case a of\n                           (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                       (\\<forall>a\\<in>Qn.\n                           case a of\n                           (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "then"], ["proof (chain)\npicking this:\n  card V = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  card V = 1\n\ngoal (1 subgoal):\n 1. (z \\<in> genericJoin V Q Qn) =\n    (wf_tuple n V z \\<and>\n     (\\<forall>a\\<in>Q.\n         case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n     (\\<forall>a\\<in>Qn.\n         case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "using base_correctness[of V n Q Qn \"genericJoin V Q Qn\" z]"], ["proof (prove)\nusing this:\n  card V = 1\n  \\<lbrakk>card V = 1; rwf_query n V Q Qn;\n   genericJoin V Q Qn = genericJoin V Q Qn\\<rbrakk>\n  \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                    (wf_tuple n V z \\<and>\n                     (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n                     (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))\n\ngoal (1 subgoal):\n 1. (z \\<in> genericJoin V Q Qn) =\n    (wf_tuple n V z \\<and>\n     (\\<forall>a\\<in>Q.\n         case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n     (\\<forall>a\\<in>Qn.\n         case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "using \"1.prems\"(1)"], ["proof (prove)\nusing this:\n  card V = 1\n  \\<lbrakk>card V = 1; rwf_query n V Q Qn;\n   genericJoin V Q Qn = genericJoin V Q Qn\\<rbrakk>\n  \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                    (wf_tuple n V z \\<and>\n                     (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n                     (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))\n  rwf_query n V Q Qn\n\ngoal (1 subgoal):\n 1. (z \\<in> genericJoin V Q Qn) =\n    (wf_tuple n V z \\<and>\n     (\\<forall>a\\<in>Q.\n         case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n     (\\<forall>a\\<in>Qn.\n         case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "by blast"], ["proof (state)\nthis:\n  (z \\<in> genericJoin V Q Qn) =\n  (wf_tuple n V z \\<and>\n   (\\<forall>a\\<in>Q.\n       case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n   (\\<forall>a\\<in>Qn.\n       case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc z.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                  (wf_tuple n xa z \\<and>\n                                   (\\<forall>a\\<in>xb.\n case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                                   (\\<forall>a\\<in>xc.\n case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X));\n     \\<And>x xa y xb xc xd xe xf xh z.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n                                    (newQuery y xe (xa, xh))) =\n                          (wf_tuple n y z \\<and>\n                           (\\<forall>a\\<in>newQuery y xf (xa, xh).\n                               case a of\n                               (A, a) \\<Rightarrow>\n                                 restrict A z \\<in> a) \\<and>\n                           (\\<forall>a\\<in>newQuery y xe (xa, xh).\n                               case a of\n                               (A, X) \\<Rightarrow>\n                                 restrict A z \\<notin> X));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                      (wf_tuple n V z \\<and>\n                       (\\<forall>a\\<in>Q.\n                           case a of\n                           (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                       (\\<forall>a\\<in>Qn.\n                           case a of\n                           (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc z.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                  (wf_tuple n xa z \\<and>\n                                   (\\<forall>a\\<in>xb.\n case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                                   (\\<forall>a\\<in>xc.\n case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X));\n     \\<And>x xa y xb xc xd xe xf xh z.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n                                    (newQuery y xe (xa, xh))) =\n                          (wf_tuple n y z \\<and>\n                           (\\<forall>a\\<in>newQuery y xf (xa, xh).\n                               case a of\n                               (A, a) \\<Rightarrow>\n                                 restrict A z \\<in> a) \\<and>\n                           (\\<forall>a\\<in>newQuery y xe (xa, xh).\n                               case a of\n                               (A, X) \\<Rightarrow>\n                                 restrict A z \\<notin> X));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                      (wf_tuple n V z \\<and>\n                       (\\<forall>a\\<in>Q.\n                           case a of\n                           (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                       (\\<forall>a\\<in>Qn.\n                           case a of\n                           (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "case False"], ["proof (state)\nthis:\n  \\<not> card V \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc z.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                  (wf_tuple n xa z \\<and>\n                                   (\\<forall>a\\<in>xb.\n case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                                   (\\<forall>a\\<in>xc.\n case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X));\n     \\<And>x xa y xb xc xd xe xf xh z.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n                                    (newQuery y xe (xa, xh))) =\n                          (wf_tuple n y z \\<and>\n                           (\\<forall>a\\<in>newQuery y xf (xa, xh).\n                               case a of\n                               (A, a) \\<Rightarrow>\n                                 restrict A z \\<in> a) \\<and>\n                           (\\<forall>a\\<in>newQuery y xe (xa, xh).\n                               case a of\n                               (A, X) \\<Rightarrow>\n                                 restrict A z \\<notin> X));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                      (wf_tuple n V z \\<and>\n                       (\\<forall>a\\<in>Q.\n                           case a of\n                           (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                       (\\<forall>a\\<in>Qn.\n                           case a of\n                           (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "obtain I J where \"(I, J) = getIJ Q Qn V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>I J.\n        (I, J) = getIJ Q Qn V \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis surj_pair)"], ["proof (state)\nthis:\n  (I, J) = getIJ Q Qn V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc z.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                  (wf_tuple n xa z \\<and>\n                                   (\\<forall>a\\<in>xb.\n case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                                   (\\<forall>a\\<in>xc.\n case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X));\n     \\<And>x xa y xb xc xd xe xf xh z.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n                                    (newQuery y xe (xa, xh))) =\n                          (wf_tuple n y z \\<and>\n                           (\\<forall>a\\<in>newQuery y xf (xa, xh).\n                               case a of\n                               (A, a) \\<Rightarrow>\n                                 restrict A z \\<in> a) \\<and>\n                           (\\<forall>a\\<in>newQuery y xe (xa, xh).\n                               case a of\n                               (A, X) \\<Rightarrow>\n                                 restrict A z \\<notin> X));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                      (wf_tuple n V z \\<and>\n                       (\\<forall>a\\<in>Q.\n                           case a of\n                           (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                       (\\<forall>a\\<in>Qn.\n                           case a of\n                           (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "define Q_I_pos where \"Q_I_pos = projectQuery I (filterQuery I Q)\""], ["proof (state)\nthis:\n  Q_I_pos = projectQuery I (filterQuery I Q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc z.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                  (wf_tuple n xa z \\<and>\n                                   (\\<forall>a\\<in>xb.\n case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                                   (\\<forall>a\\<in>xc.\n case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X));\n     \\<And>x xa y xb xc xd xe xf xh z.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n                                    (newQuery y xe (xa, xh))) =\n                          (wf_tuple n y z \\<and>\n                           (\\<forall>a\\<in>newQuery y xf (xa, xh).\n                               case a of\n                               (A, a) \\<Rightarrow>\n                                 restrict A z \\<in> a) \\<and>\n                           (\\<forall>a\\<in>newQuery y xe (xa, xh).\n                               case a of\n                               (A, X) \\<Rightarrow>\n                                 restrict A z \\<notin> X));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                      (wf_tuple n V z \\<and>\n                       (\\<forall>a\\<in>Q.\n                           case a of\n                           (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                       (\\<forall>a\\<in>Qn.\n                           case a of\n                           (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "define Q_I_neg where \"Q_I_neg = filterQueryNeg I Qn\""], ["proof (state)\nthis:\n  Q_I_neg = filterQueryNeg I Qn\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc z.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                  (wf_tuple n xa z \\<and>\n                                   (\\<forall>a\\<in>xb.\n case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                                   (\\<forall>a\\<in>xc.\n case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X));\n     \\<And>x xa y xb xc xd xe xf xh z.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n                                    (newQuery y xe (xa, xh))) =\n                          (wf_tuple n y z \\<and>\n                           (\\<forall>a\\<in>newQuery y xf (xa, xh).\n                               case a of\n                               (A, a) \\<Rightarrow>\n                                 restrict A z \\<in> a) \\<and>\n                           (\\<forall>a\\<in>newQuery y xe (xa, xh).\n                               case a of\n                               (A, X) \\<Rightarrow>\n                                 restrict A z \\<notin> X));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                      (wf_tuple n V z \\<and>\n                       (\\<forall>a\\<in>Q.\n                           case a of\n                           (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                       (\\<forall>a\\<in>Qn.\n                           case a of\n                           (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "define R_I where \"R_I = genericJoin I Q_I_pos Q_I_neg\""], ["proof (state)\nthis:\n  R_I = genericJoin I Q_I_pos Q_I_neg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc z.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                  (wf_tuple n xa z \\<and>\n                                   (\\<forall>a\\<in>xb.\n case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                                   (\\<forall>a\\<in>xc.\n case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X));\n     \\<And>x xa y xb xc xd xe xf xh z.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n                                    (newQuery y xe (xa, xh))) =\n                          (wf_tuple n y z \\<and>\n                           (\\<forall>a\\<in>newQuery y xf (xa, xh).\n                               case a of\n                               (A, a) \\<Rightarrow>\n                                 restrict A z \\<in> a) \\<and>\n                           (\\<forall>a\\<in>newQuery y xe (xa, xh).\n                               case a of\n                               (A, X) \\<Rightarrow>\n                                 restrict A z \\<notin> X));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                      (wf_tuple n V z \\<and>\n                       (\\<forall>a\\<in>Q.\n                           case a of\n                           (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                       (\\<forall>a\\<in>Qn.\n                           case a of\n                           (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "define Q_J_neg where \"Q_J_neg = filterQuery J (Qn - Q_I_neg)\""], ["proof (state)\nthis:\n  Q_J_neg = filterQuery J (Qn - Q_I_neg)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc z.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                  (wf_tuple n xa z \\<and>\n                                   (\\<forall>a\\<in>xb.\n case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                                   (\\<forall>a\\<in>xc.\n case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X));\n     \\<And>x xa y xb xc xd xe xf xh z.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n                                    (newQuery y xe (xa, xh))) =\n                          (wf_tuple n y z \\<and>\n                           (\\<forall>a\\<in>newQuery y xf (xa, xh).\n                               case a of\n                               (A, a) \\<Rightarrow>\n                                 restrict A z \\<in> a) \\<and>\n                           (\\<forall>a\\<in>newQuery y xe (xa, xh).\n                               case a of\n                               (A, X) \\<Rightarrow>\n                                 restrict A z \\<notin> X));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                      (wf_tuple n V z \\<and>\n                       (\\<forall>a\\<in>Q.\n                           case a of\n                           (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                       (\\<forall>a\\<in>Qn.\n                           case a of\n                           (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "define Q_J_pos where \"Q_J_pos = filterQuery J Q\""], ["proof (state)\nthis:\n  Q_J_pos = filterQuery J Q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc z.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                  (wf_tuple n xa z \\<and>\n                                   (\\<forall>a\\<in>xb.\n case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                                   (\\<forall>a\\<in>xc.\n case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X));\n     \\<And>x xa y xb xc xd xe xf xh z.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n                                    (newQuery y xe (xa, xh))) =\n                          (wf_tuple n y z \\<and>\n                           (\\<forall>a\\<in>newQuery y xf (xa, xh).\n                               case a of\n                               (A, a) \\<Rightarrow>\n                                 restrict A z \\<in> a) \\<and>\n                           (\\<forall>a\\<in>newQuery y xe (xa, xh).\n                               case a of\n                               (A, X) \\<Rightarrow>\n                                 restrict A z \\<notin> X));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                      (wf_tuple n V z \\<and>\n                       (\\<forall>a\\<in>Q.\n                           case a of\n                           (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                       (\\<forall>a\\<in>Qn.\n                           case a of\n                           (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "define X where \"X = {(t, genericJoin J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t))) | t . t \\<in> R_I}\""], ["proof (state)\nthis:\n  X =\n  {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n        (newQuery J Q_J_neg (I, t))) |\n   t. t \\<in> R_I}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc z.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                  (wf_tuple n xa z \\<and>\n                                   (\\<forall>a\\<in>xb.\n case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                                   (\\<forall>a\\<in>xc.\n case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X));\n     \\<And>x xa y xb xc xd xe xf xh z.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n                                    (newQuery y xe (xa, xh))) =\n                          (wf_tuple n y z \\<and>\n                           (\\<forall>a\\<in>newQuery y xf (xa, xh).\n                               case a of\n                               (A, a) \\<Rightarrow>\n                                 restrict A z \\<in> a) \\<and>\n                           (\\<forall>a\\<in>newQuery y xe (xa, xh).\n                               case a of\n                               (A, X) \\<Rightarrow>\n                                 restrict A z \\<notin> X));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                      (wf_tuple n V z \\<and>\n                       (\\<forall>a\\<in>Q.\n                           case a of\n                           (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                       (\\<forall>a\\<in>Qn.\n                           case a of\n                           (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "define R where \"R = (\\<Union>(t, x) \\<in> X. {merge xx t | xx . xx \\<in> x})\""], ["proof (state)\nthis:\n  R = (\\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc z.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                  (wf_tuple n xa z \\<and>\n                                   (\\<forall>a\\<in>xb.\n case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                                   (\\<forall>a\\<in>xc.\n case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X));\n     \\<And>x xa y xb xc xd xe xf xh z.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n                                    (newQuery y xe (xa, xh))) =\n                          (wf_tuple n y z \\<and>\n                           (\\<forall>a\\<in>newQuery y xf (xa, xh).\n                               case a of\n                               (A, a) \\<Rightarrow>\n                                 restrict A z \\<in> a) \\<and>\n                           (\\<forall>a\\<in>newQuery y xe (xa, xh).\n                               case a of\n                               (A, X) \\<Rightarrow>\n                                 restrict A z \\<notin> X));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                      (wf_tuple n V z \\<and>\n                       (\\<forall>a\\<in>Q.\n                           case a of\n                           (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                       (\\<forall>a\\<in>Qn.\n                           case a of\n                           (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "then"], ["proof (chain)\npicking this:\n  R = (\\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})", "have \"R = genericJoin V Q Qn\""], ["proof (prove)\nusing this:\n  R = (\\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})\n\ngoal (1 subgoal):\n 1. R = genericJoin V Q Qn", "using vars_genericJoin[of V I J Q Qn Q_I_pos Q_I_neg R_I Q_J_neg Q_J_pos X R]"], ["proof (prove)\nusing this:\n  R = (\\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})\n  \\<lbrakk>2 \\<le> card V; (I, J) = getIJ Q Qn V;\n   Q_I_pos = projectQuery I (filterQuery I Q);\n   Q_I_neg = filterQueryNeg I Qn; R_I = genericJoin I Q_I_pos Q_I_neg;\n   Q_J_neg = filterQuery J (Qn - Q_I_neg); Q_J_pos = filterQuery J Q;\n   X =\n   {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n         (newQuery J Q_J_neg (I, t))) |\n    t. t \\<in> R_I};\n   R = (\\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x});\n   rwf_query ?n V Q Qn\\<rbrakk>\n  \\<Longrightarrow> R = genericJoin V Q Qn\n\ngoal (1 subgoal):\n 1. R = genericJoin V Q Qn", "by (metis \"1.prems\"(1) False Q_I_neg_def Q_I_pos_def Q_J_neg_def Q_J_pos_def R_I_def Suc_1 X_def\n            \\<open>(I, J) = getIJ Q Qn V\\<close> not_less_eq_eq)"], ["proof (state)\nthis:\n  R = genericJoin V Q Qn\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc z.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                  (wf_tuple n xa z \\<and>\n                                   (\\<forall>a\\<in>xb.\n case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                                   (\\<forall>a\\<in>xc.\n case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X));\n     \\<And>x xa y xb xc xd xe xf xh z.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n                                    (newQuery y xe (xa, xh))) =\n                          (wf_tuple n y z \\<and>\n                           (\\<forall>a\\<in>newQuery y xf (xa, xh).\n                               case a of\n                               (A, a) \\<Rightarrow>\n                                 restrict A z \\<in> a) \\<and>\n                           (\\<forall>a\\<in>newQuery y xe (xa, xh).\n                               case a of\n                               (A, X) \\<Rightarrow>\n                                 restrict A z \\<notin> X));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                      (wf_tuple n V z \\<and>\n                       (\\<forall>a\\<in>Q.\n                           case a of\n                           (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                       (\\<forall>a\\<in>Qn.\n                           case a of\n                           (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "obtain \"rwf_query n I Q_I_pos Q_I_neg\" and \"card I \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>rwf_query n I Q_I_pos Q_I_neg; 1 \\<le> card I\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis \"1.prems\"(1) False Q_I_neg_def Q_I_pos_def Suc_1 \\<open>(I, J) = getIJ Q Qn V\\<close> getIJ.getIJProperties(1)\n            getIJ.wf_firstRecursiveCall getIJ_axioms not_less_eq_eq)"], ["proof (state)\nthis:\n  rwf_query n I Q_I_pos Q_I_neg\n  1 \\<le> card I\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc z.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                  (wf_tuple n xa z \\<and>\n                                   (\\<forall>a\\<in>xb.\n case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                                   (\\<forall>a\\<in>xc.\n case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X));\n     \\<And>x xa y xb xc xd xe xf xh z.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n                                    (newQuery y xe (xa, xh))) =\n                          (wf_tuple n y z \\<and>\n                           (\\<forall>a\\<in>newQuery y xf (xa, xh).\n                               case a of\n                               (A, a) \\<Rightarrow>\n                                 restrict A z \\<in> a) \\<and>\n                           (\\<forall>a\\<in>newQuery y xe (xa, xh).\n                               case a of\n                               (A, X) \\<Rightarrow>\n                                 restrict A z \\<notin> X));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                      (wf_tuple n V z \\<and>\n                       (\\<forall>a\\<in>Q.\n                           case a of\n                           (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                       (\\<forall>a\\<in>Qn.\n                           case a of\n                           (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "then"], ["proof (chain)\npicking this:\n  rwf_query n I Q_I_pos Q_I_neg\n  1 \\<le> card I", "have \"\\<forall>x. (x \\<in> R_I \\<longleftrightarrow>\n  wf_tuple n I x \\<and> (\\<forall>(A, X)\\<in>Q_I_pos. restrict A x \\<in> X)  \\<and> (\\<forall>(A, X)\\<in>Q_I_neg. restrict A x \\<notin> X))\""], ["proof (prove)\nusing this:\n  rwf_query n I Q_I_pos Q_I_neg\n  1 \\<le> card I\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (x \\<in> R_I) =\n       (wf_tuple n I x \\<and>\n        (\\<forall>(A, X)\\<in>Q_I_pos. restrict A x \\<in> X) \\<and>\n        (\\<forall>(A, X)\\<in>Q_I_neg. restrict A x \\<notin> X))", "using \"1.IH\"(1) False Q_I_neg_def Q_I_pos_def R_I_def \\<open>(I, J) = getIJ Q Qn V\\<close>"], ["proof (prove)\nusing this:\n  rwf_query n I Q_I_pos Q_I_neg\n  1 \\<le> card I\n  \\<lbrakk>\\<not> card V \\<le> 1; ?x = getIJ Q Qn V; (?xa, ?y) = ?x;\n   ?xb = projectQuery ?xa (filterQuery ?xa Q); ?xc = filterQueryNeg ?xa Qn;\n   rwf_query n ?xa ?xb ?xc; 1 \\<le> card ?xa\\<rbrakk>\n  \\<Longrightarrow> (?z \\<in> genericJoin ?xa ?xb ?xc) =\n                    (wf_tuple n ?xa ?z \\<and>\n                     (\\<forall>a\\<in>?xb.\n                         case a of\n                         (A, a) \\<Rightarrow> restrict A ?z \\<in> a) \\<and>\n                     (\\<forall>a\\<in>?xc.\n                         case a of\n                         (A, X) \\<Rightarrow> restrict A ?z \\<notin> X))\n  \\<not> card V \\<le> 1\n  Q_I_neg = filterQueryNeg I Qn\n  Q_I_pos = projectQuery I (filterQuery I Q)\n  R_I = genericJoin I Q_I_pos Q_I_neg\n  (I, J) = getIJ Q Qn V\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (x \\<in> R_I) =\n       (wf_tuple n I x \\<and>\n        (\\<forall>(A, X)\\<in>Q_I_pos. restrict A x \\<in> X) \\<and>\n        (\\<forall>(A, X)\\<in>Q_I_neg. restrict A x \\<notin> X))", "by auto"], ["proof (state)\nthis:\n  \\<forall>x.\n     (x \\<in> R_I) =\n     (wf_tuple n I x \\<and>\n      (\\<forall>(A, X)\\<in>Q_I_pos. restrict A x \\<in> X) \\<and>\n      (\\<forall>(A, X)\\<in>Q_I_neg. restrict A x \\<notin> X))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc z.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                  (wf_tuple n xa z \\<and>\n                                   (\\<forall>a\\<in>xb.\n case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                                   (\\<forall>a\\<in>xc.\n case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X));\n     \\<And>x xa y xb xc xd xe xf xh z.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n                                    (newQuery y xe (xa, xh))) =\n                          (wf_tuple n y z \\<and>\n                           (\\<forall>a\\<in>newQuery y xf (xa, xh).\n                               case a of\n                               (A, a) \\<Rightarrow>\n                                 restrict A z \\<in> a) \\<and>\n                           (\\<forall>a\\<in>newQuery y xe (xa, xh).\n                               case a of\n                               (A, X) \\<Rightarrow>\n                                 restrict A z \\<notin> X));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                      (wf_tuple n V z \\<and>\n                       (\\<forall>a\\<in>Q.\n                           case a of\n                           (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                       (\\<forall>a\\<in>Qn.\n                           case a of\n                           (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "moreover"], ["proof (state)\nthis:\n  \\<forall>x.\n     (x \\<in> R_I) =\n     (wf_tuple n I x \\<and>\n      (\\<forall>(A, X)\\<in>Q_I_pos. restrict A x \\<in> X) \\<and>\n      (\\<forall>(A, X)\\<in>Q_I_neg. restrict A x \\<notin> X))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc z.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                  (wf_tuple n xa z \\<and>\n                                   (\\<forall>a\\<in>xb.\n case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                                   (\\<forall>a\\<in>xc.\n case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X));\n     \\<And>x xa y xb xc xd xe xf xh z.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n                                    (newQuery y xe (xa, xh))) =\n                          (wf_tuple n y z \\<and>\n                           (\\<forall>a\\<in>newQuery y xf (xa, xh).\n                               case a of\n                               (A, a) \\<Rightarrow>\n                                 restrict A z \\<in> a) \\<and>\n                           (\\<forall>a\\<in>newQuery y xe (xa, xh).\n                               case a of\n                               (A, X) \\<Rightarrow>\n                                 restrict A z \\<notin> X));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                      (wf_tuple n V z \\<and>\n                       (\\<forall>a\\<in>Q.\n                           case a of\n                           (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                       (\\<forall>a\\<in>Qn.\n                           case a of\n                           (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "have \"\\<forall>t\\<in>R_I. (\\<forall>y. (y \\<in> genericJoin J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t)) \\<longleftrightarrow> wf_tuple n J y \\<and>\n  (\\<forall>(A, X)\\<in>(newQuery J Q_J_pos (I, t)). restrict A y \\<in> X) \\<and> (\\<forall>(A, X)\\<in>(newQuery J Q_J_neg (I, t)). restrict A y \\<notin> X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>R_I.\n       \\<forall>y.\n          (y \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                    (newQuery J Q_J_neg (I, t))) =\n          (wf_tuple n J y \\<and>\n           (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, t).\n               restrict A y \\<in> X) \\<and>\n           (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, t).\n               restrict A y \\<notin> X))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> R_I \\<Longrightarrow>\n       \\<forall>y.\n          (y \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                    (newQuery J Q_J_neg (I, t))) =\n          (wf_tuple n J y \\<and>\n           (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, t).\n               restrict A y \\<in> X) \\<and>\n           (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, t).\n               restrict A y \\<notin> X))", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> R_I \\<Longrightarrow>\n       \\<forall>y.\n          (y \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                    (newQuery J Q_J_neg (I, t))) =\n          (wf_tuple n J y \\<and>\n           (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, t).\n               restrict A y \\<in> X) \\<and>\n           (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, t).\n               restrict A y \\<notin> X))", "assume \"t \\<in> R_I\""], ["proof (state)\nthis:\n  t \\<in> R_I\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> R_I \\<Longrightarrow>\n       \\<forall>y.\n          (y \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                    (newQuery J Q_J_neg (I, t))) =\n          (wf_tuple n J y \\<and>\n           (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, t).\n               restrict A y \\<in> X) \\<and>\n           (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, t).\n               restrict A y \\<notin> X))", "have \"card J \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> card J", "by (metis False Suc_1 \\<open>(I, J) = getIJ Q Qn V\\<close> getIJProperties(2) le_SucE nat_le_linear)"], ["proof (state)\nthis:\n  1 \\<le> card J\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> R_I \\<Longrightarrow>\n       \\<forall>y.\n          (y \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                    (newQuery J Q_J_neg (I, t))) =\n          (wf_tuple n J y \\<and>\n           (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, t).\n               restrict A y \\<in> X) \\<and>\n           (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, t).\n               restrict A y \\<notin> X))", "moreover"], ["proof (state)\nthis:\n  1 \\<le> card J\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> R_I \\<Longrightarrow>\n       \\<forall>y.\n          (y \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                    (newQuery J Q_J_neg (I, t))) =\n          (wf_tuple n J y \\<and>\n           (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, t).\n               restrict A y \\<in> X) \\<and>\n           (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, t).\n               restrict A y \\<notin> X))", "have \"rwf_query n J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rwf_query n J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t))", "by (metis \"1.prems\"(1) Diff_subset False Q_J_neg_def Q_J_pos_def Suc_1 \\<open>(I, J) = getIJ Q Qn V\\<close>\n              getIJ.wf_secondRecursiveCalls getIJ_axioms not_less_eq_eq)"], ["proof (state)\nthis:\n  rwf_query n J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> R_I \\<Longrightarrow>\n       \\<forall>y.\n          (y \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                    (newQuery J Q_J_neg (I, t))) =\n          (wf_tuple n J y \\<and>\n           (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, t).\n               restrict A y \\<in> X) \\<and>\n           (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, t).\n               restrict A y \\<notin> X))", "define NQ_pos where \"NQ_pos = newQuery J Q_J_pos (I, t)\""], ["proof (state)\nthis:\n  NQ_pos = newQuery J Q_J_pos (I, t)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> R_I \\<Longrightarrow>\n       \\<forall>y.\n          (y \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                    (newQuery J Q_J_neg (I, t))) =\n          (wf_tuple n J y \\<and>\n           (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, t).\n               restrict A y \\<in> X) \\<and>\n           (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, t).\n               restrict A y \\<notin> X))", "define NQ_neg where \"NQ_neg = newQuery J Q_J_neg (I, t)\""], ["proof (state)\nthis:\n  NQ_neg = newQuery J Q_J_neg (I, t)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> R_I \\<Longrightarrow>\n       \\<forall>y.\n          (y \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                    (newQuery J Q_J_neg (I, t))) =\n          (wf_tuple n J y \\<and>\n           (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, t).\n               restrict A y \\<in> X) \\<and>\n           (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, t).\n               restrict A y \\<notin> X))", "have \"\\<And>y. y \\<in> genericJoin J NQ_pos NQ_neg \\<longleftrightarrow>\n  wf_tuple n J y \\<and> (\\<forall>(A, X)\\<in>NQ_pos. restrict A y \\<in> X) \\<and> (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       (y \\<in> genericJoin J NQ_pos NQ_neg) =\n       (wf_tuple n J y \\<and>\n        (\\<forall>(A, X)\\<in>NQ_pos. restrict A y \\<in> X) \\<and>\n        (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       (y \\<in> genericJoin J NQ_pos NQ_neg) =\n       (wf_tuple n J y \\<and>\n        (\\<forall>(A, X)\\<in>NQ_pos. restrict A y \\<in> X) \\<and>\n        (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X))", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       (y \\<in> genericJoin J NQ_pos NQ_neg) =\n       (wf_tuple n J y \\<and>\n        (\\<forall>(A, X)\\<in>NQ_pos. restrict A y \\<in> X) \\<and>\n        (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X))", "have \"rwf_query n J NQ_pos NQ_neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rwf_query n J NQ_pos NQ_neg", "using NQ_neg_def NQ_pos_def \\<open>rwf_query n J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t))\\<close>"], ["proof (prove)\nusing this:\n  NQ_neg = newQuery J Q_J_neg (I, t)\n  NQ_pos = newQuery J Q_J_pos (I, t)\n  rwf_query n J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t))\n\ngoal (1 subgoal):\n 1. rwf_query n J NQ_pos NQ_neg", "by blast"], ["proof (state)\nthis:\n  rwf_query n J NQ_pos NQ_neg\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       (y \\<in> genericJoin J NQ_pos NQ_neg) =\n       (wf_tuple n J y \\<and>\n        (\\<forall>(A, X)\\<in>NQ_pos. restrict A y \\<in> X) \\<and>\n        (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X))", "then"], ["proof (chain)\npicking this:\n  rwf_query n J NQ_pos NQ_neg", "show \"y \\<in> genericJoin J NQ_pos NQ_neg \\<longleftrightarrow>\n  wf_tuple n J y \\<and> (\\<forall>(A, X)\\<in>NQ_pos. restrict A y \\<in> X) \\<and> (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X)\""], ["proof (prove)\nusing this:\n  rwf_query n J NQ_pos NQ_neg\n\ngoal (1 subgoal):\n 1. (y \\<in> genericJoin J NQ_pos NQ_neg) =\n    (wf_tuple n J y \\<and>\n     (\\<forall>(A, X)\\<in>NQ_pos. restrict A y \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X))", "using \"1.IH\"(2)[of \"(I, J)\" I J Q_I_pos Q_I_neg R_I Q_J_neg Q_J_pos t y]"], ["proof (prove)\nusing this:\n  rwf_query n J NQ_pos NQ_neg\n  \\<lbrakk>\\<not> card V \\<le> 1; (I, J) = getIJ Q Qn V; (I, J) = (I, J);\n   Q_I_pos = projectQuery I (filterQuery I Q);\n   Q_I_neg = filterQueryNeg I Qn; R_I = genericJoin I Q_I_pos Q_I_neg;\n   Q_J_neg = Qn - Q_I_neg; Q_J_pos = filterQuery J Q;\n   rwf_query n J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t));\n   1 \\<le> card J\\<rbrakk>\n  \\<Longrightarrow> (y \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                              (newQuery J Q_J_neg (I, t))) =\n                    (wf_tuple n J y \\<and>\n                     (\\<forall>a\\<in>newQuery J Q_J_pos (I, t).\n                         case a of\n                         (A, a) \\<Rightarrow> restrict A y \\<in> a) \\<and>\n                     (\\<forall>a\\<in>newQuery J Q_J_neg (I, t).\n                         case a of\n                         (A, X) \\<Rightarrow> restrict A y \\<notin> X))\n\ngoal (1 subgoal):\n 1. (y \\<in> genericJoin J NQ_pos NQ_neg) =\n    (wf_tuple n J y \\<and>\n     (\\<forall>(A, X)\\<in>NQ_pos. restrict A y \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X))", "by (metis \"1.prems\"(1) False NQ_neg_def NQ_pos_def Q_I_neg_def Q_I_pos_def Q_J_neg_def\n                Q_J_pos_def R_I_def Suc_1 \\<open>(I, J) = getIJ Q Qn V\\<close> calculation filter_Q_J_neg_same not_less_eq_eq)"], ["proof (state)\nthis:\n  (y \\<in> genericJoin J NQ_pos NQ_neg) =\n  (wf_tuple n J y \\<and>\n   (\\<forall>(A, X)\\<in>NQ_pos. restrict A y \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?y \\<in> genericJoin J NQ_pos NQ_neg) =\n  (wf_tuple n J ?y \\<and>\n   (\\<forall>(A, X)\\<in>NQ_pos. restrict A ?y \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>NQ_neg. restrict A ?y \\<notin> X))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> R_I \\<Longrightarrow>\n       \\<forall>y.\n          (y \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                    (newQuery J Q_J_neg (I, t))) =\n          (wf_tuple n J y \\<and>\n           (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, t).\n               restrict A y \\<in> X) \\<and>\n           (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, t).\n               restrict A y \\<notin> X))", "then"], ["proof (chain)\npicking this:\n  (?y \\<in> genericJoin J NQ_pos NQ_neg) =\n  (wf_tuple n J ?y \\<and>\n   (\\<forall>(A, X)\\<in>NQ_pos. restrict A ?y \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>NQ_neg. restrict A ?y \\<notin> X))", "show \"\\<forall>y. (y \\<in> genericJoin J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t)) \\<longleftrightarrow> wf_tuple n J y \\<and>\n  (\\<forall>(A, X)\\<in>(newQuery J Q_J_pos (I, t)). restrict A y \\<in> X) \\<and> (\\<forall>(A, X)\\<in>(newQuery J Q_J_neg (I, t)). restrict A y \\<notin> X))\""], ["proof (prove)\nusing this:\n  (?y \\<in> genericJoin J NQ_pos NQ_neg) =\n  (wf_tuple n J ?y \\<and>\n   (\\<forall>(A, X)\\<in>NQ_pos. restrict A ?y \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>NQ_neg. restrict A ?y \\<notin> X))\n\ngoal (1 subgoal):\n 1. \\<forall>y.\n       (y \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                 (newQuery J Q_J_neg (I, t))) =\n       (wf_tuple n J y \\<and>\n        (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, t).\n            restrict A y \\<in> X) \\<and>\n        (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, t).\n            restrict A y \\<notin> X))", "using NQ_neg_def NQ_pos_def"], ["proof (prove)\nusing this:\n  (?y \\<in> genericJoin J NQ_pos NQ_neg) =\n  (wf_tuple n J ?y \\<and>\n   (\\<forall>(A, X)\\<in>NQ_pos. restrict A ?y \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>NQ_neg. restrict A ?y \\<notin> X))\n  NQ_neg = newQuery J Q_J_neg (I, t)\n  NQ_pos = newQuery J Q_J_pos (I, t)\n\ngoal (1 subgoal):\n 1. \\<forall>y.\n       (y \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                 (newQuery J Q_J_neg (I, t))) =\n       (wf_tuple n J y \\<and>\n        (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, t).\n            restrict A y \\<in> X) \\<and>\n        (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, t).\n            restrict A y \\<notin> X))", "by blast"], ["proof (state)\nthis:\n  \\<forall>y.\n     (y \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n               (newQuery J Q_J_neg (I, t))) =\n     (wf_tuple n J y \\<and>\n      (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, t).\n          restrict A y \\<in> X) \\<and>\n      (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, t).\n          restrict A y \\<notin> X))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>t\\<in>R_I.\n     \\<forall>y.\n        (y \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                  (newQuery J Q_J_neg (I, t))) =\n        (wf_tuple n J y \\<and>\n         (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, t).\n             restrict A y \\<in> X) \\<and>\n         (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, t).\n             restrict A y \\<notin> X))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc z.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                  (wf_tuple n xa z \\<and>\n                                   (\\<forall>a\\<in>xb.\n case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                                   (\\<forall>a\\<in>xc.\n case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X));\n     \\<And>x xa y xb xc xd xe xf xh z.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n                                    (newQuery y xe (xa, xh))) =\n                          (wf_tuple n y z \\<and>\n                           (\\<forall>a\\<in>newQuery y xf (xa, xh).\n                               case a of\n                               (A, a) \\<Rightarrow>\n                                 restrict A z \\<in> a) \\<and>\n                           (\\<forall>a\\<in>newQuery y xe (xa, xh).\n                               case a of\n                               (A, X) \\<Rightarrow>\n                                 restrict A z \\<notin> X));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                      (wf_tuple n V z \\<and>\n                       (\\<forall>a\\<in>Q.\n                           case a of\n                           (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                       (\\<forall>a\\<in>Qn.\n                           case a of\n                           (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "moreover"], ["proof (state)\nthis:\n  \\<forall>t\\<in>R_I.\n     \\<forall>y.\n        (y \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                  (newQuery J Q_J_neg (I, t))) =\n        (wf_tuple n J y \\<and>\n         (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, t).\n             restrict A y \\<in> X) \\<and>\n         (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, t).\n             restrict A y \\<notin> X))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc z.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                  (wf_tuple n xa z \\<and>\n                                   (\\<forall>a\\<in>xb.\n case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                                   (\\<forall>a\\<in>xc.\n case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X));\n     \\<And>x xa y xb xc xd xe xf xh z.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n                                    (newQuery y xe (xa, xh))) =\n                          (wf_tuple n y z \\<and>\n                           (\\<forall>a\\<in>newQuery y xf (xa, xh).\n                               case a of\n                               (A, a) \\<Rightarrow>\n                                 restrict A z \\<in> a) \\<and>\n                           (\\<forall>a\\<in>newQuery y xe (xa, xh).\n                               case a of\n                               (A, X) \\<Rightarrow>\n                                 restrict A z \\<notin> X));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                      (wf_tuple n V z \\<and>\n                       (\\<forall>a\\<in>Q.\n                           case a of\n                           (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                       (\\<forall>a\\<in>Qn.\n                           case a of\n                           (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "obtain \"V = I \\<union> J\" \"Set.is_empty (I \\<inter> J)\" \"card I \\<ge> 1\" \"card J \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>V = I \\<union> J; Set.is_empty (I \\<inter> J); 1 \\<le> card I;\n      1 \\<le> card J\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis False Set.is_empty_def Suc_1 \\<open>(I, J) = getIJ Q Qn V\\<close> coreProperties not_less_eq_eq)"], ["proof (state)\nthis:\n  V = I \\<union> J\n  Set.is_empty (I \\<inter> J)\n  1 \\<le> card I\n  1 \\<le> card J\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc z.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                  (wf_tuple n xa z \\<and>\n                                   (\\<forall>a\\<in>xb.\n case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                                   (\\<forall>a\\<in>xc.\n case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X));\n     \\<And>x xa y xb xc xd xe xf xh z.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n                                    (newQuery y xe (xa, xh))) =\n                          (wf_tuple n y z \\<and>\n                           (\\<forall>a\\<in>newQuery y xf (xa, xh).\n                               case a of\n                               (A, a) \\<Rightarrow>\n                                 restrict A z \\<in> a) \\<and>\n                           (\\<forall>a\\<in>newQuery y xe (xa, xh).\n                               case a of\n                               (A, X) \\<Rightarrow>\n                                 restrict A z \\<notin> X));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                      (wf_tuple n V z \\<and>\n                       (\\<forall>a\\<in>Q.\n                           case a of\n                           (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                       (\\<forall>a\\<in>Qn.\n                           case a of\n                           (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "moreover"], ["proof (state)\nthis:\n  V = I \\<union> J\n  Set.is_empty (I \\<inter> J)\n  1 \\<le> card I\n  1 \\<le> card J\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc z.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                  (wf_tuple n xa z \\<and>\n                                   (\\<forall>a\\<in>xb.\n case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                                   (\\<forall>a\\<in>xc.\n case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X));\n     \\<And>x xa y xb xc xd xe xf xh z.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n                                    (newQuery y xe (xa, xh))) =\n                          (wf_tuple n y z \\<and>\n                           (\\<forall>a\\<in>newQuery y xf (xa, xh).\n                               case a of\n                               (A, a) \\<Rightarrow>\n                                 restrict A z \\<in> a) \\<and>\n                           (\\<forall>a\\<in>newQuery y xe (xa, xh).\n                               case a of\n                               (A, X) \\<Rightarrow>\n                                 restrict A z \\<notin> X));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                      (wf_tuple n V z \\<and>\n                       (\\<forall>a\\<in>Q.\n                           case a of\n                           (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                       (\\<forall>a\\<in>Qn.\n                           case a of\n                           (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "have \"rwf_query n V Q Qn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rwf_query n V Q Qn", "by (simp add: \"1.prems\"(1))"], ["proof (state)\nthis:\n  rwf_query n V Q Qn\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xa y xb xc z.\n                \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V;\n                 (xa, y) = x; xb = projectQuery xa (filterQuery xa Q);\n                 xc = filterQueryNeg xa Qn; rwf_query n xa xb xc;\n                 1 \\<le> card xa\\<rbrakk>\n                \\<Longrightarrow> (z \\<in> genericJoin xa xb xc) =\n                                  (wf_tuple n xa z \\<and>\n                                   (\\<forall>a\\<in>xb.\n case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                                   (\\<forall>a\\<in>xc.\n case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X));\n     \\<And>x xa y xb xc xd xe xf xh z.\n        \\<lbrakk>\\<not> card V \\<le> 1; x = getIJ Q Qn V; (xa, y) = x;\n         xb = projectQuery xa (filterQuery xa Q); xc = filterQueryNeg xa Qn;\n         xd = genericJoin xa xb xc; xe = Qn - xc; xf = filterQuery y Q;\n         rwf_query n y (newQuery y xf (xa, xh)) (newQuery y xe (xa, xh));\n         1 \\<le> card y\\<rbrakk>\n        \\<Longrightarrow> (z \\<in> genericJoin y (newQuery y xf (xa, xh))\n                                    (newQuery y xe (xa, xh))) =\n                          (wf_tuple n y z \\<and>\n                           (\\<forall>a\\<in>newQuery y xf (xa, xh).\n                               case a of\n                               (A, a) \\<Rightarrow>\n                                 restrict A z \\<in> a) \\<and>\n                           (\\<forall>a\\<in>newQuery y xe (xa, xh).\n                               case a of\n                               (A, X) \\<Rightarrow>\n                                 restrict A z \\<notin> X));\n     rwf_query n V Q Qn; 1 \\<le> card V; \\<not> card V \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> genericJoin V Q Qn) =\n                      (wf_tuple n V z \\<and>\n                       (\\<forall>a\\<in>Q.\n                           case a of\n                           (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n                       (\\<forall>a\\<in>Qn.\n                           case a of\n                           (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "then"], ["proof (chain)\npicking this:\n  rwf_query n V Q Qn", "show ?thesis"], ["proof (prove)\nusing this:\n  rwf_query n V Q Qn\n\ngoal (1 subgoal):\n 1. (z \\<in> genericJoin V Q Qn) =\n    (wf_tuple n V z \\<and>\n     (\\<forall>a\\<in>Q.\n         case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n     (\\<forall>a\\<in>Qn.\n         case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rwf_query n V Q Qn \\<Longrightarrow>\n    (z \\<in> genericJoin V Q Qn) =\n    (wf_tuple n V z \\<and>\n     (\\<forall>a\\<in>Q.\n         case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n     (\\<forall>a\\<in>Qn.\n         case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "have \"z \\<in> genericJoin V Q Qn \\<Longrightarrow> wf_tuple n V z \\<and> (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> genericJoin V Q Qn \\<Longrightarrow>\n    wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<in> genericJoin V Q Qn \\<Longrightarrow>\n    wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. za__ \\<in> genericJoin V Q Qn \\<Longrightarrow>\n    wf_tuple n V za__ \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A za__ \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A za__ \\<notin> X)", "assume \"z \\<in> genericJoin V Q Qn\""], ["proof (state)\nthis:\n  z \\<in> genericJoin V Q Qn\n\ngoal (1 subgoal):\n 1. za__ \\<in> genericJoin V Q Qn \\<Longrightarrow>\n    wf_tuple n V za__ \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A za__ \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A za__ \\<notin> X)", "have \"z \\<in> (\\<Union>(t, x) \\<in> X. {merge xx t | xx . xx \\<in> x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> (\\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})", "using R_def \\<open>R = genericJoin V Q Qn\\<close> \\<open>z \\<in> genericJoin V Q Qn\\<close>"], ["proof (prove)\nusing this:\n  R = (\\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})\n  R = genericJoin V Q Qn\n  z \\<in> genericJoin V Q Qn\n\ngoal (1 subgoal):\n 1. z \\<in> (\\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})", "by blast"], ["proof (state)\nthis:\n  z \\<in> (\\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})\n\ngoal (1 subgoal):\n 1. za__ \\<in> genericJoin V Q Qn \\<Longrightarrow>\n    wf_tuple n V za__ \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A za__ \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A za__ \\<notin> X)", "obtain t R_NQ where \"z \\<in> {merge xx t | xx . xx \\<in> R_NQ}\" \"(t, R_NQ) \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t R_NQ.\n        \\<lbrakk>z \\<in> {merge xx t |xx. xx \\<in> R_NQ};\n         (t, R_NQ) \\<in> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>z \\<in> (\\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})\\<close>"], ["proof (prove)\nusing this:\n  z \\<in> (\\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})\n\ngoal (1 subgoal):\n 1. (\\<And>t R_NQ.\n        \\<lbrakk>z \\<in> {merge xx t |xx. xx \\<in> R_NQ};\n         (t, R_NQ) \\<in> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  z \\<in> {merge xx t |xx. xx \\<in> R_NQ}\n  (t, R_NQ) \\<in> X\n\ngoal (1 subgoal):\n 1. za__ \\<in> genericJoin V Q Qn \\<Longrightarrow>\n    wf_tuple n V za__ \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A za__ \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A za__ \\<notin> X)", "then"], ["proof (chain)\npicking this:\n  z \\<in> {merge xx t |xx. xx \\<in> R_NQ}\n  (t, R_NQ) \\<in> X", "have \"t \\<in> R_I\""], ["proof (prove)\nusing this:\n  z \\<in> {merge xx t |xx. xx \\<in> R_NQ}\n  (t, R_NQ) \\<in> X\n\ngoal (1 subgoal):\n 1. t \\<in> R_I", "using X_def"], ["proof (prove)\nusing this:\n  z \\<in> {merge xx t |xx. xx \\<in> R_NQ}\n  (t, R_NQ) \\<in> X\n  X =\n  {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n        (newQuery J Q_J_neg (I, t))) |\n   t. t \\<in> R_I}\n\ngoal (1 subgoal):\n 1. t \\<in> R_I", "by blast"], ["proof (state)\nthis:\n  t \\<in> R_I\n\ngoal (1 subgoal):\n 1. za__ \\<in> genericJoin V Q Qn \\<Longrightarrow>\n    wf_tuple n V za__ \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A za__ \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A za__ \\<notin> X)", "define NQ where \"NQ = newQuery J Q_J_pos (I, t)\""], ["proof (state)\nthis:\n  NQ = newQuery J Q_J_pos (I, t)\n\ngoal (1 subgoal):\n 1. za__ \\<in> genericJoin V Q Qn \\<Longrightarrow>\n    wf_tuple n V za__ \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A za__ \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A za__ \\<notin> X)", "define NQ_neg where \"NQ_neg = newQuery J Q_J_neg (I, t)\""], ["proof (state)\nthis:\n  NQ_neg = newQuery J Q_J_neg (I, t)\n\ngoal (1 subgoal):\n 1. za__ \\<in> genericJoin V Q Qn \\<Longrightarrow>\n    wf_tuple n V za__ \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A za__ \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A za__ \\<notin> X)", "have \"R_NQ = genericJoin J NQ NQ_neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R_NQ = genericJoin J NQ NQ_neg", "using NQ_def NQ_neg_def X_def \\<open>(t, R_NQ) \\<in> X\\<close>"], ["proof (prove)\nusing this:\n  NQ = newQuery J Q_J_pos (I, t)\n  NQ_neg = newQuery J Q_J_neg (I, t)\n  X =\n  {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n        (newQuery J Q_J_neg (I, t))) |\n   t. t \\<in> R_I}\n  (t, R_NQ) \\<in> X\n\ngoal (1 subgoal):\n 1. R_NQ = genericJoin J NQ NQ_neg", "by blast"], ["proof (state)\nthis:\n  R_NQ = genericJoin J NQ NQ_neg\n\ngoal (1 subgoal):\n 1. za__ \\<in> genericJoin V Q Qn \\<Longrightarrow>\n    wf_tuple n V za__ \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A za__ \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A za__ \\<notin> X)", "obtain xx where \"z = merge xx t\" \"xx \\<in> R_NQ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xx.\n        \\<lbrakk>z = merge xx t; xx \\<in> R_NQ\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>z \\<in> {merge xx t |xx. xx \\<in> R_NQ}\\<close>"], ["proof (prove)\nusing this:\n  z \\<in> {merge xx t |xx. xx \\<in> R_NQ}\n\ngoal (1 subgoal):\n 1. (\\<And>xx.\n        \\<lbrakk>z = merge xx t; xx \\<in> R_NQ\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  z = merge xx t\n  xx \\<in> R_NQ\n\ngoal (1 subgoal):\n 1. za__ \\<in> genericJoin V Q Qn \\<Longrightarrow>\n    wf_tuple n V za__ \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A za__ \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A za__ \\<notin> X)", "have \"\\<forall>y. (y \\<in> R_NQ \\<longleftrightarrow> wf_tuple n J y \\<and> (\\<forall>(A, X)\\<in>NQ. restrict A y \\<in> X) \\<and> (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y.\n       (y \\<in> R_NQ) =\n       (wf_tuple n J y \\<and>\n        (\\<forall>(A, X)\\<in>NQ. restrict A y \\<in> X) \\<and>\n        (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>y.\n       (y \\<in> R_NQ) =\n       (wf_tuple n J y \\<and>\n        (\\<forall>(A, X)\\<in>NQ. restrict A y \\<in> X) \\<and>\n        (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X))", "have \"\\<forall>tt\\<in>R_I. (\\<forall>x. (x \\<in> genericJoin J NQ NQ_neg\n                         \\<longleftrightarrow> wf_tuple n J x \\<and> (\\<forall>(A, X)\\<in>NQ. restrict A x \\<in> X) \\<and> (\\<forall>(A, X)\\<in>NQ_neg. restrict A x \\<notin> X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>tt\\<in>R_I.\n       \\<forall>x.\n          (x \\<in> genericJoin J NQ NQ_neg) =\n          (wf_tuple n J x \\<and>\n           (\\<forall>(A, X)\\<in>NQ. restrict A x \\<in> X) \\<and>\n           (\\<forall>(A, X)\\<in>NQ_neg. restrict A x \\<notin> X))", "using NQ_def NQ_neg_def \\<open>t \\<in> R_I\\<close> calculation(2)"], ["proof (prove)\nusing this:\n  NQ = newQuery J Q_J_pos (I, t)\n  NQ_neg = newQuery J Q_J_neg (I, t)\n  t \\<in> R_I\n  \\<forall>t\\<in>R_I.\n     \\<forall>y.\n        (y \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                  (newQuery J Q_J_neg (I, t))) =\n        (wf_tuple n J y \\<and>\n         (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, t).\n             restrict A y \\<in> X) \\<and>\n         (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, t).\n             restrict A y \\<notin> X))\n\ngoal (1 subgoal):\n 1. \\<forall>tt\\<in>R_I.\n       \\<forall>x.\n          (x \\<in> genericJoin J NQ NQ_neg) =\n          (wf_tuple n J x \\<and>\n           (\\<forall>(A, X)\\<in>NQ. restrict A x \\<in> X) \\<and>\n           (\\<forall>(A, X)\\<in>NQ_neg. restrict A x \\<notin> X))", "by auto"], ["proof (state)\nthis:\n  \\<forall>tt\\<in>R_I.\n     \\<forall>x.\n        (x \\<in> genericJoin J NQ NQ_neg) =\n        (wf_tuple n J x \\<and>\n         (\\<forall>(A, X)\\<in>NQ. restrict A x \\<in> X) \\<and>\n         (\\<forall>(A, X)\\<in>NQ_neg. restrict A x \\<notin> X))\n\ngoal (1 subgoal):\n 1. \\<forall>y.\n       (y \\<in> R_NQ) =\n       (wf_tuple n J y \\<and>\n        (\\<forall>(A, X)\\<in>NQ. restrict A y \\<in> X) \\<and>\n        (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X))", "moreover"], ["proof (state)\nthis:\n  \\<forall>tt\\<in>R_I.\n     \\<forall>x.\n        (x \\<in> genericJoin J NQ NQ_neg) =\n        (wf_tuple n J x \\<and>\n         (\\<forall>(A, X)\\<in>NQ. restrict A x \\<in> X) \\<and>\n         (\\<forall>(A, X)\\<in>NQ_neg. restrict A x \\<notin> X))\n\ngoal (1 subgoal):\n 1. \\<forall>y.\n       (y \\<in> R_NQ) =\n       (wf_tuple n J y \\<and>\n        (\\<forall>(A, X)\\<in>NQ. restrict A y \\<in> X) \\<and>\n        (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X))", "have \"t\\<in>R_I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> R_I", "by (simp add: \\<open>t \\<in> R_I\\<close>)"], ["proof (state)\nthis:\n  t \\<in> R_I\n\ngoal (1 subgoal):\n 1. \\<forall>y.\n       (y \\<in> R_NQ) =\n       (wf_tuple n J y \\<and>\n        (\\<forall>(A, X)\\<in>NQ. restrict A y \\<in> X) \\<and>\n        (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X))", "then"], ["proof (chain)\npicking this:\n  t \\<in> R_I", "have \"(\\<forall>x. (x \\<in> genericJoin J NQ NQ_neg\n                         \\<longleftrightarrow> wf_tuple n J x \\<and> (\\<forall>(A, X)\\<in>NQ. restrict A x \\<in> X) \\<and>  (\\<forall>(A, X)\\<in>NQ_neg. restrict A x \\<notin> X)))\""], ["proof (prove)\nusing this:\n  t \\<in> R_I\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (x \\<in> genericJoin J NQ NQ_neg) =\n       (wf_tuple n J x \\<and>\n        (\\<forall>(A, X)\\<in>NQ. restrict A x \\<in> X) \\<and>\n        (\\<forall>(A, X)\\<in>NQ_neg. restrict A x \\<notin> X))", "using obvious_forall[where ?x=t and ?X=R_I] calculation"], ["proof (prove)\nusing this:\n  t \\<in> R_I\n  \\<lbrakk>\\<forall>x\\<in>R_I. ?P x; t \\<in> R_I\\<rbrakk>\n  \\<Longrightarrow> ?P t\n  \\<forall>tt\\<in>R_I.\n     \\<forall>x.\n        (x \\<in> genericJoin J NQ NQ_neg) =\n        (wf_tuple n J x \\<and>\n         (\\<forall>(A, X)\\<in>NQ. restrict A x \\<in> X) \\<and>\n         (\\<forall>(A, X)\\<in>NQ_neg. restrict A x \\<notin> X))\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (x \\<in> genericJoin J NQ NQ_neg) =\n       (wf_tuple n J x \\<and>\n        (\\<forall>(A, X)\\<in>NQ. restrict A x \\<in> X) \\<and>\n        (\\<forall>(A, X)\\<in>NQ_neg. restrict A x \\<notin> X))", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>x.\n     (x \\<in> genericJoin J NQ NQ_neg) =\n     (wf_tuple n J x \\<and>\n      (\\<forall>(A, X)\\<in>NQ. restrict A x \\<in> X) \\<and>\n      (\\<forall>(A, X)\\<in>NQ_neg. restrict A x \\<notin> X))\n\ngoal (1 subgoal):\n 1. \\<forall>y.\n       (y \\<in> R_NQ) =\n       (wf_tuple n J y \\<and>\n        (\\<forall>(A, X)\\<in>NQ. restrict A y \\<in> X) \\<and>\n        (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X))", "then"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     (x \\<in> genericJoin J NQ NQ_neg) =\n     (wf_tuple n J x \\<and>\n      (\\<forall>(A, X)\\<in>NQ. restrict A x \\<in> X) \\<and>\n      (\\<forall>(A, X)\\<in>NQ_neg. restrict A x \\<notin> X))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     (x \\<in> genericJoin J NQ NQ_neg) =\n     (wf_tuple n J x \\<and>\n      (\\<forall>(A, X)\\<in>NQ. restrict A x \\<in> X) \\<and>\n      (\\<forall>(A, X)\\<in>NQ_neg. restrict A x \\<notin> X))\n\ngoal (1 subgoal):\n 1. \\<forall>y.\n       (y \\<in> R_NQ) =\n       (wf_tuple n J y \\<and>\n        (\\<forall>(A, X)\\<in>NQ. restrict A y \\<in> X) \\<and>\n        (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X))", "using \\<open>R_NQ = genericJoin J NQ NQ_neg\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     (x \\<in> genericJoin J NQ NQ_neg) =\n     (wf_tuple n J x \\<and>\n      (\\<forall>(A, X)\\<in>NQ. restrict A x \\<in> X) \\<and>\n      (\\<forall>(A, X)\\<in>NQ_neg. restrict A x \\<notin> X))\n  R_NQ = genericJoin J NQ NQ_neg\n\ngoal (1 subgoal):\n 1. \\<forall>y.\n       (y \\<in> R_NQ) =\n       (wf_tuple n J y \\<and>\n        (\\<forall>(A, X)\\<in>NQ. restrict A y \\<in> X) \\<and>\n        (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X))", "by blast"], ["proof (state)\nthis:\n  \\<forall>y.\n     (y \\<in> R_NQ) =\n     (wf_tuple n J y \\<and>\n      (\\<forall>(A, X)\\<in>NQ. restrict A y \\<in> X) \\<and>\n      (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>y.\n     (y \\<in> R_NQ) =\n     (wf_tuple n J y \\<and>\n      (\\<forall>(A, X)\\<in>NQ. restrict A y \\<in> X) \\<and>\n      (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X))\n\ngoal (1 subgoal):\n 1. za__ \\<in> genericJoin V Q Qn \\<Longrightarrow>\n    wf_tuple n V za__ \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A za__ \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A za__ \\<notin> X)", "show \"wf_tuple n V z \\<and> (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)", "using partial_correctness[of V I J Q_I_pos Q Q_J_pos Q_I_neg Qn Q_J_neg NQ t NQ_neg R_NQ R_I n z xx]"], ["proof (prove)\nusing this:\n  \\<lbrakk>V = I \\<union> J; Set.is_empty (I \\<inter> J); 1 \\<le> card I;\n   1 \\<le> card J; Q_I_pos = projectQuery I (filterQuery I Q);\n   Q_J_pos = filterQuery J Q; Q_I_neg = filterQueryNeg I Qn;\n   Q_J_neg = filterQuery J (Qn - Q_I_neg); NQ = newQuery J Q_J_pos (I, t);\n   NQ_neg = newQuery J Q_J_neg (I, t); R_NQ = genericJoin J NQ NQ_neg;\n   \\<forall>x.\n      (x \\<in> R_I) =\n      (wf_tuple n I x \\<and>\n       (\\<forall>(A, X)\\<in>Q_I_pos. restrict A x \\<in> X) \\<and>\n       (\\<forall>(A, X)\\<in>Q_I_neg. restrict A x \\<notin> X));\n   \\<forall>y.\n      (y \\<in> R_NQ) =\n      (wf_tuple n J y \\<and>\n       (\\<forall>(A, X)\\<in>NQ. restrict A y \\<in> X) \\<and>\n       (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X));\n   z = merge xx t; t \\<in> R_I; xx \\<in> R_NQ; rwf_query n V Q Qn\\<rbrakk>\n  \\<Longrightarrow> wf_tuple n V z \\<and>\n                    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n                    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\n\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)", "using \"1.prems\"(1) NQ_def NQ_neg_def Q_I_neg_def Q_I_pos_def Q_J_neg_def Q_J_pos_def\n              \\<open>R_NQ = genericJoin J NQ NQ_neg\\<close> \\<open>\\<forall>y. (y \\<in> R_NQ) = (wf_tuple n J y \\<and> (\\<forall>(A, X)\\<in>NQ. restrict A y \\<in> X) \\<and> (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X))\\<close>\n              \\<open>t \\<in> R_I\\<close> \\<open>xx \\<in> R_NQ\\<close> \\<open>z = merge xx t\\<close> calculation(1) calculation(3) calculation(4) calculation(5) calculation(6)"], ["proof (prove)\nusing this:\n  \\<lbrakk>V = I \\<union> J; Set.is_empty (I \\<inter> J); 1 \\<le> card I;\n   1 \\<le> card J; Q_I_pos = projectQuery I (filterQuery I Q);\n   Q_J_pos = filterQuery J Q; Q_I_neg = filterQueryNeg I Qn;\n   Q_J_neg = filterQuery J (Qn - Q_I_neg); NQ = newQuery J Q_J_pos (I, t);\n   NQ_neg = newQuery J Q_J_neg (I, t); R_NQ = genericJoin J NQ NQ_neg;\n   \\<forall>x.\n      (x \\<in> R_I) =\n      (wf_tuple n I x \\<and>\n       (\\<forall>(A, X)\\<in>Q_I_pos. restrict A x \\<in> X) \\<and>\n       (\\<forall>(A, X)\\<in>Q_I_neg. restrict A x \\<notin> X));\n   \\<forall>y.\n      (y \\<in> R_NQ) =\n      (wf_tuple n J y \\<and>\n       (\\<forall>(A, X)\\<in>NQ. restrict A y \\<in> X) \\<and>\n       (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X));\n   z = merge xx t; t \\<in> R_I; xx \\<in> R_NQ; rwf_query n V Q Qn\\<rbrakk>\n  \\<Longrightarrow> wf_tuple n V z \\<and>\n                    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n                    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\n  rwf_query n V Q Qn\n  NQ = newQuery J Q_J_pos (I, t)\n  NQ_neg = newQuery J Q_J_neg (I, t)\n  Q_I_neg = filterQueryNeg I Qn\n  Q_I_pos = projectQuery I (filterQuery I Q)\n  Q_J_neg = filterQuery J (Qn - Q_I_neg)\n  Q_J_pos = filterQuery J Q\n  R_NQ = genericJoin J NQ NQ_neg\n  \\<forall>y.\n     (y \\<in> R_NQ) =\n     (wf_tuple n J y \\<and>\n      (\\<forall>(A, X)\\<in>NQ. restrict A y \\<in> X) \\<and>\n      (\\<forall>(A, X)\\<in>NQ_neg. restrict A y \\<notin> X))\n  t \\<in> R_I\n  xx \\<in> R_NQ\n  z = merge xx t\n  \\<forall>x.\n     (x \\<in> R_I) =\n     (wf_tuple n I x \\<and>\n      (\\<forall>(A, X)\\<in>Q_I_pos. restrict A x \\<in> X) \\<and>\n      (\\<forall>(A, X)\\<in>Q_I_neg. restrict A x \\<notin> X))\n  V = I \\<union> J\n  Set.is_empty (I \\<inter> J)\n  1 \\<le> card I\n  1 \\<le> card J\n\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)", "by blast"], ["proof (state)\nthis:\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z \\<in> genericJoin V Q Qn \\<Longrightarrow>\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\n\ngoal (1 subgoal):\n 1. rwf_query n V Q Qn \\<Longrightarrow>\n    (z \\<in> genericJoin V Q Qn) =\n    (wf_tuple n V z \\<and>\n     (\\<forall>a\\<in>Q.\n         case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n     (\\<forall>a\\<in>Qn.\n         case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "moreover"], ["proof (state)\nthis:\n  z \\<in> genericJoin V Q Qn \\<Longrightarrow>\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\n\ngoal (1 subgoal):\n 1. rwf_query n V Q Qn \\<Longrightarrow>\n    (z \\<in> genericJoin V Q Qn) =\n    (wf_tuple n V z \\<and>\n     (\\<forall>a\\<in>Q.\n         case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n     (\\<forall>a\\<in>Qn.\n         case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "have \"wf_tuple n V z \\<and> (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X) \\<Longrightarrow> z \\<in> genericJoin V Q Qn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X) \\<Longrightarrow>\n    z \\<in> genericJoin V Q Qn", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_tuple n V z \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X) \\<Longrightarrow>\n    z \\<in> genericJoin V Q Qn", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_tuple n V za__ \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A za__ \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A za__ \\<notin> X) \\<Longrightarrow>\n    za__ \\<in> genericJoin V Q Qn", "assume \"wf_tuple n V z \\<and> (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\""], ["proof (state)\nthis:\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\n\ngoal (1 subgoal):\n 1. wf_tuple n V za__ \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A za__ \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A za__ \\<notin> X) \\<Longrightarrow>\n    za__ \\<in> genericJoin V Q Qn", "have \"z \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> R", "using partial_correctness_direct[of V I J Q_I_pos Q Q_J_pos Q_I_neg Qn Q_J_neg R_I X R\n                _ _ _ n z]\n            \"1.prems\"(1) Q_I_neg_def Q_I_pos_def Q_J_neg_def Q_J_pos_def R_I_def R_def X_def\n              \\<open>1 \\<le> card I\\<close> \\<open>1 \\<le> card J\\<close> \\<open>Set.is_empty (I \\<inter> J)\\<close> \\<open>V = I \\<union> J\\<close>\n              \\<open>\\<forall>t\\<in>R_I. \\<forall>y. (y \\<in> genericJoin J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t))) = (wf_tuple n J y \\<and> (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, t). restrict A y \\<in> X) \\<and> (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, t). restrict A y \\<notin> X))\\<close>\n              \\<open>\\<forall>x. (x \\<in> R_I) = (wf_tuple n I x \\<and> (\\<forall>(A, X)\\<in>Q_I_pos. restrict A x \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Q_I_neg. restrict A x \\<notin> X))\\<close>\n              \\<open>wf_tuple n V z \\<and> (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>V = I \\<union> J; Set.is_empty (I \\<inter> J); 1 \\<le> card I;\n   1 \\<le> card J; Q_I_pos = projectQuery I (filterQuery I Q);\n   Q_J_pos = filterQuery J Q; Q_I_neg = filterQueryNeg I Qn;\n   Q_J_neg = filterQuery J (Qn - Q_I_neg);\n   R_I = genericJoin I Q_I_pos Q_I_neg;\n   X =\n   {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n         (newQuery J Q_J_neg (I, t))) |\n    t. t \\<in> R_I};\n   R = (\\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x});\n   ?R_NQ = genericJoin J ?NQ_pos ?NQ_neg;\n   \\<forall>x.\n      (x \\<in> R_I) =\n      (wf_tuple n I x \\<and>\n       (\\<forall>(A, X)\\<in>Q_I_pos. restrict A x \\<in> X) \\<and>\n       (\\<forall>(A, X)\\<in>Q_I_neg. restrict A x \\<notin> X));\n   \\<forall>t\\<in>R_I.\n      \\<forall>y.\n         (y \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                   (newQuery J Q_J_neg (I, t))) =\n         (wf_tuple n J y \\<and>\n          (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, t).\n              restrict A y \\<in> X) \\<and>\n          (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, t).\n              restrict A y \\<notin> X));\n   wf_tuple n V z \\<and>\n   (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X);\n   rwf_query n V Q Qn\\<rbrakk>\n  \\<Longrightarrow> z \\<in> R\n  rwf_query n V Q Qn\n  Q_I_neg = filterQueryNeg I Qn\n  Q_I_pos = projectQuery I (filterQuery I Q)\n  Q_J_neg = filterQuery J (Qn - Q_I_neg)\n  Q_J_pos = filterQuery J Q\n  R_I = genericJoin I Q_I_pos Q_I_neg\n  R = (\\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})\n  X =\n  {(t, genericJoin J (newQuery J Q_J_pos (I, t))\n        (newQuery J Q_J_neg (I, t))) |\n   t. t \\<in> R_I}\n  1 \\<le> card I\n  1 \\<le> card J\n  Set.is_empty (I \\<inter> J)\n  V = I \\<union> J\n  \\<forall>t\\<in>R_I.\n     \\<forall>y.\n        (y \\<in> genericJoin J (newQuery J Q_J_pos (I, t))\n                  (newQuery J Q_J_neg (I, t))) =\n        (wf_tuple n J y \\<and>\n         (\\<forall>(A, X)\\<in>newQuery J Q_J_pos (I, t).\n             restrict A y \\<in> X) \\<and>\n         (\\<forall>(A, X)\\<in>newQuery J Q_J_neg (I, t).\n             restrict A y \\<notin> X))\n  \\<forall>x.\n     (x \\<in> R_I) =\n     (wf_tuple n I x \\<and>\n      (\\<forall>(A, X)\\<in>Q_I_pos. restrict A x \\<in> X) \\<and>\n      (\\<forall>(A, X)\\<in>Q_I_neg. restrict A x \\<notin> X))\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\n\ngoal (1 subgoal):\n 1. z \\<in> R", "by blast"], ["proof (state)\nthis:\n  z \\<in> R\n\ngoal (1 subgoal):\n 1. wf_tuple n V za__ \\<and>\n    (\\<forall>(A, X)\\<in>Q. restrict A za__ \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Qn. restrict A za__ \\<notin> X) \\<Longrightarrow>\n    za__ \\<in> genericJoin V Q Qn", "then"], ["proof (chain)\npicking this:\n  z \\<in> R", "show \"z \\<in> genericJoin V Q Qn\""], ["proof (prove)\nusing this:\n  z \\<in> R\n\ngoal (1 subgoal):\n 1. z \\<in> genericJoin V Q Qn", "using \\<open>R = genericJoin V Q Qn\\<close>"], ["proof (prove)\nusing this:\n  z \\<in> R\n  R = genericJoin V Q Qn\n\ngoal (1 subgoal):\n 1. z \\<in> genericJoin V Q Qn", "by blast"], ["proof (state)\nthis:\n  z \\<in> genericJoin V Q Qn\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X) \\<Longrightarrow>\n  z \\<in> genericJoin V Q Qn\n\ngoal (1 subgoal):\n 1. rwf_query n V Q Qn \\<Longrightarrow>\n    (z \\<in> genericJoin V Q Qn) =\n    (wf_tuple n V z \\<and>\n     (\\<forall>a\\<in>Q.\n         case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n     (\\<forall>a\\<in>Qn.\n         case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "then"], ["proof (chain)\npicking this:\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X) \\<Longrightarrow>\n  z \\<in> genericJoin V Q Qn", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X) \\<Longrightarrow>\n  z \\<in> genericJoin V Q Qn\n\ngoal (1 subgoal):\n 1. (z \\<in> genericJoin V Q Qn) =\n    (wf_tuple n V z \\<and>\n     (\\<forall>a\\<in>Q.\n         case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n     (\\<forall>a\\<in>Qn.\n         case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "using calculation"], ["proof (prove)\nusing this:\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X) \\<Longrightarrow>\n  z \\<in> genericJoin V Q Qn\n  z \\<in> genericJoin V Q Qn \\<Longrightarrow>\n  wf_tuple n V z \\<and>\n  (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\n\ngoal (1 subgoal):\n 1. (z \\<in> genericJoin V Q Qn) =\n    (wf_tuple n V z \\<and>\n     (\\<forall>a\\<in>Q.\n         case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n     (\\<forall>a\\<in>Qn.\n         case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X))", "by linarith"], ["proof (state)\nthis:\n  (z \\<in> genericJoin V Q Qn) =\n  (wf_tuple n V z \\<and>\n   (\\<forall>a\\<in>Q.\n       case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n   (\\<forall>a\\<in>Qn.\n       case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (z \\<in> genericJoin V Q Qn) =\n  (wf_tuple n V z \\<and>\n   (\\<forall>a\\<in>Q.\n       case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n   (\\<forall>a\\<in>Qn.\n       case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (z \\<in> genericJoin V Q Qn) =\n  (wf_tuple n V z \\<and>\n   (\\<forall>a\\<in>Q.\n       case a of (A, a) \\<Rightarrow> restrict A z \\<in> a) \\<and>\n   (\\<forall>a\\<in>Qn.\n       case a of (A, X) \\<Rightarrow> restrict A z \\<notin> X))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_set_finite:\n  assumes \"wf_set n A\"\n  shows \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A", "using assms finite_nat_set_iff_bounded wf_set_def"], ["proof (prove)\nusing this:\n  wf_set n A\n  finite ?N = (\\<exists>m. \\<forall>n\\<in>?N. n < m)\n  wf_set ?n ?V = (\\<forall>x\\<in>?V. x < ?n)\n\ngoal (1 subgoal):\n 1. finite A", "by auto"], ["", "lemma vars_wrapperGenericJoin:\n  fixes Q :: \"'a query\" and Q_pos :: \"'a query\" and Q_neg :: \"'a query\"\n  and V :: \"nat set\" and Qn :: \"'a query\"\n  assumes \"Q = Set.filter (\\<lambda>(A, _). \\<not> Set.is_empty A) Q_pos\"\n      and \"V = (\\<Union>(A, X)\\<in>Q. A)\"\n      and \"Qn = Set.filter (\\<lambda>(A, _). A \\<subseteq> V \\<and> card A \\<ge> 1) Q_neg\"\n      and \"\\<not> Set.is_empty Q\"\n      and \"\\<not>((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or> (\\<exists>(A, X)\\<in>Q_neg. Set.is_empty A \\<and> \\<not> Set.is_empty X))\"\n    shows \"wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn", "using assms wrapperGenericJoin.simps"], ["proof (prove)\nusing this:\n  Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos\n  V = (\\<Union>(A, X)\\<in>Q. A)\n  Qn =\n  Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n   Q_neg\n  \\<not> Set.is_empty Q\n  \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n          (\\<exists>(A, X)\\<in>Q_neg.\n              Set.is_empty A \\<and> \\<not> Set.is_empty X))\n  wrapperGenericJoin ?Q_pos ?Q_neg =\n  (if (\\<exists>(A, y)\\<in>?Q_pos. Set.is_empty y) \\<or>\n      (\\<exists>(A, X)\\<in>?Q_neg.\n          Set.is_empty A \\<and> \\<not> Set.is_empty X)\n   then {}\n   else let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) ?Q_pos\n        in if Set.is_empty Q\n           then (\\<Inter>(A, X)\\<in>?Q_pos. X) -\n                (\\<Union>(A, X)\\<in>?Q_neg. X)\n           else let V = \\<Union>(A, X)\\<in>Q. A\n                in Let (Set.filter\n                         (\\<lambda>(A, uu_).\n                             A \\<subseteq> V \\<and> 1 \\<le> card A)\n                         ?Q_neg)\n                    (genericJoin V Q))\n\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q =\n             Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos;\n     V = (\\<Union>(A, X)\\<in>Q. A);\n     Qn =\n     Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n      Q_neg;\n     \\<not> Set.is_empty Q;\n     \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n             (\\<exists>(A, X)\\<in>Q_neg.\n                 Set.is_empty A \\<and> \\<not> Set.is_empty X));\n     \\<And>Q_pos Q_neg.\n        wrapperGenericJoin Q_pos Q_neg =\n        (if (\\<exists>(A, y)\\<in>Q_pos. Set.is_empty y) \\<or>\n            (\\<exists>(A, X)\\<in>Q_neg.\n                Set.is_empty A \\<and> \\<not> Set.is_empty X)\n         then {}\n         else let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A)\n                       Q_pos\n              in if Set.is_empty Q\n                 then (\\<Inter>(A, X)\\<in>Q_pos. X) -\n                      (\\<Union>(A, X)\\<in>Q_neg. X)\n                 else let V = \\<Union>(A, X)\\<in>Q. A\n                      in Let (Set.filter\n                               (\\<lambda>(A, uu_).\n                                   A \\<subseteq> V \\<and> 1 \\<le> card A)\n                               Q_neg)\n                          (genericJoin V Q))\\<rbrakk>\n    \\<Longrightarrow> wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn", "let ?r = \"wrapperGenericJoin Q_pos Q_neg\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q =\n             Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos;\n     V = (\\<Union>(A, X)\\<in>Q. A);\n     Qn =\n     Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n      Q_neg;\n     \\<not> Set.is_empty Q;\n     \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n             (\\<exists>(A, X)\\<in>Q_neg.\n                 Set.is_empty A \\<and> \\<not> Set.is_empty X));\n     \\<And>Q_pos Q_neg.\n        wrapperGenericJoin Q_pos Q_neg =\n        (if (\\<exists>(A, y)\\<in>Q_pos. Set.is_empty y) \\<or>\n            (\\<exists>(A, X)\\<in>Q_neg.\n                Set.is_empty A \\<and> \\<not> Set.is_empty X)\n         then {}\n         else let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A)\n                       Q_pos\n              in if Set.is_empty Q\n                 then (\\<Inter>(A, X)\\<in>Q_pos. X) -\n                      (\\<Union>(A, X)\\<in>Q_neg. X)\n                 else let V = \\<Union>(A, X)\\<in>Q. A\n                      in Let (Set.filter\n                               (\\<lambda>(A, uu_).\n                                   A \\<subseteq> V \\<and> 1 \\<le> card A)\n                               Q_neg)\n                          (genericJoin V Q))\\<rbrakk>\n    \\<Longrightarrow> wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn", "have \"?r = (if ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or> (\\<exists>(A, X)\\<in>Q_neg. Set.is_empty A \\<and> \\<not> Set.is_empty X)) then\n      {}\n    else\n      let Q = Set.filter (\\<lambda>(A, _). \\<not> Set.is_empty A) Q_pos in\n      if Set.is_empty Q then\n        (\\<Inter>(A, X)\\<in>Q_pos. X) -  (\\<Union>(A, X)\\<in>Q_neg. X)\n      else\n        let V = (\\<Union>(A, X)\\<in>Q. A) in\n        let Qn = Set.filter (\\<lambda>(A, _). A \\<subseteq> V \\<and> card A \\<ge> 1) Q_neg in\n        genericJoin V Q Qn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg =\n    (if (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n        (\\<exists>(A, X)\\<in>Q_neg.\n            Set.is_empty A \\<and> \\<not> Set.is_empty X)\n     then {}\n     else let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A)\n                   Q_pos\n          in if Set.is_empty Q\n             then (\\<Inter>(A, X)\\<in>Q_pos. X) -\n                  (\\<Union>(A, X)\\<in>Q_neg. X)\n             else let V = \\<Union>(A, X)\\<in>Q. A\n                  in Let (Set.filter\n                           (\\<lambda>(A, uu_).\n                               A \\<subseteq> V \\<and> 1 \\<le> card A)\n                           Q_neg)\n                      (genericJoin V Q))", "by simp"], ["proof (state)\nthis:\n  wrapperGenericJoin Q_pos Q_neg =\n  (if (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n      (\\<exists>(A, X)\\<in>Q_neg.\n          Set.is_empty A \\<and> \\<not> Set.is_empty X)\n   then {}\n   else let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos\n        in if Set.is_empty Q\n           then (\\<Inter>(A, X)\\<in>Q_pos. X) -\n                (\\<Union>(A, X)\\<in>Q_neg. X)\n           else let V = \\<Union>(A, X)\\<in>Q. A\n                in Let (Set.filter\n                         (\\<lambda>(A, uu_).\n                             A \\<subseteq> V \\<and> 1 \\<le> card A)\n                         Q_neg)\n                    (genericJoin V Q))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Q =\n             Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos;\n     V = (\\<Union>(A, X)\\<in>Q. A);\n     Qn =\n     Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n      Q_neg;\n     \\<not> Set.is_empty Q;\n     \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n             (\\<exists>(A, X)\\<in>Q_neg.\n                 Set.is_empty A \\<and> \\<not> Set.is_empty X));\n     \\<And>Q_pos Q_neg.\n        wrapperGenericJoin Q_pos Q_neg =\n        (if (\\<exists>(A, y)\\<in>Q_pos. Set.is_empty y) \\<or>\n            (\\<exists>(A, X)\\<in>Q_neg.\n                Set.is_empty A \\<and> \\<not> Set.is_empty X)\n         then {}\n         else let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A)\n                       Q_pos\n              in if Set.is_empty Q\n                 then (\\<Inter>(A, X)\\<in>Q_pos. X) -\n                      (\\<Union>(A, X)\\<in>Q_neg. X)\n                 else let V = \\<Union>(A, X)\\<in>Q. A\n                      in Let (Set.filter\n                               (\\<lambda>(A, uu_).\n                                   A \\<subseteq> V \\<and> 1 \\<le> card A)\n                               Q_neg)\n                          (genericJoin V Q))\\<rbrakk>\n    \\<Longrightarrow> wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn", "also"], ["proof (state)\nthis:\n  wrapperGenericJoin Q_pos Q_neg =\n  (if (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n      (\\<exists>(A, X)\\<in>Q_neg.\n          Set.is_empty A \\<and> \\<not> Set.is_empty X)\n   then {}\n   else let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos\n        in if Set.is_empty Q\n           then (\\<Inter>(A, X)\\<in>Q_pos. X) -\n                (\\<Union>(A, X)\\<in>Q_neg. X)\n           else let V = \\<Union>(A, X)\\<in>Q. A\n                in Let (Set.filter\n                         (\\<lambda>(A, uu_).\n                             A \\<subseteq> V \\<and> 1 \\<le> card A)\n                         Q_neg)\n                    (genericJoin V Q))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Q =\n             Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos;\n     V = (\\<Union>(A, X)\\<in>Q. A);\n     Qn =\n     Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n      Q_neg;\n     \\<not> Set.is_empty Q;\n     \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n             (\\<exists>(A, X)\\<in>Q_neg.\n                 Set.is_empty A \\<and> \\<not> Set.is_empty X));\n     \\<And>Q_pos Q_neg.\n        wrapperGenericJoin Q_pos Q_neg =\n        (if (\\<exists>(A, y)\\<in>Q_pos. Set.is_empty y) \\<or>\n            (\\<exists>(A, X)\\<in>Q_neg.\n                Set.is_empty A \\<and> \\<not> Set.is_empty X)\n         then {}\n         else let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A)\n                       Q_pos\n              in if Set.is_empty Q\n                 then (\\<Inter>(A, X)\\<in>Q_pos. X) -\n                      (\\<Union>(A, X)\\<in>Q_neg. X)\n                 else let V = \\<Union>(A, X)\\<in>Q. A\n                      in Let (Set.filter\n                               (\\<lambda>(A, uu_).\n                                   A \\<subseteq> V \\<and> 1 \\<le> card A)\n                               Q_neg)\n                          (genericJoin V Q))\\<rbrakk>\n    \\<Longrightarrow> wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn", "have \"... = (let Q = Set.filter (\\<lambda>(A, _). \\<not> Set.is_empty A) Q_pos in\n      if Set.is_empty Q then\n        (\\<Inter>(A, X)\\<in>Q_pos. X) -  (\\<Union>(A, X)\\<in>Q_neg. X)\n      else\n        let V = (\\<Union>(A, X)\\<in>Q. A) in\n        let Qn = Set.filter (\\<lambda>(A, _). A \\<subseteq> V \\<and> card A \\<ge> 1) Q_neg in\n        genericJoin V Q Qn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n        (\\<exists>(A, X)\\<in>Q_neg.\n            Set.is_empty A \\<and> \\<not> Set.is_empty X)\n     then {}\n     else let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A)\n                   Q_pos\n          in if Set.is_empty Q\n             then (\\<Inter>(A, X)\\<in>Q_pos. X) -\n                  (\\<Union>(A, X)\\<in>Q_neg. X)\n             else let V = \\<Union>(A, X)\\<in>Q. A\n                  in Let (Set.filter\n                           (\\<lambda>(A, uu_).\n                               A \\<subseteq> V \\<and> 1 \\<le> card A)\n                           Q_neg)\n                      (genericJoin V Q)) =\n    (let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos\n     in if Set.is_empty Q\n        then (\\<Inter>(A, X)\\<in>Q_pos. X) - (\\<Union>(A, X)\\<in>Q_neg. X)\n        else let V = \\<Union>(A, X)\\<in>Q. A\n             in Let (Set.filter\n                      (\\<lambda>(A, uu_).\n                          A \\<subseteq> V \\<and> 1 \\<le> card A)\n                      Q_neg)\n                 (genericJoin V Q))", "using assms(5)"], ["proof (prove)\nusing this:\n  \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n          (\\<exists>(A, X)\\<in>Q_neg.\n              Set.is_empty A \\<and> \\<not> Set.is_empty X))\n\ngoal (1 subgoal):\n 1. (if (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n        (\\<exists>(A, X)\\<in>Q_neg.\n            Set.is_empty A \\<and> \\<not> Set.is_empty X)\n     then {}\n     else let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A)\n                   Q_pos\n          in if Set.is_empty Q\n             then (\\<Inter>(A, X)\\<in>Q_pos. X) -\n                  (\\<Union>(A, X)\\<in>Q_neg. X)\n             else let V = \\<Union>(A, X)\\<in>Q. A\n                  in Let (Set.filter\n                           (\\<lambda>(A, uu_).\n                               A \\<subseteq> V \\<and> 1 \\<le> card A)\n                           Q_neg)\n                      (genericJoin V Q)) =\n    (let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos\n     in if Set.is_empty Q\n        then (\\<Inter>(A, X)\\<in>Q_pos. X) - (\\<Union>(A, X)\\<in>Q_neg. X)\n        else let V = \\<Union>(A, X)\\<in>Q. A\n             in Let (Set.filter\n                      (\\<lambda>(A, uu_).\n                          A \\<subseteq> V \\<and> 1 \\<le> card A)\n                      Q_neg)\n                 (genericJoin V Q))", "by simp"], ["proof (state)\nthis:\n  (if (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n      (\\<exists>(A, X)\\<in>Q_neg.\n          Set.is_empty A \\<and> \\<not> Set.is_empty X)\n   then {}\n   else let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos\n        in if Set.is_empty Q\n           then (\\<Inter>(A, X)\\<in>Q_pos. X) -\n                (\\<Union>(A, X)\\<in>Q_neg. X)\n           else let V = \\<Union>(A, X)\\<in>Q. A\n                in Let (Set.filter\n                         (\\<lambda>(A, uu_).\n                             A \\<subseteq> V \\<and> 1 \\<le> card A)\n                         Q_neg)\n                    (genericJoin V Q)) =\n  (let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos\n   in if Set.is_empty Q\n      then (\\<Inter>(A, X)\\<in>Q_pos. X) - (\\<Union>(A, X)\\<in>Q_neg. X)\n      else let V = \\<Union>(A, X)\\<in>Q. A\n           in Let (Set.filter\n                    (\\<lambda>(A, uu_).\n                        A \\<subseteq> V \\<and> 1 \\<le> card A)\n                    Q_neg)\n               (genericJoin V Q))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Q =\n             Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos;\n     V = (\\<Union>(A, X)\\<in>Q. A);\n     Qn =\n     Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n      Q_neg;\n     \\<not> Set.is_empty Q;\n     \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n             (\\<exists>(A, X)\\<in>Q_neg.\n                 Set.is_empty A \\<and> \\<not> Set.is_empty X));\n     \\<And>Q_pos Q_neg.\n        wrapperGenericJoin Q_pos Q_neg =\n        (if (\\<exists>(A, y)\\<in>Q_pos. Set.is_empty y) \\<or>\n            (\\<exists>(A, X)\\<in>Q_neg.\n                Set.is_empty A \\<and> \\<not> Set.is_empty X)\n         then {}\n         else let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A)\n                       Q_pos\n              in if Set.is_empty Q\n                 then (\\<Inter>(A, X)\\<in>Q_pos. X) -\n                      (\\<Union>(A, X)\\<in>Q_neg. X)\n                 else let V = \\<Union>(A, X)\\<in>Q. A\n                      in Let (Set.filter\n                               (\\<lambda>(A, uu_).\n                                   A \\<subseteq> V \\<and> 1 \\<le> card A)\n                               Q_neg)\n                          (genericJoin V Q))\\<rbrakk>\n    \\<Longrightarrow> wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn", "moreover"], ["proof (state)\nthis:\n  (if (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n      (\\<exists>(A, X)\\<in>Q_neg.\n          Set.is_empty A \\<and> \\<not> Set.is_empty X)\n   then {}\n   else let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos\n        in if Set.is_empty Q\n           then (\\<Inter>(A, X)\\<in>Q_pos. X) -\n                (\\<Union>(A, X)\\<in>Q_neg. X)\n           else let V = \\<Union>(A, X)\\<in>Q. A\n                in Let (Set.filter\n                         (\\<lambda>(A, uu_).\n                             A \\<subseteq> V \\<and> 1 \\<le> card A)\n                         Q_neg)\n                    (genericJoin V Q)) =\n  (let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos\n   in if Set.is_empty Q\n      then (\\<Inter>(A, X)\\<in>Q_pos. X) - (\\<Union>(A, X)\\<in>Q_neg. X)\n      else let V = \\<Union>(A, X)\\<in>Q. A\n           in Let (Set.filter\n                    (\\<lambda>(A, uu_).\n                        A \\<subseteq> V \\<and> 1 \\<le> card A)\n                    Q_neg)\n               (genericJoin V Q))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Q =\n             Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos;\n     V = (\\<Union>(A, X)\\<in>Q. A);\n     Qn =\n     Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n      Q_neg;\n     \\<not> Set.is_empty Q;\n     \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n             (\\<exists>(A, X)\\<in>Q_neg.\n                 Set.is_empty A \\<and> \\<not> Set.is_empty X));\n     \\<And>Q_pos Q_neg.\n        wrapperGenericJoin Q_pos Q_neg =\n        (if (\\<exists>(A, y)\\<in>Q_pos. Set.is_empty y) \\<or>\n            (\\<exists>(A, X)\\<in>Q_neg.\n                Set.is_empty A \\<and> \\<not> Set.is_empty X)\n         then {}\n         else let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A)\n                       Q_pos\n              in if Set.is_empty Q\n                 then (\\<Inter>(A, X)\\<in>Q_pos. X) -\n                      (\\<Union>(A, X)\\<in>Q_neg. X)\n                 else let V = \\<Union>(A, X)\\<in>Q. A\n                      in Let (Set.filter\n                               (\\<lambda>(A, uu_).\n                                   A \\<subseteq> V \\<and> 1 \\<le> card A)\n                               Q_neg)\n                          (genericJoin V Q))\\<rbrakk>\n    \\<Longrightarrow> wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn", "have \"\\<not> (let Q = Set.filter (\\<lambda>(A, _). \\<not> Set.is_empty A) Q_pos in Set.is_empty Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Let (Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos)\n            Set.is_empty", "using assms(1) assms(4)"], ["proof (prove)\nusing this:\n  Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos\n  \\<not> Set.is_empty Q\n\ngoal (1 subgoal):\n 1. \\<not> Let (Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos)\n            Set.is_empty", "by auto"], ["proof (state)\nthis:\n  \\<not> Let (Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos)\n          Set.is_empty\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Q =\n             Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos;\n     V = (\\<Union>(A, X)\\<in>Q. A);\n     Qn =\n     Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n      Q_neg;\n     \\<not> Set.is_empty Q;\n     \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n             (\\<exists>(A, X)\\<in>Q_neg.\n                 Set.is_empty A \\<and> \\<not> Set.is_empty X));\n     \\<And>Q_pos Q_neg.\n        wrapperGenericJoin Q_pos Q_neg =\n        (if (\\<exists>(A, y)\\<in>Q_pos. Set.is_empty y) \\<or>\n            (\\<exists>(A, X)\\<in>Q_neg.\n                Set.is_empty A \\<and> \\<not> Set.is_empty X)\n         then {}\n         else let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A)\n                       Q_pos\n              in if Set.is_empty Q\n                 then (\\<Inter>(A, X)\\<in>Q_pos. X) -\n                      (\\<Union>(A, X)\\<in>Q_neg. X)\n                 else let V = \\<Union>(A, X)\\<in>Q. A\n                      in Let (Set.filter\n                               (\\<lambda>(A, uu_).\n                                   A \\<subseteq> V \\<and> 1 \\<le> card A)\n                               Q_neg)\n                          (genericJoin V Q))\\<rbrakk>\n    \\<Longrightarrow> wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn", "ultimately"], ["proof (chain)\npicking this:\n  wrapperGenericJoin Q_pos Q_neg =\n  (if (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n      (\\<exists>(A, X)\\<in>Q_neg.\n          Set.is_empty A \\<and> \\<not> Set.is_empty X)\n   then {}\n   else let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos\n        in if Set.is_empty Q\n           then (\\<Inter>(A, X)\\<in>Q_pos. X) -\n                (\\<Union>(A, X)\\<in>Q_neg. X)\n           else let V = \\<Union>(A, X)\\<in>Q. A\n                in Let (Set.filter\n                         (\\<lambda>(A, uu_).\n                             A \\<subseteq> V \\<and> 1 \\<le> card A)\n                         Q_neg)\n                    (genericJoin V Q))\n  (if (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n      (\\<exists>(A, X)\\<in>Q_neg.\n          Set.is_empty A \\<and> \\<not> Set.is_empty X)\n   then {}\n   else let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos\n        in if Set.is_empty Q\n           then (\\<Inter>(A, X)\\<in>Q_pos. X) -\n                (\\<Union>(A, X)\\<in>Q_neg. X)\n           else let V = \\<Union>(A, X)\\<in>Q. A\n                in Let (Set.filter\n                         (\\<lambda>(A, uu_).\n                             A \\<subseteq> V \\<and> 1 \\<le> card A)\n                         Q_neg)\n                    (genericJoin V Q)) =\n  (let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos\n   in if Set.is_empty Q\n      then (\\<Inter>(A, X)\\<in>Q_pos. X) - (\\<Union>(A, X)\\<in>Q_neg. X)\n      else let V = \\<Union>(A, X)\\<in>Q. A\n           in Let (Set.filter\n                    (\\<lambda>(A, uu_).\n                        A \\<subseteq> V \\<and> 1 \\<le> card A)\n                    Q_neg)\n               (genericJoin V Q))\n  \\<not> Let (Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos)\n          Set.is_empty", "have \"(let Q = Set.filter (\\<lambda>(A, _). \\<not> Set.is_empty A) Q_pos in\n      if Set.is_empty Q then\n        (\\<Inter>(A, X)\\<in>Q_pos. X) -  (\\<Union>(A, X)\\<in>Q_neg. X)\n      else\n        let V = (\\<Union>(A, X)\\<in>Q. A) in\n        let Qn = Set.filter (\\<lambda>(A, _). A \\<subseteq> V \\<and> card A \\<ge> 1) Q_neg in\n        genericJoin V Q Qn) = (let Q = Set.filter (\\<lambda>(A, _). \\<not> Set.is_empty A) Q_pos in\n        let V = (\\<Union>(A, X)\\<in>Q. A) in\n        let Qn = Set.filter (\\<lambda>(A, _). A \\<subseteq> V \\<and> card A \\<ge> 1) Q_neg in\n        genericJoin V Q Qn)\""], ["proof (prove)\nusing this:\n  wrapperGenericJoin Q_pos Q_neg =\n  (if (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n      (\\<exists>(A, X)\\<in>Q_neg.\n          Set.is_empty A \\<and> \\<not> Set.is_empty X)\n   then {}\n   else let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos\n        in if Set.is_empty Q\n           then (\\<Inter>(A, X)\\<in>Q_pos. X) -\n                (\\<Union>(A, X)\\<in>Q_neg. X)\n           else let V = \\<Union>(A, X)\\<in>Q. A\n                in Let (Set.filter\n                         (\\<lambda>(A, uu_).\n                             A \\<subseteq> V \\<and> 1 \\<le> card A)\n                         Q_neg)\n                    (genericJoin V Q))\n  (if (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n      (\\<exists>(A, X)\\<in>Q_neg.\n          Set.is_empty A \\<and> \\<not> Set.is_empty X)\n   then {}\n   else let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos\n        in if Set.is_empty Q\n           then (\\<Inter>(A, X)\\<in>Q_pos. X) -\n                (\\<Union>(A, X)\\<in>Q_neg. X)\n           else let V = \\<Union>(A, X)\\<in>Q. A\n                in Let (Set.filter\n                         (\\<lambda>(A, uu_).\n                             A \\<subseteq> V \\<and> 1 \\<le> card A)\n                         Q_neg)\n                    (genericJoin V Q)) =\n  (let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos\n   in if Set.is_empty Q\n      then (\\<Inter>(A, X)\\<in>Q_pos. X) - (\\<Union>(A, X)\\<in>Q_neg. X)\n      else let V = \\<Union>(A, X)\\<in>Q. A\n           in Let (Set.filter\n                    (\\<lambda>(A, uu_).\n                        A \\<subseteq> V \\<and> 1 \\<le> card A)\n                    Q_neg)\n               (genericJoin V Q))\n  \\<not> Let (Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos)\n          Set.is_empty\n\ngoal (1 subgoal):\n 1. (let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos\n     in if Set.is_empty Q\n        then (\\<Inter>(A, X)\\<in>Q_pos. X) - (\\<Union>(A, X)\\<in>Q_neg. X)\n        else let V = \\<Union>(A, X)\\<in>Q. A\n             in Let (Set.filter\n                      (\\<lambda>(A, uu_).\n                          A \\<subseteq> V \\<and> 1 \\<le> card A)\n                      Q_neg)\n                 (genericJoin V Q)) =\n    (let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos;\n         V = \\<Union>(A, X)\\<in>Q. A\n     in Let (Set.filter\n              (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n              Q_neg)\n         (genericJoin V Q))", "by presburger"], ["proof (state)\nthis:\n  (let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos\n   in if Set.is_empty Q\n      then (\\<Inter>(A, X)\\<in>Q_pos. X) - (\\<Union>(A, X)\\<in>Q_neg. X)\n      else let V = \\<Union>(A, X)\\<in>Q. A\n           in Let (Set.filter\n                    (\\<lambda>(A, uu_).\n                        A \\<subseteq> V \\<and> 1 \\<le> card A)\n                    Q_neg)\n               (genericJoin V Q)) =\n  (let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos;\n       V = \\<Union>(A, X)\\<in>Q. A\n   in Let (Set.filter\n            (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n            Q_neg)\n       (genericJoin V Q))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Q =\n             Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos;\n     V = (\\<Union>(A, X)\\<in>Q. A);\n     Qn =\n     Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n      Q_neg;\n     \\<not> Set.is_empty Q;\n     \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n             (\\<exists>(A, X)\\<in>Q_neg.\n                 Set.is_empty A \\<and> \\<not> Set.is_empty X));\n     \\<And>Q_pos Q_neg.\n        wrapperGenericJoin Q_pos Q_neg =\n        (if (\\<exists>(A, y)\\<in>Q_pos. Set.is_empty y) \\<or>\n            (\\<exists>(A, X)\\<in>Q_neg.\n                Set.is_empty A \\<and> \\<not> Set.is_empty X)\n         then {}\n         else let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A)\n                       Q_pos\n              in if Set.is_empty Q\n                 then (\\<Inter>(A, X)\\<in>Q_pos. X) -\n                      (\\<Union>(A, X)\\<in>Q_neg. X)\n                 else let V = \\<Union>(A, X)\\<in>Q. A\n                      in Let (Set.filter\n                               (\\<lambda>(A, uu_).\n                                   A \\<subseteq> V \\<and> 1 \\<le> card A)\n                               Q_neg)\n                          (genericJoin V Q))\\<rbrakk>\n    \\<Longrightarrow> wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn", "also"], ["proof (state)\nthis:\n  (let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos\n   in if Set.is_empty Q\n      then (\\<Inter>(A, X)\\<in>Q_pos. X) - (\\<Union>(A, X)\\<in>Q_neg. X)\n      else let V = \\<Union>(A, X)\\<in>Q. A\n           in Let (Set.filter\n                    (\\<lambda>(A, uu_).\n                        A \\<subseteq> V \\<and> 1 \\<le> card A)\n                    Q_neg)\n               (genericJoin V Q)) =\n  (let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos;\n       V = \\<Union>(A, X)\\<in>Q. A\n   in Let (Set.filter\n            (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n            Q_neg)\n       (genericJoin V Q))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Q =\n             Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos;\n     V = (\\<Union>(A, X)\\<in>Q. A);\n     Qn =\n     Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n      Q_neg;\n     \\<not> Set.is_empty Q;\n     \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n             (\\<exists>(A, X)\\<in>Q_neg.\n                 Set.is_empty A \\<and> \\<not> Set.is_empty X));\n     \\<And>Q_pos Q_neg.\n        wrapperGenericJoin Q_pos Q_neg =\n        (if (\\<exists>(A, y)\\<in>Q_pos. Set.is_empty y) \\<or>\n            (\\<exists>(A, X)\\<in>Q_neg.\n                Set.is_empty A \\<and> \\<not> Set.is_empty X)\n         then {}\n         else let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A)\n                       Q_pos\n              in if Set.is_empty Q\n                 then (\\<Inter>(A, X)\\<in>Q_pos. X) -\n                      (\\<Union>(A, X)\\<in>Q_neg. X)\n                 else let V = \\<Union>(A, X)\\<in>Q. A\n                      in Let (Set.filter\n                               (\\<lambda>(A, uu_).\n                                   A \\<subseteq> V \\<and> 1 \\<le> card A)\n                               Q_neg)\n                          (genericJoin V Q))\\<rbrakk>\n    \\<Longrightarrow> wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn", "have \"... = (genericJoin V Q Qn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos;\n         V = \\<Union>(A, X)\\<in>Q. A\n     in Let (Set.filter\n              (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n              Q_neg)\n         (genericJoin V Q)) =\n    genericJoin V Q Qn", "using assms(1) assms(2) assms(3)"], ["proof (prove)\nusing this:\n  Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos\n  V = (\\<Union>(A, X)\\<in>Q. A)\n  Qn =\n  Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n   Q_neg\n\ngoal (1 subgoal):\n 1. (let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos;\n         V = \\<Union>(A, X)\\<in>Q. A\n     in Let (Set.filter\n              (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n              Q_neg)\n         (genericJoin V Q)) =\n    genericJoin V Q Qn", "by metis"], ["proof (state)\nthis:\n  (let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos;\n       V = \\<Union>(A, X)\\<in>Q. A\n   in Let (Set.filter\n            (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n            Q_neg)\n       (genericJoin V Q)) =\n  genericJoin V Q Qn\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Q =\n             Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos;\n     V = (\\<Union>(A, X)\\<in>Q. A);\n     Qn =\n     Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n      Q_neg;\n     \\<not> Set.is_empty Q;\n     \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n             (\\<exists>(A, X)\\<in>Q_neg.\n                 Set.is_empty A \\<and> \\<not> Set.is_empty X));\n     \\<And>Q_pos Q_neg.\n        wrapperGenericJoin Q_pos Q_neg =\n        (if (\\<exists>(A, y)\\<in>Q_pos. Set.is_empty y) \\<or>\n            (\\<exists>(A, X)\\<in>Q_neg.\n                Set.is_empty A \\<and> \\<not> Set.is_empty X)\n         then {}\n         else let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A)\n                       Q_pos\n              in if Set.is_empty Q\n                 then (\\<Inter>(A, X)\\<in>Q_pos. X) -\n                      (\\<Union>(A, X)\\<in>Q_neg. X)\n                 else let V = \\<Union>(A, X)\\<in>Q. A\n                      in Let (Set.filter\n                               (\\<lambda>(A, uu_).\n                                   A \\<subseteq> V \\<and> 1 \\<le> card A)\n                               Q_neg)\n                          (genericJoin V Q))\\<rbrakk>\n    \\<Longrightarrow> wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn", "then"], ["proof (chain)\npicking this:\n  (let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos;\n       V = \\<Union>(A, X)\\<in>Q. A\n   in Let (Set.filter\n            (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n            Q_neg)\n       (genericJoin V Q)) =\n  genericJoin V Q Qn", "show ?thesis"], ["proof (prove)\nusing this:\n  (let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos;\n       V = \\<Union>(A, X)\\<in>Q. A\n   in Let (Set.filter\n            (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n            Q_neg)\n       (genericJoin V Q)) =\n  genericJoin V Q Qn\n\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn", "using wrapperGenericJoin.simps assms(5) calculation"], ["proof (prove)\nusing this:\n  (let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos;\n       V = \\<Union>(A, X)\\<in>Q. A\n   in Let (Set.filter\n            (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n            Q_neg)\n       (genericJoin V Q)) =\n  genericJoin V Q Qn\n  wrapperGenericJoin ?Q_pos ?Q_neg =\n  (if (\\<exists>(A, y)\\<in>?Q_pos. Set.is_empty y) \\<or>\n      (\\<exists>(A, X)\\<in>?Q_neg.\n          Set.is_empty A \\<and> \\<not> Set.is_empty X)\n   then {}\n   else let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) ?Q_pos\n        in if Set.is_empty Q\n           then (\\<Inter>(A, X)\\<in>?Q_pos. X) -\n                (\\<Union>(A, X)\\<in>?Q_neg. X)\n           else let V = \\<Union>(A, X)\\<in>Q. A\n                in Let (Set.filter\n                         (\\<lambda>(A, uu_).\n                             A \\<subseteq> V \\<and> 1 \\<le> card A)\n                         ?Q_neg)\n                    (genericJoin V Q))\n  \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n          (\\<exists>(A, X)\\<in>Q_neg.\n              Set.is_empty A \\<and> \\<not> Set.is_empty X))\n  (let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos\n   in if Set.is_empty Q\n      then (\\<Inter>(A, X)\\<in>Q_pos. X) - (\\<Union>(A, X)\\<in>Q_neg. X)\n      else let V = \\<Union>(A, X)\\<in>Q. A\n           in Let (Set.filter\n                    (\\<lambda>(A, uu_).\n                        A \\<subseteq> V \\<and> 1 \\<le> card A)\n                    Q_neg)\n               (genericJoin V Q)) =\n  (let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos;\n       V = \\<Union>(A, X)\\<in>Q. A\n   in Let (Set.filter\n            (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n            Q_neg)\n       (genericJoin V Q))\n\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn", "by simp"], ["proof (state)\nthis:\n  wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wrapper_correctness:\n  assumes \"card Q_pos \\<ge>1\"\n  assumes \"\\<forall>(A, X)\\<in>(Q_pos \\<union> Q_neg). table n A X \\<and> wf_set n A\"\n  shows \"z \\<in> wrapperGenericJoin Q_pos Q_neg \\<longleftrightarrow> wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and> (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "proof (cases \"(\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or> (\\<exists>(A, X)\\<in>Q_neg. Set.is_empty A \\<and> \\<not> Set.is_empty X)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n    (\\<exists>(A, X)\\<in>Q_neg.\n        Set.is_empty A \\<and> \\<not> Set.is_empty X) \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n 2. \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n            (\\<exists>(A, X)\\<in>Q_neg.\n                Set.is_empty A \\<and>\n                \\<not> Set.is_empty X)) \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "let ?r = \"wrapperGenericJoin Q_pos Q_neg\""], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n    (\\<exists>(A, X)\\<in>Q_neg.\n        Set.is_empty A \\<and> \\<not> Set.is_empty X) \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n 2. \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n            (\\<exists>(A, X)\\<in>Q_neg.\n                Set.is_empty A \\<and>\n                \\<not> Set.is_empty X)) \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "case True"], ["proof (state)\nthis:\n  (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n  (\\<exists>(A, X)\\<in>Q_neg. Set.is_empty A \\<and> \\<not> Set.is_empty X)\n\ngoal (2 subgoals):\n 1. (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n    (\\<exists>(A, X)\\<in>Q_neg.\n        Set.is_empty A \\<and> \\<not> Set.is_empty X) \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n 2. \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n            (\\<exists>(A, X)\\<in>Q_neg.\n                Set.is_empty A \\<and>\n                \\<not> Set.is_empty X)) \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "then"], ["proof (chain)\npicking this:\n  (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n  (\\<exists>(A, X)\\<in>Q_neg. Set.is_empty A \\<and> \\<not> Set.is_empty X)", "have \"?r = {}\""], ["proof (prove)\nusing this:\n  (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n  (\\<exists>(A, X)\\<in>Q_neg. Set.is_empty A \\<and> \\<not> Set.is_empty X)\n\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg = {}", "using wrapperGenericJoin.simps"], ["proof (prove)\nusing this:\n  (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n  (\\<exists>(A, X)\\<in>Q_neg. Set.is_empty A \\<and> \\<not> Set.is_empty X)\n  wrapperGenericJoin ?Q_pos ?Q_neg =\n  (if (\\<exists>(A, y)\\<in>?Q_pos. Set.is_empty y) \\<or>\n      (\\<exists>(A, X)\\<in>?Q_neg.\n          Set.is_empty A \\<and> \\<not> Set.is_empty X)\n   then {}\n   else let Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) ?Q_pos\n        in if Set.is_empty Q\n           then (\\<Inter>(A, X)\\<in>?Q_pos. X) -\n                (\\<Union>(A, X)\\<in>?Q_neg. X)\n           else let V = \\<Union>(A, X)\\<in>Q. A\n                in Let (Set.filter\n                         (\\<lambda>(A, uu_).\n                             A \\<subseteq> V \\<and> 1 \\<le> card A)\n                         ?Q_neg)\n                    (genericJoin V Q))\n\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg = {}", "by simp"], ["proof (state)\nthis:\n  wrapperGenericJoin Q_pos Q_neg = {}\n\ngoal (2 subgoals):\n 1. (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n    (\\<exists>(A, X)\\<in>Q_neg.\n        Set.is_empty A \\<and> \\<not> Set.is_empty X) \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n 2. \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n            (\\<exists>(A, X)\\<in>Q_neg.\n                Set.is_empty A \\<and>\n                \\<not> Set.is_empty X)) \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "have \"\\<not> (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and> (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n            (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n            (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "proof (rule notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n    (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X) \\<Longrightarrow>\n    False", "assume \"wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and> (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)\""], ["proof (state)\nthis:\n  wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n  (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)\n\ngoal (1 subgoal):\n 1. wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n    (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n  (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)", "show \"False\""], ["proof (prove)\nusing this:\n  wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n  (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)\n\ngoal (1 subgoal):\n 1. False", "proof (cases \"\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n             (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n             (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X);\n     \\<exists>(A, X)\\<in>Q_pos. Set.is_empty X\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n             (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n             (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X);\n     \\<not> (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X)\\<rbrakk>\n    \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  \\<exists>(A, X)\\<in>Q_pos. Set.is_empty X\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n             (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n             (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X);\n     \\<exists>(A, X)\\<in>Q_pos. Set.is_empty X\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n             (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n             (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X);\n     \\<not> (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X)\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>(A, X)\\<in>Q_pos. Set.is_empty X", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>(A, X)\\<in>Q_pos. Set.is_empty X\n\ngoal (1 subgoal):\n 1. False", "using \\<open>wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and> (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>(A, X)\\<in>Q_pos. Set.is_empty X\n  wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n  (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)\n\ngoal (1 subgoal):\n 1. False", "by (metis (no_types, lifting) Set.is_empty_def case_prod_beta' empty_iff)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n             (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n             (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X);\n     \\<not> (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X)\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n             (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n             (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X);\n     \\<not> (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X)\\<rbrakk>\n    \\<Longrightarrow> False", "let ?v = \"replicate n None\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n             (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n             (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X);\n     \\<not> (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X)\\<rbrakk>\n    \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n             (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n             (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X);\n     \\<not> (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X)\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X)", "have \"\\<exists>(A, X)\\<in>Q_neg. Set.is_empty A \\<and> \\<not> Set.is_empty X\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X)\n\ngoal (1 subgoal):\n 1. \\<exists>(A, X)\\<in>Q_neg. Set.is_empty A \\<and> \\<not> Set.is_empty X", "using True"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X)\n  (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n  (\\<exists>(A, X)\\<in>Q_neg. Set.is_empty A \\<and> \\<not> Set.is_empty X)\n\ngoal (1 subgoal):\n 1. \\<exists>(A, X)\\<in>Q_neg. Set.is_empty A \\<and> \\<not> Set.is_empty X", "by blast"], ["proof (state)\nthis:\n  \\<exists>(A, X)\\<in>Q_neg. Set.is_empty A \\<and> \\<not> Set.is_empty X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n             (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n             (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X);\n     \\<not> (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X)\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>(A, X)\\<in>Q_neg. Set.is_empty A \\<and> \\<not> Set.is_empty X", "obtain A X where \"(A, X) \\<in> Q_neg\" \"Set.is_empty A\" \"\\<not> Set.is_empty X\""], ["proof (prove)\nusing this:\n  \\<exists>(A, X)\\<in>Q_neg. Set.is_empty A \\<and> \\<not> Set.is_empty X\n\ngoal (1 subgoal):\n 1. (\\<And>A X.\n        \\<lbrakk>(A, X) \\<in> Q_neg; Set.is_empty A;\n         \\<not> Set.is_empty X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (A, X) \\<in> Q_neg\n  Set.is_empty A\n  \\<not> Set.is_empty X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n             (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n             (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X);\n     \\<not> (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X)\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (A, X) \\<in> Q_neg\n  Set.is_empty A\n  \\<not> Set.is_empty X", "have \"table n A X\""], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q_neg\n  Set.is_empty A\n  \\<not> Set.is_empty X\n\ngoal (1 subgoal):\n 1. table n A X", "using assms(2)"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q_neg\n  Set.is_empty A\n  \\<not> Set.is_empty X\n  \\<forall>(A, X)\\<in>Q_pos \\<union> Q_neg. table n A X \\<and> wf_set n A\n\ngoal (1 subgoal):\n 1. table n A X", "by auto"], ["proof (state)\nthis:\n  table n A X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n             (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n             (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X);\n     \\<not> (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X)\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  table n A X", "have \"X \\<subseteq> {?v}\""], ["proof (prove)\nusing this:\n  table n A X\n\ngoal (1 subgoal):\n 1. X \\<subseteq> {replicate n None}", "using \\<open>Set.is_empty A\\<close> table_empty unit_table_def"], ["proof (prove)\nusing this:\n  table n A X\n  Set.is_empty A\n  table ?n {} ?X = (?X = empty_table \\<or> ?X = unit_table ?n)\n  unit_table ?n = {replicate ?n None}\n\ngoal (1 subgoal):\n 1. X \\<subseteq> {replicate n None}", "by (metis Set.is_empty_def \\<open>\\<not> Set.is_empty X\\<close> empty_table_def set_eq_subset)"], ["proof (state)\nthis:\n  X \\<subseteq> {replicate n None}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n             (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n             (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X);\n     \\<not> (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X)\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  X \\<subseteq> {replicate n None}", "show ?thesis"], ["proof (prove)\nusing this:\n  X \\<subseteq> {replicate n None}\n\ngoal (1 subgoal):\n 1. False", "using \\<open>(A, X) \\<in> Q_neg\\<close> \\<open>Set.is_empty A\\<close> \\<open>\\<not> Set.is_empty X\\<close>\n          \\<open>wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and> (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)\\<close>"], ["proof (prove)\nusing this:\n  X \\<subseteq> {replicate n None}\n  (A, X) \\<in> Q_neg\n  Set.is_empty A\n  \\<not> Set.is_empty X\n  wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n  (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)\n\ngoal (1 subgoal):\n 1. False", "by (metis (no_types, lifting) Set.is_empty_def \\<open>table n A X\\<close> case_prod_beta' empty_table_def\n            in_unit_table inf_le1 inf_le2 prod.sel(1) snd_conv subset_empty table_empty wf_tuple_restrict_simple)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n          (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n          (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n\ngoal (2 subgoals):\n 1. (\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n    (\\<exists>(A, X)\\<in>Q_neg.\n        Set.is_empty A \\<and> \\<not> Set.is_empty X) \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n 2. \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n            (\\<exists>(A, X)\\<in>Q_neg.\n                Set.is_empty A \\<and>\n                \\<not> Set.is_empty X)) \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "then"], ["proof (chain)\npicking this:\n  \\<not> (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n          (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n          (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n          (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n          (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n\ngoal (1 subgoal):\n 1. (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "using \\<open>?r = {}\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n          (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n          (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n  wrapperGenericJoin Q_pos Q_neg = {}\n\ngoal (1 subgoal):\n 1. (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "by simp"], ["proof (state)\nthis:\n  (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n  (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n   (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n            (\\<exists>(A, X)\\<in>Q_neg.\n                Set.is_empty A \\<and>\n                \\<not> Set.is_empty X)) \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n            (\\<exists>(A, X)\\<in>Q_neg.\n                Set.is_empty A \\<and>\n                \\<not> Set.is_empty X)) \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "case False"], ["proof (state)\nthis:\n  \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n          (\\<exists>(A, X)\\<in>Q_neg.\n              Set.is_empty A \\<and> \\<not> Set.is_empty X))\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n            (\\<exists>(A, X)\\<in>Q_neg.\n                Set.is_empty A \\<and>\n                \\<not> Set.is_empty X)) \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "then"], ["proof (chain)\npicking this:\n  \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n          (\\<exists>(A, X)\\<in>Q_neg.\n              Set.is_empty A \\<and> \\<not> Set.is_empty X))", "have forall: \"(\\<forall>(A, X)\\<in>Q_pos. \\<not> Set.is_empty X) \\<and> (\\<forall>(A, X)\\<in>Q_neg. \\<not> Set.is_empty A \\<or> Set.is_empty X)\""], ["proof (prove)\nusing this:\n  \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n          (\\<exists>(A, X)\\<in>Q_neg.\n              Set.is_empty A \\<and> \\<not> Set.is_empty X))\n\ngoal (1 subgoal):\n 1. (\\<forall>(A, X)\\<in>Q_pos. \\<not> Set.is_empty X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg. \\<not> Set.is_empty A \\<or> Set.is_empty X)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>(A, X)\\<in>Q_pos. \\<not> Set.is_empty X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. \\<not> Set.is_empty A \\<or> Set.is_empty X)\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n            (\\<exists>(A, X)\\<in>Q_neg.\n                Set.is_empty A \\<and>\n                \\<not> Set.is_empty X)) \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "define Q where \"Q = Set.filter (\\<lambda>(A, _). \\<not> Set.is_empty A) Q_pos\""], ["proof (state)\nthis:\n  Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n            (\\<exists>(A, X)\\<in>Q_neg.\n                Set.is_empty A \\<and>\n                \\<not> Set.is_empty X)) \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "define V where \"V = (\\<Union>(A, X)\\<in>Q. A)\""], ["proof (state)\nthis:\n  V = (\\<Union>(A, X)\\<in>Q. A)\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n            (\\<exists>(A, X)\\<in>Q_neg.\n                Set.is_empty A \\<and>\n                \\<not> Set.is_empty X)) \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "let ?r = \"wrapperGenericJoin Q_pos Q_neg\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n            (\\<exists>(A, X)\\<in>Q_neg.\n                Set.is_empty A \\<and>\n                \\<not> Set.is_empty X)) \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "proof (cases \"Q = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Q = {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n 2. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "case True"], ["proof (state)\nthis:\n  Q = {}\n\ngoal (2 subgoals):\n 1. Q = {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n 2. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "then"], ["proof (chain)\npicking this:\n  Q = {}", "have r_def: \"?r = (\\<Inter>(A, X)\\<in>Q_pos. X) -  (\\<Union>(A, X)\\<in>Q_neg. X)\""], ["proof (prove)\nusing this:\n  Q = {}\n\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg =\n    (\\<Inter>(A, X)\\<in>Q_pos. X) - (\\<Union>(A, X)\\<in>Q_neg. X)", "using Q_def Set.is_empty_def False"], ["proof (prove)\nusing this:\n  Q = {}\n  Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos\n  Set.is_empty ?A = (?A = {})\n  \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n          (\\<exists>(A, X)\\<in>Q_neg.\n              Set.is_empty A \\<and> \\<not> Set.is_empty X))\n\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg =\n    (\\<Inter>(A, X)\\<in>Q_pos. X) - (\\<Union>(A, X)\\<in>Q_neg. X)", "by auto"], ["proof (state)\nthis:\n  wrapperGenericJoin Q_pos Q_neg =\n  (\\<Inter>(A, X)\\<in>Q_pos. X) - (\\<Union>(A, X)\\<in>Q_neg. X)\n\ngoal (2 subgoals):\n 1. Q = {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n 2. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "moreover"], ["proof (state)\nthis:\n  wrapperGenericJoin Q_pos Q_neg =\n  (\\<Inter>(A, X)\\<in>Q_pos. X) - (\\<Union>(A, X)\\<in>Q_neg. X)\n\ngoal (2 subgoals):\n 1. Q = {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n 2. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "have empty_u: \"(\\<Union>(A, X)\\<in>Q_pos. A) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>(A, X)\\<in>Q_pos. A) = {}", "by (metis (no_types, lifting) Q_def SUP_bot_conv(2) Set.is_empty_def True case_prod_beta' empty_iff member_filter)"], ["proof (state)\nthis:\n  (\\<Union>(A, X)\\<in>Q_pos. A) = {}\n\ngoal (2 subgoals):\n 1. Q = {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n 2. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "then"], ["proof (chain)\npicking this:\n  (\\<Union>(A, X)\\<in>Q_pos. A) = {}", "have \"V = {}\""], ["proof (prove)\nusing this:\n  (\\<Union>(A, X)\\<in>Q_pos. A) = {}\n\ngoal (1 subgoal):\n 1. V = {}", "using True V_def"], ["proof (prove)\nusing this:\n  (\\<Union>(A, X)\\<in>Q_pos. A) = {}\n  Q = {}\n  V = (\\<Union>(A, X)\\<in>Q. A)\n\ngoal (1 subgoal):\n 1. V = {}", "by blast"], ["proof (state)\nthis:\n  V = {}\n\ngoal (2 subgoals):\n 1. Q = {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n 2. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "moreover"], ["proof (state)\nthis:\n  V = {}\n\ngoal (2 subgoals):\n 1. Q = {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n 2. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "have \"\\<And>A X. (A, X) \\<in> Q_pos \\<Longrightarrow> X \\<subseteq> {replicate n None}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_pos \\<Longrightarrow> X \\<subseteq> {replicate n None}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_pos \\<Longrightarrow> X \\<subseteq> {replicate n None}", "fix A X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_pos \\<Longrightarrow> X \\<subseteq> {replicate n None}", "assume \"(A, X) \\<in> Q_pos\""], ["proof (state)\nthis:\n  (A, X) \\<in> Q_pos\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_pos \\<Longrightarrow> X \\<subseteq> {replicate n None}", "then"], ["proof (chain)\npicking this:\n  (A, X) \\<in> Q_pos", "have \"table n A X\""], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q_pos\n\ngoal (1 subgoal):\n 1. table n A X", "using assms(2)"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q_pos\n  \\<forall>(A, X)\\<in>Q_pos \\<union> Q_neg. table n A X \\<and> wf_set n A\n\ngoal (1 subgoal):\n 1. table n A X", "by auto"], ["proof (state)\nthis:\n  table n A X\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_pos \\<Longrightarrow> X \\<subseteq> {replicate n None}", "then"], ["proof (chain)\npicking this:\n  table n A X", "have \"A = {}\""], ["proof (prove)\nusing this:\n  table n A X\n\ngoal (1 subgoal):\n 1. A = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. table n A X \\<Longrightarrow> A = {}", "have \"(A, X) \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A, X) \\<notin> Q", "by (simp add: True)"], ["proof (state)\nthis:\n  (A, X) \\<notin> Q\n\ngoal (1 subgoal):\n 1. table n A X \\<Longrightarrow> A = {}", "then"], ["proof (chain)\npicking this:\n  (A, X) \\<notin> Q", "show ?thesis"], ["proof (prove)\nusing this:\n  (A, X) \\<notin> Q\n\ngoal (1 subgoal):\n 1. A = {}", "by (simp add: Q_def Set.is_empty_def \\<open>(A, X) \\<in> Q_pos\\<close>)"], ["proof (state)\nthis:\n  A = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A = {}\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_pos \\<Longrightarrow> X \\<subseteq> {replicate n None}", "then"], ["proof (chain)\npicking this:\n  A = {}", "show \"X \\<subseteq> {replicate n None}\""], ["proof (prove)\nusing this:\n  A = {}\n\ngoal (1 subgoal):\n 1. X \\<subseteq> {replicate n None}", "using \\<open>A = {}\\<close> \\<open>table n A X\\<close> table_empty unit_table_def"], ["proof (prove)\nusing this:\n  A = {}\n  A = {}\n  table n A X\n  table ?n {} ?X = (?X = empty_table \\<or> ?X = unit_table ?n)\n  unit_table ?n = {replicate ?n None}\n\ngoal (1 subgoal):\n 1. X \\<subseteq> {replicate n None}", "by fastforce"], ["proof (state)\nthis:\n  X \\<subseteq> {replicate n None}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?A, ?X) \\<in> Q_pos \\<Longrightarrow> ?X \\<subseteq> {replicate n None}\n\ngoal (2 subgoals):\n 1. Q = {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n 2. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "have \"?r \\<subseteq> {replicate n None}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg \\<subseteq> {replicate n None}", "proof (rule subsetI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> wrapperGenericJoin Q_pos Q_neg \\<Longrightarrow>\n       x \\<in> {replicate n None}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> wrapperGenericJoin Q_pos Q_neg \\<Longrightarrow>\n       x \\<in> {replicate n None}", "assume \"x \\<in> ?r\""], ["proof (state)\nthis:\n  x \\<in> wrapperGenericJoin Q_pos Q_neg\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> wrapperGenericJoin Q_pos Q_neg \\<Longrightarrow>\n       x \\<in> {replicate n None}", "obtain A X where \"(A, X) \\<in> Q_pos\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A X.\n        (A, X) \\<in> Q_pos \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>card Q_pos \\<ge> 1\\<close>"], ["proof (prove)\nusing this:\n  1 \\<le> card Q_pos\n\ngoal (1 subgoal):\n 1. (\\<And>A X.\n        (A, X) \\<in> Q_pos \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using True card.empty not_one_le_zero"], ["proof (prove)\nusing this:\n  1 \\<le> card Q_pos\n  Q = {}\n  card {} = 0\n  \\<not> (1::?'a) \\<le> (0::?'a)\n\ngoal (1 subgoal):\n 1. (\\<And>A X.\n        (A, X) \\<in> Q_pos \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis bot.extremum_uniqueI subrelI)"], ["proof (state)\nthis:\n  (A, X) \\<in> Q_pos\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> wrapperGenericJoin Q_pos Q_neg \\<Longrightarrow>\n       x \\<in> {replicate n None}", "then"], ["proof (chain)\npicking this:\n  (A, X) \\<in> Q_pos", "have \"x \\<in> X\""], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q_pos\n\ngoal (1 subgoal):\n 1. x \\<in> X", "using \\<open>x \\<in> ?r\\<close> r_def"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q_pos\n  x \\<in> wrapperGenericJoin Q_pos Q_neg\n  wrapperGenericJoin Q_pos Q_neg =\n  (\\<Inter>(A, X)\\<in>Q_pos. X) - (\\<Union>(A, X)\\<in>Q_neg. X)\n\ngoal (1 subgoal):\n 1. x \\<in> X", "by auto"], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> wrapperGenericJoin Q_pos Q_neg \\<Longrightarrow>\n       x \\<in> {replicate n None}", "then"], ["proof (chain)\npicking this:\n  x \\<in> X", "show \"x \\<in> {replicate n None}\""], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. x \\<in> {replicate n None}", "using \\<open>(A, X) \\<in> Q_pos\\<close> \\<open>\\<And>X A. (A, X) \\<in> Q_pos \\<Longrightarrow> X \\<subseteq> {replicate n None}\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> X\n  (A, X) \\<in> Q_pos\n  (?A, ?X) \\<in> Q_pos \\<Longrightarrow> ?X \\<subseteq> {replicate n None}\n\ngoal (1 subgoal):\n 1. x \\<in> {replicate n None}", "by blast"], ["proof (state)\nthis:\n  x \\<in> {replicate n None}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wrapperGenericJoin Q_pos Q_neg \\<subseteq> {replicate n None}\n\ngoal (2 subgoals):\n 1. Q = {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n 2. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "let ?v = \"replicate n None\""], ["proof (state)\ngoal (2 subgoals):\n 1. Q = {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n 2. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "proof (cases \"?r = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. wrapperGenericJoin Q_pos Q_neg = {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n 2. wrapperGenericJoin Q_pos Q_neg \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "case True"], ["proof (state)\nthis:\n  wrapperGenericJoin Q_pos Q_neg = {}\n\ngoal (2 subgoals):\n 1. wrapperGenericJoin Q_pos Q_neg = {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n 2. wrapperGenericJoin Q_pos Q_neg \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "have disj: \"\\<exists>A X. ((A, X) \\<in> Q_pos \\<and> X = {}) \\<or> ((A, X) \\<in> Q_neg \\<and> {?v} \\<subseteq> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A X.\n       (A, X) \\<in> Q_pos \\<and> X = {} \\<or>\n       (A, X) \\<in> Q_neg \\<and> {replicate n None} \\<subseteq> X", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>A X.\n       (A, X) \\<in> Q_pos \\<and> X = {} \\<or>\n       (A, X) \\<in> Q_neg \\<and>\n       {replicate n None} \\<subseteq> X \\<Longrightarrow>\n    False", "assume \"\\<nexists>A X. (A, X) \\<in> Q_pos \\<and> X = {} \\<or> (A, X) \\<in> Q_neg \\<and> {?v} \\<subseteq> X\""], ["proof (state)\nthis:\n  \\<nexists>A X.\n     (A, X) \\<in> Q_pos \\<and> X = {} \\<or>\n     (A, X) \\<in> Q_neg \\<and> {replicate n None} \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<nexists>A X.\n       (A, X) \\<in> Q_pos \\<and> X = {} \\<or>\n       (A, X) \\<in> Q_neg \\<and>\n       {replicate n None} \\<subseteq> X \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<nexists>A X.\n     (A, X) \\<in> Q_pos \\<and> X = {} \\<or>\n     (A, X) \\<in> Q_neg \\<and> {replicate n None} \\<subseteq> X", "have x_pos: \"\\<forall>(A, X)\\<in>Q_pos. X = {?v}\""], ["proof (prove)\nusing this:\n  \\<nexists>A X.\n     (A, X) \\<in> Q_pos \\<and> X = {} \\<or>\n     (A, X) \\<in> Q_neg \\<and> {replicate n None} \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<forall>(A, X)\\<in>Q_pos. X = {replicate n None}", "using \\<open>\\<And>X A. (A, X) \\<in> Q_pos \\<Longrightarrow> X \\<subseteq> {replicate n None}\\<close>"], ["proof (prove)\nusing this:\n  \\<nexists>A X.\n     (A, X) \\<in> Q_pos \\<and> X = {} \\<or>\n     (A, X) \\<in> Q_neg \\<and> {replicate n None} \\<subseteq> X\n  (?A, ?X) \\<in> Q_pos \\<Longrightarrow> ?X \\<subseteq> {replicate n None}\n\ngoal (1 subgoal):\n 1. \\<forall>(A, X)\\<in>Q_pos. X = {replicate n None}", "by blast"], ["proof (state)\nthis:\n  \\<forall>(A, X)\\<in>Q_pos. X = {replicate n None}\n\ngoal (1 subgoal):\n 1. \\<nexists>A X.\n       (A, X) \\<in> Q_pos \\<and> X = {} \\<or>\n       (A, X) \\<in> Q_neg \\<and>\n       {replicate n None} \\<subseteq> X \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  \\<forall>(A, X)\\<in>Q_pos. X = {replicate n None}\n\ngoal (1 subgoal):\n 1. \\<nexists>A X.\n       (A, X) \\<in> Q_pos \\<and> X = {} \\<or>\n       (A, X) \\<in> Q_neg \\<and>\n       {replicate n None} \\<subseteq> X \\<Longrightarrow>\n    False", "have x_neg: \"\\<forall>(A, X)\\<in>Q_neg. ?v \\<notin> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(A, X)\\<in>Q_neg. replicate n None \\<notin> X", "using \\<open>\\<nexists>A X. (A, X) \\<in> Q_pos \\<and> X = {} \\<or> (A, X) \\<in> Q_neg \\<and> {replicate n None} \\<subseteq> X\\<close>"], ["proof (prove)\nusing this:\n  \\<nexists>A X.\n     (A, X) \\<in> Q_pos \\<and> X = {} \\<or>\n     (A, X) \\<in> Q_neg \\<and> {replicate n None} \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<forall>(A, X)\\<in>Q_neg. replicate n None \\<notin> X", "by blast"], ["proof (state)\nthis:\n  \\<forall>(A, X)\\<in>Q_neg. replicate n None \\<notin> X\n\ngoal (1 subgoal):\n 1. \\<nexists>A X.\n       (A, X) \\<in> Q_pos \\<and> X = {} \\<or>\n       (A, X) \\<in> Q_neg \\<and>\n       {replicate n None} \\<subseteq> X \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>(A, X)\\<in>Q_pos. X = {replicate n None}\n  \\<forall>(A, X)\\<in>Q_neg. replicate n None \\<notin> X", "have \"?v \\<in> ?r\""], ["proof (prove)\nusing this:\n  \\<forall>(A, X)\\<in>Q_pos. X = {replicate n None}\n  \\<forall>(A, X)\\<in>Q_neg. replicate n None \\<notin> X\n\ngoal (1 subgoal):\n 1. replicate n None \\<in> wrapperGenericJoin Q_pos Q_neg", "using r_def"], ["proof (prove)\nusing this:\n  \\<forall>(A, X)\\<in>Q_pos. X = {replicate n None}\n  \\<forall>(A, X)\\<in>Q_neg. replicate n None \\<notin> X\n  wrapperGenericJoin Q_pos Q_neg =\n  (\\<Inter>(A, X)\\<in>Q_pos. X) - (\\<Union>(A, X)\\<in>Q_neg. X)\n\ngoal (1 subgoal):\n 1. replicate n None \\<in> wrapperGenericJoin Q_pos Q_neg", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(A, X)\\<in>Q_pos. X = {replicate n None};\n     \\<forall>(A, X)\\<in>Q_neg. replicate n None \\<notin> X;\n     wrapperGenericJoin Q_pos Q_neg =\n     (\\<Inter>(A, X)\\<in>Q_pos. X) - (\\<Union>(A, X)\\<in>Q_neg. X)\\<rbrakk>\n    \\<Longrightarrow> replicate n None \\<in> wrapperGenericJoin Q_pos Q_neg", "have \"?v \\<in> (\\<Inter>(A, X)\\<in>Q_pos. X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate n None \\<in> (\\<Inter>(A, X)\\<in>Q_pos. X)", "using x_pos"], ["proof (prove)\nusing this:\n  \\<forall>(A, X)\\<in>Q_pos. X = {replicate n None}\n\ngoal (1 subgoal):\n 1. replicate n None \\<in> (\\<Inter>(A, X)\\<in>Q_pos. X)", "by auto"], ["proof (state)\nthis:\n  replicate n None \\<in> (\\<Inter>(A, X)\\<in>Q_pos. X)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(A, X)\\<in>Q_pos. X = {replicate n None};\n     \\<forall>(A, X)\\<in>Q_neg. replicate n None \\<notin> X;\n     wrapperGenericJoin Q_pos Q_neg =\n     (\\<Inter>(A, X)\\<in>Q_pos. X) - (\\<Union>(A, X)\\<in>Q_neg. X)\\<rbrakk>\n    \\<Longrightarrow> replicate n None \\<in> wrapperGenericJoin Q_pos Q_neg", "moreover"], ["proof (state)\nthis:\n  replicate n None \\<in> (\\<Inter>(A, X)\\<in>Q_pos. X)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(A, X)\\<in>Q_pos. X = {replicate n None};\n     \\<forall>(A, X)\\<in>Q_neg. replicate n None \\<notin> X;\n     wrapperGenericJoin Q_pos Q_neg =\n     (\\<Inter>(A, X)\\<in>Q_pos. X) - (\\<Union>(A, X)\\<in>Q_neg. X)\\<rbrakk>\n    \\<Longrightarrow> replicate n None \\<in> wrapperGenericJoin Q_pos Q_neg", "have \"?v \\<notin> (\\<Union>(A, X)\\<in>Q_neg. X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate n None \\<notin> (\\<Union>(A, X)\\<in>Q_neg. X)", "using x_neg"], ["proof (prove)\nusing this:\n  \\<forall>(A, X)\\<in>Q_neg. replicate n None \\<notin> X\n\ngoal (1 subgoal):\n 1. replicate n None \\<notin> (\\<Union>(A, X)\\<in>Q_neg. X)", "by auto"], ["proof (state)\nthis:\n  replicate n None \\<notin> (\\<Union>(A, X)\\<in>Q_neg. X)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(A, X)\\<in>Q_pos. X = {replicate n None};\n     \\<forall>(A, X)\\<in>Q_neg. replicate n None \\<notin> X;\n     wrapperGenericJoin Q_pos Q_neg =\n     (\\<Inter>(A, X)\\<in>Q_pos. X) - (\\<Union>(A, X)\\<in>Q_neg. X)\\<rbrakk>\n    \\<Longrightarrow> replicate n None \\<in> wrapperGenericJoin Q_pos Q_neg", "ultimately"], ["proof (chain)\npicking this:\n  replicate n None \\<in> (\\<Inter>(A, X)\\<in>Q_pos. X)\n  replicate n None \\<notin> (\\<Union>(A, X)\\<in>Q_neg. X)", "show ?thesis"], ["proof (prove)\nusing this:\n  replicate n None \\<in> (\\<Inter>(A, X)\\<in>Q_pos. X)\n  replicate n None \\<notin> (\\<Union>(A, X)\\<in>Q_neg. X)\n\ngoal (1 subgoal):\n 1. replicate n None \\<in> wrapperGenericJoin Q_pos Q_neg", "using r_def"], ["proof (prove)\nusing this:\n  replicate n None \\<in> (\\<Inter>(A, X)\\<in>Q_pos. X)\n  replicate n None \\<notin> (\\<Union>(A, X)\\<in>Q_neg. X)\n  wrapperGenericJoin Q_pos Q_neg =\n  (\\<Inter>(A, X)\\<in>Q_pos. X) - (\\<Union>(A, X)\\<in>Q_neg. X)\n\ngoal (1 subgoal):\n 1. replicate n None \\<in> wrapperGenericJoin Q_pos Q_neg", "by auto"], ["proof (state)\nthis:\n  replicate n None \\<in> wrapperGenericJoin Q_pos Q_neg\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  replicate n None \\<in> wrapperGenericJoin Q_pos Q_neg\n\ngoal (1 subgoal):\n 1. \\<nexists>A X.\n       (A, X) \\<in> Q_pos \\<and> X = {} \\<or>\n       (A, X) \\<in> Q_neg \\<and>\n       {replicate n None} \\<subseteq> X \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  replicate n None \\<in> wrapperGenericJoin Q_pos Q_neg", "show \"False\""], ["proof (prove)\nusing this:\n  replicate n None \\<in> wrapperGenericJoin Q_pos Q_neg\n\ngoal (1 subgoal):\n 1. False", "using True"], ["proof (prove)\nusing this:\n  replicate n None \\<in> wrapperGenericJoin Q_pos Q_neg\n  wrapperGenericJoin Q_pos Q_neg = {}\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>A X.\n     (A, X) \\<in> Q_pos \\<and> X = {} \\<or>\n     (A, X) \\<in> Q_neg \\<and> {replicate n None} \\<subseteq> X\n\ngoal (2 subgoals):\n 1. wrapperGenericJoin Q_pos Q_neg = {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n 2. wrapperGenericJoin Q_pos Q_neg \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "have \"\\<not> (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and> (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n            (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n            (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "proof (rule notI)"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n    (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X) \\<Longrightarrow>\n    False", "assume \"wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and> (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)\""], ["proof (state)\nthis:\n  wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n  (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)\n\ngoal (1 subgoal):\n 1. wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n    (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X) \\<Longrightarrow>\n    False", "have \"z = ?v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z = replicate n None", "using \\<open>wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and> (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)\\<close> empty_u wf_tuple_empty"], ["proof (prove)\nusing this:\n  wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n  (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)\n  (\\<Union>(A, X)\\<in>Q_pos. A) = {}\n  wf_tuple ?n {} ?v = (?v = replicate ?n None)\n\ngoal (1 subgoal):\n 1. z = replicate n None", "by auto"], ["proof (state)\nthis:\n  z = replicate n None\n\ngoal (1 subgoal):\n 1. wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n    (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  z = replicate n None", "have \"\\<And>A. restrict A z = z\""], ["proof (prove)\nusing this:\n  z = replicate n None\n\ngoal (1 subgoal):\n 1. \\<And>A. restrict A z = z", "by (metis getIJ.restrict_index_out getIJ_axioms length_replicate length_restrict nth_replicate nth_restrict simple_list_index_equality)"], ["proof (state)\nthis:\n  restrict ?A1 z = z\n\ngoal (1 subgoal):\n 1. wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n    (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  restrict ?A1 z = z", "have \"(\\<exists>(A, X)\\<in>Q_pos. z \\<notin> X) \\<or> (\\<exists>(A, X)\\<in>Q_neg. z \\<in> X)\""], ["proof (prove)\nusing this:\n  restrict ?A1 z = z\n\ngoal (1 subgoal):\n 1. (\\<exists>(A, X)\\<in>Q_pos. z \\<notin> X) \\<or>\n    (\\<exists>(A, X)\\<in>Q_neg. z \\<in> X)", "using disj"], ["proof (prove)\nusing this:\n  restrict ?A1 z = z\n  \\<exists>A X.\n     (A, X) \\<in> Q_pos \\<and> X = {} \\<or>\n     (A, X) \\<in> Q_neg \\<and> {replicate n None} \\<subseteq> X\n\ngoal (1 subgoal):\n 1. (\\<exists>(A, X)\\<in>Q_pos. z \\<notin> X) \\<or>\n    (\\<exists>(A, X)\\<in>Q_neg. z \\<in> X)", "using \\<open>z = replicate n None\\<close>"], ["proof (prove)\nusing this:\n  restrict ?A1 z = z\n  \\<exists>A X.\n     (A, X) \\<in> Q_pos \\<and> X = {} \\<or>\n     (A, X) \\<in> Q_neg \\<and> {replicate n None} \\<subseteq> X\n  z = replicate n None\n\ngoal (1 subgoal):\n 1. (\\<exists>(A, X)\\<in>Q_pos. z \\<notin> X) \\<or>\n    (\\<exists>(A, X)\\<in>Q_neg. z \\<in> X)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>(A, X)\\<in>Q_pos. z \\<notin> X) \\<or>\n  (\\<exists>(A, X)\\<in>Q_neg. z \\<in> X)\n\ngoal (1 subgoal):\n 1. wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n    (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  (\\<exists>(A, X)\\<in>Q_pos. z \\<notin> X) \\<or>\n  (\\<exists>(A, X)\\<in>Q_neg. z \\<in> X)", "show \"False\""], ["proof (prove)\nusing this:\n  (\\<exists>(A, X)\\<in>Q_pos. z \\<notin> X) \\<or>\n  (\\<exists>(A, X)\\<in>Q_neg. z \\<in> X)\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<And>A. restrict A z = z\\<close> \\<open>wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and> (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)\\<close>"], ["proof (prove)\nusing this:\n  (\\<exists>(A, X)\\<in>Q_pos. z \\<notin> X) \\<or>\n  (\\<exists>(A, X)\\<in>Q_neg. z \\<in> X)\n  restrict ?A z = z\n  wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n  (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n          (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n          (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n\ngoal (2 subgoals):\n 1. wrapperGenericJoin Q_pos Q_neg = {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n 2. wrapperGenericJoin Q_pos Q_neg \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "then"], ["proof (chain)\npicking this:\n  \\<not> (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n          (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n          (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n          (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n          (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n\ngoal (1 subgoal):\n 1. (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "using True"], ["proof (prove)\nusing this:\n  \\<not> (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n          (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n          (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n  wrapperGenericJoin Q_pos Q_neg = {}\n\ngoal (1 subgoal):\n 1. (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "by blast"], ["proof (state)\nthis:\n  (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n  (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n   (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "case False"], ["proof (state)\nthis:\n  wrapperGenericJoin Q_pos Q_neg \\<noteq> {}\n\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "then"], ["proof (chain)\npicking this:\n  wrapperGenericJoin Q_pos Q_neg \\<noteq> {}", "have \"?r = {?v}\""], ["proof (prove)\nusing this:\n  wrapperGenericJoin Q_pos Q_neg \\<noteq> {}\n\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg = {replicate n None}", "using \\<open>wrapperGenericJoin Q_pos Q_neg \\<subseteq> {replicate n None}\\<close>"], ["proof (prove)\nusing this:\n  wrapperGenericJoin Q_pos Q_neg \\<noteq> {}\n  wrapperGenericJoin Q_pos Q_neg \\<subseteq> {replicate n None}\n\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg = {replicate n None}", "by blast"], ["proof (state)\nthis:\n  wrapperGenericJoin Q_pos Q_neg = {replicate n None}\n\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "then"], ["proof (chain)\npicking this:\n  wrapperGenericJoin Q_pos Q_neg = {replicate n None}", "have \"\\<And>A X. (A, X) \\<in> Q_pos \\<Longrightarrow> X = {?v}\""], ["proof (prove)\nusing this:\n  wrapperGenericJoin Q_pos Q_neg = {replicate n None}\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q_pos \\<Longrightarrow> X = {replicate n None}", "using Set.is_empty_def \\<open>\\<And>X A. (A, X) \\<in> Q_pos \\<Longrightarrow> X \\<subseteq> {replicate n None}\\<close> forall"], ["proof (prove)\nusing this:\n  wrapperGenericJoin Q_pos Q_neg = {replicate n None}\n  Set.is_empty ?A = (?A = {})\n  (?A, ?X) \\<in> Q_pos \\<Longrightarrow> ?X \\<subseteq> {replicate n None}\n  (\\<forall>(A, X)\\<in>Q_pos. \\<not> Set.is_empty X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. \\<not> Set.is_empty A \\<or> Set.is_empty X)\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q_pos \\<Longrightarrow> X = {replicate n None}", "by fastforce"], ["proof (state)\nthis:\n  (?A1, ?X1) \\<in> Q_pos \\<Longrightarrow> ?X1 = {replicate n None}\n\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "then"], ["proof (chain)\npicking this:\n  (?A1, ?X1) \\<in> Q_pos \\<Longrightarrow> ?X1 = {replicate n None}", "have \"\\<forall>(A, X)\\<in>Q_pos. X = {?v}\""], ["proof (prove)\nusing this:\n  (?A1, ?X1) \\<in> Q_pos \\<Longrightarrow> ?X1 = {replicate n None}\n\ngoal (1 subgoal):\n 1. \\<forall>(A, X)\\<in>Q_pos. X = {replicate n None}", "by blast"], ["proof (state)\nthis:\n  \\<forall>(A, X)\\<in>Q_pos. X = {replicate n None}\n\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "moreover"], ["proof (state)\nthis:\n  \\<forall>(A, X)\\<in>Q_pos. X = {replicate n None}\n\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "have \"\\<forall>(A, X)\\<in>Q_neg. ?v \\<notin> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(A, X)\\<in>Q_neg. replicate n None \\<notin> X", "using \\<open>wrapperGenericJoin Q_pos Q_neg = {replicate n None}\\<close> r_def"], ["proof (prove)\nusing this:\n  wrapperGenericJoin Q_pos Q_neg = {replicate n None}\n  wrapperGenericJoin Q_pos Q_neg =\n  (\\<Inter>(A, X)\\<in>Q_pos. X) - (\\<Union>(A, X)\\<in>Q_neg. X)\n\ngoal (1 subgoal):\n 1. \\<forall>(A, X)\\<in>Q_neg. replicate n None \\<notin> X", "by auto"], ["proof (state)\nthis:\n  \\<forall>(A, X)\\<in>Q_neg. replicate n None \\<notin> X\n\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>(A, X)\\<in>Q_pos. X = {replicate n None}\n  \\<forall>(A, X)\\<in>Q_neg. replicate n None \\<notin> X", "show ?thesis (is \"?a \\<longleftrightarrow> ?b\")"], ["proof (prove)\nusing this:\n  \\<forall>(A, X)\\<in>Q_pos. X = {replicate n None}\n  \\<forall>(A, X)\\<in>Q_neg. replicate n None \\<notin> X\n\ngoal (1 subgoal):\n 1. (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(A, X)\\<in>Q_pos. X = {replicate n None};\n     \\<forall>(A, X)\\<in>Q_neg. replicate n None \\<notin> X\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n                      (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n                       (\\<forall>(A, X)\\<in>Q_pos.\n                           restrict A z \\<in> X) \\<and>\n                       (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "have \"?a \\<Longrightarrow> ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> wrapperGenericJoin Q_pos Q_neg \\<Longrightarrow>\n    wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n    (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<in> wrapperGenericJoin Q_pos Q_neg \\<Longrightarrow>\n    wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n    (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)", "assume \"?a\""], ["proof (state)\nthis:\n  z \\<in> wrapperGenericJoin Q_pos Q_neg\n\ngoal (1 subgoal):\n 1. z \\<in> wrapperGenericJoin Q_pos Q_neg \\<Longrightarrow>\n    wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n    (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)", "then"], ["proof (chain)\npicking this:\n  z \\<in> wrapperGenericJoin Q_pos Q_neg", "have \"z = ?v\""], ["proof (prove)\nusing this:\n  z \\<in> wrapperGenericJoin Q_pos Q_neg\n\ngoal (1 subgoal):\n 1. z = replicate n None", "using \\<open>wrapperGenericJoin Q_pos Q_neg = {replicate n None}\\<close>"], ["proof (prove)\nusing this:\n  z \\<in> wrapperGenericJoin Q_pos Q_neg\n  wrapperGenericJoin Q_pos Q_neg = {replicate n None}\n\ngoal (1 subgoal):\n 1. z = replicate n None", "by blast"], ["proof (state)\nthis:\n  z = replicate n None\n\ngoal (1 subgoal):\n 1. z \\<in> wrapperGenericJoin Q_pos Q_neg \\<Longrightarrow>\n    wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n    (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)", "then"], ["proof (chain)\npicking this:\n  z = replicate n None", "have \"\\<And>A. restrict A z = z\""], ["proof (prove)\nusing this:\n  z = replicate n None\n\ngoal (1 subgoal):\n 1. \\<And>A. restrict A z = z", "by (metis getIJ.restrict_index_out getIJ_axioms length_replicate length_restrict nth_replicate nth_restrict simple_list_index_equality)"], ["proof (state)\nthis:\n  restrict ?A1 z = z\n\ngoal (1 subgoal):\n 1. z \\<in> wrapperGenericJoin Q_pos Q_neg \\<Longrightarrow>\n    wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n    (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)", "then"], ["proof (chain)\npicking this:\n  restrict ?A1 z = z", "show \"?b\""], ["proof (prove)\nusing this:\n  restrict ?A1 z = z\n\ngoal (1 subgoal):\n 1. wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n    (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)", "using \\<open>\\<forall>(A, X)\\<in>Q_neg. replicate n None \\<notin> X\\<close> \\<open>\\<forall>(A, X)\\<in>Q_pos. X = {replicate n None}\\<close>\n              \\<open>z = replicate n None\\<close> empty_u wf_tuple_empty"], ["proof (prove)\nusing this:\n  restrict ?A1 z = z\n  \\<forall>(A, X)\\<in>Q_neg. replicate n None \\<notin> X\n  \\<forall>(A, X)\\<in>Q_pos. X = {replicate n None}\n  z = replicate n None\n  (\\<Union>(A, X)\\<in>Q_pos. A) = {}\n  wf_tuple ?n {} ?v = (?v = replicate ?n None)\n\ngoal (1 subgoal):\n 1. wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n    (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)", "by fastforce"], ["proof (state)\nthis:\n  wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n  (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z \\<in> wrapperGenericJoin Q_pos Q_neg \\<Longrightarrow>\n  wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n  (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(A, X)\\<in>Q_pos. X = {replicate n None};\n     \\<forall>(A, X)\\<in>Q_neg. replicate n None \\<notin> X\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n                      (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n                       (\\<forall>(A, X)\\<in>Q_pos.\n                           restrict A z \\<in> X) \\<and>\n                       (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "moreover"], ["proof (state)\nthis:\n  z \\<in> wrapperGenericJoin Q_pos Q_neg \\<Longrightarrow>\n  wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n  (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(A, X)\\<in>Q_pos. X = {replicate n None};\n     \\<forall>(A, X)\\<in>Q_neg. replicate n None \\<notin> X\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n                      (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n                       (\\<forall>(A, X)\\<in>Q_pos.\n                           restrict A z \\<in> X) \\<and>\n                       (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "have \"?b \\<Longrightarrow> ?a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n    (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X) \\<Longrightarrow>\n    z \\<in> wrapperGenericJoin Q_pos Q_neg", "using \\<open>wrapperGenericJoin Q_pos Q_neg = {replicate n None}\\<close> empty_u wf_tuple_empty"], ["proof (prove)\nusing this:\n  wrapperGenericJoin Q_pos Q_neg = {replicate n None}\n  (\\<Union>(A, X)\\<in>Q_pos. A) = {}\n  wf_tuple ?n {} ?v = (?v = replicate ?n None)\n\ngoal (1 subgoal):\n 1. wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n    (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X) \\<Longrightarrow>\n    z \\<in> wrapperGenericJoin Q_pos Q_neg", "by auto"], ["proof (state)\nthis:\n  wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n  (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X) \\<Longrightarrow>\n  z \\<in> wrapperGenericJoin Q_pos Q_neg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>(A, X)\\<in>Q_pos. X = {replicate n None};\n     \\<forall>(A, X)\\<in>Q_neg. replicate n None \\<notin> X\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n                      (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n                       (\\<forall>(A, X)\\<in>Q_pos.\n                           restrict A z \\<in> X) \\<and>\n                       (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "ultimately"], ["proof (chain)\npicking this:\n  z \\<in> wrapperGenericJoin Q_pos Q_neg \\<Longrightarrow>\n  wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n  (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)\n  wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n  (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X) \\<Longrightarrow>\n  z \\<in> wrapperGenericJoin Q_pos Q_neg", "show ?thesis"], ["proof (prove)\nusing this:\n  z \\<in> wrapperGenericJoin Q_pos Q_neg \\<Longrightarrow>\n  wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n  (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)\n  wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n  (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X) \\<Longrightarrow>\n  z \\<in> wrapperGenericJoin Q_pos Q_neg\n\ngoal (1 subgoal):\n 1. (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "by blast"], ["proof (state)\nthis:\n  (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n  (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n   (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n  (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n   (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n  (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n   (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "case False"], ["proof (state)\nthis:\n  Q \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "then"], ["proof (chain)\npicking this:\n  Q \\<noteq> {}", "have False_prev: \"Q \\<noteq> {}\""], ["proof (prove)\nusing this:\n  Q \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  Q \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "have \"covering V Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. covering V Q", "using V_def covering_def"], ["proof (prove)\nusing this:\n  V = (\\<Union>(A, X)\\<in>Q. A)\n  covering ?V ?Q = (?V \\<subseteq> (\\<Union>(S, X)\\<in>?Q. S))\n\ngoal (1 subgoal):\n 1. covering V Q", "by blast"], ["proof (state)\nthis:\n  covering V Q\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "moreover"], ["proof (state)\nthis:\n  covering V Q\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "have \"included V Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. included V Q", "using included_def V_def"], ["proof (prove)\nusing this:\n  included ?V ?Q = (\\<forall>(S, X)\\<in>?Q. S \\<subseteq> ?V)\n  V = (\\<Union>(A, X)\\<in>Q. A)\n\ngoal (1 subgoal):\n 1. included V Q", "by fastforce"], ["proof (state)\nthis:\n  included V Q\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "define Qn where \"Qn = Set.filter (\\<lambda>(A, _). A \\<subseteq> V \\<and> card A \\<ge> 1) Q_neg\""], ["proof (state)\nthis:\n  Qn =\n  Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n   Q_neg\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "then"], ["proof (chain)\npicking this:\n  Qn =\n  Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n   Q_neg", "have \"Qn \\<subseteq> Q_neg\""], ["proof (prove)\nusing this:\n  Qn =\n  Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n   Q_neg\n\ngoal (1 subgoal):\n 1. Qn \\<subseteq> Q_neg", "by auto"], ["proof (state)\nthis:\n  Qn \\<subseteq> Q_neg\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "moreover"], ["proof (state)\nthis:\n  Qn \\<subseteq> Q_neg\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "have \"wf_query n V Q Qn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_query n V Q Qn", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_query n V Q Qn", "have \"wf_set n V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_set n V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_set n V", "have \"\\<And>x. x \\<in> V \\<Longrightarrow> x < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> V \\<Longrightarrow> x < n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> V \\<Longrightarrow> x < n", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> V \\<Longrightarrow> x < n", "assume \"x \\<in> V\""], ["proof (state)\nthis:\n  x \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> V \\<Longrightarrow> x < n", "obtain A X where \"x \\<in> A\" \"(A, X) \\<in> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A X.\n        \\<lbrakk>x \\<in> A; (A, X) \\<in> Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using V_def \\<open>x \\<in> V\\<close>"], ["proof (prove)\nusing this:\n  V = (\\<Union>(A, X)\\<in>Q. A)\n  x \\<in> V\n\ngoal (1 subgoal):\n 1. (\\<And>A X.\n        \\<lbrakk>x \\<in> A; (A, X) \\<in> Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> A\n  (A, X) \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> V \\<Longrightarrow> x < n", "then"], ["proof (chain)\npicking this:\n  x \\<in> A\n  (A, X) \\<in> Q", "have \"(A, X) \\<in> (Q_pos \\<union> Q_neg)\""], ["proof (prove)\nusing this:\n  x \\<in> A\n  (A, X) \\<in> Q\n\ngoal (1 subgoal):\n 1. (A, X) \\<in> Q_pos \\<union> Q_neg", "by (simp add: Q_def)"], ["proof (state)\nthis:\n  (A, X) \\<in> Q_pos \\<union> Q_neg\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> V \\<Longrightarrow> x < n", "then"], ["proof (chain)\npicking this:\n  (A, X) \\<in> Q_pos \\<union> Q_neg", "have \"wf_set n A\""], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q_pos \\<union> Q_neg\n\ngoal (1 subgoal):\n 1. wf_set n A", "using assms(2)"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q_pos \\<union> Q_neg\n  \\<forall>(A, X)\\<in>Q_pos \\<union> Q_neg. table n A X \\<and> wf_set n A\n\ngoal (1 subgoal):\n 1. wf_set n A", "by auto"], ["proof (state)\nthis:\n  wf_set n A\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> V \\<Longrightarrow> x < n", "then"], ["proof (chain)\npicking this:\n  wf_set n A", "show \"x < n\""], ["proof (prove)\nusing this:\n  wf_set n A\n\ngoal (1 subgoal):\n 1. x < n", "using \\<open>x \\<in> A\\<close> wf_set_def"], ["proof (prove)\nusing this:\n  wf_set n A\n  x \\<in> A\n  wf_set ?n ?V = (\\<forall>x\\<in>?V. x < ?n)\n\ngoal (1 subgoal):\n 1. x < n", "by blast"], ["proof (state)\nthis:\n  x < n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> V \\<Longrightarrow> ?x < n\n\ngoal (1 subgoal):\n 1. wf_set n V", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> V \\<Longrightarrow> ?x < n", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> V \\<Longrightarrow> ?x < n\n\ngoal (1 subgoal):\n 1. wf_set n V", "using wf_set_def"], ["proof (prove)\nusing this:\n  ?x \\<in> V \\<Longrightarrow> ?x < n\n  wf_set ?n ?V = (\\<forall>x\\<in>?V. x < ?n)\n\ngoal (1 subgoal):\n 1. wf_set n V", "by blast"], ["proof (state)\nthis:\n  wf_set n V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf_set n V\n\ngoal (1 subgoal):\n 1. wf_query n V Q Qn", "moreover"], ["proof (state)\nthis:\n  wf_set n V\n\ngoal (1 subgoal):\n 1. wf_query n V Q Qn", "have \"card Q \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> card Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 \\<le> card Q", "have \"finite Q_pos\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite Q_pos", "using assms(1) not_one_le_zero"], ["proof (prove)\nusing this:\n  1 \\<le> card Q_pos\n  \\<not> (1::?'a) \\<le> (0::?'a)\n\ngoal (1 subgoal):\n 1. finite Q_pos", "by fastforce"], ["proof (state)\nthis:\n  finite Q_pos\n\ngoal (1 subgoal):\n 1. 1 \\<le> card Q", "then"], ["proof (chain)\npicking this:\n  finite Q_pos", "have \"finite Q\""], ["proof (prove)\nusing this:\n  finite Q_pos\n\ngoal (1 subgoal):\n 1. finite Q", "by (simp add: Q_def)"], ["proof (state)\nthis:\n  finite Q\n\ngoal (1 subgoal):\n 1. 1 \\<le> card Q", "then"], ["proof (chain)\npicking this:\n  finite Q", "show ?thesis"], ["proof (prove)\nusing this:\n  finite Q\n\ngoal (1 subgoal):\n 1. 1 \\<le> card Q", "using False"], ["proof (prove)\nusing this:\n  finite Q\n  Q \\<noteq> {}\n\ngoal (1 subgoal):\n 1. 1 \\<le> card Q", "by (simp add: Suc_leI card_gt_0_iff)"], ["proof (state)\nthis:\n  1 \\<le> card Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 \\<le> card Q\n\ngoal (1 subgoal):\n 1. wf_query n V Q Qn", "moreover"], ["proof (state)\nthis:\n  1 \\<le> card Q\n\ngoal (1 subgoal):\n 1. wf_query n V Q Qn", "have \"\\<And>Y. Y \\<in> (Q \\<union> Q_neg) \\<Longrightarrow> wf_atable n Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y. Y \\<in> Q \\<union> Q_neg \\<Longrightarrow> wf_atable n Y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y. Y \\<in> Q \\<union> Q_neg \\<Longrightarrow> wf_atable n Y", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y. Y \\<in> Q \\<union> Q_neg \\<Longrightarrow> wf_atable n Y", "assume \"Y \\<in> (Q \\<union> Q_neg)\""], ["proof (state)\nthis:\n  Y \\<in> Q \\<union> Q_neg\n\ngoal (1 subgoal):\n 1. \\<And>Y. Y \\<in> Q \\<union> Q_neg \\<Longrightarrow> wf_atable n Y", "then"], ["proof (chain)\npicking this:\n  Y \\<in> Q \\<union> Q_neg", "obtain A X where \"Y = (A, X)\""], ["proof (prove)\nusing this:\n  Y \\<in> Q \\<union> Q_neg\n\ngoal (1 subgoal):\n 1. (\\<And>A X. Y = (A, X) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson case_prodE case_prodI2)"], ["proof (state)\nthis:\n  Y = (A, X)\n\ngoal (1 subgoal):\n 1. \\<And>Y. Y \\<in> Q \\<union> Q_neg \\<Longrightarrow> wf_atable n Y", "then"], ["proof (chain)\npicking this:\n  Y = (A, X)", "have \"table n A X\""], ["proof (prove)\nusing this:\n  Y = (A, X)\n\ngoal (1 subgoal):\n 1. table n A X", "by (metis (no_types, lifting) Q_def UnE Un_iff \\<open>Y \\<in> Q \\<union> Q_neg\\<close> assms(2) case_prodD member_filter sup_commute)"], ["proof (state)\nthis:\n  table n A X\n\ngoal (1 subgoal):\n 1. \\<And>Y. Y \\<in> Q \\<union> Q_neg \\<Longrightarrow> wf_atable n Y", "moreover"], ["proof (state)\nthis:\n  table n A X\n\ngoal (1 subgoal):\n 1. \\<And>Y. Y \\<in> Q \\<union> Q_neg \\<Longrightarrow> wf_atable n Y", "have \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite A", "have \"wf_set n A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_set n A", "by (metis (no_types, lifting) Q_def UnE Un_iff \\<open>Y = (A, X)\\<close> \\<open>Y \\<in> Q \\<union> Q_neg\\<close> assms(2) case_prod_conv member_filter sup.commute)"], ["proof (state)\nthis:\n  wf_set n A\n\ngoal (1 subgoal):\n 1. finite A", "then"], ["proof (chain)\npicking this:\n  wf_set n A", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_set n A\n\ngoal (1 subgoal):\n 1. finite A", "using wf_set_finite"], ["proof (prove)\nusing this:\n  wf_set n A\n  wf_set ?n ?A \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite A", "by blast"], ["proof (state)\nthis:\n  finite A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. \\<And>Y. Y \\<in> Q \\<union> Q_neg \\<Longrightarrow> wf_atable n Y", "ultimately"], ["proof (chain)\npicking this:\n  table n A X\n  finite A", "show \"wf_atable n Y\""], ["proof (prove)\nusing this:\n  table n A X\n  finite A\n\ngoal (1 subgoal):\n 1. wf_atable n Y", "by (simp add: \\<open>Y = (A, X)\\<close> wf_atable_def)"], ["proof (state)\nthis:\n  wf_atable n Y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?Y \\<in> Q \\<union> Q_neg \\<Longrightarrow> wf_atable n ?Y\n\ngoal (1 subgoal):\n 1. wf_query n V Q Qn", "ultimately"], ["proof (chain)\npicking this:\n  wf_set n V\n  1 \\<le> card Q\n  ?Y \\<in> Q \\<union> Q_neg \\<Longrightarrow> wf_atable n ?Y", "have \"wf_query n V Q Q_neg\""], ["proof (prove)\nusing this:\n  wf_set n V\n  1 \\<le> card Q\n  ?Y \\<in> Q \\<union> Q_neg \\<Longrightarrow> wf_atable n ?Y\n\ngoal (1 subgoal):\n 1. wf_query n V Q Q_neg", "using wf_query_def"], ["proof (prove)\nusing this:\n  wf_set n V\n  1 \\<le> card Q\n  ?Y \\<in> Q \\<union> Q_neg \\<Longrightarrow> wf_atable n ?Y\n  wf_query ?n ?V ?Q_pos ?Q_neg =\n  ((\\<forall>X\\<in>?Q_pos \\<union> ?Q_neg. wf_atable ?n X) \\<and>\n   wf_set ?n ?V \\<and> 1 \\<le> card ?Q_pos)\n\ngoal (1 subgoal):\n 1. wf_query n V Q Q_neg", "by blast"], ["proof (state)\nthis:\n  wf_query n V Q Q_neg\n\ngoal (1 subgoal):\n 1. wf_query n V Q Qn", "then"], ["proof (chain)\npicking this:\n  wf_query n V Q Q_neg", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_query n V Q Q_neg\n\ngoal (1 subgoal):\n 1. wf_query n V Q Qn", "using Un_iff \\<open>Qn \\<subseteq> Q_neg\\<close> subsetD wf_query_def"], ["proof (prove)\nusing this:\n  wf_query n V Q Q_neg\n  (?c \\<in> ?A \\<union> ?B) = (?c \\<in> ?A \\<or> ?c \\<in> ?B)\n  Qn \\<subseteq> Q_neg\n  \\<lbrakk>?A \\<subseteq> ?B; ?c \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?c \\<in> ?B\n  wf_query ?n ?V ?Q_pos ?Q_neg =\n  ((\\<forall>X\\<in>?Q_pos \\<union> ?Q_neg. wf_atable ?n X) \\<and>\n   wf_set ?n ?V \\<and> 1 \\<le> card ?Q_pos)\n\ngoal (1 subgoal):\n 1. wf_query n V Q Qn", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_query n V Q Q_neg;\n     \\<And>c A B. (c \\<in> A \\<union> B) = (c \\<in> A \\<or> c \\<in> B);\n     Qn \\<subseteq> Q_neg;\n     \\<And>A B c.\n        \\<lbrakk>A \\<subseteq> B; c \\<in> A\\<rbrakk>\n        \\<Longrightarrow> c \\<in> B;\n     \\<And>n V Q_pos Q_neg.\n        wf_query n V Q_pos Q_neg =\n        ((\\<forall>X\\<in>Q_pos \\<union> Q_neg. wf_atable n X) \\<and>\n         wf_set n V \\<and> 1 \\<le> card Q_pos)\\<rbrakk>\n    \\<Longrightarrow> wf_query n V Q Qn", "obtain pp :: \"(nat set \\<times> 'a option list set) set \\<Rightarrow> (nat set \\<times> 'a option list set) set \\<Rightarrow> nat \\<Rightarrow> nat set \\<times> 'a option list set\" where\n          f1: \"\\<forall>n N P Pa. (wf_query n N P Pa \\<or> \\<not> 1 \\<le> card P \\<or> \\<not> wf_set n N \\<or> \\<not> wf_atable n (pp Pa P n) \\<and> pp Pa P n \\<in> P \\<union> Pa) \\<and> (1 \\<le> card P \\<and> wf_set n N \\<and> (\\<forall>p. wf_atable n p \\<or> p \\<notin> P \\<union> Pa) \\<or> \\<not> wf_query n N P Pa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pp.\n        \\<forall>n N P Pa.\n           (wf_query n N P Pa \\<or>\n            \\<not> 1 \\<le> card P \\<or>\n            \\<not> wf_set n N \\<or>\n            \\<not> wf_atable n (pp Pa P n) \\<and>\n            pp Pa P n \\<in> P \\<union> Pa) \\<and>\n           (1 \\<le> card P \\<and>\n            wf_set n N \\<and>\n            (\\<forall>p. wf_atable n p \\<or> p \\<notin> P \\<union> Pa) \\<or>\n            \\<not> wf_query n N P Pa) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis (full_types) wf_query_def)"], ["proof (state)\nthis:\n  \\<forall>n N P Pa.\n     (wf_query n N P Pa \\<or>\n      \\<not> 1 \\<le> card P \\<or>\n      \\<not> wf_set n N \\<or>\n      \\<not> wf_atable n (pp Pa P n) \\<and>\n      pp Pa P n \\<in> P \\<union> Pa) \\<and>\n     (1 \\<le> card P \\<and>\n      wf_set n N \\<and>\n      (\\<forall>p. wf_atable n p \\<or> p \\<notin> P \\<union> Pa) \\<or>\n      \\<not> wf_query n N P Pa)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_query n V Q Q_neg;\n     \\<And>c A B. (c \\<in> A \\<union> B) = (c \\<in> A \\<or> c \\<in> B);\n     Qn \\<subseteq> Q_neg;\n     \\<And>A B c.\n        \\<lbrakk>A \\<subseteq> B; c \\<in> A\\<rbrakk>\n        \\<Longrightarrow> c \\<in> B;\n     \\<And>n V Q_pos Q_neg.\n        wf_query n V Q_pos Q_neg =\n        ((\\<forall>X\\<in>Q_pos \\<union> Q_neg. wf_atable n X) \\<and>\n         wf_set n V \\<and> 1 \\<le> card Q_pos)\\<rbrakk>\n    \\<Longrightarrow> wf_query n V Q Qn", "have \"pp Qn Q n \\<in> Qn \\<longrightarrow> pp Qn Q n \\<in> Q_neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp Qn Q n \\<in> Qn \\<longrightarrow> pp Qn Q n \\<in> Q_neg", "using \\<open>Qn \\<subseteq> Q_neg\\<close>"], ["proof (prove)\nusing this:\n  Qn \\<subseteq> Q_neg\n\ngoal (1 subgoal):\n 1. pp Qn Q n \\<in> Qn \\<longrightarrow> pp Qn Q n \\<in> Q_neg", "by blast"], ["proof (state)\nthis:\n  pp Qn Q n \\<in> Qn \\<longrightarrow> pp Qn Q n \\<in> Q_neg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_query n V Q Q_neg;\n     \\<And>c A B. (c \\<in> A \\<union> B) = (c \\<in> A \\<or> c \\<in> B);\n     Qn \\<subseteq> Q_neg;\n     \\<And>A B c.\n        \\<lbrakk>A \\<subseteq> B; c \\<in> A\\<rbrakk>\n        \\<Longrightarrow> c \\<in> B;\n     \\<And>n V Q_pos Q_neg.\n        wf_query n V Q_pos Q_neg =\n        ((\\<forall>X\\<in>Q_pos \\<union> Q_neg. wf_atable n X) \\<and>\n         wf_set n V \\<and> 1 \\<le> card Q_pos)\\<rbrakk>\n    \\<Longrightarrow> wf_query n V Q Qn", "then"], ["proof (chain)\npicking this:\n  pp Qn Q n \\<in> Qn \\<longrightarrow> pp Qn Q n \\<in> Q_neg", "have \"pp Qn Q n \\<in> Q \\<union> Q_neg \\<or> wf_query n V Q Qn\""], ["proof (prove)\nusing this:\n  pp Qn Q n \\<in> Qn \\<longrightarrow> pp Qn Q n \\<in> Q_neg\n\ngoal (1 subgoal):\n 1. pp Qn Q n \\<in> Q \\<union> Q_neg \\<or> wf_query n V Q Qn", "using \\<open>1 \\<le> card Q\\<close> \\<open>wf_set n V\\<close> f1"], ["proof (prove)\nusing this:\n  pp Qn Q n \\<in> Qn \\<longrightarrow> pp Qn Q n \\<in> Q_neg\n  1 \\<le> card Q\n  wf_set n V\n  \\<forall>n N P Pa.\n     (wf_query n N P Pa \\<or>\n      \\<not> 1 \\<le> card P \\<or>\n      \\<not> wf_set n N \\<or>\n      \\<not> wf_atable n (pp Pa P n) \\<and>\n      pp Pa P n \\<in> P \\<union> Pa) \\<and>\n     (1 \\<le> card P \\<and>\n      wf_set n N \\<and>\n      (\\<forall>p. wf_atable n p \\<or> p \\<notin> P \\<union> Pa) \\<or>\n      \\<not> wf_query n N P Pa)\n\ngoal (1 subgoal):\n 1. pp Qn Q n \\<in> Q \\<union> Q_neg \\<or> wf_query n V Q Qn", "by auto"], ["proof (state)\nthis:\n  pp Qn Q n \\<in> Q \\<union> Q_neg \\<or> wf_query n V Q Qn\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_query n V Q Q_neg;\n     \\<And>c A B. (c \\<in> A \\<union> B) = (c \\<in> A \\<or> c \\<in> B);\n     Qn \\<subseteq> Q_neg;\n     \\<And>A B c.\n        \\<lbrakk>A \\<subseteq> B; c \\<in> A\\<rbrakk>\n        \\<Longrightarrow> c \\<in> B;\n     \\<And>n V Q_pos Q_neg.\n        wf_query n V Q_pos Q_neg =\n        ((\\<forall>X\\<in>Q_pos \\<union> Q_neg. wf_atable n X) \\<and>\n         wf_set n V \\<and> 1 \\<le> card Q_pos)\\<rbrakk>\n    \\<Longrightarrow> wf_query n V Q Qn", "then"], ["proof (chain)\npicking this:\n  pp Qn Q n \\<in> Q \\<union> Q_neg \\<or> wf_query n V Q Qn", "show ?thesis"], ["proof (prove)\nusing this:\n  pp Qn Q n \\<in> Q \\<union> Q_neg \\<or> wf_query n V Q Qn\n\ngoal (1 subgoal):\n 1. wf_query n V Q Qn", "using \\<open>1 \\<le> card Q\\<close> \\<open>\\<And>Y. Y \\<in> Q \\<union> Q_neg \\<Longrightarrow> wf_atable n Y\\<close> \\<open>wf_set n V\\<close> f1"], ["proof (prove)\nusing this:\n  pp Qn Q n \\<in> Q \\<union> Q_neg \\<or> wf_query n V Q Qn\n  1 \\<le> card Q\n  ?Y \\<in> Q \\<union> Q_neg \\<Longrightarrow> wf_atable n ?Y\n  wf_set n V\n  \\<forall>n N P Pa.\n     (wf_query n N P Pa \\<or>\n      \\<not> 1 \\<le> card P \\<or>\n      \\<not> wf_set n N \\<or>\n      \\<not> wf_atable n (pp Pa P n) \\<and>\n      pp Pa P n \\<in> P \\<union> Pa) \\<and>\n     (1 \\<le> card P \\<and>\n      wf_set n N \\<and>\n      (\\<forall>p. wf_atable n p \\<or> p \\<notin> P \\<union> Pa) \\<or>\n      \\<not> wf_query n N P Pa)\n\ngoal (1 subgoal):\n 1. wf_query n V Q Qn", "by blast"], ["proof (state)\nthis:\n  wf_query n V Q Qn\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf_query n V Q Qn\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf_query n V Q Qn\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "moreover"], ["proof (state)\nthis:\n  wf_query n V Q Qn\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "have \"non_empty_query Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_empty_query Q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. non_empty_query Q", "have \"\\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> card A \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> 1 \\<le> card A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> 1 \\<le> card A", "fix A X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> 1 \\<le> card A", "assume asm: \"(A, X) \\<in> Q\""], ["proof (state)\nthis:\n  (A, X) \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> 1 \\<le> card A", "then"], ["proof (chain)\npicking this:\n  (A, X) \\<in> Q", "have \"wf_set n A\""], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q\n\ngoal (1 subgoal):\n 1. wf_set n A", "by (metis \\<open>included V Q\\<close> calculation(3) case_prodD included_def subsetD wf_query_def wf_set_def)"], ["proof (state)\nthis:\n  wf_set n A\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> 1 \\<le> card A", "then"], ["proof (chain)\npicking this:\n  wf_set n A", "have \"finite A\""], ["proof (prove)\nusing this:\n  wf_set n A\n\ngoal (1 subgoal):\n 1. finite A", "using wf_set_finite"], ["proof (prove)\nusing this:\n  wf_set n A\n  wf_set ?n ?A \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite A", "by blast"], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q \\<Longrightarrow> 1 \\<le> card A", "then"], ["proof (chain)\npicking this:\n  finite A", "show \"card A \\<ge> 1\""], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. 1 \\<le> card A", "by (metis (no_types, lifting) One_nat_def Q_def Set.is_empty_def Suc_leI asm card_gt_0_iff case_prod_beta' member_filter prod.sel(1))"], ["proof (state)\nthis:\n  1 \\<le> card A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?A, ?X) \\<in> Q \\<Longrightarrow> 1 \\<le> card ?A\n\ngoal (1 subgoal):\n 1. non_empty_query Q", "then"], ["proof (chain)\npicking this:\n  (?A, ?X) \\<in> Q \\<Longrightarrow> 1 \\<le> card ?A", "show ?thesis"], ["proof (prove)\nusing this:\n  (?A, ?X) \\<in> Q \\<Longrightarrow> 1 \\<le> card ?A\n\ngoal (1 subgoal):\n 1. non_empty_query Q", "by (metis Q_def case_prodE fst_conv member_filter non_empty_query_def)"], ["proof (state)\nthis:\n  non_empty_query Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  non_empty_query Q\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "moreover"], ["proof (state)\nthis:\n  non_empty_query Q\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "have \"included V Qn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. included V Qn", "by (simp add: Qn_def case_prod_beta' included_def)"], ["proof (state)\nthis:\n  included V Qn\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "moreover"], ["proof (state)\nthis:\n  included V Qn\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "have \"non_empty_query Qn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. non_empty_query Qn", "by (simp add: Qn_def case_prod_beta' non_empty_query_def)"], ["proof (state)\nthis:\n  non_empty_query Qn\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "then"], ["proof (chain)\npicking this:\n  non_empty_query Qn", "have \"rwf_query n V Q Qn\""], ["proof (prove)\nusing this:\n  non_empty_query Qn\n\ngoal (1 subgoal):\n 1. rwf_query n V Q Qn", "by (simp add: \\<open>included V Q\\<close> calculation(1) calculation(3) calculation(4) calculation(5) rwf_query_def)"], ["proof (state)\nthis:\n  rwf_query n V Q Qn\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "moreover"], ["proof (state)\nthis:\n  rwf_query n V Q Qn\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "have \"card V \\<ge> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> card V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 \\<le> card V", "obtain A X where \"(A, X) \\<in> Q_pos\" \"\\<not> Set.is_empty A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A X.\n        \\<lbrakk>(A, X) \\<in> Q_pos; \\<not> Set.is_empty A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using False Q_def"], ["proof (prove)\nusing this:\n  Q \\<noteq> {}\n  Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos\n\ngoal (1 subgoal):\n 1. (\\<And>A X.\n        \\<lbrakk>(A, X) \\<in> Q_pos; \\<not> Set.is_empty A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (A, X) \\<in> Q_pos\n  \\<not> Set.is_empty A\n\ngoal (1 subgoal):\n 1. 1 \\<le> card V", "then"], ["proof (chain)\npicking this:\n  (A, X) \\<in> Q_pos\n  \\<not> Set.is_empty A", "have \"A \\<subseteq> V\""], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q_pos\n  \\<not> Set.is_empty A\n\ngoal (1 subgoal):\n 1. A \\<subseteq> V", "by (metis Q_def \\<open>included V Q\\<close> included_def member_filter prod.simps(2))"], ["proof (state)\nthis:\n  A \\<subseteq> V\n\ngoal (1 subgoal):\n 1. 1 \\<le> card V", "moreover"], ["proof (state)\nthis:\n  A \\<subseteq> V\n\ngoal (1 subgoal):\n 1. 1 \\<le> card V", "have \"finite V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite V", "using wf_set_finite \\<open>wf_query n V Q Qn\\<close> wf_query_def"], ["proof (prove)\nusing this:\n  wf_set ?n ?A \\<Longrightarrow> finite ?A\n  wf_query n V Q Qn\n  wf_query ?n ?V ?Q_pos ?Q_neg =\n  ((\\<forall>X\\<in>?Q_pos \\<union> ?Q_neg. wf_atable ?n X) \\<and>\n   wf_set ?n ?V \\<and> 1 \\<le> card ?Q_pos)\n\ngoal (1 subgoal):\n 1. finite V", "by blast"], ["proof (state)\nthis:\n  finite V\n\ngoal (1 subgoal):\n 1. 1 \\<le> card V", "ultimately"], ["proof (chain)\npicking this:\n  A \\<subseteq> V\n  finite V", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<subseteq> V\n  finite V\n\ngoal (1 subgoal):\n 1. 1 \\<le> card V", "by (metis One_nat_def Set.is_empty_def Suc_leI \\<open>\\<not> Set.is_empty A\\<close> card_gt_0_iff subset_empty)"], ["proof (state)\nthis:\n  1 \\<le> card V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 \\<le> card V\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "then"], ["proof (chain)\npicking this:\n  1 \\<le> card V", "have \"z \\<in> genericJoin V Q Qn \\<longleftrightarrow> wf_tuple n V z \\<and> (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\""], ["proof (prove)\nusing this:\n  1 \\<le> card V\n\ngoal (1 subgoal):\n 1. (z \\<in> genericJoin V Q Qn) =\n    (wf_tuple n V z \\<and>\n     (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))", "using correctness[where ?n=n and ?V=V and ?Q=Q and ?z=z]"], ["proof (prove)\nusing this:\n  1 \\<le> card V\n  \\<lbrakk>rwf_query n V Q ?Qn; 1 \\<le> card V\\<rbrakk>\n  \\<Longrightarrow> (z \\<in> genericJoin V Q ?Qn) =\n                    (wf_tuple n V z \\<and>\n                     (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n                     (\\<forall>(A, X)\\<in>?Qn. restrict A z \\<notin> X))\n\ngoal (1 subgoal):\n 1. (z \\<in> genericJoin V Q Qn) =\n    (wf_tuple n V z \\<and>\n     (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))", "by (simp add: calculation(6))"], ["proof (state)\nthis:\n  (z \\<in> genericJoin V Q Qn) =\n  (wf_tuple n V z \\<and>\n   (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "moreover"], ["proof (state)\nthis:\n  (z \\<in> genericJoin V Q Qn) =\n  (wf_tuple n V z \\<and>\n   (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "have \"?r = genericJoin V Q Qn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn", "have \"Qn = Set.filter (\\<lambda>(A, _). A \\<subseteq> V \\<and> 1 \\<le> card A) Q_neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Qn =\n    Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n     Q_neg", "using Qn_def"], ["proof (prove)\nusing this:\n  Qn =\n  Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n   Q_neg\n\ngoal (1 subgoal):\n 1. Qn =\n    Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n     Q_neg", "by blast"], ["proof (state)\nthis:\n  Qn =\n  Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n   Q_neg\n\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn", "moreover"], ["proof (state)\nthis:\n  Qn =\n  Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n   Q_neg\n\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn", "have \"\\<not> Set.is_empty Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Set.is_empty Q", "by (simp add: False_prev Set.is_empty_def)"], ["proof (state)\nthis:\n  \\<not> Set.is_empty Q\n\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn", "moreover"], ["proof (state)\nthis:\n  \\<not> Set.is_empty Q\n\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn", "have \"\\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or> (\\<exists>(A, X)\\<in>Q_neg. Set.is_empty A \\<and> \\<not> Set.is_empty X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n            (\\<exists>(A, X)\\<in>Q_neg.\n                Set.is_empty A \\<and> \\<not> Set.is_empty X))", "using forall"], ["proof (prove)\nusing this:\n  (\\<forall>(A, X)\\<in>Q_pos. \\<not> Set.is_empty X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. \\<not> Set.is_empty A \\<or> Set.is_empty X)\n\ngoal (1 subgoal):\n 1. \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n            (\\<exists>(A, X)\\<in>Q_neg.\n                Set.is_empty A \\<and> \\<not> Set.is_empty X))", "by blast"], ["proof (state)\nthis:\n  \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n          (\\<exists>(A, X)\\<in>Q_neg.\n              Set.is_empty A \\<and> \\<not> Set.is_empty X))\n\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn", "ultimately"], ["proof (chain)\npicking this:\n  Qn =\n  Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n   Q_neg\n  \\<not> Set.is_empty Q\n  \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n          (\\<exists>(A, X)\\<in>Q_neg.\n              Set.is_empty A \\<and> \\<not> Set.is_empty X))", "show ?thesis"], ["proof (prove)\nusing this:\n  Qn =\n  Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n   Q_neg\n  \\<not> Set.is_empty Q\n  \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n          (\\<exists>(A, X)\\<in>Q_neg.\n              Set.is_empty A \\<and> \\<not> Set.is_empty X))\n\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn", "using vars_wrapperGenericJoin[of Q Q_pos V Qn Q_neg] Q_def V_def"], ["proof (prove)\nusing this:\n  Qn =\n  Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n   Q_neg\n  \\<not> Set.is_empty Q\n  \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n          (\\<exists>(A, X)\\<in>Q_neg.\n              Set.is_empty A \\<and> \\<not> Set.is_empty X))\n  \\<lbrakk>Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos;\n   V = (\\<Union>(A, X)\\<in>Q. A);\n   Qn =\n   Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n    Q_neg;\n   \\<not> Set.is_empty Q;\n   \\<not> ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or>\n           (\\<exists>(A, X)\\<in>Q_neg.\n               Set.is_empty A \\<and> \\<not> Set.is_empty X))\\<rbrakk>\n  \\<Longrightarrow> wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn\n  Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos\n  V = (\\<Union>(A, X)\\<in>Q. A)\n\ngoal (1 subgoal):\n 1. wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn", "by simp"], ["proof (state)\nthis:\n  wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "moreover"], ["proof (state)\nthis:\n  wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "have \"z \\<in> genericJoin V Q Qn \\<Longrightarrow> (\\<forall>(A, X)\\<in>Q_pos - Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Q_neg - Qn. restrict A z \\<notin> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> genericJoin V Q Qn \\<Longrightarrow>\n    (\\<forall>(A, X)\\<in>Q_pos - Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg - Qn. restrict A z \\<notin> X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<in> genericJoin V Q Qn \\<Longrightarrow>\n    (\\<forall>(A, X)\\<in>Q_pos - Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg - Qn. restrict A z \\<notin> X)", "assume \"z \\<in> genericJoin V Q Qn\""], ["proof (state)\nthis:\n  z \\<in> genericJoin V Q Qn\n\ngoal (1 subgoal):\n 1. z \\<in> genericJoin V Q Qn \\<Longrightarrow>\n    (\\<forall>(A, X)\\<in>Q_pos - Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg - Qn. restrict A z \\<notin> X)", "have \"(\\<And>A X. (A, X)\\<in>Q_pos - Q \\<Longrightarrow> restrict A z \\<in> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q_pos - Q \\<Longrightarrow> restrict A z \\<in> X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q_pos - Q \\<Longrightarrow> restrict A z \\<in> X", "fix A X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q_pos - Q \\<Longrightarrow> restrict A z \\<in> X", "assume \"(A, X) \\<in> Q_pos - Q\""], ["proof (state)\nthis:\n  (A, X) \\<in> Q_pos - Q\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q_pos - Q \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  (A, X) \\<in> Q_pos - Q", "have \"table n A X\""], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q_pos - Q\n\ngoal (1 subgoal):\n 1. table n A X", "using assms(2)"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q_pos - Q\n  \\<forall>(A, X)\\<in>Q_pos \\<union> Q_neg. table n A X \\<and> wf_set n A\n\ngoal (1 subgoal):\n 1. table n A X", "by auto"], ["proof (state)\nthis:\n  table n A X\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q_pos - Q \\<Longrightarrow> restrict A z \\<in> X", "moreover"], ["proof (state)\nthis:\n  table n A X\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q_pos - Q \\<Longrightarrow> restrict A z \\<in> X", "have \"Set.is_empty A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set.is_empty A", "by (metis (no_types, lifting) DiffD1 DiffD2 Q_def \\<open>(A, X) \\<in> Q_pos - Q\\<close> case_prod_beta' member_filter prod.sel(1))"], ["proof (state)\nthis:\n  Set.is_empty A\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q_pos - Q \\<Longrightarrow> restrict A z \\<in> X", "moreover"], ["proof (state)\nthis:\n  Set.is_empty A\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q_pos - Q \\<Longrightarrow> restrict A z \\<in> X", "have \"\\<not> Set.is_empty X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Set.is_empty X", "using forall"], ["proof (prove)\nusing this:\n  (\\<forall>(A, X)\\<in>Q_pos. \\<not> Set.is_empty X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. \\<not> Set.is_empty A \\<or> Set.is_empty X)\n\ngoal (1 subgoal):\n 1. \\<not> Set.is_empty X", "using \\<open>(A, X) \\<in> Q_pos - Q\\<close>"], ["proof (prove)\nusing this:\n  (\\<forall>(A, X)\\<in>Q_pos. \\<not> Set.is_empty X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. \\<not> Set.is_empty A \\<or> Set.is_empty X)\n  (A, X) \\<in> Q_pos - Q\n\ngoal (1 subgoal):\n 1. \\<not> Set.is_empty X", "by blast"], ["proof (state)\nthis:\n  \\<not> Set.is_empty X\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q_pos - Q \\<Longrightarrow> restrict A z \\<in> X", "ultimately"], ["proof (chain)\npicking this:\n  table n A X\n  Set.is_empty A\n  \\<not> Set.is_empty X", "have \"X = {replicate n None}\""], ["proof (prove)\nusing this:\n  table n A X\n  Set.is_empty A\n  \\<not> Set.is_empty X\n\ngoal (1 subgoal):\n 1. X = {replicate n None}", "by (simp add: Set.is_empty_def empty_table_def table_empty unit_table_def)"], ["proof (state)\nthis:\n  X = {replicate n None}\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q_pos - Q \\<Longrightarrow> restrict A z \\<in> X", "moreover"], ["proof (state)\nthis:\n  X = {replicate n None}\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q_pos - Q \\<Longrightarrow> restrict A z \\<in> X", "have \"wf_tuple n V z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple n V z", "using \\<open>(z \\<in> genericJoin V Q Qn) = (wf_tuple n V z \\<and> (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))\\<close> \\<open>z \\<in> genericJoin V Q Qn\\<close>"], ["proof (prove)\nusing this:\n  (z \\<in> genericJoin V Q Qn) =\n  (wf_tuple n V z \\<and>\n   (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))\n  z \\<in> genericJoin V Q Qn\n\ngoal (1 subgoal):\n 1. wf_tuple n V z", "by linarith"], ["proof (state)\nthis:\n  wf_tuple n V z\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q_pos - Q \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  wf_tuple n V z", "have \"restrict A z = replicate n None\""], ["proof (prove)\nusing this:\n  wf_tuple n V z\n\ngoal (1 subgoal):\n 1. restrict A z = replicate n None", "using \\<open>Set.is_empty A\\<close> wf_tuple_empty wf_tuple_restrict_simple"], ["proof (prove)\nusing this:\n  wf_tuple n V z\n  Set.is_empty A\n  wf_tuple ?n {} ?v = (?v = replicate ?n None)\n  \\<lbrakk>wf_tuple ?n ?B ?v; ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> wf_tuple ?n ?A (restrict ?A ?v)\n\ngoal (1 subgoal):\n 1. restrict A z = replicate n None", "by (metis Diff_Int2 Diff_Int_distrib2 Diff_eq_empty_iff Set.is_empty_def inf_le2)"], ["proof (state)\nthis:\n  restrict A z = replicate n None\n\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q_pos - Q \\<Longrightarrow> restrict A z \\<in> X", "then"], ["proof (chain)\npicking this:\n  restrict A z = replicate n None", "show \"restrict A z \\<in> X\""], ["proof (prove)\nusing this:\n  restrict A z = replicate n None\n\ngoal (1 subgoal):\n 1. restrict A z \\<in> X", "by (simp add: calculation)"], ["proof (state)\nthis:\n  restrict A z \\<in> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?A, ?X) \\<in> Q_pos - Q \\<Longrightarrow> restrict ?A z \\<in> ?X\n\ngoal (1 subgoal):\n 1. z \\<in> genericJoin V Q Qn \\<Longrightarrow>\n    (\\<forall>(A, X)\\<in>Q_pos - Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg - Qn. restrict A z \\<notin> X)", "moreover"], ["proof (state)\nthis:\n  (?A, ?X) \\<in> Q_pos - Q \\<Longrightarrow> restrict ?A z \\<in> ?X\n\ngoal (1 subgoal):\n 1. z \\<in> genericJoin V Q Qn \\<Longrightarrow>\n    (\\<forall>(A, X)\\<in>Q_pos - Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg - Qn. restrict A z \\<notin> X)", "have \"\\<And>A X. (A, X)\\<in>Q_neg - Qn \\<Longrightarrow> restrict A z \\<notin> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_neg - Qn \\<Longrightarrow> restrict A z \\<notin> X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_neg - Qn \\<Longrightarrow> restrict A z \\<notin> X", "fix A X"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_neg - Qn \\<Longrightarrow> restrict A z \\<notin> X", "assume \"(A, X) \\<in> Q_neg - Qn\""], ["proof (state)\nthis:\n  (A, X) \\<in> Q_neg - Qn\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_neg - Qn \\<Longrightarrow> restrict A z \\<notin> X", "then"], ["proof (chain)\npicking this:\n  (A, X) \\<in> Q_neg - Qn", "have notc: \"\\<not> (card A \\<ge> 1 \\<and> A \\<subseteq> V)\""], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q_neg - Qn\n\ngoal (1 subgoal):\n 1. \\<not> (1 \\<le> card A \\<and> A \\<subseteq> V)", "using Qn_def"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q_neg - Qn\n  Qn =\n  Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n   Q_neg\n\ngoal (1 subgoal):\n 1. \\<not> (1 \\<le> card A \\<and> A \\<subseteq> V)", "by auto"], ["proof (state)\nthis:\n  \\<not> (1 \\<le> card A \\<and> A \\<subseteq> V)\n\ngoal (1 subgoal):\n 1. \\<And>A X.\n       (A, X) \\<in> Q_neg - Qn \\<Longrightarrow> restrict A z \\<notin> X", "then"], ["proof (chain)\npicking this:\n  \\<not> (1 \\<le> card A \\<and> A \\<subseteq> V)", "show \"restrict A z \\<notin> X\""], ["proof (prove)\nusing this:\n  \\<not> (1 \\<le> card A \\<and> A \\<subseteq> V)\n\ngoal (1 subgoal):\n 1. restrict A z \\<notin> X", "proof (cases \"A \\<subseteq> V\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (1 \\<le> card A \\<and> A \\<subseteq> V);\n     A \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X\n 2. \\<lbrakk>\\<not> (1 \\<le> card A \\<and> A \\<subseteq> V);\n     \\<not> A \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "case True"], ["proof (state)\nthis:\n  A \\<subseteq> V\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (1 \\<le> card A \\<and> A \\<subseteq> V);\n     A \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X\n 2. \\<lbrakk>\\<not> (1 \\<le> card A \\<and> A \\<subseteq> V);\n     \\<not> A \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "then"], ["proof (chain)\npicking this:\n  A \\<subseteq> V", "have \"card A = 0\""], ["proof (prove)\nusing this:\n  A \\<subseteq> V\n\ngoal (1 subgoal):\n 1. card A = 0", "using Qn_def"], ["proof (prove)\nusing this:\n  A \\<subseteq> V\n  Qn =\n  Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n   Q_neg\n\ngoal (1 subgoal):\n 1. card A = 0", "using notc"], ["proof (prove)\nusing this:\n  A \\<subseteq> V\n  Qn =\n  Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n   Q_neg\n  \\<not> (1 \\<le> card A \\<and> A \\<subseteq> V)\n\ngoal (1 subgoal):\n 1. card A = 0", "by linarith"], ["proof (state)\nthis:\n  card A = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (1 \\<le> card A \\<and> A \\<subseteq> V);\n     A \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X\n 2. \\<lbrakk>\\<not> (1 \\<le> card A \\<and> A \\<subseteq> V);\n     \\<not> A \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "then"], ["proof (chain)\npicking this:\n  card A = 0", "have \"Set.is_empty X\""], ["proof (prove)\nusing this:\n  card A = 0\n\ngoal (1 subgoal):\n 1. Set.is_empty X", "by (metis DiffD1 Set.is_empty_def True \\<open>(A, X) \\<in> Q_neg - Qn\\<close> \\<open>1 \\<le> card V\\<close> card_eq_0_iff forall notc prod.simps(2) rev_finite_subset)"], ["proof (state)\nthis:\n  Set.is_empty X\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (1 \\<le> card A \\<and> A \\<subseteq> V);\n     A \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X\n 2. \\<lbrakk>\\<not> (1 \\<le> card A \\<and> A \\<subseteq> V);\n     \\<not> A \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "then"], ["proof (chain)\npicking this:\n  Set.is_empty X", "show ?thesis"], ["proof (prove)\nusing this:\n  Set.is_empty X\n\ngoal (1 subgoal):\n 1. restrict A z \\<notin> X", "by (simp add: Set.is_empty_def)"], ["proof (state)\nthis:\n  restrict A z \\<notin> X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (1 \\<le> card A \\<and> A \\<subseteq> V);\n     \\<not> A \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (1 \\<le> card A \\<and> A \\<subseteq> V);\n     \\<not> A \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "case False"], ["proof (state)\nthis:\n  \\<not> A \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (1 \\<le> card A \\<and> A \\<subseteq> V);\n     \\<not> A \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "then"], ["proof (chain)\npicking this:\n  \\<not> A \\<subseteq> V", "obtain i where \"i \\<in> A\" \"i \\<notin> V\""], ["proof (prove)\nusing this:\n  \\<not> A \\<subseteq> V\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<in> A; i \\<notin> V\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i \\<in> A\n  i \\<notin> V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (1 \\<le> card A \\<and> A \\<subseteq> V);\n     \\<not> A \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "then"], ["proof (chain)\npicking this:\n  i \\<in> A\n  i \\<notin> V", "have \"i < n\""], ["proof (prove)\nusing this:\n  i \\<in> A\n  i \\<notin> V\n\ngoal (1 subgoal):\n 1. i < n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<in> A; i \\<notin> V\\<rbrakk> \\<Longrightarrow> i < n", "have \"(A, X) \\<in> Q_neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A, X) \\<in> Q_neg", "using \\<open>(A, X) \\<in> Q_neg - Qn\\<close>"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q_neg - Qn\n\ngoal (1 subgoal):\n 1. (A, X) \\<in> Q_neg", "by auto"], ["proof (state)\nthis:\n  (A, X) \\<in> Q_neg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<in> A; i \\<notin> V\\<rbrakk> \\<Longrightarrow> i < n", "then"], ["proof (chain)\npicking this:\n  (A, X) \\<in> Q_neg", "have \"wf_set n A\""], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q_neg\n\ngoal (1 subgoal):\n 1. wf_set n A", "using assms(2)"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q_neg\n  \\<forall>(A, X)\\<in>Q_pos \\<union> Q_neg. table n A X \\<and> wf_set n A\n\ngoal (1 subgoal):\n 1. wf_set n A", "by auto"], ["proof (state)\nthis:\n  wf_set n A\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<in> A; i \\<notin> V\\<rbrakk> \\<Longrightarrow> i < n", "then"], ["proof (chain)\npicking this:\n  wf_set n A", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_set n A\n\ngoal (1 subgoal):\n 1. i < n", "by (simp add: \\<open>i \\<in> A\\<close> wf_set_def)"], ["proof (state)\nthis:\n  i < n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (1 \\<le> card A \\<and> A \\<subseteq> V);\n     \\<not> A \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "moreover"], ["proof (state)\nthis:\n  i < n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (1 \\<le> card A \\<and> A \\<subseteq> V);\n     \\<not> A \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "have \"table n A X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. table n A X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. table n A X", "have \"(A, X) \\<in> Q_neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A, X) \\<in> Q_neg", "using \\<open>(A, X) \\<in> Q_neg - Qn\\<close>"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q_neg - Qn\n\ngoal (1 subgoal):\n 1. (A, X) \\<in> Q_neg", "by auto"], ["proof (state)\nthis:\n  (A, X) \\<in> Q_neg\n\ngoal (1 subgoal):\n 1. table n A X", "then"], ["proof (chain)\npicking this:\n  (A, X) \\<in> Q_neg", "show ?thesis"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q_neg\n\ngoal (1 subgoal):\n 1. table n A X", "using assms(2)"], ["proof (prove)\nusing this:\n  (A, X) \\<in> Q_neg\n  \\<forall>(A, X)\\<in>Q_pos \\<union> Q_neg. table n A X \\<and> wf_set n A\n\ngoal (1 subgoal):\n 1. table n A X", "by auto"], ["proof (state)\nthis:\n  table n A X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  table n A X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (1 \\<le> card A \\<and> A \\<subseteq> V);\n     \\<not> A \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "have \"wf_tuple n V z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple n V z", "using \\<open>(z \\<in> genericJoin V Q Qn) = (wf_tuple n V z \\<and> (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))\\<close> \\<open>z \\<in> genericJoin V Q Qn\\<close>"], ["proof (prove)\nusing this:\n  (z \\<in> genericJoin V Q Qn) =\n  (wf_tuple n V z \\<and>\n   (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))\n  z \\<in> genericJoin V Q Qn\n\ngoal (1 subgoal):\n 1. wf_tuple n V z", "by blast"], ["proof (state)\nthis:\n  wf_tuple n V z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (1 \\<le> card A \\<and> A \\<subseteq> V);\n     \\<not> A \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> restrict A z \\<notin> X", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict A z \\<notin> X", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> restrict A z \\<notin> X \\<Longrightarrow> False", "let ?zz = \"restrict A z\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> restrict A z \\<notin> X \\<Longrightarrow> False", "assume \"\\<not> ?zz \\<notin> X\""], ["proof (state)\nthis:\n  \\<not> restrict A z \\<notin> X\n\ngoal (1 subgoal):\n 1. \\<not> restrict A z \\<notin> X \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> restrict A z \\<notin> X", "have \"?zz \\<in> X\""], ["proof (prove)\nusing this:\n  \\<not> restrict A z \\<notin> X\n\ngoal (1 subgoal):\n 1. restrict A z \\<in> X", "by blast"], ["proof (state)\nthis:\n  restrict A z \\<in> X\n\ngoal (1 subgoal):\n 1. \\<not> restrict A z \\<notin> X \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  restrict A z \\<in> X", "have \"wf_tuple n A ?zz\""], ["proof (prove)\nusing this:\n  restrict A z \\<in> X\n\ngoal (1 subgoal):\n 1. wf_tuple n A (restrict A z)", "using \\<open>table n A X\\<close> table_def"], ["proof (prove)\nusing this:\n  restrict A z \\<in> X\n  table n A X\n  table ?n ?V ?X = (\\<forall>x\\<in>?X. wf_tuple ?n ?V x)\n\ngoal (1 subgoal):\n 1. wf_tuple n A (restrict A z)", "by blast"], ["proof (state)\nthis:\n  wf_tuple n A (restrict A z)\n\ngoal (1 subgoal):\n 1. \\<not> restrict A z \\<notin> X \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  wf_tuple n A (restrict A z)", "have \"?zz ! i \\<noteq> None\""], ["proof (prove)\nusing this:\n  wf_tuple n A (restrict A z)\n\ngoal (1 subgoal):\n 1. restrict A z ! i \\<noteq> None", "by (simp add: \\<open>i \\<in> A\\<close> calculation wf_tuple_def)"], ["proof (state)\nthis:\n  restrict A z ! i \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<not> restrict A z \\<notin> X \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  restrict A z ! i \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<not> restrict A z \\<notin> X \\<Longrightarrow> False", "have \"z ! i = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z ! i = None", "using \\<open>wf_tuple n V z\\<close> \\<open>i \\<notin> V\\<close> wf_tuple_def"], ["proof (prove)\nusing this:\n  wf_tuple n V z\n  i \\<notin> V\n  wf_tuple ?n ?V ?x =\n  (length ?x = ?n \\<and> (\\<forall>i<?n. (?x ! i = None) = (i \\<notin> ?V)))\n\ngoal (1 subgoal):\n 1. z ! i = None", "using \\<open>i < n\\<close>"], ["proof (prove)\nusing this:\n  wf_tuple n V z\n  i \\<notin> V\n  wf_tuple ?n ?V ?x =\n  (length ?x = ?n \\<and> (\\<forall>i<?n. (?x ! i = None) = (i \\<notin> ?V)))\n  i < n\n\ngoal (1 subgoal):\n 1. z ! i = None", "by blast"], ["proof (state)\nthis:\n  z ! i = None\n\ngoal (1 subgoal):\n 1. \\<not> restrict A z \\<notin> X \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  restrict A z ! i \\<noteq> None\n  z ! i = None", "show \"False\""], ["proof (prove)\nusing this:\n  restrict A z ! i \\<noteq> None\n  z ! i = None\n\ngoal (1 subgoal):\n 1. False", "using \\<open>i < n\\<close> \\<open>i \\<in> A\\<close> \\<open>wf_tuple n A (restrict A z)\\<close> nth_restrict wf_tuple_length"], ["proof (prove)\nusing this:\n  restrict A z ! i \\<noteq> None\n  z ! i = None\n  i < n\n  i \\<in> A\n  wf_tuple n A (restrict A z)\n  \\<lbrakk>?i \\<in> ?A; ?i < length ?v\\<rbrakk>\n  \\<Longrightarrow> restrict ?A ?v ! ?i = ?v ! ?i\n  wf_tuple ?n ?V ?x \\<Longrightarrow> length ?x = ?n\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict A z \\<notin> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict A z \\<notin> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?A, ?X) \\<in> Q_neg - Qn \\<Longrightarrow> restrict ?A z \\<notin> ?X\n\ngoal (1 subgoal):\n 1. z \\<in> genericJoin V Q Qn \\<Longrightarrow>\n    (\\<forall>(A, X)\\<in>Q_pos - Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg - Qn. restrict A z \\<notin> X)", "ultimately"], ["proof (chain)\npicking this:\n  (?A, ?X) \\<in> Q_pos - Q \\<Longrightarrow> restrict ?A z \\<in> ?X\n  (?A, ?X) \\<in> Q_neg - Qn \\<Longrightarrow> restrict ?A z \\<notin> ?X", "show ?thesis"], ["proof (prove)\nusing this:\n  (?A, ?X) \\<in> Q_pos - Q \\<Longrightarrow> restrict ?A z \\<in> ?X\n  (?A, ?X) \\<in> Q_neg - Qn \\<Longrightarrow> restrict ?A z \\<notin> ?X\n\ngoal (1 subgoal):\n 1. (\\<forall>(A, X)\\<in>Q_pos - Q. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg - Qn. restrict A z \\<notin> X)", "by blast"], ["proof (state)\nthis:\n  (\\<forall>(A, X)\\<in>Q_pos - Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg - Qn. restrict A z \\<notin> X)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z \\<in> genericJoin V Q Qn \\<Longrightarrow>\n  (\\<forall>(A, X)\\<in>Q_pos - Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg - Qn. restrict A z \\<notin> X)\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "ultimately"], ["proof (chain)\npicking this:\n  covering V Q\n  Qn \\<subseteq> Q_neg\n  wf_query n V Q Qn\n  non_empty_query Q\n  included V Qn\n  rwf_query n V Q Qn\n  (z \\<in> genericJoin V Q Qn) =\n  (wf_tuple n V z \\<and>\n   (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))\n  wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn\n  z \\<in> genericJoin V Q Qn \\<Longrightarrow>\n  (\\<forall>(A, X)\\<in>Q_pos - Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg - Qn. restrict A z \\<notin> X)", "have \"z \\<in> genericJoin V Q Qn \\<longleftrightarrow> (\\<forall>(A, X)\\<in>Q_pos - Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Q_neg - Qn. restrict A z \\<notin> X)\n\\<and> wf_tuple n V z \\<and> (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X)\""], ["proof (prove)\nusing this:\n  covering V Q\n  Qn \\<subseteq> Q_neg\n  wf_query n V Q Qn\n  non_empty_query Q\n  included V Qn\n  rwf_query n V Q Qn\n  (z \\<in> genericJoin V Q Qn) =\n  (wf_tuple n V z \\<and>\n   (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))\n  wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn\n  z \\<in> genericJoin V Q Qn \\<Longrightarrow>\n  (\\<forall>(A, X)\\<in>Q_pos - Q. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg - Qn. restrict A z \\<notin> X)\n\ngoal (1 subgoal):\n 1. (z \\<in> genericJoin V Q Qn) =\n    ((\\<forall>(A, X)\\<in>Q_pos - Q. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg - Qn. restrict A z \\<notin> X) \\<and>\n     wf_tuple n V z \\<and>\n     (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))", "by blast"], ["proof (state)\nthis:\n  (z \\<in> genericJoin V Q Qn) =\n  ((\\<forall>(A, X)\\<in>Q_pos - Q. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Q_neg - Qn. restrict A z \\<notin> X) \\<and>\n   wf_tuple n V z \\<and>\n   (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "moreover"], ["proof (state)\nthis:\n  (z \\<in> genericJoin V Q Qn) =\n  ((\\<forall>(A, X)\\<in>Q_pos - Q. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Q_neg - Qn. restrict A z \\<notin> X) \\<and>\n   wf_tuple n V z \\<and>\n   (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "have \"V = (\\<Union>(A, X)\\<in>Q_pos. A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V = (\\<Union>(A, X)\\<in>Q_pos. A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. V = (\\<Union>(A, X)\\<in>Q_pos. A)", "have \"(\\<Union>(A, X)\\<in>Q_pos - Q. A) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>(A, X)\\<in>Q_pos - Q. A) = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Union>(A, X)\\<in>Q_pos - Q. A) = {}", "have \"\\<And>A X. (A, X) \\<in> (Q_pos - Q) \\<Longrightarrow> A = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A X. (A, X) \\<in> Q_pos - Q \\<Longrightarrow> A = {}", "by (simp add: Q_def Set.is_empty_def)"], ["proof (state)\nthis:\n  (?A, ?X) \\<in> Q_pos - Q \\<Longrightarrow> ?A = {}\n\ngoal (1 subgoal):\n 1. (\\<Union>(A, X)\\<in>Q_pos - Q. A) = {}", "then"], ["proof (chain)\npicking this:\n  (?A, ?X) \\<in> Q_pos - Q \\<Longrightarrow> ?A = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  (?A, ?X) \\<in> Q_pos - Q \\<Longrightarrow> ?A = {}\n\ngoal (1 subgoal):\n 1. (\\<Union>(A, X)\\<in>Q_pos - Q. A) = {}", "by blast"], ["proof (state)\nthis:\n  (\\<Union>(A, X)\\<in>Q_pos - Q. A) = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Union>(A, X)\\<in>Q_pos - Q. A) = {}\n\ngoal (1 subgoal):\n 1. V = (\\<Union>(A, X)\\<in>Q_pos. A)", "moreover"], ["proof (state)\nthis:\n  (\\<Union>(A, X)\\<in>Q_pos - Q. A) = {}\n\ngoal (1 subgoal):\n 1. V = (\\<Union>(A, X)\\<in>Q_pos. A)", "have \"V = (\\<Union>(A, X)\\<in>Q. A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V = (\\<Union>(A, X)\\<in>Q. A)", "using V_def"], ["proof (prove)\nusing this:\n  V = (\\<Union>(A, X)\\<in>Q. A)\n\ngoal (1 subgoal):\n 1. V = (\\<Union>(A, X)\\<in>Q. A)", "by simp"], ["proof (state)\nthis:\n  V = (\\<Union>(A, X)\\<in>Q. A)\n\ngoal (1 subgoal):\n 1. V = (\\<Union>(A, X)\\<in>Q_pos. A)", "moreover"], ["proof (state)\nthis:\n  V = (\\<Union>(A, X)\\<in>Q. A)\n\ngoal (1 subgoal):\n 1. V = (\\<Union>(A, X)\\<in>Q_pos. A)", "have \"(\\<Union>(A, X)\\<in>Q_pos. A) = (\\<Union>(A, X)\\<in>Q. A) \\<union> (\\<Union>(A, X)\\<in>Q_pos - Q. A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>(A, X)\\<in>Q_pos. A) =\n    (\\<Union>(A, X)\\<in>Q. A) \\<union> (\\<Union>(A, X)\\<in>Q_pos - Q. A)", "using Q_def"], ["proof (prove)\nusing this:\n  Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos\n\ngoal (1 subgoal):\n 1. (\\<Union>(A, X)\\<in>Q_pos. A) =\n    (\\<Union>(A, X)\\<in>Q. A) \\<union> (\\<Union>(A, X)\\<in>Q_pos - Q. A)", "by auto"], ["proof (state)\nthis:\n  (\\<Union>(A, X)\\<in>Q_pos. A) =\n  (\\<Union>(A, X)\\<in>Q. A) \\<union> (\\<Union>(A, X)\\<in>Q_pos - Q. A)\n\ngoal (1 subgoal):\n 1. V = (\\<Union>(A, X)\\<in>Q_pos. A)", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Union>(A, X)\\<in>Q_pos - Q. A) = {}\n  V = (\\<Union>(A, X)\\<in>Q. A)\n  (\\<Union>(A, X)\\<in>Q_pos. A) =\n  (\\<Union>(A, X)\\<in>Q. A) \\<union> (\\<Union>(A, X)\\<in>Q_pos - Q. A)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Union>(A, X)\\<in>Q_pos - Q. A) = {}\n  V = (\\<Union>(A, X)\\<in>Q. A)\n  (\\<Union>(A, X)\\<in>Q_pos. A) =\n  (\\<Union>(A, X)\\<in>Q. A) \\<union> (\\<Union>(A, X)\\<in>Q_pos - Q. A)\n\ngoal (1 subgoal):\n 1. V = (\\<Union>(A, X)\\<in>Q_pos. A)", "by simp"], ["proof (state)\nthis:\n  V = (\\<Union>(A, X)\\<in>Q_pos. A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  V = (\\<Union>(A, X)\\<in>Q_pos. A)\n\ngoal (1 subgoal):\n 1. Q \\<noteq> {} \\<Longrightarrow>\n    (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "ultimately"], ["proof (chain)\npicking this:\n  (z \\<in> genericJoin V Q Qn) =\n  ((\\<forall>(A, X)\\<in>Q_pos - Q. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Q_neg - Qn. restrict A z \\<notin> X) \\<and>\n   wf_tuple n V z \\<and>\n   (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))\n  V = (\\<Union>(A, X)\\<in>Q_pos. A)", "show ?thesis (is \"?a = ?b\")"], ["proof (prove)\nusing this:\n  (z \\<in> genericJoin V Q Qn) =\n  ((\\<forall>(A, X)\\<in>Q_pos - Q. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Q_neg - Qn. restrict A z \\<notin> X) \\<and>\n   wf_tuple n V z \\<and>\n   (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))\n  V = (\\<Union>(A, X)\\<in>Q_pos. A)\n\ngoal (1 subgoal):\n 1. (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(z \\<in> genericJoin V Q Qn) =\n             ((\\<forall>(A, X)\\<in>Q_pos - Q. restrict A z \\<in> X) \\<and>\n              (\\<forall>(A, X)\\<in>Q_neg - Qn.\n                  restrict A z \\<notin> X) \\<and>\n              wf_tuple n V z \\<and>\n              (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n              (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X));\n     V = (\\<Union>(A, X)\\<in>Q_pos. A)\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n                      (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n                       (\\<forall>(A, X)\\<in>Q_pos.\n                           restrict A z \\<in> X) \\<and>\n                       (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "have \"?a \\<Longrightarrow> ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> wrapperGenericJoin Q_pos Q_neg \\<Longrightarrow>\n    wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n    (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)", "using Diff_iff \\<open>(z \\<in> genericJoin V Q Qn) = ((\\<forall>(A, X)\\<in>Q_pos - Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Q_neg - Qn. restrict A z \\<notin> X) \\<and> wf_tuple n V z \\<and> (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))\\<close> \\<open>V = (\\<Union>(A, X)\\<in>Q_pos. A)\\<close> \\<open>wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn\\<close>"], ["proof (prove)\nusing this:\n  (?c \\<in> ?A - ?B) = (?c \\<in> ?A \\<and> ?c \\<notin> ?B)\n  (z \\<in> genericJoin V Q Qn) =\n  ((\\<forall>(A, X)\\<in>Q_pos - Q. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Q_neg - Qn. restrict A z \\<notin> X) \\<and>\n   wf_tuple n V z \\<and>\n   (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))\n  V = (\\<Union>(A, X)\\<in>Q_pos. A)\n  wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn\n\ngoal (1 subgoal):\n 1. z \\<in> wrapperGenericJoin Q_pos Q_neg \\<Longrightarrow>\n    wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n    (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)", "by blast"], ["proof (state)\nthis:\n  z \\<in> wrapperGenericJoin Q_pos Q_neg \\<Longrightarrow>\n  wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n  (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(z \\<in> genericJoin V Q Qn) =\n             ((\\<forall>(A, X)\\<in>Q_pos - Q. restrict A z \\<in> X) \\<and>\n              (\\<forall>(A, X)\\<in>Q_neg - Qn.\n                  restrict A z \\<notin> X) \\<and>\n              wf_tuple n V z \\<and>\n              (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n              (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X));\n     V = (\\<Union>(A, X)\\<in>Q_pos. A)\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n                      (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n                       (\\<forall>(A, X)\\<in>Q_pos.\n                           restrict A z \\<in> X) \\<and>\n                       (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "moreover"], ["proof (state)\nthis:\n  z \\<in> wrapperGenericJoin Q_pos Q_neg \\<Longrightarrow>\n  wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n  (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(z \\<in> genericJoin V Q Qn) =\n             ((\\<forall>(A, X)\\<in>Q_pos - Q. restrict A z \\<in> X) \\<and>\n              (\\<forall>(A, X)\\<in>Q_neg - Qn.\n                  restrict A z \\<notin> X) \\<and>\n              wf_tuple n V z \\<and>\n              (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n              (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X));\n     V = (\\<Union>(A, X)\\<in>Q_pos. A)\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n                      (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n                       (\\<forall>(A, X)\\<in>Q_pos.\n                           restrict A z \\<in> X) \\<and>\n                       (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "have \"?b \\<Longrightarrow> ?a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n    (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X) \\<Longrightarrow>\n    z \\<in> wrapperGenericJoin Q_pos Q_neg", "using Q_def Qn_def \\<open>(z \\<in> genericJoin V Q Qn) = (wf_tuple n V z \\<and> (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and> (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))\\<close> \\<open>V = (\\<Union>(A, X)\\<in>Q_pos. A)\\<close> \\<open>wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn\\<close>"], ["proof (prove)\nusing this:\n  Q = Set.filter (\\<lambda>(A, uu_). \\<not> Set.is_empty A) Q_pos\n  Qn =\n  Set.filter (\\<lambda>(A, uu_). A \\<subseteq> V \\<and> 1 \\<le> card A)\n   Q_neg\n  (z \\<in> genericJoin V Q Qn) =\n  (wf_tuple n V z \\<and>\n   (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X))\n  V = (\\<Union>(A, X)\\<in>Q_pos. A)\n  wrapperGenericJoin Q_pos Q_neg = genericJoin V Q Qn\n\ngoal (1 subgoal):\n 1. wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n    (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n    (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X) \\<Longrightarrow>\n    z \\<in> wrapperGenericJoin Q_pos Q_neg", "by auto"], ["proof (state)\nthis:\n  wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n  (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X) \\<Longrightarrow>\n  z \\<in> wrapperGenericJoin Q_pos Q_neg\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(z \\<in> genericJoin V Q Qn) =\n             ((\\<forall>(A, X)\\<in>Q_pos - Q. restrict A z \\<in> X) \\<and>\n              (\\<forall>(A, X)\\<in>Q_neg - Qn.\n                  restrict A z \\<notin> X) \\<and>\n              wf_tuple n V z \\<and>\n              (\\<forall>(A, X)\\<in>Q. restrict A z \\<in> X) \\<and>\n              (\\<forall>(A, X)\\<in>Qn. restrict A z \\<notin> X));\n     V = (\\<Union>(A, X)\\<in>Q_pos. A)\\<rbrakk>\n    \\<Longrightarrow> (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n                      (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n                       (\\<forall>(A, X)\\<in>Q_pos.\n                           restrict A z \\<in> X) \\<and>\n                       (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "ultimately"], ["proof (chain)\npicking this:\n  z \\<in> wrapperGenericJoin Q_pos Q_neg \\<Longrightarrow>\n  wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n  (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)\n  wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n  (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X) \\<Longrightarrow>\n  z \\<in> wrapperGenericJoin Q_pos Q_neg", "show ?thesis"], ["proof (prove)\nusing this:\n  z \\<in> wrapperGenericJoin Q_pos Q_neg \\<Longrightarrow>\n  wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n  (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X)\n  wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n  (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n  (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X) \\<Longrightarrow>\n  z \\<in> wrapperGenericJoin Q_pos Q_neg\n\ngoal (1 subgoal):\n 1. (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n    (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n     (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n     (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))", "by blast"], ["proof (state)\nthis:\n  (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n  (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n   (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n  (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n   (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (z \\<in> wrapperGenericJoin Q_pos Q_neg) =\n  (wf_tuple n (\\<Union>(A, X)\\<in>Q_pos. A) z \\<and>\n   (\\<forall>(A, X)\\<in>Q_pos. restrict A z \\<in> X) \\<and>\n   (\\<forall>(A, X)\\<in>Q_neg. restrict A z \\<notin> X))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}