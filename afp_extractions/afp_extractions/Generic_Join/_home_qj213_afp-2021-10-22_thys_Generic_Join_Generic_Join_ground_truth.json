{"file_name": "/home/qj213/afp-2021-10-22/thys/Generic_Join/Generic_Join.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Generic_Join", "problem_names": ["lemma getIJProperties:\n  assumes \"card V \\<ge> 2\"\n  assumes \"(I, J) = getIJ Q_pos Q_neg V\"\n  shows \"card I \\<ge> 1\" and \"card J \\<ge> 1\" and \"card I < card V\" and \"card J < card V\"\n    and \"V = I \\<union> J\" and \"I \\<inter> J = {}\"", "lemma arg_max_list_element:\n  assumes \"length l \\<ge> 1\" shows \"arg_max_list f l \\<in> set l\"", "lemma max_getIJ_coreProperties:\n  assumes \"card V \\<ge> 2\"\n  assumes \"(I, J) = max_getIJ Q_pos Q_neg V\"\n  shows \"card I \\<ge> 1 \\<and> card J \\<ge> 1 \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}\""], "translations": [["", "lemma getIJProperties:\n  assumes \"card V \\<ge> 2\"\n  assumes \"(I, J) = getIJ Q_pos Q_neg V\"\n  shows \"card I \\<ge> 1\" and \"card J \\<ge> 1\" and \"card I < card V\" and \"card J < card V\"\n    and \"V = I \\<union> J\" and \"I \\<inter> J = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 \\<le> card I &&& 1 \\<le> card J &&& card I < card V) &&&\n    card J < card V &&& V = I \\<union> J &&& I \\<inter> J = {}", "proof -"], ["proof (state)\ngoal (6 subgoals):\n 1. 1 \\<le> card I\n 2. 1 \\<le> card J\n 3. card I < card V\n 4. card J < card V\n 5. V = I \\<union> J\n 6. I \\<inter> J = {}", "show \"1 \\<le> card I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> card I", "using coreProperties[of V Q_pos Q_neg I J] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>2 \\<le> card V; getIJ Q_pos Q_neg V = (I, J)\\<rbrakk>\n  \\<Longrightarrow> 1 \\<le> card I \\<and>\n                    1 \\<le> card J \\<and>\n                    V = I \\<union> J \\<and> I \\<inter> J = {}\n  2 \\<le> card V\n  (I, J) = getIJ Q_pos Q_neg V\n\ngoal (1 subgoal):\n 1. 1 \\<le> card I", "by auto"], ["proof (state)\nthis:\n  1 \\<le> card I\n\ngoal (5 subgoals):\n 1. 1 \\<le> card J\n 2. card I < card V\n 3. card J < card V\n 4. V = I \\<union> J\n 5. I \\<inter> J = {}", "show \"1 \\<le> card J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> card J", "using coreProperties[of V Q_pos Q_neg I J] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>2 \\<le> card V; getIJ Q_pos Q_neg V = (I, J)\\<rbrakk>\n  \\<Longrightarrow> 1 \\<le> card I \\<and>\n                    1 \\<le> card J \\<and>\n                    V = I \\<union> J \\<and> I \\<inter> J = {}\n  2 \\<le> card V\n  (I, J) = getIJ Q_pos Q_neg V\n\ngoal (1 subgoal):\n 1. 1 \\<le> card J", "by auto"], ["proof (state)\nthis:\n  1 \\<le> card J\n\ngoal (4 subgoals):\n 1. card I < card V\n 2. card J < card V\n 3. V = I \\<union> J\n 4. I \\<inter> J = {}", "show \"card I < card V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card I < card V", "by (metis (no_types, lifting) Int_ac(3) One_nat_def Suc_le_lessD assms(1)\n        assms(2) card_gt_0_iff card_seteq dual_order.trans getIJ.coreProperties getIJ_axioms leI\n        le_iff_inf one_le_numeral sup_ge1 sup_ge2)"], ["proof (state)\nthis:\n  card I < card V\n\ngoal (3 subgoals):\n 1. card J < card V\n 2. V = I \\<union> J\n 3. I \\<inter> J = {}", "show \"card J < card V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card J < card V", "by (metis One_nat_def Suc_1 assms(1) assms(2) card_gt_0_iff card_seteq\n        getIJ.coreProperties getIJ_axioms leI le_0_eq le_iff_inf nat.simps(3) sup_ge1 sup_ge2)"], ["proof (state)\nthis:\n  card J < card V\n\ngoal (2 subgoals):\n 1. V = I \\<union> J\n 2. I \\<inter> J = {}", "show \"V = I \\<union> J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V = I \\<union> J", "by (metis assms(1) assms(2) getIJ.coreProperties getIJ_axioms)"], ["proof (state)\nthis:\n  V = I \\<union> J\n\ngoal (1 subgoal):\n 1. I \\<inter> J = {}", "show \"I \\<inter> J = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<inter> J = {}", "by (metis assms(1) assms(2) getIJ_axioms getIJ_def)"], ["proof (state)\nthis:\n  I \\<inter> J = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "fun projectTable :: \"vertices \\<Rightarrow> 'a atable \\<Rightarrow> 'a atable\" where\n  \"projectTable V (s, t) = (s \\<inter> V, Set.image (restrict V) t)\""], ["", "fun filterQuery :: \"vertices \\<Rightarrow> 'a query \\<Rightarrow> 'a query\" where\n  \"filterQuery V Q = Set.filter (\\<lambda>(s, _). \\<not> Set.is_empty (s \\<inter> V)) Q\""], ["", "fun filterQueryNeg :: \"vertices \\<Rightarrow> 'a query \\<Rightarrow> 'a query\" where\n  \"filterQueryNeg V Q = Set.filter (\\<lambda>(A, _). A \\<subseteq> V) Q\""], ["", "fun projectQuery :: \"vertices \\<Rightarrow> 'a query \\<Rightarrow> 'a query\" where\n  \"projectQuery V s = Set.image (projectTable V) s\""], ["", "fun isSameIntersection :: \"'a tuple \\<Rightarrow> nat set \\<Rightarrow> 'a tuple \\<Rightarrow> bool\" where\n  \"isSameIntersection t1 s t2 = (\\<forall>i\\<in>s. t1!i = t2!i)\""], ["", "fun semiJoin :: \"'a atable \\<Rightarrow> (nat set \\<times> 'a tuple) \\<Rightarrow> 'a atable\" where\n  \"semiJoin (s, tab) (st, tup) = (s, Set.filter (isSameIntersection tup (s \\<inter> st)) tab)\""], ["", "fun newQuery :: \"vertices \\<Rightarrow> 'a query \\<Rightarrow> (nat set \\<times> 'a tuple) \\<Rightarrow> 'a query\" where\n  \"newQuery V Q (st, t) = Set.image (\\<lambda>tab. projectTable V (semiJoin tab (st, t))) Q\""], ["", "fun merge_option :: \"'a option \\<times> 'a option \\<Rightarrow> 'a option\" where\n  \"merge_option (None, None) = None\"\n| \"merge_option (Some x, None) = Some x\"\n| \"merge_option (None, Some x) = Some x\"\n| \"merge_option (Some a, Some b) = Some a\""], ["", "(* Last case shouldn't happen but useful for proof *)"], ["", "fun merge :: \"'a tuple \\<Rightarrow> 'a tuple \\<Rightarrow> 'a tuple\" where\n  \"merge t1 t2 = map merge_option (zip t1 t2)\""], ["", "function (sequential) genericJoin :: \"vertices \\<Rightarrow> 'a query \\<Rightarrow> 'a query \\<Rightarrow> 'a table\" where\n  \"genericJoin V Q_pos Q_neg =\n    (if card V \\<le> 1 then\n      (\\<Inter>(_, x) \\<in> Q_pos. x) - (\\<Union>(_, x) \\<in> Q_neg. x)\n    else\n      let (I, J) = getIJ Q_pos Q_neg V in\n      let Q_I_pos = projectQuery I (filterQuery I Q_pos) in\n      let Q_I_neg = filterQueryNeg I Q_neg in\n      let R_I = genericJoin I Q_I_pos Q_I_neg in\n      let Q_J_neg = Q_neg - Q_I_neg in\n      let Q_J_pos = filterQuery J Q_pos in\n      let X = {(t, genericJoin J (newQuery J Q_J_pos (I, t)) (newQuery J Q_J_neg (I, t))) | t . t \\<in> R_I} in\n      (\\<Union>(t, x) \\<in> X. {merge xx t | xx . xx \\<in> x}))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>V Q_pos Q_neg.\n           x = (V, Q_pos, Q_neg) \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 2. \\<And>V Q_pos Q_neg Va Q_posa Q_nega.\n       (V, Q_pos, Q_neg) = (Va, Q_posa, Q_nega) \\<Longrightarrow>\n       (if card V \\<le> 1\n        then (\\<Inter>(uu_, x)\\<in>Q_pos. x) -\n             (\\<Union>(uu_, x)\\<in>Q_neg. x)\n        else let (I, J) = getIJ Q_pos Q_neg V;\n                 Q_I_pos = projectQuery I (filterQuery I Q_pos);\n                 Q_I_neg = filterQueryNeg I Q_neg;\n                 R_I = genericJoin_sumC (I, Q_I_pos, Q_I_neg);\n                 Q_J_neg = Q_neg - Q_I_neg; Q_J_pos = filterQuery J Q_pos;\n                 X = {(t, genericJoin_sumC\n                           (J, newQuery J Q_J_pos (I, t),\n                            newQuery J Q_J_neg (I, t))) |\n                      t. t \\<in> R_I}\n             in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x}) =\n       (if card Va \\<le> 1\n        then (\\<Inter>(uu_, x)\\<in>Q_posa. x) -\n             (\\<Union>(uu_, x)\\<in>Q_nega. x)\n        else let (I, J) = getIJ Q_posa Q_nega Va;\n                 Q_I_pos = projectQuery I (filterQuery I Q_posa);\n                 Q_I_neg = filterQueryNeg I Q_nega;\n                 R_I = genericJoin_sumC (I, Q_I_pos, Q_I_neg);\n                 Q_J_neg = Q_nega - Q_I_neg; Q_J_pos = filterQuery J Q_posa;\n                 X = {(t, genericJoin_sumC\n                           (J, newQuery J Q_J_pos (I, t),\n                            newQuery J Q_J_neg (I, t))) |\n                      t. t \\<in> R_I}\n             in \\<Union>(t, x)\\<in>X. {merge xx t |xx. xx \\<in> x})", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All genericJoin_dom", "by (relation \"measure (\\<lambda>(V, Q_pos, Q_neg). card V)\") (auto simp add: getIJProperties)"], ["", "fun wrapperGenericJoin :: \"'a query \\<Rightarrow> 'a query \\<Rightarrow> 'a table\" where\n  \"wrapperGenericJoin Q_pos Q_neg =\n    (if ((\\<exists>(A, X)\\<in>Q_pos. Set.is_empty X) \\<or> (\\<exists>(A, X)\\<in>Q_neg. Set.is_empty A \\<and> \\<not> Set.is_empty X)) then\n      {}\n    else\n      let Q = Set.filter (\\<lambda>(A, _). \\<not> Set.is_empty A) Q_pos in\n      if Set.is_empty Q then\n        (\\<Inter>(A, X)\\<in>Q_pos. X) -  (\\<Union>(A, X)\\<in>Q_neg. X)\n      else\n        let V = (\\<Union>(A, X)\\<in>Q. A) in\n        let Qn = Set.filter (\\<lambda>(A, _). A \\<subseteq> V \\<and> card A \\<ge> 1) Q_neg in\n        genericJoin V Q Qn)\""], ["", "end"], ["", "subsection \\<open>An instantation\\<close>"], ["", "fun score :: \"'a query \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"score Q i = (let relevant = Set.image (\\<lambda>(_, x). card x) (Set.filter (\\<lambda>(sign, _). i \\<in> sign) Q) in\n    let l = sorted_list_of_set relevant in\n    foldl (+) 0 l\n)\""], ["", "fun arg_max_list :: \"('a \\<Rightarrow> nat) \\<Rightarrow> 'a list \\<Rightarrow> 'a\" where\n  \"arg_max_list f l = (let m = Max (set (map f l)) in arg_min_list (\\<lambda>x. m - f x) l)\""], ["", "lemma arg_max_list_element:\n  assumes \"length l \\<ge> 1\" shows \"arg_max_list f l \\<in> set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg_max_list f l \\<in> set l", "by (metis One_nat_def arg_max_list.simps arg_min_list_in assms le_imp_less_Suc less_irrefl list.size(3))"], ["", "fun max_getIJ :: \"'a query \\<Rightarrow> 'a query \\<Rightarrow> vertices \\<Rightarrow> vertices \\<times> vertices\" where\n  \"max_getIJ Q_pos Q_neg V = (\n  let l = sorted_list_of_set V in\n  if Set.is_empty Q_neg then\n    let x = arg_max_list (score Q_pos) l in\n    ({x}, V - {x})\n  else\n    let x = arg_max_list (score Q_neg) l in\n    (V - {x}, {x}))\""], ["", "lemma max_getIJ_coreProperties:\n  assumes \"card V \\<ge> 2\"\n  assumes \"(I, J) = max_getIJ Q_pos Q_neg V\"\n  shows \"card I \\<ge> 1 \\<and> card J \\<ge> 1 \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}", "have \"finite V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite V", "using assms(1) card.infinite"], ["proof (prove)\nusing this:\n  2 \\<le> card V\n  infinite ?A \\<Longrightarrow> card ?A = 0\n\ngoal (1 subgoal):\n 1. finite V", "by force"], ["proof (state)\nthis:\n  finite V\n\ngoal (1 subgoal):\n 1. 1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}", "define l where \"l = sorted_list_of_set V\""], ["proof (state)\nthis:\n  l = sorted_list_of_set V\n\ngoal (1 subgoal):\n 1. 1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}", "then"], ["proof (chain)\npicking this:\n  l = sorted_list_of_set V", "have \"length l \\<ge> 1\""], ["proof (prove)\nusing this:\n  l = sorted_list_of_set V\n\ngoal (1 subgoal):\n 1. 1 \\<le> length l", "by (metis Suc_1 Suc_le_lessD \\<open>finite V\\<close> assms(1) distinct_card\n        distinct_sorted_list_of_set less_imp_le set_sorted_list_of_set)"], ["proof (state)\nthis:\n  1 \\<le> length l\n\ngoal (1 subgoal):\n 1. 1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}", "proof (cases \"Set.is_empty Q_neg\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Set.is_empty Q_neg \\<Longrightarrow>\n    1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}\n 2. \\<not> Set.is_empty Q_neg \\<Longrightarrow>\n    1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}", "case True"], ["proof (state)\nthis:\n  Set.is_empty Q_neg\n\ngoal (2 subgoals):\n 1. Set.is_empty Q_neg \\<Longrightarrow>\n    1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}\n 2. \\<not> Set.is_empty Q_neg \\<Longrightarrow>\n    1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}", "define x where \"x = arg_max_list (score Q_pos) l\""], ["proof (state)\nthis:\n  x = arg_max_list (score Q_pos) l\n\ngoal (2 subgoals):\n 1. Set.is_empty Q_neg \\<Longrightarrow>\n    1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}\n 2. \\<not> Set.is_empty Q_neg \\<Longrightarrow>\n    1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}", "then"], ["proof (chain)\npicking this:\n  x = arg_max_list (score Q_pos) l", "have \"x \\<in> (set l)\""], ["proof (prove)\nusing this:\n  x = arg_max_list (score Q_pos) l\n\ngoal (1 subgoal):\n 1. x \\<in> set l", "using \\<open>1 \\<le> length l\\<close> arg_max_list_element"], ["proof (prove)\nusing this:\n  x = arg_max_list (score Q_pos) l\n  1 \\<le> length l\n  1 \\<le> length ?l \\<Longrightarrow> arg_max_list ?f ?l \\<in> set ?l\n\ngoal (1 subgoal):\n 1. x \\<in> set l", "by blast"], ["proof (state)\nthis:\n  x \\<in> set l\n\ngoal (2 subgoals):\n 1. Set.is_empty Q_neg \\<Longrightarrow>\n    1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}\n 2. \\<not> Set.is_empty Q_neg \\<Longrightarrow>\n    1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}", "then"], ["proof (chain)\npicking this:\n  x \\<in> set l", "have \"x \\<in> V\""], ["proof (prove)\nusing this:\n  x \\<in> set l\n\ngoal (1 subgoal):\n 1. x \\<in> V", "by (simp add: \\<open>finite V\\<close> l_def)"], ["proof (state)\nthis:\n  x \\<in> V\n\ngoal (2 subgoals):\n 1. Set.is_empty Q_neg \\<Longrightarrow>\n    1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}\n 2. \\<not> Set.is_empty Q_neg \\<Longrightarrow>\n    1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}", "moreover"], ["proof (state)\nthis:\n  x \\<in> V\n\ngoal (2 subgoals):\n 1. Set.is_empty Q_neg \\<Longrightarrow>\n    1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}\n 2. \\<not> Set.is_empty Q_neg \\<Longrightarrow>\n    1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}", "have \"(I, J) = ({x}, V - {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I, J) = ({x}, V - {x})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (I, J) = ({x}, V - {x})", "have \"(I, J) =  (let l = sorted_list_of_set V in\n    let x = arg_max_list (score Q_pos) l in\n    ({x}, V - {x}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I, J) =\n    (let l = sorted_list_of_set V; x = arg_max_list (score Q_pos) l\n     in ({x}, V - {x}))", "by (simp add: True assms(2))"], ["proof (state)\nthis:\n  (I, J) =\n  (let l = sorted_list_of_set V; x = arg_max_list (score Q_pos) l\n   in ({x}, V - {x}))\n\ngoal (1 subgoal):\n 1. (I, J) = ({x}, V - {x})", "then"], ["proof (chain)\npicking this:\n  (I, J) =\n  (let l = sorted_list_of_set V; x = arg_max_list (score Q_pos) l\n   in ({x}, V - {x}))", "show ?thesis"], ["proof (prove)\nusing this:\n  (I, J) =\n  (let l = sorted_list_of_set V; x = arg_max_list (score Q_pos) l\n   in ({x}, V - {x}))\n\ngoal (1 subgoal):\n 1. (I, J) = ({x}, V - {x})", "by (metis l_def x_def)"], ["proof (state)\nthis:\n  (I, J) = ({x}, V - {x})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (I, J) = ({x}, V - {x})\n\ngoal (2 subgoals):\n 1. Set.is_empty Q_neg \\<Longrightarrow>\n    1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}\n 2. \\<not> Set.is_empty Q_neg \\<Longrightarrow>\n    1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}", "then"], ["proof (chain)\npicking this:\n  (I, J) = ({x}, V - {x})", "show ?thesis"], ["proof (prove)\nusing this:\n  (I, J) = ({x}, V - {x})\n\ngoal (1 subgoal):\n 1. 1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}", "using Pair_inject \\<open>finite V\\<close> assms(1) calculation"], ["proof (prove)\nusing this:\n  (I, J) = ({x}, V - {x})\n  \\<lbrakk>(?a, ?b) = (?a', ?b');\n   \\<lbrakk>?a = ?a'; ?b = ?b'\\<rbrakk> \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n  finite V\n  2 \\<le> card V\n  x \\<in> V\n\ngoal (1 subgoal):\n 1. 1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}", "by auto"], ["proof (state)\nthis:\n  1 \\<le> card I \\<and>\n  1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}\n\ngoal (1 subgoal):\n 1. \\<not> Set.is_empty Q_neg \\<Longrightarrow>\n    1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Set.is_empty Q_neg \\<Longrightarrow>\n    1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}", "case False"], ["proof (state)\nthis:\n  \\<not> Set.is_empty Q_neg\n\ngoal (1 subgoal):\n 1. \\<not> Set.is_empty Q_neg \\<Longrightarrow>\n    1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}", "define x where \"x = arg_max_list (score Q_neg) l\""], ["proof (state)\nthis:\n  x = arg_max_list (score Q_neg) l\n\ngoal (1 subgoal):\n 1. \\<not> Set.is_empty Q_neg \\<Longrightarrow>\n    1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}", "then"], ["proof (chain)\npicking this:\n  x = arg_max_list (score Q_neg) l", "have \"x \\<in> (set l)\""], ["proof (prove)\nusing this:\n  x = arg_max_list (score Q_neg) l\n\ngoal (1 subgoal):\n 1. x \\<in> set l", "using \\<open>1 \\<le> length l\\<close> arg_max_list_element"], ["proof (prove)\nusing this:\n  x = arg_max_list (score Q_neg) l\n  1 \\<le> length l\n  1 \\<le> length ?l \\<Longrightarrow> arg_max_list ?f ?l \\<in> set ?l\n\ngoal (1 subgoal):\n 1. x \\<in> set l", "by blast"], ["proof (state)\nthis:\n  x \\<in> set l\n\ngoal (1 subgoal):\n 1. \\<not> Set.is_empty Q_neg \\<Longrightarrow>\n    1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}", "then"], ["proof (chain)\npicking this:\n  x \\<in> set l", "have \"x \\<in> V\""], ["proof (prove)\nusing this:\n  x \\<in> set l\n\ngoal (1 subgoal):\n 1. x \\<in> V", "by (simp add: \\<open>finite V\\<close> l_def)"], ["proof (state)\nthis:\n  x \\<in> V\n\ngoal (1 subgoal):\n 1. \\<not> Set.is_empty Q_neg \\<Longrightarrow>\n    1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}", "moreover"], ["proof (state)\nthis:\n  x \\<in> V\n\ngoal (1 subgoal):\n 1. \\<not> Set.is_empty Q_neg \\<Longrightarrow>\n    1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}", "have \"(I, J) = (V - {x}, {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I, J) = (V - {x}, {x})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (I, J) = (V - {x}, {x})", "have \"(I, J) = (let l = sorted_list_of_set V in\n  let x = arg_max_list (score Q_neg) l in (V - {x}, {x}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I, J) =\n    (let l = sorted_list_of_set V; x = arg_max_list (score Q_neg) l\n     in (V - {x}, {x}))", "by (simp add: False assms(2))"], ["proof (state)\nthis:\n  (I, J) =\n  (let l = sorted_list_of_set V; x = arg_max_list (score Q_neg) l\n   in (V - {x}, {x}))\n\ngoal (1 subgoal):\n 1. (I, J) = (V - {x}, {x})", "then"], ["proof (chain)\npicking this:\n  (I, J) =\n  (let l = sorted_list_of_set V; x = arg_max_list (score Q_neg) l\n   in (V - {x}, {x}))", "show ?thesis"], ["proof (prove)\nusing this:\n  (I, J) =\n  (let l = sorted_list_of_set V; x = arg_max_list (score Q_neg) l\n   in (V - {x}, {x}))\n\ngoal (1 subgoal):\n 1. (I, J) = (V - {x}, {x})", "by (metis l_def x_def)"], ["proof (state)\nthis:\n  (I, J) = (V - {x}, {x})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (I, J) = (V - {x}, {x})\n\ngoal (1 subgoal):\n 1. \\<not> Set.is_empty Q_neg \\<Longrightarrow>\n    1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}", "then"], ["proof (chain)\npicking this:\n  (I, J) = (V - {x}, {x})", "show ?thesis"], ["proof (prove)\nusing this:\n  (I, J) = (V - {x}, {x})\n\ngoal (1 subgoal):\n 1. 1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}", "using Pair_inject \\<open>finite V\\<close> assms(1) calculation"], ["proof (prove)\nusing this:\n  (I, J) = (V - {x}, {x})\n  \\<lbrakk>(?a, ?b) = (?a', ?b');\n   \\<lbrakk>?a = ?a'; ?b = ?b'\\<rbrakk> \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n  finite V\n  2 \\<le> card V\n  x \\<in> V\n\ngoal (1 subgoal):\n 1. 1 \\<le> card I \\<and>\n    1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}", "by auto"], ["proof (state)\nthis:\n  1 \\<le> card I \\<and>\n  1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  1 \\<le> card I \\<and>\n  1 \\<le> card J \\<and> V = I \\<union> J \\<and> I \\<inter> J = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "global_interpretation New_max: getIJ max_getIJ\n  defines New_max_getIJ_genericJoin = \"New_max.genericJoin\"\n  and New_max_getIJ_wrapperGenericJoin = \"New_max.wrapperGenericJoin\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getIJ max_getIJ", "by standard (metis max_getIJ_coreProperties)"], ["", "end"]]}