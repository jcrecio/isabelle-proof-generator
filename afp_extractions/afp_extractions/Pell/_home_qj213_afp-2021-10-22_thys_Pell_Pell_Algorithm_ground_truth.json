{"file_name": "/home/qj213/afp-2021-10-22/thys/Pell/Pell_Algorithm.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Pell", "problem_names": ["lemma efficient_power_code [code]:\n  \"efficient_power y x n =\n     (if n = 0 then y\n      else if n = 1 then f x y\n      else if even n then efficient_power y (f x x) (n div 2)\n      else efficient_power (f x y) (f x x) (n div 2))\"", "lemma efficient_power_correct:\n  assumes \"\\<And>x z. f x (f x z) = f (f x x) z\"\n  shows   \"efficient_power y x n = (f x ^^ n) y\"", "lemma (in pell) pell_mul_nat_correct [simp]: \"pell_mul_nat D = pell.pell_mul D\"", "lemma efficient_pell_power_correct [simp]:\n  \"efficient_pell_power D z n = (pell_mul_nat D z ^^ n) (1, 0)\"", "lemma Discrete_sqrt_square_is_square:\n  assumes \"is_square n\"\n  shows   \"Discrete.sqrt n ^ 2 = n\"", "lemma fund_sol_code:\n  assumes \"\\<not>is_square (D :: nat)\"\n  shows   \"pell.fund_sol D = sum.projr (while isl (find_fund_sol_step D) (Inl (Suc 0, Suc D)))\"", "lemma find_fund_sol_correct: \"find_fund_sol D = (if is_square D then (0, 0) else pell.fund_sol D)\"", "lemma (in pell) \"snth (pell_solutions D) n = nth_solution n\"", "lemma (in pell) find_nth_solution_correct: \"find_nth_solution D n = nth_solution n\""], "translations": [["", "lemma efficient_power_code [code]:\n  \"efficient_power y x n =\n     (if n = 0 then y\n      else if n = 1 then f x y\n      else if even n then efficient_power y (f x x) (n div 2)\n      else efficient_power (f x y) (f x x) (n div 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.efficient_power y x n =\n    (if n = 0 then y\n     else if n = 1 then f x y\n          else if even n then local.efficient_power y (f x x) (n div 2)\n               else local.efficient_power (f x y) (f x x) (n div 2))", "by (induction y x n rule: efficient_power.induct) auto"], ["", "lemma efficient_power_correct:\n  assumes \"\\<And>x z. f x (f x z) = f (f x x) z\"\n  shows   \"efficient_power y x n = (f x ^^ n) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.efficient_power y x n = (f x ^^ n) y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.efficient_power y x n = (f x ^^ n) y", "have [simp]: \"f ^^ 2 = (\\<lambda>x. f (f x))\" for f :: \"'a \\<Rightarrow> 'a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ^^ 2 = (\\<lambda>x. f (f x))", "by (simp add: eval_nat_numeral o_def)"], ["proof (state)\nthis:\n  ?f ^^ 2 = (\\<lambda>x. ?f (?f x))\n\ngoal (1 subgoal):\n 1. local.efficient_power y x n = (f x ^^ n) y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.efficient_power y x n = (f x ^^ n) y", "by (induction y x n rule: efficient_power.induct)\n       (auto elim!: evenE oddE simp: funpow_mult [symmetric] funpow_Suc_right assms\n             simp del: funpow.simps(2))"], ["proof (state)\nthis:\n  local.efficient_power y x n = (f x ^^ n) y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Multiplication and powers of solutions\\<close>"], ["", "text \\<open>\n  We define versions of Pell solution multiplication and exponentiation specialised\n  to natural numbers, both for efficiency reasons and to circumvent the problem of\n  generating code for definitions made inside locales.\n\\<close>"], ["", "fun pell_mul_nat :: \"nat \\<Rightarrow> nat \\<times> nat \\<Rightarrow> _\" where\n  \"pell_mul_nat D (a, b) (x, y) = (a * x + D * b * y, a * y + b * x)\""], ["", "lemma (in pell) pell_mul_nat_correct [simp]: \"pell_mul_nat D = pell.pell_mul D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_mul_nat D = pell_mul", "by (auto simp add: pell_mul_def fun_eq_iff)"], ["", "definition efficient_pell_power :: \"nat \\<Rightarrow> nat \\<times> nat \\<Rightarrow> nat \\<Rightarrow> nat \\<times> nat\" where\n  \"efficient_pell_power D z n = efficient_power (pell_mul_nat D) (1, 0) z n\""], ["", "lemma efficient_pell_power_correct [simp]:\n  \"efficient_pell_power D z n = (pell_mul_nat D z ^^ n) (1, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. efficient_pell_power D z n = (pell_mul_nat D z ^^ n) (1, 0)", "unfolding efficient_pell_power_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. efficient_power (pell_mul_nat D) (1, 0) z n =\n    (pell_mul_nat D z ^^ n) (1, 0)", "by (intro efficient_power_correct) (auto simp: algebra_simps)"], ["", "subsubsection \\<open>Finding the fundamental solution\\<close>"], ["", "text \\<open>\n  In the following, we set up a very simple algorithm for computing the fundamental\n  solution \\<open>(x, y)\\<close>. We try inreasing values for \\<open>y\\<close> until $1 + Dy^2$ is a perfect \n  square, which we check using an efficient square-detection algorithm. This is efficient\n  enough to work on some interesting small examples.\n\n  Much better algorithms (typically based on the continued fraction expansion of $\\sqrt{D}$) \n  are available, but they are also considerably more complicated.\n\\<close>"], ["", "lemma Discrete_sqrt_square_is_square:\n  assumes \"is_square n\"\n  shows   \"Discrete.sqrt n ^ 2 = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Discrete.sqrt n)\\<^sup>2 = n", "using assms"], ["proof (prove)\nusing this:\n  is_square n\n\ngoal (1 subgoal):\n 1. (Discrete.sqrt n)\\<^sup>2 = n", "unfolding is_nth_power_def"], ["proof (prove)\nusing this:\n  \\<exists>y. n = y\\<^sup>2\n\ngoal (1 subgoal):\n 1. (Discrete.sqrt n)\\<^sup>2 = n", "by force"], ["", "definition find_fund_sol_step :: \"nat \\<Rightarrow> nat \\<times> nat + nat \\<times> nat \\<Rightarrow> _\" where\n  \"find_fund_sol_step D = (\\<lambda>Inl (y, y') \\<Rightarrow>\n     (case get_nat_sqrt y' of \n        Some x \\<Rightarrow> Inr (x, y)\n      | None \\<Rightarrow> Inl (y + 1, y' + D * (2 * y + 1))))\""], ["", "definition find_fund_sol where\n  \"find_fund_sol D =\n     (if square_test D then\n        (0, 0)\n      else\n        sum.projr (while sum.isl (find_fund_sol_step D) (Inl (1, 1 + D))))\""], ["", "lemma fund_sol_code:\n  assumes \"\\<not>is_square (D :: nat)\"\n  shows   \"pell.fund_sol D = sum.projr (while isl (find_fund_sol_step D) (Inl (Suc 0, Suc D)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell.fund_sol D =\n    projr (while isl (find_fund_sol_step D) (Inl (Suc 0, Suc D)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pell.fund_sol D =\n    projr (while isl (find_fund_sol_step D) (Inl (Suc 0, Suc D)))", "from assms"], ["proof (chain)\npicking this:\n  \\<not> is_square D", "interpret pell D"], ["proof (prove)\nusing this:\n  \\<not> is_square D\n\ngoal (1 subgoal):\n 1. pell D", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. fund_sol = projr (while isl (find_fund_sol_step D) (Inl (Suc 0, Suc D)))", "note [simp] = find_fund_sol_step_def"], ["proof (state)\nthis:\n  find_fund_sol_step ?D =\n  (\\<lambda>x.\n      case x of\n      Inl (y, y') \\<Rightarrow>\n        case get_nat_sqrt y' of\n        None \\<Rightarrow> Inl (y + 1, y' + ?D * (2 * y + 1))\n        | Some x \\<Rightarrow> Inr (x, y))\n\ngoal (1 subgoal):\n 1. fund_sol = projr (while isl (find_fund_sol_step D) (Inl (Suc 0, Suc D)))", "define f where \"f = find_fund_sol_step D\""], ["proof (state)\nthis:\n  f = find_fund_sol_step D\n\ngoal (1 subgoal):\n 1. fund_sol = projr (while isl (find_fund_sol_step D) (Inl (Suc 0, Suc D)))", "define P :: \"nat \\<Rightarrow> bool\" where \"P = (\\<lambda>y. y > 0 \\<and> is_square (y^2 * D + 1))\""], ["proof (state)\nthis:\n  P = (\\<lambda>y. 0 < y \\<and> is_square (y\\<^sup>2 * D + 1))\n\ngoal (1 subgoal):\n 1. fund_sol = projr (while isl (find_fund_sol_step D) (Inl (Suc 0, Suc D)))", "define Q :: \"nat \\<times> nat \\<Rightarrow> bool\" where\n    \"Q = (\\<lambda>(x,y). P y \\<and> (\\<forall>y'\\<in>{0<..<y}. \\<not>P y') \\<and> x = Discrete.sqrt (y^2 * D + 1))\""], ["proof (state)\nthis:\n  Q =\n  (\\<lambda>(x, y).\n      P y \\<and>\n      (\\<forall>y'\\<in>{0<..<y}. \\<not> P y') \\<and>\n      x = Discrete.sqrt (y\\<^sup>2 * D + 1))\n\ngoal (1 subgoal):\n 1. fund_sol = projr (while isl (find_fund_sol_step D) (Inl (Suc 0, Suc D)))", "define R :: \"nat \\<times> nat + nat \\<times> nat \\<Rightarrow> bool\" \n    where \"R = (\\<lambda>s. case s of\n                      Inl (m, m') \\<Rightarrow> m > 0 \\<and> (m' = m^2 * D + 1) \\<and> (\\<forall>y\\<in>{0<..<m}. \\<not>is_square (y^2 * D + 1))\n                    | Inr x \\<Rightarrow> Q x)\""], ["proof (state)\nthis:\n  R =\n  (\\<lambda>s.\n      case s of\n      Inl (m, m') \\<Rightarrow>\n        0 < m \\<and>\n        m' = m\\<^sup>2 * D + 1 \\<and>\n        (\\<forall>y\\<in>{0<..<m}. \\<not> is_square (y\\<^sup>2 * D + 1))\n      | Inr x \\<Rightarrow> Q x)\n\ngoal (1 subgoal):\n 1. fund_sol = projr (while isl (find_fund_sol_step D) (Inl (Suc 0, Suc D)))", "define rel :: \"((nat \\<times> nat + nat \\<times> nat) \\<times> (nat \\<times> nat + nat \\<times> nat)) set\"\n    where \"rel = {(A,B). (case (A, B) of\n                           (Inl (m, _), Inl (m', _)) \\<Rightarrow> m' > 0 \\<and> m > m' \\<and> m \\<le> snd fund_sol\n                         | (Inr _, Inl (m', _)) \\<Rightarrow> m' \\<le> snd fund_sol\n                         | _ \\<Rightarrow> False) \\<and> A = f B}\""], ["proof (state)\nthis:\n  rel =\n  {(A, B).\n   (case (A, B) of\n    (Inl (m, x), Inl (m', xa)) \\<Rightarrow>\n      0 < m' \\<and> m' < m \\<and> m \\<le> snd fund_sol\n    | (Inl (m, x), Inr ba) \\<Rightarrow> False\n    | (Inr x, Inl (m', xa)) \\<Rightarrow> m' \\<le> snd fund_sol\n    | (Inr x, Inr ba) \\<Rightarrow> False) \\<and>\n   A = f B}\n\ngoal (1 subgoal):\n 1. fund_sol = projr (while isl (find_fund_sol_step D) (Inl (Suc 0, Suc D)))", "obtain x y where xy: \"sum.projr (while isl f (Inl (Suc 0, Suc D))) = (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        projr (while isl f (Inl (Suc 0, Suc D))) = (x, y) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"sum.projr (while isl f (Inl (Suc 0, Suc D)))\")"], ["proof (state)\nthis:\n  projr (while isl f (Inl (Suc 0, Suc D))) = (x, y)\n\ngoal (1 subgoal):\n 1. fund_sol = projr (while isl (find_fund_sol_step D) (Inl (Suc 0, Suc D)))", "have neq_fund_solI: \"y \\<noteq> snd fund_sol\" if \"\\<not> is_square (Suc (y\\<^sup>2 * D))\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<noteq> snd fund_sol", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. y = snd fund_sol \\<Longrightarrow> False", "assume \"y = snd fund_sol\""], ["proof (state)\nthis:\n  y = snd fund_sol\n\ngoal (1 subgoal):\n 1. y = snd fund_sol \\<Longrightarrow> False", "with fund_sol_is_nontriv_solution"], ["proof (chain)\npicking this:\n  nontriv_solution fund_sol\n  y = snd fund_sol", "have \"Suc (y\\<^sup>2 * D) = fst fund_sol ^ 2\""], ["proof (prove)\nusing this:\n  nontriv_solution fund_sol\n  y = snd fund_sol\n\ngoal (1 subgoal):\n 1. Suc (y\\<^sup>2 * D) = (fst fund_sol)\\<^sup>2", "by (simp add: nontriv_solution_def case_prod_unfold)"], ["proof (state)\nthis:\n  Suc (y\\<^sup>2 * D) = (fst fund_sol)\\<^sup>2\n\ngoal (1 subgoal):\n 1. y = snd fund_sol \\<Longrightarrow> False", "hence \"is_square (Suc (y\\<^sup>2 * D))\""], ["proof (prove)\nusing this:\n  Suc (y\\<^sup>2 * D) = (fst fund_sol)\\<^sup>2\n\ngoal (1 subgoal):\n 1. is_square (Suc (y\\<^sup>2 * D))", "by simp"], ["proof (state)\nthis:\n  is_square (Suc (y\\<^sup>2 * D))\n\ngoal (1 subgoal):\n 1. y = snd fund_sol \\<Longrightarrow> False", "with that"], ["proof (chain)\npicking this:\n  \\<not> is_square (Suc (y\\<^sup>2 * D))\n  is_square (Suc (y\\<^sup>2 * D))", "show False"], ["proof (prove)\nusing this:\n  \\<not> is_square (Suc (y\\<^sup>2 * D))\n  is_square (Suc (y\\<^sup>2 * D))\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_square (Suc (?y1\\<^sup>2 * D)) \\<Longrightarrow>\n  ?y1 \\<noteq> snd fund_sol\n\ngoal (1 subgoal):\n 1. fund_sol = projr (while isl (find_fund_sol_step D) (Inl (Suc 0, Suc D)))", "have \"case_sum (\\<lambda>_. False) Q (while sum.isl f (Inl (m, m^2 * D + 1)))\"\n    if \"\\<forall>y\\<in>{0<..<m}. \\<not>is_square (y^2 * D + 1)\" \"m > 0\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. case while isl f (Inl (m, m\\<^sup>2 * D + 1)) of\n    Inl uu_ \\<Rightarrow> False | Inr x \\<Rightarrow> Q x", "proof (rule while_rule[where b = sum.isl])"], ["proof (state)\ngoal (5 subgoals):\n 1. ?P (Inl (m, m\\<^sup>2 * D + 1))\n 2. \\<And>s. \\<lbrakk>?P s; isl s\\<rbrakk> \\<Longrightarrow> ?P (f s)\n 3. \\<And>s.\n       \\<lbrakk>?P s; \\<not> isl s\\<rbrakk>\n       \\<Longrightarrow> case s of Inl uu_ \\<Rightarrow> False\n                         | Inr a \\<Rightarrow> Q a\n 4. wf ?r\n 5. \\<And>s.\n       \\<lbrakk>?P s; isl s\\<rbrakk> \\<Longrightarrow> (f s, s) \\<in> ?r", "show \"R (Inl (m, m\\<^sup>2 * D + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R (Inl (m, m\\<^sup>2 * D + 1))", "using that"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>{0<..<m}. \\<not> is_square (y\\<^sup>2 * D + 1)\n  0 < m\n\ngoal (1 subgoal):\n 1. R (Inl (m, m\\<^sup>2 * D + 1))", "by (auto simp: R_def)"], ["proof (state)\nthis:\n  R (Inl (m, m\\<^sup>2 * D + 1))\n\ngoal (4 subgoals):\n 1. \\<And>s. \\<lbrakk>R s; isl s\\<rbrakk> \\<Longrightarrow> R (f s)\n 2. \\<And>s.\n       \\<lbrakk>R s; \\<not> isl s\\<rbrakk>\n       \\<Longrightarrow> case s of Inl uu_ \\<Rightarrow> False\n                         | Inr a \\<Rightarrow> Q a\n 3. wf ?r\n 4. \\<And>s.\n       \\<lbrakk>R s; isl s\\<rbrakk> \\<Longrightarrow> (f s, s) \\<in> ?r", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s. \\<lbrakk>R s; isl s\\<rbrakk> \\<Longrightarrow> R (f s)\n 2. \\<And>s.\n       \\<lbrakk>R s; \\<not> isl s\\<rbrakk>\n       \\<Longrightarrow> case s of Inl uu_ \\<Rightarrow> False\n                         | Inr a \\<Rightarrow> Q a\n 3. wf ?r\n 4. \\<And>s.\n       \\<lbrakk>R s; isl s\\<rbrakk> \\<Longrightarrow> (f s, s) \\<in> ?r", "fix s"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>s. \\<lbrakk>R s; isl s\\<rbrakk> \\<Longrightarrow> R (f s)\n 2. \\<And>s.\n       \\<lbrakk>R s; \\<not> isl s\\<rbrakk>\n       \\<Longrightarrow> case s of Inl uu_ \\<Rightarrow> False\n                         | Inr a \\<Rightarrow> Q a\n 3. wf ?r\n 4. \\<And>s.\n       \\<lbrakk>R s; isl s\\<rbrakk> \\<Longrightarrow> (f s, s) \\<in> ?r", "assume \"R s\" \"isl s\""], ["proof (state)\nthis:\n  R s\n  isl s\n\ngoal (4 subgoals):\n 1. \\<And>s. \\<lbrakk>R s; isl s\\<rbrakk> \\<Longrightarrow> R (f s)\n 2. \\<And>s.\n       \\<lbrakk>R s; \\<not> isl s\\<rbrakk>\n       \\<Longrightarrow> case s of Inl uu_ \\<Rightarrow> False\n                         | Inr a \\<Rightarrow> Q a\n 3. wf ?r\n 4. \\<And>s.\n       \\<lbrakk>R s; isl s\\<rbrakk> \\<Longrightarrow> (f s, s) \\<in> ?r", "thus \"R (f s)\""], ["proof (prove)\nusing this:\n  R s\n  isl s\n\ngoal (1 subgoal):\n 1. R (f s)", "by (auto simp: not_less_less_Suc_eq Q_def P_def R_def f_def get_nat_sqrt_def\n                     power2_eq_square algebra_simps split: sum.splits prod.splits)"], ["proof (state)\nthis:\n  R (f s)\n\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>R s; \\<not> isl s\\<rbrakk>\n       \\<Longrightarrow> case s of Inl uu_ \\<Rightarrow> False\n                         | Inr a \\<Rightarrow> Q a\n 2. wf ?r\n 3. \\<And>s.\n       \\<lbrakk>R s; isl s\\<rbrakk> \\<Longrightarrow> (f s, s) \\<in> ?r", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>R s; \\<not> isl s\\<rbrakk>\n       \\<Longrightarrow> case s of Inl uu_ \\<Rightarrow> False\n                         | Inr a \\<Rightarrow> Q a\n 2. wf ?r\n 3. \\<And>s.\n       \\<lbrakk>R s; isl s\\<rbrakk> \\<Longrightarrow> (f s, s) \\<in> ?r", "fix s"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>R s; \\<not> isl s\\<rbrakk>\n       \\<Longrightarrow> case s of Inl uu_ \\<Rightarrow> False\n                         | Inr a \\<Rightarrow> Q a\n 2. wf ?r\n 3. \\<And>s.\n       \\<lbrakk>R s; isl s\\<rbrakk> \\<Longrightarrow> (f s, s) \\<in> ?r", "assume \"R s\" \"\\<not>isl s\""], ["proof (state)\nthis:\n  R s\n  \\<not> isl s\n\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>R s; \\<not> isl s\\<rbrakk>\n       \\<Longrightarrow> case s of Inl uu_ \\<Rightarrow> False\n                         | Inr a \\<Rightarrow> Q a\n 2. wf ?r\n 3. \\<And>s.\n       \\<lbrakk>R s; isl s\\<rbrakk> \\<Longrightarrow> (f s, s) \\<in> ?r", "thus \"case s of Inl _ \\<Rightarrow> False | Inr x \\<Rightarrow> Q x\""], ["proof (prove)\nusing this:\n  R s\n  \\<not> isl s\n\ngoal (1 subgoal):\n 1. case s of Inl x \\<Rightarrow> False | Inr x \\<Rightarrow> Q x", "by (auto simp: R_def split: sum.splits)"], ["proof (state)\nthis:\n  case s of Inl x \\<Rightarrow> False | Inr x \\<Rightarrow> Q x\n\ngoal (2 subgoals):\n 1. wf ?r\n 2. \\<And>s.\n       \\<lbrakk>R s; isl s\\<rbrakk> \\<Longrightarrow> (f s, s) \\<in> ?r", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. wf ?r\n 2. \\<And>s.\n       \\<lbrakk>R s; isl s\\<rbrakk> \\<Longrightarrow> (f s, s) \\<in> ?r", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. wf ?r\n 2. \\<And>s.\n       \\<lbrakk>R s; isl s\\<rbrakk> \\<Longrightarrow> (f s, s) \\<in> ?r", "assume s: \"R s\" \"isl s\""], ["proof (state)\nthis:\n  R s\n  isl s\n\ngoal (2 subgoals):\n 1. wf ?r\n 2. \\<And>s.\n       \\<lbrakk>R s; isl s\\<rbrakk> \\<Longrightarrow> (f s, s) \\<in> ?r", "show \"(f s, s) \\<in> rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f s, s) \\<in> rel", "proof (cases s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. s = Inl a \\<Longrightarrow> (f s, s) \\<in> rel\n 2. \\<And>b. s = Inr b \\<Longrightarrow> (f s, s) \\<in> rel", "case [simp]: (Inl s')"], ["proof (state)\nthis:\n  s = Inl s'\n\ngoal (2 subgoals):\n 1. \\<And>a. s = Inl a \\<Longrightarrow> (f s, s) \\<in> rel\n 2. \\<And>b. s = Inr b \\<Longrightarrow> (f s, s) \\<in> rel", "obtain a b where [simp]: \"s' = (a, b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b. s' = (a, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases s')"], ["proof (state)\nthis:\n  s' = (a, b)\n\ngoal (2 subgoals):\n 1. \\<And>a. s = Inl a \\<Longrightarrow> (f s, s) \\<in> rel\n 2. \\<And>b. s = Inr b \\<Longrightarrow> (f s, s) \\<in> rel", "from s"], ["proof (chain)\npicking this:\n  R s\n  isl s", "have *: \"a > 0\" \"b = Suc (a\\<^sup>2 * D)\" \"\\<And>y. y \\<in> {0<..<a} \\<Longrightarrow> \\<not> is_square (Suc (y\\<^sup>2 * D))\""], ["proof (prove)\nusing this:\n  R s\n  isl s\n\ngoal (1 subgoal):\n 1. 0 < a &&&\n    b = Suc (a\\<^sup>2 * D) &&&\n    (\\<And>y.\n        y \\<in> {0<..<a} \\<Longrightarrow>\n        \\<not> is_square (Suc (y\\<^sup>2 * D)))", "by (auto simp: R_def)"], ["proof (state)\nthis:\n  0 < a\n  b = Suc (a\\<^sup>2 * D)\n  ?y1 \\<in> {0<..<a} \\<Longrightarrow>\n  \\<not> is_square (Suc (?y1\\<^sup>2 * D))\n\ngoal (2 subgoals):\n 1. \\<And>a. s = Inl a \\<Longrightarrow> (f s, s) \\<in> rel\n 2. \\<And>b. s = Inr b \\<Longrightarrow> (f s, s) \\<in> rel", "have \"a < snd fund_sol\" if **: \"\\<not> is_square (Suc (a\\<^sup>2 * D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < snd fund_sol", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a < snd fund_sol", "from neq_fund_solI"], ["proof (chain)\npicking this:\n  \\<not> is_square (Suc (?y1\\<^sup>2 * D)) \\<Longrightarrow>\n  ?y1 \\<noteq> snd fund_sol", "have \"y' \\<noteq> snd fund_sol\" if \"y' \\<in> {0<..<Suc a}\" for y'"], ["proof (prove)\nusing this:\n  \\<not> is_square (Suc (?y1\\<^sup>2 * D)) \\<Longrightarrow>\n  ?y1 \\<noteq> snd fund_sol\n\ngoal (1 subgoal):\n 1. y' \\<noteq> snd fund_sol", "using * ** that"], ["proof (prove)\nusing this:\n  \\<not> is_square (Suc (?y1\\<^sup>2 * D)) \\<Longrightarrow>\n  ?y1 \\<noteq> snd fund_sol\n  0 < a\n  b = Suc (a\\<^sup>2 * D)\n  ?y1 \\<in> {0<..<a} \\<Longrightarrow>\n  \\<not> is_square (Suc (?y1\\<^sup>2 * D))\n  \\<not> is_square (Suc (a\\<^sup>2 * D))\n  y' \\<in> {0<..<Suc a}\n\ngoal (1 subgoal):\n 1. y' \\<noteq> snd fund_sol", "by (cases \"y' = a\") auto"], ["proof (state)\nthis:\n  ?y'1 \\<in> {0<..<Suc a} \\<Longrightarrow> ?y'1 \\<noteq> snd fund_sol\n\ngoal (1 subgoal):\n 1. a < snd fund_sol", "moreover"], ["proof (state)\nthis:\n  ?y'1 \\<in> {0<..<Suc a} \\<Longrightarrow> ?y'1 \\<noteq> snd fund_sol\n\ngoal (1 subgoal):\n 1. a < snd fund_sol", "have \"snd fund_sol \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd fund_sol \\<noteq> 0", "using fund_sol_is_nontriv_solution"], ["proof (prove)\nusing this:\n  nontriv_solution fund_sol\n\ngoal (1 subgoal):\n 1. snd fund_sol \\<noteq> 0", "by (intro notI, cases fund_sol) (auto simp: nontriv_solution_altdef)"], ["proof (state)\nthis:\n  snd fund_sol \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a < snd fund_sol", "ultimately"], ["proof (chain)\npicking this:\n  ?y'1 \\<in> {0<..<Suc a} \\<Longrightarrow> ?y'1 \\<noteq> snd fund_sol\n  snd fund_sol \\<noteq> 0", "have \"\\<forall>y'\\<le>a. y' \\<noteq> snd fund_sol\""], ["proof (prove)\nusing this:\n  ?y'1 \\<in> {0<..<Suc a} \\<Longrightarrow> ?y'1 \\<noteq> snd fund_sol\n  snd fund_sol \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>y'\\<le>a. y' \\<noteq> snd fund_sol", "by (auto simp: less_Suc_eq_le)"], ["proof (state)\nthis:\n  \\<forall>y'\\<le>a. y' \\<noteq> snd fund_sol\n\ngoal (1 subgoal):\n 1. a < snd fund_sol", "thus \"snd fund_sol > a\""], ["proof (prove)\nusing this:\n  \\<forall>y'\\<le>a. y' \\<noteq> snd fund_sol\n\ngoal (1 subgoal):\n 1. a < snd fund_sol", "by (cases \"a < snd fund_sol\") (auto simp: not_less)"], ["proof (state)\nthis:\n  a < snd fund_sol\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_square (Suc (a\\<^sup>2 * D)) \\<Longrightarrow> a < snd fund_sol\n\ngoal (2 subgoals):\n 1. \\<And>a. s = Inl a \\<Longrightarrow> (f s, s) \\<in> rel\n 2. \\<And>b. s = Inr b \\<Longrightarrow> (f s, s) \\<in> rel", "moreover"], ["proof (state)\nthis:\n  \\<not> is_square (Suc (a\\<^sup>2 * D)) \\<Longrightarrow> a < snd fund_sol\n\ngoal (2 subgoals):\n 1. \\<And>a. s = Inl a \\<Longrightarrow> (f s, s) \\<in> rel\n 2. \\<And>b. s = Inr b \\<Longrightarrow> (f s, s) \\<in> rel", "have \"a \\<le> snd fund_sol\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> snd fund_sol", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<le> snd fund_sol", "have \"\\<forall>y'\\<in>{0<..<a}. y' \\<noteq> snd fund_sol\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y'\\<in>{0<..<a}. y' \\<noteq> snd fund_sol", "using neq_fund_solI *"], ["proof (prove)\nusing this:\n  \\<not> is_square (Suc (?y1\\<^sup>2 * D)) \\<Longrightarrow>\n  ?y1 \\<noteq> snd fund_sol\n  0 < a\n  b = Suc (a\\<^sup>2 * D)\n  ?y1 \\<in> {0<..<a} \\<Longrightarrow>\n  \\<not> is_square (Suc (?y1\\<^sup>2 * D))\n\ngoal (1 subgoal):\n 1. \\<forall>y'\\<in>{0<..<a}. y' \\<noteq> snd fund_sol", "by (auto simp: less_Suc_eq_le)"], ["proof (state)\nthis:\n  \\<forall>y'\\<in>{0<..<a}. y' \\<noteq> snd fund_sol\n\ngoal (1 subgoal):\n 1. a \\<le> snd fund_sol", "moreover"], ["proof (state)\nthis:\n  \\<forall>y'\\<in>{0<..<a}. y' \\<noteq> snd fund_sol\n\ngoal (1 subgoal):\n 1. a \\<le> snd fund_sol", "have \"snd fund_sol \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd fund_sol \\<noteq> 0", "using fund_sol_is_nontriv_solution"], ["proof (prove)\nusing this:\n  nontriv_solution fund_sol\n\ngoal (1 subgoal):\n 1. snd fund_sol \\<noteq> 0", "by (intro notI, cases fund_sol) (auto simp: nontriv_solution_altdef)"], ["proof (state)\nthis:\n  snd fund_sol \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a \\<le> snd fund_sol", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>y'\\<in>{0<..<a}. y' \\<noteq> snd fund_sol\n  snd fund_sol \\<noteq> 0", "have \"\\<forall>y'<a. y' \\<noteq> snd fund_sol\""], ["proof (prove)\nusing this:\n  \\<forall>y'\\<in>{0<..<a}. y' \\<noteq> snd fund_sol\n  snd fund_sol \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>y'<a. y' \\<noteq> snd fund_sol", "by (auto simp: less_Suc_eq_le)"], ["proof (state)\nthis:\n  \\<forall>y'<a. y' \\<noteq> snd fund_sol\n\ngoal (1 subgoal):\n 1. a \\<le> snd fund_sol", "thus \"snd fund_sol \\<ge> a\""], ["proof (prove)\nusing this:\n  \\<forall>y'<a. y' \\<noteq> snd fund_sol\n\ngoal (1 subgoal):\n 1. a \\<le> snd fund_sol", "by (cases \"a \\<le> snd fund_sol\") (auto simp: not_less)"], ["proof (state)\nthis:\n  a \\<le> snd fund_sol\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a \\<le> snd fund_sol\n\ngoal (2 subgoals):\n 1. \\<And>a. s = Inl a \\<Longrightarrow> (f s, s) \\<in> rel\n 2. \\<And>b. s = Inr b \\<Longrightarrow> (f s, s) \\<in> rel", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> is_square (Suc (a\\<^sup>2 * D)) \\<Longrightarrow> a < snd fund_sol\n  a \\<le> snd fund_sol", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_square (Suc (a\\<^sup>2 * D)) \\<Longrightarrow> a < snd fund_sol\n  a \\<le> snd fund_sol\n\ngoal (1 subgoal):\n 1. (f s, s) \\<in> rel", "using *"], ["proof (prove)\nusing this:\n  \\<not> is_square (Suc (a\\<^sup>2 * D)) \\<Longrightarrow> a < snd fund_sol\n  a \\<le> snd fund_sol\n  0 < a\n  b = Suc (a\\<^sup>2 * D)\n  ?y1 \\<in> {0<..<a} \\<Longrightarrow>\n  \\<not> is_square (Suc (?y1\\<^sup>2 * D))\n\ngoal (1 subgoal):\n 1. (f s, s) \\<in> rel", "by (auto simp: f_def get_nat_sqrt_def rel_def)"], ["proof (state)\nthis:\n  (f s, s) \\<in> rel\n\ngoal (1 subgoal):\n 1. \\<And>b. s = Inr b \\<Longrightarrow> (f s, s) \\<in> rel", "qed (insert s, auto)"], ["proof (state)\nthis:\n  (f s, s) \\<in> rel\n\ngoal (1 subgoal):\n 1. wf rel", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. wf rel", "define rel'\n      where \"rel' = {(y, x). (case x of Inl (m, _) \\<Rightarrow> m \\<le> snd fund_sol | Inr _ \\<Rightarrow> False) \\<and> y = f x}\""], ["proof (state)\nthis:\n  rel' =\n  {(y, x).\n   (case x of Inl (m, x) \\<Rightarrow> m \\<le> snd fund_sol\n    | Inr x \\<Rightarrow> False) \\<and>\n   y = f x}\n\ngoal (1 subgoal):\n 1. wf rel", "have \"wf rel'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf rel'", "unfolding rel'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(y, x).\n        (case x of Inl (m, xa) \\<Rightarrow> m \\<le> snd fund_sol\n         | Inr x \\<Rightarrow> False) \\<and>\n        y = f x}", "by (rule wf_if_measure[where f = \"\\<lambda>z. case z of Inl (m, _) \\<Rightarrow> Suc (snd fund_sol) - m | _ \\<Rightarrow> 0\"])\n         (auto split: prod.splits sum.splits simp: f_def get_nat_sqrt_def)"], ["proof (state)\nthis:\n  wf rel'\n\ngoal (1 subgoal):\n 1. wf rel", "moreover"], ["proof (state)\nthis:\n  wf rel'\n\ngoal (1 subgoal):\n 1. wf rel", "have \"rel \\<subseteq> rel'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel \\<subseteq> rel'", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> rel \\<Longrightarrow> (a, b) \\<in> rel'", "fix w z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> rel \\<Longrightarrow> (a, b) \\<in> rel'", "assume \"(w, z) \\<in> rel\""], ["proof (state)\nthis:\n  (w, z) \\<in> rel\n\ngoal (1 subgoal):\n 1. \\<And>a b. (a, b) \\<in> rel \\<Longrightarrow> (a, b) \\<in> rel'", "thus \"(w, z) \\<in> rel'\""], ["proof (prove)\nusing this:\n  (w, z) \\<in> rel\n\ngoal (1 subgoal):\n 1. (w, z) \\<in> rel'", "by (cases w; cases z) (auto simp: rel_def rel'_def)"], ["proof (state)\nthis:\n  (w, z) \\<in> rel'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel \\<subseteq> rel'\n\ngoal (1 subgoal):\n 1. wf rel", "ultimately"], ["proof (chain)\npicking this:\n  wf rel'\n  rel \\<subseteq> rel'", "show \"wf rel\""], ["proof (prove)\nusing this:\n  wf rel'\n  rel \\<subseteq> rel'\n\ngoal (1 subgoal):\n 1. wf rel", "by (rule wf_subset)"], ["proof (state)\nthis:\n  wf rel\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>y\\<in>{0<..<?m1}. \\<not> is_square (y\\<^sup>2 * D + 1);\n   0 < ?m1\\<rbrakk>\n  \\<Longrightarrow> case while isl f (Inl (?m1, ?m1\\<^sup>2 * D + 1)) of\n                    Inl uu_ \\<Rightarrow> False | Inr x \\<Rightarrow> Q x\n\ngoal (1 subgoal):\n 1. fund_sol = projr (while isl (find_fund_sol_step D) (Inl (Suc 0, Suc D)))", "from this[of 1] and xy"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>y\\<in>{0<..<1}. \\<not> is_square (y\\<^sup>2 * D + 1);\n   0 < 1\\<rbrakk>\n  \\<Longrightarrow> case while isl f (Inl (1, 1\\<^sup>2 * D + 1)) of\n                    Inl uu_ \\<Rightarrow> False | Inr x \\<Rightarrow> Q x\n  projr (while isl f (Inl (Suc 0, Suc D))) = (x, y)", "have *: \"Q (x, y)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>y\\<in>{0<..<1}. \\<not> is_square (y\\<^sup>2 * D + 1);\n   0 < 1\\<rbrakk>\n  \\<Longrightarrow> case while isl f (Inl (1, 1\\<^sup>2 * D + 1)) of\n                    Inl uu_ \\<Rightarrow> False | Inr x \\<Rightarrow> Q x\n  projr (while isl f (Inl (Suc 0, Suc D))) = (x, y)\n\ngoal (1 subgoal):\n 1. Q (x, y)", "by (auto split: sum.splits)"], ["proof (state)\nthis:\n  Q (x, y)\n\ngoal (1 subgoal):\n 1. fund_sol = projr (while isl (find_fund_sol_step D) (Inl (Suc 0, Suc D)))", "from *"], ["proof (chain)\npicking this:\n  Q (x, y)", "have \"is_square (Suc (y\\<^sup>2 * D))\""], ["proof (prove)\nusing this:\n  Q (x, y)\n\ngoal (1 subgoal):\n 1. is_square (Suc (y\\<^sup>2 * D))", "by (simp add: Q_def P_def)"], ["proof (state)\nthis:\n  is_square (Suc (y\\<^sup>2 * D))\n\ngoal (1 subgoal):\n 1. fund_sol = projr (while isl (find_fund_sol_step D) (Inl (Suc 0, Suc D)))", "with *"], ["proof (chain)\npicking this:\n  Q (x, y)\n  is_square (Suc (y\\<^sup>2 * D))", "have \"x\\<^sup>2 = Suc (y\\<^sup>2 * D)\" \"y > 0\""], ["proof (prove)\nusing this:\n  Q (x, y)\n  is_square (Suc (y\\<^sup>2 * D))\n\ngoal (1 subgoal):\n 1. x\\<^sup>2 = Suc (y\\<^sup>2 * D) &&& 0 < y", "by (auto simp: Q_def P_def Discrete_sqrt_square_is_square)"], ["proof (state)\nthis:\n  x\\<^sup>2 = Suc (y\\<^sup>2 * D)\n  0 < y\n\ngoal (1 subgoal):\n 1. fund_sol = projr (while isl (find_fund_sol_step D) (Inl (Suc 0, Suc D)))", "hence \"nontriv_solution (x, y)\""], ["proof (prove)\nusing this:\n  x\\<^sup>2 = Suc (y\\<^sup>2 * D)\n  0 < y\n\ngoal (1 subgoal):\n 1. nontriv_solution (x, y)", "by (auto simp: nontriv_solution_def)"], ["proof (state)\nthis:\n  nontriv_solution (x, y)\n\ngoal (1 subgoal):\n 1. fund_sol = projr (while isl (find_fund_sol_step D) (Inl (Suc 0, Suc D)))", "from this"], ["proof (chain)\npicking this:\n  nontriv_solution (x, y)", "have \"snd fund_sol \\<le> snd (x, y)\""], ["proof (prove)\nusing this:\n  nontriv_solution (x, y)\n\ngoal (1 subgoal):\n 1. snd fund_sol \\<le> snd (x, y)", "by (rule fund_sol_minimal'')"], ["proof (state)\nthis:\n  snd fund_sol \\<le> snd (x, y)\n\ngoal (1 subgoal):\n 1. fund_sol = projr (while isl (find_fund_sol_step D) (Inl (Suc 0, Suc D)))", "moreover"], ["proof (state)\nthis:\n  snd fund_sol \\<le> snd (x, y)\n\ngoal (1 subgoal):\n 1. fund_sol = projr (while isl (find_fund_sol_step D) (Inl (Suc 0, Suc D)))", "have \"snd fund_sol \\<ge> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> snd fund_sol", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<le> snd fund_sol", "from *"], ["proof (chain)\npicking this:\n  Q (x, y)", "have \"(\\<forall>y'\\<in>{0<..<y}. \\<not> is_square (Suc (y'\\<^sup>2 * D)))\""], ["proof (prove)\nusing this:\n  Q (x, y)\n\ngoal (1 subgoal):\n 1. \\<forall>y'\\<in>{0<..<y}. \\<not> is_square (Suc (y'\\<^sup>2 * D))", "by (simp add: Q_def P_def)"], ["proof (state)\nthis:\n  \\<forall>y'\\<in>{0<..<y}. \\<not> is_square (Suc (y'\\<^sup>2 * D))\n\ngoal (1 subgoal):\n 1. y \\<le> snd fund_sol", "with neq_fund_solI"], ["proof (chain)\npicking this:\n  \\<not> is_square (Suc (?y1\\<^sup>2 * D)) \\<Longrightarrow>\n  ?y1 \\<noteq> snd fund_sol\n  \\<forall>y'\\<in>{0<..<y}. \\<not> is_square (Suc (y'\\<^sup>2 * D))", "have \"(\\<forall>y'\\<in>{0<..<y}. y' \\<noteq> snd fund_sol)\""], ["proof (prove)\nusing this:\n  \\<not> is_square (Suc (?y1\\<^sup>2 * D)) \\<Longrightarrow>\n  ?y1 \\<noteq> snd fund_sol\n  \\<forall>y'\\<in>{0<..<y}. \\<not> is_square (Suc (y'\\<^sup>2 * D))\n\ngoal (1 subgoal):\n 1. \\<forall>y'\\<in>{0<..<y}. y' \\<noteq> snd fund_sol", "by auto"], ["proof (state)\nthis:\n  \\<forall>y'\\<in>{0<..<y}. y' \\<noteq> snd fund_sol\n\ngoal (1 subgoal):\n 1. y \\<le> snd fund_sol", "moreover"], ["proof (state)\nthis:\n  \\<forall>y'\\<in>{0<..<y}. y' \\<noteq> snd fund_sol\n\ngoal (1 subgoal):\n 1. y \\<le> snd fund_sol", "have \"snd fund_sol \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd fund_sol \\<noteq> 0", "using fund_sol_is_nontriv_solution"], ["proof (prove)\nusing this:\n  nontriv_solution fund_sol\n\ngoal (1 subgoal):\n 1. snd fund_sol \\<noteq> 0", "by (cases fund_sol) (auto intro!: Nat.gr0I simp: nontriv_solution_altdef)"], ["proof (state)\nthis:\n  snd fund_sol \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y \\<le> snd fund_sol", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>y'\\<in>{0<..<y}. y' \\<noteq> snd fund_sol\n  snd fund_sol \\<noteq> 0", "have \"(\\<forall>y'<y. y' \\<noteq> snd fund_sol)\""], ["proof (prove)\nusing this:\n  \\<forall>y'\\<in>{0<..<y}. y' \\<noteq> snd fund_sol\n  snd fund_sol \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>y'<y. y' \\<noteq> snd fund_sol", "by auto"], ["proof (state)\nthis:\n  \\<forall>y'<y. y' \\<noteq> snd fund_sol\n\ngoal (1 subgoal):\n 1. y \\<le> snd fund_sol", "thus \"snd fund_sol \\<ge> y\""], ["proof (prove)\nusing this:\n  \\<forall>y'<y. y' \\<noteq> snd fund_sol\n\ngoal (1 subgoal):\n 1. y \\<le> snd fund_sol", "by (cases \"snd fund_sol \\<ge> y\") (auto simp: not_less)"], ["proof (state)\nthis:\n  y \\<le> snd fund_sol\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<le> snd fund_sol\n\ngoal (1 subgoal):\n 1. fund_sol = projr (while isl (find_fund_sol_step D) (Inl (Suc 0, Suc D)))", "ultimately"], ["proof (chain)\npicking this:\n  snd fund_sol \\<le> snd (x, y)\n  y \\<le> snd fund_sol", "have \"snd fund_sol = y\""], ["proof (prove)\nusing this:\n  snd fund_sol \\<le> snd (x, y)\n  y \\<le> snd fund_sol\n\ngoal (1 subgoal):\n 1. snd fund_sol = y", "by simp"], ["proof (state)\nthis:\n  snd fund_sol = y\n\ngoal (1 subgoal):\n 1. fund_sol = projr (while isl (find_fund_sol_step D) (Inl (Suc 0, Suc D)))", "with solutions_linorder_strict[of x y \"fst fund_sol\" \"snd fund_sol\"]\n       fund_sol_is_nontriv_solution \\<open>nontriv_solution (x, y)\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>solution (x, y); solution (fst fund_sol, snd fund_sol)\\<rbrakk>\n  \\<Longrightarrow> (x, y) = (fst fund_sol, snd fund_sol) \\<or>\n                    x < fst fund_sol \\<and> y < snd fund_sol \\<or>\n                    fst fund_sol < x \\<and> snd fund_sol < y\n  nontriv_solution fund_sol\n  nontriv_solution (x, y)\n  snd fund_sol = y", "have \"fst fund_sol = x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>solution (x, y); solution (fst fund_sol, snd fund_sol)\\<rbrakk>\n  \\<Longrightarrow> (x, y) = (fst fund_sol, snd fund_sol) \\<or>\n                    x < fst fund_sol \\<and> y < snd fund_sol \\<or>\n                    fst fund_sol < x \\<and> snd fund_sol < y\n  nontriv_solution fund_sol\n  nontriv_solution (x, y)\n  snd fund_sol = y\n\ngoal (1 subgoal):\n 1. fst fund_sol = x", "by (cases fund_sol) (auto simp: nontriv_solution_altdef)"], ["proof (state)\nthis:\n  fst fund_sol = x\n\ngoal (1 subgoal):\n 1. fund_sol = projr (while isl (find_fund_sol_step D) (Inl (Suc 0, Suc D)))", "with \\<open>snd fund_sol = y\\<close>"], ["proof (chain)\npicking this:\n  snd fund_sol = y\n  fst fund_sol = x", "have \"fund_sol = (x, y)\""], ["proof (prove)\nusing this:\n  snd fund_sol = y\n  fst fund_sol = x\n\ngoal (1 subgoal):\n 1. fund_sol = (x, y)", "by (cases fund_sol) simp"], ["proof (state)\nthis:\n  fund_sol = (x, y)\n\ngoal (1 subgoal):\n 1. fund_sol = projr (while isl (find_fund_sol_step D) (Inl (Suc 0, Suc D)))", "with xy"], ["proof (chain)\npicking this:\n  projr (while isl f (Inl (Suc 0, Suc D))) = (x, y)\n  fund_sol = (x, y)", "show ?thesis"], ["proof (prove)\nusing this:\n  projr (while isl f (Inl (Suc 0, Suc D))) = (x, y)\n  fund_sol = (x, y)\n\ngoal (1 subgoal):\n 1. fund_sol = projr (while isl (find_fund_sol_step D) (Inl (Suc 0, Suc D)))", "by (simp add: f_def)"], ["proof (state)\nthis:\n  fund_sol = projr (while isl (find_fund_sol_step D) (Inl (Suc 0, Suc D)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_fund_sol_correct: \"find_fund_sol D = (if is_square D then (0, 0) else pell.fund_sol D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_fund_sol D = (if is_square D then (0, 0) else pell.fund_sol D)", "by (simp add: find_fund_sol_def fund_sol_code square_test_correct)"], ["", "subsubsection \\<open>The infinite list of all solutions\\<close>"], ["", "definition pell_solutions :: \"nat \\<Rightarrow> (nat \\<times> nat) stream\" where\n  \"pell_solutions D = (let z = find_fund_sol D in siterate (pell_mul_nat D z) (1, 0))\""], ["", "lemma (in pell) \"snth (pell_solutions D) n = nth_solution n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_solutions D !! n = nth_solution n", "by (simp add: pell_solutions_def Let_def find_fund_sol_correct nonsquare_D nth_solution_def\n                pell_power_def pell_mul_commutes[of _ fund_sol])"], ["", "subsubsection \\<open>Computing the $n$-th solution\\<close>"], ["", "definition find_nth_solution :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<times> nat\" where\n  \"find_nth_solution D n =\n     (if is_square D then (0, 0) else\n        let z = sum.projr (while isl (find_fund_sol_step D) (Inl (Suc 0, Suc D)))\n        in  efficient_pell_power D z n)\""], ["", "lemma (in pell) find_nth_solution_correct: \"find_nth_solution D n = nth_solution n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_nth_solution D n = nth_solution n", "by (simp add: find_nth_solution_def nonsquare_D nth_solution_def fund_sol_code \n                pell_power_def pell_mul_commutes[of _ \"projr _\"])"], ["", "end"]]}