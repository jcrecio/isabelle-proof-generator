{"file_name": "/home/qj213/afp-2021-10-22/thys/Pell/Efficient_Discrete_Sqrt.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Pell", "problem_names": ["lemma sqrt_eq_floor_sqrt: \"Discrete.sqrt n = nat \\<lfloor>sqrt n\\<rfloor>\"", "lemma newton_sqrt_aux_simps:\n  \"(x + n div x) div 2 < x \\<Longrightarrow> newton_sqrt_aux x n = newton_sqrt_aux ((x + n div x) div 2) n\"\n  \"(x + n div x) div 2 \\<ge> x \\<Longrightarrow> newton_sqrt_aux x n = x\"", "lemma heron_step_real: \"\\<lbrakk>t > 0; n \\<ge> 0\\<rbrakk> \\<Longrightarrow> (t + n/t) / 2 \\<ge> sqrt n\"", "lemma heron_step_div_eq_floored:\n  \"(t::nat) > 0 \\<Longrightarrow> (t + (n::nat) div t) div 2 = nat \\<lfloor>(t + n/t) / 2\\<rfloor>\"", "lemma heron_step: \"t > 0 \\<Longrightarrow> (t + n div t) div 2 \\<ge> Discrete.sqrt n\"", "lemma newton_sqrt_aux_correct:\n  assumes \"x \\<ge> Discrete.sqrt n\"\n  shows   \"newton_sqrt_aux x n = Discrete.sqrt n\"", "theorem Discrete_sqrt_eq_newton_sqrt [code]: \"Discrete.sqrt n = newton_sqrt n\"", "lemma sub_q11_array: \"i \\<in> {..<11} \\<Longrightarrow> IArray.sub q11_array i \\<longleftrightarrow> i \\<in> q11\"", "lemma sub_q63_array: \"i \\<in> {..<63} \\<Longrightarrow> IArray.sub q63_array i \\<longleftrightarrow> i \\<in> q63\"", "lemma sub_q64_array: \"i \\<in> {..<64} \\<Longrightarrow> IArray.sub q64_array i \\<longleftrightarrow> i \\<in> q64\"", "lemma sub_q65_array: \"i \\<in> {..<65} \\<Longrightarrow> IArray.sub q65_array i \\<longleftrightarrow> i \\<in> q65\"", "lemma in_q11_code: \"x mod 11 \\<in> q11 \\<longleftrightarrow> IArray.sub q11_array (x mod 11)\"", "lemma in_q63_code: \"x mod 63 \\<in> q63 \\<longleftrightarrow> IArray.sub q63_array (x mod 63)\"", "lemma in_q64_code: \"x mod 64 \\<in> q64 \\<longleftrightarrow> IArray.sub q64_array (x mod 64)\"", "lemma in_q65_code: \"x mod 65 \\<in> q65 \\<longleftrightarrow> IArray.sub q65_array (x mod 65)\"", "lemma square_test_code [code]:\n  \"square_test n =\n    (IArray.sub q64_array (n mod 64) \\<and> (let r = n mod 45045 in\n           IArray.sub q63_array (r mod 63) \\<and> \n           IArray.sub q65_array (r mod 65) \\<and>\n           IArray.sub q11_array (r mod 11) \\<and> n = (Discrete.sqrt n)\\<^sup>2))\"", "lemma square_mod_lower: \"m > 0 \\<Longrightarrow> (q\\<^sup>2 :: nat) mod m = a \\<Longrightarrow> \\<exists>q' < m. q'\\<^sup>2 mod m = a\"", "lemma q11_upto_def: \"q11 = (\\<lambda>k. k\\<^sup>2 mod 11) ` {..<11}\"", "lemma q11_infinite_def: \"q11 = (\\<lambda>k. k\\<^sup>2 mod 11) ` {0..}\"", "lemma q63_upto_def: \"q63 = (\\<lambda>k. k\\<^sup>2 mod 63) ` {..<63}\"", "lemma q63_infinite_def: \"q63 = (\\<lambda>k. k\\<^sup>2 mod 63) ` {0..}\"", "lemma q64_upto_def: \"q64 = (\\<lambda>k. k\\<^sup>2 mod 64) ` {..<64}\"", "lemma q64_infinite_def: \"q64 = (\\<lambda>k. k\\<^sup>2 mod 64) ` {0..}\"", "lemma q65_upto_def: \"q65 = (\\<lambda>k. k\\<^sup>2 mod 65) ` {..<65}\"", "lemma q65_infinite_def: \"q65 = (\\<lambda>k. k\\<^sup>2 mod 65) ` {0..}\"", "lemma square_mod_existence:\n  fixes n k :: nat\n  assumes \"\\<exists>q. q\\<^sup>2 = n\"\n  shows \"\\<exists>q. n mod k = q\\<^sup>2 mod k\"", "theorem square_test_correct: \"square_test n \\<longleftrightarrow> is_square n\"", "lemma get_nat_sqrt_code [code]:\n  \"get_nat_sqrt n = \n    (if IArray.sub q64_array (n mod 64) \\<and> (let r = n mod 45045 in\n           IArray.sub q63_array (r mod 63) \\<and> \n           IArray.sub q65_array (r mod 65) \\<and>\n           IArray.sub q11_array (r mod 11)) then\n       (let x = Discrete.sqrt n in if x\\<^sup>2 = n then Some x else None) else None)\""], "translations": [["", "lemma sqrt_eq_floor_sqrt: \"Discrete.sqrt n = nat \\<lfloor>sqrt n\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Discrete.sqrt n = nat \\<lfloor>sqrt (real n)\\<rfloor>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Discrete.sqrt n = nat \\<lfloor>sqrt (real n)\\<rfloor>", "have \"real ((nat \\<lfloor>sqrt n\\<rfloor>)\\<^sup>2) = (real (nat \\<lfloor>sqrt n\\<rfloor>))\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real ((nat \\<lfloor>sqrt (real n)\\<rfloor>)\\<^sup>2) =\n    (real (nat \\<lfloor>sqrt (real n)\\<rfloor>))\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  real ((nat \\<lfloor>sqrt (real n)\\<rfloor>)\\<^sup>2) =\n  (real (nat \\<lfloor>sqrt (real n)\\<rfloor>))\\<^sup>2\n\ngoal (1 subgoal):\n 1. Discrete.sqrt n = nat \\<lfloor>sqrt (real n)\\<rfloor>", "also"], ["proof (state)\nthis:\n  real ((nat \\<lfloor>sqrt (real n)\\<rfloor>)\\<^sup>2) =\n  (real (nat \\<lfloor>sqrt (real n)\\<rfloor>))\\<^sup>2\n\ngoal (1 subgoal):\n 1. Discrete.sqrt n = nat \\<lfloor>sqrt (real n)\\<rfloor>", "have \"\\<dots> \\<le> sqrt (real n) ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (real (nat \\<lfloor>sqrt (real n)\\<rfloor>))\\<^sup>2\n    \\<le> (sqrt (real n))\\<^sup>2", "by (intro power_mono) auto"], ["proof (state)\nthis:\n  (real (nat \\<lfloor>sqrt (real n)\\<rfloor>))\\<^sup>2\n  \\<le> (sqrt (real n))\\<^sup>2\n\ngoal (1 subgoal):\n 1. Discrete.sqrt n = nat \\<lfloor>sqrt (real n)\\<rfloor>", "also"], ["proof (state)\nthis:\n  (real (nat \\<lfloor>sqrt (real n)\\<rfloor>))\\<^sup>2\n  \\<le> (sqrt (real n))\\<^sup>2\n\ngoal (1 subgoal):\n 1. Discrete.sqrt n = nat \\<lfloor>sqrt (real n)\\<rfloor>", "have \"\\<dots> = real n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sqrt (real n))\\<^sup>2 = real n", "by simp"], ["proof (state)\nthis:\n  (sqrt (real n))\\<^sup>2 = real n\n\ngoal (1 subgoal):\n 1. Discrete.sqrt n = nat \\<lfloor>sqrt (real n)\\<rfloor>", "finally"], ["proof (chain)\npicking this:\n  real ((nat \\<lfloor>sqrt (real n)\\<rfloor>)\\<^sup>2) \\<le> real n", "have \"(nat \\<lfloor>sqrt n\\<rfloor>)\\<^sup>2 \\<le> n\""], ["proof (prove)\nusing this:\n  real ((nat \\<lfloor>sqrt (real n)\\<rfloor>)\\<^sup>2) \\<le> real n\n\ngoal (1 subgoal):\n 1. (nat \\<lfloor>sqrt (real n)\\<rfloor>)\\<^sup>2 \\<le> n", "by (simp only: of_nat_le_iff)"], ["proof (state)\nthis:\n  (nat \\<lfloor>sqrt (real n)\\<rfloor>)\\<^sup>2 \\<le> n\n\ngoal (1 subgoal):\n 1. Discrete.sqrt n = nat \\<lfloor>sqrt (real n)\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  (nat \\<lfloor>sqrt (real n)\\<rfloor>)\\<^sup>2 \\<le> n\n\ngoal (1 subgoal):\n 1. Discrete.sqrt n = nat \\<lfloor>sqrt (real n)\\<rfloor>", "have \"n < (Suc (nat \\<lfloor>sqrt n\\<rfloor>))\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < (Suc (nat \\<lfloor>sqrt (real n)\\<rfloor>))\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n < (Suc (nat \\<lfloor>sqrt (real n)\\<rfloor>))\\<^sup>2", "have \"(1 + \\<lfloor>sqrt n\\<rfloor>)\\<^sup>2 > n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int n < (1 + \\<lfloor>sqrt (real n)\\<rfloor>)\\<^sup>2", "using floor_correct[of \"sqrt n\"] real_le_rsqrt[of \"1 + \\<lfloor>sqrt n\\<rfloor>\" n]\n        of_int_less_iff[of n \"(1 + \\<lfloor>sqrt n\\<rfloor>)\\<^sup>2\"] not_le"], ["proof (prove)\nusing this:\n  real_of_int \\<lfloor>sqrt (real n)\\<rfloor> \\<le> sqrt (real n) \\<and>\n  sqrt (real n) < real_of_int (\\<lfloor>sqrt (real n)\\<rfloor> + 1)\n  (real_of_int (1 + \\<lfloor>sqrt (real n)\\<rfloor>))\\<^sup>2\n  \\<le> real n \\<Longrightarrow>\n  real_of_int (1 + \\<lfloor>sqrt (real n)\\<rfloor>) \\<le> sqrt (real n)\n  (of_int (int n)\n   < of_int ((1 + \\<lfloor>sqrt (real n)\\<rfloor>)\\<^sup>2)) =\n  (int n < (1 + \\<lfloor>sqrt (real n)\\<rfloor>)\\<^sup>2)\n  (\\<not> ?x \\<le> ?y) = (?y < ?x)\n\ngoal (1 subgoal):\n 1. int n < (1 + \\<lfloor>sqrt (real n)\\<rfloor>)\\<^sup>2", "by fastforce"], ["proof (state)\nthis:\n  int n < (1 + \\<lfloor>sqrt (real n)\\<rfloor>)\\<^sup>2\n\ngoal (1 subgoal):\n 1. n < (Suc (nat \\<lfloor>sqrt (real n)\\<rfloor>))\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  int n < (1 + \\<lfloor>sqrt (real n)\\<rfloor>)\\<^sup>2", "show ?thesis"], ["proof (prove)\nusing this:\n  int n < (1 + \\<lfloor>sqrt (real n)\\<rfloor>)\\<^sup>2\n\ngoal (1 subgoal):\n 1. n < (Suc (nat \\<lfloor>sqrt (real n)\\<rfloor>))\\<^sup>2", "using le_nat_floor[of \"Suc (nat \\<lfloor>sqrt n\\<rfloor>)\" \"sqrt n\"]\n        of_nat_le_iff[of \"(Suc (nat \\<lfloor>sqrt n\\<rfloor>))\\<^sup>2\" n] real_le_rsqrt[of _ n] not_le"], ["proof (prove)\nusing this:\n  int n < (1 + \\<lfloor>sqrt (real n)\\<rfloor>)\\<^sup>2\n  real (Suc (nat \\<lfloor>sqrt (real n)\\<rfloor>))\n  \\<le> sqrt (real n) \\<Longrightarrow>\n  Suc (nat \\<lfloor>sqrt (real n)\\<rfloor>)\n  \\<le> nat \\<lfloor>sqrt (real n)\\<rfloor>\n  (of_nat ((Suc (nat \\<lfloor>sqrt (real n)\\<rfloor>))\\<^sup>2)\n   \\<le> of_nat n) =\n  ((Suc (nat \\<lfloor>sqrt (real n)\\<rfloor>))\\<^sup>2 \\<le> n)\n  ?x\\<^sup>2 \\<le> real n \\<Longrightarrow> ?x \\<le> sqrt (real n)\n  (\\<not> ?x \\<le> ?y) = (?y < ?x)\n\ngoal (1 subgoal):\n 1. n < (Suc (nat \\<lfloor>sqrt (real n)\\<rfloor>))\\<^sup>2", "by fastforce"], ["proof (state)\nthis:\n  n < (Suc (nat \\<lfloor>sqrt (real n)\\<rfloor>))\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n < (Suc (nat \\<lfloor>sqrt (real n)\\<rfloor>))\\<^sup>2\n\ngoal (1 subgoal):\n 1. Discrete.sqrt n = nat \\<lfloor>sqrt (real n)\\<rfloor>", "ultimately"], ["proof (chain)\npicking this:\n  (nat \\<lfloor>sqrt (real n)\\<rfloor>)\\<^sup>2 \\<le> n\n  n < (Suc (nat \\<lfloor>sqrt (real n)\\<rfloor>))\\<^sup>2", "show ?thesis"], ["proof (prove)\nusing this:\n  (nat \\<lfloor>sqrt (real n)\\<rfloor>)\\<^sup>2 \\<le> n\n  n < (Suc (nat \\<lfloor>sqrt (real n)\\<rfloor>))\\<^sup>2\n\ngoal (1 subgoal):\n 1. Discrete.sqrt n = nat \\<lfloor>sqrt (real n)\\<rfloor>", "using sqrt_unique"], ["proof (prove)\nusing this:\n  (nat \\<lfloor>sqrt (real n)\\<rfloor>)\\<^sup>2 \\<le> n\n  n < (Suc (nat \\<lfloor>sqrt (real n)\\<rfloor>))\\<^sup>2\n  \\<lbrakk>?m\\<^sup>2 \\<le> ?n; ?n < (Suc ?m)\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> Discrete.sqrt ?n = ?m\n\ngoal (1 subgoal):\n 1. Discrete.sqrt n = nat \\<lfloor>sqrt (real n)\\<rfloor>", "by fast"], ["proof (state)\nthis:\n  Discrete.sqrt n = nat \\<lfloor>sqrt (real n)\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "fun newton_sqrt_aux :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"newton_sqrt_aux x n =\n     (let y = (x + n div x) div 2\n      in if y < x then newton_sqrt_aux y n else x)\""], ["", "declare newton_sqrt_aux.simps [simp del]"], ["", "lemma newton_sqrt_aux_simps:\n  \"(x + n div x) div 2 < x \\<Longrightarrow> newton_sqrt_aux x n = newton_sqrt_aux ((x + n div x) div 2) n\"\n  \"(x + n div x) div 2 \\<ge> x \\<Longrightarrow> newton_sqrt_aux x n = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x + n div x) div 2 < x \\<Longrightarrow>\n     newton_sqrt_aux x n = newton_sqrt_aux ((x + n div x) div 2) n) &&&\n    (x \\<le> (x + n div x) div 2 \\<Longrightarrow> newton_sqrt_aux x n = x)", "by (subst newton_sqrt_aux.simps; simp add: Let_def)+"], ["", "lemma heron_step_real: \"\\<lbrakk>t > 0; n \\<ge> 0\\<rbrakk> \\<Longrightarrow> (t + n/t) / 2 \\<ge> sqrt n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < t; 0 \\<le> n\\<rbrakk>\n    \\<Longrightarrow> sqrt n \\<le> (t + n / t) / 2", "using arith_geo_mean_sqrt[of t \"n/t\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> t; 0 \\<le> n / t\\<rbrakk>\n  \\<Longrightarrow> sqrt (t * (n / t)) \\<le> (t + n / t) / 2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < t; 0 \\<le> n\\<rbrakk>\n    \\<Longrightarrow> sqrt n \\<le> (t + n / t) / 2", "by simp"], ["", "lemma heron_step_div_eq_floored:\n  \"(t::nat) > 0 \\<Longrightarrow> (t + (n::nat) div t) div 2 = nat \\<lfloor>(t + n/t) / 2\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < t \\<Longrightarrow>\n    (t + n div t) div 2 =\n    nat \\<lfloor>(real t + real n / real t) / 2\\<rfloor>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < t \\<Longrightarrow>\n    (t + n div t) div 2 =\n    nat \\<lfloor>(real t + real n / real t) / 2\\<rfloor>", "assume \"t > 0\""], ["proof (state)\nthis:\n  0 < t\n\ngoal (1 subgoal):\n 1. 0 < t \\<Longrightarrow>\n    (t + n div t) div 2 =\n    nat \\<lfloor>(real t + real n / real t) / 2\\<rfloor>", "then"], ["proof (chain)\npicking this:\n  0 < t", "have \"\\<lfloor>(t + n/t) / 2\\<rfloor> = \\<lfloor>(t*t + n) / (2*t)\\<rfloor>\""], ["proof (prove)\nusing this:\n  0 < t\n\ngoal (1 subgoal):\n 1. \\<lfloor>(real t + real n / real t) / 2\\<rfloor> =\n    \\<lfloor>real (t * t + n) / real (2 * t)\\<rfloor>", "by (simp add: mult_divide_mult_cancel_right[of t \"t + n/t\" 2, symmetric]\n        algebra_simps)"], ["proof (state)\nthis:\n  \\<lfloor>(real t + real n / real t) / 2\\<rfloor> =\n  \\<lfloor>real (t * t + n) / real (2 * t)\\<rfloor>\n\ngoal (1 subgoal):\n 1. 0 < t \\<Longrightarrow>\n    (t + n div t) div 2 =\n    nat \\<lfloor>(real t + real n / real t) / 2\\<rfloor>", "also"], ["proof (state)\nthis:\n  \\<lfloor>(real t + real n / real t) / 2\\<rfloor> =\n  \\<lfloor>real (t * t + n) / real (2 * t)\\<rfloor>\n\ngoal (1 subgoal):\n 1. 0 < t \\<Longrightarrow>\n    (t + n div t) div 2 =\n    nat \\<lfloor>(real t + real n / real t) / 2\\<rfloor>", "have \"\\<dots> = (t*t + n) div (2*t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>real (t * t + n) / real (2 * t)\\<rfloor> =\n    int ((t * t + n) div (2 * t))", "using floor_divide_of_nat_eq"], ["proof (prove)\nusing this:\n  \\<lfloor>of_nat ?m / of_nat ?n\\<rfloor> = int (?m div ?n)\n\ngoal (1 subgoal):\n 1. \\<lfloor>real (t * t + n) / real (2 * t)\\<rfloor> =\n    int ((t * t + n) div (2 * t))", "by blast"], ["proof (state)\nthis:\n  \\<lfloor>real (t * t + n) / real (2 * t)\\<rfloor> =\n  int ((t * t + n) div (2 * t))\n\ngoal (1 subgoal):\n 1. 0 < t \\<Longrightarrow>\n    (t + n div t) div 2 =\n    nat \\<lfloor>(real t + real n / real t) / 2\\<rfloor>", "also"], ["proof (state)\nthis:\n  \\<lfloor>real (t * t + n) / real (2 * t)\\<rfloor> =\n  int ((t * t + n) div (2 * t))\n\ngoal (1 subgoal):\n 1. 0 < t \\<Longrightarrow>\n    (t + n div t) div 2 =\n    nat \\<lfloor>(real t + real n / real t) / 2\\<rfloor>", "have \"\\<dots> = (t*t + n) div t div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int ((t * t + n) div (2 * t)) = int ((t * t + n) div t div 2)", "by (simp add: Divides.div_mult2_eq mult.commute)"], ["proof (state)\nthis:\n  int ((t * t + n) div (2 * t)) = int ((t * t + n) div t div 2)\n\ngoal (1 subgoal):\n 1. 0 < t \\<Longrightarrow>\n    (t + n div t) div 2 =\n    nat \\<lfloor>(real t + real n / real t) / 2\\<rfloor>", "also"], ["proof (state)\nthis:\n  int ((t * t + n) div (2 * t)) = int ((t * t + n) div t div 2)\n\ngoal (1 subgoal):\n 1. 0 < t \\<Longrightarrow>\n    (t + n div t) div 2 =\n    nat \\<lfloor>(real t + real n / real t) / 2\\<rfloor>", "have \"\\<dots> = (t + n div t) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int ((t * t + n) div t div 2) = int ((t + n div t) div 2)", "by (simp add: \\<open>0 < t\\<close> power2_eq_square)"], ["proof (state)\nthis:\n  int ((t * t + n) div t div 2) = int ((t + n div t) div 2)\n\ngoal (1 subgoal):\n 1. 0 < t \\<Longrightarrow>\n    (t + n div t) div 2 =\n    nat \\<lfloor>(real t + real n / real t) / 2\\<rfloor>", "finally"], ["proof (chain)\npicking this:\n  \\<lfloor>(real t + real n / real t) / 2\\<rfloor> =\n  int ((t + n div t) div 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lfloor>(real t + real n / real t) / 2\\<rfloor> =\n  int ((t + n div t) div 2)\n\ngoal (1 subgoal):\n 1. (t + n div t) div 2 =\n    nat \\<lfloor>(real t + real n / real t) / 2\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  (t + n div t) div 2 = nat \\<lfloor>(real t + real n / real t) / 2\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma heron_step: \"t > 0 \\<Longrightarrow> (t + n div t) div 2 \\<ge> Discrete.sqrt n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < t \\<Longrightarrow> Discrete.sqrt n \\<le> (t + n div t) div 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < t \\<Longrightarrow> Discrete.sqrt n \\<le> (t + n div t) div 2", "assume \"t > 0\""], ["proof (state)\nthis:\n  0 < t\n\ngoal (1 subgoal):\n 1. 0 < t \\<Longrightarrow> Discrete.sqrt n \\<le> (t + n div t) div 2", "have \"Discrete.sqrt n = nat \\<lfloor>sqrt n\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Discrete.sqrt n = nat \\<lfloor>sqrt (real n)\\<rfloor>", "by (rule sqrt_eq_floor_sqrt)"], ["proof (state)\nthis:\n  Discrete.sqrt n = nat \\<lfloor>sqrt (real n)\\<rfloor>\n\ngoal (1 subgoal):\n 1. 0 < t \\<Longrightarrow> Discrete.sqrt n \\<le> (t + n div t) div 2", "also"], ["proof (state)\nthis:\n  Discrete.sqrt n = nat \\<lfloor>sqrt (real n)\\<rfloor>\n\ngoal (1 subgoal):\n 1. 0 < t \\<Longrightarrow> Discrete.sqrt n \\<le> (t + n div t) div 2", "have \"\\<dots> \\<le> nat \\<lfloor>(t + n/t) / 2\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat \\<lfloor>sqrt (real n)\\<rfloor>\n    \\<le> nat \\<lfloor>(real t + real n / real t) / 2\\<rfloor>", "using heron_step_real[of t n] \\<open>t > 0\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < real t; 0 \\<le> real n\\<rbrakk>\n  \\<Longrightarrow> sqrt (real n) \\<le> (real t + real n / real t) / 2\n  0 < t\n\ngoal (1 subgoal):\n 1. nat \\<lfloor>sqrt (real n)\\<rfloor>\n    \\<le> nat \\<lfloor>(real t + real n / real t) / 2\\<rfloor>", "by linarith"], ["proof (state)\nthis:\n  nat \\<lfloor>sqrt (real n)\\<rfloor>\n  \\<le> nat \\<lfloor>(real t + real n / real t) / 2\\<rfloor>\n\ngoal (1 subgoal):\n 1. 0 < t \\<Longrightarrow> Discrete.sqrt n \\<le> (t + n div t) div 2", "also"], ["proof (state)\nthis:\n  nat \\<lfloor>sqrt (real n)\\<rfloor>\n  \\<le> nat \\<lfloor>(real t + real n / real t) / 2\\<rfloor>\n\ngoal (1 subgoal):\n 1. 0 < t \\<Longrightarrow> Discrete.sqrt n \\<le> (t + n div t) div 2", "have \"\\<dots> = (t + n div t) div 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat \\<lfloor>(real t + real n / real t) / 2\\<rfloor> =\n    (t + n div t) div 2", "using heron_step_div_eq_floored[OF \\<open>t > 0\\<close>]"], ["proof (prove)\nusing this:\n  (t + ?n div t) div 2 =\n  nat \\<lfloor>(real t + real ?n / real t) / 2\\<rfloor>\n\ngoal (1 subgoal):\n 1. nat \\<lfloor>(real t + real n / real t) / 2\\<rfloor> =\n    (t + n div t) div 2", "by simp"], ["proof (state)\nthis:\n  nat \\<lfloor>(real t + real n / real t) / 2\\<rfloor> = (t + n div t) div 2\n\ngoal (1 subgoal):\n 1. 0 < t \\<Longrightarrow> Discrete.sqrt n \\<le> (t + n div t) div 2", "finally"], ["proof (chain)\npicking this:\n  Discrete.sqrt n \\<le> (t + n div t) div 2", "show ?thesis"], ["proof (prove)\nusing this:\n  Discrete.sqrt n \\<le> (t + n div t) div 2\n\ngoal (1 subgoal):\n 1. Discrete.sqrt n \\<le> (t + n div t) div 2", "."], ["proof (state)\nthis:\n  Discrete.sqrt n \\<le> (t + n div t) div 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma newton_sqrt_aux_correct:\n  assumes \"x \\<ge> Discrete.sqrt n\"\n  shows   \"newton_sqrt_aux x n = Discrete.sqrt n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. newton_sqrt_aux x n = Discrete.sqrt n", "using assms"], ["proof (prove)\nusing this:\n  Discrete.sqrt n \\<le> x\n\ngoal (1 subgoal):\n 1. newton_sqrt_aux x n = Discrete.sqrt n", "proof (induction x n rule: newton_sqrt_aux.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x n.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>xa = (x + n div x) div 2; xa < x;\n                    Discrete.sqrt n \\<le> xa\\<rbrakk>\n                   \\<Longrightarrow> newton_sqrt_aux xa n = Discrete.sqrt n;\n        Discrete.sqrt n \\<le> x\\<rbrakk>\n       \\<Longrightarrow> newton_sqrt_aux x n = Discrete.sqrt n", "case (1 x n)"], ["proof (state)\nthis:\n  \\<lbrakk>?xa = (x + n div x) div 2; ?xa < x;\n   Discrete.sqrt n \\<le> ?xa\\<rbrakk>\n  \\<Longrightarrow> newton_sqrt_aux ?xa n = Discrete.sqrt n\n  Discrete.sqrt n \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>x n.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>xa = (x + n div x) div 2; xa < x;\n                    Discrete.sqrt n \\<le> xa\\<rbrakk>\n                   \\<Longrightarrow> newton_sqrt_aux xa n = Discrete.sqrt n;\n        Discrete.sqrt n \\<le> x\\<rbrakk>\n       \\<Longrightarrow> newton_sqrt_aux x n = Discrete.sqrt n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. newton_sqrt_aux x n = Discrete.sqrt n", "proof (cases \"x = Discrete.sqrt n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n\n 2. x \\<noteq> Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n", "case True"], ["proof (state)\nthis:\n  x = Discrete.sqrt n\n\ngoal (2 subgoals):\n 1. x = Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n\n 2. x \\<noteq> Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n", "then"], ["proof (chain)\npicking this:\n  x = Discrete.sqrt n", "have \"(x ^ 2) div x \\<le> n div x\""], ["proof (prove)\nusing this:\n  x = Discrete.sqrt n\n\ngoal (1 subgoal):\n 1. x\\<^sup>2 div x \\<le> n div x", "by (intro div_le_mono) simp_all"], ["proof (state)\nthis:\n  x\\<^sup>2 div x \\<le> n div x\n\ngoal (2 subgoals):\n 1. x = Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n\n 2. x \\<noteq> Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n", "also"], ["proof (state)\nthis:\n  x\\<^sup>2 div x \\<le> n div x\n\ngoal (2 subgoals):\n 1. x = Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n\n 2. x \\<noteq> Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n", "have \"(x ^ 2) div x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>2 div x = x", "by (simp add: power2_eq_square)"], ["proof (state)\nthis:\n  x\\<^sup>2 div x = x\n\ngoal (2 subgoals):\n 1. x = Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n\n 2. x \\<noteq> Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n", "finally"], ["proof (chain)\npicking this:\n  x \\<le> n div x", "have \"(x + n div x) div 2 \\<ge> x\""], ["proof (prove)\nusing this:\n  x \\<le> n div x\n\ngoal (1 subgoal):\n 1. x \\<le> (x + n div x) div 2", "by linarith"], ["proof (state)\nthis:\n  x \\<le> (x + n div x) div 2\n\ngoal (2 subgoals):\n 1. x = Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n\n 2. x \\<noteq> Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n", "with True"], ["proof (chain)\npicking this:\n  x = Discrete.sqrt n\n  x \\<le> (x + n div x) div 2", "show ?thesis"], ["proof (prove)\nusing this:\n  x = Discrete.sqrt n\n  x \\<le> (x + n div x) div 2\n\ngoal (1 subgoal):\n 1. newton_sqrt_aux x n = Discrete.sqrt n", "by (auto simp: newton_sqrt_aux_simps)"], ["proof (state)\nthis:\n  newton_sqrt_aux x n = Discrete.sqrt n\n\ngoal (1 subgoal):\n 1. x \\<noteq> Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n", "case False"], ["proof (state)\nthis:\n  x \\<noteq> Discrete.sqrt n\n\ngoal (1 subgoal):\n 1. x \\<noteq> Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n", "with \"1.prems\""], ["proof (chain)\npicking this:\n  Discrete.sqrt n \\<le> x\n  x \\<noteq> Discrete.sqrt n", "have x_gt_sqrt: \"x > Discrete.sqrt n\""], ["proof (prove)\nusing this:\n  Discrete.sqrt n \\<le> x\n  x \\<noteq> Discrete.sqrt n\n\ngoal (1 subgoal):\n 1. Discrete.sqrt n < x", "by auto"], ["proof (state)\nthis:\n  Discrete.sqrt n < x\n\ngoal (1 subgoal):\n 1. x \\<noteq> Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n", "with Discrete.le_sqrt_iff[of x n]"], ["proof (chain)\npicking this:\n  (x \\<le> Discrete.sqrt n) = (x\\<^sup>2 \\<le> n)\n  Discrete.sqrt n < x", "have \"n < x ^ 2\""], ["proof (prove)\nusing this:\n  (x \\<le> Discrete.sqrt n) = (x\\<^sup>2 \\<le> n)\n  Discrete.sqrt n < x\n\ngoal (1 subgoal):\n 1. n < x\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  n < x\\<^sup>2\n\ngoal (1 subgoal):\n 1. x \\<noteq> Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n", "have \"x * (n div x) \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (n div x) \\<le> n", "using mult_div_mod_eq[of x n]"], ["proof (prove)\nusing this:\n  x * (n div x) + n mod x = n\n\ngoal (1 subgoal):\n 1. x * (n div x) \\<le> n", "by linarith"], ["proof (state)\nthis:\n  x * (n div x) \\<le> n\n\ngoal (1 subgoal):\n 1. x \\<noteq> Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n", "also"], ["proof (state)\nthis:\n  x * (n div x) \\<le> n\n\ngoal (1 subgoal):\n 1. x \\<noteq> Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n", "have \"\\<dots> < x ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < x\\<^sup>2", "using Discrete.le_sqrt_iff[of x n] and x_gt_sqrt"], ["proof (prove)\nusing this:\n  (x \\<le> Discrete.sqrt n) = (x\\<^sup>2 \\<le> n)\n  Discrete.sqrt n < x\n\ngoal (1 subgoal):\n 1. n < x\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  n < x\\<^sup>2\n\ngoal (1 subgoal):\n 1. x \\<noteq> Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n", "also"], ["proof (state)\nthis:\n  n < x\\<^sup>2\n\ngoal (1 subgoal):\n 1. x \\<noteq> Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n", "have \"\\<dots> = x * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>2 = x * x", "by (simp add: power2_eq_square)"], ["proof (state)\nthis:\n  x\\<^sup>2 = x * x\n\ngoal (1 subgoal):\n 1. x \\<noteq> Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n", "finally"], ["proof (chain)\npicking this:\n  x * (n div x) < x * x", "have \"n div x < x\""], ["proof (prove)\nusing this:\n  x * (n div x) < x * x\n\ngoal (1 subgoal):\n 1. n div x < x", "by (subst (asm) mult_less_cancel1) auto"], ["proof (state)\nthis:\n  n div x < x\n\ngoal (1 subgoal):\n 1. x \\<noteq> Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n", "then"], ["proof (chain)\npicking this:\n  n div x < x", "have step_decreasing: \"(x + n div x) div 2 < x\""], ["proof (prove)\nusing this:\n  n div x < x\n\ngoal (1 subgoal):\n 1. (x + n div x) div 2 < x", "by linarith"], ["proof (state)\nthis:\n  (x + n div x) div 2 < x\n\ngoal (1 subgoal):\n 1. x \\<noteq> Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n", "with x_gt_sqrt"], ["proof (chain)\npicking this:\n  Discrete.sqrt n < x\n  (x + n div x) div 2 < x", "have step_ge_sqrt: \"(x + n div x) div 2 \\<ge> Discrete.sqrt n\""], ["proof (prove)\nusing this:\n  Discrete.sqrt n < x\n  (x + n div x) div 2 < x\n\ngoal (1 subgoal):\n 1. Discrete.sqrt n \\<le> (x + n div x) div 2", "by (simp add: heron_step)"], ["proof (state)\nthis:\n  Discrete.sqrt n \\<le> (x + n div x) div 2\n\ngoal (1 subgoal):\n 1. x \\<noteq> Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n", "from step_decreasing"], ["proof (chain)\npicking this:\n  (x + n div x) div 2 < x", "have \"newton_sqrt_aux x n = newton_sqrt_aux ((x + n div x) div 2) n\""], ["proof (prove)\nusing this:\n  (x + n div x) div 2 < x\n\ngoal (1 subgoal):\n 1. newton_sqrt_aux x n = newton_sqrt_aux ((x + n div x) div 2) n", "by (simp add: newton_sqrt_aux_simps)"], ["proof (state)\nthis:\n  newton_sqrt_aux x n = newton_sqrt_aux ((x + n div x) div 2) n\n\ngoal (1 subgoal):\n 1. x \\<noteq> Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n", "also"], ["proof (state)\nthis:\n  newton_sqrt_aux x n = newton_sqrt_aux ((x + n div x) div 2) n\n\ngoal (1 subgoal):\n 1. x \\<noteq> Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n", "have \"\\<dots> = Discrete.sqrt n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. newton_sqrt_aux ((x + n div x) div 2) n = Discrete.sqrt n", "by (intro \"1.IH\" step_decreasing step_ge_sqrt) simp_all"], ["proof (state)\nthis:\n  newton_sqrt_aux ((x + n div x) div 2) n = Discrete.sqrt n\n\ngoal (1 subgoal):\n 1. x \\<noteq> Discrete.sqrt n \\<Longrightarrow>\n    newton_sqrt_aux x n = Discrete.sqrt n", "finally"], ["proof (chain)\npicking this:\n  newton_sqrt_aux x n = Discrete.sqrt n", "show ?thesis"], ["proof (prove)\nusing this:\n  newton_sqrt_aux x n = Discrete.sqrt n\n\ngoal (1 subgoal):\n 1. newton_sqrt_aux x n = Discrete.sqrt n", "."], ["proof (state)\nthis:\n  newton_sqrt_aux x n = Discrete.sqrt n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  newton_sqrt_aux x n = Discrete.sqrt n\n\ngoal:\nNo subgoals!", "qed"], ["", "definition newton_sqrt :: \"nat \\<Rightarrow> nat\" where\n  \"newton_sqrt n = newton_sqrt_aux n n\""], ["", "declare Discrete.sqrt_code [code del]"], ["", "theorem Discrete_sqrt_eq_newton_sqrt [code]: \"Discrete.sqrt n = newton_sqrt n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Discrete.sqrt n = newton_sqrt n", "unfolding newton_sqrt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Discrete.sqrt n = newton_sqrt_aux n n", "by (simp add: newton_sqrt_aux_correct Discrete.sqrt_le)"], ["", "subsection \\<open>Square Testing\\<close>"], ["", "text \\<open>\n  Next, we implement an algorithm to determine whether a given natural number is a perfect square,\n  as described by Cohen~\\cite{cohen2010algebraic}. Essentially, the number first determines whether\n  the number is a square. Essentially\n\\<close>"], ["", "definition q11 :: \"nat set\"\n  where \"q11 = {0, 1, 3, 4, 5, 9}\""], ["", "definition q63 :: \"nat set\"\n  where \"q63 = {0, 1, 4, 7, 9, 16, 28, 18, 22, 25, 36, 58, 46, 49, 37, 43}\""], ["", "definition q64 :: \"nat set\"\n  where \"q64 = {0, 1, 4, 9, 16, 17, 25, 36, 33, 49, 41, 57}\""], ["", "definition q65 :: \"nat set\"\n  where \"q65 = {0, 1, 4, 10, 14, 9, 16, 26, 30, 25, 29, 40, 56, 36, 49, 61, 35, 51, 39, 55, 64}\""], ["", "definition q11_array where\n  \"q11_array = IArray [True,True,False,True,True,True,False,False,False,True,False]\""], ["", "definition q63_array where\n  \"q63_array = IArray [True,True,False,False,True,False,False,True,False,True,False,False,\n     False,False,False,False,True,False,True,False,False,False,True,False,False,True,False,\n     False,True,False,False,False,False,False,False,False,True,True,False,False,False,False,\n     False,True,False,False,True,False,False,True,False,False,False,False,False,False,False,\n     False,True,False,False,False,False,False]\""], ["", "definition q64_array where\n  \"q64_array = IArray [True,True,False,False,True,False,False,False,False,True,False,False,\n     False,False,False,False,True,True,False,False,False,False,False,False,False,True,False,\n     False,False,False,False,False,False,True,False,False,True,False,False,False,False,True,\n     False,False,False,False,False,False,False,True,False,False,False,False,False,False,\n     False,True,False,False,False,False,False,False, False]\""], ["", "definition q65_array where\n  \"q65_array = IArray [True,True,False,False,True,False,False,False,False,True,True,False,\n     False,False,True,False,True,False,False,False,False,False,False,False,False,True,True,\n     False,False,True,True,False,False,False,False,True,True,False,False,True,True,False,\n     False,False,False,False,False,False,False,True,False,True,False,False,False,True,True\n     ,False,False,False,False,True,False,False,True,False]\""], ["", "lemma sub_q11_array: \"i \\<in> {..<11} \\<Longrightarrow> IArray.sub q11_array i \\<longleftrightarrow> i \\<in> q11\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> {..<11} \\<Longrightarrow> q11_array !! i = (i \\<in> q11)", "by (simp add: lessThan_nat_numeral lessThan_Suc q11_def q11_array_def, elim disjE; simp)"], ["", "lemma sub_q63_array: \"i \\<in> {..<63} \\<Longrightarrow> IArray.sub q63_array i \\<longleftrightarrow> i \\<in> q63\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> {..<63} \\<Longrightarrow> q63_array !! i = (i \\<in> q63)", "by (simp add: lessThan_nat_numeral lessThan_Suc q63_def q63_array_def, elim disjE; simp)"], ["", "lemma sub_q64_array: \"i \\<in> {..<64} \\<Longrightarrow> IArray.sub q64_array i \\<longleftrightarrow> i \\<in> q64\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> {..<64} \\<Longrightarrow> q64_array !! i = (i \\<in> q64)", "by (simp add: lessThan_nat_numeral lessThan_Suc q64_def q64_array_def, elim disjE; simp)"], ["", "lemma sub_q65_array: \"i \\<in> {..<65} \\<Longrightarrow> IArray.sub q65_array i \\<longleftrightarrow> i \\<in> q65\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> {..<65} \\<Longrightarrow> q65_array !! i = (i \\<in> q65)", "by (simp add: lessThan_nat_numeral lessThan_Suc q65_def q65_array_def, elim disjE; simp)"], ["", "lemma in_q11_code: \"x mod 11 \\<in> q11 \\<longleftrightarrow> IArray.sub q11_array (x mod 11)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x mod 11 \\<in> q11) = q11_array !! (x mod 11)", "by (subst sub_q11_array) auto"], ["", "lemma in_q63_code: \"x mod 63 \\<in> q63 \\<longleftrightarrow> IArray.sub q63_array (x mod 63)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x mod 63 \\<in> q63) = q63_array !! (x mod 63)", "by (subst sub_q63_array) auto"], ["", "lemma in_q64_code: \"x mod 64 \\<in> q64 \\<longleftrightarrow> IArray.sub q64_array (x mod 64)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x mod 64 \\<in> q64) = q64_array !! (x mod 64)", "by (subst sub_q64_array) auto"], ["", "lemma in_q65_code: \"x mod 65 \\<in> q65 \\<longleftrightarrow> IArray.sub q65_array (x mod 65)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x mod 65 \\<in> q65) = q65_array !! (x mod 65)", "by (subst sub_q65_array) auto"], ["", "definition square_test :: \"nat \\<Rightarrow> bool\" where\n  \"square_test n =\n    (n mod 64 \\<in> q64 \\<and> (let r = n mod 45045 in\n      r mod 63 \\<in> q63 \\<and> r mod 65 \\<in> q65 \\<and> r mod 11 \\<in> q11 \\<and> n = (Discrete.sqrt n)\\<^sup>2))\""], ["", "lemma square_test_code [code]:\n  \"square_test n =\n    (IArray.sub q64_array (n mod 64) \\<and> (let r = n mod 45045 in\n           IArray.sub q63_array (r mod 63) \\<and> \n           IArray.sub q65_array (r mod 65) \\<and>\n           IArray.sub q11_array (r mod 11) \\<and> n = (Discrete.sqrt n)\\<^sup>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_test n =\n    (q64_array !! (n mod 64) \\<and>\n     (let r = n mod 45045\n      in q63_array !! (r mod 63) \\<and>\n         q65_array !! (r mod 65) \\<and>\n         q11_array !! (r mod 11) \\<and> n = (Discrete.sqrt n)\\<^sup>2))", "using in_q11_code [symmetric] in_q63_code [symmetric] \n          in_q64_code [symmetric] in_q65_code [symmetric]"], ["proof (prove)\nusing this:\n  q11_array !! (?x mod 11) = (?x mod 11 \\<in> q11)\n  q63_array !! (?x mod 63) = (?x mod 63 \\<in> q63)\n  q64_array !! (?x mod 64) = (?x mod 64 \\<in> q64)\n  q65_array !! (?x mod 65) = (?x mod 65 \\<in> q65)\n\ngoal (1 subgoal):\n 1. square_test n =\n    (q64_array !! (n mod 64) \\<and>\n     (let r = n mod 45045\n      in q63_array !! (r mod 63) \\<and>\n         q65_array !! (r mod 65) \\<and>\n         q11_array !! (r mod 11) \\<and> n = (Discrete.sqrt n)\\<^sup>2))", "by (simp add: Let_def square_test_def)"], ["", "lemma square_mod_lower: \"m > 0 \\<Longrightarrow> (q\\<^sup>2 :: nat) mod m = a \\<Longrightarrow> \\<exists>q' < m. q'\\<^sup>2 mod m = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; q\\<^sup>2 mod m = a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q'<m. q'\\<^sup>2 mod m = a", "using mod_less_divisor mod_mod_trivial power_mod"], ["proof (prove)\nusing this:\n  0 < ?n \\<Longrightarrow> ?m mod ?n < ?n\n  ?a mod ?b mod ?b = ?a mod ?b\n  (?a mod ?b) ^ ?n mod ?b = ?a ^ ?n mod ?b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < m; q\\<^sup>2 mod m = a\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q'<m. q'\\<^sup>2 mod m = a", "by blast"], ["", "lemma q11_upto_def: \"q11 = (\\<lambda>k. k\\<^sup>2 mod 11) ` {..<11}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q11 = (\\<lambda>k. k\\<^sup>2 mod 11) ` {..<11}", "by (simp add: q11_def lessThan_nat_numeral lessThan_Suc insert_commute)"], ["", "lemma q11_infinite_def: \"q11 = (\\<lambda>k. k\\<^sup>2 mod 11) ` {0..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q11 = (\\<lambda>k. k\\<^sup>2 mod 11) ` {0..}", "unfolding q11_upto_def image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. \\<exists>x\\<in>{..<11}. y = x\\<^sup>2 mod 11} =\n    {y. \\<exists>x\\<in>{0..}. y = x\\<^sup>2 mod 11}", "proof (auto, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. \\<exists>x\\<in>{..<11}. xa\\<^sup>2 mod 11 = x\\<^sup>2 mod 11", "case (1 xa)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>xa. \\<exists>x\\<in>{..<11}. xa\\<^sup>2 mod 11 = x\\<^sup>2 mod 11", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{..<11}. xa\\<^sup>2 mod 11 = x\\<^sup>2 mod 11", "using square_mod_lower[of 11 xa \"xa\\<^sup>2 mod 11\"]\n      ex_nat_less_eq[of 11 \"\\<lambda>x. xa\\<^sup>2 mod 11 = x\\<^sup>2 mod 11\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < 11; xa\\<^sup>2 mod 11 = xa\\<^sup>2 mod 11\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q'<11. q'\\<^sup>2 mod 11 = xa\\<^sup>2 mod 11\n  (\\<exists>m<11. xa\\<^sup>2 mod 11 = m\\<^sup>2 mod 11) =\n  (\\<exists>m\\<in>{0..<11}. xa\\<^sup>2 mod 11 = m\\<^sup>2 mod 11)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{..<11}. xa\\<^sup>2 mod 11 = x\\<^sup>2 mod 11", "by auto"], ["proof (state)\nthis:\n  \\<exists>x\\<in>{..<11}. xa\\<^sup>2 mod 11 = x\\<^sup>2 mod 11\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma q63_upto_def: \"q63 = (\\<lambda>k. k\\<^sup>2 mod 63) ` {..<63}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q63 = (\\<lambda>k. k\\<^sup>2 mod 63) ` {..<63}", "by (simp add: q63_def lessThan_nat_numeral lessThan_Suc insert_commute)"], ["", "lemma q63_infinite_def: \"q63 = (\\<lambda>k. k\\<^sup>2 mod 63) ` {0..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q63 = (\\<lambda>k. k\\<^sup>2 mod 63) ` {0..}", "unfolding q63_upto_def image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. \\<exists>x\\<in>{..<63}. y = x\\<^sup>2 mod 63} =\n    {y. \\<exists>x\\<in>{0..}. y = x\\<^sup>2 mod 63}", "proof (auto, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. \\<exists>x\\<in>{..<63}. xa\\<^sup>2 mod 63 = x\\<^sup>2 mod 63", "case (1 xa)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>xa. \\<exists>x\\<in>{..<63}. xa\\<^sup>2 mod 63 = x\\<^sup>2 mod 63", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{..<63}. xa\\<^sup>2 mod 63 = x\\<^sup>2 mod 63", "using square_mod_lower[of 63 xa \"xa\\<^sup>2 mod 63\"]\n      ex_nat_less_eq[of 63 \"\\<lambda>x. xa\\<^sup>2 mod 63 = x\\<^sup>2 mod 63\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < 63; xa\\<^sup>2 mod 63 = xa\\<^sup>2 mod 63\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q'<63. q'\\<^sup>2 mod 63 = xa\\<^sup>2 mod 63\n  (\\<exists>m<63. xa\\<^sup>2 mod 63 = m\\<^sup>2 mod 63) =\n  (\\<exists>m\\<in>{0..<63}. xa\\<^sup>2 mod 63 = m\\<^sup>2 mod 63)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{..<63}. xa\\<^sup>2 mod 63 = x\\<^sup>2 mod 63", "by auto"], ["proof (state)\nthis:\n  \\<exists>x\\<in>{..<63}. xa\\<^sup>2 mod 63 = x\\<^sup>2 mod 63\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma q64_upto_def: \"q64 = (\\<lambda>k. k\\<^sup>2 mod 64) ` {..<64}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q64 = (\\<lambda>k. k\\<^sup>2 mod 64) ` {..<64}", "by (simp add: q64_def lessThan_nat_numeral lessThan_Suc insert_commute)"], ["", "lemma q64_infinite_def: \"q64 = (\\<lambda>k. k\\<^sup>2 mod 64) ` {0..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q64 = (\\<lambda>k. k\\<^sup>2 mod 64) ` {0..}", "unfolding q64_upto_def image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. \\<exists>x\\<in>{..<64}. y = x\\<^sup>2 mod 64} =\n    {y. \\<exists>x\\<in>{0..}. y = x\\<^sup>2 mod 64}", "proof (auto, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. \\<exists>x\\<in>{..<64}. xa\\<^sup>2 mod 64 = x\\<^sup>2 mod 64", "case (1 xa)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>xa. \\<exists>x\\<in>{..<64}. xa\\<^sup>2 mod 64 = x\\<^sup>2 mod 64", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{..<64}. xa\\<^sup>2 mod 64 = x\\<^sup>2 mod 64", "using square_mod_lower[of 64 xa \"xa\\<^sup>2 mod 64\"]\n      ex_nat_less_eq[of 64 \"\\<lambda>x. xa\\<^sup>2 mod 64 = x\\<^sup>2 mod 64\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < 64; xa\\<^sup>2 mod 64 = xa\\<^sup>2 mod 64\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q'<64. q'\\<^sup>2 mod 64 = xa\\<^sup>2 mod 64\n  (\\<exists>m<64. xa\\<^sup>2 mod 64 = m\\<^sup>2 mod 64) =\n  (\\<exists>m\\<in>{0..<64}. xa\\<^sup>2 mod 64 = m\\<^sup>2 mod 64)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{..<64}. xa\\<^sup>2 mod 64 = x\\<^sup>2 mod 64", "by auto"], ["proof (state)\nthis:\n  \\<exists>x\\<in>{..<64}. xa\\<^sup>2 mod 64 = x\\<^sup>2 mod 64\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma q65_upto_def: \"q65 = (\\<lambda>k. k\\<^sup>2 mod 65) ` {..<65}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q65 = (\\<lambda>k. k\\<^sup>2 mod 65) ` {..<65}", "by (simp add: q65_def lessThan_nat_numeral lessThan_Suc insert_commute)"], ["", "lemma q65_infinite_def: \"q65 = (\\<lambda>k. k\\<^sup>2 mod 65) ` {0..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q65 = (\\<lambda>k. k\\<^sup>2 mod 65) ` {0..}", "unfolding q65_upto_def image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. \\<exists>x\\<in>{..<65}. y = x\\<^sup>2 mod 65} =\n    {y. \\<exists>x\\<in>{0..}. y = x\\<^sup>2 mod 65}", "proof (auto, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. \\<exists>x\\<in>{..<65}. xa\\<^sup>2 mod 65 = x\\<^sup>2 mod 65", "case (1 xa)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>xa. \\<exists>x\\<in>{..<65}. xa\\<^sup>2 mod 65 = x\\<^sup>2 mod 65", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{..<65}. xa\\<^sup>2 mod 65 = x\\<^sup>2 mod 65", "using square_mod_lower[of 65 xa \"xa\\<^sup>2 mod 65\"]\n      ex_nat_less_eq[of 65 \"\\<lambda>x. xa\\<^sup>2 mod 65 = x\\<^sup>2 mod 65\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < 65; xa\\<^sup>2 mod 65 = xa\\<^sup>2 mod 65\\<rbrakk>\n  \\<Longrightarrow> \\<exists>q'<65. q'\\<^sup>2 mod 65 = xa\\<^sup>2 mod 65\n  (\\<exists>m<65. xa\\<^sup>2 mod 65 = m\\<^sup>2 mod 65) =\n  (\\<exists>m\\<in>{0..<65}. xa\\<^sup>2 mod 65 = m\\<^sup>2 mod 65)\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>{..<65}. xa\\<^sup>2 mod 65 = x\\<^sup>2 mod 65", "by auto"], ["proof (state)\nthis:\n  \\<exists>x\\<in>{..<65}. xa\\<^sup>2 mod 65 = x\\<^sup>2 mod 65\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma square_mod_existence:\n  fixes n k :: nat\n  assumes \"\\<exists>q. q\\<^sup>2 = n\"\n  shows \"\\<exists>q. n mod k = q\\<^sup>2 mod k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q. n mod k = q\\<^sup>2 mod k", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>q. q\\<^sup>2 = n\n\ngoal (1 subgoal):\n 1. \\<exists>q. n mod k = q\\<^sup>2 mod k", "by auto"], ["", "theorem square_test_correct: \"square_test n \\<longleftrightarrow> is_square n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. square_test n = is_square n", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> square_test n = is_square n\n 2. \\<not> ?P \\<Longrightarrow> square_test n = is_square n", "assume \"is_square n\""], ["proof (state)\nthis:\n  is_square n\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> square_test n = is_square n\n 2. \\<not> ?P \\<Longrightarrow> square_test n = is_square n", "hence  rhs: \"\\<exists>q. q\\<^sup>2 = n\""], ["proof (prove)\nusing this:\n  is_square n\n\ngoal (1 subgoal):\n 1. \\<exists>q. q\\<^sup>2 = n", "by (auto elim: is_nth_powerE)"], ["proof (state)\nthis:\n  \\<exists>q. q\\<^sup>2 = n\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> square_test n = is_square n\n 2. \\<not> ?P \\<Longrightarrow> square_test n = is_square n", "note sq_mod = square_mod_existence[OF this]"], ["proof (state)\nthis:\n  \\<exists>q. n mod ?k = q\\<^sup>2 mod ?k\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> square_test n = is_square n\n 2. \\<not> ?P \\<Longrightarrow> square_test n = is_square n", "have q64_member: \"n mod 64 \\<in> q64\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n mod 64 \\<in> q64", "using sq_mod[of 64]"], ["proof (prove)\nusing this:\n  \\<exists>q. n mod 64 = q\\<^sup>2 mod 64\n\ngoal (1 subgoal):\n 1. n mod 64 \\<in> q64", "unfolding q64_infinite_def image_def"], ["proof (prove)\nusing this:\n  \\<exists>q. n mod 64 = q\\<^sup>2 mod 64\n\ngoal (1 subgoal):\n 1. n mod 64 \\<in> {y. \\<exists>x\\<in>{0..}. y = x\\<^sup>2 mod 64}", "by simp"], ["proof (state)\nthis:\n  n mod 64 \\<in> q64\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> square_test n = is_square n\n 2. \\<not> ?P \\<Longrightarrow> square_test n = is_square n", "let ?r = \"n mod 45045\""], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> square_test n = is_square n\n 2. \\<not> ?P \\<Longrightarrow> square_test n = is_square n", "have \"11 dvd (45045::nat)\" \"63 dvd (45045::nat)\" \"65 dvd (45045::nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 11 dvd 45045 &&& 63 dvd 45045 &&& 65 dvd 45045", "by force+"], ["proof (state)\nthis:\n  11 dvd 45045\n  63 dvd 45045\n  65 dvd 45045\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> square_test n = is_square n\n 2. \\<not> ?P \\<Longrightarrow> square_test n = is_square n", "then"], ["proof (chain)\npicking this:\n  11 dvd 45045\n  63 dvd 45045\n  65 dvd 45045", "have mod_45045: \"?r mod 11 = n mod 11\" \"?r mod 63 = n mod 63\" \"?r mod 65 = n mod 65\""], ["proof (prove)\nusing this:\n  11 dvd 45045\n  63 dvd 45045\n  65 dvd 45045\n\ngoal (1 subgoal):\n 1. n mod 45045 mod 11 = n mod 11 &&&\n    n mod 45045 mod 63 = n mod 63 &&& n mod 45045 mod 65 = n mod 65", "using mod_mod_cancel[of _ 45045 n]"], ["proof (prove)\nusing this:\n  11 dvd 45045\n  63 dvd 45045\n  65 dvd 45045\n  ?c dvd 45045 \\<Longrightarrow> n mod 45045 mod ?c = n mod ?c\n\ngoal (1 subgoal):\n 1. n mod 45045 mod 11 = n mod 11 &&&\n    n mod 45045 mod 63 = n mod 63 &&& n mod 45045 mod 65 = n mod 65", "by presburger+"], ["proof (state)\nthis:\n  n mod 45045 mod 11 = n mod 11\n  n mod 45045 mod 63 = n mod 63\n  n mod 45045 mod 65 = n mod 65\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> square_test n = is_square n\n 2. \\<not> ?P \\<Longrightarrow> square_test n = is_square n", "then"], ["proof (chain)\npicking this:\n  n mod 45045 mod 11 = n mod 11\n  n mod 45045 mod 63 = n mod 63\n  n mod 45045 mod 65 = n mod 65", "have \"?r mod 11 \\<in> q11\" \"?r mod 63 \\<in> q63\" \"?r mod 65 \\<in> q65\""], ["proof (prove)\nusing this:\n  n mod 45045 mod 11 = n mod 11\n  n mod 45045 mod 63 = n mod 63\n  n mod 45045 mod 65 = n mod 65\n\ngoal (1 subgoal):\n 1. n mod 45045 mod 11 \\<in> q11 &&&\n    n mod 45045 mod 63 \\<in> q63 &&& n mod 45045 mod 65 \\<in> q65", "using sq_mod[of 11] sq_mod[of 63] sq_mod[of 65]"], ["proof (prove)\nusing this:\n  n mod 45045 mod 11 = n mod 11\n  n mod 45045 mod 63 = n mod 63\n  n mod 45045 mod 65 = n mod 65\n  \\<exists>q. n mod 11 = q\\<^sup>2 mod 11\n  \\<exists>q. n mod 63 = q\\<^sup>2 mod 63\n  \\<exists>q. n mod 65 = q\\<^sup>2 mod 65\n\ngoal (1 subgoal):\n 1. n mod 45045 mod 11 \\<in> q11 &&&\n    n mod 45045 mod 63 \\<in> q63 &&& n mod 45045 mod 65 \\<in> q65", "unfolding q11_infinite_def q63_infinite_def q65_infinite_def image_def mod_45045"], ["proof (prove)\nusing this:\n  n mod 11 = n mod 11\n  n mod 63 = n mod 63\n  n mod 65 = n mod 65\n  \\<exists>q. n mod 11 = q\\<^sup>2 mod 11\n  \\<exists>q. n mod 63 = q\\<^sup>2 mod 63\n  \\<exists>q. n mod 65 = q\\<^sup>2 mod 65\n\ngoal (1 subgoal):\n 1. n mod 11 \\<in> {y. \\<exists>x\\<in>{0..}. y = x\\<^sup>2 mod 11} &&&\n    n mod 63 \\<in> {y. \\<exists>x\\<in>{0..}. y = x\\<^sup>2 mod 63} &&&\n    n mod 65 \\<in> {y. \\<exists>x\\<in>{0..}. y = x\\<^sup>2 mod 65}", "by fast+"], ["proof (state)\nthis:\n  n mod 45045 mod 11 \\<in> q11\n  n mod 45045 mod 63 \\<in> q63\n  n mod 45045 mod 65 \\<in> q65\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> square_test n = is_square n\n 2. \\<not> ?P \\<Longrightarrow> square_test n = is_square n", "then"], ["proof (chain)\npicking this:\n  n mod 45045 mod 11 \\<in> q11\n  n mod 45045 mod 63 \\<in> q63\n  n mod 45045 mod 65 \\<in> q65", "show ?thesis"], ["proof (prove)\nusing this:\n  n mod 45045 mod 11 \\<in> q11\n  n mod 45045 mod 63 \\<in> q63\n  n mod 45045 mod 65 \\<in> q65\n\ngoal (1 subgoal):\n 1. square_test n = is_square n", "unfolding square_test_def Let_def"], ["proof (prove)\nusing this:\n  n mod 45045 mod 11 \\<in> q11\n  n mod 45045 mod 63 \\<in> q63\n  n mod 45045 mod 65 \\<in> q65\n\ngoal (1 subgoal):\n 1. (n mod 64 \\<in> q64 \\<and>\n     n mod 45045 mod 63 \\<in> q63 \\<and>\n     n mod 45045 mod 65 \\<in> q65 \\<and>\n     n mod 45045 mod 11 \\<in> q11 \\<and> n = (Discrete.sqrt n)\\<^sup>2) =\n    is_square n", "using q64_member rhs"], ["proof (prove)\nusing this:\n  n mod 45045 mod 11 \\<in> q11\n  n mod 45045 mod 63 \\<in> q63\n  n mod 45045 mod 65 \\<in> q65\n  n mod 64 \\<in> q64\n  \\<exists>q. q\\<^sup>2 = n\n\ngoal (1 subgoal):\n 1. (n mod 64 \\<in> q64 \\<and>\n     n mod 45045 mod 63 \\<in> q63 \\<and>\n     n mod 45045 mod 65 \\<in> q65 \\<and>\n     n mod 45045 mod 11 \\<in> q11 \\<and> n = (Discrete.sqrt n)\\<^sup>2) =\n    is_square n", "by auto"], ["proof (state)\nthis:\n  square_test n = is_square n\n\ngoal (1 subgoal):\n 1. \\<not> is_square n \\<Longrightarrow> square_test n = is_square n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_square n \\<Longrightarrow> square_test n = is_square n", "assume not_rhs: \"\\<not>is_square n\""], ["proof (state)\nthis:\n  \\<not> is_square n\n\ngoal (1 subgoal):\n 1. \\<not> is_square n \\<Longrightarrow> square_test n = is_square n", "hence \"\\<nexists>q. q\\<^sup>2 = n\""], ["proof (prove)\nusing this:\n  \\<not> is_square n\n\ngoal (1 subgoal):\n 1. \\<nexists>q. q\\<^sup>2 = n", "by auto"], ["proof (state)\nthis:\n  \\<nexists>q. q\\<^sup>2 = n\n\ngoal (1 subgoal):\n 1. \\<not> is_square n \\<Longrightarrow> square_test n = is_square n", "then"], ["proof (chain)\npicking this:\n  \\<nexists>q. q\\<^sup>2 = n", "have \"(Discrete.sqrt n)\\<^sup>2 \\<noteq> n\""], ["proof (prove)\nusing this:\n  \\<nexists>q. q\\<^sup>2 = n\n\ngoal (1 subgoal):\n 1. (Discrete.sqrt n)\\<^sup>2 \\<noteq> n", "by simp"], ["proof (state)\nthis:\n  (Discrete.sqrt n)\\<^sup>2 \\<noteq> n\n\ngoal (1 subgoal):\n 1. \\<not> is_square n \\<Longrightarrow> square_test n = is_square n", "then"], ["proof (chain)\npicking this:\n  (Discrete.sqrt n)\\<^sup>2 \\<noteq> n", "show ?thesis"], ["proof (prove)\nusing this:\n  (Discrete.sqrt n)\\<^sup>2 \\<noteq> n\n\ngoal (1 subgoal):\n 1. square_test n = is_square n", "unfolding square_test_def"], ["proof (prove)\nusing this:\n  (Discrete.sqrt n)\\<^sup>2 \\<noteq> n\n\ngoal (1 subgoal):\n 1. (n mod 64 \\<in> q64 \\<and>\n     (let r = n mod 45045\n      in r mod 63 \\<in> q63 \\<and>\n         r mod 65 \\<in> q65 \\<and>\n         r mod 11 \\<in> q11 \\<and> n = (Discrete.sqrt n)\\<^sup>2)) =\n    is_square n", "by (auto simp: is_nth_power_def)"], ["proof (state)\nthis:\n  square_test n = is_square n\n\ngoal:\nNo subgoals!", "qed"], ["", "definition get_nat_sqrt :: \"nat \\<Rightarrow> nat option\" \n  where \"get_nat_sqrt n = (if is_square n then Some (Discrete.sqrt n) else None)\""], ["", "lemma get_nat_sqrt_code [code]:\n  \"get_nat_sqrt n = \n    (if IArray.sub q64_array (n mod 64) \\<and> (let r = n mod 45045 in\n           IArray.sub q63_array (r mod 63) \\<and> \n           IArray.sub q65_array (r mod 65) \\<and>\n           IArray.sub q11_array (r mod 11)) then\n       (let x = Discrete.sqrt n in if x\\<^sup>2 = n then Some x else None) else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_nat_sqrt n =\n    (if q64_array !! (n mod 64) \\<and>\n        (let r = n mod 45045\n         in q63_array !! (r mod 63) \\<and>\n            q65_array !! (r mod 65) \\<and> q11_array !! (r mod 11))\n     then let x = Discrete.sqrt n in if x\\<^sup>2 = n then Some x else None\n     else None)", "unfolding get_nat_sqrt_def square_test_correct [symmetric] square_test_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if n mod 64 \\<in> q64 \\<and>\n        (let r = n mod 45045\n         in r mod 63 \\<in> q63 \\<and>\n            r mod 65 \\<in> q65 \\<and>\n            r mod 11 \\<in> q11 \\<and> n = (Discrete.sqrt n)\\<^sup>2)\n     then Some (Discrete.sqrt n) else None) =\n    (if q64_array !! (n mod 64) \\<and>\n        (let r = n mod 45045\n         in q63_array !! (r mod 63) \\<and>\n            q65_array !! (r mod 65) \\<and> q11_array !! (r mod 11))\n     then let x = Discrete.sqrt n in if x\\<^sup>2 = n then Some x else None\n     else None)", "using in_q11_code [symmetric] in_q63_code [symmetric] \n        in_q64_code [symmetric] in_q65_code [symmetric]"], ["proof (prove)\nusing this:\n  q11_array !! (?x mod 11) = (?x mod 11 \\<in> q11)\n  q63_array !! (?x mod 63) = (?x mod 63 \\<in> q63)\n  q64_array !! (?x mod 64) = (?x mod 64 \\<in> q64)\n  q65_array !! (?x mod 65) = (?x mod 65 \\<in> q65)\n\ngoal (1 subgoal):\n 1. (if n mod 64 \\<in> q64 \\<and>\n        (let r = n mod 45045\n         in r mod 63 \\<in> q63 \\<and>\n            r mod 65 \\<in> q65 \\<and>\n            r mod 11 \\<in> q11 \\<and> n = (Discrete.sqrt n)\\<^sup>2)\n     then Some (Discrete.sqrt n) else None) =\n    (if q64_array !! (n mod 64) \\<and>\n        (let r = n mod 45045\n         in q63_array !! (r mod 63) \\<and>\n            q65_array !! (r mod 65) \\<and> q11_array !! (r mod 11))\n     then let x = Discrete.sqrt n in if x\\<^sup>2 = n then Some x else None\n     else None)", "by (auto split: if_splits simp: Let_def )"], ["", "end"]]}