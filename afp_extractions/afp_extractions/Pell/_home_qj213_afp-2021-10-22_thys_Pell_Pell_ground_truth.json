{"file_name": "/home/qj213/afp-2021-10-22/thys/Pell/Pell.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Pell", "problem_names": ["lemma gcd_int_nonpos_iff [simp]: \"gcd x (y :: int) \\<le> 0 \\<longleftrightarrow> x = 0 \\<and> y = 0\"", "lemma minus_in_Ints_iff [simp]:\n  \"-x \\<in> \\<int> \\<longleftrightarrow> x \\<in> \\<int>\"", "lemma nonneg_sqrt_nat_or_irrat:\n  assumes \"x ^ 2 = real a\" and \"x \\<ge> 0\"\n  shows   \"x \\<in> \\<nat> \\<or> x \\<notin> \\<rat>\"", "lemma pell_square_solution_nat_aux:\n  fixes x y :: nat\n  assumes \"D > 0\" and \"x ^ 2 = 1 + D * y ^ 2\"\n  shows \"(x, y) = (1, 0)\"", "lemma pell_square_solution_int_aux:\n  fixes x y :: int\n  assumes \"D > 0\" and \"x ^ 2 = 1 + D * y ^ 2\"\n  shows \"x \\<in> {-1, 1} \\<and> y = 0\"", "lemma pell_square_solution_nat_iff:\n  fixes x y :: nat\n  shows \"x ^ 2 = 1 + D * y ^ 2  \\<longleftrightarrow>  x = 1 \\<and> (D = 0 \\<or> y = 0)\"", "lemma pell_square_solution_int_iff:\n  fixes x y :: int\n  shows \"x ^ 2 = 1 + D * y ^ 2  \\<longleftrightarrow>  x \\<in> {-1, 1} \\<and> (D = 0 \\<or> y = 0)\"", "lemma pell_approximation_lemma:\n  fixes s :: nat and x :: real\n  assumes s: \"s > 0\"\n  shows \"\\<exists>u::nat. \\<exists>t::int. u > 0 \\<and> coprime u t \\<and> 1 / s \\<in> {\\<bar>t - u * x\\<bar><..1 / u}\"", "lemma D_gt_1: \"D > 1\"", "lemma D_pos: \"D > 0\"", "theorem pell_solution_exists: \"\\<exists>(x::nat) (y::nat). y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2\"", "lemma nontriv_solution_altdef: \"nontriv_solution z \\<longleftrightarrow> solution z \\<and> z \\<noteq> (1, 0)\"", "lemma solution_trivial_nat [simp, intro]: \"solution (Suc 0, 0)\"", "lemma solution_trivial [simp, intro]: \"solution (1, 0)\"", "lemma solution_uminus_left [simp]: \"solution (-x, y :: 'a :: comm_ring_1) \\<longleftrightarrow> solution (x, y)\"", "lemma solution_uminus_right [simp]: \"solution (x, -y :: 'a :: comm_ring_1) \\<longleftrightarrow> solution (x, y)\"", "lemma solution_0_snd_nat_iff [simp]: \"solution (a :: nat, 0) \\<longleftrightarrow> a = 1\"", "lemma solution_0_snd_iff [simp]: \"solution (a :: 'a :: idom, 0) \\<longleftrightarrow> a \\<in> {1, -1}\"", "lemma no_solution_0_fst_nat [simp]: \"\\<not>solution (0, b :: nat)\"", "lemma no_solution_0_fst_int [simp]: \"\\<not>solution (0, b :: int)\"", "lemma solution_of_nat_of_nat [simp]:\n  \"solution (of_nat a, of_nat b :: 'a :: {comm_ring_1, ring_char_0}) \\<longleftrightarrow> solution (a, b)\"", "lemma solution_of_nat_of_nat' [simp]:\n  \"solution (case z of (a, b) \\<Rightarrow> (of_nat a, of_nat b :: 'a :: {comm_ring_1, ring_char_0})) \\<longleftrightarrow>\n     solution z\"", "lemma solution_nat_abs_nat_abs [simp]:\n  \"solution (nat \\<bar>x\\<bar>, nat \\<bar>y\\<bar>) \\<longleftrightarrow> solution (x, y)\"", "lemma nontriv_solution_of_nat_of_nat [simp]:\n  \"nontriv_solution (of_nat a, of_nat b :: 'a :: {comm_ring_1, ring_char_0}) \\<longleftrightarrow> nontriv_solution (a, b)\"", "lemma nontriv_solution_of_nat_of_nat' [simp]:\n  \"nontriv_solution (case z of (a, b) \\<Rightarrow> (of_nat a, of_nat b :: 'a :: {comm_ring_1, ring_char_0})) \\<longleftrightarrow>\n     nontriv_solution z\"", "lemma nontriv_solution_imp_solution [dest]: \"nontriv_solution z \\<Longrightarrow> solution z\"", "lemma pell_valuation_nonneg [simp]: \"fst z \\<ge> 0 \\<Longrightarrow> snd z \\<ge> 0 \\<Longrightarrow> pell_valuation z \\<ge> 0\"", "lemma pell_valuation_uminus_uminus [simp]: \"pell_valuation (-x, -y) = -pell_valuation (x, y)\"", "lemma pell_valuation_eq_iff [simp]:\n  \"pell_valuation z1 = pell_valuation z2 \\<longleftrightarrow> z1 = z2\"", "lemma solutions_linorder:\n  fixes a b x y :: nat\n  assumes \"solution (a, b)\" \"solution (x, y)\"\n  shows   \"a \\<le> x \\<and> b \\<le> y \\<or> a \\<ge> x \\<and> b \\<ge> y\"", "lemma solutions_linorder_strict:\n  fixes a b x y :: nat\n  assumes \"solution (a, b)\" \"solution (x, y)\"\n  shows   \"(a, b) = (x, y) \\<or> a < x \\<and> b < y \\<or> a > x \\<and> b > y\"", "lemma solutions_le_iff_pell_valuation_le:\n  fixes a b x y :: nat\n  assumes \"solution (a, b)\" \"solution (x, y)\"\n  shows   \"a \\<le> x \\<and> b \\<le> y \\<longleftrightarrow> pell_valuation (a, b) \\<le> pell_valuation (x, y)\"", "lemma solutions_less_iff_pell_valuation_less:\n  fixes a b x y :: nat\n  assumes \"solution (a, b)\" \"solution (x, y)\"\n  shows   \"a < x \\<and> b < y \\<longleftrightarrow> pell_valuation (a, b) < pell_valuation (x, y)\"", "theorem fund_sol_is_arg_min:\n  \"is_arg_min (pell_valuation :: nat \\<times> nat \\<Rightarrow> real) nontriv_solution fund_sol\"", "lemma fund_sol_minimal'':\n  assumes \"nontriv_solution z\"\n  shows   \"fst fund_sol \\<le> fst z\" \"snd fund_sol \\<le> snd z\"", "lemma pell_cnj_snd_0 [simp]: \"snd z = 0 \\<Longrightarrow> pell_cnj z = z\"", "lemma pell_mul_commutes: \"pell_mul z1 z2 = pell_mul z2 z1\"", "lemma pell_mul_assoc: \"pell_mul z1 (pell_mul z2 z3) = pell_mul (pell_mul z1 z2) z3\"", "lemma pell_mul_trivial_left [simp]: \"pell_mul (1, 0) z = z\"", "lemma pell_mul_trivial_right [simp]: \"pell_mul z (1, 0) = z\"", "lemma pell_mul_trivial_left_nat [simp]: \"pell_mul (Suc 0, 0) z = z\"", "lemma pell_mul_trivial_right_nat [simp]: \"pell_mul z (Suc 0, 0) = z\"", "lemma pell_power_0 [simp]: \"pell_power z 0 = (1, 0)\"", "lemma pell_power_one [simp]: \"pell_power (1, 0) n = (1, 0)\"", "lemma pell_power_one_right [simp]: \"pell_power z 1 = z\"", "lemma pell_power_Suc: \"pell_power z (Suc n) = pell_mul z (pell_power z n)\"", "lemma pell_power_add: \"pell_power z (m + n) = pell_mul (pell_power z m) (pell_power z n)\"", "lemma pell_valuation_mult [simp]:\n  \"pell_valuation (pell_mul z1 z2) = pell_valuation z1 * pell_valuation z2\"", "lemma pell_valuation_mult_nat [simp]:\n  \"pell_valuation (case pell_mul z1 z2 of (a, b) \\<Rightarrow> (int a, int b)) =\n     pell_valuation z1 * pell_valuation z2\"", "lemma pell_valuation_trivial [simp]: \"pell_valuation (1, 0) = 1\"", "lemma pell_valuation_trivial_nat [simp]: \"pell_valuation (Suc 0, 0) = 1\"", "lemma pell_valuation_cnj: \"pell_valuation (pell_cnj z) = fst z - snd z * sqrt D\"", "lemma pell_valuation_snd_0 [simp]: \"pell_valuation (a, 0) = of_int a\"", "lemma pell_valuation_0_iff [simp]: \"pell_valuation z = 0 \\<longleftrightarrow> z = (0, 0)\"", "lemma pell_valuation_solution_pos_nat:\n  fixes z :: \"nat \\<times> nat\"\n  assumes \"solution z\"\n  shows   \"pell_valuation z > 0\"", "lemma\n  assumes \"solution z\"\n  shows   pell_mul_cnj_right: \"pell_mul z (pell_cnj z) = (1, 0)\"\n    and   pell_mul_cnj_left: \"pell_mul (pell_cnj z) z = (1, 0)\"", "lemma pell_valuation_cnj_solution:\n  fixes z :: \"nat \\<times> nat\"\n  assumes \"solution z\"\n  shows   \"pell_valuation (pell_cnj z) = 1 / pell_valuation z\"", "lemma pell_valuation_power [simp]: \"pell_valuation (pell_power z n) = pell_valuation z ^ n\"", "lemma pell_valuation_power_nat [simp]:\n  \"pell_valuation (case pell_power z n of (a, b) \\<Rightarrow> (int a, int b)) = pell_valuation z ^ n\"", "lemma pell_valuation_fund_sol_ge_2: \"pell_valuation fund_sol \\<ge> 2\"", "lemma solution_pell_mul [intro]:\n  assumes \"solution z1\" \"solution z2\"\n  shows   \"solution (pell_mul z1 z2)\"", "lemma solution_pell_cnj [intro]:\n  assumes \"solution z\"\n  shows   \"solution (pell_cnj z)\"", "lemma solution_pell_power [simp, intro]: \"solution z \\<Longrightarrow> solution (pell_power z n)\"", "lemma pell_mul_eq_trivial_nat_iff:\n  \"pell_mul z1 z2 = (Suc 0, 0) \\<longleftrightarrow> z1 = (Suc 0, 0) \\<and> z2 = (Suc 0, 0)\"", "lemma nontriv_solution_pell_nat_mul1:\n  \"solution (z1 :: nat \\<times> nat) \\<Longrightarrow> nontriv_solution z2 \\<Longrightarrow> nontriv_solution (pell_mul z1 z2)\"", "lemma nontriv_solution_pell_nat_mul2:\n  \"nontriv_solution (z1 :: nat \\<times> nat) \\<Longrightarrow> solution z2 \\<Longrightarrow> nontriv_solution (pell_mul z1 z2)\"", "lemma nontriv_solution_power_nat [intro]:\n  assumes \"nontriv_solution (z :: nat \\<times> nat)\" \"n > 0\"\n  shows   \"nontriv_solution (pell_power z n)\"", "lemma\n  assumes \"x > 0\" \"y > 0\" \"solution (x, y)\"\n  shows   pell_valuation_pos_pos: \"pell_valuation (x, y) > 1\"\n    and   pell_valuation_pos_neg_aux: \"pell_valuation (x, -y) \\<in> {0<..<1}\"", "lemma pell_valuation_pos_neg:\n  assumes \"x > 0\" \"y < 0\" \"solution (x, y)\"\n  shows   \"pell_valuation (x, y) \\<in> {0<..<1}\"", "lemma pell_valuation_neg_neg:\n  assumes \"x < 0\" \"y < 0\" \"solution (x, y)\"\n  shows   \"pell_valuation (x, y) < -1\"", "lemma pell_valuation_neg_pos:\n  assumes \"x < 0\" \"y > 0\" \"solution (x, y)\"\n  shows   \"pell_valuation (x, y) \\<in> {-1<..<0}\"", "lemma pell_valuation_solution_gt1D:\n  assumes \"solution z\" \"pell_valuation z > 1\"\n  shows   \"fst z > 0 \\<and> snd z > 0\"", "lemma pell_valuation_nth_solution [simp]:\n  \"pell_valuation (nth_solution n) = pell_valuation fund_sol ^ n\"", "theorem nth_solution_inj: \"inj nth_solution\"", "theorem nth_solution_sound [intro]: \"solution (nth_solution n)\"", "theorem nth_solution_sound' [intro]: \"n > 0 \\<Longrightarrow> nontriv_solution (nth_solution n)\"", "theorem nth_solution_complete:\n  fixes z :: \"nat \\<times> nat\"\n  assumes \"solution z\"\n  shows   \"z \\<in> range nth_solution\"", "lemma strict_mono_pell_valuation_nth_solution: \"strict_mono (pell_valuation \\<circ> nth_solution)\"", "lemma strict_mono_nth_solution:\n  \"strict_mono (fst \\<circ> nth_solution)\" \"strict_mono (snd \\<circ> nth_solution)\"", "lemma pell_square_minus1: \"pell (a\\<^sup>2 - Suc 0)\"", "lemma fund_sol_square_minus1: \"fund_sol = (a, 1)\"", "theorem pell_solutions:\n fixes D :: nat\n assumes \"\\<nexists>k. D = k\\<^sup>2\"\n obtains x\\<^sub>0 y\\<^sub>0 :: nat\n where   \"\\<forall>(x::int) (y::int).\n            x\\<^sup>2 - D * y\\<^sup>2 = 1 \\<longleftrightarrow>\n            (\\<exists>n::nat. nat \\<bar>x\\<bar> + sqrt D * nat \\<bar>y\\<bar> = (x\\<^sub>0 + sqrt D * y\\<^sub>0) ^ n)\""], "translations": [["", "lemma gcd_int_nonpos_iff [simp]: \"gcd x (y :: int) \\<le> 0 \\<longleftrightarrow> x = 0 \\<and> y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gcd x y \\<le> 0) = (x = 0 \\<and> y = 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. gcd x y \\<le> 0 \\<Longrightarrow> x = 0 \\<and> y = 0\n 2. x = 0 \\<and> y = 0 \\<Longrightarrow> gcd x y \\<le> 0", "assume \"gcd x y \\<le> 0\""], ["proof (state)\nthis:\n  gcd x y \\<le> 0\n\ngoal (2 subgoals):\n 1. gcd x y \\<le> 0 \\<Longrightarrow> x = 0 \\<and> y = 0\n 2. x = 0 \\<and> y = 0 \\<Longrightarrow> gcd x y \\<le> 0", "with gcd_ge_0_int[of x y]"], ["proof (chain)\npicking this:\n  0 \\<le> gcd x y\n  gcd x y \\<le> 0", "have \"gcd x y = 0\""], ["proof (prove)\nusing this:\n  0 \\<le> gcd x y\n  gcd x y \\<le> 0\n\ngoal (1 subgoal):\n 1. gcd x y = 0", "by linarith"], ["proof (state)\nthis:\n  gcd x y = 0\n\ngoal (2 subgoals):\n 1. gcd x y \\<le> 0 \\<Longrightarrow> x = 0 \\<and> y = 0\n 2. x = 0 \\<and> y = 0 \\<Longrightarrow> gcd x y \\<le> 0", "thus \"x = 0 \\<and> y = 0\""], ["proof (prove)\nusing this:\n  gcd x y = 0\n\ngoal (1 subgoal):\n 1. x = 0 \\<and> y = 0", "by auto"], ["proof (state)\nthis:\n  x = 0 \\<and> y = 0\n\ngoal (1 subgoal):\n 1. x = 0 \\<and> y = 0 \\<Longrightarrow> gcd x y \\<le> 0", "qed auto"], ["", "lemma minus_in_Ints_iff [simp]:\n  \"-x \\<in> \\<int> \\<longleftrightarrow> x \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- x \\<in> \\<int>) = (x \\<in> \\<int>)", "using Ints_minus[of x] Ints_minus[of \"-x\"]"], ["proof (prove)\nusing this:\n  x \\<in> \\<int> \\<Longrightarrow> - x \\<in> \\<int>\n  - x \\<in> \\<int> \\<Longrightarrow> - (- x) \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (- x \\<in> \\<int>) = (x \\<in> \\<int>)", "by auto"], ["", "text \\<open>\n  A (positive) square root of a natural number is either a natural number or irrational.\n\\<close>"], ["", "lemma nonneg_sqrt_nat_or_irrat:\n  assumes \"x ^ 2 = real a\" and \"x \\<ge> 0\"\n  shows   \"x \\<in> \\<nat> \\<or> x \\<notin> \\<rat>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<nat> \\<or> x \\<notin> \\<rat>", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> \\<nat>; x \\<in> \\<rat>\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"x \\<notin> \\<nat>\" and \"x \\<in> \\<rat>\""], ["proof (state)\nthis:\n  x \\<notin> \\<nat>\n  x \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> \\<nat>; x \\<in> \\<rat>\\<rbrakk>\n    \\<Longrightarrow> False", "from Rats_abs_nat_div_natE[OF this(2)]"], ["proof (chain)\npicking this:\n  (\\<And>m n.\n      \\<lbrakk>n \\<noteq> 0; \\<bar>x\\<bar> = real m / real n;\n       coprime m n\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain p q :: nat where q_nz [simp]: \"q \\<noteq> 0\" and \"abs x = p / q\" and coprime: \"coprime p q\""], ["proof (prove)\nusing this:\n  (\\<And>m n.\n      \\<lbrakk>n \\<noteq> 0; \\<bar>x\\<bar> = real m / real n;\n       coprime m n\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>q p.\n        \\<lbrakk>q \\<noteq> 0; \\<bar>x\\<bar> = real p / real q;\n         coprime p q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  q \\<noteq> 0\n  \\<bar>x\\<bar> = real p / real q\n  coprime p q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> \\<nat>; x \\<in> \\<rat>\\<rbrakk>\n    \\<Longrightarrow> False", "with \\<open>x \\<ge> 0\\<close>"], ["proof (chain)\npicking this:\n  0 \\<le> x\n  q \\<noteq> 0\n  \\<bar>x\\<bar> = real p / real q\n  coprime p q", "have x: \"x = p / q\""], ["proof (prove)\nusing this:\n  0 \\<le> x\n  q \\<noteq> 0\n  \\<bar>x\\<bar> = real p / real q\n  coprime p q\n\ngoal (1 subgoal):\n 1. x = real p / real q", "by simp"], ["proof (state)\nthis:\n  x = real p / real q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> \\<nat>; x \\<in> \\<rat>\\<rbrakk>\n    \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  x\\<^sup>2 = real a\n  0 \\<le> x\n  x = real p / real q", "have \"real (q ^ 2) * real a = real (p ^ 2)\""], ["proof (prove)\nusing this:\n  x\\<^sup>2 = real a\n  0 \\<le> x\n  x = real p / real q\n\ngoal (1 subgoal):\n 1. real (q\\<^sup>2) * real a = real (p\\<^sup>2)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  real (q\\<^sup>2) * real a = real (p\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> \\<nat>; x \\<in> \\<rat>\\<rbrakk>\n    \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  real (q\\<^sup>2) * real a = real (p\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> \\<nat>; x \\<in> \\<rat>\\<rbrakk>\n    \\<Longrightarrow> False", "have \"real (q ^ 2) * real a = real (q ^ 2 * a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (q\\<^sup>2) * real a = real (q\\<^sup>2 * a)", "by simp"], ["proof (state)\nthis:\n  real (q\\<^sup>2) * real a = real (q\\<^sup>2 * a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> \\<nat>; x \\<in> \\<rat>\\<rbrakk>\n    \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  real (q\\<^sup>2 * a) = real (p\\<^sup>2)", "have \"p ^ 2 = q ^ 2 * a\""], ["proof (prove)\nusing this:\n  real (q\\<^sup>2 * a) = real (p\\<^sup>2)\n\ngoal (1 subgoal):\n 1. p\\<^sup>2 = q\\<^sup>2 * a", "by (subst (asm) of_nat_eq_iff) auto"], ["proof (state)\nthis:\n  p\\<^sup>2 = q\\<^sup>2 * a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> \\<nat>; x \\<in> \\<rat>\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"q ^ 2 dvd p ^ 2\""], ["proof (prove)\nusing this:\n  p\\<^sup>2 = q\\<^sup>2 * a\n\ngoal (1 subgoal):\n 1. q\\<^sup>2 dvd p\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  q\\<^sup>2 dvd p\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> \\<nat>; x \\<in> \\<rat>\\<rbrakk>\n    \\<Longrightarrow> False", "hence \"q dvd p\""], ["proof (prove)\nusing this:\n  q\\<^sup>2 dvd p\\<^sup>2\n\ngoal (1 subgoal):\n 1. q dvd p", "by simp"], ["proof (state)\nthis:\n  q dvd p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> \\<nat>; x \\<in> \\<rat>\\<rbrakk>\n    \\<Longrightarrow> False", "with coprime"], ["proof (chain)\npicking this:\n  coprime p q\n  q dvd p", "have \"q = 1\""], ["proof (prove)\nusing this:\n  coprime p q\n  q dvd p\n\ngoal (1 subgoal):\n 1. q = 1", "by auto"], ["proof (state)\nthis:\n  q = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> \\<nat>; x \\<in> \\<rat>\\<rbrakk>\n    \\<Longrightarrow> False", "with x and \\<open>x \\<notin> \\<nat>\\<close>"], ["proof (chain)\npicking this:\n  x = real p / real q\n  x \\<notin> \\<nat>\n  q = 1", "show False"], ["proof (prove)\nusing this:\n  x = real p / real q\n  x \\<notin> \\<nat>\n  q = 1\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  A square root of a natural number is either an integer or irrational.\n\\<close>"], ["", "corollary sqrt_nat_or_irrat:\n  assumes \"x ^ 2 = real a\"\n  shows   \"x \\<in> \\<int> \\<or> x \\<notin> \\<rat>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<int> \\<or> x \\<notin> \\<rat>", "proof (cases \"x \\<ge> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> x \\<Longrightarrow> x \\<in> \\<int> \\<or> x \\<notin> \\<rat>\n 2. \\<not> 0 \\<le> x \\<Longrightarrow>\n    x \\<in> \\<int> \\<or> x \\<notin> \\<rat>", "case True"], ["proof (state)\nthis:\n  0 \\<le> x\n\ngoal (2 subgoals):\n 1. 0 \\<le> x \\<Longrightarrow> x \\<in> \\<int> \\<or> x \\<notin> \\<rat>\n 2. \\<not> 0 \\<le> x \\<Longrightarrow>\n    x \\<in> \\<int> \\<or> x \\<notin> \\<rat>", "with nonneg_sqrt_nat_or_irrat[OF assms this]"], ["proof (chain)\npicking this:\n  x \\<in> \\<nat> \\<or> x \\<notin> \\<rat>\n  0 \\<le> x", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> \\<nat> \\<or> x \\<notin> \\<rat>\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. x \\<in> \\<int> \\<or> x \\<notin> \\<rat>", "by (auto simp: Nats_altdef2)"], ["proof (state)\nthis:\n  x \\<in> \\<int> \\<or> x \\<notin> \\<rat>\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> x \\<Longrightarrow>\n    x \\<in> \\<int> \\<or> x \\<notin> \\<rat>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> x \\<Longrightarrow>\n    x \\<in> \\<int> \\<or> x \\<notin> \\<rat>", "case False"], ["proof (state)\nthis:\n  \\<not> 0 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> x \\<Longrightarrow>\n    x \\<in> \\<int> \\<or> x \\<notin> \\<rat>", "from assms"], ["proof (chain)\npicking this:\n  x\\<^sup>2 = real a", "have \"(-x) ^ 2 = real a\""], ["proof (prove)\nusing this:\n  x\\<^sup>2 = real a\n\ngoal (1 subgoal):\n 1. (- x)\\<^sup>2 = real a", "by simp"], ["proof (state)\nthis:\n  (- x)\\<^sup>2 = real a\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> x \\<Longrightarrow>\n    x \\<in> \\<int> \\<or> x \\<notin> \\<rat>", "moreover"], ["proof (state)\nthis:\n  (- x)\\<^sup>2 = real a\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> x \\<Longrightarrow>\n    x \\<in> \\<int> \\<or> x \\<notin> \\<rat>", "from False"], ["proof (chain)\npicking this:\n  \\<not> 0 \\<le> x", "have \"-x \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> x\n\ngoal (1 subgoal):\n 1. 0 \\<le> - x", "by simp"], ["proof (state)\nthis:\n  0 \\<le> - x\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> x \\<Longrightarrow>\n    x \\<in> \\<int> \\<or> x \\<notin> \\<rat>", "ultimately"], ["proof (chain)\npicking this:\n  (- x)\\<^sup>2 = real a\n  0 \\<le> - x", "have \"-x \\<in> \\<nat> \\<or> -x \\<notin> \\<rat>\""], ["proof (prove)\nusing this:\n  (- x)\\<^sup>2 = real a\n  0 \\<le> - x\n\ngoal (1 subgoal):\n 1. - x \\<in> \\<nat> \\<or> - x \\<notin> \\<rat>", "by (rule nonneg_sqrt_nat_or_irrat)"], ["proof (state)\nthis:\n  - x \\<in> \\<nat> \\<or> - x \\<notin> \\<rat>\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> x \\<Longrightarrow>\n    x \\<in> \\<int> \\<or> x \\<notin> \\<rat>", "thus ?thesis"], ["proof (prove)\nusing this:\n  - x \\<in> \\<nat> \\<or> - x \\<notin> \\<rat>\n\ngoal (1 subgoal):\n 1. x \\<in> \\<int> \\<or> x \\<notin> \\<rat>", "by (auto simp: Nats_altdef2)"], ["proof (state)\nthis:\n  x \\<in> \\<int> \\<or> x \\<notin> \\<rat>\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary sqrt_nat_or_irrat':\n  \"sqrt (real a) \\<in> \\<nat> \\<or> sqrt (real a) \\<notin> \\<rat>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (real a) \\<in> \\<nat> \\<or> sqrt (real a) \\<notin> \\<rat>", "using nonneg_sqrt_nat_or_irrat[of \"sqrt a\" a]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(sqrt (real a))\\<^sup>2 = real a; 0 \\<le> sqrt (real a)\\<rbrakk>\n  \\<Longrightarrow> sqrt (real a) \\<in> \\<nat> \\<or>\n                    sqrt (real a) \\<notin> \\<rat>\n\ngoal (1 subgoal):\n 1. sqrt (real a) \\<in> \\<nat> \\<or> sqrt (real a) \\<notin> \\<rat>", "by auto"], ["", "text \\<open>\n  The square root of a natural number \\<open>n\\<close> is again a natural number iff \\<open>n is a perfect square.\\<close>\n\\<close>"], ["", "corollary sqrt_nat_iff_is_square:\n  \"sqrt (real n) \\<in> \\<nat> \\<longleftrightarrow> is_square n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sqrt (real n) \\<in> \\<nat>) = is_square n", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. sqrt (real n) \\<in> \\<nat> \\<Longrightarrow> is_square n\n 2. is_square n \\<Longrightarrow> sqrt (real n) \\<in> \\<nat>", "assume \"sqrt (real n) \\<in> \\<nat>\""], ["proof (state)\nthis:\n  sqrt (real n) \\<in> \\<nat>\n\ngoal (2 subgoals):\n 1. sqrt (real n) \\<in> \\<nat> \\<Longrightarrow> is_square n\n 2. is_square n \\<Longrightarrow> sqrt (real n) \\<in> \\<nat>", "then"], ["proof (chain)\npicking this:\n  sqrt (real n) \\<in> \\<nat>", "obtain k where \"sqrt (real n) = real k\""], ["proof (prove)\nusing this:\n  sqrt (real n) \\<in> \\<nat>\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        sqrt (real n) = real k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: Nats_cases)"], ["proof (state)\nthis:\n  sqrt (real n) = real k\n\ngoal (2 subgoals):\n 1. sqrt (real n) \\<in> \\<nat> \\<Longrightarrow> is_square n\n 2. is_square n \\<Longrightarrow> sqrt (real n) \\<in> \\<nat>", "hence \"sqrt (real n) ^ 2 = real (k ^ 2)\""], ["proof (prove)\nusing this:\n  sqrt (real n) = real k\n\ngoal (1 subgoal):\n 1. (sqrt (real n))\\<^sup>2 = real (k\\<^sup>2)", "by (simp only: of_nat_power)"], ["proof (state)\nthis:\n  (sqrt (real n))\\<^sup>2 = real (k\\<^sup>2)\n\ngoal (2 subgoals):\n 1. sqrt (real n) \\<in> \\<nat> \\<Longrightarrow> is_square n\n 2. is_square n \\<Longrightarrow> sqrt (real n) \\<in> \\<nat>", "also"], ["proof (state)\nthis:\n  (sqrt (real n))\\<^sup>2 = real (k\\<^sup>2)\n\ngoal (2 subgoals):\n 1. sqrt (real n) \\<in> \\<nat> \\<Longrightarrow> is_square n\n 2. is_square n \\<Longrightarrow> sqrt (real n) \\<in> \\<nat>", "have \"sqrt (real n) ^ 2 = real n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sqrt (real n))\\<^sup>2 = real n", "by simp"], ["proof (state)\nthis:\n  (sqrt (real n))\\<^sup>2 = real n\n\ngoal (2 subgoals):\n 1. sqrt (real n) \\<in> \\<nat> \\<Longrightarrow> is_square n\n 2. is_square n \\<Longrightarrow> sqrt (real n) \\<in> \\<nat>", "finally"], ["proof (chain)\npicking this:\n  real n = real (k\\<^sup>2)", "have \"n = k ^ 2\""], ["proof (prove)\nusing this:\n  real n = real (k\\<^sup>2)\n\ngoal (1 subgoal):\n 1. n = k\\<^sup>2", "by (simp only: of_nat_eq_iff)"], ["proof (state)\nthis:\n  n = k\\<^sup>2\n\ngoal (2 subgoals):\n 1. sqrt (real n) \\<in> \\<nat> \\<Longrightarrow> is_square n\n 2. is_square n \\<Longrightarrow> sqrt (real n) \\<in> \\<nat>", "thus \"is_square n\""], ["proof (prove)\nusing this:\n  n = k\\<^sup>2\n\ngoal (1 subgoal):\n 1. is_square n", "by blast"], ["proof (state)\nthis:\n  is_square n\n\ngoal (1 subgoal):\n 1. is_square n \\<Longrightarrow> sqrt (real n) \\<in> \\<nat>", "qed (auto elim!: is_nth_powerE)"], ["", "corollary irrat_sqrt_nonsquare: \"\\<not>is_square n \\<Longrightarrow> sqrt (real n) \\<notin> \\<rat>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_square n \\<Longrightarrow> sqrt (real n) \\<notin> \\<rat>", "using sqrt_nat_or_irrat'[of n]"], ["proof (prove)\nusing this:\n  sqrt (real n) \\<in> \\<nat> \\<or> sqrt (real n) \\<notin> \\<rat>\n\ngoal (1 subgoal):\n 1. \\<not> is_square n \\<Longrightarrow> sqrt (real n) \\<notin> \\<rat>", "by (auto simp: sqrt_nat_iff_is_square)"], ["", "subsection \\<open>The case of a perfect square\\<close>"], ["", "text \\<open>\n  As we have noted, the case where \\<open>D\\<close> is a perfect square is trivial: In fact, we will\n  show that the only solutions in this case are the trivial solutions \\<open>(x, y) = (\\<plusminus>1, 0)\\<close> if\n  \\<open>D\\<close> is a non-zero perfect square, or \\<open>(\\<plusminus>1, y)\\<close> for arbitrary \\<open>y \\<in> \\<int>\\<close> if \\<open>D = 0\\<close>.\n\\<close>"], ["", "context\n  fixes D :: nat\n  assumes square_D: \"is_square D\"\nbegin"], ["", "lemma pell_square_solution_nat_aux:\n  fixes x y :: nat\n  assumes \"D > 0\" and \"x ^ 2 = 1 + D * y ^ 2\"\n  shows \"(x, y) = (1, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) = (1, 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x, y) = (1, 0)", "from assms"], ["proof (chain)\npicking this:\n  0 < D\n  x\\<^sup>2 = 1 + D * y\\<^sup>2", "have x_nz: \"x > 0\""], ["proof (prove)\nusing this:\n  0 < D\n  x\\<^sup>2 = 1 + D * y\\<^sup>2\n\ngoal (1 subgoal):\n 1. 0 < x", "by (auto intro!: Nat.gr0I)"], ["proof (state)\nthis:\n  0 < x\n\ngoal (1 subgoal):\n 1. (x, y) = (1, 0)", "from square_D"], ["proof (chain)\npicking this:\n  is_square D", "obtain d where [simp]: \"D = d\\<^sup>2\""], ["proof (prove)\nusing this:\n  is_square D\n\ngoal (1 subgoal):\n 1. (\\<And>d. D = d\\<^sup>2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: is_nth_powerE)"], ["proof (state)\nthis:\n  D = d\\<^sup>2\n\ngoal (1 subgoal):\n 1. (x, y) = (1, 0)", "have \"int x ^ 2 = int (x ^ 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (int x)\\<^sup>2 = int (x\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  (int x)\\<^sup>2 = int (x\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (x, y) = (1, 0)", "also"], ["proof (state)\nthis:\n  (int x)\\<^sup>2 = int (x\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (x, y) = (1, 0)", "note assms(2)"], ["proof (state)\nthis:\n  x\\<^sup>2 = 1 + D * y\\<^sup>2\n\ngoal (1 subgoal):\n 1. (x, y) = (1, 0)", "also"], ["proof (state)\nthis:\n  x\\<^sup>2 = 1 + D * y\\<^sup>2\n\ngoal (1 subgoal):\n 1. (x, y) = (1, 0)", "have \"int (1 + D * y ^ 2) = 1 + int D * int y ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (1 + D * y\\<^sup>2) = 1 + int D * (int y)\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  int (1 + D * y\\<^sup>2) = 1 + int D * (int y)\\<^sup>2\n\ngoal (1 subgoal):\n 1. (x, y) = (1, 0)", "finally"], ["proof (chain)\npicking this:\n  (int x)\\<^sup>2 = 1 + int D * (int y)\\<^sup>2", "have \"(int x + int d * int y) * (int x - int d * int y) = 1\""], ["proof (prove)\nusing this:\n  (int x)\\<^sup>2 = 1 + int D * (int y)\\<^sup>2\n\ngoal (1 subgoal):\n 1. (int x + int d * int y) * (int x - int d * int y) = 1", "by (simp add: algebra_simps power2_eq_square)"], ["proof (state)\nthis:\n  (int x + int d * int y) * (int x - int d * int y) = 1\n\ngoal (1 subgoal):\n 1. (x, y) = (1, 0)", "hence *: \"int x + int d * int y = 1 \\<and> int x - int d * int y = 1\""], ["proof (prove)\nusing this:\n  (int x + int d * int y) * (int x - int d * int y) = 1\n\ngoal (1 subgoal):\n 1. int x + int d * int y = 1 \\<and> int x - int d * int y = 1", "using x_nz"], ["proof (prove)\nusing this:\n  (int x + int d * int y) * (int x - int d * int y) = 1\n  0 < x\n\ngoal (1 subgoal):\n 1. int x + int d * int y = 1 \\<and> int x - int d * int y = 1", "by (subst (asm) pos_zmult_eq_1_iff) (auto intro: add_pos_nonneg)"], ["proof (state)\nthis:\n  int x + int d * int y = 1 \\<and> int x - int d * int y = 1\n\ngoal (1 subgoal):\n 1. (x, y) = (1, 0)", "from *"], ["proof (chain)\npicking this:\n  int x + int d * int y = 1 \\<and> int x - int d * int y = 1", "have [simp]: \"x = 1\""], ["proof (prove)\nusing this:\n  int x + int d * int y = 1 \\<and> int x - int d * int y = 1\n\ngoal (1 subgoal):\n 1. x = 1", "by simp"], ["proof (state)\nthis:\n  x = 1\n\ngoal (1 subgoal):\n 1. (x, y) = (1, 0)", "moreover"], ["proof (state)\nthis:\n  x = 1\n\ngoal (1 subgoal):\n 1. (x, y) = (1, 0)", "from * and assms(1)"], ["proof (chain)\npicking this:\n  int x + int d * int y = 1 \\<and> int x - int d * int y = 1\n  0 < D", "have \"y = 0\""], ["proof (prove)\nusing this:\n  int x + int d * int y = 1 \\<and> int x - int d * int y = 1\n  0 < D\n\ngoal (1 subgoal):\n 1. y = 0", "by auto"], ["proof (state)\nthis:\n  y = 0\n\ngoal (1 subgoal):\n 1. (x, y) = (1, 0)", "ultimately"], ["proof (chain)\npicking this:\n  x = 1\n  y = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  x = 1\n  y = 0\n\ngoal (1 subgoal):\n 1. (x, y) = (1, 0)", "by simp"], ["proof (state)\nthis:\n  (x, y) = (1, 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pell_square_solution_int_aux:\n  fixes x y :: int\n  assumes \"D > 0\" and \"x ^ 2 = 1 + D * y ^ 2\"\n  shows \"x \\<in> {-1, 1} \\<and> y = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {- 1, 1} \\<and> y = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> {- 1, 1} \\<and> y = 0", "define x' y' where \"x' = nat \\<bar>x\\<bar>\" and \"y' = nat \\<bar>y\\<bar>\""], ["proof (state)\nthis:\n  x' = nat \\<bar>x\\<bar>\n  y' = nat \\<bar>y\\<bar>\n\ngoal (1 subgoal):\n 1. x \\<in> {- 1, 1} \\<and> y = 0", "have x: \"x = sgn x * x'\" and y: \"y = sgn y * y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = sgn x * int x' &&& y = sgn y * int y'", "by (auto simp: sgn_if x'_def y'_def)"], ["proof (state)\nthis:\n  x = sgn x * int x'\n  y = sgn y * int y'\n\ngoal (1 subgoal):\n 1. x \\<in> {- 1, 1} \\<and> y = 0", "have zero_iff: \"x = 0 \\<longleftrightarrow> x' = 0\" \"y = 0 \\<longleftrightarrow> y' = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = 0) = (x' = 0) &&& (y = 0) = (y' = 0)", "by (auto simp: x'_def y'_def)"], ["proof (state)\nthis:\n  (x = 0) = (x' = 0)\n  (y = 0) = (y' = 0)\n\ngoal (1 subgoal):\n 1. x \\<in> {- 1, 1} \\<and> y = 0", "note assms(2)"], ["proof (state)\nthis:\n  x\\<^sup>2 = 1 + int D * y\\<^sup>2\n\ngoal (1 subgoal):\n 1. x \\<in> {- 1, 1} \\<and> y = 0", "also"], ["proof (state)\nthis:\n  x\\<^sup>2 = 1 + int D * y\\<^sup>2\n\ngoal (1 subgoal):\n 1. x \\<in> {- 1, 1} \\<and> y = 0", "have \"x ^ 2 = int (x' ^ 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>2 = int (x'\\<^sup>2)", "by (subst x) (auto simp: sgn_if zero_iff)"], ["proof (state)\nthis:\n  x\\<^sup>2 = int (x'\\<^sup>2)\n\ngoal (1 subgoal):\n 1. x \\<in> {- 1, 1} \\<and> y = 0", "also"], ["proof (state)\nthis:\n  x\\<^sup>2 = int (x'\\<^sup>2)\n\ngoal (1 subgoal):\n 1. x \\<in> {- 1, 1} \\<and> y = 0", "have \"1 + D * y ^ 2 = int (1 + D * y' ^ 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + int D * y\\<^sup>2 = int (1 + D * y'\\<^sup>2)", "by (subst y) (auto simp: sgn_if zero_iff)"], ["proof (state)\nthis:\n  1 + int D * y\\<^sup>2 = int (1 + D * y'\\<^sup>2)\n\ngoal (1 subgoal):\n 1. x \\<in> {- 1, 1} \\<and> y = 0", "also"], ["proof (state)\nthis:\n  1 + int D * y\\<^sup>2 = int (1 + D * y'\\<^sup>2)\n\ngoal (1 subgoal):\n 1. x \\<in> {- 1, 1} \\<and> y = 0", "note of_nat_eq_iff"], ["proof (state)\nthis:\n  (of_nat ?m = of_nat ?n) = (?m = ?n)\n\ngoal (1 subgoal):\n 1. x \\<in> {- 1, 1} \\<and> y = 0", "finally"], ["proof (chain)\npicking this:\n  x'\\<^sup>2 = 1 + D * y'\\<^sup>2", "have \"x'\\<^sup>2 = 1 + D * y'\\<^sup>2\""], ["proof (prove)\nusing this:\n  x'\\<^sup>2 = 1 + D * y'\\<^sup>2\n\ngoal (1 subgoal):\n 1. x'\\<^sup>2 = 1 + D * y'\\<^sup>2", "."], ["proof (state)\nthis:\n  x'\\<^sup>2 = 1 + D * y'\\<^sup>2\n\ngoal (1 subgoal):\n 1. x \\<in> {- 1, 1} \\<and> y = 0", "from \\<open>D > 0\\<close> and this"], ["proof (chain)\npicking this:\n  0 < D\n  x'\\<^sup>2 = 1 + D * y'\\<^sup>2", "have \"(x', y') = (1, 0)\""], ["proof (prove)\nusing this:\n  0 < D\n  x'\\<^sup>2 = 1 + D * y'\\<^sup>2\n\ngoal (1 subgoal):\n 1. (x', y') = (1, 0)", "by (rule pell_square_solution_nat_aux)"], ["proof (state)\nthis:\n  (x', y') = (1, 0)\n\ngoal (1 subgoal):\n 1. x \\<in> {- 1, 1} \\<and> y = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  (x', y') = (1, 0)\n\ngoal (1 subgoal):\n 1. x \\<in> {- 1, 1} \\<and> y = 0", "by (auto simp: x'_def y'_def)"], ["proof (state)\nthis:\n  x \\<in> {- 1, 1} \\<and> y = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pell_square_solution_nat_iff:\n  fixes x y :: nat\n  shows \"x ^ 2 = 1 + D * y ^ 2  \\<longleftrightarrow>  x = 1 \\<and> (D = 0 \\<or> y = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>2 = 1 + D * y\\<^sup>2) = (x = 1 \\<and> (D = 0 \\<or> y = 0))", "using pell_square_solution_nat_aux[of x y]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < D; x\\<^sup>2 = 1 + D * y\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> (x, y) = (1, 0)\n\ngoal (1 subgoal):\n 1. (x\\<^sup>2 = 1 + D * y\\<^sup>2) = (x = 1 \\<and> (D = 0 \\<or> y = 0))", "by (cases \"D = 0\") auto"], ["", "lemma pell_square_solution_int_iff:\n  fixes x y :: int\n  shows \"x ^ 2 = 1 + D * y ^ 2  \\<longleftrightarrow>  x \\<in> {-1, 1} \\<and> (D = 0 \\<or> y = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>2 = 1 + int D * y\\<^sup>2) =\n    (x \\<in> {- 1, 1} \\<and> (D = 0 \\<or> y = 0))", "using pell_square_solution_int_aux[of x y]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < D; x\\<^sup>2 = 1 + int D * y\\<^sup>2\\<rbrakk>\n  \\<Longrightarrow> x \\<in> {- 1, 1} \\<and> y = 0\n\ngoal (1 subgoal):\n 1. (x\\<^sup>2 = 1 + int D * y\\<^sup>2) =\n    (x \\<in> {- 1, 1} \\<and> (D = 0 \\<or> y = 0))", "by (cases \"D = 0\") (auto simp: power2_eq_1_iff)"], ["", "end"], ["", "subsection \\<open>Existence of a non-trivial solution\\<close>"], ["", "text \\<open>\n  Let us now turn to the case where \\<open>D\\<close> is not a perfect square.\n\n  We first show that Pell's equation always has at least one non-trivial solution (apart\n  from the trivial solution \\<open>(1, 0)\\<close>). For this, we first need a lemma about the existence\n  of rational approximations of real numbers.\n\n  The following lemma states that for any positive integer \\<open>s\\<close> and real number \\<open>x\\<close>, we can find a\n  rational approximation \\<open>t / u\\<close> to \\<open>x\\<close> with an error of most \\<open>1 / (u * s)\\<close> where the denominator\n  \\<open>u\\<close> is at most \\<open>s\\<close>.\n\\<close>"], ["", "lemma pell_approximation_lemma:\n  fixes s :: nat and x :: real\n  assumes s: \"s > 0\"\n  shows \"\\<exists>u::nat. \\<exists>t::int. u > 0 \\<and> coprime u t \\<and> 1 / s \\<in> {\\<bar>t - u * x\\<bar><..1 / u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "define f where \"f = (\\<lambda>u. \\<lceil>u * x\\<rceil>)\""], ["proof (state)\nthis:\n  f = (\\<lambda>u. \\<lceil>u * x\\<rceil>)\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "define g :: \"nat \\<Rightarrow> int\" where \"g = (\\<lambda>u. \\<lfloor>frac (u * x) * s\\<rfloor>)\""], ["proof (state)\nthis:\n  g = (\\<lambda>xa. \\<lfloor>frac (real xa * x) * real s\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "{"], ["proof (state)\nthis:\n  g = (\\<lambda>xa. \\<lfloor>frac (real xa * x) * real s\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "fix u :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "assume u: \"u \\<le> s\""], ["proof (state)\nthis:\n  u \\<le> s\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "hence \"frac (u * x) * real s < 1 * real s\""], ["proof (prove)\nusing this:\n  u \\<le> s\n\ngoal (1 subgoal):\n 1. frac (real u * x) * real s < 1 * real s", "using s"], ["proof (prove)\nusing this:\n  u \\<le> s\n  0 < s\n\ngoal (1 subgoal):\n 1. frac (real u * x) * real s < 1 * real s", "by (intro mult_strict_right_mono) (auto simp: frac_lt_1)"], ["proof (state)\nthis:\n  frac (real u * x) * real s < 1 * real s\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "hence \"g u < int s\""], ["proof (prove)\nusing this:\n  frac (real u * x) * real s < 1 * real s\n\ngoal (1 subgoal):\n 1. g u < int s", "by (auto simp: floor_less_iff g_def)"], ["proof (state)\nthis:\n  g u < int s\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "}"], ["proof (state)\nthis:\n  ?u2 \\<le> s \\<Longrightarrow> g ?u2 < int s\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "hence \"g ` {..s} \\<subseteq> {0..<s}\""], ["proof (prove)\nusing this:\n  ?u2 \\<le> s \\<Longrightarrow> g ?u2 < int s\n\ngoal (1 subgoal):\n 1. g ` {..s} \\<subseteq> {0..<int s}", "by (auto simp: g_def floor_less_iff)"], ["proof (state)\nthis:\n  g ` {..s} \\<subseteq> {0..<int s}\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "hence \"card (g ` {..s}) \\<le> card {0..<int s}\""], ["proof (prove)\nusing this:\n  g ` {..s} \\<subseteq> {0..<int s}\n\ngoal (1 subgoal):\n 1. card (g ` {..s}) \\<le> card {0..<int s}", "by (intro card_mono) auto"], ["proof (state)\nthis:\n  card (g ` {..s}) \\<le> card {0..<int s}\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "also"], ["proof (state)\nthis:\n  card (g ` {..s}) \\<le> card {0..<int s}\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "have \"\\<dots> < card {..s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {0..<int s} < card {..s}", "by simp"], ["proof (state)\nthis:\n  card {0..<int s} < card {..s}\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "finally"], ["proof (chain)\npicking this:\n  card (g ` {..s}) < card {..s}", "have \"\\<not>inj_on g {..s}\""], ["proof (prove)\nusing this:\n  card (g ` {..s}) < card {..s}\n\ngoal (1 subgoal):\n 1. \\<not> inj_on g {..s}", "by (rule pigeonhole)"], ["proof (state)\nthis:\n  \\<not> inj_on g {..s}\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "then"], ["proof (chain)\npicking this:\n  \\<not> inj_on g {..s}", "obtain a b where ab: \"a \\<le> s\" \"b \\<le> s\" \"a \\<noteq> b\" \"g a = g b\""], ["proof (prove)\nusing this:\n  \\<not> inj_on g {..s}\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>a \\<le> s; b \\<le> s; a \\<noteq> b; g a = g b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: inj_on_def)"], ["proof (state)\nthis:\n  a \\<le> s\n  b \\<le> s\n  a \\<noteq> b\n  g a = g b\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "define u1 and u2 where \"u1 = max a b\" and \"u2 = min a b\""], ["proof (state)\nthis:\n  u1 = max a b\n  u2 = min a b\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "have u12: \"u1 \\<le> s\" \"u2 \\<le> s\" \"u2 < u1\" \"g u1 = g u2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u1 \\<le> s &&& u2 \\<le> s) &&& u2 < u1 &&& g u1 = g u2", "using ab"], ["proof (prove)\nusing this:\n  a \\<le> s\n  b \\<le> s\n  a \\<noteq> b\n  g a = g b\n\ngoal (1 subgoal):\n 1. (u1 \\<le> s &&& u2 \\<le> s) &&& u2 < u1 &&& g u1 = g u2", "by (auto simp: u1_def u2_def)"], ["proof (state)\nthis:\n  u1 \\<le> s\n  u2 \\<le> s\n  u2 < u1\n  g u1 = g u2\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "define u t where \"u = u1 - u2\" and \"t = \\<lfloor>u1 * x\\<rfloor> - \\<lfloor>u2 * x\\<rfloor>\""], ["proof (state)\nthis:\n  u = u1 - u2\n  t = \\<lfloor>real u1 * x\\<rfloor> - \\<lfloor>real u2 * x\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "have u: \"u > 0\" \"\\<bar>u\\<bar> \\<le> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < u &&& \\<bar>int u\\<bar> \\<le> int s", "using u12"], ["proof (prove)\nusing this:\n  u1 \\<le> s\n  u2 \\<le> s\n  u2 < u1\n  g u1 = g u2\n\ngoal (1 subgoal):\n 1. 0 < u &&& \\<bar>int u\\<bar> \\<le> int s", "by (simp_all add: u_def)"], ["proof (state)\nthis:\n  0 < u\n  \\<bar>int u\\<bar> \\<le> int s\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "from \\<open>g u1 = g u2\\<close>"], ["proof (chain)\npicking this:\n  g u1 = g u2", "have \"\\<bar>frac (u2 * x) * s - frac (u1 * x) * s\\<bar> < 1\""], ["proof (prove)\nusing this:\n  g u1 = g u2\n\ngoal (1 subgoal):\n 1. \\<bar>frac (real u2 * x) * real s - frac (real u1 * x) * real s\\<bar>\n    < 1", "unfolding g_def"], ["proof (prove)\nusing this:\n  \\<lfloor>frac (real u1 * x) * real s\\<rfloor> =\n  \\<lfloor>frac (real u2 * x) * real s\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<bar>frac (real u2 * x) * real s - frac (real u1 * x) * real s\\<bar>\n    < 1", "by linarith"], ["proof (state)\nthis:\n  \\<bar>frac (real u2 * x) * real s - frac (real u1 * x) * real s\\<bar> < 1\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "also"], ["proof (state)\nthis:\n  \\<bar>frac (real u2 * x) * real s - frac (real u1 * x) * real s\\<bar> < 1\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "have \"\\<bar>frac (u2 * x) * s - frac (u1 * x) * s\\<bar> =\n               \\<bar>real s\\<bar> * \\<bar>frac (u2 * x) - frac (u1 * x)\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>frac (real u2 * x) * real s - frac (real u1 * x) * real s\\<bar> =\n    \\<bar>real s\\<bar> * \\<bar>frac (real u2 * x) - frac (real u1 * x)\\<bar>", "by (subst abs_mult [symmetric]) (simp add: algebra_simps)"], ["proof (state)\nthis:\n  \\<bar>frac (real u2 * x) * real s - frac (real u1 * x) * real s\\<bar> =\n  \\<bar>real s\\<bar> * \\<bar>frac (real u2 * x) - frac (real u1 * x)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "finally"], ["proof (chain)\npicking this:\n  \\<bar>real s\\<bar> * \\<bar>frac (real u2 * x) - frac (real u1 * x)\\<bar>\n  < 1", "have \"\\<bar>t - u * x\\<bar> * s < 1\""], ["proof (prove)\nusing this:\n  \\<bar>real s\\<bar> * \\<bar>frac (real u2 * x) - frac (real u1 * x)\\<bar>\n  < 1\n\ngoal (1 subgoal):\n 1. \\<bar>real_of_int t - real u * x\\<bar> * real s < 1", "using \\<open>u1 > u2\\<close>"], ["proof (prove)\nusing this:\n  \\<bar>real s\\<bar> * \\<bar>frac (real u2 * x) - frac (real u1 * x)\\<bar>\n  < 1\n  u2 < u1\n\ngoal (1 subgoal):\n 1. \\<bar>real_of_int t - real u * x\\<bar> * real s < 1", "by (simp add: g_def u_def t_def frac_def algebra_simps of_nat_diff)"], ["proof (state)\nthis:\n  \\<bar>real_of_int t - real u * x\\<bar> * real s < 1\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "with \\<open>s > 0\\<close>"], ["proof (chain)\npicking this:\n  0 < s\n  \\<bar>real_of_int t - real u * x\\<bar> * real s < 1", "have less: \"\\<bar>t - u * x\\<bar> < 1 / s\""], ["proof (prove)\nusing this:\n  0 < s\n  \\<bar>real_of_int t - real u * x\\<bar> * real s < 1\n\ngoal (1 subgoal):\n 1. \\<bar>real_of_int t - real u * x\\<bar> < 1 / real s", "by (simp add: divide_simps)"], ["proof (state)\nthis:\n  \\<bar>real_of_int t - real u * x\\<bar> < 1 / real s\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "define d where \"d = gcd (nat \\<bar>t\\<bar>) u\""], ["proof (state)\nthis:\n  d = gcd (nat \\<bar>t\\<bar>) u\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "define t' :: int and u' :: nat where \"t'= t div d\" and \"u' = u div d\""], ["proof (state)\nthis:\n  t' = t div int d\n  u' = u div d\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "from u"], ["proof (chain)\npicking this:\n  0 < u\n  \\<bar>int u\\<bar> \\<le> int s", "have \"d \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < u\n  \\<bar>int u\\<bar> \\<le> int s\n\ngoal (1 subgoal):\n 1. d \\<noteq> 0", "by (intro notI) (auto simp: d_def)"], ["proof (state)\nthis:\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "have \"int (gcd (nat \\<bar>t\\<bar>) u) = gcd \\<bar>t\\<bar> (int u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (gcd (nat \\<bar>t\\<bar>) u) = gcd \\<bar>t\\<bar> (int u)", "by simp"], ["proof (state)\nthis:\n  int (gcd (nat \\<bar>t\\<bar>) u) = gcd \\<bar>t\\<bar> (int u)\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "hence t'_u': \"t = t' * d\" \"u = u' * d\""], ["proof (prove)\nusing this:\n  int (gcd (nat \\<bar>t\\<bar>) u) = gcd \\<bar>t\\<bar> (int u)\n\ngoal (1 subgoal):\n 1. t = t' * int d &&& u = u' * d", "by (auto simp: t'_def u'_def d_def nat_dvd_iff)"], ["proof (state)\nthis:\n  t = t' * int d\n  u = u' * d\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "from \\<open>d \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  d \\<noteq> 0", "have \"\\<bar>t' - u' * x\\<bar> * 1 \\<le> \\<bar>t' - u' * x\\<bar> * \\<bar>real d\\<bar>\""], ["proof (prove)\nusing this:\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<bar>real_of_int t' - real u' * x\\<bar> * 1\n    \\<le> \\<bar>real_of_int t' - real u' * x\\<bar> * \\<bar>real d\\<bar>", "by (intro mult_left_mono) auto"], ["proof (state)\nthis:\n  \\<bar>real_of_int t' - real u' * x\\<bar> * 1\n  \\<le> \\<bar>real_of_int t' - real u' * x\\<bar> * \\<bar>real d\\<bar>\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "also"], ["proof (state)\nthis:\n  \\<bar>real_of_int t' - real u' * x\\<bar> * 1\n  \\<le> \\<bar>real_of_int t' - real u' * x\\<bar> * \\<bar>real d\\<bar>\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "have \"\\<dots> = \\<bar>t - u * x\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>real_of_int t' - real u' * x\\<bar> * \\<bar>real d\\<bar> =\n    \\<bar>real_of_int t - real u * x\\<bar>", "by (subst abs_mult [symmetric]) (simp add: algebra_simps t'_u')"], ["proof (state)\nthis:\n  \\<bar>real_of_int t' - real u' * x\\<bar> * \\<bar>real d\\<bar> =\n  \\<bar>real_of_int t - real u * x\\<bar>\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "also"], ["proof (state)\nthis:\n  \\<bar>real_of_int t' - real u' * x\\<bar> * \\<bar>real d\\<bar> =\n  \\<bar>real_of_int t - real u * x\\<bar>\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "note less"], ["proof (state)\nthis:\n  \\<bar>real_of_int t - real u * x\\<bar> < 1 / real s\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "finally"], ["proof (chain)\npicking this:\n  \\<bar>real_of_int t' - real u' * x\\<bar> * 1 < 1 / real s", "have \"\\<bar>t' - u' * x\\<bar> < 1 / s\""], ["proof (prove)\nusing this:\n  \\<bar>real_of_int t' - real u' * x\\<bar> * 1 < 1 / real s\n\ngoal (1 subgoal):\n 1. \\<bar>real_of_int t' - real u' * x\\<bar> < 1 / real s", "by simp"], ["proof (state)\nthis:\n  \\<bar>real_of_int t' - real u' * x\\<bar> < 1 / real s\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "moreover"], ["proof (state)\nthis:\n  \\<bar>real_of_int t' - real u' * x\\<bar> < 1 / real s\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "{"], ["proof (state)\nthis:\n  \\<bar>real_of_int t' - real u' * x\\<bar> < 1 / real s\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "from \\<open>s > 0\\<close> and u"], ["proof (chain)\npicking this:\n  0 < s\n  0 < u\n  \\<bar>int u\\<bar> \\<le> int s", "have \"1 / s \\<le> 1 / u\""], ["proof (prove)\nusing this:\n  0 < s\n  0 < u\n  \\<bar>int u\\<bar> \\<le> int s\n\ngoal (1 subgoal):\n 1. 1 / real s \\<le> 1 / real u", "by (simp add: divide_simps u_def)"], ["proof (state)\nthis:\n  1 / real s \\<le> 1 / real u\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "also"], ["proof (state)\nthis:\n  1 / real s \\<le> 1 / real u\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "have \"\\<dots> = 1 / u' / d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / real u = 1 / real u' / real d", "by (simp add: t'_u' divide_simps)"], ["proof (state)\nthis:\n  1 / real u = 1 / real u' / real d\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "also"], ["proof (state)\nthis:\n  1 / real u = 1 / real u' / real d\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "have \"\\<dots> \\<le> 1 / u' / 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / real u' / real d \\<le> 1 / real u' / 1", "using \\<open>d \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 / real u' / real d \\<le> 1 / real u' / 1", "by (intro divide_left_mono) auto"], ["proof (state)\nthis:\n  1 / real u' / real d \\<le> 1 / real u' / 1\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "finally"], ["proof (chain)\npicking this:\n  1 / real s \\<le> 1 / real u' / 1", "have \"1 / s \\<le> 1 / u'\""], ["proof (prove)\nusing this:\n  1 / real s \\<le> 1 / real u' / 1\n\ngoal (1 subgoal):\n 1. 1 / real s \\<le> 1 / real u'", "by simp"], ["proof (state)\nthis:\n  1 / real s \\<le> 1 / real u'\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "}"], ["proof (state)\nthis:\n  1 / real s \\<le> 1 / real u'\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "ultimately"], ["proof (chain)\npicking this:\n  \\<bar>real_of_int t' - real u' * x\\<bar> < 1 / real s\n  1 / real s \\<le> 1 / real u'", "have \"1 / s \\<in> {\\<bar>t' - u' * x\\<bar><..1 / u'}\""], ["proof (prove)\nusing this:\n  \\<bar>real_of_int t' - real u' * x\\<bar> < 1 / real s\n  1 / real s \\<le> 1 / real u'\n\ngoal (1 subgoal):\n 1. 1 / real s\n    \\<in> {\\<bar>real_of_int t' - real u' * x\\<bar><..1 / real u'}", "by auto"], ["proof (state)\nthis:\n  1 / real s \\<in> {\\<bar>real_of_int t' - real u' * x\\<bar><..1 / real u'}\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "moreover"], ["proof (state)\nthis:\n  1 / real s \\<in> {\\<bar>real_of_int t' - real u' * x\\<bar><..1 / real u'}\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "from \\<open>u > 0\\<close>"], ["proof (chain)\npicking this:\n  0 < u", "have \"u' > 0\""], ["proof (prove)\nusing this:\n  0 < u\n\ngoal (1 subgoal):\n 1. 0 < u'", "by (auto simp: t'_u')"], ["proof (state)\nthis:\n  0 < u'\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "moreover"], ["proof (state)\nthis:\n  0 < u'\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "{"], ["proof (state)\nthis:\n  0 < u'\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "have \"gcd u t = gcd t' u' * int d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd (int u) t = gcd t' (int u') * int d", "by (simp add: t'_u' gcd_mult_right gcd.commute)"], ["proof (state)\nthis:\n  gcd (int u) t = gcd t' (int u') * int d\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "also"], ["proof (state)\nthis:\n  gcd (int u) t = gcd t' (int u') * int d\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "have \"int d = gcd u t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int d = gcd (int u) t", "by (simp add: d_def gcd.commute)"], ["proof (state)\nthis:\n  int d = gcd (int u) t\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "finally"], ["proof (chain)\npicking this:\n  gcd (int u) t = gcd t' (int u') * gcd (int u) t", "have \"gcd u' t' = 1\""], ["proof (prove)\nusing this:\n  gcd (int u) t = gcd t' (int u') * gcd (int u) t\n\ngoal (1 subgoal):\n 1. gcd (int u') t' = 1", "using u"], ["proof (prove)\nusing this:\n  gcd (int u) t = gcd t' (int u') * gcd (int u) t\n  0 < u\n  \\<bar>int u\\<bar> \\<le> int s\n\ngoal (1 subgoal):\n 1. gcd (int u') t' = 1", "by (simp add: gcd.commute)"], ["proof (state)\nthis:\n  gcd (int u') t' = 1\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "}"], ["proof (state)\nthis:\n  gcd (int u') t' = 1\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "ultimately"], ["proof (chain)\npicking this:\n  1 / real s \\<in> {\\<bar>real_of_int t' - real u' * x\\<bar><..1 / real u'}\n  0 < u'\n  gcd (int u') t' = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  1 / real s \\<in> {\\<bar>real_of_int t' - real u' * x\\<bar><..1 / real u'}\n  0 < u'\n  gcd (int u') t' = 1\n\ngoal (1 subgoal):\n 1. \\<exists>u t.\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       1 / real s\n       \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "by blast"], ["proof (state)\nthis:\n  \\<exists>u t.\n     0 < u \\<and>\n     coprime (int u) t \\<and>\n     1 / real s \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  As a simple corollary of this, we can show that for irrational \\<open>x\\<close>, there is an infinite\n  number of rational approximations \\<open>t / u\\<close> to \\<open>x\\<close> whose error is less that \\<open>1 / u\\<^sup>2\\<close>.\n\\<close>"], ["", "corollary pell_approximation_corollary:\n  fixes x :: real\n  assumes \"x \\<notin> \\<rat>\"\n  shows \"infinite {(t :: int, u :: nat). u > 0 \\<and> coprime u t \\<and> \\<bar>t - u * x\\<bar> < 1 / u}\"\n    (is \"infinite ?A\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite\n     {(t, u).\n      0 < u \\<and>\n      coprime (int u) t \\<and>\n      \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {(t, u).\n      0 < u \\<and>\n      coprime (int u) t \\<and>\n      \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u} \\<Longrightarrow>\n    False", "assume fin: \"finite ?A\""], ["proof (state)\nthis:\n  finite\n   {(t, u).\n    0 < u \\<and>\n    coprime (int u) t \\<and>\n    \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}\n\ngoal (1 subgoal):\n 1. finite\n     {(t, u).\n      0 < u \\<and>\n      coprime (int u) t \\<and>\n      \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u} \\<Longrightarrow>\n    False", "let ?f = \"\\<lambda>(t :: int, u :: nat). \\<bar>t - u * x\\<bar>\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite\n     {(t, u).\n      0 < u \\<and>\n      coprime (int u) t \\<and>\n      \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u} \\<Longrightarrow>\n    False", "from fin"], ["proof (chain)\npicking this:\n  finite\n   {(t, u).\n    0 < u \\<and>\n    coprime (int u) t \\<and>\n    \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}", "have fin': \"finite (insert 1 (?f ` ?A))\""], ["proof (prove)\nusing this:\n  finite\n   {(t, u).\n    0 < u \\<and>\n    coprime (int u) t \\<and>\n    \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}\n\ngoal (1 subgoal):\n 1. finite\n     (insert 1\n       ((\\<lambda>(xb, xa). \\<bar>real_of_int xb - real xa * x\\<bar>) `\n        {(t, u).\n         0 < u \\<and>\n         coprime (int u) t \\<and>\n         \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}))", "by blast"], ["proof (state)\nthis:\n  finite\n   (insert 1\n     ((\\<lambda>(xb, xa). \\<bar>real_of_int xb - real xa * x\\<bar>) `\n      {(t, u).\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}))\n\ngoal (1 subgoal):\n 1. finite\n     {(t, u).\n      0 < u \\<and>\n      coprime (int u) t \\<and>\n      \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u} \\<Longrightarrow>\n    False", "have \"Min (insert 1 (?f ` ?A)) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Min (insert 1\n              ((\\<lambda>(xb, xa).\n                   \\<bar>real_of_int xb - real xa * x\\<bar>) `\n               {(t, u).\n                0 < u \\<and>\n                coprime (int u) t \\<and>\n                \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}))", "proof (subst Min_gr_iff)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite\n     (insert 1\n       ((\\<lambda>(xb, xa). \\<bar>real_of_int xb - real xa * x\\<bar>) `\n        {(t, u).\n         0 < u \\<and>\n         coprime (int u) t \\<and>\n         \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}))\n 2. insert 1\n     ((\\<lambda>(xb, xa). \\<bar>real_of_int xb - real xa * x\\<bar>) `\n      {(t, u).\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}) \\<noteq>\n    {}\n 3. Ball\n     (insert 1\n       ((\\<lambda>(xb, xa). \\<bar>real_of_int xb - real xa * x\\<bar>) `\n        {(t, u).\n         0 < u \\<and>\n         coprime (int u) t \\<and>\n         \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}))\n     ((<) 0)", "have \"a \\<noteq> b * x\" if \"b > 0\" for a :: int and b :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int a \\<noteq> real b * x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int a = real b * x \\<Longrightarrow> False", "assume \"a = b * x\""], ["proof (state)\nthis:\n  real_of_int a = real b * x\n\ngoal (1 subgoal):\n 1. real_of_int a = real b * x \\<Longrightarrow> False", "with \\<open>b > 0\\<close>"], ["proof (chain)\npicking this:\n  0 < b\n  real_of_int a = real b * x", "have \"x = a / b\""], ["proof (prove)\nusing this:\n  0 < b\n  real_of_int a = real b * x\n\ngoal (1 subgoal):\n 1. x = real_of_int a / real b", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  x = real_of_int a / real b\n\ngoal (1 subgoal):\n 1. real_of_int a = real b * x \\<Longrightarrow> False", "with \\<open>x \\<notin> \\<rat>\\<close> and \\<open>b > 0\\<close>"], ["proof (chain)\npicking this:\n  x \\<notin> \\<rat>\n  0 < b\n  x = real_of_int a / real b", "show False"], ["proof (prove)\nusing this:\n  x \\<notin> \\<rat>\n  0 < b\n  x = real_of_int a / real b\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: Rats_eq_int_div_nat)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?b \\<Longrightarrow> real_of_int ?a \\<noteq> real ?b * x\n\ngoal (3 subgoals):\n 1. finite\n     (insert 1\n       ((\\<lambda>(xb, xa). \\<bar>real_of_int xb - real xa * x\\<bar>) `\n        {(t, u).\n         0 < u \\<and>\n         coprime (int u) t \\<and>\n         \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}))\n 2. insert 1\n     ((\\<lambda>(xb, xa). \\<bar>real_of_int xb - real xa * x\\<bar>) `\n      {(t, u).\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}) \\<noteq>\n    {}\n 3. Ball\n     (insert 1\n       ((\\<lambda>(xb, xa). \\<bar>real_of_int xb - real xa * x\\<bar>) `\n        {(t, u).\n         0 < u \\<and>\n         coprime (int u) t \\<and>\n         \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}))\n     ((<) 0)", "thus \"\\<forall>x\\<in>insert 1 (?f ` ?A). x > 0\""], ["proof (prove)\nusing this:\n  0 < ?b \\<Longrightarrow> real_of_int ?a \\<noteq> real ?b * x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>insert 1\n                    ((\\<lambda>(xb, xa).\n                         \\<bar>real_of_int xb - real xa * x\\<bar>) `\n                     {(t, u).\n                      0 < u \\<and>\n                      coprime (int u) t \\<and>\n                      \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}).\n       0 < x", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>insert 1\n                  ((\\<lambda>(xb, xa).\n                       \\<bar>real_of_int xb - real xa * x\\<bar>) `\n                   {(t, u).\n                    0 < u \\<and>\n                    coprime (int u) t \\<and>\n                    \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}).\n     0 < x\n\ngoal (2 subgoals):\n 1. finite\n     (insert 1\n       ((\\<lambda>(xb, xa). \\<bar>real_of_int xb - real xa * x\\<bar>) `\n        {(t, u).\n         0 < u \\<and>\n         coprime (int u) t \\<and>\n         \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}))\n 2. insert 1\n     ((\\<lambda>(xb, xa). \\<bar>real_of_int xb - real xa * x\\<bar>) `\n      {(t, u).\n       0 < u \\<and>\n       coprime (int u) t \\<and>\n       \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}) \\<noteq>\n    {}", "qed (insert fin', simp_all)"], ["proof (state)\nthis:\n  0 < Min (insert 1\n            ((\\<lambda>(xb, xa). \\<bar>real_of_int xb - real xa * x\\<bar>) `\n             {(t, u).\n              0 < u \\<and>\n              coprime (int u) t \\<and>\n              \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}))\n\ngoal (1 subgoal):\n 1. finite\n     {(t, u).\n      0 < u \\<and>\n      coprime (int u) t \\<and>\n      \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u} \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  0 < Min (insert 1\n            ((\\<lambda>(xb, xa). \\<bar>real_of_int xb - real xa * x\\<bar>) `\n             {(t, u).\n              0 < u \\<and>\n              coprime (int u) t \\<and>\n              \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}))\n\ngoal (1 subgoal):\n 1. finite\n     {(t, u).\n      0 < u \\<and>\n      coprime (int u) t \\<and>\n      \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u} \\<Longrightarrow>\n    False", "note real_arch_inverse"], ["proof (state)\nthis:\n  (0 < ?e) =\n  (\\<exists>n.\n      n \\<noteq> 0 \\<and> 0 < inverse (real n) \\<and> inverse (real n) < ?e)\n\ngoal (1 subgoal):\n 1. finite\n     {(t, u).\n      0 < u \\<and>\n      coprime (int u) t \\<and>\n      \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u} \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  \\<exists>n.\n     n \\<noteq> 0 \\<and>\n     0 < inverse (real n) \\<and>\n     inverse (real n)\n     < Min (insert 1\n             ((\\<lambda>(xb, xa).\n                  \\<bar>real_of_int xb - real xa * x\\<bar>) `\n              {(t, u).\n               0 < u \\<and>\n               coprime (int u) t \\<and>\n               \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}))", "obtain M :: nat where M: \"M \\<noteq> 0\" \"inverse M < Min (insert 1 (?f ` ?A))\""], ["proof (prove)\nusing this:\n  \\<exists>n.\n     n \\<noteq> 0 \\<and>\n     0 < inverse (real n) \\<and>\n     inverse (real n)\n     < Min (insert 1\n             ((\\<lambda>(xb, xa).\n                  \\<bar>real_of_int xb - real xa * x\\<bar>) `\n              {(t, u).\n               0 < u \\<and>\n               coprime (int u) t \\<and>\n               \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}))\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>M \\<noteq> 0;\n         inverse (real M)\n         < Min (insert 1\n                 ((\\<lambda>(xb, xa).\n                      \\<bar>real_of_int xb - real xa * x\\<bar>) `\n                  {(t, u).\n                   0 < u \\<and>\n                   coprime (int u) t \\<and>\n                   \\<bar>real_of_int t - real u * x\\<bar>\n                   < 1 / real u}))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  M \\<noteq> 0\n  inverse (real M)\n  < Min (insert 1\n          ((\\<lambda>(xb, xa). \\<bar>real_of_int xb - real xa * x\\<bar>) `\n           {(t, u).\n            0 < u \\<and>\n            coprime (int u) t \\<and>\n            \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}))\n\ngoal (1 subgoal):\n 1. finite\n     {(t, u).\n      0 < u \\<and>\n      coprime (int u) t \\<and>\n      \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u} \\<Longrightarrow>\n    False", "hence \"M > 0\""], ["proof (prove)\nusing this:\n  M \\<noteq> 0\n  inverse (real M)\n  < Min (insert 1\n          ((\\<lambda>(xb, xa). \\<bar>real_of_int xb - real xa * x\\<bar>) `\n           {(t, u).\n            0 < u \\<and>\n            coprime (int u) t \\<and>\n            \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}))\n\ngoal (1 subgoal):\n 1. 0 < M", "by simp"], ["proof (state)\nthis:\n  0 < M\n\ngoal (1 subgoal):\n 1. finite\n     {(t, u).\n      0 < u \\<and>\n      coprime (int u) t \\<and>\n      \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u} \\<Longrightarrow>\n    False", "from pell_approximation_lemma[OF this, of x]"], ["proof (chain)\npicking this:\n  \\<exists>u t.\n     0 < u \\<and>\n     coprime (int u) t \\<and>\n     1 / real M \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}", "obtain u :: nat and t :: int\n    where ut: \"u > 0\" \"coprime u t\" \"1 / real M \\<in> {?f (t, u)<..1 / u}\""], ["proof (prove)\nusing this:\n  \\<exists>u t.\n     0 < u \\<and>\n     coprime (int u) t \\<and>\n     1 / real M \\<in> {\\<bar>real_of_int t - real u * x\\<bar><..1 / real u}\n\ngoal (1 subgoal):\n 1. (\\<And>u t.\n        \\<lbrakk>0 < u; coprime (int u) t;\n         1 / real M\n         \\<in> {case (t, u) of\n                (xa, xb) \\<Rightarrow>\n                  \\<bar>real_of_int xa -\n                        real xb * x\\<bar><..1 / real u}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < u\n  coprime (int u) t\n  1 / real M\n  \\<in> {case (t, u) of\n         (xa, xb) \\<Rightarrow>\n           \\<bar>real_of_int xa - real xb * x\\<bar><..1 / real u}\n\ngoal (1 subgoal):\n 1. finite\n     {(t, u).\n      0 < u \\<and>\n      coprime (int u) t \\<and>\n      \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u} \\<Longrightarrow>\n    False", "from ut"], ["proof (chain)\npicking this:\n  0 < u\n  coprime (int u) t\n  1 / real M\n  \\<in> {case (t, u) of\n         (xa, xb) \\<Rightarrow>\n           \\<bar>real_of_int xa - real xb * x\\<bar><..1 / real u}", "have \"?f (t, u) < 1 / real M\""], ["proof (prove)\nusing this:\n  0 < u\n  coprime (int u) t\n  1 / real M\n  \\<in> {case (t, u) of\n         (xa, xb) \\<Rightarrow>\n           \\<bar>real_of_int xa - real xb * x\\<bar><..1 / real u}\n\ngoal (1 subgoal):\n 1. (case (t, u) of\n     (xa, xb) \\<Rightarrow> \\<bar>real_of_int xa - real xb * x\\<bar>)\n    < 1 / real M", "by simp"], ["proof (state)\nthis:\n  (case (t, u) of\n   (xa, xb) \\<Rightarrow> \\<bar>real_of_int xa - real xb * x\\<bar>)\n  < 1 / real M\n\ngoal (1 subgoal):\n 1. finite\n     {(t, u).\n      0 < u \\<and>\n      coprime (int u) t \\<and>\n      \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u} \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  (case (t, u) of\n   (xa, xb) \\<Rightarrow> \\<bar>real_of_int xa - real xb * x\\<bar>)\n  < 1 / real M\n\ngoal (1 subgoal):\n 1. finite\n     {(t, u).\n      0 < u \\<and>\n      coprime (int u) t \\<and>\n      \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u} \\<Longrightarrow>\n    False", "from M"], ["proof (chain)\npicking this:\n  M \\<noteq> 0\n  inverse (real M)\n  < Min (insert 1\n          ((\\<lambda>(xb, xa). \\<bar>real_of_int xb - real xa * x\\<bar>) `\n           {(t, u).\n            0 < u \\<and>\n            coprime (int u) t \\<and>\n            \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}))", "have \"\\<dots>  < Min (insert 1 (?f ` ?A))\""], ["proof (prove)\nusing this:\n  M \\<noteq> 0\n  inverse (real M)\n  < Min (insert 1\n          ((\\<lambda>(xb, xa). \\<bar>real_of_int xb - real xa * x\\<bar>) `\n           {(t, u).\n            0 < u \\<and>\n            coprime (int u) t \\<and>\n            \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}))\n\ngoal (1 subgoal):\n 1. 1 / real M\n    < Min (insert 1\n            ((\\<lambda>(xb, xa). \\<bar>real_of_int xb - real xa * x\\<bar>) `\n             {(t, u).\n              0 < u \\<and>\n              coprime (int u) t \\<and>\n              \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}))", "by (simp add: divide_simps)"], ["proof (state)\nthis:\n  1 / real M\n  < Min (insert 1\n          ((\\<lambda>(xb, xa). \\<bar>real_of_int xb - real xa * x\\<bar>) `\n           {(t, u).\n            0 < u \\<and>\n            coprime (int u) t \\<and>\n            \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}))\n\ngoal (1 subgoal):\n 1. finite\n     {(t, u).\n      0 < u \\<and>\n      coprime (int u) t \\<and>\n      \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u} \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  1 / real M\n  < Min (insert 1\n          ((\\<lambda>(xb, xa). \\<bar>real_of_int xb - real xa * x\\<bar>) `\n           {(t, u).\n            0 < u \\<and>\n            coprime (int u) t \\<and>\n            \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}))\n\ngoal (1 subgoal):\n 1. finite\n     {(t, u).\n      0 < u \\<and>\n      coprime (int u) t \\<and>\n      \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u} \\<Longrightarrow>\n    False", "from ut"], ["proof (chain)\npicking this:\n  0 < u\n  coprime (int u) t\n  1 / real M\n  \\<in> {case (t, u) of\n         (xa, xb) \\<Rightarrow>\n           \\<bar>real_of_int xa - real xb * x\\<bar><..1 / real u}", "have \"Min (insert 1 (?f ` ?A)) \\<le> ?f (t, u)\""], ["proof (prove)\nusing this:\n  0 < u\n  coprime (int u) t\n  1 / real M\n  \\<in> {case (t, u) of\n         (xa, xb) \\<Rightarrow>\n           \\<bar>real_of_int xa - real xb * x\\<bar><..1 / real u}\n\ngoal (1 subgoal):\n 1. Min (insert 1\n          ((\\<lambda>(xa, xaa). \\<bar>real_of_int xa - real xaa * x\\<bar>) `\n           {(t, u).\n            0 < u \\<and>\n            coprime (int u) t \\<and>\n            \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}))\n    \\<le> (case (t, u) of\n           (xa, xb) \\<Rightarrow> \\<bar>real_of_int xa - real xb * x\\<bar>)", "by (intro Min.coboundedI fin') auto"], ["proof (state)\nthis:\n  Min (insert 1\n        ((\\<lambda>(xa, xaa). \\<bar>real_of_int xa - real xaa * x\\<bar>) `\n         {(t, u).\n          0 < u \\<and>\n          coprime (int u) t \\<and>\n          \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u}))\n  \\<le> (case (t, u) of\n         (xa, xb) \\<Rightarrow> \\<bar>real_of_int xa - real xb * x\\<bar>)\n\ngoal (1 subgoal):\n 1. finite\n     {(t, u).\n      0 < u \\<and>\n      coprime (int u) t \\<and>\n      \\<bar>real_of_int t - real u * x\\<bar> < 1 / real u} \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  (case (t, u) of\n   (xa, xb) \\<Rightarrow> \\<bar>real_of_int xa - real xb * x\\<bar>)\n  < (case (t, u) of\n     (xa, xb) \\<Rightarrow> \\<bar>real_of_int xa - real xb * x\\<bar>)", "show False"], ["proof (prove)\nusing this:\n  (case (t, u) of\n   (xa, xb) \\<Rightarrow> \\<bar>real_of_int xa - real xb * x\\<bar>)\n  < (case (t, u) of\n     (xa, xb) \\<Rightarrow> \\<bar>real_of_int xa - real xb * x\\<bar>)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "locale pell =\n  fixes D :: nat\n  assumes nonsquare_D: \"\\<not>is_square D\"\nbegin"], ["", "lemma D_gt_1: \"D > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 < D", "from nonsquare_D"], ["proof (chain)\npicking this:\n  \\<not> is_square D", "have \"D \\<noteq> 0\" \"D \\<noteq> 1\""], ["proof (prove)\nusing this:\n  \\<not> is_square D\n\ngoal (1 subgoal):\n 1. D \\<noteq> 0 &&& D \\<noteq> 1", "by (auto intro!: Nat.gr0I)"], ["proof (state)\nthis:\n  D \\<noteq> 0\n  D \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 1 < D", "thus ?thesis"], ["proof (prove)\nusing this:\n  D \\<noteq> 0\n  D \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 1 < D", "by simp"], ["proof (state)\nthis:\n  1 < D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma D_pos: \"D > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < D", "using nonsquare_D"], ["proof (prove)\nusing this:\n  \\<not> is_square D\n\ngoal (1 subgoal):\n 1. 0 < D", "by (intro Nat.gr0I) auto"], ["", "text \\<open>\n  With the above corollary, we can show the existence of a non-trivial solution. We restrict our\n  attention to solutions \\<open>(x, y)\\<close> where both \\<open>x\\<close> and \\<open>y\\<close> are non-negative.\n\\<close>"], ["", "theorem pell_solution_exists: \"\\<exists>(x::nat) (y::nat). y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "define S where \"S = {(t :: int, u :: nat). u > 0 \\<and> coprime u t \\<and> \\<bar>t - u * sqrt D\\<bar> < 1 / u}\""], ["proof (state)\nthis:\n  S =\n  {(t, u).\n   0 < u \\<and>\n   coprime (int u) t \\<and>\n   \\<bar>real_of_int t - real u * sqrt (real D)\\<bar> < 1 / real u}\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "let ?f = \"\\<lambda>(t :: int, u :: nat). t\\<^sup>2 - u\\<^sup>2 * D\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "define M where \"M = \\<lfloor>1 + 2 * sqrt D\\<rfloor>\""], ["proof (state)\nthis:\n  M = \\<lfloor>1 + 2 * sqrt (real D)\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "have infinite: \"\\<not>finite S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite S", "unfolding S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite\n     {(t, u).\n      0 < u \\<and>\n      coprime (int u) t \\<and>\n      \\<bar>real_of_int t - real u * sqrt (real D)\\<bar> < 1 / real u}", "by (intro pell_approximation_corollary irrat_sqrt_nonsquare nonsquare_D)"], ["proof (state)\nthis:\n  infinite S\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "have subset: \"?f ` S \\<subseteq> {-M..M}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(t, u). t\\<^sup>2 - int (u\\<^sup>2 * D)) ` S\n    \\<subseteq> {- M..M}", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> S \\<Longrightarrow>\n       a\\<^sup>2 - int (b\\<^sup>2 * D) \\<in> {- M..M}", "fix u :: nat and t :: int"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> S \\<Longrightarrow>\n       a\\<^sup>2 - int (b\\<^sup>2 * D) \\<in> {- M..M}", "assume tu: \"(t, u) \\<in> S\""], ["proof (state)\nthis:\n  (t, u) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> S \\<Longrightarrow>\n       a\\<^sup>2 - int (b\\<^sup>2 * D) \\<in> {- M..M}", "from tu"], ["proof (chain)\npicking this:\n  (t, u) \\<in> S", "have [simp]: \"u > 0\""], ["proof (prove)\nusing this:\n  (t, u) \\<in> S\n\ngoal (1 subgoal):\n 1. 0 < u", "by (auto simp: S_def)"], ["proof (state)\nthis:\n  0 < u\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> S \\<Longrightarrow>\n       a\\<^sup>2 - int (b\\<^sup>2 * D) \\<in> {- M..M}", "have \"\\<bar>t + u * sqrt D\\<bar> = \\<bar>t - u * sqrt D + 2 * u * sqrt D\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>real_of_int t + real u * sqrt (real D)\\<bar> =\n    \\<bar>real_of_int t - real u * sqrt (real D) +\n          real (2 * u) * sqrt (real D)\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>real_of_int t + real u * sqrt (real D)\\<bar> =\n  \\<bar>real_of_int t - real u * sqrt (real D) +\n        real (2 * u) * sqrt (real D)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> S \\<Longrightarrow>\n       a\\<^sup>2 - int (b\\<^sup>2 * D) \\<in> {- M..M}", "also"], ["proof (state)\nthis:\n  \\<bar>real_of_int t + real u * sqrt (real D)\\<bar> =\n  \\<bar>real_of_int t - real u * sqrt (real D) +\n        real (2 * u) * sqrt (real D)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> S \\<Longrightarrow>\n       a\\<^sup>2 - int (b\\<^sup>2 * D) \\<in> {- M..M}", "have \"\\<dots> \\<le> \\<bar>t - u * sqrt D\\<bar> + \\<bar>2 * u * sqrt D\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>real_of_int t - real u * sqrt (real D) +\n          real (2 * u) * sqrt (real D)\\<bar>\n    \\<le> \\<bar>real_of_int t - real u * sqrt (real D)\\<bar> +\n          \\<bar>real (2 * u) * sqrt (real D)\\<bar>", "by (rule abs_triangle_ineq)"], ["proof (state)\nthis:\n  \\<bar>real_of_int t - real u * sqrt (real D) +\n        real (2 * u) * sqrt (real D)\\<bar>\n  \\<le> \\<bar>real_of_int t - real u * sqrt (real D)\\<bar> +\n        \\<bar>real (2 * u) * sqrt (real D)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> S \\<Longrightarrow>\n       a\\<^sup>2 - int (b\\<^sup>2 * D) \\<in> {- M..M}", "also"], ["proof (state)\nthis:\n  \\<bar>real_of_int t - real u * sqrt (real D) +\n        real (2 * u) * sqrt (real D)\\<bar>\n  \\<le> \\<bar>real_of_int t - real u * sqrt (real D)\\<bar> +\n        \\<bar>real (2 * u) * sqrt (real D)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> S \\<Longrightarrow>\n       a\\<^sup>2 - int (b\\<^sup>2 * D) \\<in> {- M..M}", "have \"\\<bar>2 * u * sqrt D\\<bar> = 2 * u * sqrt D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>real (2 * u) * sqrt (real D)\\<bar> = real (2 * u) * sqrt (real D)", "by simp"], ["proof (state)\nthis:\n  \\<bar>real (2 * u) * sqrt (real D)\\<bar> = real (2 * u) * sqrt (real D)\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> S \\<Longrightarrow>\n       a\\<^sup>2 - int (b\\<^sup>2 * D) \\<in> {- M..M}", "also"], ["proof (state)\nthis:\n  \\<bar>real (2 * u) * sqrt (real D)\\<bar> = real (2 * u) * sqrt (real D)\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> S \\<Longrightarrow>\n       a\\<^sup>2 - int (b\\<^sup>2 * D) \\<in> {- M..M}", "have \"\\<bar>t - u * sqrt D\\<bar> \\<le> 1 / u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>real_of_int t - real u * sqrt (real D)\\<bar> \\<le> 1 / real u", "using tu"], ["proof (prove)\nusing this:\n  (t, u) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<bar>real_of_int t - real u * sqrt (real D)\\<bar> \\<le> 1 / real u", "by (simp add: S_def)"], ["proof (state)\nthis:\n  \\<bar>real_of_int t - real u * sqrt (real D)\\<bar> \\<le> 1 / real u\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> S \\<Longrightarrow>\n       a\\<^sup>2 - int (b\\<^sup>2 * D) \\<in> {- M..M}", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + real (2 * u) * sqrt (real D)\n      \\<le> y + real (2 * u) * sqrt (real D)) \\<Longrightarrow>\n  \\<bar>real_of_int t + real u * sqrt (real D)\\<bar>\n  \\<le> 1 / real u + real (2 * u) * sqrt (real D)", "have le: \"\\<bar>t + u * sqrt D\\<bar> \\<le> 1 / u + 2 * u * sqrt D\""], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + real (2 * u) * sqrt (real D)\n      \\<le> y + real (2 * u) * sqrt (real D)) \\<Longrightarrow>\n  \\<bar>real_of_int t + real u * sqrt (real D)\\<bar>\n  \\<le> 1 / real u + real (2 * u) * sqrt (real D)\n\ngoal (1 subgoal):\n 1. \\<bar>real_of_int t + real u * sqrt (real D)\\<bar>\n    \\<le> 1 / real u + real (2 * u) * sqrt (real D)", "by simp"], ["proof (state)\nthis:\n  \\<bar>real_of_int t + real u * sqrt (real D)\\<bar>\n  \\<le> 1 / real u + real (2 * u) * sqrt (real D)\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> S \\<Longrightarrow>\n       a\\<^sup>2 - int (b\\<^sup>2 * D) \\<in> {- M..M}", "have \"\\<bar>t\\<^sup>2 - u\\<^sup>2 * D\\<bar> = \\<bar>t - u * sqrt D\\<bar> * \\<bar>t + u * sqrt D\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int \\<bar>t\\<^sup>2 - int (u\\<^sup>2 * D)\\<bar> =\n    \\<bar>real_of_int t - real u * sqrt (real D)\\<bar> *\n    \\<bar>real_of_int t + real u * sqrt (real D)\\<bar>", "by (subst abs_mult [symmetric]) (simp add: algebra_simps power2_eq_square)"], ["proof (state)\nthis:\n  real_of_int \\<bar>t\\<^sup>2 - int (u\\<^sup>2 * D)\\<bar> =\n  \\<bar>real_of_int t - real u * sqrt (real D)\\<bar> *\n  \\<bar>real_of_int t + real u * sqrt (real D)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> S \\<Longrightarrow>\n       a\\<^sup>2 - int (b\\<^sup>2 * D) \\<in> {- M..M}", "also"], ["proof (state)\nthis:\n  real_of_int \\<bar>t\\<^sup>2 - int (u\\<^sup>2 * D)\\<bar> =\n  \\<bar>real_of_int t - real u * sqrt (real D)\\<bar> *\n  \\<bar>real_of_int t + real u * sqrt (real D)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> S \\<Longrightarrow>\n       a\\<^sup>2 - int (b\\<^sup>2 * D) \\<in> {- M..M}", "have \"\\<dots> \\<le> 1 / u * (1 / u + 2 * u * sqrt D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>real_of_int t - real u * sqrt (real D)\\<bar> *\n    \\<bar>real_of_int t + real u * sqrt (real D)\\<bar>\n    \\<le> 1 / real u * (1 / real u + real (2 * u) * sqrt (real D))", "using tu"], ["proof (prove)\nusing this:\n  (t, u) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<bar>real_of_int t - real u * sqrt (real D)\\<bar> *\n    \\<bar>real_of_int t + real u * sqrt (real D)\\<bar>\n    \\<le> 1 / real u * (1 / real u + real (2 * u) * sqrt (real D))", "by (intro mult_mono le) (auto simp: S_def)"], ["proof (state)\nthis:\n  \\<bar>real_of_int t - real u * sqrt (real D)\\<bar> *\n  \\<bar>real_of_int t + real u * sqrt (real D)\\<bar>\n  \\<le> 1 / real u * (1 / real u + real (2 * u) * sqrt (real D))\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> S \\<Longrightarrow>\n       a\\<^sup>2 - int (b\\<^sup>2 * D) \\<in> {- M..M}", "also"], ["proof (state)\nthis:\n  \\<bar>real_of_int t - real u * sqrt (real D)\\<bar> *\n  \\<bar>real_of_int t + real u * sqrt (real D)\\<bar>\n  \\<le> 1 / real u * (1 / real u + real (2 * u) * sqrt (real D))\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> S \\<Longrightarrow>\n       a\\<^sup>2 - int (b\\<^sup>2 * D) \\<in> {- M..M}", "have \"\\<dots> = 1 / real u ^ 2 + 2 * sqrt D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / real u * (1 / real u + real (2 * u) * sqrt (real D)) =\n    1 / (real u)\\<^sup>2 + 2 * sqrt (real D)", "by (simp add: algebra_simps power2_eq_square)"], ["proof (state)\nthis:\n  1 / real u * (1 / real u + real (2 * u) * sqrt (real D)) =\n  1 / (real u)\\<^sup>2 + 2 * sqrt (real D)\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> S \\<Longrightarrow>\n       a\\<^sup>2 - int (b\\<^sup>2 * D) \\<in> {- M..M}", "also"], ["proof (state)\nthis:\n  1 / real u * (1 / real u + real (2 * u) * sqrt (real D)) =\n  1 / (real u)\\<^sup>2 + 2 * sqrt (real D)\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> S \\<Longrightarrow>\n       a\\<^sup>2 - int (b\\<^sup>2 * D) \\<in> {- M..M}", "from \\<open>u > 0\\<close>"], ["proof (chain)\npicking this:\n  0 < u", "have \"real u \\<ge> 1\""], ["proof (prove)\nusing this:\n  0 < u\n\ngoal (1 subgoal):\n 1. 1 \\<le> real u", "by linarith"], ["proof (state)\nthis:\n  1 \\<le> real u\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> S \\<Longrightarrow>\n       a\\<^sup>2 - int (b\\<^sup>2 * D) \\<in> {- M..M}", "hence \"1 / real u ^ 2 \\<le> 1 / 1 ^ 2\""], ["proof (prove)\nusing this:\n  1 \\<le> real u\n\ngoal (1 subgoal):\n 1. 1 / (real u)\\<^sup>2 \\<le> 1 / 1\\<^sup>2", "by (intro divide_left_mono power_mono) auto"], ["proof (state)\nthis:\n  1 / (real u)\\<^sup>2 \\<le> 1 / 1\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> S \\<Longrightarrow>\n       a\\<^sup>2 - int (b\\<^sup>2 * D) \\<in> {- M..M}", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + 2 * sqrt (real D) \\<le> y + 2 * sqrt (real D)) \\<Longrightarrow>\n  real_of_int \\<bar>t\\<^sup>2 - int (u\\<^sup>2 * D)\\<bar>\n  \\<le> 1 / 1\\<^sup>2 + 2 * sqrt (real D)", "have \"\\<bar>t\\<^sup>2 - u\\<^sup>2 * D\\<bar> \\<le> 1 + 2 * sqrt D\""], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + 2 * sqrt (real D) \\<le> y + 2 * sqrt (real D)) \\<Longrightarrow>\n  real_of_int \\<bar>t\\<^sup>2 - int (u\\<^sup>2 * D)\\<bar>\n  \\<le> 1 / 1\\<^sup>2 + 2 * sqrt (real D)\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>t\\<^sup>2 - int (u\\<^sup>2 * D)\\<bar>\n    \\<le> 1 + 2 * sqrt (real D)", "by simp"], ["proof (state)\nthis:\n  real_of_int \\<bar>t\\<^sup>2 - int (u\\<^sup>2 * D)\\<bar>\n  \\<le> 1 + 2 * sqrt (real D)\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> S \\<Longrightarrow>\n       a\\<^sup>2 - int (b\\<^sup>2 * D) \\<in> {- M..M}", "hence \"t\\<^sup>2 - u\\<^sup>2 * D \\<ge> -M\" \"t\\<^sup>2 - u\\<^sup>2 * D \\<le> M\""], ["proof (prove)\nusing this:\n  real_of_int \\<bar>t\\<^sup>2 - int (u\\<^sup>2 * D)\\<bar>\n  \\<le> 1 + 2 * sqrt (real D)\n\ngoal (1 subgoal):\n 1. - M \\<le> t\\<^sup>2 - int (u\\<^sup>2 * D) &&&\n    t\\<^sup>2 - int (u\\<^sup>2 * D) \\<le> M", "unfolding M_def"], ["proof (prove)\nusing this:\n  real_of_int \\<bar>t\\<^sup>2 - int (u\\<^sup>2 * D)\\<bar>\n  \\<le> 1 + 2 * sqrt (real D)\n\ngoal (1 subgoal):\n 1. - \\<lfloor>1 + 2 * sqrt (real D)\\<rfloor>\n    \\<le> t\\<^sup>2 - int (u\\<^sup>2 * D) &&&\n    t\\<^sup>2 - int (u\\<^sup>2 * D)\n    \\<le> \\<lfloor>1 + 2 * sqrt (real D)\\<rfloor>", "by linarith+"], ["proof (state)\nthis:\n  - M \\<le> t\\<^sup>2 - int (u\\<^sup>2 * D)\n  t\\<^sup>2 - int (u\\<^sup>2 * D) \\<le> M\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (a, b) \\<in> S \\<Longrightarrow>\n       a\\<^sup>2 - int (b\\<^sup>2 * D) \\<in> {- M..M}", "thus \"t\\<^sup>2 - u\\<^sup>2 * D \\<in> {-M..M}\""], ["proof (prove)\nusing this:\n  - M \\<le> t\\<^sup>2 - int (u\\<^sup>2 * D)\n  t\\<^sup>2 - int (u\\<^sup>2 * D) \\<le> M\n\ngoal (1 subgoal):\n 1. t\\<^sup>2 - int (u\\<^sup>2 * D) \\<in> {- M..M}", "by simp"], ["proof (state)\nthis:\n  t\\<^sup>2 - int (u\\<^sup>2 * D) \\<in> {- M..M}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>(t, u). t\\<^sup>2 - int (u\\<^sup>2 * D)) ` S\n  \\<subseteq> {- M..M}\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "hence fin: \"finite (?f ` S)\""], ["proof (prove)\nusing this:\n  (\\<lambda>(t, u). t\\<^sup>2 - int (u\\<^sup>2 * D)) ` S\n  \\<subseteq> {- M..M}\n\ngoal (1 subgoal):\n 1. finite ((\\<lambda>(t, u). t\\<^sup>2 - int (u\\<^sup>2 * D)) ` S)", "by (rule finite_subset) auto"], ["proof (state)\nthis:\n  finite ((\\<lambda>(t, u). t\\<^sup>2 - int (u\\<^sup>2 * D)) ` S)\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "from pigeonhole_infinite[OF infinite fin]"], ["proof (chain)\npicking this:\n  \\<exists>a0\\<in>S.\n     infinite\n      {a \\<in> S.\n       (case a of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n       (case a0 of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D))}", "obtain z where z: \"z \\<in> S\" \"infinite {z' \\<in> S. ?f z' = ?f z}\""], ["proof (prove)\nusing this:\n  \\<exists>a0\\<in>S.\n     infinite\n      {a \\<in> S.\n       (case a of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n       (case a0 of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D))}\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> S;\n         infinite\n          {z' \\<in> S.\n           (case z' of\n            (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n           (case z of\n            (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D))}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  z \\<in> S\n  infinite\n   {z' \\<in> S.\n    (case z' of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n    (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D))}\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "define k where \"k = ?f z\""], ["proof (state)\nthis:\n  k = (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D))\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "with subset and z"], ["proof (chain)\npicking this:\n  (\\<lambda>(t, u). t\\<^sup>2 - int (u\\<^sup>2 * D)) ` S\n  \\<subseteq> {- M..M}\n  z \\<in> S\n  infinite\n   {z' \\<in> S.\n    (case z' of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n    (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D))}\n  k = (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D))", "have k: \"k \\<in> {-M..M}\" \"infinite {z\\<in>S. ?f z = k}\""], ["proof (prove)\nusing this:\n  (\\<lambda>(t, u). t\\<^sup>2 - int (u\\<^sup>2 * D)) ` S\n  \\<subseteq> {- M..M}\n  z \\<in> S\n  infinite\n   {z' \\<in> S.\n    (case z' of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n    (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D))}\n  k = (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D))\n\ngoal (1 subgoal):\n 1. k \\<in> {- M..M} &&&\n    infinite\n     {z \\<in> S.\n      (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) = k}", "by (auto simp: k_def)"], ["proof (state)\nthis:\n  k \\<in> {- M..M}\n  infinite\n   {z \\<in> S.\n    (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) = k}\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "have k_nz: \"k \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. k = 0 \\<Longrightarrow> False", "assume [simp]: \"k = 0\""], ["proof (state)\nthis:\n  k = 0\n\ngoal (1 subgoal):\n 1. k = 0 \\<Longrightarrow> False", "note k(2)"], ["proof (state)\nthis:\n  infinite\n   {z \\<in> S.\n    (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) = k}\n\ngoal (1 subgoal):\n 1. k = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  infinite\n   {z \\<in> S.\n    (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) = k}\n\ngoal (1 subgoal):\n 1. k = 0 \\<Longrightarrow> False", "have \"?f z \\<noteq> 0\" if \"z \\<in> S\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case z of\n     (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) \\<noteq>\n    0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n    0 \\<Longrightarrow>\n    False", "assume *: \"?f z = 0\""], ["proof (state)\nthis:\n  (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) = 0\n\ngoal (1 subgoal):\n 1. (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n    0 \\<Longrightarrow>\n    False", "obtain t u where [simp]: \"z = (t, u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t u. z = (t, u) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases z)"], ["proof (state)\nthis:\n  z = (t, u)\n\ngoal (1 subgoal):\n 1. (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n    0 \\<Longrightarrow>\n    False", "from *"], ["proof (chain)\npicking this:\n  (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) = 0", "have \"t ^ 2 = int u ^ 2 * int D\""], ["proof (prove)\nusing this:\n  (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) = 0\n\ngoal (1 subgoal):\n 1. t\\<^sup>2 = (int u)\\<^sup>2 * int D", "by simp"], ["proof (state)\nthis:\n  t\\<^sup>2 = (int u)\\<^sup>2 * int D\n\ngoal (1 subgoal):\n 1. (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n    0 \\<Longrightarrow>\n    False", "hence \"int u ^ 2 dvd t ^ 2\""], ["proof (prove)\nusing this:\n  t\\<^sup>2 = (int u)\\<^sup>2 * int D\n\ngoal (1 subgoal):\n 1. (int u)\\<^sup>2 dvd t\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  (int u)\\<^sup>2 dvd t\\<^sup>2\n\ngoal (1 subgoal):\n 1. (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n    0 \\<Longrightarrow>\n    False", "hence \"int u dvd t\""], ["proof (prove)\nusing this:\n  (int u)\\<^sup>2 dvd t\\<^sup>2\n\ngoal (1 subgoal):\n 1. int u dvd t", "by simp"], ["proof (state)\nthis:\n  int u dvd t\n\ngoal (1 subgoal):\n 1. (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n    0 \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  int u dvd t", "obtain k where [simp]: \"t = int u * k\""], ["proof (prove)\nusing this:\n  int u dvd t\n\ngoal (1 subgoal):\n 1. (\\<And>k. t = int u * k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: dvdE)"], ["proof (state)\nthis:\n  t = int u * k\n\ngoal (1 subgoal):\n 1. (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n    0 \\<Longrightarrow>\n    False", "from * and \\<open>z \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) = 0\n  z \\<in> S", "have \"k ^ 2 = int D\""], ["proof (prove)\nusing this:\n  (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) = 0\n  z \\<in> S\n\ngoal (1 subgoal):\n 1. k\\<^sup>2 = int D", "by (auto simp: power_mult_distrib S_def)"], ["proof (state)\nthis:\n  k\\<^sup>2 = int D\n\ngoal (1 subgoal):\n 1. (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n    0 \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  k\\<^sup>2 = int D\n\ngoal (1 subgoal):\n 1. (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n    0 \\<Longrightarrow>\n    False", "have \"k ^ 2 = int (nat \\<bar>k\\<bar> ^ 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k\\<^sup>2 = int ((nat \\<bar>k\\<bar>)\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  k\\<^sup>2 = int ((nat \\<bar>k\\<bar>)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n    0 \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  int ((nat \\<bar>k\\<bar>)\\<^sup>2) = int D", "have \"D = nat \\<bar>k\\<bar> ^ 2\""], ["proof (prove)\nusing this:\n  int ((nat \\<bar>k\\<bar>)\\<^sup>2) = int D\n\ngoal (1 subgoal):\n 1. D = (nat \\<bar>k\\<bar>)\\<^sup>2", "by (simp only: of_nat_eq_iff)"], ["proof (state)\nthis:\n  D = (nat \\<bar>k\\<bar>)\\<^sup>2\n\ngoal (1 subgoal):\n 1. (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n    0 \\<Longrightarrow>\n    False", "hence \"is_square D\""], ["proof (prove)\nusing this:\n  D = (nat \\<bar>k\\<bar>)\\<^sup>2\n\ngoal (1 subgoal):\n 1. is_square D", "by auto"], ["proof (state)\nthis:\n  is_square D\n\ngoal (1 subgoal):\n 1. (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n    0 \\<Longrightarrow>\n    False", "with nonsquare_D"], ["proof (chain)\npicking this:\n  \\<not> is_square D\n  is_square D", "show False"], ["proof (prove)\nusing this:\n  \\<not> is_square D\n  is_square D\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?z \\<in> S \\<Longrightarrow>\n  (case ?z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. k = 0 \\<Longrightarrow> False", "hence \"{z\\<in>S. ?f z = k} = {}\""], ["proof (prove)\nusing this:\n  ?z \\<in> S \\<Longrightarrow>\n  (case ?z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. {z \\<in> S.\n     (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) = k} =\n    {}", "by auto"], ["proof (state)\nthis:\n  {z \\<in> S.\n   (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) = k} =\n  {}\n\ngoal (1 subgoal):\n 1. k = 0 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  infinite {}", "show False"], ["proof (prove)\nusing this:\n  infinite {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "let ?h = \"\\<lambda>(t :: int, u :: nat). (t mod (abs k), u mod (abs k))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "have \"?h ` {z\\<in>S. ?f z = k} \\<subseteq> {0..<abs k} \\<times> {0..< abs k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(t, x). (t mod \\<bar>k\\<bar>, int x mod \\<bar>k\\<bar>)) `\n    {z \\<in> S.\n     (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) = k}\n    \\<subseteq> {0..<\\<bar>k\\<bar>} \\<times> {0..<\\<bar>k\\<bar>}", "using k_nz"], ["proof (prove)\nusing this:\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>(t, x). (t mod \\<bar>k\\<bar>, int x mod \\<bar>k\\<bar>)) `\n    {z \\<in> S.\n     (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) = k}\n    \\<subseteq> {0..<\\<bar>k\\<bar>} \\<times> {0..<\\<bar>k\\<bar>}", "by (auto simp: case_prod_unfold)"], ["proof (state)\nthis:\n  (\\<lambda>(t, x). (t mod \\<bar>k\\<bar>, int x mod \\<bar>k\\<bar>)) `\n  {z \\<in> S.\n   (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) = k}\n  \\<subseteq> {0..<\\<bar>k\\<bar>} \\<times> {0..<\\<bar>k\\<bar>}\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "hence \"finite (?h ` {z\\<in>S. ?f z = k})\""], ["proof (prove)\nusing this:\n  (\\<lambda>(t, x). (t mod \\<bar>k\\<bar>, int x mod \\<bar>k\\<bar>)) `\n  {z \\<in> S.\n   (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) = k}\n  \\<subseteq> {0..<\\<bar>k\\<bar>} \\<times> {0..<\\<bar>k\\<bar>}\n\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>(t, x). (t mod \\<bar>k\\<bar>, int x mod \\<bar>k\\<bar>)) `\n      {z \\<in> S.\n       (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n       k})", "by (rule finite_subset) auto"], ["proof (state)\nthis:\n  finite\n   ((\\<lambda>(t, x). (t mod \\<bar>k\\<bar>, int x mod \\<bar>k\\<bar>)) `\n    {z \\<in> S.\n     (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) = k})\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "from pigeonhole_infinite[OF k(2) this]"], ["proof (chain)\npicking this:\n  \\<exists>a0\\<in>{z \\<in> S.\n                   (case z of\n                    (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n                   k}.\n     infinite\n      {a \\<in> {z \\<in> S.\n                (case z of\n                 (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n                k}.\n       (case a of\n        (t, x) \\<Rightarrow>\n          (t mod \\<bar>k\\<bar>, int x mod \\<bar>k\\<bar>)) =\n       (case a0 of\n        (t, x) \\<Rightarrow>\n          (t mod \\<bar>k\\<bar>, int x mod \\<bar>k\\<bar>))}", "obtain z'\n    where z': \"z' \\<in> S\" \"?f z' = k\" \"infinite {z''\\<in>{z\\<in>S. ?f z = k}. ?h z'' = ?h z'}\""], ["proof (prove)\nusing this:\n  \\<exists>a0\\<in>{z \\<in> S.\n                   (case z of\n                    (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n                   k}.\n     infinite\n      {a \\<in> {z \\<in> S.\n                (case z of\n                 (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n                k}.\n       (case a of\n        (t, x) \\<Rightarrow>\n          (t mod \\<bar>k\\<bar>, int x mod \\<bar>k\\<bar>)) =\n       (case a0 of\n        (t, x) \\<Rightarrow>\n          (t mod \\<bar>k\\<bar>, int x mod \\<bar>k\\<bar>))}\n\ngoal (1 subgoal):\n 1. (\\<And>z'.\n        \\<lbrakk>z' \\<in> S;\n         (case z' of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n         k;\n         infinite\n          {z''\n           \\<in> {z \\<in> S.\n                  (case z of\n                   (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n                  k}.\n           (case z'' of\n            (t, x) \\<Rightarrow>\n              (t mod \\<bar>k\\<bar>, int x mod \\<bar>k\\<bar>)) =\n           (case z' of\n            (t, x) \\<Rightarrow>\n              (t mod \\<bar>k\\<bar>, int x mod \\<bar>k\\<bar>))}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  z' \\<in> S\n  (case z' of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) = k\n  infinite\n   {z''\n    \\<in> {z \\<in> S.\n           (case z of\n            (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n           k}.\n    (case z'' of\n     (t, x) \\<Rightarrow> (t mod \\<bar>k\\<bar>, int x mod \\<bar>k\\<bar>)) =\n    (case z' of\n     (t, x) \\<Rightarrow> (t mod \\<bar>k\\<bar>, int x mod \\<bar>k\\<bar>))}\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "define l1 and l2 where \"l1 = fst (?h z')\" and \"l2 = snd (?h z')\""], ["proof (state)\nthis:\n  l1 =\n  fst (case z' of\n       (t, x) \\<Rightarrow> (t mod \\<bar>k\\<bar>, int x mod \\<bar>k\\<bar>))\n  l2 =\n  snd (case z' of\n       (t, x) \\<Rightarrow> (t mod \\<bar>k\\<bar>, int x mod \\<bar>k\\<bar>))\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "define S' where \"S' = {(t,u) \\<in> S. ?f (t,u) = k \\<and> t mod abs k = l1 \\<and> u mod abs k = l2}\""], ["proof (state)\nthis:\n  S' =\n  {(t, u).\n   (t, u) \\<in> S \\<and>\n   (case (t, u) of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n   k \\<and>\n   t mod \\<bar>k\\<bar> = l1 \\<and> int u mod \\<bar>k\\<bar> = l2}\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "note z'(3)"], ["proof (state)\nthis:\n  infinite\n   {z''\n    \\<in> {z \\<in> S.\n           (case z of\n            (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n           k}.\n    (case z'' of\n     (t, x) \\<Rightarrow> (t mod \\<bar>k\\<bar>, int x mod \\<bar>k\\<bar>)) =\n    (case z' of\n     (t, x) \\<Rightarrow> (t mod \\<bar>k\\<bar>, int x mod \\<bar>k\\<bar>))}\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "also"], ["proof (state)\nthis:\n  infinite\n   {z''\n    \\<in> {z \\<in> S.\n           (case z of\n            (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n           k}.\n    (case z'' of\n     (t, x) \\<Rightarrow> (t mod \\<bar>k\\<bar>, int x mod \\<bar>k\\<bar>)) =\n    (case z' of\n     (t, x) \\<Rightarrow> (t mod \\<bar>k\\<bar>, int x mod \\<bar>k\\<bar>))}\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "have \"{z''\\<in>{z\\<in>S. ?f z = k}. ?h z'' = ?h z'} = S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {z''\n     \\<in> {z \\<in> S.\n            (case z of\n             (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n            k}.\n     (case z'' of\n      (t, x) \\<Rightarrow> (t mod \\<bar>k\\<bar>, int x mod \\<bar>k\\<bar>)) =\n     (case z' of\n      (t, x) \\<Rightarrow>\n        (t mod \\<bar>k\\<bar>, int x mod \\<bar>k\\<bar>))} =\n    S'", "by (auto simp: l1_def l2_def case_prod_unfold S'_def)"], ["proof (state)\nthis:\n  {z''\n   \\<in> {z \\<in> S.\n          (case z of (t, u) \\<Rightarrow> t\\<^sup>2 - int (u\\<^sup>2 * D)) =\n          k}.\n   (case z'' of\n    (t, x) \\<Rightarrow> (t mod \\<bar>k\\<bar>, int x mod \\<bar>k\\<bar>)) =\n   (case z' of\n    (t, x) \\<Rightarrow> (t mod \\<bar>k\\<bar>, int x mod \\<bar>k\\<bar>))} =\n  S'\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  infinite S'", "have infinite: \"infinite S'\""], ["proof (prove)\nusing this:\n  infinite S'\n\ngoal (1 subgoal):\n 1. infinite S'", "."], ["proof (state)\nthis:\n  infinite S'\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "from z'(1) and k_nz"], ["proof (chain)\npicking this:\n  z' \\<in> S\n  k \\<noteq> 0", "have l12: \"l1 \\<in> {0..<abs k}\" \"l2 \\<in> {0..<abs k}\""], ["proof (prove)\nusing this:\n  z' \\<in> S\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. l1 \\<in> {0..<\\<bar>k\\<bar>} &&& l2 \\<in> {0..<\\<bar>k\\<bar>}", "by (auto simp: l1_def l2_def case_prod_unfold)"], ["proof (state)\nthis:\n  l1 \\<in> {0..<\\<bar>k\\<bar>}\n  l2 \\<in> {0..<\\<bar>k\\<bar>}\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "from infinite_arbitrarily_large[OF infinite]"], ["proof (chain)\npicking this:\n  \\<exists>B. finite B \\<and> card B = ?n \\<and> B \\<subseteq> S'", "obtain X where X: \"finite X\" \"card X = 2\" \"X \\<subseteq> S'\""], ["proof (prove)\nusing this:\n  \\<exists>B. finite B \\<and> card B = ?n \\<and> B \\<subseteq> S'\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>finite X; card X = 2; X \\<subseteq> S'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  finite X\n  card X = 2\n  X \\<subseteq> S'\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "from finite_distinct_list[OF this(1)]"], ["proof (chain)\npicking this:\n  \\<exists>xs. set xs = X \\<and> distinct xs", "obtain xs where xs: \"set xs = X\" \"distinct xs\""], ["proof (prove)\nusing this:\n  \\<exists>xs. set xs = X \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>set xs = X; distinct xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  set xs = X\n  distinct xs\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "with X"], ["proof (chain)\npicking this:\n  finite X\n  card X = 2\n  X \\<subseteq> S'\n  set xs = X\n  distinct xs", "have \"length xs = 2\""], ["proof (prove)\nusing this:\n  finite X\n  card X = 2\n  X \\<subseteq> S'\n  set xs = X\n  distinct xs\n\ngoal (1 subgoal):\n 1. length xs = 2", "using distinct_card[of xs]"], ["proof (prove)\nusing this:\n  finite X\n  card X = 2\n  X \\<subseteq> S'\n  set xs = X\n  distinct xs\n  distinct xs \\<Longrightarrow> card (set xs) = length xs\n\ngoal (1 subgoal):\n 1. length xs = 2", "by simp"], ["proof (state)\nthis:\n  length xs = 2\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  length xs = 2", "obtain z1 z2 where [simp]: \"xs = [z1, z2]\""], ["proof (prove)\nusing this:\n  length xs = 2\n\ngoal (1 subgoal):\n 1. (\\<And>z1 z2. xs = [z1, z2] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: length_Suc_conv eval_nat_numeral)"], ["proof (state)\nthis:\n  xs = [z1, z2]\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "from X xs"], ["proof (chain)\npicking this:\n  finite X\n  card X = 2\n  X \\<subseteq> S'\n  set xs = X\n  distinct xs", "have S': \"z1 \\<in> S'\" \"z2 \\<in> S'\" and neq: \"z1 \\<noteq> z2\""], ["proof (prove)\nusing this:\n  finite X\n  card X = 2\n  X \\<subseteq> S'\n  set xs = X\n  distinct xs\n\ngoal (1 subgoal):\n 1. (z1 \\<in> S' &&& z2 \\<in> S') &&& z1 \\<noteq> z2", "by auto"], ["proof (state)\nthis:\n  z1 \\<in> S'\n  z2 \\<in> S'\n  z1 \\<noteq> z2\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "define t1 u1 t2 u2 where \"t1 = fst z1\" and \"u1 = snd z1\" and \"t2 = fst z2\" and \"u2 = snd z2\""], ["proof (state)\nthis:\n  t1 = fst z1\n  u1 = snd z1\n  t2 = fst z2\n  u2 = snd z2\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "have [simp]: \"z1 = (t1, u1)\" \"z2 = (t2, u2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z1 = (t1, u1) &&& z2 = (t2, u2)", "by (simp_all add: t1_def u1_def t2_def u2_def)"], ["proof (state)\nthis:\n  z1 = (t1, u1)\n  z2 = (t2, u2)\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "from S'"], ["proof (chain)\npicking this:\n  z1 \\<in> S'\n  z2 \\<in> S'", "have * [simp]: \"t1 mod abs k = l1\" \"t2 mod abs k = l1\" \"u1 mod abs k = l2\" \"u2 mod abs k = l2\""], ["proof (prove)\nusing this:\n  z1 \\<in> S'\n  z2 \\<in> S'\n\ngoal (1 subgoal):\n 1. (t1 mod \\<bar>k\\<bar> = l1 &&& t2 mod \\<bar>k\\<bar> = l1) &&&\n    int u1 mod \\<bar>k\\<bar> = l2 &&& int u2 mod \\<bar>k\\<bar> = l2", "by (simp_all add: S'_def)"], ["proof (state)\nthis:\n  t1 mod \\<bar>k\\<bar> = l1\n  t2 mod \\<bar>k\\<bar> = l1\n  int u1 mod \\<bar>k\\<bar> = l2\n  int u2 mod \\<bar>k\\<bar> = l2\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "define x where \"x = (t1 * t2 - D * u1 * u2) div k\""], ["proof (state)\nthis:\n  x = (t1 * t2 - int (D * u1 * u2)) div k\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "define y where \"y = (t1 * u2 - t2 * u1) div k\""], ["proof (state)\nthis:\n  y = (t1 * int u2 - t2 * int u1) div k\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "from S'"], ["proof (chain)\npicking this:\n  z1 \\<in> S'\n  z2 \\<in> S'", "have \"(t1\\<^sup>2 - u1\\<^sup>2 * D) = k\" \"(t2\\<^sup>2 - u2\\<^sup>2 * D) = k\""], ["proof (prove)\nusing this:\n  z1 \\<in> S'\n  z2 \\<in> S'\n\ngoal (1 subgoal):\n 1. t1\\<^sup>2 - int (u1\\<^sup>2 * D) = k &&&\n    t2\\<^sup>2 - int (u2\\<^sup>2 * D) = k", "by (auto simp: S'_def)"], ["proof (state)\nthis:\n  t1\\<^sup>2 - int (u1\\<^sup>2 * D) = k\n  t2\\<^sup>2 - int (u2\\<^sup>2 * D) = k\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "hence \"(t1\\<^sup>2 - u1\\<^sup>2 * D) * (t2\\<^sup>2 - u2\\<^sup>2 * D) = k ^ 2\""], ["proof (prove)\nusing this:\n  t1\\<^sup>2 - int (u1\\<^sup>2 * D) = k\n  t2\\<^sup>2 - int (u2\\<^sup>2 * D) = k\n\ngoal (1 subgoal):\n 1. (t1\\<^sup>2 - int (u1\\<^sup>2 * D)) *\n    (t2\\<^sup>2 - int (u2\\<^sup>2 * D)) =\n    k\\<^sup>2", "unfolding power2_eq_square"], ["proof (prove)\nusing this:\n  t1 * t1 - int (u1 * u1 * D) = k\n  t2 * t2 - int (u2 * u2 * D) = k\n\ngoal (1 subgoal):\n 1. (t1 * t1 - int (u1 * u1 * D)) * (t2 * t2 - int (u2 * u2 * D)) = k * k", "by simp"], ["proof (state)\nthis:\n  (t1\\<^sup>2 - int (u1\\<^sup>2 * D)) *\n  (t2\\<^sup>2 - int (u2\\<^sup>2 * D)) =\n  k\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "also"], ["proof (state)\nthis:\n  (t1\\<^sup>2 - int (u1\\<^sup>2 * D)) *\n  (t2\\<^sup>2 - int (u2\\<^sup>2 * D)) =\n  k\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "have \"(t1\\<^sup>2 - u1\\<^sup>2 * D) * (t2\\<^sup>2 - u2\\<^sup>2 * D) =\n               (t1 * t2 - D * u1 * u2) ^ 2 - D * (t1 * u2 - t2 * u1) ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t1\\<^sup>2 - int (u1\\<^sup>2 * D)) *\n    (t2\\<^sup>2 - int (u2\\<^sup>2 * D)) =\n    (t1 * t2 - int (D * u1 * u2))\\<^sup>2 -\n    int D * (t1 * int u2 - t2 * int u1)\\<^sup>2", "by (simp add: power2_eq_square algebra_simps)"], ["proof (state)\nthis:\n  (t1\\<^sup>2 - int (u1\\<^sup>2 * D)) *\n  (t2\\<^sup>2 - int (u2\\<^sup>2 * D)) =\n  (t1 * t2 - int (D * u1 * u2))\\<^sup>2 -\n  int D * (t1 * int u2 - t2 * int u1)\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  (t1 * t2 - int (D * u1 * u2))\\<^sup>2 -\n  int D * (t1 * int u2 - t2 * int u1)\\<^sup>2 =\n  k\\<^sup>2", "have eq: \"(t1 * t2 - D * u1 * u2)\\<^sup>2 - D * (t1 * u2 - t2 * u1)\\<^sup>2 = k\\<^sup>2\""], ["proof (prove)\nusing this:\n  (t1 * t2 - int (D * u1 * u2))\\<^sup>2 -\n  int D * (t1 * int u2 - t2 * int u1)\\<^sup>2 =\n  k\\<^sup>2\n\ngoal (1 subgoal):\n 1. (t1 * t2 - int (D * u1 * u2))\\<^sup>2 -\n    int D * (t1 * int u2 - t2 * int u1)\\<^sup>2 =\n    k\\<^sup>2", "."], ["proof (state)\nthis:\n  (t1 * t2 - int (D * u1 * u2))\\<^sup>2 -\n  int D * (t1 * int u2 - t2 * int u1)\\<^sup>2 =\n  k\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "have \"(t1 * u2 - t2 * u1) mod abs k = (l1 * l2 - l1 * l2) mod abs k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t1 * int u2 - t2 * int u1) mod \\<bar>k\\<bar> =\n    (l1 * l2 - l1 * l2) mod \\<bar>k\\<bar>", "using l12"], ["proof (prove)\nusing this:\n  l1 \\<in> {0..<\\<bar>k\\<bar>}\n  l2 \\<in> {0..<\\<bar>k\\<bar>}\n\ngoal (1 subgoal):\n 1. (t1 * int u2 - t2 * int u1) mod \\<bar>k\\<bar> =\n    (l1 * l2 - l1 * l2) mod \\<bar>k\\<bar>", "by (intro mod_diff_cong mod_mult_cong) (auto simp: mod_pos_pos_trivial)"], ["proof (state)\nthis:\n  (t1 * int u2 - t2 * int u1) mod \\<bar>k\\<bar> =\n  (l1 * l2 - l1 * l2) mod \\<bar>k\\<bar>\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "hence dvd1: \"k dvd t1 * u2 - t2 * u1\""], ["proof (prove)\nusing this:\n  (t1 * int u2 - t2 * int u1) mod \\<bar>k\\<bar> =\n  (l1 * l2 - l1 * l2) mod \\<bar>k\\<bar>\n\ngoal (1 subgoal):\n 1. k dvd t1 * int u2 - t2 * int u1", "by (simp add: mod_eq_0_iff_dvd)"], ["proof (state)\nthis:\n  k dvd t1 * int u2 - t2 * int u1\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "have \"k\\<^sup>2 dvd k\\<^sup>2 + D * (t1 * u2 - t2 * u1)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k\\<^sup>2 dvd k\\<^sup>2 + int D * (t1 * int u2 - t2 * int u1)\\<^sup>2", "using dvd1"], ["proof (prove)\nusing this:\n  k dvd t1 * int u2 - t2 * int u1\n\ngoal (1 subgoal):\n 1. k\\<^sup>2 dvd k\\<^sup>2 + int D * (t1 * int u2 - t2 * int u1)\\<^sup>2", "by (intro dvd_add) auto"], ["proof (state)\nthis:\n  k\\<^sup>2 dvd k\\<^sup>2 + int D * (t1 * int u2 - t2 * int u1)\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "also"], ["proof (state)\nthis:\n  k\\<^sup>2 dvd k\\<^sup>2 + int D * (t1 * int u2 - t2 * int u1)\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "from eq"], ["proof (chain)\npicking this:\n  (t1 * t2 - int (D * u1 * u2))\\<^sup>2 -\n  int D * (t1 * int u2 - t2 * int u1)\\<^sup>2 =\n  k\\<^sup>2", "have \"\\<dots> = (t1 * t2 - D * u1 * u2)\\<^sup>2\""], ["proof (prove)\nusing this:\n  (t1 * t2 - int (D * u1 * u2))\\<^sup>2 -\n  int D * (t1 * int u2 - t2 * int u1)\\<^sup>2 =\n  k\\<^sup>2\n\ngoal (1 subgoal):\n 1. k\\<^sup>2 + int D * (t1 * int u2 - t2 * int u1)\\<^sup>2 =\n    (t1 * t2 - int (D * u1 * u2))\\<^sup>2", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  k\\<^sup>2 + int D * (t1 * int u2 - t2 * int u1)\\<^sup>2 =\n  (t1 * t2 - int (D * u1 * u2))\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  k\\<^sup>2 dvd (t1 * t2 - int (D * u1 * u2))\\<^sup>2", "have dvd2: \"k dvd t1 * t2 - D * u1 * u2\""], ["proof (prove)\nusing this:\n  k\\<^sup>2 dvd (t1 * t2 - int (D * u1 * u2))\\<^sup>2\n\ngoal (1 subgoal):\n 1. k dvd t1 * t2 - int (D * u1 * u2)", "by simp"], ["proof (state)\nthis:\n  k dvd t1 * t2 - int (D * u1 * u2)\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "note eq"], ["proof (state)\nthis:\n  (t1 * t2 - int (D * u1 * u2))\\<^sup>2 -\n  int D * (t1 * int u2 - t2 * int u1)\\<^sup>2 =\n  k\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "also"], ["proof (state)\nthis:\n  (t1 * t2 - int (D * u1 * u2))\\<^sup>2 -\n  int D * (t1 * int u2 - t2 * int u1)\\<^sup>2 =\n  k\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "from dvd2"], ["proof (chain)\npicking this:\n  k dvd t1 * t2 - int (D * u1 * u2)", "have \"t1 * t2 - D * u1 * u2 = k * x\""], ["proof (prove)\nusing this:\n  k dvd t1 * t2 - int (D * u1 * u2)\n\ngoal (1 subgoal):\n 1. t1 * t2 - int (D * u1 * u2) = k * x", "by (simp add: x_def)"], ["proof (state)\nthis:\n  t1 * t2 - int (D * u1 * u2) = k * x\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "also"], ["proof (state)\nthis:\n  t1 * t2 - int (D * u1 * u2) = k * x\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "from dvd1"], ["proof (chain)\npicking this:\n  k dvd t1 * int u2 - t2 * int u1", "have \"t1 * u2 - t2 * u1 = k * y\""], ["proof (prove)\nusing this:\n  k dvd t1 * int u2 - t2 * int u1\n\ngoal (1 subgoal):\n 1. t1 * int u2 - t2 * int u1 = k * y", "by (simp add: y_def)"], ["proof (state)\nthis:\n  t1 * int u2 - t2 * int u1 = k * y\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "also"], ["proof (state)\nthis:\n  t1 * int u2 - t2 * int u1 = k * y\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "have \"(k * x)\\<^sup>2 - D * (k * y)\\<^sup>2 = k\\<^sup>2 * (x\\<^sup>2 - D * y\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k * x)\\<^sup>2 - int D * (k * y)\\<^sup>2 =\n    k\\<^sup>2 * (x\\<^sup>2 - int D * y\\<^sup>2)", "by (simp add: power_mult_distrib algebra_simps)"], ["proof (state)\nthis:\n  (k * x)\\<^sup>2 - int D * (k * y)\\<^sup>2 =\n  k\\<^sup>2 * (x\\<^sup>2 - int D * y\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  k\\<^sup>2 * (x\\<^sup>2 - int D * y\\<^sup>2) = k\\<^sup>2", "have eq': \"x\\<^sup>2 - D * y\\<^sup>2 = 1\""], ["proof (prove)\nusing this:\n  k\\<^sup>2 * (x\\<^sup>2 - int D * y\\<^sup>2) = k\\<^sup>2\n\ngoal (1 subgoal):\n 1. x\\<^sup>2 - int D * y\\<^sup>2 = 1", "using k_nz"], ["proof (prove)\nusing this:\n  k\\<^sup>2 * (x\\<^sup>2 - int D * y\\<^sup>2) = k\\<^sup>2\n  k \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x\\<^sup>2 - int D * y\\<^sup>2 = 1", "by simp"], ["proof (state)\nthis:\n  x\\<^sup>2 - int D * y\\<^sup>2 = 1\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "hence \"x\\<^sup>2 = 1 + D * y\\<^sup>2\""], ["proof (prove)\nusing this:\n  x\\<^sup>2 - int D * y\\<^sup>2 = 1\n\ngoal (1 subgoal):\n 1. x\\<^sup>2 = 1 + int D * y\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  x\\<^sup>2 = 1 + int D * y\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "also"], ["proof (state)\nthis:\n  x\\<^sup>2 = 1 + int D * y\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "have \"x\\<^sup>2 = int (nat \\<bar>x\\<bar> ^ 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>2 = int ((nat \\<bar>x\\<bar>)\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  x\\<^sup>2 = int ((nat \\<bar>x\\<bar>)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "also"], ["proof (state)\nthis:\n  x\\<^sup>2 = int ((nat \\<bar>x\\<bar>)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "have \"1 + D * y\\<^sup>2 = int (1 + D * nat \\<bar>y\\<bar> ^ 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + int D * y\\<^sup>2 = int (1 + D * (nat \\<bar>y\\<bar>)\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  1 + int D * y\\<^sup>2 = int (1 + D * (nat \\<bar>y\\<bar>)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "also"], ["proof (state)\nthis:\n  1 + int D * y\\<^sup>2 = int (1 + D * (nat \\<bar>y\\<bar>)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "note of_nat_eq_iff"], ["proof (state)\nthis:\n  (of_nat ?m = of_nat ?n) = (?m = ?n)\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "finally"], ["proof (chain)\npicking this:\n  (nat \\<bar>x\\<bar>)\\<^sup>2 = 1 + D * (nat \\<bar>y\\<bar>)\\<^sup>2", "have eq'': \"(nat \\<bar>x\\<bar>)\\<^sup>2 = 1 + D * (nat \\<bar>y\\<bar>)\\<^sup>2\""], ["proof (prove)\nusing this:\n  (nat \\<bar>x\\<bar>)\\<^sup>2 = 1 + D * (nat \\<bar>y\\<bar>)\\<^sup>2\n\ngoal (1 subgoal):\n 1. (nat \\<bar>x\\<bar>)\\<^sup>2 = 1 + D * (nat \\<bar>y\\<bar>)\\<^sup>2", "."], ["proof (state)\nthis:\n  (nat \\<bar>x\\<bar>)\\<^sup>2 = 1 + D * (nat \\<bar>y\\<bar>)\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "have \"t1 * u2 \\<noteq> t2 * u1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t1 * int u2 \\<noteq> t2 * int u1", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. t1 * int u2 = t2 * int u1 \\<Longrightarrow> False", "assume *: \"t1 * u2 = t2 * u1\""], ["proof (state)\nthis:\n  t1 * int u2 = t2 * int u1\n\ngoal (1 subgoal):\n 1. t1 * int u2 = t2 * int u1 \\<Longrightarrow> False", "hence \"\\<bar>t1\\<bar> * \\<bar>u2\\<bar> = \\<bar>t2\\<bar> * \\<bar>u1\\<bar>\""], ["proof (prove)\nusing this:\n  t1 * int u2 = t2 * int u1\n\ngoal (1 subgoal):\n 1. \\<bar>t1\\<bar> * \\<bar>int u2\\<bar> =\n    \\<bar>t2\\<bar> * \\<bar>int u1\\<bar>", "by (simp only: abs_mult [symmetric])"], ["proof (state)\nthis:\n  \\<bar>t1\\<bar> * \\<bar>int u2\\<bar> = \\<bar>t2\\<bar> * \\<bar>int u1\\<bar>\n\ngoal (1 subgoal):\n 1. t1 * int u2 = t2 * int u1 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<bar>t1\\<bar> * \\<bar>int u2\\<bar> = \\<bar>t2\\<bar> * \\<bar>int u1\\<bar>\n\ngoal (1 subgoal):\n 1. t1 * int u2 = t2 * int u1 \\<Longrightarrow> False", "from S'"], ["proof (chain)\npicking this:\n  z1 \\<in> S'\n  z2 \\<in> S'", "have \"coprime u1 t1\" \"coprime u2 t2\""], ["proof (prove)\nusing this:\n  z1 \\<in> S'\n  z2 \\<in> S'\n\ngoal (1 subgoal):\n 1. coprime (int u1) t1 &&& coprime (int u2) t2", "by (auto simp: S'_def S_def)"], ["proof (state)\nthis:\n  coprime (int u1) t1\n  coprime (int u2) t2\n\ngoal (1 subgoal):\n 1. t1 * int u2 = t2 * int u1 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<bar>t1\\<bar> * \\<bar>int u2\\<bar> = \\<bar>t2\\<bar> * \\<bar>int u1\\<bar>\n  coprime (int u1) t1\n  coprime (int u2) t2", "have eq: \"\\<bar>t1\\<bar> = \\<bar>t2\\<bar> \\<and> u1 = u2\""], ["proof (prove)\nusing this:\n  \\<bar>t1\\<bar> * \\<bar>int u2\\<bar> = \\<bar>t2\\<bar> * \\<bar>int u1\\<bar>\n  coprime (int u1) t1\n  coprime (int u2) t2\n\ngoal (1 subgoal):\n 1. \\<bar>t1\\<bar> = \\<bar>t2\\<bar> \\<and> u1 = u2", "by (subst (asm) coprime_crossproduct_int) (auto simp: S'_def S_def gcd.commute coprime_commute)"], ["proof (state)\nthis:\n  \\<bar>t1\\<bar> = \\<bar>t2\\<bar> \\<and> u1 = u2\n\ngoal (1 subgoal):\n 1. t1 * int u2 = t2 * int u1 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<bar>t1\\<bar> = \\<bar>t2\\<bar> \\<and> u1 = u2\n\ngoal (1 subgoal):\n 1. t1 * int u2 = t2 * int u1 \\<Longrightarrow> False", "from S'"], ["proof (chain)\npicking this:\n  z1 \\<in> S'\n  z2 \\<in> S'", "have \"u1 \\<noteq> 0\" \"u2 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  z1 \\<in> S'\n  z2 \\<in> S'\n\ngoal (1 subgoal):\n 1. u1 \\<noteq> 0 &&& u2 \\<noteq> 0", "by (auto simp: S'_def S_def)"], ["proof (state)\nthis:\n  u1 \\<noteq> 0\n  u2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. t1 * int u2 = t2 * int u1 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<bar>t1\\<bar> = \\<bar>t2\\<bar> \\<and> u1 = u2\n  u1 \\<noteq> 0\n  u2 \\<noteq> 0", "have \"t1 = t2\""], ["proof (prove)\nusing this:\n  \\<bar>t1\\<bar> = \\<bar>t2\\<bar> \\<and> u1 = u2\n  u1 \\<noteq> 0\n  u2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. t1 = t2", "using *"], ["proof (prove)\nusing this:\n  \\<bar>t1\\<bar> = \\<bar>t2\\<bar> \\<and> u1 = u2\n  u1 \\<noteq> 0\n  u2 \\<noteq> 0\n  t1 * int u2 = t2 * int u1\n\ngoal (1 subgoal):\n 1. t1 = t2", "by auto"], ["proof (state)\nthis:\n  t1 = t2\n\ngoal (1 subgoal):\n 1. t1 * int u2 = t2 * int u1 \\<Longrightarrow> False", "with eq and neq"], ["proof (chain)\npicking this:\n  \\<bar>t1\\<bar> = \\<bar>t2\\<bar> \\<and> u1 = u2\n  z1 \\<noteq> z2\n  t1 = t2", "show False"], ["proof (prove)\nusing this:\n  \\<bar>t1\\<bar> = \\<bar>t2\\<bar> \\<and> u1 = u2\n  z1 \\<noteq> z2\n  t1 = t2\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t1 * int u2 \\<noteq> t2 * int u1\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "with dvd1"], ["proof (chain)\npicking this:\n  k dvd t1 * int u2 - t2 * int u1\n  t1 * int u2 \\<noteq> t2 * int u1", "have \"y \\<noteq> 0\""], ["proof (prove)\nusing this:\n  k dvd t1 * int u2 - t2 * int u1\n  t1 * int u2 \\<noteq> t2 * int u1\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0", "by (auto simp add: y_def dvd_div_eq_0_iff)"], ["proof (state)\nthis:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "hence \"nat \\<bar>y\\<bar> \\<noteq> 0\""], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. nat \\<bar>y\\<bar> \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  nat \\<bar>y\\<bar> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "with eq''"], ["proof (chain)\npicking this:\n  (nat \\<bar>x\\<bar>)\\<^sup>2 = 1 + D * (nat \\<bar>y\\<bar>)\\<^sup>2\n  nat \\<bar>y\\<bar> \\<noteq> 0", "show \"\\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2\""], ["proof (prove)\nusing this:\n  (nat \\<bar>x\\<bar>)\\<^sup>2 = 1 + D * (nat \\<bar>y\\<bar>)\\<^sup>2\n  nat \\<bar>y\\<bar> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2", "by blast"], ["proof (state)\nthis:\n  \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Definition of solutions\\<close>"], ["", "text \\<open>\n  We define some abbreviations for the concepts of a solution and a non-trivial solution.\n\\<close>"], ["", "definition solution :: \"('a \\<times> 'a :: comm_semiring_1) \\<Rightarrow> bool\" where\n  \"solution = (\\<lambda>(a, b). a\\<^sup>2 = 1 + of_nat D * b\\<^sup>2)\""], ["", "definition nontriv_solution :: \"('a \\<times> 'a :: comm_semiring_1) \\<Rightarrow> bool\" where\n  \"nontriv_solution = (\\<lambda>(a, b). (a, b) \\<noteq> (1, 0) \\<and> a\\<^sup>2 = 1 + of_nat D * b\\<^sup>2)\""], ["", "lemma nontriv_solution_altdef: \"nontriv_solution z \\<longleftrightarrow> solution z \\<and> z \\<noteq> (1, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nontriv_solution z = (solution z \\<and> z \\<noteq> (1::'a, 0::'a))", "by (auto simp: solution_def nontriv_solution_def)"], ["", "lemma solution_trivial_nat [simp, intro]: \"solution (Suc 0, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution (Suc 0, 0)", "by (simp add: solution_def)"], ["", "lemma solution_trivial [simp, intro]: \"solution (1, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution (1::'a, 0::'a)", "by (simp add: solution_def)"], ["", "lemma solution_uminus_left [simp]: \"solution (-x, y :: 'a :: comm_ring_1) \\<longleftrightarrow> solution (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution (- x, y) = solution (x, y)", "by (simp add: solution_def)"], ["", "lemma solution_uminus_right [simp]: \"solution (x, -y :: 'a :: comm_ring_1) \\<longleftrightarrow> solution (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution (x, - y) = solution (x, y)", "by (simp add: solution_def)"], ["", "lemma solution_0_snd_nat_iff [simp]: \"solution (a :: nat, 0) \\<longleftrightarrow> a = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution (a, 0) = (a = 1)", "by (auto simp: solution_def)"], ["", "lemma solution_0_snd_iff [simp]: \"solution (a :: 'a :: idom, 0) \\<longleftrightarrow> a \\<in> {1, -1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution (a, 0::'a) = (a \\<in> {1::'a, - (1::'a)})", "by (auto simp: solution_def power2_eq_1_iff)"], ["", "lemma no_solution_0_fst_nat [simp]: \"\\<not>solution (0, b :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> solution (0, b)", "by (auto simp: solution_def)"], ["", "lemma no_solution_0_fst_int [simp]: \"\\<not>solution (0, b :: int)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> solution (0, b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> solution (0, b)", "have \"1 + int D * b\\<^sup>2 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < 1 + int D * b\\<^sup>2", "by (intro add_pos_nonneg) auto"], ["proof (state)\nthis:\n  0 < 1 + int D * b\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> solution (0, b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < 1 + int D * b\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<not> solution (0, b)", "by (auto simp add: solution_def)"], ["proof (state)\nthis:\n  \\<not> solution (0, b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma solution_of_nat_of_nat [simp]:\n  \"solution (of_nat a, of_nat b :: 'a :: {comm_ring_1, ring_char_0}) \\<longleftrightarrow> solution (a, b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution (of_nat a, of_nat b) = solution (a, b)", "by (simp only: solution_def prod.case of_nat_power [symmetric]\n                 of_nat_1 [symmetric, where ?'a = 'a] of_nat_add [symmetric]\n                 of_nat_mult [symmetric] of_nat_eq_iff of_nat_id)"], ["", "lemma solution_of_nat_of_nat' [simp]:\n  \"solution (case z of (a, b) \\<Rightarrow> (of_nat a, of_nat b :: 'a :: {comm_ring_1, ring_char_0})) \\<longleftrightarrow>\n     solution z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution (case z of (a, b) \\<Rightarrow> (of_nat a, of_nat b)) =\n    solution z", "by (auto simp: case_prod_unfold)"], ["", "lemma solution_nat_abs_nat_abs [simp]:\n  \"solution (nat \\<bar>x\\<bar>, nat \\<bar>y\\<bar>) \\<longleftrightarrow> solution (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution (nat \\<bar>x\\<bar>, nat \\<bar>y\\<bar>) = solution (x, y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. solution (nat \\<bar>x\\<bar>, nat \\<bar>y\\<bar>) = solution (x, y)", "define x' and y' where \"x' = nat \\<bar>x\\<bar>\" and \"y' = nat \\<bar>y\\<bar>\""], ["proof (state)\nthis:\n  x' = nat \\<bar>x\\<bar>\n  y' = nat \\<bar>y\\<bar>\n\ngoal (1 subgoal):\n 1. solution (nat \\<bar>x\\<bar>, nat \\<bar>y\\<bar>) = solution (x, y)", "have x: \"x = sgn x * x'\" and y: \"y = sgn y * y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = sgn x * int x' &&& y = sgn y * int y'", "by (auto simp: x'_def y'_def sgn_if)"], ["proof (state)\nthis:\n  x = sgn x * int x'\n  y = sgn y * int y'\n\ngoal (1 subgoal):\n 1. solution (nat \\<bar>x\\<bar>, nat \\<bar>y\\<bar>) = solution (x, y)", "have [simp]: \"x = 0 \\<longleftrightarrow> x' = 0\" \"y = 0 \\<longleftrightarrow> y' = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = 0) = (x' = 0) &&& (y = 0) = (y' = 0)", "by (auto simp: x'_def y'_def)"], ["proof (state)\nthis:\n  (x = 0) = (x' = 0)\n  (y = 0) = (y' = 0)\n\ngoal (1 subgoal):\n 1. solution (nat \\<bar>x\\<bar>, nat \\<bar>y\\<bar>) = solution (x, y)", "show \"solution (x', y') \\<longleftrightarrow> solution (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution (x', y') = solution (x, y)", "by (subst x, subst y) (auto simp: sgn_if)"], ["proof (state)\nthis:\n  solution (x', y') = solution (x, y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nontriv_solution_of_nat_of_nat [simp]:\n  \"nontriv_solution (of_nat a, of_nat b :: 'a :: {comm_ring_1, ring_char_0}) \\<longleftrightarrow> nontriv_solution (a, b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nontriv_solution (of_nat a, of_nat b) = nontriv_solution (a, b)", "by (auto simp: nontriv_solution_altdef)"], ["", "lemma nontriv_solution_of_nat_of_nat' [simp]:\n  \"nontriv_solution (case z of (a, b) \\<Rightarrow> (of_nat a, of_nat b :: 'a :: {comm_ring_1, ring_char_0})) \\<longleftrightarrow>\n     nontriv_solution z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nontriv_solution (case z of (a, b) \\<Rightarrow> (of_nat a, of_nat b)) =\n    nontriv_solution z", "by (auto simp: case_prod_unfold)"], ["", "lemma nontriv_solution_imp_solution [dest]: \"nontriv_solution z \\<Longrightarrow> solution z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nontriv_solution z \\<Longrightarrow> solution z", "by (auto simp: nontriv_solution_altdef)"], ["", "subsection \\<open>The Pell valuation function\\<close>"], ["", "text \\<open>\n  Solutions \\<open>(x,y)\\<close> have an interesting correspondence to the ring $\\mathbb{Z}[\\sqrt{D}]$ via\n  the map $(x,y) \\mapsto x + y \\sqrt{D}$. We call this map the \\<^emph>\\<open>Pell valuation function\\<close>.\n  It is obvious that this map is injective, since $\\sqrt{D}$ is irrational.\n\\<close>"], ["", "definition pell_valuation :: \"int \\<times> int \\<Rightarrow> real\" where\n  \"pell_valuation = (\\<lambda>(a,b). a + b * sqrt D)\""], ["", "lemma pell_valuation_nonneg [simp]: \"fst z \\<ge> 0 \\<Longrightarrow> snd z \\<ge> 0 \\<Longrightarrow> pell_valuation z \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> fst z; 0 \\<le> snd z\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> pell_valuation z", "by (auto simp: pell_valuation_def case_prod_unfold)"], ["", "lemma pell_valuation_uminus_uminus [simp]: \"pell_valuation (-x, -y) = -pell_valuation (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_valuation (- x, - y) = - pell_valuation (x, y)", "by (simp add: pell_valuation_def)"], ["", "lemma pell_valuation_eq_iff [simp]:\n  \"pell_valuation z1 = pell_valuation z2 \\<longleftrightarrow> z1 = z2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pell_valuation z1 = pell_valuation z2) = (z1 = z2)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. pell_valuation z1 = pell_valuation z2 \\<Longrightarrow> z1 = z2\n 2. z1 = z2 \\<Longrightarrow> pell_valuation z1 = pell_valuation z2", "assume *: \"pell_valuation z1 = pell_valuation z2\""], ["proof (state)\nthis:\n  pell_valuation z1 = pell_valuation z2\n\ngoal (2 subgoals):\n 1. pell_valuation z1 = pell_valuation z2 \\<Longrightarrow> z1 = z2\n 2. z1 = z2 \\<Longrightarrow> pell_valuation z1 = pell_valuation z2", "obtain a b where [simp]: \"z1 = (a, b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b. z1 = (a, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases z1)"], ["proof (state)\nthis:\n  z1 = (a, b)\n\ngoal (2 subgoals):\n 1. pell_valuation z1 = pell_valuation z2 \\<Longrightarrow> z1 = z2\n 2. z1 = z2 \\<Longrightarrow> pell_valuation z1 = pell_valuation z2", "obtain u v where [simp]: \"z2 = (u, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v. z2 = (u, v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases z2)"], ["proof (state)\nthis:\n  z2 = (u, v)\n\ngoal (2 subgoals):\n 1. pell_valuation z1 = pell_valuation z2 \\<Longrightarrow> z1 = z2\n 2. z1 = z2 \\<Longrightarrow> pell_valuation z1 = pell_valuation z2", "have \"b = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = v", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<noteq> v \\<Longrightarrow> False", "assume \"b \\<noteq> v\""], ["proof (state)\nthis:\n  b \\<noteq> v\n\ngoal (1 subgoal):\n 1. b \\<noteq> v \\<Longrightarrow> False", "with *"], ["proof (chain)\npicking this:\n  pell_valuation z1 = pell_valuation z2\n  b \\<noteq> v", "have \"sqrt D = (u - a) / (b - v)\""], ["proof (prove)\nusing this:\n  pell_valuation z1 = pell_valuation z2\n  b \\<noteq> v\n\ngoal (1 subgoal):\n 1. sqrt (real D) = real_of_int (u - a) / real_of_int (b - v)", "by (simp add: field_simps pell_valuation_def)"], ["proof (state)\nthis:\n  sqrt (real D) = real_of_int (u - a) / real_of_int (b - v)\n\ngoal (1 subgoal):\n 1. b \\<noteq> v \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  sqrt (real D) = real_of_int (u - a) / real_of_int (b - v)\n\ngoal (1 subgoal):\n 1. b \\<noteq> v \\<Longrightarrow> False", "have \"\\<dots> \\<in> \\<rat>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (u - a) / real_of_int (b - v) \\<in> \\<rat>", "by auto"], ["proof (state)\nthis:\n  real_of_int (u - a) / real_of_int (b - v) \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. b \\<noteq> v \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  sqrt (real D) \\<in> \\<rat>", "show False"], ["proof (prove)\nusing this:\n  sqrt (real D) \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. False", "using irrat_sqrt_nonsquare nonsquare_D"], ["proof (prove)\nusing this:\n  sqrt (real D) \\<in> \\<rat>\n  \\<not> is_square ?n \\<Longrightarrow> sqrt (real ?n) \\<notin> \\<rat>\n  \\<not> is_square D\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b = v\n\ngoal (2 subgoals):\n 1. pell_valuation z1 = pell_valuation z2 \\<Longrightarrow> z1 = z2\n 2. z1 = z2 \\<Longrightarrow> pell_valuation z1 = pell_valuation z2", "moreover"], ["proof (state)\nthis:\n  b = v\n\ngoal (2 subgoals):\n 1. pell_valuation z1 = pell_valuation z2 \\<Longrightarrow> z1 = z2\n 2. z1 = z2 \\<Longrightarrow> pell_valuation z1 = pell_valuation z2", "from this and *"], ["proof (chain)\npicking this:\n  b = v\n  pell_valuation z1 = pell_valuation z2", "have \"a = u\""], ["proof (prove)\nusing this:\n  b = v\n  pell_valuation z1 = pell_valuation z2\n\ngoal (1 subgoal):\n 1. a = u", "by (simp add: pell_valuation_def)"], ["proof (state)\nthis:\n  a = u\n\ngoal (2 subgoals):\n 1. pell_valuation z1 = pell_valuation z2 \\<Longrightarrow> z1 = z2\n 2. z1 = z2 \\<Longrightarrow> pell_valuation z1 = pell_valuation z2", "ultimately"], ["proof (chain)\npicking this:\n  b = v\n  a = u", "show \"z1 = z2\""], ["proof (prove)\nusing this:\n  b = v\n  a = u\n\ngoal (1 subgoal):\n 1. z1 = z2", "by simp"], ["proof (state)\nthis:\n  z1 = z2\n\ngoal (1 subgoal):\n 1. z1 = z2 \\<Longrightarrow> pell_valuation z1 = pell_valuation z2", "qed auto"], ["", "subsection \\<open>Linear ordering of solutions\\<close>"], ["", "text \\<open>\n  Next, we show that solutions are linearly ordered w.\\,r.\\,t.\\ the pointwise order on products.\n  This means thatfor two different solutions \\<open>(a, b)\\<close> and \\<open>(x, y)\\<close>, we always either have\n  \\<open>a < x\\<close> and \\<open>b < y\\<close> or \\<open>a > x\\<close> and \\<open>b > y\\<close>.\n\\<close>"], ["", "lemma solutions_linorder:\n  fixes a b x y :: nat\n  assumes \"solution (a, b)\" \"solution (x, y)\"\n  shows   \"a \\<le> x \\<and> b \\<le> y \\<or> a \\<ge> x \\<and> b \\<ge> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> x \\<and> b \\<le> y \\<or> x \\<le> a \\<and> y \\<le> b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<le> x \\<and> b \\<le> y \\<or> x \\<le> a \\<and> y \\<le> b", "have \"b \\<le> y\" if \"a \\<le> x\" \"solution (a, b)\" \"solution (x, y)\" for a b x y :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<le> y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b \\<le> y", "from that"], ["proof (chain)\npicking this:\n  a \\<le> x\n  solution (a, b)\n  solution (x, y)", "have \"a ^ 2 \\<le> x ^ 2\""], ["proof (prove)\nusing this:\n  a \\<le> x\n  solution (a, b)\n  solution (x, y)\n\ngoal (1 subgoal):\n 1. a\\<^sup>2 \\<le> x\\<^sup>2", "by (intro power_mono) auto"], ["proof (state)\nthis:\n  a\\<^sup>2 \\<le> x\\<^sup>2\n\ngoal (1 subgoal):\n 1. b \\<le> y", "with that and D_gt_1"], ["proof (chain)\npicking this:\n  a \\<le> x\n  solution (a, b)\n  solution (x, y)\n  1 < D\n  a\\<^sup>2 \\<le> x\\<^sup>2", "have \"b\\<^sup>2 \\<le> y\\<^sup>2\""], ["proof (prove)\nusing this:\n  a \\<le> x\n  solution (a, b)\n  solution (x, y)\n  1 < D\n  a\\<^sup>2 \\<le> x\\<^sup>2\n\ngoal (1 subgoal):\n 1. b\\<^sup>2 \\<le> y\\<^sup>2", "by (simp add: solution_def)"], ["proof (state)\nthis:\n  b\\<^sup>2 \\<le> y\\<^sup>2\n\ngoal (1 subgoal):\n 1. b \\<le> y", "thus \"b \\<le> y\""], ["proof (prove)\nusing this:\n  b\\<^sup>2 \\<le> y\\<^sup>2\n\ngoal (1 subgoal):\n 1. b \\<le> y", "by (simp add: power2_nat_le_eq_le)"], ["proof (state)\nthis:\n  b \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?a2 \\<le> ?x2; solution (?a2, ?b2); solution (?x2, ?y2)\\<rbrakk>\n  \\<Longrightarrow> ?b2 \\<le> ?y2\n\ngoal (1 subgoal):\n 1. a \\<le> x \\<and> b \\<le> y \\<or> x \\<le> a \\<and> y \\<le> b", "from this[of a x b y] and this[of x a y b] and assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>a \\<le> x; solution (a, b); solution (x, y)\\<rbrakk>\n  \\<Longrightarrow> b \\<le> y\n  \\<lbrakk>x \\<le> a; solution (x, y); solution (a, b)\\<rbrakk>\n  \\<Longrightarrow> y \\<le> b\n  solution (a, b)\n  solution (x, y)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>a \\<le> x; solution (a, b); solution (x, y)\\<rbrakk>\n  \\<Longrightarrow> b \\<le> y\n  \\<lbrakk>x \\<le> a; solution (x, y); solution (a, b)\\<rbrakk>\n  \\<Longrightarrow> y \\<le> b\n  solution (a, b)\n  solution (x, y)\n\ngoal (1 subgoal):\n 1. a \\<le> x \\<and> b \\<le> y \\<or> x \\<le> a \\<and> y \\<le> b", "by (cases \"a \\<le> x\") auto"], ["proof (state)\nthis:\n  a \\<le> x \\<and> b \\<le> y \\<or> x \\<le> a \\<and> y \\<le> b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma solutions_linorder_strict:\n  fixes a b x y :: nat\n  assumes \"solution (a, b)\" \"solution (x, y)\"\n  shows   \"(a, b) = (x, y) \\<or> a < x \\<and> b < y \\<or> a > x \\<and> b > y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) = (x, y) \\<or> a < x \\<and> b < y \\<or> x < a \\<and> y < b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (a, b) = (x, y) \\<or> a < x \\<and> b < y \\<or> x < a \\<and> y < b", "have \"b = y\" if \"a = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = y", "using that assms and D_gt_1"], ["proof (prove)\nusing this:\n  a = x\n  solution (a, b)\n  solution (x, y)\n  1 < D\n\ngoal (1 subgoal):\n 1. b = y", "by (simp add: solution_def)"], ["proof (state)\nthis:\n  a = x \\<Longrightarrow> b = y\n\ngoal (1 subgoal):\n 1. (a, b) = (x, y) \\<or> a < x \\<and> b < y \\<or> x < a \\<and> y < b", "moreover"], ["proof (state)\nthis:\n  a = x \\<Longrightarrow> b = y\n\ngoal (1 subgoal):\n 1. (a, b) = (x, y) \\<or> a < x \\<and> b < y \\<or> x < a \\<and> y < b", "have \"a = x\" if \"b = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a = x", "from that and assms"], ["proof (chain)\npicking this:\n  b = y\n  solution (a, b)\n  solution (x, y)", "have \"a\\<^sup>2 = Suc (D * y\\<^sup>2)\""], ["proof (prove)\nusing this:\n  b = y\n  solution (a, b)\n  solution (x, y)\n\ngoal (1 subgoal):\n 1. a\\<^sup>2 = Suc (D * y\\<^sup>2)", "by (simp add: solution_def)"], ["proof (state)\nthis:\n  a\\<^sup>2 = Suc (D * y\\<^sup>2)\n\ngoal (1 subgoal):\n 1. a = x", "also"], ["proof (state)\nthis:\n  a\\<^sup>2 = Suc (D * y\\<^sup>2)\n\ngoal (1 subgoal):\n 1. a = x", "from that and assms"], ["proof (chain)\npicking this:\n  b = y\n  solution (a, b)\n  solution (x, y)", "have \"\\<dots> = x\\<^sup>2\""], ["proof (prove)\nusing this:\n  b = y\n  solution (a, b)\n  solution (x, y)\n\ngoal (1 subgoal):\n 1. Suc (D * y\\<^sup>2) = x\\<^sup>2", "by (simp add: solution_def)"], ["proof (state)\nthis:\n  Suc (D * y\\<^sup>2) = x\\<^sup>2\n\ngoal (1 subgoal):\n 1. a = x", "finally"], ["proof (chain)\npicking this:\n  a\\<^sup>2 = x\\<^sup>2", "show \"a = x\""], ["proof (prove)\nusing this:\n  a\\<^sup>2 = x\\<^sup>2\n\ngoal (1 subgoal):\n 1. a = x", "by simp"], ["proof (state)\nthis:\n  a = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b = y \\<Longrightarrow> a = x\n\ngoal (1 subgoal):\n 1. (a, b) = (x, y) \\<or> a < x \\<and> b < y \\<or> x < a \\<and> y < b", "ultimately"], ["proof (chain)\npicking this:\n  a = x \\<Longrightarrow> b = y\n  b = y \\<Longrightarrow> a = x", "have [simp]: \"a = x \\<longleftrightarrow> b = y\""], ["proof (prove)\nusing this:\n  a = x \\<Longrightarrow> b = y\n  b = y \\<Longrightarrow> a = x\n\ngoal (1 subgoal):\n 1. (a = x) = (b = y)", ".."], ["proof (state)\nthis:\n  (a = x) = (b = y)\n\ngoal (1 subgoal):\n 1. (a, b) = (x, y) \\<or> a < x \\<and> b < y \\<or> x < a \\<and> y < b", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, b) = (x, y) \\<or> a < x \\<and> b < y \\<or> x < a \\<and> y < b", "using solutions_linorder[OF assms]"], ["proof (prove)\nusing this:\n  a \\<le> x \\<and> b \\<le> y \\<or> x \\<le> a \\<and> y \\<le> b\n\ngoal (1 subgoal):\n 1. (a, b) = (x, y) \\<or> a < x \\<and> b < y \\<or> x < a \\<and> y < b", "by (cases a x rule: linorder_cases; cases b y rule: linorder_cases) simp_all"], ["proof (state)\nthis:\n  (a, b) = (x, y) \\<or> a < x \\<and> b < y \\<or> x < a \\<and> y < b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma solutions_le_iff_pell_valuation_le:\n  fixes a b x y :: nat\n  assumes \"solution (a, b)\" \"solution (x, y)\"\n  shows   \"a \\<le> x \\<and> b \\<le> y \\<longleftrightarrow> pell_valuation (a, b) \\<le> pell_valuation (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<le> x \\<and> b \\<le> y) =\n    (pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n     \\<le> pell_valuation\n            (case (x, y) of (x, y) \\<Rightarrow> (int x, int y)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<le> x \\<and> b \\<le> y \\<Longrightarrow>\n    pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n    \\<le> pell_valuation\n           (case (x, y) of (x, y) \\<Rightarrow> (int x, int y))\n 2. pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n    \\<le> pell_valuation\n           (case (x, y) of\n            (x, y) \\<Rightarrow> (int x, int y)) \\<Longrightarrow>\n    a \\<le> x \\<and> b \\<le> y", "assume \"a \\<le> x \\<and> b \\<le> y\""], ["proof (state)\nthis:\n  a \\<le> x \\<and> b \\<le> y\n\ngoal (2 subgoals):\n 1. a \\<le> x \\<and> b \\<le> y \\<Longrightarrow>\n    pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n    \\<le> pell_valuation\n           (case (x, y) of (x, y) \\<Rightarrow> (int x, int y))\n 2. pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n    \\<le> pell_valuation\n           (case (x, y) of\n            (x, y) \\<Rightarrow> (int x, int y)) \\<Longrightarrow>\n    a \\<le> x \\<and> b \\<le> y", "thus \"pell_valuation (a, b) \\<le> pell_valuation (x, y)\""], ["proof (prove)\nusing this:\n  a \\<le> x \\<and> b \\<le> y\n\ngoal (1 subgoal):\n 1. pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n    \\<le> pell_valuation\n           (case (x, y) of (x, y) \\<Rightarrow> (int x, int y))", "unfolding pell_valuation_def prod.case"], ["proof (prove)\nusing this:\n  a \\<le> x \\<and> b \\<le> y\n\ngoal (1 subgoal):\n 1. real_of_int (int a) + real_of_int (int b) * sqrt (real D)\n    \\<le> real_of_int (int x) + real_of_int (int y) * sqrt (real D)", "using D_gt_1"], ["proof (prove)\nusing this:\n  a \\<le> x \\<and> b \\<le> y\n  1 < D\n\ngoal (1 subgoal):\n 1. real_of_int (int a) + real_of_int (int b) * sqrt (real D)\n    \\<le> real_of_int (int x) + real_of_int (int y) * sqrt (real D)", "by (intro add_mono mult_right_mono) auto"], ["proof (state)\nthis:\n  pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n  \\<le> pell_valuation (case (x, y) of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (1 subgoal):\n 1. pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n    \\<le> pell_valuation\n           (case (x, y) of\n            (x, y) \\<Rightarrow> (int x, int y)) \\<Longrightarrow>\n    a \\<le> x \\<and> b \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n    \\<le> pell_valuation\n           (case (x, y) of\n            (x, y) \\<Rightarrow> (int x, int y)) \\<Longrightarrow>\n    a \\<le> x \\<and> b \\<le> y", "assume *: \"pell_valuation (a, b) \\<le> pell_valuation (x, y)\""], ["proof (state)\nthis:\n  pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n  \\<le> pell_valuation (case (x, y) of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (1 subgoal):\n 1. pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n    \\<le> pell_valuation\n           (case (x, y) of\n            (x, y) \\<Rightarrow> (int x, int y)) \\<Longrightarrow>\n    a \\<le> x \\<and> b \\<le> y", "from assms"], ["proof (chain)\npicking this:\n  solution (a, b)\n  solution (x, y)", "have \"a \\<le> x \\<and> b \\<le> y \\<or> x \\<le> a \\<and> y \\<le> b\""], ["proof (prove)\nusing this:\n  solution (a, b)\n  solution (x, y)\n\ngoal (1 subgoal):\n 1. a \\<le> x \\<and> b \\<le> y \\<or> x \\<le> a \\<and> y \\<le> b", "by (rule solutions_linorder)"], ["proof (state)\nthis:\n  a \\<le> x \\<and> b \\<le> y \\<or> x \\<le> a \\<and> y \\<le> b\n\ngoal (1 subgoal):\n 1. pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n    \\<le> pell_valuation\n           (case (x, y) of\n            (x, y) \\<Rightarrow> (int x, int y)) \\<Longrightarrow>\n    a \\<le> x \\<and> b \\<le> y", "thus \"a \\<le> x \\<and> b \\<le> y\""], ["proof (prove)\nusing this:\n  a \\<le> x \\<and> b \\<le> y \\<or> x \\<le> a \\<and> y \\<le> b\n\ngoal (1 subgoal):\n 1. a \\<le> x \\<and> b \\<le> y", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<le> x \\<and> b \\<le> y \\<Longrightarrow> a \\<le> x \\<and> b \\<le> y\n 2. x \\<le> a \\<and> y \\<le> b \\<Longrightarrow> a \\<le> x \\<and> b \\<le> y", "assume \"x \\<le> a \\<and> y \\<le> b\""], ["proof (state)\nthis:\n  x \\<le> a \\<and> y \\<le> b\n\ngoal (2 subgoals):\n 1. a \\<le> x \\<and> b \\<le> y \\<Longrightarrow> a \\<le> x \\<and> b \\<le> y\n 2. x \\<le> a \\<and> y \\<le> b \\<Longrightarrow> a \\<le> x \\<and> b \\<le> y", "hence \"pell_valuation (a, b) \\<ge> pell_valuation (x, y)\""], ["proof (prove)\nusing this:\n  x \\<le> a \\<and> y \\<le> b\n\ngoal (1 subgoal):\n 1. pell_valuation (case (x, y) of (x, y) \\<Rightarrow> (int x, int y))\n    \\<le> pell_valuation\n           (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))", "unfolding pell_valuation_def prod.case"], ["proof (prove)\nusing this:\n  x \\<le> a \\<and> y \\<le> b\n\ngoal (1 subgoal):\n 1. real_of_int (int x) + real_of_int (int y) * sqrt (real D)\n    \\<le> real_of_int (int a) + real_of_int (int b) * sqrt (real D)", "using D_gt_1"], ["proof (prove)\nusing this:\n  x \\<le> a \\<and> y \\<le> b\n  1 < D\n\ngoal (1 subgoal):\n 1. real_of_int (int x) + real_of_int (int y) * sqrt (real D)\n    \\<le> real_of_int (int a) + real_of_int (int b) * sqrt (real D)", "by (intro add_mono mult_right_mono) auto"], ["proof (state)\nthis:\n  pell_valuation (case (x, y) of (x, y) \\<Rightarrow> (int x, int y))\n  \\<le> pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (2 subgoals):\n 1. a \\<le> x \\<and> b \\<le> y \\<Longrightarrow> a \\<le> x \\<and> b \\<le> y\n 2. x \\<le> a \\<and> y \\<le> b \\<Longrightarrow> a \\<le> x \\<and> b \\<le> y", "with *"], ["proof (chain)\npicking this:\n  pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n  \\<le> pell_valuation (case (x, y) of (x, y) \\<Rightarrow> (int x, int y))\n  pell_valuation (case (x, y) of (x, y) \\<Rightarrow> (int x, int y))\n  \\<le> pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))", "have \"pell_valuation (a, b) = pell_valuation (x, y)\""], ["proof (prove)\nusing this:\n  pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n  \\<le> pell_valuation (case (x, y) of (x, y) \\<Rightarrow> (int x, int y))\n  pell_valuation (case (x, y) of (x, y) \\<Rightarrow> (int x, int y))\n  \\<le> pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (1 subgoal):\n 1. pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y)) =\n    pell_valuation (case (x, y) of (x, y) \\<Rightarrow> (int x, int y))", "by linarith"], ["proof (state)\nthis:\n  pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y)) =\n  pell_valuation (case (x, y) of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (2 subgoals):\n 1. a \\<le> x \\<and> b \\<le> y \\<Longrightarrow> a \\<le> x \\<and> b \\<le> y\n 2. x \\<le> a \\<and> y \\<le> b \\<Longrightarrow> a \\<le> x \\<and> b \\<le> y", "hence \"(a, b) = (x, y)\""], ["proof (prove)\nusing this:\n  pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y)) =\n  pell_valuation (case (x, y) of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (1 subgoal):\n 1. (a, b) = (x, y)", "by simp"], ["proof (state)\nthis:\n  (a, b) = (x, y)\n\ngoal (2 subgoals):\n 1. a \\<le> x \\<and> b \\<le> y \\<Longrightarrow> a \\<le> x \\<and> b \\<le> y\n 2. x \\<le> a \\<and> y \\<le> b \\<Longrightarrow> a \\<le> x \\<and> b \\<le> y", "thus \"a \\<le> x \\<and> b \\<le> y\""], ["proof (prove)\nusing this:\n  (a, b) = (x, y)\n\ngoal (1 subgoal):\n 1. a \\<le> x \\<and> b \\<le> y", "by simp"], ["proof (state)\nthis:\n  a \\<le> x \\<and> b \\<le> y\n\ngoal (1 subgoal):\n 1. a \\<le> x \\<and> b \\<le> y \\<Longrightarrow> a \\<le> x \\<and> b \\<le> y", "qed auto"], ["proof (state)\nthis:\n  a \\<le> x \\<and> b \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma solutions_less_iff_pell_valuation_less:\n  fixes a b x y :: nat\n  assumes \"solution (a, b)\" \"solution (x, y)\"\n  shows   \"a < x \\<and> b < y \\<longleftrightarrow> pell_valuation (a, b) < pell_valuation (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a < x \\<and> b < y) =\n    (pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n     < pell_valuation (case (x, y) of (x, y) \\<Rightarrow> (int x, int y)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a < x \\<and> b < y \\<Longrightarrow>\n    pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n    < pell_valuation (case (x, y) of (x, y) \\<Rightarrow> (int x, int y))\n 2. pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n    < pell_valuation\n       (case (x, y) of\n        (x, y) \\<Rightarrow> (int x, int y)) \\<Longrightarrow>\n    a < x \\<and> b < y", "assume \"a < x \\<and> b < y\""], ["proof (state)\nthis:\n  a < x \\<and> b < y\n\ngoal (2 subgoals):\n 1. a < x \\<and> b < y \\<Longrightarrow>\n    pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n    < pell_valuation (case (x, y) of (x, y) \\<Rightarrow> (int x, int y))\n 2. pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n    < pell_valuation\n       (case (x, y) of\n        (x, y) \\<Rightarrow> (int x, int y)) \\<Longrightarrow>\n    a < x \\<and> b < y", "thus \"pell_valuation (a, b) < pell_valuation (x, y)\""], ["proof (prove)\nusing this:\n  a < x \\<and> b < y\n\ngoal (1 subgoal):\n 1. pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n    < pell_valuation (case (x, y) of (x, y) \\<Rightarrow> (int x, int y))", "unfolding pell_valuation_def prod.case"], ["proof (prove)\nusing this:\n  a < x \\<and> b < y\n\ngoal (1 subgoal):\n 1. real_of_int (int a) + real_of_int (int b) * sqrt (real D)\n    < real_of_int (int x) + real_of_int (int y) * sqrt (real D)", "using D_gt_1"], ["proof (prove)\nusing this:\n  a < x \\<and> b < y\n  1 < D\n\ngoal (1 subgoal):\n 1. real_of_int (int a) + real_of_int (int b) * sqrt (real D)\n    < real_of_int (int x) + real_of_int (int y) * sqrt (real D)", "by (intro add_strict_mono mult_strict_right_mono) auto"], ["proof (state)\nthis:\n  pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n  < pell_valuation (case (x, y) of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (1 subgoal):\n 1. pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n    < pell_valuation\n       (case (x, y) of\n        (x, y) \\<Rightarrow> (int x, int y)) \\<Longrightarrow>\n    a < x \\<and> b < y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n    < pell_valuation\n       (case (x, y) of\n        (x, y) \\<Rightarrow> (int x, int y)) \\<Longrightarrow>\n    a < x \\<and> b < y", "assume *: \"pell_valuation (a, b) < pell_valuation (x, y)\""], ["proof (state)\nthis:\n  pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n  < pell_valuation (case (x, y) of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (1 subgoal):\n 1. pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n    < pell_valuation\n       (case (x, y) of\n        (x, y) \\<Rightarrow> (int x, int y)) \\<Longrightarrow>\n    a < x \\<and> b < y", "from assms"], ["proof (chain)\npicking this:\n  solution (a, b)\n  solution (x, y)", "have \"(a, b) = (x, y) \\<or> a < x \\<and> b < y \\<or> x < a \\<and> y < b\""], ["proof (prove)\nusing this:\n  solution (a, b)\n  solution (x, y)\n\ngoal (1 subgoal):\n 1. (a, b) = (x, y) \\<or> a < x \\<and> b < y \\<or> x < a \\<and> y < b", "by (rule solutions_linorder_strict)"], ["proof (state)\nthis:\n  (a, b) = (x, y) \\<or> a < x \\<and> b < y \\<or> x < a \\<and> y < b\n\ngoal (1 subgoal):\n 1. pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n    < pell_valuation\n       (case (x, y) of\n        (x, y) \\<Rightarrow> (int x, int y)) \\<Longrightarrow>\n    a < x \\<and> b < y", "thus \"a < x \\<and> b < y\""], ["proof (prove)\nusing this:\n  (a, b) = (x, y) \\<or> a < x \\<and> b < y \\<or> x < a \\<and> y < b\n\ngoal (1 subgoal):\n 1. a < x \\<and> b < y", "proof (elim disjE)"], ["proof (state)\ngoal (3 subgoals):\n 1. (a, b) = (x, y) \\<Longrightarrow> a < x \\<and> b < y\n 2. a < x \\<and> b < y \\<Longrightarrow> a < x \\<and> b < y\n 3. x < a \\<and> y < b \\<Longrightarrow> a < x \\<and> b < y", "assume \"x < a \\<and> y < b\""], ["proof (state)\nthis:\n  x < a \\<and> y < b\n\ngoal (3 subgoals):\n 1. (a, b) = (x, y) \\<Longrightarrow> a < x \\<and> b < y\n 2. a < x \\<and> b < y \\<Longrightarrow> a < x \\<and> b < y\n 3. x < a \\<and> y < b \\<Longrightarrow> a < x \\<and> b < y", "hence \"pell_valuation (a, b) > pell_valuation (x, y)\""], ["proof (prove)\nusing this:\n  x < a \\<and> y < b\n\ngoal (1 subgoal):\n 1. pell_valuation (case (x, y) of (x, y) \\<Rightarrow> (int x, int y))\n    < pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))", "unfolding pell_valuation_def prod.case"], ["proof (prove)\nusing this:\n  x < a \\<and> y < b\n\ngoal (1 subgoal):\n 1. real_of_int (int x) + real_of_int (int y) * sqrt (real D)\n    < real_of_int (int a) + real_of_int (int b) * sqrt (real D)", "using D_gt_1"], ["proof (prove)\nusing this:\n  x < a \\<and> y < b\n  1 < D\n\ngoal (1 subgoal):\n 1. real_of_int (int x) + real_of_int (int y) * sqrt (real D)\n    < real_of_int (int a) + real_of_int (int b) * sqrt (real D)", "by (intro add_strict_mono mult_strict_right_mono) auto"], ["proof (state)\nthis:\n  pell_valuation (case (x, y) of (x, y) \\<Rightarrow> (int x, int y))\n  < pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (3 subgoals):\n 1. (a, b) = (x, y) \\<Longrightarrow> a < x \\<and> b < y\n 2. a < x \\<and> b < y \\<Longrightarrow> a < x \\<and> b < y\n 3. x < a \\<and> y < b \\<Longrightarrow> a < x \\<and> b < y", "with *"], ["proof (chain)\npicking this:\n  pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n  < pell_valuation (case (x, y) of (x, y) \\<Rightarrow> (int x, int y))\n  pell_valuation (case (x, y) of (x, y) \\<Rightarrow> (int x, int y))\n  < pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))", "have False"], ["proof (prove)\nusing this:\n  pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n  < pell_valuation (case (x, y) of (x, y) \\<Rightarrow> (int x, int y))\n  pell_valuation (case (x, y) of (x, y) \\<Rightarrow> (int x, int y))\n  < pell_valuation (case (a, b) of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (1 subgoal):\n 1. False", "by linarith"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. (a, b) = (x, y) \\<Longrightarrow> a < x \\<and> b < y\n 2. a < x \\<and> b < y \\<Longrightarrow> a < x \\<and> b < y\n 3. x < a \\<and> y < b \\<Longrightarrow> a < x \\<and> b < y", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. a < x \\<and> b < y", ".."], ["proof (state)\nthis:\n  a < x \\<and> b < y\n\ngoal (2 subgoals):\n 1. (a, b) = (x, y) \\<Longrightarrow> a < x \\<and> b < y\n 2. a < x \\<and> b < y \\<Longrightarrow> a < x \\<and> b < y", "qed (insert *, auto)"], ["proof (state)\nthis:\n  a < x \\<and> b < y\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The fundamental solution\\<close>"], ["", "text \\<open>\n  The \\<^emph>\\<open>fundamental solution\\<close> is the non-trivial solution \\<open>(x, y)\\<close> with non-negative \\<open>x\\<close> and \\<open>y\\<close>\n  for which the Pell valuation $x + y\\sqrt{D}$ is minimal, or, equivalently, for which \\<open>x\\<close> and \\<open>y\\<close>\n  are minimal.\n\\<close>"], ["", "definition fund_sol :: \"nat \\<times> nat\" where\n  \"fund_sol = (THE z::nat\\<times>nat. is_arg_min (pell_valuation :: nat \\<times> nat \\<Rightarrow> real) nontriv_solution z)\""], ["", "text \\<open>\n  The well-definedness of this follows from the injectivity of the Pell valuation and the fact\n  that smaller Pell valuation of a solution is smaller than that of another iff the components\n  are both smaller.\n\\<close>"], ["", "theorem fund_sol_is_arg_min:\n  \"is_arg_min (pell_valuation :: nat \\<times> nat \\<Rightarrow> real) nontriv_solution fund_sol\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_arg_min\n     (\\<lambda>x.\n         pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n     nontriv_solution fund_sol", "unfolding fund_sol_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_arg_min\n     (\\<lambda>x.\n         pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n     nontriv_solution\n     (The (is_arg_min\n            (\\<lambda>x.\n                pell_valuation\n                 (case x of (x, y) \\<Rightarrow> (int x, int y)))\n            nontriv_solution))", "proof (rule theI')"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!x.\n       is_arg_min\n        (\\<lambda>x.\n            pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n        nontriv_solution x", "show \"\\<exists>!z::nat\\<times>nat. is_arg_min (pell_valuation :: nat \\<times> nat \\<Rightarrow> real) nontriv_solution z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!z.\n       is_arg_min\n        (\\<lambda>x.\n            pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n        nontriv_solution z", "proof (rule ex_ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>z.\n       is_arg_min\n        (\\<lambda>x.\n            pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n        nontriv_solution z\n 2. \\<And>z y.\n       \\<lbrakk>is_arg_min\n                 (\\<lambda>x.\n                     pell_valuation\n                      (case x of (x, y) \\<Rightarrow> (int x, int y)))\n                 nontriv_solution z;\n        is_arg_min\n         (\\<lambda>x.\n             pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n         nontriv_solution y\\<rbrakk>\n       \\<Longrightarrow> z = y", "fix z1 z2 :: \"nat \\<times> nat\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>z.\n       is_arg_min\n        (\\<lambda>x.\n            pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n        nontriv_solution z\n 2. \\<And>z y.\n       \\<lbrakk>is_arg_min\n                 (\\<lambda>x.\n                     pell_valuation\n                      (case x of (x, y) \\<Rightarrow> (int x, int y)))\n                 nontriv_solution z;\n        is_arg_min\n         (\\<lambda>x.\n             pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n         nontriv_solution y\\<rbrakk>\n       \\<Longrightarrow> z = y", "assume \"is_arg_min (pell_valuation :: nat \\<times> nat \\<Rightarrow> real) nontriv_solution z1\"\n           \"is_arg_min (pell_valuation :: nat \\<times> nat \\<Rightarrow> real) nontriv_solution z2\""], ["proof (state)\nthis:\n  is_arg_min\n   (\\<lambda>x.\n       pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n   nontriv_solution z1\n  is_arg_min\n   (\\<lambda>x.\n       pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n   nontriv_solution z2\n\ngoal (2 subgoals):\n 1. \\<exists>z.\n       is_arg_min\n        (\\<lambda>x.\n            pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n        nontriv_solution z\n 2. \\<And>z y.\n       \\<lbrakk>is_arg_min\n                 (\\<lambda>x.\n                     pell_valuation\n                      (case x of (x, y) \\<Rightarrow> (int x, int y)))\n                 nontriv_solution z;\n        is_arg_min\n         (\\<lambda>x.\n             pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n         nontriv_solution y\\<rbrakk>\n       \\<Longrightarrow> z = y", "hence \"pell_valuation z1 = pell_valuation z2\""], ["proof (prove)\nusing this:\n  is_arg_min\n   (\\<lambda>x.\n       pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n   nontriv_solution z1\n  is_arg_min\n   (\\<lambda>x.\n       pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n   nontriv_solution z2\n\ngoal (1 subgoal):\n 1. pell_valuation (case z1 of (x, y) \\<Rightarrow> (int x, int y)) =\n    pell_valuation (case z2 of (x, y) \\<Rightarrow> (int x, int y))", "by (cases z1, cases z2, intro antisym) (auto simp: is_arg_min_def not_less)"], ["proof (state)\nthis:\n  pell_valuation (case z1 of (x, y) \\<Rightarrow> (int x, int y)) =\n  pell_valuation (case z2 of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (2 subgoals):\n 1. \\<exists>z.\n       is_arg_min\n        (\\<lambda>x.\n            pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n        nontriv_solution z\n 2. \\<And>z y.\n       \\<lbrakk>is_arg_min\n                 (\\<lambda>x.\n                     pell_valuation\n                      (case x of (x, y) \\<Rightarrow> (int x, int y)))\n                 nontriv_solution z;\n        is_arg_min\n         (\\<lambda>x.\n             pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n         nontriv_solution y\\<rbrakk>\n       \\<Longrightarrow> z = y", "thus \"z1 = z2\""], ["proof (prove)\nusing this:\n  pell_valuation (case z1 of (x, y) \\<Rightarrow> (int x, int y)) =\n  pell_valuation (case z2 of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (1 subgoal):\n 1. z1 = z2", "by (auto split: prod.splits)"], ["proof (state)\nthis:\n  z1 = z2\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       is_arg_min\n        (\\<lambda>x.\n            pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n        nontriv_solution z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>z.\n       is_arg_min\n        (\\<lambda>x.\n            pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n        nontriv_solution z", "define y where \"y = (LEAST y. y > 0 \\<and> is_square (1 + D * y\\<^sup>2))\""], ["proof (state)\nthis:\n  y = (LEAST y. 0 < y \\<and> is_square (1 + D * y\\<^sup>2))\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       is_arg_min\n        (\\<lambda>x.\n            pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n        nontriv_solution z", "have \"\\<exists>y>0. is_square (1 + D * y\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y>0. is_square (1 + D * y\\<^sup>2)", "using pell_solution_exists"], ["proof (prove)\nusing this:\n  \\<exists>x y. y \\<noteq> 0 \\<and> x\\<^sup>2 = 1 + D * y\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>y>0. is_square (1 + D * y\\<^sup>2)", "by (auto simp: eq_commute[of _ \"Suc _\"])"], ["proof (state)\nthis:\n  \\<exists>y>0. is_square (1 + D * y\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       is_arg_min\n        (\\<lambda>x.\n            pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n        nontriv_solution z", "hence y: \"y > 0 \\<and> is_square (1 + D * y\\<^sup>2)\""], ["proof (prove)\nusing this:\n  \\<exists>y>0. is_square (1 + D * y\\<^sup>2)\n\ngoal (1 subgoal):\n 1. 0 < y \\<and> is_square (1 + D * y\\<^sup>2)", "unfolding y_def"], ["proof (prove)\nusing this:\n  \\<exists>y>0. is_square (1 + D * y\\<^sup>2)\n\ngoal (1 subgoal):\n 1. 0 < (LEAST y. 0 < y \\<and> is_square (1 + D * y\\<^sup>2)) \\<and>\n    is_square\n     (1 + D * (LEAST y. 0 < y \\<and> is_square (1 + D * y\\<^sup>2))\\<^sup>2)", "by (rule LeastI_ex)"], ["proof (state)\nthis:\n  0 < y \\<and> is_square (1 + D * y\\<^sup>2)\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       is_arg_min\n        (\\<lambda>x.\n            pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n        nontriv_solution z", "have y_le: \"y \\<le> y'\" if \"y' > 0\" \"is_square (1 + D * y'\\<^sup>2)\" for y'"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> y'", "unfolding y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST y. 0 < y \\<and> is_square (1 + D * y\\<^sup>2)) \\<le> y'", "using that"], ["proof (prove)\nusing this:\n  0 < y'\n  is_square (1 + D * y'\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (LEAST y. 0 < y \\<and> is_square (1 + D * y\\<^sup>2)) \\<le> y'", "by (intro Least_le) auto"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?y'2; is_square (1 + D * ?y'2\\<^sup>2)\\<rbrakk>\n  \\<Longrightarrow> y \\<le> ?y'2\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       is_arg_min\n        (\\<lambda>x.\n            pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n        nontriv_solution z", "from y"], ["proof (chain)\npicking this:\n  0 < y \\<and> is_square (1 + D * y\\<^sup>2)", "obtain x where x: \"x\\<^sup>2 = 1 + D * y\\<^sup>2\""], ["proof (prove)\nusing this:\n  0 < y \\<and> is_square (1 + D * y\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x\\<^sup>2 = 1 + D * y\\<^sup>2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: is_nth_powerE)"], ["proof (state)\nthis:\n  x\\<^sup>2 = 1 + D * y\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       is_arg_min\n        (\\<lambda>x.\n            pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n        nontriv_solution z", "with y"], ["proof (chain)\npicking this:\n  0 < y \\<and> is_square (1 + D * y\\<^sup>2)\n  x\\<^sup>2 = 1 + D * y\\<^sup>2", "have \"nontriv_solution (x, y)\""], ["proof (prove)\nusing this:\n  0 < y \\<and> is_square (1 + D * y\\<^sup>2)\n  x\\<^sup>2 = 1 + D * y\\<^sup>2\n\ngoal (1 subgoal):\n 1. nontriv_solution (x, y)", "by (auto simp: nontriv_solution_def)"], ["proof (state)\nthis:\n  nontriv_solution (x, y)\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       is_arg_min\n        (\\<lambda>x.\n            pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n        nontriv_solution z", "have \"is_arg_min (pell_valuation :: nat \\<times> nat \\<Rightarrow> real) nontriv_solution (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_arg_min\n     (\\<lambda>x.\n         pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n     nontriv_solution (x, y)", "unfolding is_arg_min_linorder"], ["proof (prove)\ngoal (1 subgoal):\n 1. nontriv_solution (x, y) \\<and>\n    (\\<forall>ya.\n        nontriv_solution ya \\<longrightarrow>\n        pell_valuation (case (x, y) of (x, y) \\<Rightarrow> (int x, int y))\n        \\<le> pell_valuation\n               (case ya of (x, y) \\<Rightarrow> (int x, int y)))", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. nontriv_solution (x, y)\n 2. \\<And>a b.\n       nontriv_solution (a, b) \\<Longrightarrow>\n       pell_valuation (int x, int y) \\<le> pell_valuation (int a, int b)", "fix a b :: nat"], ["proof (state)\ngoal (2 subgoals):\n 1. nontriv_solution (x, y)\n 2. \\<And>a b.\n       nontriv_solution (a, b) \\<Longrightarrow>\n       pell_valuation (int x, int y) \\<le> pell_valuation (int a, int b)", "assume *: \"nontriv_solution (a, b)\""], ["proof (state)\nthis:\n  nontriv_solution (a, b)\n\ngoal (2 subgoals):\n 1. nontriv_solution (x, y)\n 2. \\<And>a b.\n       nontriv_solution (a, b) \\<Longrightarrow>\n       pell_valuation (int x, int y) \\<le> pell_valuation (int a, int b)", "hence \"b > 0\" and \"Suc (D * b\\<^sup>2) = a\\<^sup>2\""], ["proof (prove)\nusing this:\n  nontriv_solution (a, b)\n\ngoal (1 subgoal):\n 1. 0 < b &&& Suc (D * b\\<^sup>2) = a\\<^sup>2", "by (auto simp: nontriv_solution_def intro!: Nat.gr0I)"], ["proof (state)\nthis:\n  0 < b\n  Suc (D * b\\<^sup>2) = a\\<^sup>2\n\ngoal (2 subgoals):\n 1. nontriv_solution (x, y)\n 2. \\<And>a b.\n       nontriv_solution (a, b) \\<Longrightarrow>\n       pell_valuation (int x, int y) \\<le> pell_valuation (int a, int b)", "hence \"is_square (1 + D * b\\<^sup>2)\""], ["proof (prove)\nusing this:\n  0 < b\n  Suc (D * b\\<^sup>2) = a\\<^sup>2\n\ngoal (1 subgoal):\n 1. is_square (1 + D * b\\<^sup>2)", "by (auto simp: nontriv_solution_def)"], ["proof (state)\nthis:\n  is_square (1 + D * b\\<^sup>2)\n\ngoal (2 subgoals):\n 1. nontriv_solution (x, y)\n 2. \\<And>a b.\n       nontriv_solution (a, b) \\<Longrightarrow>\n       pell_valuation (int x, int y) \\<le> pell_valuation (int a, int b)", "from \\<open>b > 0\\<close> and this"], ["proof (chain)\npicking this:\n  0 < b\n  is_square (1 + D * b\\<^sup>2)", "have \"y \\<le> b\""], ["proof (prove)\nusing this:\n  0 < b\n  is_square (1 + D * b\\<^sup>2)\n\ngoal (1 subgoal):\n 1. y \\<le> b", "by (rule y_le)"], ["proof (state)\nthis:\n  y \\<le> b\n\ngoal (2 subgoals):\n 1. nontriv_solution (x, y)\n 2. \\<And>a b.\n       nontriv_solution (a, b) \\<Longrightarrow>\n       pell_valuation (int x, int y) \\<le> pell_valuation (int a, int b)", "with \\<open>nontriv_solution (x, y)\\<close> and *"], ["proof (chain)\npicking this:\n  nontriv_solution (x, y)\n  nontriv_solution (a, b)\n  y \\<le> b", "have \"x \\<le> a\""], ["proof (prove)\nusing this:\n  nontriv_solution (x, y)\n  nontriv_solution (a, b)\n  y \\<le> b\n\ngoal (1 subgoal):\n 1. x \\<le> a", "using solutions_linorder_strict[of x y a b]"], ["proof (prove)\nusing this:\n  nontriv_solution (x, y)\n  nontriv_solution (a, b)\n  y \\<le> b\n  \\<lbrakk>solution (x, y); solution (a, b)\\<rbrakk>\n  \\<Longrightarrow> (x, y) = (a, b) \\<or>\n                    x < a \\<and> y < b \\<or> a < x \\<and> b < y\n\ngoal (1 subgoal):\n 1. x \\<le> a", "by (auto simp: nontriv_solution_altdef)"], ["proof (state)\nthis:\n  x \\<le> a\n\ngoal (2 subgoals):\n 1. nontriv_solution (x, y)\n 2. \\<And>a b.\n       nontriv_solution (a, b) \\<Longrightarrow>\n       pell_valuation (int x, int y) \\<le> pell_valuation (int a, int b)", "with \\<open>y \\<le> b\\<close>"], ["proof (chain)\npicking this:\n  y \\<le> b\n  x \\<le> a", "show \"pell_valuation (int x, int y) \\<le> pell_valuation (int a, int b)\""], ["proof (prove)\nusing this:\n  y \\<le> b\n  x \\<le> a\n\ngoal (1 subgoal):\n 1. pell_valuation (int x, int y) \\<le> pell_valuation (int a, int b)", "unfolding pell_valuation_def prod.case"], ["proof (prove)\nusing this:\n  y \\<le> b\n  x \\<le> a\n\ngoal (1 subgoal):\n 1. real_of_int (int x) + real_of_int (int y) * sqrt (real D)\n    \\<le> real_of_int (int a) + real_of_int (int b) * sqrt (real D)", "by (intro add_mono mult_right_mono) auto"], ["proof (state)\nthis:\n  pell_valuation (int x, int y) \\<le> pell_valuation (int a, int b)\n\ngoal (1 subgoal):\n 1. nontriv_solution (x, y)", "qed fact+"], ["proof (state)\nthis:\n  is_arg_min\n   (\\<lambda>x.\n       pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n   nontriv_solution (x, y)\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       is_arg_min\n        (\\<lambda>x.\n            pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n        nontriv_solution z", "thus \"\\<exists>z. is_arg_min (pell_valuation :: nat \\<times> nat \\<Rightarrow> real) nontriv_solution z\""], ["proof (prove)\nusing this:\n  is_arg_min\n   (\\<lambda>x.\n       pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n   nontriv_solution (x, y)\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       is_arg_min\n        (\\<lambda>x.\n            pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n        nontriv_solution z", ".."], ["proof (state)\nthis:\n  \\<exists>z.\n     is_arg_min\n      (\\<lambda>x.\n          pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n      nontriv_solution z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!z.\n     is_arg_min\n      (\\<lambda>x.\n          pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n      nontriv_solution z\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary\n      fund_sol_is_nontriv_solution: \"nontriv_solution fund_sol\"\n  and fund_sol_minimal:\n        \"nontriv_solution (a, b) \\<Longrightarrow> pell_valuation fund_sol \\<le> pell_valuation (int a, int b)\"\n  and fund_sol_minimal':\n        \"nontriv_solution (z :: nat \\<times> nat) \\<Longrightarrow> pell_valuation fund_sol \\<le> pell_valuation z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nontriv_solution fund_sol &&&\n    (nontriv_solution (a, b) \\<Longrightarrow>\n     pell_valuation (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))\n     \\<le> pell_valuation (int a, int b)) &&&\n    (nontriv_solution z \\<Longrightarrow>\n     pell_valuation (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))\n     \\<le> pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y)))", "using fund_sol_is_arg_min"], ["proof (prove)\nusing this:\n  is_arg_min\n   (\\<lambda>x.\n       pell_valuation (case x of (x, y) \\<Rightarrow> (int x, int y)))\n   nontriv_solution fund_sol\n\ngoal (1 subgoal):\n 1. nontriv_solution fund_sol &&&\n    (nontriv_solution (a, b) \\<Longrightarrow>\n     pell_valuation (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))\n     \\<le> pell_valuation (int a, int b)) &&&\n    (nontriv_solution z \\<Longrightarrow>\n     pell_valuation (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))\n     \\<le> pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y)))", "by (auto simp: is_arg_min_linorder case_prod_unfold)"], ["", "lemma fund_sol_minimal'':\n  assumes \"nontriv_solution z\"\n  shows   \"fst fund_sol \\<le> fst z\" \"snd fund_sol \\<le> snd z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst fund_sol \\<le> fst z &&& snd fund_sol \\<le> snd z", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. fst fund_sol \\<le> fst z\n 2. snd fund_sol \\<le> snd z", "have \"pell_valuation (fst fund_sol, snd fund_sol) \\<le> pell_valuation (fst z, snd z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_valuation\n     (case (fst fund_sol, snd fund_sol) of\n      (x, y) \\<Rightarrow> (int x, int y))\n    \\<le> pell_valuation\n           (case (fst z, snd z) of (x, y) \\<Rightarrow> (int x, int y))", "using fund_sol_minimal'[OF assms]"], ["proof (prove)\nusing this:\n  pell_valuation (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))\n  \\<le> pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (1 subgoal):\n 1. pell_valuation\n     (case (fst fund_sol, snd fund_sol) of\n      (x, y) \\<Rightarrow> (int x, int y))\n    \\<le> pell_valuation\n           (case (fst z, snd z) of (x, y) \\<Rightarrow> (int x, int y))", "by (simp add: case_prod_unfold)"], ["proof (state)\nthis:\n  pell_valuation\n   (case (fst fund_sol, snd fund_sol) of\n    (x, y) \\<Rightarrow> (int x, int y))\n  \\<le> pell_valuation\n         (case (fst z, snd z) of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (2 subgoals):\n 1. fst fund_sol \\<le> fst z\n 2. snd fund_sol \\<le> snd z", "hence \"fst fund_sol \\<le> fst z \\<and> snd fund_sol \\<le> snd z\""], ["proof (prove)\nusing this:\n  pell_valuation\n   (case (fst fund_sol, snd fund_sol) of\n    (x, y) \\<Rightarrow> (int x, int y))\n  \\<le> pell_valuation\n         (case (fst z, snd z) of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (1 subgoal):\n 1. fst fund_sol \\<le> fst z \\<and> snd fund_sol \\<le> snd z", "using assms fund_sol_is_nontriv_solution"], ["proof (prove)\nusing this:\n  pell_valuation\n   (case (fst fund_sol, snd fund_sol) of\n    (x, y) \\<Rightarrow> (int x, int y))\n  \\<le> pell_valuation\n         (case (fst z, snd z) of (x, y) \\<Rightarrow> (int x, int y))\n  nontriv_solution z\n  nontriv_solution fund_sol\n\ngoal (1 subgoal):\n 1. fst fund_sol \\<le> fst z \\<and> snd fund_sol \\<le> snd z", "by (subst solutions_le_iff_pell_valuation_le) (auto simp: case_prod_unfold)"], ["proof (state)\nthis:\n  fst fund_sol \\<le> fst z \\<and> snd fund_sol \\<le> snd z\n\ngoal (2 subgoals):\n 1. fst fund_sol \\<le> fst z\n 2. snd fund_sol \\<le> snd z", "thus \"fst fund_sol \\<le> fst z\" \"snd fund_sol \\<le> snd z\""], ["proof (prove)\nusing this:\n  fst fund_sol \\<le> fst z \\<and> snd fund_sol \\<le> snd z\n\ngoal (1 subgoal):\n 1. fst fund_sol \\<le> fst z &&& snd fund_sol \\<le> snd z", "by blast+"], ["proof (state)\nthis:\n  fst fund_sol \\<le> fst z\n  snd fund_sol \\<le> snd z\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Group structure on solutions\\<close>"], ["", "text \\<open>\n  As was mentioned already, the Pell valuation function provides an injective map from\n  solutions of Pell's equation into the ring $\\mathbb{Z}[\\sqrt{D}]$. We shall see now that\n  the solutions are actually a subgroup of the multiplicative group of $\\mathbb{Z}[\\sqrt{D}]$ via\n  the valuation function as a homomorphism:\n\n    \\<^item> The trivial solution \\<open>(1, 0)\\<close> has valuation \\<open>1\\<close>, which is the neutral element of\n      $\\mathbb{Z}[\\sqrt{D}]^*$\n\n    \\<^item> Multiplication of two solutions $a + b \\sqrt D$ and\n      $x + y \\sqrt D$ leads to $\\bar x + \\bar y\\sqrt D$\n      with $\\bar x = xa + ybD$ and $\\bar y = xb + ya$, which is again a solution.\n\n    \\<^item> The conjugate \\<open>(x, -y)\\<close> of a solution \\<open>(x, y)\\<close> is an inverse element to this\n      multiplication operation, since $(x + y \\sqrt D) (x - y \\sqrt D) = 1$.\n\\<close>"], ["", "definition pell_mul :: \"('a :: comm_semiring_1 \\<times> 'a) \\<Rightarrow> ('a \\<times> 'a) \\<Rightarrow> ('a \\<times> 'a)\" where\n  \"pell_mul = (\\<lambda>(a,b) (x,y). (x * a + y * b * of_nat D, x * b + y * a))\""], ["", "definition pell_cnj :: \"('a :: comm_ring_1 \\<times> 'a) \\<Rightarrow> 'a \\<times> 'a\" where\n  \"pell_cnj = (\\<lambda>(a,b). (a, -b))\""], ["", "lemma pell_cnj_snd_0 [simp]: \"snd z = 0 \\<Longrightarrow> pell_cnj z = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd z = (0::'a) \\<Longrightarrow> pell_cnj z = z", "by (cases z) (simp_all add: pell_cnj_def)"], ["", "lemma pell_mul_commutes: \"pell_mul z1 z2 = pell_mul z2 z1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_mul z1 z2 = pell_mul z2 z1", "by (auto simp: pell_mul_def algebra_simps case_prod_unfold)"], ["", "lemma pell_mul_assoc: \"pell_mul z1 (pell_mul z2 z3) = pell_mul (pell_mul z1 z2) z3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_mul z1 (pell_mul z2 z3) = pell_mul (pell_mul z1 z2) z3", "by (auto simp: pell_mul_def algebra_simps case_prod_unfold)"], ["", "lemma pell_mul_trivial_left [simp]: \"pell_mul (1, 0) z = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_mul (1::'a, 0::'a) z = z", "by (auto simp: pell_mul_def algebra_simps case_prod_unfold)"], ["", "lemma pell_mul_trivial_right [simp]: \"pell_mul z (1, 0) = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_mul z (1::'a, 0::'a) = z", "by (auto simp: pell_mul_def algebra_simps case_prod_unfold)"], ["", "lemma pell_mul_trivial_left_nat [simp]: \"pell_mul (Suc 0, 0) z = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_mul (Suc 0, 0) z = z", "by (auto simp: pell_mul_def algebra_simps case_prod_unfold)"], ["", "lemma pell_mul_trivial_right_nat [simp]: \"pell_mul z (Suc 0, 0) = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_mul z (Suc 0, 0) = z", "by (auto simp: pell_mul_def algebra_simps case_prod_unfold)"], ["", "definition pell_power :: \"('a :: comm_semiring_1 \\<times> 'a) \\<Rightarrow> nat \\<Rightarrow> ('a \\<times> 'a)\" where\n  \"pell_power z n = ((\\<lambda>z'. pell_mul z' z) ^^ n) (1, 0)\""], ["", "lemma pell_power_0 [simp]: \"pell_power z 0 = (1, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_power z 0 = (1::'a, 0::'a)", "by (simp add: pell_power_def)"], ["", "lemma pell_power_one [simp]: \"pell_power (1, 0) n = (1, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_power (1::'a, 0::'a) n = (1::'a, 0::'a)", "by (induction n) (auto simp: pell_power_def)"], ["", "lemma pell_power_one_right [simp]: \"pell_power z 1 = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_power z 1 = z", "by (simp add: pell_power_def)"], ["", "lemma pell_power_Suc: \"pell_power z (Suc n) = pell_mul z (pell_power z n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_power z (Suc n) = pell_mul z (pell_power z n)", "by (simp add: pell_power_def pell_mul_commutes)"], ["", "lemma pell_power_add: \"pell_power z (m + n) = pell_mul (pell_power z m) (pell_power z n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_power z (m + n) = pell_mul (pell_power z m) (pell_power z n)", "by (induction m arbitrary: z )\n     (simp_all add: funpow_add o_def pell_power_Suc pell_mul_assoc)"], ["", "lemma pell_valuation_mult [simp]:\n  \"pell_valuation (pell_mul z1 z2) = pell_valuation z1 * pell_valuation z2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_valuation (pell_mul z1 z2) = pell_valuation z1 * pell_valuation z2", "by (simp add: pell_valuation_def pell_mul_def case_prod_unfold algebra_simps)"], ["", "lemma pell_valuation_mult_nat [simp]:\n  \"pell_valuation (case pell_mul z1 z2 of (a, b) \\<Rightarrow> (int a, int b)) =\n     pell_valuation z1 * pell_valuation z2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_valuation\n     (case pell_mul z1 z2 of (a, b) \\<Rightarrow> (int a, int b)) =\n    pell_valuation (case z1 of (x, y) \\<Rightarrow> (int x, int y)) *\n    pell_valuation (case z2 of (x, y) \\<Rightarrow> (int x, int y))", "by (simp add: pell_valuation_def pell_mul_def case_prod_unfold algebra_simps)"], ["", "lemma pell_valuation_trivial [simp]: \"pell_valuation (1, 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_valuation (1, 0) = 1", "by (simp add: pell_valuation_def)"], ["", "lemma pell_valuation_trivial_nat [simp]: \"pell_valuation (Suc 0, 0) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_valuation (case (Suc 0, 0) of (x, y) \\<Rightarrow> (int x, y)) = 1", "by (simp add: pell_valuation_def)"], ["", "lemma pell_valuation_cnj: \"pell_valuation (pell_cnj z) = fst z - snd z * sqrt D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_valuation (pell_cnj z) =\n    fst (case z of (x, y) \\<Rightarrow> (real_of_int x, y)) -\n    snd (case z of (x, y) \\<Rightarrow> (x, real_of_int y)) * sqrt (real D)", "by (simp add: pell_valuation_def pell_cnj_def case_prod_unfold)"], ["", "lemma pell_valuation_snd_0 [simp]: \"pell_valuation (a, 0) = of_int a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_valuation (a, 0) = real_of_int a", "by (simp add: pell_valuation_def)"], ["", "lemma pell_valuation_0_iff [simp]: \"pell_valuation z = 0 \\<longleftrightarrow> z = (0, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pell_valuation z = 0) = (z = (0, 0))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. pell_valuation z = 0 \\<Longrightarrow> z = (0, 0)\n 2. z = (0, 0) \\<Longrightarrow> pell_valuation z = 0", "assume *: \"pell_valuation z = 0\""], ["proof (state)\nthis:\n  pell_valuation z = 0\n\ngoal (2 subgoals):\n 1. pell_valuation z = 0 \\<Longrightarrow> z = (0, 0)\n 2. z = (0, 0) \\<Longrightarrow> pell_valuation z = 0", "have \"snd z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd z = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. snd z \\<noteq> 0 \\<Longrightarrow> False", "assume \"snd z \\<noteq> 0\""], ["proof (state)\nthis:\n  snd z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. snd z \\<noteq> 0 \\<Longrightarrow> False", "with *"], ["proof (chain)\npicking this:\n  pell_valuation z = 0\n  snd z \\<noteq> 0", "have \"sqrt D = -fst z / snd z\""], ["proof (prove)\nusing this:\n  pell_valuation z = 0\n  snd z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sqrt (real D) = real_of_int (- fst z) / real_of_int (snd z)", "by (simp add: pell_valuation_def case_prod_unfold field_simps)"], ["proof (state)\nthis:\n  sqrt (real D) = real_of_int (- fst z) / real_of_int (snd z)\n\ngoal (1 subgoal):\n 1. snd z \\<noteq> 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  sqrt (real D) = real_of_int (- fst z) / real_of_int (snd z)\n\ngoal (1 subgoal):\n 1. snd z \\<noteq> 0 \\<Longrightarrow> False", "have \"\\<dots> \\<in> \\<rat>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (- fst z) / real_of_int (snd z) \\<in> \\<rat>", "by auto"], ["proof (state)\nthis:\n  real_of_int (- fst z) / real_of_int (snd z) \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. snd z \\<noteq> 0 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  sqrt (real D) \\<in> \\<rat>", "show False"], ["proof (prove)\nusing this:\n  sqrt (real D) \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. False", "using nonsquare_D irrat_sqrt_nonsquare"], ["proof (prove)\nusing this:\n  sqrt (real D) \\<in> \\<rat>\n  \\<not> is_square D\n  \\<not> is_square ?n \\<Longrightarrow> sqrt (real ?n) \\<notin> \\<rat>\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  snd z = 0\n\ngoal (2 subgoals):\n 1. pell_valuation z = 0 \\<Longrightarrow> z = (0, 0)\n 2. z = (0, 0) \\<Longrightarrow> pell_valuation z = 0", "with *"], ["proof (chain)\npicking this:\n  pell_valuation z = 0\n  snd z = 0", "have \"fst z = 0\""], ["proof (prove)\nusing this:\n  pell_valuation z = 0\n  snd z = 0\n\ngoal (1 subgoal):\n 1. fst z = 0", "by (simp add: pell_valuation_def case_prod_unfold)"], ["proof (state)\nthis:\n  fst z = 0\n\ngoal (2 subgoals):\n 1. pell_valuation z = 0 \\<Longrightarrow> z = (0, 0)\n 2. z = (0, 0) \\<Longrightarrow> pell_valuation z = 0", "with \\<open>snd z = 0\\<close>"], ["proof (chain)\npicking this:\n  snd z = 0\n  fst z = 0", "show \"z = (0, 0)\""], ["proof (prove)\nusing this:\n  snd z = 0\n  fst z = 0\n\ngoal (1 subgoal):\n 1. z = (0, 0)", "by (cases z) auto"], ["proof (state)\nthis:\n  z = (0, 0)\n\ngoal (1 subgoal):\n 1. z = (0, 0) \\<Longrightarrow> pell_valuation z = 0", "qed (auto simp: pell_valuation_def)"], ["", "lemma pell_valuation_solution_pos_nat:\n  fixes z :: \"nat \\<times> nat\"\n  assumes \"solution z\"\n  shows   \"pell_valuation z > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y))", "from assms"], ["proof (chain)\npicking this:\n  solution z", "have \"z \\<noteq> (0, 0)\""], ["proof (prove)\nusing this:\n  solution z\n\ngoal (1 subgoal):\n 1. z \\<noteq> (0, 0)", "by (intro notI) auto"], ["proof (state)\nthis:\n  z \\<noteq> (0, 0)\n\ngoal (1 subgoal):\n 1. 0 < pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y))", "hence \"pell_valuation z \\<noteq> 0\""], ["proof (prove)\nusing this:\n  z \\<noteq> (0, 0)\n\ngoal (1 subgoal):\n 1. pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y)) \\<noteq>\n    0", "by (auto split: prod.splits)"], ["proof (state)\nthis:\n  pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y))", "moreover"], ["proof (state)\nthis:\n  pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y))", "have \"pell_valuation z \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y))", "by (intro pell_valuation_nonneg) (auto split: prod.splits)"], ["proof (state)\nthis:\n  0 \\<le> pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (1 subgoal):\n 1. 0 < pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y))", "ultimately"], ["proof (chain)\npicking this:\n  pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y)) \\<noteq> 0\n  0 \\<le> pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y))", "show ?thesis"], ["proof (prove)\nusing this:\n  pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y)) \\<noteq> 0\n  0 \\<le> pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (1 subgoal):\n 1. 0 < pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y))", "by linarith"], ["proof (state)\nthis:\n  0 < pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  assumes \"solution z\"\n  shows   pell_mul_cnj_right: \"pell_mul z (pell_cnj z) = (1, 0)\"\n    and   pell_mul_cnj_left: \"pell_mul (pell_cnj z) z = (1, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_mul z (pell_cnj z) = (1::'a, 0::'a) &&&\n    pell_mul (pell_cnj z) z = (1::'a, 0::'a)", "using assms"], ["proof (prove)\nusing this:\n  solution z\n\ngoal (1 subgoal):\n 1. pell_mul z (pell_cnj z) = (1::'a, 0::'a) &&&\n    pell_mul (pell_cnj z) z = (1::'a, 0::'a)", "by (auto simp: pell_mul_def pell_cnj_def solution_def power2_eq_square)"], ["", "lemma pell_valuation_cnj_solution:\n  fixes z :: \"nat \\<times> nat\"\n  assumes \"solution z\"\n  shows   \"pell_valuation (pell_cnj z) = 1 / pell_valuation z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_valuation\n     (pell_cnj (case z of (x, y) \\<Rightarrow> (int x, int y))) =\n    1 / pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pell_valuation\n     (pell_cnj (case z of (x, y) \\<Rightarrow> (int x, int y))) =\n    1 / pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y))", "have \"pell_valuation (pell_cnj z) * pell_valuation z = pell_valuation (pell_mul (pell_cnj z) z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_valuation\n     (pell_cnj (case z of (x, y) \\<Rightarrow> (int x, int y))) *\n    pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y)) =\n    pell_valuation\n     (pell_mul (pell_cnj (case z of (x, y) \\<Rightarrow> (int x, int y)))\n       (case z of (x, y) \\<Rightarrow> (int x, int y)))", "by simp"], ["proof (state)\nthis:\n  pell_valuation\n   (pell_cnj (case z of (x, y) \\<Rightarrow> (int x, int y))) *\n  pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y)) =\n  pell_valuation\n   (pell_mul (pell_cnj (case z of (x, y) \\<Rightarrow> (int x, int y)))\n     (case z of (x, y) \\<Rightarrow> (int x, int y)))\n\ngoal (1 subgoal):\n 1. pell_valuation\n     (pell_cnj (case z of (x, y) \\<Rightarrow> (int x, int y))) =\n    1 / pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y))", "also"], ["proof (state)\nthis:\n  pell_valuation\n   (pell_cnj (case z of (x, y) \\<Rightarrow> (int x, int y))) *\n  pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y)) =\n  pell_valuation\n   (pell_mul (pell_cnj (case z of (x, y) \\<Rightarrow> (int x, int y)))\n     (case z of (x, y) \\<Rightarrow> (int x, int y)))\n\ngoal (1 subgoal):\n 1. pell_valuation\n     (pell_cnj (case z of (x, y) \\<Rightarrow> (int x, int y))) =\n    1 / pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y))", "from assms"], ["proof (chain)\npicking this:\n  solution z", "have \"pell_mul (pell_cnj z) z = (1, 0)\""], ["proof (prove)\nusing this:\n  solution z\n\ngoal (1 subgoal):\n 1. pell_mul (pell_cnj (case z of (x, y) \\<Rightarrow> (int x, int y)))\n     (case z of (x, y) \\<Rightarrow> (int x, int y)) =\n    (1, 0)", "by (subst pell_mul_cnj_left) (auto simp: case_prod_unfold)"], ["proof (state)\nthis:\n  pell_mul (pell_cnj (case z of (x, y) \\<Rightarrow> (int x, int y)))\n   (case z of (x, y) \\<Rightarrow> (int x, int y)) =\n  (1, 0)\n\ngoal (1 subgoal):\n 1. pell_valuation\n     (pell_cnj (case z of (x, y) \\<Rightarrow> (int x, int y))) =\n    1 / pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y))", "finally"], ["proof (chain)\npicking this:\n  pell_valuation\n   (pell_cnj (case z of (x, y) \\<Rightarrow> (int x, int y))) *\n  pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y)) =\n  pell_valuation (1, 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  pell_valuation\n   (pell_cnj (case z of (x, y) \\<Rightarrow> (int x, int y))) *\n  pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y)) =\n  pell_valuation (1, 0)\n\ngoal (1 subgoal):\n 1. pell_valuation\n     (pell_cnj (case z of (x, y) \\<Rightarrow> (int x, int y))) =\n    1 / pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y))", "using pell_valuation_solution_pos_nat[OF assms]"], ["proof (prove)\nusing this:\n  pell_valuation\n   (pell_cnj (case z of (x, y) \\<Rightarrow> (int x, int y))) *\n  pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y)) =\n  pell_valuation (1, 0)\n  0 < pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (1 subgoal):\n 1. pell_valuation\n     (pell_cnj (case z of (x, y) \\<Rightarrow> (int x, int y))) =\n    1 / pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y))", "by (auto simp: divide_simps)"], ["proof (state)\nthis:\n  pell_valuation\n   (pell_cnj (case z of (x, y) \\<Rightarrow> (int x, int y))) =\n  1 / pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pell_valuation_power [simp]: \"pell_valuation (pell_power z n) = pell_valuation z ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_valuation (pell_power z n) = pell_valuation z ^ n", "by (induction n) (simp_all add: pell_power_Suc)"], ["", "lemma pell_valuation_power_nat [simp]:\n  \"pell_valuation (case pell_power z n of (a, b) \\<Rightarrow> (int a, int b)) = pell_valuation z ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_valuation\n     (case pell_power z n of (a, b) \\<Rightarrow> (int a, int b)) =\n    pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y)) ^ n", "by (induction n) (simp_all add: pell_power_Suc)"], ["", "lemma pell_valuation_fund_sol_ge_2: \"pell_valuation fund_sol \\<ge> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> pell_valuation\n             (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 \\<le> pell_valuation\n             (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))", "obtain x y where [simp]: \"fund_sol = (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        fund_sol = (x, y) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases fund_sol)"], ["proof (state)\nthis:\n  fund_sol = (x, y)\n\ngoal (1 subgoal):\n 1. 2 \\<le> pell_valuation\n             (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))", "from fund_sol_is_nontriv_solution"], ["proof (chain)\npicking this:\n  nontriv_solution fund_sol", "have eq: \"x\\<^sup>2 = 1 + D * y\\<^sup>2\""], ["proof (prove)\nusing this:\n  nontriv_solution fund_sol\n\ngoal (1 subgoal):\n 1. x\\<^sup>2 = 1 + D * y\\<^sup>2", "by (auto simp: nontriv_solution_def)"], ["proof (state)\nthis:\n  x\\<^sup>2 = 1 + D * y\\<^sup>2\n\ngoal (1 subgoal):\n 1. 2 \\<le> pell_valuation\n             (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))", "consider \"y > 0\" | \"y = 0\" \"x \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < y \\<Longrightarrow> thesis;\n     \\<lbrakk>y = 0; x \\<noteq> 1\\<rbrakk> \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using fund_sol_is_nontriv_solution"], ["proof (prove)\nusing this:\n  nontriv_solution fund_sol\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < y \\<Longrightarrow> thesis;\n     \\<lbrakk>y = 0; x \\<noteq> 1\\<rbrakk> \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (force simp: nontriv_solution_def)"], ["proof (state)\nthis:\n  \\<lbrakk>0 < y \\<Longrightarrow> ?thesis4;\n   \\<lbrakk>y = 0; x \\<noteq> 1\\<rbrakk> \\<Longrightarrow> ?thesis4\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n\ngoal (1 subgoal):\n 1. 2 \\<le> pell_valuation\n             (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < y \\<Longrightarrow> ?thesis4;\n   \\<lbrakk>y = 0; x \\<noteq> 1\\<rbrakk> \\<Longrightarrow> ?thesis4\\<rbrakk>\n  \\<Longrightarrow> ?thesis4\n\ngoal (1 subgoal):\n 1. 2 \\<le> pell_valuation\n             (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < y \\<Longrightarrow>\n    2 \\<le> pell_valuation\n             (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))\n 2. \\<lbrakk>y = 0; x \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> 2 \\<le> pell_valuation\n                               (case fund_sol of\n                                (x, y) \\<Rightarrow> (int x, int y))", "assume \"y > 0\""], ["proof (state)\nthis:\n  0 < y\n\ngoal (2 subgoals):\n 1. 0 < y \\<Longrightarrow>\n    2 \\<le> pell_valuation\n             (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))\n 2. \\<lbrakk>y = 0; x \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> 2 \\<le> pell_valuation\n                               (case fund_sol of\n                                (x, y) \\<Rightarrow> (int x, int y))", "hence \"1 + 1 * 1 \\<le> 1 + D * y\\<^sup>2\""], ["proof (prove)\nusing this:\n  0 < y\n\ngoal (1 subgoal):\n 1. 1 + 1 * 1 \\<le> 1 + D * y\\<^sup>2", "using D_pos"], ["proof (prove)\nusing this:\n  0 < y\n  0 < D\n\ngoal (1 subgoal):\n 1. 1 + 1 * 1 \\<le> 1 + D * y\\<^sup>2", "by (intro add_mono mult_mono) auto"], ["proof (state)\nthis:\n  1 + 1 * 1 \\<le> 1 + D * y\\<^sup>2\n\ngoal (2 subgoals):\n 1. 0 < y \\<Longrightarrow>\n    2 \\<le> pell_valuation\n             (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))\n 2. \\<lbrakk>y = 0; x \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> 2 \\<le> pell_valuation\n                               (case fund_sol of\n                                (x, y) \\<Rightarrow> (int x, int y))", "also"], ["proof (state)\nthis:\n  1 + 1 * 1 \\<le> 1 + D * y\\<^sup>2\n\ngoal (2 subgoals):\n 1. 0 < y \\<Longrightarrow>\n    2 \\<le> pell_valuation\n             (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))\n 2. \\<lbrakk>y = 0; x \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> 2 \\<le> pell_valuation\n                               (case fund_sol of\n                                (x, y) \\<Rightarrow> (int x, int y))", "from eq"], ["proof (chain)\npicking this:\n  x\\<^sup>2 = 1 + D * y\\<^sup>2", "have \"\\<dots> = x\\<^sup>2\""], ["proof (prove)\nusing this:\n  x\\<^sup>2 = 1 + D * y\\<^sup>2\n\ngoal (1 subgoal):\n 1. 1 + D * y\\<^sup>2 = x\\<^sup>2", ".."], ["proof (state)\nthis:\n  1 + D * y\\<^sup>2 = x\\<^sup>2\n\ngoal (2 subgoals):\n 1. 0 < y \\<Longrightarrow>\n    2 \\<le> pell_valuation\n             (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))\n 2. \\<lbrakk>y = 0; x \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> 2 \\<le> pell_valuation\n                               (case fund_sol of\n                                (x, y) \\<Rightarrow> (int x, int y))", "finally"], ["proof (chain)\npicking this:\n  1 + 1 * 1 \\<le> x\\<^sup>2", "have \"x\\<^sup>2 > 1\\<^sup>2\""], ["proof (prove)\nusing this:\n  1 + 1 * 1 \\<le> x\\<^sup>2\n\ngoal (1 subgoal):\n 1. 1\\<^sup>2 < x\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  1\\<^sup>2 < x\\<^sup>2\n\ngoal (2 subgoals):\n 1. 0 < y \\<Longrightarrow>\n    2 \\<le> pell_valuation\n             (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))\n 2. \\<lbrakk>y = 0; x \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> 2 \\<le> pell_valuation\n                               (case fund_sol of\n                                (x, y) \\<Rightarrow> (int x, int y))", "hence \"x > 1\""], ["proof (prove)\nusing this:\n  1\\<^sup>2 < x\\<^sup>2\n\ngoal (1 subgoal):\n 1. 1 < x", "by (rule power2_less_imp_less) auto"], ["proof (state)\nthis:\n  1 < x\n\ngoal (2 subgoals):\n 1. 0 < y \\<Longrightarrow>\n    2 \\<le> pell_valuation\n             (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))\n 2. \\<lbrakk>y = 0; x \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> 2 \\<le> pell_valuation\n                               (case fund_sol of\n                                (x, y) \\<Rightarrow> (int x, int y))", "with \\<open>y > 0\\<close>"], ["proof (chain)\npicking this:\n  0 < y\n  1 < x", "have \"x + y * sqrt D \\<ge> 2 + 1 * 1\""], ["proof (prove)\nusing this:\n  0 < y\n  1 < x\n\ngoal (1 subgoal):\n 1. 2 + 1 * 1 \\<le> real x + real y * sqrt (real D)", "using D_pos"], ["proof (prove)\nusing this:\n  0 < y\n  1 < x\n  0 < D\n\ngoal (1 subgoal):\n 1. 2 + 1 * 1 \\<le> real x + real y * sqrt (real D)", "by (intro add_mono mult_mono) auto"], ["proof (state)\nthis:\n  2 + 1 * 1 \\<le> real x + real y * sqrt (real D)\n\ngoal (2 subgoals):\n 1. 0 < y \\<Longrightarrow>\n    2 \\<le> pell_valuation\n             (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))\n 2. \\<lbrakk>y = 0; x \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> 2 \\<le> pell_valuation\n                               (case fund_sol of\n                                (x, y) \\<Rightarrow> (int x, int y))", "thus ?thesis"], ["proof (prove)\nusing this:\n  2 + 1 * 1 \\<le> real x + real y * sqrt (real D)\n\ngoal (1 subgoal):\n 1. 2 \\<le> pell_valuation\n             (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))", "by (simp add: pell_valuation_def)"], ["proof (state)\nthis:\n  2 \\<le> pell_valuation\n           (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y = 0; x \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> 2 \\<le> pell_valuation\n                               (case fund_sol of\n                                (x, y) \\<Rightarrow> (int x, int y))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>y = 0; x \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> 2 \\<le> pell_valuation\n                               (case fund_sol of\n                                (x, y) \\<Rightarrow> (int x, int y))", "assume [simp]: \"y = 0\" and \"x \\<noteq> 1\""], ["proof (state)\nthis:\n  y = 0\n  x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y = 0; x \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> 2 \\<le> pell_valuation\n                               (case fund_sol of\n                                (x, y) \\<Rightarrow> (int x, int y))", "with eq"], ["proof (chain)\npicking this:\n  x\\<^sup>2 = 1 + D * y\\<^sup>2\n  y = 0\n  x \\<noteq> 1", "have \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x\\<^sup>2 = 1 + D * y\\<^sup>2\n  y = 0\n  x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0", "by (intro notI) auto"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y = 0; x \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> 2 \\<le> pell_valuation\n                               (case fund_sol of\n                                (x, y) \\<Rightarrow> (int x, int y))", "with \\<open>x \\<noteq> 1\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> 1\n  x \\<noteq> 0", "have \"x \\<ge> 2\""], ["proof (prove)\nusing this:\n  x \\<noteq> 1\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 \\<le> x", "by simp"], ["proof (state)\nthis:\n  2 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>y = 0; x \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> 2 \\<le> pell_valuation\n                               (case fund_sol of\n                                (x, y) \\<Rightarrow> (int x, int y))", "thus ?thesis"], ["proof (prove)\nusing this:\n  2 \\<le> x\n\ngoal (1 subgoal):\n 1. 2 \\<le> pell_valuation\n             (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))", "by (auto simp: pell_valuation_def)"], ["proof (state)\nthis:\n  2 \\<le> pell_valuation\n           (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 \\<le> pell_valuation\n           (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma solution_pell_mul [intro]:\n  assumes \"solution z1\" \"solution z2\"\n  shows   \"solution (pell_mul z1 z2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution (pell_mul z1 z2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. solution (pell_mul z1 z2)", "obtain a b where [simp]: \"z1 = (a, b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b. z1 = (a, b) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases z1)"], ["proof (state)\nthis:\n  z1 = (a, b)\n\ngoal (1 subgoal):\n 1. solution (pell_mul z1 z2)", "obtain c d where [simp]: \"z2 = (c, d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c d. z2 = (c, d) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases z2)"], ["proof (state)\nthis:\n  z2 = (c, d)\n\ngoal (1 subgoal):\n 1. solution (pell_mul z1 z2)", "from assms"], ["proof (chain)\npicking this:\n  solution z1\n  solution z2", "show ?thesis"], ["proof (prove)\nusing this:\n  solution z1\n  solution z2\n\ngoal (1 subgoal):\n 1. solution (pell_mul z1 z2)", "by (simp add: solution_def pell_mul_def case_prod_unfold power2_eq_square algebra_simps)"], ["proof (state)\nthis:\n  solution (pell_mul z1 z2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma solution_pell_cnj [intro]:\n  assumes \"solution z\"\n  shows   \"solution (pell_cnj z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution (pell_cnj z)", "using assms"], ["proof (prove)\nusing this:\n  solution z\n\ngoal (1 subgoal):\n 1. solution (pell_cnj z)", "by (auto simp: solution_def pell_cnj_def)"], ["", "lemma solution_pell_power [simp, intro]: \"solution z \\<Longrightarrow> solution (pell_power z n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution z \\<Longrightarrow> solution (pell_power z n)", "by (induction n) (auto simp: pell_power_Suc)"], ["", "lemma pell_mul_eq_trivial_nat_iff:\n  \"pell_mul z1 z2 = (Suc 0, 0) \\<longleftrightarrow> z1 = (Suc 0, 0) \\<and> z2 = (Suc 0, 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pell_mul z1 z2 = (Suc 0, 0)) = (z1 = (Suc 0, 0) \\<and> z2 = (Suc 0, 0))", "using D_gt_1"], ["proof (prove)\nusing this:\n  1 < D\n\ngoal (1 subgoal):\n 1. (pell_mul z1 z2 = (Suc 0, 0)) = (z1 = (Suc 0, 0) \\<and> z2 = (Suc 0, 0))", "by (cases z1; cases z2) (auto simp: pell_mul_def)"], ["", "lemma nontriv_solution_pell_nat_mul1:\n  \"solution (z1 :: nat \\<times> nat) \\<Longrightarrow> nontriv_solution z2 \\<Longrightarrow> nontriv_solution (pell_mul z1 z2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>solution z1; nontriv_solution z2\\<rbrakk>\n    \\<Longrightarrow> nontriv_solution (pell_mul z1 z2)", "by (auto simp: nontriv_solution_altdef pell_mul_eq_trivial_nat_iff)"], ["", "lemma nontriv_solution_pell_nat_mul2:\n  \"nontriv_solution (z1 :: nat \\<times> nat) \\<Longrightarrow> solution z2 \\<Longrightarrow> nontriv_solution (pell_mul z1 z2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>nontriv_solution z1; solution z2\\<rbrakk>\n    \\<Longrightarrow> nontriv_solution (pell_mul z1 z2)", "by (auto simp: nontriv_solution_altdef pell_mul_eq_trivial_nat_iff)"], ["", "lemma nontriv_solution_power_nat [intro]:\n  assumes \"nontriv_solution (z :: nat \\<times> nat)\" \"n > 0\"\n  shows   \"nontriv_solution (pell_power z n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nontriv_solution (pell_power z n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nontriv_solution (pell_power z n)", "have \"nontriv_solution (pell_power z n) \\<or> n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nontriv_solution (pell_power z n) \\<or> n = 0", "by (induction n)\n       (insert assms(1), auto intro: nontriv_solution_pell_nat_mul1 simp: pell_power_Suc)"], ["proof (state)\nthis:\n  nontriv_solution (pell_power z n) \\<or> n = 0\n\ngoal (1 subgoal):\n 1. nontriv_solution (pell_power z n)", "with assms(2)"], ["proof (chain)\npicking this:\n  0 < n\n  nontriv_solution (pell_power z n) \\<or> n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < n\n  nontriv_solution (pell_power z n) \\<or> n = 0\n\ngoal (1 subgoal):\n 1. nontriv_solution (pell_power z n)", "by auto"], ["proof (state)\nthis:\n  nontriv_solution (pell_power z n)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The different regions of the valuation function\\<close>"], ["", "text \\<open>\n  Next, we shall explore what happens to the valuation function for solutions \\<open>(x, y)\\<close> for\n  different signs of \\<open>x\\<close> and \\<open>y\\<close>:\n\n    \\<^item> If \\<open>x > 0\\<close> and \\<open>y > 0\\<close>, we have  $x + y \\sqrt D > 1$.\n\n    \\<^item> If \\<open>x > 0\\<close> and \\<open>y < 0\\<close>, we have $0 < x + y \\sqrt D < 1$.\n\n    \\<^item> If \\<open>x < 0\\<close> and \\<open>y > 0\\<close>, we have $-1 < x + y \\sqrt D < 0$.\n\n    \\<^item> If \\<open>x < 0\\<close> and \\<open>y < 0\\<close>, we have $x + y \\sqrt D < -1$.\n\n  In particular, this means that we can deduce the sign of \\<open>x\\<close> and \\<open>y\\<close> if we know in\n  which of these four regions the valuation lies.\n\\<close>"], ["", "lemma\n  assumes \"x > 0\" \"y > 0\" \"solution (x, y)\"\n  shows   pell_valuation_pos_pos: \"pell_valuation (x, y) > 1\"\n    and   pell_valuation_pos_neg_aux: \"pell_valuation (x, -y) \\<in> {0<..<1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < pell_valuation (x, y) &&& pell_valuation (x, - y) \\<in> {0<..<1}", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. 1 < pell_valuation (x, y)\n 2. pell_valuation (x, - y) \\<in> {0<..<1}", "from D_gt_1 assms"], ["proof (chain)\npicking this:\n  1 < D\n  0 < x\n  0 < y\n  solution (x, y)", "have \"x + y * sqrt D \\<ge> 1 + 1 * 1\""], ["proof (prove)\nusing this:\n  1 < D\n  0 < x\n  0 < y\n  solution (x, y)\n\ngoal (1 subgoal):\n 1. 1 + 1 * 1 \\<le> real_of_int x + real_of_int y * sqrt (real D)", "by (intro add_mono mult_mono) auto"], ["proof (state)\nthis:\n  1 + 1 * 1 \\<le> real_of_int x + real_of_int y * sqrt (real D)\n\ngoal (2 subgoals):\n 1. 1 < pell_valuation (x, y)\n 2. pell_valuation (x, - y) \\<in> {0<..<1}", "hence gt_1: \"x + y * sqrt D > 1\""], ["proof (prove)\nusing this:\n  1 + 1 * 1 \\<le> real_of_int x + real_of_int y * sqrt (real D)\n\ngoal (1 subgoal):\n 1. 1 < real_of_int x + real_of_int y * sqrt (real D)", "by simp"], ["proof (state)\nthis:\n  1 < real_of_int x + real_of_int y * sqrt (real D)\n\ngoal (2 subgoals):\n 1. 1 < pell_valuation (x, y)\n 2. pell_valuation (x, - y) \\<in> {0<..<1}", "thus \"pell_valuation (x, y) > 1\""], ["proof (prove)\nusing this:\n  1 < real_of_int x + real_of_int y * sqrt (real D)\n\ngoal (1 subgoal):\n 1. 1 < pell_valuation (x, y)", "by (simp add: pell_valuation_def)"], ["proof (state)\nthis:\n  1 < pell_valuation (x, y)\n\ngoal (1 subgoal):\n 1. pell_valuation (x, - y) \\<in> {0<..<1}", "from assms"], ["proof (chain)\npicking this:\n  0 < x\n  0 < y\n  solution (x, y)", "have \"1 = x^2 - D * y^2\""], ["proof (prove)\nusing this:\n  0 < x\n  0 < y\n  solution (x, y)\n\ngoal (1 subgoal):\n 1. 1 = x\\<^sup>2 - int D * y\\<^sup>2", "by (simp add: solution_def)"], ["proof (state)\nthis:\n  1 = x\\<^sup>2 - int D * y\\<^sup>2\n\ngoal (1 subgoal):\n 1. pell_valuation (x, - y) \\<in> {0<..<1}", "also"], ["proof (state)\nthis:\n  1 = x\\<^sup>2 - int D * y\\<^sup>2\n\ngoal (1 subgoal):\n 1. pell_valuation (x, - y) \\<in> {0<..<1}", "have \"of_int \\<dots> = (x - y * sqrt D) * (x + y * sqrt D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (x\\<^sup>2 - int D * y\\<^sup>2) =\n    (real_of_int x - real_of_int y * sqrt (real D)) *\n    (real_of_int x + real_of_int y * sqrt (real D))", "by (simp add: field_simps power2_eq_square)"], ["proof (state)\nthis:\n  real_of_int (x\\<^sup>2 - int D * y\\<^sup>2) =\n  (real_of_int x - real_of_int y * sqrt (real D)) *\n  (real_of_int x + real_of_int y * sqrt (real D))\n\ngoal (1 subgoal):\n 1. pell_valuation (x, - y) \\<in> {0<..<1}", "finally"], ["proof (chain)\npicking this:\n  real_of_int 1 =\n  (real_of_int x - real_of_int y * sqrt (real D)) *\n  (real_of_int x + real_of_int y * sqrt (real D))", "have eq: \"(x - y * sqrt D) = 1 / (x + y * sqrt D)\""], ["proof (prove)\nusing this:\n  real_of_int 1 =\n  (real_of_int x - real_of_int y * sqrt (real D)) *\n  (real_of_int x + real_of_int y * sqrt (real D))\n\ngoal (1 subgoal):\n 1. real_of_int x - real_of_int y * sqrt (real D) =\n    1 / (real_of_int x + real_of_int y * sqrt (real D))", "using gt_1"], ["proof (prove)\nusing this:\n  real_of_int 1 =\n  (real_of_int x - real_of_int y * sqrt (real D)) *\n  (real_of_int x + real_of_int y * sqrt (real D))\n  1 < real_of_int x + real_of_int y * sqrt (real D)\n\ngoal (1 subgoal):\n 1. real_of_int x - real_of_int y * sqrt (real D) =\n    1 / (real_of_int x + real_of_int y * sqrt (real D))", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  real_of_int x - real_of_int y * sqrt (real D) =\n  1 / (real_of_int x + real_of_int y * sqrt (real D))\n\ngoal (1 subgoal):\n 1. pell_valuation (x, - y) \\<in> {0<..<1}", "note eq"], ["proof (state)\nthis:\n  real_of_int x - real_of_int y * sqrt (real D) =\n  1 / (real_of_int x + real_of_int y * sqrt (real D))\n\ngoal (1 subgoal):\n 1. pell_valuation (x, - y) \\<in> {0<..<1}", "also"], ["proof (state)\nthis:\n  real_of_int x - real_of_int y * sqrt (real D) =\n  1 / (real_of_int x + real_of_int y * sqrt (real D))\n\ngoal (1 subgoal):\n 1. pell_valuation (x, - y) \\<in> {0<..<1}", "from gt_1"], ["proof (chain)\npicking this:\n  1 < real_of_int x + real_of_int y * sqrt (real D)", "have \"1 / (x + y * sqrt D) < 1 / 1\""], ["proof (prove)\nusing this:\n  1 < real_of_int x + real_of_int y * sqrt (real D)\n\ngoal (1 subgoal):\n 1. 1 / (real_of_int x + real_of_int y * sqrt (real D)) < 1 / 1", "by (intro divide_strict_left_mono) auto"], ["proof (state)\nthis:\n  1 / (real_of_int x + real_of_int y * sqrt (real D)) < 1 / 1\n\ngoal (1 subgoal):\n 1. pell_valuation (x, - y) \\<in> {0<..<1}", "finally"], ["proof (chain)\npicking this:\n  real_of_int x - real_of_int y * sqrt (real D) < 1 / 1", "have \"x - y * sqrt D < 1\""], ["proof (prove)\nusing this:\n  real_of_int x - real_of_int y * sqrt (real D) < 1 / 1\n\ngoal (1 subgoal):\n 1. real_of_int x - real_of_int y * sqrt (real D) < 1", "by simp"], ["proof (state)\nthis:\n  real_of_int x - real_of_int y * sqrt (real D) < 1\n\ngoal (1 subgoal):\n 1. pell_valuation (x, - y) \\<in> {0<..<1}", "note eq"], ["proof (state)\nthis:\n  real_of_int x - real_of_int y * sqrt (real D) =\n  1 / (real_of_int x + real_of_int y * sqrt (real D))\n\ngoal (1 subgoal):\n 1. pell_valuation (x, - y) \\<in> {0<..<1}", "also"], ["proof (state)\nthis:\n  real_of_int x - real_of_int y * sqrt (real D) =\n  1 / (real_of_int x + real_of_int y * sqrt (real D))\n\ngoal (1 subgoal):\n 1. pell_valuation (x, - y) \\<in> {0<..<1}", "from gt_1"], ["proof (chain)\npicking this:\n  1 < real_of_int x + real_of_int y * sqrt (real D)", "have \"1 / (x + y * sqrt D) > 0\""], ["proof (prove)\nusing this:\n  1 < real_of_int x + real_of_int y * sqrt (real D)\n\ngoal (1 subgoal):\n 1. 0 < 1 / (real_of_int x + real_of_int y * sqrt (real D))", "by (intro divide_pos_pos) auto"], ["proof (state)\nthis:\n  0 < 1 / (real_of_int x + real_of_int y * sqrt (real D))\n\ngoal (1 subgoal):\n 1. pell_valuation (x, - y) \\<in> {0<..<1}", "finally"], ["proof (chain)\npicking this:\n  0 < real_of_int x - real_of_int y * sqrt (real D)", "have \"x - y * sqrt D > 0\""], ["proof (prove)\nusing this:\n  0 < real_of_int x - real_of_int y * sqrt (real D)\n\ngoal (1 subgoal):\n 1. 0 < real_of_int x - real_of_int y * sqrt (real D)", "."], ["proof (state)\nthis:\n  0 < real_of_int x - real_of_int y * sqrt (real D)\n\ngoal (1 subgoal):\n 1. pell_valuation (x, - y) \\<in> {0<..<1}", "with \\<open>x - y * sqrt D < 1\\<close>"], ["proof (chain)\npicking this:\n  real_of_int x - real_of_int y * sqrt (real D) < 1\n  0 < real_of_int x - real_of_int y * sqrt (real D)", "show \"pell_valuation (x, -y) \\<in> {0<..<1}\""], ["proof (prove)\nusing this:\n  real_of_int x - real_of_int y * sqrt (real D) < 1\n  0 < real_of_int x - real_of_int y * sqrt (real D)\n\ngoal (1 subgoal):\n 1. pell_valuation (x, - y) \\<in> {0<..<1}", "by (simp add: pell_valuation_def)"], ["proof (state)\nthis:\n  pell_valuation (x, - y) \\<in> {0<..<1}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pell_valuation_pos_neg:\n  assumes \"x > 0\" \"y < 0\" \"solution (x, y)\"\n  shows   \"pell_valuation (x, y) \\<in> {0<..<1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_valuation (x, y) \\<in> {0<..<1}", "using pell_valuation_pos_neg_aux[of x \"-y\"] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < x; 0 < - y; solution (x, - y)\\<rbrakk>\n  \\<Longrightarrow> pell_valuation (x, - (- y)) \\<in> {0<..<1}\n  0 < x\n  y < 0\n  solution (x, y)\n\ngoal (1 subgoal):\n 1. pell_valuation (x, y) \\<in> {0<..<1}", "by simp"], ["", "lemma pell_valuation_neg_neg:\n  assumes \"x < 0\" \"y < 0\" \"solution (x, y)\"\n  shows   \"pell_valuation (x, y) < -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_valuation (x, y) < - 1", "using pell_valuation_pos_pos[of \"-x\" \"-y\"] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < - x; 0 < - y; solution (- x, - y)\\<rbrakk>\n  \\<Longrightarrow> 1 < pell_valuation (- x, - y)\n  x < 0\n  y < 0\n  solution (x, y)\n\ngoal (1 subgoal):\n 1. pell_valuation (x, y) < - 1", "by simp"], ["", "lemma pell_valuation_neg_pos:\n  assumes \"x < 0\" \"y > 0\" \"solution (x, y)\"\n  shows   \"pell_valuation (x, y) \\<in> {-1<..<0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_valuation (x, y) \\<in> {- 1<..<0}", "using pell_valuation_pos_neg[of \"-x\" \"-y\"] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < - x; - y < 0; solution (- x, - y)\\<rbrakk>\n  \\<Longrightarrow> pell_valuation (- x, - y) \\<in> {0<..<1}\n  x < 0\n  0 < y\n  solution (x, y)\n\ngoal (1 subgoal):\n 1. pell_valuation (x, y) \\<in> {- 1<..<0}", "by simp"], ["", "lemma pell_valuation_solution_gt1D:\n  assumes \"solution z\" \"pell_valuation z > 1\"\n  shows   \"fst z > 0 \\<and> snd z > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < fst z \\<and> 0 < snd z", "using pell_valuation_pos_pos[of \"fst z\" \"snd z\"] pell_valuation_pos_neg[of \"fst z\" \"snd z\"]\n        pell_valuation_neg_pos[of \"fst z\" \"snd z\"] pell_valuation_neg_neg[of \"fst z\" \"snd z\"]\n        assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < fst z; 0 < snd z; solution (fst z, snd z)\\<rbrakk>\n  \\<Longrightarrow> 1 < pell_valuation (fst z, snd z)\n  \\<lbrakk>0 < fst z; snd z < 0; solution (fst z, snd z)\\<rbrakk>\n  \\<Longrightarrow> pell_valuation (fst z, snd z) \\<in> {0<..<1}\n  \\<lbrakk>fst z < 0; 0 < snd z; solution (fst z, snd z)\\<rbrakk>\n  \\<Longrightarrow> pell_valuation (fst z, snd z) \\<in> {- 1<..<0}\n  \\<lbrakk>fst z < 0; snd z < 0; solution (fst z, snd z)\\<rbrakk>\n  \\<Longrightarrow> pell_valuation (fst z, snd z) < - 1\n  solution z\n  1 < pell_valuation z\n\ngoal (1 subgoal):\n 1. 0 < fst z \\<and> 0 < snd z", "by (cases \"fst z\" \"0 :: int\" rule: linorder_cases;\n      cases \"snd z\" \"0 :: int\" rule: linorder_cases;\n      cases z) auto"], ["", "subsection \\<open>Generating property of the fundamental solution\\<close>"], ["", "text \\<open>\n  We now show that the fundamental solution generates the set of the (non-negative) solutions\n  in the sense that each solution is a power of the fundamental solution. Combined with the\n  symmetry property that \\<open>(x,y)\\<close> is a solution iff \\<open>(\\<plusminus>x, \\<plusminus>y)\\<close> is a solution, this gives us\n  a complete characterisation of all solutions of Pell's equation.\n\\<close>"], ["", "definition nth_solution :: \"nat \\<Rightarrow> nat \\<times> nat\" where\n  \"nth_solution n = pell_power fund_sol n\""], ["", "lemma pell_valuation_nth_solution [simp]:\n  \"pell_valuation (nth_solution n) = pell_valuation fund_sol ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_valuation\n     (case nth_solution n of (x, y) \\<Rightarrow> (int x, int y)) =\n    pell_valuation (case fund_sol of (x, y) \\<Rightarrow> (int x, int y)) ^\n    n", "by (simp add: nth_solution_def)"], ["", "theorem nth_solution_inj: \"inj nth_solution\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj nth_solution", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV;\n        nth_solution x = nth_solution y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix m n :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV;\n        nth_solution x = nth_solution y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"nth_solution m = nth_solution n\""], ["proof (state)\nthis:\n  nth_solution m = nth_solution n\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV;\n        nth_solution x = nth_solution y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"pell_valuation (nth_solution m) = pell_valuation (nth_solution n)\""], ["proof (prove)\nusing this:\n  nth_solution m = nth_solution n\n\ngoal (1 subgoal):\n 1. pell_valuation\n     (case nth_solution m of (x, y) \\<Rightarrow> (int x, int y)) =\n    pell_valuation\n     (case nth_solution n of (x, y) \\<Rightarrow> (int x, int y))", "by (simp only: )"], ["proof (state)\nthis:\n  pell_valuation\n   (case nth_solution m of (x, y) \\<Rightarrow> (int x, int y)) =\n  pell_valuation\n   (case nth_solution n of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV;\n        nth_solution x = nth_solution y\\<rbrakk>\n       \\<Longrightarrow> x = y", "also"], ["proof (state)\nthis:\n  pell_valuation\n   (case nth_solution m of (x, y) \\<Rightarrow> (int x, int y)) =\n  pell_valuation\n   (case nth_solution n of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV;\n        nth_solution x = nth_solution y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"pell_valuation (nth_solution m) = pell_valuation fund_sol ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_valuation\n     (case nth_solution m of (x, y) \\<Rightarrow> (int x, int y)) =\n    pell_valuation (case fund_sol of (x, y) \\<Rightarrow> (int x, int y)) ^\n    m", "by simp"], ["proof (state)\nthis:\n  pell_valuation\n   (case nth_solution m of (x, y) \\<Rightarrow> (int x, int y)) =\n  pell_valuation (case fund_sol of (x, y) \\<Rightarrow> (int x, int y)) ^ m\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV;\n        nth_solution x = nth_solution y\\<rbrakk>\n       \\<Longrightarrow> x = y", "also"], ["proof (state)\nthis:\n  pell_valuation\n   (case nth_solution m of (x, y) \\<Rightarrow> (int x, int y)) =\n  pell_valuation (case fund_sol of (x, y) \\<Rightarrow> (int x, int y)) ^ m\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV;\n        nth_solution x = nth_solution y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"pell_valuation (nth_solution n) = pell_valuation fund_sol ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_valuation\n     (case nth_solution n of (x, y) \\<Rightarrow> (int x, int y)) =\n    pell_valuation (case fund_sol of (x, y) \\<Rightarrow> (int x, int y)) ^\n    n", "by simp"], ["proof (state)\nthis:\n  pell_valuation\n   (case nth_solution n of (x, y) \\<Rightarrow> (int x, int y)) =\n  pell_valuation (case fund_sol of (x, y) \\<Rightarrow> (int x, int y)) ^ n\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV;\n        nth_solution x = nth_solution y\\<rbrakk>\n       \\<Longrightarrow> x = y", "finally"], ["proof (chain)\npicking this:\n  pell_valuation (case fund_sol of (x, y) \\<Rightarrow> (int x, int y)) ^\n  m =\n  pell_valuation (case fund_sol of (x, y) \\<Rightarrow> (int x, int y)) ^ n", "show \"m = n\""], ["proof (prove)\nusing this:\n  pell_valuation (case fund_sol of (x, y) \\<Rightarrow> (int x, int y)) ^\n  m =\n  pell_valuation (case fund_sol of (x, y) \\<Rightarrow> (int x, int y)) ^ n\n\ngoal (1 subgoal):\n 1. m = n", "using pell_valuation_fund_sol_ge_2"], ["proof (prove)\nusing this:\n  pell_valuation (case fund_sol of (x, y) \\<Rightarrow> (int x, int y)) ^\n  m =\n  pell_valuation (case fund_sol of (x, y) \\<Rightarrow> (int x, int y)) ^ n\n  2 \\<le> pell_valuation\n           (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (1 subgoal):\n 1. m = n", "by (subst (asm) power_inject_exp) auto"], ["proof (state)\nthis:\n  m = n\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem nth_solution_sound [intro]: \"solution (nth_solution n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution (nth_solution n)", "using fund_sol_is_nontriv_solution"], ["proof (prove)\nusing this:\n  nontriv_solution fund_sol\n\ngoal (1 subgoal):\n 1. solution (nth_solution n)", "by (auto simp: nth_solution_def)"], ["", "theorem nth_solution_sound' [intro]: \"n > 0 \\<Longrightarrow> nontriv_solution (nth_solution n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> nontriv_solution (nth_solution n)", "using fund_sol_is_nontriv_solution"], ["proof (prove)\nusing this:\n  nontriv_solution fund_sol\n\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> nontriv_solution (nth_solution n)", "by (auto simp: nth_solution_def)"], ["", "theorem nth_solution_complete:\n  fixes z :: \"nat \\<times> nat\"\n  assumes \"solution z\"\n  shows   \"z \\<in> range nth_solution\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> range nth_solution", "proof (cases \"z = (1, 0)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. z = (1, 0) \\<Longrightarrow> z \\<in> range nth_solution\n 2. z \\<noteq> (1, 0) \\<Longrightarrow> z \\<in> range nth_solution", "case True"], ["proof (state)\nthis:\n  z = (1, 0)\n\ngoal (2 subgoals):\n 1. z = (1, 0) \\<Longrightarrow> z \\<in> range nth_solution\n 2. z \\<noteq> (1, 0) \\<Longrightarrow> z \\<in> range nth_solution", "hence \"z = nth_solution 0\""], ["proof (prove)\nusing this:\n  z = (1, 0)\n\ngoal (1 subgoal):\n 1. z = nth_solution 0", "by (simp add: nth_solution_def)"], ["proof (state)\nthis:\n  z = nth_solution 0\n\ngoal (2 subgoals):\n 1. z = (1, 0) \\<Longrightarrow> z \\<in> range nth_solution\n 2. z \\<noteq> (1, 0) \\<Longrightarrow> z \\<in> range nth_solution", "thus ?thesis"], ["proof (prove)\nusing this:\n  z = nth_solution 0\n\ngoal (1 subgoal):\n 1. z \\<in> range nth_solution", "by auto"], ["proof (state)\nthis:\n  z \\<in> range nth_solution\n\ngoal (1 subgoal):\n 1. z \\<noteq> (1, 0) \\<Longrightarrow> z \\<in> range nth_solution", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<noteq> (1, 0) \\<Longrightarrow> z \\<in> range nth_solution", "case False"], ["proof (state)\nthis:\n  z \\<noteq> (1, 0)\n\ngoal (1 subgoal):\n 1. z \\<noteq> (1, 0) \\<Longrightarrow> z \\<in> range nth_solution", "with assms"], ["proof (chain)\npicking this:\n  solution z\n  z \\<noteq> (1, 0)", "have \"nontriv_solution z\""], ["proof (prove)\nusing this:\n  solution z\n  z \\<noteq> (1, 0)\n\ngoal (1 subgoal):\n 1. nontriv_solution z", "by (auto simp: nontriv_solution_altdef)"], ["proof (state)\nthis:\n  nontriv_solution z\n\ngoal (1 subgoal):\n 1. z \\<noteq> (1, 0) \\<Longrightarrow> z \\<in> range nth_solution", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> range nth_solution", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<notin> range nth_solution \\<Longrightarrow> False", "assume \"\\<not>?thesis\""], ["proof (state)\nthis:\n  z \\<notin> range nth_solution\n\ngoal (1 subgoal):\n 1. z \\<notin> range nth_solution \\<Longrightarrow> False", "hence *: \"pell_power fund_sol n \\<noteq> z\" for n"], ["proof (prove)\nusing this:\n  z \\<notin> range nth_solution\n\ngoal (1 subgoal):\n 1. pell_power fund_sol n \\<noteq> z", "unfolding nth_solution_def"], ["proof (prove)\nusing this:\n  z \\<notin> range (pell_power fund_sol)\n\ngoal (1 subgoal):\n 1. pell_power fund_sol n \\<noteq> z", "by blast"], ["proof (state)\nthis:\n  pell_power fund_sol ?n4 \\<noteq> z\n\ngoal (1 subgoal):\n 1. z \\<notin> range nth_solution \\<Longrightarrow> False", "define u where \"u = pell_valuation fund_sol\""], ["proof (state)\nthis:\n  u = pell_valuation (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (1 subgoal):\n 1. z \\<notin> range nth_solution \\<Longrightarrow> False", "define v where \"v = pell_valuation z\""], ["proof (state)\nthis:\n  v = pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (1 subgoal):\n 1. z \\<notin> range nth_solution \\<Longrightarrow> False", "define n where \"n = nat \\<lfloor>log u v\\<rfloor>\""], ["proof (state)\nthis:\n  n = nat \\<lfloor>log u v\\<rfloor>\n\ngoal (1 subgoal):\n 1. z \\<notin> range nth_solution \\<Longrightarrow> False", "have u_ge_2: \"u \\<ge> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> u", "using pell_valuation_fund_sol_ge_2"], ["proof (prove)\nusing this:\n  2 \\<le> pell_valuation\n           (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (1 subgoal):\n 1. 2 \\<le> u", "by (auto simp: u_def)"], ["proof (state)\nthis:\n  2 \\<le> u\n\ngoal (1 subgoal):\n 1. z \\<notin> range nth_solution \\<Longrightarrow> False", "have v_pos: \"v > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < v", "unfolding v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y))", "using assms"], ["proof (prove)\nusing this:\n  solution z\n\ngoal (1 subgoal):\n 1. 0 < pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y))", "by (intro pell_valuation_solution_pos_nat) auto"], ["proof (state)\nthis:\n  0 < v\n\ngoal (1 subgoal):\n 1. z \\<notin> range nth_solution \\<Longrightarrow> False", "have u_le_v: \"u \\<le> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<le> v", "unfolding u_def v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pell_valuation (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))\n    \\<le> pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y))", "by (rule fund_sol_minimal') fact"], ["proof (state)\nthis:\n  u \\<le> v\n\ngoal (1 subgoal):\n 1. z \\<notin> range nth_solution \\<Longrightarrow> False", "have u_power_neq_v: \"u ^ k \\<noteq> v\" for k"], ["proof (prove)\ngoal (1 subgoal):\n 1. u ^ k \\<noteq> v", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. u ^ k = v \\<Longrightarrow> False", "assume \"u ^ k = v\""], ["proof (state)\nthis:\n  u ^ k = v\n\ngoal (1 subgoal):\n 1. u ^ k = v \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  u ^ k = v\n\ngoal (1 subgoal):\n 1. u ^ k = v \\<Longrightarrow> False", "have \"u ^ k = pell_valuation (pell_power fund_sol k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u ^ k =\n    pell_valuation\n     (case pell_power fund_sol k of (x, y) \\<Rightarrow> (int x, int y))", "by (simp add: u_def)"], ["proof (state)\nthis:\n  u ^ k =\n  pell_valuation\n   (case pell_power fund_sol k of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (1 subgoal):\n 1. u ^ k = v \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  u ^ k =\n  pell_valuation\n   (case pell_power fund_sol k of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (1 subgoal):\n 1. u ^ k = v \\<Longrightarrow> False", "have \"\\<dots> = v \\<longleftrightarrow> pell_power fund_sol k = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pell_valuation\n      (case pell_power fund_sol k of (x, y) \\<Rightarrow> (int x, int y)) =\n     v) =\n    (pell_power fund_sol k = z)", "unfolding v_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pell_valuation\n      (case pell_power fund_sol k of (x, y) \\<Rightarrow> (int x, int y)) =\n     pell_valuation (case z of (x, y) \\<Rightarrow> (int x, int y))) =\n    (pell_power fund_sol k = z)", "by (subst pell_valuation_eq_iff) (auto split: prod.splits)"], ["proof (state)\nthis:\n  (pell_valuation\n    (case pell_power fund_sol k of (x, y) \\<Rightarrow> (int x, int y)) =\n   v) =\n  (pell_power fund_sol k = z)\n\ngoal (1 subgoal):\n 1. u ^ k = v \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  pell_power fund_sol k = z", "show False"], ["proof (prove)\nusing this:\n  pell_power fund_sol k = z\n\ngoal (1 subgoal):\n 1. False", "using *"], ["proof (prove)\nusing this:\n  pell_power fund_sol k = z\n  pell_power fund_sol ?n4 \\<noteq> z\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u ^ ?k4 \\<noteq> v\n\ngoal (1 subgoal):\n 1. z \\<notin> range nth_solution \\<Longrightarrow> False", "from u_le_v v_pos u_ge_2"], ["proof (chain)\npicking this:\n  u \\<le> v\n  0 < v\n  2 \\<le> u", "have log_ge_1: \"log u v \\<ge> 1\""], ["proof (prove)\nusing this:\n  u \\<le> v\n  0 < v\n  2 \\<le> u\n\ngoal (1 subgoal):\n 1. 1 \\<le> log u v", "by (subst one_le_log_cancel_iff) auto"], ["proof (state)\nthis:\n  1 \\<le> log u v\n\ngoal (1 subgoal):\n 1. z \\<notin> range nth_solution \\<Longrightarrow> False", "define z' where \"z' = pell_mul z (pell_power (pell_cnj fund_sol) n)\""], ["proof (state)\nthis:\n  z' =\n  pell_mul (case z of (x, y) \\<Rightarrow> (int x, int y))\n   (pell_power\n     (pell_cnj (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))) n)\n\ngoal (1 subgoal):\n 1. z \\<notin> range nth_solution \\<Longrightarrow> False", "define x and y where \"x = nat \\<bar>fst z'\\<bar>\" and \"y = nat \\<bar>snd z'\\<bar>\""], ["proof (state)\nthis:\n  x = nat \\<bar>fst z'\\<bar>\n  y = nat \\<bar>snd z'\\<bar>\n\ngoal (1 subgoal):\n 1. z \\<notin> range nth_solution \\<Longrightarrow> False", "have \"solution z'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution z'", "using assms fund_sol_is_nontriv_solution"], ["proof (prove)\nusing this:\n  solution z\n  nontriv_solution fund_sol\n\ngoal (1 subgoal):\n 1. solution z'", "unfolding z'_def"], ["proof (prove)\nusing this:\n  solution z\n  nontriv_solution fund_sol\n\ngoal (1 subgoal):\n 1. solution\n     (pell_mul (case z of (x, y) \\<Rightarrow> (int x, int y))\n       (pell_power\n         (pell_cnj (case fund_sol of (x, y) \\<Rightarrow> (int x, int y)))\n         n))", "by (intro solution_pell_mul solution_pell_power solution_pell_cnj) (auto simp: case_prod_unfold)"], ["proof (state)\nthis:\n  solution z'\n\ngoal (1 subgoal):\n 1. z \\<notin> range nth_solution \\<Longrightarrow> False", "have \"u ^ n < v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u ^ n < v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u ^ n < v", "from u_ge_2"], ["proof (chain)\npicking this:\n  2 \\<le> u", "have \"u ^ n = u powr real n\""], ["proof (prove)\nusing this:\n  2 \\<le> u\n\ngoal (1 subgoal):\n 1. u ^ n = u powr real n", "by (subst powr_realpow) auto"], ["proof (state)\nthis:\n  u ^ n = u powr real n\n\ngoal (1 subgoal):\n 1. u ^ n < v", "also"], ["proof (state)\nthis:\n  u ^ n = u powr real n\n\ngoal (1 subgoal):\n 1. u ^ n < v", "have \"\\<dots> \\<le> u powr log u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u powr real n \\<le> u powr log u v", "using u_ge_2 log_ge_1"], ["proof (prove)\nusing this:\n  2 \\<le> u\n  1 \\<le> log u v\n\ngoal (1 subgoal):\n 1. u powr real n \\<le> u powr log u v", "by (intro powr_mono) (auto simp: n_def)"], ["proof (state)\nthis:\n  u powr real n \\<le> u powr log u v\n\ngoal (1 subgoal):\n 1. u ^ n < v", "also"], ["proof (state)\nthis:\n  u powr real n \\<le> u powr log u v\n\ngoal (1 subgoal):\n 1. u ^ n < v", "have \"\\<dots> = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u powr log u v = v", "using u_ge_2 v_pos"], ["proof (prove)\nusing this:\n  2 \\<le> u\n  0 < v\n\ngoal (1 subgoal):\n 1. u powr log u v = v", "by (subst powr_log_cancel) auto"], ["proof (state)\nthis:\n  u powr log u v = v\n\ngoal (1 subgoal):\n 1. u ^ n < v", "finally"], ["proof (chain)\npicking this:\n  u ^ n \\<le> v", "have \"u ^ n \\<le> v\""], ["proof (prove)\nusing this:\n  u ^ n \\<le> v\n\ngoal (1 subgoal):\n 1. u ^ n \\<le> v", "."], ["proof (state)\nthis:\n  u ^ n \\<le> v\n\ngoal (1 subgoal):\n 1. u ^ n < v", "with u_power_neq_v[of n]"], ["proof (chain)\npicking this:\n  u ^ n \\<noteq> v\n  u ^ n \\<le> v", "show ?thesis"], ["proof (prove)\nusing this:\n  u ^ n \\<noteq> v\n  u ^ n \\<le> v\n\ngoal (1 subgoal):\n 1. u ^ n < v", "by linarith"], ["proof (state)\nthis:\n  u ^ n < v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u ^ n < v\n\ngoal (1 subgoal):\n 1. z \\<notin> range nth_solution \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  u ^ n < v\n\ngoal (1 subgoal):\n 1. z \\<notin> range nth_solution \\<Longrightarrow> False", "have \"v < u ^ Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v < u ^ Suc n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v < u ^ Suc n", "have \"v = u powr log u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = u powr log u v", "using u_ge_2 v_pos"], ["proof (prove)\nusing this:\n  2 \\<le> u\n  0 < v\n\ngoal (1 subgoal):\n 1. v = u powr log u v", "by (subst powr_log_cancel) auto"], ["proof (state)\nthis:\n  v = u powr log u v\n\ngoal (1 subgoal):\n 1. v < u ^ Suc n", "also"], ["proof (state)\nthis:\n  v = u powr log u v\n\ngoal (1 subgoal):\n 1. v < u ^ Suc n", "have \"log u v \\<le> 1 + real_of_int \\<lfloor>log u v\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log u v \\<le> 1 + real_of_int \\<lfloor>log u v\\<rfloor>", "by linarith"], ["proof (state)\nthis:\n  log u v \\<le> 1 + real_of_int \\<lfloor>log u v\\<rfloor>\n\ngoal (1 subgoal):\n 1. v < u ^ Suc n", "hence \"u powr log u v \\<le> u powr real (Suc n)\""], ["proof (prove)\nusing this:\n  log u v \\<le> 1 + real_of_int \\<lfloor>log u v\\<rfloor>\n\ngoal (1 subgoal):\n 1. u powr log u v \\<le> u powr real (Suc n)", "using u_ge_2 log_ge_1"], ["proof (prove)\nusing this:\n  log u v \\<le> 1 + real_of_int \\<lfloor>log u v\\<rfloor>\n  2 \\<le> u\n  1 \\<le> log u v\n\ngoal (1 subgoal):\n 1. u powr log u v \\<le> u powr real (Suc n)", "by (intro powr_mono) (auto simp: n_def)"], ["proof (state)\nthis:\n  u powr log u v \\<le> u powr real (Suc n)\n\ngoal (1 subgoal):\n 1. v < u ^ Suc n", "also"], ["proof (state)\nthis:\n  u powr log u v \\<le> u powr real (Suc n)\n\ngoal (1 subgoal):\n 1. v < u ^ Suc n", "have \"\\<dots> = u ^ Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u powr real (Suc n) = u ^ Suc n", "using u_ge_2"], ["proof (prove)\nusing this:\n  2 \\<le> u\n\ngoal (1 subgoal):\n 1. u powr real (Suc n) = u ^ Suc n", "by (subst powr_realpow) auto"], ["proof (state)\nthis:\n  u powr real (Suc n) = u ^ Suc n\n\ngoal (1 subgoal):\n 1. v < u ^ Suc n", "finally"], ["proof (chain)\npicking this:\n  v \\<le> u ^ Suc n", "have \"u ^ Suc n \\<ge> v\""], ["proof (prove)\nusing this:\n  v \\<le> u ^ Suc n\n\ngoal (1 subgoal):\n 1. v \\<le> u ^ Suc n", "."], ["proof (state)\nthis:\n  v \\<le> u ^ Suc n\n\ngoal (1 subgoal):\n 1. v < u ^ Suc n", "with u_power_neq_v[of \"Suc n\"]"], ["proof (chain)\npicking this:\n  u ^ Suc n \\<noteq> v\n  v \\<le> u ^ Suc n", "show ?thesis"], ["proof (prove)\nusing this:\n  u ^ Suc n \\<noteq> v\n  v \\<le> u ^ Suc n\n\ngoal (1 subgoal):\n 1. v < u ^ Suc n", "by linarith"], ["proof (state)\nthis:\n  v < u ^ Suc n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v < u ^ Suc n\n\ngoal (1 subgoal):\n 1. z \\<notin> range nth_solution \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  u ^ n < v\n  v < u ^ Suc n", "have \"v / u ^ n \\<in> {1<..<u}\""], ["proof (prove)\nusing this:\n  u ^ n < v\n  v < u ^ Suc n\n\ngoal (1 subgoal):\n 1. v / u ^ n \\<in> {1<..<u}", "using u_ge_2"], ["proof (prove)\nusing this:\n  u ^ n < v\n  v < u ^ Suc n\n  2 \\<le> u\n\ngoal (1 subgoal):\n 1. v / u ^ n \\<in> {1<..<u}", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  v / u ^ n \\<in> {1<..<u}\n\ngoal (1 subgoal):\n 1. z \\<notin> range nth_solution \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  v / u ^ n \\<in> {1<..<u}\n\ngoal (1 subgoal):\n 1. z \\<notin> range nth_solution \\<Longrightarrow> False", "have \"v / u ^ n = pell_valuation z'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v / u ^ n = pell_valuation z'", "using fund_sol_is_nontriv_solution"], ["proof (prove)\nusing this:\n  nontriv_solution fund_sol\n\ngoal (1 subgoal):\n 1. v / u ^ n = pell_valuation z'", "by (auto simp add: z'_def u_def v_def pell_valuation_cnj_solution field_simps)"], ["proof (state)\nthis:\n  v / u ^ n = pell_valuation z'\n\ngoal (1 subgoal):\n 1. z \\<notin> range nth_solution \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  pell_valuation z' \\<in> {1<..<u}", "have val: \"pell_valuation z' \\<in> {1<..<u}\""], ["proof (prove)\nusing this:\n  pell_valuation z' \\<in> {1<..<u}\n\ngoal (1 subgoal):\n 1. pell_valuation z' \\<in> {1<..<u}", "."], ["proof (state)\nthis:\n  pell_valuation z' \\<in> {1<..<u}\n\ngoal (1 subgoal):\n 1. z \\<notin> range nth_solution \\<Longrightarrow> False", "from val and \\<open>solution z'\\<close>"], ["proof (chain)\npicking this:\n  pell_valuation z' \\<in> {1<..<u}\n  solution z'", "have \"nontriv_solution z'\""], ["proof (prove)\nusing this:\n  pell_valuation z' \\<in> {1<..<u}\n  solution z'\n\ngoal (1 subgoal):\n 1. nontriv_solution z'", "by (auto simp: nontriv_solution_altdef)"], ["proof (state)\nthis:\n  nontriv_solution z'\n\ngoal (1 subgoal):\n 1. z \\<notin> range nth_solution \\<Longrightarrow> False", "from \\<open>solution z'\\<close> and val"], ["proof (chain)\npicking this:\n  solution z'\n  pell_valuation z' \\<in> {1<..<u}", "have \"fst z' > 0 \\<and> snd z' > 0\""], ["proof (prove)\nusing this:\n  solution z'\n  pell_valuation z' \\<in> {1<..<u}\n\ngoal (1 subgoal):\n 1. 0 < fst z' \\<and> 0 < snd z'", "by (intro pell_valuation_solution_gt1D) auto"], ["proof (state)\nthis:\n  0 < fst z' \\<and> 0 < snd z'\n\ngoal (1 subgoal):\n 1. z \\<notin> range nth_solution \\<Longrightarrow> False", "hence [simp]: \"z' = (int x, int y)\""], ["proof (prove)\nusing this:\n  0 < fst z' \\<and> 0 < snd z'\n\ngoal (1 subgoal):\n 1. z' = (int x, int y)", "by (auto simp: x_def y_def)"], ["proof (state)\nthis:\n  z' = (int x, int y)\n\ngoal (1 subgoal):\n 1. z \\<notin> range nth_solution \\<Longrightarrow> False", "from \\<open>nontriv_solution z'\\<close>"], ["proof (chain)\npicking this:\n  nontriv_solution z'", "have \"pell_valuation (int x, int y) \\<ge> u\""], ["proof (prove)\nusing this:\n  nontriv_solution z'\n\ngoal (1 subgoal):\n 1. u \\<le> pell_valuation (int x, int y)", "unfolding u_def"], ["proof (prove)\nusing this:\n  nontriv_solution z'\n\ngoal (1 subgoal):\n 1. pell_valuation (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))\n    \\<le> pell_valuation (int x, int y)", "by (intro fund_sol_minimal) auto"], ["proof (state)\nthis:\n  u \\<le> pell_valuation (int x, int y)\n\ngoal (1 subgoal):\n 1. z \\<notin> range nth_solution \\<Longrightarrow> False", "with val"], ["proof (chain)\npicking this:\n  pell_valuation z' \\<in> {1<..<u}\n  u \\<le> pell_valuation (int x, int y)", "show False"], ["proof (prove)\nusing this:\n  pell_valuation z' \\<in> {1<..<u}\n  u \\<le> pell_valuation (int x, int y)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z \\<in> range nth_solution\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary solution_iff_nth_solution:\n  fixes z :: \"nat \\<times> nat\"\n  shows \"solution z \\<longleftrightarrow> z \\<in> range nth_solution\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution z = (z \\<in> range nth_solution)", "using nth_solution_sound nth_solution_complete"], ["proof (prove)\nusing this:\n  solution (nth_solution ?n)\n  solution ?z \\<Longrightarrow> ?z \\<in> range nth_solution\n\ngoal (1 subgoal):\n 1. solution z = (z \\<in> range nth_solution)", "by blast"], ["", "corollary solution_iff_nth_solution':\n  fixes z :: \"int \\<times> int\"\n  shows \"solution (a, b) \\<longleftrightarrow> (nat \\<bar>a\\<bar>, nat \\<bar>b\\<bar>) \\<in> range nth_solution\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution (a, b) =\n    ((nat \\<bar>a\\<bar>, nat \\<bar>b\\<bar>) \\<in> range nth_solution)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. solution (a, b) =\n    ((nat \\<bar>a\\<bar>, nat \\<bar>b\\<bar>) \\<in> range nth_solution)", "have \"solution (a, b) \\<longleftrightarrow> solution (nat \\<bar>a\\<bar>, nat \\<bar>b\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution (a, b) = solution (nat \\<bar>a\\<bar>, nat \\<bar>b\\<bar>)", "by simp"], ["proof (state)\nthis:\n  solution (a, b) = solution (nat \\<bar>a\\<bar>, nat \\<bar>b\\<bar>)\n\ngoal (1 subgoal):\n 1. solution (a, b) =\n    ((nat \\<bar>a\\<bar>, nat \\<bar>b\\<bar>) \\<in> range nth_solution)", "also"], ["proof (state)\nthis:\n  solution (a, b) = solution (nat \\<bar>a\\<bar>, nat \\<bar>b\\<bar>)\n\ngoal (1 subgoal):\n 1. solution (a, b) =\n    ((nat \\<bar>a\\<bar>, nat \\<bar>b\\<bar>) \\<in> range nth_solution)", "have \"\\<dots> \\<longleftrightarrow> (nat \\<bar>a\\<bar>, nat \\<bar>b\\<bar>) \\<in> range nth_solution\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution (nat \\<bar>a\\<bar>, nat \\<bar>b\\<bar>) =\n    ((nat \\<bar>a\\<bar>, nat \\<bar>b\\<bar>) \\<in> range nth_solution)", "by (rule solution_iff_nth_solution)"], ["proof (state)\nthis:\n  solution (nat \\<bar>a\\<bar>, nat \\<bar>b\\<bar>) =\n  ((nat \\<bar>a\\<bar>, nat \\<bar>b\\<bar>) \\<in> range nth_solution)\n\ngoal (1 subgoal):\n 1. solution (a, b) =\n    ((nat \\<bar>a\\<bar>, nat \\<bar>b\\<bar>) \\<in> range nth_solution)", "finally"], ["proof (chain)\npicking this:\n  solution (a, b) =\n  ((nat \\<bar>a\\<bar>, nat \\<bar>b\\<bar>) \\<in> range nth_solution)", "show ?thesis"], ["proof (prove)\nusing this:\n  solution (a, b) =\n  ((nat \\<bar>a\\<bar>, nat \\<bar>b\\<bar>) \\<in> range nth_solution)\n\ngoal (1 subgoal):\n 1. solution (a, b) =\n    ((nat \\<bar>a\\<bar>, nat \\<bar>b\\<bar>) \\<in> range nth_solution)", "."], ["proof (state)\nthis:\n  solution (a, b) =\n  ((nat \\<bar>a\\<bar>, nat \\<bar>b\\<bar>) \\<in> range nth_solution)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary infinite_solutions: \"infinite {z :: nat \\<times> nat. solution z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (Collect solution)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite (Collect solution)", "have \"infinite (range nth_solution)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (range nth_solution)", "by (intro range_inj_infinite nth_solution_inj)"], ["proof (state)\nthis:\n  infinite (range nth_solution)\n\ngoal (1 subgoal):\n 1. infinite (Collect solution)", "also"], ["proof (state)\nthis:\n  infinite (range nth_solution)\n\ngoal (1 subgoal):\n 1. infinite (Collect solution)", "have \"range nth_solution = {z :: nat \\<times> nat. solution z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range nth_solution = Collect solution", "by (auto simp: solution_iff_nth_solution)"], ["proof (state)\nthis:\n  range nth_solution = Collect solution\n\ngoal (1 subgoal):\n 1. infinite (Collect solution)", "finally"], ["proof (chain)\npicking this:\n  infinite (Collect solution)", "show ?thesis"], ["proof (prove)\nusing this:\n  infinite (Collect solution)\n\ngoal (1 subgoal):\n 1. infinite (Collect solution)", "."], ["proof (state)\nthis:\n  infinite (Collect solution)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary infinite_solutions': \"infinite {z :: int \\<times> int. solution z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (Collect solution)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (Collect solution) \\<Longrightarrow> False", "assume \"finite {z :: int \\<times> int. solution z}\""], ["proof (state)\nthis:\n  finite (Collect solution)\n\ngoal (1 subgoal):\n 1. finite (Collect solution) \\<Longrightarrow> False", "hence \"finite (map_prod (nat \\<circ> abs) (nat \\<circ> abs) ` {z :: int \\<times> int. solution z})\""], ["proof (prove)\nusing this:\n  finite (Collect solution)\n\ngoal (1 subgoal):\n 1. finite (map_prod (nat \\<circ> abs) (nat \\<circ> abs) ` Collect solution)", "by (rule finite_imageI)"], ["proof (state)\nthis:\n  finite (map_prod (nat \\<circ> abs) (nat \\<circ> abs) ` Collect solution)\n\ngoal (1 subgoal):\n 1. finite (Collect solution) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  finite (map_prod (nat \\<circ> abs) (nat \\<circ> abs) ` Collect solution)\n\ngoal (1 subgoal):\n 1. finite (Collect solution) \\<Longrightarrow> False", "have \"(map_prod (nat \\<circ> abs) (nat \\<circ> abs) ` {z :: int \\<times> int. solution z}) =\n               {z :: nat \\<times> nat. solution z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_prod (nat \\<circ> abs) (nat \\<circ> abs) ` Collect solution =\n    Collect solution", "by (auto simp: map_prod_def image_iff intro!: exI[of _ \"int x\" for x])"], ["proof (state)\nthis:\n  map_prod (nat \\<circ> abs) (nat \\<circ> abs) ` Collect solution =\n  Collect solution\n\ngoal (1 subgoal):\n 1. finite (Collect solution) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  finite (Collect solution)", "show False"], ["proof (prove)\nusing this:\n  finite (Collect solution)\n\ngoal (1 subgoal):\n 1. False", "using infinite_solutions"], ["proof (prove)\nusing this:\n  finite (Collect solution)\n  infinite (Collect solution)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma strict_mono_pell_valuation_nth_solution: \"strict_mono (pell_valuation \\<circ> nth_solution)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_mono\n     (pell_valuation \\<circ>\n      (\\<lambda>x.\n          case nth_solution x of (x, y) \\<Rightarrow> (int x, int y)))", "using pell_valuation_fund_sol_ge_2"], ["proof (prove)\nusing this:\n  2 \\<le> pell_valuation\n           (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))\n\ngoal (1 subgoal):\n 1. strict_mono\n     (pell_valuation \\<circ>\n      (\\<lambda>x.\n          case nth_solution x of (x, y) \\<Rightarrow> (int x, int y)))", "by (auto simp: strict_mono_def intro!: power_strict_increasing)"], ["", "lemma strict_mono_nth_solution:\n  \"strict_mono (fst \\<circ> nth_solution)\" \"strict_mono (snd \\<circ> nth_solution)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_mono (fst \\<circ> nth_solution) &&&\n    strict_mono (snd \\<circ> nth_solution)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. strict_mono (fst \\<circ> nth_solution)\n 2. strict_mono (snd \\<circ> nth_solution)", "let ?g = nth_solution"], ["proof (state)\ngoal (2 subgoals):\n 1. strict_mono (fst \\<circ> nth_solution)\n 2. strict_mono (snd \\<circ> nth_solution)", "have \"fst (?g m) < fst (?g n) \\<and> snd (?g m) < snd (?g n)\" if \"m < n\" for m n"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (nth_solution m) < fst (nth_solution n) \\<and>\n    snd (nth_solution m) < snd (nth_solution n)", "using pell_valuation_fund_sol_ge_2 that"], ["proof (prove)\nusing this:\n  2 \\<le> pell_valuation\n           (case fund_sol of (x, y) \\<Rightarrow> (int x, int y))\n  m < n\n\ngoal (1 subgoal):\n 1. fst (nth_solution m) < fst (nth_solution n) \\<and>\n    snd (nth_solution m) < snd (nth_solution n)", "by (subst solutions_less_iff_pell_valuation_less) auto"], ["proof (state)\nthis:\n  ?m4 < ?n4 \\<Longrightarrow>\n  fst (nth_solution ?m4) < fst (nth_solution ?n4) \\<and>\n  snd (nth_solution ?m4) < snd (nth_solution ?n4)\n\ngoal (2 subgoals):\n 1. strict_mono (fst \\<circ> nth_solution)\n 2. strict_mono (snd \\<circ> nth_solution)", "thus \"strict_mono (fst \\<circ> nth_solution)\" \"strict_mono (snd \\<circ> nth_solution)\""], ["proof (prove)\nusing this:\n  ?m4 < ?n4 \\<Longrightarrow>\n  fst (nth_solution ?m4) < fst (nth_solution ?n4) \\<and>\n  snd (nth_solution ?m4) < snd (nth_solution ?n4)\n\ngoal (1 subgoal):\n 1. strict_mono (fst \\<circ> nth_solution) &&&\n    strict_mono (snd \\<circ> nth_solution)", "by (auto simp: strict_mono_def)"], ["proof (state)\nthis:\n  strict_mono (fst \\<circ> nth_solution)\n  strict_mono (snd \\<circ> nth_solution)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>The case of an ``almost square'' parameter\\<close>"], ["", "text \\<open>\n  If \\<open>D\\<close> is equal to \\<open>a\\<^sup>2 - 1\\<close> for some \\<open>a > 1\\<close>, we have a particularly simple case\n  where the fundamental solution is simply \\<open>(1, a)\\<close>.\n\\<close>"], ["", "context\n  fixes a :: nat\n  assumes a: \"a > 1\"\nbegin"], ["", "lemma pell_square_minus1: \"pell (a\\<^sup>2 - Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell (a\\<^sup>2 - Suc 0)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_square (a\\<^sup>2 - Suc 0)", "show \"\\<not>is_square (a\\<^sup>2 - Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_square (a\\<^sup>2 - Suc 0)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. is_square (a\\<^sup>2 - Suc 0) \\<Longrightarrow> False", "assume \"is_square (a\\<^sup>2 - Suc 0)\""], ["proof (state)\nthis:\n  is_square (a\\<^sup>2 - Suc 0)\n\ngoal (1 subgoal):\n 1. is_square (a\\<^sup>2 - Suc 0) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  is_square (a\\<^sup>2 - Suc 0)", "obtain k where \"k\\<^sup>2 = a\\<^sup>2 - 1\""], ["proof (prove)\nusing this:\n  is_square (a\\<^sup>2 - Suc 0)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        k\\<^sup>2 = a\\<^sup>2 - 1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto elim: is_nth_powerE)"], ["proof (state)\nthis:\n  k\\<^sup>2 = a\\<^sup>2 - 1\n\ngoal (1 subgoal):\n 1. is_square (a\\<^sup>2 - Suc 0) \\<Longrightarrow> False", "with a"], ["proof (chain)\npicking this:\n  1 < a\n  k\\<^sup>2 = a\\<^sup>2 - 1", "have \"a\\<^sup>2 = Suc (k\\<^sup>2)\""], ["proof (prove)\nusing this:\n  1 < a\n  k\\<^sup>2 = a\\<^sup>2 - 1\n\ngoal (1 subgoal):\n 1. a\\<^sup>2 = Suc (k\\<^sup>2)", "by simp"], ["proof (state)\nthis:\n  a\\<^sup>2 = Suc (k\\<^sup>2)\n\ngoal (1 subgoal):\n 1. is_square (a\\<^sup>2 - Suc 0) \\<Longrightarrow> False", "hence \"a = 1\""], ["proof (prove)\nusing this:\n  a\\<^sup>2 = Suc (k\\<^sup>2)\n\ngoal (1 subgoal):\n 1. a = 1", "using pell_square_solution_nat_iff[of \"1\" a k]"], ["proof (prove)\nusing this:\n  a\\<^sup>2 = Suc (k\\<^sup>2)\n  is_square 1 \\<Longrightarrow>\n  (a\\<^sup>2 = 1 + 1 * k\\<^sup>2) = (a = 1 \\<and> (1 = 0 \\<or> k = 0))\n\ngoal (1 subgoal):\n 1. a = 1", "by simp"], ["proof (state)\nthis:\n  a = 1\n\ngoal (1 subgoal):\n 1. is_square (a\\<^sup>2 - Suc 0) \\<Longrightarrow> False", "with a"], ["proof (chain)\npicking this:\n  1 < a\n  a = 1", "show False"], ["proof (prove)\nusing this:\n  1 < a\n  a = 1\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> is_square (a\\<^sup>2 - Suc 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation pell \"a\\<^sup>2 - Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pell (a\\<^sup>2 - Suc 0)", "by (rule pell_square_minus1)"], ["", "lemma fund_sol_square_minus1: \"fund_sol = (a, 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fund_sol = (a, 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fund_sol = (a, 1)", "from a"], ["proof (chain)\npicking this:\n  1 < a", "have sol: \"nontriv_solution (a, 1)\""], ["proof (prove)\nusing this:\n  1 < a\n\ngoal (1 subgoal):\n 1. nontriv_solution (a, 1)", "by (simp add: nontriv_solution_def)"], ["proof (state)\nthis:\n  nontriv_solution (a, 1)\n\ngoal (1 subgoal):\n 1. fund_sol = (a, 1)", "from sol"], ["proof (chain)\npicking this:\n  nontriv_solution (a, 1)", "have \"snd fund_sol \\<le> 1\""], ["proof (prove)\nusing this:\n  nontriv_solution (a, 1)\n\ngoal (1 subgoal):\n 1. snd fund_sol \\<le> 1", "using fund_sol_minimal''[of \"(a, 1)\"]"], ["proof (prove)\nusing this:\n  nontriv_solution (a, 1)\n  nontriv_solution (a, 1) \\<Longrightarrow> fst fund_sol \\<le> fst (a, 1)\n  nontriv_solution (a, 1) \\<Longrightarrow> snd fund_sol \\<le> snd (a, 1)\n\ngoal (1 subgoal):\n 1. snd fund_sol \\<le> 1", "by auto"], ["proof (state)\nthis:\n  snd fund_sol \\<le> 1\n\ngoal (1 subgoal):\n 1. fund_sol = (a, 1)", "with solutions_linorder_strict[of a 1 \"fst fund_sol\" \"snd fund_sol\"]\n       fund_sol_is_nontriv_solution sol"], ["proof (chain)\npicking this:\n  \\<lbrakk>solution (a, 1); solution (fst fund_sol, snd fund_sol)\\<rbrakk>\n  \\<Longrightarrow> (a, 1) = (fst fund_sol, snd fund_sol) \\<or>\n                    a < fst fund_sol \\<and> 1 < snd fund_sol \\<or>\n                    fst fund_sol < a \\<and> snd fund_sol < 1\n  nontriv_solution fund_sol\n  nontriv_solution (a, 1)\n  snd fund_sol \\<le> 1", "show \"fund_sol = (a, 1)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>solution (a, 1); solution (fst fund_sol, snd fund_sol)\\<rbrakk>\n  \\<Longrightarrow> (a, 1) = (fst fund_sol, snd fund_sol) \\<or>\n                    a < fst fund_sol \\<and> 1 < snd fund_sol \\<or>\n                    fst fund_sol < a \\<and> snd fund_sol < 1\n  nontriv_solution fund_sol\n  nontriv_solution (a, 1)\n  snd fund_sol \\<le> 1\n\ngoal (1 subgoal):\n 1. fund_sol = (a, 1)", "by (cases fund_sol) (auto simp: nontriv_solution_altdef)"], ["proof (state)\nthis:\n  fund_sol = (a, 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Alternative presentation of the main results\\<close>"], ["", "theorem pell_solutions:\n fixes D :: nat\n assumes \"\\<nexists>k. D = k\\<^sup>2\"\n obtains x\\<^sub>0 y\\<^sub>0 :: nat\n where   \"\\<forall>(x::int) (y::int).\n            x\\<^sup>2 - D * y\\<^sup>2 = 1 \\<longleftrightarrow>\n            (\\<exists>n::nat. nat \\<bar>x\\<bar> + sqrt D * nat \\<bar>y\\<bar> = (x\\<^sub>0 + sqrt D * y\\<^sub>0) ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x\\<^sub>0 y\\<^sub>0.\n        \\<forall>x y.\n           (x\\<^sup>2 - int D * y\\<^sup>2 = 1) =\n           (\\<exists>n.\n               real (nat \\<bar>x\\<bar>) +\n               sqrt (real D) * real (nat \\<bar>y\\<bar>) =\n               (real x\\<^sub>0 + sqrt (real D) * real y\\<^sub>0) ^\n               n) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x\\<^sub>0 y\\<^sub>0.\n        \\<forall>x y.\n           (x\\<^sup>2 - int D * y\\<^sup>2 = 1) =\n           (\\<exists>n.\n               real (nat \\<bar>x\\<bar>) +\n               sqrt (real D) * real (nat \\<bar>y\\<bar>) =\n               (real x\\<^sub>0 + sqrt (real D) * real y\\<^sub>0) ^\n               n) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  \\<nexists>k. D = k\\<^sup>2", "interpret pell"], ["proof (prove)\nusing this:\n  \\<nexists>k. D = k\\<^sup>2\n\ngoal (1 subgoal):\n 1. pell D", "by unfold_locales (auto simp: is_nth_power_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x\\<^sub>0 y\\<^sub>0.\n        \\<forall>x y.\n           (x\\<^sup>2 - int D * y\\<^sup>2 = 1) =\n           (\\<exists>n.\n               real (nat \\<bar>x\\<bar>) +\n               sqrt (real D) * real (nat \\<bar>y\\<bar>) =\n               (real x\\<^sub>0 + sqrt (real D) * real y\\<^sub>0) ^\n               n) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (rule that[of \"fst fund_sol\" \"snd fund_sol\"], intro allI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x\\<^sup>2 - int D * y\\<^sup>2 = 1) =\n       (\\<exists>n.\n           real (nat \\<bar>x\\<bar>) +\n           sqrt (real D) * real (nat \\<bar>y\\<bar>) =\n           (real (fst fund_sol) + sqrt (real D) * real (snd fund_sol)) ^ n)", "case (1 x y)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x\\<^sup>2 - int D * y\\<^sup>2 = 1) =\n       (\\<exists>n.\n           real (nat \\<bar>x\\<bar>) +\n           sqrt (real D) * real (nat \\<bar>y\\<bar>) =\n           (real (fst fund_sol) + sqrt (real D) * real (snd fund_sol)) ^ n)", "have \"(x\\<^sup>2 - int D * y\\<^sup>2 = 1) \\<longleftrightarrow> solution (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>2 - int D * y\\<^sup>2 = 1) = solution (x, y)", "by (auto simp: solution_def)"], ["proof (state)\nthis:\n  (x\\<^sup>2 - int D * y\\<^sup>2 = 1) = solution (x, y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x\\<^sup>2 - int D * y\\<^sup>2 = 1) =\n       (\\<exists>n.\n           real (nat \\<bar>x\\<bar>) +\n           sqrt (real D) * real (nat \\<bar>y\\<bar>) =\n           (real (fst fund_sol) + sqrt (real D) * real (snd fund_sol)) ^ n)", "also"], ["proof (state)\nthis:\n  (x\\<^sup>2 - int D * y\\<^sup>2 = 1) = solution (x, y)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x\\<^sup>2 - int D * y\\<^sup>2 = 1) =\n       (\\<exists>n.\n           real (nat \\<bar>x\\<bar>) +\n           sqrt (real D) * real (nat \\<bar>y\\<bar>) =\n           (real (fst fund_sol) + sqrt (real D) * real (snd fund_sol)) ^ n)", "have \"\\<dots> \\<longleftrightarrow> (\\<exists>n. (nat \\<bar>x\\<bar>, nat \\<bar>y\\<bar>) = nth_solution n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solution (x, y) =\n    (\\<exists>n. (nat \\<bar>x\\<bar>, nat \\<bar>y\\<bar>) = nth_solution n)", "by (subst solution_iff_nth_solution') blast"], ["proof (state)\nthis:\n  solution (x, y) =\n  (\\<exists>n. (nat \\<bar>x\\<bar>, nat \\<bar>y\\<bar>) = nth_solution n)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x\\<^sup>2 - int D * y\\<^sup>2 = 1) =\n       (\\<exists>n.\n           real (nat \\<bar>x\\<bar>) +\n           sqrt (real D) * real (nat \\<bar>y\\<bar>) =\n           (real (fst fund_sol) + sqrt (real D) * real (snd fund_sol)) ^ n)", "also"], ["proof (state)\nthis:\n  solution (x, y) =\n  (\\<exists>n. (nat \\<bar>x\\<bar>, nat \\<bar>y\\<bar>) = nth_solution n)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x\\<^sup>2 - int D * y\\<^sup>2 = 1) =\n       (\\<exists>n.\n           real (nat \\<bar>x\\<bar>) +\n           sqrt (real D) * real (nat \\<bar>y\\<bar>) =\n           (real (fst fund_sol) + sqrt (real D) * real (snd fund_sol)) ^ n)", "have \"(\\<lambda>n. (nat \\<bar>x\\<bar>, nat \\<bar>y\\<bar>) = nth_solution n) =\n                 (\\<lambda>n. pell_valuation (nat \\<bar>x\\<bar>, nat \\<bar>y\\<bar>) = pell_valuation (nth_solution n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. (nat \\<bar>x\\<bar>, nat \\<bar>y\\<bar>) = nth_solution n) =\n    (\\<lambda>n.\n        pell_valuation\n         (case (nat \\<bar>x\\<bar>, nat \\<bar>y\\<bar>) of\n          (x, y) \\<Rightarrow> (int x, int y)) =\n        pell_valuation\n         (case nth_solution n of (x, y) \\<Rightarrow> (int x, int y)))", "by (subst pell_valuation_eq_iff) (auto simp add: case_prod_unfold prod_eq_iff fun_eq_iff)"], ["proof (state)\nthis:\n  (\\<lambda>n. (nat \\<bar>x\\<bar>, nat \\<bar>y\\<bar>) = nth_solution n) =\n  (\\<lambda>n.\n      pell_valuation\n       (case (nat \\<bar>x\\<bar>, nat \\<bar>y\\<bar>) of\n        (x, y) \\<Rightarrow> (int x, int y)) =\n      pell_valuation\n       (case nth_solution n of (x, y) \\<Rightarrow> (int x, int y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x\\<^sup>2 - int D * y\\<^sup>2 = 1) =\n       (\\<exists>n.\n           real (nat \\<bar>x\\<bar>) +\n           sqrt (real D) * real (nat \\<bar>y\\<bar>) =\n           (real (fst fund_sol) + sqrt (real D) * real (snd fund_sol)) ^ n)", "also"], ["proof (state)\nthis:\n  (\\<lambda>n. (nat \\<bar>x\\<bar>, nat \\<bar>y\\<bar>) = nth_solution n) =\n  (\\<lambda>n.\n      pell_valuation\n       (case (nat \\<bar>x\\<bar>, nat \\<bar>y\\<bar>) of\n        (x, y) \\<Rightarrow> (int x, int y)) =\n      pell_valuation\n       (case nth_solution n of (x, y) \\<Rightarrow> (int x, int y)))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x\\<^sup>2 - int D * y\\<^sup>2 = 1) =\n       (\\<exists>n.\n           real (nat \\<bar>x\\<bar>) +\n           sqrt (real D) * real (nat \\<bar>y\\<bar>) =\n           (real (fst fund_sol) + sqrt (real D) * real (snd fund_sol)) ^ n)", "have \"\\<dots> = (\\<lambda>n. nat \\<bar>x\\<bar> + sqrt D * nat \\<bar>y\\<bar> = (fst fund_sol + sqrt D * snd fund_sol) ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        pell_valuation\n         (case (nat \\<bar>x\\<bar>, nat \\<bar>y\\<bar>) of\n          (x, y) \\<Rightarrow> (int x, int y)) =\n        pell_valuation\n         (case nth_solution n of (x, y) \\<Rightarrow> (int x, int y))) =\n    (\\<lambda>n.\n        real (nat \\<bar>x\\<bar>) +\n        sqrt (real D) * real (nat \\<bar>y\\<bar>) =\n        (real (fst fund_sol) + sqrt (real D) * real (snd fund_sol)) ^ n)", "by (subst pell_valuation_nth_solution)\n         (simp add: pell_valuation_def case_prod_unfold mult_ac)"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      pell_valuation\n       (case (nat \\<bar>x\\<bar>, nat \\<bar>y\\<bar>) of\n        (x, y) \\<Rightarrow> (int x, int y)) =\n      pell_valuation\n       (case nth_solution n of (x, y) \\<Rightarrow> (int x, int y))) =\n  (\\<lambda>n.\n      real (nat \\<bar>x\\<bar>) + sqrt (real D) * real (nat \\<bar>y\\<bar>) =\n      (real (fst fund_sol) + sqrt (real D) * real (snd fund_sol)) ^ n)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (x\\<^sup>2 - int D * y\\<^sup>2 = 1) =\n       (\\<exists>n.\n           real (nat \\<bar>x\\<bar>) +\n           sqrt (real D) * real (nat \\<bar>y\\<bar>) =\n           (real (fst fund_sol) + sqrt (real D) * real (snd fund_sol)) ^ n)", "finally"], ["proof (chain)\npicking this:\n  (x\\<^sup>2 - int D * y\\<^sup>2 = 1) =\n  (\\<exists>n.\n      real (nat \\<bar>x\\<bar>) + sqrt (real D) * real (nat \\<bar>y\\<bar>) =\n      (real (fst fund_sol) + sqrt (real D) * real (snd fund_sol)) ^ n)", "show ?case"], ["proof (prove)\nusing this:\n  (x\\<^sup>2 - int D * y\\<^sup>2 = 1) =\n  (\\<exists>n.\n      real (nat \\<bar>x\\<bar>) + sqrt (real D) * real (nat \\<bar>y\\<bar>) =\n      (real (fst fund_sol) + sqrt (real D) * real (snd fund_sol)) ^ n)\n\ngoal (1 subgoal):\n 1. (x\\<^sup>2 - int D * y\\<^sup>2 = 1) =\n    (\\<exists>n.\n        real (nat \\<bar>x\\<bar>) +\n        sqrt (real D) * real (nat \\<bar>y\\<bar>) =\n        (real (fst fund_sol) + sqrt (real D) * real (snd fund_sol)) ^ n)", "."], ["proof (state)\nthis:\n  (x\\<^sup>2 - int D * y\\<^sup>2 = 1) =\n  (\\<exists>n.\n      real (nat \\<bar>x\\<bar>) + sqrt (real D) * real (nat \\<bar>y\\<bar>) =\n      (real (fst fund_sol) + sqrt (real D) * real (snd fund_sol)) ^ n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary pell_solutions_infinite:\n fixes D :: nat\n assumes \"\\<nexists>k. D = k\\<^sup>2\"\n shows   \"infinite {(x :: int, y :: int). x\\<^sup>2 - D * y\\<^sup>2 = 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {(x, y). x\\<^sup>2 - int D * y\\<^sup>2 = 1}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite {(x, y). x\\<^sup>2 - int D * y\\<^sup>2 = 1}", "from assms"], ["proof (chain)\npicking this:\n  \\<nexists>k. D = k\\<^sup>2", "interpret pell"], ["proof (prove)\nusing this:\n  \\<nexists>k. D = k\\<^sup>2\n\ngoal (1 subgoal):\n 1. pell D", "by unfold_locales (auto simp: is_nth_power_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite {(x, y). x\\<^sup>2 - int D * y\\<^sup>2 = 1}", "have \"{(x :: int, y :: int). x\\<^sup>2 - D * y\\<^sup>2 = 1} = {z. solution z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). x\\<^sup>2 - int D * y\\<^sup>2 = 1} = Collect solution", "by (auto simp: solution_def)"], ["proof (state)\nthis:\n  {(x, y). x\\<^sup>2 - int D * y\\<^sup>2 = 1} = Collect solution\n\ngoal (1 subgoal):\n 1. infinite {(x, y). x\\<^sup>2 - int D * y\\<^sup>2 = 1}", "also"], ["proof (state)\nthis:\n  {(x, y). x\\<^sup>2 - int D * y\\<^sup>2 = 1} = Collect solution\n\ngoal (1 subgoal):\n 1. infinite {(x, y). x\\<^sup>2 - int D * y\\<^sup>2 = 1}", "have \"infinite \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (Collect solution)", "by (rule infinite_solutions')"], ["proof (state)\nthis:\n  infinite (Collect solution)\n\ngoal (1 subgoal):\n 1. infinite {(x, y). x\\<^sup>2 - int D * y\\<^sup>2 = 1}", "finally"], ["proof (chain)\npicking this:\n  infinite {(x, y). x\\<^sup>2 - int D * y\\<^sup>2 = 1}", "show ?thesis"], ["proof (prove)\nusing this:\n  infinite {(x, y). x\\<^sup>2 - int D * y\\<^sup>2 = 1}\n\ngoal (1 subgoal):\n 1. infinite {(x, y). x\\<^sup>2 - int D * y\\<^sup>2 = 1}", "."], ["proof (state)\nthis:\n  infinite {(x, y). x\\<^sup>2 - int D * y\\<^sup>2 = 1}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}