{"file_name": "/home/qj213/afp-2021-10-22/thys/SuperCalc/superposition.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/SuperCalc", "problem_names": ["lemma lift_orient_lit: \n  assumes \"orient_lit_inst L t s p \\<sigma>\"\n  shows \"orient_lit (subst_lit L \\<sigma>) (subst t \\<sigma>)  (subst s \\<sigma>) p\"", "lemma orient_lit_vars:\n  assumes \"orient_lit L t s p\"\n  shows \"vars_of t \\<subseteq> vars_of_lit L \\<and> vars_of s \\<subseteq> vars_of_lit L\"", "lemma orient_lit_inst_vars:\n  assumes \"orient_lit_inst L t s p \\<sigma>\"\n  shows \"vars_of t \\<subseteq> vars_of_lit L \\<and> vars_of s \\<subseteq> vars_of_lit L\"", "lemma orient_lit_inst_coincide:\n  assumes \"orient_lit_inst L1 t s polarity \\<sigma>\"\n  assumes \"coincide_on \\<sigma> \\<eta> (vars_of_lit L1)\"\n  shows \"orient_lit_inst L1 t s polarity \\<eta>\"", "lemma orient_lit_inst_subterms:\n  assumes \"orient_lit_inst L t s polarity \\<sigma>\"\n  assumes \"u \\<in> subterms_of t\"\n  shows \"u \\<in> subterms_of_lit L\"", "lemma mset_ecl_and_mset_lit:\n  assumes \"L \\<in> (cl_ecl C)\"\n  assumes \"finite (cl_ecl C)\"\n  shows \"(mset_lit (subst_lit L \\<sigma>)) \\<in># (mset_ecl (C,\\<sigma>))\"", "lemma ecl_ord_coincide:\n  assumes \"coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\"\n  shows \"mset_ecl (C,\\<sigma>) = mset_ecl (C,\\<sigma>')\"", "lemma mult_trm_ord_trans:\n  shows \"trans (mult trm_ord)\"", "lemma lit_ord_trans:\n  shows \"trans  lit_ord\"", "lemma lit_ord_wf:\n  shows \"wf lit_ord\"", "lemma mult_mult_trm_ord_trans:\n  shows \"trans (mult (mult trm_ord))\"", "lemma ecl_ord_trans:\n  shows \"trans  ecl_ord\"", "lemma cl_ord_trans:\n  shows \"trans cl_ord\"", "lemma cl_ord_eq_trans:\n  shows \"trans cl_ord_eq\"", "lemma wf_ecl_ord:\n  shows \"wf ecl_ord\"", "lemma eligible_literal_coincide:\n  assumes \"coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\"\n  assumes \"eligible_literal L C \\<sigma>\"\n  assumes \"L \\<in> (cl_ecl C)\"\n  shows \"eligible_literal L C \\<sigma>'\"", "lemma lower_or_eq_monotonic:\n  assumes \"lower_or_eq t1 s1\"\n  assumes \"lower_or_eq t2 s2\"\n  shows \"lower_or_eq (Comb t1 t2) (Comb s1 s2)\"", "lemma lower_on_term:\n  shows \"\\<And> \\<sigma> \\<eta>. lower_on \\<sigma> \\<eta> (vars_of t) \\<Longrightarrow> \n    (lower_or_eq (subst t \\<sigma>) (subst t \\<eta>))\"", "lemma diff_substs_yield_diff_trms:\n  assumes \"(subst (Var x) \\<sigma>) \\<noteq> (subst (Var x) \\<eta>)\"\n  shows \"(x \\<in> vars_of t)\n   \\<Longrightarrow> (subst t \\<sigma>) \\<noteq> (subst t \\<eta>)\"", "lemma lower_subst_yields_lower_trms:\n  assumes \"lower_on \\<sigma> \\<eta> (vars_of t)\"\n  assumes \"((subst (Var x) \\<sigma>),(subst (Var x) \\<eta>)) \\<in> trm_ord\"\n  assumes \"(x \\<in> vars_of t)\"\n  shows \"((subst t \\<sigma>),(subst t \\<eta>)) \\<in> trm_ord\"", "lemma lower_on_lit:\n  assumes \"lower_on \\<sigma> \\<eta> (vars_of_lit L)\"\n  assumes \"((subst (Var x) \\<sigma>),(subst (Var x) \\<eta>)) \\<in> trm_ord\"\n  assumes \"x \\<in> vars_of_lit L\"\n  shows \"((subst_lit L \\<sigma>), (subst_lit L \\<eta>)) \\<in> lit_ord\"", "lemma lower_on_lit_eq:\n  assumes \"lower_on \\<sigma> \\<eta> (vars_of_lit L)\"\n  shows \"((subst_lit L \\<sigma>) = (subst_lit L \\<eta>)) \\<or> ((subst_lit L \\<sigma>), (subst_lit L \\<eta>)) \\<in> lit_ord\"", "lemma lower_on_cl:\n  assumes \"lower_on \\<sigma> \\<eta> (vars_of_cl (cl_ecl C))\"\n  assumes \"((subst (Var x) \\<sigma>),(subst (Var x) \\<eta>)) \\<in> trm_ord\"\n  assumes \"x \\<in> vars_of_cl (cl_ecl C)\"\n  assumes \"finite (cl_ecl C)\"\n  shows \"((C,\\<sigma>), (C, \\<eta>)) \\<in> ecl_ord\"", "lemma subterm_trm_ord :\n  shows \"\\<And> t  s. \n           subterm t p s \\<Longrightarrow> p \\<noteq> []  \n          \\<Longrightarrow> (s,t) \\<in> trm_ord\"", "lemma subterm_trm_ord_eq :\n  assumes \"subterm t p s\" \n  shows \"s = t \\<or> (s,t) \\<in> trm_ord\"", "lemma subterms_of_trm_ord_eq :\n  assumes \"s \\<in> subterms_of t\" \n  shows \"s = t \\<or> (s,t) \\<in> trm_ord\"", "lemma subt_trm_ord:\n  shows \"t \\<prec> s \\<longrightarrow> (t,s) \\<in> trm_ord\"", "lemma trm_ord_vars:\n  assumes \"(t,s) \\<in> trm_ord\"\n  shows \"vars_of t \\<subseteq> vars_of s\"", "lemma lower_on_ground:\n  assumes \"lower_on \\<sigma> \\<eta> V\"\n  assumes \"ground_on  V \\<eta>\"\n  shows \"ground_on  V \\<sigma>\"", "lemma replacement_monotonic :\n  shows \"\\<And> t  s. ((subst v \\<sigma>), (subst u \\<sigma>)) \\<in> trm_ord \n          \\<Longrightarrow> subterm t p u \\<Longrightarrow> replace_subterm t p v s \n          \\<Longrightarrow> ((subst s \\<sigma>), (subst t \\<sigma>)) \\<in> trm_ord\"", "lemma mset_lit_subst:\n  shows \"(mset_lit (subst_lit L \\<sigma>)) = \n    {# (subst x \\<sigma>). x \\<in># (mset_lit L) #}\"", "lemma lit_ord_irrefl:\n  shows \"(L,L) \\<notin> lit_ord\"", "lemma lit_ord_subst:\n  assumes \"(L,M) \\<in> lit_ord\"\n  shows \"((subst_lit L \\<sigma>), (subst_lit M \\<sigma>)) \\<in> lit_ord\"", "lemma args_are_strictly_lower:\n   assumes \"is_compound t\"\n   shows \"(lhs t,t) \\<in> trm_ord \\<and> (rhs t,t) \\<in> trm_ord\"", "lemma mset_subst:\n  assumes \"C' = subst_cl D \\<theta>\" \n  assumes \"\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\"\n  assumes \"finite D\"\n  shows \"mset_cl (C',\\<eta>) = mset_cl (D,\\<sigma>) \\<or> (mset_cl (C',\\<eta>),mset_cl (D,\\<sigma>)) \\<in> (mult (mult trm_ord))\"", "lemma max_lit_exists:\n  shows \"finite C \\<Longrightarrow> C \\<noteq> {} \\<longrightarrow> ground_clause C \\<longrightarrow> (\\<exists>L. (L \\<in> C \\<and> (maximal_literal L C)))\"", "lemma eligible_lit_exists:\n  assumes \"finite (cl_ecl C)\"\n  assumes \"(cl_ecl C) \\<noteq> {}\"\n  assumes \"(ground_clause (subst_cl (cl_ecl C) \\<sigma>))\"\n  shows \"\\<exists>L. ((eligible_literal L C \\<sigma>) \\<and> (L \\<in> (cl_ecl C)))\"", "lemma lit_ord_dominating_term:\n  assumes \"(s1,s2) \\<in> trm_ord \\<or> (s1,t2) \\<in> trm_ord\"\n  assumes \"orient_lit x1 s1 t1 p1\"\n  assumes \"orient_lit x2 s2 t2 p2\"\n  assumes \"vars_of_lit x1 = {}\"\n  assumes \"vars_of_lit x2 = {}\"\n  shows \"(x1,x2) \\<in> lit_ord\"", "lemma lit_ord_neg_lit_lhs:\n  assumes \"orient_lit x1 s t1 pos\"\n  assumes \"orient_lit x2 s t2 neg\"\n  assumes \"vars_of_lit x1 = {}\"\n  assumes \"vars_of_lit x2 = {}\"\n  shows \"(x1,x2) \\<in> lit_ord\"", "lemma lit_ord_neg_lit_rhs:\n  assumes \"orient_lit x1 s t1 pos\"\n  assumes \"orient_lit x2 t2 s neg\"\n  assumes \"vars_of_lit x1 = {}\"\n  assumes \"vars_of_lit x2 = {}\"\n  shows \"(x1,x2) \\<in> lit_ord\"", "lemma lit_ord_rhs:\n  assumes \"(t1,t2) \\<in> trm_ord\"\n  assumes \"orient_lit x1 s t1 p\"\n  assumes \"orient_lit x2 s t2 p\"\n  assumes \"vars_of_lit x1 = {}\"\n  assumes \"vars_of_lit x2 = {}\"\n  shows \"(x1,x2) \\<in> lit_ord\"", "lemma trm_rep_preserves_eq_semantics:\n  assumes \"fo_interpretation I\"\n  assumes \"(I (subst t1 \\<sigma>) (subst t2 \\<sigma>))\"\n  assumes \"(validate_ground_eq I (subst_equation (Eq t1 s) \\<sigma>))\"\n  shows \"(validate_ground_eq I (subst_equation (Eq t2 s) \\<sigma>))\"", "lemma trm_rep_preserves_lit_semantics:\n  assumes \"fo_interpretation I\"\n  assumes \"(I (subst t1 \\<sigma>) (subst t2 \\<sigma>))\"\n  assumes \"orient_lit_inst L t1 s polarity \\<sigma>'\"\n  assumes \"\\<not>(validate_ground_lit I (subst_lit L \\<sigma>))\"\n  shows \"\\<not>validate_ground_lit I (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)\"", "lemma subterms_dominated :\n  assumes \"maximal_literal L C\"\n  assumes \"orient_lit L t s p\"\n  assumes \"u \\<in> subterms_of_cl C\"\n  assumes \"vars_of_lit L = {}\"\n  assumes \"vars_of_cl C = {}\"\n  shows \"u = t \\<or> (u,t) \\<in> trm_ord\"", "lemma ck_unifier_thm:\n  assumes \"ck_unifier t s \\<sigma> k\"\n  shows \"(subst t \\<sigma>) = (subst s \\<sigma>)\"", "lemma subst_preserve_ck_unifier:\n  assumes \"ck_unifier t s \\<sigma> k\"\n  shows \"ck_unifier t s (comp \\<sigma> \\<eta>) Ground\"", "lemma dom_trm_lemma:\n  assumes \"dom_trm t C\"\n  shows \"\\<exists> u. (u \\<in> (subterms_of_cl C) \\<and> (u = t \\<or> (t,u) \\<in> trm_ord))\"", "lemma dom_trms_subset:\n  shows \"(dom_trms C E ) \\<subseteq> E\"", "lemma dom_trm_vars:\n  assumes \"dom_trm t C\"\n  shows \"vars_of t \\<subseteq> vars_of_cl C\"", "lemma derivable_premisses:\n  assumes \"derivable C P S \\<sigma> k C'\"\n  shows \"P \\<subseteq> S\"", "lemma cannot_validate_contradictary_literals :\n  assumes \"l = Neg (Eq t t)\"\n  assumes \"fo_interpretation I\"\n  shows \"\\<not> (validate_ground_lit I l)\"", "lemma ground_reflexion_is_sound :\n  assumes \"finite (cl_ecl C)\"\n  assumes \"reflexion C D \\<sigma> k C'\"\n  assumes \"(ground_clause (subst_cl (cl_ecl D) \\<theta>))\"\n  shows \"clause_entails_clause (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \n          (subst_cl (cl_ecl D) \\<theta>)\"", "lemma reflexion_is_sound :\n  assumes \"finite (cl_ecl C)\"\n  assumes \"reflexion C D \\<sigma> k C'\"\n  shows \"clause_entails_clause (cl_ecl C) (cl_ecl D)\"", "lemma orient_lit_semantics_pos :\n  assumes \"fo_interpretation I\"\n  assumes \"orient_lit_inst l u v pos \\<eta>\"\n  assumes \"validate_ground_lit I (subst_lit l \\<sigma>)\"\n  shows \"I (subst u \\<sigma>) (subst v \\<sigma>)\"", "lemma orient_lit_semantics_neg :\n  assumes \"fo_interpretation I\"\n  assumes \"orient_lit_inst l u v neg \\<theta>\"\n  assumes \"validate_ground_lit I (subst_lit l \\<sigma>)\"\n  shows \"\\<not>I (subst u \\<sigma>) (subst v \\<sigma>)\"", "lemma orient_lit_semantics_replacement :\n  assumes \"fo_interpretation I\"\n  assumes \"orient_lit_inst l u v polarity \\<theta>\"\n  assumes \"validate_ground_lit I (subst_lit l \\<sigma>)\" \n  assumes \"I (subst u \\<sigma>) (subst u' \\<sigma>)\"\n  shows \"validate_ground_lit I (subst_lit (mk_lit polarity (Eq u' v)) \\<sigma>)\"", "lemma ground_factorization_is_sound :\n  assumes \"finite (cl_ecl C)\"\n  assumes \"factorization C D \\<sigma> k C'\"\n  assumes \"(ground_clause (subst_cl (cl_ecl D) \\<theta>))\"\n  shows \"clause_entails_clause (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \n          (subst_cl (cl_ecl D) \\<theta>)\"", "lemma factorization_is_sound :\n  assumes \"finite (cl_ecl C)\"\n  assumes \"factorization C D \\<sigma> k C'\"\n  shows \"clause_entails_clause (cl_ecl C) (cl_ecl D)\"", "lemma ground_superposition_is_sound :\n  assumes \"finite (cl_ecl P1)\"\n  assumes \"finite (cl_ecl P2)\"\n  assumes \"superposition P1 P2 C \\<sigma> k C'\"\n  assumes \"(ground_clause (subst_cl (cl_ecl C) \\<theta>))\"\n  shows \"set_entails_clause \n    { (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>), \n      (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) }\n          (subst_cl (cl_ecl C) \\<theta>)\"", "lemma superposition_is_sound :\n  assumes \"finite (cl_ecl P1)\"\n  assumes \"finite (cl_ecl P2)\"\n  assumes \"superposition P1 P2 C \\<sigma> k C'\"\n  shows \"set_entails_clause { cl_ecl P1, cl_ecl P2 } (cl_ecl C)\"", "lemma superposition_preserves_finiteness:\n  assumes \"finite (cl_ecl P1)\"\n  assumes \"finite (cl_ecl P2)\"\n  assumes \"superposition P1 P2 C \\<sigma> k C'\"\n  shows \"finite (cl_ecl C) \\<and> (finite C')\"", "lemma reflexion_preserves_finiteness:\n  assumes \"finite (cl_ecl P1)\"\n  assumes \"reflexion P1 C \\<sigma> k C'\"\n  shows \"finite (cl_ecl C) \\<and> (finite C')\"", "lemma factorization_preserves_finiteness:\n  assumes \"finite (cl_ecl P1)\"\n  assumes \"factorization P1 C \\<sigma> k C'\"\n  shows \"finite (cl_ecl C) \\<and> (finite C')\"", "lemma derivable_clauses_are_finite:\n  assumes \"derivable C P S \\<sigma> k C'\"\n  assumes \"\\<forall>x \\<in> P. (finite (cl_ecl x))\" \n  shows \"finite (cl_ecl C) \\<and> (finite C')\"", "lemma derivable_clauses_lemma:\n  assumes \"derivable C P S \\<sigma> k C'\"\n  shows \"((cl_ecl C) = (subst_cl C' \\<sigma>))\"", "lemma substs_preserves_decompose_literal:\n  assumes \"decompose_literal L t s polarity\"\n  shows \"decompose_literal (subst_lit L \\<eta>) (subst t \\<eta>) (subst s \\<eta>) polarity\"", "lemma substs_preserve_dom_trm:\n  assumes \"dom_trm t C\"\n  shows \"dom_trm (subst t \\<sigma>) (subst_cl C \\<sigma>)\"", "lemma substs_preserve_well_constrainedness:\n  assumes \"well_constrained C\"\n  shows \"well_constrained (subst_ecl C \\<sigma>)\"", "lemma ck_trms_sound:\n  assumes \"T = get_trms D (dom_trms C E) k\"\n  shows \"T \\<subseteq> (dom_trms C E)\"", "lemma derivable_clauses_are_well_constrained:\n  assumes \"derivable C P S \\<sigma> k C'\"\n  shows \"well_constrained C\"", "lemma derivable_clauses_are_entailed:\n  assumes \"derivable C P S \\<sigma> k C'\"\n  assumes \"validate_clause_set I (cl_ecl ` P)\"\n  assumes \"fo_interpretation I\"\n  assumes \"\\<forall>x \\<in> P. (finite (cl_ecl x))\"\n  shows \"validate_clause I (cl_ecl C)\"", "lemma all_derived_clauses_are_finite:\n  shows \"derivable_ecl C S \\<Longrightarrow> \\<forall>x \\<in> S. (finite (cl_ecl x)) \\<Longrightarrow> finite (cl_ecl C)\"", "lemma all_derived_clauses_are_wellconstrained:\n  shows \"derivable_ecl C S \\<Longrightarrow> \\<forall>x \\<in> S. (well_constrained x) \\<Longrightarrow> well_constrained C\"", "lemma SOUNDNESS:\n  shows \"derivable_ecl C S \\<Longrightarrow> \\<forall>x \\<in> S. (finite (cl_ecl x)) \n    \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)\"", "lemma REFUTABLE_SETS_ARE_UNSAT:\n  assumes \"\\<forall>x \\<in> S. (finite (cl_ecl x))\"\n  assumes \"derivable_ecl C S\"\n  assumes \"(cl_ecl C = {})\"\n  shows \"\\<not> (satisfiable_clause_set (cl_ecl ` S))\"", "lemma subterms_inclusion_refl:\n shows \"subterms_inclusion E E\"", "lemma subterms_inclusion_subset:\n  assumes \"subterms_inclusion E1 E2\"\n  assumes \"E2 \\<subseteq> E2'\"\n  shows \"subterms_inclusion E1 E2'\"", "lemma set_inclusion_preserve_normalization:\n  assumes \"all_trms_irreducible E f\"\n  assumes \"E' \\<subseteq> E\"\n  shows \"all_trms_irreducible E' f\"", "lemma subterms_inclusion_preserves_normalization:\n  assumes \"all_trms_irreducible E f\"\n  assumes \"subterms_inclusion E' E\"\n  shows \"all_trms_irreducible E' f\"", "lemma self_redundant_clause:\n  assumes \"C \\<in> S\"\n  assumes \"C' = (cl_ecl C)\"\n  assumes \"ground_clause (subst_cl (cl_ecl C) \\<sigma>)\"\n  shows \"redundant_clause (subst_ecl C \\<sigma>) S \\<sigma> C'\"", "lemma conclusion_is_smaller_than_premisses:\n  assumes \"derivable C P S \\<sigma> Ground C'\"\n  assumes \"\\<forall>x \\<in> S. (finite (cl_ecl x))\" \n  assumes \"grounding_set P \\<sigma>\" \n  shows \"\\<exists> D. (D \\<in> P \\<and> (( (mset_cl (C',\\<sigma>)), (mset_ecl (D,\\<sigma>))) \\<in> (mult (mult trm_ord))))\"", "lemma redundant_inference_clause:\n  assumes \"redundant_clause E S \\<sigma> C'\"\n  assumes \"derivable C P S \\<sigma> Ground C'\"\n  assumes \"grounding_set P \\<sigma>\"\n  assumes \"\\<forall>x \\<in> S. (finite (cl_ecl x))\" \n  shows \"redundant_inference E S P \\<sigma>\"", "lemma clause_saturated_and_inference_saturated:\n  assumes \"clause_saturated S\"\n  assumes \"\\<forall>x \\<in> S. (finite (cl_ecl x))\" \n  shows \"inference_saturated S\"", "lemma same_values_fo_int:\n  assumes \"value_is_compatible_with_structure f\"\n  shows \"fo_interpretation (same_values f)\"", "lemma min_trms_not_empty:\n  assumes \"E \\<noteq> {}\"\n  shows \"min_trms E \\<noteq> {}\"", "lemma smaller_lits_are_false_if_cl_not_valid:\n  assumes \"\\<not>(validate_ground_clause (int_clset S) C)\"\n  shows \"smaller_lits_are_false t C S\"", "lemma trms_irreducible_lemma:\n  assumes \"all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>) (\\<lambda>t. trm_rep t S)\"\n  shows \"trms_irreducible C \\<sigma> S t\"", "lemma trm_rep_is_lower_aux:\n  assumes \"\\<forall>y. (y,t) \\<in> trm_ord \\<longrightarrow>\n      (y \\<noteq> (trm_rep y S) \\<longrightarrow> ((trm_rep y S),y) \\<in> trm_ord)\"\n  assumes \"(subterm_reduction_applicable S t)\"\n  shows \"((Comb (trm_rep (lhs t) S) (trm_rep (rhs t) S)),t) \\<in> trm_ord\"", "lemma trm_rep_init_def:\n  shows \"(trm_rep t) = (\\<lambda>S. (if (subterm_reduction_applicable_aux S t) \n                        then (subterm_reduction_aux S t)\n                        else (get_min t (set_of_candidate_values S t))))\"", "lemma trm_rep_aux_def:\n  assumes \"\\<forall>y. (y,t) \\<in> trm_ord \\<longrightarrow>\n      (y \\<noteq> (trm_rep y S) \\<longrightarrow> ((trm_rep y S),y) \\<in> trm_ord)\"\n  shows \"(trm_rep t S) = (if (subterm_reduction_applicable S t) \n                        then (subterm_reduction S t)\n                        else (get_min t (set_of_candidate_values S t)))\"", "lemma trm_rep_is_lower:  \n  shows \"(t \\<noteq> (trm_rep t S)) \\<longrightarrow> (((trm_rep t S),t) \\<in> trm_ord)\" (is \"?P t\")", "lemma trm_rep_is_lower_subt_red:  \n  assumes \"(subterm_reduction_applicable S x)\"\n  shows \"((trm_rep x S),x) \\<in> trm_ord\"", "lemma trm_rep_is_lower_root_red:  \n  assumes \"\\<not>(subterm_reduction_applicable S x)\"\n  assumes \"min_trms (set_of_candidate_values S x) \\<noteq> {}\"\n  shows \"(((trm_rep x S),x) \\<in> trm_ord)\"", "lemma trm_rep_simp_def:\n  shows \"(trm_rep t S) = (if (subterm_reduction_applicable S t) \n                        then (subterm_reduction S t)\n                        else (get_min t (set_of_candidate_values S t)))\"", "lemma trm_rep_involutive:  \n  shows \"(trm_rep (trm_rep t S) S) = (trm_rep t S)\" (is \"?P t\")", "lemma red_arg_implies_red_trm :\n  assumes \"st_red S t1\"\n  assumes \"t = (Comb t1 t2) \\<or> t = (Comb t2 t1)\"\n  shows \"st_red S t\"", "lemma subterms_of_irred_trms_are_irred: \n  \"(trm_rep t S) \\<noteq> t \\<longrightarrow> st_red S t\" (is \"(?P t)\")", "lemma trm_rep_compatible_with_structure:\n  shows \"value_is_compatible_with_structure (\\<lambda>x. trm_rep x S)\"", "lemma maximal_literal_is_unique_lemma:\n  assumes \"\\<not>equivalent_eq_exists t s C (int_clset S) \\<sigma> L1\"\n  shows \"maximal_literal_is_unique (subst t \\<sigma>) (subst s \\<sigma>) C L1 S \\<sigma>\"", "lemma max_pos_lit_dominates_cl:\n  assumes \"maximal_literal (subst_lit L \\<sigma>) (subst_cl C \\<sigma>)\"\n  assumes \"orient_lit_inst L t s pos \\<sigma>\"\n  assumes \"L' \\<in> C - { L }\"\n  assumes \"\\<not>equivalent_eq_exists t s C I \\<sigma> L\"\n  assumes \"vars_of_lit (subst_lit L \\<sigma>) = {}\"\n  assumes \"vars_of_lit (subst_lit L' \\<sigma>) = {}\"\n  assumes \"fo_interpretation I\"\n  shows \"((subst_lit L' \\<sigma>),(subst_lit L \\<sigma>)) \\<in> lit_ord\"", "lemma if_all_smaller_are_false_then_cl_not_valid:\n  assumes \"(smaller_lits_are_false (subst t \\<sigma>) (subst_cl C \\<sigma>) S)\"\n  assumes \"(fo_interpretation (same_values (\\<lambda>t. (trm_rep t S))))\"\n  assumes \"orient_lit_inst L1 t s pos \\<sigma>\"\n  assumes \"maximal_literal (subst_lit L1 \\<sigma>) (subst_cl C \\<sigma>)\"\n  assumes \"ground_clause (subst_cl C \\<sigma>)\"\n  assumes \"(subst_lit L1 \\<sigma>) \\<in> (subst_cl C \\<sigma>)\"\n  assumes \"\\<not>equivalent_eq_exists t s C (same_values (\\<lambda>t. (trm_rep t S))) \\<sigma> L1\"\n  assumes \"trm_rep (subst t \\<sigma>) S = trm_rep (subst s \\<sigma>) S\"\n  shows \"(\\<not> validate_ground_clause (same_values (\\<lambda>t. (trm_rep t S))) (subst_cl ( C - { L1 } ) \\<sigma>))\"", "lemma candidate_values_renaming:\n    assumes \"(candidate_values z CC C' C s L L' \\<sigma> t' s' t S)\"\n    assumes \"finite C'\"\n    assumes \"finite (cl_ecl (D:: 'a eclause))\"\n    assumes \"closed_under_renaming S\"\n    assumes \"Ball S well_constrained\"\n    shows \"\\<exists> CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n     (candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis s'_bis t S)\n     \\<and> (vars_of_cl (cl_ecl D)) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}\"", "lemma pos_ord_acyclic:\n  shows \"acyclic (pos_ord C t)\"", "lemma reduction_exists: \n  assumes \"polarity = neg \\<or> \\<not> equivalent_eq_exists t s (cl_ecl C) (int_clset S) \\<sigma> L1\n    \\<or> proper_subterm_red t S \\<sigma>\"\n  assumes \"\\<forall>x y. (( x \\<in> vars_of_cl (cl_ecl C)) \\<longrightarrow> (occurs_in y (subst (Var x) \\<sigma>)) \n            \\<longrightarrow> trm_rep y S = y)\"\n  assumes \"eligible_literal L1 C \\<sigma>\"\n  assumes \"(trm_rep (subst t \\<sigma>) S) \\<noteq>  (subst t \\<sigma>)\"\n  assumes \"L1 \\<in> (cl_ecl C)\"\n  assumes \"(orient_lit_inst L1 t s polarity \\<sigma>)\"\n  assumes \"\\<forall>x \\<in> S. finite (cl_ecl x)\"\n  assumes \"ground_clause (subst_cl (cl_ecl C) \\<sigma>)\"\n  assumes \"(fo_interpretation (same_values (\\<lambda>t. (trm_rep t S))))\"\n  assumes \"C \\<in> S\"\n  assumes \"Ball S well_constrained\"\n  assumes \"all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>) (\\<lambda>t. trm_rep t S)\"\n  assumes \"\\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\"\n  assumes \"closed_under_renaming S\"\n\n  shows \"\\<exists>\\<sigma>' u u' p v D L2. \n    ((reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (same_values (\\<lambda>t. (trm_rep t S))) S \\<sigma>)\n    \\<and> (variable_disjoint C D))\"", "lemma subts_of_irred_trms_are_irred:\n  assumes \"trm_rep y S \\<noteq> y\"\n  shows \"\\<And> x. subterm x p y \\<longrightarrow> trm_rep x S \\<noteq> x\"", "lemma allowed_redex_coincide:\n  assumes \"allowed_redex t C \\<sigma>\"\n  assumes \"t \\<in> subterms_of_cl (cl_ecl C)\" \n  assumes \"coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\"\n  assumes \"well_constrained C\"\n  shows \"allowed_redex t C \\<sigma>'\"", "lemma irred_terms_and_reduced_subst:\n  assumes \"f = (\\<lambda>t. (trm_rep t S))\"\n  assumes \"\\<eta> = (map_subst f \\<sigma>)\"\n  assumes \"all_trms_irreducible (subst_set E \\<sigma>) f\"\n  assumes \"I = int_clset S\"\n  assumes \"equivalent_on  \\<sigma> \\<eta> (vars_of_cl (cl_ecl C)) I\"\n  assumes \"lower_on \\<eta> \\<sigma>  (vars_of_cl (cl_ecl C))\"\n  assumes \"E = (trms_ecl C)\"\n  assumes \"\\<forall>x \\<in> S. \\<forall>y. (y \\<in> trms_ecl x \\<longrightarrow> dom_trm y (cl_ecl x))\"\n  assumes \"C \\<in> S\"\n  assumes \"fo_interpretation I\"\n  shows \"all_trms_irreducible (subst_set E \\<eta> ) f\"", "lemma no_valid_literal:\n  assumes \"L \\<in> C\"\n  assumes \"orient_lit_inst L t s pos \\<sigma>\"\n  assumes \"\\<not>(validate_ground_clause (int_clset S) (subst_cl C \\<sigma>))\"\n  shows \"trm_rep (subst t \\<sigma>) S \\<noteq> trm_rep (subst s \\<sigma>) S\"", "lemma lift_orient_lit_inst:\n  assumes \"orient_lit_inst  L t s polarity \\<theta>\"\n  assumes \"subst_eq \\<theta> (comp \\<sigma> \\<eta>)\" \n  shows \"orient_lit_inst L t s polarity \\<sigma>\"", "lemma lift_maximal_literal:\n  assumes \"maximal_literal (subst_lit L \\<sigma>) (subst_cl C \\<sigma>)\"\n  shows \"maximal_literal L C\"", "lemma lift_eligible_literal:\n  assumes \"eligible_literal L C \\<sigma>\"\n  assumes \"\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\"\n  shows \"eligible_literal L C \\<theta>\"", "lemma lift_allowed_redex:  \n    assumes \"\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\"\n    assumes \"(allowed_redex u C \\<sigma>)\"\n    shows \"(allowed_redex u C \\<theta>)\"", "lemma lift_decompose_literal:\n  assumes \"decompose_literal (subst_lit L \\<sigma>) t s polarity\"\n  assumes \"subst_eq \\<theta> (comp \\<sigma> \\<eta>)\" \n  shows \"decompose_literal (subst_lit L \\<theta>) (subst t \\<eta>) (subst s \\<eta>) polarity\"", "lemma lift_dom_trm:\n  assumes \"dom_trm (subst t \\<theta>) (subst_cl C \\<theta>)\"\n  assumes \"\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\"\n  shows \"dom_trm (subst t \\<sigma>) (subst_cl C \\<sigma>)\"", "lemma lift_irreducible_terms:\n  assumes \"T = get_trms C (dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)) Ground\"\n  assumes \"\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\"\n  shows \"\\<exists>T'. ( (subst_set T' \\<eta>) \\<subseteq> T \\<and> T' = get_trms C' \n    (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)) FirstOrder)\"", "lemma lifting_lemma:\n  assumes \"derivable C P S \\<sigma> Ground C'\"\n  shows \"\\<exists> D \\<theta> \\<eta>. ((derivable D P S \\<theta> FirstOrder C') \\<and> (\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>) \\<and> (trms_subsumes D C \\<eta>))\"", "lemma trms_subsumes_and_red_inf:\n  assumes \"trms_subsumes D C \\<eta>\"\n  assumes \"redundant_inference (subst_ecl D \\<eta>) S P \\<sigma>\"\n  assumes \"\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\"\n  shows \"redundant_inference C S P \\<sigma>\"", "lemma lift_inference:\n  assumes \"inference_saturated S\"\n  shows \"ground_inference_saturated S\"", "lemma lift_redundant_cl :\n  assumes \"C' = subst_cl D \\<theta>\" \n  assumes \"redundant_clause C S \\<eta> C'\" \n  assumes \"\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\"\n  assumes \"finite D\"\n  shows \"redundant_clause C S \\<sigma> D\"", "lemma inference_closed_sets_are_saturated:\n  assumes \"inference_closed S\"\n  assumes \"\\<forall>x \\<in> S. (finite (cl_ecl x))\"\n  shows \"clause_saturated S\"", "lemma int_clset_is_a_model:\n  assumes \"ground_inference_saturated S\"\n  assumes all_finite: \"\\<forall>x \\<in> S. (finite (cl_ecl x))\"\n  assumes \"Ball S well_constrained\"\n  assumes all_non_empty: \"\\<forall>x \\<in> S. (cl_ecl x) \\<noteq> {}\"\n  assumes \"closed_under_renaming S\"\n  shows \"\\<forall> C \\<sigma>. (fst pair = C) \\<longrightarrow> \\<sigma> = (snd pair) \\<longrightarrow> C \\<in> S \\<longrightarrow> \n    ground_clause (subst_cl (cl_ecl C) \\<sigma>) \n    \\<longrightarrow> (all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>) (\\<lambda>t. (trm_rep t S))) \n          \\<longrightarrow> validate_ground_clause (same_values (\\<lambda>t. (trm_rep t S))) (subst_cl (cl_ecl C) \\<sigma>)\" \n          (is \"?P pair\")", "lemma COMPLETENESS:\n  assumes \"\\<forall>x. (x \\<in> S \\<longrightarrow> (trms_ecl x = {}))\"\n  assumes \"(\\<forall>x\\<in>S. finite (cl_ecl x))\"\n  assumes \"\\<not> (satisfiable_clause_set (cl_ecl ` S))\"\n  shows \"\\<exists>x. (derivable_ecl x S) \\<and> cl_ecl x = {}\""], "translations": [["", "lemma lift_orient_lit: \n  assumes \"orient_lit_inst L t s p \\<sigma>\"\n  shows \"orient_lit (subst_lit L \\<sigma>) (subst t \\<sigma>)  (subst s \\<sigma>) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>)\n     (s \\<lhd> \\<sigma>) p", "unfolding orient_lit_inst_def orient_lit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma> =\n     Pos (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)) \\<or>\n     subst_lit L \\<sigma> =\n     Pos (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))) \\<and>\n    (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n    p = pos \\<or>\n    (subst_lit L \\<sigma> =\n     Neg (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)) \\<or>\n     subst_lit L \\<sigma> =\n     Neg (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))) \\<and>\n    (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and> p = neg", "using assms orient_lit_inst_def"], ["proof (prove)\nusing this:\n  orient_lit_inst L t s p \\<sigma>\n  orient_lit_inst ?L ?u ?v ?s ?\\<sigma> =\n  ((?L = Pos (Eq ?u ?v) \\<or> ?L = Pos (Eq ?v ?u)) \\<and>\n   (?u \\<lhd> ?\\<sigma>, ?v \\<lhd> ?\\<sigma>) \\<notin> trm_ord \\<and>\n   ?s = pos \\<or>\n   (?L = Neg (Eq ?u ?v) \\<or> ?L = Neg (Eq ?v ?u)) \\<and>\n   (?u \\<lhd> ?\\<sigma>, ?v \\<lhd> ?\\<sigma>) \\<notin> trm_ord \\<and>\n   ?s = neg)\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma> =\n     Pos (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)) \\<or>\n     subst_lit L \\<sigma> =\n     Pos (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))) \\<and>\n    (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n    p = pos \\<or>\n    (subst_lit L \\<sigma> =\n     Neg (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)) \\<or>\n     subst_lit L \\<sigma> =\n     Neg (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))) \\<and>\n    (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and> p = neg", "by auto"], ["", "lemma orient_lit_vars:\n  assumes \"orient_lit L t s p\"\n  shows \"vars_of t \\<subseteq> vars_of_lit L \\<and> vars_of s \\<subseteq> vars_of_lit L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "have \"p = neg \\<or> p = pos\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = neg \\<or> p = pos", "using sign.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = pos \\<Longrightarrow> ?P;\n   ?y = neg \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. p = neg \\<or> p = pos", "by auto"], ["proof (state)\nthis:\n  p = neg \\<or> p = pos\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "then"], ["proof (chain)\npicking this:\n  p = neg \\<or> p = pos", "show ?thesis"], ["proof (prove)\nusing this:\n  p = neg \\<or> p = pos\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p = neg \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L\n 2. p = pos \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "assume \"p = neg\""], ["proof (state)\nthis:\n  p = neg\n\ngoal (2 subgoals):\n 1. p = neg \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L\n 2. p = pos \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "from this and assms(1)"], ["proof (chain)\npicking this:\n  p = neg\n  orient_lit L t s p", "have \"(L = Neg (Eq t s)) \\<or> (L = (Neg (Eq s t)))\""], ["proof (prove)\nusing this:\n  p = neg\n  orient_lit L t s p\n\ngoal (1 subgoal):\n 1. L = Neg (Eq t s) \\<or> L = Neg (Eq s t)", "unfolding orient_lit_def"], ["proof (prove)\nusing this:\n  p = neg\n  (L = Pos (Eq t s) \\<or> L = Pos (Eq s t)) \\<and>\n  (t, s) \\<notin> trm_ord \\<and> p = pos \\<or>\n  (L = Neg (Eq t s) \\<or> L = Neg (Eq s t)) \\<and>\n  (t, s) \\<notin> trm_ord \\<and> p = neg\n\ngoal (1 subgoal):\n 1. L = Neg (Eq t s) \\<or> L = Neg (Eq s t)", "by auto"], ["proof (state)\nthis:\n  L = Neg (Eq t s) \\<or> L = Neg (Eq s t)\n\ngoal (2 subgoals):\n 1. p = neg \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L\n 2. p = pos \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "then"], ["proof (chain)\npicking this:\n  L = Neg (Eq t s) \\<or> L = Neg (Eq s t)", "show ?thesis"], ["proof (prove)\nusing this:\n  L = Neg (Eq t s) \\<or> L = Neg (Eq s t)\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. L = Neg (Eq t s) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L\n 2. L = Neg (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "assume \"L = Neg (Eq t s)\""], ["proof (state)\nthis:\n  L = Neg (Eq t s)\n\ngoal (2 subgoals):\n 1. L = Neg (Eq t s) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L\n 2. L = Neg (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "then"], ["proof (chain)\npicking this:\n  L = Neg (Eq t s)", "have \"vars_of_lit L = vars_of t \\<union> vars_of s\""], ["proof (prove)\nusing this:\n  L = Neg (Eq t s)\n\ngoal (1 subgoal):\n 1. vars_of_lit L = vars_of t \\<union> vars_of s", "by simp"], ["proof (state)\nthis:\n  vars_of_lit L = vars_of t \\<union> vars_of s\n\ngoal (2 subgoals):\n 1. L = Neg (Eq t s) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L\n 2. L = Neg (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "from this"], ["proof (chain)\npicking this:\n  vars_of_lit L = vars_of t \\<union> vars_of s", "show ?thesis"], ["proof (prove)\nusing this:\n  vars_of_lit L = vars_of t \\<union> vars_of s\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "by simp"], ["proof (state)\nthis:\n  vars_of t \\<subseteq> vars_of_lit L \\<and>\n  vars_of s \\<subseteq> vars_of_lit L\n\ngoal (1 subgoal):\n 1. L = Neg (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. L = Neg (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "assume \"L = Neg (Eq s t)\""], ["proof (state)\nthis:\n  L = Neg (Eq s t)\n\ngoal (1 subgoal):\n 1. L = Neg (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "then"], ["proof (chain)\npicking this:\n  L = Neg (Eq s t)", "have \"vars_of_lit L = vars_of s \\<union> vars_of t\""], ["proof (prove)\nusing this:\n  L = Neg (Eq s t)\n\ngoal (1 subgoal):\n 1. vars_of_lit L = vars_of s \\<union> vars_of t", "by simp"], ["proof (state)\nthis:\n  vars_of_lit L = vars_of s \\<union> vars_of t\n\ngoal (1 subgoal):\n 1. L = Neg (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "from this"], ["proof (chain)\npicking this:\n  vars_of_lit L = vars_of s \\<union> vars_of t", "show ?thesis"], ["proof (prove)\nusing this:\n  vars_of_lit L = vars_of s \\<union> vars_of t\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "by simp"], ["proof (state)\nthis:\n  vars_of t \\<subseteq> vars_of_lit L \\<and>\n  vars_of s \\<subseteq> vars_of_lit L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vars_of t \\<subseteq> vars_of_lit L \\<and>\n  vars_of s \\<subseteq> vars_of_lit L\n\ngoal (1 subgoal):\n 1. p = pos \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p = pos \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "assume \"p = pos\""], ["proof (state)\nthis:\n  p = pos\n\ngoal (1 subgoal):\n 1. p = pos \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "from this and assms(1)"], ["proof (chain)\npicking this:\n  p = pos\n  orient_lit L t s p", "have \"(L = Pos (Eq t s)) \\<or> (L = (Pos (Eq s t)))\""], ["proof (prove)\nusing this:\n  p = pos\n  orient_lit L t s p\n\ngoal (1 subgoal):\n 1. L = Pos (Eq t s) \\<or> L = Pos (Eq s t)", "unfolding orient_lit_def"], ["proof (prove)\nusing this:\n  p = pos\n  (L = Pos (Eq t s) \\<or> L = Pos (Eq s t)) \\<and>\n  (t, s) \\<notin> trm_ord \\<and> p = pos \\<or>\n  (L = Neg (Eq t s) \\<or> L = Neg (Eq s t)) \\<and>\n  (t, s) \\<notin> trm_ord \\<and> p = neg\n\ngoal (1 subgoal):\n 1. L = Pos (Eq t s) \\<or> L = Pos (Eq s t)", "by auto"], ["proof (state)\nthis:\n  L = Pos (Eq t s) \\<or> L = Pos (Eq s t)\n\ngoal (1 subgoal):\n 1. p = pos \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "then"], ["proof (chain)\npicking this:\n  L = Pos (Eq t s) \\<or> L = Pos (Eq s t)", "show ?thesis"], ["proof (prove)\nusing this:\n  L = Pos (Eq t s) \\<or> L = Pos (Eq s t)\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. L = Pos (Eq t s) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L\n 2. L = Pos (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "assume \"L = Pos (Eq t s)\""], ["proof (state)\nthis:\n  L = Pos (Eq t s)\n\ngoal (2 subgoals):\n 1. L = Pos (Eq t s) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L\n 2. L = Pos (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "then"], ["proof (chain)\npicking this:\n  L = Pos (Eq t s)", "have \"vars_of_lit L = vars_of t \\<union> vars_of s\""], ["proof (prove)\nusing this:\n  L = Pos (Eq t s)\n\ngoal (1 subgoal):\n 1. vars_of_lit L = vars_of t \\<union> vars_of s", "by simp"], ["proof (state)\nthis:\n  vars_of_lit L = vars_of t \\<union> vars_of s\n\ngoal (2 subgoals):\n 1. L = Pos (Eq t s) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L\n 2. L = Pos (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "from this"], ["proof (chain)\npicking this:\n  vars_of_lit L = vars_of t \\<union> vars_of s", "show ?thesis"], ["proof (prove)\nusing this:\n  vars_of_lit L = vars_of t \\<union> vars_of s\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "by simp"], ["proof (state)\nthis:\n  vars_of t \\<subseteq> vars_of_lit L \\<and>\n  vars_of s \\<subseteq> vars_of_lit L\n\ngoal (1 subgoal):\n 1. L = Pos (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. L = Pos (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "assume \"L = Pos (Eq s t)\""], ["proof (state)\nthis:\n  L = Pos (Eq s t)\n\ngoal (1 subgoal):\n 1. L = Pos (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "then"], ["proof (chain)\npicking this:\n  L = Pos (Eq s t)", "have \"vars_of_lit L = vars_of s \\<union> vars_of t\""], ["proof (prove)\nusing this:\n  L = Pos (Eq s t)\n\ngoal (1 subgoal):\n 1. vars_of_lit L = vars_of s \\<union> vars_of t", "by simp"], ["proof (state)\nthis:\n  vars_of_lit L = vars_of s \\<union> vars_of t\n\ngoal (1 subgoal):\n 1. L = Pos (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "from this"], ["proof (chain)\npicking this:\n  vars_of_lit L = vars_of s \\<union> vars_of t", "show ?thesis"], ["proof (prove)\nusing this:\n  vars_of_lit L = vars_of s \\<union> vars_of t\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "by simp"], ["proof (state)\nthis:\n  vars_of t \\<subseteq> vars_of_lit L \\<and>\n  vars_of s \\<subseteq> vars_of_lit L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vars_of t \\<subseteq> vars_of_lit L \\<and>\n  vars_of s \\<subseteq> vars_of_lit L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vars_of t \\<subseteq> vars_of_lit L \\<and>\n  vars_of s \\<subseteq> vars_of_lit L\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orient_lit_inst_vars:\n  assumes \"orient_lit_inst L t s p \\<sigma>\"\n  shows \"vars_of t \\<subseteq> vars_of_lit L \\<and> vars_of s \\<subseteq> vars_of_lit L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "have \"p = neg \\<or> p = pos\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = neg \\<or> p = pos", "using sign.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = pos \\<Longrightarrow> ?P;\n   ?y = neg \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. p = neg \\<or> p = pos", "by auto"], ["proof (state)\nthis:\n  p = neg \\<or> p = pos\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "then"], ["proof (chain)\npicking this:\n  p = neg \\<or> p = pos", "show ?thesis"], ["proof (prove)\nusing this:\n  p = neg \\<or> p = pos\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p = neg \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L\n 2. p = pos \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "assume \"p = neg\""], ["proof (state)\nthis:\n  p = neg\n\ngoal (2 subgoals):\n 1. p = neg \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L\n 2. p = pos \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "from this and assms(1)"], ["proof (chain)\npicking this:\n  p = neg\n  orient_lit_inst L t s p \\<sigma>", "have \"(L = Neg (Eq t s)) \\<or> (L = (Neg (Eq s t)))\""], ["proof (prove)\nusing this:\n  p = neg\n  orient_lit_inst L t s p \\<sigma>\n\ngoal (1 subgoal):\n 1. L = Neg (Eq t s) \\<or> L = Neg (Eq s t)", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  p = neg\n  (L = Pos (Eq t s) \\<or> L = Pos (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  p = pos \\<or>\n  (L = Neg (Eq t s) \\<or> L = Neg (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and> p = neg\n\ngoal (1 subgoal):\n 1. L = Neg (Eq t s) \\<or> L = Neg (Eq s t)", "by auto"], ["proof (state)\nthis:\n  L = Neg (Eq t s) \\<or> L = Neg (Eq s t)\n\ngoal (2 subgoals):\n 1. p = neg \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L\n 2. p = pos \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "then"], ["proof (chain)\npicking this:\n  L = Neg (Eq t s) \\<or> L = Neg (Eq s t)", "show ?thesis"], ["proof (prove)\nusing this:\n  L = Neg (Eq t s) \\<or> L = Neg (Eq s t)\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. L = Neg (Eq t s) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L\n 2. L = Neg (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "assume \"L = Neg (Eq t s)\""], ["proof (state)\nthis:\n  L = Neg (Eq t s)\n\ngoal (2 subgoals):\n 1. L = Neg (Eq t s) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L\n 2. L = Neg (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "then"], ["proof (chain)\npicking this:\n  L = Neg (Eq t s)", "have \"vars_of_lit L = vars_of t \\<union> vars_of s\""], ["proof (prove)\nusing this:\n  L = Neg (Eq t s)\n\ngoal (1 subgoal):\n 1. vars_of_lit L = vars_of t \\<union> vars_of s", "by simp"], ["proof (state)\nthis:\n  vars_of_lit L = vars_of t \\<union> vars_of s\n\ngoal (2 subgoals):\n 1. L = Neg (Eq t s) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L\n 2. L = Neg (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "from this"], ["proof (chain)\npicking this:\n  vars_of_lit L = vars_of t \\<union> vars_of s", "show ?thesis"], ["proof (prove)\nusing this:\n  vars_of_lit L = vars_of t \\<union> vars_of s\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "by simp"], ["proof (state)\nthis:\n  vars_of t \\<subseteq> vars_of_lit L \\<and>\n  vars_of s \\<subseteq> vars_of_lit L\n\ngoal (1 subgoal):\n 1. L = Neg (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. L = Neg (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "assume \"L = Neg (Eq s t)\""], ["proof (state)\nthis:\n  L = Neg (Eq s t)\n\ngoal (1 subgoal):\n 1. L = Neg (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "then"], ["proof (chain)\npicking this:\n  L = Neg (Eq s t)", "have \"vars_of_lit L = vars_of s \\<union> vars_of t\""], ["proof (prove)\nusing this:\n  L = Neg (Eq s t)\n\ngoal (1 subgoal):\n 1. vars_of_lit L = vars_of s \\<union> vars_of t", "by simp"], ["proof (state)\nthis:\n  vars_of_lit L = vars_of s \\<union> vars_of t\n\ngoal (1 subgoal):\n 1. L = Neg (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "from this"], ["proof (chain)\npicking this:\n  vars_of_lit L = vars_of s \\<union> vars_of t", "show ?thesis"], ["proof (prove)\nusing this:\n  vars_of_lit L = vars_of s \\<union> vars_of t\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "by simp"], ["proof (state)\nthis:\n  vars_of t \\<subseteq> vars_of_lit L \\<and>\n  vars_of s \\<subseteq> vars_of_lit L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vars_of t \\<subseteq> vars_of_lit L \\<and>\n  vars_of s \\<subseteq> vars_of_lit L\n\ngoal (1 subgoal):\n 1. p = pos \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p = pos \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "assume \"p = pos\""], ["proof (state)\nthis:\n  p = pos\n\ngoal (1 subgoal):\n 1. p = pos \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "from this and assms(1)"], ["proof (chain)\npicking this:\n  p = pos\n  orient_lit_inst L t s p \\<sigma>", "have \"(L = Pos (Eq t s)) \\<or> (L = (Pos (Eq s t)))\""], ["proof (prove)\nusing this:\n  p = pos\n  orient_lit_inst L t s p \\<sigma>\n\ngoal (1 subgoal):\n 1. L = Pos (Eq t s) \\<or> L = Pos (Eq s t)", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  p = pos\n  (L = Pos (Eq t s) \\<or> L = Pos (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  p = pos \\<or>\n  (L = Neg (Eq t s) \\<or> L = Neg (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and> p = neg\n\ngoal (1 subgoal):\n 1. L = Pos (Eq t s) \\<or> L = Pos (Eq s t)", "by auto"], ["proof (state)\nthis:\n  L = Pos (Eq t s) \\<or> L = Pos (Eq s t)\n\ngoal (1 subgoal):\n 1. p = pos \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "then"], ["proof (chain)\npicking this:\n  L = Pos (Eq t s) \\<or> L = Pos (Eq s t)", "show ?thesis"], ["proof (prove)\nusing this:\n  L = Pos (Eq t s) \\<or> L = Pos (Eq s t)\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. L = Pos (Eq t s) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L\n 2. L = Pos (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "assume \"L = Pos (Eq t s)\""], ["proof (state)\nthis:\n  L = Pos (Eq t s)\n\ngoal (2 subgoals):\n 1. L = Pos (Eq t s) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L\n 2. L = Pos (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "then"], ["proof (chain)\npicking this:\n  L = Pos (Eq t s)", "have \"vars_of_lit L = vars_of t \\<union> vars_of s\""], ["proof (prove)\nusing this:\n  L = Pos (Eq t s)\n\ngoal (1 subgoal):\n 1. vars_of_lit L = vars_of t \\<union> vars_of s", "by simp"], ["proof (state)\nthis:\n  vars_of_lit L = vars_of t \\<union> vars_of s\n\ngoal (2 subgoals):\n 1. L = Pos (Eq t s) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L\n 2. L = Pos (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "from this"], ["proof (chain)\npicking this:\n  vars_of_lit L = vars_of t \\<union> vars_of s", "show ?thesis"], ["proof (prove)\nusing this:\n  vars_of_lit L = vars_of t \\<union> vars_of s\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "by simp"], ["proof (state)\nthis:\n  vars_of t \\<subseteq> vars_of_lit L \\<and>\n  vars_of s \\<subseteq> vars_of_lit L\n\ngoal (1 subgoal):\n 1. L = Pos (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. L = Pos (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "assume \"L = Pos (Eq s t)\""], ["proof (state)\nthis:\n  L = Pos (Eq s t)\n\ngoal (1 subgoal):\n 1. L = Pos (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "then"], ["proof (chain)\npicking this:\n  L = Pos (Eq s t)", "have \"vars_of_lit L = vars_of s \\<union> vars_of t\""], ["proof (prove)\nusing this:\n  L = Pos (Eq s t)\n\ngoal (1 subgoal):\n 1. vars_of_lit L = vars_of s \\<union> vars_of t", "by simp"], ["proof (state)\nthis:\n  vars_of_lit L = vars_of s \\<union> vars_of t\n\ngoal (1 subgoal):\n 1. L = Pos (Eq s t) \\<Longrightarrow>\n    vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "from this"], ["proof (chain)\npicking this:\n  vars_of_lit L = vars_of s \\<union> vars_of t", "show ?thesis"], ["proof (prove)\nusing this:\n  vars_of_lit L = vars_of s \\<union> vars_of t\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L \\<and>\n    vars_of s \\<subseteq> vars_of_lit L", "by simp"], ["proof (state)\nthis:\n  vars_of t \\<subseteq> vars_of_lit L \\<and>\n  vars_of s \\<subseteq> vars_of_lit L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vars_of t \\<subseteq> vars_of_lit L \\<and>\n  vars_of s \\<subseteq> vars_of_lit L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vars_of t \\<subseteq> vars_of_lit L \\<and>\n  vars_of s \\<subseteq> vars_of_lit L\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orient_lit_inst_coincide:\n  assumes \"orient_lit_inst L1 t s polarity \\<sigma>\"\n  assumes \"coincide_on \\<sigma> \\<eta> (vars_of_lit L1)\"\n  shows \"orient_lit_inst L1 t s polarity \\<eta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orient_lit_inst L1 t s polarity \\<eta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. orient_lit_inst L1 t s polarity \\<eta>", "have \"polarity = pos \\<or> polarity = neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polarity = pos \\<or> polarity = neg", "using sign.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = pos \\<Longrightarrow> ?P;\n   ?y = neg \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. polarity = pos \\<or> polarity = neg", "by auto"], ["proof (state)\nthis:\n  polarity = pos \\<or> polarity = neg\n\ngoal (1 subgoal):\n 1. orient_lit_inst L1 t s polarity \\<eta>", "then"], ["proof (chain)\npicking this:\n  polarity = pos \\<or> polarity = neg", "show ?thesis"], ["proof (prove)\nusing this:\n  polarity = pos \\<or> polarity = neg\n\ngoal (1 subgoal):\n 1. orient_lit_inst L1 t s polarity \\<eta>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow> orient_lit_inst L1 t s polarity \\<eta>\n 2. polarity = neg \\<Longrightarrow> orient_lit_inst L1 t s polarity \\<eta>", "assume \"polarity = pos\""], ["proof (state)\nthis:\n  polarity = pos\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow> orient_lit_inst L1 t s polarity \\<eta>\n 2. polarity = neg \\<Longrightarrow> orient_lit_inst L1 t s polarity \\<eta>", "from this and assms(1)"], ["proof (chain)\npicking this:\n  polarity = pos\n  orient_lit_inst L1 t s polarity \\<sigma>", "have \"L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)\" \n      and \"( (subst t \\<sigma>),  (subst s \\<sigma>)) \\<notin> trm_ord\""], ["proof (prove)\nusing this:\n  polarity = pos\n  orient_lit_inst L1 t s polarity \\<sigma>\n\ngoal (1 subgoal):\n 1. L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t) &&&\n    (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  polarity = pos\n  (L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  polarity = pos \\<or>\n  (L1 = Neg (Eq t s) \\<or> L1 = Neg (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  polarity = neg\n\ngoal (1 subgoal):\n 1. L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t) &&&\n    (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow> orient_lit_inst L1 t s polarity \\<eta>\n 2. polarity = neg \\<Longrightarrow> orient_lit_inst L1 t s polarity \\<eta>", "from \\<open>L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)\\<close>"], ["proof (chain)\npicking this:\n  L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)", "have \"vars_of t \\<subseteq> vars_of_lit L1\" and \"vars_of s \\<subseteq> vars_of_lit L1\""], ["proof (prove)\nusing this:\n  L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L1 &&&\n    vars_of s \\<subseteq> vars_of_lit L1", "by auto"], ["proof (state)\nthis:\n  vars_of t \\<subseteq> vars_of_lit L1\n  vars_of s \\<subseteq> vars_of_lit L1\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow> orient_lit_inst L1 t s polarity \\<eta>\n 2. polarity = neg \\<Longrightarrow> orient_lit_inst L1 t s polarity \\<eta>", "from \\<open>vars_of t \\<subseteq> vars_of_lit L1\\<close> and assms(2)"], ["proof (chain)\npicking this:\n  vars_of t \\<subseteq> vars_of_lit L1\n  coincide_on \\<sigma> \\<eta> (vars_of_lit L1)", "have \"coincide_on \\<sigma> \\<eta> (vars_of t)\""], ["proof (prove)\nusing this:\n  vars_of t \\<subseteq> vars_of_lit L1\n  coincide_on \\<sigma> \\<eta> (vars_of_lit L1)\n\ngoal (1 subgoal):\n 1. coincide_on \\<sigma> \\<eta> (vars_of t)", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  vars_of t \\<subseteq> vars_of_lit L1\n  \\<forall>x\\<in>vars_of_lit L1. Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of t. Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  coincide_on \\<sigma> \\<eta> (vars_of t)\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow> orient_lit_inst L1 t s polarity \\<eta>\n 2. polarity = neg \\<Longrightarrow> orient_lit_inst L1 t s polarity \\<eta>", "from \\<open>vars_of s \\<subseteq> vars_of_lit L1\\<close> and assms(2)"], ["proof (chain)\npicking this:\n  vars_of s \\<subseteq> vars_of_lit L1\n  coincide_on \\<sigma> \\<eta> (vars_of_lit L1)", "have \"coincide_on \\<sigma> \\<eta> (vars_of s)\""], ["proof (prove)\nusing this:\n  vars_of s \\<subseteq> vars_of_lit L1\n  coincide_on \\<sigma> \\<eta> (vars_of_lit L1)\n\ngoal (1 subgoal):\n 1. coincide_on \\<sigma> \\<eta> (vars_of s)", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  vars_of s \\<subseteq> vars_of_lit L1\n  \\<forall>x\\<in>vars_of_lit L1. Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of s. Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  coincide_on \\<sigma> \\<eta> (vars_of s)\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow> orient_lit_inst L1 t s polarity \\<eta>\n 2. polarity = neg \\<Longrightarrow> orient_lit_inst L1 t s polarity \\<eta>", "from \\<open>( (subst t \\<sigma>),  (subst s \\<sigma>)) \\<notin> trm_ord\\<close>\n      and \\<open>coincide_on \\<sigma> \\<eta> (vars_of t)\\<close> and \\<open>coincide_on \\<sigma> \\<eta> (vars_of s)\\<close> assms(2)"], ["proof (chain)\npicking this:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  coincide_on \\<sigma> \\<eta> (vars_of t)\n  coincide_on \\<sigma> \\<eta> (vars_of s)\n  coincide_on \\<sigma> \\<eta> (vars_of_lit L1)", "have \"( (subst t \\<eta>),  (subst s \\<eta>)) \\<notin> trm_ord\""], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  coincide_on \\<sigma> \\<eta> (vars_of t)\n  coincide_on \\<sigma> \\<eta> (vars_of s)\n  coincide_on \\<sigma> \\<eta> (vars_of_lit L1)\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<eta>, s \\<lhd> \\<eta>) \\<notin> trm_ord", "using coincide_on_term"], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  coincide_on \\<sigma> \\<eta> (vars_of t)\n  coincide_on \\<sigma> \\<eta> (vars_of s)\n  coincide_on \\<sigma> \\<eta> (vars_of_lit L1)\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of ?t) \\<Longrightarrow>\n  ?t \\<lhd> ?\\<sigma> = ?t \\<lhd> ?\\<eta>\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<eta>, s \\<lhd> \\<eta>) \\<notin> trm_ord", "by metis"], ["proof (state)\nthis:\n  (t \\<lhd> \\<eta>, s \\<lhd> \\<eta>) \\<notin> trm_ord\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow> orient_lit_inst L1 t s polarity \\<eta>\n 2. polarity = neg \\<Longrightarrow> orient_lit_inst L1 t s polarity \\<eta>", "from this and \\<open>polarity = pos\\<close> and \\<open>L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)\\<close>"], ["proof (chain)\npicking this:\n  (t \\<lhd> \\<eta>, s \\<lhd> \\<eta>) \\<notin> trm_ord\n  polarity = pos\n  L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)", "show ?thesis"], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<eta>, s \\<lhd> \\<eta>) \\<notin> trm_ord\n  polarity = pos\n  L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)\n\ngoal (1 subgoal):\n 1. orient_lit_inst L1 t s polarity \\<eta>", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<eta>, s \\<lhd> \\<eta>) \\<notin> trm_ord\n  polarity = pos\n  L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)\n\ngoal (1 subgoal):\n 1. (L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)) \\<and>\n    (t \\<lhd> \\<eta>, s \\<lhd> \\<eta>) \\<notin> trm_ord \\<and>\n    polarity = pos \\<or>\n    (L1 = Neg (Eq t s) \\<or> L1 = Neg (Eq s t)) \\<and>\n    (t \\<lhd> \\<eta>, s \\<lhd> \\<eta>) \\<notin> trm_ord \\<and>\n    polarity = neg", "by auto"], ["proof (state)\nthis:\n  orient_lit_inst L1 t s polarity \\<eta>\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> orient_lit_inst L1 t s polarity \\<eta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> orient_lit_inst L1 t s polarity \\<eta>", "assume \"polarity = neg\""], ["proof (state)\nthis:\n  polarity = neg\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> orient_lit_inst L1 t s polarity \\<eta>", "from this and assms(1)"], ["proof (chain)\npicking this:\n  polarity = neg\n  orient_lit_inst L1 t s polarity \\<sigma>", "have \"L1 = Neg (Eq t s) \\<or> L1 = Neg (Eq s t)\" \n      and \"( (subst t \\<sigma>),  (subst s \\<sigma>)) \\<notin> trm_ord\""], ["proof (prove)\nusing this:\n  polarity = neg\n  orient_lit_inst L1 t s polarity \\<sigma>\n\ngoal (1 subgoal):\n 1. L1 = Neg (Eq t s) \\<or> L1 = Neg (Eq s t) &&&\n    (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  polarity = neg\n  (L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  polarity = pos \\<or>\n  (L1 = Neg (Eq t s) \\<or> L1 = Neg (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  polarity = neg\n\ngoal (1 subgoal):\n 1. L1 = Neg (Eq t s) \\<or> L1 = Neg (Eq s t) &&&\n    (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  L1 = Neg (Eq t s) \\<or> L1 = Neg (Eq s t)\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> orient_lit_inst L1 t s polarity \\<eta>", "from \\<open>L1 = Neg (Eq t s) \\<or> L1 = Neg (Eq s t)\\<close>"], ["proof (chain)\npicking this:\n  L1 = Neg (Eq t s) \\<or> L1 = Neg (Eq s t)", "have \"vars_of t \\<subseteq> vars_of_lit L1\" and \"vars_of s \\<subseteq> vars_of_lit L1\""], ["proof (prove)\nusing this:\n  L1 = Neg (Eq t s) \\<or> L1 = Neg (Eq s t)\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L1 &&&\n    vars_of s \\<subseteq> vars_of_lit L1", "by auto"], ["proof (state)\nthis:\n  vars_of t \\<subseteq> vars_of_lit L1\n  vars_of s \\<subseteq> vars_of_lit L1\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> orient_lit_inst L1 t s polarity \\<eta>", "from \\<open>vars_of t \\<subseteq> vars_of_lit L1\\<close> and assms(2)"], ["proof (chain)\npicking this:\n  vars_of t \\<subseteq> vars_of_lit L1\n  coincide_on \\<sigma> \\<eta> (vars_of_lit L1)", "have \"coincide_on \\<sigma> \\<eta> (vars_of t)\""], ["proof (prove)\nusing this:\n  vars_of t \\<subseteq> vars_of_lit L1\n  coincide_on \\<sigma> \\<eta> (vars_of_lit L1)\n\ngoal (1 subgoal):\n 1. coincide_on \\<sigma> \\<eta> (vars_of t)", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  vars_of t \\<subseteq> vars_of_lit L1\n  \\<forall>x\\<in>vars_of_lit L1. Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of t. Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  coincide_on \\<sigma> \\<eta> (vars_of t)\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> orient_lit_inst L1 t s polarity \\<eta>", "from \\<open>vars_of s \\<subseteq> vars_of_lit L1\\<close> and assms(2)"], ["proof (chain)\npicking this:\n  vars_of s \\<subseteq> vars_of_lit L1\n  coincide_on \\<sigma> \\<eta> (vars_of_lit L1)", "have \"coincide_on \\<sigma> \\<eta> (vars_of s)\""], ["proof (prove)\nusing this:\n  vars_of s \\<subseteq> vars_of_lit L1\n  coincide_on \\<sigma> \\<eta> (vars_of_lit L1)\n\ngoal (1 subgoal):\n 1. coincide_on \\<sigma> \\<eta> (vars_of s)", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  vars_of s \\<subseteq> vars_of_lit L1\n  \\<forall>x\\<in>vars_of_lit L1. Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of s. Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  coincide_on \\<sigma> \\<eta> (vars_of s)\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> orient_lit_inst L1 t s polarity \\<eta>", "from \\<open>( (subst t \\<sigma>),  (subst s \\<sigma>)) \\<notin> trm_ord\\<close>\n      and \\<open>coincide_on \\<sigma> \\<eta> (vars_of t)\\<close> and \\<open>coincide_on \\<sigma> \\<eta> (vars_of s)\\<close> assms(2)"], ["proof (chain)\npicking this:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  coincide_on \\<sigma> \\<eta> (vars_of t)\n  coincide_on \\<sigma> \\<eta> (vars_of s)\n  coincide_on \\<sigma> \\<eta> (vars_of_lit L1)", "have \"( (subst t \\<eta>),  (subst s \\<eta>)) \\<notin> trm_ord\""], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  coincide_on \\<sigma> \\<eta> (vars_of t)\n  coincide_on \\<sigma> \\<eta> (vars_of s)\n  coincide_on \\<sigma> \\<eta> (vars_of_lit L1)\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<eta>, s \\<lhd> \\<eta>) \\<notin> trm_ord", "using coincide_on_term"], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  coincide_on \\<sigma> \\<eta> (vars_of t)\n  coincide_on \\<sigma> \\<eta> (vars_of s)\n  coincide_on \\<sigma> \\<eta> (vars_of_lit L1)\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of ?t) \\<Longrightarrow>\n  ?t \\<lhd> ?\\<sigma> = ?t \\<lhd> ?\\<eta>\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<eta>, s \\<lhd> \\<eta>) \\<notin> trm_ord", "by metis"], ["proof (state)\nthis:\n  (t \\<lhd> \\<eta>, s \\<lhd> \\<eta>) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> orient_lit_inst L1 t s polarity \\<eta>", "from this and \\<open>polarity = neg\\<close> and \\<open>L1 = Neg (Eq t s) \\<or> L1 = Neg (Eq s t)\\<close>"], ["proof (chain)\npicking this:\n  (t \\<lhd> \\<eta>, s \\<lhd> \\<eta>) \\<notin> trm_ord\n  polarity = neg\n  L1 = Neg (Eq t s) \\<or> L1 = Neg (Eq s t)", "show ?thesis"], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<eta>, s \\<lhd> \\<eta>) \\<notin> trm_ord\n  polarity = neg\n  L1 = Neg (Eq t s) \\<or> L1 = Neg (Eq s t)\n\ngoal (1 subgoal):\n 1. orient_lit_inst L1 t s polarity \\<eta>", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<eta>, s \\<lhd> \\<eta>) \\<notin> trm_ord\n  polarity = neg\n  L1 = Neg (Eq t s) \\<or> L1 = Neg (Eq s t)\n\ngoal (1 subgoal):\n 1. (L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)) \\<and>\n    (t \\<lhd> \\<eta>, s \\<lhd> \\<eta>) \\<notin> trm_ord \\<and>\n    polarity = pos \\<or>\n    (L1 = Neg (Eq t s) \\<or> L1 = Neg (Eq s t)) \\<and>\n    (t \\<lhd> \\<eta>, s \\<lhd> \\<eta>) \\<notin> trm_ord \\<and>\n    polarity = neg", "by auto"], ["proof (state)\nthis:\n  orient_lit_inst L1 t s polarity \\<eta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  orient_lit_inst L1 t s polarity \\<eta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orient_lit_inst_subterms:\n  assumes \"orient_lit_inst L t s polarity \\<sigma>\"\n  assumes \"u \\<in> subterms_of t\"\n  shows \"u \\<in> subterms_of_lit L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> subterms_of_lit L", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<in> subterms_of_lit L", "have \"polarity = pos \\<or> polarity = neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polarity = pos \\<or> polarity = neg", "using sign.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = pos \\<Longrightarrow> ?P;\n   ?y = neg \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. polarity = pos \\<or> polarity = neg", "by auto"], ["proof (state)\nthis:\n  polarity = pos \\<or> polarity = neg\n\ngoal (1 subgoal):\n 1. u \\<in> subterms_of_lit L", "then"], ["proof (chain)\npicking this:\n  polarity = pos \\<or> polarity = neg", "show ?thesis"], ["proof (prove)\nusing this:\n  polarity = pos \\<or> polarity = neg\n\ngoal (1 subgoal):\n 1. u \\<in> subterms_of_lit L", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow> u \\<in> subterms_of_lit L\n 2. polarity = neg \\<Longrightarrow> u \\<in> subterms_of_lit L", "assume \"polarity = pos\""], ["proof (state)\nthis:\n  polarity = pos\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow> u \\<in> subterms_of_lit L\n 2. polarity = neg \\<Longrightarrow> u \\<in> subterms_of_lit L", "from this and assms(1)"], ["proof (chain)\npicking this:\n  polarity = pos\n  orient_lit_inst L t s polarity \\<sigma>", "have \"L = (Pos (Eq t s)) \\<or> L = (Pos (Eq s t))\""], ["proof (prove)\nusing this:\n  polarity = pos\n  orient_lit_inst L t s polarity \\<sigma>\n\ngoal (1 subgoal):\n 1. L = Pos (Eq t s) \\<or> L = Pos (Eq s t)", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  polarity = pos\n  (L = Pos (Eq t s) \\<or> L = Pos (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  polarity = pos \\<or>\n  (L = Neg (Eq t s) \\<or> L = Neg (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  polarity = neg\n\ngoal (1 subgoal):\n 1. L = Pos (Eq t s) \\<or> L = Pos (Eq s t)", "by auto"], ["proof (state)\nthis:\n  L = Pos (Eq t s) \\<or> L = Pos (Eq s t)\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow> u \\<in> subterms_of_lit L\n 2. polarity = neg \\<Longrightarrow> u \\<in> subterms_of_lit L", "then"], ["proof (chain)\npicking this:\n  L = Pos (Eq t s) \\<or> L = Pos (Eq s t)", "show ?thesis"], ["proof (prove)\nusing this:\n  L = Pos (Eq t s) \\<or> L = Pos (Eq s t)\n\ngoal (1 subgoal):\n 1. u \\<in> subterms_of_lit L", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. L = Pos (Eq t s) \\<Longrightarrow> u \\<in> subterms_of_lit L\n 2. L = Pos (Eq s t) \\<Longrightarrow> u \\<in> subterms_of_lit L", "assume \"L = (Pos (Eq t s))\""], ["proof (state)\nthis:\n  L = Pos (Eq t s)\n\ngoal (2 subgoals):\n 1. L = Pos (Eq t s) \\<Longrightarrow> u \\<in> subterms_of_lit L\n 2. L = Pos (Eq s t) \\<Longrightarrow> u \\<in> subterms_of_lit L", "from this and assms(2)"], ["proof (chain)\npicking this:\n  L = Pos (Eq t s)\n  u \\<in> subterms_of t", "show ?thesis"], ["proof (prove)\nusing this:\n  L = Pos (Eq t s)\n  u \\<in> subterms_of t\n\ngoal (1 subgoal):\n 1. u \\<in> subterms_of_lit L", "by simp"], ["proof (state)\nthis:\n  u \\<in> subterms_of_lit L\n\ngoal (1 subgoal):\n 1. L = Pos (Eq s t) \\<Longrightarrow> u \\<in> subterms_of_lit L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. L = Pos (Eq s t) \\<Longrightarrow> u \\<in> subterms_of_lit L", "assume \"L = (Pos (Eq s t))\""], ["proof (state)\nthis:\n  L = Pos (Eq s t)\n\ngoal (1 subgoal):\n 1. L = Pos (Eq s t) \\<Longrightarrow> u \\<in> subterms_of_lit L", "from this and assms(2)"], ["proof (chain)\npicking this:\n  L = Pos (Eq s t)\n  u \\<in> subterms_of t", "show ?thesis"], ["proof (prove)\nusing this:\n  L = Pos (Eq s t)\n  u \\<in> subterms_of t\n\ngoal (1 subgoal):\n 1. u \\<in> subterms_of_lit L", "by simp"], ["proof (state)\nthis:\n  u \\<in> subterms_of_lit L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u \\<in> subterms_of_lit L\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> u \\<in> subterms_of_lit L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> u \\<in> subterms_of_lit L", "assume \"polarity = neg\""], ["proof (state)\nthis:\n  polarity = neg\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> u \\<in> subterms_of_lit L", "from this and assms(1)"], ["proof (chain)\npicking this:\n  polarity = neg\n  orient_lit_inst L t s polarity \\<sigma>", "have \"L = (Neg (Eq t s)) \\<or> L = (Neg (Eq s t))\""], ["proof (prove)\nusing this:\n  polarity = neg\n  orient_lit_inst L t s polarity \\<sigma>\n\ngoal (1 subgoal):\n 1. L = Neg (Eq t s) \\<or> L = Neg (Eq s t)", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  polarity = neg\n  (L = Pos (Eq t s) \\<or> L = Pos (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  polarity = pos \\<or>\n  (L = Neg (Eq t s) \\<or> L = Neg (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  polarity = neg\n\ngoal (1 subgoal):\n 1. L = Neg (Eq t s) \\<or> L = Neg (Eq s t)", "by auto"], ["proof (state)\nthis:\n  L = Neg (Eq t s) \\<or> L = Neg (Eq s t)\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> u \\<in> subterms_of_lit L", "then"], ["proof (chain)\npicking this:\n  L = Neg (Eq t s) \\<or> L = Neg (Eq s t)", "show ?thesis"], ["proof (prove)\nusing this:\n  L = Neg (Eq t s) \\<or> L = Neg (Eq s t)\n\ngoal (1 subgoal):\n 1. u \\<in> subterms_of_lit L", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. L = Neg (Eq t s) \\<Longrightarrow> u \\<in> subterms_of_lit L\n 2. L = Neg (Eq s t) \\<Longrightarrow> u \\<in> subterms_of_lit L", "assume \"L = (Neg (Eq t s))\""], ["proof (state)\nthis:\n  L = Neg (Eq t s)\n\ngoal (2 subgoals):\n 1. L = Neg (Eq t s) \\<Longrightarrow> u \\<in> subterms_of_lit L\n 2. L = Neg (Eq s t) \\<Longrightarrow> u \\<in> subterms_of_lit L", "from this and assms(2)"], ["proof (chain)\npicking this:\n  L = Neg (Eq t s)\n  u \\<in> subterms_of t", "show ?thesis"], ["proof (prove)\nusing this:\n  L = Neg (Eq t s)\n  u \\<in> subterms_of t\n\ngoal (1 subgoal):\n 1. u \\<in> subterms_of_lit L", "by simp"], ["proof (state)\nthis:\n  u \\<in> subterms_of_lit L\n\ngoal (1 subgoal):\n 1. L = Neg (Eq s t) \\<Longrightarrow> u \\<in> subterms_of_lit L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. L = Neg (Eq s t) \\<Longrightarrow> u \\<in> subterms_of_lit L", "assume \"L = (Neg (Eq s t))\""], ["proof (state)\nthis:\n  L = Neg (Eq s t)\n\ngoal (1 subgoal):\n 1. L = Neg (Eq s t) \\<Longrightarrow> u \\<in> subterms_of_lit L", "from this and assms(2)"], ["proof (chain)\npicking this:\n  L = Neg (Eq s t)\n  u \\<in> subterms_of t", "show ?thesis"], ["proof (prove)\nusing this:\n  L = Neg (Eq s t)\n  u \\<in> subterms_of t\n\ngoal (1 subgoal):\n 1. u \\<in> subterms_of_lit L", "by simp"], ["proof (state)\nthis:\n  u \\<in> subterms_of_lit L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u \\<in> subterms_of_lit L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u \\<in> subterms_of_lit L\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Clause Ordering\\<close>"], ["", "text \\<open>Clauses and extended clauses are ordered by transforming them into multisets of multisets \nof terms. To avoid any problem with the merging of identical literals, the multiset is assigned \nto a pair clause-substitution rather than to an instantiated clause.\\<close>"], ["", "text \\<open>We first map every literal to a multiset of terms, using the usual conventions and then \ndefine the multisets associated with clauses and extended clauses.\\<close>"], ["", "fun mset_lit :: \"'a literal \\<Rightarrow> 'a trm multiset\"\n  where \"mset_lit (Pos (Eq t s)) = {# t,s #}\" |\n        \"mset_lit (Neg (Eq t s)) = {# t,t,s,s #}\""], ["", "fun mset_cl \n   where \"mset_cl (C,\\<sigma>) = {# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set C) #}\""], ["", "fun mset_ecl \n   where \"mset_ecl (C,\\<sigma>) = {# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set (cl_ecl C)) #}\""], ["", "lemma mset_ecl_and_mset_lit:\n  assumes \"L \\<in> (cl_ecl C)\"\n  assumes \"finite (cl_ecl C)\"\n  shows \"(mset_lit (subst_lit L \\<sigma>)) \\<in># (mset_ecl (C,\\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L \\<sigma>) \\<in># mset_ecl (C, \\<sigma>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L \\<sigma>) \\<in># mset_ecl (C, \\<sigma>)", "from assms(1) assms(2)"], ["proof (chain)\npicking this:\n  L \\<in> cl_ecl C\n  finite (cl_ecl C)", "have \"L \\<in># (mset_set (cl_ecl C))\""], ["proof (prove)\nusing this:\n  L \\<in> cl_ecl C\n  finite (cl_ecl C)\n\ngoal (1 subgoal):\n 1. L \\<in># mset_set (cl_ecl C)", "by (simp)"], ["proof (state)\nthis:\n  L \\<in># mset_set (cl_ecl C)\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L \\<sigma>) \\<in># mset_ecl (C, \\<sigma>)", "then"], ["proof (chain)\npicking this:\n  L \\<in># mset_set (cl_ecl C)", "show ?thesis"], ["proof (prove)\nusing this:\n  L \\<in># mset_set (cl_ecl C)\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L \\<sigma>) \\<in># mset_ecl (C, \\<sigma>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. L \\<in># mset_set (cl_ecl C) \\<Longrightarrow>\n    mset_lit (subst_lit L \\<sigma>) \\<in># mset_ecl (C, \\<sigma>)", "have f1: \"mset_set (cl_ecl C) - {#L#} + {#L#} = mset_set (cl_ecl C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_set (cl_ecl C) - {#L#} + {#L#} = mset_set (cl_ecl C)", "by (meson \\<open>L \\<in># mset_set (cl_ecl C)\\<close> insert_DiffM2)"], ["proof (state)\nthis:\n  mset_set (cl_ecl C) - {#L#} + {#L#} = mset_set (cl_ecl C)\n\ngoal (1 subgoal):\n 1. L \\<in># mset_set (cl_ecl C) \\<Longrightarrow>\n    mset_lit (subst_lit L \\<sigma>) \\<in># mset_ecl (C, \\<sigma>)", "have \"count {#mset_lit (subst_lit L \\<sigma>)#} (mset_lit (subst_lit L \\<sigma>)) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count {#mset_lit (subst_lit L \\<sigma>)#}\n     (mset_lit (subst_lit L \\<sigma>)) =\n    1", "by simp"], ["proof (state)\nthis:\n  count {#mset_lit (subst_lit L \\<sigma>)#}\n   (mset_lit (subst_lit L \\<sigma>)) =\n  1\n\ngoal (1 subgoal):\n 1. L \\<in># mset_set (cl_ecl C) \\<Longrightarrow>\n    mset_lit (subst_lit L \\<sigma>) \\<in># mset_ecl (C, \\<sigma>)", "then"], ["proof (chain)\npicking this:\n  count {#mset_lit (subst_lit L \\<sigma>)#}\n   (mset_lit (subst_lit L \\<sigma>)) =\n  1", "show ?thesis"], ["proof (prove)\nusing this:\n  count {#mset_lit (subst_lit L \\<sigma>)#}\n   (mset_lit (subst_lit L \\<sigma>)) =\n  1\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L \\<sigma>) \\<in># mset_ecl (C, \\<sigma>)", "by (metis (no_types, lifting) f1 image_mset_add_mset insert_iff mset_ecl.simps set_mset_add_mset_insert union_mset_add_mset_right)"], ["proof (state)\nthis:\n  mset_lit (subst_lit L \\<sigma>) \\<in># mset_ecl (C, \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mset_lit (subst_lit L \\<sigma>) \\<in># mset_ecl (C, \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ecl_ord_coincide:\n  assumes \"coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\"\n  shows \"mset_ecl (C,\\<sigma>) = mset_ecl (C,\\<sigma>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_ecl (C, \\<sigma>) = mset_ecl (C, \\<sigma>')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mset_ecl (C, \\<sigma>) = mset_ecl (C, \\<sigma>')", "have \"\\<forall>x. (x \\<in> (cl_ecl C) \\<longrightarrow> ((subst_lit x \\<sigma>) = (subst_lit x \\<sigma>')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<in> cl_ecl C \\<longrightarrow>\n       subst_lit x \\<sigma> = subst_lit x \\<sigma>'", "proof ((rule allI),(rule impI))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cl_ecl C \\<Longrightarrow>\n       subst_lit x \\<sigma> = subst_lit x \\<sigma>'", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cl_ecl C \\<Longrightarrow>\n       subst_lit x \\<sigma> = subst_lit x \\<sigma>'", "assume \"x \\<in> (cl_ecl C)\""], ["proof (state)\nthis:\n  x \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cl_ecl C \\<Longrightarrow>\n       subst_lit x \\<sigma> = subst_lit x \\<sigma>'", "from this"], ["proof (chain)\npicking this:\n  x \\<in> cl_ecl C", "have \"vars_of_lit x \\<subseteq> (vars_of_cl (cl_ecl C))\""], ["proof (prove)\nusing this:\n  x \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. vars_of_lit x \\<subseteq> vars_of_cl (cl_ecl C)", "by auto"], ["proof (state)\nthis:\n  vars_of_lit x \\<subseteq> vars_of_cl (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cl_ecl C \\<Longrightarrow>\n       subst_lit x \\<sigma> = subst_lit x \\<sigma>'", "from this and assms(1)"], ["proof (chain)\npicking this:\n  vars_of_lit x \\<subseteq> vars_of_cl (cl_ecl C)\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))", "have \"coincide_on \\<sigma> \\<sigma>' (vars_of_lit x)\""], ["proof (prove)\nusing this:\n  vars_of_lit x \\<subseteq> vars_of_cl (cl_ecl C)\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\n\ngoal (1 subgoal):\n 1. coincide_on \\<sigma> \\<sigma>' (vars_of_lit x)", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  vars_of_lit x \\<subseteq> vars_of_cl (cl_ecl C)\n  \\<forall>x\\<in>vars_of_cl (cl_ecl C).\n     Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of_lit x.\n       Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_lit x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cl_ecl C \\<Longrightarrow>\n       subst_lit x \\<sigma> = subst_lit x \\<sigma>'", "from this"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_lit x)", "show \"((subst_lit x \\<sigma>) = (subst_lit x \\<sigma>'))\""], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_lit x)\n\ngoal (1 subgoal):\n 1. subst_lit x \\<sigma> = subst_lit x \\<sigma>'", "by (simp add: coincide_on_lit)"], ["proof (state)\nthis:\n  subst_lit x \\<sigma> = subst_lit x \\<sigma>'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x.\n     x \\<in> cl_ecl C \\<longrightarrow>\n     subst_lit x \\<sigma> = subst_lit x \\<sigma>'\n\ngoal (1 subgoal):\n 1. mset_ecl (C, \\<sigma>) = mset_ecl (C, \\<sigma>')", "then"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     x \\<in> cl_ecl C \\<longrightarrow>\n     subst_lit x \\<sigma> = subst_lit x \\<sigma>'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in> cl_ecl C \\<longrightarrow>\n     subst_lit x \\<sigma> = subst_lit x \\<sigma>'\n\ngoal (1 subgoal):\n 1. mset_ecl (C, \\<sigma>) = mset_ecl (C, \\<sigma>')", "using equal_image_mset \n  [of  \"cl_ecl C\" \"\\<lambda>x. (mset_lit (subst_lit x \\<sigma>))\"  \"\\<lambda>x. (mset_lit (subst_lit x \\<sigma>'))\"]"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in> cl_ecl C \\<longrightarrow>\n     subst_lit x \\<sigma> = subst_lit x \\<sigma>'\n  \\<forall>x\\<in>cl_ecl C.\n     mset_lit (subst_lit x \\<sigma>) =\n     mset_lit (subst_lit x \\<sigma>') \\<Longrightarrow>\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl C)#} =\n  {#mset_lit (subst_lit x \\<sigma>'). x \\<in># mset_set (cl_ecl C)#}\n\ngoal (1 subgoal):\n 1. mset_ecl (C, \\<sigma>) = mset_ecl (C, \\<sigma>')", "by (metis  mset_ecl.simps)"], ["proof (state)\nthis:\n  mset_ecl (C, \\<sigma>) = mset_ecl (C, \\<sigma>')\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Literal and clause orderings are obtained as usual as the multiset extensions of the term \nordering.\\<close>"], ["", "definition lit_ord :: \"('a literal \\<times> 'a literal) set\"\n  where \n  \"lit_ord =  \n    { (x,y). (((mset_lit x),(mset_lit y)) \\<in> (mult trm_ord)) }\""], ["", "lemma mult_trm_ord_trans:\n  shows \"trans (mult trm_ord)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans (mult trm_ord)", "by (metis (no_types, lifting)  mult_def transI transitive_closure_trans(2))"], ["", "lemma lit_ord_trans:\n  shows \"trans  lit_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans lit_ord", "by (metis (no_types, lifting) basic_superposition.lit_ord_def basic_superposition_axioms \n    case_prodD case_prodI mem_Collect_eq mult_def transI transitive_closure_trans(2))"], ["", "lemma lit_ord_wf:\n  shows \"wf lit_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf lit_ord", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf lit_ord", "from trm_ord_wf"], ["proof (chain)\npicking this:\n  wf trm_ord", "have \"wf (mult trm_ord)\""], ["proof (prove)\nusing this:\n  wf trm_ord\n\ngoal (1 subgoal):\n 1. wf (mult trm_ord)", "using wf_mult"], ["proof (prove)\nusing this:\n  wf trm_ord\n  wf ?r \\<Longrightarrow> wf (mult ?r)\n\ngoal (1 subgoal):\n 1. wf (mult trm_ord)", "by auto"], ["proof (state)\nthis:\n  wf (mult trm_ord)\n\ngoal (1 subgoal):\n 1. wf lit_ord", "then"], ["proof (chain)\npicking this:\n  wf (mult trm_ord)", "show ?thesis"], ["proof (prove)\nusing this:\n  wf (mult trm_ord)\n\ngoal (1 subgoal):\n 1. wf lit_ord", "using lit_ord_def \n        and measure_wf [of \"(mult trm_ord)\" lit_ord mset_lit]"], ["proof (prove)\nusing this:\n  wf (mult trm_ord)\n  lit_ord = {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}\n  \\<lbrakk>wf (mult trm_ord);\n   lit_ord = {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}\\<rbrakk>\n  \\<Longrightarrow> wf lit_ord\n\ngoal (1 subgoal):\n 1. wf lit_ord", "by blast"], ["proof (state)\nthis:\n  wf lit_ord\n\ngoal:\nNo subgoals!", "qed"], ["", "definition ecl_ord :: \"(('a eclause \\<times> 'a subst) \\<times> ('a eclause \\<times> 'a subst)) set\"\n  where \n  \"ecl_ord =  \n    { (x,y). (((mset_ecl x),(mset_ecl y)) \\<in> (mult (mult trm_ord))) }\""], ["", "definition ecl_ord_eq :: \"(('a eclause \\<times> 'a subst) \\<times> ('a eclause \\<times> 'a subst)) set\"\n  where \n  \"ecl_ord_eq =  \n    ecl_ord \\<union> { (x,y). ((mset_ecl x) = (mset_ecl y)) }\""], ["", "definition cl_ord :: \"(('a clause \\<times> 'a subst) \\<times> ('a clause \\<times> 'a subst)) set\"\n  where \n  \"cl_ord =  \n    { (x,y). (((mset_cl x),(mset_cl  y)) \\<in> (mult (mult trm_ord))) }\""], ["", "definition cl_ord_eq :: \"(('a clause \\<times> 'a subst) \\<times> ('a clause \\<times> 'a subst)) set\"\n  where \n  \"cl_ord_eq =  cl_ord \\<union> \n    { (x,y). (mset_cl x) = (mset_cl  y) }\""], ["", "lemma mult_mult_trm_ord_trans:\n  shows \"trans (mult (mult trm_ord))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans (mult (mult trm_ord))", "by (metis (no_types, lifting)  mult_def transI transitive_closure_trans(2))"], ["", "lemma ecl_ord_trans:\n  shows \"trans  ecl_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans ecl_ord", "by (metis (no_types, lifting) basic_superposition.ecl_ord_def basic_superposition_axioms case_prodD \n    case_prodI mem_Collect_eq mult_def transI transitive_closure_trans(2))"], ["", "lemma cl_ord_trans:\n  shows \"trans cl_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans cl_ord", "by (metis (no_types, lifting) basic_superposition.cl_ord_def basic_superposition_axioms case_prodD \n    case_prodI mem_Collect_eq mult_def transI transitive_closure_trans(2))"], ["", "lemma cl_ord_eq_trans:\n  shows \"trans cl_ord_eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans cl_ord_eq", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. trans cl_ord_eq", "have \"\\<forall>r. trans r = (\\<forall>p pa pb. ((p::'a literal set \\<times> ('a \\<times> 'a trm) list, pa) \\<notin> r \\<or> (pa, pb) \\<notin> r) \n          \\<or> (p, pb) \\<in> r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r.\n       trans r =\n       (\\<forall>p pa pb.\n           ((p, pa) \\<notin> r \\<or> (pa, pb) \\<notin> r) \\<or>\n           (p, pb) \\<in> r)", "by (simp add: trans_def)"], ["proof (state)\nthis:\n  \\<forall>r.\n     trans r =\n     (\\<forall>p pa pb.\n         ((p, pa) \\<notin> r \\<or> (pa, pb) \\<notin> r) \\<or>\n         (p, pb) \\<in> r)\n\ngoal (1 subgoal):\n 1. trans cl_ord_eq", "then"], ["proof (chain)\npicking this:\n  \\<forall>r.\n     trans r =\n     (\\<forall>p pa pb.\n         ((p, pa) \\<notin> r \\<or> (pa, pb) \\<notin> r) \\<or>\n         (p, pb) \\<in> r)", "obtain pp :: \"(('a literal set \\<times> ('a \\<times> 'a trm) list) \\<times> 'a literal set \\<times> ('a \\<times> 'a trm) list) set \\<Rightarrow> 'a literal set \\<times> ('a \\<times> 'a trm) list\" and ppa :: \"(('a literal set \\<times> ('a \\<times> 'a trm) list) \\<times> 'a literal set \\<times> ('a \\<times> 'a trm) list) set \\<Rightarrow> 'a literal set \\<times> ('a \\<times> 'a trm) list\" and ppb :: \"(('a literal set \\<times> ('a \\<times> 'a trm) list) \\<times> 'a literal set \\<times> ('a \\<times> 'a trm) list) set \\<Rightarrow> 'a literal set \\<times> ('a \\<times> 'a trm) list\" where\n    f1: \"\\<forall>r. (\\<not> trans r \\<or> (\\<forall>p pa pb. (p, pa) \\<notin> r \\<or> (pa, pb) \\<notin> r \\<or> (p, pb) \\<in> r)) \\<and> (trans r \\<or> (pp r, ppa r) \\<in> r \\<and> (ppa r, ppb r) \\<in> r \\<and> (pp r, ppb r) \\<notin> r)\""], ["proof (prove)\nusing this:\n  \\<forall>r.\n     trans r =\n     (\\<forall>p pa pb.\n         ((p, pa) \\<notin> r \\<or> (pa, pb) \\<notin> r) \\<or>\n         (p, pb) \\<in> r)\n\ngoal (1 subgoal):\n 1. (\\<And>pp ppa ppb.\n        \\<forall>r.\n           (\\<not> trans r \\<or>\n            (\\<forall>p pa pb.\n                (p, pa) \\<notin> r \\<or>\n                (pa, pb) \\<notin> r \\<or> (p, pb) \\<in> r)) \\<and>\n           (trans r \\<or>\n            (pp r, ppa r) \\<in> r \\<and>\n            (ppa r, ppb r) \\<in> r \\<and>\n            (pp r, ppb r) \\<notin> r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types))"], ["proof (state)\nthis:\n  \\<forall>r.\n     (\\<not> trans r \\<or>\n      (\\<forall>p pa pb.\n          (p, pa) \\<notin> r \\<or>\n          (pa, pb) \\<notin> r \\<or> (p, pb) \\<in> r)) \\<and>\n     (trans r \\<or>\n      (pp r, ppa r) \\<in> r \\<and>\n      (ppa r, ppb r) \\<in> r \\<and> (pp r, ppb r) \\<notin> r)\n\ngoal (1 subgoal):\n 1. trans cl_ord_eq", "have f2: \"trans {(p, pa). (mset_cl p, mset_cl pa) \\<in> mult (mult trm_ord)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans {(p, pa). (mset_cl p, mset_cl pa) \\<in> mult (mult trm_ord)}", "using cl_ord_def cl_ord_trans"], ["proof (prove)\nusing this:\n  cl_ord = {(x, y). (mset_cl x, mset_cl y) \\<in> mult (mult trm_ord)}\n  trans cl_ord\n\ngoal (1 subgoal):\n 1. trans {(p, pa). (mset_cl p, mset_cl pa) \\<in> mult (mult trm_ord)}", "by presburger"], ["proof (state)\nthis:\n  trans {(p, pa). (mset_cl p, mset_cl pa) \\<in> mult (mult trm_ord)}\n\ngoal (1 subgoal):\n 1. trans cl_ord_eq", "{"], ["proof (state)\nthis:\n  trans {(p, pa). (mset_cl p, mset_cl pa) \\<in> mult (mult trm_ord)}\n\ngoal (1 subgoal):\n 1. trans cl_ord_eq", "assume \"\\<not> (case (ppa (cl_ord \\<union> {(p, pa). mset_cl p = mset_cl pa}), ppb (cl_ord \\<union> {(p, pa). mset_cl p = mset_cl pa})) of (p, pa) \\<Rightarrow> mset_cl p = mset_cl pa)\""], ["proof (state)\nthis:\n  \\<not> (case (ppa (cl_ord \\<union> {(p, pa). mset_cl p = mset_cl pa}),\n                ppb (cl_ord \\<union> {(p, pa). mset_cl p = mset_cl pa})) of\n          (p, pa) \\<Rightarrow> mset_cl p = mset_cl pa)\n\ngoal (1 subgoal):\n 1. trans cl_ord_eq", "{"], ["proof (state)\nthis:\n  \\<not> (case (ppa (cl_ord \\<union> {(p, pa). mset_cl p = mset_cl pa}),\n                ppb (cl_ord \\<union> {(p, pa). mset_cl p = mset_cl pa})) of\n          (p, pa) \\<Rightarrow> mset_cl p = mset_cl pa)\n\ngoal (1 subgoal):\n 1. trans cl_ord_eq", "assume \"(ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}), ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})) \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)}\""], ["proof (state)\nthis:\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)}\n\ngoal (1 subgoal):\n 1. trans cl_ord_eq", "moreover"], ["proof (state)\nthis:\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)}\n\ngoal (1 subgoal):\n 1. trans cl_ord_eq", "{"], ["proof (state)\nthis:\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)}\n\ngoal (1 subgoal):\n 1. trans cl_ord_eq", "assume \"(ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}), ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})) \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and> (mset_cl (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})), mset_cl (ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))) \\<notin> mult (mult trm_ord)\""], ["proof (state)\nthis:\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n  (mset_cl (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})),\n   mset_cl (ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})))\n  \\<notin> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. trans cl_ord_eq", "then"], ["proof (chain)\npicking this:\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n  (mset_cl (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})),\n   mset_cl (ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})))\n  \\<notin> mult (mult trm_ord)", "have \"(ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}), ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})) \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and> mset_cl (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})) \\<noteq> mset_cl (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\""], ["proof (prove)\nusing this:\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n  (mset_cl (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})),\n   mset_cl (ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})))\n  \\<notin> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n     ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n    \\<in> {(pa, p).\n           (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n    mset_cl\n     (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})) \\<noteq>\n    mset_cl (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))", "by force"], ["proof (state)\nthis:\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n  mset_cl (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})) \\<noteq>\n  mset_cl (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n\ngoal (1 subgoal):\n 1. trans cl_ord_eq", "then"], ["proof (chain)\npicking this:\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n  mset_cl (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})) \\<noteq>\n  mset_cl (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))", "have \"((pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}), ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})) \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<or> (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}), ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})) \\<in> {(pa, p). mset_cl pa = mset_cl p}) \\<or> (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}), ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})) \\<notin> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and> (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}), ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})) \\<notin> {(pa, p). mset_cl pa = mset_cl p}\""], ["proof (prove)\nusing this:\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n  mset_cl (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})) \\<noteq>\n  mset_cl (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n\ngoal (1 subgoal):\n 1. ((pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n      ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n     \\<in> {(pa, p).\n            (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<or>\n     (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n      ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n     \\<in> {(pa, p). mset_cl pa = mset_cl p}) \\<or>\n    (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n     ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n    \\<notin> {(pa, p).\n              (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n    (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n     ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n    \\<notin> {(pa, p). mset_cl pa = mset_cl p}", "using f2 f1"], ["proof (prove)\nusing this:\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n  mset_cl (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})) \\<noteq>\n  mset_cl (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  trans {(p, pa). (mset_cl p, mset_cl pa) \\<in> mult (mult trm_ord)}\n  \\<forall>r.\n     (\\<not> trans r \\<or>\n      (\\<forall>p pa pb.\n          (p, pa) \\<notin> r \\<or>\n          (pa, pb) \\<notin> r \\<or> (p, pb) \\<in> r)) \\<and>\n     (trans r \\<or>\n      (pp r, ppa r) \\<in> r \\<and>\n      (ppa r, ppb r) \\<in> r \\<and> (pp r, ppb r) \\<notin> r)\n\ngoal (1 subgoal):\n 1. ((pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n      ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n     \\<in> {(pa, p).\n            (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<or>\n     (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n      ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n     \\<in> {(pa, p). mset_cl pa = mset_cl p}) \\<or>\n    (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n     ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n    \\<notin> {(pa, p).\n              (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n    (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n     ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n    \\<notin> {(pa, p). mset_cl pa = mset_cl p}", "by blast"], ["proof (state)\nthis:\n  ((pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<or>\n   (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). mset_cl pa = mset_cl p}) \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p).\n            (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p). mset_cl pa = mset_cl p}\n\ngoal (1 subgoal):\n 1. trans cl_ord_eq", "}"], ["proof (state)\nthis:\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n  (mset_cl (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})),\n   mset_cl (ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})))\n  \\<notin> mult (mult trm_ord) \\<Longrightarrow>\n  ((pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<or>\n   (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). mset_cl pa = mset_cl p}) \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p).\n            (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p). mset_cl pa = mset_cl p}\n\ngoal (1 subgoal):\n 1. trans cl_ord_eq", "ultimately"], ["proof (chain)\npicking this:\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)}\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n  (mset_cl (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})),\n   mset_cl (ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})))\n  \\<notin> mult (mult trm_ord) \\<Longrightarrow>\n  ((pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<or>\n   (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). mset_cl pa = mset_cl p}) \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p).\n            (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p). mset_cl pa = mset_cl p}", "have \"(mset_cl (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})), mset_cl (ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))) \\<in> mult (mult trm_ord) \\<or> ((pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}), ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})) \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<or> (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}), ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})) \\<in> {(pa, p). mset_cl pa = mset_cl p}) \\<or> (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}), ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})) \\<notin> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and> (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}), ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})) \\<notin> {(pa, p). mset_cl pa = mset_cl p}\""], ["proof (prove)\nusing this:\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)}\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n  (mset_cl (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})),\n   mset_cl (ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})))\n  \\<notin> mult (mult trm_ord) \\<Longrightarrow>\n  ((pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<or>\n   (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). mset_cl pa = mset_cl p}) \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p).\n            (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p). mset_cl pa = mset_cl p}\n\ngoal (1 subgoal):\n 1. (mset_cl (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})),\n     mset_cl (ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})))\n    \\<in> mult (mult trm_ord) \\<or>\n    ((pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n      ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n     \\<in> {(pa, p).\n            (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<or>\n     (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n      ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n     \\<in> {(pa, p). mset_cl pa = mset_cl p}) \\<or>\n    (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n     ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n    \\<notin> {(pa, p).\n              (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n    (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n     ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n    \\<notin> {(pa, p). mset_cl pa = mset_cl p}", "by fastforce"], ["proof (state)\nthis:\n  (mset_cl (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})),\n   mset_cl (ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})))\n  \\<in> mult (mult trm_ord) \\<or>\n  ((pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<or>\n   (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). mset_cl pa = mset_cl p}) \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p).\n            (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p). mset_cl pa = mset_cl p}\n\ngoal (1 subgoal):\n 1. trans cl_ord_eq", "}"], ["proof (state)\nthis:\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> {(pa, p).\n         (mset_cl pa, mset_cl p)\n         \\<in> mult (mult trm_ord)} \\<Longrightarrow>\n  (mset_cl (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})),\n   mset_cl (ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})))\n  \\<in> mult (mult trm_ord) \\<or>\n  ((pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<or>\n   (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). mset_cl pa = mset_cl p}) \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p).\n            (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p). mset_cl pa = mset_cl p}\n\ngoal (1 subgoal):\n 1. trans cl_ord_eq", "then"], ["proof (chain)\npicking this:\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> {(pa, p).\n         (mset_cl pa, mset_cl p)\n         \\<in> mult (mult trm_ord)} \\<Longrightarrow>\n  (mset_cl (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})),\n   mset_cl (ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})))\n  \\<in> mult (mult trm_ord) \\<or>\n  ((pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<or>\n   (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). mset_cl pa = mset_cl p}) \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p).\n            (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p). mset_cl pa = mset_cl p}", "have \"(mset_cl (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})), mset_cl (ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))) \\<in> mult (mult trm_ord) \\<or> ((pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}), ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})) \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<or> (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}), ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})) \\<in> {(pa, p). mset_cl pa = mset_cl p}) \\<or> (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}), ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})) \\<notin> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and> (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}), ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})) \\<notin> {(pa, p). mset_cl pa = mset_cl p} \\<or> (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}), ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})) \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or> (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}), ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})) \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or> (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}), ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})) \\<in> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}\""], ["proof (prove)\nusing this:\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> {(pa, p).\n         (mset_cl pa, mset_cl p)\n         \\<in> mult (mult trm_ord)} \\<Longrightarrow>\n  (mset_cl (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})),\n   mset_cl (ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})))\n  \\<in> mult (mult trm_ord) \\<or>\n  ((pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<or>\n   (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). mset_cl pa = mset_cl p}) \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p).\n            (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p). mset_cl pa = mset_cl p}\n\ngoal (1 subgoal):\n 1. (mset_cl (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})),\n     mset_cl (ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})))\n    \\<in> mult (mult trm_ord) \\<or>\n    ((pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n      ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n     \\<in> {(pa, p).\n            (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<or>\n     (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n      ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n     \\<in> {(pa, p). mset_cl pa = mset_cl p}) \\<or>\n    (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n     ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n    \\<notin> {(pa, p).\n              (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n    (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n     ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n    \\<notin> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n    (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n     ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n    \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n    (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n     ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n    \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n    (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n     ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n    \\<in> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}", "using cl_ord_def"], ["proof (prove)\nusing this:\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> {(pa, p).\n         (mset_cl pa, mset_cl p)\n         \\<in> mult (mult trm_ord)} \\<Longrightarrow>\n  (mset_cl (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})),\n   mset_cl (ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})))\n  \\<in> mult (mult trm_ord) \\<or>\n  ((pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<or>\n   (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). mset_cl pa = mset_cl p}) \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p).\n            (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p). mset_cl pa = mset_cl p}\n  cl_ord = {(x, y). (mset_cl x, mset_cl y) \\<in> mult (mult trm_ord)}\n\ngoal (1 subgoal):\n 1. (mset_cl (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})),\n     mset_cl (ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})))\n    \\<in> mult (mult trm_ord) \\<or>\n    ((pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n      ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n     \\<in> {(pa, p).\n            (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<or>\n     (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n      ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n     \\<in> {(pa, p). mset_cl pa = mset_cl p}) \\<or>\n    (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n     ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n    \\<notin> {(pa, p).\n              (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n    (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n     ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n    \\<notin> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n    (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n     ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n    \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n    (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n     ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n    \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n    (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n     ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n    \\<in> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}", "by auto"], ["proof (state)\nthis:\n  (mset_cl (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})),\n   mset_cl (ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})))\n  \\<in> mult (mult trm_ord) \\<or>\n  ((pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<or>\n   (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). mset_cl pa = mset_cl p}) \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p).\n            (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}\n\ngoal (1 subgoal):\n 1. trans cl_ord_eq", "}"], ["proof (state)\nthis:\n  \\<not> (case (ppa (cl_ord \\<union> {(p, pa). mset_cl p = mset_cl pa}),\n                ppb (cl_ord \\<union> {(p, pa). mset_cl p = mset_cl pa})) of\n          (p, pa) \\<Rightarrow> mset_cl p = mset_cl pa) \\<Longrightarrow>\n  (mset_cl (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})),\n   mset_cl (ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})))\n  \\<in> mult (mult trm_ord) \\<or>\n  ((pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<or>\n   (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). mset_cl pa = mset_cl p}) \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p).\n            (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}\n\ngoal (1 subgoal):\n 1. trans cl_ord_eq", "then"], ["proof (chain)\npicking this:\n  \\<not> (case (ppa (cl_ord \\<union> {(p, pa). mset_cl p = mset_cl pa}),\n                ppb (cl_ord \\<union> {(p, pa). mset_cl p = mset_cl pa})) of\n          (p, pa) \\<Rightarrow> mset_cl p = mset_cl pa) \\<Longrightarrow>\n  (mset_cl (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})),\n   mset_cl (ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})))\n  \\<in> mult (mult trm_ord) \\<or>\n  ((pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<or>\n   (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). mset_cl pa = mset_cl p}) \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p).\n            (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}", "have \"(pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}), ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})) \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or> (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}), ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})) \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or> (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}), ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})) \\<in> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}\""], ["proof (prove)\nusing this:\n  \\<not> (case (ppa (cl_ord \\<union> {(p, pa). mset_cl p = mset_cl pa}),\n                ppb (cl_ord \\<union> {(p, pa). mset_cl p = mset_cl pa})) of\n          (p, pa) \\<Rightarrow> mset_cl p = mset_cl pa) \\<Longrightarrow>\n  (mset_cl (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})),\n   mset_cl (ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})))\n  \\<in> mult (mult trm_ord) \\<or>\n  ((pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<or>\n   (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). mset_cl pa = mset_cl p}) \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p).\n            (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}\n\ngoal (1 subgoal):\n 1. (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n     ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n    \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n    (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n     ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n    \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n    (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n     ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n    \\<in> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}", "using cl_ord_def"], ["proof (prove)\nusing this:\n  \\<not> (case (ppa (cl_ord \\<union> {(p, pa). mset_cl p = mset_cl pa}),\n                ppb (cl_ord \\<union> {(p, pa). mset_cl p = mset_cl pa})) of\n          (p, pa) \\<Rightarrow> mset_cl p = mset_cl pa) \\<Longrightarrow>\n  (mset_cl (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})),\n   mset_cl (ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})))\n  \\<in> mult (mult trm_ord) \\<or>\n  ((pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<or>\n   (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n    ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n   \\<in> {(pa, p). mset_cl pa = mset_cl p}) \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p).\n            (mset_cl pa, mset_cl p) \\<in> mult (mult trm_ord)} \\<and>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}\n  cl_ord = {(x, y). (mset_cl x, mset_cl y) \\<in> mult (mult trm_ord)}\n\ngoal (1 subgoal):\n 1. (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n     ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n    \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n    (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n     ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n    \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n    (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n     ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n    \\<in> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}", "by force"], ["proof (state)\nthis:\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}\n\ngoal (1 subgoal):\n 1. trans cl_ord_eq", "then"], ["proof (chain)\npicking this:\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}", "have \"trans (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})\""], ["proof (prove)\nusing this:\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}\n\ngoal (1 subgoal):\n 1. trans (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})", "using f1"], ["proof (prove)\nusing this:\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n  (ppa (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<notin> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p} \\<or>\n  (pp (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}),\n   ppb (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}))\n  \\<in> cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p}\n  \\<forall>r.\n     (\\<not> trans r \\<or>\n      (\\<forall>p pa pb.\n          (p, pa) \\<notin> r \\<or>\n          (pa, pb) \\<notin> r \\<or> (p, pb) \\<in> r)) \\<and>\n     (trans r \\<or>\n      (pp r, ppa r) \\<in> r \\<and>\n      (ppa r, ppb r) \\<in> r \\<and> (pp r, ppb r) \\<notin> r)\n\ngoal (1 subgoal):\n 1. trans (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})", "by meson"], ["proof (state)\nthis:\n  trans (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})\n\ngoal (1 subgoal):\n 1. trans cl_ord_eq", "from this"], ["proof (chain)\npicking this:\n  trans (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})", "show ?thesis"], ["proof (prove)\nusing this:\n  trans (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})\n\ngoal (1 subgoal):\n 1. trans cl_ord_eq", "unfolding cl_ord_eq_def"], ["proof (prove)\nusing this:\n  trans (cl_ord \\<union> {(pa, p). mset_cl pa = mset_cl p})\n\ngoal (1 subgoal):\n 1. trans (cl_ord \\<union> {(x, y). mset_cl x = mset_cl y})", "by auto"], ["proof (state)\nthis:\n  trans cl_ord_eq\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_ecl_ord:\n  shows \"wf ecl_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf ecl_ord", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf ecl_ord", "have \"wf (mult trm_ord)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (mult trm_ord)", "using trm_ord_wf and wf_mult"], ["proof (prove)\nusing this:\n  wf trm_ord\n  wf ?r \\<Longrightarrow> wf (mult ?r)\n\ngoal (1 subgoal):\n 1. wf (mult trm_ord)", "by auto"], ["proof (state)\nthis:\n  wf (mult trm_ord)\n\ngoal (1 subgoal):\n 1. wf ecl_ord", "then"], ["proof (chain)\npicking this:\n  wf (mult trm_ord)", "have \"wf (mult (mult trm_ord))\""], ["proof (prove)\nusing this:\n  wf (mult trm_ord)\n\ngoal (1 subgoal):\n 1. wf (mult (mult trm_ord))", "using wf_mult"], ["proof (prove)\nusing this:\n  wf (mult trm_ord)\n  wf ?r \\<Longrightarrow> wf (mult ?r)\n\ngoal (1 subgoal):\n 1. wf (mult (mult trm_ord))", "by auto"], ["proof (state)\nthis:\n  wf (mult (mult trm_ord))\n\ngoal (1 subgoal):\n 1. wf ecl_ord", "thus ?thesis"], ["proof (prove)\nusing this:\n  wf (mult (mult trm_ord))\n\ngoal (1 subgoal):\n 1. wf ecl_ord", "using ecl_ord_def \n        and measure_wf [of \"(mult (mult trm_ord))\" ecl_ord mset_ecl]"], ["proof (prove)\nusing this:\n  wf (mult (mult trm_ord))\n  ecl_ord = {(x, y). (mset_ecl x, mset_ecl y) \\<in> mult (mult trm_ord)}\n  \\<lbrakk>wf (mult (mult trm_ord));\n   ecl_ord =\n   {(x, y). (mset_ecl x, mset_ecl y) \\<in> mult (mult trm_ord)}\\<rbrakk>\n  \\<Longrightarrow> wf ecl_ord\n\ngoal (1 subgoal):\n 1. wf ecl_ord", "by blast"], ["proof (state)\nthis:\n  wf ecl_ord\n\ngoal:\nNo subgoals!", "qed"], ["", "definition maximal_literal :: \"'a literal \\<Rightarrow> 'a clause \\<Rightarrow> bool\"\n  where\n    \"(maximal_literal L C) = (\\<forall>x. (x \\<in> C \\<longrightarrow> (L,x) \\<notin> lit_ord))\""], ["", "definition eligible_literal \nwhere \n  \"(eligible_literal L C \\<sigma>) = (L \\<in> sel (cl_ecl C) \\<or> \n    (sel(cl_ecl C) = {} \n    \\<and> (maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>))))\""], ["", "definition strictly_maximal_literal\nwhere \"strictly_maximal_literal C L \\<sigma>  = \n  (\\<forall>x \\<in> (cl_ecl C) - { L }. ( (subst_lit x \\<sigma>),(subst_lit L \\<sigma>)) \n                                        \\<in> lit_ord)\""], ["", "definition lower_or_eq \n  where \"lower_or_eq t s = ((t = s) \\<or> ((t,s) \\<in> trm_ord))\""], ["", "lemma eligible_literal_coincide:\n  assumes \"coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\"\n  assumes \"eligible_literal L C \\<sigma>\"\n  assumes \"L \\<in> (cl_ecl C)\"\n  shows \"eligible_literal L C \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eligible_literal L C \\<sigma>'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eligible_literal L C \\<sigma>'", "from assms(2)"], ["proof (chain)\npicking this:\n  eligible_literal L C \\<sigma>", "have \n    \"L \\<in> sel (cl_ecl C) \\<or> (sel (cl_ecl C) = {} \\<and> maximal_literal (subst_lit L \\<sigma>) \n      (subst_cl (cl_ecl C) \\<sigma>))\""], ["proof (prove)\nusing this:\n  eligible_literal L C \\<sigma>\n\ngoal (1 subgoal):\n 1. L \\<in> sel (cl_ecl C) \\<or>\n    sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)", "unfolding eligible_literal_def"], ["proof (prove)\nusing this:\n  L \\<in> sel (cl_ecl C) \\<or>\n  sel (cl_ecl C) = {} \\<and>\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. L \\<in> sel (cl_ecl C) \\<or>\n    sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  L \\<in> sel (cl_ecl C) \\<or>\n  sel (cl_ecl C) = {} \\<and>\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. eligible_literal L C \\<sigma>'", "then"], ["proof (chain)\npicking this:\n  L \\<in> sel (cl_ecl C) \\<or>\n  sel (cl_ecl C) = {} \\<and>\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)", "show ?thesis"], ["proof (prove)\nusing this:\n  L \\<in> sel (cl_ecl C) \\<or>\n  sel (cl_ecl C) = {} \\<and>\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. eligible_literal L C \\<sigma>'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. L \\<in> sel (cl_ecl C) \\<Longrightarrow> eligible_literal L C \\<sigma>'\n 2. sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) \\<Longrightarrow>\n    eligible_literal L C \\<sigma>'", "assume \"L \\<in> sel (cl_ecl C)\""], ["proof (state)\nthis:\n  L \\<in> sel (cl_ecl C)\n\ngoal (2 subgoals):\n 1. L \\<in> sel (cl_ecl C) \\<Longrightarrow> eligible_literal L C \\<sigma>'\n 2. sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) \\<Longrightarrow>\n    eligible_literal L C \\<sigma>'", "then"], ["proof (chain)\npicking this:\n  L \\<in> sel (cl_ecl C)", "show ?thesis"], ["proof (prove)\nusing this:\n  L \\<in> sel (cl_ecl C)\n\ngoal (1 subgoal):\n 1. eligible_literal L C \\<sigma>'", "unfolding eligible_literal_def"], ["proof (prove)\nusing this:\n  L \\<in> sel (cl_ecl C)\n\ngoal (1 subgoal):\n 1. L \\<in> sel (cl_ecl C) \\<or>\n    sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>') (subst_cl (cl_ecl C) \\<sigma>')", "by auto"], ["proof (state)\nthis:\n  eligible_literal L C \\<sigma>'\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) \\<Longrightarrow>\n    eligible_literal L C \\<sigma>'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) \\<Longrightarrow>\n    eligible_literal L C \\<sigma>'", "assume \"sel (cl_ecl C) = {} \\<and> maximal_literal (subst_lit L \\<sigma>)  (subst_cl (cl_ecl C) \\<sigma>)\""], ["proof (state)\nthis:\n  sel (cl_ecl C) = {} \\<and>\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) \\<Longrightarrow>\n    eligible_literal L C \\<sigma>'", "then"], ["proof (chain)\npicking this:\n  sel (cl_ecl C) = {} \\<and>\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)", "have \"sel (cl_ecl C) = {}\" and \"maximal_literal (subst_lit L \\<sigma>)  (subst_cl (cl_ecl C) \\<sigma>)\""], ["proof (prove)\nusing this:\n  sel (cl_ecl C) = {} \\<and>\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C) = {} &&&\n    maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  sel (cl_ecl C) = {}\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) \\<Longrightarrow>\n    eligible_literal L C \\<sigma>'", "from assms(1)"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))", "have \"(subst_cl (cl_ecl C) \\<sigma>) = (subst_cl (cl_ecl C) \\<sigma>')\""], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl C) \\<sigma> = subst_cl (cl_ecl C) \\<sigma>'", "using coincide_on_cl"], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of_cl ?C) \\<Longrightarrow>\n  subst_cl ?C ?\\<sigma> = subst_cl ?C ?\\<eta>\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl C) \\<sigma> = subst_cl (cl_ecl C) \\<sigma>'", "by blast"], ["proof (state)\nthis:\n  subst_cl (cl_ecl C) \\<sigma> = subst_cl (cl_ecl C) \\<sigma>'\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) \\<Longrightarrow>\n    eligible_literal L C \\<sigma>'", "from assms(3) and assms(1)"], ["proof (chain)\npicking this:\n  L \\<in> cl_ecl C\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))", "have \"coincide_on \\<sigma> \\<sigma>' (vars_of_lit L)\""], ["proof (prove)\nusing this:\n  L \\<in> cl_ecl C\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\n\ngoal (1 subgoal):\n 1. coincide_on \\<sigma> \\<sigma>' (vars_of_lit L)", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  L \\<in> cl_ecl C\n  \\<forall>x\\<in>vars_of_cl (cl_ecl C).\n     Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of_lit L.\n       Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_lit L)\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) \\<Longrightarrow>\n    eligible_literal L C \\<sigma>'", "from this"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_lit L)", "have \"(subst_lit L \\<sigma>) = (subst_lit L \\<sigma>')\""], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_lit L)\n\ngoal (1 subgoal):\n 1. subst_lit L \\<sigma> = subst_lit L \\<sigma>'", "using coincide_on_lit"], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_lit L)\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of_lit ?l) \\<Longrightarrow>\n  subst_lit ?l ?\\<sigma> = subst_lit ?l ?\\<eta>\n\ngoal (1 subgoal):\n 1. subst_lit L \\<sigma> = subst_lit L \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  subst_lit L \\<sigma> = subst_lit L \\<sigma>'\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) \\<Longrightarrow>\n    eligible_literal L C \\<sigma>'", "from this and \\<open>(subst_cl (cl_ecl C) \\<sigma>) = (subst_cl (cl_ecl C) \\<sigma>')\\<close> \n      and \\<open>maximal_literal (subst_lit L \\<sigma>)  (subst_cl (cl_ecl C) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  subst_lit L \\<sigma> = subst_lit L \\<sigma>'\n  subst_cl (cl_ecl C) \\<sigma> = subst_cl (cl_ecl C) \\<sigma>'\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)", "have \"maximal_literal (subst_lit L \\<sigma>')  (subst_cl (cl_ecl C) \\<sigma>')\""], ["proof (prove)\nusing this:\n  subst_lit L \\<sigma> = subst_lit L \\<sigma>'\n  subst_cl (cl_ecl C) \\<sigma> = subst_cl (cl_ecl C) \\<sigma>'\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. maximal_literal (subst_lit L \\<sigma>') (subst_cl (cl_ecl C) \\<sigma>')", "by auto"], ["proof (state)\nthis:\n  maximal_literal (subst_lit L \\<sigma>') (subst_cl (cl_ecl C) \\<sigma>')\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) \\<Longrightarrow>\n    eligible_literal L C \\<sigma>'", "from this and \\<open>sel (cl_ecl C) = {}\\<close>"], ["proof (chain)\npicking this:\n  maximal_literal (subst_lit L \\<sigma>') (subst_cl (cl_ecl C) \\<sigma>')\n  sel (cl_ecl C) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  maximal_literal (subst_lit L \\<sigma>') (subst_cl (cl_ecl C) \\<sigma>')\n  sel (cl_ecl C) = {}\n\ngoal (1 subgoal):\n 1. eligible_literal L C \\<sigma>'", "unfolding eligible_literal_def"], ["proof (prove)\nusing this:\n  maximal_literal (subst_lit L \\<sigma>') (subst_cl (cl_ecl C) \\<sigma>')\n  sel (cl_ecl C) = {}\n\ngoal (1 subgoal):\n 1. L \\<in> sel (cl_ecl C) \\<or>\n    sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>') (subst_cl (cl_ecl C) \\<sigma>')", "by auto"], ["proof (state)\nthis:\n  eligible_literal L C \\<sigma>'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eligible_literal L C \\<sigma>'\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The next definition extends the ordering to substitutions.\\<close>"], ["", "definition lower_on \nwhere \"lower_on \\<sigma> \\<eta> V = (\\<forall>x \\<in> V. \n  (lower_or_eq (subst (Var x) \\<sigma>) ( (subst (Var x) \\<eta>))))\""], ["", "text \\<open>We now establish some properties of the ordering relations.\\<close>"], ["", "lemma lower_or_eq_monotonic:\n  assumes \"lower_or_eq t1 s1\"\n  assumes \"lower_or_eq t2 s2\"\n  shows \"lower_or_eq (Comb t1 t2) (Comb s1 s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lower_or_eq (t1 \\<cdot> t2) (s1 \\<cdot> s2)", "unfolding lower_or_eq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. t1 \\<cdot> t2 = s1 \\<cdot> s2 \\<or>\n    (t1 \\<cdot> t2, s1 \\<cdot> s2) \\<in> trm_ord", "using trm_ord_reduction_left trm_ord_reduction_right"], ["proof (prove)\nusing this:\n  \\<forall>x1 x2 y.\n     (x1, x2) \\<in> trm_ord \\<longrightarrow>\n     (x1 \\<cdot> y, x2 \\<cdot> y) \\<in> trm_ord\n  \\<forall>x1 x2 y.\n     (x1, x2) \\<in> trm_ord \\<longrightarrow>\n     (y \\<cdot> x1, y \\<cdot> x2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t1 \\<cdot> t2 = s1 \\<cdot> s2 \\<or>\n    (t1 \\<cdot> t2, s1 \\<cdot> s2) \\<in> trm_ord", "by (metis assms(1) assms(2) lower_or_eq_def trm_ord_trans transD)"], ["", "lemma lower_on_term:\n  shows \"\\<And> \\<sigma> \\<eta>. lower_on \\<sigma> \\<eta> (vars_of t) \\<Longrightarrow> \n    (lower_or_eq (subst t \\<sigma>) (subst t \\<eta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<eta>.\n       lower_on \\<sigma> \\<eta> (vars_of t) \\<Longrightarrow>\n       lower_or_eq (t \\<lhd> \\<sigma>) (t \\<lhd> \\<eta>)", "proof (induction t)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x \\<sigma> \\<eta>.\n       lower_on \\<sigma> \\<eta> (vars_of (Var x)) \\<Longrightarrow>\n       lower_or_eq (Var x \\<lhd> \\<sigma>) (Var x \\<lhd> \\<eta>)\n 2. \\<And>x \\<sigma> \\<eta>.\n       lower_on \\<sigma> \\<eta> (vars_of (Const x)) \\<Longrightarrow>\n       lower_or_eq (Const x \\<lhd> \\<sigma>) (Const x \\<lhd> \\<eta>)\n 3. \\<And>t1 t2 \\<sigma> \\<eta>.\n       \\<lbrakk>\\<And>\\<sigma> \\<eta>.\n                   lower_on \\<sigma> \\<eta> (vars_of t1) \\<Longrightarrow>\n                   lower_or_eq (t1 \\<lhd> \\<sigma>) (t1 \\<lhd> \\<eta>);\n        \\<And>\\<sigma> \\<eta>.\n           lower_on \\<sigma> \\<eta> (vars_of t2) \\<Longrightarrow>\n           lower_or_eq (t2 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<eta>);\n        lower_on \\<sigma> \\<eta> (vars_of (t1 \\<cdot> t2))\\<rbrakk>\n       \\<Longrightarrow> lower_or_eq (t1 \\<cdot> t2 \\<lhd> \\<sigma>)\n                          (t1 \\<cdot> t2 \\<lhd> \\<eta>)", "case (Var x)"], ["proof (state)\nthis:\n  lower_on \\<sigma> \\<eta> (vars_of (Var x))\n\ngoal (3 subgoals):\n 1. \\<And>x \\<sigma> \\<eta>.\n       lower_on \\<sigma> \\<eta> (vars_of (Var x)) \\<Longrightarrow>\n       lower_or_eq (Var x \\<lhd> \\<sigma>) (Var x \\<lhd> \\<eta>)\n 2. \\<And>x \\<sigma> \\<eta>.\n       lower_on \\<sigma> \\<eta> (vars_of (Const x)) \\<Longrightarrow>\n       lower_or_eq (Const x \\<lhd> \\<sigma>) (Const x \\<lhd> \\<eta>)\n 3. \\<And>t1 t2 \\<sigma> \\<eta>.\n       \\<lbrakk>\\<And>\\<sigma> \\<eta>.\n                   lower_on \\<sigma> \\<eta> (vars_of t1) \\<Longrightarrow>\n                   lower_or_eq (t1 \\<lhd> \\<sigma>) (t1 \\<lhd> \\<eta>);\n        \\<And>\\<sigma> \\<eta>.\n           lower_on \\<sigma> \\<eta> (vars_of t2) \\<Longrightarrow>\n           lower_or_eq (t2 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<eta>);\n        lower_on \\<sigma> \\<eta> (vars_of (t1 \\<cdot> t2))\\<rbrakk>\n       \\<Longrightarrow> lower_or_eq (t1 \\<cdot> t2 \\<lhd> \\<sigma>)\n                          (t1 \\<cdot> t2 \\<lhd> \\<eta>)", "from this"], ["proof (chain)\npicking this:\n  lower_on \\<sigma> \\<eta> (vars_of (Var x))", "show ?case"], ["proof (prove)\nusing this:\n  lower_on \\<sigma> \\<eta> (vars_of (Var x))\n\ngoal (1 subgoal):\n 1. lower_or_eq (Var x \\<lhd> \\<sigma>) (Var x \\<lhd> \\<eta>)", "unfolding lower_on_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>vars_of (Var x).\n     lower_or_eq (Var x \\<lhd> \\<sigma>) (Var x \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. lower_or_eq (Var x \\<lhd> \\<sigma>) (Var x \\<lhd> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  lower_or_eq (Var x \\<lhd> \\<sigma>) (Var x \\<lhd> \\<eta>)\n\ngoal (2 subgoals):\n 1. \\<And>x \\<sigma> \\<eta>.\n       lower_on \\<sigma> \\<eta> (vars_of (Const x)) \\<Longrightarrow>\n       lower_or_eq (Const x \\<lhd> \\<sigma>) (Const x \\<lhd> \\<eta>)\n 2. \\<And>t1 t2 \\<sigma> \\<eta>.\n       \\<lbrakk>\\<And>\\<sigma> \\<eta>.\n                   lower_on \\<sigma> \\<eta> (vars_of t1) \\<Longrightarrow>\n                   lower_or_eq (t1 \\<lhd> \\<sigma>) (t1 \\<lhd> \\<eta>);\n        \\<And>\\<sigma> \\<eta>.\n           lower_on \\<sigma> \\<eta> (vars_of t2) \\<Longrightarrow>\n           lower_or_eq (t2 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<eta>);\n        lower_on \\<sigma> \\<eta> (vars_of (t1 \\<cdot> t2))\\<rbrakk>\n       \\<Longrightarrow> lower_or_eq (t1 \\<cdot> t2 \\<lhd> \\<sigma>)\n                          (t1 \\<cdot> t2 \\<lhd> \\<eta>)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x \\<sigma> \\<eta>.\n       lower_on \\<sigma> \\<eta> (vars_of (Const x)) \\<Longrightarrow>\n       lower_or_eq (Const x \\<lhd> \\<sigma>) (Const x \\<lhd> \\<eta>)\n 2. \\<And>t1 t2 \\<sigma> \\<eta>.\n       \\<lbrakk>\\<And>\\<sigma> \\<eta>.\n                   lower_on \\<sigma> \\<eta> (vars_of t1) \\<Longrightarrow>\n                   lower_or_eq (t1 \\<lhd> \\<sigma>) (t1 \\<lhd> \\<eta>);\n        \\<And>\\<sigma> \\<eta>.\n           lower_on \\<sigma> \\<eta> (vars_of t2) \\<Longrightarrow>\n           lower_or_eq (t2 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<eta>);\n        lower_on \\<sigma> \\<eta> (vars_of (t1 \\<cdot> t2))\\<rbrakk>\n       \\<Longrightarrow> lower_or_eq (t1 \\<cdot> t2 \\<lhd> \\<sigma>)\n                          (t1 \\<cdot> t2 \\<lhd> \\<eta>)", "case (Const x)"], ["proof (state)\nthis:\n  lower_on \\<sigma> \\<eta> (vars_of (Const x))\n\ngoal (2 subgoals):\n 1. \\<And>x \\<sigma> \\<eta>.\n       lower_on \\<sigma> \\<eta> (vars_of (Const x)) \\<Longrightarrow>\n       lower_or_eq (Const x \\<lhd> \\<sigma>) (Const x \\<lhd> \\<eta>)\n 2. \\<And>t1 t2 \\<sigma> \\<eta>.\n       \\<lbrakk>\\<And>\\<sigma> \\<eta>.\n                   lower_on \\<sigma> \\<eta> (vars_of t1) \\<Longrightarrow>\n                   lower_or_eq (t1 \\<lhd> \\<sigma>) (t1 \\<lhd> \\<eta>);\n        \\<And>\\<sigma> \\<eta>.\n           lower_on \\<sigma> \\<eta> (vars_of t2) \\<Longrightarrow>\n           lower_or_eq (t2 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<eta>);\n        lower_on \\<sigma> \\<eta> (vars_of (t1 \\<cdot> t2))\\<rbrakk>\n       \\<Longrightarrow> lower_or_eq (t1 \\<cdot> t2 \\<lhd> \\<sigma>)\n                          (t1 \\<cdot> t2 \\<lhd> \\<eta>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lower_or_eq (Const x \\<lhd> \\<sigma>) (Const x \\<lhd> \\<eta>)", "unfolding lower_or_eq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Const x \\<lhd> \\<sigma> = Const x \\<lhd> \\<eta> \\<or>\n    (Const x \\<lhd> \\<sigma>, Const x \\<lhd> \\<eta>) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  lower_or_eq (Const x \\<lhd> \\<sigma>) (Const x \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2 \\<sigma> \\<eta>.\n       \\<lbrakk>\\<And>\\<sigma> \\<eta>.\n                   lower_on \\<sigma> \\<eta> (vars_of t1) \\<Longrightarrow>\n                   lower_or_eq (t1 \\<lhd> \\<sigma>) (t1 \\<lhd> \\<eta>);\n        \\<And>\\<sigma> \\<eta>.\n           lower_on \\<sigma> \\<eta> (vars_of t2) \\<Longrightarrow>\n           lower_or_eq (t2 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<eta>);\n        lower_on \\<sigma> \\<eta> (vars_of (t1 \\<cdot> t2))\\<rbrakk>\n       \\<Longrightarrow> lower_or_eq (t1 \\<cdot> t2 \\<lhd> \\<sigma>)\n                          (t1 \\<cdot> t2 \\<lhd> \\<eta>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t1 t2 \\<sigma> \\<eta>.\n       \\<lbrakk>\\<And>\\<sigma> \\<eta>.\n                   lower_on \\<sigma> \\<eta> (vars_of t1) \\<Longrightarrow>\n                   lower_or_eq (t1 \\<lhd> \\<sigma>) (t1 \\<lhd> \\<eta>);\n        \\<And>\\<sigma> \\<eta>.\n           lower_on \\<sigma> \\<eta> (vars_of t2) \\<Longrightarrow>\n           lower_or_eq (t2 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<eta>);\n        lower_on \\<sigma> \\<eta> (vars_of (t1 \\<cdot> t2))\\<rbrakk>\n       \\<Longrightarrow> lower_or_eq (t1 \\<cdot> t2 \\<lhd> \\<sigma>)\n                          (t1 \\<cdot> t2 \\<lhd> \\<eta>)", "case (Comb t1 t2)"], ["proof (state)\nthis:\n  lower_on ?\\<sigma> ?\\<eta> (vars_of t1) \\<Longrightarrow>\n  lower_or_eq (t1 \\<lhd> ?\\<sigma>) (t1 \\<lhd> ?\\<eta>)\n  lower_on ?\\<sigma> ?\\<eta> (vars_of t2) \\<Longrightarrow>\n  lower_or_eq (t2 \\<lhd> ?\\<sigma>) (t2 \\<lhd> ?\\<eta>)\n  lower_on \\<sigma> \\<eta> (vars_of (t1 \\<cdot> t2))\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2 \\<sigma> \\<eta>.\n       \\<lbrakk>\\<And>\\<sigma> \\<eta>.\n                   lower_on \\<sigma> \\<eta> (vars_of t1) \\<Longrightarrow>\n                   lower_or_eq (t1 \\<lhd> \\<sigma>) (t1 \\<lhd> \\<eta>);\n        \\<And>\\<sigma> \\<eta>.\n           lower_on \\<sigma> \\<eta> (vars_of t2) \\<Longrightarrow>\n           lower_or_eq (t2 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<eta>);\n        lower_on \\<sigma> \\<eta> (vars_of (t1 \\<cdot> t2))\\<rbrakk>\n       \\<Longrightarrow> lower_or_eq (t1 \\<cdot> t2 \\<lhd> \\<sigma>)\n                          (t1 \\<cdot> t2 \\<lhd> \\<eta>)", "show \"\\<And> \\<sigma> \\<eta>. lower_on \\<sigma> \\<eta> (vars_of (Comb t1 t2)) \\<Longrightarrow> \n    (lower_or_eq (subst  (Comb t1 t2) \\<sigma>) (subst  (Comb t1 t2) \\<eta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<eta>.\n       lower_on \\<sigma> \\<eta> (vars_of (t1 \\<cdot> t2)) \\<Longrightarrow>\n       lower_or_eq (t1 \\<cdot> t2 \\<lhd> \\<sigma>)\n        (t1 \\<cdot> t2 \\<lhd> \\<eta>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<eta>.\n       lower_on \\<sigma> \\<eta> (vars_of (t1 \\<cdot> t2)) \\<Longrightarrow>\n       lower_or_eq (t1 \\<cdot> t2 \\<lhd> \\<sigma>)\n        (t1 \\<cdot> t2 \\<lhd> \\<eta>)", "fix \\<sigma> \\<eta>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<eta>.\n       lower_on \\<sigma> \\<eta> (vars_of (t1 \\<cdot> t2)) \\<Longrightarrow>\n       lower_or_eq (t1 \\<cdot> t2 \\<lhd> \\<sigma>)\n        (t1 \\<cdot> t2 \\<lhd> \\<eta>)", "assume \"lower_on \\<sigma> \\<eta> (vars_of (Comb t1 t2))\""], ["proof (state)\nthis:\n  lower_on \\<sigma> \\<eta> (vars_of (t1 \\<cdot> t2))\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<eta>.\n       lower_on \\<sigma> \\<eta> (vars_of (t1 \\<cdot> t2)) \\<Longrightarrow>\n       lower_or_eq (t1 \\<cdot> t2 \\<lhd> \\<sigma>)\n        (t1 \\<cdot> t2 \\<lhd> \\<eta>)", "from this"], ["proof (chain)\npicking this:\n  lower_on \\<sigma> \\<eta> (vars_of (t1 \\<cdot> t2))", "have \"lower_on \\<sigma> \\<eta> (vars_of t1)\" and \"lower_on \\<sigma> \\<eta> (vars_of t2)\""], ["proof (prove)\nusing this:\n  lower_on \\<sigma> \\<eta> (vars_of (t1 \\<cdot> t2))\n\ngoal (1 subgoal):\n 1. lower_on \\<sigma> \\<eta> (vars_of t1) &&&\n    lower_on \\<sigma> \\<eta> (vars_of t2)", "unfolding lower_on_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>vars_of (t1 \\<cdot> t2).\n     lower_or_eq (Var x \\<lhd> \\<sigma>) (Var x \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of t1.\n       lower_or_eq (Var x \\<lhd> \\<sigma>) (Var x \\<lhd> \\<eta>) &&&\n    \\<forall>x\\<in>vars_of t2.\n       lower_or_eq (Var x \\<lhd> \\<sigma>) (Var x \\<lhd> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  lower_on \\<sigma> \\<eta> (vars_of t1)\n  lower_on \\<sigma> \\<eta> (vars_of t2)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<eta>.\n       lower_on \\<sigma> \\<eta> (vars_of (t1 \\<cdot> t2)) \\<Longrightarrow>\n       lower_or_eq (t1 \\<cdot> t2 \\<lhd> \\<sigma>)\n        (t1 \\<cdot> t2 \\<lhd> \\<eta>)", "from \\<open>lower_on \\<sigma> \\<eta> (vars_of t1)\\<close>"], ["proof (chain)\npicking this:\n  lower_on \\<sigma> \\<eta> (vars_of t1)", "have \"lower_or_eq (subst t1 \\<sigma>) (subst t1 \\<eta>)\""], ["proof (prove)\nusing this:\n  lower_on \\<sigma> \\<eta> (vars_of t1)\n\ngoal (1 subgoal):\n 1. lower_or_eq (t1 \\<lhd> \\<sigma>) (t1 \\<lhd> \\<eta>)", "using Comb.IH"], ["proof (prove)\nusing this:\n  lower_on \\<sigma> \\<eta> (vars_of t1)\n  lower_on ?\\<sigma> ?\\<eta> (vars_of t1) \\<Longrightarrow>\n  lower_or_eq (t1 \\<lhd> ?\\<sigma>) (t1 \\<lhd> ?\\<eta>)\n  lower_on ?\\<sigma> ?\\<eta> (vars_of t2) \\<Longrightarrow>\n  lower_or_eq (t2 \\<lhd> ?\\<sigma>) (t2 \\<lhd> ?\\<eta>)\n\ngoal (1 subgoal):\n 1. lower_or_eq (t1 \\<lhd> \\<sigma>) (t1 \\<lhd> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  lower_or_eq (t1 \\<lhd> \\<sigma>) (t1 \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<eta>.\n       lower_on \\<sigma> \\<eta> (vars_of (t1 \\<cdot> t2)) \\<Longrightarrow>\n       lower_or_eq (t1 \\<cdot> t2 \\<lhd> \\<sigma>)\n        (t1 \\<cdot> t2 \\<lhd> \\<eta>)", "from \\<open>lower_on \\<sigma> \\<eta> (vars_of t2)\\<close>"], ["proof (chain)\npicking this:\n  lower_on \\<sigma> \\<eta> (vars_of t2)", "have \"lower_or_eq (subst t2 \\<sigma>) (subst t2 \\<eta>)\""], ["proof (prove)\nusing this:\n  lower_on \\<sigma> \\<eta> (vars_of t2)\n\ngoal (1 subgoal):\n 1. lower_or_eq (t2 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<eta>)", "using Comb.IH"], ["proof (prove)\nusing this:\n  lower_on \\<sigma> \\<eta> (vars_of t2)\n  lower_on ?\\<sigma> ?\\<eta> (vars_of t1) \\<Longrightarrow>\n  lower_or_eq (t1 \\<lhd> ?\\<sigma>) (t1 \\<lhd> ?\\<eta>)\n  lower_on ?\\<sigma> ?\\<eta> (vars_of t2) \\<Longrightarrow>\n  lower_or_eq (t2 \\<lhd> ?\\<sigma>) (t2 \\<lhd> ?\\<eta>)\n\ngoal (1 subgoal):\n 1. lower_or_eq (t2 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  lower_or_eq (t2 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<eta>.\n       lower_on \\<sigma> \\<eta> (vars_of (t1 \\<cdot> t2)) \\<Longrightarrow>\n       lower_or_eq (t1 \\<cdot> t2 \\<lhd> \\<sigma>)\n        (t1 \\<cdot> t2 \\<lhd> \\<eta>)", "from \\<open>lower_or_eq (subst t1 \\<sigma>) (subst t1 \\<eta>)\\<close> \\<open>lower_or_eq (subst t2 \\<sigma>) (subst t2 \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  lower_or_eq (t1 \\<lhd> \\<sigma>) (t1 \\<lhd> \\<eta>)\n  lower_or_eq (t2 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<eta>)", "show \"lower_or_eq (subst  (Comb t1 t2) \\<sigma>) (subst (Comb t1 t2) \\<eta>)\""], ["proof (prove)\nusing this:\n  lower_or_eq (t1 \\<lhd> \\<sigma>) (t1 \\<lhd> \\<eta>)\n  lower_or_eq (t2 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. lower_or_eq (t1 \\<cdot> t2 \\<lhd> \\<sigma>)\n     (t1 \\<cdot> t2 \\<lhd> \\<eta>)", "using lower_or_eq_monotonic"], ["proof (prove)\nusing this:\n  lower_or_eq (t1 \\<lhd> \\<sigma>) (t1 \\<lhd> \\<eta>)\n  lower_or_eq (t2 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<eta>)\n  \\<lbrakk>lower_or_eq ?t1.0 ?s1.0; lower_or_eq ?t2.0 ?s2.0\\<rbrakk>\n  \\<Longrightarrow> lower_or_eq (?t1.0 \\<cdot> ?t2.0) (?s1.0 \\<cdot> ?s2.0)\n\ngoal (1 subgoal):\n 1. lower_or_eq (t1 \\<cdot> t2 \\<lhd> \\<sigma>)\n     (t1 \\<cdot> t2 \\<lhd> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  lower_or_eq (t1 \\<cdot> t2 \\<lhd> \\<sigma>) (t1 \\<cdot> t2 \\<lhd> \\<eta>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lower_on ?\\<sigma> ?\\<eta> (vars_of (t1 \\<cdot> t2)) \\<Longrightarrow>\n  lower_or_eq (t1 \\<cdot> t2 \\<lhd> ?\\<sigma>)\n   (t1 \\<cdot> t2 \\<lhd> ?\\<eta>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma diff_substs_yield_diff_trms:\n  assumes \"(subst (Var x) \\<sigma>) \\<noteq> (subst (Var x) \\<eta>)\"\n  shows \"(x \\<in> vars_of t)\n   \\<Longrightarrow> (subst t \\<sigma>) \\<noteq> (subst t \\<eta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> vars_of t \\<Longrightarrow>\n    t \\<lhd> \\<sigma> \\<noteq> t \\<lhd> \\<eta>", "proof (induction t)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       x \\<in> vars_of (Var xa) \\<Longrightarrow>\n       Var xa \\<lhd> \\<sigma> \\<noteq> Var xa \\<lhd> \\<eta>\n 2. \\<And>xa.\n       x \\<in> vars_of (Const xa) \\<Longrightarrow>\n       Const xa \\<lhd> \\<sigma> \\<noteq> Const xa \\<lhd> \\<eta>\n 3. \\<And>t1 t2.\n       \\<lbrakk>x \\<in> vars_of t1 \\<Longrightarrow>\n                t1 \\<lhd> \\<sigma> \\<noteq> t1 \\<lhd> \\<eta>;\n        x \\<in> vars_of t2 \\<Longrightarrow>\n        t2 \\<lhd> \\<sigma> \\<noteq> t2 \\<lhd> \\<eta>;\n        x \\<in> vars_of (t1 \\<cdot> t2)\\<rbrakk>\n       \\<Longrightarrow> t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq>\n                         t1 \\<cdot> t2 \\<lhd> \\<eta>", "case (Var y)"], ["proof (state)\nthis:\n  x \\<in> vars_of (Var y)\n\ngoal (3 subgoals):\n 1. \\<And>xa.\n       x \\<in> vars_of (Var xa) \\<Longrightarrow>\n       Var xa \\<lhd> \\<sigma> \\<noteq> Var xa \\<lhd> \\<eta>\n 2. \\<And>xa.\n       x \\<in> vars_of (Const xa) \\<Longrightarrow>\n       Const xa \\<lhd> \\<sigma> \\<noteq> Const xa \\<lhd> \\<eta>\n 3. \\<And>t1 t2.\n       \\<lbrakk>x \\<in> vars_of t1 \\<Longrightarrow>\n                t1 \\<lhd> \\<sigma> \\<noteq> t1 \\<lhd> \\<eta>;\n        x \\<in> vars_of t2 \\<Longrightarrow>\n        t2 \\<lhd> \\<sigma> \\<noteq> t2 \\<lhd> \\<eta>;\n        x \\<in> vars_of (t1 \\<cdot> t2)\\<rbrakk>\n       \\<Longrightarrow> t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq>\n                         t1 \\<cdot> t2 \\<lhd> \\<eta>", "show \"(x \\<in> vars_of (Var y))  \\<Longrightarrow> (subst  (Var y) \\<sigma>) \\<noteq> (subst  (Var y) \\<eta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> vars_of (Var y) \\<Longrightarrow>\n    Var y \\<lhd> \\<sigma> \\<noteq> Var y \\<lhd> \\<eta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> vars_of (Var y) \\<Longrightarrow>\n    Var y \\<lhd> \\<sigma> \\<noteq> Var y \\<lhd> \\<eta>", "assume \"(x \\<in> vars_of  (Var y))\""], ["proof (state)\nthis:\n  x \\<in> vars_of (Var y)\n\ngoal (1 subgoal):\n 1. x \\<in> vars_of (Var y) \\<Longrightarrow>\n    Var y \\<lhd> \\<sigma> \\<noteq> Var y \\<lhd> \\<eta>", "from \\<open>(x \\<in> vars_of  (Var y))\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> vars_of (Var y)", "have \"x = y\""], ["proof (prove)\nusing this:\n  x \\<in> vars_of (Var y)\n\ngoal (1 subgoal):\n 1. x = y", "by auto"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. x \\<in> vars_of (Var y) \\<Longrightarrow>\n    Var y \\<lhd> \\<sigma> \\<noteq> Var y \\<lhd> \\<eta>", "from this and assms(1)"], ["proof (chain)\npicking this:\n  x = y\n  Var x \\<lhd> \\<sigma> \\<noteq> Var x \\<lhd> \\<eta>", "show \"(subst  (Var y) \\<sigma>) \\<noteq> (subst  (Var y) \\<eta>)\""], ["proof (prove)\nusing this:\n  x = y\n  Var x \\<lhd> \\<sigma> \\<noteq> Var x \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. Var y \\<lhd> \\<sigma> \\<noteq> Var y \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  Var y \\<lhd> \\<sigma> \\<noteq> Var y \\<lhd> \\<eta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> vars_of (Var y) \\<Longrightarrow>\n  Var y \\<lhd> \\<sigma> \\<noteq> Var y \\<lhd> \\<eta>\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       x \\<in> vars_of (Const xa) \\<Longrightarrow>\n       Const xa \\<lhd> \\<sigma> \\<noteq> Const xa \\<lhd> \\<eta>\n 2. \\<And>t1 t2.\n       \\<lbrakk>x \\<in> vars_of t1 \\<Longrightarrow>\n                t1 \\<lhd> \\<sigma> \\<noteq> t1 \\<lhd> \\<eta>;\n        x \\<in> vars_of t2 \\<Longrightarrow>\n        t2 \\<lhd> \\<sigma> \\<noteq> t2 \\<lhd> \\<eta>;\n        x \\<in> vars_of (t1 \\<cdot> t2)\\<rbrakk>\n       \\<Longrightarrow> t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq>\n                         t1 \\<cdot> t2 \\<lhd> \\<eta>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       x \\<in> vars_of (Const xa) \\<Longrightarrow>\n       Const xa \\<lhd> \\<sigma> \\<noteq> Const xa \\<lhd> \\<eta>\n 2. \\<And>t1 t2.\n       \\<lbrakk>x \\<in> vars_of t1 \\<Longrightarrow>\n                t1 \\<lhd> \\<sigma> \\<noteq> t1 \\<lhd> \\<eta>;\n        x \\<in> vars_of t2 \\<Longrightarrow>\n        t2 \\<lhd> \\<sigma> \\<noteq> t2 \\<lhd> \\<eta>;\n        x \\<in> vars_of (t1 \\<cdot> t2)\\<rbrakk>\n       \\<Longrightarrow> t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq>\n                         t1 \\<cdot> t2 \\<lhd> \\<eta>", "case (Const y)"], ["proof (state)\nthis:\n  x \\<in> vars_of (Const y)\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       x \\<in> vars_of (Const xa) \\<Longrightarrow>\n       Const xa \\<lhd> \\<sigma> \\<noteq> Const xa \\<lhd> \\<eta>\n 2. \\<And>t1 t2.\n       \\<lbrakk>x \\<in> vars_of t1 \\<Longrightarrow>\n                t1 \\<lhd> \\<sigma> \\<noteq> t1 \\<lhd> \\<eta>;\n        x \\<in> vars_of t2 \\<Longrightarrow>\n        t2 \\<lhd> \\<sigma> \\<noteq> t2 \\<lhd> \\<eta>;\n        x \\<in> vars_of (t1 \\<cdot> t2)\\<rbrakk>\n       \\<Longrightarrow> t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq>\n                         t1 \\<cdot> t2 \\<lhd> \\<eta>", "show \" (x \\<in> vars_of (Const y))\n   \\<Longrightarrow> (subst  (Const y) \\<sigma>) \\<noteq> (subst  (Const y) \\<eta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> vars_of (Const y) \\<Longrightarrow>\n    Const y \\<lhd> \\<sigma> \\<noteq> Const y \\<lhd> \\<eta>", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> vars_of (Const y);\n     \\<not> Const y \\<lhd> \\<sigma> \\<noteq> Const y \\<lhd> \\<eta>\\<rbrakk>\n    \\<Longrightarrow> False", "from \\<open>(x \\<in> vars_of  (Const y))\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> vars_of (Const y)", "show False"], ["proof (prove)\nusing this:\n  x \\<in> vars_of (Const y)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> vars_of (Const y) \\<Longrightarrow>\n  Const y \\<lhd> \\<sigma> \\<noteq> Const y \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>x \\<in> vars_of t1 \\<Longrightarrow>\n                t1 \\<lhd> \\<sigma> \\<noteq> t1 \\<lhd> \\<eta>;\n        x \\<in> vars_of t2 \\<Longrightarrow>\n        t2 \\<lhd> \\<sigma> \\<noteq> t2 \\<lhd> \\<eta>;\n        x \\<in> vars_of (t1 \\<cdot> t2)\\<rbrakk>\n       \\<Longrightarrow> t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq>\n                         t1 \\<cdot> t2 \\<lhd> \\<eta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>x \\<in> vars_of t1 \\<Longrightarrow>\n                t1 \\<lhd> \\<sigma> \\<noteq> t1 \\<lhd> \\<eta>;\n        x \\<in> vars_of t2 \\<Longrightarrow>\n        t2 \\<lhd> \\<sigma> \\<noteq> t2 \\<lhd> \\<eta>;\n        x \\<in> vars_of (t1 \\<cdot> t2)\\<rbrakk>\n       \\<Longrightarrow> t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq>\n                         t1 \\<cdot> t2 \\<lhd> \\<eta>", "case (Comb t1 t2)"], ["proof (state)\nthis:\n  x \\<in> vars_of t1 \\<Longrightarrow>\n  t1 \\<lhd> \\<sigma> \\<noteq> t1 \\<lhd> \\<eta>\n  x \\<in> vars_of t2 \\<Longrightarrow>\n  t2 \\<lhd> \\<sigma> \\<noteq> t2 \\<lhd> \\<eta>\n  x \\<in> vars_of (t1 \\<cdot> t2)\n\ngoal (1 subgoal):\n 1. \\<And>t1 t2.\n       \\<lbrakk>x \\<in> vars_of t1 \\<Longrightarrow>\n                t1 \\<lhd> \\<sigma> \\<noteq> t1 \\<lhd> \\<eta>;\n        x \\<in> vars_of t2 \\<Longrightarrow>\n        t2 \\<lhd> \\<sigma> \\<noteq> t2 \\<lhd> \\<eta>;\n        x \\<in> vars_of (t1 \\<cdot> t2)\\<rbrakk>\n       \\<Longrightarrow> t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq>\n                         t1 \\<cdot> t2 \\<lhd> \\<eta>", "show \" (x \\<in> vars_of (Comb t1 t2))\n   \\<Longrightarrow> (subst  (Comb t1 t2) \\<sigma>) \\<noteq> (subst (Comb t1 t2) \\<eta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> vars_of (t1 \\<cdot> t2) \\<Longrightarrow>\n    t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq> t1 \\<cdot> t2 \\<lhd> \\<eta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> vars_of (t1 \\<cdot> t2) \\<Longrightarrow>\n    t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq> t1 \\<cdot> t2 \\<lhd> \\<eta>", "assume \"(x \\<in> vars_of (Comb t1 t2))\""], ["proof (state)\nthis:\n  x \\<in> vars_of (t1 \\<cdot> t2)\n\ngoal (1 subgoal):\n 1. x \\<in> vars_of (t1 \\<cdot> t2) \\<Longrightarrow>\n    t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq> t1 \\<cdot> t2 \\<lhd> \\<eta>", "from \\<open>x \\<in> vars_of (Comb t1 t2)\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> vars_of (t1 \\<cdot> t2)", "have \"x \\<in> vars_of t1 \\<or> x \\<in> vars_of t2\""], ["proof (prove)\nusing this:\n  x \\<in> vars_of (t1 \\<cdot> t2)\n\ngoal (1 subgoal):\n 1. x \\<in> vars_of t1 \\<or> x \\<in> vars_of t2", "by auto"], ["proof (state)\nthis:\n  x \\<in> vars_of t1 \\<or> x \\<in> vars_of t2\n\ngoal (1 subgoal):\n 1. x \\<in> vars_of (t1 \\<cdot> t2) \\<Longrightarrow>\n    t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq> t1 \\<cdot> t2 \\<lhd> \\<eta>", "then"], ["proof (chain)\npicking this:\n  x \\<in> vars_of t1 \\<or> x \\<in> vars_of t2", "show \"(subst  (Comb t1 t2) \\<sigma>) \\<noteq> (subst (Comb t1 t2) \\<eta>)\""], ["proof (prove)\nusing this:\n  x \\<in> vars_of t1 \\<or> x \\<in> vars_of t2\n\ngoal (1 subgoal):\n 1. t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq> t1 \\<cdot> t2 \\<lhd> \\<eta>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> vars_of t1 \\<Longrightarrow>\n    t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq> t1 \\<cdot> t2 \\<lhd> \\<eta>\n 2. x \\<in> vars_of t2 \\<Longrightarrow>\n    t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq> t1 \\<cdot> t2 \\<lhd> \\<eta>", "assume \"x \\<in> vars_of t1\""], ["proof (state)\nthis:\n  x \\<in> vars_of t1\n\ngoal (2 subgoals):\n 1. x \\<in> vars_of t1 \\<Longrightarrow>\n    t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq> t1 \\<cdot> t2 \\<lhd> \\<eta>\n 2. x \\<in> vars_of t2 \\<Longrightarrow>\n    t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq> t1 \\<cdot> t2 \\<lhd> \\<eta>", "from this"], ["proof (chain)\npicking this:\n  x \\<in> vars_of t1", "have \"(subst t1 \\<sigma>) \\<noteq> (subst t1 \\<eta>)\""], ["proof (prove)\nusing this:\n  x \\<in> vars_of t1\n\ngoal (1 subgoal):\n 1. t1 \\<lhd> \\<sigma> \\<noteq> t1 \\<lhd> \\<eta>", "using Comb.IH"], ["proof (prove)\nusing this:\n  x \\<in> vars_of t1\n  x \\<in> vars_of t1 \\<Longrightarrow>\n  t1 \\<lhd> \\<sigma> \\<noteq> t1 \\<lhd> \\<eta>\n  x \\<in> vars_of t2 \\<Longrightarrow>\n  t2 \\<lhd> \\<sigma> \\<noteq> t2 \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. t1 \\<lhd> \\<sigma> \\<noteq> t1 \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  t1 \\<lhd> \\<sigma> \\<noteq> t1 \\<lhd> \\<eta>\n\ngoal (2 subgoals):\n 1. x \\<in> vars_of t1 \\<Longrightarrow>\n    t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq> t1 \\<cdot> t2 \\<lhd> \\<eta>\n 2. x \\<in> vars_of t2 \\<Longrightarrow>\n    t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq> t1 \\<cdot> t2 \\<lhd> \\<eta>", "then"], ["proof (chain)\npicking this:\n  t1 \\<lhd> \\<sigma> \\<noteq> t1 \\<lhd> \\<eta>", "show ?thesis"], ["proof (prove)\nusing this:\n  t1 \\<lhd> \\<sigma> \\<noteq> t1 \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq> t1 \\<cdot> t2 \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq> t1 \\<cdot> t2 \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. x \\<in> vars_of t2 \\<Longrightarrow>\n    t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq> t1 \\<cdot> t2 \\<lhd> \\<eta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> vars_of t2 \\<Longrightarrow>\n    t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq> t1 \\<cdot> t2 \\<lhd> \\<eta>", "assume \"x \\<in> vars_of t2\""], ["proof (state)\nthis:\n  x \\<in> vars_of t2\n\ngoal (1 subgoal):\n 1. x \\<in> vars_of t2 \\<Longrightarrow>\n    t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq> t1 \\<cdot> t2 \\<lhd> \\<eta>", "from this"], ["proof (chain)\npicking this:\n  x \\<in> vars_of t2", "have \"(subst t2 \\<sigma>) \\<noteq> (subst t2 \\<eta>)\""], ["proof (prove)\nusing this:\n  x \\<in> vars_of t2\n\ngoal (1 subgoal):\n 1. t2 \\<lhd> \\<sigma> \\<noteq> t2 \\<lhd> \\<eta>", "using Comb.IH"], ["proof (prove)\nusing this:\n  x \\<in> vars_of t2\n  x \\<in> vars_of t1 \\<Longrightarrow>\n  t1 \\<lhd> \\<sigma> \\<noteq> t1 \\<lhd> \\<eta>\n  x \\<in> vars_of t2 \\<Longrightarrow>\n  t2 \\<lhd> \\<sigma> \\<noteq> t2 \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. t2 \\<lhd> \\<sigma> \\<noteq> t2 \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  t2 \\<lhd> \\<sigma> \\<noteq> t2 \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. x \\<in> vars_of t2 \\<Longrightarrow>\n    t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq> t1 \\<cdot> t2 \\<lhd> \\<eta>", "then"], ["proof (chain)\npicking this:\n  t2 \\<lhd> \\<sigma> \\<noteq> t2 \\<lhd> \\<eta>", "show ?thesis"], ["proof (prove)\nusing this:\n  t2 \\<lhd> \\<sigma> \\<noteq> t2 \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq> t1 \\<cdot> t2 \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq> t1 \\<cdot> t2 \\<lhd> \\<eta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq> t1 \\<cdot> t2 \\<lhd> \\<eta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> vars_of (t1 \\<cdot> t2) \\<Longrightarrow>\n  t1 \\<cdot> t2 \\<lhd> \\<sigma> \\<noteq> t1 \\<cdot> t2 \\<lhd> \\<eta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lower_subst_yields_lower_trms:\n  assumes \"lower_on \\<sigma> \\<eta> (vars_of t)\"\n  assumes \"((subst (Var x) \\<sigma>),(subst (Var x) \\<eta>)) \\<in> trm_ord\"\n  assumes \"(x \\<in> vars_of t)\"\n  shows \"((subst t \\<sigma>),(subst t \\<eta>)) \\<in> trm_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, t \\<lhd> \\<eta>) \\<in> trm_ord", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, t \\<lhd> \\<eta>) \\<in> trm_ord", "from assms(1)"], ["proof (chain)\npicking this:\n  lower_on \\<sigma> \\<eta> (vars_of t)", "have \"lower_or_eq (subst t \\<sigma>) (subst t \\<eta>)\""], ["proof (prove)\nusing this:\n  lower_on \\<sigma> \\<eta> (vars_of t)\n\ngoal (1 subgoal):\n 1. lower_or_eq (t \\<lhd> \\<sigma>) (t \\<lhd> \\<eta>)", "using lower_on_term"], ["proof (prove)\nusing this:\n  lower_on \\<sigma> \\<eta> (vars_of t)\n  lower_on ?\\<sigma> ?\\<eta> (vars_of ?t) \\<Longrightarrow>\n  lower_or_eq (?t \\<lhd> ?\\<sigma>) (?t \\<lhd> ?\\<eta>)\n\ngoal (1 subgoal):\n 1. lower_or_eq (t \\<lhd> \\<sigma>) (t \\<lhd> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  lower_or_eq (t \\<lhd> \\<sigma>) (t \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, t \\<lhd> \\<eta>) \\<in> trm_ord", "from assms(2)"], ["proof (chain)\npicking this:\n  (Var x \\<lhd> \\<sigma>, Var x \\<lhd> \\<eta>) \\<in> trm_ord", "have \"(subst (Var x) \\<sigma>) \\<noteq> (subst (Var x) \\<eta>)\""], ["proof (prove)\nusing this:\n  (Var x \\<lhd> \\<sigma>, Var x \\<lhd> \\<eta>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. Var x \\<lhd> \\<sigma> \\<noteq> Var x \\<lhd> \\<eta>", "using trm_ord_irrefl irrefl_def"], ["proof (prove)\nusing this:\n  (Var x \\<lhd> \\<sigma>, Var x \\<lhd> \\<eta>) \\<in> trm_ord\n  irrefl trm_ord\n  irrefl ?r = (\\<forall>a. (a, a) \\<notin> ?r)\n\ngoal (1 subgoal):\n 1. Var x \\<lhd> \\<sigma> \\<noteq> Var x \\<lhd> \\<eta>", "by fastforce"], ["proof (state)\nthis:\n  Var x \\<lhd> \\<sigma> \\<noteq> Var x \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, t \\<lhd> \\<eta>) \\<in> trm_ord", "from this and assms(3)"], ["proof (chain)\npicking this:\n  Var x \\<lhd> \\<sigma> \\<noteq> Var x \\<lhd> \\<eta>\n  x \\<in> vars_of t", "have \"(subst t \\<sigma>) \\<noteq> (subst t \\<eta>)\""], ["proof (prove)\nusing this:\n  Var x \\<lhd> \\<sigma> \\<noteq> Var x \\<lhd> \\<eta>\n  x \\<in> vars_of t\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> \\<noteq> t \\<lhd> \\<eta>", "using diff_substs_yield_diff_trms"], ["proof (prove)\nusing this:\n  Var x \\<lhd> \\<sigma> \\<noteq> Var x \\<lhd> \\<eta>\n  x \\<in> vars_of t\n  \\<lbrakk>Var ?x \\<lhd> ?\\<sigma> \\<noteq> Var ?x \\<lhd> ?\\<eta>;\n   ?x \\<in> vars_of ?t\\<rbrakk>\n  \\<Longrightarrow> ?t \\<lhd> ?\\<sigma> \\<noteq> ?t \\<lhd> ?\\<eta>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> \\<noteq> t \\<lhd> \\<eta>", "by fastforce"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> \\<noteq> t \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, t \\<lhd> \\<eta>) \\<in> trm_ord", "from this and \\<open>lower_or_eq (subst t \\<sigma>) (subst t \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<sigma> \\<noteq> t \\<lhd> \\<eta>\n  lower_or_eq (t \\<lhd> \\<sigma>) (t \\<lhd> \\<eta>)", "show ?thesis"], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> \\<noteq> t \\<lhd> \\<eta>\n  lower_or_eq (t \\<lhd> \\<sigma>) (t \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, t \\<lhd> \\<eta>) \\<in> trm_ord", "unfolding lower_or_eq_def"], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> \\<noteq> t \\<lhd> \\<eta>\n  t \\<lhd> \\<sigma> = t \\<lhd> \\<eta> \\<or>\n  (t \\<lhd> \\<sigma>, t \\<lhd> \\<eta>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, t \\<lhd> \\<eta>) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (t \\<lhd> \\<sigma>, t \\<lhd> \\<eta>) \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lower_on_lit:\n  assumes \"lower_on \\<sigma> \\<eta> (vars_of_lit L)\"\n  assumes \"((subst (Var x) \\<sigma>),(subst (Var x) \\<eta>)) \\<in> trm_ord\"\n  assumes \"x \\<in> vars_of_lit L\"\n  shows \"((subst_lit L \\<sigma>), (subst_lit L \\<eta>)) \\<in> lit_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "obtain t s where def_l: \"L = Pos (Eq t s) | L = (Neg (Eq t s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t s.\n        L = Pos (Eq t s) \\<or> L = Neg (Eq t s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis mset_lit.cases)"], ["proof (state)\nthis:\n  L = Pos (Eq t s) \\<or> L = Neg (Eq t s)\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  L = Pos (Eq t s) \\<or> L = Neg (Eq t s)", "have \"vars_of t \\<subseteq> vars_of_lit L\" and \"vars_of s \\<subseteq> vars_of_lit L\""], ["proof (prove)\nusing this:\n  L = Pos (Eq t s) \\<or> L = Neg (Eq t s)\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L &&&\n    vars_of s \\<subseteq> vars_of_lit L", "by auto"], ["proof (state)\nthis:\n  vars_of t \\<subseteq> vars_of_lit L\n  vars_of s \\<subseteq> vars_of_lit L\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "from \\<open>vars_of s \\<subseteq> vars_of_lit L\\<close> and assms(1)"], ["proof (chain)\npicking this:\n  vars_of s \\<subseteq> vars_of_lit L\n  lower_on \\<sigma> \\<eta> (vars_of_lit L)", "have \"lower_on \\<sigma> \\<eta> (vars_of s)\""], ["proof (prove)\nusing this:\n  vars_of s \\<subseteq> vars_of_lit L\n  lower_on \\<sigma> \\<eta> (vars_of_lit L)\n\ngoal (1 subgoal):\n 1. lower_on \\<sigma> \\<eta> (vars_of s)", "unfolding lower_on_def"], ["proof (prove)\nusing this:\n  vars_of s \\<subseteq> vars_of_lit L\n  \\<forall>x\\<in>vars_of_lit L.\n     lower_or_eq (Var x \\<lhd> \\<sigma>) (Var x \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of s.\n       lower_or_eq (Var x \\<lhd> \\<sigma>) (Var x \\<lhd> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  lower_on \\<sigma> \\<eta> (vars_of s)\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "from def_l"], ["proof (chain)\npicking this:\n  L = Pos (Eq t s) \\<or> L = Neg (Eq t s)", "have def_ms_l: \"mset_lit L = {# t,s #} \\<or> mset_lit L = {# t,t,s,s #}\""], ["proof (prove)\nusing this:\n  L = Pos (Eq t s) \\<or> L = Neg (Eq t s)\n\ngoal (1 subgoal):\n 1. mset_lit L = {#t, s#} \\<or> mset_lit L = {#t, t, s, s#}", "by auto"], ["proof (state)\nthis:\n  mset_lit L = {#t, s#} \\<or> mset_lit L = {#t, t, s, s#}\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  mset_lit L = {#t, s#} \\<or> mset_lit L = {#t, t, s, s#}", "have \"t \\<in># (mset_lit L)\" and \"s \\<in># (mset_lit L)\""], ["proof (prove)\nusing this:\n  mset_lit L = {#t, s#} \\<or> mset_lit L = {#t, t, s, s#}\n\ngoal (1 subgoal):\n 1. t \\<in># mset_lit L &&& s \\<in># mset_lit L", "by auto"], ["proof (state)\nthis:\n  t \\<in># mset_lit L\n  s \\<in># mset_lit L\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "from def_l"], ["proof (chain)\npicking this:\n  L = Pos (Eq t s) \\<or> L = Neg (Eq t s)", "have \"mset_lit (subst_lit L \\<sigma>) = {# (subst u \\<sigma>). u \\<in># (mset_lit L) #}\""], ["proof (prove)\nusing this:\n  L = Pos (Eq t s) \\<or> L = Neg (Eq t s)\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L \\<sigma>) =\n    {#u \\<lhd> \\<sigma>. u \\<in># mset_lit L#}", "by auto"], ["proof (state)\nthis:\n  mset_lit (subst_lit L \\<sigma>) =\n  {#u \\<lhd> \\<sigma>. u \\<in># mset_lit L#}\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "from def_l"], ["proof (chain)\npicking this:\n  L = Pos (Eq t s) \\<or> L = Neg (Eq t s)", "have \"mset_lit (subst_lit L \\<eta>) = {# (subst u \\<eta>). u \\<in># (mset_lit L) #}\""], ["proof (prove)\nusing this:\n  L = Pos (Eq t s) \\<or> L = Neg (Eq t s)\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L \\<eta>) = {#u \\<lhd> \\<eta>. u \\<in># mset_lit L#}", "by auto"], ["proof (state)\nthis:\n  mset_lit (subst_lit L \\<eta>) = {#u \\<lhd> \\<eta>. u \\<in># mset_lit L#}\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "from \\<open>lower_on \\<sigma> \\<eta> (vars_of s)\\<close>"], ["proof (chain)\npicking this:\n  lower_on \\<sigma> \\<eta> (vars_of s)", "have \"lower_or_eq (subst s \\<sigma>) (subst s \\<eta>)\""], ["proof (prove)\nusing this:\n  lower_on \\<sigma> \\<eta> (vars_of s)\n\ngoal (1 subgoal):\n 1. lower_or_eq (s \\<lhd> \\<sigma>) (s \\<lhd> \\<eta>)", "using lower_on_term"], ["proof (prove)\nusing this:\n  lower_on \\<sigma> \\<eta> (vars_of s)\n  lower_on ?\\<sigma> ?\\<eta> (vars_of ?t) \\<Longrightarrow>\n  lower_or_eq (?t \\<lhd> ?\\<sigma>) (?t \\<lhd> ?\\<eta>)\n\ngoal (1 subgoal):\n 1. lower_or_eq (s \\<lhd> \\<sigma>) (s \\<lhd> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  lower_or_eq (s \\<lhd> \\<sigma>) (s \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "let ?L = \"mset_lit L\""], ["proof (state)\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "let ?M1 = \"mset_lit (subst_lit L \\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "let ?M2 = \"mset_lit (subst_lit L \\<eta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "from \\<open>vars_of t \\<subseteq> vars_of_lit L\\<close> and assms(1)"], ["proof (chain)\npicking this:\n  vars_of t \\<subseteq> vars_of_lit L\n  lower_on \\<sigma> \\<eta> (vars_of_lit L)", "have \"lower_on \\<sigma> \\<eta> (vars_of t)\""], ["proof (prove)\nusing this:\n  vars_of t \\<subseteq> vars_of_lit L\n  lower_on \\<sigma> \\<eta> (vars_of_lit L)\n\ngoal (1 subgoal):\n 1. lower_on \\<sigma> \\<eta> (vars_of t)", "unfolding lower_on_def"], ["proof (prove)\nusing this:\n  vars_of t \\<subseteq> vars_of_lit L\n  \\<forall>x\\<in>vars_of_lit L.\n     lower_or_eq (Var x \\<lhd> \\<sigma>) (Var x \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of t.\n       lower_or_eq (Var x \\<lhd> \\<sigma>) (Var x \\<lhd> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  lower_on \\<sigma> \\<eta> (vars_of t)\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "from \\<open>vars_of s \\<subseteq> vars_of_lit L\\<close> and assms(1)"], ["proof (chain)\npicking this:\n  vars_of s \\<subseteq> vars_of_lit L\n  lower_on \\<sigma> \\<eta> (vars_of_lit L)", "have \"lower_on \\<sigma> \\<eta> (vars_of s)\""], ["proof (prove)\nusing this:\n  vars_of s \\<subseteq> vars_of_lit L\n  lower_on \\<sigma> \\<eta> (vars_of_lit L)\n\ngoal (1 subgoal):\n 1. lower_on \\<sigma> \\<eta> (vars_of s)", "unfolding lower_on_def"], ["proof (prove)\nusing this:\n  vars_of s \\<subseteq> vars_of_lit L\n  \\<forall>x\\<in>vars_of_lit L.\n     lower_or_eq (Var x \\<lhd> \\<sigma>) (Var x \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of s.\n       lower_or_eq (Var x \\<lhd> \\<sigma>) (Var x \\<lhd> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  lower_on \\<sigma> \\<eta> (vars_of s)\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "have all_lower: \"\\<forall>u. (u \\<in># (mset_lit L) \\<longrightarrow> (((subst  u \\<sigma>), (subst u \\<eta>)) \\<in> trm_ord \n  \\<or> (subst  u \\<sigma>) = (subst u \\<eta>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u.\n       u \\<in># mset_lit L \\<longrightarrow>\n       (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n       u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>", "proof  (rule allI,rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in># mset_lit L \\<Longrightarrow>\n       (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n       u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in># mset_lit L \\<Longrightarrow>\n       (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n       u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>", "assume \"u \\<in># (mset_lit L)\""], ["proof (state)\nthis:\n  u \\<in># mset_lit L\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in># mset_lit L \\<Longrightarrow>\n       (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n       u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>", "have \"u = t \\<or> u = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = t \\<or> u = s", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> u = t \\<or> u = s\n 2. \\<not> ?P \\<Longrightarrow> u = t \\<or> u = s", "assume \"mset_lit L = {# t,s #}\""], ["proof (state)\nthis:\n  mset_lit L = {#t, s#}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> u = t \\<or> u = s\n 2. \\<not> ?P \\<Longrightarrow> u = t \\<or> u = s", "from this and \\<open>u \\<in># (mset_lit L)\\<close>"], ["proof (chain)\npicking this:\n  mset_lit L = {#t, s#}\n  u \\<in># mset_lit L", "show ?thesis"], ["proof (prove)\nusing this:\n  mset_lit L = {#t, s#}\n  u \\<in># mset_lit L\n\ngoal (1 subgoal):\n 1. u = t \\<or> u = s", "by (simp add: count_single insert_DiffM2 insert_noteq_member not_gr0)"], ["proof (state)\nthis:\n  u = t \\<or> u = s\n\ngoal (1 subgoal):\n 1. mset_lit L \\<noteq> {#t, s#} \\<Longrightarrow> u = t \\<or> u = s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mset_lit L \\<noteq> {#t, s#} \\<Longrightarrow> u = t \\<or> u = s", "assume \"\\<not>mset_lit L = {# t,s #}\""], ["proof (state)\nthis:\n  mset_lit L \\<noteq> {#t, s#}\n\ngoal (1 subgoal):\n 1. mset_lit L \\<noteq> {#t, s#} \\<Longrightarrow> u = t \\<or> u = s", "from this and def_ms_l"], ["proof (chain)\npicking this:\n  mset_lit L \\<noteq> {#t, s#}\n  mset_lit L = {#t, s#} \\<or> mset_lit L = {#t, t, s, s#}", "have \"mset_lit L = {# t,t,s,s #}\""], ["proof (prove)\nusing this:\n  mset_lit L \\<noteq> {#t, s#}\n  mset_lit L = {#t, s#} \\<or> mset_lit L = {#t, t, s, s#}\n\ngoal (1 subgoal):\n 1. mset_lit L = {#t, t, s, s#}", "by auto"], ["proof (state)\nthis:\n  mset_lit L = {#t, t, s, s#}\n\ngoal (1 subgoal):\n 1. mset_lit L \\<noteq> {#t, s#} \\<Longrightarrow> u = t \\<or> u = s", "from this and \\<open>u \\<in># (mset_lit L)\\<close>"], ["proof (chain)\npicking this:\n  mset_lit L = {#t, t, s, s#}\n  u \\<in># mset_lit L", "show ?thesis"], ["proof (prove)\nusing this:\n  mset_lit L = {#t, t, s, s#}\n  u \\<in># mset_lit L\n\ngoal (1 subgoal):\n 1. u = t \\<or> u = s", "using not_gr0"], ["proof (prove)\nusing this:\n  mset_lit L = {#t, t, s, s#}\n  u \\<in># mset_lit L\n  (\\<not> 0 < ?n) = (?n = 0)\n\ngoal (1 subgoal):\n 1. u = t \\<or> u = s", "by fastforce"], ["proof (state)\nthis:\n  u = t \\<or> u = s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u = t \\<or> u = s\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in># mset_lit L \\<Longrightarrow>\n       (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n       u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>", "then"], ["proof (chain)\npicking this:\n  u = t \\<or> u = s", "show \"(((subst  u \\<sigma>), (subst u \\<eta>)) \\<in> trm_ord \n  \\<or> (subst  u \\<sigma>) = (subst u \\<eta>))\""], ["proof (prove)\nusing this:\n  u = t \\<or> u = s\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n    u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. u = t \\<Longrightarrow>\n    (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n    u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>\n 2. u = s \\<Longrightarrow>\n    (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n    u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>", "assume \"u = t\""], ["proof (state)\nthis:\n  u = t\n\ngoal (2 subgoals):\n 1. u = t \\<Longrightarrow>\n    (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n    u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>\n 2. u = s \\<Longrightarrow>\n    (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n    u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>", "from \\<open>lower_on \\<sigma> \\<eta> (vars_of t)\\<close>"], ["proof (chain)\npicking this:\n  lower_on \\<sigma> \\<eta> (vars_of t)", "have \"lower_or_eq (subst t \\<sigma>) (subst t \\<eta>)\""], ["proof (prove)\nusing this:\n  lower_on \\<sigma> \\<eta> (vars_of t)\n\ngoal (1 subgoal):\n 1. lower_or_eq (t \\<lhd> \\<sigma>) (t \\<lhd> \\<eta>)", "using lower_on_term"], ["proof (prove)\nusing this:\n  lower_on \\<sigma> \\<eta> (vars_of t)\n  lower_on ?\\<sigma> ?\\<eta> (vars_of ?t) \\<Longrightarrow>\n  lower_or_eq (?t \\<lhd> ?\\<sigma>) (?t \\<lhd> ?\\<eta>)\n\ngoal (1 subgoal):\n 1. lower_or_eq (t \\<lhd> \\<sigma>) (t \\<lhd> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  lower_or_eq (t \\<lhd> \\<sigma>) (t \\<lhd> \\<eta>)\n\ngoal (2 subgoals):\n 1. u = t \\<Longrightarrow>\n    (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n    u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>\n 2. u = s \\<Longrightarrow>\n    (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n    u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>", "from this"], ["proof (chain)\npicking this:\n  lower_or_eq (t \\<lhd> \\<sigma>) (t \\<lhd> \\<eta>)", "show ?thesis"], ["proof (prove)\nusing this:\n  lower_or_eq (t \\<lhd> \\<sigma>) (t \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n    u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>", "unfolding lower_or_eq_def"], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> = t \\<lhd> \\<eta> \\<or>\n  (t \\<lhd> \\<sigma>, t \\<lhd> \\<eta>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n    u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>", "using \\<open>u = t\\<close>"], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> = t \\<lhd> \\<eta> \\<or>\n  (t \\<lhd> \\<sigma>, t \\<lhd> \\<eta>) \\<in> trm_ord\n  u = t\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n    u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n  u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. u = s \\<Longrightarrow>\n    (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n    u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u = s \\<Longrightarrow>\n    (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n    u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>", "assume \"u = s\""], ["proof (state)\nthis:\n  u = s\n\ngoal (1 subgoal):\n 1. u = s \\<Longrightarrow>\n    (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n    u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>", "from \\<open>lower_on \\<sigma> \\<eta> (vars_of s)\\<close>"], ["proof (chain)\npicking this:\n  lower_on \\<sigma> \\<eta> (vars_of s)", "have \"lower_or_eq (subst s \\<sigma>) (subst s \\<eta>)\""], ["proof (prove)\nusing this:\n  lower_on \\<sigma> \\<eta> (vars_of s)\n\ngoal (1 subgoal):\n 1. lower_or_eq (s \\<lhd> \\<sigma>) (s \\<lhd> \\<eta>)", "using lower_on_term"], ["proof (prove)\nusing this:\n  lower_on \\<sigma> \\<eta> (vars_of s)\n  lower_on ?\\<sigma> ?\\<eta> (vars_of ?t) \\<Longrightarrow>\n  lower_or_eq (?t \\<lhd> ?\\<sigma>) (?t \\<lhd> ?\\<eta>)\n\ngoal (1 subgoal):\n 1. lower_or_eq (s \\<lhd> \\<sigma>) (s \\<lhd> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  lower_or_eq (s \\<lhd> \\<sigma>) (s \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. u = s \\<Longrightarrow>\n    (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n    u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>", "from this"], ["proof (chain)\npicking this:\n  lower_or_eq (s \\<lhd> \\<sigma>) (s \\<lhd> \\<eta>)", "show ?thesis"], ["proof (prove)\nusing this:\n  lower_or_eq (s \\<lhd> \\<sigma>) (s \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n    u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>", "unfolding lower_or_eq_def"], ["proof (prove)\nusing this:\n  s \\<lhd> \\<sigma> = s \\<lhd> \\<eta> \\<or>\n  (s \\<lhd> \\<sigma>, s \\<lhd> \\<eta>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n    u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>", "using \\<open>u = s\\<close>"], ["proof (prove)\nusing this:\n  s \\<lhd> \\<sigma> = s \\<lhd> \\<eta> \\<or>\n  (s \\<lhd> \\<sigma>, s \\<lhd> \\<eta>) \\<in> trm_ord\n  u = s\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n    u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n  u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n  u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>u.\n     u \\<in># mset_lit L \\<longrightarrow>\n     (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n     u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "have sl_exists: \"\\<exists>u. (u \\<in># (mset_lit L) \\<and> ((subst u \\<sigma>), (subst u \\<eta>)) \\<in> trm_ord)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u.\n       u \\<in># mset_lit L \\<and>\n       (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>u.\n       u \\<in># mset_lit L \\<and>\n       (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord", "from \\<open>x \\<in> vars_of_lit L\\<close> and def_l"], ["proof (chain)\npicking this:\n  x \\<in> vars_of_lit L\n  L = Pos (Eq t s) \\<or> L = Neg (Eq t s)", "have \n      \"x \\<in> vars_of t \\<or> x \\<in> vars_of s\""], ["proof (prove)\nusing this:\n  x \\<in> vars_of_lit L\n  L = Pos (Eq t s) \\<or> L = Neg (Eq t s)\n\ngoal (1 subgoal):\n 1. x \\<in> vars_of t \\<or> x \\<in> vars_of s", "by auto"], ["proof (state)\nthis:\n  x \\<in> vars_of t \\<or> x \\<in> vars_of s\n\ngoal (1 subgoal):\n 1. \\<exists>u.\n       u \\<in># mset_lit L \\<and>\n       (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord", "then"], ["proof (chain)\npicking this:\n  x \\<in> vars_of t \\<or> x \\<in> vars_of s", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> vars_of t \\<or> x \\<in> vars_of s\n\ngoal (1 subgoal):\n 1. \\<exists>u.\n       u \\<in># mset_lit L \\<and>\n       (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> vars_of t \\<Longrightarrow>\n    \\<exists>u.\n       u \\<in># mset_lit L \\<and>\n       (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord\n 2. x \\<in> vars_of s \\<Longrightarrow>\n    \\<exists>u.\n       u \\<in># mset_lit L \\<and>\n       (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord", "assume \"x \\<in> vars_of t\""], ["proof (state)\nthis:\n  x \\<in> vars_of t\n\ngoal (2 subgoals):\n 1. x \\<in> vars_of t \\<Longrightarrow>\n    \\<exists>u.\n       u \\<in># mset_lit L \\<and>\n       (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord\n 2. x \\<in> vars_of s \\<Longrightarrow>\n    \\<exists>u.\n       u \\<in># mset_lit L \\<and>\n       (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord", "from this and \\<open>lower_on \\<sigma> \\<eta> (vars_of t)\\<close> assms(1) assms(2)"], ["proof (chain)\npicking this:\n  x \\<in> vars_of t\n  lower_on \\<sigma> \\<eta> (vars_of t)\n  lower_on \\<sigma> \\<eta> (vars_of_lit L)\n  (Var x \\<lhd> \\<sigma>, Var x \\<lhd> \\<eta>) \\<in> trm_ord", "have \"( (subst t \\<sigma>),(subst t \\<eta>)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  x \\<in> vars_of t\n  lower_on \\<sigma> \\<eta> (vars_of t)\n  lower_on \\<sigma> \\<eta> (vars_of_lit L)\n  (Var x \\<lhd> \\<sigma>, Var x \\<lhd> \\<eta>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, t \\<lhd> \\<eta>) \\<in> trm_ord", "using lower_subst_yields_lower_trms"], ["proof (prove)\nusing this:\n  x \\<in> vars_of t\n  lower_on \\<sigma> \\<eta> (vars_of t)\n  lower_on \\<sigma> \\<eta> (vars_of_lit L)\n  (Var x \\<lhd> \\<sigma>, Var x \\<lhd> \\<eta>) \\<in> trm_ord\n  \\<lbrakk>lower_on ?\\<sigma> ?\\<eta> (vars_of ?t);\n   (Var ?x \\<lhd> ?\\<sigma>, Var ?x \\<lhd> ?\\<eta>) \\<in> trm_ord;\n   ?x \\<in> vars_of ?t\\<rbrakk>\n  \\<Longrightarrow> (?t \\<lhd> ?\\<sigma>, ?t \\<lhd> ?\\<eta>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, t \\<lhd> \\<eta>) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (t \\<lhd> \\<sigma>, t \\<lhd> \\<eta>) \\<in> trm_ord\n\ngoal (2 subgoals):\n 1. x \\<in> vars_of t \\<Longrightarrow>\n    \\<exists>u.\n       u \\<in># mset_lit L \\<and>\n       (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord\n 2. x \\<in> vars_of s \\<Longrightarrow>\n    \\<exists>u.\n       u \\<in># mset_lit L \\<and>\n       (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord", "from this and \\<open>t \\<in># (mset_lit L)\\<close>"], ["proof (chain)\npicking this:\n  (t \\<lhd> \\<sigma>, t \\<lhd> \\<eta>) \\<in> trm_ord\n  t \\<in># mset_lit L", "show ?thesis"], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<sigma>, t \\<lhd> \\<eta>) \\<in> trm_ord\n  t \\<in># mset_lit L\n\ngoal (1 subgoal):\n 1. \\<exists>u.\n       u \\<in># mset_lit L \\<and>\n       (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  \\<exists>u.\n     u \\<in># mset_lit L \\<and>\n     (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. x \\<in> vars_of s \\<Longrightarrow>\n    \\<exists>u.\n       u \\<in># mset_lit L \\<and>\n       (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> vars_of s \\<Longrightarrow>\n    \\<exists>u.\n       u \\<in># mset_lit L \\<and>\n       (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord", "assume \"x \\<in> vars_of s\""], ["proof (state)\nthis:\n  x \\<in> vars_of s\n\ngoal (1 subgoal):\n 1. x \\<in> vars_of s \\<Longrightarrow>\n    \\<exists>u.\n       u \\<in># mset_lit L \\<and>\n       (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord", "from this and \\<open>lower_on \\<sigma> \\<eta> (vars_of s)\\<close> assms(1) assms(2)"], ["proof (chain)\npicking this:\n  x \\<in> vars_of s\n  lower_on \\<sigma> \\<eta> (vars_of s)\n  lower_on \\<sigma> \\<eta> (vars_of_lit L)\n  (Var x \\<lhd> \\<sigma>, Var x \\<lhd> \\<eta>) \\<in> trm_ord", "have \"( (subst s \\<sigma>),(subst s \\<eta>)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  x \\<in> vars_of s\n  lower_on \\<sigma> \\<eta> (vars_of s)\n  lower_on \\<sigma> \\<eta> (vars_of_lit L)\n  (Var x \\<lhd> \\<sigma>, Var x \\<lhd> \\<eta>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (s \\<lhd> \\<sigma>, s \\<lhd> \\<eta>) \\<in> trm_ord", "using lower_subst_yields_lower_trms"], ["proof (prove)\nusing this:\n  x \\<in> vars_of s\n  lower_on \\<sigma> \\<eta> (vars_of s)\n  lower_on \\<sigma> \\<eta> (vars_of_lit L)\n  (Var x \\<lhd> \\<sigma>, Var x \\<lhd> \\<eta>) \\<in> trm_ord\n  \\<lbrakk>lower_on ?\\<sigma> ?\\<eta> (vars_of ?t);\n   (Var ?x \\<lhd> ?\\<sigma>, Var ?x \\<lhd> ?\\<eta>) \\<in> trm_ord;\n   ?x \\<in> vars_of ?t\\<rbrakk>\n  \\<Longrightarrow> (?t \\<lhd> ?\\<sigma>, ?t \\<lhd> ?\\<eta>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (s \\<lhd> \\<sigma>, s \\<lhd> \\<eta>) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (s \\<lhd> \\<sigma>, s \\<lhd> \\<eta>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. x \\<in> vars_of s \\<Longrightarrow>\n    \\<exists>u.\n       u \\<in># mset_lit L \\<and>\n       (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord", "from this and \\<open>s \\<in># (mset_lit L)\\<close>"], ["proof (chain)\npicking this:\n  (s \\<lhd> \\<sigma>, s \\<lhd> \\<eta>) \\<in> trm_ord\n  s \\<in># mset_lit L", "show ?thesis"], ["proof (prove)\nusing this:\n  (s \\<lhd> \\<sigma>, s \\<lhd> \\<eta>) \\<in> trm_ord\n  s \\<in># mset_lit L\n\ngoal (1 subgoal):\n 1. \\<exists>u.\n       u \\<in># mset_lit L \\<and>\n       (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  \\<exists>u.\n     u \\<in># mset_lit L \\<and>\n     (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>u.\n     u \\<in># mset_lit L \\<and>\n     (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>u.\n     u \\<in># mset_lit L \\<and>\n     (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "from all_lower sl_exists and \n  \\<open>mset_lit (subst_lit L \\<sigma>) = {# (subst u \\<sigma>). u \\<in># (mset_lit L) #}\\<close> \n  \\<open>mset_lit (subst_lit L \\<eta>) = {# (subst u \\<eta>). u \\<in># (mset_lit L) #}\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>u.\n     u \\<in># mset_lit L \\<longrightarrow>\n     (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n     u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>\n  \\<exists>u.\n     u \\<in># mset_lit L \\<and>\n     (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord\n  mset_lit (subst_lit L \\<sigma>) =\n  {#u \\<lhd> \\<sigma>. u \\<in># mset_lit L#}\n  mset_lit (subst_lit L \\<eta>) = {#u \\<lhd> \\<eta>. u \\<in># mset_lit L#}", "have \"(?M1,?M2) \\<in> (mult trm_ord)\""], ["proof (prove)\nusing this:\n  \\<forall>u.\n     u \\<in># mset_lit L \\<longrightarrow>\n     (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n     u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>\n  \\<exists>u.\n     u \\<in># mset_lit L \\<and>\n     (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord\n  mset_lit (subst_lit L \\<sigma>) =\n  {#u \\<lhd> \\<sigma>. u \\<in># mset_lit L#}\n  mset_lit (subst_lit L \\<eta>) = {#u \\<lhd> \\<eta>. u \\<in># mset_lit L#}\n\ngoal (1 subgoal):\n 1. (mset_lit (subst_lit L \\<sigma>), mset_lit (subst_lit L \\<eta>))\n    \\<in> mult trm_ord", "using trm_ord_irrefl image_mset_ordering \n                        [of ?M1 \"\\<lambda>x. (subst x \\<sigma>)\" ?L ?M2 \"\\<lambda>x. (subst x \\<eta>)\" trm_ord]"], ["proof (prove)\nusing this:\n  \\<forall>u.\n     u \\<in># mset_lit L \\<longrightarrow>\n     (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n     u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>\n  \\<exists>u.\n     u \\<in># mset_lit L \\<and>\n     (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord\n  mset_lit (subst_lit L \\<sigma>) =\n  {#u \\<lhd> \\<sigma>. u \\<in># mset_lit L#}\n  mset_lit (subst_lit L \\<eta>) = {#u \\<lhd> \\<eta>. u \\<in># mset_lit L#}\n  irrefl trm_ord\n  \\<lbrakk>mset_lit (subst_lit L \\<sigma>) =\n           {#u \\<lhd> \\<sigma>. u \\<in># mset_lit L#};\n   mset_lit (subst_lit L \\<eta>) = {#u \\<lhd> \\<eta>. u \\<in># mset_lit L#};\n   \\<forall>u.\n      u \\<in># mset_lit L \\<longrightarrow>\n      (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord \\<or>\n      u \\<lhd> \\<sigma> = u \\<lhd> \\<eta>;\n   \\<exists>u.\n      u \\<in># mset_lit L \\<and>\n      (u \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord;\n   irrefl trm_ord\\<rbrakk>\n  \\<Longrightarrow> (mset_lit (subst_lit L \\<sigma>),\n                     mset_lit (subst_lit L \\<eta>))\n                    \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. (mset_lit (subst_lit L \\<sigma>), mset_lit (subst_lit L \\<eta>))\n    \\<in> mult trm_ord", "by blast"], ["proof (state)\nthis:\n  (mset_lit (subst_lit L \\<sigma>), mset_lit (subst_lit L \\<eta>))\n  \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  (mset_lit (subst_lit L \\<sigma>), mset_lit (subst_lit L \\<eta>))\n  \\<in> mult trm_ord", "show ?thesis"], ["proof (prove)\nusing this:\n  (mset_lit (subst_lit L \\<sigma>), mset_lit (subst_lit L \\<eta>))\n  \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "unfolding lit_ord_def"], ["proof (prove)\nusing this:\n  (mset_lit (subst_lit L \\<sigma>), mset_lit (subst_lit L \\<eta>))\n  \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit L \\<eta>)\n    \\<in> {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}", "by auto"], ["proof (state)\nthis:\n  (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lower_on_lit_eq:\n  assumes \"lower_on \\<sigma> \\<eta> (vars_of_lit L)\"\n  shows \"((subst_lit L \\<sigma>) = (subst_lit L \\<eta>)) \\<or> ((subst_lit L \\<sigma>), (subst_lit L \\<eta>)) \\<in> lit_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_lit L \\<sigma> = subst_lit L \\<eta> \\<or>\n    (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    subst_lit L \\<sigma> = subst_lit L \\<eta> \\<or>\n    (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord\n 2. \\<not> ?P \\<Longrightarrow>\n    subst_lit L \\<sigma> = subst_lit L \\<eta> \\<or>\n    (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "assume \"coincide_on \\<sigma> \\<eta> (vars_of_lit L)\""], ["proof (state)\nthis:\n  coincide_on \\<sigma> \\<eta> (vars_of_lit L)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    subst_lit L \\<sigma> = subst_lit L \\<eta> \\<or>\n    (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord\n 2. \\<not> ?P \\<Longrightarrow>\n    subst_lit L \\<sigma> = subst_lit L \\<eta> \\<or>\n    (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "then"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma> \\<eta> (vars_of_lit L)", "show ?thesis"], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> \\<eta> (vars_of_lit L)\n\ngoal (1 subgoal):\n 1. subst_lit L \\<sigma> = subst_lit L \\<eta> \\<or>\n    (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "using coincide_on_lit"], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> \\<eta> (vars_of_lit L)\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of_lit ?l) \\<Longrightarrow>\n  subst_lit ?l ?\\<sigma> = subst_lit ?l ?\\<eta>\n\ngoal (1 subgoal):\n 1. subst_lit L \\<sigma> = subst_lit L \\<eta> \\<or>\n    (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "by auto"], ["proof (state)\nthis:\n  subst_lit L \\<sigma> = subst_lit L \\<eta> \\<or>\n  (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. \\<not> coincide_on \\<sigma> \\<eta> (vars_of_lit L) \\<Longrightarrow>\n    subst_lit L \\<sigma> = subst_lit L \\<eta> \\<or>\n    (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> coincide_on \\<sigma> \\<eta> (vars_of_lit L) \\<Longrightarrow>\n    subst_lit L \\<sigma> = subst_lit L \\<eta> \\<or>\n    (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "assume \"\\<not>coincide_on \\<sigma> \\<eta> (vars_of_lit L)\""], ["proof (state)\nthis:\n  \\<not> coincide_on \\<sigma> \\<eta> (vars_of_lit L)\n\ngoal (1 subgoal):\n 1. \\<not> coincide_on \\<sigma> \\<eta> (vars_of_lit L) \\<Longrightarrow>\n    subst_lit L \\<sigma> = subst_lit L \\<eta> \\<or>\n    (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "then"], ["proof (chain)\npicking this:\n  \\<not> coincide_on \\<sigma> \\<eta> (vars_of_lit L)", "obtain x where \"x \\<in> vars_of_lit L\" \n    and \"(subst (Var x) \\<sigma>) \\<noteq> (subst (Var x) \\<eta>)\""], ["proof (prove)\nusing this:\n  \\<not> coincide_on \\<sigma> \\<eta> (vars_of_lit L)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> vars_of_lit L;\n         Var x \\<lhd> \\<sigma> \\<noteq> Var x \\<lhd> \\<eta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x\\<in>vars_of_lit L.\n             Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> vars_of_lit L;\n         Var x \\<lhd> \\<sigma> \\<noteq> Var x \\<lhd> \\<eta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> vars_of_lit L\n  Var x \\<lhd> \\<sigma> \\<noteq> Var x \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> coincide_on \\<sigma> \\<eta> (vars_of_lit L) \\<Longrightarrow>\n    subst_lit L \\<sigma> = subst_lit L \\<eta> \\<or>\n    (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "from \\<open>x \\<in> vars_of_lit L\\<close> assms(1) \n  \\<open>(subst (Var x) \\<sigma>) \\<noteq> (subst (Var x) \\<eta>)\\<close>and assms(1)"], ["proof (chain)\npicking this:\n  x \\<in> vars_of_lit L\n  lower_on \\<sigma> \\<eta> (vars_of_lit L)\n  Var x \\<lhd> \\<sigma> \\<noteq> Var x \\<lhd> \\<eta>\n  lower_on \\<sigma> \\<eta> (vars_of_lit L)", "have \"((subst (Var x) \\<sigma>),(subst (Var x) \\<eta>)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  x \\<in> vars_of_lit L\n  lower_on \\<sigma> \\<eta> (vars_of_lit L)\n  Var x \\<lhd> \\<sigma> \\<noteq> Var x \\<lhd> \\<eta>\n  lower_on \\<sigma> \\<eta> (vars_of_lit L)\n\ngoal (1 subgoal):\n 1. (Var x \\<lhd> \\<sigma>, Var x \\<lhd> \\<eta>) \\<in> trm_ord", "unfolding lower_on_def lower_or_eq_def"], ["proof (prove)\nusing this:\n  x \\<in> vars_of_lit L\n  \\<forall>x\\<in>vars_of_lit L.\n     Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<eta> \\<or>\n     (Var x \\<lhd> \\<sigma>, Var x \\<lhd> \\<eta>) \\<in> trm_ord\n  Var x \\<lhd> \\<sigma> \\<noteq> Var x \\<lhd> \\<eta>\n  \\<forall>x\\<in>vars_of_lit L.\n     Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<eta> \\<or>\n     (Var x \\<lhd> \\<sigma>, Var x \\<lhd> \\<eta>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (Var x \\<lhd> \\<sigma>, Var x \\<lhd> \\<eta>) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (Var x \\<lhd> \\<sigma>, Var x \\<lhd> \\<eta>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> coincide_on \\<sigma> \\<eta> (vars_of_lit L) \\<Longrightarrow>\n    subst_lit L \\<sigma> = subst_lit L \\<eta> \\<or>\n    (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "from this assms(1) \\<open>x \\<in> vars_of_lit L\\<close>"], ["proof (chain)\npicking this:\n  (Var x \\<lhd> \\<sigma>, Var x \\<lhd> \\<eta>) \\<in> trm_ord\n  lower_on \\<sigma> \\<eta> (vars_of_lit L)\n  x \\<in> vars_of_lit L", "show ?thesis"], ["proof (prove)\nusing this:\n  (Var x \\<lhd> \\<sigma>, Var x \\<lhd> \\<eta>) \\<in> trm_ord\n  lower_on \\<sigma> \\<eta> (vars_of_lit L)\n  x \\<in> vars_of_lit L\n\ngoal (1 subgoal):\n 1. subst_lit L \\<sigma> = subst_lit L \\<eta> \\<or>\n    (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "using lower_on_lit"], ["proof (prove)\nusing this:\n  (Var x \\<lhd> \\<sigma>, Var x \\<lhd> \\<eta>) \\<in> trm_ord\n  lower_on \\<sigma> \\<eta> (vars_of_lit L)\n  x \\<in> vars_of_lit L\n  \\<lbrakk>lower_on ?\\<sigma> ?\\<eta> (vars_of_lit ?L);\n   (Var ?x \\<lhd> ?\\<sigma>, Var ?x \\<lhd> ?\\<eta>) \\<in> trm_ord;\n   ?x \\<in> vars_of_lit ?L\\<rbrakk>\n  \\<Longrightarrow> (subst_lit ?L ?\\<sigma>, subst_lit ?L ?\\<eta>)\n                    \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. subst_lit L \\<sigma> = subst_lit L \\<eta> \\<or>\n    (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord", "by auto"], ["proof (state)\nthis:\n  subst_lit L \\<sigma> = subst_lit L \\<eta> \\<or>\n  (subst_lit L \\<sigma>, subst_lit L \\<eta>) \\<in> lit_ord\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lower_on_cl:\n  assumes \"lower_on \\<sigma> \\<eta> (vars_of_cl (cl_ecl C))\"\n  assumes \"((subst (Var x) \\<sigma>),(subst (Var x) \\<eta>)) \\<in> trm_ord\"\n  assumes \"x \\<in> vars_of_cl (cl_ecl C)\"\n  assumes \"finite (cl_ecl C)\"\n  shows \"((C,\\<sigma>), (C, \\<eta>)) \\<in> ecl_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((C, \\<sigma>), C, \\<eta>) \\<in> ecl_ord", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((C, \\<sigma>), C, \\<eta>) \\<in> ecl_ord", "let ?M1 = \"mset_ecl (C,\\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((C, \\<sigma>), C, \\<eta>) \\<in> ecl_ord", "let ?M2 = \"mset_ecl (C,\\<eta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((C, \\<sigma>), C, \\<eta>) \\<in> ecl_ord", "let ?M = \"(mset_set (cl_ecl C))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((C, \\<sigma>), C, \\<eta>) \\<in> ecl_ord", "let ?f1 = \"\\<lambda>x. (mset_lit (subst_lit x \\<sigma>))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((C, \\<sigma>), C, \\<eta>) \\<in> ecl_ord", "let ?f2 = \"\\<lambda>x. (mset_lit (subst_lit x \\<eta>))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((C, \\<sigma>), C, \\<eta>) \\<in> ecl_ord", "have \"?M1 = {# (?f1 u). u \\<in># ?M #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_ecl (C, \\<sigma>) =\n    {#mset_lit (subst_lit u \\<sigma>). u \\<in># mset_set (cl_ecl C)#}", "using mset_ecl.simps"], ["proof (prove)\nusing this:\n  mset_ecl (?C, ?\\<sigma>) =\n  {#mset_lit (subst_lit x ?\\<sigma>). x \\<in># mset_set (cl_ecl ?C)#}\n\ngoal (1 subgoal):\n 1. mset_ecl (C, \\<sigma>) =\n    {#mset_lit (subst_lit u \\<sigma>). u \\<in># mset_set (cl_ecl C)#}", "by blast"], ["proof (state)\nthis:\n  mset_ecl (C, \\<sigma>) =\n  {#mset_lit (subst_lit u \\<sigma>). u \\<in># mset_set (cl_ecl C)#}\n\ngoal (1 subgoal):\n 1. ((C, \\<sigma>), C, \\<eta>) \\<in> ecl_ord", "have \"?M2 = {# (?f2 u). u \\<in># ?M #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_ecl (C, \\<eta>) =\n    {#mset_lit (subst_lit u \\<eta>). u \\<in># mset_set (cl_ecl C)#}", "using mset_ecl.simps"], ["proof (prove)\nusing this:\n  mset_ecl (?C, ?\\<sigma>) =\n  {#mset_lit (subst_lit x ?\\<sigma>). x \\<in># mset_set (cl_ecl ?C)#}\n\ngoal (1 subgoal):\n 1. mset_ecl (C, \\<eta>) =\n    {#mset_lit (subst_lit u \\<eta>). u \\<in># mset_set (cl_ecl C)#}", "by blast"], ["proof (state)\nthis:\n  mset_ecl (C, \\<eta>) =\n  {#mset_lit (subst_lit u \\<eta>). u \\<in># mset_set (cl_ecl C)#}\n\ngoal (1 subgoal):\n 1. ((C, \\<sigma>), C, \\<eta>) \\<in> ecl_ord", "have i: \"\\<forall>u. (u \\<in># ?M \\<longrightarrow> (((?f1 u), (?f2 u)) \\<in> (mult trm_ord) \\<or> (?f1 u) = (?f2 u)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u.\n       u \\<in># mset_set (cl_ecl C) \\<longrightarrow>\n       (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n       \\<in> mult trm_ord \\<or>\n       mset_lit (subst_lit u \\<sigma>) = mset_lit (subst_lit u \\<eta>)", "proof ((rule allI),(rule impI))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in># mset_set (cl_ecl C) \\<Longrightarrow>\n       (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n       \\<in> mult trm_ord \\<or>\n       mset_lit (subst_lit u \\<sigma>) = mset_lit (subst_lit u \\<eta>)", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in># mset_set (cl_ecl C) \\<Longrightarrow>\n       (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n       \\<in> mult trm_ord \\<or>\n       mset_lit (subst_lit u \\<sigma>) = mset_lit (subst_lit u \\<eta>)", "assume \"u \\<in># ?M\""], ["proof (state)\nthis:\n  u \\<in># mset_set (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in># mset_set (cl_ecl C) \\<Longrightarrow>\n       (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n       \\<in> mult trm_ord \\<or>\n       mset_lit (subst_lit u \\<sigma>) = mset_lit (subst_lit u \\<eta>)", "from this"], ["proof (chain)\npicking this:\n  u \\<in># mset_set (cl_ecl C)", "have \"u \\<in> (cl_ecl C)\""], ["proof (prove)\nusing this:\n  u \\<in># mset_set (cl_ecl C)\n\ngoal (1 subgoal):\n 1. u \\<in> cl_ecl C", "using count_mset_set(3)"], ["proof (prove)\nusing this:\n  u \\<in># mset_set (cl_ecl C)\n  ?x \\<notin> ?A \\<Longrightarrow> count (mset_set ?A) ?x = 0\n\ngoal (1 subgoal):\n 1. u \\<in> cl_ecl C", "by (simp add: assms(4))"], ["proof (state)\nthis:\n  u \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in># mset_set (cl_ecl C) \\<Longrightarrow>\n       (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n       \\<in> mult trm_ord \\<or>\n       mset_lit (subst_lit u \\<sigma>) = mset_lit (subst_lit u \\<eta>)", "from this and assms(1)"], ["proof (chain)\npicking this:\n  u \\<in> cl_ecl C\n  lower_on \\<sigma> \\<eta> (vars_of_cl (cl_ecl C))", "have \"lower_on \\<sigma> \\<eta> (vars_of_lit u)\""], ["proof (prove)\nusing this:\n  u \\<in> cl_ecl C\n  lower_on \\<sigma> \\<eta> (vars_of_cl (cl_ecl C))\n\ngoal (1 subgoal):\n 1. lower_on \\<sigma> \\<eta> (vars_of_lit u)", "unfolding lower_on_def"], ["proof (prove)\nusing this:\n  u \\<in> cl_ecl C\n  \\<forall>x\\<in>vars_of_cl (cl_ecl C).\n     lower_or_eq (Var x \\<lhd> \\<sigma>) (Var x \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of_lit u.\n       lower_or_eq (Var x \\<lhd> \\<sigma>) (Var x \\<lhd> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  lower_on \\<sigma> \\<eta> (vars_of_lit u)\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in># mset_set (cl_ecl C) \\<Longrightarrow>\n       (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n       \\<in> mult trm_ord \\<or>\n       mset_lit (subst_lit u \\<sigma>) = mset_lit (subst_lit u \\<eta>)", "then"], ["proof (chain)\npicking this:\n  lower_on \\<sigma> \\<eta> (vars_of_lit u)", "have \"((subst_lit u \\<sigma>) = (subst_lit u \\<eta>)) \n      \\<or> ((subst_lit u \\<sigma>), (subst_lit u \\<eta>)) \\<in> lit_ord\""], ["proof (prove)\nusing this:\n  lower_on \\<sigma> \\<eta> (vars_of_lit u)\n\ngoal (1 subgoal):\n 1. subst_lit u \\<sigma> = subst_lit u \\<eta> \\<or>\n    (subst_lit u \\<sigma>, subst_lit u \\<eta>) \\<in> lit_ord", "using lower_on_lit_eq"], ["proof (prove)\nusing this:\n  lower_on \\<sigma> \\<eta> (vars_of_lit u)\n  lower_on ?\\<sigma> ?\\<eta> (vars_of_lit ?L) \\<Longrightarrow>\n  subst_lit ?L ?\\<sigma> = subst_lit ?L ?\\<eta> \\<or>\n  (subst_lit ?L ?\\<sigma>, subst_lit ?L ?\\<eta>) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. subst_lit u \\<sigma> = subst_lit u \\<eta> \\<or>\n    (subst_lit u \\<sigma>, subst_lit u \\<eta>) \\<in> lit_ord", "by blast"], ["proof (state)\nthis:\n  subst_lit u \\<sigma> = subst_lit u \\<eta> \\<or>\n  (subst_lit u \\<sigma>, subst_lit u \\<eta>) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in># mset_set (cl_ecl C) \\<Longrightarrow>\n       (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n       \\<in> mult trm_ord \\<or>\n       mset_lit (subst_lit u \\<sigma>) = mset_lit (subst_lit u \\<eta>)", "from this"], ["proof (chain)\npicking this:\n  subst_lit u \\<sigma> = subst_lit u \\<eta> \\<or>\n  (subst_lit u \\<sigma>, subst_lit u \\<eta>) \\<in> lit_ord", "show \"(((?f1 u), (?f2 u)) \\<in> (mult trm_ord) \\<or> (?f1 u) = (?f2 u))\""], ["proof (prove)\nusing this:\n  subst_lit u \\<sigma> = subst_lit u \\<eta> \\<or>\n  (subst_lit u \\<sigma>, subst_lit u \\<eta>) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n    \\<in> mult trm_ord \\<or>\n    mset_lit (subst_lit u \\<sigma>) = mset_lit (subst_lit u \\<eta>)", "unfolding lit_ord_def"], ["proof (prove)\nusing this:\n  subst_lit u \\<sigma> = subst_lit u \\<eta> \\<or>\n  (subst_lit u \\<sigma>, subst_lit u \\<eta>)\n  \\<in> {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}\n\ngoal (1 subgoal):\n 1. (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n    \\<in> mult trm_ord \\<or>\n    mset_lit (subst_lit u \\<sigma>) = mset_lit (subst_lit u \\<eta>)", "by auto"], ["proof (state)\nthis:\n  (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n  \\<in> mult trm_ord \\<or>\n  mset_lit (subst_lit u \\<sigma>) = mset_lit (subst_lit u \\<eta>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>u.\n     u \\<in># mset_set (cl_ecl C) \\<longrightarrow>\n     (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n     \\<in> mult trm_ord \\<or>\n     mset_lit (subst_lit u \\<sigma>) = mset_lit (subst_lit u \\<eta>)\n\ngoal (1 subgoal):\n 1. ((C, \\<sigma>), C, \\<eta>) \\<in> ecl_ord", "have \"irrefl (mult trm_ord)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irrefl (mult trm_ord)", "by (simp add: irreflI trm_ord_wf wf_mult)"], ["proof (state)\nthis:\n  irrefl (mult trm_ord)\n\ngoal (1 subgoal):\n 1. ((C, \\<sigma>), C, \\<eta>) \\<in> ecl_ord", "have ii: \"\\<exists>u. (u \\<in># ?M \\<and> ((?f1 u), (?f2 u)) \\<in> (mult trm_ord))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u.\n       u \\<in># mset_set (cl_ecl C) \\<and>\n       (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n       \\<in> mult trm_ord", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>u.\n       u \\<in># mset_set (cl_ecl C) \\<and>\n       (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n       \\<in> mult trm_ord", "from \\<open>x \\<in> vars_of_cl (cl_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> vars_of_cl (cl_ecl C)", "obtain u where \"u \\<in> (cl_ecl C)\" and \"x \\<in> vars_of_lit u\""], ["proof (prove)\nusing this:\n  x \\<in> vars_of_cl (cl_ecl C)\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> cl_ecl C; x \\<in> vars_of_lit u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u \\<in> cl_ecl C\n  x \\<in> vars_of_lit u\n\ngoal (1 subgoal):\n 1. \\<exists>u.\n       u \\<in># mset_set (cl_ecl C) \\<and>\n       (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n       \\<in> mult trm_ord", "from assms(4) \\<open>u \\<in> (cl_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  finite (cl_ecl C)\n  u \\<in> cl_ecl C", "have \"u \\<in># ?M\""], ["proof (prove)\nusing this:\n  finite (cl_ecl C)\n  u \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. u \\<in># mset_set (cl_ecl C)", "by auto"], ["proof (state)\nthis:\n  u \\<in># mset_set (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<exists>u.\n       u \\<in># mset_set (cl_ecl C) \\<and>\n       (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n       \\<in> mult trm_ord", "from \\<open>u \\<in> (cl_ecl C)\\<close> and assms(1)"], ["proof (chain)\npicking this:\n  u \\<in> cl_ecl C\n  lower_on \\<sigma> \\<eta> (vars_of_cl (cl_ecl C))", "have \"lower_on \\<sigma> \\<eta> (vars_of_lit u)\""], ["proof (prove)\nusing this:\n  u \\<in> cl_ecl C\n  lower_on \\<sigma> \\<eta> (vars_of_cl (cl_ecl C))\n\ngoal (1 subgoal):\n 1. lower_on \\<sigma> \\<eta> (vars_of_lit u)", "unfolding lower_on_def"], ["proof (prove)\nusing this:\n  u \\<in> cl_ecl C\n  \\<forall>x\\<in>vars_of_cl (cl_ecl C).\n     lower_or_eq (Var x \\<lhd> \\<sigma>) (Var x \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of_lit u.\n       lower_or_eq (Var x \\<lhd> \\<sigma>) (Var x \\<lhd> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  lower_on \\<sigma> \\<eta> (vars_of_lit u)\n\ngoal (1 subgoal):\n 1. \\<exists>u.\n       u \\<in># mset_set (cl_ecl C) \\<and>\n       (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n       \\<in> mult trm_ord", "from \\<open>x \\<in> vars_of_lit u\\<close> \\<open>lower_on \\<sigma> \\<eta> (vars_of_lit u)\\<close> assms(2)"], ["proof (chain)\npicking this:\n  x \\<in> vars_of_lit u\n  lower_on \\<sigma> \\<eta> (vars_of_lit u)\n  (Var x \\<lhd> \\<sigma>, Var x \\<lhd> \\<eta>) \\<in> trm_ord", "have \"((subst_lit u \\<sigma>), (subst_lit u \\<eta>)) \\<in> lit_ord\""], ["proof (prove)\nusing this:\n  x \\<in> vars_of_lit u\n  lower_on \\<sigma> \\<eta> (vars_of_lit u)\n  (Var x \\<lhd> \\<sigma>, Var x \\<lhd> \\<eta>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (subst_lit u \\<sigma>, subst_lit u \\<eta>) \\<in> lit_ord", "using lower_on_lit"], ["proof (prove)\nusing this:\n  x \\<in> vars_of_lit u\n  lower_on \\<sigma> \\<eta> (vars_of_lit u)\n  (Var x \\<lhd> \\<sigma>, Var x \\<lhd> \\<eta>) \\<in> trm_ord\n  \\<lbrakk>lower_on ?\\<sigma> ?\\<eta> (vars_of_lit ?L);\n   (Var ?x \\<lhd> ?\\<sigma>, Var ?x \\<lhd> ?\\<eta>) \\<in> trm_ord;\n   ?x \\<in> vars_of_lit ?L\\<rbrakk>\n  \\<Longrightarrow> (subst_lit ?L ?\\<sigma>, subst_lit ?L ?\\<eta>)\n                    \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (subst_lit u \\<sigma>, subst_lit u \\<eta>) \\<in> lit_ord", "by blast"], ["proof (state)\nthis:\n  (subst_lit u \\<sigma>, subst_lit u \\<eta>) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. \\<exists>u.\n       u \\<in># mset_set (cl_ecl C) \\<and>\n       (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n       \\<in> mult trm_ord", "from this \\<open>u \\<in># ?M\\<close>"], ["proof (chain)\npicking this:\n  (subst_lit u \\<sigma>, subst_lit u \\<eta>) \\<in> lit_ord\n  u \\<in># mset_set (cl_ecl C)", "have \"(u \\<in># ?M \\<and> ((?f1 u), (?f2 u)) \\<in> (mult trm_ord))\""], ["proof (prove)\nusing this:\n  (subst_lit u \\<sigma>, subst_lit u \\<eta>) \\<in> lit_ord\n  u \\<in># mset_set (cl_ecl C)\n\ngoal (1 subgoal):\n 1. u \\<in># mset_set (cl_ecl C) \\<and>\n    (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n    \\<in> mult trm_ord", "unfolding lit_ord_def"], ["proof (prove)\nusing this:\n  (subst_lit u \\<sigma>, subst_lit u \\<eta>)\n  \\<in> {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}\n  u \\<in># mset_set (cl_ecl C)\n\ngoal (1 subgoal):\n 1. u \\<in># mset_set (cl_ecl C) \\<and>\n    (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n    \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  u \\<in># mset_set (cl_ecl C) \\<and>\n  (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n  \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. \\<exists>u.\n       u \\<in># mset_set (cl_ecl C) \\<and>\n       (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n       \\<in> mult trm_ord", "then"], ["proof (chain)\npicking this:\n  u \\<in># mset_set (cl_ecl C) \\<and>\n  (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n  \\<in> mult trm_ord", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<in># mset_set (cl_ecl C) \\<and>\n  (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n  \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. \\<exists>u.\n       u \\<in># mset_set (cl_ecl C) \\<and>\n       (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n       \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  \\<exists>u.\n     u \\<in># mset_set (cl_ecl C) \\<and>\n     (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n     \\<in> mult trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>u.\n     u \\<in># mset_set (cl_ecl C) \\<and>\n     (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n     \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. ((C, \\<sigma>), C, \\<eta>) \\<in> ecl_ord", "from i ii  \\<open>?M1 = {# (?f1 u). u \\<in># ?M #}\\<close> \\<open>?M2 = {# (?f2 u). u \\<in># ?M #}\\<close> \\<open>irrefl (mult trm_ord)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>u.\n     u \\<in># mset_set (cl_ecl C) \\<longrightarrow>\n     (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n     \\<in> mult trm_ord \\<or>\n     mset_lit (subst_lit u \\<sigma>) = mset_lit (subst_lit u \\<eta>)\n  \\<exists>u.\n     u \\<in># mset_set (cl_ecl C) \\<and>\n     (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n     \\<in> mult trm_ord\n  mset_ecl (C, \\<sigma>) =\n  {#mset_lit (subst_lit u \\<sigma>). u \\<in># mset_set (cl_ecl C)#}\n  mset_ecl (C, \\<eta>) =\n  {#mset_lit (subst_lit u \\<eta>). u \\<in># mset_set (cl_ecl C)#}\n  irrefl (mult trm_ord)", "have \"(?M1,?M2) \\<in> (mult (mult trm_ord))\""], ["proof (prove)\nusing this:\n  \\<forall>u.\n     u \\<in># mset_set (cl_ecl C) \\<longrightarrow>\n     (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n     \\<in> mult trm_ord \\<or>\n     mset_lit (subst_lit u \\<sigma>) = mset_lit (subst_lit u \\<eta>)\n  \\<exists>u.\n     u \\<in># mset_set (cl_ecl C) \\<and>\n     (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n     \\<in> mult trm_ord\n  mset_ecl (C, \\<sigma>) =\n  {#mset_lit (subst_lit u \\<sigma>). u \\<in># mset_set (cl_ecl C)#}\n  mset_ecl (C, \\<eta>) =\n  {#mset_lit (subst_lit u \\<eta>). u \\<in># mset_set (cl_ecl C)#}\n  irrefl (mult trm_ord)\n\ngoal (1 subgoal):\n 1. (mset_ecl (C, \\<sigma>), mset_ecl (C, \\<eta>)) \\<in> mult (mult trm_ord)", "using image_mset_ordering [of ?M1 ?f1 ?M ?M2 ?f2 \"(mult trm_ord)\" ]"], ["proof (prove)\nusing this:\n  \\<forall>u.\n     u \\<in># mset_set (cl_ecl C) \\<longrightarrow>\n     (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n     \\<in> mult trm_ord \\<or>\n     mset_lit (subst_lit u \\<sigma>) = mset_lit (subst_lit u \\<eta>)\n  \\<exists>u.\n     u \\<in># mset_set (cl_ecl C) \\<and>\n     (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n     \\<in> mult trm_ord\n  mset_ecl (C, \\<sigma>) =\n  {#mset_lit (subst_lit u \\<sigma>). u \\<in># mset_set (cl_ecl C)#}\n  mset_ecl (C, \\<eta>) =\n  {#mset_lit (subst_lit u \\<eta>). u \\<in># mset_set (cl_ecl C)#}\n  irrefl (mult trm_ord)\n  \\<lbrakk>mset_ecl (C, \\<sigma>) =\n           {#mset_lit (subst_lit u \\<sigma>)\n           . u \\<in># mset_set (cl_ecl C)#};\n   mset_ecl (C, \\<eta>) =\n   {#mset_lit (subst_lit u \\<eta>). u \\<in># mset_set (cl_ecl C)#};\n   \\<forall>u.\n      u \\<in># mset_set (cl_ecl C) \\<longrightarrow>\n      (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n      \\<in> mult trm_ord \\<or>\n      mset_lit (subst_lit u \\<sigma>) = mset_lit (subst_lit u \\<eta>);\n   \\<exists>u.\n      u \\<in># mset_set (cl_ecl C) \\<and>\n      (mset_lit (subst_lit u \\<sigma>), mset_lit (subst_lit u \\<eta>))\n      \\<in> mult trm_ord;\n   irrefl (mult trm_ord)\\<rbrakk>\n  \\<Longrightarrow> (mset_ecl (C, \\<sigma>), mset_ecl (C, \\<eta>))\n                    \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. (mset_ecl (C, \\<sigma>), mset_ecl (C, \\<eta>)) \\<in> mult (mult trm_ord)", "by auto"], ["proof (state)\nthis:\n  (mset_ecl (C, \\<sigma>), mset_ecl (C, \\<eta>)) \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. ((C, \\<sigma>), C, \\<eta>) \\<in> ecl_ord", "then"], ["proof (chain)\npicking this:\n  (mset_ecl (C, \\<sigma>), mset_ecl (C, \\<eta>)) \\<in> mult (mult trm_ord)", "show ?thesis"], ["proof (prove)\nusing this:\n  (mset_ecl (C, \\<sigma>), mset_ecl (C, \\<eta>)) \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. ((C, \\<sigma>), C, \\<eta>) \\<in> ecl_ord", "unfolding ecl_ord_def"], ["proof (prove)\nusing this:\n  (mset_ecl (C, \\<sigma>), mset_ecl (C, \\<eta>)) \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. ((C, \\<sigma>), C, \\<eta>)\n    \\<in> {(x, y). (mset_ecl x, mset_ecl y) \\<in> mult (mult trm_ord)}", "by auto"], ["proof (state)\nthis:\n  ((C, \\<sigma>), C, \\<eta>) \\<in> ecl_ord\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subterm_trm_ord :\n  shows \"\\<And> t  s. \n           subterm t p s \\<Longrightarrow> p \\<noteq> []  \n          \\<Longrightarrow> (s,t) \\<in> trm_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t s.\n       \\<lbrakk>subterm t p s; p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (s, t) \\<in> trm_ord", "proof (induction p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t s.\n       \\<lbrakk>subterm t [] s; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (s, t) \\<in> trm_ord\n 2. \\<And>a p t s.\n       \\<lbrakk>\\<And>t s.\n                   \\<lbrakk>subterm t p s; p \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> (s, t) \\<in> trm_ord;\n        subterm t (a # p) s; a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (s, t) \\<in> trm_ord", "case Nil"], ["proof (state)\nthis:\n  subterm t [] s\n  [] \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>t s.\n       \\<lbrakk>subterm t [] s; [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (s, t) \\<in> trm_ord\n 2. \\<And>a p t s.\n       \\<lbrakk>\\<And>t s.\n                   \\<lbrakk>subterm t p s; p \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> (s, t) \\<in> trm_ord;\n        subterm t (a # p) s; a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (s, t) \\<in> trm_ord", "from \\<open>Nil \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  [] \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  [] \\<noteq> []\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (s, t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<And>a p t s.\n       \\<lbrakk>\\<And>t s.\n                   \\<lbrakk>subterm t p s; p \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> (s, t) \\<in> trm_ord;\n        subterm t (a # p) s; a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (s, t) \\<in> trm_ord", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p t s.\n       \\<lbrakk>\\<And>t s.\n                   \\<lbrakk>subterm t p s; p \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> (s, t) \\<in> trm_ord;\n        subterm t (a # p) s; a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (s, t) \\<in> trm_ord", "case (Cons i q)"], ["proof (state)\nthis:\n  \\<lbrakk>subterm ?t q ?s; q \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> (?s, ?t) \\<in> trm_ord\n  subterm t (i # q) s\n  i # q \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a p t s.\n       \\<lbrakk>\\<And>t s.\n                   \\<lbrakk>subterm t p s; p \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> (s, t) \\<in> trm_ord;\n        subterm t (a # p) s; a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (s, t) \\<in> trm_ord", "from \\<open>subterm t (i # q) s\\<close>"], ["proof (chain)\npicking this:\n  subterm t (i # q) s", "obtain t1 t2 where\n        \"t = (Comb t1 t2)\""], ["proof (prove)\nusing this:\n  subterm t (i # q) s\n\ngoal (1 subgoal):\n 1. (\\<And>t1 t2.\n        t = t1 \\<cdot> t2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using subterm.elims(2)"], ["proof (prove)\nusing this:\n  subterm t (i # q) s\n  \\<lbrakk>subterm ?x ?xa ?xb;\n   \\<And>T S.\n      \\<lbrakk>?x = T; ?xa = []; ?xb = S; T = S\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>x y next S.\n      \\<lbrakk>?x = x \\<cdot> y; ?xa = indices.Left # next; ?xb = S;\n       subterm x next S\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>x y next S.\n      \\<lbrakk>?x = x \\<cdot> y; ?xa = indices.Right # next; ?xb = S;\n       subterm y next S\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>t1 t2.\n        t = t1 \\<cdot> t2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t = t1 \\<cdot> t2\n\ngoal (1 subgoal):\n 1. \\<And>a p t s.\n       \\<lbrakk>\\<And>t s.\n                   \\<lbrakk>subterm t p s; p \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> (s, t) \\<in> trm_ord;\n        subterm t (a # p) s; a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (s, t) \\<in> trm_ord", "have \"i = Left \\<or> i = Right\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = indices.Left \\<or> i = indices.Right", "using indices.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = indices.Left \\<Longrightarrow> ?P;\n   ?y = indices.Right \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. i = indices.Left \\<or> i = indices.Right", "by blast"], ["proof (state)\nthis:\n  i = indices.Left \\<or> i = indices.Right\n\ngoal (1 subgoal):\n 1. \\<And>a p t s.\n       \\<lbrakk>\\<And>t s.\n                   \\<lbrakk>subterm t p s; p \\<noteq> []\\<rbrakk>\n                   \\<Longrightarrow> (s, t) \\<in> trm_ord;\n        subterm t (a # p) s; a # p \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (s, t) \\<in> trm_ord", "then"], ["proof (chain)\npicking this:\n  i = indices.Left \\<or> i = indices.Right", "show \"(s,t) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  i = indices.Left \\<or> i = indices.Right\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> trm_ord", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. i = indices.Left \\<Longrightarrow> (s, t) \\<in> trm_ord\n 2. i = indices.Right \\<Longrightarrow> (s, t) \\<in> trm_ord", "assume \"i = Left\""], ["proof (state)\nthis:\n  i = indices.Left\n\ngoal (2 subgoals):\n 1. i = indices.Left \\<Longrightarrow> (s, t) \\<in> trm_ord\n 2. i = indices.Right \\<Longrightarrow> (s, t) \\<in> trm_ord", "from this and \\<open>t = Comb t1 t2\\<close> and \\<open>subterm t (i # q) s\\<close>"], ["proof (chain)\npicking this:\n  i = indices.Left\n  t = t1 \\<cdot> t2\n  subterm t (i # q) s", "have \"subterm t1 q s\""], ["proof (prove)\nusing this:\n  i = indices.Left\n  t = t1 \\<cdot> t2\n  subterm t (i # q) s\n\ngoal (1 subgoal):\n 1. subterm t1 q s", "by auto"], ["proof (state)\nthis:\n  subterm t1 q s\n\ngoal (2 subgoals):\n 1. i = indices.Left \\<Longrightarrow> (s, t) \\<in> trm_ord\n 2. i = indices.Right \\<Longrightarrow> (s, t) \\<in> trm_ord", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, t) \\<in> trm_ord", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (s, t) \\<in> trm_ord\n 2. \\<not> ?P \\<Longrightarrow> (s, t) \\<in> trm_ord", "assume \"q = Nil\""], ["proof (state)\nthis:\n  q = []\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (s, t) \\<in> trm_ord\n 2. \\<not> ?P \\<Longrightarrow> (s, t) \\<in> trm_ord", "from this and \\<open>subterm t1 q s\\<close>"], ["proof (chain)\npicking this:\n  q = []\n  subterm t1 q s", "have \"t1 = s\""], ["proof (prove)\nusing this:\n  q = []\n  subterm t1 q s\n\ngoal (1 subgoal):\n 1. t1 = s", "by auto"], ["proof (state)\nthis:\n  t1 = s\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (s, t) \\<in> trm_ord\n 2. \\<not> ?P \\<Longrightarrow> (s, t) \\<in> trm_ord", "from this and  \\<open>t = Comb t1 t2\\<close>"], ["proof (chain)\npicking this:\n  t1 = s\n  t = t1 \\<cdot> t2", "show ?case"], ["proof (prove)\nusing this:\n  t1 = s\n  t = t1 \\<cdot> t2\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> trm_ord", "using trm_ord_subterm"], ["proof (prove)\nusing this:\n  t1 = s\n  t = t1 \\<cdot> t2\n  \\<forall>x1 x2.\n     (x1, x1 \\<cdot> x2) \\<in> trm_ord \\<and>\n     (x2, x1 \\<cdot> x2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (s, t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. q \\<noteq> [] \\<Longrightarrow> (s, t) \\<in> trm_ord", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<noteq> [] \\<Longrightarrow> (s, t) \\<in> trm_ord", "assume \"q \\<noteq> Nil\""], ["proof (state)\nthis:\n  q \\<noteq> []\n\ngoal (1 subgoal):\n 1. q \\<noteq> [] \\<Longrightarrow> (s, t) \\<in> trm_ord", "from this and \\<open>subterm t1 q s\\<close>"], ["proof (chain)\npicking this:\n  q \\<noteq> []\n  subterm t1 q s", "have \"(s,t1) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  q \\<noteq> []\n  subterm t1 q s\n\ngoal (1 subgoal):\n 1. (s, t1) \\<in> trm_ord", "using Cons.IH"], ["proof (prove)\nusing this:\n  q \\<noteq> []\n  subterm t1 q s\n  \\<lbrakk>subterm ?t q ?s; q \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> (?s, ?t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (s, t1) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (s, t1) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. q \\<noteq> [] \\<Longrightarrow> (s, t) \\<in> trm_ord", "from \\<open>t = Comb t1 t2\\<close>"], ["proof (chain)\npicking this:\n  t = t1 \\<cdot> t2", "have \"(t1,t) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  t = t1 \\<cdot> t2\n\ngoal (1 subgoal):\n 1. (t1, t) \\<in> trm_ord", "using trm_ord_subterm"], ["proof (prove)\nusing this:\n  t = t1 \\<cdot> t2\n  \\<forall>x1 x2.\n     (x1, x1 \\<cdot> x2) \\<in> trm_ord \\<and>\n     (x2, x1 \\<cdot> x2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (t1, t) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (t1, t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. q \\<noteq> [] \\<Longrightarrow> (s, t) \\<in> trm_ord", "from this and \\<open>(s,t1) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  (t1, t) \\<in> trm_ord\n  (s, t1) \\<in> trm_ord", "show ?case"], ["proof (prove)\nusing this:\n  (t1, t) \\<in> trm_ord\n  (s, t1) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> trm_ord", "using trm_ord_trans"], ["proof (prove)\nusing this:\n  (t1, t) \\<in> trm_ord\n  (s, t1) \\<in> trm_ord\n  trans trm_ord\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> trm_ord", "unfolding trans_def"], ["proof (prove)\nusing this:\n  (t1, t) \\<in> trm_ord\n  (s, t1) \\<in> trm_ord\n  \\<forall>x y z.\n     (x, y) \\<in> trm_ord \\<longrightarrow>\n     (y, z) \\<in> trm_ord \\<longrightarrow> (x, z) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (s, t) \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s, t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. i = indices.Right \\<Longrightarrow> (s, t) \\<in> trm_ord", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i = indices.Right \\<Longrightarrow> (s, t) \\<in> trm_ord", "assume \"i = Right\""], ["proof (state)\nthis:\n  i = indices.Right\n\ngoal (1 subgoal):\n 1. i = indices.Right \\<Longrightarrow> (s, t) \\<in> trm_ord", "from this and \\<open>t = Comb t1 t2\\<close> and \\<open>subterm t (i # q) s\\<close>"], ["proof (chain)\npicking this:\n  i = indices.Right\n  t = t1 \\<cdot> t2\n  subterm t (i # q) s", "have \"subterm t2 q s\""], ["proof (prove)\nusing this:\n  i = indices.Right\n  t = t1 \\<cdot> t2\n  subterm t (i # q) s\n\ngoal (1 subgoal):\n 1. subterm t2 q s", "by auto"], ["proof (state)\nthis:\n  subterm t2 q s\n\ngoal (1 subgoal):\n 1. i = indices.Right \\<Longrightarrow> (s, t) \\<in> trm_ord", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, t) \\<in> trm_ord", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (s, t) \\<in> trm_ord\n 2. \\<not> ?P \\<Longrightarrow> (s, t) \\<in> trm_ord", "assume \"q = Nil\""], ["proof (state)\nthis:\n  q = []\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (s, t) \\<in> trm_ord\n 2. \\<not> ?P \\<Longrightarrow> (s, t) \\<in> trm_ord", "from this and \\<open>subterm t2 q s\\<close>"], ["proof (chain)\npicking this:\n  q = []\n  subterm t2 q s", "have \"t2 = s\""], ["proof (prove)\nusing this:\n  q = []\n  subterm t2 q s\n\ngoal (1 subgoal):\n 1. t2 = s", "by auto"], ["proof (state)\nthis:\n  t2 = s\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (s, t) \\<in> trm_ord\n 2. \\<not> ?P \\<Longrightarrow> (s, t) \\<in> trm_ord", "from this and  \\<open>t = Comb t1 t2\\<close>"], ["proof (chain)\npicking this:\n  t2 = s\n  t = t1 \\<cdot> t2", "show ?case"], ["proof (prove)\nusing this:\n  t2 = s\n  t = t1 \\<cdot> t2\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> trm_ord", "using trm_ord_subterm"], ["proof (prove)\nusing this:\n  t2 = s\n  t = t1 \\<cdot> t2\n  \\<forall>x1 x2.\n     (x1, x1 \\<cdot> x2) \\<in> trm_ord \\<and>\n     (x2, x1 \\<cdot> x2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (s, t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. q \\<noteq> [] \\<Longrightarrow> (s, t) \\<in> trm_ord", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<noteq> [] \\<Longrightarrow> (s, t) \\<in> trm_ord", "assume \"q \\<noteq> Nil\""], ["proof (state)\nthis:\n  q \\<noteq> []\n\ngoal (1 subgoal):\n 1. q \\<noteq> [] \\<Longrightarrow> (s, t) \\<in> trm_ord", "from this and \\<open>subterm t2 q s\\<close>"], ["proof (chain)\npicking this:\n  q \\<noteq> []\n  subterm t2 q s", "have \"(s,t2) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  q \\<noteq> []\n  subterm t2 q s\n\ngoal (1 subgoal):\n 1. (s, t2) \\<in> trm_ord", "using Cons.IH"], ["proof (prove)\nusing this:\n  q \\<noteq> []\n  subterm t2 q s\n  \\<lbrakk>subterm ?t q ?s; q \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> (?s, ?t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (s, t2) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (s, t2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. q \\<noteq> [] \\<Longrightarrow> (s, t) \\<in> trm_ord", "from \\<open>t = Comb t1 t2\\<close>"], ["proof (chain)\npicking this:\n  t = t1 \\<cdot> t2", "have \"(t2,t) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  t = t1 \\<cdot> t2\n\ngoal (1 subgoal):\n 1. (t2, t) \\<in> trm_ord", "using trm_ord_subterm"], ["proof (prove)\nusing this:\n  t = t1 \\<cdot> t2\n  \\<forall>x1 x2.\n     (x1, x1 \\<cdot> x2) \\<in> trm_ord \\<and>\n     (x2, x1 \\<cdot> x2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (t2, t) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (t2, t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. q \\<noteq> [] \\<Longrightarrow> (s, t) \\<in> trm_ord", "from this and \\<open>(s,t2) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  (t2, t) \\<in> trm_ord\n  (s, t2) \\<in> trm_ord", "show ?case"], ["proof (prove)\nusing this:\n  (t2, t) \\<in> trm_ord\n  (s, t2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> trm_ord", "using trm_ord_trans"], ["proof (prove)\nusing this:\n  (t2, t) \\<in> trm_ord\n  (s, t2) \\<in> trm_ord\n  trans trm_ord\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> trm_ord", "unfolding trans_def"], ["proof (prove)\nusing this:\n  (t2, t) \\<in> trm_ord\n  (s, t2) \\<in> trm_ord\n  \\<forall>x y z.\n     (x, y) \\<in> trm_ord \\<longrightarrow>\n     (y, z) \\<in> trm_ord \\<longrightarrow> (x, z) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (s, t) \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s, t) \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s, t) \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subterm_trm_ord_eq :\n  assumes \"subterm t p s\" \n  shows \"s = t \\<or> (s,t) \\<in> trm_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = t \\<or> (s, t) \\<in> trm_ord", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> s = t \\<or> (s, t) \\<in> trm_ord\n 2. \\<not> ?P \\<Longrightarrow> s = t \\<or> (s, t) \\<in> trm_ord", "assume \"p = Nil\""], ["proof (state)\nthis:\n  p = []\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> s = t \\<or> (s, t) \\<in> trm_ord\n 2. \\<not> ?P \\<Longrightarrow> s = t \\<or> (s, t) \\<in> trm_ord", "from this and assms(1)"], ["proof (chain)\npicking this:\n  p = []\n  subterm t p s", "show ?thesis"], ["proof (prove)\nusing this:\n  p = []\n  subterm t p s\n\ngoal (1 subgoal):\n 1. s = t \\<or> (s, t) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  s = t \\<or> (s, t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow> s = t \\<or> (s, t) \\<in> trm_ord", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow> s = t \\<or> (s, t) \\<in> trm_ord", "assume \"p \\<noteq> Nil\""], ["proof (state)\nthis:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow> s = t \\<or> (s, t) \\<in> trm_ord", "from this and assms(1)"], ["proof (chain)\npicking this:\n  p \\<noteq> []\n  subterm t p s", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  subterm t p s\n\ngoal (1 subgoal):\n 1. s = t \\<or> (s, t) \\<in> trm_ord", "using subterm_trm_ord"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  subterm t p s\n  \\<lbrakk>subterm ?t ?p ?s; ?p \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> (?s, ?t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. s = t \\<or> (s, t) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  s = t \\<or> (s, t) \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subterms_of_trm_ord_eq :\n  assumes \"s \\<in> subterms_of t\" \n  shows \"s = t \\<or> (s,t) \\<in> trm_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = t \\<or> (s, t) \\<in> trm_ord", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s = t \\<or> (s, t) \\<in> trm_ord", "from assms(1)"], ["proof (chain)\npicking this:\n  s \\<in> subterms_of t", "obtain p where \"subterm t p s\""], ["proof (prove)\nusing this:\n  s \\<in> subterms_of t\n\ngoal (1 subgoal):\n 1. (\\<And>p. subterm t p s \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using occurs_in_def"], ["proof (prove)\nusing this:\n  s \\<in> subterms_of t\n  occurs_in ?t ?s = (\\<exists>p. subterm ?s p ?t)\n\ngoal (1 subgoal):\n 1. (\\<And>p. subterm t p s \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  subterm t p s\n\ngoal (1 subgoal):\n 1. s = t \\<or> (s, t) \\<in> trm_ord", "from this"], ["proof (chain)\npicking this:\n  subterm t p s", "show ?thesis"], ["proof (prove)\nusing this:\n  subterm t p s\n\ngoal (1 subgoal):\n 1. s = t \\<or> (s, t) \\<in> trm_ord", "using subterm_trm_ord_eq"], ["proof (prove)\nusing this:\n  subterm t p s\n  subterm ?t ?p ?s \\<Longrightarrow> ?s = ?t \\<or> (?s, ?t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. s = t \\<or> (s, t) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  s = t \\<or> (s, t) \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subt_trm_ord:\n  shows \"t \\<prec> s \\<longrightarrow> (t,s) \\<in> trm_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<prec> s \\<longrightarrow> (t, s) \\<in> trm_ord", "proof (induction s)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. t \\<prec> Var x \\<longrightarrow> (t, Var x) \\<in> trm_ord\n 2. \\<And>x. t \\<prec> Const x \\<longrightarrow> (t, Const x) \\<in> trm_ord\n 3. \\<And>s1 s2.\n       \\<lbrakk>t \\<prec> s1 \\<longrightarrow> (t, s1) \\<in> trm_ord;\n        t \\<prec> s2 \\<longrightarrow> (t, s2) \\<in> trm_ord\\<rbrakk>\n       \\<Longrightarrow> t \\<prec> s1 \\<cdot> s2 \\<longrightarrow>\n                         (t, s1 \\<cdot> s2) \\<in> trm_ord", "case (Var x)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>x. t \\<prec> Var x \\<longrightarrow> (t, Var x) \\<in> trm_ord\n 2. \\<And>x. t \\<prec> Const x \\<longrightarrow> (t, Const x) \\<in> trm_ord\n 3. \\<And>s1 s2.\n       \\<lbrakk>t \\<prec> s1 \\<longrightarrow> (t, s1) \\<in> trm_ord;\n        t \\<prec> s2 \\<longrightarrow> (t, s2) \\<in> trm_ord\\<rbrakk>\n       \\<Longrightarrow> t \\<prec> s1 \\<cdot> s2 \\<longrightarrow>\n                         (t, s1 \\<cdot> s2) \\<in> trm_ord", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<prec> Var x \\<longrightarrow> (t, Var x) \\<in> trm_ord", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<prec> Var x \\<Longrightarrow> (t, Var x) \\<in> trm_ord", "assume \"t \\<prec> Var x\""], ["proof (state)\nthis:\n  t \\<prec> Var x\n\ngoal (1 subgoal):\n 1. t \\<prec> Var x \\<Longrightarrow> (t, Var x) \\<in> trm_ord", "then"], ["proof (chain)\npicking this:\n  t \\<prec> Var x", "show \"(t,Var x) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  t \\<prec> Var x\n\ngoal (1 subgoal):\n 1. (t, Var x) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (t, Var x) \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<prec> Var x \\<longrightarrow> (t, Var x) \\<in> trm_ord\n\ngoal (2 subgoals):\n 1. \\<And>x. t \\<prec> Const x \\<longrightarrow> (t, Const x) \\<in> trm_ord\n 2. \\<And>s1 s2.\n       \\<lbrakk>t \\<prec> s1 \\<longrightarrow> (t, s1) \\<in> trm_ord;\n        t \\<prec> s2 \\<longrightarrow> (t, s2) \\<in> trm_ord\\<rbrakk>\n       \\<Longrightarrow> t \\<prec> s1 \\<cdot> s2 \\<longrightarrow>\n                         (t, s1 \\<cdot> s2) \\<in> trm_ord", "case (Const x)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x. t \\<prec> Const x \\<longrightarrow> (t, Const x) \\<in> trm_ord\n 2. \\<And>s1 s2.\n       \\<lbrakk>t \\<prec> s1 \\<longrightarrow> (t, s1) \\<in> trm_ord;\n        t \\<prec> s2 \\<longrightarrow> (t, s2) \\<in> trm_ord\\<rbrakk>\n       \\<Longrightarrow> t \\<prec> s1 \\<cdot> s2 \\<longrightarrow>\n                         (t, s1 \\<cdot> s2) \\<in> trm_ord", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<prec> Const x \\<longrightarrow> (t, Const x) \\<in> trm_ord", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<prec> Const x \\<Longrightarrow> (t, Const x) \\<in> trm_ord", "assume \"t \\<prec> Const x\""], ["proof (state)\nthis:\n  t \\<prec> Const x\n\ngoal (1 subgoal):\n 1. t \\<prec> Const x \\<Longrightarrow> (t, Const x) \\<in> trm_ord", "then"], ["proof (chain)\npicking this:\n  t \\<prec> Const x", "show \"(t,Const x) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  t \\<prec> Const x\n\ngoal (1 subgoal):\n 1. (t, Const x) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (t, Const x) \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<prec> Const x \\<longrightarrow> (t, Const x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>t \\<prec> s1 \\<longrightarrow> (t, s1) \\<in> trm_ord;\n        t \\<prec> s2 \\<longrightarrow> (t, s2) \\<in> trm_ord\\<rbrakk>\n       \\<Longrightarrow> t \\<prec> s1 \\<cdot> s2 \\<longrightarrow>\n                         (t, s1 \\<cdot> s2) \\<in> trm_ord", "case (Comb t1 t2)"], ["proof (state)\nthis:\n  t \\<prec> t1 \\<longrightarrow> (t, t1) \\<in> trm_ord\n  t \\<prec> t2 \\<longrightarrow> (t, t2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>t \\<prec> s1 \\<longrightarrow> (t, s1) \\<in> trm_ord;\n        t \\<prec> s2 \\<longrightarrow> (t, s2) \\<in> trm_ord\\<rbrakk>\n       \\<Longrightarrow> t \\<prec> s1 \\<cdot> s2 \\<longrightarrow>\n                         (t, s1 \\<cdot> s2) \\<in> trm_ord", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<prec> t1 \\<cdot> t2 \\<longrightarrow>\n    (t, t1 \\<cdot> t2) \\<in> trm_ord", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<prec> t1 \\<cdot> t2 \\<Longrightarrow>\n    (t, t1 \\<cdot> t2) \\<in> trm_ord", "assume \"t \\<prec> Comb t1 t2\""], ["proof (state)\nthis:\n  t \\<prec> t1 \\<cdot> t2\n\ngoal (1 subgoal):\n 1. t \\<prec> t1 \\<cdot> t2 \\<Longrightarrow>\n    (t, t1 \\<cdot> t2) \\<in> trm_ord", "show \"(t, Comb t1 t2) \\<in> trm_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t, t1 \\<cdot> t2) \\<in> trm_ord", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. (t, t1 \\<cdot> t2) \\<notin> trm_ord \\<Longrightarrow> False", "assume \"(t, Comb t1 t2) \\<notin> trm_ord\""], ["proof (state)\nthis:\n  (t, t1 \\<cdot> t2) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. (t, t1 \\<cdot> t2) \\<notin> trm_ord \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (t, t1 \\<cdot> t2) \\<notin> trm_ord", "have i: \"t \\<noteq> t1\""], ["proof (prove)\nusing this:\n  (t, t1 \\<cdot> t2) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. t \\<noteq> t1", "using trm_ord_subterm"], ["proof (prove)\nusing this:\n  (t, t1 \\<cdot> t2) \\<notin> trm_ord\n  \\<forall>x1 x2.\n     (x1, x1 \\<cdot> x2) \\<in> trm_ord \\<and>\n     (x2, x1 \\<cdot> x2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t \\<noteq> t1", "by auto"], ["proof (state)\nthis:\n  t \\<noteq> t1\n\ngoal (1 subgoal):\n 1. (t, t1 \\<cdot> t2) \\<notin> trm_ord \\<Longrightarrow> False", "from \\<open>(t, Comb t1 t2) \\<notin> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  (t, t1 \\<cdot> t2) \\<notin> trm_ord", "have ii: \"t \\<noteq> t2\""], ["proof (prove)\nusing this:\n  (t, t1 \\<cdot> t2) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. t \\<noteq> t2", "using trm_ord_subterm"], ["proof (prove)\nusing this:\n  (t, t1 \\<cdot> t2) \\<notin> trm_ord\n  \\<forall>x1 x2.\n     (x1, x1 \\<cdot> x2) \\<in> trm_ord \\<and>\n     (x2, x1 \\<cdot> x2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t \\<noteq> t2", "by auto"], ["proof (state)\nthis:\n  t \\<noteq> t2\n\ngoal (1 subgoal):\n 1. (t, t1 \\<cdot> t2) \\<notin> trm_ord \\<Longrightarrow> False", "from i ii and \\<open>t \\<prec> Comb t1 t2\\<close>"], ["proof (chain)\npicking this:\n  t \\<noteq> t1\n  t \\<noteq> t2\n  t \\<prec> t1 \\<cdot> t2", "have \"t \\<prec> t1 \\<or> t \\<prec> t2\""], ["proof (prove)\nusing this:\n  t \\<noteq> t1\n  t \\<noteq> t2\n  t \\<prec> t1 \\<cdot> t2\n\ngoal (1 subgoal):\n 1. t \\<prec> t1 \\<or> t \\<prec> t2", "by auto"], ["proof (state)\nthis:\n  t \\<prec> t1 \\<or> t \\<prec> t2\n\ngoal (1 subgoal):\n 1. (t, t1 \\<cdot> t2) \\<notin> trm_ord \\<Longrightarrow> False", "from this and \\<open>(t, Comb t1 t2) \\<notin> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  t \\<prec> t1 \\<or> t \\<prec> t2\n  (t, t1 \\<cdot> t2) \\<notin> trm_ord", "show False"], ["proof (prove)\nusing this:\n  t \\<prec> t1 \\<or> t \\<prec> t2\n  (t, t1 \\<cdot> t2) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. False", "using Comb.IH trm_ord_subterm trm_ord_trans trans_def"], ["proof (prove)\nusing this:\n  t \\<prec> t1 \\<or> t \\<prec> t2\n  (t, t1 \\<cdot> t2) \\<notin> trm_ord\n  t \\<prec> t1 \\<longrightarrow> (t, t1) \\<in> trm_ord\n  t \\<prec> t2 \\<longrightarrow> (t, t2) \\<in> trm_ord\n  \\<forall>x1 x2.\n     (x1, x1 \\<cdot> x2) \\<in> trm_ord \\<and>\n     (x2, x1 \\<cdot> x2) \\<in> trm_ord\n  trans trm_ord\n  trans ?r =\n  (\\<forall>x y z.\n      (x, y) \\<in> ?r \\<longrightarrow>\n      (y, z) \\<in> ?r \\<longrightarrow> (x, z) \\<in> ?r)\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (t, t1 \\<cdot> t2) \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<prec> t1 \\<cdot> t2 \\<longrightarrow> (t, t1 \\<cdot> t2) \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trm_ord_vars:\n  assumes \"(t,s) \\<in> trm_ord\"\n  shows \"vars_of t \\<subseteq> vars_of s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of s", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> vars_of t \\<subseteq> vars_of s \\<Longrightarrow> False", "assume \"\\<not>vars_of t \\<subseteq> vars_of s\""], ["proof (state)\nthis:\n  \\<not> vars_of t \\<subseteq> vars_of s\n\ngoal (1 subgoal):\n 1. \\<not> vars_of t \\<subseteq> vars_of s \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> vars_of t \\<subseteq> vars_of s", "obtain x where \"x \\<in> vars_of t\" and \"x \\<notin> vars_of s\""], ["proof (prove)\nusing this:\n  \\<not> vars_of t \\<subseteq> vars_of s\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> vars_of t; x \\<notin> vars_of s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> vars_of t\n  x \\<notin> vars_of s\n\ngoal (1 subgoal):\n 1. \\<not> vars_of t \\<subseteq> vars_of s \\<Longrightarrow> False", "let ?\\<sigma> = \"[(x,s)]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> vars_of t \\<subseteq> vars_of s \\<Longrightarrow> False", "from assms"], ["proof (chain)\npicking this:\n  (t, s) \\<in> trm_ord", "have \"((subst t ?\\<sigma>),(subst s ?\\<sigma>)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (t, s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (t \\<lhd> [(x, s)], s \\<lhd> [(x, s)]) \\<in> trm_ord", "using trm_ord_subst"], ["proof (prove)\nusing this:\n  (t, s) \\<in> trm_ord\n  \\<forall>s x y.\n     (x, y) \\<in> trm_ord \\<longrightarrow>\n     (x \\<lhd> s, y \\<lhd> s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (t \\<lhd> [(x, s)], s \\<lhd> [(x, s)]) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (t \\<lhd> [(x, s)], s \\<lhd> [(x, s)]) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> vars_of t \\<subseteq> vars_of s \\<Longrightarrow> False", "let ?\\<theta> = \"[]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> vars_of t \\<subseteq> vars_of s \\<Longrightarrow> False", "let ?V = \"vars_of s\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> vars_of t \\<subseteq> vars_of s \\<Longrightarrow> False", "have \"subst s ?\\<theta> = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<lhd> [] = s", "by simp"], ["proof (state)\nthis:\n  s \\<lhd> [] = s\n\ngoal (1 subgoal):\n 1. \\<not> vars_of t \\<subseteq> vars_of s \\<Longrightarrow> False", "have \"subst (Var x) ?\\<sigma> = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Var x \\<lhd> [(x, s)] = s", "by simp"], ["proof (state)\nthis:\n  Var x \\<lhd> [(x, s)] = s\n\ngoal (1 subgoal):\n 1. \\<not> vars_of t \\<subseteq> vars_of s \\<Longrightarrow> False", "have \"coincide_on ?\\<sigma> ?\\<theta> ?V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coincide_on [(x, s)] [] (vars_of s)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> coincide_on [(x, s)] [] (vars_of s) \\<Longrightarrow> False", "assume \"\\<not> coincide_on ?\\<sigma> ?\\<theta> ?V\""], ["proof (state)\nthis:\n  \\<not> coincide_on [(x, s)] [] (vars_of s)\n\ngoal (1 subgoal):\n 1. \\<not> coincide_on [(x, s)] [] (vars_of s) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> coincide_on [(x, s)] [] (vars_of s)", "obtain y where \"y \\<in> ?V\" \"subst (Var y) ?\\<sigma> \\<noteq> subst (Var y) ?\\<theta>\""], ["proof (prove)\nusing this:\n  \\<not> coincide_on [(x, s)] [] (vars_of s)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> vars_of s;\n         Var y \\<lhd> [(x, s)] \\<noteq> Var y \\<lhd> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>xa\\<in>vars_of s.\n             Var xa \\<lhd> [(x, s)] = Var xa \\<lhd> [])\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> vars_of s;\n         Var y \\<lhd> [(x, s)] \\<noteq> Var y \\<lhd> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> vars_of s\n  Var y \\<lhd> [(x, s)] \\<noteq> Var y \\<lhd> []\n\ngoal (1 subgoal):\n 1. \\<not> coincide_on [(x, s)] [] (vars_of s) \\<Longrightarrow> False", "from \\<open>subst (Var y) ?\\<sigma> \\<noteq> subst (Var y) ?\\<theta>\\<close>"], ["proof (chain)\npicking this:\n  Var y \\<lhd> [(x, s)] \\<noteq> Var y \\<lhd> []", "have \"y = x\""], ["proof (prove)\nusing this:\n  Var y \\<lhd> [(x, s)] \\<noteq> Var y \\<lhd> []\n\ngoal (1 subgoal):\n 1. y = x", "by (metis assoc.simps(2) subst.simps(1))"], ["proof (state)\nthis:\n  y = x\n\ngoal (1 subgoal):\n 1. \\<not> coincide_on [(x, s)] [] (vars_of s) \\<Longrightarrow> False", "from this and \\<open>x \\<notin> vars_of s\\<close> \\<open>y \\<in> ?V\\<close>"], ["proof (chain)\npicking this:\n  y = x\n  x \\<notin> vars_of s\n  y \\<in> vars_of s", "show False"], ["proof (prove)\nusing this:\n  y = x\n  x \\<notin> vars_of s\n  y \\<in> vars_of s\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coincide_on [(x, s)] [] (vars_of s)\n\ngoal (1 subgoal):\n 1. \\<not> vars_of t \\<subseteq> vars_of s \\<Longrightarrow> False", "from this and \\<open>subst s ?\\<theta> = s\\<close>"], ["proof (chain)\npicking this:\n  coincide_on [(x, s)] [] (vars_of s)\n  s \\<lhd> [] = s", "have \"subst s ?\\<sigma> = s\""], ["proof (prove)\nusing this:\n  coincide_on [(x, s)] [] (vars_of s)\n  s \\<lhd> [] = s\n\ngoal (1 subgoal):\n 1. s \\<lhd> [(x, s)] = s", "using coincide_on_term"], ["proof (prove)\nusing this:\n  coincide_on [(x, s)] [] (vars_of s)\n  s \\<lhd> [] = s\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of ?t) \\<Longrightarrow>\n  ?t \\<lhd> ?\\<sigma> = ?t \\<lhd> ?\\<eta>\n\ngoal (1 subgoal):\n 1. s \\<lhd> [(x, s)] = s", "by metis"], ["proof (state)\nthis:\n  s \\<lhd> [(x, s)] = s\n\ngoal (1 subgoal):\n 1. \\<not> vars_of t \\<subseteq> vars_of s \\<Longrightarrow> False", "from \\<open>x \\<in> vars_of t\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> vars_of t", "have \"(Var x) \\<prec> t\""], ["proof (prove)\nusing this:\n  x \\<in> vars_of t\n\ngoal (1 subgoal):\n 1. Var x \\<prec> t", "using \\<open>(subst t [(x, s)], subst s [(x, s)]) \\<in> trm_ord\\<close> \n      \\<open>subst s [(x, s)] = s\\<close> trm_ord_wf vars_iff_occseq"], ["proof (prove)\nusing this:\n  x \\<in> vars_of t\n  (t \\<lhd> [(x, s)], s \\<lhd> [(x, s)]) \\<in> trm_ord\n  s \\<lhd> [(x, s)] = s\n  wf trm_ord\n  (?x \\<in> vars_of ?t) = (Var ?x \\<prec> ?t \\<or> Var ?x = ?t)\n\ngoal (1 subgoal):\n 1. Var x \\<prec> t", "by fastforce"], ["proof (state)\nthis:\n  Var x \\<prec> t\n\ngoal (1 subgoal):\n 1. \\<not> vars_of t \\<subseteq> vars_of s \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  Var x \\<prec> t", "have \"((Var x), t) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  Var x \\<prec> t\n\ngoal (1 subgoal):\n 1. (Var x, t) \\<in> trm_ord", "using subt_trm_ord"], ["proof (prove)\nusing this:\n  Var x \\<prec> t\n  ?t \\<prec> ?s \\<longrightarrow> (?t, ?s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (Var x, t) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (Var x, t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> vars_of t \\<subseteq> vars_of s \\<Longrightarrow> False", "from this and assms(1)"], ["proof (chain)\npicking this:\n  (Var x, t) \\<in> trm_ord\n  (t, s) \\<in> trm_ord", "have \"(Var x,s) \\<in>trm_ord\""], ["proof (prove)\nusing this:\n  (Var x, t) \\<in> trm_ord\n  (t, s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (Var x, s) \\<in> trm_ord", "using trm_ord_trans trans_def"], ["proof (prove)\nusing this:\n  (Var x, t) \\<in> trm_ord\n  (t, s) \\<in> trm_ord\n  trans trm_ord\n  trans ?r =\n  (\\<forall>x y z.\n      (x, y) \\<in> ?r \\<longrightarrow>\n      (y, z) \\<in> ?r \\<longrightarrow> (x, z) \\<in> ?r)\n\ngoal (1 subgoal):\n 1. (Var x, s) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (Var x, s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> vars_of t \\<subseteq> vars_of s \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  (Var x, s) \\<in> trm_ord", "have \"((subst (Var x) ?\\<sigma>),(subst s ?\\<sigma>)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (Var x, s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (Var x \\<lhd> [(x, s)], s \\<lhd> [(x, s)]) \\<in> trm_ord", "using trm_ord_subst"], ["proof (prove)\nusing this:\n  (Var x, s) \\<in> trm_ord\n  \\<forall>s x y.\n     (x, y) \\<in> trm_ord \\<longrightarrow>\n     (x \\<lhd> s, y \\<lhd> s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (Var x \\<lhd> [(x, s)], s \\<lhd> [(x, s)]) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (Var x \\<lhd> [(x, s)], s \\<lhd> [(x, s)]) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> vars_of t \\<subseteq> vars_of s \\<Longrightarrow> False", "from this and \\<open>subst s ?\\<sigma> = s\\<close> \\<open>subst (Var x) ?\\<sigma> = s\\<close>"], ["proof (chain)\npicking this:\n  (Var x \\<lhd> [(x, s)], s \\<lhd> [(x, s)]) \\<in> trm_ord\n  s \\<lhd> [(x, s)] = s\n  Var x \\<lhd> [(x, s)] = s", "have \"(s,s) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (Var x \\<lhd> [(x, s)], s \\<lhd> [(x, s)]) \\<in> trm_ord\n  s \\<lhd> [(x, s)] = s\n  Var x \\<lhd> [(x, s)] = s\n\ngoal (1 subgoal):\n 1. (s, s) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (s, s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> vars_of t \\<subseteq> vars_of s \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  (s, s) \\<in> trm_ord", "show False"], ["proof (prove)\nusing this:\n  (s, s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. False", "using trm_ord_irrefl irrefl_def"], ["proof (prove)\nusing this:\n  (s, s) \\<in> trm_ord\n  irrefl trm_ord\n  irrefl ?r = (\\<forall>a. (a, a) \\<notin> ?r)\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lower_on_ground:\n  assumes \"lower_on \\<sigma> \\<eta> V\"\n  assumes \"ground_on  V \\<eta>\"\n  shows \"ground_on  V \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ground_on V \\<sigma>", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ground_on V \\<sigma> \\<Longrightarrow> False", "assume \"\\<not> ground_on V \\<sigma>\""], ["proof (state)\nthis:\n  \\<not> ground_on V \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> ground_on V \\<sigma> \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  \\<not> ground_on V \\<sigma>", "obtain x where \"x \\<in> V\" and \"vars_of (subst (Var x) \\<sigma>) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<not> ground_on V \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> V;\n         vars_of (Var x \\<lhd> \\<sigma>) \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ground_on_def ground_term_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x\\<in>V. vars_of (Var x \\<lhd> \\<sigma>) = {})\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> V;\n         vars_of (Var x \\<lhd> \\<sigma>) \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  x \\<in> V\n  vars_of (Var x \\<lhd> \\<sigma>) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> ground_on V \\<sigma> \\<Longrightarrow> False", "from assms(1) \\<open>x \\<in> V\\<close>"], ["proof (chain)\npicking this:\n  lower_on \\<sigma> \\<eta> V\n  x \\<in> V", "have \"(subst (Var x) \\<sigma>) = (subst (Var x) \\<eta>)\n    \\<or> ((subst (Var x) \\<sigma>),(subst (Var x) \\<eta>)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  lower_on \\<sigma> \\<eta> V\n  x \\<in> V\n\ngoal (1 subgoal):\n 1. Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<eta> \\<or>\n    (Var x \\<lhd> \\<sigma>, Var x \\<lhd> \\<eta>) \\<in> trm_ord", "unfolding lower_on_def lower_or_eq_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>V.\n     Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<eta> \\<or>\n     (Var x \\<lhd> \\<sigma>, Var x \\<lhd> \\<eta>) \\<in> trm_ord\n  x \\<in> V\n\ngoal (1 subgoal):\n 1. Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<eta> \\<or>\n    (Var x \\<lhd> \\<sigma>, Var x \\<lhd> \\<eta>) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<eta> \\<or>\n  (Var x \\<lhd> \\<sigma>, Var x \\<lhd> \\<eta>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> ground_on V \\<sigma> \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<eta> \\<or>\n  (Var x \\<lhd> \\<sigma>, Var x \\<lhd> \\<eta>) \\<in> trm_ord", "have \"vars_of (subst (Var x) \\<sigma>) \\<subseteq> vars_of (subst (Var x) \\<eta>)\""], ["proof (prove)\nusing this:\n  Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<eta> \\<or>\n  (Var x \\<lhd> \\<sigma>, Var x \\<lhd> \\<eta>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. vars_of (Var x \\<lhd> \\<sigma>)\n    \\<subseteq> vars_of (Var x \\<lhd> \\<eta>)", "using trm_ord_vars"], ["proof (prove)\nusing this:\n  Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<eta> \\<or>\n  (Var x \\<lhd> \\<sigma>, Var x \\<lhd> \\<eta>) \\<in> trm_ord\n  (?t, ?s) \\<in> trm_ord \\<Longrightarrow> vars_of ?t \\<subseteq> vars_of ?s\n\ngoal (1 subgoal):\n 1. vars_of (Var x \\<lhd> \\<sigma>)\n    \\<subseteq> vars_of (Var x \\<lhd> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  vars_of (Var x \\<lhd> \\<sigma>) \\<subseteq> vars_of (Var x \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> ground_on V \\<sigma> \\<Longrightarrow> False", "from this and \\<open>vars_of (subst (Var x) \\<sigma>) \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  vars_of (Var x \\<lhd> \\<sigma>) \\<subseteq> vars_of (Var x \\<lhd> \\<eta>)\n  vars_of (Var x \\<lhd> \\<sigma>) \\<noteq> {}", "have \"vars_of (subst (Var x) \\<eta>) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  vars_of (Var x \\<lhd> \\<sigma>) \\<subseteq> vars_of (Var x \\<lhd> \\<eta>)\n  vars_of (Var x \\<lhd> \\<sigma>) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. vars_of (Var x \\<lhd> \\<eta>) \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  vars_of (Var x \\<lhd> \\<eta>) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> ground_on V \\<sigma> \\<Longrightarrow> False", "from this and \\<open>x \\<in> V\\<close> and assms(2)"], ["proof (chain)\npicking this:\n  vars_of (Var x \\<lhd> \\<eta>) \\<noteq> {}\n  x \\<in> V\n  ground_on V \\<eta>", "show False"], ["proof (prove)\nusing this:\n  vars_of (Var x \\<lhd> \\<eta>) \\<noteq> {}\n  x \\<in> V\n  ground_on V \\<eta>\n\ngoal (1 subgoal):\n 1. False", "unfolding ground_on_def ground_term_def"], ["proof (prove)\nusing this:\n  vars_of (Var x \\<lhd> \\<eta>) \\<noteq> {}\n  x \\<in> V\n  \\<forall>x\\<in>V. vars_of (Var x \\<lhd> \\<eta>) = {}\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma replacement_monotonic :\n  shows \"\\<And> t  s. ((subst v \\<sigma>), (subst u \\<sigma>)) \\<in> trm_ord \n          \\<Longrightarrow> subterm t p u \\<Longrightarrow> replace_subterm t p v s \n          \\<Longrightarrow> ((subst s \\<sigma>), (subst t \\<sigma>)) \\<in> trm_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t s.\n       \\<lbrakk>(v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord;\n        subterm t p u; replace_subterm t p v s\\<rbrakk>\n       \\<Longrightarrow> (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n                         \\<in> trm_ord", "proof (induction p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t s.\n       \\<lbrakk>(v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord;\n        subterm t [] u; replace_subterm t [] v s\\<rbrakk>\n       \\<Longrightarrow> (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n                         \\<in> trm_ord\n 2. \\<And>a p t s.\n       \\<lbrakk>\\<And>t s.\n                   \\<lbrakk>(v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>)\n                            \\<in> trm_ord;\n                    subterm t p u; replace_subterm t p v s\\<rbrakk>\n                   \\<Longrightarrow> (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n                                     \\<in> trm_ord;\n        (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord;\n        subterm t (a # p) u; replace_subterm t (a # p) v s\\<rbrakk>\n       \\<Longrightarrow> (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n                         \\<in> trm_ord", "case Nil"], ["proof (state)\nthis:\n  (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n  subterm t [] u\n  replace_subterm t [] v s\n\ngoal (2 subgoals):\n 1. \\<And>t s.\n       \\<lbrakk>(v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord;\n        subterm t [] u; replace_subterm t [] v s\\<rbrakk>\n       \\<Longrightarrow> (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n                         \\<in> trm_ord\n 2. \\<And>a p t s.\n       \\<lbrakk>\\<And>t s.\n                   \\<lbrakk>(v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>)\n                            \\<in> trm_ord;\n                    subterm t p u; replace_subterm t p v s\\<rbrakk>\n                   \\<Longrightarrow> (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n                                     \\<in> trm_ord;\n        (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord;\n        subterm t (a # p) u; replace_subterm t (a # p) v s\\<rbrakk>\n       \\<Longrightarrow> (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n                         \\<in> trm_ord", "from \\<open>subterm t Nil u\\<close>"], ["proof (chain)\npicking this:\n  subterm t [] u", "have \"t = u\""], ["proof (prove)\nusing this:\n  subterm t [] u\n\ngoal (1 subgoal):\n 1. t = u", "by auto"], ["proof (state)\nthis:\n  t = u\n\ngoal (2 subgoals):\n 1. \\<And>t s.\n       \\<lbrakk>(v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord;\n        subterm t [] u; replace_subterm t [] v s\\<rbrakk>\n       \\<Longrightarrow> (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n                         \\<in> trm_ord\n 2. \\<And>a p t s.\n       \\<lbrakk>\\<And>t s.\n                   \\<lbrakk>(v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>)\n                            \\<in> trm_ord;\n                    subterm t p u; replace_subterm t p v s\\<rbrakk>\n                   \\<Longrightarrow> (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n                                     \\<in> trm_ord;\n        (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord;\n        subterm t (a # p) u; replace_subterm t (a # p) v s\\<rbrakk>\n       \\<Longrightarrow> (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n                         \\<in> trm_ord", "from \\<open>replace_subterm t Nil v s\\<close>"], ["proof (chain)\npicking this:\n  replace_subterm t [] v s", "have \"s = v\""], ["proof (prove)\nusing this:\n  replace_subterm t [] v s\n\ngoal (1 subgoal):\n 1. s = v", "by auto"], ["proof (state)\nthis:\n  s = v\n\ngoal (2 subgoals):\n 1. \\<And>t s.\n       \\<lbrakk>(v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord;\n        subterm t [] u; replace_subterm t [] v s\\<rbrakk>\n       \\<Longrightarrow> (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n                         \\<in> trm_ord\n 2. \\<And>a p t s.\n       \\<lbrakk>\\<And>t s.\n                   \\<lbrakk>(v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>)\n                            \\<in> trm_ord;\n                    subterm t p u; replace_subterm t p v s\\<rbrakk>\n                   \\<Longrightarrow> (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n                                     \\<in> trm_ord;\n        (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord;\n        subterm t (a # p) u; replace_subterm t (a # p) v s\\<rbrakk>\n       \\<Longrightarrow> (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n                         \\<in> trm_ord", "from \\<open>t = u\\<close> and \\<open>s = v\\<close> and \\<open>((subst v \\<sigma>), (subst u \\<sigma>)) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  t = u\n  s = v\n  (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord", "show ?case"], ["proof (prove)\nusing this:\n  t = u\n  s = v\n  (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<And>a p t s.\n       \\<lbrakk>\\<And>t s.\n                   \\<lbrakk>(v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>)\n                            \\<in> trm_ord;\n                    subterm t p u; replace_subterm t p v s\\<rbrakk>\n                   \\<Longrightarrow> (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n                                     \\<in> trm_ord;\n        (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord;\n        subterm t (a # p) u; replace_subterm t (a # p) v s\\<rbrakk>\n       \\<Longrightarrow> (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n                         \\<in> trm_ord", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p t s.\n       \\<lbrakk>\\<And>t s.\n                   \\<lbrakk>(v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>)\n                            \\<in> trm_ord;\n                    subterm t p u; replace_subterm t p v s\\<rbrakk>\n                   \\<Longrightarrow> (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n                                     \\<in> trm_ord;\n        (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord;\n        subterm t (a # p) u; replace_subterm t (a # p) v s\\<rbrakk>\n       \\<Longrightarrow> (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n                         \\<in> trm_ord", "case (Cons i q)"], ["proof (state)\nthis:\n  \\<lbrakk>(v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord;\n   subterm ?t q u; replace_subterm ?t q v ?s\\<rbrakk>\n  \\<Longrightarrow> (?s \\<lhd> \\<sigma>, ?t \\<lhd> \\<sigma>) \\<in> trm_ord\n  (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n  subterm t (i # q) u\n  replace_subterm t (i # q) v s\n\ngoal (1 subgoal):\n 1. \\<And>a p t s.\n       \\<lbrakk>\\<And>t s.\n                   \\<lbrakk>(v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>)\n                            \\<in> trm_ord;\n                    subterm t p u; replace_subterm t p v s\\<rbrakk>\n                   \\<Longrightarrow> (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n                                     \\<in> trm_ord;\n        (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord;\n        subterm t (a # p) u; replace_subterm t (a # p) v s\\<rbrakk>\n       \\<Longrightarrow> (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n                         \\<in> trm_ord", "from \\<open>subterm t (i # q) u\\<close>"], ["proof (chain)\npicking this:\n  subterm t (i # q) u", "obtain t1 t2 where\n        \"t = (Comb t1 t2)\""], ["proof (prove)\nusing this:\n  subterm t (i # q) u\n\ngoal (1 subgoal):\n 1. (\\<And>t1 t2.\n        t = t1 \\<cdot> t2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using subterm.elims(2)"], ["proof (prove)\nusing this:\n  subterm t (i # q) u\n  \\<lbrakk>subterm ?x ?xa ?xb;\n   \\<And>T S.\n      \\<lbrakk>?x = T; ?xa = []; ?xb = S; T = S\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>x y next S.\n      \\<lbrakk>?x = x \\<cdot> y; ?xa = indices.Left # next; ?xb = S;\n       subterm x next S\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>x y next S.\n      \\<lbrakk>?x = x \\<cdot> y; ?xa = indices.Right # next; ?xb = S;\n       subterm y next S\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>t1 t2.\n        t = t1 \\<cdot> t2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t = t1 \\<cdot> t2\n\ngoal (1 subgoal):\n 1. \\<And>a p t s.\n       \\<lbrakk>\\<And>t s.\n                   \\<lbrakk>(v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>)\n                            \\<in> trm_ord;\n                    subterm t p u; replace_subterm t p v s\\<rbrakk>\n                   \\<Longrightarrow> (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n                                     \\<in> trm_ord;\n        (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord;\n        subterm t (a # p) u; replace_subterm t (a # p) v s\\<rbrakk>\n       \\<Longrightarrow> (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n                         \\<in> trm_ord", "have \"i = Left \\<or> i = Right\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = indices.Left \\<or> i = indices.Right", "using indices.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = indices.Left \\<Longrightarrow> ?P;\n   ?y = indices.Right \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. i = indices.Left \\<or> i = indices.Right", "by blast"], ["proof (state)\nthis:\n  i = indices.Left \\<or> i = indices.Right\n\ngoal (1 subgoal):\n 1. \\<And>a p t s.\n       \\<lbrakk>\\<And>t s.\n                   \\<lbrakk>(v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>)\n                            \\<in> trm_ord;\n                    subterm t p u; replace_subterm t p v s\\<rbrakk>\n                   \\<Longrightarrow> (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n                                     \\<in> trm_ord;\n        (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord;\n        subterm t (a # p) u; replace_subterm t (a # p) v s\\<rbrakk>\n       \\<Longrightarrow> (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n                         \\<in> trm_ord", "then"], ["proof (chain)\npicking this:\n  i = indices.Left \\<or> i = indices.Right", "show \"((subst s \\<sigma>), (subst t \\<sigma>)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  i = indices.Left \\<or> i = indices.Right\n\ngoal (1 subgoal):\n 1. (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. i = indices.Left \\<Longrightarrow>\n    (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n 2. i = indices.Right \\<Longrightarrow>\n    (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "assume \"i = Left\""], ["proof (state)\nthis:\n  i = indices.Left\n\ngoal (2 subgoals):\n 1. i = indices.Left \\<Longrightarrow>\n    (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n 2. i = indices.Right \\<Longrightarrow>\n    (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "from this and \\<open>t = Comb t1 t2\\<close> and \\<open>subterm t (i # q) u\\<close>"], ["proof (chain)\npicking this:\n  i = indices.Left\n  t = t1 \\<cdot> t2\n  subterm t (i # q) u", "have \"subterm t1 q u\""], ["proof (prove)\nusing this:\n  i = indices.Left\n  t = t1 \\<cdot> t2\n  subterm t (i # q) u\n\ngoal (1 subgoal):\n 1. subterm t1 q u", "by auto"], ["proof (state)\nthis:\n  subterm t1 q u\n\ngoal (2 subgoals):\n 1. i = indices.Left \\<Longrightarrow>\n    (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n 2. i = indices.Right \\<Longrightarrow>\n    (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "from \\<open>i = Left\\<close> and \\<open>t = Comb t1 t2\\<close> and \\<open>replace_subterm t (i # q) v s\\<close>"], ["proof (chain)\npicking this:\n  i = indices.Left\n  t = t1 \\<cdot> t2\n  replace_subterm t (i # q) v s", "obtain t1' where \"replace_subterm t1 q v t1'\" and \"s = Comb t1' t2\""], ["proof (prove)\nusing this:\n  i = indices.Left\n  t = t1 \\<cdot> t2\n  replace_subterm t (i # q) v s\n\ngoal (1 subgoal):\n 1. (\\<And>t1'.\n        \\<lbrakk>replace_subterm t1 q v t1'; s = t1' \\<cdot> t2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  replace_subterm t1 q v t1'\n  s = t1' \\<cdot> t2\n\ngoal (2 subgoals):\n 1. i = indices.Left \\<Longrightarrow>\n    (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n 2. i = indices.Right \\<Longrightarrow>\n    (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "from  \\<open>((subst v \\<sigma>), (subst u \\<sigma>)) \\<in> trm_ord\\<close> \n        and \\<open>subterm t1 q u\\<close> and \\<open>replace_subterm t1 q v t1'\\<close>"], ["proof (chain)\npicking this:\n  (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n  subterm t1 q u\n  replace_subterm t1 q v t1'", "have \n        \"((subst t1' \\<sigma>), (subst t1 \\<sigma>)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n  subterm t1 q u\n  replace_subterm t1 q v t1'\n\ngoal (1 subgoal):\n 1. (t1' \\<lhd> \\<sigma>, t1 \\<lhd> \\<sigma>) \\<in> trm_ord", "using Cons.IH Cons.prems(1)"], ["proof (prove)\nusing this:\n  (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n  subterm t1 q u\n  replace_subterm t1 q v t1'\n  \\<lbrakk>(v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord;\n   subterm ?t q u; replace_subterm ?t q v ?s\\<rbrakk>\n  \\<Longrightarrow> (?s \\<lhd> \\<sigma>, ?t \\<lhd> \\<sigma>) \\<in> trm_ord\n  (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (t1' \\<lhd> \\<sigma>, t1 \\<lhd> \\<sigma>) \\<in> trm_ord", "by blast"], ["proof (state)\nthis:\n  (t1' \\<lhd> \\<sigma>, t1 \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (2 subgoals):\n 1. i = indices.Left \\<Longrightarrow>\n    (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n 2. i = indices.Right \\<Longrightarrow>\n    (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "from this  and \\<open>t = (Comb t1 t2)\\<close> and \\<open>s = (Comb t1' t2)\\<close>"], ["proof (chain)\npicking this:\n  (t1' \\<lhd> \\<sigma>, t1 \\<lhd> \\<sigma>) \\<in> trm_ord\n  t = t1 \\<cdot> t2\n  s = t1' \\<cdot> t2", "show \"((subst s \\<sigma>), (subst t \\<sigma>)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (t1' \\<lhd> \\<sigma>, t1 \\<lhd> \\<sigma>) \\<in> trm_ord\n  t = t1 \\<cdot> t2\n  s = t1' \\<cdot> t2\n\ngoal (1 subgoal):\n 1. (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "by (simp add: trm_ord_reduction_left)"], ["proof (state)\nthis:\n  (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. i = indices.Right \\<Longrightarrow>\n    (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i = indices.Right \\<Longrightarrow>\n    (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "assume \"i = Right\""], ["proof (state)\nthis:\n  i = indices.Right\n\ngoal (1 subgoal):\n 1. i = indices.Right \\<Longrightarrow>\n    (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "from this and \\<open>t = Comb t1 t2\\<close> and \\<open>subterm t (i # q) u\\<close>"], ["proof (chain)\npicking this:\n  i = indices.Right\n  t = t1 \\<cdot> t2\n  subterm t (i # q) u", "have \"subterm t2 q u\""], ["proof (prove)\nusing this:\n  i = indices.Right\n  t = t1 \\<cdot> t2\n  subterm t (i # q) u\n\ngoal (1 subgoal):\n 1. subterm t2 q u", "by auto"], ["proof (state)\nthis:\n  subterm t2 q u\n\ngoal (1 subgoal):\n 1. i = indices.Right \\<Longrightarrow>\n    (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "from \\<open>i = Right\\<close> and \\<open>t = Comb t1 t2\\<close> and \\<open>replace_subterm t (i # q) v s\\<close>"], ["proof (chain)\npicking this:\n  i = indices.Right\n  t = t1 \\<cdot> t2\n  replace_subterm t (i # q) v s", "obtain t2' where \"replace_subterm t2 q v t2'\" and \"s = Comb t1 t2'\""], ["proof (prove)\nusing this:\n  i = indices.Right\n  t = t1 \\<cdot> t2\n  replace_subterm t (i # q) v s\n\ngoal (1 subgoal):\n 1. (\\<And>t2'.\n        \\<lbrakk>replace_subterm t2 q v t2'; s = t1 \\<cdot> t2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  replace_subterm t2 q v t2'\n  s = t1 \\<cdot> t2'\n\ngoal (1 subgoal):\n 1. i = indices.Right \\<Longrightarrow>\n    (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "from  \\<open>((subst v \\<sigma>), (subst u \\<sigma>)) \\<in> trm_ord\\<close> \n        and \\<open>subterm t2 q u\\<close> and \\<open>replace_subterm t2 q v t2'\\<close>"], ["proof (chain)\npicking this:\n  (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n  subterm t2 q u\n  replace_subterm t2 q v t2'", "have \n        \"((subst t2' \\<sigma>), (subst t2 \\<sigma>)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n  subterm t2 q u\n  replace_subterm t2 q v t2'\n\ngoal (1 subgoal):\n 1. (t2' \\<lhd> \\<sigma>, t2 \\<lhd> \\<sigma>) \\<in> trm_ord", "using Cons.IH Cons.prems(2)"], ["proof (prove)\nusing this:\n  (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n  subterm t2 q u\n  replace_subterm t2 q v t2'\n  \\<lbrakk>(v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord;\n   subterm ?t q u; replace_subterm ?t q v ?s\\<rbrakk>\n  \\<Longrightarrow> (?s \\<lhd> \\<sigma>, ?t \\<lhd> \\<sigma>) \\<in> trm_ord\n  subterm t (i # q) u\n\ngoal (1 subgoal):\n 1. (t2' \\<lhd> \\<sigma>, t2 \\<lhd> \\<sigma>) \\<in> trm_ord", "by blast"], ["proof (state)\nthis:\n  (t2' \\<lhd> \\<sigma>, t2 \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. i = indices.Right \\<Longrightarrow>\n    (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "from this and \\<open>t = (Comb t1 t2)\\<close> and \\<open>s = (Comb t1 t2')\\<close>"], ["proof (chain)\npicking this:\n  (t2' \\<lhd> \\<sigma>, t2 \\<lhd> \\<sigma>) \\<in> trm_ord\n  t = t1 \\<cdot> t2\n  s = t1 \\<cdot> t2'", "show \"((subst s \\<sigma>), (subst t \\<sigma>)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (t2' \\<lhd> \\<sigma>, t2 \\<lhd> \\<sigma>) \\<in> trm_ord\n  t = t1 \\<cdot> t2\n  s = t1 \\<cdot> t2'\n\ngoal (1 subgoal):\n 1. (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "by (simp add: trm_ord_reduction_right)"], ["proof (state)\nthis:\n  (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mset_lit_subst:\n  shows \"(mset_lit (subst_lit L \\<sigma>)) = \n    {# (subst x \\<sigma>). x \\<in># (mset_lit L) #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L \\<sigma>) =\n    {#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L \\<sigma>) =\n    {#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#}", "have \"positive_literal L \\<or> negative_literal L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. positive_literal L \\<or> negative_literal L", "using negative_literal.simps(2) positive_literal.elims(3)"], ["proof (prove)\nusing this:\n  negative_literal (Neg ?x) = True\n  \\<lbrakk>\\<not> positive_literal ?x;\n   \\<And>x. ?x = Neg x \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. positive_literal L \\<or> negative_literal L", "by blast"], ["proof (state)\nthis:\n  positive_literal L \\<or> negative_literal L\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L \\<sigma>) =\n    {#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#}", "then"], ["proof (chain)\npicking this:\n  positive_literal L \\<or> negative_literal L", "show ?thesis"], ["proof (prove)\nusing this:\n  positive_literal L \\<or> negative_literal L\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L \\<sigma>) =\n    {#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. positive_literal L \\<Longrightarrow>\n    mset_lit (subst_lit L \\<sigma>) =\n    {#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#}\n 2. negative_literal L \\<Longrightarrow>\n    mset_lit (subst_lit L \\<sigma>) =\n    {#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#}", "assume \"positive_literal L\""], ["proof (state)\nthis:\n  positive_literal L\n\ngoal (2 subgoals):\n 1. positive_literal L \\<Longrightarrow>\n    mset_lit (subst_lit L \\<sigma>) =\n    {#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#}\n 2. negative_literal L \\<Longrightarrow>\n    mset_lit (subst_lit L \\<sigma>) =\n    {#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#}", "then"], ["proof (chain)\npicking this:\n  positive_literal L", "obtain t s where \"L = Pos (Eq t s)\""], ["proof (prove)\nusing this:\n  positive_literal L\n\ngoal (1 subgoal):\n 1. (\\<And>t s. L = Pos (Eq t s) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis equation.exhaust positive_literal.elims(2))"], ["proof (state)\nthis:\n  L = Pos (Eq t s)\n\ngoal (2 subgoals):\n 1. positive_literal L \\<Longrightarrow>\n    mset_lit (subst_lit L \\<sigma>) =\n    {#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#}\n 2. negative_literal L \\<Longrightarrow>\n    mset_lit (subst_lit L \\<sigma>) =\n    {#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#}", "from this"], ["proof (chain)\npicking this:\n  L = Pos (Eq t s)", "show ?thesis"], ["proof (prove)\nusing this:\n  L = Pos (Eq t s)\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L \\<sigma>) =\n    {#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#}", "by auto"], ["proof (state)\nthis:\n  mset_lit (subst_lit L \\<sigma>) =\n  {#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#}\n\ngoal (1 subgoal):\n 1. negative_literal L \\<Longrightarrow>\n    mset_lit (subst_lit L \\<sigma>) =\n    {#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. negative_literal L \\<Longrightarrow>\n    mset_lit (subst_lit L \\<sigma>) =\n    {#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#}", "assume \"negative_literal L\""], ["proof (state)\nthis:\n  negative_literal L\n\ngoal (1 subgoal):\n 1. negative_literal L \\<Longrightarrow>\n    mset_lit (subst_lit L \\<sigma>) =\n    {#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#}", "then"], ["proof (chain)\npicking this:\n  negative_literal L", "obtain t s where \"L = Neg (Eq t s)\""], ["proof (prove)\nusing this:\n  negative_literal L\n\ngoal (1 subgoal):\n 1. (\\<And>t s. L = Neg (Eq t s) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis equation.exhaust negative_literal.elims(2))"], ["proof (state)\nthis:\n  L = Neg (Eq t s)\n\ngoal (1 subgoal):\n 1. negative_literal L \\<Longrightarrow>\n    mset_lit (subst_lit L \\<sigma>) =\n    {#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#}", "from this"], ["proof (chain)\npicking this:\n  L = Neg (Eq t s)", "show ?thesis"], ["proof (prove)\nusing this:\n  L = Neg (Eq t s)\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L \\<sigma>) =\n    {#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#}", "by auto"], ["proof (state)\nthis:\n  mset_lit (subst_lit L \\<sigma>) =\n  {#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mset_lit (subst_lit L \\<sigma>) =\n  {#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lit_ord_irrefl:\n  shows \"(L,L) \\<notin> lit_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (L, L) \\<notin> lit_ord", "by (simp add: lit_ord_wf)"], ["", "lemma lit_ord_subst:\n  assumes \"(L,M) \\<in> lit_ord\"\n  shows \"((subst_lit L \\<sigma>), (subst_lit M \\<sigma>)) \\<in> lit_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord", "let ?f = \"\\<lambda>x. (subst x \\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord", "have i: \"\\<And> t s. ((t,s) \\<in> trm_ord \\<Longrightarrow> ((?f t), (?f s)) \\<in> trm_ord)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t s.\n       (t, s) \\<in> trm_ord \\<Longrightarrow>\n       (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<in> trm_ord", "using trm_ord_subst"], ["proof (prove)\nusing this:\n  \\<forall>s x y.\n     (x, y) \\<in> trm_ord \\<longrightarrow>\n     (x \\<lhd> s, y \\<lhd> s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<And>t s.\n       (t, s) \\<in> trm_ord \\<Longrightarrow>\n       (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (?t, ?s) \\<in> trm_ord \\<Longrightarrow>\n  (?t \\<lhd> \\<sigma>, ?s \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord", "from assms(1)"], ["proof (chain)\npicking this:\n  (L, M) \\<in> lit_ord", "have ii: \"( (mset_lit L),(mset_lit M)) \\<in> (mult trm_ord)\""], ["proof (prove)\nusing this:\n  (L, M) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (mset_lit L, mset_lit M) \\<in> mult trm_ord", "unfolding lit_ord_def"], ["proof (prove)\nusing this:\n  (L, M) \\<in> {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}\n\ngoal (1 subgoal):\n 1. (mset_lit L, mset_lit M) \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  (mset_lit L, mset_lit M) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord", "let ?L = \"{# (?f x). x \\<in># (mset_lit L) #}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord", "let ?M = \"{# (?f x). x \\<in># (mset_lit M) #}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord", "from i and ii"], ["proof (chain)\npicking this:\n  (?t, ?s) \\<in> trm_ord \\<Longrightarrow>\n  (?t \\<lhd> \\<sigma>, ?s \\<lhd> \\<sigma>) \\<in> trm_ord\n  (mset_lit L, mset_lit M) \\<in> mult trm_ord", "have iii: \"( ?L,?M ) \\<in> (mult trm_ord)\""], ["proof (prove)\nusing this:\n  (?t, ?s) \\<in> trm_ord \\<Longrightarrow>\n  (?t \\<lhd> \\<sigma>, ?s \\<lhd> \\<sigma>) \\<in> trm_ord\n  (mset_lit L, mset_lit M) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. ({#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#},\n     {#x \\<lhd> \\<sigma>. x \\<in># mset_lit M#})\n    \\<in> mult trm_ord", "using monotonic_fun_mult"], ["proof (prove)\nusing this:\n  (?t, ?s) \\<in> trm_ord \\<Longrightarrow>\n  (?t \\<lhd> \\<sigma>, ?s \\<lhd> \\<sigma>) \\<in> trm_ord\n  (mset_lit L, mset_lit M) \\<in> mult trm_ord\n  \\<lbrakk>\\<And>t s.\n              (t, s) \\<in> ?r \\<Longrightarrow> (?f t, ?f s) \\<in> ?r;\n   (?E1.0, ?E2.0) \\<in> mult ?r\\<rbrakk>\n  \\<Longrightarrow> (image_mset ?f ?E1.0, image_mset ?f ?E2.0) \\<in> mult ?r\n\ngoal (1 subgoal):\n 1. ({#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#},\n     {#x \\<lhd> \\<sigma>. x \\<in># mset_lit M#})\n    \\<in> mult trm_ord", "by metis"], ["proof (state)\nthis:\n  ({#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#},\n   {#x \\<lhd> \\<sigma>. x \\<in># mset_lit M#})\n  \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord", "have l: \"?L = (mset_lit (subst_lit L \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#} =\n    mset_lit (subst_lit L \\<sigma>)", "using mset_lit_subst"], ["proof (prove)\nusing this:\n  mset_lit (subst_lit ?L ?\\<sigma>) =\n  {#x \\<lhd> ?\\<sigma>. x \\<in># mset_lit ?L#}\n\ngoal (1 subgoal):\n 1. {#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#} =\n    mset_lit (subst_lit L \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  {#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#} =\n  mset_lit (subst_lit L \\<sigma>)\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord", "have m: \"?M = (mset_lit (subst_lit M \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#x \\<lhd> \\<sigma>. x \\<in># mset_lit M#} =\n    mset_lit (subst_lit M \\<sigma>)", "using mset_lit_subst"], ["proof (prove)\nusing this:\n  mset_lit (subst_lit ?L ?\\<sigma>) =\n  {#x \\<lhd> ?\\<sigma>. x \\<in># mset_lit ?L#}\n\ngoal (1 subgoal):\n 1. {#x \\<lhd> \\<sigma>. x \\<in># mset_lit M#} =\n    mset_lit (subst_lit M \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  {#x \\<lhd> \\<sigma>. x \\<in># mset_lit M#} =\n  mset_lit (subst_lit M \\<sigma>)\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord", "from l m iii"], ["proof (chain)\npicking this:\n  {#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#} =\n  mset_lit (subst_lit L \\<sigma>)\n  {#x \\<lhd> \\<sigma>. x \\<in># mset_lit M#} =\n  mset_lit (subst_lit M \\<sigma>)\n  ({#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#},\n   {#x \\<lhd> \\<sigma>. x \\<in># mset_lit M#})\n  \\<in> mult trm_ord", "show ?thesis"], ["proof (prove)\nusing this:\n  {#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#} =\n  mset_lit (subst_lit L \\<sigma>)\n  {#x \\<lhd> \\<sigma>. x \\<in># mset_lit M#} =\n  mset_lit (subst_lit M \\<sigma>)\n  ({#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#},\n   {#x \\<lhd> \\<sigma>. x \\<in># mset_lit M#})\n  \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord", "unfolding lit_ord_def"], ["proof (prove)\nusing this:\n  {#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#} =\n  mset_lit (subst_lit L \\<sigma>)\n  {#x \\<lhd> \\<sigma>. x \\<in># mset_lit M#} =\n  mset_lit (subst_lit M \\<sigma>)\n  ({#x \\<lhd> \\<sigma>. x \\<in># mset_lit L#},\n   {#x \\<lhd> \\<sigma>. x \\<in># mset_lit M#})\n  \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit M \\<sigma>)\n    \\<in> {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}", "by auto"], ["proof (state)\nthis:\n  (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma args_are_strictly_lower:\n   assumes \"is_compound t\"\n   shows \"(lhs t,t) \\<in> trm_ord \\<and> (rhs t,t) \\<in> trm_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lhs t, t) \\<in> trm_ord \\<and> (rhs t, t) \\<in> trm_ord", "by (metis assms is_compound.elims(2) lhs.simps(1) rhs.simps(1) trm_ord_subterm)"], ["", "lemma mset_subst:\n  assumes \"C' = subst_cl D \\<theta>\" \n  assumes \"\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\"\n  assumes \"finite D\"\n  shows \"mset_cl (C',\\<eta>) = mset_cl (D,\\<sigma>) \\<or> (mset_cl (C',\\<eta>),mset_cl (D,\\<sigma>)) \\<in> (mult (mult trm_ord))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset_cl (C', \\<eta>) = mset_cl (D, \\<sigma>) \\<or>\n    (mset_cl (C', \\<eta>), mset_cl (D, \\<sigma>)) \\<in> mult (mult trm_ord)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mset_cl (C', \\<eta>) = mset_cl (D, \\<sigma>) \\<or>\n    (mset_cl (C', \\<eta>), mset_cl (D, \\<sigma>)) \\<in> mult (mult trm_ord)", "let ?f = \"\\<lambda>x. (subst_lit x \\<theta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. mset_cl (C', \\<eta>) = mset_cl (D, \\<sigma>) \\<or>\n    (mset_cl (C', \\<eta>), mset_cl (D, \\<sigma>)) \\<in> mult (mult trm_ord)", "let ?g = \"\\<lambda>x. (mset_lit (subst_lit x \\<eta>))\""], ["proof (state)\ngoal (1 subgoal):\n 1. mset_cl (C', \\<eta>) = mset_cl (D, \\<sigma>) \\<or>\n    (mset_cl (C', \\<eta>), mset_cl (D, \\<sigma>)) \\<in> mult (mult trm_ord)", "let ?h = \"\\<lambda>x. (mset_lit (subst_lit x \\<sigma>))\""], ["proof (state)\ngoal (1 subgoal):\n 1. mset_cl (C', \\<eta>) = mset_cl (D, \\<sigma>) \\<or>\n    (mset_cl (C', \\<eta>), mset_cl (D, \\<sigma>)) \\<in> mult (mult trm_ord)", "have i: \"\\<forall>x \\<in> D. ( (?g (?f x)) = (?h x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>D.\n       mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>) =\n       mset_lit (subst_lit x \\<sigma>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> D \\<Longrightarrow>\n       mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>) =\n       mset_lit (subst_lit x \\<sigma>)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> D \\<Longrightarrow>\n       mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>) =\n       mset_lit (subst_lit x \\<sigma>)", "have \"(subst_lit (subst_lit x \\<theta>) \\<eta>) = (subst_lit x (\\<theta> \\<lozenge> \\<eta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_lit (subst_lit x \\<theta>) \\<eta> =\n    subst_lit x (\\<theta> \\<lozenge> \\<eta>)", "using composition_of_substs_lit"], ["proof (prove)\nusing this:\n  subst_lit (subst_lit ?l ?\\<sigma>) ?\\<eta> =\n  subst_lit ?l (?\\<sigma> \\<lozenge> ?\\<eta>)\n\ngoal (1 subgoal):\n 1. subst_lit (subst_lit x \\<theta>) \\<eta> =\n    subst_lit x (\\<theta> \\<lozenge> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  subst_lit (subst_lit x \\<theta>) \\<eta> =\n  subst_lit x (\\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> D \\<Longrightarrow>\n       mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>) =\n       mset_lit (subst_lit x \\<sigma>)", "from assms(2)"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>", "have \"(subst_lit x  \\<sigma>) = (subst_lit x (\\<theta> \\<lozenge> \\<eta>))\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. subst_lit x \\<sigma> = subst_lit x (\\<theta> \\<lozenge> \\<eta>)", "using subst_eq_lit"], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  ?\\<sigma> \\<doteq> ?\\<eta> \\<Longrightarrow>\n  subst_lit ?l ?\\<sigma> = subst_lit ?l ?\\<eta>\n\ngoal (1 subgoal):\n 1. subst_lit x \\<sigma> = subst_lit x (\\<theta> \\<lozenge> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  subst_lit x \\<sigma> = subst_lit x (\\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> D \\<Longrightarrow>\n       mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>) =\n       mset_lit (subst_lit x \\<sigma>)", "from this \\<open>(subst_lit (subst_lit x \\<theta>) \\<eta>) = (subst_lit x (\\<theta> \\<lozenge> \\<eta>))\\<close>"], ["proof (chain)\npicking this:\n  subst_lit x \\<sigma> = subst_lit x (\\<theta> \\<lozenge> \\<eta>)\n  subst_lit (subst_lit x \\<theta>) \\<eta> =\n  subst_lit x (\\<theta> \\<lozenge> \\<eta>)", "show \"(?g (?f x)) = (?h x)\""], ["proof (prove)\nusing this:\n  subst_lit x \\<sigma> = subst_lit x (\\<theta> \\<lozenge> \\<eta>)\n  subst_lit (subst_lit x \\<theta>) \\<eta> =\n  subst_lit x (\\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>) =\n    mset_lit (subst_lit x \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>) =\n  mset_lit (subst_lit x \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>D.\n     mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>) =\n     mset_lit (subst_lit x \\<sigma>)\n\ngoal (1 subgoal):\n 1. mset_cl (C', \\<eta>) = mset_cl (D, \\<sigma>) \\<or>\n    (mset_cl (C', \\<eta>), mset_cl (D, \\<sigma>)) \\<in> mult (mult trm_ord)", "from assms(3)"], ["proof (chain)\npicking this:\n  finite D", "have \"mset_set (?f ` D) \\<subseteq>#  {# (?f x). x \\<in># mset_set (D) #}\""], ["proof (prove)\nusing this:\n  finite D\n\ngoal (1 subgoal):\n 1. mset_set ((\\<lambda>x. subst_lit x \\<theta>) ` D) \\<subseteq>#\n    {#subst_lit x \\<theta>. x \\<in># mset_set D#}", "using mset_set_mset_image"], ["proof (prove)\nusing this:\n  finite D\n  \\<lbrakk>card ?E = ?N; finite ?E\\<rbrakk>\n  \\<Longrightarrow> mset_set (?g ` ?E) \\<subseteq>#\n                    image_mset ?g (mset_set ?E)\n\ngoal (1 subgoal):\n 1. mset_set ((\\<lambda>x. subst_lit x \\<theta>) ` D) \\<subseteq>#\n    {#subst_lit x \\<theta>. x \\<in># mset_set D#}", "by auto"], ["proof (state)\nthis:\n  mset_set ((\\<lambda>x. subst_lit x \\<theta>) ` D) \\<subseteq>#\n  {#subst_lit x \\<theta>. x \\<in># mset_set D#}\n\ngoal (1 subgoal):\n 1. mset_cl (C', \\<eta>) = mset_cl (D, \\<sigma>) \\<or>\n    (mset_cl (C', \\<eta>), mset_cl (D, \\<sigma>)) \\<in> mult (mult trm_ord)", "from this"], ["proof (chain)\npicking this:\n  mset_set ((\\<lambda>x. subst_lit x \\<theta>) ` D) \\<subseteq>#\n  {#subst_lit x \\<theta>. x \\<in># mset_set D#}", "have ii: \"{# (?g x). x \\<in># mset_set (?f ` D) #} \\<subseteq>#  {# (?g x). x \\<in># {# (?f x). x \\<in># mset_set (D) #} #}\""], ["proof (prove)\nusing this:\n  mset_set ((\\<lambda>x. subst_lit x \\<theta>) ` D) \\<subseteq>#\n  {#subst_lit x \\<theta>. x \\<in># mset_set D#}\n\ngoal (1 subgoal):\n 1. {#mset_lit (subst_lit x \\<eta>)\n    . x \\<in># mset_set\n                ((\\<lambda>x. subst_lit x \\<theta>) ` D)#} \\<subseteq>#\n    {#mset_lit (subst_lit x \\<eta>)\n    . x \\<in># {#subst_lit x \\<theta>. x \\<in># mset_set D#}#}", "using image_mset_subseteq_mono"], ["proof (prove)\nusing this:\n  mset_set ((\\<lambda>x. subst_lit x \\<theta>) ` D) \\<subseteq>#\n  {#subst_lit x \\<theta>. x \\<in># mset_set D#}\n  ?A \\<subseteq># ?B \\<Longrightarrow>\n  image_mset ?f ?A \\<subseteq># image_mset ?f ?B\n\ngoal (1 subgoal):\n 1. {#mset_lit (subst_lit x \\<eta>)\n    . x \\<in># mset_set\n                ((\\<lambda>x. subst_lit x \\<theta>) ` D)#} \\<subseteq>#\n    {#mset_lit (subst_lit x \\<eta>)\n    . x \\<in># {#subst_lit x \\<theta>. x \\<in># mset_set D#}#}", "by auto"], ["proof (state)\nthis:\n  {#mset_lit (subst_lit x \\<eta>)\n  . x \\<in># mset_set\n              ((\\<lambda>x. subst_lit x \\<theta>) ` D)#} \\<subseteq>#\n  {#mset_lit (subst_lit x \\<eta>)\n  . x \\<in># {#subst_lit x \\<theta>. x \\<in># mset_set D#}#}\n\ngoal (1 subgoal):\n 1. mset_cl (C', \\<eta>) = mset_cl (D, \\<sigma>) \\<or>\n    (mset_cl (C', \\<eta>), mset_cl (D, \\<sigma>)) \\<in> mult (mult trm_ord)", "have \"{# (?g x). x \\<in># {# (?f x). x \\<in># mset_set (D) #} #} = {# (?g (?f x)). x \\<in># mset_set D #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#mset_lit (subst_lit x \\<eta>)\n    . x \\<in># {#subst_lit x \\<theta>. x \\<in># mset_set D#}#} =\n    {#mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>)\n    . x \\<in># mset_set D#}", "using mset_image_comp [of ?g ?f ]"], ["proof (prove)\nusing this:\n  {#mset_lit (subst_lit x \\<eta>)\n  . x \\<in># {#subst_lit x \\<theta>. x \\<in># ?E#}#} =\n  {#mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>). x \\<in># ?E#}\n\ngoal (1 subgoal):\n 1. {#mset_lit (subst_lit x \\<eta>)\n    . x \\<in># {#subst_lit x \\<theta>. x \\<in># mset_set D#}#} =\n    {#mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>)\n    . x \\<in># mset_set D#}", "by auto"], ["proof (state)\nthis:\n  {#mset_lit (subst_lit x \\<eta>)\n  . x \\<in># {#subst_lit x \\<theta>. x \\<in># mset_set D#}#} =\n  {#mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>)\n  . x \\<in># mset_set D#}\n\ngoal (1 subgoal):\n 1. mset_cl (C', \\<eta>) = mset_cl (D, \\<sigma>) \\<or>\n    (mset_cl (C', \\<eta>), mset_cl (D, \\<sigma>)) \\<in> mult (mult trm_ord)", "from this and ii"], ["proof (chain)\npicking this:\n  {#mset_lit (subst_lit x \\<eta>)\n  . x \\<in># {#subst_lit x \\<theta>. x \\<in># mset_set D#}#} =\n  {#mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>)\n  . x \\<in># mset_set D#}\n  {#mset_lit (subst_lit x \\<eta>)\n  . x \\<in># mset_set\n              ((\\<lambda>x. subst_lit x \\<theta>) ` D)#} \\<subseteq>#\n  {#mset_lit (subst_lit x \\<eta>)\n  . x \\<in># {#subst_lit x \\<theta>. x \\<in># mset_set D#}#}", "have\n    iii: \"{# (?g x). x \\<in># mset_set (?f ` D) #} \\<subseteq># {# (?g (?f x)). x \\<in># mset_set D #}\""], ["proof (prove)\nusing this:\n  {#mset_lit (subst_lit x \\<eta>)\n  . x \\<in># {#subst_lit x \\<theta>. x \\<in># mset_set D#}#} =\n  {#mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>)\n  . x \\<in># mset_set D#}\n  {#mset_lit (subst_lit x \\<eta>)\n  . x \\<in># mset_set\n              ((\\<lambda>x. subst_lit x \\<theta>) ` D)#} \\<subseteq>#\n  {#mset_lit (subst_lit x \\<eta>)\n  . x \\<in># {#subst_lit x \\<theta>. x \\<in># mset_set D#}#}\n\ngoal (1 subgoal):\n 1. {#mset_lit (subst_lit x \\<eta>)\n    . x \\<in># mset_set\n                ((\\<lambda>x. subst_lit x \\<theta>) ` D)#} \\<subseteq>#\n    {#mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>)\n    . x \\<in># mset_set D#}", "by auto"], ["proof (state)\nthis:\n  {#mset_lit (subst_lit x \\<eta>)\n  . x \\<in># mset_set\n              ((\\<lambda>x. subst_lit x \\<theta>) ` D)#} \\<subseteq>#\n  {#mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>)\n  . x \\<in># mset_set D#}\n\ngoal (1 subgoal):\n 1. mset_cl (C', \\<eta>) = mset_cl (D, \\<sigma>) \\<or>\n    (mset_cl (C', \\<eta>), mset_cl (D, \\<sigma>)) \\<in> mult (mult trm_ord)", "from i"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>D.\n     mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>) =\n     mset_lit (subst_lit x \\<sigma>)", "have \"{# (?g (?f x)). x \\<in># (mset_set D) #} = {# (?h x). x \\<in># (mset_set D)  #} \""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>D.\n     mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>) =\n     mset_lit (subst_lit x \\<sigma>)\n\ngoal (1 subgoal):\n 1. {#mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>)\n    . x \\<in># mset_set D#} =\n    {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set D#}", "using equal_image_mset [of D \"\\<lambda>x. (?g (?f x))\"]"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>D.\n     mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>) =\n     mset_lit (subst_lit x \\<sigma>)\n  \\<forall>x\\<in>D.\n     mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>) =\n     ?g x \\<Longrightarrow>\n  {#mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>)\n  . x \\<in># mset_set D#} =\n  image_mset ?g (mset_set D)\n\ngoal (1 subgoal):\n 1. {#mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>)\n    . x \\<in># mset_set D#} =\n    {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set D#}", "by auto"], ["proof (state)\nthis:\n  {#mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>)\n  . x \\<in># mset_set D#} =\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set D#}\n\ngoal (1 subgoal):\n 1. mset_cl (C', \\<eta>) = mset_cl (D, \\<sigma>) \\<or>\n    (mset_cl (C', \\<eta>), mset_cl (D, \\<sigma>)) \\<in> mult (mult trm_ord)", "from this and iii"], ["proof (chain)\npicking this:\n  {#mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>)\n  . x \\<in># mset_set D#} =\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set D#}\n  {#mset_lit (subst_lit x \\<eta>)\n  . x \\<in># mset_set\n              ((\\<lambda>x. subst_lit x \\<theta>) ` D)#} \\<subseteq>#\n  {#mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>)\n  . x \\<in># mset_set D#}", "have \"{# (?g x). x \\<in># mset_set (?f ` D) #} \\<subseteq># {# (?h x). x \\<in># mset_set D #}\""], ["proof (prove)\nusing this:\n  {#mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>)\n  . x \\<in># mset_set D#} =\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set D#}\n  {#mset_lit (subst_lit x \\<eta>)\n  . x \\<in># mset_set\n              ((\\<lambda>x. subst_lit x \\<theta>) ` D)#} \\<subseteq>#\n  {#mset_lit (subst_lit (subst_lit x \\<theta>) \\<eta>)\n  . x \\<in># mset_set D#}\n\ngoal (1 subgoal):\n 1. {#mset_lit (subst_lit x \\<eta>)\n    . x \\<in># mset_set\n                ((\\<lambda>x. subst_lit x \\<theta>) ` D)#} \\<subseteq>#\n    {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set D#}", "by auto"], ["proof (state)\nthis:\n  {#mset_lit (subst_lit x \\<eta>)\n  . x \\<in># mset_set\n              ((\\<lambda>x. subst_lit x \\<theta>) ` D)#} \\<subseteq>#\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set D#}\n\ngoal (1 subgoal):\n 1. mset_cl (C', \\<eta>) = mset_cl (D, \\<sigma>) \\<or>\n    (mset_cl (C', \\<eta>), mset_cl (D, \\<sigma>)) \\<in> mult (mult trm_ord)", "from this"], ["proof (chain)\npicking this:\n  {#mset_lit (subst_lit x \\<eta>)\n  . x \\<in># mset_set\n              ((\\<lambda>x. subst_lit x \\<theta>) ` D)#} \\<subseteq>#\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set D#}", "have iv: \"{# (?g x). x \\<in># mset_set (?f ` D) #} \\<subseteq># mset_cl (D,\\<sigma>)\""], ["proof (prove)\nusing this:\n  {#mset_lit (subst_lit x \\<eta>)\n  . x \\<in># mset_set\n              ((\\<lambda>x. subst_lit x \\<theta>) ` D)#} \\<subseteq>#\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set D#}\n\ngoal (1 subgoal):\n 1. {#mset_lit (subst_lit x \\<eta>)\n    . x \\<in># mset_set\n                ((\\<lambda>x. subst_lit x \\<theta>) ` D)#} \\<subseteq>#\n    mset_cl (D, \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  {#mset_lit (subst_lit x \\<eta>)\n  . x \\<in># mset_set\n              ((\\<lambda>x. subst_lit x \\<theta>) ` D)#} \\<subseteq>#\n  mset_cl (D, \\<sigma>)\n\ngoal (1 subgoal):\n 1. mset_cl (C', \\<eta>) = mset_cl (D, \\<sigma>) \\<or>\n    (mset_cl (C', \\<eta>), mset_cl (D, \\<sigma>)) \\<in> mult (mult trm_ord)", "from assms(1)"], ["proof (chain)\npicking this:\n  C' = subst_cl D \\<theta>", "have \"((\\<lambda>x. subst_lit x \\<theta>) ` D) = C'\""], ["proof (prove)\nusing this:\n  C' = subst_cl D \\<theta>\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. subst_lit x \\<theta>) ` D = C'", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. subst_lit x \\<theta>) ` D = C'\n\ngoal (1 subgoal):\n 1. mset_cl (C', \\<eta>) = mset_cl (D, \\<sigma>) \\<or>\n    (mset_cl (C', \\<eta>), mset_cl (D, \\<sigma>)) \\<in> mult (mult trm_ord)", "from this and iv"], ["proof (chain)\npicking this:\n  (\\<lambda>x. subst_lit x \\<theta>) ` D = C'\n  {#mset_lit (subst_lit x \\<eta>)\n  . x \\<in># mset_set\n              ((\\<lambda>x. subst_lit x \\<theta>) ` D)#} \\<subseteq>#\n  mset_cl (D, \\<sigma>)", "have \"{#mset_lit (subst_lit x \\<eta>). x \\<in># mset_set C' #} \\<subseteq># mset_cl (D, \\<sigma>)\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. subst_lit x \\<theta>) ` D = C'\n  {#mset_lit (subst_lit x \\<eta>)\n  . x \\<in># mset_set\n              ((\\<lambda>x. subst_lit x \\<theta>) ` D)#} \\<subseteq>#\n  mset_cl (D, \\<sigma>)\n\ngoal (1 subgoal):\n 1. {#mset_lit (subst_lit x \\<eta>). x \\<in># mset_set C'#} \\<subseteq>#\n    mset_cl (D, \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  {#mset_lit (subst_lit x \\<eta>). x \\<in># mset_set C'#} \\<subseteq>#\n  mset_cl (D, \\<sigma>)\n\ngoal (1 subgoal):\n 1. mset_cl (C', \\<eta>) = mset_cl (D, \\<sigma>) \\<or>\n    (mset_cl (C', \\<eta>), mset_cl (D, \\<sigma>)) \\<in> mult (mult trm_ord)", "from this"], ["proof (chain)\npicking this:\n  {#mset_lit (subst_lit x \\<eta>). x \\<in># mset_set C'#} \\<subseteq>#\n  mset_cl (D, \\<sigma>)", "have \"mset_cl (C', \\<eta>) \\<subseteq># mset_cl (D, \\<sigma>)\""], ["proof (prove)\nusing this:\n  {#mset_lit (subst_lit x \\<eta>). x \\<in># mset_set C'#} \\<subseteq>#\n  mset_cl (D, \\<sigma>)\n\ngoal (1 subgoal):\n 1. mset_cl (C', \\<eta>) \\<subseteq># mset_cl (D, \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  mset_cl (C', \\<eta>) \\<subseteq># mset_cl (D, \\<sigma>)\n\ngoal (1 subgoal):\n 1. mset_cl (C', \\<eta>) = mset_cl (D, \\<sigma>) \\<or>\n    (mset_cl (C', \\<eta>), mset_cl (D, \\<sigma>)) \\<in> mult (mult trm_ord)", "from this"], ["proof (chain)\npicking this:\n  mset_cl (C', \\<eta>) \\<subseteq># mset_cl (D, \\<sigma>)", "show ?thesis"], ["proof (prove)\nusing this:\n  mset_cl (C', \\<eta>) \\<subseteq># mset_cl (D, \\<sigma>)\n\ngoal (1 subgoal):\n 1. mset_cl (C', \\<eta>) = mset_cl (D, \\<sigma>) \\<or>\n    (mset_cl (C', \\<eta>), mset_cl (D, \\<sigma>)) \\<in> mult (mult trm_ord)", "using multiset_order_inclusion_eq mult_trm_ord_trans"], ["proof (prove)\nusing this:\n  mset_cl (C', \\<eta>) \\<subseteq># mset_cl (D, \\<sigma>)\n  \\<lbrakk>?E \\<subseteq># ?F; trans ?r\\<rbrakk>\n  \\<Longrightarrow> ?E = ?F \\<or> (?E, ?F) \\<in> mult ?r\n  trans (mult trm_ord)\n\ngoal (1 subgoal):\n 1. mset_cl (C', \\<eta>) = mset_cl (D, \\<sigma>) \\<or>\n    (mset_cl (C', \\<eta>), mset_cl (D, \\<sigma>)) \\<in> mult (mult trm_ord)", "by auto"], ["proof (state)\nthis:\n  mset_cl (C', \\<eta>) = mset_cl (D, \\<sigma>) \\<or>\n  (mset_cl (C', \\<eta>), mset_cl (D, \\<sigma>)) \\<in> mult (mult trm_ord)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma max_lit_exists:\n  shows \"finite C \\<Longrightarrow> C \\<noteq> {} \\<longrightarrow> ground_clause C \\<longrightarrow> (\\<exists>L. (L \\<in> C \\<and> (maximal_literal L C)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite C \\<Longrightarrow>\n    C \\<noteq> {} \\<longrightarrow>\n    ground_clause C \\<longrightarrow>\n    (\\<exists>L. L \\<in> C \\<and> maximal_literal L C)", "proof (induction rule: finite.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. {} \\<noteq> {} \\<longrightarrow>\n    ground_clause {} \\<longrightarrow>\n    (\\<exists>L. L \\<in> {} \\<and> maximal_literal L {})\n 2. \\<And>A a.\n       \\<lbrakk>finite A;\n        A \\<noteq> {} \\<longrightarrow>\n        ground_clause A \\<longrightarrow>\n        (\\<exists>L. L \\<in> A \\<and> maximal_literal L A)\\<rbrakk>\n       \\<Longrightarrow> insert a A \\<noteq> {} \\<longrightarrow>\n                         ground_clause (insert a A) \\<longrightarrow>\n                         (\\<exists>L.\n                             L \\<in> insert a A \\<and>\n                             maximal_literal L (insert a A))", "case emptyI"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. {} \\<noteq> {} \\<longrightarrow>\n    ground_clause {} \\<longrightarrow>\n    (\\<exists>L. L \\<in> {} \\<and> maximal_literal L {})\n 2. \\<And>A a.\n       \\<lbrakk>finite A;\n        A \\<noteq> {} \\<longrightarrow>\n        ground_clause A \\<longrightarrow>\n        (\\<exists>L. L \\<in> A \\<and> maximal_literal L A)\\<rbrakk>\n       \\<Longrightarrow> insert a A \\<noteq> {} \\<longrightarrow>\n                         ground_clause (insert a A) \\<longrightarrow>\n                         (\\<exists>L.\n                             L \\<in> insert a A \\<and>\n                             maximal_literal L (insert a A))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<noteq> {} \\<longrightarrow>\n    ground_clause {} \\<longrightarrow>\n    (\\<exists>L. L \\<in> {} \\<and> maximal_literal L {})", "by simp"], ["proof (state)\nthis:\n  {} \\<noteq> {} \\<longrightarrow>\n  ground_clause {} \\<longrightarrow>\n  (\\<exists>L. L \\<in> {} \\<and> maximal_literal L {})\n\ngoal (1 subgoal):\n 1. \\<And>A a.\n       \\<lbrakk>finite A;\n        A \\<noteq> {} \\<longrightarrow>\n        ground_clause A \\<longrightarrow>\n        (\\<exists>L. L \\<in> A \\<and> maximal_literal L A)\\<rbrakk>\n       \\<Longrightarrow> insert a A \\<noteq> {} \\<longrightarrow>\n                         ground_clause (insert a A) \\<longrightarrow>\n                         (\\<exists>L.\n                             L \\<in> insert a A \\<and>\n                             maximal_literal L (insert a A))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A a.\n       \\<lbrakk>finite A;\n        A \\<noteq> {} \\<longrightarrow>\n        ground_clause A \\<longrightarrow>\n        (\\<exists>L. L \\<in> A \\<and> maximal_literal L A)\\<rbrakk>\n       \\<Longrightarrow> insert a A \\<noteq> {} \\<longrightarrow>\n                         ground_clause (insert a A) \\<longrightarrow>\n                         (\\<exists>L.\n                             L \\<in> insert a A \\<and>\n                             maximal_literal L (insert a A))", "fix A :: \"'a clause\" and a:: \"'a literal\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A a.\n       \\<lbrakk>finite A;\n        A \\<noteq> {} \\<longrightarrow>\n        ground_clause A \\<longrightarrow>\n        (\\<exists>L. L \\<in> A \\<and> maximal_literal L A)\\<rbrakk>\n       \\<Longrightarrow> insert a A \\<noteq> {} \\<longrightarrow>\n                         ground_clause (insert a A) \\<longrightarrow>\n                         (\\<exists>L.\n                             L \\<in> insert a A \\<and>\n                             maximal_literal L (insert a A))", "assume \"finite A\""], ["proof (state)\nthis:\n  finite A\n\ngoal (1 subgoal):\n 1. \\<And>A a.\n       \\<lbrakk>finite A;\n        A \\<noteq> {} \\<longrightarrow>\n        ground_clause A \\<longrightarrow>\n        (\\<exists>L. L \\<in> A \\<and> maximal_literal L A)\\<rbrakk>\n       \\<Longrightarrow> insert a A \\<noteq> {} \\<longrightarrow>\n                         ground_clause (insert a A) \\<longrightarrow>\n                         (\\<exists>L.\n                             L \\<in> insert a A \\<and>\n                             maximal_literal L (insert a A))", "assume hyp_ind: \"A \\<noteq> {} \\<longrightarrow> ground_clause A \\<longrightarrow> (\\<exists>L. (L \\<in> A \\<and> (maximal_literal L A)))\""], ["proof (state)\nthis:\n  A \\<noteq> {} \\<longrightarrow>\n  ground_clause A \\<longrightarrow>\n  (\\<exists>L. L \\<in> A \\<and> maximal_literal L A)\n\ngoal (1 subgoal):\n 1. \\<And>A a.\n       \\<lbrakk>finite A;\n        A \\<noteq> {} \\<longrightarrow>\n        ground_clause A \\<longrightarrow>\n        (\\<exists>L. L \\<in> A \\<and> maximal_literal L A)\\<rbrakk>\n       \\<Longrightarrow> insert a A \\<noteq> {} \\<longrightarrow>\n                         ground_clause (insert a A) \\<longrightarrow>\n                         (\\<exists>L.\n                             L \\<in> insert a A \\<and>\n                             maximal_literal L (insert a A))", "show \"(insert a A) \\<noteq> {} \\<longrightarrow> ground_clause (insert a A) \n          \\<longrightarrow> (\\<exists>L. (L \\<in> (insert a A) \\<and> (maximal_literal L (insert a A))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert a A \\<noteq> {} \\<longrightarrow>\n    ground_clause (insert a A) \\<longrightarrow>\n    (\\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A))", "proof ((rule impI)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>insert a A \\<noteq> {}; ground_clause (insert a A)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>L.\n                         L \\<in> insert a A \\<and>\n                         maximal_literal L (insert a A)", "assume \"insert a A \\<noteq> {}\""], ["proof (state)\nthis:\n  insert a A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>insert a A \\<noteq> {}; ground_clause (insert a A)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>L.\n                         L \\<in> insert a A \\<and>\n                         maximal_literal L (insert a A)", "assume \"ground_clause (insert a A)\""], ["proof (state)\nthis:\n  ground_clause (insert a A)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>insert a A \\<noteq> {}; ground_clause (insert a A)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>L.\n                         L \\<in> insert a A \\<and>\n                         maximal_literal L (insert a A)", "show \"(\\<exists>L. (L \\<in> (insert a A) \\<and> (maximal_literal L (insert a A))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)", "assume \"A = {}\""], ["proof (state)\nthis:\n  A = {}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)", "then"], ["proof (chain)\npicking this:\n  A = {}", "have \"a \\<in> (insert a A) \\<and> (maximal_literal a (insert a A))\""], ["proof (prove)\nusing this:\n  A = {}\n\ngoal (1 subgoal):\n 1. a \\<in> insert a A \\<and> maximal_literal a (insert a A)", "unfolding maximal_literal_def"], ["proof (prove)\nusing this:\n  A = {}\n\ngoal (1 subgoal):\n 1. a \\<in> insert a A \\<and>\n    (\\<forall>x.\n        x \\<in> insert a A \\<longrightarrow> (a, x) \\<notin> lit_ord)", "using lit_ord_irrefl"], ["proof (prove)\nusing this:\n  A = {}\n  (?L, ?L) \\<notin> lit_ord\n\ngoal (1 subgoal):\n 1. a \\<in> insert a A \\<and>\n    (\\<forall>x.\n        x \\<in> insert a A \\<longrightarrow> (a, x) \\<notin> lit_ord)", "by auto"], ["proof (state)\nthis:\n  a \\<in> insert a A \\<and> maximal_literal a (insert a A)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)", "then"], ["proof (chain)\npicking this:\n  a \\<in> insert a A \\<and> maximal_literal a (insert a A)", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> insert a A \\<and> maximal_literal a (insert a A)\n\ngoal (1 subgoal):\n 1. \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)", "by auto"], ["proof (state)\nthis:\n  \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)", "assume \"A \\<noteq> {}\""], ["proof (state)\nthis:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)", "have \"insert a A = {a} \\<union> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert a A = {a} \\<union> A", "by auto"], ["proof (state)\nthis:\n  insert a A = {a} \\<union> A\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)", "then"], ["proof (chain)\npicking this:\n  insert a A = {a} \\<union> A", "have \"vars_of_cl (insert a A) = vars_of_cl A \\<union> vars_of_lit a\""], ["proof (prove)\nusing this:\n  insert a A = {a} \\<union> A\n\ngoal (1 subgoal):\n 1. vars_of_cl (insert a A) = vars_of_cl A \\<union> vars_of_lit a", "by auto"], ["proof (state)\nthis:\n  vars_of_cl (insert a A) = vars_of_cl A \\<union> vars_of_lit a\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)", "from this and \\<open>ground_clause (insert a A)\\<close>"], ["proof (chain)\npicking this:\n  vars_of_cl (insert a A) = vars_of_cl A \\<union> vars_of_lit a\n  ground_clause (insert a A)", "have \n        \"vars_of_lit a = {}\" and \"ground_clause A\""], ["proof (prove)\nusing this:\n  vars_of_cl (insert a A) = vars_of_cl A \\<union> vars_of_lit a\n  ground_clause (insert a A)\n\ngoal (1 subgoal):\n 1. vars_of_lit a = {} &&& ground_clause A", "by auto"], ["proof (state)\nthis:\n  vars_of_lit a = {}\n  ground_clause A\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)", "from \\<open>ground_clause A\\<close> and \\<open>A \\<noteq> {}\\<close> and hyp_ind"], ["proof (chain)\npicking this:\n  ground_clause A\n  A \\<noteq> {}\n  A \\<noteq> {} \\<longrightarrow>\n  ground_clause A \\<longrightarrow>\n  (\\<exists>L. L \\<in> A \\<and> maximal_literal L A)", "obtain b where\n        \"b \\<in> A\" and \"maximal_literal b A\""], ["proof (prove)\nusing this:\n  ground_clause A\n  A \\<noteq> {}\n  A \\<noteq> {} \\<longrightarrow>\n  ground_clause A \\<longrightarrow>\n  (\\<exists>L. L \\<in> A \\<and> maximal_literal L A)\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>b \\<in> A; maximal_literal b A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b \\<in> A\n  maximal_literal b A\n\ngoal (1 subgoal):\n 1. A \\<noteq> {} \\<Longrightarrow>\n    \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)", "assume \"maximal_literal a A\""], ["proof (state)\nthis:\n  maximal_literal a A\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)", "then"], ["proof (chain)\npicking this:\n  maximal_literal a A", "have \"maximal_literal a (insert a A)\""], ["proof (prove)\nusing this:\n  maximal_literal a A\n\ngoal (1 subgoal):\n 1. maximal_literal a (insert a A)", "using lit_ord_wf maximal_literal_def"], ["proof (prove)\nusing this:\n  maximal_literal a A\n  wf lit_ord\n  maximal_literal ?L ?C =\n  (\\<forall>x. x \\<in> ?C \\<longrightarrow> (?L, x) \\<notin> lit_ord)\n\ngoal (1 subgoal):\n 1. maximal_literal a (insert a A)", "by auto"], ["proof (state)\nthis:\n  maximal_literal a (insert a A)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)", "then"], ["proof (chain)\npicking this:\n  maximal_literal a (insert a A)", "show ?thesis"], ["proof (prove)\nusing this:\n  maximal_literal a (insert a A)\n\ngoal (1 subgoal):\n 1. \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)", "by auto"], ["proof (state)\nthis:\n  \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal a A \\<Longrightarrow>\n    \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> maximal_literal a A \\<Longrightarrow>\n    \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)", "assume \"\\<not>maximal_literal a A\""], ["proof (state)\nthis:\n  \\<not> maximal_literal a A\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal a A \\<Longrightarrow>\n    \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)", "then"], ["proof (chain)\npicking this:\n  \\<not> maximal_literal a A", "obtain a' where \"a' \\<in> A\" and \"(a,a') \\<in> lit_ord\""], ["proof (prove)\nusing this:\n  \\<not> maximal_literal a A\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a' \\<in> A; (a, a') \\<in> lit_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding maximal_literal_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x. x \\<in> A \\<longrightarrow> (a, x) \\<notin> lit_ord)\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>a' \\<in> A; (a, a') \\<in> lit_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a' \\<in> A\n  (a, a') \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal a A \\<Longrightarrow>\n    \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)", "from \\<open>a' \\<in> A\\<close> and \\<open>maximal_literal b A\\<close>"], ["proof (chain)\npicking this:\n  a' \\<in> A\n  maximal_literal b A", "have \"(b,a') \\<notin> lit_ord\""], ["proof (prove)\nusing this:\n  a' \\<in> A\n  maximal_literal b A\n\ngoal (1 subgoal):\n 1. (b, a') \\<notin> lit_ord", "unfolding maximal_literal_def"], ["proof (prove)\nusing this:\n  a' \\<in> A\n  \\<forall>x. x \\<in> A \\<longrightarrow> (b, x) \\<notin> lit_ord\n\ngoal (1 subgoal):\n 1. (b, a') \\<notin> lit_ord", "by auto"], ["proof (state)\nthis:\n  (b, a') \\<notin> lit_ord\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal a A \\<Longrightarrow>\n    \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)", "from this and \\<open>(a,a') \\<in> lit_ord\\<close>"], ["proof (chain)\npicking this:\n  (b, a') \\<notin> lit_ord\n  (a, a') \\<in> lit_ord", "have \"(b,a) \\<notin> lit_ord\""], ["proof (prove)\nusing this:\n  (b, a') \\<notin> lit_ord\n  (a, a') \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (b, a) \\<notin> lit_ord", "unfolding lit_ord_def"], ["proof (prove)\nusing this:\n  (b, a') \\<notin> {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}\n  (a, a') \\<in> {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}\n\ngoal (1 subgoal):\n 1. (b, a) \\<notin> {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}", "using mult_def trancl_trans"], ["proof (prove)\nusing this:\n  (b, a') \\<notin> {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}\n  (a, a') \\<in> {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}\n  mult ?r = (mult1 ?r)\\<^sup>+\n  \\<lbrakk>(?x, ?y) \\<in> ?r\\<^sup>+; (?y, ?z) \\<in> ?r\\<^sup>+\\<rbrakk>\n  \\<Longrightarrow> (?x, ?z) \\<in> ?r\\<^sup>+\n\ngoal (1 subgoal):\n 1. (b, a) \\<notin> {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}", "by fastforce"], ["proof (state)\nthis:\n  (b, a) \\<notin> lit_ord\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal a A \\<Longrightarrow>\n    \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)", "from this and \\<open>maximal_literal b A\\<close>"], ["proof (chain)\npicking this:\n  (b, a) \\<notin> lit_ord\n  maximal_literal b A", "have \"maximal_literal b (insert a A)\""], ["proof (prove)\nusing this:\n  (b, a) \\<notin> lit_ord\n  maximal_literal b A\n\ngoal (1 subgoal):\n 1. maximal_literal b (insert a A)", "unfolding maximal_literal_def"], ["proof (prove)\nusing this:\n  (b, a) \\<notin> lit_ord\n  \\<forall>x. x \\<in> A \\<longrightarrow> (b, x) \\<notin> lit_ord\n\ngoal (1 subgoal):\n 1. \\<forall>x. x \\<in> insert a A \\<longrightarrow> (b, x) \\<notin> lit_ord", "by simp"], ["proof (state)\nthis:\n  maximal_literal b (insert a A)\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal a A \\<Longrightarrow>\n    \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)", "from this and \\<open>b \\<in> A\\<close>"], ["proof (chain)\npicking this:\n  maximal_literal b (insert a A)\n  b \\<in> A", "show ?thesis"], ["proof (prove)\nusing this:\n  maximal_literal b (insert a A)\n  b \\<in> A\n\ngoal (1 subgoal):\n 1. \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)", "by auto"], ["proof (state)\nthis:\n  \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  insert a A \\<noteq> {} \\<longrightarrow>\n  ground_clause (insert a A) \\<longrightarrow>\n  (\\<exists>L. L \\<in> insert a A \\<and> maximal_literal L (insert a A))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We deduce that a clause contains at least one eligible literal.\\<close>"], ["", "lemma eligible_lit_exists:\n  assumes \"finite (cl_ecl C)\"\n  assumes \"(cl_ecl C) \\<noteq> {}\"\n  assumes \"(ground_clause (subst_cl (cl_ecl C) \\<sigma>))\"\n  shows \"\\<exists>L. ((eligible_literal L C \\<sigma>) \\<and> (L \\<in> (cl_ecl C)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>L. eligible_literal L C \\<sigma> \\<and> L \\<in> cl_ecl C", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>L. eligible_literal L C \\<sigma> \\<and> L \\<in> cl_ecl C\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>L. eligible_literal L C \\<sigma> \\<and> L \\<in> cl_ecl C", "assume \"sel (cl_ecl C) = {}\""], ["proof (state)\nthis:\n  sel (cl_ecl C) = {}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>L. eligible_literal L C \\<sigma> \\<and> L \\<in> cl_ecl C\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>L. eligible_literal L C \\<sigma> \\<and> L \\<in> cl_ecl C", "let ?C = \"(subst_cl (cl_ecl C) \\<sigma>)\""], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>L. eligible_literal L C \\<sigma> \\<and> L \\<in> cl_ecl C\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>L. eligible_literal L C \\<sigma> \\<and> L \\<in> cl_ecl C", "have \"finite ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (subst_cl (cl_ecl C) \\<sigma>)", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  finite (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>L. eligible_literal L C \\<sigma> \\<and> L \\<in> cl_ecl C\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>L. eligible_literal L C \\<sigma> \\<and> L \\<in> cl_ecl C", "have \"?C \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl C) \\<sigma> \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl C) \\<sigma> \\<noteq> {}", "from assms(2)"], ["proof (chain)\npicking this:\n  cl_ecl C \\<noteq> {}", "obtain L where \"L \\<in> (cl_ecl C)\""], ["proof (prove)\nusing this:\n  cl_ecl C \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>L. L \\<in> cl_ecl C \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl C) \\<sigma> \\<noteq> {}", "from this"], ["proof (chain)\npicking this:\n  L \\<in> cl_ecl C", "have \"(subst_lit L \\<sigma>) \\<in> ?C\""], ["proof (prove)\nusing this:\n  L \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. subst_lit L \\<sigma> \\<in> subst_cl (cl_ecl C) \\<sigma>", "by auto"], ["proof (state)\nthis:\n  subst_lit L \\<sigma> \\<in> subst_cl (cl_ecl C) \\<sigma>\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl C) \\<sigma> \\<noteq> {}", "from this"], ["proof (chain)\npicking this:\n  subst_lit L \\<sigma> \\<in> subst_cl (cl_ecl C) \\<sigma>", "show \"?C \\<noteq> {}\""], ["proof (prove)\nusing this:\n  subst_lit L \\<sigma> \\<in> subst_cl (cl_ecl C) \\<sigma>\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl C) \\<sigma> \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  subst_cl (cl_ecl C) \\<sigma> \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst_cl (cl_ecl C) \\<sigma> \\<noteq> {}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>L. eligible_literal L C \\<sigma> \\<and> L \\<in> cl_ecl C\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>L. eligible_literal L C \\<sigma> \\<and> L \\<in> cl_ecl C", "from \\<open>finite ?C\\<close> \\<open>?C \\<noteq> {}\\<close> assms(3)"], ["proof (chain)\npicking this:\n  finite (subst_cl (cl_ecl C) \\<sigma>)\n  subst_cl (cl_ecl C) \\<sigma> \\<noteq> {}\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)", "obtain L where \"L \\<in> ?C\" \"maximal_literal L ?C\""], ["proof (prove)\nusing this:\n  finite (subst_cl (cl_ecl C) \\<sigma>)\n  subst_cl (cl_ecl C) \\<sigma> \\<noteq> {}\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>L \\<in> subst_cl (cl_ecl C) \\<sigma>;\n         maximal_literal L (subst_cl (cl_ecl C) \\<sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using max_lit_exists"], ["proof (prove)\nusing this:\n  finite (subst_cl (cl_ecl C) \\<sigma>)\n  subst_cl (cl_ecl C) \\<sigma> \\<noteq> {}\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n  finite ?C \\<Longrightarrow>\n  ?C \\<noteq> {} \\<longrightarrow>\n  ground_clause ?C \\<longrightarrow>\n  (\\<exists>L. L \\<in> ?C \\<and> maximal_literal L ?C)\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>L \\<in> subst_cl (cl_ecl C) \\<sigma>;\n         maximal_literal L (subst_cl (cl_ecl C) \\<sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  L \\<in> subst_cl (cl_ecl C) \\<sigma>\n  maximal_literal L (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>L. eligible_literal L C \\<sigma> \\<and> L \\<in> cl_ecl C\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>L. eligible_literal L C \\<sigma> \\<and> L \\<in> cl_ecl C", "from \\<open>L \\<in> ?C\\<close>"], ["proof (chain)\npicking this:\n  L \\<in> subst_cl (cl_ecl C) \\<sigma>", "obtain L' where \"L' \\<in> (cl_ecl C)\" and \"L = (subst_lit L' \\<sigma>)\""], ["proof (prove)\nusing this:\n  L \\<in> subst_cl (cl_ecl C) \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>L'.\n        \\<lbrakk>L' \\<in> cl_ecl C; L = subst_lit L' \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L' \\<in> cl_ecl C\n  L = subst_lit L' \\<sigma>\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>L. eligible_literal L C \\<sigma> \\<and> L \\<in> cl_ecl C\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>L. eligible_literal L C \\<sigma> \\<and> L \\<in> cl_ecl C", "from \\<open>L' \\<in> (cl_ecl C)\\<close> \\<open>L = (subst_lit L' \\<sigma>)\\<close> \\<open>maximal_literal L ?C\\<close> \\<open>sel (cl_ecl C) = {}\\<close>"], ["proof (chain)\npicking this:\n  L' \\<in> cl_ecl C\n  L = subst_lit L' \\<sigma>\n  maximal_literal L (subst_cl (cl_ecl C) \\<sigma>)\n  sel (cl_ecl C) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  L' \\<in> cl_ecl C\n  L = subst_lit L' \\<sigma>\n  maximal_literal L (subst_cl (cl_ecl C) \\<sigma>)\n  sel (cl_ecl C) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>L. eligible_literal L C \\<sigma> \\<and> L \\<in> cl_ecl C", "unfolding eligible_literal_def"], ["proof (prove)\nusing this:\n  L' \\<in> cl_ecl C\n  L = subst_lit L' \\<sigma>\n  maximal_literal L (subst_cl (cl_ecl C) \\<sigma>)\n  sel (cl_ecl C) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>L.\n       (L \\<in> sel (cl_ecl C) \\<or>\n        sel (cl_ecl C) = {} \\<and>\n        maximal_literal (subst_lit L \\<sigma>)\n         (subst_cl (cl_ecl C) \\<sigma>)) \\<and>\n       L \\<in> cl_ecl C", "by metis"], ["proof (state)\nthis:\n  \\<exists>L. eligible_literal L C \\<sigma> \\<and> L \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C) \\<noteq> {} \\<Longrightarrow>\n    \\<exists>L. eligible_literal L C \\<sigma> \\<and> L \\<in> cl_ecl C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sel (cl_ecl C) \\<noteq> {} \\<Longrightarrow>\n    \\<exists>L. eligible_literal L C \\<sigma> \\<and> L \\<in> cl_ecl C", "assume \"sel (cl_ecl C) \\<noteq> {}\""], ["proof (state)\nthis:\n  sel (cl_ecl C) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C) \\<noteq> {} \\<Longrightarrow>\n    \\<exists>L. eligible_literal L C \\<sigma> \\<and> L \\<in> cl_ecl C", "then"], ["proof (chain)\npicking this:\n  sel (cl_ecl C) \\<noteq> {}", "obtain L where \"L \\<in> sel (cl_ecl C)\""], ["proof (prove)\nusing this:\n  sel (cl_ecl C) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        L \\<in> sel (cl_ecl C) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L \\<in> sel (cl_ecl C)\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C) \\<noteq> {} \\<Longrightarrow>\n    \\<exists>L. eligible_literal L C \\<sigma> \\<and> L \\<in> cl_ecl C", "from this"], ["proof (chain)\npicking this:\n  L \\<in> sel (cl_ecl C)", "show ?thesis"], ["proof (prove)\nusing this:\n  L \\<in> sel (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<exists>L. eligible_literal L C \\<sigma> \\<and> L \\<in> cl_ecl C", "unfolding eligible_literal_def"], ["proof (prove)\nusing this:\n  L \\<in> sel (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<exists>L.\n       (L \\<in> sel (cl_ecl C) \\<or>\n        sel (cl_ecl C) = {} \\<and>\n        maximal_literal (subst_lit L \\<sigma>)\n         (subst_cl (cl_ecl C) \\<sigma>)) \\<and>\n       L \\<in> cl_ecl C", "using sel_neg"], ["proof (prove)\nusing this:\n  L \\<in> sel (cl_ecl C)\n  \\<forall>x.\n     sel (cl_ecl x) \\<subseteq> cl_ecl x \\<and>\n     (\\<forall>y\\<in>sel (cl_ecl x). negative_literal y)\n\ngoal (1 subgoal):\n 1. \\<exists>L.\n       (L \\<in> sel (cl_ecl C) \\<or>\n        sel (cl_ecl C) = {} \\<and>\n        maximal_literal (subst_lit L \\<sigma>)\n         (subst_cl (cl_ecl C) \\<sigma>)) \\<and>\n       L \\<in> cl_ecl C", "by blast"], ["proof (state)\nthis:\n  \\<exists>L. eligible_literal L C \\<sigma> \\<and> L \\<in> cl_ecl C\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The following lemmata provide various ways of proving that literals are ordered, depending \non the relations between the terms they contain.\\<close>"], ["", "lemma lit_ord_dominating_term:\n  assumes \"(s1,s2) \\<in> trm_ord \\<or> (s1,t2) \\<in> trm_ord\"\n  assumes \"orient_lit x1 s1 t1 p1\"\n  assumes \"orient_lit x2 s2 t2 p2\"\n  assumes \"vars_of_lit x1 = {}\"\n  assumes \"vars_of_lit x2 = {}\"\n  shows \"(x1,x2) \\<in> lit_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from \\<open>vars_of_lit x1 = {}\\<close> and \\<open>orient_lit x1 s1 t1 p1\\<close>"], ["proof (chain)\npicking this:\n  vars_of_lit x1 = {}\n  orient_lit x1 s1 t1 p1", "have \"vars_of t1 = {}\" and \"vars_of s1 = {}\" \n    and \"\\<not>(s1,t1) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  vars_of_lit x1 = {}\n  orient_lit x1 s1 t1 p1\n\ngoal (1 subgoal):\n 1. vars_of t1 = {} &&& vars_of s1 = {} &&& (s1, t1) \\<notin> trm_ord", "unfolding orient_lit_def"], ["proof (prove)\nusing this:\n  vars_of_lit x1 = {}\n  (x1 = Pos (Eq s1 t1) \\<or> x1 = Pos (Eq t1 s1)) \\<and>\n  (s1, t1) \\<notin> trm_ord \\<and> p1 = pos \\<or>\n  (x1 = Neg (Eq s1 t1) \\<or> x1 = Neg (Eq t1 s1)) \\<and>\n  (s1, t1) \\<notin> trm_ord \\<and> p1 = neg\n\ngoal (1 subgoal):\n 1. vars_of t1 = {} &&& vars_of s1 = {} &&& (s1, t1) \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  vars_of t1 = {}\n  vars_of s1 = {}\n  (s1, t1) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from assms(5) and \\<open>orient_lit x2 s2 t2 p2\\<close>"], ["proof (chain)\npicking this:\n  vars_of_lit x2 = {}\n  orient_lit x2 s2 t2 p2", "have \"vars_of t2 = {}\" and \"vars_of s2 = {}\" \n    and \"\\<not>(s2,t2) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  vars_of_lit x2 = {}\n  orient_lit x2 s2 t2 p2\n\ngoal (1 subgoal):\n 1. vars_of t2 = {} &&& vars_of s2 = {} &&& (s2, t2) \\<notin> trm_ord", "unfolding orient_lit_def"], ["proof (prove)\nusing this:\n  vars_of_lit x2 = {}\n  (x2 = Pos (Eq s2 t2) \\<or> x2 = Pos (Eq t2 s2)) \\<and>\n  (s2, t2) \\<notin> trm_ord \\<and> p2 = pos \\<or>\n  (x2 = Neg (Eq s2 t2) \\<or> x2 = Neg (Eq t2 s2)) \\<and>\n  (s2, t2) \\<notin> trm_ord \\<and> p2 = neg\n\ngoal (1 subgoal):\n 1. vars_of t2 = {} &&& vars_of s2 = {} &&& (s2, t2) \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  vars_of t2 = {}\n  vars_of s2 = {}\n  (s2, t2) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from \\<open>vars_of t1 = {}\\<close> and \\<open>vars_of s1 = {}\\<close> and \\<open>\\<not>(s1,t1) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  vars_of t1 = {}\n  vars_of s1 = {}\n  (s1, t1) \\<notin> trm_ord", "have o1: \"t1 = s1 \\<or> (t1,s1) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  vars_of t1 = {}\n  vars_of s1 = {}\n  (s1, t1) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. t1 = s1 \\<or> (t1, s1) \\<in> trm_ord", "using trm_ord_ground_total"], ["proof (prove)\nusing this:\n  vars_of t1 = {}\n  vars_of s1 = {}\n  (s1, t1) \\<notin> trm_ord\n  \\<forall>x y.\n     ground_term x \\<longrightarrow>\n     ground_term y \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t1 = s1 \\<or> (t1, s1) \\<in> trm_ord", "unfolding ground_term_def"], ["proof (prove)\nusing this:\n  vars_of t1 = {}\n  vars_of s1 = {}\n  (s1, t1) \\<notin> trm_ord\n  \\<forall>x y.\n     vars_of x = {} \\<longrightarrow>\n     vars_of y = {} \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t1 = s1 \\<or> (t1, s1) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  t1 = s1 \\<or> (t1, s1) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from \\<open>vars_of t2 = {}\\<close> and \\<open>vars_of s2 = {}\\<close> and \\<open>\\<not>(s2,t2) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  vars_of t2 = {}\n  vars_of s2 = {}\n  (s2, t2) \\<notin> trm_ord", "have o2: \"t2 = s2 \\<or> (t2,s2) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  vars_of t2 = {}\n  vars_of s2 = {}\n  (s2, t2) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. t2 = s2 \\<or> (t2, s2) \\<in> trm_ord", "using trm_ord_ground_total"], ["proof (prove)\nusing this:\n  vars_of t2 = {}\n  vars_of s2 = {}\n  (s2, t2) \\<notin> trm_ord\n  \\<forall>x y.\n     ground_term x \\<longrightarrow>\n     ground_term y \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t2 = s2 \\<or> (t2, s2) \\<in> trm_ord", "unfolding ground_term_def"], ["proof (prove)\nusing this:\n  vars_of t2 = {}\n  vars_of s2 = {}\n  (s2, t2) \\<notin> trm_ord\n  \\<forall>x y.\n     vars_of x = {} \\<longrightarrow>\n     vars_of y = {} \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t2 = s2 \\<or> (t2, s2) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  t2 = s2 \\<or> (t2, s2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from \\<open>\\<not>(s2,t2) \\<in> trm_ord\\<close> and assms(1)"], ["proof (chain)\npicking this:\n  (s2, t2) \\<notin> trm_ord\n  (s1, s2) \\<in> trm_ord \\<or> (s1, t2) \\<in> trm_ord", "have \"(s1,s2) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (s2, t2) \\<notin> trm_ord\n  (s1, s2) \\<in> trm_ord \\<or> (s1, t2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (s1, s2) \\<in> trm_ord", "by (metis assms(1) o2 trm_ord_trans transE)"], ["proof (state)\nthis:\n  (s1, s2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "let ?m1 = \"mset_lit x1\""], ["proof (state)\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "let ?m2 = \"mset_lit x2\""], ["proof (state)\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from assms(1) and o1 and o2"], ["proof (chain)\npicking this:\n  (s1, s2) \\<in> trm_ord \\<or> (s1, t2) \\<in> trm_ord\n  t1 = s1 \\<or> (t1, s1) \\<in> trm_ord\n  t2 = s2 \\<or> (t2, s2) \\<in> trm_ord", "have \"(t1,s2) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (s1, s2) \\<in> trm_ord \\<or> (s1, t2) \\<in> trm_ord\n  t1 = s1 \\<or> (t1, s1) \\<in> trm_ord\n  t2 = s2 \\<or> (t2, s2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (t1, s2) \\<in> trm_ord", "using trm_ord_trans \n     trans_def"], ["proof (prove)\nusing this:\n  (s1, s2) \\<in> trm_ord \\<or> (s1, t2) \\<in> trm_ord\n  t1 = s1 \\<or> (t1, s1) \\<in> trm_ord\n  t2 = s2 \\<or> (t2, s2) \\<in> trm_ord\n  trans trm_ord\n  trans ?r =\n  (\\<forall>x y z.\n      (x, y) \\<in> ?r \\<longrightarrow>\n      (y, z) \\<in> ?r \\<longrightarrow> (x, z) \\<in> ?r)\n\ngoal (1 subgoal):\n 1. (t1, s2) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (t1, s2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from this and \\<open>(s1,s2) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  (t1, s2) \\<in> trm_ord\n  (s1, s2) \\<in> trm_ord", "have \n    s2max: \"\\<forall>x. (x \\<in># {# t1,t1,s1,s1 #} \\<longrightarrow> (x,s2) \\<in> trm_ord)\""], ["proof (prove)\nusing this:\n  (t1, s2) \\<in> trm_ord\n  (s1, s2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<in># {#t1, t1, s1, s1#} \\<longrightarrow> (x, s2) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  \\<forall>x.\n     x \\<in># {#t1, t1, s1, s1#} \\<longrightarrow> (x, s2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "have \"{# s2 #} \\<subset># {# t2,t2,s2,s2 #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#s2#} \\<subset># {#t2, t2, s2, s2#}", "by simp"], ["proof (state)\nthis:\n  {#s2#} \\<subset># {#t2, t2, s2, s2#}\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from \\<open>{# s2 #} \\<subset># {# t2,t2,s2,s2 #}\\<close>"], ["proof (chain)\npicking this:\n  {#s2#} \\<subset># {#t2, t2, s2, s2#}", "have \"( {# s2 #}, {# t2,t2,s2,s2 #} ) \\<in> mult trm_ord\""], ["proof (prove)\nusing this:\n  {#s2#} \\<subset># {#t2, t2, s2, s2#}\n\ngoal (1 subgoal):\n 1. ({#s2#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord", "using trm_ord_trans multiset_order_inclusion [of \"{# s2 #}\" \"{# t2,t2,s2,s2 #}\" \"trm_ord\"]"], ["proof (prove)\nusing this:\n  {#s2#} \\<subset># {#t2, t2, s2, s2#}\n  trans trm_ord\n  \\<lbrakk>{#s2#} \\<subset># {#t2, t2, s2, s2#}; trans trm_ord\\<rbrakk>\n  \\<Longrightarrow> ({#s2#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. ({#s2#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  ({#s2#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "have \"p1 = neg \\<or> p1 = pos\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 = neg \\<or> p1 = pos", "using sign.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = pos \\<Longrightarrow> ?P;\n   ?y = neg \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. p1 = neg \\<or> p1 = pos", "by auto"], ["proof (state)\nthis:\n  p1 = neg \\<or> p1 = pos\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "then"], ["proof (chain)\npicking this:\n  p1 = neg \\<or> p1 = pos", "show ?thesis"], ["proof (prove)\nusing this:\n  p1 = neg \\<or> p1 = pos\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p1 = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. p1 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "assume \"p1 = neg\""], ["proof (state)\nthis:\n  p1 = neg\n\ngoal (2 subgoals):\n 1. p1 = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. p1 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this and \\<open>orient_lit x1 s1 t1 p1\\<close>"], ["proof (chain)\npicking this:\n  p1 = neg\n  orient_lit x1 s1 t1 p1", "have \"x1 = (Neg (Eq t1 s1)) \\<or> x1 = (Neg (Eq s1 t1))\""], ["proof (prove)\nusing this:\n  p1 = neg\n  orient_lit x1 s1 t1 p1\n\ngoal (1 subgoal):\n 1. x1 = Neg (Eq t1 s1) \\<or> x1 = Neg (Eq s1 t1)", "using orient_lit_def"], ["proof (prove)\nusing this:\n  p1 = neg\n  orient_lit x1 s1 t1 p1\n  orient_lit ?L ?u ?v ?s =\n  ((?L = Pos (Eq ?u ?v) \\<or> ?L = Pos (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = pos \\<or>\n   (?L = Neg (Eq ?u ?v) \\<or> ?L = Neg (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = neg)\n\ngoal (1 subgoal):\n 1. x1 = Neg (Eq t1 s1) \\<or> x1 = Neg (Eq s1 t1)", "by blast"], ["proof (state)\nthis:\n  x1 = Neg (Eq t1 s1) \\<or> x1 = Neg (Eq s1 t1)\n\ngoal (2 subgoals):\n 1. p1 = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. p1 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  x1 = Neg (Eq t1 s1) \\<or> x1 = Neg (Eq s1 t1)", "have m1: \"?m1 = {# t1,t1,s1,s1 #}\""], ["proof (prove)\nusing this:\n  x1 = Neg (Eq t1 s1) \\<or> x1 = Neg (Eq s1 t1)\n\ngoal (1 subgoal):\n 1. mset_lit x1 = {#t1, t1, s1, s1#}", "using mset_lit.simps"], ["proof (prove)\nusing this:\n  x1 = Neg (Eq t1 s1) \\<or> x1 = Neg (Eq s1 t1)\n  mset_lit (Pos (Eq ?t ?s)) = {#?t, ?s#}\n  mset_lit (Neg (Eq ?t ?s)) = {#?t, ?t, ?s, ?s#}\n\ngoal (1 subgoal):\n 1. mset_lit x1 = {#t1, t1, s1, s1#}", "by auto"], ["proof (state)\nthis:\n  mset_lit x1 = {#t1, t1, s1, s1#}\n\ngoal (2 subgoals):\n 1. p1 = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. p1 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "have \"p2 = neg \\<or> p2 = pos\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p2 = neg \\<or> p2 = pos", "using sign.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = pos \\<Longrightarrow> ?P;\n   ?y = neg \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. p2 = neg \\<or> p2 = pos", "by auto"], ["proof (state)\nthis:\n  p2 = neg \\<or> p2 = pos\n\ngoal (2 subgoals):\n 1. p1 = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. p1 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "then"], ["proof (chain)\npicking this:\n  p2 = neg \\<or> p2 = pos", "show ?thesis"], ["proof (prove)\nusing this:\n  p2 = neg \\<or> p2 = pos\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p2 = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. p2 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "assume \"p2 = neg\""], ["proof (state)\nthis:\n  p2 = neg\n\ngoal (2 subgoals):\n 1. p2 = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. p2 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this and \\<open>orient_lit x2 s2 t2 p2\\<close>"], ["proof (chain)\npicking this:\n  p2 = neg\n  orient_lit x2 s2 t2 p2", "have \"x2 = (Neg (Eq t2 s2)) \\<or> x2 = (Neg (Eq s2 t2))\""], ["proof (prove)\nusing this:\n  p2 = neg\n  orient_lit x2 s2 t2 p2\n\ngoal (1 subgoal):\n 1. x2 = Neg (Eq t2 s2) \\<or> x2 = Neg (Eq s2 t2)", "using orient_lit_def"], ["proof (prove)\nusing this:\n  p2 = neg\n  orient_lit x2 s2 t2 p2\n  orient_lit ?L ?u ?v ?s =\n  ((?L = Pos (Eq ?u ?v) \\<or> ?L = Pos (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = pos \\<or>\n   (?L = Neg (Eq ?u ?v) \\<or> ?L = Neg (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = neg)\n\ngoal (1 subgoal):\n 1. x2 = Neg (Eq t2 s2) \\<or> x2 = Neg (Eq s2 t2)", "by blast"], ["proof (state)\nthis:\n  x2 = Neg (Eq t2 s2) \\<or> x2 = Neg (Eq s2 t2)\n\ngoal (2 subgoals):\n 1. p2 = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. p2 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  x2 = Neg (Eq t2 s2) \\<or> x2 = Neg (Eq s2 t2)", "have m2: \"?m2 = {# t2,t2,s2,s2 #}\""], ["proof (prove)\nusing this:\n  x2 = Neg (Eq t2 s2) \\<or> x2 = Neg (Eq s2 t2)\n\ngoal (1 subgoal):\n 1. mset_lit x2 = {#t2, t2, s2, s2#}", "using mset_lit.simps"], ["proof (prove)\nusing this:\n  x2 = Neg (Eq t2 s2) \\<or> x2 = Neg (Eq s2 t2)\n  mset_lit (Pos (Eq ?t ?s)) = {#?t, ?s#}\n  mset_lit (Neg (Eq ?t ?s)) = {#?t, ?t, ?s, ?s#}\n\ngoal (1 subgoal):\n 1. mset_lit x2 = {#t2, t2, s2, s2#}", "by auto"], ["proof (state)\nthis:\n  mset_lit x2 = {#t2, t2, s2, s2#}\n\ngoal (2 subgoals):\n 1. p2 = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. p2 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from s2max"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     x \\<in># {#t1, t1, s1, s1#} \\<longrightarrow> (x, s2) \\<in> trm_ord", "have \"({# t1,t1,s1,s1 #}, {# s2 #}) \\<in> mult trm_ord\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in># {#t1, t1, s1, s1#} \\<longrightarrow> (x, s2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. ({#t1, t1, s1, s1#}, {#s2#}) \\<in> mult trm_ord", "using mult1_def_lemma [of \"{# s2 #}\" \"{#}\" s2 \"{# t1,t1,s1,s1 #}\" \"{# t1,t1,s1,s1 #}\" trm_ord]\n        mult_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in># {#t1, t1, s1, s1#} \\<longrightarrow> (x, s2) \\<in> trm_ord\n  {#s2#} = {#} + {#s2#} \\<and>\n  {#t1, t1, s1, s1#} = {#} + {#t1, t1, s1, s1#} \\<and>\n  (\\<forall>b.\n      b \\<in># {#t1, t1, s1, s1#} \\<longrightarrow>\n      (b, s2) \\<in> trm_ord) \\<Longrightarrow>\n  ({#t1, t1, s1, s1#}, {#s2#}) \\<in> mult1 trm_ord\n  mult ?r = (mult1 ?r)\\<^sup>+\n\ngoal (1 subgoal):\n 1. ({#t1, t1, s1, s1#}, {#s2#}) \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  ({#t1, t1, s1, s1#}, {#s2#}) \\<in> mult trm_ord\n\ngoal (2 subgoals):\n 1. p2 = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. p2 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from \\<open>( {# s2 #}, {# t2,t2,s2,s2 #} ) \\<in> mult trm_ord\\<close> and \\<open>({# t1,t1,s1,s1 #}, {# s2 #}) \\<in> mult trm_ord\\<close>"], ["proof (chain)\npicking this:\n  ({#s2#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord\n  ({#t1, t1, s1, s1#}, {#s2#}) \\<in> mult trm_ord", "have \"( {# t1,t1,s1,s1 #}, {# t2,t2,s2,s2 #} ) \\<in> mult trm_ord\""], ["proof (prove)\nusing this:\n  ({#s2#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord\n  ({#t1, t1, s1, s1#}, {#s2#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. ({#t1, t1, s1, s1#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord", "using mult_trm_ord_trans"], ["proof (prove)\nusing this:\n  ({#s2#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord\n  ({#t1, t1, s1, s1#}, {#s2#}) \\<in> mult trm_ord\n  trans (mult trm_ord)\n\ngoal (1 subgoal):\n 1. ({#t1, t1, s1, s1#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord", "unfolding trans_def"], ["proof (prove)\nusing this:\n  ({#s2#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord\n  ({#t1, t1, s1, s1#}, {#s2#}) \\<in> mult trm_ord\n  \\<forall>x y z.\n     (x, y) \\<in> mult trm_ord \\<longrightarrow>\n     (y, z) \\<in> mult trm_ord \\<longrightarrow> (x, z) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. ({#t1, t1, s1, s1#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord", "by blast"], ["proof (state)\nthis:\n  ({#t1, t1, s1, s1#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord\n\ngoal (2 subgoals):\n 1. p2 = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. p2 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this and m1 and m2"], ["proof (chain)\npicking this:\n  ({#t1, t1, s1, s1#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord\n  mset_lit x1 = {#t1, t1, s1, s1#}\n  mset_lit x2 = {#t2, t2, s2, s2#}", "show ?thesis"], ["proof (prove)\nusing this:\n  ({#t1, t1, s1, s1#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord\n  mset_lit x1 = {#t1, t1, s1, s1#}\n  mset_lit x2 = {#t2, t2, s2, s2#}\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "using lit_ord_def"], ["proof (prove)\nusing this:\n  ({#t1, t1, s1, s1#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord\n  mset_lit x1 = {#t1, t1, s1, s1#}\n  mset_lit x2 = {#t2, t2, s2, s2#}\n  lit_ord = {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "by auto"], ["proof (state)\nthis:\n  (x1, x2) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. p2 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p2 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "assume \"p2 = pos\""], ["proof (state)\nthis:\n  p2 = pos\n\ngoal (1 subgoal):\n 1. p2 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this and \\<open>orient_lit x2 s2 t2 p2\\<close>"], ["proof (chain)\npicking this:\n  p2 = pos\n  orient_lit x2 s2 t2 p2", "have \"x2 = (Pos (Eq t2 s2)) \\<or> x2 = (Pos (Eq s2 t2))\""], ["proof (prove)\nusing this:\n  p2 = pos\n  orient_lit x2 s2 t2 p2\n\ngoal (1 subgoal):\n 1. x2 = Pos (Eq t2 s2) \\<or> x2 = Pos (Eq s2 t2)", "using orient_lit_def"], ["proof (prove)\nusing this:\n  p2 = pos\n  orient_lit x2 s2 t2 p2\n  orient_lit ?L ?u ?v ?s =\n  ((?L = Pos (Eq ?u ?v) \\<or> ?L = Pos (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = pos \\<or>\n   (?L = Neg (Eq ?u ?v) \\<or> ?L = Neg (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = neg)\n\ngoal (1 subgoal):\n 1. x2 = Pos (Eq t2 s2) \\<or> x2 = Pos (Eq s2 t2)", "by blast"], ["proof (state)\nthis:\n  x2 = Pos (Eq t2 s2) \\<or> x2 = Pos (Eq s2 t2)\n\ngoal (1 subgoal):\n 1. p2 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  x2 = Pos (Eq t2 s2) \\<or> x2 = Pos (Eq s2 t2)", "have m2: \"?m2 = {# t2,s2 #}\""], ["proof (prove)\nusing this:\n  x2 = Pos (Eq t2 s2) \\<or> x2 = Pos (Eq s2 t2)\n\ngoal (1 subgoal):\n 1. mset_lit x2 = {#t2, s2#}", "using mset_lit.simps"], ["proof (prove)\nusing this:\n  x2 = Pos (Eq t2 s2) \\<or> x2 = Pos (Eq s2 t2)\n  mset_lit (Pos (Eq ?t ?s)) = {#?t, ?s#}\n  mset_lit (Neg (Eq ?t ?s)) = {#?t, ?t, ?s, ?s#}\n\ngoal (1 subgoal):\n 1. mset_lit x2 = {#t2, s2#}", "by auto"], ["proof (state)\nthis:\n  mset_lit x2 = {#t2, s2#}\n\ngoal (1 subgoal):\n 1. p2 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from s2max"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     x \\<in># {#t1, t1, s1, s1#} \\<longrightarrow> (x, s2) \\<in> trm_ord", "have \"({# t1,t1,s1,s1 #}, {# s2 #}) \\<in> mult trm_ord\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in># {#t1, t1, s1, s1#} \\<longrightarrow> (x, s2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. ({#t1, t1, s1, s1#}, {#s2#}) \\<in> mult trm_ord", "using mult1_def_lemma [of \"{# s2 #}\" \"{#}\" s2 \"{# t1,t1,s1,s1 #}\" \"{# t1,t1,s1,s1 #}\" trm_ord]\n        mult_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in># {#t1, t1, s1, s1#} \\<longrightarrow> (x, s2) \\<in> trm_ord\n  {#s2#} = {#} + {#s2#} \\<and>\n  {#t1, t1, s1, s1#} = {#} + {#t1, t1, s1, s1#} \\<and>\n  (\\<forall>b.\n      b \\<in># {#t1, t1, s1, s1#} \\<longrightarrow>\n      (b, s2) \\<in> trm_ord) \\<Longrightarrow>\n  ({#t1, t1, s1, s1#}, {#s2#}) \\<in> mult1 trm_ord\n  mult ?r = (mult1 ?r)\\<^sup>+\n\ngoal (1 subgoal):\n 1. ({#t1, t1, s1, s1#}, {#s2#}) \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  ({#t1, t1, s1, s1#}, {#s2#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. p2 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this and \\<open>( {# s2 #}, {# t2,t2,s2,s2 #} ) \\<in> mult trm_ord\\<close>"], ["proof (chain)\npicking this:\n  ({#t1, t1, s1, s1#}, {#s2#}) \\<in> mult trm_ord\n  ({#s2#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord", "have \"({# t1,t1,s1,s1 #}, {# t2,s2 #}) \\<in> mult trm_ord\""], ["proof (prove)\nusing this:\n  ({#t1, t1, s1, s1#}, {#s2#}) \\<in> mult trm_ord\n  ({#s2#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. ({#t1, t1, s1, s1#}, {#t2, s2#}) \\<in> mult trm_ord", "using mset_ordering_add1 [of \"{# t1,t1,s1,s1 #}\" \" {# s2 #}\" trm_ord t2]"], ["proof (prove)\nusing this:\n  ({#t1, t1, s1, s1#}, {#s2#}) \\<in> mult trm_ord\n  ({#s2#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord\n  ({#t1, t1, s1, s1#}, {#s2#}) \\<in> mult trm_ord \\<Longrightarrow>\n  ({#t1, t1, s1, s1#}, {#s2#} + {#t2#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. ({#t1, t1, s1, s1#}, {#t2, s2#}) \\<in> mult trm_ord", "by (auto)"], ["proof (state)\nthis:\n  ({#t1, t1, s1, s1#}, {#t2, s2#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. p2 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this and m1 and m2"], ["proof (chain)\npicking this:\n  ({#t1, t1, s1, s1#}, {#t2, s2#}) \\<in> mult trm_ord\n  mset_lit x1 = {#t1, t1, s1, s1#}\n  mset_lit x2 = {#t2, s2#}", "show ?thesis"], ["proof (prove)\nusing this:\n  ({#t1, t1, s1, s1#}, {#t2, s2#}) \\<in> mult trm_ord\n  mset_lit x1 = {#t1, t1, s1, s1#}\n  mset_lit x2 = {#t2, s2#}\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "using lit_ord_def"], ["proof (prove)\nusing this:\n  ({#t1, t1, s1, s1#}, {#t2, s2#}) \\<in> mult trm_ord\n  mset_lit x1 = {#t1, t1, s1, s1#}\n  mset_lit x2 = {#t2, s2#}\n  lit_ord = {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "by auto"], ["proof (state)\nthis:\n  (x1, x2) \\<in> lit_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x1, x2) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. p1 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p1 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "assume \"p1 = pos\""], ["proof (state)\nthis:\n  p1 = pos\n\ngoal (1 subgoal):\n 1. p1 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this and \\<open>orient_lit x1 s1 t1 p1\\<close>"], ["proof (chain)\npicking this:\n  p1 = pos\n  orient_lit x1 s1 t1 p1", "have \"x1 = (Pos (Eq t1 s1)) \\<or> x1 = (Pos (Eq s1 t1))\""], ["proof (prove)\nusing this:\n  p1 = pos\n  orient_lit x1 s1 t1 p1\n\ngoal (1 subgoal):\n 1. x1 = Pos (Eq t1 s1) \\<or> x1 = Pos (Eq s1 t1)", "using orient_lit_def"], ["proof (prove)\nusing this:\n  p1 = pos\n  orient_lit x1 s1 t1 p1\n  orient_lit ?L ?u ?v ?s =\n  ((?L = Pos (Eq ?u ?v) \\<or> ?L = Pos (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = pos \\<or>\n   (?L = Neg (Eq ?u ?v) \\<or> ?L = Neg (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = neg)\n\ngoal (1 subgoal):\n 1. x1 = Pos (Eq t1 s1) \\<or> x1 = Pos (Eq s1 t1)", "by blast"], ["proof (state)\nthis:\n  x1 = Pos (Eq t1 s1) \\<or> x1 = Pos (Eq s1 t1)\n\ngoal (1 subgoal):\n 1. p1 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  x1 = Pos (Eq t1 s1) \\<or> x1 = Pos (Eq s1 t1)", "have m1: \"?m1 = {# t1,s1 #}\""], ["proof (prove)\nusing this:\n  x1 = Pos (Eq t1 s1) \\<or> x1 = Pos (Eq s1 t1)\n\ngoal (1 subgoal):\n 1. mset_lit x1 = {#t1, s1#}", "using mset_lit.simps"], ["proof (prove)\nusing this:\n  x1 = Pos (Eq t1 s1) \\<or> x1 = Pos (Eq s1 t1)\n  mset_lit (Pos (Eq ?t ?s)) = {#?t, ?s#}\n  mset_lit (Neg (Eq ?t ?s)) = {#?t, ?t, ?s, ?s#}\n\ngoal (1 subgoal):\n 1. mset_lit x1 = {#t1, s1#}", "by auto"], ["proof (state)\nthis:\n  mset_lit x1 = {#t1, s1#}\n\ngoal (1 subgoal):\n 1. p1 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "have \"p2 = neg \\<or> p2 = pos\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p2 = neg \\<or> p2 = pos", "using sign.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = pos \\<Longrightarrow> ?P;\n   ?y = neg \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. p2 = neg \\<or> p2 = pos", "by auto"], ["proof (state)\nthis:\n  p2 = neg \\<or> p2 = pos\n\ngoal (1 subgoal):\n 1. p1 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "then"], ["proof (chain)\npicking this:\n  p2 = neg \\<or> p2 = pos", "show ?thesis"], ["proof (prove)\nusing this:\n  p2 = neg \\<or> p2 = pos\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p2 = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. p2 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "assume \"p2 = neg\""], ["proof (state)\nthis:\n  p2 = neg\n\ngoal (2 subgoals):\n 1. p2 = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. p2 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this and \\<open>orient_lit x2 s2 t2 p2\\<close>"], ["proof (chain)\npicking this:\n  p2 = neg\n  orient_lit x2 s2 t2 p2", "have \"x2 = (Neg (Eq t2 s2)) \\<or> x2 = (Neg (Eq s2 t2))\""], ["proof (prove)\nusing this:\n  p2 = neg\n  orient_lit x2 s2 t2 p2\n\ngoal (1 subgoal):\n 1. x2 = Neg (Eq t2 s2) \\<or> x2 = Neg (Eq s2 t2)", "using orient_lit_def"], ["proof (prove)\nusing this:\n  p2 = neg\n  orient_lit x2 s2 t2 p2\n  orient_lit ?L ?u ?v ?s =\n  ((?L = Pos (Eq ?u ?v) \\<or> ?L = Pos (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = pos \\<or>\n   (?L = Neg (Eq ?u ?v) \\<or> ?L = Neg (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = neg)\n\ngoal (1 subgoal):\n 1. x2 = Neg (Eq t2 s2) \\<or> x2 = Neg (Eq s2 t2)", "by blast"], ["proof (state)\nthis:\n  x2 = Neg (Eq t2 s2) \\<or> x2 = Neg (Eq s2 t2)\n\ngoal (2 subgoals):\n 1. p2 = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. p2 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  x2 = Neg (Eq t2 s2) \\<or> x2 = Neg (Eq s2 t2)", "have m2: \"?m2 = {# t2,t2,s2,s2 #}\""], ["proof (prove)\nusing this:\n  x2 = Neg (Eq t2 s2) \\<or> x2 = Neg (Eq s2 t2)\n\ngoal (1 subgoal):\n 1. mset_lit x2 = {#t2, t2, s2, s2#}", "using mset_lit.simps"], ["proof (prove)\nusing this:\n  x2 = Neg (Eq t2 s2) \\<or> x2 = Neg (Eq s2 t2)\n  mset_lit (Pos (Eq ?t ?s)) = {#?t, ?s#}\n  mset_lit (Neg (Eq ?t ?s)) = {#?t, ?t, ?s, ?s#}\n\ngoal (1 subgoal):\n 1. mset_lit x2 = {#t2, t2, s2, s2#}", "by auto"], ["proof (state)\nthis:\n  mset_lit x2 = {#t2, t2, s2, s2#}\n\ngoal (2 subgoals):\n 1. p2 = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. p2 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from s2max"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     x \\<in># {#t1, t1, s1, s1#} \\<longrightarrow> (x, s2) \\<in> trm_ord", "have \"({# t1,s1 #}, {# s2 #}) \\<in> mult trm_ord\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in># {#t1, t1, s1, s1#} \\<longrightarrow> (x, s2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. ({#t1, s1#}, {#s2#}) \\<in> mult trm_ord", "using mult1_def_lemma [of \"{# s2 #}\" \"{#}\" s2 \"{# t1,s1 #}\" \"{# t1,s1 #}\" trm_ord]\n        mult_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in># {#t1, t1, s1, s1#} \\<longrightarrow> (x, s2) \\<in> trm_ord\n  {#s2#} = {#} + {#s2#} \\<and>\n  {#t1, s1#} = {#} + {#t1, s1#} \\<and>\n  (\\<forall>b.\n      b \\<in># {#t1, s1#} \\<longrightarrow>\n      (b, s2) \\<in> trm_ord) \\<Longrightarrow>\n  ({#t1, s1#}, {#s2#}) \\<in> mult1 trm_ord\n  mult ?r = (mult1 ?r)\\<^sup>+\n\ngoal (1 subgoal):\n 1. ({#t1, s1#}, {#s2#}) \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  ({#t1, s1#}, {#s2#}) \\<in> mult trm_ord\n\ngoal (2 subgoals):\n 1. p2 = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. p2 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from \\<open>( {# s2 #}, {# t2,t2,s2,s2 #} ) \\<in> mult trm_ord\\<close> and \\<open>({# t1,s1 #}, {# s2 #}) \\<in> mult trm_ord\\<close>"], ["proof (chain)\npicking this:\n  ({#s2#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord\n  ({#t1, s1#}, {#s2#}) \\<in> mult trm_ord", "have \"( {# t1,s1 #}, {# t2,t2,s2,s2 #} ) \\<in> mult trm_ord\""], ["proof (prove)\nusing this:\n  ({#s2#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord\n  ({#t1, s1#}, {#s2#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. ({#t1, s1#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord", "using mult_trm_ord_trans"], ["proof (prove)\nusing this:\n  ({#s2#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord\n  ({#t1, s1#}, {#s2#}) \\<in> mult trm_ord\n  trans (mult trm_ord)\n\ngoal (1 subgoal):\n 1. ({#t1, s1#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord", "unfolding trans_def"], ["proof (prove)\nusing this:\n  ({#s2#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord\n  ({#t1, s1#}, {#s2#}) \\<in> mult trm_ord\n  \\<forall>x y z.\n     (x, y) \\<in> mult trm_ord \\<longrightarrow>\n     (y, z) \\<in> mult trm_ord \\<longrightarrow> (x, z) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. ({#t1, s1#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord", "by blast"], ["proof (state)\nthis:\n  ({#t1, s1#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord\n\ngoal (2 subgoals):\n 1. p2 = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. p2 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this and m1 and m2"], ["proof (chain)\npicking this:\n  ({#t1, s1#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord\n  mset_lit x1 = {#t1, s1#}\n  mset_lit x2 = {#t2, t2, s2, s2#}", "show ?thesis"], ["proof (prove)\nusing this:\n  ({#t1, s1#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord\n  mset_lit x1 = {#t1, s1#}\n  mset_lit x2 = {#t2, t2, s2, s2#}\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "using lit_ord_def"], ["proof (prove)\nusing this:\n  ({#t1, s1#}, {#t2, t2, s2, s2#}) \\<in> mult trm_ord\n  mset_lit x1 = {#t1, s1#}\n  mset_lit x2 = {#t2, t2, s2, s2#}\n  lit_ord = {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "by auto"], ["proof (state)\nthis:\n  (x1, x2) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. p2 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p2 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "assume \"p2 = pos\""], ["proof (state)\nthis:\n  p2 = pos\n\ngoal (1 subgoal):\n 1. p2 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this and \\<open>orient_lit x2 s2 t2 p2\\<close>"], ["proof (chain)\npicking this:\n  p2 = pos\n  orient_lit x2 s2 t2 p2", "have \"x2 = (Pos (Eq t2 s2)) \\<or> x2 = (Pos (Eq s2 t2))\""], ["proof (prove)\nusing this:\n  p2 = pos\n  orient_lit x2 s2 t2 p2\n\ngoal (1 subgoal):\n 1. x2 = Pos (Eq t2 s2) \\<or> x2 = Pos (Eq s2 t2)", "using orient_lit_def"], ["proof (prove)\nusing this:\n  p2 = pos\n  orient_lit x2 s2 t2 p2\n  orient_lit ?L ?u ?v ?s =\n  ((?L = Pos (Eq ?u ?v) \\<or> ?L = Pos (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = pos \\<or>\n   (?L = Neg (Eq ?u ?v) \\<or> ?L = Neg (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = neg)\n\ngoal (1 subgoal):\n 1. x2 = Pos (Eq t2 s2) \\<or> x2 = Pos (Eq s2 t2)", "by blast"], ["proof (state)\nthis:\n  x2 = Pos (Eq t2 s2) \\<or> x2 = Pos (Eq s2 t2)\n\ngoal (1 subgoal):\n 1. p2 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  x2 = Pos (Eq t2 s2) \\<or> x2 = Pos (Eq s2 t2)", "have m2: \"?m2 = {# t2,s2 #}\""], ["proof (prove)\nusing this:\n  x2 = Pos (Eq t2 s2) \\<or> x2 = Pos (Eq s2 t2)\n\ngoal (1 subgoal):\n 1. mset_lit x2 = {#t2, s2#}", "using mset_lit.simps"], ["proof (prove)\nusing this:\n  x2 = Pos (Eq t2 s2) \\<or> x2 = Pos (Eq s2 t2)\n  mset_lit (Pos (Eq ?t ?s)) = {#?t, ?s#}\n  mset_lit (Neg (Eq ?t ?s)) = {#?t, ?t, ?s, ?s#}\n\ngoal (1 subgoal):\n 1. mset_lit x2 = {#t2, s2#}", "by auto"], ["proof (state)\nthis:\n  mset_lit x2 = {#t2, s2#}\n\ngoal (1 subgoal):\n 1. p2 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from s2max"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     x \\<in># {#t1, t1, s1, s1#} \\<longrightarrow> (x, s2) \\<in> trm_ord", "have \"({# t1,s1 #}, {# s2 #}) \\<in> mult trm_ord\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in># {#t1, t1, s1, s1#} \\<longrightarrow> (x, s2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. ({#t1, s1#}, {#s2#}) \\<in> mult trm_ord", "using mult1_def_lemma [of \"{# s2 #}\" \"{#}\" s2 \"{# t1,s1 #}\" \"{# t1,s1 #}\" trm_ord]\n        mult_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in># {#t1, t1, s1, s1#} \\<longrightarrow> (x, s2) \\<in> trm_ord\n  {#s2#} = {#} + {#s2#} \\<and>\n  {#t1, s1#} = {#} + {#t1, s1#} \\<and>\n  (\\<forall>b.\n      b \\<in># {#t1, s1#} \\<longrightarrow>\n      (b, s2) \\<in> trm_ord) \\<Longrightarrow>\n  ({#t1, s1#}, {#s2#}) \\<in> mult1 trm_ord\n  mult ?r = (mult1 ?r)\\<^sup>+\n\ngoal (1 subgoal):\n 1. ({#t1, s1#}, {#s2#}) \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  ({#t1, s1#}, {#s2#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. p2 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  ({#t1, s1#}, {#s2#}) \\<in> mult trm_ord", "have \"({# t1,s1 #}, {# t2,s2 #}) \\<in> mult trm_ord\""], ["proof (prove)\nusing this:\n  ({#t1, s1#}, {#s2#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. ({#t1, s1#}, {#t2, s2#}) \\<in> mult trm_ord", "using mset_ordering_add1 [of \"{# t1,s1 #}\" \" {# s2 #}\" trm_ord t2]"], ["proof (prove)\nusing this:\n  ({#t1, s1#}, {#s2#}) \\<in> mult trm_ord\n  ({#t1, s1#}, {#s2#}) \\<in> mult trm_ord \\<Longrightarrow>\n  ({#t1, s1#}, {#s2#} + {#t2#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. ({#t1, s1#}, {#t2, s2#}) \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  ({#t1, s1#}, {#t2, s2#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. p2 = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this and m1 and m2"], ["proof (chain)\npicking this:\n  ({#t1, s1#}, {#t2, s2#}) \\<in> mult trm_ord\n  mset_lit x1 = {#t1, s1#}\n  mset_lit x2 = {#t2, s2#}", "show ?thesis"], ["proof (prove)\nusing this:\n  ({#t1, s1#}, {#t2, s2#}) \\<in> mult trm_ord\n  mset_lit x1 = {#t1, s1#}\n  mset_lit x2 = {#t2, s2#}\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "using lit_ord_def"], ["proof (prove)\nusing this:\n  ({#t1, s1#}, {#t2, s2#}) \\<in> mult trm_ord\n  mset_lit x1 = {#t1, s1#}\n  mset_lit x2 = {#t2, s2#}\n  lit_ord = {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "by auto"], ["proof (state)\nthis:\n  (x1, x2) \\<in> lit_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x1, x2) \\<in> lit_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x1, x2) \\<in> lit_ord\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lit_ord_neg_lit_lhs:\n  assumes \"orient_lit x1 s t1 pos\"\n  assumes \"orient_lit x2 s t2 neg\"\n  assumes \"vars_of_lit x1 = {}\"\n  assumes \"vars_of_lit x2 = {}\"\n  shows \"(x1,x2) \\<in> lit_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from assms(3) and assms(1)"], ["proof (chain)\npicking this:\n  vars_of_lit x1 = {}\n  orient_lit x1 s t1 pos", "have \"vars_of t1 = {}\" and \"vars_of s = {}\" \n    and \"\\<not>(s,t1) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  vars_of_lit x1 = {}\n  orient_lit x1 s t1 pos\n\ngoal (1 subgoal):\n 1. vars_of t1 = {} &&& vars_of s = {} &&& (s, t1) \\<notin> trm_ord", "unfolding orient_lit_def"], ["proof (prove)\nusing this:\n  vars_of_lit x1 = {}\n  (x1 = Pos (Eq s t1) \\<or> x1 = Pos (Eq t1 s)) \\<and>\n  (s, t1) \\<notin> trm_ord \\<and> pos = pos \\<or>\n  (x1 = Neg (Eq s t1) \\<or> x1 = Neg (Eq t1 s)) \\<and>\n  (s, t1) \\<notin> trm_ord \\<and> pos = neg\n\ngoal (1 subgoal):\n 1. vars_of t1 = {} &&& vars_of s = {} &&& (s, t1) \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  vars_of t1 = {}\n  vars_of s = {}\n  (s, t1) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from assms(4) and assms(2)"], ["proof (chain)\npicking this:\n  vars_of_lit x2 = {}\n  orient_lit x2 s t2 neg", "have \"vars_of t2 = {}\"  \n    and \"\\<not>(s,t2) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  vars_of_lit x2 = {}\n  orient_lit x2 s t2 neg\n\ngoal (1 subgoal):\n 1. vars_of t2 = {} &&& (s, t2) \\<notin> trm_ord", "unfolding orient_lit_def"], ["proof (prove)\nusing this:\n  vars_of_lit x2 = {}\n  (x2 = Pos (Eq s t2) \\<or> x2 = Pos (Eq t2 s)) \\<and>\n  (s, t2) \\<notin> trm_ord \\<and> neg = pos \\<or>\n  (x2 = Neg (Eq s t2) \\<or> x2 = Neg (Eq t2 s)) \\<and>\n  (s, t2) \\<notin> trm_ord \\<and> neg = neg\n\ngoal (1 subgoal):\n 1. vars_of t2 = {} &&& (s, t2) \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  vars_of t2 = {}\n  (s, t2) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from \\<open>vars_of t1 = {}\\<close> and \\<open>vars_of s = {}\\<close> and \\<open>\\<not>(s,t1) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  vars_of t1 = {}\n  vars_of s = {}\n  (s, t1) \\<notin> trm_ord", "have o1: \"t1 = s \\<or> (t1,s) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  vars_of t1 = {}\n  vars_of s = {}\n  (s, t1) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. t1 = s \\<or> (t1, s) \\<in> trm_ord", "using trm_ord_ground_total"], ["proof (prove)\nusing this:\n  vars_of t1 = {}\n  vars_of s = {}\n  (s, t1) \\<notin> trm_ord\n  \\<forall>x y.\n     ground_term x \\<longrightarrow>\n     ground_term y \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t1 = s \\<or> (t1, s) \\<in> trm_ord", "unfolding ground_term_def"], ["proof (prove)\nusing this:\n  vars_of t1 = {}\n  vars_of s = {}\n  (s, t1) \\<notin> trm_ord\n  \\<forall>x y.\n     vars_of x = {} \\<longrightarrow>\n     vars_of y = {} \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t1 = s \\<or> (t1, s) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  t1 = s \\<or> (t1, s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from \\<open>vars_of t2 = {}\\<close> and \\<open>vars_of s = {}\\<close> and \\<open>\\<not>(s,t2) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  vars_of t2 = {}\n  vars_of s = {}\n  (s, t2) \\<notin> trm_ord", "have o2: \"t2 = s \\<or> (t2,s) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  vars_of t2 = {}\n  vars_of s = {}\n  (s, t2) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. t2 = s \\<or> (t2, s) \\<in> trm_ord", "using trm_ord_ground_total"], ["proof (prove)\nusing this:\n  vars_of t2 = {}\n  vars_of s = {}\n  (s, t2) \\<notin> trm_ord\n  \\<forall>x y.\n     ground_term x \\<longrightarrow>\n     ground_term y \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t2 = s \\<or> (t2, s) \\<in> trm_ord", "unfolding ground_term_def"], ["proof (prove)\nusing this:\n  vars_of t2 = {}\n  vars_of s = {}\n  (s, t2) \\<notin> trm_ord\n  \\<forall>x y.\n     vars_of x = {} \\<longrightarrow>\n     vars_of y = {} \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t2 = s \\<or> (t2, s) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  t2 = s \\<or> (t2, s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "let ?m1 = \"mset_lit x1\""], ["proof (state)\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "let ?m2 = \"mset_lit x2\""], ["proof (state)\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from \\<open>orient_lit x1 s t1 pos\\<close>"], ["proof (chain)\npicking this:\n  orient_lit x1 s t1 pos", "have \"x1 = (Pos (Eq t1 s)) \\<or> x1 = (Pos (Eq s t1))\""], ["proof (prove)\nusing this:\n  orient_lit x1 s t1 pos\n\ngoal (1 subgoal):\n 1. x1 = Pos (Eq t1 s) \\<or> x1 = Pos (Eq s t1)", "using orient_lit_def"], ["proof (prove)\nusing this:\n  orient_lit x1 s t1 pos\n  orient_lit ?L ?u ?v ?s =\n  ((?L = Pos (Eq ?u ?v) \\<or> ?L = Pos (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = pos \\<or>\n   (?L = Neg (Eq ?u ?v) \\<or> ?L = Neg (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = neg)\n\ngoal (1 subgoal):\n 1. x1 = Pos (Eq t1 s) \\<or> x1 = Pos (Eq s t1)", "by blast"], ["proof (state)\nthis:\n  x1 = Pos (Eq t1 s) \\<or> x1 = Pos (Eq s t1)\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  x1 = Pos (Eq t1 s) \\<or> x1 = Pos (Eq s t1)", "have m1: \"?m1 = {# t1,s #}\""], ["proof (prove)\nusing this:\n  x1 = Pos (Eq t1 s) \\<or> x1 = Pos (Eq s t1)\n\ngoal (1 subgoal):\n 1. mset_lit x1 = {#t1, s#}", "using mset_lit.simps"], ["proof (prove)\nusing this:\n  x1 = Pos (Eq t1 s) \\<or> x1 = Pos (Eq s t1)\n  mset_lit (Pos (Eq ?t ?s)) = {#?t, ?s#}\n  mset_lit (Neg (Eq ?t ?s)) = {#?t, ?t, ?s, ?s#}\n\ngoal (1 subgoal):\n 1. mset_lit x1 = {#t1, s#}", "by auto"], ["proof (state)\nthis:\n  mset_lit x1 = {#t1, s#}\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from \\<open>orient_lit x2 s t2 neg\\<close>"], ["proof (chain)\npicking this:\n  orient_lit x2 s t2 neg", "have \"x2 = (Neg (Eq t2 s)) \\<or> x2 = (Neg (Eq s t2))\""], ["proof (prove)\nusing this:\n  orient_lit x2 s t2 neg\n\ngoal (1 subgoal):\n 1. x2 = Neg (Eq t2 s) \\<or> x2 = Neg (Eq s t2)", "using orient_lit_def"], ["proof (prove)\nusing this:\n  orient_lit x2 s t2 neg\n  orient_lit ?L ?u ?v ?s =\n  ((?L = Pos (Eq ?u ?v) \\<or> ?L = Pos (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = pos \\<or>\n   (?L = Neg (Eq ?u ?v) \\<or> ?L = Neg (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = neg)\n\ngoal (1 subgoal):\n 1. x2 = Neg (Eq t2 s) \\<or> x2 = Neg (Eq s t2)", "by blast"], ["proof (state)\nthis:\n  x2 = Neg (Eq t2 s) \\<or> x2 = Neg (Eq s t2)\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  x2 = Neg (Eq t2 s) \\<or> x2 = Neg (Eq s t2)", "have m2: \"?m2 = {# t2,t2,s,s #}\""], ["proof (prove)\nusing this:\n  x2 = Neg (Eq t2 s) \\<or> x2 = Neg (Eq s t2)\n\ngoal (1 subgoal):\n 1. mset_lit x2 = {#t2, t2, s, s#}", "using mset_lit.simps"], ["proof (prove)\nusing this:\n  x2 = Neg (Eq t2 s) \\<or> x2 = Neg (Eq s t2)\n  mset_lit (Pos (Eq ?t ?s)) = {#?t, ?s#}\n  mset_lit (Neg (Eq ?t ?s)) = {#?t, ?t, ?s, ?s#}\n\ngoal (1 subgoal):\n 1. mset_lit x2 = {#t2, t2, s, s#}", "by auto"], ["proof (state)\nthis:\n  mset_lit x2 = {#t2, t2, s, s#}\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. \\<not> ?P \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "assume \"t1 = s\""], ["proof (state)\nthis:\n  t1 = s\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. \\<not> ?P \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "have \"({# s,s #}, {# t2,s,s #}) \\<in> mult trm_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({#s, s#}, {#t2, s, s#}) \\<in> mult trm_ord", "using mult1_def_lemma [of \"{# t2,s,s #}\" \"{# s,s #}\" t2 \"{# s,s #}\" \"{#}\" trm_ord]\n        mult_def"], ["proof (prove)\nusing this:\n  {#t2, s, s#} = {#s, s#} + {#t2#} \\<and>\n  {#s, s#} = {#s, s#} + {#} \\<and>\n  (\\<forall>b.\n      b \\<in># {#} \\<longrightarrow>\n      (b, t2) \\<in> trm_ord) \\<Longrightarrow>\n  ({#s, s#}, {#t2, s, s#}) \\<in> mult1 trm_ord\n  mult ?r = (mult1 ?r)\\<^sup>+\n\ngoal (1 subgoal):\n 1. ({#s, s#}, {#t2, s, s#}) \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  ({#s, s#}, {#t2, s, s#}) \\<in> mult trm_ord\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. \\<not> ?P \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "then"], ["proof (chain)\npicking this:\n  ({#s, s#}, {#t2, s, s#}) \\<in> mult trm_ord", "have \"({# s,s #}, {# t2,t2,s,s #}) \\<in> mult trm_ord\""], ["proof (prove)\nusing this:\n  ({#s, s#}, {#t2, s, s#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. ({#s, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord", "using mset_ordering_add1 [of \"{# s,s #}\" \" {# t2,s,s #}\" trm_ord t2]"], ["proof (prove)\nusing this:\n  ({#s, s#}, {#t2, s, s#}) \\<in> mult trm_ord\n  ({#s, s#}, {#t2, s, s#}) \\<in> mult trm_ord \\<Longrightarrow>\n  ({#s, s#}, {#t2, s, s#} + {#t2#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. ({#s, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  ({#s, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. \\<not> ?P \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this and \\<open>t1 = s\\<close> and m1 and m2"], ["proof (chain)\npicking this:\n  ({#s, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord\n  t1 = s\n  mset_lit x1 = {#t1, s#}\n  mset_lit x2 = {#t2, t2, s, s#}", "show ?thesis"], ["proof (prove)\nusing this:\n  ({#s, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord\n  t1 = s\n  mset_lit x1 = {#t1, s#}\n  mset_lit x2 = {#t2, t2, s, s#}\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "using lit_ord_def"], ["proof (prove)\nusing this:\n  ({#s, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord\n  t1 = s\n  mset_lit x1 = {#t1, s#}\n  mset_lit x2 = {#t2, t2, s, s#}\n  lit_ord = {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "by auto"], ["proof (state)\nthis:\n  (x1, x2) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. t1 \\<noteq> s \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t1 \\<noteq> s \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "assume \"t1 \\<noteq> s\""], ["proof (state)\nthis:\n  t1 \\<noteq> s\n\ngoal (1 subgoal):\n 1. t1 \\<noteq> s \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this and o1"], ["proof (chain)\npicking this:\n  t1 \\<noteq> s\n  t1 = s \\<or> (t1, s) \\<in> trm_ord", "have \"(t1,s) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  t1 \\<noteq> s\n  t1 = s \\<or> (t1, s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (t1, s) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (t1, s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t1 \\<noteq> s \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  (t1, s) \\<in> trm_ord", "have smax: \"\\<forall>x. (x \\<in># {# t1 #} \\<longrightarrow> (x,s) \\<in> trm_ord)\""], ["proof (prove)\nusing this:\n  (t1, s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<forall>x. x \\<in># {#t1#} \\<longrightarrow> (x, s) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  \\<forall>x. x \\<in># {#t1#} \\<longrightarrow> (x, s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t1 \\<noteq> s \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from smax"], ["proof (chain)\npicking this:\n  \\<forall>x. x \\<in># {#t1#} \\<longrightarrow> (x, s) \\<in> trm_ord", "have \"({# t1,s #}, {# s,s #}) \\<in> mult trm_ord\""], ["proof (prove)\nusing this:\n  \\<forall>x. x \\<in># {#t1#} \\<longrightarrow> (x, s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. ({#t1, s#}, {#s, s#}) \\<in> mult trm_ord", "using mult1_def_lemma [of \"{# s,s #}\" \"{# s #}\" s \"{# t1,s #}\" \"{# t1 #}\" trm_ord]\n        mult_def"], ["proof (prove)\nusing this:\n  \\<forall>x. x \\<in># {#t1#} \\<longrightarrow> (x, s) \\<in> trm_ord\n  {#s, s#} = {#s#} + {#s#} \\<and>\n  {#t1, s#} = {#s#} + {#t1#} \\<and>\n  (\\<forall>b.\n      b \\<in># {#t1#} \\<longrightarrow>\n      (b, s) \\<in> trm_ord) \\<Longrightarrow>\n  ({#t1, s#}, {#s, s#}) \\<in> mult1 trm_ord\n  mult ?r = (mult1 ?r)\\<^sup>+\n\ngoal (1 subgoal):\n 1. ({#t1, s#}, {#s, s#}) \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  ({#t1, s#}, {#s, s#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. t1 \\<noteq> s \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  ({#t1, s#}, {#s, s#}) \\<in> mult trm_ord", "have \"({# t1,s #}, {# t2,s,s #}) \\<in> mult trm_ord\""], ["proof (prove)\nusing this:\n  ({#t1, s#}, {#s, s#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. ({#t1, s#}, {#t2, s, s#}) \\<in> mult trm_ord", "using mset_ordering_add1 [of \"{# t1,s #}\" \" {# s,s #}\" trm_ord t2]"], ["proof (prove)\nusing this:\n  ({#t1, s#}, {#s, s#}) \\<in> mult trm_ord\n  ({#t1, s#}, {#s, s#}) \\<in> mult trm_ord \\<Longrightarrow>\n  ({#t1, s#}, {#s, s#} + {#t2#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. ({#t1, s#}, {#t2, s, s#}) \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  ({#t1, s#}, {#t2, s, s#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. t1 \\<noteq> s \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  ({#t1, s#}, {#t2, s, s#}) \\<in> mult trm_ord", "have \"({# t1,s #}, {# t2,t2,s,s #}) \\<in> mult trm_ord\""], ["proof (prove)\nusing this:\n  ({#t1, s#}, {#t2, s, s#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. ({#t1, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord", "using mset_ordering_add1 [of \"{# t1,s #}\" \" {# t2,s,s #}\" trm_ord t2]"], ["proof (prove)\nusing this:\n  ({#t1, s#}, {#t2, s, s#}) \\<in> mult trm_ord\n  ({#t1, s#}, {#t2, s, s#}) \\<in> mult trm_ord \\<Longrightarrow>\n  ({#t1, s#}, {#t2, s, s#} + {#t2#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. ({#t1, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  ({#t1, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. t1 \\<noteq> s \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this and m1 and m2"], ["proof (chain)\npicking this:\n  ({#t1, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord\n  mset_lit x1 = {#t1, s#}\n  mset_lit x2 = {#t2, t2, s, s#}", "show ?thesis"], ["proof (prove)\nusing this:\n  ({#t1, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord\n  mset_lit x1 = {#t1, s#}\n  mset_lit x2 = {#t2, t2, s, s#}\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "using lit_ord_def"], ["proof (prove)\nusing this:\n  ({#t1, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord\n  mset_lit x1 = {#t1, s#}\n  mset_lit x2 = {#t2, t2, s, s#}\n  lit_ord = {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "by auto"], ["proof (state)\nthis:\n  (x1, x2) \\<in> lit_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x1, x2) \\<in> lit_ord\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lit_ord_neg_lit_rhs:\n  assumes \"orient_lit x1 s t1 pos\"\n  assumes \"orient_lit x2 t2 s neg\"\n  assumes \"vars_of_lit x1 = {}\"\n  assumes \"vars_of_lit x2 = {}\"\n  shows \"(x1,x2) \\<in> lit_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from assms(3) and assms(1)"], ["proof (chain)\npicking this:\n  vars_of_lit x1 = {}\n  orient_lit x1 s t1 pos", "have \"vars_of t1 = {}\" and \"vars_of s = {}\" \n    and \"\\<not>(s,t1) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  vars_of_lit x1 = {}\n  orient_lit x1 s t1 pos\n\ngoal (1 subgoal):\n 1. vars_of t1 = {} &&& vars_of s = {} &&& (s, t1) \\<notin> trm_ord", "unfolding orient_lit_def"], ["proof (prove)\nusing this:\n  vars_of_lit x1 = {}\n  (x1 = Pos (Eq s t1) \\<or> x1 = Pos (Eq t1 s)) \\<and>\n  (s, t1) \\<notin> trm_ord \\<and> pos = pos \\<or>\n  (x1 = Neg (Eq s t1) \\<or> x1 = Neg (Eq t1 s)) \\<and>\n  (s, t1) \\<notin> trm_ord \\<and> pos = neg\n\ngoal (1 subgoal):\n 1. vars_of t1 = {} &&& vars_of s = {} &&& (s, t1) \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  vars_of t1 = {}\n  vars_of s = {}\n  (s, t1) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from assms(4) and assms(2)"], ["proof (chain)\npicking this:\n  vars_of_lit x2 = {}\n  orient_lit x2 t2 s neg", "have \"vars_of t2 = {}\"  \n    and \"\\<not>(t2,s) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  vars_of_lit x2 = {}\n  orient_lit x2 t2 s neg\n\ngoal (1 subgoal):\n 1. vars_of t2 = {} &&& (t2, s) \\<notin> trm_ord", "unfolding orient_lit_def"], ["proof (prove)\nusing this:\n  vars_of_lit x2 = {}\n  (x2 = Pos (Eq t2 s) \\<or> x2 = Pos (Eq s t2)) \\<and>\n  (t2, s) \\<notin> trm_ord \\<and> neg = pos \\<or>\n  (x2 = Neg (Eq t2 s) \\<or> x2 = Neg (Eq s t2)) \\<and>\n  (t2, s) \\<notin> trm_ord \\<and> neg = neg\n\ngoal (1 subgoal):\n 1. vars_of t2 = {} &&& (t2, s) \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  vars_of t2 = {}\n  (t2, s) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from \\<open>vars_of t1 = {}\\<close> and \\<open>vars_of s = {}\\<close> and \\<open>\\<not>(s,t1) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  vars_of t1 = {}\n  vars_of s = {}\n  (s, t1) \\<notin> trm_ord", "have o1: \"t1 = s \\<or> (t1,s) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  vars_of t1 = {}\n  vars_of s = {}\n  (s, t1) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. t1 = s \\<or> (t1, s) \\<in> trm_ord", "using trm_ord_ground_total"], ["proof (prove)\nusing this:\n  vars_of t1 = {}\n  vars_of s = {}\n  (s, t1) \\<notin> trm_ord\n  \\<forall>x y.\n     ground_term x \\<longrightarrow>\n     ground_term y \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t1 = s \\<or> (t1, s) \\<in> trm_ord", "unfolding ground_term_def"], ["proof (prove)\nusing this:\n  vars_of t1 = {}\n  vars_of s = {}\n  (s, t1) \\<notin> trm_ord\n  \\<forall>x y.\n     vars_of x = {} \\<longrightarrow>\n     vars_of y = {} \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t1 = s \\<or> (t1, s) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  t1 = s \\<or> (t1, s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from \\<open>vars_of t2 = {}\\<close> and \\<open>vars_of s = {}\\<close> and \\<open>\\<not>(t2,s) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  vars_of t2 = {}\n  vars_of s = {}\n  (t2, s) \\<notin> trm_ord", "have o2: \"t2 = s \\<or> (s,t2) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  vars_of t2 = {}\n  vars_of s = {}\n  (t2, s) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. t2 = s \\<or> (s, t2) \\<in> trm_ord", "using trm_ord_ground_total"], ["proof (prove)\nusing this:\n  vars_of t2 = {}\n  vars_of s = {}\n  (t2, s) \\<notin> trm_ord\n  \\<forall>x y.\n     ground_term x \\<longrightarrow>\n     ground_term y \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t2 = s \\<or> (s, t2) \\<in> trm_ord", "unfolding ground_term_def"], ["proof (prove)\nusing this:\n  vars_of t2 = {}\n  vars_of s = {}\n  (t2, s) \\<notin> trm_ord\n  \\<forall>x y.\n     vars_of x = {} \\<longrightarrow>\n     vars_of y = {} \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t2 = s \\<or> (s, t2) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  t2 = s \\<or> (s, t2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "let ?m1 = \"mset_lit x1\""], ["proof (state)\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "let ?m2 = \"mset_lit x2\""], ["proof (state)\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from \\<open>orient_lit x1 s t1 pos\\<close>"], ["proof (chain)\npicking this:\n  orient_lit x1 s t1 pos", "have \"x1 = (Pos (Eq t1 s)) \\<or> x1 = (Pos (Eq s t1))\""], ["proof (prove)\nusing this:\n  orient_lit x1 s t1 pos\n\ngoal (1 subgoal):\n 1. x1 = Pos (Eq t1 s) \\<or> x1 = Pos (Eq s t1)", "using orient_lit_def"], ["proof (prove)\nusing this:\n  orient_lit x1 s t1 pos\n  orient_lit ?L ?u ?v ?s =\n  ((?L = Pos (Eq ?u ?v) \\<or> ?L = Pos (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = pos \\<or>\n   (?L = Neg (Eq ?u ?v) \\<or> ?L = Neg (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = neg)\n\ngoal (1 subgoal):\n 1. x1 = Pos (Eq t1 s) \\<or> x1 = Pos (Eq s t1)", "by blast"], ["proof (state)\nthis:\n  x1 = Pos (Eq t1 s) \\<or> x1 = Pos (Eq s t1)\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  x1 = Pos (Eq t1 s) \\<or> x1 = Pos (Eq s t1)", "have m1: \"?m1 = {# t1,s #}\""], ["proof (prove)\nusing this:\n  x1 = Pos (Eq t1 s) \\<or> x1 = Pos (Eq s t1)\n\ngoal (1 subgoal):\n 1. mset_lit x1 = {#t1, s#}", "using mset_lit.simps"], ["proof (prove)\nusing this:\n  x1 = Pos (Eq t1 s) \\<or> x1 = Pos (Eq s t1)\n  mset_lit (Pos (Eq ?t ?s)) = {#?t, ?s#}\n  mset_lit (Neg (Eq ?t ?s)) = {#?t, ?t, ?s, ?s#}\n\ngoal (1 subgoal):\n 1. mset_lit x1 = {#t1, s#}", "by auto"], ["proof (state)\nthis:\n  mset_lit x1 = {#t1, s#}\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from \\<open>orient_lit x2 t2 s neg\\<close>"], ["proof (chain)\npicking this:\n  orient_lit x2 t2 s neg", "have \"x2 = (Neg (Eq t2 s)) \\<or> x2 = (Neg (Eq s t2))\""], ["proof (prove)\nusing this:\n  orient_lit x2 t2 s neg\n\ngoal (1 subgoal):\n 1. x2 = Neg (Eq t2 s) \\<or> x2 = Neg (Eq s t2)", "using orient_lit_def"], ["proof (prove)\nusing this:\n  orient_lit x2 t2 s neg\n  orient_lit ?L ?u ?v ?s =\n  ((?L = Pos (Eq ?u ?v) \\<or> ?L = Pos (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = pos \\<or>\n   (?L = Neg (Eq ?u ?v) \\<or> ?L = Neg (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = neg)\n\ngoal (1 subgoal):\n 1. x2 = Neg (Eq t2 s) \\<or> x2 = Neg (Eq s t2)", "by blast"], ["proof (state)\nthis:\n  x2 = Neg (Eq t2 s) \\<or> x2 = Neg (Eq s t2)\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  x2 = Neg (Eq t2 s) \\<or> x2 = Neg (Eq s t2)", "have m2: \"?m2 = {# t2,t2,s,s #}\""], ["proof (prove)\nusing this:\n  x2 = Neg (Eq t2 s) \\<or> x2 = Neg (Eq s t2)\n\ngoal (1 subgoal):\n 1. mset_lit x2 = {#t2, t2, s, s#}", "using mset_lit.simps"], ["proof (prove)\nusing this:\n  x2 = Neg (Eq t2 s) \\<or> x2 = Neg (Eq s t2)\n  mset_lit (Pos (Eq ?t ?s)) = {#?t, ?s#}\n  mset_lit (Neg (Eq ?t ?s)) = {#?t, ?t, ?s, ?s#}\n\ngoal (1 subgoal):\n 1. mset_lit x2 = {#t2, t2, s, s#}", "by auto"], ["proof (state)\nthis:\n  mset_lit x2 = {#t2, t2, s, s#}\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. \\<not> ?P \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "assume \"t1 = s\""], ["proof (state)\nthis:\n  t1 = s\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. \\<not> ?P \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "have \"({# s,s #}, {# t2,s,s #}) \\<in> mult trm_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({#s, s#}, {#t2, s, s#}) \\<in> mult trm_ord", "using mult1_def_lemma [of \"{# t2,s,s #}\" \"{# s,s #}\" t2 \"{# s,s #}\" \"{#}\" trm_ord]\n        mult_def"], ["proof (prove)\nusing this:\n  {#t2, s, s#} = {#s, s#} + {#t2#} \\<and>\n  {#s, s#} = {#s, s#} + {#} \\<and>\n  (\\<forall>b.\n      b \\<in># {#} \\<longrightarrow>\n      (b, t2) \\<in> trm_ord) \\<Longrightarrow>\n  ({#s, s#}, {#t2, s, s#}) \\<in> mult1 trm_ord\n  mult ?r = (mult1 ?r)\\<^sup>+\n\ngoal (1 subgoal):\n 1. ({#s, s#}, {#t2, s, s#}) \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  ({#s, s#}, {#t2, s, s#}) \\<in> mult trm_ord\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. \\<not> ?P \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "then"], ["proof (chain)\npicking this:\n  ({#s, s#}, {#t2, s, s#}) \\<in> mult trm_ord", "have \"({# s,s #}, {# t2,t2,s,s #}) \\<in> mult trm_ord\""], ["proof (prove)\nusing this:\n  ({#s, s#}, {#t2, s, s#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. ({#s, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord", "using mset_ordering_add1 [of \"{# s,s #}\" \" {# t2,s,s #}\" trm_ord t2]"], ["proof (prove)\nusing this:\n  ({#s, s#}, {#t2, s, s#}) \\<in> mult trm_ord\n  ({#s, s#}, {#t2, s, s#}) \\<in> mult trm_ord \\<Longrightarrow>\n  ({#s, s#}, {#t2, s, s#} + {#t2#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. ({#s, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  ({#s, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. \\<not> ?P \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this and \\<open>t1 = s\\<close> and m1 and m2"], ["proof (chain)\npicking this:\n  ({#s, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord\n  t1 = s\n  mset_lit x1 = {#t1, s#}\n  mset_lit x2 = {#t2, t2, s, s#}", "show ?thesis"], ["proof (prove)\nusing this:\n  ({#s, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord\n  t1 = s\n  mset_lit x1 = {#t1, s#}\n  mset_lit x2 = {#t2, t2, s, s#}\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "using lit_ord_def"], ["proof (prove)\nusing this:\n  ({#s, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord\n  t1 = s\n  mset_lit x1 = {#t1, s#}\n  mset_lit x2 = {#t2, t2, s, s#}\n  lit_ord = {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "by auto"], ["proof (state)\nthis:\n  (x1, x2) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. t1 \\<noteq> s \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t1 \\<noteq> s \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "assume \"t1 \\<noteq> s\""], ["proof (state)\nthis:\n  t1 \\<noteq> s\n\ngoal (1 subgoal):\n 1. t1 \\<noteq> s \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this and o1"], ["proof (chain)\npicking this:\n  t1 \\<noteq> s\n  t1 = s \\<or> (t1, s) \\<in> trm_ord", "have \"(t1,s) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  t1 \\<noteq> s\n  t1 = s \\<or> (t1, s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (t1, s) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (t1, s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t1 \\<noteq> s \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  (t1, s) \\<in> trm_ord", "have smax: \"\\<forall>x. (x \\<in># {# t1 #} \\<longrightarrow> (x,s) \\<in> trm_ord)\""], ["proof (prove)\nusing this:\n  (t1, s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<forall>x. x \\<in># {#t1#} \\<longrightarrow> (x, s) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  \\<forall>x. x \\<in># {#t1#} \\<longrightarrow> (x, s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t1 \\<noteq> s \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from smax"], ["proof (chain)\npicking this:\n  \\<forall>x. x \\<in># {#t1#} \\<longrightarrow> (x, s) \\<in> trm_ord", "have \"({# t1,s #}, {# s,s #}) \\<in> mult trm_ord\""], ["proof (prove)\nusing this:\n  \\<forall>x. x \\<in># {#t1#} \\<longrightarrow> (x, s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. ({#t1, s#}, {#s, s#}) \\<in> mult trm_ord", "using mult1_def_lemma [of \"{# s,s #}\" \"{# s #}\" s \"{# t1,s #}\" \"{# t1 #}\" trm_ord]\n        mult_def"], ["proof (prove)\nusing this:\n  \\<forall>x. x \\<in># {#t1#} \\<longrightarrow> (x, s) \\<in> trm_ord\n  {#s, s#} = {#s#} + {#s#} \\<and>\n  {#t1, s#} = {#s#} + {#t1#} \\<and>\n  (\\<forall>b.\n      b \\<in># {#t1#} \\<longrightarrow>\n      (b, s) \\<in> trm_ord) \\<Longrightarrow>\n  ({#t1, s#}, {#s, s#}) \\<in> mult1 trm_ord\n  mult ?r = (mult1 ?r)\\<^sup>+\n\ngoal (1 subgoal):\n 1. ({#t1, s#}, {#s, s#}) \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  ({#t1, s#}, {#s, s#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. t1 \\<noteq> s \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  ({#t1, s#}, {#s, s#}) \\<in> mult trm_ord", "have \"({# t1,s #}, {# t2,s,s #}) \\<in> mult trm_ord\""], ["proof (prove)\nusing this:\n  ({#t1, s#}, {#s, s#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. ({#t1, s#}, {#t2, s, s#}) \\<in> mult trm_ord", "using mset_ordering_add1 [of \"{# t1,s #}\" \" {# s,s #}\" trm_ord t2]"], ["proof (prove)\nusing this:\n  ({#t1, s#}, {#s, s#}) \\<in> mult trm_ord\n  ({#t1, s#}, {#s, s#}) \\<in> mult trm_ord \\<Longrightarrow>\n  ({#t1, s#}, {#s, s#} + {#t2#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. ({#t1, s#}, {#t2, s, s#}) \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  ({#t1, s#}, {#t2, s, s#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. t1 \\<noteq> s \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  ({#t1, s#}, {#t2, s, s#}) \\<in> mult trm_ord", "have \"({# t1,s #}, {# t2,t2,s,s #}) \\<in> mult trm_ord\""], ["proof (prove)\nusing this:\n  ({#t1, s#}, {#t2, s, s#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. ({#t1, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord", "using mset_ordering_add1 [of \"{# t1,s #}\" \" {# t2,s,s #}\" trm_ord t2]"], ["proof (prove)\nusing this:\n  ({#t1, s#}, {#t2, s, s#}) \\<in> mult trm_ord\n  ({#t1, s#}, {#t2, s, s#}) \\<in> mult trm_ord \\<Longrightarrow>\n  ({#t1, s#}, {#t2, s, s#} + {#t2#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. ({#t1, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  ({#t1, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. t1 \\<noteq> s \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this and m1 and m2"], ["proof (chain)\npicking this:\n  ({#t1, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord\n  mset_lit x1 = {#t1, s#}\n  mset_lit x2 = {#t2, t2, s, s#}", "show ?thesis"], ["proof (prove)\nusing this:\n  ({#t1, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord\n  mset_lit x1 = {#t1, s#}\n  mset_lit x2 = {#t2, t2, s, s#}\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "using lit_ord_def"], ["proof (prove)\nusing this:\n  ({#t1, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord\n  mset_lit x1 = {#t1, s#}\n  mset_lit x2 = {#t2, t2, s, s#}\n  lit_ord = {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "by auto"], ["proof (state)\nthis:\n  (x1, x2) \\<in> lit_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x1, x2) \\<in> lit_ord\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lit_ord_rhs:\n  assumes \"(t1,t2) \\<in> trm_ord\"\n  assumes \"orient_lit x1 s t1 p\"\n  assumes \"orient_lit x2 s t2 p\"\n  assumes \"vars_of_lit x1 = {}\"\n  assumes \"vars_of_lit x2 = {}\"\n  shows \"(x1,x2) \\<in> lit_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from assms(2) and assms(4)"], ["proof (chain)\npicking this:\n  orient_lit x1 s t1 p\n  vars_of_lit x1 = {}", "have \"vars_of t1 = {}\" and \"vars_of s = {}\" \n    and \"\\<not>(s,t1) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  orient_lit x1 s t1 p\n  vars_of_lit x1 = {}\n\ngoal (1 subgoal):\n 1. vars_of t1 = {} &&& vars_of s = {} &&& (s, t1) \\<notin> trm_ord", "unfolding orient_lit_def"], ["proof (prove)\nusing this:\n  (x1 = Pos (Eq s t1) \\<or> x1 = Pos (Eq t1 s)) \\<and>\n  (s, t1) \\<notin> trm_ord \\<and> p = pos \\<or>\n  (x1 = Neg (Eq s t1) \\<or> x1 = Neg (Eq t1 s)) \\<and>\n  (s, t1) \\<notin> trm_ord \\<and> p = neg\n  vars_of_lit x1 = {}\n\ngoal (1 subgoal):\n 1. vars_of t1 = {} &&& vars_of s = {} &&& (s, t1) \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  vars_of t1 = {}\n  vars_of s = {}\n  (s, t1) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from assms(3) and assms(5)"], ["proof (chain)\npicking this:\n  orient_lit x2 s t2 p\n  vars_of_lit x2 = {}", "have \"vars_of t2 = {}\"  \n    and \"\\<not>(s,t2) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  orient_lit x2 s t2 p\n  vars_of_lit x2 = {}\n\ngoal (1 subgoal):\n 1. vars_of t2 = {} &&& (s, t2) \\<notin> trm_ord", "unfolding orient_lit_def"], ["proof (prove)\nusing this:\n  (x2 = Pos (Eq s t2) \\<or> x2 = Pos (Eq t2 s)) \\<and>\n  (s, t2) \\<notin> trm_ord \\<and> p = pos \\<or>\n  (x2 = Neg (Eq s t2) \\<or> x2 = Neg (Eq t2 s)) \\<and>\n  (s, t2) \\<notin> trm_ord \\<and> p = neg\n  vars_of_lit x2 = {}\n\ngoal (1 subgoal):\n 1. vars_of t2 = {} &&& (s, t2) \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  vars_of t2 = {}\n  (s, t2) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from \\<open>vars_of t1 = {}\\<close> and \\<open>vars_of s = {}\\<close> and \\<open>\\<not>(s,t1) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  vars_of t1 = {}\n  vars_of s = {}\n  (s, t1) \\<notin> trm_ord", "have o1: \"t1 = s \\<or> (t1,s) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  vars_of t1 = {}\n  vars_of s = {}\n  (s, t1) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. t1 = s \\<or> (t1, s) \\<in> trm_ord", "using trm_ord_ground_total"], ["proof (prove)\nusing this:\n  vars_of t1 = {}\n  vars_of s = {}\n  (s, t1) \\<notin> trm_ord\n  \\<forall>x y.\n     ground_term x \\<longrightarrow>\n     ground_term y \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t1 = s \\<or> (t1, s) \\<in> trm_ord", "unfolding ground_term_def"], ["proof (prove)\nusing this:\n  vars_of t1 = {}\n  vars_of s = {}\n  (s, t1) \\<notin> trm_ord\n  \\<forall>x y.\n     vars_of x = {} \\<longrightarrow>\n     vars_of y = {} \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t1 = s \\<or> (t1, s) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  t1 = s \\<or> (t1, s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "from \\<open>vars_of t2 = {}\\<close> and \\<open>vars_of s = {}\\<close> and \\<open>\\<not>(s,t2) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  vars_of t2 = {}\n  vars_of s = {}\n  (s, t2) \\<notin> trm_ord", "have o2: \"t2 = s \\<or> (t2,s) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  vars_of t2 = {}\n  vars_of s = {}\n  (s, t2) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. t2 = s \\<or> (t2, s) \\<in> trm_ord", "using trm_ord_ground_total"], ["proof (prove)\nusing this:\n  vars_of t2 = {}\n  vars_of s = {}\n  (s, t2) \\<notin> trm_ord\n  \\<forall>x y.\n     ground_term x \\<longrightarrow>\n     ground_term y \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t2 = s \\<or> (t2, s) \\<in> trm_ord", "unfolding ground_term_def"], ["proof (prove)\nusing this:\n  vars_of t2 = {}\n  vars_of s = {}\n  (s, t2) \\<notin> trm_ord\n  \\<forall>x y.\n     vars_of x = {} \\<longrightarrow>\n     vars_of y = {} \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t2 = s \\<or> (t2, s) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  t2 = s \\<or> (t2, s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "let ?m1 = \"mset_lit x1\""], ["proof (state)\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "let ?m2 = \"mset_lit x2\""], ["proof (state)\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "have \"p = pos \\<or> p = neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = pos \\<or> p = neg", "using sign.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = pos \\<Longrightarrow> ?P;\n   ?y = neg \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. p = pos \\<or> p = neg", "by auto"], ["proof (state)\nthis:\n  p = pos \\<or> p = neg\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "then"], ["proof (chain)\npicking this:\n  p = pos \\<or> p = neg", "show ?thesis"], ["proof (prove)\nusing this:\n  p = pos \\<or> p = neg\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. p = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "assume \"p = pos\""], ["proof (state)\nthis:\n  p = pos\n\ngoal (2 subgoals):\n 1. p = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. p = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this and \\<open>orient_lit x1 s t1 p\\<close>"], ["proof (chain)\npicking this:\n  p = pos\n  orient_lit x1 s t1 p", "have \"x1 = (Pos (Eq t1 s)) \\<or> x1 = (Pos (Eq s t1))\""], ["proof (prove)\nusing this:\n  p = pos\n  orient_lit x1 s t1 p\n\ngoal (1 subgoal):\n 1. x1 = Pos (Eq t1 s) \\<or> x1 = Pos (Eq s t1)", "using orient_lit_def"], ["proof (prove)\nusing this:\n  p = pos\n  orient_lit x1 s t1 p\n  orient_lit ?L ?u ?v ?s =\n  ((?L = Pos (Eq ?u ?v) \\<or> ?L = Pos (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = pos \\<or>\n   (?L = Neg (Eq ?u ?v) \\<or> ?L = Neg (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = neg)\n\ngoal (1 subgoal):\n 1. x1 = Pos (Eq t1 s) \\<or> x1 = Pos (Eq s t1)", "by blast"], ["proof (state)\nthis:\n  x1 = Pos (Eq t1 s) \\<or> x1 = Pos (Eq s t1)\n\ngoal (2 subgoals):\n 1. p = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. p = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  x1 = Pos (Eq t1 s) \\<or> x1 = Pos (Eq s t1)", "have m1: \"?m1 = {# t1,s #}\""], ["proof (prove)\nusing this:\n  x1 = Pos (Eq t1 s) \\<or> x1 = Pos (Eq s t1)\n\ngoal (1 subgoal):\n 1. mset_lit x1 = {#t1, s#}", "using mset_lit.simps"], ["proof (prove)\nusing this:\n  x1 = Pos (Eq t1 s) \\<or> x1 = Pos (Eq s t1)\n  mset_lit (Pos (Eq ?t ?s)) = {#?t, ?s#}\n  mset_lit (Neg (Eq ?t ?s)) = {#?t, ?t, ?s, ?s#}\n\ngoal (1 subgoal):\n 1. mset_lit x1 = {#t1, s#}", "by auto"], ["proof (state)\nthis:\n  mset_lit x1 = {#t1, s#}\n\ngoal (2 subgoals):\n 1. p = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. p = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from \\<open>p = pos\\<close> and \\<open>orient_lit x2 s t2 p\\<close>"], ["proof (chain)\npicking this:\n  p = pos\n  orient_lit x2 s t2 p", "have \"x2 = (Pos (Eq t2 s)) \\<or> x2 = (Pos (Eq s t2))\""], ["proof (prove)\nusing this:\n  p = pos\n  orient_lit x2 s t2 p\n\ngoal (1 subgoal):\n 1. x2 = Pos (Eq t2 s) \\<or> x2 = Pos (Eq s t2)", "using orient_lit_def"], ["proof (prove)\nusing this:\n  p = pos\n  orient_lit x2 s t2 p\n  orient_lit ?L ?u ?v ?s =\n  ((?L = Pos (Eq ?u ?v) \\<or> ?L = Pos (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = pos \\<or>\n   (?L = Neg (Eq ?u ?v) \\<or> ?L = Neg (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = neg)\n\ngoal (1 subgoal):\n 1. x2 = Pos (Eq t2 s) \\<or> x2 = Pos (Eq s t2)", "by blast"], ["proof (state)\nthis:\n  x2 = Pos (Eq t2 s) \\<or> x2 = Pos (Eq s t2)\n\ngoal (2 subgoals):\n 1. p = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. p = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  x2 = Pos (Eq t2 s) \\<or> x2 = Pos (Eq s t2)", "have m2: \"?m2 = {# t2,s #}\""], ["proof (prove)\nusing this:\n  x2 = Pos (Eq t2 s) \\<or> x2 = Pos (Eq s t2)\n\ngoal (1 subgoal):\n 1. mset_lit x2 = {#t2, s#}", "using mset_lit.simps"], ["proof (prove)\nusing this:\n  x2 = Pos (Eq t2 s) \\<or> x2 = Pos (Eq s t2)\n  mset_lit (Pos (Eq ?t ?s)) = {#?t, ?s#}\n  mset_lit (Neg (Eq ?t ?s)) = {#?t, ?t, ?s, ?s#}\n\ngoal (1 subgoal):\n 1. mset_lit x2 = {#t2, s#}", "by auto"], ["proof (state)\nthis:\n  mset_lit x2 = {#t2, s#}\n\ngoal (2 subgoals):\n 1. p = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. p = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from assms(1)"], ["proof (chain)\npicking this:\n  (t1, t2) \\<in> trm_ord", "have \"(\\<forall>b. b \\<in># {#t1#} \\<longrightarrow> (b, t2) \\<in> trm_ord)\""], ["proof (prove)\nusing this:\n  (t1, t2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<forall>b. b \\<in># {#t1#} \\<longrightarrow> (b, t2) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  \\<forall>b. b \\<in># {#t1#} \\<longrightarrow> (b, t2) \\<in> trm_ord\n\ngoal (2 subgoals):\n 1. p = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. p = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "then"], ["proof (chain)\npicking this:\n  \\<forall>b. b \\<in># {#t1#} \\<longrightarrow> (b, t2) \\<in> trm_ord", "have \"({# t1,s #}, {# t2,s #}) \\<in> mult trm_ord\""], ["proof (prove)\nusing this:\n  \\<forall>b. b \\<in># {#t1#} \\<longrightarrow> (b, t2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. ({#t1, s#}, {#t2, s#}) \\<in> mult trm_ord", "using mult1_def_lemma [of \"{# t2,s #}\" \"{# s #}\" t2 \"{# t1,s #}\" \"{# t1 #}\" trm_ord]\n        mult_def"], ["proof (prove)\nusing this:\n  \\<forall>b. b \\<in># {#t1#} \\<longrightarrow> (b, t2) \\<in> trm_ord\n  {#t2, s#} = {#s#} + {#t2#} \\<and>\n  {#t1, s#} = {#s#} + {#t1#} \\<and>\n  (\\<forall>b.\n      b \\<in># {#t1#} \\<longrightarrow>\n      (b, t2) \\<in> trm_ord) \\<Longrightarrow>\n  ({#t1, s#}, {#t2, s#}) \\<in> mult1 trm_ord\n  mult ?r = (mult1 ?r)\\<^sup>+\n\ngoal (1 subgoal):\n 1. ({#t1, s#}, {#t2, s#}) \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  ({#t1, s#}, {#t2, s#}) \\<in> mult trm_ord\n\ngoal (2 subgoals):\n 1. p = pos \\<Longrightarrow> (x1, x2) \\<in> lit_ord\n 2. p = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this and m1 and m2"], ["proof (chain)\npicking this:\n  ({#t1, s#}, {#t2, s#}) \\<in> mult trm_ord\n  mset_lit x1 = {#t1, s#}\n  mset_lit x2 = {#t2, s#}", "show ?thesis"], ["proof (prove)\nusing this:\n  ({#t1, s#}, {#t2, s#}) \\<in> mult trm_ord\n  mset_lit x1 = {#t1, s#}\n  mset_lit x2 = {#t2, s#}\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "using lit_ord_def"], ["proof (prove)\nusing this:\n  ({#t1, s#}, {#t2, s#}) \\<in> mult trm_ord\n  mset_lit x1 = {#t1, s#}\n  mset_lit x2 = {#t2, s#}\n  lit_ord = {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "by auto"], ["proof (state)\nthis:\n  (x1, x2) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. p = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "assume \"p = neg\""], ["proof (state)\nthis:\n  p = neg\n\ngoal (1 subgoal):\n 1. p = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this and \\<open>orient_lit x1 s t1 p\\<close>"], ["proof (chain)\npicking this:\n  p = neg\n  orient_lit x1 s t1 p", "have \"x1 = (Neg (Eq t1 s)) \\<or> x1 = (Neg (Eq s t1))\""], ["proof (prove)\nusing this:\n  p = neg\n  orient_lit x1 s t1 p\n\ngoal (1 subgoal):\n 1. x1 = Neg (Eq t1 s) \\<or> x1 = Neg (Eq s t1)", "using orient_lit_def"], ["proof (prove)\nusing this:\n  p = neg\n  orient_lit x1 s t1 p\n  orient_lit ?L ?u ?v ?s =\n  ((?L = Pos (Eq ?u ?v) \\<or> ?L = Pos (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = pos \\<or>\n   (?L = Neg (Eq ?u ?v) \\<or> ?L = Neg (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = neg)\n\ngoal (1 subgoal):\n 1. x1 = Neg (Eq t1 s) \\<or> x1 = Neg (Eq s t1)", "by blast"], ["proof (state)\nthis:\n  x1 = Neg (Eq t1 s) \\<or> x1 = Neg (Eq s t1)\n\ngoal (1 subgoal):\n 1. p = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  x1 = Neg (Eq t1 s) \\<or> x1 = Neg (Eq s t1)", "have m1: \"?m1 = {# t1,t1,s,s #}\""], ["proof (prove)\nusing this:\n  x1 = Neg (Eq t1 s) \\<or> x1 = Neg (Eq s t1)\n\ngoal (1 subgoal):\n 1. mset_lit x1 = {#t1, t1, s, s#}", "using mset_lit.simps"], ["proof (prove)\nusing this:\n  x1 = Neg (Eq t1 s) \\<or> x1 = Neg (Eq s t1)\n  mset_lit (Pos (Eq ?t ?s)) = {#?t, ?s#}\n  mset_lit (Neg (Eq ?t ?s)) = {#?t, ?t, ?s, ?s#}\n\ngoal (1 subgoal):\n 1. mset_lit x1 = {#t1, t1, s, s#}", "by auto"], ["proof (state)\nthis:\n  mset_lit x1 = {#t1, t1, s, s#}\n\ngoal (1 subgoal):\n 1. p = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from \\<open>p = neg\\<close> and \\<open>orient_lit x2 s t2 p\\<close>"], ["proof (chain)\npicking this:\n  p = neg\n  orient_lit x2 s t2 p", "have \"x2 = (Neg (Eq t2 s)) \\<or> x2 = (Neg (Eq s t2))\""], ["proof (prove)\nusing this:\n  p = neg\n  orient_lit x2 s t2 p\n\ngoal (1 subgoal):\n 1. x2 = Neg (Eq t2 s) \\<or> x2 = Neg (Eq s t2)", "using orient_lit_def"], ["proof (prove)\nusing this:\n  p = neg\n  orient_lit x2 s t2 p\n  orient_lit ?L ?u ?v ?s =\n  ((?L = Pos (Eq ?u ?v) \\<or> ?L = Pos (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = pos \\<or>\n   (?L = Neg (Eq ?u ?v) \\<or> ?L = Neg (Eq ?v ?u)) \\<and>\n   (?u, ?v) \\<notin> trm_ord \\<and> ?s = neg)\n\ngoal (1 subgoal):\n 1. x2 = Neg (Eq t2 s) \\<or> x2 = Neg (Eq s t2)", "by blast"], ["proof (state)\nthis:\n  x2 = Neg (Eq t2 s) \\<or> x2 = Neg (Eq s t2)\n\ngoal (1 subgoal):\n 1. p = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  x2 = Neg (Eq t2 s) \\<or> x2 = Neg (Eq s t2)", "have m2: \"?m2 = {# t2,t2,s,s #}\""], ["proof (prove)\nusing this:\n  x2 = Neg (Eq t2 s) \\<or> x2 = Neg (Eq s t2)\n\ngoal (1 subgoal):\n 1. mset_lit x2 = {#t2, t2, s, s#}", "using mset_lit.simps"], ["proof (prove)\nusing this:\n  x2 = Neg (Eq t2 s) \\<or> x2 = Neg (Eq s t2)\n  mset_lit (Pos (Eq ?t ?s)) = {#?t, ?s#}\n  mset_lit (Neg (Eq ?t ?s)) = {#?t, ?t, ?s, ?s#}\n\ngoal (1 subgoal):\n 1. mset_lit x2 = {#t2, t2, s, s#}", "by auto"], ["proof (state)\nthis:\n  mset_lit x2 = {#t2, t2, s, s#}\n\ngoal (1 subgoal):\n 1. p = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from assms(1)"], ["proof (chain)\npicking this:\n  (t1, t2) \\<in> trm_ord", "have max: \"(\\<forall>b. b \\<in># {#t1,t1#} \\<longrightarrow> (b, t2) \\<in> trm_ord)\""], ["proof (prove)\nusing this:\n  (t1, t2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<forall>b. b \\<in># {#t1, t1#} \\<longrightarrow> (b, t2) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  \\<forall>b. b \\<in># {#t1, t1#} \\<longrightarrow> (b, t2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. p = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "have i: \"{# t2,s,s #} = {# s,s,t2 #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#t2, s, s#} = {#s, s, t2#}", "by (simp add: add.commute add.left_commute)"], ["proof (state)\nthis:\n  {#t2, s, s#} = {#s, s, t2#}\n\ngoal (1 subgoal):\n 1. p = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "have ii: \"{# t1,t1,s,s #} = {# s,s,t1,t1 #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#t1, t1, s, s#} = {#s, s, t1, t1#}", "by (simp add: add.commute add.left_commute)"], ["proof (state)\nthis:\n  {#t1, t1, s, s#} = {#s, s, t1, t1#}\n\ngoal (1 subgoal):\n 1. p = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from i and ii and max"], ["proof (chain)\npicking this:\n  {#t2, s, s#} = {#s, s, t2#}\n  {#t1, t1, s, s#} = {#s, s, t1, t1#}\n  \\<forall>b. b \\<in># {#t1, t1#} \\<longrightarrow> (b, t2) \\<in> trm_ord", "have \"({# t1,t1,s,s #}, {# t2,s,s #}) \\<in> mult trm_ord\""], ["proof (prove)\nusing this:\n  {#t2, s, s#} = {#s, s, t2#}\n  {#t1, t1, s, s#} = {#s, s, t1, t1#}\n  \\<forall>b. b \\<in># {#t1, t1#} \\<longrightarrow> (b, t2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. ({#t1, t1, s, s#}, {#t2, s, s#}) \\<in> mult trm_ord", "using mult1_def_lemma [of \"{# t2,s,s #}\" \"{# s,s #}\" t2 \"{# t1,t1,s,s #}\" \"{# t1,t1 #}\" trm_ord]\n        mult_def"], ["proof (prove)\nusing this:\n  {#t2, s, s#} = {#s, s, t2#}\n  {#t1, t1, s, s#} = {#s, s, t1, t1#}\n  \\<forall>b. b \\<in># {#t1, t1#} \\<longrightarrow> (b, t2) \\<in> trm_ord\n  {#t2, s, s#} = {#s, s#} + {#t2#} \\<and>\n  {#t1, t1, s, s#} = {#s, s#} + {#t1, t1#} \\<and>\n  (\\<forall>b.\n      b \\<in># {#t1, t1#} \\<longrightarrow>\n      (b, t2) \\<in> trm_ord) \\<Longrightarrow>\n  ({#t1, t1, s, s#}, {#t2, s, s#}) \\<in> mult1 trm_ord\n  mult ?r = (mult1 ?r)\\<^sup>+\n\ngoal (1 subgoal):\n 1. ({#t1, t1, s, s#}, {#t2, s, s#}) \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  ({#t1, t1, s, s#}, {#t2, s, s#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. p = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "then"], ["proof (chain)\npicking this:\n  ({#t1, t1, s, s#}, {#t2, s, s#}) \\<in> mult trm_ord", "have \"({# t1,t1,s,s #}, {# t2,t2,s,s #}) \\<in> mult trm_ord\""], ["proof (prove)\nusing this:\n  ({#t1, t1, s, s#}, {#t2, s, s#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. ({#t1, t1, s, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord", "using mset_ordering_add1 [of \"{# t1,t1,s,s #}\" \" {# t2,s,s #}\" trm_ord t2]"], ["proof (prove)\nusing this:\n  ({#t1, t1, s, s#}, {#t2, s, s#}) \\<in> mult trm_ord\n  ({#t1, t1, s, s#}, {#t2, s, s#}) \\<in> mult trm_ord \\<Longrightarrow>\n  ({#t1, t1, s, s#}, {#t2, s, s#} + {#t2#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. ({#t1, t1, s, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  ({#t1, t1, s, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. p = neg \\<Longrightarrow> (x1, x2) \\<in> lit_ord", "from this and m1 and m2"], ["proof (chain)\npicking this:\n  ({#t1, t1, s, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord\n  mset_lit x1 = {#t1, t1, s, s#}\n  mset_lit x2 = {#t2, t2, s, s#}", "show ?thesis"], ["proof (prove)\nusing this:\n  ({#t1, t1, s, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord\n  mset_lit x1 = {#t1, t1, s, s#}\n  mset_lit x2 = {#t2, t2, s, s#}\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "using lit_ord_def"], ["proof (prove)\nusing this:\n  ({#t1, t1, s, s#}, {#t2, t2, s, s#}) \\<in> mult trm_ord\n  mset_lit x1 = {#t1, t1, s, s#}\n  mset_lit x2 = {#t2, t2, s, s#}\n  lit_ord = {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}\n\ngoal (1 subgoal):\n 1. (x1, x2) \\<in> lit_ord", "by auto"], ["proof (state)\nthis:\n  (x1, x2) \\<in> lit_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x1, x2) \\<in> lit_ord\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We show that the replacement of a term by an equivalent term preserves the semantics.\\<close>"], ["", "lemma trm_rep_preserves_eq_semantics:\n  assumes \"fo_interpretation I\"\n  assumes \"(I (subst t1 \\<sigma>) (subst t2 \\<sigma>))\"\n  assumes \"(validate_ground_eq I (subst_equation (Eq t1 s) \\<sigma>))\"\n  shows \"(validate_ground_eq I (subst_equation (Eq t2 s) \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. validate_ground_eq I (subst_equation (Eq t2 s) \\<sigma>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. validate_ground_eq I (subst_equation (Eq t2 s) \\<sigma>)", "from assms(1)"], ["proof (chain)\npicking this:\n  fo_interpretation I", "have \"transitive I\" and \"symmetric I\""], ["proof (prove)\nusing this:\n  fo_interpretation I\n\ngoal (1 subgoal):\n 1. transitive I &&& symmetric I", "unfolding \n    fo_interpretation_def congruence_def equivalence_relation_def"], ["proof (prove)\nusing this:\n  (reflexive I \\<and> symmetric I \\<and> transitive I) \\<and>\n  compatible_with_structure I\n\ngoal (1 subgoal):\n 1. transitive I &&& symmetric I", "by auto"], ["proof (state)\nthis:\n  transitive I\n  symmetric I\n\ngoal (1 subgoal):\n 1. validate_ground_eq I (subst_equation (Eq t2 s) \\<sigma>)", "have \"(subst_equation (Eq t1 s) \\<sigma>) = (Eq (subst t1 \\<sigma>) (subst s \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_equation (Eq t1 s) \\<sigma> =\n    Eq (t1 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)", "by simp"], ["proof (state)\nthis:\n  subst_equation (Eq t1 s) \\<sigma> =\n  Eq (t1 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. validate_ground_eq I (subst_equation (Eq t2 s) \\<sigma>)", "from this and assms(3)"], ["proof (chain)\npicking this:\n  subst_equation (Eq t1 s) \\<sigma> =\n  Eq (t1 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n  validate_ground_eq I (subst_equation (Eq t1 s) \\<sigma>)", "have \"I (subst t1 \\<sigma>)  (subst s \\<sigma>)\""], ["proof (prove)\nusing this:\n  subst_equation (Eq t1 s) \\<sigma> =\n  Eq (t1 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n  validate_ground_eq I (subst_equation (Eq t1 s) \\<sigma>)\n\ngoal (1 subgoal):\n 1. I (t1 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)", "by simp"], ["proof (state)\nthis:\n  I (t1 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. validate_ground_eq I (subst_equation (Eq t2 s) \\<sigma>)", "from this and assms(2) and \\<open>transitive I\\<close> and \\<open>symmetric I\\<close>"], ["proof (chain)\npicking this:\n  I (t1 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n  I (t1 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<sigma>)\n  transitive I\n  symmetric I", "have \"I (subst t2 \\<sigma>) (subst s \\<sigma>)\""], ["proof (prove)\nusing this:\n  I (t1 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n  I (t1 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<sigma>)\n  transitive I\n  symmetric I\n\ngoal (1 subgoal):\n 1. I (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)", "unfolding transitive_def symmetric_def"], ["proof (prove)\nusing this:\n  I (t1 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n  I (t1 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<sigma>)\n  \\<forall>y z u. I y z \\<longrightarrow> I z u \\<longrightarrow> I y u\n  \\<forall>y z. I y z = I z y\n\ngoal (1 subgoal):\n 1. I (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)", "by metis"], ["proof (state)\nthis:\n  I (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. validate_ground_eq I (subst_equation (Eq t2 s) \\<sigma>)", "have \"(subst_equation (Eq t2 s) \\<sigma>) = (Eq (subst t2 \\<sigma>) (subst s \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_equation (Eq t2 s) \\<sigma> =\n    Eq (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)", "by simp"], ["proof (state)\nthis:\n  subst_equation (Eq t2 s) \\<sigma> =\n  Eq (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. validate_ground_eq I (subst_equation (Eq t2 s) \\<sigma>)", "from this and \\<open>I (subst t2 \\<sigma>) (subst s \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  subst_equation (Eq t2 s) \\<sigma> =\n  Eq (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n  I (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)", "show ?thesis"], ["proof (prove)\nusing this:\n  subst_equation (Eq t2 s) \\<sigma> =\n  Eq (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n  I (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. validate_ground_eq I (subst_equation (Eq t2 s) \\<sigma>)", "by simp"], ["proof (state)\nthis:\n  validate_ground_eq I (subst_equation (Eq t2 s) \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trm_rep_preserves_lit_semantics:\n  assumes \"fo_interpretation I\"\n  assumes \"(I (subst t1 \\<sigma>) (subst t2 \\<sigma>))\"\n  assumes \"orient_lit_inst L t1 s polarity \\<sigma>'\"\n  assumes \"\\<not>(validate_ground_lit I (subst_lit L \\<sigma>))\"\n  shows \"\\<not>validate_ground_lit I (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "from assms(1)"], ["proof (chain)\npicking this:\n  fo_interpretation I", "have \"transitive I\" and \"symmetric I\""], ["proof (prove)\nusing this:\n  fo_interpretation I\n\ngoal (1 subgoal):\n 1. transitive I &&& symmetric I", "unfolding \n    fo_interpretation_def congruence_def equivalence_relation_def"], ["proof (prove)\nusing this:\n  (reflexive I \\<and> symmetric I \\<and> transitive I) \\<and>\n  compatible_with_structure I\n\ngoal (1 subgoal):\n 1. transitive I &&& symmetric I", "by auto"], ["proof (state)\nthis:\n  transitive I\n  symmetric I\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "have \"polarity = pos \\<or> polarity = neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polarity = pos \\<or> polarity = neg", "using sign.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = pos \\<Longrightarrow> ?P;\n   ?y = neg \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. polarity = pos \\<or> polarity = neg", "by auto"], ["proof (state)\nthis:\n  polarity = pos \\<or> polarity = neg\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "then"], ["proof (chain)\npicking this:\n  polarity = pos \\<or> polarity = neg", "show ?thesis"], ["proof (prove)\nusing this:\n  polarity = pos \\<or> polarity = neg\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)\n 2. polarity = neg \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "assume \"polarity = pos\""], ["proof (state)\nthis:\n  polarity = pos\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)\n 2. polarity = neg \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "from this"], ["proof (chain)\npicking this:\n  polarity = pos", "have mk: \"(mk_lit polarity (Eq t2 s)) = (Pos (Eq t2 s))\""], ["proof (prove)\nusing this:\n  polarity = pos\n\ngoal (1 subgoal):\n 1. mk_lit polarity (Eq t2 s) = Pos (Eq t2 s)", "by auto"], ["proof (state)\nthis:\n  mk_lit polarity (Eq t2 s) = Pos (Eq t2 s)\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)\n 2. polarity = neg \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "from \\<open>polarity = pos\\<close> and assms(3)"], ["proof (chain)\npicking this:\n  polarity = pos\n  orient_lit_inst L t1 s polarity \\<sigma>'", "have \"L = (Pos (Eq t1 s)) \\<or> L = (Pos (Eq s t1))\""], ["proof (prove)\nusing this:\n  polarity = pos\n  orient_lit_inst L t1 s polarity \\<sigma>'\n\ngoal (1 subgoal):\n 1. L = Pos (Eq t1 s) \\<or> L = Pos (Eq s t1)", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  polarity = pos\n  (L = Pos (Eq t1 s) \\<or> L = Pos (Eq s t1)) \\<and>\n  (t1 \\<lhd> \\<sigma>', s \\<lhd> \\<sigma>') \\<notin> trm_ord \\<and>\n  polarity = pos \\<or>\n  (L = Neg (Eq t1 s) \\<or> L = Neg (Eq s t1)) \\<and>\n  (t1 \\<lhd> \\<sigma>', s \\<lhd> \\<sigma>') \\<notin> trm_ord \\<and>\n  polarity = neg\n\ngoal (1 subgoal):\n 1. L = Pos (Eq t1 s) \\<or> L = Pos (Eq s t1)", "by auto"], ["proof (state)\nthis:\n  L = Pos (Eq t1 s) \\<or> L = Pos (Eq s t1)\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)\n 2. polarity = neg \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "then"], ["proof (chain)\npicking this:\n  L = Pos (Eq t1 s) \\<or> L = Pos (Eq s t1)", "show ?thesis"], ["proof (prove)\nusing this:\n  L = Pos (Eq t1 s) \\<or> L = Pos (Eq s t1)\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. L = Pos (Eq t1 s) \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)\n 2. L = Pos (Eq s t1) \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "assume \"L = (Pos (Eq t1 s))\""], ["proof (state)\nthis:\n  L = Pos (Eq t1 s)\n\ngoal (2 subgoals):\n 1. L = Pos (Eq t1 s) \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)\n 2. L = Pos (Eq s t1) \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "from this and assms(4)"], ["proof (chain)\npicking this:\n  L = Pos (Eq t1 s)\n  \\<not> validate_ground_lit I (subst_lit L \\<sigma>)", "have \"\\<not>I (subst t1 \\<sigma>) (subst s \\<sigma>)\""], ["proof (prove)\nusing this:\n  L = Pos (Eq t1 s)\n  \\<not> validate_ground_lit I (subst_lit L \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> I (t1 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)", "by simp"], ["proof (state)\nthis:\n  \\<not> I (t1 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n\ngoal (2 subgoals):\n 1. L = Pos (Eq t1 s) \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)\n 2. L = Pos (Eq s t1) \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "from this and assms(2) and \\<open>transitive I\\<close> and \\<open>symmetric I\\<close>"], ["proof (chain)\npicking this:\n  \\<not> I (t1 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n  I (t1 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<sigma>)\n  transitive I\n  symmetric I", "have \"\\<not>I (subst t2 \\<sigma>) (subst s \\<sigma>)\""], ["proof (prove)\nusing this:\n  \\<not> I (t1 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n  I (t1 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<sigma>)\n  transitive I\n  symmetric I\n\ngoal (1 subgoal):\n 1. \\<not> I (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)", "unfolding transitive_def symmetric_def"], ["proof (prove)\nusing this:\n  \\<not> I (t1 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n  I (t1 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<sigma>)\n  \\<forall>y z u. I y z \\<longrightarrow> I z u \\<longrightarrow> I y u\n  \\<forall>y z. I y z = I z y\n\ngoal (1 subgoal):\n 1. \\<not> I (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)", "by metis"], ["proof (state)\nthis:\n  \\<not> I (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n\ngoal (2 subgoals):\n 1. L = Pos (Eq t1 s) \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)\n 2. L = Pos (Eq s t1) \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "from this and mk"], ["proof (chain)\npicking this:\n  \\<not> I (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n  mk_lit polarity (Eq t2 s) = Pos (Eq t2 s)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> I (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n  mk_lit polarity (Eq t2 s) = Pos (Eq t2 s)\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "by simp"], ["proof (state)\nthis:\n  \\<not> validate_ground_lit I\n          (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)\n\ngoal (1 subgoal):\n 1. L = Pos (Eq s t1) \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. L = Pos (Eq s t1) \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "assume \"L = (Pos (Eq s t1))\""], ["proof (state)\nthis:\n  L = Pos (Eq s t1)\n\ngoal (1 subgoal):\n 1. L = Pos (Eq s t1) \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "from this and assms(4)"], ["proof (chain)\npicking this:\n  L = Pos (Eq s t1)\n  \\<not> validate_ground_lit I (subst_lit L \\<sigma>)", "have \"\\<not>I (subst s \\<sigma>) (subst t1 \\<sigma>)\""], ["proof (prove)\nusing this:\n  L = Pos (Eq s t1)\n  \\<not> validate_ground_lit I (subst_lit L \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> I (s \\<lhd> \\<sigma>) (t1 \\<lhd> \\<sigma>)", "by simp"], ["proof (state)\nthis:\n  \\<not> I (s \\<lhd> \\<sigma>) (t1 \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. L = Pos (Eq s t1) \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "from this and assms(2) and \\<open>transitive I\\<close> and \\<open>symmetric I\\<close>"], ["proof (chain)\npicking this:\n  \\<not> I (s \\<lhd> \\<sigma>) (t1 \\<lhd> \\<sigma>)\n  I (t1 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<sigma>)\n  transitive I\n  symmetric I", "have \"\\<not>I (subst t2 \\<sigma>) (subst s \\<sigma>)\""], ["proof (prove)\nusing this:\n  \\<not> I (s \\<lhd> \\<sigma>) (t1 \\<lhd> \\<sigma>)\n  I (t1 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<sigma>)\n  transitive I\n  symmetric I\n\ngoal (1 subgoal):\n 1. \\<not> I (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)", "unfolding transitive_def symmetric_def"], ["proof (prove)\nusing this:\n  \\<not> I (s \\<lhd> \\<sigma>) (t1 \\<lhd> \\<sigma>)\n  I (t1 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<sigma>)\n  \\<forall>y z u. I y z \\<longrightarrow> I z u \\<longrightarrow> I y u\n  \\<forall>y z. I y z = I z y\n\ngoal (1 subgoal):\n 1. \\<not> I (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)", "by metis"], ["proof (state)\nthis:\n  \\<not> I (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. L = Pos (Eq s t1) \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "from this and mk"], ["proof (chain)\npicking this:\n  \\<not> I (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n  mk_lit polarity (Eq t2 s) = Pos (Eq t2 s)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> I (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n  mk_lit polarity (Eq t2 s) = Pos (Eq t2 s)\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "by simp"], ["proof (state)\nthis:\n  \\<not> validate_ground_lit I\n          (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> validate_ground_lit I\n          (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "assume \"polarity = neg\""], ["proof (state)\nthis:\n  polarity = neg\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "from this"], ["proof (chain)\npicking this:\n  polarity = neg", "have mk: \"(mk_lit polarity (Eq t2 s)) = (Neg (Eq t2 s))\""], ["proof (prove)\nusing this:\n  polarity = neg\n\ngoal (1 subgoal):\n 1. mk_lit polarity (Eq t2 s) = Neg (Eq t2 s)", "by auto"], ["proof (state)\nthis:\n  mk_lit polarity (Eq t2 s) = Neg (Eq t2 s)\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "from \\<open>polarity = neg\\<close> and assms(3)"], ["proof (chain)\npicking this:\n  polarity = neg\n  orient_lit_inst L t1 s polarity \\<sigma>'", "have \"L = (Neg (Eq t1 s)) \\<or> L = (Neg (Eq s t1))\""], ["proof (prove)\nusing this:\n  polarity = neg\n  orient_lit_inst L t1 s polarity \\<sigma>'\n\ngoal (1 subgoal):\n 1. L = Neg (Eq t1 s) \\<or> L = Neg (Eq s t1)", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  polarity = neg\n  (L = Pos (Eq t1 s) \\<or> L = Pos (Eq s t1)) \\<and>\n  (t1 \\<lhd> \\<sigma>', s \\<lhd> \\<sigma>') \\<notin> trm_ord \\<and>\n  polarity = pos \\<or>\n  (L = Neg (Eq t1 s) \\<or> L = Neg (Eq s t1)) \\<and>\n  (t1 \\<lhd> \\<sigma>', s \\<lhd> \\<sigma>') \\<notin> trm_ord \\<and>\n  polarity = neg\n\ngoal (1 subgoal):\n 1. L = Neg (Eq t1 s) \\<or> L = Neg (Eq s t1)", "by auto"], ["proof (state)\nthis:\n  L = Neg (Eq t1 s) \\<or> L = Neg (Eq s t1)\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "then"], ["proof (chain)\npicking this:\n  L = Neg (Eq t1 s) \\<or> L = Neg (Eq s t1)", "show ?thesis"], ["proof (prove)\nusing this:\n  L = Neg (Eq t1 s) \\<or> L = Neg (Eq s t1)\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. L = Neg (Eq t1 s) \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)\n 2. L = Neg (Eq s t1) \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "assume \"L = (Neg (Eq t1 s))\""], ["proof (state)\nthis:\n  L = Neg (Eq t1 s)\n\ngoal (2 subgoals):\n 1. L = Neg (Eq t1 s) \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)\n 2. L = Neg (Eq s t1) \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "from this and assms(4)"], ["proof (chain)\npicking this:\n  L = Neg (Eq t1 s)\n  \\<not> validate_ground_lit I (subst_lit L \\<sigma>)", "have \"I (subst t1 \\<sigma>) (subst s \\<sigma>)\""], ["proof (prove)\nusing this:\n  L = Neg (Eq t1 s)\n  \\<not> validate_ground_lit I (subst_lit L \\<sigma>)\n\ngoal (1 subgoal):\n 1. I (t1 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)", "by simp"], ["proof (state)\nthis:\n  I (t1 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n\ngoal (2 subgoals):\n 1. L = Neg (Eq t1 s) \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)\n 2. L = Neg (Eq s t1) \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "from this and assms(2) and \\<open>transitive I\\<close> and \\<open>symmetric I\\<close>"], ["proof (chain)\npicking this:\n  I (t1 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n  I (t1 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<sigma>)\n  transitive I\n  symmetric I", "have \"I (subst t2 \\<sigma>) (subst s \\<sigma>)\""], ["proof (prove)\nusing this:\n  I (t1 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n  I (t1 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<sigma>)\n  transitive I\n  symmetric I\n\ngoal (1 subgoal):\n 1. I (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)", "unfolding transitive_def symmetric_def"], ["proof (prove)\nusing this:\n  I (t1 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n  I (t1 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<sigma>)\n  \\<forall>y z u. I y z \\<longrightarrow> I z u \\<longrightarrow> I y u\n  \\<forall>y z. I y z = I z y\n\ngoal (1 subgoal):\n 1. I (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)", "by metis"], ["proof (state)\nthis:\n  I (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n\ngoal (2 subgoals):\n 1. L = Neg (Eq t1 s) \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)\n 2. L = Neg (Eq s t1) \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "from this and mk"], ["proof (chain)\npicking this:\n  I (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n  mk_lit polarity (Eq t2 s) = Neg (Eq t2 s)", "show ?thesis"], ["proof (prove)\nusing this:\n  I (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n  mk_lit polarity (Eq t2 s) = Neg (Eq t2 s)\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "by simp"], ["proof (state)\nthis:\n  \\<not> validate_ground_lit I\n          (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)\n\ngoal (1 subgoal):\n 1. L = Neg (Eq s t1) \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. L = Neg (Eq s t1) \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "assume \"L = (Neg (Eq s t1))\""], ["proof (state)\nthis:\n  L = Neg (Eq s t1)\n\ngoal (1 subgoal):\n 1. L = Neg (Eq s t1) \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "from this and assms(4)"], ["proof (chain)\npicking this:\n  L = Neg (Eq s t1)\n  \\<not> validate_ground_lit I (subst_lit L \\<sigma>)", "have \"I (subst s \\<sigma>) (subst t1 \\<sigma>)\""], ["proof (prove)\nusing this:\n  L = Neg (Eq s t1)\n  \\<not> validate_ground_lit I (subst_lit L \\<sigma>)\n\ngoal (1 subgoal):\n 1. I (s \\<lhd> \\<sigma>) (t1 \\<lhd> \\<sigma>)", "by simp"], ["proof (state)\nthis:\n  I (s \\<lhd> \\<sigma>) (t1 \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. L = Neg (Eq s t1) \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "from this and assms(2) and \\<open>transitive I\\<close> and \\<open>symmetric I\\<close>"], ["proof (chain)\npicking this:\n  I (s \\<lhd> \\<sigma>) (t1 \\<lhd> \\<sigma>)\n  I (t1 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<sigma>)\n  transitive I\n  symmetric I", "have \"I (subst t2 \\<sigma>) (subst s \\<sigma>)\""], ["proof (prove)\nusing this:\n  I (s \\<lhd> \\<sigma>) (t1 \\<lhd> \\<sigma>)\n  I (t1 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<sigma>)\n  transitive I\n  symmetric I\n\ngoal (1 subgoal):\n 1. I (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)", "unfolding transitive_def symmetric_def"], ["proof (prove)\nusing this:\n  I (s \\<lhd> \\<sigma>) (t1 \\<lhd> \\<sigma>)\n  I (t1 \\<lhd> \\<sigma>) (t2 \\<lhd> \\<sigma>)\n  \\<forall>y z u. I y z \\<longrightarrow> I z u \\<longrightarrow> I y u\n  \\<forall>y z. I y z = I z y\n\ngoal (1 subgoal):\n 1. I (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)", "by metis"], ["proof (state)\nthis:\n  I (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. L = Neg (Eq s t1) \\<Longrightarrow>\n    \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "from this and mk"], ["proof (chain)\npicking this:\n  I (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n  mk_lit polarity (Eq t2 s) = Neg (Eq t2 s)", "show ?thesis"], ["proof (prove)\nusing this:\n  I (t2 \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n  mk_lit polarity (Eq t2 s) = Neg (Eq t2 s)\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_lit I\n            (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)", "by simp"], ["proof (state)\nthis:\n  \\<not> validate_ground_lit I\n          (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> validate_ground_lit I\n          (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> validate_ground_lit I\n          (subst_lit (mk_lit polarity (Eq t2 s)) \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subterms_dominated :\n  assumes \"maximal_literal L C\"\n  assumes \"orient_lit L t s p\"\n  assumes \"u \\<in> subterms_of_cl C\"\n  assumes \"vars_of_lit L = {}\"\n  assumes \"vars_of_cl C = {}\"\n  shows \"u = t \\<or> (u,t) \\<in> trm_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u = t \\<or> (u, t) \\<in> trm_ord", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (u = t \\<or> (u, t) \\<in> trm_ord) \\<Longrightarrow> False", "assume neg_h: \"\\<not>(u = t \\<or> (u,t) \\<in> trm_ord)\""], ["proof (state)\nthis:\n  \\<not> (u = t \\<or> (u, t) \\<in> trm_ord)\n\ngoal (1 subgoal):\n 1. \\<not> (u = t \\<or> (u, t) \\<in> trm_ord) \\<Longrightarrow> False", "from assms(5) and assms(3)"], ["proof (chain)\npicking this:\n  vars_of_cl C = {}\n  u \\<in> subterms_of_cl C", "have \"vars_of u = {}\""], ["proof (prove)\nusing this:\n  vars_of_cl C = {}\n  u \\<in> subterms_of_cl C\n\ngoal (1 subgoal):\n 1. vars_of u = {}", "using subterm_vars"], ["proof (prove)\nusing this:\n  vars_of_cl C = {}\n  u \\<in> subterms_of_cl C\n  ?u \\<in> subterms_of_cl ?C \\<Longrightarrow>\n  vars_of ?u \\<subseteq> vars_of_cl ?C\n\ngoal (1 subgoal):\n 1. vars_of u = {}", "by blast"], ["proof (state)\nthis:\n  vars_of u = {}\n\ngoal (1 subgoal):\n 1. \\<not> (u = t \\<or> (u, t) \\<in> trm_ord) \\<Longrightarrow> False", "from \\<open>vars_of_lit L = {}\\<close> and \\<open>orient_lit L t s p\\<close>"], ["proof (chain)\npicking this:\n  vars_of_lit L = {}\n  orient_lit L t s p", "have \"vars_of s = {}\" and \"vars_of t = {}\" \n    and \"\\<not>(t,s) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  vars_of_lit L = {}\n  orient_lit L t s p\n\ngoal (1 subgoal):\n 1. vars_of s = {} &&& vars_of t = {} &&& (t, s) \\<notin> trm_ord", "unfolding orient_lit_def"], ["proof (prove)\nusing this:\n  vars_of_lit L = {}\n  (L = Pos (Eq t s) \\<or> L = Pos (Eq s t)) \\<and>\n  (t, s) \\<notin> trm_ord \\<and> p = pos \\<or>\n  (L = Neg (Eq t s) \\<or> L = Neg (Eq s t)) \\<and>\n  (t, s) \\<notin> trm_ord \\<and> p = neg\n\ngoal (1 subgoal):\n 1. vars_of s = {} &&& vars_of t = {} &&& (t, s) \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  vars_of s = {}\n  vars_of t = {}\n  (t, s) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> (u = t \\<or> (u, t) \\<in> trm_ord) \\<Longrightarrow> False", "from assms(3)"], ["proof (chain)\npicking this:\n  u \\<in> subterms_of_cl C", "obtain L' where \"u \\<in> subterms_of_lit L'\" and \"L' \\<in> C\""], ["proof (prove)\nusing this:\n  u \\<in> subterms_of_cl C\n\ngoal (1 subgoal):\n 1. (\\<And>L'.\n        \\<lbrakk>u \\<in> subterms_of_lit L'; L' \\<in> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u \\<in> subterms_of_lit L'\n  L' \\<in> C\n\ngoal (1 subgoal):\n 1. \\<not> (u = t \\<or> (u, t) \\<in> trm_ord) \\<Longrightarrow> False", "from assms(5) and \\<open>L' \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  vars_of_cl C = {}\n  L' \\<in> C", "have \"vars_of_lit L' = {}\""], ["proof (prove)\nusing this:\n  vars_of_cl C = {}\n  L' \\<in> C\n\ngoal (1 subgoal):\n 1. vars_of_lit L' = {}", "using vars_of_cl.simps"], ["proof (prove)\nusing this:\n  vars_of_cl C = {}\n  L' \\<in> C\n  vars_of_cl ?C = {x. \\<exists>L. x \\<in> vars_of_lit L \\<and> L \\<in> ?C}\n\ngoal (1 subgoal):\n 1. vars_of_lit L' = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_lit L' = {}\n\ngoal (1 subgoal):\n 1. \\<not> (u = t \\<or> (u, t) \\<in> trm_ord) \\<Longrightarrow> False", "from \\<open>u \\<in> subterms_of_lit L'\\<close>"], ["proof (chain)\npicking this:\n  u \\<in> subterms_of_lit L'", "obtain t' s' p' where \"orient_lit L' t' s' p'\" \n    and \"u \\<in> subterms_of t' \\<union> subterms_of s'\""], ["proof (prove)\nusing this:\n  u \\<in> subterms_of_lit L'\n\ngoal (1 subgoal):\n 1. (\\<And>t' s' p'.\n        \\<lbrakk>orient_lit L' t' s' p';\n         u \\<in> subterms_of t' \\<union> subterms_of s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding orient_lit_def"], ["proof (prove)\nusing this:\n  u \\<in> subterms_of_lit L'\n\ngoal (1 subgoal):\n 1. (\\<And>t' s' p'.\n        \\<lbrakk>(L' = Pos (Eq t' s') \\<or> L' = Pos (Eq s' t')) \\<and>\n                 (t', s') \\<notin> trm_ord \\<and> p' = pos \\<or>\n                 (L' = Neg (Eq t' s') \\<or> L' = Neg (Eq s' t')) \\<and>\n                 (t', s') \\<notin> trm_ord \\<and> p' = neg;\n         u \\<in> subterms_of t' \\<union> subterms_of s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis Un_commute mset_lit.cases subterms_of_eq.simps subterms_of_lit.simps(1) \n          subterms_of_lit.simps(2) trm_ord_wf wf_asym)"], ["proof (state)\nthis:\n  orient_lit L' t' s' p'\n  u \\<in> subterms_of t' \\<union> subterms_of s'\n\ngoal (1 subgoal):\n 1. \\<not> (u = t \\<or> (u, t) \\<in> trm_ord) \\<Longrightarrow> False", "from \\<open>u \\<in> subterms_of t' \\<union> subterms_of s'\\<close>"], ["proof (chain)\npicking this:\n  u \\<in> subterms_of t' \\<union> subterms_of s'", "have \"u \\<in> subterms_of t' \\<or> u \\<in> subterms_of s'\""], ["proof (prove)\nusing this:\n  u \\<in> subterms_of t' \\<union> subterms_of s'\n\ngoal (1 subgoal):\n 1. u \\<in> subterms_of t' \\<or> u \\<in> subterms_of s'", "by auto"], ["proof (state)\nthis:\n  u \\<in> subterms_of t' \\<or> u \\<in> subterms_of s'\n\ngoal (1 subgoal):\n 1. \\<not> (u = t \\<or> (u, t) \\<in> trm_ord) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  u \\<in> subterms_of t' \\<or> u \\<in> subterms_of s'", "show False"], ["proof (prove)\nusing this:\n  u \\<in> subterms_of t' \\<or> u \\<in> subterms_of s'\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<in> subterms_of t' \\<Longrightarrow> False\n 2. u \\<in> subterms_of s' \\<Longrightarrow> False", "assume \"u \\<in> subterms_of t'\""], ["proof (state)\nthis:\n  u \\<in> subterms_of t'\n\ngoal (2 subgoals):\n 1. u \\<in> subterms_of t' \\<Longrightarrow> False\n 2. u \\<in> subterms_of s' \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  u \\<in> subterms_of t'", "have \"u = t' \\<or> (u,t') \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  u \\<in> subterms_of t'\n\ngoal (1 subgoal):\n 1. u = t' \\<or> (u, t') \\<in> trm_ord", "using subterms_of_trm_ord_eq [of u t']"], ["proof (prove)\nusing this:\n  u \\<in> subterms_of t'\n  u \\<in> subterms_of t' \\<Longrightarrow>\n  u = t' \\<or> (u, t') \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. u = t' \\<or> (u, t') \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  u = t' \\<or> (u, t') \\<in> trm_ord\n\ngoal (2 subgoals):\n 1. u \\<in> subterms_of t' \\<Longrightarrow> False\n 2. u \\<in> subterms_of s' \\<Longrightarrow> False", "from neg_h and \\<open>vars_of u = {}\\<close> and  \\<open>vars_of t = {}\\<close>"], ["proof (chain)\npicking this:\n  \\<not> (u = t \\<or> (u, t) \\<in> trm_ord)\n  vars_of u = {}\n  vars_of t = {}", "have \"(t,u) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  \\<not> (u = t \\<or> (u, t) \\<in> trm_ord)\n  vars_of u = {}\n  vars_of t = {}\n\ngoal (1 subgoal):\n 1. (t, u) \\<in> trm_ord", "using trm_ord_ground_total"], ["proof (prove)\nusing this:\n  \\<not> (u = t \\<or> (u, t) \\<in> trm_ord)\n  vars_of u = {}\n  vars_of t = {}\n  \\<forall>x y.\n     ground_term x \\<longrightarrow>\n     ground_term y \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (t, u) \\<in> trm_ord", "unfolding ground_term_def"], ["proof (prove)\nusing this:\n  \\<not> (u = t \\<or> (u, t) \\<in> trm_ord)\n  vars_of u = {}\n  vars_of t = {}\n  \\<forall>x y.\n     vars_of x = {} \\<longrightarrow>\n     vars_of y = {} \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (t, u) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (t, u) \\<in> trm_ord\n\ngoal (2 subgoals):\n 1. u \\<in> subterms_of t' \\<Longrightarrow> False\n 2. u \\<in> subterms_of s' \\<Longrightarrow> False", "from this and \\<open>u = t' \\<or> (u,t') \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  (t, u) \\<in> trm_ord\n  u = t' \\<or> (u, t') \\<in> trm_ord", "have \"(t,t') \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (t, u) \\<in> trm_ord\n  u = t' \\<or> (u, t') \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (t, t') \\<in> trm_ord", "using trm_ord_trans"], ["proof (prove)\nusing this:\n  (t, u) \\<in> trm_ord\n  u = t' \\<or> (u, t') \\<in> trm_ord\n  trans trm_ord\n\ngoal (1 subgoal):\n 1. (t, t') \\<in> trm_ord", "unfolding trans_def"], ["proof (prove)\nusing this:\n  (t, u) \\<in> trm_ord\n  u = t' \\<or> (u, t') \\<in> trm_ord\n  \\<forall>x y z.\n     (x, y) \\<in> trm_ord \\<longrightarrow>\n     (y, z) \\<in> trm_ord \\<longrightarrow> (x, z) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (t, t') \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (t, t') \\<in> trm_ord\n\ngoal (2 subgoals):\n 1. u \\<in> subterms_of t' \\<Longrightarrow> False\n 2. u \\<in> subterms_of s' \\<Longrightarrow> False", "from this and \\<open>vars_of_lit L' = {}\\<close>  and assms(4) and \n        \\<open>orient_lit L t s p\\<close> and \\<open>orient_lit L' t' s' p'\\<close>"], ["proof (chain)\npicking this:\n  (t, t') \\<in> trm_ord\n  vars_of_lit L' = {}\n  vars_of_lit L = {}\n  orient_lit L t s p\n  orient_lit L' t' s' p'", "have \"(L,L') \\<in> lit_ord\""], ["proof (prove)\nusing this:\n  (t, t') \\<in> trm_ord\n  vars_of_lit L' = {}\n  vars_of_lit L = {}\n  orient_lit L t s p\n  orient_lit L' t' s' p'\n\ngoal (1 subgoal):\n 1. (L, L') \\<in> lit_ord", "using lit_ord_dominating_term"], ["proof (prove)\nusing this:\n  (t, t') \\<in> trm_ord\n  vars_of_lit L' = {}\n  vars_of_lit L = {}\n  orient_lit L t s p\n  orient_lit L' t' s' p'\n  \\<lbrakk>(?s1.0, ?s2.0) \\<in> trm_ord \\<or> (?s1.0, ?t2.0) \\<in> trm_ord;\n   orient_lit ?x1.0 ?s1.0 ?t1.0 ?p1.0; orient_lit ?x2.0 ?s2.0 ?t2.0 ?p2.0;\n   vars_of_lit ?x1.0 = {}; vars_of_lit ?x2.0 = {}\\<rbrakk>\n  \\<Longrightarrow> (?x1.0, ?x2.0) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (L, L') \\<in> lit_ord", "by blast"], ["proof (state)\nthis:\n  (L, L') \\<in> lit_ord\n\ngoal (2 subgoals):\n 1. u \\<in> subterms_of t' \\<Longrightarrow> False\n 2. u \\<in> subterms_of s' \\<Longrightarrow> False", "from this and assms(1) and \\<open>L' \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  (L, L') \\<in> lit_ord\n  maximal_literal L C\n  L' \\<in> C", "show False"], ["proof (prove)\nusing this:\n  (L, L') \\<in> lit_ord\n  maximal_literal L C\n  L' \\<in> C\n\ngoal (1 subgoal):\n 1. False", "unfolding maximal_literal_def"], ["proof (prove)\nusing this:\n  (L, L') \\<in> lit_ord\n  \\<forall>x. x \\<in> C \\<longrightarrow> (L, x) \\<notin> lit_ord\n  L' \\<in> C\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. u \\<in> subterms_of s' \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<in> subterms_of s' \\<Longrightarrow> False", "assume \"u \\<in> subterms_of s'\""], ["proof (state)\nthis:\n  u \\<in> subterms_of s'\n\ngoal (1 subgoal):\n 1. u \\<in> subterms_of s' \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  u \\<in> subterms_of s'", "have \"u = s' \\<or> (u,s') \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  u \\<in> subterms_of s'\n\ngoal (1 subgoal):\n 1. u = s' \\<or> (u, s') \\<in> trm_ord", "using subterms_of_trm_ord_eq [of u s']"], ["proof (prove)\nusing this:\n  u \\<in> subterms_of s'\n  u \\<in> subterms_of s' \\<Longrightarrow>\n  u = s' \\<or> (u, s') \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. u = s' \\<or> (u, s') \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  u = s' \\<or> (u, s') \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. u \\<in> subterms_of s' \\<Longrightarrow> False", "from neg_h and \\<open>vars_of u = {}\\<close> and  \\<open>vars_of t = {}\\<close>"], ["proof (chain)\npicking this:\n  \\<not> (u = t \\<or> (u, t) \\<in> trm_ord)\n  vars_of u = {}\n  vars_of t = {}", "have \"(t,u) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  \\<not> (u = t \\<or> (u, t) \\<in> trm_ord)\n  vars_of u = {}\n  vars_of t = {}\n\ngoal (1 subgoal):\n 1. (t, u) \\<in> trm_ord", "using trm_ord_ground_total"], ["proof (prove)\nusing this:\n  \\<not> (u = t \\<or> (u, t) \\<in> trm_ord)\n  vars_of u = {}\n  vars_of t = {}\n  \\<forall>x y.\n     ground_term x \\<longrightarrow>\n     ground_term y \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (t, u) \\<in> trm_ord", "unfolding ground_term_def"], ["proof (prove)\nusing this:\n  \\<not> (u = t \\<or> (u, t) \\<in> trm_ord)\n  vars_of u = {}\n  vars_of t = {}\n  \\<forall>x y.\n     vars_of x = {} \\<longrightarrow>\n     vars_of y = {} \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (t, u) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (t, u) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. u \\<in> subterms_of s' \\<Longrightarrow> False", "from this and \\<open>u = s' \\<or> (u,s') \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  (t, u) \\<in> trm_ord\n  u = s' \\<or> (u, s') \\<in> trm_ord", "have \"(t,s') \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (t, u) \\<in> trm_ord\n  u = s' \\<or> (u, s') \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (t, s') \\<in> trm_ord", "using trm_ord_trans"], ["proof (prove)\nusing this:\n  (t, u) \\<in> trm_ord\n  u = s' \\<or> (u, s') \\<in> trm_ord\n  trans trm_ord\n\ngoal (1 subgoal):\n 1. (t, s') \\<in> trm_ord", "unfolding trans_def"], ["proof (prove)\nusing this:\n  (t, u) \\<in> trm_ord\n  u = s' \\<or> (u, s') \\<in> trm_ord\n  \\<forall>x y z.\n     (x, y) \\<in> trm_ord \\<longrightarrow>\n     (y, z) \\<in> trm_ord \\<longrightarrow> (x, z) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (t, s') \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (t, s') \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. u \\<in> subterms_of s' \\<Longrightarrow> False", "from this and \\<open>vars_of_lit L' = {}\\<close>  and assms(4) and \n        \\<open>orient_lit L t s p\\<close> and \\<open>orient_lit L' t' s' p'\\<close>"], ["proof (chain)\npicking this:\n  (t, s') \\<in> trm_ord\n  vars_of_lit L' = {}\n  vars_of_lit L = {}\n  orient_lit L t s p\n  orient_lit L' t' s' p'", "have \"(L,L') \\<in> lit_ord\""], ["proof (prove)\nusing this:\n  (t, s') \\<in> trm_ord\n  vars_of_lit L' = {}\n  vars_of_lit L = {}\n  orient_lit L t s p\n  orient_lit L' t' s' p'\n\ngoal (1 subgoal):\n 1. (L, L') \\<in> lit_ord", "using lit_ord_dominating_term"], ["proof (prove)\nusing this:\n  (t, s') \\<in> trm_ord\n  vars_of_lit L' = {}\n  vars_of_lit L = {}\n  orient_lit L t s p\n  orient_lit L' t' s' p'\n  \\<lbrakk>(?s1.0, ?s2.0) \\<in> trm_ord \\<or> (?s1.0, ?t2.0) \\<in> trm_ord;\n   orient_lit ?x1.0 ?s1.0 ?t1.0 ?p1.0; orient_lit ?x2.0 ?s2.0 ?t2.0 ?p2.0;\n   vars_of_lit ?x1.0 = {}; vars_of_lit ?x2.0 = {}\\<rbrakk>\n  \\<Longrightarrow> (?x1.0, ?x2.0) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (L, L') \\<in> lit_ord", "by blast"], ["proof (state)\nthis:\n  (L, L') \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. u \\<in> subterms_of s' \\<Longrightarrow> False", "from this and assms(1) and \\<open>L' \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  (L, L') \\<in> lit_ord\n  maximal_literal L C\n  L' \\<in> C", "show False"], ["proof (prove)\nusing this:\n  (L, L') \\<in> lit_ord\n  maximal_literal L C\n  L' \\<in> C\n\ngoal (1 subgoal):\n 1. False", "unfolding maximal_literal_def"], ["proof (prove)\nusing this:\n  (L, L') \\<in> lit_ord\n  \\<forall>x. x \\<in> C \\<longrightarrow> (L, x) \\<notin> lit_ord\n  L' \\<in> C\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>A term dominates an expression if the expression contains no strictly greater subterm:\\<close>"], ["", "fun dominate_eq:: \"'a trm \\<Rightarrow> 'a equation \\<Rightarrow> bool\"\n  where \"(dominate_eq t (Eq u v)) = ((t,u) \\<notin> trm_ord \\<and> (t,v) \\<notin> trm_ord)\""], ["", "fun dominate_lit:: \"'a trm \\<Rightarrow> 'a literal \\<Rightarrow> bool\"\n  where \"(dominate_lit t (Pos e)) = (dominate_eq t e)\" |\n        \"(dominate_lit t (Neg e)) = (dominate_eq t e)\""], ["", "definition dominate_cl:: \"'a trm \\<Rightarrow> 'a clause \\<Rightarrow> bool\"\n  where \"(dominate_cl t C) = (\\<forall>x \\<in> C. (dominate_lit t x))\""], ["", "definition no_disequation_in_cl:: \"'a trm \\<Rightarrow> 'a clause \\<Rightarrow> bool\"\n  where \"(no_disequation_in_cl t C) = (\\<forall>u v. \n    (Neg (Eq u v) \\<in> C \\<longrightarrow> (u \\<noteq> t \\<and> v \\<noteq> t)))\""], ["", "definition no_taut_eq_in_cl:: \"'a trm \\<Rightarrow> 'a clause \\<Rightarrow> bool\"\n  where \"(no_taut_eq_in_cl t C) = (Pos (Eq t t) \\<notin> C)\""], ["", "definition eq_occurs_in_cl\n  where\n    \"(eq_occurs_in_cl t s C \\<sigma>) = (\\<exists>L t' s'. (L \\<in> C) \\<and> (orient_lit_inst L t' s' pos \\<sigma>) \n        \\<and> (t = subst t' \\<sigma>) \\<and> (s = subst s' \\<sigma>))\""], ["", "subsection \\<open>Inference Rules\\<close>"], ["", "text \\<open>We now define the rules of the superposition calculus. Standard superposition is \na refinement of the paramodulation rule based on the following ideas: \n\n(i) the replacement of a term by a bigger term is forbidden; \n\n(ii) the replacement can be performed only in the maximal term of a maximal (or selected) literal; \n\n(iii) replacement of variables is forbidden.\n\nOur definition imposes additional conditions on the positions on which the replacements\nare allowed: any superposition inference inside a term occurring in the set attached to the \nextended clause is blocked.\n\\<close>"], ["", "text \\<open>We consider two different kinds of inferences: ground or first-order. Ground inferences\nare those needed for completeness, first-order inferences are those actually used \nby theorem provers. For conciseness, these two notions of inferences are defined simultaneously, \nand a parameter is added to the corresponding functions to determine whether the \ninference is ground or first-order.\\<close>"], ["", "datatype inferences = Ground | FirstOrder"], ["", "text \\<open>The following function checks whether a given substitution is a unifier of two terms.\nIf the inference is first-order then the unifier must be maximal.\\<close>"], ["", "definition ck_unifier\nwhere \n  \"(ck_unifier t s \\<sigma> type) = \n    (if (type = FirstOrder) then (MGU \\<sigma> t s) else (Unifier \\<sigma> t s))\""], ["", "lemma ck_unifier_thm:\n  assumes \"ck_unifier t s \\<sigma> k\"\n  shows \"(subst t \\<sigma>) = (subst s \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>", "by (metis assms MGU_is_Unifier ck_unifier_def Unifier_def)"], ["", "lemma subst_preserve_ck_unifier:\n  assumes \"ck_unifier t s \\<sigma> k\"\n  shows \"ck_unifier t s (comp \\<sigma> \\<eta>) Ground\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ck_unifier t s (\\<sigma> \\<lozenge> \\<eta>) Ground", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ck_unifier t s (\\<sigma> \\<lozenge> \\<eta>) Ground", "let ?\\<sigma>' = \"(comp \\<sigma> \\<eta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ck_unifier t s (\\<sigma> \\<lozenge> \\<eta>) Ground", "from assms"], ["proof (chain)\npicking this:\n  ck_unifier t s \\<sigma> k", "have \"(subst t \\<sigma>) = (subst s \\<sigma>)\""], ["proof (prove)\nusing this:\n  ck_unifier t s \\<sigma> k\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>", "using ck_unifier_thm"], ["proof (prove)\nusing this:\n  ck_unifier t s \\<sigma> k\n  ck_unifier ?t ?s ?\\<sigma> ?k \\<Longrightarrow>\n  ?t \\<lhd> ?\\<sigma> = ?s \\<lhd> ?\\<sigma>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. ck_unifier t s (\\<sigma> \\<lozenge> \\<eta>) Ground", "then"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>", "have \"(subst t ?\\<sigma>') = (subst s ?\\<sigma>')\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> \\<lozenge> \\<eta> =\n    s \\<lhd> \\<sigma> \\<lozenge> \\<eta>", "by simp"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> \\<lozenge> \\<eta> = s \\<lhd> \\<sigma> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. ck_unifier t s (\\<sigma> \\<lozenge> \\<eta>) Ground", "then"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<sigma> \\<lozenge> \\<eta> = s \\<lhd> \\<sigma> \\<lozenge> \\<eta>", "show ?thesis"], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> \\<lozenge> \\<eta> = s \\<lhd> \\<sigma> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. ck_unifier t s (\\<sigma> \\<lozenge> \\<eta>) Ground", "unfolding ck_unifier_def Unifier_def"], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> \\<lozenge> \\<eta> = s \\<lhd> \\<sigma> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. if Ground = FirstOrder then MGU (\\<sigma> \\<lozenge> \\<eta>) t s\n    else t \\<lhd> \\<sigma> \\<lozenge> \\<eta> =\n         s \\<lhd> \\<sigma> \\<lozenge> \\<eta>", "by auto"], ["proof (state)\nthis:\n  ck_unifier t s (\\<sigma> \\<lozenge> \\<eta>) Ground\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The following function checks whether a given term is allowed to be reduced according to the \nstrategy described above, i.e., that it does not occur in the set of terms associated with \nthe clause (we do not assume that the set of irreducible terms is closed under subterm\nthus we use the function @{term \"occurs_in\"} instead of a mere membership test.\\<close>"], ["", "definition allowed_redex \n  where \"allowed_redex t C \\<sigma> = (\\<not> (\\<exists>s \\<in> (trms_ecl C). \n    (occurs_in (subst t \\<sigma>) (subst s \\<sigma>))))\""], ["", "text \\<open>The following function allows one to compute the set of irreducible terms attached to\nthe conclusion of an inference. The computation depends on the type of the considered inference: \nfor ground inferences the entire set of irreducible terms is kept. For first-order inferences, \nthe function @{term \"filter_trms\"} is called to remove some of the terms \n(see also the function @{term \"dom_trms\"} below).\\<close>"], ["", "definition get_trms\n  where \n      \"get_trms C E t = (if (t = FirstOrder) then (filter_trms C E) else E)\""], ["", "text \\<open>The following definition provides the conditions that allow one to propagate irreducible\nterms from the parent clauses to the conclusion. A term can be propagated if it is strictly lower \nthan a term occurring in the derived clause, or if it occurs in a negative literal of the derived \nclause. Note that this condition is slightly more restrictive than that of the basic superposition \ncalculus, because maximal terms occurring in maximal positive literals cannot be kept in the set of \nirreducible terms. However in our definition, terms can be propagated even if they do not occur in \nthe parent clause or in the conclusion. Extended clauses whose set of irreducible terms fulfills \nthis property are called well-constrained.\\<close>"], ["", "definition dom_trm\n  where \"dom_trm t C = \n      (\\<exists> L u v p. (L \\<in> C \\<and> (decompose_literal L u v p) \n        \\<and> (( (p = neg \\<and> t = u) \\<or> (t,u) \\<in> trm_ord))))\""], ["", "lemma dom_trm_lemma:\n  assumes \"dom_trm t C\"\n  shows \"\\<exists> u. (u \\<in> (subterms_of_cl C) \\<and> (u = t \\<or> (t,u) \\<in> trm_ord))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u.\n       u \\<in> subterms_of_cl C \\<and> (u = t \\<or> (t, u) \\<in> trm_ord)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>u.\n       u \\<in> subterms_of_cl C \\<and> (u = t \\<or> (t, u) \\<in> trm_ord)", "from   assms(1)"], ["proof (chain)\npicking this:\n  dom_trm t C", "obtain L u v p where\n    \"L \\<in> C\" \"decompose_literal L u v p\" \"(u = t \\<or> (t,u) \\<in> trm_ord)\""], ["proof (prove)\nusing this:\n  dom_trm t C\n\ngoal (1 subgoal):\n 1. (\\<And>L u v p.\n        \\<lbrakk>L \\<in> C; decompose_literal L u v p;\n         u = t \\<or> (t, u) \\<in> trm_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dom_trm_def"], ["proof (prove)\nusing this:\n  \\<exists>L u v p.\n     L \\<in> C \\<and>\n     decompose_literal L u v p \\<and>\n     (p = neg \\<and> t = u \\<or> (t, u) \\<in> trm_ord)\n\ngoal (1 subgoal):\n 1. (\\<And>L u v p.\n        \\<lbrakk>L \\<in> C; decompose_literal L u v p;\n         u = t \\<or> (t, u) \\<in> trm_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  L \\<in> C\n  decompose_literal L u v p\n  u = t \\<or> (t, u) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<exists>u.\n       u \\<in> subterms_of_cl C \\<and> (u = t \\<or> (t, u) \\<in> trm_ord)", "from \\<open>decompose_literal L u v p\\<close>"], ["proof (chain)\npicking this:\n  decompose_literal L u v p", "have \"u \\<in> subterms_of_lit L\""], ["proof (prove)\nusing this:\n  decompose_literal L u v p\n\ngoal (1 subgoal):\n 1. u \\<in> subterms_of_lit L", "unfolding decompose_literal_def decompose_equation_def"], ["proof (prove)\nusing this:\n  \\<exists>e.\n     p = pos \\<and> L = Pos e \\<and> (e = Eq u v \\<or> e = Eq v u) \\<or>\n     p = neg \\<and> L = Neg e \\<and> (e = Eq u v \\<or> e = Eq v u)\n\ngoal (1 subgoal):\n 1. u \\<in> subterms_of_lit L", "using root_subterm"], ["proof (prove)\nusing this:\n  \\<exists>e.\n     p = pos \\<and> L = Pos e \\<and> (e = Eq u v \\<or> e = Eq v u) \\<or>\n     p = neg \\<and> L = Neg e \\<and> (e = Eq u v \\<or> e = Eq v u)\n  ?t \\<in> subterms_of ?t\n\ngoal (1 subgoal):\n 1. u \\<in> subterms_of_lit L", "by force"], ["proof (state)\nthis:\n  u \\<in> subterms_of_lit L\n\ngoal (1 subgoal):\n 1. \\<exists>u.\n       u \\<in> subterms_of_cl C \\<and> (u = t \\<or> (t, u) \\<in> trm_ord)", "from this and \\<open>L \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  u \\<in> subterms_of_lit L\n  L \\<in> C", "have \"u \\<in> (subterms_of_cl C)\""], ["proof (prove)\nusing this:\n  u \\<in> subterms_of_lit L\n  L \\<in> C\n\ngoal (1 subgoal):\n 1. u \\<in> subterms_of_cl C", "by auto"], ["proof (state)\nthis:\n  u \\<in> subterms_of_cl C\n\ngoal (1 subgoal):\n 1. \\<exists>u.\n       u \\<in> subterms_of_cl C \\<and> (u = t \\<or> (t, u) \\<in> trm_ord)", "from this and \\<open>(u = t \\<or> (t,u) \\<in> trm_ord)\\<close>"], ["proof (chain)\npicking this:\n  u \\<in> subterms_of_cl C\n  u = t \\<or> (t, u) \\<in> trm_ord", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<in> subterms_of_cl C\n  u = t \\<or> (t, u) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<exists>u.\n       u \\<in> subterms_of_cl C \\<and> (u = t \\<or> (t, u) \\<in> trm_ord)", "by auto"], ["proof (state)\nthis:\n  \\<exists>u.\n     u \\<in> subterms_of_cl C \\<and> (u = t \\<or> (t, u) \\<in> trm_ord)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition dom_trms\nwhere\n  \"dom_trms C E = { x. (x \\<in> E) \\<and> (dom_trm x C) }\""], ["", "lemma dom_trms_subset:\n  shows \"(dom_trms C E ) \\<subseteq> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom_trms C E \\<subseteq> E", "unfolding dom_trms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> E. dom_trm x C} \\<subseteq> E", "by auto"], ["", "lemma dom_trm_vars:\n  assumes \"dom_trm t C\"\n  shows \"vars_of t \\<subseteq> vars_of_cl C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_cl C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_cl C", "from assms"], ["proof (chain)\npicking this:\n  dom_trm t C", "obtain L u v p where \"L \\<in> C\" \"decompose_literal L u v p\" \"t = u \\<or> (t,u) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  dom_trm t C\n\ngoal (1 subgoal):\n 1. (\\<And>L u v p.\n        \\<lbrakk>L \\<in> C; decompose_literal L u v p;\n         t = u \\<or> (t, u) \\<in> trm_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dom_trm_def"], ["proof (prove)\nusing this:\n  \\<exists>L u v p.\n     L \\<in> C \\<and>\n     decompose_literal L u v p \\<and>\n     (p = neg \\<and> t = u \\<or> (t, u) \\<in> trm_ord)\n\ngoal (1 subgoal):\n 1. (\\<And>L u v p.\n        \\<lbrakk>L \\<in> C; decompose_literal L u v p;\n         t = u \\<or> (t, u) \\<in> trm_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L \\<in> C\n  decompose_literal L u v p\n  t = u \\<or> (t, u) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_cl C", "from \\<open>t = u \\<or> (t,u) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  t = u \\<or> (t, u) \\<in> trm_ord", "have \"vars_of t \\<subseteq> vars_of u\""], ["proof (prove)\nusing this:\n  t = u \\<or> (t, u) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of u", "using trm_ord_vars"], ["proof (prove)\nusing this:\n  t = u \\<or> (t, u) \\<in> trm_ord\n  (?t, ?s) \\<in> trm_ord \\<Longrightarrow> vars_of ?t \\<subseteq> vars_of ?s\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of u", "by blast"], ["proof (state)\nthis:\n  vars_of t \\<subseteq> vars_of u\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_cl C", "from this and \\<open>decompose_literal L u v p\\<close>"], ["proof (chain)\npicking this:\n  vars_of t \\<subseteq> vars_of u\n  decompose_literal L u v p", "have \"vars_of t \\<subseteq> vars_of_lit L\""], ["proof (prove)\nusing this:\n  vars_of t \\<subseteq> vars_of u\n  decompose_literal L u v p\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L", "using decompose_literal_vars"], ["proof (prove)\nusing this:\n  vars_of t \\<subseteq> vars_of u\n  decompose_literal L u v p\n  decompose_literal ?L ?t ?s ?p \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L", "by blast"], ["proof (state)\nthis:\n  vars_of t \\<subseteq> vars_of_lit L\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_cl C", "from this"], ["proof (chain)\npicking this:\n  vars_of t \\<subseteq> vars_of_lit L", "show ?thesis"], ["proof (prove)\nusing this:\n  vars_of t \\<subseteq> vars_of_lit L\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_cl C", "using \\<open>L \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  vars_of t \\<subseteq> vars_of_lit L\n  L \\<in> C\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_cl C", "by auto"], ["proof (state)\nthis:\n  vars_of t \\<subseteq> vars_of_cl C\n\ngoal:\nNo subgoals!", "qed"], ["", "definition well_constrained\n  where \"well_constrained C = (\\<forall>y. (y \\<in> trms_ecl C \\<longrightarrow> dom_trm y (cl_ecl C)))\""], ["", "text \\<open>The next function allows one to check that a set of terms is in normal form. \nThe argument @{term \"f\"} denotes the function mapping a term to its normal form \n(we do not assume that @{term \"f\"} is compatible with the term structure at this point).\\<close>"], ["", "definition all_trms_irreducible\n  where \"(all_trms_irreducible E f) = (\\<forall>x y. (x \\<in> E \\<longrightarrow> occurs_in y x \\<longrightarrow> (f y) = y))\""], ["", "paragraph \\<open>Superposition\\<close>"], ["", "text \\<open>We now define the superposition rule. Note that we assume that the parent clauses are\nvariable-disjoint, but we do not explicitly rename them at this point, thus for completeness\nwe will have to assume that the clause sets are closed under renaming. During the application \nof the rule, all the terms occurring at a position that is lower than that of the reduced\nterm can be added in the set of irreducible terms attached to the conclusion (the intuition is that\nwe assume that the terms occurring at minimal positions are reduced first). \nIn particular, every proper subterm of the reduced term @{term \"u'\"} is added in the set of \nirreducible terms, thus every application of the superposition rule in a term introduced \nby unification will be blocked.\n\nClause @{term \"P1\"} is the ``into'' clause and clause @{term \"P2\"} is the ``from'' clause.\\<close>"], ["", "definition superposition :: \n  \"'a eclause \\<Rightarrow> 'a eclause \\<Rightarrow> 'a eclause \\<Rightarrow> 'a subst \\<Rightarrow> inferences \\<Rightarrow> 'a clause \\<Rightarrow> bool\"\nwhere\n   \"(superposition P1 P2 C \\<sigma> k C') =\n   (\\<exists>L t s u v M p Cl_P1 Cl_P2 Cl_C polarity t' u' L' trms_C. \n      (L \\<in> Cl_P1) \\<and> (M \\<in> Cl_P2) \\<and> (eligible_literal L P1 \\<sigma>) \\<and>  (eligible_literal M P2 \\<sigma>)\n      \\<and> (variable_disjoint P1 P2)\n      \\<and> (Cl_P1 = (cl_ecl P1)) \\<and> (Cl_P2 = (cl_ecl P2)) \n    \\<and> (\\<not> is_a_variable u')\n    \\<and> (allowed_redex u' P1 \\<sigma>)\n    \\<and> trms_C = (get_trms Cl_C (dom_trms Cl_C (subst_set \n        ((trms_ecl P1) \\<union> (trms_ecl P2) \\<union> \n          { r. \\<exists> q. (q,p) \\<in> (pos_ord P1 t) \\<and> (subterm t q r) }) \\<sigma>)) k) \n    \\<and> (C = (Ecl Cl_C trms_C)) \n    \\<and> (orient_lit_inst M u v pos \\<sigma>) \n    \\<and> (orient_lit_inst L t s polarity \\<sigma>) \n    \\<and> ((subst u \\<sigma>) \\<noteq> (subst v \\<sigma>))\n    \\<and> (subterm t p u')\n    \\<and> (ck_unifier u' u \\<sigma> k)\n    \\<and> (replace_subterm t p v t') \n    \\<and> ((k = FirstOrder) \\<or> ( (subst_lit M \\<sigma>),(subst_lit L \\<sigma>)) \\<in> lit_ord)\n    \\<and> ((k = FirstOrder) \\<or> (strictly_maximal_literal P2 M \\<sigma>))\n    \\<and> (L' = mk_lit polarity (Eq t' s)) \n    \\<and> (Cl_C = (subst_cl C' \\<sigma>))\n    \\<and> (C' = (Cl_P1 - { L }) \\<union> ((Cl_P2 - { M }) \\<union> { L' } )))\""], ["", "paragraph \\<open>Reflexion\\<close>"], ["", "text \\<open>We now define the Reflexion rule, which deletes contradictory literals (after unification). \nAll the terms occurring in these literals can be added into the set of irreducible terms\n(intuitively, we can assume that these terms have been normalized before applying the rule). \nIt is sufficient to add the term @{term \"t\"}, since every term occurring in the considered literal \nis a subterm of @{term \"t\"} (after unification).\\<close>"], ["", "definition reflexion ::\n  \"'a eclause \\<Rightarrow> 'a eclause \\<Rightarrow> 'a subst \\<Rightarrow> inferences \\<Rightarrow> 'a clause \\<Rightarrow> bool\"\nwhere\n  \"(reflexion P C \\<sigma> k C') = \n    (\\<exists>L1 t s Cl_P Cl_C trms_C.\n      (eligible_literal L1 P \\<sigma>)\n      \\<and> (L1 \\<in> (cl_ecl P)) \\<and> (Cl_C = (cl_ecl C)) \\<and> (Cl_P = (cl_ecl P)) \n      \\<and> (orient_lit_inst L1 t s neg \\<sigma>)\n      \\<and> (ck_unifier t s \\<sigma> k)\n      \\<and> (C = (Ecl Cl_C trms_C))\n      \\<and> trms_C = (get_trms Cl_C \n          (dom_trms Cl_C (subst_set ( (trms_ecl P) \\<union> { t } ) \\<sigma>)) k) \n      \\<and> (Cl_C = (subst_cl C' \\<sigma>))\n      \\<and> (C' = ((Cl_P - { L1 }) )))\""], ["", "paragraph \\<open>Factorization\\<close>"], ["", "text \\<open>We now define the equational factorization rule, which merges two equations sharing the \nsame left-hand side (after unification), if the right-hand sides are equivalent. \nHere, contrarily to the previous rule, the term @{term \"t\"} cannot be added into the set of \nirreducible terms, because we cannot assume that this term is in normal form (e.g., the application\nof the equational factorization rule may yield a new rewrite rule of left-hand side @{term \"t\"}). \nHowever, all proper subterms of @{term \"t\"} can be added.\\<close>"], ["", "definition factorization ::\n  \"'a eclause \\<Rightarrow> 'a eclause \\<Rightarrow> 'a subst \\<Rightarrow> inferences \\<Rightarrow> 'a clause \\<Rightarrow> bool\"\nwhere\n  \"(factorization P C \\<sigma> k C') = \n    (\\<exists>L1 L2 L' t s u v Cl_P Cl_C trms_C.\n      (eligible_literal L1 P \\<sigma>)\n      \\<and> (L1 \\<in> (cl_ecl P)) \\<and> (L2 \\<in> (cl_ecl P) - { L1 }) \\<and> (Cl_C = (cl_ecl C)) \\<and> (Cl_P = (cl_ecl P)) \n      \\<and> (orient_lit_inst L1 t s pos \\<sigma>)\n      \\<and> (orient_lit_inst L2 u v pos \\<sigma>)\n      \\<and> ((subst t \\<sigma>) \\<noteq> (subst s \\<sigma>))\n      \\<and> ((subst t \\<sigma>) \\<noteq> (subst v \\<sigma>))\n      \\<and> (ck_unifier t u \\<sigma> k)\n      \\<and> (L' = Neg (Eq s v))\n      \\<and> (C = (Ecl Cl_C trms_C)\n      \\<and> trms_C = (get_trms Cl_C \n          (dom_trms Cl_C (subst_set ( (trms_ecl P) \\<union> (proper_subterms_of t) ) \\<sigma>))) k) \n      \\<and> (Cl_C = (subst_cl C' \\<sigma>))\n      \\<and> (C' = ( (Cl_P - { L2 }) \\<union> { L' } )))\""], ["", "subsection \\<open>Derivations\\<close>"], ["", "text \\<open>We now define the set of derivable clauses by induction. Note that redundancy criteria \nare not taken into account at this point. Our definition of derivations also covers renaming.\\<close>"], ["", "definition derivable :: \"'a eclause \\<Rightarrow> 'a eclause set \n  \\<Rightarrow> 'a eclause set \\<Rightarrow> 'a subst \\<Rightarrow> inferences \\<Rightarrow> 'a clause \\<Rightarrow> bool\"\nwhere\n  \"(derivable C P S \\<sigma> k C') = \n      ((\\<exists>P1 P2. (P1 \\<in> S \\<and> P2 \\<in> S \\<and> P = { P1, P2 } \\<and> superposition P1 P2 C \\<sigma> k C'))\n    \\<or> (\\<exists>P1. (P1 \\<in> S \\<and> P = { P1 } \\<and> factorization P1 C \\<sigma> k C'))\n    \\<or> (\\<exists>P1. (P1 \\<in> S \\<and> P = { P1 } \\<and> reflexion P1 C \\<sigma> k C')))\""], ["", "lemma derivable_premisses:\n  assumes \"derivable C P S \\<sigma> k C'\"\n  shows \"P \\<subseteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<subseteq> S", "using assms derivable_def"], ["proof (prove)\nusing this:\n  derivable C P S \\<sigma> k C'\n  derivable ?C ?P ?S ?\\<sigma> ?k ?C' =\n  ((\\<exists>P1 P2.\n       P1 \\<in> ?S \\<and>\n       P2 \\<in> ?S \\<and>\n       ?P = {P1, P2} \\<and> superposition P1 P2 ?C ?\\<sigma> ?k ?C') \\<or>\n   (\\<exists>P1.\n       P1 \\<in> ?S \\<and>\n       ?P = {P1} \\<and> factorization P1 ?C ?\\<sigma> ?k ?C') \\<or>\n   (\\<exists>P1.\n       P1 \\<in> ?S \\<and>\n       ?P = {P1} \\<and> reflexion P1 ?C ?\\<sigma> ?k ?C'))\n\ngoal (1 subgoal):\n 1. P \\<subseteq> S", "by auto"], ["", "inductive derivable_ecl :: \"'a eclause \\<Rightarrow> 'a eclause set  \\<Rightarrow> bool\"\n  where\n    init [simp, intro!]: \"C \\<in> S \\<Longrightarrow> (derivable_ecl C S)\" | \n    rn [simp, intro!]: \"(derivable_ecl C S) \\<Longrightarrow> (renaming_cl C D) \\<Longrightarrow> (derivable_ecl D S)\" | \n    deriv [simp, intro!]: \"(\\<forall>x. (x \\<in> P \\<longrightarrow> (derivable_ecl x S))) \n      \\<Longrightarrow> (derivable C P S' \\<sigma> FirstOrder C') \\<Longrightarrow> (derivable_ecl C S)\""], ["", "text \\<open>We define a notion of instance by associating clauses with ground substitutions.\\<close>"], ["", "definition instances:: \"'a eclause set \\<Rightarrow> ('a eclause \\<times> 'a subst) set\"\n  where \"instances S = { x. \\<exists>C \\<sigma>. (C \\<in> S  \\<and> (ground_clause (subst_cl (cl_ecl C) \\<sigma>)) \n  \\<and> x = ( C,\\<sigma>))}\""], ["", "definition clset_instances:: \"('a eclause \\<times> 'a subst) set \\<Rightarrow> 'a clause set\"\nwhere\n  \"clset_instances S = { C. \\<exists>x. (x \\<in> S \\<and> C = (subst_cl (cl_ecl (fst x)) (snd x))) }\""], ["", "definition grounding_set\n  where \"grounding_set S \\<sigma> = (\\<forall>x. (x \\<in> S \\<longrightarrow> (ground_clause (subst_cl (cl_ecl x) \\<sigma>))))\""], ["", "section \\<open>Soundness\\<close>"], ["", "text \\<open>In this section, we prove that the conclusion of every inference rule is a logical \nconsequence of the premises. Thus a clause set is unsatisfiable if the empty clause is derivable. \nFor each rule, we first prove that all ground instances of the conclusion are entailed by \nthe corresponding instances of the parent clauses, then we lift the result to first-order clauses. \nThe proof is standard and straightforward, but note that we also prove that the derived \nclauses are finite and well-constrained.\\<close>"], ["", "lemma cannot_validate_contradictary_literals :\n  assumes \"l = Neg (Eq t t)\"\n  assumes \"fo_interpretation I\"\n  shows \"\\<not> (validate_ground_lit I l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> validate_ground_lit I l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> validate_ground_lit I l", "from assms(2)"], ["proof (chain)\npicking this:\n  fo_interpretation I", "have \"congruence I\""], ["proof (prove)\nusing this:\n  fo_interpretation I\n\ngoal (1 subgoal):\n 1. congruence I", "unfolding fo_interpretation_def"], ["proof (prove)\nusing this:\n  congruence I\n\ngoal (1 subgoal):\n 1. congruence I", "by auto"], ["proof (state)\nthis:\n  congruence I\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_lit I l", "then"], ["proof (chain)\npicking this:\n  congruence I", "have \"I t t\""], ["proof (prove)\nusing this:\n  congruence I\n\ngoal (1 subgoal):\n 1. I t t", "unfolding congruence_def reflexive_def equivalence_relation_def"], ["proof (prove)\nusing this:\n  ((\\<forall>y. I y y) \\<and> symmetric I \\<and> transitive I) \\<and>\n  compatible_with_structure I\n\ngoal (1 subgoal):\n 1. I t t", "by auto"], ["proof (state)\nthis:\n  I t t\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_lit I l", "from this and assms(1)"], ["proof (chain)\npicking this:\n  I t t\n  l = Neg (Eq t t)", "show ?thesis"], ["proof (prove)\nusing this:\n  I t t\n  l = Neg (Eq t t)\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_lit I l", "by auto"], ["proof (state)\nthis:\n  \\<not> validate_ground_lit I l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ground_reflexion_is_sound :\n  assumes \"finite (cl_ecl C)\"\n  assumes \"reflexion C D \\<sigma> k C'\"\n  assumes \"(ground_clause (subst_cl (cl_ecl D) \\<theta>))\"\n  shows \"clause_entails_clause (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \n          (subst_cl (cl_ecl D) \\<theta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clause_entails_clause (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n     (subst_cl (cl_ecl D) \\<theta>)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "let ?C = \"(cl_ecl C)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "let ?D = \"(cl_ecl D)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "let ?C' = \"(subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "let ?D' = \"(subst_cl (cl_ecl D) \\<theta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "assume \"\\<not> (clause_entails_clause ?C' ?D')\""], ["proof (state)\nthis:\n  \\<not> clause_entails_clause\n          (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n          (subst_cl (cl_ecl D) \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> clause_entails_clause\n          (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n          (subst_cl (cl_ecl D) \\<theta>)", "obtain I where \"validate_clause I ?C'\" and \"\\<not> (validate_clause I ?D')\" \"fo_interpretation I\""], ["proof (prove)\nusing this:\n  \\<not> clause_entails_clause\n          (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n          (subst_cl (cl_ecl D) \\<theta>)\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        \\<lbrakk>validate_clause I\n                  (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>);\n         \\<not> validate_clause I (subst_cl (cl_ecl D) \\<theta>);\n         fo_interpretation I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding clause_entails_clause_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>I.\n             fo_interpretation I \\<longrightarrow>\n             validate_clause I\n              (subst_cl (subst_cl (cl_ecl C) \\<sigma>)\n                \\<theta>) \\<longrightarrow>\n             validate_clause I (subst_cl (cl_ecl D) \\<theta>))\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        \\<lbrakk>validate_clause I\n                  (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>);\n         \\<not> validate_clause I (subst_cl (cl_ecl D) \\<theta>);\n         fo_interpretation I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  validate_clause I (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n  \\<not> validate_clause I (subst_cl (cl_ecl D) \\<theta>)\n  fo_interpretation I\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "from assms(2)"], ["proof (chain)\npicking this:\n  reflexion C D \\<sigma> k C'", "obtain L1 t s where\n    \"?D = (subst_cl (?C - { L1 }) \\<sigma>)\" \n    and \"orient_lit_inst L1 t s neg \\<sigma>\" and \"ck_unifier t s \\<sigma> k\""], ["proof (prove)\nusing this:\n  reflexion C D \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. (\\<And>L1 t s.\n        \\<lbrakk>cl_ecl D = subst_cl (cl_ecl C - {L1}) \\<sigma>;\n         orient_lit_inst L1 t s neg \\<sigma>;\n         ck_unifier t s \\<sigma> k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using reflexion_def [of C D \\<sigma> k]"], ["proof (prove)\nusing this:\n  reflexion C D \\<sigma> k C'\n  reflexion C D \\<sigma> k ?C' =\n  (\\<exists>L1 t s Cl_P Cl_C trms_C.\n      eligible_literal L1 C \\<sigma> \\<and>\n      L1 \\<in> cl_ecl C \\<and>\n      Cl_C = cl_ecl D \\<and>\n      Cl_P = cl_ecl C \\<and>\n      orient_lit_inst L1 t s neg \\<sigma> \\<and>\n      ck_unifier t s \\<sigma> k \\<and>\n      D = Ecl Cl_C trms_C \\<and>\n      trms_C =\n      get_trms Cl_C\n       (dom_trms Cl_C (subst_set (trms_ecl C \\<union> {t}) \\<sigma>))\n       k \\<and>\n      Cl_C = subst_cl ?C' \\<sigma> \\<and> ?C' = Cl_P - {L1})\n\ngoal (1 subgoal):\n 1. (\\<And>L1 t s.\n        \\<lbrakk>cl_ecl D = subst_cl (cl_ecl C - {L1}) \\<sigma>;\n         orient_lit_inst L1 t s neg \\<sigma>;\n         ck_unifier t s \\<sigma> k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  cl_ecl D = subst_cl (cl_ecl C - {L1}) \\<sigma>\n  orient_lit_inst L1 t s neg \\<sigma>\n  ck_unifier t s \\<sigma> k\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "from assms(1)"], ["proof (chain)\npicking this:\n  finite (cl_ecl C)", "have \"finite (subst_cl (subst_cl ?C \\<sigma>) \\<theta>)\""], ["proof (prove)\nusing this:\n  finite (cl_ecl C)\n\ngoal (1 subgoal):\n 1. finite (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)", "by auto"], ["proof (state)\nthis:\n  finite (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  finite (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)", "obtain \\<eta> where i: \"ground_clause (subst_cl \n        (subst_cl (subst_cl ?C \\<sigma>) \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  finite (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>.\n        ground_clause\n         (subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n           \\<eta>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ground_instance_exists [of \"(subst_cl (subst_cl ?C \\<sigma>) \\<theta>)\"]"], ["proof (prove)\nusing this:\n  finite (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n  finite\n   (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<Longrightarrow>\n  \\<exists>\\<sigma>'.\n     ground_clause\n      (subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n        \\<sigma>')\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>.\n        ground_clause\n         (subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n           \\<eta>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ground_clause\n   (subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "let ?CC = \"(subst_cl (subst_cl (subst_cl ?C \\<sigma>) \\<theta>) \\<eta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "let ?\\<sigma>'' = \"comp \\<sigma> \\<theta>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "let ?\\<sigma>' = \"comp ?\\<sigma>'' \\<eta>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "have \"?CC = (subst_cl (subst_cl ?C ?\\<sigma>'') \\<eta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta> =\n    subst_cl (subst_cl (cl_ecl C) (\\<sigma> \\<lozenge> \\<theta>)) \\<eta>", "using composition_of_substs_cl [of ?C]"], ["proof (prove)\nusing this:\n  subst_cl (subst_cl (cl_ecl C) ?\\<sigma>) ?\\<eta> =\n  subst_cl (cl_ecl C) (?\\<sigma> \\<lozenge> ?\\<eta>)\n\ngoal (1 subgoal):\n 1. subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta> =\n    subst_cl (subst_cl (cl_ecl C) (\\<sigma> \\<lozenge> \\<theta>)) \\<eta>", "by auto"], ["proof (state)\nthis:\n  subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (subst_cl (cl_ecl C) (\\<sigma> \\<lozenge> \\<theta>)) \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (subst_cl (cl_ecl C) (\\<sigma> \\<lozenge> \\<theta>)) \\<eta>", "have \"?CC = (subst_cl ?C ?\\<sigma>')\""], ["proof (prove)\nusing this:\n  subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (subst_cl (cl_ecl C) (\\<sigma> \\<lozenge> \\<theta>)) \\<eta>\n\ngoal (1 subgoal):\n 1. subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta> =\n    subst_cl (cl_ecl C) (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "using composition_of_substs_cl [of ?C]"], ["proof (prove)\nusing this:\n  subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (subst_cl (cl_ecl C) (\\<sigma> \\<lozenge> \\<theta>)) \\<eta>\n  subst_cl (subst_cl (cl_ecl C) ?\\<sigma>) ?\\<eta> =\n  subst_cl (cl_ecl C) (?\\<sigma> \\<lozenge> ?\\<eta>)\n\ngoal (1 subgoal):\n 1. subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta> =\n    subst_cl (cl_ecl C) (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (cl_ecl C) (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "from \\<open>validate_clause I (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\\<close>"], ["proof (chain)\npicking this:\n  validate_clause I (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)", "have \"validate_ground_clause I ?CC\""], ["proof (prove)\nusing this:\n  validate_clause I (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n\ngoal (1 subgoal):\n 1. validate_ground_clause I\n     (subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta>)", "using i validate_clause.simps"], ["proof (prove)\nusing this:\n  validate_clause I (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n  ground_clause\n   (subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta>)\n  validate_clause ?I ?C =\n  (\\<forall>s.\n      ground_clause (subst_cl ?C s) \\<longrightarrow>\n      validate_ground_clause ?I (subst_cl ?C s))\n\ngoal (1 subgoal):\n 1. validate_ground_clause I\n     (subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta>)", "by blast"], ["proof (state)\nthis:\n  validate_ground_clause I\n   (subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  validate_ground_clause I\n   (subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta>)", "obtain l' where \"l' \\<in> ?CC\" and \"validate_ground_lit I l'\""], ["proof (prove)\nusing this:\n  validate_ground_clause I\n   (subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>l' \\<in> subst_cl\n                           (subst_cl (subst_cl (cl_ecl C) \\<sigma>)\n                             \\<theta>)\n                           \\<eta>;\n         validate_ground_lit I l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l' \\<in> subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            \\<eta>\n  validate_ground_lit I l'\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "from \\<open>l' \\<in> ?CC\\<close> and \\<open>?CC = (subst_cl ?C ?\\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  l' \\<in> subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            \\<eta>\n  subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (cl_ecl C) (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "obtain l where \n    \"l \\<in> ?C\" and \"l' = (subst_lit l ?\\<sigma>')\""], ["proof (prove)\nusing this:\n  l' \\<in> subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            \\<eta>\n  subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (cl_ecl C) (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l \\<in> cl_ecl C;\n         l' =\n         subst_lit l\n          (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using subst_cl.simps"], ["proof (prove)\nusing this:\n  l' \\<in> subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            \\<eta>\n  subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (cl_ecl C) (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  subst_cl ?C ?s = {L. \\<exists>L'. L' \\<in> ?C \\<and> L = subst_lit L' ?s}\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l \\<in> cl_ecl C;\n         l' =\n         subst_lit l\n          (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  l \\<in> cl_ecl C\n  l' = subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "have \"subst_lit l \\<sigma> \\<in> ?D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<in> cl_ecl D", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<notin> cl_ecl D \\<Longrightarrow> False", "assume \"subst_lit l \\<sigma> \\<notin> ?D\""], ["proof (state)\nthis:\n  subst_lit l \\<sigma> \\<notin> cl_ecl D\n\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<notin> cl_ecl D \\<Longrightarrow> False", "from this and \\<open>?D = (subst_cl (?C - { L1 }) \\<sigma>)\\<close> and \\<open>l \\<in> ?C\\<close>"], ["proof (chain)\npicking this:\n  subst_lit l \\<sigma> \\<notin> cl_ecl D\n  cl_ecl D = subst_cl (cl_ecl C - {L1}) \\<sigma>\n  l \\<in> cl_ecl C", "have \"l = L1\""], ["proof (prove)\nusing this:\n  subst_lit l \\<sigma> \\<notin> cl_ecl D\n  cl_ecl D = subst_cl (cl_ecl C - {L1}) \\<sigma>\n  l \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. l = L1", "by auto"], ["proof (state)\nthis:\n  l = L1\n\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<notin> cl_ecl D \\<Longrightarrow> False", "from this and \\<open>orient_lit_inst L1 t s neg \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  l = L1\n  orient_lit_inst L1 t s neg \\<sigma>", "have \"l = (Neg (Eq t s)) \\<or> l = (Neg (Eq s t))\""], ["proof (prove)\nusing this:\n  l = L1\n  orient_lit_inst L1 t s neg \\<sigma>\n\ngoal (1 subgoal):\n 1. l = Neg (Eq t s) \\<or> l = Neg (Eq s t)", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  l = L1\n  (L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  neg = pos \\<or>\n  (L1 = Neg (Eq t s) \\<or> L1 = Neg (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and> neg = neg\n\ngoal (1 subgoal):\n 1. l = Neg (Eq t s) \\<or> l = Neg (Eq s t)", "by auto"], ["proof (state)\nthis:\n  l = Neg (Eq t s) \\<or> l = Neg (Eq s t)\n\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<notin> cl_ecl D \\<Longrightarrow> False", "from \\<open>ck_unifier t s \\<sigma> k\\<close>"], ["proof (chain)\npicking this:\n  ck_unifier t s \\<sigma> k", "have \"subst t \\<sigma> = subst s \\<sigma>\""], ["proof (prove)\nusing this:\n  ck_unifier t s \\<sigma> k\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>", "using ck_unifier_thm"], ["proof (prove)\nusing this:\n  ck_unifier t s \\<sigma> k\n  ck_unifier ?t ?s ?\\<sigma> ?k \\<Longrightarrow>\n  ?t \\<lhd> ?\\<sigma> = ?s \\<lhd> ?\\<sigma>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<notin> cl_ecl D \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>", "have \"subst (subst (subst t \\<sigma>) \\<theta>) \\<eta> =\n      subst (subst (subst s \\<sigma>) \\<theta>) \\<eta>\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta> =\n    s \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta> =\n  s \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<notin> cl_ecl D \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta> =\n  s \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta>", "have \"(subst t ?\\<sigma>') = subst s ?\\<sigma>'\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta> =\n  s \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta> =\n    s \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>", "by auto"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta> =\n  s \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<notin> cl_ecl D \\<Longrightarrow> False", "from this and \\<open>l = (Neg (Eq t s)) \\<or> l = (Neg (Eq s t))\\<close>"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta> =\n  s \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>\n  l = Neg (Eq t s) \\<or> l = Neg (Eq s t)", "have \"(subst_lit l ?\\<sigma>') = (Neg (Eq (subst t ?\\<sigma>') (subst t ?\\<sigma>')))\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta> =\n  s \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>\n  l = Neg (Eq t s) \\<or> l = Neg (Eq s t)\n\ngoal (1 subgoal):\n 1. subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>) =\n    Neg (Eq (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n          (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))", "by auto"], ["proof (state)\nthis:\n  subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>) =\n  Neg (Eq (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n        (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))\n\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<notin> cl_ecl D \\<Longrightarrow> False", "from this and \\<open>fo_interpretation I\\<close>"], ["proof (chain)\npicking this:\n  subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>) =\n  Neg (Eq (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n        (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))\n  fo_interpretation I", "have \"\\<not> (validate_ground_lit I (subst_lit l ?\\<sigma>'))\""], ["proof (prove)\nusing this:\n  subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>) =\n  Neg (Eq (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n        (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))\n  fo_interpretation I\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_lit I\n            (subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))", "using cannot_validate_contradictary_literals [of \"(subst_lit l ?\\<sigma>')\" \"(subst t ?\\<sigma>')\" I]"], ["proof (prove)\nusing this:\n  subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>) =\n  Neg (Eq (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n        (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))\n  fo_interpretation I\n  \\<lbrakk>subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>) =\n           Neg (Eq (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n                 (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>));\n   fo_interpretation I\\<rbrakk>\n  \\<Longrightarrow> \\<not> validate_ground_lit I\n                            (subst_lit l\n                              (\\<sigma> \\<lozenge> \\<theta> \\<lozenge>\n                               \\<eta>))\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_lit I\n            (subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))", "by auto"], ["proof (state)\nthis:\n  \\<not> validate_ground_lit I\n          (subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))\n\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<notin> cl_ecl D \\<Longrightarrow> False", "from this and \\<open>l' = subst_lit l ?\\<sigma>'\\<close> and \\<open>validate_ground_lit I l'\\<close>"], ["proof (chain)\npicking this:\n  \\<not> validate_ground_lit I\n          (subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))\n  l' = subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  validate_ground_lit I l'", "show False"], ["proof (prove)\nusing this:\n  \\<not> validate_ground_lit I\n          (subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))\n  l' = subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  validate_ground_lit I l'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst_lit l \\<sigma> \\<in> cl_ecl D\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "from \\<open>subst_lit l \\<sigma> \\<in> ?D\\<close> and \\<open>l' = subst_lit l ?\\<sigma>'\\<close>"], ["proof (chain)\npicking this:\n  subst_lit l \\<sigma> \\<in> cl_ecl D\n  l' = subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "have \"l' \\<in> (subst_cl (subst_cl ?D \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  subst_lit l \\<sigma> \\<in> cl_ecl D\n  l' = subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. l' \\<in> subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>", "using subst_cl.simps composition_of_substs_lit mem_Collect_eq"], ["proof (prove)\nusing this:\n  subst_lit l \\<sigma> \\<in> cl_ecl D\n  l' = subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  subst_cl ?C ?s = {L. \\<exists>L'. L' \\<in> ?C \\<and> L = subst_lit L' ?s}\n  subst_lit (subst_lit ?l ?\\<sigma>) ?\\<eta> =\n  subst_lit ?l (?\\<sigma> \\<lozenge> ?\\<eta>)\n  (?a \\<in> Collect ?P) = ?P ?a\n\ngoal (1 subgoal):\n 1. l' \\<in> subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>", "by (metis (mono_tags, lifting))"], ["proof (state)\nthis:\n  l' \\<in> subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "from this and \\<open>validate_ground_lit I l'\\<close>"], ["proof (chain)\npicking this:\n  l' \\<in> subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>\n  validate_ground_lit I l'", "have \n    \"validate_ground_clause I (subst_cl (subst_cl ?D \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  l' \\<in> subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>\n  validate_ground_lit I l'\n\ngoal (1 subgoal):\n 1. validate_ground_clause I\n     (subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>)", "by auto"], ["proof (state)\nthis:\n  validate_ground_clause I (subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "from \\<open>ground_clause (subst_cl ?D \\<theta>)\\<close>"], ["proof (chain)\npicking this:\n  ground_clause (subst_cl (cl_ecl D) \\<theta>)", "have\n    \"(subst_cl ?D \\<theta>) = (subst_cl (subst_cl ?D \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  ground_clause (subst_cl (cl_ecl D) \\<theta>)\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl D) \\<theta> =\n    subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>", "using substs_preserve_ground_clause [of \"(subst_cl ?D \\<theta>)\"  \\<eta>]"], ["proof (prove)\nusing this:\n  ground_clause (subst_cl (cl_ecl D) \\<theta>)\n  ground_clause (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n  subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta> =\n  subst_cl (cl_ecl D) \\<theta>\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl D) \\<theta> =\n    subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>", "by blast"], ["proof (state)\nthis:\n  subst_cl (cl_ecl D) \\<theta> =\n  subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "from this and \\<open>validate_ground_clause I (subst_cl (subst_cl ?D \\<theta>) \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  subst_cl (cl_ecl D) \\<theta> =\n  subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>\n  validate_ground_clause I (subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>)", "have \"validate_ground_clause I (subst_cl ?D \\<theta>)\""], ["proof (prove)\nusing this:\n  subst_cl (cl_ecl D) \\<theta> =\n  subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>\n  validate_ground_clause I (subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. validate_ground_clause I (subst_cl (cl_ecl D) \\<theta>)", "by force"], ["proof (state)\nthis:\n  validate_ground_clause I (subst_cl (cl_ecl D) \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "from this and assms(3) and \\<open>\\<not> validate_clause I (subst_cl (cl_ecl D) \\<theta>)\\<close>"], ["proof (chain)\npicking this:\n  validate_ground_clause I (subst_cl (cl_ecl D) \\<theta>)\n  ground_clause (subst_cl (cl_ecl D) \\<theta>)\n  \\<not> validate_clause I (subst_cl (cl_ecl D) \\<theta>)", "show False"], ["proof (prove)\nusing this:\n  validate_ground_clause I (subst_cl (cl_ecl D) \\<theta>)\n  ground_clause (subst_cl (cl_ecl D) \\<theta>)\n  \\<not> validate_clause I (subst_cl (cl_ecl D) \\<theta>)\n\ngoal (1 subgoal):\n 1. False", "using substs_preserve_ground_clause validate_clause.elims(3)"], ["proof (prove)\nusing this:\n  validate_ground_clause I (subst_cl (cl_ecl D) \\<theta>)\n  ground_clause (subst_cl (cl_ecl D) \\<theta>)\n  \\<not> validate_clause I (subst_cl (cl_ecl D) \\<theta>)\n  ground_clause ?C \\<Longrightarrow> subst_cl ?C ?\\<sigma> = ?C\n  \\<lbrakk>\\<not> validate_clause ?x ?xa;\n   \\<And>I C.\n      \\<lbrakk>?x = I; ?xa = C;\n       \\<not> (\\<forall>s.\n                  ground_clause (subst_cl C s) \\<longrightarrow>\n                  validate_ground_clause I (subst_cl C s))\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reflexion_is_sound :\n  assumes \"finite (cl_ecl C)\"\n  assumes \"reflexion C D \\<sigma> k C'\"\n  shows \"clause_entails_clause (cl_ecl C) (cl_ecl D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clause_entails_clause (cl_ecl C) (cl_ecl D)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause (cl_ecl C) (cl_ecl D) \\<Longrightarrow>\n    False", "let ?C = \"(cl_ecl C)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause (cl_ecl C) (cl_ecl D) \\<Longrightarrow>\n    False", "let ?D = \"(cl_ecl D)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause (cl_ecl C) (cl_ecl D) \\<Longrightarrow>\n    False", "assume \"\\<not> (clause_entails_clause ?C ?D)\""], ["proof (state)\nthis:\n  \\<not> clause_entails_clause (cl_ecl C) (cl_ecl D)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause (cl_ecl C) (cl_ecl D) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> clause_entails_clause (cl_ecl C) (cl_ecl D)", "obtain I where \"validate_clause I ?C\" and \"\\<not> (validate_clause I ?D)\" \"fo_interpretation I\""], ["proof (prove)\nusing this:\n  \\<not> clause_entails_clause (cl_ecl C) (cl_ecl D)\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        \\<lbrakk>validate_clause I (cl_ecl C);\n         \\<not> validate_clause I (cl_ecl D); fo_interpretation I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding clause_entails_clause_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>I.\n             fo_interpretation I \\<longrightarrow>\n             validate_clause I (cl_ecl C) \\<longrightarrow>\n             validate_clause I (cl_ecl D))\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        \\<lbrakk>validate_clause I (cl_ecl C);\n         \\<not> validate_clause I (cl_ecl D); fo_interpretation I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  validate_clause I (cl_ecl C)\n  \\<not> validate_clause I (cl_ecl D)\n  fo_interpretation I\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause (cl_ecl C) (cl_ecl D) \\<Longrightarrow>\n    False", "from \\<open>\\<not> (validate_clause I ?D)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> validate_clause I (cl_ecl D)", "obtain \\<theta> \n    where D_false: \"\\<not> (validate_ground_clause I (subst_cl ?D \\<theta>))\" \n      and \"(ground_clause (subst_cl ?D \\<theta>))\""], ["proof (prove)\nusing this:\n  \\<not> validate_clause I (cl_ecl D)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<theta>.\n        \\<lbrakk>\\<not> validate_ground_clause I\n                         (subst_cl (cl_ecl D) \\<theta>);\n         ground_clause (subst_cl (cl_ecl D) \\<theta>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<not> validate_ground_clause I (subst_cl (cl_ecl D) \\<theta>)\n  ground_clause (subst_cl (cl_ecl D) \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause (cl_ecl C) (cl_ecl D) \\<Longrightarrow>\n    False", "have  \"validate_clause I (subst_cl (subst_cl ?C \\<sigma>) \\<theta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. validate_clause I (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)", "using \\<open>validate_clause I (cl_ecl C)\\<close> instances_are_entailed"], ["proof (prove)\nusing this:\n  validate_clause I (cl_ecl C)\n  validate_clause ?I ?C \\<Longrightarrow>\n  validate_clause ?I (subst_cl ?C ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. validate_clause I (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)", "by blast"], ["proof (state)\nthis:\n  validate_clause I (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause (cl_ecl C) (cl_ecl D) \\<Longrightarrow>\n    False", "from this and assms(1) and assms(2)"], ["proof (chain)\npicking this:\n  validate_clause I (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n  finite (cl_ecl C)\n  reflexion C D \\<sigma> k C'", "have \"validate_clause I (subst_cl ?D \\<theta>)\""], ["proof (prove)\nusing this:\n  validate_clause I (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n  finite (cl_ecl C)\n  reflexion C D \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. validate_clause I (subst_cl (cl_ecl D) \\<theta>)", "using ground_reflexion_is_sound"], ["proof (prove)\nusing this:\n  validate_clause I (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n  finite (cl_ecl C)\n  reflexion C D \\<sigma> k C'\n  \\<lbrakk>finite (cl_ecl ?C); reflexion ?C ?D ?\\<sigma> ?k ?C';\n   ground_clause (subst_cl (cl_ecl ?D) ?\\<theta>)\\<rbrakk>\n  \\<Longrightarrow> clause_entails_clause\n                     (subst_cl (subst_cl (cl_ecl ?C) ?\\<sigma>) ?\\<theta>)\n                     (subst_cl (cl_ecl ?D) ?\\<theta>)\n\ngoal (1 subgoal):\n 1. validate_clause I (subst_cl (cl_ecl D) \\<theta>)", "unfolding clause_entails_clause_def"], ["proof (prove)\nusing this:\n  validate_clause I (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n  finite (cl_ecl C)\n  reflexion C D \\<sigma> k C'\n  \\<lbrakk>finite (cl_ecl ?C); reflexion ?C ?D ?\\<sigma> ?k ?C';\n   ground_clause (subst_cl (cl_ecl ?D) ?\\<theta>)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>I.\n                       fo_interpretation I \\<longrightarrow>\n                       validate_clause I\n                        (subst_cl (subst_cl (cl_ecl ?C) ?\\<sigma>)\n                          ?\\<theta>) \\<longrightarrow>\n                       validate_clause I (subst_cl (cl_ecl ?D) ?\\<theta>)\n\ngoal (1 subgoal):\n 1. validate_clause I (subst_cl (cl_ecl D) \\<theta>)", "using \\<open>fo_interpretation I\\<close> \\<open>ground_clause (subst_cl (cl_ecl D) \\<theta>)\\<close>"], ["proof (prove)\nusing this:\n  validate_clause I (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n  finite (cl_ecl C)\n  reflexion C D \\<sigma> k C'\n  \\<lbrakk>finite (cl_ecl ?C); reflexion ?C ?D ?\\<sigma> ?k ?C';\n   ground_clause (subst_cl (cl_ecl ?D) ?\\<theta>)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>I.\n                       fo_interpretation I \\<longrightarrow>\n                       validate_clause I\n                        (subst_cl (subst_cl (cl_ecl ?C) ?\\<sigma>)\n                          ?\\<theta>) \\<longrightarrow>\n                       validate_clause I (subst_cl (cl_ecl ?D) ?\\<theta>)\n  fo_interpretation I\n  ground_clause (subst_cl (cl_ecl D) \\<theta>)\n\ngoal (1 subgoal):\n 1. validate_clause I (subst_cl (cl_ecl D) \\<theta>)", "by blast"], ["proof (state)\nthis:\n  validate_clause I (subst_cl (cl_ecl D) \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause (cl_ecl C) (cl_ecl D) \\<Longrightarrow>\n    False", "from this and D_false"], ["proof (chain)\npicking this:\n  validate_clause I (subst_cl (cl_ecl D) \\<theta>)\n  \\<not> validate_ground_clause I (subst_cl (cl_ecl D) \\<theta>)", "show False"], ["proof (prove)\nusing this:\n  validate_clause I (subst_cl (cl_ecl D) \\<theta>)\n  \\<not> validate_ground_clause I (subst_cl (cl_ecl D) \\<theta>)\n\ngoal (1 subgoal):\n 1. False", "by (metis \\<open>ground_clause (subst_cl (cl_ecl D) \\<theta>)\\<close> \n    substs_preserve_ground_clause validate_clause.elims(1))"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orient_lit_semantics_pos :\n  assumes \"fo_interpretation I\"\n  assumes \"orient_lit_inst l u v pos \\<eta>\"\n  assumes \"validate_ground_lit I (subst_lit l \\<sigma>)\"\n  shows \"I (subst u \\<sigma>) (subst v \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "let ?u = \"subst u \\<sigma>\""], ["proof (state)\ngoal (1 subgoal):\n 1. I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "let ?v = \"subst v \\<sigma>\""], ["proof (state)\ngoal (1 subgoal):\n 1. I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "from assms(2)"], ["proof (chain)\npicking this:\n  orient_lit_inst l u v pos \\<eta>", "have \"l = (Pos (Eq u v)) \\<or> l = (Pos (Eq v u))\""], ["proof (prove)\nusing this:\n  orient_lit_inst l u v pos \\<eta>\n\ngoal (1 subgoal):\n 1. l = Pos (Eq u v) \\<or> l = Pos (Eq v u)", "using orient_lit_inst_def"], ["proof (prove)\nusing this:\n  orient_lit_inst l u v pos \\<eta>\n  orient_lit_inst ?L ?u ?v ?s ?\\<sigma> =\n  ((?L = Pos (Eq ?u ?v) \\<or> ?L = Pos (Eq ?v ?u)) \\<and>\n   (?u \\<lhd> ?\\<sigma>, ?v \\<lhd> ?\\<sigma>) \\<notin> trm_ord \\<and>\n   ?s = pos \\<or>\n   (?L = Neg (Eq ?u ?v) \\<or> ?L = Neg (Eq ?v ?u)) \\<and>\n   (?u \\<lhd> ?\\<sigma>, ?v \\<lhd> ?\\<sigma>) \\<notin> trm_ord \\<and>\n   ?s = neg)\n\ngoal (1 subgoal):\n 1. l = Pos (Eq u v) \\<or> l = Pos (Eq v u)", "by auto"], ["proof (state)\nthis:\n  l = Pos (Eq u v) \\<or> l = Pos (Eq v u)\n\ngoal (1 subgoal):\n 1. I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "from this and assms(3)"], ["proof (chain)\npicking this:\n  l = Pos (Eq u v) \\<or> l = Pos (Eq v u)\n  validate_ground_lit I (subst_lit l \\<sigma>)", "have \"validate_ground_eq I (Eq ?u ?v) \\<or> validate_ground_eq I (Eq ?v ?u)\""], ["proof (prove)\nusing this:\n  l = Pos (Eq u v) \\<or> l = Pos (Eq v u)\n  validate_ground_lit I (subst_lit l \\<sigma>)\n\ngoal (1 subgoal):\n 1. validate_ground_eq I (Eq (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)) \\<or>\n    validate_ground_eq I (Eq (v \\<lhd> \\<sigma>) (u \\<lhd> \\<sigma>))", "by auto"], ["proof (state)\nthis:\n  validate_ground_eq I (Eq (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)) \\<or>\n  validate_ground_eq I (Eq (v \\<lhd> \\<sigma>) (u \\<lhd> \\<sigma>))\n\ngoal (1 subgoal):\n 1. I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "then"], ["proof (chain)\npicking this:\n  validate_ground_eq I (Eq (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)) \\<or>\n  validate_ground_eq I (Eq (v \\<lhd> \\<sigma>) (u \\<lhd> \\<sigma>))", "have \"I ?u ?v \\<or> I ?v ?u\""], ["proof (prove)\nusing this:\n  validate_ground_eq I (Eq (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)) \\<or>\n  validate_ground_eq I (Eq (v \\<lhd> \\<sigma>) (u \\<lhd> \\<sigma>))\n\ngoal (1 subgoal):\n 1. I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) \\<or>\n    I (v \\<lhd> \\<sigma>) (u \\<lhd> \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) \\<or>\n  I (v \\<lhd> \\<sigma>) (u \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "from this and \\<open>fo_interpretation I\\<close>"], ["proof (chain)\npicking this:\n  I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) \\<or>\n  I (v \\<lhd> \\<sigma>) (u \\<lhd> \\<sigma>)\n  fo_interpretation I", "show \"I ?u ?v\""], ["proof (prove)\nusing this:\n  I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) \\<or>\n  I (v \\<lhd> \\<sigma>) (u \\<lhd> \\<sigma>)\n  fo_interpretation I\n\ngoal (1 subgoal):\n 1. I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "unfolding fo_interpretation_def congruence_def equivalence_relation_def symmetric_def"], ["proof (prove)\nusing this:\n  I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) \\<or>\n  I (v \\<lhd> \\<sigma>) (u \\<lhd> \\<sigma>)\n  (reflexive I \\<and>\n   (\\<forall>y z. I y z = I z y) \\<and> transitive I) \\<and>\n  compatible_with_structure I\n\ngoal (1 subgoal):\n 1. I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "by blast"], ["proof (state)\nthis:\n  I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orient_lit_semantics_neg :\n  assumes \"fo_interpretation I\"\n  assumes \"orient_lit_inst l u v neg \\<theta>\"\n  assumes \"validate_ground_lit I (subst_lit l \\<sigma>)\"\n  shows \"\\<not>I (subst u \\<sigma>) (subst v \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "let ?u = \"subst u \\<sigma>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "let ?v = \"subst v \\<sigma>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "from assms(2)"], ["proof (chain)\npicking this:\n  orient_lit_inst l u v neg \\<theta>", "have \"l = (Neg (Eq u v)) \\<or> l = (Neg (Eq v u))\""], ["proof (prove)\nusing this:\n  orient_lit_inst l u v neg \\<theta>\n\ngoal (1 subgoal):\n 1. l = Neg (Eq u v) \\<or> l = Neg (Eq v u)", "using orient_lit_inst_def"], ["proof (prove)\nusing this:\n  orient_lit_inst l u v neg \\<theta>\n  orient_lit_inst ?L ?u ?v ?s ?\\<sigma> =\n  ((?L = Pos (Eq ?u ?v) \\<or> ?L = Pos (Eq ?v ?u)) \\<and>\n   (?u \\<lhd> ?\\<sigma>, ?v \\<lhd> ?\\<sigma>) \\<notin> trm_ord \\<and>\n   ?s = pos \\<or>\n   (?L = Neg (Eq ?u ?v) \\<or> ?L = Neg (Eq ?v ?u)) \\<and>\n   (?u \\<lhd> ?\\<sigma>, ?v \\<lhd> ?\\<sigma>) \\<notin> trm_ord \\<and>\n   ?s = neg)\n\ngoal (1 subgoal):\n 1. l = Neg (Eq u v) \\<or> l = Neg (Eq v u)", "by auto"], ["proof (state)\nthis:\n  l = Neg (Eq u v) \\<or> l = Neg (Eq v u)\n\ngoal (1 subgoal):\n 1. \\<not> I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "from this and assms(3)"], ["proof (chain)\npicking this:\n  l = Neg (Eq u v) \\<or> l = Neg (Eq v u)\n  validate_ground_lit I (subst_lit l \\<sigma>)", "have \"\\<not>validate_ground_eq I (Eq ?u ?v) \\<or> \\<not>validate_ground_eq I (Eq ?v ?u)\""], ["proof (prove)\nusing this:\n  l = Neg (Eq u v) \\<or> l = Neg (Eq v u)\n  validate_ground_lit I (subst_lit l \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_eq I\n            (Eq (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)) \\<or>\n    \\<not> validate_ground_eq I (Eq (v \\<lhd> \\<sigma>) (u \\<lhd> \\<sigma>))", "by auto"], ["proof (state)\nthis:\n  \\<not> validate_ground_eq I\n          (Eq (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)) \\<or>\n  \\<not> validate_ground_eq I (Eq (v \\<lhd> \\<sigma>) (u \\<lhd> \\<sigma>))\n\ngoal (1 subgoal):\n 1. \\<not> I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "then"], ["proof (chain)\npicking this:\n  \\<not> validate_ground_eq I\n          (Eq (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)) \\<or>\n  \\<not> validate_ground_eq I (Eq (v \\<lhd> \\<sigma>) (u \\<lhd> \\<sigma>))", "have \"\\<not>I ?u ?v \\<or> \\<not>I ?v ?u\""], ["proof (prove)\nusing this:\n  \\<not> validate_ground_eq I\n          (Eq (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)) \\<or>\n  \\<not> validate_ground_eq I (Eq (v \\<lhd> \\<sigma>) (u \\<lhd> \\<sigma>))\n\ngoal (1 subgoal):\n 1. \\<not> I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) \\<or>\n    \\<not> I (v \\<lhd> \\<sigma>) (u \\<lhd> \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  \\<not> I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) \\<or>\n  \\<not> I (v \\<lhd> \\<sigma>) (u \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "from this and \\<open>fo_interpretation I\\<close>"], ["proof (chain)\npicking this:\n  \\<not> I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) \\<or>\n  \\<not> I (v \\<lhd> \\<sigma>) (u \\<lhd> \\<sigma>)\n  fo_interpretation I", "show \"\\<not>I ?u ?v\""], ["proof (prove)\nusing this:\n  \\<not> I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) \\<or>\n  \\<not> I (v \\<lhd> \\<sigma>) (u \\<lhd> \\<sigma>)\n  fo_interpretation I\n\ngoal (1 subgoal):\n 1. \\<not> I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "unfolding fo_interpretation_def congruence_def equivalence_relation_def symmetric_def"], ["proof (prove)\nusing this:\n  \\<not> I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) \\<or>\n  \\<not> I (v \\<lhd> \\<sigma>) (u \\<lhd> \\<sigma>)\n  (reflexive I \\<and>\n   (\\<forall>y z. I y z = I z y) \\<and> transitive I) \\<and>\n  compatible_with_structure I\n\ngoal (1 subgoal):\n 1. \\<not> I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "by blast"], ["proof (state)\nthis:\n  \\<not> I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orient_lit_semantics_replacement :\n  assumes \"fo_interpretation I\"\n  assumes \"orient_lit_inst l u v polarity \\<theta>\"\n  assumes \"validate_ground_lit I (subst_lit l \\<sigma>)\" \n  assumes \"I (subst u \\<sigma>) (subst u' \\<sigma>)\"\n  shows \"validate_ground_lit I (subst_lit (mk_lit polarity (Eq u' v)) \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. validate_ground_lit I (subst_lit (mk_lit polarity (Eq u' v)) \\<sigma>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. validate_ground_lit I (subst_lit (mk_lit polarity (Eq u' v)) \\<sigma>)", "from assms(2)"], ["proof (chain)\npicking this:\n  orient_lit_inst l u v polarity \\<theta>", "obtain e where \"l = Pos e \\<or> l = Neg e\" and \"e = Eq u v \\<or> e = Eq v u\""], ["proof (prove)\nusing this:\n  orient_lit_inst l u v polarity \\<theta>\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>l = Pos e \\<or> l = Neg e;\n         e = Eq u v \\<or> e = Eq v u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  (l = Pos (Eq u v) \\<or> l = Pos (Eq v u)) \\<and>\n  (u \\<lhd> \\<theta>, v \\<lhd> \\<theta>) \\<notin> trm_ord \\<and>\n  polarity = pos \\<or>\n  (l = Neg (Eq u v) \\<or> l = Neg (Eq v u)) \\<and>\n  (u \\<lhd> \\<theta>, v \\<lhd> \\<theta>) \\<notin> trm_ord \\<and>\n  polarity = neg\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>l = Pos e \\<or> l = Neg e;\n         e = Eq u v \\<or> e = Eq v u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l = Pos e \\<or> l = Neg e\n  e = Eq u v \\<or> e = Eq v u\n\ngoal (1 subgoal):\n 1. validate_ground_lit I (subst_lit (mk_lit polarity (Eq u' v)) \\<sigma>)", "have \"polarity = pos \\<or> polarity = neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polarity = pos \\<or> polarity = neg", "using sign.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = pos \\<Longrightarrow> ?P;\n   ?y = neg \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. polarity = pos \\<or> polarity = neg", "by blast"], ["proof (state)\nthis:\n  polarity = pos \\<or> polarity = neg\n\ngoal (1 subgoal):\n 1. validate_ground_lit I (subst_lit (mk_lit polarity (Eq u' v)) \\<sigma>)", "then"], ["proof (chain)\npicking this:\n  polarity = pos \\<or> polarity = neg", "show ?thesis"], ["proof (prove)\nusing this:\n  polarity = pos \\<or> polarity = neg\n\ngoal (1 subgoal):\n 1. validate_ground_lit I (subst_lit (mk_lit polarity (Eq u' v)) \\<sigma>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow>\n    validate_ground_lit I (subst_lit (mk_lit polarity (Eq u' v)) \\<sigma>)\n 2. polarity = neg \\<Longrightarrow>\n    validate_ground_lit I (subst_lit (mk_lit polarity (Eq u' v)) \\<sigma>)", "assume \"polarity = pos\""], ["proof (state)\nthis:\n  polarity = pos\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow>\n    validate_ground_lit I (subst_lit (mk_lit polarity (Eq u' v)) \\<sigma>)\n 2. polarity = neg \\<Longrightarrow>\n    validate_ground_lit I (subst_lit (mk_lit polarity (Eq u' v)) \\<sigma>)", "from this and assms(1) and assms(2) and \\<open>validate_ground_lit I (subst_lit l \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  polarity = pos\n  fo_interpretation I\n  orient_lit_inst l u v polarity \\<theta>\n  validate_ground_lit I (subst_lit l \\<sigma>)", "have\n      \"I (subst u \\<sigma>) (subst v \\<sigma>)\""], ["proof (prove)\nusing this:\n  polarity = pos\n  fo_interpretation I\n  orient_lit_inst l u v polarity \\<theta>\n  validate_ground_lit I (subst_lit l \\<sigma>)\n\ngoal (1 subgoal):\n 1. I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "using orient_lit_semantics_pos"], ["proof (prove)\nusing this:\n  polarity = pos\n  fo_interpretation I\n  orient_lit_inst l u v polarity \\<theta>\n  validate_ground_lit I (subst_lit l \\<sigma>)\n  \\<lbrakk>fo_interpretation ?I; orient_lit_inst ?l ?u ?v pos ?\\<eta>;\n   validate_ground_lit ?I (subst_lit ?l ?\\<sigma>)\\<rbrakk>\n  \\<Longrightarrow> ?I (?u \\<lhd> ?\\<sigma>) (?v \\<lhd> ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow>\n    validate_ground_lit I (subst_lit (mk_lit polarity (Eq u' v)) \\<sigma>)\n 2. polarity = neg \\<Longrightarrow>\n    validate_ground_lit I (subst_lit (mk_lit polarity (Eq u' v)) \\<sigma>)", "from this and assms(1) and \\<open>I (subst u \\<sigma>) (subst u' \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n  fo_interpretation I\n  I (u \\<lhd> \\<sigma>) (u' \\<lhd> \\<sigma>)", "have \"I (subst u' \\<sigma>) (subst v \\<sigma>)\""], ["proof (prove)\nusing this:\n  I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n  fo_interpretation I\n  I (u \\<lhd> \\<sigma>) (u' \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. I (u' \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "unfolding fo_interpretation_def \n      congruence_def equivalence_relation_def symmetric_def transitive_def"], ["proof (prove)\nusing this:\n  I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n  (reflexive I \\<and>\n   (\\<forall>y z. I y z = I z y) \\<and>\n   (\\<forall>y z u.\n       I y z \\<longrightarrow> I z u \\<longrightarrow> I y u)) \\<and>\n  compatible_with_structure I\n  I (u \\<lhd> \\<sigma>) (u' \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. I (u' \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "by blast"], ["proof (state)\nthis:\n  I (u' \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow>\n    validate_ground_lit I (subst_lit (mk_lit polarity (Eq u' v)) \\<sigma>)\n 2. polarity = neg \\<Longrightarrow>\n    validate_ground_lit I (subst_lit (mk_lit polarity (Eq u' v)) \\<sigma>)", "from this and \\<open>polarity = pos\\<close>"], ["proof (chain)\npicking this:\n  I (u' \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n  polarity = pos", "show ?thesis"], ["proof (prove)\nusing this:\n  I (u' \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n  polarity = pos\n\ngoal (1 subgoal):\n 1. validate_ground_lit I (subst_lit (mk_lit polarity (Eq u' v)) \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  validate_ground_lit I (subst_lit (mk_lit polarity (Eq u' v)) \\<sigma>)\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    validate_ground_lit I (subst_lit (mk_lit polarity (Eq u' v)) \\<sigma>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    validate_ground_lit I (subst_lit (mk_lit polarity (Eq u' v)) \\<sigma>)", "assume \"polarity = neg\""], ["proof (state)\nthis:\n  polarity = neg\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    validate_ground_lit I (subst_lit (mk_lit polarity (Eq u' v)) \\<sigma>)", "from this and assms(1) and assms(2) and \\<open>validate_ground_lit I (subst_lit l \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  polarity = neg\n  fo_interpretation I\n  orient_lit_inst l u v polarity \\<theta>\n  validate_ground_lit I (subst_lit l \\<sigma>)", "have\n      \"\\<not>I (subst u \\<sigma>) (subst v \\<sigma>)\""], ["proof (prove)\nusing this:\n  polarity = neg\n  fo_interpretation I\n  orient_lit_inst l u v polarity \\<theta>\n  validate_ground_lit I (subst_lit l \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "using orient_lit_semantics_neg"], ["proof (prove)\nusing this:\n  polarity = neg\n  fo_interpretation I\n  orient_lit_inst l u v polarity \\<theta>\n  validate_ground_lit I (subst_lit l \\<sigma>)\n  \\<lbrakk>fo_interpretation ?I; orient_lit_inst ?l ?u ?v neg ?\\<theta>;\n   validate_ground_lit ?I (subst_lit ?l ?\\<sigma>)\\<rbrakk>\n  \\<Longrightarrow> \\<not> ?I (?u \\<lhd> ?\\<sigma>) (?v \\<lhd> ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "by blast"], ["proof (state)\nthis:\n  \\<not> I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    validate_ground_lit I (subst_lit (mk_lit polarity (Eq u' v)) \\<sigma>)", "from this and assms(1) and \\<open>I (subst u \\<sigma>) (subst u' \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n  fo_interpretation I\n  I (u \\<lhd> \\<sigma>) (u' \\<lhd> \\<sigma>)", "have \"\\<not>I (subst u' \\<sigma>) (subst v \\<sigma>)\""], ["proof (prove)\nusing this:\n  \\<not> I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n  fo_interpretation I\n  I (u \\<lhd> \\<sigma>) (u' \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> I (u' \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "unfolding fo_interpretation_def \n      congruence_def equivalence_relation_def symmetric_def transitive_def"], ["proof (prove)\nusing this:\n  \\<not> I (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n  (reflexive I \\<and>\n   (\\<forall>y z. I y z = I z y) \\<and>\n   (\\<forall>y z u.\n       I y z \\<longrightarrow> I z u \\<longrightarrow> I y u)) \\<and>\n  compatible_with_structure I\n  I (u \\<lhd> \\<sigma>) (u' \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> I (u' \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "by blast"], ["proof (state)\nthis:\n  \\<not> I (u' \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    validate_ground_lit I (subst_lit (mk_lit polarity (Eq u' v)) \\<sigma>)", "from this and \\<open>polarity = neg\\<close>"], ["proof (chain)\npicking this:\n  \\<not> I (u' \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n  polarity = neg", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> I (u' \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n  polarity = neg\n\ngoal (1 subgoal):\n 1. validate_ground_lit I (subst_lit (mk_lit polarity (Eq u' v)) \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  validate_ground_lit I (subst_lit (mk_lit polarity (Eq u' v)) \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  validate_ground_lit I (subst_lit (mk_lit polarity (Eq u' v)) \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ground_factorization_is_sound :\n  assumes \"finite (cl_ecl C)\"\n  assumes \"factorization C D \\<sigma> k C'\"\n  assumes \"(ground_clause (subst_cl (cl_ecl D) \\<theta>))\"\n  shows \"clause_entails_clause (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \n          (subst_cl (cl_ecl D) \\<theta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clause_entails_clause (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n     (subst_cl (cl_ecl D) \\<theta>)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "let ?C = \"(cl_ecl C)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "let ?D = \"(cl_ecl D)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "assume \"\\<not> clause_entails_clause (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \n          (subst_cl (cl_ecl D) \\<theta>)\""], ["proof (state)\nthis:\n  \\<not> clause_entails_clause\n          (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n          (subst_cl (cl_ecl D) \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> clause_entails_clause\n          (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n          (subst_cl (cl_ecl D) \\<theta>)", "obtain I where \n    \"validate_clause I (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\" and \n      \"\\<not> (validate_clause I (subst_cl (cl_ecl D) \\<theta>))\" and \"fo_interpretation I\""], ["proof (prove)\nusing this:\n  \\<not> clause_entails_clause\n          (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n          (subst_cl (cl_ecl D) \\<theta>)\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        \\<lbrakk>validate_clause I\n                  (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>);\n         \\<not> validate_clause I (subst_cl (cl_ecl D) \\<theta>);\n         fo_interpretation I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding clause_entails_clause_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>I.\n             fo_interpretation I \\<longrightarrow>\n             validate_clause I\n              (subst_cl (subst_cl (cl_ecl C) \\<sigma>)\n                \\<theta>) \\<longrightarrow>\n             validate_clause I (subst_cl (cl_ecl D) \\<theta>))\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        \\<lbrakk>validate_clause I\n                  (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>);\n         \\<not> validate_clause I (subst_cl (cl_ecl D) \\<theta>);\n         fo_interpretation I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  validate_clause I (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n  \\<not> validate_clause I (subst_cl (cl_ecl D) \\<theta>)\n  fo_interpretation I\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "from assms(2)"], ["proof (chain)\npicking this:\n  factorization C D \\<sigma> k C'", "obtain L1 L2 L' t s u v where\n      \"orient_lit_inst L1 t s pos \\<sigma>\" and \"orient_lit_inst L2 u v pos \\<sigma>\" and \"ck_unifier t u \\<sigma> k\"\n      and \"L' = Neg (Eq s v)\" \n      and \"(?D =  (subst_cl ( (?C - { L2 }) \\<union> { L' } )) \\<sigma>)\"\n      and \"L1 \\<noteq> L2\"\n      and \"L1 \\<in> ?C\""], ["proof (prove)\nusing this:\n  factorization C D \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. (\\<And>L1 t s L2 u v L'.\n        \\<lbrakk>orient_lit_inst L1 t s pos \\<sigma>;\n         orient_lit_inst L2 u v pos \\<sigma>; ck_unifier t u \\<sigma> k;\n         L' = Neg (Eq s v);\n         cl_ecl D = subst_cl (cl_ecl C - {L2} \\<union> {L'}) \\<sigma>;\n         L1 \\<noteq> L2; L1 \\<in> cl_ecl C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using factorization_def"], ["proof (prove)\nusing this:\n  factorization C D \\<sigma> k C'\n  factorization ?P ?C ?\\<sigma> ?k ?C' =\n  (\\<exists>L1 L2 L' t s u v Cl_P Cl_C trms_C.\n      eligible_literal L1 ?P ?\\<sigma> \\<and>\n      L1 \\<in> cl_ecl ?P \\<and>\n      L2 \\<in> cl_ecl ?P - {L1} \\<and>\n      Cl_C = cl_ecl ?C \\<and>\n      Cl_P = cl_ecl ?P \\<and>\n      orient_lit_inst L1 t s pos ?\\<sigma> \\<and>\n      orient_lit_inst L2 u v pos ?\\<sigma> \\<and>\n      t \\<lhd> ?\\<sigma> \\<noteq> s \\<lhd> ?\\<sigma> \\<and>\n      t \\<lhd> ?\\<sigma> \\<noteq> v \\<lhd> ?\\<sigma> \\<and>\n      ck_unifier t u ?\\<sigma> ?k \\<and>\n      L' = Neg (Eq s v) \\<and>\n      (?C = Ecl Cl_C trms_C \\<and>\n       trms_C =\n       get_trms Cl_C\n        (dom_trms Cl_C\n          (subst_set (trms_ecl ?P \\<union> proper_subterms_of t) ?\\<sigma>))\n        ?k) \\<and>\n      Cl_C = subst_cl ?C' ?\\<sigma> \\<and> ?C' = Cl_P - {L2} \\<union> {L'})\n\ngoal (1 subgoal):\n 1. (\\<And>L1 t s L2 u v L'.\n        \\<lbrakk>orient_lit_inst L1 t s pos \\<sigma>;\n         orient_lit_inst L2 u v pos \\<sigma>; ck_unifier t u \\<sigma> k;\n         L' = Neg (Eq s v);\n         cl_ecl D = subst_cl (cl_ecl C - {L2} \\<union> {L'}) \\<sigma>;\n         L1 \\<noteq> L2; L1 \\<in> cl_ecl C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  orient_lit_inst L1 t s pos \\<sigma>\n  orient_lit_inst L2 u v pos \\<sigma>\n  ck_unifier t u \\<sigma> k\n  L' = Neg (Eq s v)\n  cl_ecl D = subst_cl (cl_ecl C - {L2} \\<union> {L'}) \\<sigma>\n  L1 \\<noteq> L2\n  L1 \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "from assms(1)"], ["proof (chain)\npicking this:\n  finite (cl_ecl C)", "have \"finite (subst_cl (subst_cl ?C \\<sigma>) \\<theta>)\""], ["proof (prove)\nusing this:\n  finite (cl_ecl C)\n\ngoal (1 subgoal):\n 1. finite (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)", "by auto"], ["proof (state)\nthis:\n  finite (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  finite (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)", "obtain \\<eta> where i: \"ground_clause (subst_cl \n        (subst_cl (subst_cl ?C \\<sigma>) \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  finite (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>.\n        ground_clause\n         (subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n           \\<eta>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ground_instance_exists [of \"(subst_cl (subst_cl ?C \\<sigma>) \\<theta>)\"]"], ["proof (prove)\nusing this:\n  finite (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n  finite\n   (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<Longrightarrow>\n  \\<exists>\\<sigma>'.\n     ground_clause\n      (subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n        \\<sigma>')\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>.\n        ground_clause\n         (subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n           \\<eta>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ground_clause\n   (subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "let ?CC = \"(subst_cl (subst_cl (subst_cl ?C \\<sigma>) \\<theta>) \\<eta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "let ?\\<sigma>'' = \"comp \\<sigma> \\<theta>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "let ?\\<sigma>' = \"comp ?\\<sigma>'' \\<eta>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "have \"?CC = (subst_cl (subst_cl ?C ?\\<sigma>'') \\<eta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta> =\n    subst_cl (subst_cl (cl_ecl C) (\\<sigma> \\<lozenge> \\<theta>)) \\<eta>", "using composition_of_substs_cl [of ?C]"], ["proof (prove)\nusing this:\n  subst_cl (subst_cl (cl_ecl C) ?\\<sigma>) ?\\<eta> =\n  subst_cl (cl_ecl C) (?\\<sigma> \\<lozenge> ?\\<eta>)\n\ngoal (1 subgoal):\n 1. subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta> =\n    subst_cl (subst_cl (cl_ecl C) (\\<sigma> \\<lozenge> \\<theta>)) \\<eta>", "by auto"], ["proof (state)\nthis:\n  subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (subst_cl (cl_ecl C) (\\<sigma> \\<lozenge> \\<theta>)) \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (subst_cl (cl_ecl C) (\\<sigma> \\<lozenge> \\<theta>)) \\<eta>", "have \"?CC = (subst_cl ?C ?\\<sigma>')\""], ["proof (prove)\nusing this:\n  subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (subst_cl (cl_ecl C) (\\<sigma> \\<lozenge> \\<theta>)) \\<eta>\n\ngoal (1 subgoal):\n 1. subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta> =\n    subst_cl (cl_ecl C) (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "using composition_of_substs_cl [of ?C]"], ["proof (prove)\nusing this:\n  subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (subst_cl (cl_ecl C) (\\<sigma> \\<lozenge> \\<theta>)) \\<eta>\n  subst_cl (subst_cl (cl_ecl C) ?\\<sigma>) ?\\<eta> =\n  subst_cl (cl_ecl C) (?\\<sigma> \\<lozenge> ?\\<eta>)\n\ngoal (1 subgoal):\n 1. subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta> =\n    subst_cl (cl_ecl C) (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (cl_ecl C) (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "from \\<open>validate_clause I (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\\<close>"], ["proof (chain)\npicking this:\n  validate_clause I (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)", "have \"validate_ground_clause I ?CC\""], ["proof (prove)\nusing this:\n  validate_clause I (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n\ngoal (1 subgoal):\n 1. validate_ground_clause I\n     (subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta>)", "using i validate_clause.simps"], ["proof (prove)\nusing this:\n  validate_clause I (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n  ground_clause\n   (subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta>)\n  validate_clause ?I ?C =\n  (\\<forall>s.\n      ground_clause (subst_cl ?C s) \\<longrightarrow>\n      validate_ground_clause ?I (subst_cl ?C s))\n\ngoal (1 subgoal):\n 1. validate_ground_clause I\n     (subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta>)", "by blast"], ["proof (state)\nthis:\n  validate_ground_clause I\n   (subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  validate_ground_clause I\n   (subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta>)", "obtain l' where \"l' \\<in> ?CC\" and \"validate_ground_lit I l'\""], ["proof (prove)\nusing this:\n  validate_ground_clause I\n   (subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>l' \\<in> subst_cl\n                           (subst_cl (subst_cl (cl_ecl C) \\<sigma>)\n                             \\<theta>)\n                           \\<eta>;\n         validate_ground_lit I l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l' \\<in> subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            \\<eta>\n  validate_ground_lit I l'\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "from \\<open>l' \\<in> ?CC\\<close> and \\<open>?CC = (subst_cl ?C ?\\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  l' \\<in> subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            \\<eta>\n  subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (cl_ecl C) (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "obtain l where \n    \"l \\<in> ?C\" and \"l' = (subst_lit l ?\\<sigma>')\""], ["proof (prove)\nusing this:\n  l' \\<in> subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            \\<eta>\n  subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (cl_ecl C) (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l \\<in> cl_ecl C;\n         l' =\n         subst_lit l\n          (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using subst_cl.simps"], ["proof (prove)\nusing this:\n  l' \\<in> subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            \\<eta>\n  subst_cl (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (cl_ecl C) (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  subst_cl ?C ?s = {L. \\<exists>L'. L' \\<in> ?C \\<and> L = subst_lit L' ?s}\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>l \\<in> cl_ecl C;\n         l' =\n         subst_lit l\n          (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  l \\<in> cl_ecl C\n  l' = subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "from \\<open>\\<not> validate_clause I (subst_cl (cl_ecl D) \\<theta>)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> validate_clause I (subst_cl (cl_ecl D) \\<theta>)", "have \"\\<not> validate_ground_clause I (subst_cl ?D \\<theta>)\""], ["proof (prove)\nusing this:\n  \\<not> validate_clause I (subst_cl (cl_ecl D) \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_clause I (subst_cl (cl_ecl D) \\<theta>)", "using assms(3) substs_preserve_ground_clause validate_clause.elims(3)"], ["proof (prove)\nusing this:\n  \\<not> validate_clause I (subst_cl (cl_ecl D) \\<theta>)\n  ground_clause (subst_cl (cl_ecl D) \\<theta>)\n  ground_clause ?C \\<Longrightarrow> subst_cl ?C ?\\<sigma> = ?C\n  \\<lbrakk>\\<not> validate_clause ?x ?xa;\n   \\<And>I C.\n      \\<lbrakk>?x = I; ?xa = C;\n       \\<not> (\\<forall>s.\n                  ground_clause (subst_cl C s) \\<longrightarrow>\n                  validate_ground_clause I (subst_cl C s))\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_clause I (subst_cl (cl_ecl D) \\<theta>)", "by metis"], ["proof (state)\nthis:\n  \\<not> validate_ground_clause I (subst_cl (cl_ecl D) \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "from \\<open>ground_clause (subst_cl ?D \\<theta>)\\<close>"], ["proof (chain)\npicking this:\n  ground_clause (subst_cl (cl_ecl D) \\<theta>)", "have\n    \"(subst_cl ?D \\<theta>) = (subst_cl (subst_cl ?D \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  ground_clause (subst_cl (cl_ecl D) \\<theta>)\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl D) \\<theta> =\n    subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>", "using substs_preserve_ground_clause [of \"(subst_cl ?D \\<theta>)\"  \\<eta>]"], ["proof (prove)\nusing this:\n  ground_clause (subst_cl (cl_ecl D) \\<theta>)\n  ground_clause (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n  subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta> =\n  subst_cl (cl_ecl D) \\<theta>\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl D) \\<theta> =\n    subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>", "by blast"], ["proof (state)\nthis:\n  subst_cl (cl_ecl D) \\<theta> =\n  subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "from this and \\<open>\\<not> validate_ground_clause I (subst_cl ?D \\<theta>)\\<close>"], ["proof (chain)\npicking this:\n  subst_cl (cl_ecl D) \\<theta> =\n  subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>\n  \\<not> validate_ground_clause I (subst_cl (cl_ecl D) \\<theta>)", "have \"\\<not> validate_ground_clause I (subst_cl (subst_cl ?D \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  subst_cl (cl_ecl D) \\<theta> =\n  subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>\n  \\<not> validate_ground_clause I (subst_cl (cl_ecl D) \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_clause I\n            (subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>)", "by force"], ["proof (state)\nthis:\n  \\<not> validate_ground_clause I\n          (subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "from \\<open>(?D =  (subst_cl ( (?C - { L2 }) \\<union> { L' } )) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  cl_ecl D = subst_cl (cl_ecl C - {L2} \\<union> {L'}) \\<sigma>", "have \"(subst_lit L' \\<sigma>) \\<in> ?D\""], ["proof (prove)\nusing this:\n  cl_ecl D = subst_cl (cl_ecl C - {L2} \\<union> {L'}) \\<sigma>\n\ngoal (1 subgoal):\n 1. subst_lit L' \\<sigma> \\<in> cl_ecl D", "by auto"], ["proof (state)\nthis:\n  subst_lit L' \\<sigma> \\<in> cl_ecl D\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  subst_lit L' \\<sigma> \\<in> cl_ecl D", "have \n    \"(subst_lit (subst_lit (subst_lit L' \\<sigma>) \\<theta>) \\<eta>) \n      \\<in> (subst_cl (subst_cl ?D \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  subst_lit L' \\<sigma> \\<in> cl_ecl D\n\ngoal (1 subgoal):\n 1. subst_lit (subst_lit (subst_lit L' \\<sigma>) \\<theta>) \\<eta>\n    \\<in> subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>", "by auto"], ["proof (state)\nthis:\n  subst_lit (subst_lit (subst_lit L' \\<sigma>) \\<theta>) \\<eta>\n  \\<in> subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "from this and \\<open>\\<not> validate_ground_clause I (subst_cl (subst_cl ?D \\<theta>) \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  subst_lit (subst_lit (subst_lit L' \\<sigma>) \\<theta>) \\<eta>\n  \\<in> subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>\n  \\<not> validate_ground_clause I\n          (subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>)", "have \"\\<not>validate_ground_lit I (subst_lit (subst_lit (subst_lit L' \\<sigma>) \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  subst_lit (subst_lit (subst_lit L' \\<sigma>) \\<theta>) \\<eta>\n  \\<in> subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>\n  \\<not> validate_ground_clause I\n          (subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_lit I\n            (subst_lit (subst_lit (subst_lit L' \\<sigma>) \\<theta>) \\<eta>)", "by auto"], ["proof (state)\nthis:\n  \\<not> validate_ground_lit I\n          (subst_lit (subst_lit (subst_lit L' \\<sigma>) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "from this and \\<open>L'= Neg (Eq s v)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> validate_ground_lit I\n          (subst_lit (subst_lit (subst_lit L' \\<sigma>) \\<theta>) \\<eta>)\n  L' = Neg (Eq s v)", "have \n    \"I (subst (subst (subst s \\<sigma>) \\<theta>) \\<eta>)\n       (subst (subst (subst v \\<sigma>) \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  \\<not> validate_ground_lit I\n          (subst_lit (subst_lit (subst_lit L' \\<sigma>) \\<theta>) \\<eta>)\n  L' = Neg (Eq s v)\n\ngoal (1 subgoal):\n 1. I (s \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta>)\n     (v \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  I (s \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta>)\n   (v \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  I (s \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta>)\n   (v \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta>)", "have \"I (subst s ?\\<sigma>') (subst v ?\\<sigma>')\""], ["proof (prove)\nusing this:\n  I (s \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta>)\n   (v \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. I (s \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n     (v \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "by simp"], ["proof (state)\nthis:\n  I (s \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (v \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "have \"subst_lit l \\<sigma> \\<in> ?D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<in> cl_ecl D", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<notin> cl_ecl D \\<Longrightarrow> False", "assume \"subst_lit l \\<sigma> \\<notin> ?D\""], ["proof (state)\nthis:\n  subst_lit l \\<sigma> \\<notin> cl_ecl D\n\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<notin> cl_ecl D \\<Longrightarrow> False", "from this and \\<open>(?D =  (subst_cl ( (?C - { L2 }) \\<union> { L' } )) \\<sigma>)\\<close> and \\<open>l \\<in> ?C\\<close>"], ["proof (chain)\npicking this:\n  subst_lit l \\<sigma> \\<notin> cl_ecl D\n  cl_ecl D = subst_cl (cl_ecl C - {L2} \\<union> {L'}) \\<sigma>\n  l \\<in> cl_ecl C", "have \"l = L2\""], ["proof (prove)\nusing this:\n  subst_lit l \\<sigma> \\<notin> cl_ecl D\n  cl_ecl D = subst_cl (cl_ecl C - {L2} \\<union> {L'}) \\<sigma>\n  l \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. l = L2", "by auto"], ["proof (state)\nthis:\n  l = L2\n\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<notin> cl_ecl D \\<Longrightarrow> False", "from \\<open>ck_unifier t u \\<sigma>  k\\<close>"], ["proof (chain)\npicking this:\n  ck_unifier t u \\<sigma> k", "have \"subst t \\<sigma> = subst u \\<sigma>\""], ["proof (prove)\nusing this:\n  ck_unifier t u \\<sigma> k\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>", "using ck_unifier_thm"], ["proof (prove)\nusing this:\n  ck_unifier t u \\<sigma> k\n  ck_unifier ?t ?s ?\\<sigma> ?k \\<Longrightarrow>\n  ?t \\<lhd> ?\\<sigma> = ?s \\<lhd> ?\\<sigma>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<notin> cl_ecl D \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>", "have \"subst (subst (subst t \\<sigma>) \\<theta>) \\<eta> =\n      subst (subst (subst u \\<sigma>) \\<theta>) \\<eta>\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta> =\n    u \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta> =\n  u \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<notin> cl_ecl D \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta> =\n  u \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta>", "have \"(subst t ?\\<sigma>') = subst u ?\\<sigma>'\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta> =\n  u \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta> =\n    u \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>", "by auto"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta> =\n  u \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<notin> cl_ecl D \\<Longrightarrow> False", "from \\<open>validate_ground_lit I l'\\<close> and \\<open>l' = (subst_lit l ?\\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  validate_ground_lit I l'\n  l' = subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "have \n      \"validate_ground_lit I (subst_lit l ?\\<sigma>')\""], ["proof (prove)\nusing this:\n  validate_ground_lit I l'\n  l' = subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. validate_ground_lit I\n     (subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))", "by auto"], ["proof (state)\nthis:\n  validate_ground_lit I\n   (subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))\n\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<notin> cl_ecl D \\<Longrightarrow> False", "from this and \\<open>fo_interpretation I\\<close> and \\<open>l = L2\\<close> and \\<open>orient_lit_inst L2 u v pos \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  validate_ground_lit I\n   (subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))\n  fo_interpretation I\n  l = L2\n  orient_lit_inst L2 u v pos \\<sigma>", "have \"I (subst u ?\\<sigma>') (subst v ?\\<sigma>')\""], ["proof (prove)\nusing this:\n  validate_ground_lit I\n   (subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))\n  fo_interpretation I\n  l = L2\n  orient_lit_inst L2 u v pos \\<sigma>\n\ngoal (1 subgoal):\n 1. I (u \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n     (v \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "using orient_lit_semantics_pos"], ["proof (prove)\nusing this:\n  validate_ground_lit I\n   (subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))\n  fo_interpretation I\n  l = L2\n  orient_lit_inst L2 u v pos \\<sigma>\n  \\<lbrakk>fo_interpretation ?I; orient_lit_inst ?l ?u ?v pos ?\\<eta>;\n   validate_ground_lit ?I (subst_lit ?l ?\\<sigma>)\\<rbrakk>\n  \\<Longrightarrow> ?I (?u \\<lhd> ?\\<sigma>) (?v \\<lhd> ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. I (u \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n     (v \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "by blast"], ["proof (state)\nthis:\n  I (u \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (v \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<notin> cl_ecl D \\<Longrightarrow> False", "from this and \\<open>fo_interpretation I\\<close> and \\<open>I (subst s ?\\<sigma>') (subst v ?\\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  I (u \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (v \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  fo_interpretation I\n  I (s \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (v \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "have \"I (subst u ?\\<sigma>') (subst s ?\\<sigma>')\""], ["proof (prove)\nusing this:\n  I (u \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (v \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  fo_interpretation I\n  I (s \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (v \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. I (u \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n     (s \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "unfolding fo_interpretation_def congruence_def equivalence_relation_def \n        symmetric_def transitive_def"], ["proof (prove)\nusing this:\n  I (u \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (v \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  (reflexive I \\<and>\n   (\\<forall>y z. I y z = I z y) \\<and>\n   (\\<forall>y z u.\n       I y z \\<longrightarrow> I z u \\<longrightarrow> I y u)) \\<and>\n  compatible_with_structure I\n  I (s \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (v \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. I (u \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n     (s \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "by blast"], ["proof (state)\nthis:\n  I (u \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (s \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<notin> cl_ecl D \\<Longrightarrow> False", "from this and \\<open>(subst t ?\\<sigma>') = subst u ?\\<sigma>'\\<close>"], ["proof (chain)\npicking this:\n  I (u \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (s \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta> =\n  u \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>", "have \"I (subst t ?\\<sigma>') (subst s ?\\<sigma>')\""], ["proof (prove)\nusing this:\n  I (u \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (s \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta> =\n  u \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. I (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n     (s \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  I (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (s \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<notin> cl_ecl D \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  I (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (s \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "have \"validate_ground_eq I (subst_equation (Eq t s) ?\\<sigma>')\""], ["proof (prove)\nusing this:\n  I (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (s \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. validate_ground_eq I\n     (subst_equation (Eq t s)\n       (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))", "by auto"], ["proof (state)\nthis:\n  validate_ground_eq I\n   (subst_equation (Eq t s)\n     (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))\n\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<notin> cl_ecl D \\<Longrightarrow> False", "from \\<open>I (subst t ?\\<sigma>') (subst s ?\\<sigma>')\\<close> and \\<open>fo_interpretation I\\<close>"], ["proof (chain)\npicking this:\n  I (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (s \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  fo_interpretation I", "have \"I (subst s ?\\<sigma>') (subst t ?\\<sigma>')\""], ["proof (prove)\nusing this:\n  I (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (s \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  fo_interpretation I\n\ngoal (1 subgoal):\n 1. I (s \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n     (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "unfolding fo_interpretation_def congruence_def equivalence_relation_def \n        symmetric_def"], ["proof (prove)\nusing this:\n  I (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (s \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  (reflexive I \\<and>\n   (\\<forall>y z. I y z = I z y) \\<and> transitive I) \\<and>\n  compatible_with_structure I\n\ngoal (1 subgoal):\n 1. I (s \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n     (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  I (s \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<notin> cl_ecl D \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  I (s \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "have \"validate_ground_eq I (subst_equation (Eq s t) ?\\<sigma>')\""], ["proof (prove)\nusing this:\n  I (s \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. validate_ground_eq I\n     (subst_equation (Eq s t)\n       (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))", "by auto"], ["proof (state)\nthis:\n  validate_ground_eq I\n   (subst_equation (Eq s t)\n     (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))\n\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<notin> cl_ecl D \\<Longrightarrow> False", "from \\<open>orient_lit_inst L1 t s pos \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L1 t s pos \\<sigma>", "have \"L1 = (Pos (Eq t s)) \\<or> L1 = (Pos (Eq s t))\""], ["proof (prove)\nusing this:\n  orient_lit_inst L1 t s pos \\<sigma>\n\ngoal (1 subgoal):\n 1. L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  (L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  pos = pos \\<or>\n  (L1 = Neg (Eq t s) \\<or> L1 = Neg (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and> pos = neg\n\ngoal (1 subgoal):\n 1. L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)", "by auto"], ["proof (state)\nthis:\n  L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)\n\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<notin> cl_ecl D \\<Longrightarrow> False", "from this and \\<open>validate_ground_eq I (subst_equation (Eq s t) ?\\<sigma>')\\<close> and \n      \\<open>validate_ground_eq I (subst_equation (Eq t s) ?\\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)\n  validate_ground_eq I\n   (subst_equation (Eq s t)\n     (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))\n  validate_ground_eq I\n   (subst_equation (Eq t s)\n     (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))", "have \"validate_ground_lit I (subst_lit L1 ?\\<sigma>')\""], ["proof (prove)\nusing this:\n  L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)\n  validate_ground_eq I\n   (subst_equation (Eq s t)\n     (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))\n  validate_ground_eq I\n   (subst_equation (Eq t s)\n     (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))\n\ngoal (1 subgoal):\n 1. validate_ground_lit I\n     (subst_lit L1 (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))", "by auto"], ["proof (state)\nthis:\n  validate_ground_lit I\n   (subst_lit L1 (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))\n\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<notin> cl_ecl D \\<Longrightarrow> False", "from \\<open>L1 \\<in> ?C\\<close> and \\<open>?D =  (subst_cl ( (?C - { L2 }) \\<union> { L' } )) \\<sigma>\\<close> and \\<open>L1 \\<noteq> L2\\<close>"], ["proof (chain)\npicking this:\n  L1 \\<in> cl_ecl C\n  cl_ecl D = subst_cl (cl_ecl C - {L2} \\<union> {L'}) \\<sigma>\n  L1 \\<noteq> L2", "have \"(subst_lit L1 \\<sigma>) \\<in> ?D\""], ["proof (prove)\nusing this:\n  L1 \\<in> cl_ecl C\n  cl_ecl D = subst_cl (cl_ecl C - {L2} \\<union> {L'}) \\<sigma>\n  L1 \\<noteq> L2\n\ngoal (1 subgoal):\n 1. subst_lit L1 \\<sigma> \\<in> cl_ecl D", "by auto"], ["proof (state)\nthis:\n  subst_lit L1 \\<sigma> \\<in> cl_ecl D\n\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<notin> cl_ecl D \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  subst_lit L1 \\<sigma> \\<in> cl_ecl D", "have \n      \"(subst_lit (subst_lit (subst_lit L1 \\<sigma>) \\<theta>) \\<eta>) \n        \\<in> (subst_cl (subst_cl ?D \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  subst_lit L1 \\<sigma> \\<in> cl_ecl D\n\ngoal (1 subgoal):\n 1. subst_lit (subst_lit (subst_lit L1 \\<sigma>) \\<theta>) \\<eta>\n    \\<in> subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>", "by auto"], ["proof (state)\nthis:\n  subst_lit (subst_lit (subst_lit L1 \\<sigma>) \\<theta>) \\<eta>\n  \\<in> subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>\n\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<notin> cl_ecl D \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  subst_lit (subst_lit (subst_lit L1 \\<sigma>) \\<theta>) \\<eta>\n  \\<in> subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>", "have \"(subst_lit L1 ?\\<sigma>') \\<in> (subst_cl (subst_cl ?D \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  subst_lit (subst_lit (subst_lit L1 \\<sigma>) \\<theta>) \\<eta>\n  \\<in> subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>\n\ngoal (1 subgoal):\n 1. subst_lit L1 (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n    \\<in> subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>", "using composition_of_substs_lit"], ["proof (prove)\nusing this:\n  subst_lit (subst_lit (subst_lit L1 \\<sigma>) \\<theta>) \\<eta>\n  \\<in> subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>\n  subst_lit (subst_lit ?l ?\\<sigma>) ?\\<eta> =\n  subst_lit ?l (?\\<sigma> \\<lozenge> ?\\<eta>)\n\ngoal (1 subgoal):\n 1. subst_lit L1 (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n    \\<in> subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>", "by metis"], ["proof (state)\nthis:\n  subst_lit L1 (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  \\<in> subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>\n\ngoal (1 subgoal):\n 1. subst_lit l \\<sigma> \\<notin> cl_ecl D \\<Longrightarrow> False", "from this and \\<open>validate_ground_lit I (subst_lit L1 ?\\<sigma>')\\<close> and \n      \\<open>\\<not> validate_ground_clause I (subst_cl (subst_cl ?D \\<theta>) \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  subst_lit L1 (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  \\<in> subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>\n  validate_ground_lit I\n   (subst_lit L1 (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))\n  \\<not> validate_ground_clause I\n          (subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>)", "show False"], ["proof (prove)\nusing this:\n  subst_lit L1 (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  \\<in> subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>\n  validate_ground_lit I\n   (subst_lit L1 (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))\n  \\<not> validate_ground_clause I\n          (subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst_lit l \\<sigma> \\<in> cl_ecl D\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "from \\<open>subst_lit l \\<sigma> \\<in> ?D\\<close> and \\<open>l' = subst_lit l ?\\<sigma>'\\<close>"], ["proof (chain)\npicking this:\n  subst_lit l \\<sigma> \\<in> cl_ecl D\n  l' = subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "have \"l' \\<in> (subst_cl (subst_cl ?D \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  subst_lit l \\<sigma> \\<in> cl_ecl D\n  l' = subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. l' \\<in> subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>", "using subst_cl.simps composition_of_substs_lit mem_Collect_eq"], ["proof (prove)\nusing this:\n  subst_lit l \\<sigma> \\<in> cl_ecl D\n  l' = subst_lit l (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  subst_cl ?C ?s = {L. \\<exists>L'. L' \\<in> ?C \\<and> L = subst_lit L' ?s}\n  subst_lit (subst_lit ?l ?\\<sigma>) ?\\<eta> =\n  subst_lit ?l (?\\<sigma> \\<lozenge> ?\\<eta>)\n  (?a \\<in> Collect ?P) = ?P ?a\n\ngoal (1 subgoal):\n 1. l' \\<in> subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>", "by (metis (mono_tags, lifting))"], ["proof (state)\nthis:\n  l' \\<in> subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "from this and \\<open>validate_ground_lit I l'\\<close>"], ["proof (chain)\npicking this:\n  l' \\<in> subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>\n  validate_ground_lit I l'", "have \n    \"validate_ground_clause I (subst_cl (subst_cl ?D \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  l' \\<in> subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>\n  validate_ground_lit I l'\n\ngoal (1 subgoal):\n 1. validate_ground_clause I\n     (subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>)", "by auto"], ["proof (state)\nthis:\n  validate_ground_clause I (subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause\n            (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n            (subst_cl (cl_ecl D) \\<theta>) \\<Longrightarrow>\n    False", "from this and \\<open>\\<not> validate_ground_clause I (subst_cl (subst_cl ?D \\<theta>) \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  validate_ground_clause I (subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>)\n  \\<not> validate_ground_clause I\n          (subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>)", "show False"], ["proof (prove)\nusing this:\n  validate_ground_clause I (subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>)\n  \\<not> validate_ground_clause I\n          (subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma factorization_is_sound :\n  assumes \"finite (cl_ecl C)\"\n  assumes \"factorization C D \\<sigma> k C'\"\n  shows \"clause_entails_clause (cl_ecl C) (cl_ecl D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clause_entails_clause (cl_ecl C) (cl_ecl D)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause (cl_ecl C) (cl_ecl D) \\<Longrightarrow>\n    False", "let ?C = \"(cl_ecl C)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause (cl_ecl C) (cl_ecl D) \\<Longrightarrow>\n    False", "let ?D = \"(cl_ecl D)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause (cl_ecl C) (cl_ecl D) \\<Longrightarrow>\n    False", "assume \"\\<not> (clause_entails_clause ?C ?D)\""], ["proof (state)\nthis:\n  \\<not> clause_entails_clause (cl_ecl C) (cl_ecl D)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause (cl_ecl C) (cl_ecl D) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> clause_entails_clause (cl_ecl C) (cl_ecl D)", "obtain I where \"validate_clause I ?C\" and \"\\<not> (validate_clause I ?D)\" \"fo_interpretation I\""], ["proof (prove)\nusing this:\n  \\<not> clause_entails_clause (cl_ecl C) (cl_ecl D)\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        \\<lbrakk>validate_clause I (cl_ecl C);\n         \\<not> validate_clause I (cl_ecl D); fo_interpretation I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding clause_entails_clause_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>I.\n             fo_interpretation I \\<longrightarrow>\n             validate_clause I (cl_ecl C) \\<longrightarrow>\n             validate_clause I (cl_ecl D))\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        \\<lbrakk>validate_clause I (cl_ecl C);\n         \\<not> validate_clause I (cl_ecl D); fo_interpretation I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  validate_clause I (cl_ecl C)\n  \\<not> validate_clause I (cl_ecl D)\n  fo_interpretation I\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause (cl_ecl C) (cl_ecl D) \\<Longrightarrow>\n    False", "from \\<open>\\<not> (validate_clause I ?D)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> validate_clause I (cl_ecl D)", "obtain \\<theta> \n    where D_false: \"\\<not> (validate_ground_clause I (subst_cl ?D \\<theta>))\" \n      and \"(ground_clause (subst_cl ?D \\<theta>))\""], ["proof (prove)\nusing this:\n  \\<not> validate_clause I (cl_ecl D)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<theta>.\n        \\<lbrakk>\\<not> validate_ground_clause I\n                         (subst_cl (cl_ecl D) \\<theta>);\n         ground_clause (subst_cl (cl_ecl D) \\<theta>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<not> validate_ground_clause I (subst_cl (cl_ecl D) \\<theta>)\n  ground_clause (subst_cl (cl_ecl D) \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause (cl_ecl C) (cl_ecl D) \\<Longrightarrow>\n    False", "have  \"validate_clause I (subst_cl (subst_cl ?C \\<sigma>) \\<theta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. validate_clause I (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)", "using \\<open>validate_clause I (cl_ecl C)\\<close> instances_are_entailed"], ["proof (prove)\nusing this:\n  validate_clause I (cl_ecl C)\n  validate_clause ?I ?C \\<Longrightarrow>\n  validate_clause ?I (subst_cl ?C ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. validate_clause I (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)", "by blast"], ["proof (state)\nthis:\n  validate_clause I (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause (cl_ecl C) (cl_ecl D) \\<Longrightarrow>\n    False", "from this and assms(1) and assms(2)"], ["proof (chain)\npicking this:\n  validate_clause I (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n  finite (cl_ecl C)\n  factorization C D \\<sigma> k C'", "have \"validate_clause I (subst_cl ?D \\<theta>)\""], ["proof (prove)\nusing this:\n  validate_clause I (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n  finite (cl_ecl C)\n  factorization C D \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. validate_clause I (subst_cl (cl_ecl D) \\<theta>)", "using ground_factorization_is_sound"], ["proof (prove)\nusing this:\n  validate_clause I (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n  finite (cl_ecl C)\n  factorization C D \\<sigma> k C'\n  \\<lbrakk>finite (cl_ecl ?C); factorization ?C ?D ?\\<sigma> ?k ?C';\n   ground_clause (subst_cl (cl_ecl ?D) ?\\<theta>)\\<rbrakk>\n  \\<Longrightarrow> clause_entails_clause\n                     (subst_cl (subst_cl (cl_ecl ?C) ?\\<sigma>) ?\\<theta>)\n                     (subst_cl (cl_ecl ?D) ?\\<theta>)\n\ngoal (1 subgoal):\n 1. validate_clause I (subst_cl (cl_ecl D) \\<theta>)", "unfolding clause_entails_clause_def"], ["proof (prove)\nusing this:\n  validate_clause I (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n  finite (cl_ecl C)\n  factorization C D \\<sigma> k C'\n  \\<lbrakk>finite (cl_ecl ?C); factorization ?C ?D ?\\<sigma> ?k ?C';\n   ground_clause (subst_cl (cl_ecl ?D) ?\\<theta>)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>I.\n                       fo_interpretation I \\<longrightarrow>\n                       validate_clause I\n                        (subst_cl (subst_cl (cl_ecl ?C) ?\\<sigma>)\n                          ?\\<theta>) \\<longrightarrow>\n                       validate_clause I (subst_cl (cl_ecl ?D) ?\\<theta>)\n\ngoal (1 subgoal):\n 1. validate_clause I (subst_cl (cl_ecl D) \\<theta>)", "using \\<open>fo_interpretation I\\<close> \\<open>ground_clause (subst_cl (cl_ecl D) \\<theta>)\\<close>"], ["proof (prove)\nusing this:\n  validate_clause I (subst_cl (subst_cl (cl_ecl C) \\<sigma>) \\<theta>)\n  finite (cl_ecl C)\n  factorization C D \\<sigma> k C'\n  \\<lbrakk>finite (cl_ecl ?C); factorization ?C ?D ?\\<sigma> ?k ?C';\n   ground_clause (subst_cl (cl_ecl ?D) ?\\<theta>)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>I.\n                       fo_interpretation I \\<longrightarrow>\n                       validate_clause I\n                        (subst_cl (subst_cl (cl_ecl ?C) ?\\<sigma>)\n                          ?\\<theta>) \\<longrightarrow>\n                       validate_clause I (subst_cl (cl_ecl ?D) ?\\<theta>)\n  fo_interpretation I\n  ground_clause (subst_cl (cl_ecl D) \\<theta>)\n\ngoal (1 subgoal):\n 1. validate_clause I (subst_cl (cl_ecl D) \\<theta>)", "by blast"], ["proof (state)\nthis:\n  validate_clause I (subst_cl (cl_ecl D) \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_entails_clause (cl_ecl C) (cl_ecl D) \\<Longrightarrow>\n    False", "from this and D_false"], ["proof (chain)\npicking this:\n  validate_clause I (subst_cl (cl_ecl D) \\<theta>)\n  \\<not> validate_ground_clause I (subst_cl (cl_ecl D) \\<theta>)", "show False"], ["proof (prove)\nusing this:\n  validate_clause I (subst_cl (cl_ecl D) \\<theta>)\n  \\<not> validate_ground_clause I (subst_cl (cl_ecl D) \\<theta>)\n\ngoal (1 subgoal):\n 1. False", "by (metis \\<open>ground_clause (subst_cl (cl_ecl D) \\<theta>)\\<close> \n    substs_preserve_ground_clause validate_clause.elims(1))"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ground_superposition_is_sound :\n  assumes \"finite (cl_ecl P1)\"\n  assumes \"finite (cl_ecl P2)\"\n  assumes \"superposition P1 P2 C \\<sigma> k C'\"\n  assumes \"(ground_clause (subst_cl (cl_ecl C) \\<theta>))\"\n  shows \"set_entails_clause \n    { (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>), \n      (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) }\n          (subst_cl (cl_ecl C) \\<theta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_entails_clause\n     {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n      subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n     (subst_cl (cl_ecl C) \\<theta>)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "let ?P1 = \"(cl_ecl P1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "let ?P2 = \"(cl_ecl P2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "let ?C = \"(cl_ecl C)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "assume \"\\<not> set_entails_clause \n    { (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>), \n      (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) }\n          (subst_cl (cl_ecl C) \\<theta>)\""], ["proof (state)\nthis:\n  \\<not> set_entails_clause\n          {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n           subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n          (subst_cl (cl_ecl C) \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> set_entails_clause\n          {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n           subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n          (subst_cl (cl_ecl C) \\<theta>)", "obtain I \n    where \"validate_clause I (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>)\" \n    and \"validate_clause I (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>)\" \n      and \"\\<not> (validate_clause I (subst_cl (cl_ecl C) \\<theta>))\" and \"fo_interpretation I\""], ["proof (prove)\nusing this:\n  \\<not> set_entails_clause\n          {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n           subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n          (subst_cl (cl_ecl C) \\<theta>)\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        \\<lbrakk>validate_clause I\n                  (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>);\n         validate_clause I\n          (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>);\n         \\<not> validate_clause I (subst_cl (cl_ecl C) \\<theta>);\n         fo_interpretation I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_entails_clause_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>I.\n             fo_interpretation I \\<longrightarrow>\n             validate_clause_set I\n              {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n               subst_cl (subst_cl (cl_ecl P2) \\<sigma>)\n                \\<theta>} \\<longrightarrow>\n             validate_clause I (subst_cl (cl_ecl C) \\<theta>))\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        \\<lbrakk>validate_clause I\n                  (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>);\n         validate_clause I\n          (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>);\n         \\<not> validate_clause I (subst_cl (cl_ecl C) \\<theta>);\n         fo_interpretation I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson insert_iff validate_clause_set.elims(2))"], ["proof (state)\nthis:\n  validate_clause I (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>)\n  validate_clause I (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>)\n  \\<not> validate_clause I (subst_cl (cl_ecl C) \\<theta>)\n  fo_interpretation I\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "from assms(3)"], ["proof (chain)\npicking this:\n  superposition P1 P2 C \\<sigma> k C'", "obtain t s u v M p polarity t' u' L L'   where\n    \"orient_lit_inst M u v pos \\<sigma>\" \n    and \"orient_lit_inst L t s polarity \\<sigma>\"\n    and \"subterm t p u'\"\n    and \"ck_unifier u' u \\<sigma> k\"\n    and \"replace_subterm t p v t'\"\n    and \"L' = mk_lit polarity (Eq t' s)\"\n    and \"?C = (subst_cl ((?P1 - { L }) \\<union> ((?P2 - { M }) \\<union> { L' } )) \\<sigma>)\""], ["proof (prove)\nusing this:\n  superposition P1 P2 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. (\\<And>M u v L t s polarity p u' t' L'.\n        \\<lbrakk>orient_lit_inst M u v pos \\<sigma>;\n         orient_lit_inst L t s polarity \\<sigma>; subterm t p u';\n         ck_unifier u' u \\<sigma> k; replace_subterm t p v t';\n         L' = mk_lit polarity (Eq t' s);\n         cl_ecl C =\n         subst_cl (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))\n          \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using superposition_def"], ["proof (prove)\nusing this:\n  superposition P1 P2 C \\<sigma> k C'\n  superposition ?P1.0 ?P2.0 ?C ?\\<sigma> ?k ?C' =\n  (\\<exists>L t s u v M p Cl_P1 Cl_P2 Cl_C polarity t' u' L' trms_C.\n      L \\<in> Cl_P1 \\<and>\n      M \\<in> Cl_P2 \\<and>\n      eligible_literal L ?P1.0 ?\\<sigma> \\<and>\n      eligible_literal M ?P2.0 ?\\<sigma> \\<and>\n      variable_disjoint ?P1.0 ?P2.0 \\<and>\n      Cl_P1 = cl_ecl ?P1.0 \\<and>\n      Cl_P2 = cl_ecl ?P2.0 \\<and>\n      \\<not> is_a_variable u' \\<and>\n      allowed_redex u' ?P1.0 ?\\<sigma> \\<and>\n      trms_C =\n      get_trms Cl_C\n       (dom_trms Cl_C\n         (subst_set\n           (trms_ecl ?P1.0 \\<union> trms_ecl ?P2.0 \\<union>\n            {r. \\<exists>q.\n                   (q, p) \\<in> pos_ord ?P1.0 t \\<and> subterm t q r})\n           ?\\<sigma>))\n       ?k \\<and>\n      ?C = Ecl Cl_C trms_C \\<and>\n      orient_lit_inst M u v pos ?\\<sigma> \\<and>\n      orient_lit_inst L t s polarity ?\\<sigma> \\<and>\n      u \\<lhd> ?\\<sigma> \\<noteq> v \\<lhd> ?\\<sigma> \\<and>\n      subterm t p u' \\<and>\n      ck_unifier u' u ?\\<sigma> ?k \\<and>\n      replace_subterm t p v t' \\<and>\n      (?k = FirstOrder \\<or>\n       (subst_lit M ?\\<sigma>, subst_lit L ?\\<sigma>) \\<in> lit_ord) \\<and>\n      (?k = FirstOrder \\<or>\n       strictly_maximal_literal ?P2.0 M ?\\<sigma>) \\<and>\n      L' = mk_lit polarity (Eq t' s) \\<and>\n      Cl_C = subst_cl ?C' ?\\<sigma> \\<and>\n      ?C' = Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'}))\n\ngoal (1 subgoal):\n 1. (\\<And>M u v L t s polarity p u' t' L'.\n        \\<lbrakk>orient_lit_inst M u v pos \\<sigma>;\n         orient_lit_inst L t s polarity \\<sigma>; subterm t p u';\n         ck_unifier u' u \\<sigma> k; replace_subterm t p v t';\n         L' = mk_lit polarity (Eq t' s);\n         cl_ecl C =\n         subst_cl (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))\n          \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  orient_lit_inst M u v pos \\<sigma>\n  orient_lit_inst L t s polarity \\<sigma>\n  subterm t p u'\n  ck_unifier u' u \\<sigma> k\n  replace_subterm t p v t'\n  L' = mk_lit polarity (Eq t' s)\n  cl_ecl C =\n  subst_cl (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "let ?P1' = \"(subst_cl (subst_cl ?P1 \\<sigma>) \\<theta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "let ?P2' = \"(subst_cl (subst_cl ?P2 \\<sigma>) \\<theta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "from assms(1)"], ["proof (chain)\npicking this:\n  finite (cl_ecl P1)", "have \"finite ?P1'\""], ["proof (prove)\nusing this:\n  finite (cl_ecl P1)\n\ngoal (1 subgoal):\n 1. finite (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>)", "by simp"], ["proof (state)\nthis:\n  finite (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "from assms(2)"], ["proof (chain)\npicking this:\n  finite (cl_ecl P2)", "have \"finite ?P2'\""], ["proof (prove)\nusing this:\n  finite (cl_ecl P2)\n\ngoal (1 subgoal):\n 1. finite (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>)", "by simp"], ["proof (state)\nthis:\n  finite (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "let ?vars = \"(vars_of_cl ?P1') \\<union> (vars_of_cl ?P2')\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "from \\<open>finite ?P1'\\<close>"], ["proof (chain)\npicking this:\n  finite (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>)", "have \"finite (vars_of_cl ?P1')\""], ["proof (prove)\nusing this:\n  finite (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>)\n\ngoal (1 subgoal):\n 1. finite (vars_of_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>))", "using set_of_variables_is_finite_cl [of ?P1']"], ["proof (prove)\nusing this:\n  finite (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>)\n  finite\n   (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<Longrightarrow>\n  finite (vars_of_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>))\n\ngoal (1 subgoal):\n 1. finite (vars_of_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>))", "by auto"], ["proof (state)\nthis:\n  finite (vars_of_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>))\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "from \\<open>finite ?P2'\\<close>"], ["proof (chain)\npicking this:\n  finite (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>)", "have \"finite (vars_of_cl ?P2')\""], ["proof (prove)\nusing this:\n  finite (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>)\n\ngoal (1 subgoal):\n 1. finite (vars_of_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>))", "using set_of_variables_is_finite_cl [of ?P2']"], ["proof (prove)\nusing this:\n  finite (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>)\n  finite\n   (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<Longrightarrow>\n  finite (vars_of_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>))\n\ngoal (1 subgoal):\n 1. finite (vars_of_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>))", "by auto"], ["proof (state)\nthis:\n  finite (vars_of_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>))\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "from \\<open>finite (vars_of_cl ?P1')\\<close> and \\<open>finite (vars_of_cl ?P2')\\<close>"], ["proof (chain)\npicking this:\n  finite (vars_of_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>))\n  finite (vars_of_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>))", "have \"finite ?vars\""], ["proof (prove)\nusing this:\n  finite (vars_of_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>))\n  finite (vars_of_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>))\n\ngoal (1 subgoal):\n 1. finite\n     (vars_of_cl\n       (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<union>\n      vars_of_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>))", "by auto"], ["proof (state)\nthis:\n  finite\n   (vars_of_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<union>\n    vars_of_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>))\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  finite\n   (vars_of_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<union>\n    vars_of_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>))", "obtain \\<eta> where \"ground_on ?vars \\<eta>\""], ["proof (prove)\nusing this:\n  finite\n   (vars_of_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<union>\n    vars_of_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>.\n        ground_on\n         (vars_of_cl\n           (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<union>\n          vars_of_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>))\n         \\<eta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ground_subst_exists"], ["proof (prove)\nusing this:\n  finite\n   (vars_of_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<union>\n    vars_of_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>))\n  finite ?V \\<Longrightarrow> \\<exists>\\<sigma>. ground_on ?V \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>.\n        ground_on\n         (vars_of_cl\n           (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<union>\n          vars_of_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>))\n         \\<eta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ground_on\n   (vars_of_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<union>\n    vars_of_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>))\n   \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  ground_on\n   (vars_of_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<union>\n    vars_of_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>))\n   \\<eta>", "have \"ground_on (vars_of_cl ?P1') \\<eta>\""], ["proof (prove)\nusing this:\n  ground_on\n   (vars_of_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<union>\n    vars_of_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>))\n   \\<eta>\n\ngoal (1 subgoal):\n 1. ground_on\n     (vars_of_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>)) \\<eta>", "unfolding ground_on_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>vars_of_cl\n                  (subst_cl (subst_cl (cl_ecl P1) \\<sigma>)\n                    \\<theta>) \\<union>\n                 vars_of_cl\n                  (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>).\n     ground_term (Var x \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of_cl\n                    (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>).\n       ground_term (Var x \\<lhd> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  ground_on (vars_of_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>))\n   \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  ground_on (vars_of_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>))\n   \\<eta>", "have \"ground_clause (subst_cl \n        (subst_cl (subst_cl ?P1 \\<sigma>) \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  ground_on (vars_of_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>))\n   \\<eta>\n\ngoal (1 subgoal):\n 1. ground_clause\n     (subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta>)", "using ground_substs_yield_ground_clause\n        [of \"(subst_cl (subst_cl ?P1 \\<sigma>) \\<theta>)\" \\<eta>]"], ["proof (prove)\nusing this:\n  ground_on (vars_of_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>))\n   \\<eta>\n  ground_on (vars_of_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>))\n   \\<eta> \\<Longrightarrow>\n  ground_clause\n   (subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. ground_clause\n     (subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta>)", "by auto"], ["proof (state)\nthis:\n  ground_clause\n   (subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "from \\<open>ground_on ?vars \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  ground_on\n   (vars_of_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<union>\n    vars_of_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>))\n   \\<eta>", "have \"ground_on (vars_of_cl ?P2') \\<eta>\""], ["proof (prove)\nusing this:\n  ground_on\n   (vars_of_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<union>\n    vars_of_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>))\n   \\<eta>\n\ngoal (1 subgoal):\n 1. ground_on\n     (vars_of_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>)) \\<eta>", "unfolding ground_on_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>vars_of_cl\n                  (subst_cl (subst_cl (cl_ecl P1) \\<sigma>)\n                    \\<theta>) \\<union>\n                 vars_of_cl\n                  (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>).\n     ground_term (Var x \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of_cl\n                    (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>).\n       ground_term (Var x \\<lhd> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  ground_on (vars_of_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>))\n   \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  ground_on (vars_of_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>))\n   \\<eta>", "have \"ground_clause (subst_cl \n        (subst_cl (subst_cl ?P2 \\<sigma>) \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  ground_on (vars_of_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>))\n   \\<eta>\n\ngoal (1 subgoal):\n 1. ground_clause\n     (subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta>)", "using ground_substs_yield_ground_clause \n        [of \"(subst_cl (subst_cl ?P2 \\<sigma>) \\<theta>)\" \\<eta>]"], ["proof (prove)\nusing this:\n  ground_on (vars_of_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>))\n   \\<eta>\n  ground_on (vars_of_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>))\n   \\<eta> \\<Longrightarrow>\n  ground_clause\n   (subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. ground_clause\n     (subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta>)", "by auto"], ["proof (state)\nthis:\n  ground_clause\n   (subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "let ?P1'' = \"(subst_cl ?P1' \\<eta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "let ?P2'' = \"(subst_cl ?P2' \\<eta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "let ?\\<sigma>'' = \"comp \\<sigma> \\<theta>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "let ?\\<sigma>' = \"comp ?\\<sigma>'' \\<eta>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "have \"?P1'' = (subst_cl (subst_cl ?P1 ?\\<sigma>'') \\<eta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta> =\n    subst_cl (subst_cl (cl_ecl P1) (\\<sigma> \\<lozenge> \\<theta>)) \\<eta>", "using composition_of_substs_cl [of ?P1]"], ["proof (prove)\nusing this:\n  subst_cl (subst_cl (cl_ecl P1) ?\\<sigma>) ?\\<eta> =\n  subst_cl (cl_ecl P1) (?\\<sigma> \\<lozenge> ?\\<eta>)\n\ngoal (1 subgoal):\n 1. subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta> =\n    subst_cl (subst_cl (cl_ecl P1) (\\<sigma> \\<lozenge> \\<theta>)) \\<eta>", "by auto"], ["proof (state)\nthis:\n  subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (subst_cl (cl_ecl P1) (\\<sigma> \\<lozenge> \\<theta>)) \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (subst_cl (cl_ecl P1) (\\<sigma> \\<lozenge> \\<theta>)) \\<eta>", "have \"?P1'' = (subst_cl ?P1 ?\\<sigma>')\""], ["proof (prove)\nusing this:\n  subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (subst_cl (cl_ecl P1) (\\<sigma> \\<lozenge> \\<theta>)) \\<eta>\n\ngoal (1 subgoal):\n 1. subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta> =\n    subst_cl (cl_ecl P1) (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "using composition_of_substs_cl [of ?P1]"], ["proof (prove)\nusing this:\n  subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (subst_cl (cl_ecl P1) (\\<sigma> \\<lozenge> \\<theta>)) \\<eta>\n  subst_cl (subst_cl (cl_ecl P1) ?\\<sigma>) ?\\<eta> =\n  subst_cl (cl_ecl P1) (?\\<sigma> \\<lozenge> ?\\<eta>)\n\ngoal (1 subgoal):\n 1. subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta> =\n    subst_cl (cl_ecl P1) (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (cl_ecl P1) (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "from \\<open>ground_clause (subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta>)\\<close>\n    and \\<open>validate_clause I (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>)\\<close>"], ["proof (chain)\npicking this:\n  ground_clause\n   (subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta>)\n  validate_clause I (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>)", "have \"validate_ground_clause I ?P1''\""], ["proof (prove)\nusing this:\n  ground_clause\n   (subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta>)\n  validate_clause I (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>)\n\ngoal (1 subgoal):\n 1. validate_ground_clause I\n     (subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta>)", "using  validate_clause.simps"], ["proof (prove)\nusing this:\n  ground_clause\n   (subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta>)\n  validate_clause I (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>)\n  validate_clause ?I ?C =\n  (\\<forall>s.\n      ground_clause (subst_cl ?C s) \\<longrightarrow>\n      validate_ground_clause ?I (subst_cl ?C s))\n\ngoal (1 subgoal):\n 1. validate_ground_clause I\n     (subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta>)", "by blast"], ["proof (state)\nthis:\n  validate_ground_clause I\n   (subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  validate_ground_clause I\n   (subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta>)", "obtain l1' where \"l1' \\<in> ?P1''\" and \"validate_ground_lit I l1'\""], ["proof (prove)\nusing this:\n  validate_ground_clause I\n   (subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. (\\<And>l1'.\n        \\<lbrakk>l1'\n                 \\<in> subst_cl\n                        (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>)\n                        \\<eta>;\n         validate_ground_lit I l1'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l1'\n  \\<in> subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta>\n  validate_ground_lit I l1'\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "have \"?P2'' = (subst_cl (subst_cl ?P2 ?\\<sigma>'') \\<eta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta> =\n    subst_cl (subst_cl (cl_ecl P2) (\\<sigma> \\<lozenge> \\<theta>)) \\<eta>", "using composition_of_substs_cl [of ?P2]"], ["proof (prove)\nusing this:\n  subst_cl (subst_cl (cl_ecl P2) ?\\<sigma>) ?\\<eta> =\n  subst_cl (cl_ecl P2) (?\\<sigma> \\<lozenge> ?\\<eta>)\n\ngoal (1 subgoal):\n 1. subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta> =\n    subst_cl (subst_cl (cl_ecl P2) (\\<sigma> \\<lozenge> \\<theta>)) \\<eta>", "by auto"], ["proof (state)\nthis:\n  subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (subst_cl (cl_ecl P2) (\\<sigma> \\<lozenge> \\<theta>)) \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (subst_cl (cl_ecl P2) (\\<sigma> \\<lozenge> \\<theta>)) \\<eta>", "have \"?P2'' = (subst_cl ?P2 ?\\<sigma>')\""], ["proof (prove)\nusing this:\n  subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (subst_cl (cl_ecl P2) (\\<sigma> \\<lozenge> \\<theta>)) \\<eta>\n\ngoal (1 subgoal):\n 1. subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta> =\n    subst_cl (cl_ecl P2) (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "using composition_of_substs_cl [of ?P2]"], ["proof (prove)\nusing this:\n  subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (subst_cl (cl_ecl P2) (\\<sigma> \\<lozenge> \\<theta>)) \\<eta>\n  subst_cl (subst_cl (cl_ecl P2) ?\\<sigma>) ?\\<eta> =\n  subst_cl (cl_ecl P2) (?\\<sigma> \\<lozenge> ?\\<eta>)\n\ngoal (1 subgoal):\n 1. subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta> =\n    subst_cl (cl_ecl P2) (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (cl_ecl P2) (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "from \\<open>ground_clause (subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta>)\\<close> \\<open>validate_clause I (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>)\\<close>"], ["proof (chain)\npicking this:\n  ground_clause\n   (subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta>)\n  validate_clause I (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>)", "have \"validate_ground_clause I ?P2''\""], ["proof (prove)\nusing this:\n  ground_clause\n   (subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta>)\n  validate_clause I (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>)\n\ngoal (1 subgoal):\n 1. validate_ground_clause I\n     (subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta>)", "using  validate_clause.simps"], ["proof (prove)\nusing this:\n  ground_clause\n   (subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta>)\n  validate_clause I (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>)\n  validate_clause ?I ?C =\n  (\\<forall>s.\n      ground_clause (subst_cl ?C s) \\<longrightarrow>\n      validate_ground_clause ?I (subst_cl ?C s))\n\ngoal (1 subgoal):\n 1. validate_ground_clause I\n     (subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta>)", "by blast"], ["proof (state)\nthis:\n  validate_ground_clause I\n   (subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  validate_ground_clause I\n   (subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta>)", "obtain l2' where \"l2' \\<in> ?P2''\" and \"validate_ground_lit I l2'\""], ["proof (prove)\nusing this:\n  validate_ground_clause I\n   (subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. (\\<And>l2'.\n        \\<lbrakk>l2'\n                 \\<in> subst_cl\n                        (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>)\n                        \\<eta>;\n         validate_ground_lit I l2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l2'\n  \\<in> subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta>\n  validate_ground_lit I l2'\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "from \\<open>l1' \\<in> ?P1''\\<close> and \\<open>?P1'' = (subst_cl ?P1 ?\\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  l1'\n  \\<in> subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta>\n  subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (cl_ecl P1) (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "obtain l1 where \n    \"l1 \\<in> ?P1\" and \"l1' = (subst_lit l1 ?\\<sigma>')\""], ["proof (prove)\nusing this:\n  l1'\n  \\<in> subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta>\n  subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (cl_ecl P1) (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. (\\<And>l1.\n        \\<lbrakk>l1 \\<in> cl_ecl P1;\n         l1' =\n         subst_lit l1\n          (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using subst_cl.simps"], ["proof (prove)\nusing this:\n  l1'\n  \\<in> subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta>\n  subst_cl (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (cl_ecl P1) (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  subst_cl ?C ?s = {L. \\<exists>L'. L' \\<in> ?C \\<and> L = subst_lit L' ?s}\n\ngoal (1 subgoal):\n 1. (\\<And>l1.\n        \\<lbrakk>l1 \\<in> cl_ecl P1;\n         l1' =\n         subst_lit l1\n          (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  l1 \\<in> cl_ecl P1\n  l1' = subst_lit l1 (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "from \\<open>l2' \\<in> ?P2''\\<close> and \\<open>?P2'' = (subst_cl ?P2 ?\\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  l2'\n  \\<in> subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta>\n  subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (cl_ecl P2) (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "obtain l2 where \n    \"l2 \\<in> ?P2\" and \"l2' = (subst_lit l2 ?\\<sigma>')\""], ["proof (prove)\nusing this:\n  l2'\n  \\<in> subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta>\n  subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (cl_ecl P2) (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. (\\<And>l2.\n        \\<lbrakk>l2 \\<in> cl_ecl P2;\n         l2' =\n         subst_lit l2\n          (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using subst_cl.simps"], ["proof (prove)\nusing this:\n  l2'\n  \\<in> subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta>\n  subst_cl (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) \\<eta> =\n  subst_cl (cl_ecl P2) (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  subst_cl ?C ?s = {L. \\<exists>L'. L' \\<in> ?C \\<and> L = subst_lit L' ?s}\n\ngoal (1 subgoal):\n 1. (\\<And>l2.\n        \\<lbrakk>l2 \\<in> cl_ecl P2;\n         l2' =\n         subst_lit l2\n          (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  l2 \\<in> cl_ecl P2\n  l2' = subst_lit l2 (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "let ?C' = \"(subst_cl (subst_cl ?C \\<theta>) \\<eta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "from \\<open>ground_clause (subst_cl ?C \\<theta>)\\<close>"], ["proof (chain)\npicking this:\n  ground_clause (subst_cl (cl_ecl C) \\<theta>)", "have\n    \"(subst_cl ?C \\<theta>) = (subst_cl (subst_cl ?C \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  ground_clause (subst_cl (cl_ecl C) \\<theta>)\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl C) \\<theta> =\n    subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>", "using substs_preserve_ground_clause [of \"(subst_cl ?C \\<theta>)\"  \\<eta>]"], ["proof (prove)\nusing this:\n  ground_clause (subst_cl (cl_ecl C) \\<theta>)\n  ground_clause (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n  subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta> =\n  subst_cl (cl_ecl C) \\<theta>\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl C) \\<theta> =\n    subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>", "by blast"], ["proof (state)\nthis:\n  subst_cl (cl_ecl C) \\<theta> =\n  subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "from \\<open>\\<not> validate_clause I (subst_cl (cl_ecl C) \\<theta>)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> validate_clause I (subst_cl (cl_ecl C) \\<theta>)", "have \"\\<not> validate_ground_clause I ?C'\""], ["proof (prove)\nusing this:\n  \\<not> validate_clause I (subst_cl (cl_ecl C) \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_clause I\n            (subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>)", "by (metis assms(4) substs_preserve_ground_clause validate_clause.simps)"], ["proof (state)\nthis:\n  \\<not> validate_ground_clause I\n          (subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "have \"l1 = L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l1 = L", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. l1 \\<noteq> L \\<Longrightarrow> False", "assume \"l1 \\<noteq> L\""], ["proof (state)\nthis:\n  l1 \\<noteq> L\n\ngoal (1 subgoal):\n 1. l1 \\<noteq> L \\<Longrightarrow> False", "from this and \\<open>l1 \\<in> ?P1\\<close> and \\<open>?C = (subst_cl ((?P1 - { L }) \\<union> ((?P2 - { M }) \\<union> { L' } )) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  l1 \\<noteq> L\n  l1 \\<in> cl_ecl P1\n  cl_ecl C =\n  subst_cl (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))\n   \\<sigma>", "have \"(subst_lit l1 \\<sigma>) \\<in> ?C\""], ["proof (prove)\nusing this:\n  l1 \\<noteq> L\n  l1 \\<in> cl_ecl P1\n  cl_ecl C =\n  subst_cl (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. subst_lit l1 \\<sigma> \\<in> cl_ecl C", "by auto"], ["proof (state)\nthis:\n  subst_lit l1 \\<sigma> \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. l1 \\<noteq> L \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  subst_lit l1 \\<sigma> \\<in> cl_ecl C", "have \"(subst_lit (subst_lit (subst_lit l1 \\<sigma>) \\<theta>) \\<eta>)\n      \\<in> ?C'\""], ["proof (prove)\nusing this:\n  subst_lit l1 \\<sigma> \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. subst_lit (subst_lit (subst_lit l1 \\<sigma>) \\<theta>) \\<eta>\n    \\<in> subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>", "by auto"], ["proof (state)\nthis:\n  subst_lit (subst_lit (subst_lit l1 \\<sigma>) \\<theta>) \\<eta>\n  \\<in> subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>\n\ngoal (1 subgoal):\n 1. l1 \\<noteq> L \\<Longrightarrow> False", "from this and \\<open>l1' = (subst_lit l1 ?\\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  subst_lit (subst_lit (subst_lit l1 \\<sigma>) \\<theta>) \\<eta>\n  \\<in> subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>\n  l1' = subst_lit l1 (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "have \"l1' \\<in> ?C'\""], ["proof (prove)\nusing this:\n  subst_lit (subst_lit (subst_lit l1 \\<sigma>) \\<theta>) \\<eta>\n  \\<in> subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>\n  l1' = subst_lit l1 (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. l1' \\<in> subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>", "by (simp add: composition_of_substs_lit)"], ["proof (state)\nthis:\n  l1' \\<in> subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>\n\ngoal (1 subgoal):\n 1. l1 \\<noteq> L \\<Longrightarrow> False", "from this and \\<open>validate_ground_lit I l1'\\<close>"], ["proof (chain)\npicking this:\n  l1' \\<in> subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>\n  validate_ground_lit I l1'", "have \"validate_ground_clause I ?C'\""], ["proof (prove)\nusing this:\n  l1' \\<in> subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>\n  validate_ground_lit I l1'\n\ngoal (1 subgoal):\n 1. validate_ground_clause I\n     (subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>)", "by auto"], ["proof (state)\nthis:\n  validate_ground_clause I (subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. l1 \\<noteq> L \\<Longrightarrow> False", "from this and \\<open>\\<not> validate_ground_clause I (subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  validate_ground_clause I (subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>)\n  \\<not> validate_ground_clause I\n          (subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>)", "show False"], ["proof (prove)\nusing this:\n  validate_ground_clause I (subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>)\n  \\<not> validate_ground_clause I\n          (subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l1 = L\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "have \"l2 = M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l2 = M", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. l2 \\<noteq> M \\<Longrightarrow> False", "assume \"l2 \\<noteq> M\""], ["proof (state)\nthis:\n  l2 \\<noteq> M\n\ngoal (1 subgoal):\n 1. l2 \\<noteq> M \\<Longrightarrow> False", "from this and \\<open>l2 \\<in> ?P2\\<close> and \\<open>?C = (subst_cl ((?P1 - { L }) \\<union> ((?P2 - { M }) \\<union> { L' } )) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  l2 \\<noteq> M\n  l2 \\<in> cl_ecl P2\n  cl_ecl C =\n  subst_cl (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))\n   \\<sigma>", "have \"(subst_lit l2 \\<sigma>) \\<in> ?C\""], ["proof (prove)\nusing this:\n  l2 \\<noteq> M\n  l2 \\<in> cl_ecl P2\n  cl_ecl C =\n  subst_cl (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. subst_lit l2 \\<sigma> \\<in> cl_ecl C", "by auto"], ["proof (state)\nthis:\n  subst_lit l2 \\<sigma> \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. l2 \\<noteq> M \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  subst_lit l2 \\<sigma> \\<in> cl_ecl C", "have \"(subst_lit (subst_lit (subst_lit l2 \\<sigma>) \\<theta>) \\<eta>)\n      \\<in> ?C'\""], ["proof (prove)\nusing this:\n  subst_lit l2 \\<sigma> \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. subst_lit (subst_lit (subst_lit l2 \\<sigma>) \\<theta>) \\<eta>\n    \\<in> subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>", "by auto"], ["proof (state)\nthis:\n  subst_lit (subst_lit (subst_lit l2 \\<sigma>) \\<theta>) \\<eta>\n  \\<in> subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>\n\ngoal (1 subgoal):\n 1. l2 \\<noteq> M \\<Longrightarrow> False", "from this and \\<open>l2' = (subst_lit l2 ?\\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  subst_lit (subst_lit (subst_lit l2 \\<sigma>) \\<theta>) \\<eta>\n  \\<in> subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>\n  l2' = subst_lit l2 (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "have \"l2' \\<in> ?C'\""], ["proof (prove)\nusing this:\n  subst_lit (subst_lit (subst_lit l2 \\<sigma>) \\<theta>) \\<eta>\n  \\<in> subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>\n  l2' = subst_lit l2 (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. l2' \\<in> subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>", "by (simp add: composition_of_substs_lit)"], ["proof (state)\nthis:\n  l2' \\<in> subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>\n\ngoal (1 subgoal):\n 1. l2 \\<noteq> M \\<Longrightarrow> False", "from this and \\<open>validate_ground_lit I l2'\\<close>"], ["proof (chain)\npicking this:\n  l2' \\<in> subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>\n  validate_ground_lit I l2'", "have \"validate_ground_clause I ?C'\""], ["proof (prove)\nusing this:\n  l2' \\<in> subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>\n  validate_ground_lit I l2'\n\ngoal (1 subgoal):\n 1. validate_ground_clause I\n     (subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>)", "by auto"], ["proof (state)\nthis:\n  validate_ground_clause I (subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. l2 \\<noteq> M \\<Longrightarrow> False", "from this and \\<open>\\<not> validate_ground_clause I (subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  validate_ground_clause I (subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>)\n  \\<not> validate_ground_clause I\n          (subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>)", "show False"], ["proof (prove)\nusing this:\n  validate_ground_clause I (subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>)\n  \\<not> validate_ground_clause I\n          (subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l2 = M\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "from \\<open>orient_lit_inst M u v pos \\<sigma>\\<close> and \\<open>l2 = M\\<close> and \\<open>fo_interpretation I\\<close> \n    and \\<open>validate_ground_lit I l2'\\<close> and \\<open>l2' = (subst_lit l2 ?\\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst M u v pos \\<sigma>\n  l2 = M\n  fo_interpretation I\n  validate_ground_lit I l2'\n  l2' = subst_lit l2 (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "have \"I (subst u ?\\<sigma>') (subst v ?\\<sigma>')\""], ["proof (prove)\nusing this:\n  orient_lit_inst M u v pos \\<sigma>\n  l2 = M\n  fo_interpretation I\n  validate_ground_lit I l2'\n  l2' = subst_lit l2 (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. I (u \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n     (v \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "using orient_lit_semantics_pos"], ["proof (prove)\nusing this:\n  orient_lit_inst M u v pos \\<sigma>\n  l2 = M\n  fo_interpretation I\n  validate_ground_lit I l2'\n  l2' = subst_lit l2 (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  \\<lbrakk>fo_interpretation ?I; orient_lit_inst ?l ?u ?v pos ?\\<eta>;\n   validate_ground_lit ?I (subst_lit ?l ?\\<sigma>)\\<rbrakk>\n  \\<Longrightarrow> ?I (?u \\<lhd> ?\\<sigma>) (?v \\<lhd> ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. I (u \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n     (v \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "by blast"], ["proof (state)\nthis:\n  I (u \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (v \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "from \\<open>subterm t p u'\\<close>"], ["proof (chain)\npicking this:\n  subterm t p u'", "have\n    \"subterm (subst t ?\\<sigma>') p (subst u' ?\\<sigma>')\""], ["proof (prove)\nusing this:\n  subterm t p u'\n\ngoal (1 subgoal):\n 1. subterm (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>) p\n     (u' \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "using substs_preserve_subterms [of t p u']"], ["proof (prove)\nusing this:\n  subterm t p u'\n  subterm t p u' \\<Longrightarrow>\n  subterm (t \\<lhd> ?\\<sigma>) p (u' \\<lhd> ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. subterm (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>) p\n     (u' \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "by metis"], ["proof (state)\nthis:\n  subterm (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>) p\n   (u' \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "from \\<open>ck_unifier u' u \\<sigma> k\\<close>"], ["proof (chain)\npicking this:\n  ck_unifier u' u \\<sigma> k", "have \"(subst u \\<sigma>) = (subst u' \\<sigma>)\""], ["proof (prove)\nusing this:\n  ck_unifier u' u \\<sigma> k\n\ngoal (1 subgoal):\n 1. u \\<lhd> \\<sigma> = u' \\<lhd> \\<sigma>", "using ck_unifier_thm [of u' u \\<sigma> k]"], ["proof (prove)\nusing this:\n  ck_unifier u' u \\<sigma> k\n  ck_unifier u' u \\<sigma> k \\<Longrightarrow>\n  u' \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. u \\<lhd> \\<sigma> = u' \\<lhd> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  u \\<lhd> \\<sigma> = u' \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  u \\<lhd> \\<sigma> = u' \\<lhd> \\<sigma>", "have \"(subst (subst (subst u \\<sigma>) \\<theta>) \\<eta>) \n    = (subst (subst (subst u' \\<sigma>) \\<theta> ) \\<eta>)\""], ["proof (prove)\nusing this:\n  u \\<lhd> \\<sigma> = u' \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. u \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta> =\n    u' \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  u \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta> =\n  u' \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  u \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta> =\n  u' \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta>", "have \"(subst u ?\\<sigma>') = (subst u' ?\\<sigma>')\""], ["proof (prove)\nusing this:\n  u \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta> =\n  u' \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. u \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta> =\n    u' \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>", "using composition_of_substs"], ["proof (prove)\nusing this:\n  u \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta> =\n  u' \\<lhd> \\<sigma> \\<lhd> \\<theta> \\<lhd> \\<eta>\n  ?t \\<lhd> ?\\<sigma> \\<lhd> ?\\<eta> =\n  ?t \\<lhd> ?\\<sigma> \\<lozenge> ?\\<eta>\n\ngoal (1 subgoal):\n 1. u \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta> =\n    u' \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>", "by auto"], ["proof (state)\nthis:\n  u \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta> =\n  u' \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "from \\<open>(subst u ?\\<sigma>') = (subst u' ?\\<sigma>')\\<close> \n    and \\<open>I (subst u ?\\<sigma>') (subst v ?\\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  u \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta> =\n  u' \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>\n  I (u \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (v \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "have \"I (subst u' ?\\<sigma>') (subst v ?\\<sigma>')\""], ["proof (prove)\nusing this:\n  u \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta> =\n  u' \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>\n  I (u \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (v \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. I (u' \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n     (v \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  I (u' \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (v \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "from \\<open>subterm t p u'\\<close> \n    and \\<open>I (subst u' ?\\<sigma>') (subst v ?\\<sigma>')\\<close> \n    and \\<open>fo_interpretation I\\<close>\n    and \\<open>replace_subterm t p v t'\\<close>"], ["proof (chain)\npicking this:\n  subterm t p u'\n  I (u' \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (v \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  fo_interpretation I\n  replace_subterm t p v t'", "have \"I (subst t ?\\<sigma>') (subst t' ?\\<sigma>')\""], ["proof (prove)\nusing this:\n  subterm t p u'\n  I (u' \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (v \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  fo_interpretation I\n  replace_subterm t p v t'\n\ngoal (1 subgoal):\n 1. I (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n     (t' \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "unfolding fo_interpretation_def"], ["proof (prove)\nusing this:\n  subterm t p u'\n  I (u' \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (v \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  congruence I\n  replace_subterm t p v t'\n\ngoal (1 subgoal):\n 1. I (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n     (t' \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "using replacement_preserves_congruences [of I u' ?\\<sigma>' v t p t']"], ["proof (prove)\nusing this:\n  subterm t p u'\n  I (u' \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (v \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  congruence I\n  replace_subterm t p v t'\n  \\<lbrakk>congruence I;\n   I (u' \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n    (v \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>);\n   subterm t p u'; replace_subterm t p v t'\\<rbrakk>\n  \\<Longrightarrow> I (t \\<lhd>\n                       \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n                     (t' \\<lhd>\n                      \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. I (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n     (t' \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  I (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (t' \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "from \\<open>l1 = L\\<close> and \\<open>fo_interpretation I\\<close> and \\<open>validate_ground_lit I l1'\\<close> \n    and \\<open>l1' = (subst_lit l1 ?\\<sigma>')\\<close> \n    and \\<open>orient_lit_inst L t s polarity \\<sigma>\\<close> \n    and \\<open>I (subst t ?\\<sigma>') (subst t' ?\\<sigma>')\\<close>\n    and \\<open>L' =  mk_lit polarity (Eq t' s)\\<close>"], ["proof (chain)\npicking this:\n  l1 = L\n  fo_interpretation I\n  validate_ground_lit I l1'\n  l1' = subst_lit l1 (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  orient_lit_inst L t s polarity \\<sigma>\n  I (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (t' \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  L' = mk_lit polarity (Eq t' s)", "have \"validate_ground_lit I (subst_lit L' ?\\<sigma>')\""], ["proof (prove)\nusing this:\n  l1 = L\n  fo_interpretation I\n  validate_ground_lit I l1'\n  l1' = subst_lit l1 (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  orient_lit_inst L t s polarity \\<sigma>\n  I (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (t' \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  L' = mk_lit polarity (Eq t' s)\n\ngoal (1 subgoal):\n 1. validate_ground_lit I\n     (subst_lit L' (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))", "using orient_lit_semantics_replacement [of I L t s polarity \\<sigma> ?\\<sigma>' t']"], ["proof (prove)\nusing this:\n  l1 = L\n  fo_interpretation I\n  validate_ground_lit I l1'\n  l1' = subst_lit l1 (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  orient_lit_inst L t s polarity \\<sigma>\n  I (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n   (t' \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  L' = mk_lit polarity (Eq t' s)\n  \\<lbrakk>fo_interpretation I; orient_lit_inst L t s polarity \\<sigma>;\n   validate_ground_lit I\n    (subst_lit L (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>));\n   I (t \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n    (t' \\<lhd> \\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\\<rbrakk>\n  \\<Longrightarrow> validate_ground_lit I\n                     (subst_lit (mk_lit polarity (Eq t' s))\n                       (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))\n\ngoal (1 subgoal):\n 1. validate_ground_lit I\n     (subst_lit L' (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))", "by blast"], ["proof (state)\nthis:\n  validate_ground_lit I\n   (subst_lit L' (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "from \\<open>?C = (subst_cl ((?P1 - { L }) \\<union> ((?P2 - { M }) \\<union> { L' } )) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  cl_ecl C =\n  subst_cl (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))\n   \\<sigma>", "have \"subst_lit L' \\<sigma> \\<in> ?C\""], ["proof (prove)\nusing this:\n  cl_ecl C =\n  subst_cl (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. subst_lit L' \\<sigma> \\<in> cl_ecl C", "by auto"], ["proof (state)\nthis:\n  subst_lit L' \\<sigma> \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  subst_lit L' \\<sigma> \\<in> cl_ecl C", "have \"subst_lit (subst_lit (subst_lit L' \\<sigma>) \\<theta>) \\<eta> \\<in> ?C'\""], ["proof (prove)\nusing this:\n  subst_lit L' \\<sigma> \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. subst_lit (subst_lit (subst_lit L' \\<sigma>) \\<theta>) \\<eta>\n    \\<in> subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>", "by auto"], ["proof (state)\nthis:\n  subst_lit (subst_lit (subst_lit L' \\<sigma>) \\<theta>) \\<eta>\n  \\<in> subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  subst_lit (subst_lit (subst_lit L' \\<sigma>) \\<theta>) \\<eta>\n  \\<in> subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>", "have \"subst_lit L' ?\\<sigma>' \\<in> ?C'\""], ["proof (prove)\nusing this:\n  subst_lit (subst_lit (subst_lit L' \\<sigma>) \\<theta>) \\<eta>\n  \\<in> subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>\n\ngoal (1 subgoal):\n 1. subst_lit L' (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n    \\<in> subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>", "by (simp add: composition_of_substs_lit)"], ["proof (state)\nthis:\n  subst_lit L' (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  \\<in> subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>) \\<Longrightarrow>\n    False", "from this and \\<open>validate_ground_lit I (subst_lit L' ?\\<sigma>')\\<close> and \\<open>\\<not>validate_ground_clause I ?C'\\<close>"], ["proof (chain)\npicking this:\n  subst_lit L' (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  \\<in> subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>\n  validate_ground_lit I\n   (subst_lit L' (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))\n  \\<not> validate_ground_clause I\n          (subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>)", "show False"], ["proof (prove)\nusing this:\n  subst_lit L' (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>)\n  \\<in> subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>\n  validate_ground_lit I\n   (subst_lit L' (\\<sigma> \\<lozenge> \\<theta> \\<lozenge> \\<eta>))\n  \\<not> validate_ground_clause I\n          (subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma superposition_is_sound :\n  assumes \"finite (cl_ecl P1)\"\n  assumes \"finite (cl_ecl P2)\"\n  assumes \"superposition P1 P2 C \\<sigma> k C'\"\n  shows \"set_entails_clause { cl_ecl P1, cl_ecl P2 } (cl_ecl C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_entails_clause {cl_ecl P1, cl_ecl P2} (cl_ecl C)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause {cl_ecl P1, cl_ecl P2}\n            (cl_ecl C) \\<Longrightarrow>\n    False", "let ?P1 = \"(cl_ecl P1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause {cl_ecl P1, cl_ecl P2}\n            (cl_ecl C) \\<Longrightarrow>\n    False", "let ?P2 = \"(cl_ecl P2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause {cl_ecl P1, cl_ecl P2}\n            (cl_ecl C) \\<Longrightarrow>\n    False", "let ?C = \"(cl_ecl C)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause {cl_ecl P1, cl_ecl P2}\n            (cl_ecl C) \\<Longrightarrow>\n    False", "assume \"\\<not> set_entails_clause { cl_ecl P1, cl_ecl P2 } (cl_ecl C)\""], ["proof (state)\nthis:\n  \\<not> set_entails_clause {cl_ecl P1, cl_ecl P2} (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause {cl_ecl P1, cl_ecl P2}\n            (cl_ecl C) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> set_entails_clause {cl_ecl P1, cl_ecl P2} (cl_ecl C)", "obtain I \n    where \"validate_clause I ?P1\" and \"validate_clause I ?P2\" \n      and \"\\<not> (validate_clause I ?C)\" and \"fo_interpretation I\""], ["proof (prove)\nusing this:\n  \\<not> set_entails_clause {cl_ecl P1, cl_ecl P2} (cl_ecl C)\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        \\<lbrakk>validate_clause I (cl_ecl P1);\n         validate_clause I (cl_ecl P2); \\<not> validate_clause I (cl_ecl C);\n         fo_interpretation I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_entails_clause_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>I.\n             fo_interpretation I \\<longrightarrow>\n             validate_clause_set I {cl_ecl P1, cl_ecl P2} \\<longrightarrow>\n             validate_clause I (cl_ecl C))\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        \\<lbrakk>validate_clause I (cl_ecl P1);\n         validate_clause I (cl_ecl P2); \\<not> validate_clause I (cl_ecl C);\n         fo_interpretation I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson insert_iff validate_clause_set.elims(2))"], ["proof (state)\nthis:\n  validate_clause I (cl_ecl P1)\n  validate_clause I (cl_ecl P2)\n  \\<not> validate_clause I (cl_ecl C)\n  fo_interpretation I\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause {cl_ecl P1, cl_ecl P2}\n            (cl_ecl C) \\<Longrightarrow>\n    False", "from \\<open>\\<not> (validate_clause I ?C)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> validate_clause I (cl_ecl C)", "obtain \\<theta> \n    where \"\\<not> (validate_ground_clause I (subst_cl ?C \\<theta>))\" \n      and \"(ground_clause (subst_cl ?C \\<theta>))\""], ["proof (prove)\nusing this:\n  \\<not> validate_clause I (cl_ecl C)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<theta>.\n        \\<lbrakk>\\<not> validate_ground_clause I\n                         (subst_cl (cl_ecl C) \\<theta>);\n         ground_clause (subst_cl (cl_ecl C) \\<theta>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<not> validate_ground_clause I (subst_cl (cl_ecl C) \\<theta>)\n  ground_clause (subst_cl (cl_ecl C) \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause {cl_ecl P1, cl_ecl P2}\n            (cl_ecl C) \\<Longrightarrow>\n    False", "have P1_true: \"validate_clause I (subst_cl (subst_cl ?P1 \\<sigma>) \\<theta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. validate_clause I (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>)", "using \\<open>validate_clause I (cl_ecl P1)\\<close> instances_are_entailed"], ["proof (prove)\nusing this:\n  validate_clause I (cl_ecl P1)\n  validate_clause ?I ?C \\<Longrightarrow>\n  validate_clause ?I (subst_cl ?C ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. validate_clause I (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>)", "by blast"], ["proof (state)\nthis:\n  validate_clause I (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause {cl_ecl P1, cl_ecl P2}\n            (cl_ecl C) \\<Longrightarrow>\n    False", "have P2_true: \"validate_clause I (subst_cl (subst_cl ?P2 \\<sigma>) \\<theta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. validate_clause I (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>)", "using \\<open>validate_clause I (cl_ecl P2)\\<close> instances_are_entailed"], ["proof (prove)\nusing this:\n  validate_clause I (cl_ecl P2)\n  validate_clause ?I ?C \\<Longrightarrow>\n  validate_clause ?I (subst_cl ?C ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. validate_clause I (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>)", "by blast"], ["proof (state)\nthis:\n  validate_clause I (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause {cl_ecl P1, cl_ecl P2}\n            (cl_ecl C) \\<Longrightarrow>\n    False", "have \"\\<not> (validate_clause I (subst_cl ?C \\<theta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> validate_clause I (subst_cl (cl_ecl C) \\<theta>)", "by (metis \\<open>\\<not> validate_ground_clause I (subst_cl (cl_ecl C) \\<theta>)\\<close> \n        \\<open>ground_clause (subst_cl (cl_ecl C) \\<theta>)\\<close> \n        substs_preserve_ground_clause validate_clause.elims(1))"], ["proof (state)\nthis:\n  \\<not> validate_clause I (subst_cl (cl_ecl C) \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause {cl_ecl P1, cl_ecl P2}\n            (cl_ecl C) \\<Longrightarrow>\n    False", "let ?S = \"{ (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>), \n      (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>) }\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause {cl_ecl P1, cl_ecl P2}\n            (cl_ecl C) \\<Longrightarrow>\n    False", "from P1_true and P2_true"], ["proof (chain)\npicking this:\n  validate_clause I (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>)\n  validate_clause I (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>)", "have \"validate_clause_set I ?S\""], ["proof (prove)\nusing this:\n  validate_clause I (subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>)\n  validate_clause I (subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>)\n\ngoal (1 subgoal):\n 1. validate_clause_set I\n     {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n      subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}", "by (metis insert_iff singletonD validate_clause_set.elims(3))"], ["proof (state)\nthis:\n  validate_clause_set I\n   {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n    subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause {cl_ecl P1, cl_ecl P2}\n            (cl_ecl C) \\<Longrightarrow>\n    False", "from this and \\<open>\\<not> (validate_clause I (subst_cl ?C \\<theta>))\\<close> \\<open>fo_interpretation I\\<close>"], ["proof (chain)\npicking this:\n  validate_clause_set I\n   {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n    subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n  \\<not> validate_clause I (subst_cl (cl_ecl C) \\<theta>)\n  fo_interpretation I", "have \"\\<not> set_entails_clause ?S (subst_cl (cl_ecl C) \\<theta>)\""], ["proof (prove)\nusing this:\n  validate_clause_set I\n   {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n    subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n  \\<not> validate_clause I (subst_cl (cl_ecl C) \\<theta>)\n  fo_interpretation I\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>)", "using set_entails_clause_def"], ["proof (prove)\nusing this:\n  validate_clause_set I\n   {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n    subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n  \\<not> validate_clause I (subst_cl (cl_ecl C) \\<theta>)\n  fo_interpretation I\n  set_entails_clause ?S ?C =\n  (\\<forall>I.\n      fo_interpretation I \\<longrightarrow>\n      validate_clause_set I ?S \\<longrightarrow> validate_clause I ?C)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause\n            {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n             subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n            (subst_cl (cl_ecl C) \\<theta>)", "by blast"], ["proof (state)\nthis:\n  \\<not> set_entails_clause\n          {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n           subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n          (subst_cl (cl_ecl C) \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause {cl_ecl P1, cl_ecl P2}\n            (cl_ecl C) \\<Longrightarrow>\n    False", "from this and assms(1) and assms(2) and assms(3) and \n    \\<open>(ground_clause (subst_cl ?C \\<theta>))\\<close>"], ["proof (chain)\npicking this:\n  \\<not> set_entails_clause\n          {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n           subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n          (subst_cl (cl_ecl C) \\<theta>)\n  finite (cl_ecl P1)\n  finite (cl_ecl P2)\n  superposition P1 P2 C \\<sigma> k C'\n  ground_clause (subst_cl (cl_ecl C) \\<theta>)", "show False"], ["proof (prove)\nusing this:\n  \\<not> set_entails_clause\n          {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n           subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n          (subst_cl (cl_ecl C) \\<theta>)\n  finite (cl_ecl P1)\n  finite (cl_ecl P2)\n  superposition P1 P2 C \\<sigma> k C'\n  ground_clause (subst_cl (cl_ecl C) \\<theta>)\n\ngoal (1 subgoal):\n 1. False", "using ground_superposition_is_sound"], ["proof (prove)\nusing this:\n  \\<not> set_entails_clause\n          {subst_cl (subst_cl (cl_ecl P1) \\<sigma>) \\<theta>,\n           subst_cl (subst_cl (cl_ecl P2) \\<sigma>) \\<theta>}\n          (subst_cl (cl_ecl C) \\<theta>)\n  finite (cl_ecl P1)\n  finite (cl_ecl P2)\n  superposition P1 P2 C \\<sigma> k C'\n  ground_clause (subst_cl (cl_ecl C) \\<theta>)\n  \\<lbrakk>finite (cl_ecl ?P1.0); finite (cl_ecl ?P2.0);\n   superposition ?P1.0 ?P2.0 ?C ?\\<sigma> ?k ?C';\n   ground_clause (subst_cl (cl_ecl ?C) ?\\<theta>)\\<rbrakk>\n  \\<Longrightarrow> set_entails_clause\n                     {subst_cl (subst_cl (cl_ecl ?P1.0) ?\\<sigma>)\n                       ?\\<theta>,\n                      subst_cl (subst_cl (cl_ecl ?P2.0) ?\\<sigma>)\n                       ?\\<theta>}\n                     (subst_cl (cl_ecl ?C) ?\\<theta>)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma superposition_preserves_finiteness:\n  assumes \"finite (cl_ecl P1)\"\n  assumes \"finite (cl_ecl P2)\"\n  assumes \"superposition P1 P2 C \\<sigma> k C'\"\n  shows \"finite (cl_ecl C) \\<and> (finite C')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (cl_ecl C) \\<and> finite C'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (cl_ecl C) \\<and> finite C'", "from assms(3)"], ["proof (chain)\npicking this:\n  superposition P1 P2 C \\<sigma> k C'", "obtain L M L' where \n    def_C: \"(cl_ecl C) = (subst_cl (((cl_ecl P1) - { L }) \\<union> (((cl_ecl P2) - { M }) \\<union> { L' } )) \\<sigma>)\"\n    and def_C': \"C' = (((cl_ecl P1) - { L }) \\<union> (((cl_ecl P2) - { M }) \\<union> { L' } ))\""], ["proof (prove)\nusing this:\n  superposition P1 P2 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. (\\<And>L M L'.\n        \\<lbrakk>cl_ecl C =\n                 subst_cl\n                  (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))\n                  \\<sigma>;\n         C' =\n         cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using superposition_def"], ["proof (prove)\nusing this:\n  superposition P1 P2 C \\<sigma> k C'\n  superposition ?P1.0 ?P2.0 ?C ?\\<sigma> ?k ?C' =\n  (\\<exists>L t s u v M p Cl_P1 Cl_P2 Cl_C polarity t' u' L' trms_C.\n      L \\<in> Cl_P1 \\<and>\n      M \\<in> Cl_P2 \\<and>\n      eligible_literal L ?P1.0 ?\\<sigma> \\<and>\n      eligible_literal M ?P2.0 ?\\<sigma> \\<and>\n      variable_disjoint ?P1.0 ?P2.0 \\<and>\n      Cl_P1 = cl_ecl ?P1.0 \\<and>\n      Cl_P2 = cl_ecl ?P2.0 \\<and>\n      \\<not> is_a_variable u' \\<and>\n      allowed_redex u' ?P1.0 ?\\<sigma> \\<and>\n      trms_C =\n      get_trms Cl_C\n       (dom_trms Cl_C\n         (subst_set\n           (trms_ecl ?P1.0 \\<union> trms_ecl ?P2.0 \\<union>\n            {r. \\<exists>q.\n                   (q, p) \\<in> pos_ord ?P1.0 t \\<and> subterm t q r})\n           ?\\<sigma>))\n       ?k \\<and>\n      ?C = Ecl Cl_C trms_C \\<and>\n      orient_lit_inst M u v pos ?\\<sigma> \\<and>\n      orient_lit_inst L t s polarity ?\\<sigma> \\<and>\n      u \\<lhd> ?\\<sigma> \\<noteq> v \\<lhd> ?\\<sigma> \\<and>\n      subterm t p u' \\<and>\n      ck_unifier u' u ?\\<sigma> ?k \\<and>\n      replace_subterm t p v t' \\<and>\n      (?k = FirstOrder \\<or>\n       (subst_lit M ?\\<sigma>, subst_lit L ?\\<sigma>) \\<in> lit_ord) \\<and>\n      (?k = FirstOrder \\<or>\n       strictly_maximal_literal ?P2.0 M ?\\<sigma>) \\<and>\n      L' = mk_lit polarity (Eq t' s) \\<and>\n      Cl_C = subst_cl ?C' ?\\<sigma> \\<and>\n      ?C' = Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'}))\n\ngoal (1 subgoal):\n 1. (\\<And>L M L'.\n        \\<lbrakk>cl_ecl C =\n                 subst_cl\n                  (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))\n                  \\<sigma>;\n         C' =\n         cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  cl_ecl C =\n  subst_cl (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))\n   \\<sigma>\n  C' = cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'})\n\ngoal (1 subgoal):\n 1. finite (cl_ecl C) \\<and> finite C'", "from assms(1) and assms(2)"], ["proof (chain)\npicking this:\n  finite (cl_ecl P1)\n  finite (cl_ecl P2)", "have \"finite (((cl_ecl P1) - { L }) \\<union> (((cl_ecl P2) - { M }) \\<union> { L' } ))\""], ["proof (prove)\nusing this:\n  finite (cl_ecl P1)\n  finite (cl_ecl P2)\n\ngoal (1 subgoal):\n 1. finite (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))\n\ngoal (1 subgoal):\n 1. finite (cl_ecl C) \\<and> finite C'", "from this and def_C def_C'"], ["proof (chain)\npicking this:\n  finite (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))\n  cl_ecl C =\n  subst_cl (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))\n   \\<sigma>\n  C' = cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'})", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))\n  cl_ecl C =\n  subst_cl (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))\n   \\<sigma>\n  C' = cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'})\n\ngoal (1 subgoal):\n 1. finite (cl_ecl C) \\<and> finite C'", "using substs_preserve_finiteness"], ["proof (prove)\nusing this:\n  finite (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))\n  cl_ecl C =\n  subst_cl (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))\n   \\<sigma>\n  C' = cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'})\n  finite ?C \\<Longrightarrow> finite (subst_cl ?C ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. finite (cl_ecl C) \\<and> finite C'", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl C) \\<and> finite C'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reflexion_preserves_finiteness:\n  assumes \"finite (cl_ecl P1)\"\n  assumes \"reflexion P1 C \\<sigma> k C'\"\n  shows \"finite (cl_ecl C) \\<and> (finite C')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (cl_ecl C) \\<and> finite C'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (cl_ecl C) \\<and> finite C'", "from assms(2)"], ["proof (chain)\npicking this:\n  reflexion P1 C \\<sigma> k C'", "obtain L1 where \n    def_C: \"(cl_ecl C) = (subst_cl ((cl_ecl P1) - { L1 }) \\<sigma>)\"\n    and def_C': \"C' = ((cl_ecl P1) - { L1 })\""], ["proof (prove)\nusing this:\n  reflexion P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. (\\<And>L1.\n        \\<lbrakk>cl_ecl C = subst_cl (cl_ecl P1 - {L1}) \\<sigma>;\n         C' = cl_ecl P1 - {L1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using reflexion_def"], ["proof (prove)\nusing this:\n  reflexion P1 C \\<sigma> k C'\n  reflexion ?P ?C ?\\<sigma> ?k ?C' =\n  (\\<exists>L1 t s Cl_P Cl_C trms_C.\n      eligible_literal L1 ?P ?\\<sigma> \\<and>\n      L1 \\<in> cl_ecl ?P \\<and>\n      Cl_C = cl_ecl ?C \\<and>\n      Cl_P = cl_ecl ?P \\<and>\n      orient_lit_inst L1 t s neg ?\\<sigma> \\<and>\n      ck_unifier t s ?\\<sigma> ?k \\<and>\n      ?C = Ecl Cl_C trms_C \\<and>\n      trms_C =\n      get_trms Cl_C\n       (dom_trms Cl_C (subst_set (trms_ecl ?P \\<union> {t}) ?\\<sigma>))\n       ?k \\<and>\n      Cl_C = subst_cl ?C' ?\\<sigma> \\<and> ?C' = Cl_P - {L1})\n\ngoal (1 subgoal):\n 1. (\\<And>L1.\n        \\<lbrakk>cl_ecl C = subst_cl (cl_ecl P1 - {L1}) \\<sigma>;\n         C' = cl_ecl P1 - {L1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  cl_ecl C = subst_cl (cl_ecl P1 - {L1}) \\<sigma>\n  C' = cl_ecl P1 - {L1}\n\ngoal (1 subgoal):\n 1. finite (cl_ecl C) \\<and> finite C'", "from assms(1)"], ["proof (chain)\npicking this:\n  finite (cl_ecl P1)", "have \"finite ((cl_ecl P1) - { L1 })\""], ["proof (prove)\nusing this:\n  finite (cl_ecl P1)\n\ngoal (1 subgoal):\n 1. finite (cl_ecl P1 - {L1})", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl P1 - {L1})\n\ngoal (1 subgoal):\n 1. finite (cl_ecl C) \\<and> finite C'", "from this and def_C def_C'"], ["proof (chain)\npicking this:\n  finite (cl_ecl P1 - {L1})\n  cl_ecl C = subst_cl (cl_ecl P1 - {L1}) \\<sigma>\n  C' = cl_ecl P1 - {L1}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (cl_ecl P1 - {L1})\n  cl_ecl C = subst_cl (cl_ecl P1 - {L1}) \\<sigma>\n  C' = cl_ecl P1 - {L1}\n\ngoal (1 subgoal):\n 1. finite (cl_ecl C) \\<and> finite C'", "using substs_preserve_finiteness"], ["proof (prove)\nusing this:\n  finite (cl_ecl P1 - {L1})\n  cl_ecl C = subst_cl (cl_ecl P1 - {L1}) \\<sigma>\n  C' = cl_ecl P1 - {L1}\n  finite ?C \\<Longrightarrow> finite (subst_cl ?C ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. finite (cl_ecl C) \\<and> finite C'", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl C) \\<and> finite C'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma factorization_preserves_finiteness:\n  assumes \"finite (cl_ecl P1)\"\n  assumes \"factorization P1 C \\<sigma> k C'\"\n  shows \"finite (cl_ecl C) \\<and> (finite C')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (cl_ecl C) \\<and> finite C'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (cl_ecl C) \\<and> finite C'", "from assms(2)"], ["proof (chain)\npicking this:\n  factorization P1 C \\<sigma> k C'", "obtain L2 L' where \n    def_C: \"(cl_ecl C) = (subst_cl ( ((cl_ecl P1) - { L2 }) \\<union> { L' } ) \\<sigma>)\"\n    and def_C': \"C' = ( ((cl_ecl P1) - { L2 }) \\<union> { L' } )\""], ["proof (prove)\nusing this:\n  factorization P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. (\\<And>L2 L'.\n        \\<lbrakk>cl_ecl C =\n                 subst_cl (cl_ecl P1 - {L2} \\<union> {L'}) \\<sigma>;\n         C' = cl_ecl P1 - {L2} \\<union> {L'}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using factorization_def"], ["proof (prove)\nusing this:\n  factorization P1 C \\<sigma> k C'\n  factorization ?P ?C ?\\<sigma> ?k ?C' =\n  (\\<exists>L1 L2 L' t s u v Cl_P Cl_C trms_C.\n      eligible_literal L1 ?P ?\\<sigma> \\<and>\n      L1 \\<in> cl_ecl ?P \\<and>\n      L2 \\<in> cl_ecl ?P - {L1} \\<and>\n      Cl_C = cl_ecl ?C \\<and>\n      Cl_P = cl_ecl ?P \\<and>\n      orient_lit_inst L1 t s pos ?\\<sigma> \\<and>\n      orient_lit_inst L2 u v pos ?\\<sigma> \\<and>\n      t \\<lhd> ?\\<sigma> \\<noteq> s \\<lhd> ?\\<sigma> \\<and>\n      t \\<lhd> ?\\<sigma> \\<noteq> v \\<lhd> ?\\<sigma> \\<and>\n      ck_unifier t u ?\\<sigma> ?k \\<and>\n      L' = Neg (Eq s v) \\<and>\n      (?C = Ecl Cl_C trms_C \\<and>\n       trms_C =\n       get_trms Cl_C\n        (dom_trms Cl_C\n          (subst_set (trms_ecl ?P \\<union> proper_subterms_of t) ?\\<sigma>))\n        ?k) \\<and>\n      Cl_C = subst_cl ?C' ?\\<sigma> \\<and> ?C' = Cl_P - {L2} \\<union> {L'})\n\ngoal (1 subgoal):\n 1. (\\<And>L2 L'.\n        \\<lbrakk>cl_ecl C =\n                 subst_cl (cl_ecl P1 - {L2} \\<union> {L'}) \\<sigma>;\n         C' = cl_ecl P1 - {L2} \\<union> {L'}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  cl_ecl C = subst_cl (cl_ecl P1 - {L2} \\<union> {L'}) \\<sigma>\n  C' = cl_ecl P1 - {L2} \\<union> {L'}\n\ngoal (1 subgoal):\n 1. finite (cl_ecl C) \\<and> finite C'", "from assms(1)"], ["proof (chain)\npicking this:\n  finite (cl_ecl P1)", "have \"(finite (((cl_ecl P1) - { L2 }) \\<union> { L' }))\""], ["proof (prove)\nusing this:\n  finite (cl_ecl P1)\n\ngoal (1 subgoal):\n 1. finite (cl_ecl P1 - {L2} \\<union> {L'})", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl P1 - {L2} \\<union> {L'})\n\ngoal (1 subgoal):\n 1. finite (cl_ecl C) \\<and> finite C'", "from this and def_C def_C'"], ["proof (chain)\npicking this:\n  finite (cl_ecl P1 - {L2} \\<union> {L'})\n  cl_ecl C = subst_cl (cl_ecl P1 - {L2} \\<union> {L'}) \\<sigma>\n  C' = cl_ecl P1 - {L2} \\<union> {L'}", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (cl_ecl P1 - {L2} \\<union> {L'})\n  cl_ecl C = subst_cl (cl_ecl P1 - {L2} \\<union> {L'}) \\<sigma>\n  C' = cl_ecl P1 - {L2} \\<union> {L'}\n\ngoal (1 subgoal):\n 1. finite (cl_ecl C) \\<and> finite C'", "using substs_preserve_finiteness"], ["proof (prove)\nusing this:\n  finite (cl_ecl P1 - {L2} \\<union> {L'})\n  cl_ecl C = subst_cl (cl_ecl P1 - {L2} \\<union> {L'}) \\<sigma>\n  C' = cl_ecl P1 - {L2} \\<union> {L'}\n  finite ?C \\<Longrightarrow> finite (subst_cl ?C ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. finite (cl_ecl C) \\<and> finite C'", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl C) \\<and> finite C'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma derivable_clauses_are_finite:\n  assumes \"derivable C P S \\<sigma> k C'\"\n  assumes \"\\<forall>x \\<in> P. (finite (cl_ecl x))\" \n  shows \"finite (cl_ecl C) \\<and> (finite C')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (cl_ecl C) \\<and> finite C'", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (finite (cl_ecl C) \\<and> finite C') \\<Longrightarrow> False", "assume hyp: \"\\<not> (finite (cl_ecl C)  \\<and> (finite C'))\""], ["proof (state)\nthis:\n  \\<not> (finite (cl_ecl C) \\<and> finite C')\n\ngoal (1 subgoal):\n 1. \\<not> (finite (cl_ecl C) \\<and> finite C') \\<Longrightarrow> False", "have not_sup: \"\\<not> (\\<exists>P1 P2. (P1 \\<in> P \\<and> P2 \\<in> P \\<and> superposition P1 P2 C \\<sigma> k C'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and> superposition P1 P2 C \\<sigma> k C'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> k C' \\<Longrightarrow>\n    False", "assume \"(\\<exists>P1 P2. (P1 \\<in> P \\<and> P2 \\<in> P \\<and> superposition P1 P2 C \\<sigma> k C'))\""], ["proof (state)\nthis:\n  \\<exists>P1 P2.\n     P1 \\<in> P \\<and> P2 \\<in> P \\<and> superposition P1 P2 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> k C' \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>P1 P2.\n     P1 \\<in> P \\<and> P2 \\<in> P \\<and> superposition P1 P2 C \\<sigma> k C'", "obtain P1 P2 where \"P1 \\<in> P\" \"P2 \\<in> P\" \"superposition P1 P2 C \\<sigma> k C'\""], ["proof (prove)\nusing this:\n  \\<exists>P1 P2.\n     P1 \\<in> P \\<and> P2 \\<in> P \\<and> superposition P1 P2 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2.\n        \\<lbrakk>P1 \\<in> P; P2 \\<in> P;\n         superposition P1 P2 C \\<sigma> k C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> P\n  P2 \\<in> P\n  superposition P1 P2 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from \\<open>P1 \\<in> P\\<close> and assms(2)"], ["proof (chain)\npicking this:\n  P1 \\<in> P\n  \\<forall>x\\<in>P. finite (cl_ecl x)", "have \"finite (cl_ecl P1)\""], ["proof (prove)\nusing this:\n  P1 \\<in> P\n  \\<forall>x\\<in>P. finite (cl_ecl x)\n\ngoal (1 subgoal):\n 1. finite (cl_ecl P1)", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl P1)\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from \\<open>P2 \\<in> P\\<close> and assms(2)"], ["proof (chain)\npicking this:\n  P2 \\<in> P\n  \\<forall>x\\<in>P. finite (cl_ecl x)", "have \"finite (cl_ecl P2)\""], ["proof (prove)\nusing this:\n  P2 \\<in> P\n  \\<forall>x\\<in>P. finite (cl_ecl x)\n\ngoal (1 subgoal):\n 1. finite (cl_ecl P2)", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl P2)\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from \\<open>(finite (cl_ecl P1))\\<close> and  \\<open>(finite (cl_ecl P2))\\<close> and \\<open>superposition P1 P2 C \\<sigma> k C'\\<close>"], ["proof (chain)\npicking this:\n  finite (cl_ecl P1)\n  finite (cl_ecl P2)\n  superposition P1 P2 C \\<sigma> k C'", "have \"finite (cl_ecl C) \\<and> (finite C')\""], ["proof (prove)\nusing this:\n  finite (cl_ecl P1)\n  finite (cl_ecl P2)\n  superposition P1 P2 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. finite (cl_ecl C) \\<and> finite C'", "using superposition_preserves_finiteness [of P1 P2 C \\<sigma>]"], ["proof (prove)\nusing this:\n  finite (cl_ecl P1)\n  finite (cl_ecl P2)\n  superposition P1 P2 C \\<sigma> k C'\n  \\<lbrakk>finite (cl_ecl P1); finite (cl_ecl P2);\n   superposition P1 P2 C \\<sigma> ?k ?C'\\<rbrakk>\n  \\<Longrightarrow> finite (cl_ecl C) \\<and> finite ?C'\n\ngoal (1 subgoal):\n 1. finite (cl_ecl C) \\<and> finite C'", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl C) \\<and> finite C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> k C' \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  finite (cl_ecl C) \\<and> finite C'", "show False"], ["proof (prove)\nusing this:\n  finite (cl_ecl C) \\<and> finite C'\n\ngoal (1 subgoal):\n 1. False", "using hyp"], ["proof (prove)\nusing this:\n  finite (cl_ecl C) \\<and> finite C'\n  \\<not> (finite (cl_ecl C) \\<and> finite C')\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>P1 P2.\n     P1 \\<in> P \\<and> P2 \\<in> P \\<and> superposition P1 P2 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<not> (finite (cl_ecl C) \\<and> finite C') \\<Longrightarrow> False", "have not_ref: \"\\<not> (\\<exists>P1. (P1 \\<in> P \\<and> reflexion P1 C \\<sigma> k C'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>P1. P1 \\<in> P \\<and> reflexion P1 C \\<sigma> k C'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> reflexion P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "assume \"(\\<exists>P1. (P1 \\<in> P \\<and> reflexion P1 C \\<sigma> k C'))\""], ["proof (state)\nthis:\n  \\<exists>P1. P1 \\<in> P \\<and> reflexion P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> reflexion P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>P1. P1 \\<in> P \\<and> reflexion P1 C \\<sigma> k C'", "obtain P1 where \"P1 \\<in> P\" \"reflexion P1 C \\<sigma> k C'\""], ["proof (prove)\nusing this:\n  \\<exists>P1. P1 \\<in> P \\<and> reflexion P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. (\\<And>P1.\n        \\<lbrakk>P1 \\<in> P; reflexion P1 C \\<sigma> k C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> P\n  reflexion P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> reflexion P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from \\<open>P1 \\<in> P\\<close> and assms(2)"], ["proof (chain)\npicking this:\n  P1 \\<in> P\n  \\<forall>x\\<in>P. finite (cl_ecl x)", "have \"finite (cl_ecl P1)\""], ["proof (prove)\nusing this:\n  P1 \\<in> P\n  \\<forall>x\\<in>P. finite (cl_ecl x)\n\ngoal (1 subgoal):\n 1. finite (cl_ecl P1)", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl P1)\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> reflexion P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from \\<open>(finite (cl_ecl P1))\\<close>  and \\<open>reflexion P1 C \\<sigma> k C'\\<close>"], ["proof (chain)\npicking this:\n  finite (cl_ecl P1)\n  reflexion P1 C \\<sigma> k C'", "have \"finite (cl_ecl C)  \\<and> (finite C')\""], ["proof (prove)\nusing this:\n  finite (cl_ecl P1)\n  reflexion P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. finite (cl_ecl C) \\<and> finite C'", "using reflexion_preserves_finiteness [of P1 C \\<sigma>]"], ["proof (prove)\nusing this:\n  finite (cl_ecl P1)\n  reflexion P1 C \\<sigma> k C'\n  \\<lbrakk>finite (cl_ecl P1); reflexion P1 C \\<sigma> ?k ?C'\\<rbrakk>\n  \\<Longrightarrow> finite (cl_ecl C) \\<and> finite ?C'\n\ngoal (1 subgoal):\n 1. finite (cl_ecl C) \\<and> finite C'", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl C) \\<and> finite C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> reflexion P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  finite (cl_ecl C) \\<and> finite C'", "show False"], ["proof (prove)\nusing this:\n  finite (cl_ecl C) \\<and> finite C'\n\ngoal (1 subgoal):\n 1. False", "using hyp"], ["proof (prove)\nusing this:\n  finite (cl_ecl C) \\<and> finite C'\n  \\<not> (finite (cl_ecl C) \\<and> finite C')\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>P1. P1 \\<in> P \\<and> reflexion P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<not> (finite (cl_ecl C) \\<and> finite C') \\<Longrightarrow> False", "have not_fact: \"\\<not> (\\<exists>P1. (P1 \\<in> P \\<and> factorization P1 C \\<sigma> k C'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>P1. P1 \\<in> P \\<and> factorization P1 C \\<sigma> k C'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> factorization P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "assume \"(\\<exists>P1. (P1 \\<in> P \\<and>  factorization P1 C \\<sigma> k C'))\""], ["proof (state)\nthis:\n  \\<exists>P1. P1 \\<in> P \\<and> factorization P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> factorization P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>P1. P1 \\<in> P \\<and> factorization P1 C \\<sigma> k C'", "obtain P1 where \"P1 \\<in> P\" \" factorization P1 C \\<sigma> k C'\""], ["proof (prove)\nusing this:\n  \\<exists>P1. P1 \\<in> P \\<and> factorization P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. (\\<And>P1.\n        \\<lbrakk>P1 \\<in> P; factorization P1 C \\<sigma> k C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> P\n  factorization P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> factorization P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from \\<open>P1 \\<in> P\\<close> and assms(2)"], ["proof (chain)\npicking this:\n  P1 \\<in> P\n  \\<forall>x\\<in>P. finite (cl_ecl x)", "have \"finite (cl_ecl P1)\""], ["proof (prove)\nusing this:\n  P1 \\<in> P\n  \\<forall>x\\<in>P. finite (cl_ecl x)\n\ngoal (1 subgoal):\n 1. finite (cl_ecl P1)", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl P1)\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> factorization P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from \\<open>(finite (cl_ecl P1))\\<close>  and \\<open> factorization P1 C \\<sigma> k C'\\<close>"], ["proof (chain)\npicking this:\n  finite (cl_ecl P1)\n  factorization P1 C \\<sigma> k C'", "have \"finite (cl_ecl C)  \\<and> (finite C')\""], ["proof (prove)\nusing this:\n  finite (cl_ecl P1)\n  factorization P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. finite (cl_ecl C) \\<and> finite C'", "using  factorization_preserves_finiteness [of P1 C \\<sigma>]"], ["proof (prove)\nusing this:\n  finite (cl_ecl P1)\n  factorization P1 C \\<sigma> k C'\n  \\<lbrakk>finite (cl_ecl P1); factorization P1 C \\<sigma> ?k ?C'\\<rbrakk>\n  \\<Longrightarrow> finite (cl_ecl C) \\<and> finite ?C'\n\ngoal (1 subgoal):\n 1. finite (cl_ecl C) \\<and> finite C'", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl C) \\<and> finite C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> factorization P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  finite (cl_ecl C) \\<and> finite C'", "show False"], ["proof (prove)\nusing this:\n  finite (cl_ecl C) \\<and> finite C'\n\ngoal (1 subgoal):\n 1. False", "using hyp"], ["proof (prove)\nusing this:\n  finite (cl_ecl C) \\<and> finite C'\n  \\<not> (finite (cl_ecl C) \\<and> finite C')\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>P1. P1 \\<in> P \\<and> factorization P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<not> (finite (cl_ecl C) \\<and> finite C') \\<Longrightarrow> False", "from not_sup not_ref not_fact and assms(1)"], ["proof (chain)\npicking this:\n  \\<nexists>P1 P2.\n     P1 \\<in> P \\<and> P2 \\<in> P \\<and> superposition P1 P2 C \\<sigma> k C'\n  \\<nexists>P1. P1 \\<in> P \\<and> reflexion P1 C \\<sigma> k C'\n  \\<nexists>P1. P1 \\<in> P \\<and> factorization P1 C \\<sigma> k C'\n  derivable C P S \\<sigma> k C'", "show False"], ["proof (prove)\nusing this:\n  \\<nexists>P1 P2.\n     P1 \\<in> P \\<and> P2 \\<in> P \\<and> superposition P1 P2 C \\<sigma> k C'\n  \\<nexists>P1. P1 \\<in> P \\<and> reflexion P1 C \\<sigma> k C'\n  \\<nexists>P1. P1 \\<in> P \\<and> factorization P1 C \\<sigma> k C'\n  derivable C P S \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. False", "unfolding derivable_def"], ["proof (prove)\nusing this:\n  \\<nexists>P1 P2.\n     P1 \\<in> P \\<and> P2 \\<in> P \\<and> superposition P1 P2 C \\<sigma> k C'\n  \\<nexists>P1. P1 \\<in> P \\<and> reflexion P1 C \\<sigma> k C'\n  \\<nexists>P1. P1 \\<in> P \\<and> factorization P1 C \\<sigma> k C'\n  (\\<exists>P1 P2.\n      P1 \\<in> S \\<and>\n      P2 \\<in> S \\<and>\n      P = {P1, P2} \\<and> superposition P1 P2 C \\<sigma> k C') \\<or>\n  (\\<exists>P1.\n      P1 \\<in> S \\<and>\n      P = {P1} \\<and> factorization P1 C \\<sigma> k C') \\<or>\n  (\\<exists>P1.\n      P1 \\<in> S \\<and> P = {P1} \\<and> reflexion P1 C \\<sigma> k C')\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma derivable_clauses_lemma:\n  assumes \"derivable C P S \\<sigma> k C'\"\n  shows \"((cl_ecl C) = (subst_cl C' \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_ecl C = subst_cl C' \\<sigma>", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. cl_ecl C \\<noteq> subst_cl C' \\<sigma> \\<Longrightarrow> False", "assume hyp: \"\\<not> ((cl_ecl C) = (subst_cl C' \\<sigma>))\""], ["proof (state)\nthis:\n  cl_ecl C \\<noteq> subst_cl C' \\<sigma>\n\ngoal (1 subgoal):\n 1. cl_ecl C \\<noteq> subst_cl C' \\<sigma> \\<Longrightarrow> False", "have not_sup: \"\\<not> (\\<exists>P1 P2. (P1 \\<in> S \\<and> P2 \\<in> S \\<and> superposition P1 P2 C \\<sigma> k C'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>P1 P2.\n       P1 \\<in> S \\<and>\n       P2 \\<in> S \\<and> superposition P1 P2 C \\<sigma> k C'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> S \\<and>\n       P2 \\<in> S \\<and>\n       superposition P1 P2 C \\<sigma> k C' \\<Longrightarrow>\n    False", "assume \"(\\<exists>P1 P2. (P1 \\<in> S \\<and> P2 \\<in> S \\<and> superposition P1 P2 C \\<sigma> k C'))\""], ["proof (state)\nthis:\n  \\<exists>P1 P2.\n     P1 \\<in> S \\<and> P2 \\<in> S \\<and> superposition P1 P2 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> S \\<and>\n       P2 \\<in> S \\<and>\n       superposition P1 P2 C \\<sigma> k C' \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>P1 P2.\n     P1 \\<in> S \\<and> P2 \\<in> S \\<and> superposition P1 P2 C \\<sigma> k C'", "obtain P1 P2 where \"P1 \\<in> S\" \"P2 \\<in> S\" \"superposition P1 P2 C \\<sigma> k C'\""], ["proof (prove)\nusing this:\n  \\<exists>P1 P2.\n     P1 \\<in> S \\<and> P2 \\<in> S \\<and> superposition P1 P2 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2.\n        \\<lbrakk>P1 \\<in> S; P2 \\<in> S;\n         superposition P1 P2 C \\<sigma> k C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> S\n  P2 \\<in> S\n  superposition P1 P2 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> S \\<and>\n       P2 \\<in> S \\<and>\n       superposition P1 P2 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from \\<open>superposition P1 P2 C \\<sigma> k C'\\<close>"], ["proof (chain)\npicking this:\n  superposition P1 P2 C \\<sigma> k C'", "obtain Cl_C Cl_P1 L Cl_P2 M L' T\n      where \"Cl_C = (subst_cl ((Cl_P1 - { L }) \\<union> ((Cl_P2 - { M }) \\<union> { L' } )) \\<sigma>)\"\n        \"(C' = (Cl_P1 - { L }) \\<union> ((Cl_P2 - { M }) \\<union> { L' } ))\"\n        \"C = (Ecl Cl_C T)\""], ["proof (prove)\nusing this:\n  superposition P1 P2 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. (\\<And>Cl_C Cl_P1 L Cl_P2 M L' T.\n        \\<lbrakk>Cl_C =\n                 subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'}))\n                  \\<sigma>;\n         C' = Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'});\n         C = Ecl Cl_C T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding superposition_def"], ["proof (prove)\nusing this:\n  \\<exists>L t s u v M p Cl_P1 Cl_P2 Cl_C polarity t' u' L' trms_C.\n     L \\<in> Cl_P1 \\<and>\n     M \\<in> Cl_P2 \\<and>\n     eligible_literal L P1 \\<sigma> \\<and>\n     eligible_literal M P2 \\<sigma> \\<and>\n     variable_disjoint P1 P2 \\<and>\n     Cl_P1 = cl_ecl P1 \\<and>\n     Cl_P2 = cl_ecl P2 \\<and>\n     \\<not> is_a_variable u' \\<and>\n     allowed_redex u' P1 \\<sigma> \\<and>\n     trms_C =\n     get_trms Cl_C\n      (dom_trms Cl_C\n        (subst_set\n          (trms_ecl P1 \\<union> trms_ecl P2 \\<union>\n           {r. \\<exists>q. (q, p) \\<in> pos_ord P1 t \\<and> subterm t q r})\n          \\<sigma>))\n      k \\<and>\n     C = Ecl Cl_C trms_C \\<and>\n     orient_lit_inst M u v pos \\<sigma> \\<and>\n     orient_lit_inst L t s polarity \\<sigma> \\<and>\n     u \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma> \\<and>\n     subterm t p u' \\<and>\n     ck_unifier u' u \\<sigma> k \\<and>\n     replace_subterm t p v t' \\<and>\n     (k = FirstOrder \\<or>\n      (subst_lit M \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord) \\<and>\n     (k = FirstOrder \\<or> strictly_maximal_literal P2 M \\<sigma>) \\<and>\n     L' = mk_lit polarity (Eq t' s) \\<and>\n     Cl_C = subst_cl C' \\<sigma> \\<and>\n     C' = Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})\n\ngoal (1 subgoal):\n 1. (\\<And>Cl_C Cl_P1 L Cl_P2 M L' T.\n        \\<lbrakk>Cl_C =\n                 subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'}))\n                  \\<sigma>;\n         C' = Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'});\n         C = Ecl Cl_C T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Cl_C =\n  subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<sigma>\n  C' = Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})\n  C = Ecl Cl_C T\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> S \\<and>\n       P2 \\<in> S \\<and>\n       superposition P1 P2 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from \\<open>Cl_C = (subst_cl ((Cl_P1 - { L }) \\<union> ((Cl_P2 - { M }) \\<union> { L' } )) \\<sigma>)\\<close> \n      \\<open>(C' = (Cl_P1 - { L }) \\<union> ((Cl_P2 - { M }) \\<union> { L' } ))\\<close> \\<open>C = (Ecl Cl_C T)\\<close> hyp"], ["proof (chain)\npicking this:\n  Cl_C =\n  subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<sigma>\n  C' = Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})\n  C = Ecl Cl_C T\n  cl_ecl C \\<noteq> subst_cl C' \\<sigma>", "show False"], ["proof (prove)\nusing this:\n  Cl_C =\n  subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<sigma>\n  C' = Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})\n  C = Ecl Cl_C T\n  cl_ecl C \\<noteq> subst_cl C' \\<sigma>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>P1 P2.\n     P1 \\<in> S \\<and> P2 \\<in> S \\<and> superposition P1 P2 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. cl_ecl C \\<noteq> subst_cl C' \\<sigma> \\<Longrightarrow> False", "have not_ref: \"\\<not> (\\<exists>P1. (P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>P1. P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "assume \"(\\<exists>P1. (P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C'))\""], ["proof (state)\nthis:\n  \\<exists>P1. P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>P1. P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C'", "obtain P1 where \"P1 \\<in> S\" \"reflexion P1 C \\<sigma> k C'\""], ["proof (prove)\nusing this:\n  \\<exists>P1. P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. (\\<And>P1.\n        \\<lbrakk>P1 \\<in> S; reflexion P1 C \\<sigma> k C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> S\n  reflexion P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from \\<open>reflexion P1 C \\<sigma> k C'\\<close>"], ["proof (chain)\npicking this:\n  reflexion P1 C \\<sigma> k C'", "obtain T Cl_C Cl_P L1 where\n      \"C = (Ecl Cl_C T)\"\n      \"Cl_C = (subst_cl ((Cl_P - { L1 }) )) \\<sigma>\"\n      \"(C' = ((Cl_P - { L1 }) ))\""], ["proof (prove)\nusing this:\n  reflexion P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. (\\<And>Cl_C T Cl_P L1.\n        \\<lbrakk>C = Ecl Cl_C T; Cl_C = subst_cl (Cl_P - {L1}) \\<sigma>;\n         C' = Cl_P - {L1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding reflexion_def"], ["proof (prove)\nusing this:\n  \\<exists>L1 t s Cl_P Cl_C trms_C.\n     eligible_literal L1 P1 \\<sigma> \\<and>\n     L1 \\<in> cl_ecl P1 \\<and>\n     Cl_C = cl_ecl C \\<and>\n     Cl_P = cl_ecl P1 \\<and>\n     orient_lit_inst L1 t s neg \\<sigma> \\<and>\n     ck_unifier t s \\<sigma> k \\<and>\n     C = Ecl Cl_C trms_C \\<and>\n     trms_C =\n     get_trms Cl_C\n      (dom_trms Cl_C (subst_set (trms_ecl P1 \\<union> {t}) \\<sigma>))\n      k \\<and>\n     Cl_C = subst_cl C' \\<sigma> \\<and> C' = Cl_P - {L1}\n\ngoal (1 subgoal):\n 1. (\\<And>Cl_C T Cl_P L1.\n        \\<lbrakk>C = Ecl Cl_C T; Cl_C = subst_cl (Cl_P - {L1}) \\<sigma>;\n         C' = Cl_P - {L1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  C = Ecl Cl_C T\n  Cl_C = subst_cl (Cl_P - {L1}) \\<sigma>\n  C' = Cl_P - {L1}\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from \\<open>Cl_C = (subst_cl ((Cl_P - { L1 }) )) \\<sigma>\\<close> \n      \\<open>(C' = ((Cl_P - { L1 }) ))\\<close> \\<open>C = (Ecl Cl_C T)\\<close> hyp"], ["proof (chain)\npicking this:\n  Cl_C = subst_cl (Cl_P - {L1}) \\<sigma>\n  C' = Cl_P - {L1}\n  C = Ecl Cl_C T\n  cl_ecl C \\<noteq> subst_cl C' \\<sigma>", "show False"], ["proof (prove)\nusing this:\n  Cl_C = subst_cl (Cl_P - {L1}) \\<sigma>\n  C' = Cl_P - {L1}\n  C = Ecl Cl_C T\n  cl_ecl C \\<noteq> subst_cl C' \\<sigma>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>P1. P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. cl_ecl C \\<noteq> subst_cl C' \\<sigma> \\<Longrightarrow> False", "have not_fact: \"\\<not> (\\<exists>P1. (P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>P1. P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "assume \"(\\<exists>P1. (P1 \\<in> S \\<and>  factorization P1 C \\<sigma> k C'))\""], ["proof (state)\nthis:\n  \\<exists>P1. P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>P1. P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C'", "obtain P1 where \"P1 \\<in> S\" \"factorization P1 C \\<sigma> k C'\""], ["proof (prove)\nusing this:\n  \\<exists>P1. P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. (\\<And>P1.\n        \\<lbrakk>P1 \\<in> S; factorization P1 C \\<sigma> k C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> S\n  factorization P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from \\<open>factorization P1 C \\<sigma> k C'\\<close>"], ["proof (chain)\npicking this:\n  factorization P1 C \\<sigma> k C'", "obtain T Cl_C Cl_P L' L2 where\n      \"C = (Ecl Cl_C T)\"\n      \"Cl_C = (subst_cl ( (Cl_P - { L2 }) \\<union> { L' } )) \\<sigma>\"\n      \"C' = ( (Cl_P - { L2 }) \\<union> { L' } )\""], ["proof (prove)\nusing this:\n  factorization P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. (\\<And>Cl_C T Cl_P L2 L'.\n        \\<lbrakk>C = Ecl Cl_C T;\n         Cl_C = subst_cl (Cl_P - {L2} \\<union> {L'}) \\<sigma>;\n         C' = Cl_P - {L2} \\<union> {L'}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding factorization_def"], ["proof (prove)\nusing this:\n  \\<exists>L1 L2 L' t s u v Cl_P Cl_C trms_C.\n     eligible_literal L1 P1 \\<sigma> \\<and>\n     L1 \\<in> cl_ecl P1 \\<and>\n     L2 \\<in> cl_ecl P1 - {L1} \\<and>\n     Cl_C = cl_ecl C \\<and>\n     Cl_P = cl_ecl P1 \\<and>\n     orient_lit_inst L1 t s pos \\<sigma> \\<and>\n     orient_lit_inst L2 u v pos \\<sigma> \\<and>\n     t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma> \\<and>\n     t \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma> \\<and>\n     ck_unifier t u \\<sigma> k \\<and>\n     L' = Neg (Eq s v) \\<and>\n     (C = Ecl Cl_C trms_C \\<and>\n      trms_C =\n      get_trms Cl_C\n       (dom_trms Cl_C\n         (subst_set (trms_ecl P1 \\<union> proper_subterms_of t) \\<sigma>))\n       k) \\<and>\n     Cl_C = subst_cl C' \\<sigma> \\<and> C' = Cl_P - {L2} \\<union> {L'}\n\ngoal (1 subgoal):\n 1. (\\<And>Cl_C T Cl_P L2 L'.\n        \\<lbrakk>C = Ecl Cl_C T;\n         Cl_C = subst_cl (Cl_P - {L2} \\<union> {L'}) \\<sigma>;\n         C' = Cl_P - {L2} \\<union> {L'}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  C = Ecl Cl_C T\n  Cl_C = subst_cl (Cl_P - {L2} \\<union> {L'}) \\<sigma>\n  C' = Cl_P - {L2} \\<union> {L'}\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from \\<open>Cl_C = (subst_cl ( (Cl_P - { L2 }) \\<union> { L' } )) \\<sigma>\\<close> \n      \\<open>C' = ( (Cl_P - { L2 }) \\<union> { L' } )\\<close> \\<open>C = (Ecl Cl_C T)\\<close> hyp"], ["proof (chain)\npicking this:\n  Cl_C = subst_cl (Cl_P - {L2} \\<union> {L'}) \\<sigma>\n  C' = Cl_P - {L2} \\<union> {L'}\n  C = Ecl Cl_C T\n  cl_ecl C \\<noteq> subst_cl C' \\<sigma>", "show False"], ["proof (prove)\nusing this:\n  Cl_C = subst_cl (Cl_P - {L2} \\<union> {L'}) \\<sigma>\n  C' = Cl_P - {L2} \\<union> {L'}\n  C = Ecl Cl_C T\n  cl_ecl C \\<noteq> subst_cl C' \\<sigma>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>P1. P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. cl_ecl C \\<noteq> subst_cl C' \\<sigma> \\<Longrightarrow> False", "from not_sup not_ref not_fact and assms(1)"], ["proof (chain)\npicking this:\n  \\<nexists>P1 P2.\n     P1 \\<in> S \\<and> P2 \\<in> S \\<and> superposition P1 P2 C \\<sigma> k C'\n  \\<nexists>P1. P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C'\n  \\<nexists>P1. P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C'\n  derivable C P S \\<sigma> k C'", "show False"], ["proof (prove)\nusing this:\n  \\<nexists>P1 P2.\n     P1 \\<in> S \\<and> P2 \\<in> S \\<and> superposition P1 P2 C \\<sigma> k C'\n  \\<nexists>P1. P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C'\n  \\<nexists>P1. P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C'\n  derivable C P S \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. False", "unfolding derivable_def"], ["proof (prove)\nusing this:\n  \\<nexists>P1 P2.\n     P1 \\<in> S \\<and> P2 \\<in> S \\<and> superposition P1 P2 C \\<sigma> k C'\n  \\<nexists>P1. P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C'\n  \\<nexists>P1. P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C'\n  (\\<exists>P1 P2.\n      P1 \\<in> S \\<and>\n      P2 \\<in> S \\<and>\n      P = {P1, P2} \\<and> superposition P1 P2 C \\<sigma> k C') \\<or>\n  (\\<exists>P1.\n      P1 \\<in> S \\<and>\n      P = {P1} \\<and> factorization P1 C \\<sigma> k C') \\<or>\n  (\\<exists>P1.\n      P1 \\<in> S \\<and> P = {P1} \\<and> reflexion P1 C \\<sigma> k C')\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma substs_preserves_decompose_literal:\n  assumes \"decompose_literal L t s polarity\"\n  shows \"decompose_literal (subst_lit L \\<eta>) (subst t \\<eta>) (subst s \\<eta>) polarity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decompose_literal (subst_lit L \\<eta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. decompose_literal (subst_lit L \\<eta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "let ?L = \"(subst_lit L \\<eta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. decompose_literal (subst_lit L \\<eta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "let ?t = \"(subst t \\<eta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. decompose_literal (subst_lit L \\<eta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "let ?s = \"(subst s \\<eta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. decompose_literal (subst_lit L \\<eta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "have \"polarity = pos \\<or> polarity = neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polarity = pos \\<or> polarity = neg", "using sign.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = pos \\<Longrightarrow> ?P;\n   ?y = neg \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. polarity = pos \\<or> polarity = neg", "by auto"], ["proof (state)\nthis:\n  polarity = pos \\<or> polarity = neg\n\ngoal (1 subgoal):\n 1. decompose_literal (subst_lit L \\<eta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "then"], ["proof (chain)\npicking this:\n  polarity = pos \\<or> polarity = neg", "show ?thesis"], ["proof (prove)\nusing this:\n  polarity = pos \\<or> polarity = neg\n\ngoal (1 subgoal):\n 1. decompose_literal (subst_lit L \\<eta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<eta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity\n 2. polarity = neg \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<eta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "assume \"polarity = pos\""], ["proof (state)\nthis:\n  polarity = pos\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<eta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity\n 2. polarity = neg \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<eta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "from this and assms(1)"], ["proof (chain)\npicking this:\n  polarity = pos\n  decompose_literal L t s polarity", "have \"L = Pos (Eq t s) \\<or> L = Pos (Eq s t)\""], ["proof (prove)\nusing this:\n  polarity = pos\n  decompose_literal L t s polarity\n\ngoal (1 subgoal):\n 1. L = Pos (Eq t s) \\<or> L = Pos (Eq s t)", "unfolding decompose_literal_def decompose_equation_def"], ["proof (prove)\nusing this:\n  polarity = pos\n  \\<exists>e.\n     polarity = pos \\<and>\n     L = Pos e \\<and> (e = Eq t s \\<or> e = Eq s t) \\<or>\n     polarity = neg \\<and> L = Neg e \\<and> (e = Eq t s \\<or> e = Eq s t)\n\ngoal (1 subgoal):\n 1. L = Pos (Eq t s) \\<or> L = Pos (Eq s t)", "by auto"], ["proof (state)\nthis:\n  L = Pos (Eq t s) \\<or> L = Pos (Eq s t)\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<eta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity\n 2. polarity = neg \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<eta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "from \\<open>L = Pos (Eq t s) \\<or> L = Pos (Eq s t)\\<close>"], ["proof (chain)\npicking this:\n  L = Pos (Eq t s) \\<or> L = Pos (Eq s t)", "have \"?L = Pos (Eq ?t ?s) \\<or> ?L = Pos (Eq ?s ?t)\""], ["proof (prove)\nusing this:\n  L = Pos (Eq t s) \\<or> L = Pos (Eq s t)\n\ngoal (1 subgoal):\n 1. subst_lit L \\<eta> = Pos (Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>)) \\<or>\n    subst_lit L \\<eta> = Pos (Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>))", "by auto"], ["proof (state)\nthis:\n  subst_lit L \\<eta> = Pos (Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>)) \\<or>\n  subst_lit L \\<eta> = Pos (Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>))\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<eta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity\n 2. polarity = neg \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<eta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "from this \\<open>polarity = pos\\<close>"], ["proof (chain)\npicking this:\n  subst_lit L \\<eta> = Pos (Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>)) \\<or>\n  subst_lit L \\<eta> = Pos (Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>))\n  polarity = pos", "show ?thesis"], ["proof (prove)\nusing this:\n  subst_lit L \\<eta> = Pos (Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>)) \\<or>\n  subst_lit L \\<eta> = Pos (Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>))\n  polarity = pos\n\ngoal (1 subgoal):\n 1. decompose_literal (subst_lit L \\<eta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "unfolding decompose_literal_def \n      decompose_equation_def"], ["proof (prove)\nusing this:\n  subst_lit L \\<eta> = Pos (Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>)) \\<or>\n  subst_lit L \\<eta> = Pos (Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>))\n  polarity = pos\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       polarity = pos \\<and>\n       subst_lit L \\<eta> = Pos e \\<and>\n       (e = Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>) \\<or>\n        e = Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>)) \\<or>\n       polarity = neg \\<and>\n       subst_lit L \\<eta> = Neg e \\<and>\n       (e = Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>) \\<or>\n        e = Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>))", "by auto"], ["proof (state)\nthis:\n  decompose_literal (subst_lit L \\<eta>) (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>)\n   polarity\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<eta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<eta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "assume \"polarity = neg\""], ["proof (state)\nthis:\n  polarity = neg\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<eta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "from this and assms(1)"], ["proof (chain)\npicking this:\n  polarity = neg\n  decompose_literal L t s polarity", "have \"L = Neg (Eq t s) \\<or> L = Neg (Eq s t)\""], ["proof (prove)\nusing this:\n  polarity = neg\n  decompose_literal L t s polarity\n\ngoal (1 subgoal):\n 1. L = Neg (Eq t s) \\<or> L = Neg (Eq s t)", "unfolding decompose_literal_def decompose_equation_def"], ["proof (prove)\nusing this:\n  polarity = neg\n  \\<exists>e.\n     polarity = pos \\<and>\n     L = Pos e \\<and> (e = Eq t s \\<or> e = Eq s t) \\<or>\n     polarity = neg \\<and> L = Neg e \\<and> (e = Eq t s \\<or> e = Eq s t)\n\ngoal (1 subgoal):\n 1. L = Neg (Eq t s) \\<or> L = Neg (Eq s t)", "by auto"], ["proof (state)\nthis:\n  L = Neg (Eq t s) \\<or> L = Neg (Eq s t)\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<eta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "from this \\<open>polarity = neg\\<close>"], ["proof (chain)\npicking this:\n  L = Neg (Eq t s) \\<or> L = Neg (Eq s t)\n  polarity = neg", "show ?thesis"], ["proof (prove)\nusing this:\n  L = Neg (Eq t s) \\<or> L = Neg (Eq s t)\n  polarity = neg\n\ngoal (1 subgoal):\n 1. decompose_literal (subst_lit L \\<eta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "unfolding decompose_literal_def \n      decompose_equation_def"], ["proof (prove)\nusing this:\n  L = Neg (Eq t s) \\<or> L = Neg (Eq s t)\n  polarity = neg\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       polarity = pos \\<and>\n       subst_lit L \\<eta> = Pos e \\<and>\n       (e = Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>) \\<or>\n        e = Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>)) \\<or>\n       polarity = neg \\<and>\n       subst_lit L \\<eta> = Neg e \\<and>\n       (e = Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>) \\<or>\n        e = Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>))", "by auto"], ["proof (state)\nthis:\n  decompose_literal (subst_lit L \\<eta>) (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>)\n   polarity\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  decompose_literal (subst_lit L \\<eta>) (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>)\n   polarity\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma substs_preserve_dom_trm:\n  assumes \"dom_trm t C\"\n  shows \"dom_trm (subst t \\<sigma>) (subst_cl C \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "let ?t = \"(subst t \\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "from assms(1)"], ["proof (chain)\npicking this:\n  dom_trm t C", "have \"(\\<exists> L u v p. (L \\<in> C \\<and> (decompose_literal L u v p) \n        \\<and> (( (p = neg \\<and> t = u) \\<or> (t,u) \\<in> trm_ord))))\""], ["proof (prove)\nusing this:\n  dom_trm t C\n\ngoal (1 subgoal):\n 1. \\<exists>L u v p.\n       L \\<in> C \\<and>\n       decompose_literal L u v p \\<and>\n       (p = neg \\<and> t = u \\<or> (t, u) \\<in> trm_ord)", "unfolding dom_trm_def"], ["proof (prove)\nusing this:\n  \\<exists>L u v p.\n     L \\<in> C \\<and>\n     decompose_literal L u v p \\<and>\n     (p = neg \\<and> t = u \\<or> (t, u) \\<in> trm_ord)\n\ngoal (1 subgoal):\n 1. \\<exists>L u v p.\n       L \\<in> C \\<and>\n       decompose_literal L u v p \\<and>\n       (p = neg \\<and> t = u \\<or> (t, u) \\<in> trm_ord)", "by auto"], ["proof (state)\nthis:\n  \\<exists>L u v p.\n     L \\<in> C \\<and>\n     decompose_literal L u v p \\<and>\n     (p = neg \\<and> t = u \\<or> (t, u) \\<in> trm_ord)\n\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>L u v p.\n     L \\<in> C \\<and>\n     decompose_literal L u v p \\<and>\n     (p = neg \\<and> t = u \\<or> (t, u) \\<in> trm_ord)", "obtain L u v p where  \"L \\<in> C\" \n    \"decompose_literal L u v p\" \"(( (p = neg \\<and> t = u) \\<or> (t,u) \\<in> trm_ord))\""], ["proof (prove)\nusing this:\n  \\<exists>L u v p.\n     L \\<in> C \\<and>\n     decompose_literal L u v p \\<and>\n     (p = neg \\<and> t = u \\<or> (t, u) \\<in> trm_ord)\n\ngoal (1 subgoal):\n 1. (\\<And>L u v p.\n        \\<lbrakk>L \\<in> C; decompose_literal L u v p;\n         p = neg \\<and> t = u \\<or> (t, u) \\<in> trm_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dom_trm_def"], ["proof (prove)\nusing this:\n  \\<exists>L u v p.\n     L \\<in> C \\<and>\n     decompose_literal L u v p \\<and>\n     (p = neg \\<and> t = u \\<or> (t, u) \\<in> trm_ord)\n\ngoal (1 subgoal):\n 1. (\\<And>L u v p.\n        \\<lbrakk>L \\<in> C; decompose_literal L u v p;\n         p = neg \\<and> t = u \\<or> (t, u) \\<in> trm_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  L \\<in> C\n  decompose_literal L u v p\n  p = neg \\<and> t = u \\<or> (t, u) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "let ?u = \"(subst u \\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "from \\<open>L \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  L \\<in> C", "have \"(subst_lit L \\<sigma>) \\<in> (subst_cl C \\<sigma>)\""], ["proof (prove)\nusing this:\n  L \\<in> C\n\ngoal (1 subgoal):\n 1. subst_lit L \\<sigma> \\<in> subst_cl C \\<sigma>", "by auto"], ["proof (state)\nthis:\n  subst_lit L \\<sigma> \\<in> subst_cl C \\<sigma>\n\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "from \\<open>decompose_literal L u v p\\<close>"], ["proof (chain)\npicking this:\n  decompose_literal L u v p", "have \"decompose_literal (subst_lit L \\<sigma>) (subst u \\<sigma>) (subst v \\<sigma>) p\""], ["proof (prove)\nusing this:\n  decompose_literal L u v p\n\ngoal (1 subgoal):\n 1. decompose_literal (subst_lit L \\<sigma>) (u \\<lhd> \\<sigma>)\n     (v \\<lhd> \\<sigma>) p", "using substs_preserves_decompose_literal"], ["proof (prove)\nusing this:\n  decompose_literal L u v p\n  decompose_literal ?L ?t ?s ?polarity \\<Longrightarrow>\n  decompose_literal (subst_lit ?L ?\\<eta>) (?t \\<lhd> ?\\<eta>)\n   (?s \\<lhd> ?\\<eta>) ?polarity\n\ngoal (1 subgoal):\n 1. decompose_literal (subst_lit L \\<sigma>) (u \\<lhd> \\<sigma>)\n     (v \\<lhd> \\<sigma>) p", "by metis"], ["proof (state)\nthis:\n  decompose_literal (subst_lit L \\<sigma>) (u \\<lhd> \\<sigma>)\n   (v \\<lhd> \\<sigma>) p\n\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "from \\<open>(( (p = neg \\<and> t = u) \\<or> (t,u) \\<in> trm_ord))\\<close>"], ["proof (chain)\npicking this:\n  p = neg \\<and> t = u \\<or> (t, u) \\<in> trm_ord", "have \"(( (p = neg \\<and> ?t = ?u) \\<or> (?t,?u) \\<in> trm_ord))\""], ["proof (prove)\nusing this:\n  p = neg \\<and> t = u \\<or> (t, u) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. p = neg \\<and> t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<or>\n    (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord", "using trm_ord_subst"], ["proof (prove)\nusing this:\n  p = neg \\<and> t = u \\<or> (t, u) \\<in> trm_ord\n  \\<forall>s x y.\n     (x, y) \\<in> trm_ord \\<longrightarrow>\n     (x \\<lhd> s, y \\<lhd> s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. p = neg \\<and> t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<or>\n    (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  p = neg \\<and> t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<or>\n  (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "from this \\<open>(subst_lit L \\<sigma>) \\<in> (subst_cl C \\<sigma>)\\<close> \n    \\<open>decompose_literal (subst_lit L \\<sigma>) (subst u \\<sigma>) (subst v \\<sigma>) p\\<close>"], ["proof (chain)\npicking this:\n  p = neg \\<and> t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<or>\n  (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n  subst_lit L \\<sigma> \\<in> subst_cl C \\<sigma>\n  decompose_literal (subst_lit L \\<sigma>) (u \\<lhd> \\<sigma>)\n   (v \\<lhd> \\<sigma>) p", "show \"dom_trm (subst t \\<sigma>) (subst_cl C \\<sigma>)\""], ["proof (prove)\nusing this:\n  p = neg \\<and> t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<or>\n  (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n  subst_lit L \\<sigma> \\<in> subst_cl C \\<sigma>\n  decompose_literal (subst_lit L \\<sigma>) (u \\<lhd> \\<sigma>)\n   (v \\<lhd> \\<sigma>) p\n\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "unfolding dom_trm_def"], ["proof (prove)\nusing this:\n  p = neg \\<and> t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<or>\n  (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n  subst_lit L \\<sigma> \\<in> subst_cl C \\<sigma>\n  decompose_literal (subst_lit L \\<sigma>) (u \\<lhd> \\<sigma>)\n   (v \\<lhd> \\<sigma>) p\n\ngoal (1 subgoal):\n 1. \\<exists>L u v p.\n       L \\<in> subst_cl C \\<sigma> \\<and>\n       decompose_literal L u v p \\<and>\n       (p = neg \\<and> t \\<lhd> \\<sigma> = u \\<or>\n        (t \\<lhd> \\<sigma>, u) \\<in> trm_ord)", "by auto"], ["proof (state)\nthis:\n  dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma substs_preserve_well_constrainedness:\n  assumes \"well_constrained C\"\n  shows \"well_constrained (subst_ecl C \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_constrained (subst_ecl C \\<sigma>)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> well_constrained (subst_ecl C \\<sigma>) \\<Longrightarrow> False", "assume \"\\<not>?thesis\""], ["proof (state)\nthis:\n  \\<not> well_constrained (subst_ecl C \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> well_constrained (subst_ecl C \\<sigma>) \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  \\<not> well_constrained (subst_ecl C \\<sigma>)", "obtain y where \"y \\<in> trms_ecl (subst_ecl C \\<sigma>)\"\n    and \"\\<not> dom_trm y (cl_ecl (subst_ecl C \\<sigma>))\""], ["proof (prove)\nusing this:\n  \\<not> well_constrained (subst_ecl C \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> trms_ecl (subst_ecl C \\<sigma>);\n         \\<not> dom_trm y (cl_ecl (subst_ecl C \\<sigma>))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding well_constrained_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>y.\n             y \\<in> trms_ecl (subst_ecl C \\<sigma>) \\<longrightarrow>\n             dom_trm y (cl_ecl (subst_ecl C \\<sigma>)))\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> trms_ecl (subst_ecl C \\<sigma>);\n         \\<not> dom_trm y (cl_ecl (subst_ecl C \\<sigma>))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> trms_ecl (subst_ecl C \\<sigma>)\n  \\<not> dom_trm y (cl_ecl (subst_ecl C \\<sigma>))\n\ngoal (1 subgoal):\n 1. \\<not> well_constrained (subst_ecl C \\<sigma>) \\<Longrightarrow> False", "obtain Cl_C T where \"C = (Ecl Cl_C T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Cl_C T.\n        C = Ecl Cl_C T \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \"eclause.exhaust\""], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = Ecl x1 x2 \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>Cl_C T.\n        C = Ecl Cl_C T \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C = Ecl Cl_C T\n\ngoal (1 subgoal):\n 1. \\<not> well_constrained (subst_ecl C \\<sigma>) \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  C = Ecl Cl_C T", "have \"(subst_ecl C \\<sigma>) \n    = (Ecl (subst_cl Cl_C \\<sigma>) (subst_set T \\<sigma>))\""], ["proof (prove)\nusing this:\n  C = Ecl Cl_C T\n\ngoal (1 subgoal):\n 1. subst_ecl C \\<sigma> =\n    Ecl (subst_cl Cl_C \\<sigma>) (subst_set T \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  subst_ecl C \\<sigma> = Ecl (subst_cl Cl_C \\<sigma>) (subst_set T \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> well_constrained (subst_ecl C \\<sigma>) \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  subst_ecl C \\<sigma> = Ecl (subst_cl Cl_C \\<sigma>) (subst_set T \\<sigma>)", "have \"(cl_ecl (subst_ecl C \\<sigma>) = (subst_cl Cl_C \\<sigma>))\" \n    and \"trms_ecl (subst_ecl C \\<sigma>) = (subst_set T \\<sigma>)\""], ["proof (prove)\nusing this:\n  subst_ecl C \\<sigma> = Ecl (subst_cl Cl_C \\<sigma>) (subst_set T \\<sigma>)\n\ngoal (1 subgoal):\n 1. cl_ecl (subst_ecl C \\<sigma>) = subst_cl Cl_C \\<sigma> &&&\n    trms_ecl (subst_ecl C \\<sigma>) = subst_set T \\<sigma>", "by auto"], ["proof (state)\nthis:\n  cl_ecl (subst_ecl C \\<sigma>) = subst_cl Cl_C \\<sigma>\n  trms_ecl (subst_ecl C \\<sigma>) = subst_set T \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> well_constrained (subst_ecl C \\<sigma>) \\<Longrightarrow> False", "from \\<open>(cl_ecl (subst_ecl C \\<sigma>) = (subst_cl Cl_C \\<sigma>))\\<close> \n    \\<open>C = (Ecl Cl_C T)\\<close>"], ["proof (chain)\npicking this:\n  cl_ecl (subst_ecl C \\<sigma>) = subst_cl Cl_C \\<sigma>\n  C = Ecl Cl_C T", "have \"(cl_ecl (subst_ecl C \\<sigma>) = (subst_cl (cl_ecl C) \\<sigma>))\""], ["proof (prove)\nusing this:\n  cl_ecl (subst_ecl C \\<sigma>) = subst_cl Cl_C \\<sigma>\n  C = Ecl Cl_C T\n\ngoal (1 subgoal):\n 1. cl_ecl (subst_ecl C \\<sigma>) = subst_cl (cl_ecl C) \\<sigma>", "by auto"], ["proof (state)\nthis:\n  cl_ecl (subst_ecl C \\<sigma>) = subst_cl (cl_ecl C) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> well_constrained (subst_ecl C \\<sigma>) \\<Longrightarrow> False", "from \\<open>y \\<in> trms_ecl (subst_ecl C \\<sigma>)\\<close> \\<open>C = (Ecl Cl_C T)\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> trms_ecl (subst_ecl C \\<sigma>)\n  C = Ecl Cl_C T", "obtain z where \"z \\<in> T\" and \"y = (subst z \\<sigma>)\""], ["proof (prove)\nusing this:\n  y \\<in> trms_ecl (subst_ecl C \\<sigma>)\n  C = Ecl Cl_C T\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> T; y = z \\<lhd> \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z \\<in> T\n  y = z \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> well_constrained (subst_ecl C \\<sigma>) \\<Longrightarrow> False", "from \\<open>z \\<in> T\\<close> assms(1) \\<open>C = (Ecl Cl_C T)\\<close>"], ["proof (chain)\npicking this:\n  z \\<in> T\n  well_constrained C\n  C = Ecl Cl_C T", "have \"dom_trm z (cl_ecl C)\""], ["proof (prove)\nusing this:\n  z \\<in> T\n  well_constrained C\n  C = Ecl Cl_C T\n\ngoal (1 subgoal):\n 1. dom_trm z (cl_ecl C)", "unfolding well_constrained_def"], ["proof (prove)\nusing this:\n  z \\<in> T\n  \\<forall>y. y \\<in> trms_ecl C \\<longrightarrow> dom_trm y (cl_ecl C)\n  C = Ecl Cl_C T\n\ngoal (1 subgoal):\n 1. dom_trm z (cl_ecl C)", "by auto"], ["proof (state)\nthis:\n  dom_trm z (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<not> well_constrained (subst_ecl C \\<sigma>) \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  dom_trm z (cl_ecl C)", "have \"dom_trm (subst z \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\""], ["proof (prove)\nusing this:\n  dom_trm z (cl_ecl C)\n\ngoal (1 subgoal):\n 1. dom_trm (z \\<lhd> \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)", "using substs_preserve_dom_trm"], ["proof (prove)\nusing this:\n  dom_trm z (cl_ecl C)\n  dom_trm ?t ?C \\<Longrightarrow>\n  dom_trm (?t \\<lhd> ?\\<sigma>) (subst_cl ?C ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. dom_trm (z \\<lhd> \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  dom_trm (z \\<lhd> \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> well_constrained (subst_ecl C \\<sigma>) \\<Longrightarrow> False", "from this \\<open>y = (subst z \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  dom_trm (z \\<lhd> \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n  y = z \\<lhd> \\<sigma>", "have \"dom_trm y (subst_cl (cl_ecl C) \\<sigma>)\""], ["proof (prove)\nusing this:\n  dom_trm (z \\<lhd> \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n  y = z \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. dom_trm y (subst_cl (cl_ecl C) \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  dom_trm y (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> well_constrained (subst_ecl C \\<sigma>) \\<Longrightarrow> False", "from this \\<open>(cl_ecl (subst_ecl C \\<sigma>) = (subst_cl (cl_ecl C) \\<sigma>))\\<close>\n    \\<open>\\<not> dom_trm y (cl_ecl (subst_ecl C \\<sigma>))\\<close>"], ["proof (chain)\npicking this:\n  dom_trm y (subst_cl (cl_ecl C) \\<sigma>)\n  cl_ecl (subst_ecl C \\<sigma>) = subst_cl (cl_ecl C) \\<sigma>\n  \\<not> dom_trm y (cl_ecl (subst_ecl C \\<sigma>))", "show False"], ["proof (prove)\nusing this:\n  dom_trm y (subst_cl (cl_ecl C) \\<sigma>)\n  cl_ecl (subst_ecl C \\<sigma>) = subst_cl (cl_ecl C) \\<sigma>\n  \\<not> dom_trm y (cl_ecl (subst_ecl C \\<sigma>))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ck_trms_sound:\n  assumes \"T = get_trms D (dom_trms C E) k\"\n  shows \"T \\<subseteq> (dom_trms C E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T \\<subseteq> dom_trms C E", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> T \\<subseteq> dom_trms C E\n 2. \\<not> ?P \\<Longrightarrow> T \\<subseteq> dom_trms C E", "assume \"k = FirstOrder\""], ["proof (state)\nthis:\n  k = FirstOrder\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> T \\<subseteq> dom_trms C E\n 2. \\<not> ?P \\<Longrightarrow> T \\<subseteq> dom_trms C E", "from this and assms"], ["proof (chain)\npicking this:\n  k = FirstOrder\n  T = get_trms D (dom_trms C E) k", "have \"T = filter_trms D (dom_trms C E)\""], ["proof (prove)\nusing this:\n  k = FirstOrder\n  T = get_trms D (dom_trms C E) k\n\ngoal (1 subgoal):\n 1. T = filter_trms D (dom_trms C E)", "unfolding get_trms_def"], ["proof (prove)\nusing this:\n  k = FirstOrder\n  T =\n  (if k = FirstOrder then filter_trms D (dom_trms C E) else dom_trms C E)\n\ngoal (1 subgoal):\n 1. T = filter_trms D (dom_trms C E)", "by auto"], ["proof (state)\nthis:\n  T = filter_trms D (dom_trms C E)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> T \\<subseteq> dom_trms C E\n 2. \\<not> ?P \\<Longrightarrow> T \\<subseteq> dom_trms C E", "from this"], ["proof (chain)\npicking this:\n  T = filter_trms D (dom_trms C E)", "show ?thesis"], ["proof (prove)\nusing this:\n  T = filter_trms D (dom_trms C E)\n\ngoal (1 subgoal):\n 1. T \\<subseteq> dom_trms C E", "using filter_trms_inclusion"], ["proof (prove)\nusing this:\n  T = filter_trms D (dom_trms C E)\n  filter_trms ?C ?E \\<subseteq> ?E\n\ngoal (1 subgoal):\n 1. T \\<subseteq> dom_trms C E", "by blast"], ["proof (state)\nthis:\n  T \\<subseteq> dom_trms C E\n\ngoal (1 subgoal):\n 1. k \\<noteq> FirstOrder \\<Longrightarrow> T \\<subseteq> dom_trms C E", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> FirstOrder \\<Longrightarrow> T \\<subseteq> dom_trms C E", "assume \"k \\<noteq> FirstOrder\""], ["proof (state)\nthis:\n  k \\<noteq> FirstOrder\n\ngoal (1 subgoal):\n 1. k \\<noteq> FirstOrder \\<Longrightarrow> T \\<subseteq> dom_trms C E", "from this and assms"], ["proof (chain)\npicking this:\n  k \\<noteq> FirstOrder\n  T = get_trms D (dom_trms C E) k", "have \"T = (dom_trms C E)\""], ["proof (prove)\nusing this:\n  k \\<noteq> FirstOrder\n  T = get_trms D (dom_trms C E) k\n\ngoal (1 subgoal):\n 1. T = dom_trms C E", "unfolding get_trms_def"], ["proof (prove)\nusing this:\n  k \\<noteq> FirstOrder\n  T =\n  (if k = FirstOrder then filter_trms D (dom_trms C E) else dom_trms C E)\n\ngoal (1 subgoal):\n 1. T = dom_trms C E", "by auto"], ["proof (state)\nthis:\n  T = dom_trms C E\n\ngoal (1 subgoal):\n 1. k \\<noteq> FirstOrder \\<Longrightarrow> T \\<subseteq> dom_trms C E", "from this"], ["proof (chain)\npicking this:\n  T = dom_trms C E", "show ?thesis"], ["proof (prove)\nusing this:\n  T = dom_trms C E\n\ngoal (1 subgoal):\n 1. T \\<subseteq> dom_trms C E", "using filter_trms_inclusion"], ["proof (prove)\nusing this:\n  T = dom_trms C E\n  filter_trms ?C ?E \\<subseteq> ?E\n\ngoal (1 subgoal):\n 1. T \\<subseteq> dom_trms C E", "by blast"], ["proof (state)\nthis:\n  T \\<subseteq> dom_trms C E\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma derivable_clauses_are_well_constrained:\n  assumes \"derivable C P S \\<sigma> k C'\"\n  shows \"well_constrained C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. well_constrained C", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> well_constrained C \\<Longrightarrow> False", "assume hyp: \"\\<not> well_constrained C\""], ["proof (state)\nthis:\n  \\<not> well_constrained C\n\ngoal (1 subgoal):\n 1. \\<not> well_constrained C \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> well_constrained C", "obtain y where \"y \\<in> trms_ecl C\" and \"\\<not> dom_trm y (cl_ecl C)\""], ["proof (prove)\nusing this:\n  \\<not> well_constrained C\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> trms_ecl C; \\<not> dom_trm y (cl_ecl C)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding well_constrained_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>y.\n             y \\<in> trms_ecl C \\<longrightarrow> dom_trm y (cl_ecl C))\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> trms_ecl C; \\<not> dom_trm y (cl_ecl C)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> trms_ecl C\n  \\<not> dom_trm y (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<not> well_constrained C \\<Longrightarrow> False", "have not_sup: \"\\<not> (\\<exists>P1 P2. (P1 \\<in> S \\<and> P2 \\<in> S \\<and> superposition P1 P2 C \\<sigma> k C'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>P1 P2.\n       P1 \\<in> S \\<and>\n       P2 \\<in> S \\<and> superposition P1 P2 C \\<sigma> k C'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> S \\<and>\n       P2 \\<in> S \\<and>\n       superposition P1 P2 C \\<sigma> k C' \\<Longrightarrow>\n    False", "assume \"(\\<exists>P1 P2. (P1 \\<in> S \\<and> P2 \\<in> S \\<and> superposition P1 P2 C \\<sigma> k C'))\""], ["proof (state)\nthis:\n  \\<exists>P1 P2.\n     P1 \\<in> S \\<and> P2 \\<in> S \\<and> superposition P1 P2 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> S \\<and>\n       P2 \\<in> S \\<and>\n       superposition P1 P2 C \\<sigma> k C' \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>P1 P2.\n     P1 \\<in> S \\<and> P2 \\<in> S \\<and> superposition P1 P2 C \\<sigma> k C'", "obtain P1 P2 where \"P1 \\<in> S\" \"P2 \\<in> S\" \"superposition P1 P2 C \\<sigma> k C'\""], ["proof (prove)\nusing this:\n  \\<exists>P1 P2.\n     P1 \\<in> S \\<and> P2 \\<in> S \\<and> superposition P1 P2 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2.\n        \\<lbrakk>P1 \\<in> S; P2 \\<in> S;\n         superposition P1 P2 C \\<sigma> k C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> S\n  P2 \\<in> S\n  superposition P1 P2 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> S \\<and>\n       P2 \\<in> S \\<and>\n       superposition P1 P2 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from \\<open>superposition P1 P2 C \\<sigma> k C'\\<close>"], ["proof (chain)\npicking this:\n  superposition P1 P2 C \\<sigma> k C'", "obtain Cl_C T E\n      where \n        \"T = (get_trms Cl_C (dom_trms Cl_C (subst_set E \\<sigma>)) k)\"\n        \"Cl_C = (subst_cl C' \\<sigma>)\"\n        \"C = (Ecl Cl_C T)\""], ["proof (prove)\nusing this:\n  superposition P1 P2 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. (\\<And>T Cl_C E.\n        \\<lbrakk>T = get_trms Cl_C (dom_trms Cl_C (subst_set E \\<sigma>)) k;\n         Cl_C = subst_cl C' \\<sigma>; C = Ecl Cl_C T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding superposition_def"], ["proof (prove)\nusing this:\n  \\<exists>L t s u v M p Cl_P1 Cl_P2 Cl_C polarity t' u' L' trms_C.\n     L \\<in> Cl_P1 \\<and>\n     M \\<in> Cl_P2 \\<and>\n     eligible_literal L P1 \\<sigma> \\<and>\n     eligible_literal M P2 \\<sigma> \\<and>\n     variable_disjoint P1 P2 \\<and>\n     Cl_P1 = cl_ecl P1 \\<and>\n     Cl_P2 = cl_ecl P2 \\<and>\n     \\<not> is_a_variable u' \\<and>\n     allowed_redex u' P1 \\<sigma> \\<and>\n     trms_C =\n     get_trms Cl_C\n      (dom_trms Cl_C\n        (subst_set\n          (trms_ecl P1 \\<union> trms_ecl P2 \\<union>\n           {r. \\<exists>q. (q, p) \\<in> pos_ord P1 t \\<and> subterm t q r})\n          \\<sigma>))\n      k \\<and>\n     C = Ecl Cl_C trms_C \\<and>\n     orient_lit_inst M u v pos \\<sigma> \\<and>\n     orient_lit_inst L t s polarity \\<sigma> \\<and>\n     u \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma> \\<and>\n     subterm t p u' \\<and>\n     ck_unifier u' u \\<sigma> k \\<and>\n     replace_subterm t p v t' \\<and>\n     (k = FirstOrder \\<or>\n      (subst_lit M \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord) \\<and>\n     (k = FirstOrder \\<or> strictly_maximal_literal P2 M \\<sigma>) \\<and>\n     L' = mk_lit polarity (Eq t' s) \\<and>\n     Cl_C = subst_cl C' \\<sigma> \\<and>\n     C' = Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})\n\ngoal (1 subgoal):\n 1. (\\<And>T Cl_C E.\n        \\<lbrakk>T = get_trms Cl_C (dom_trms Cl_C (subst_set E \\<sigma>)) k;\n         Cl_C = subst_cl C' \\<sigma>; C = Ecl Cl_C T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  T = get_trms Cl_C (dom_trms Cl_C (subst_set E \\<sigma>)) k\n  Cl_C = subst_cl C' \\<sigma>\n  C = Ecl Cl_C T\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> S \\<and>\n       P2 \\<in> S \\<and>\n       superposition P1 P2 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from \\<open>T = (get_trms Cl_C (dom_trms Cl_C (subst_set E \\<sigma>)) k)\\<close>"], ["proof (chain)\npicking this:\n  T = get_trms Cl_C (dom_trms Cl_C (subst_set E \\<sigma>)) k", "have \"T \\<subseteq>(dom_trms Cl_C (subst_set E \\<sigma>))\""], ["proof (prove)\nusing this:\n  T = get_trms Cl_C (dom_trms Cl_C (subst_set E \\<sigma>)) k\n\ngoal (1 subgoal):\n 1. T \\<subseteq> dom_trms Cl_C (subst_set E \\<sigma>)", "using ck_trms_sound"], ["proof (prove)\nusing this:\n  T = get_trms Cl_C (dom_trms Cl_C (subst_set E \\<sigma>)) k\n  ?T = get_trms ?D (dom_trms ?C ?E) ?k \\<Longrightarrow>\n  ?T \\<subseteq> dom_trms ?C ?E\n\ngoal (1 subgoal):\n 1. T \\<subseteq> dom_trms Cl_C (subst_set E \\<sigma>)", "by metis"], ["proof (state)\nthis:\n  T \\<subseteq> dom_trms Cl_C (subst_set E \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> S \\<and>\n       P2 \\<in> S \\<and>\n       superposition P1 P2 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from this and \\<open>y \\<in> trms_ecl C\\<close> and \\<open>C = (Ecl Cl_C T)\\<close>"], ["proof (chain)\npicking this:\n  T \\<subseteq> dom_trms Cl_C (subst_set E \\<sigma>)\n  y \\<in> trms_ecl C\n  C = Ecl Cl_C T", "have \n      \"y \\<in> (dom_trms (cl_ecl C) (subst_set E \\<sigma>))\""], ["proof (prove)\nusing this:\n  T \\<subseteq> dom_trms Cl_C (subst_set E \\<sigma>)\n  y \\<in> trms_ecl C\n  C = Ecl Cl_C T\n\ngoal (1 subgoal):\n 1. y \\<in> dom_trms (cl_ecl C) (subst_set E \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  y \\<in> dom_trms (cl_ecl C) (subst_set E \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> S \\<and>\n       P2 \\<in> S \\<and>\n       superposition P1 P2 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from this and \\<open>\\<not> dom_trm y (cl_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> dom_trms (cl_ecl C) (subst_set E \\<sigma>)\n  \\<not> dom_trm y (cl_ecl C)", "show False"], ["proof (prove)\nusing this:\n  y \\<in> dom_trms (cl_ecl C) (subst_set E \\<sigma>)\n  \\<not> dom_trm y (cl_ecl C)\n\ngoal (1 subgoal):\n 1. False", "unfolding dom_trms_def"], ["proof (prove)\nusing this:\n  y \\<in> {x \\<in> subst_set E \\<sigma>. dom_trm x (cl_ecl C)}\n  \\<not> dom_trm y (cl_ecl C)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>P1 P2.\n     P1 \\<in> S \\<and> P2 \\<in> S \\<and> superposition P1 P2 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<not> well_constrained C \\<Longrightarrow> False", "have not_ref: \"\\<not> (\\<exists>P1. (P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>P1. P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "assume \"(\\<exists>P1. (P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C'))\""], ["proof (state)\nthis:\n  \\<exists>P1. P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>P1. P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C'", "obtain P1 where \"P1 \\<in> S\" \"reflexion P1 C \\<sigma> k C'\""], ["proof (prove)\nusing this:\n  \\<exists>P1. P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. (\\<And>P1.\n        \\<lbrakk>P1 \\<in> S; reflexion P1 C \\<sigma> k C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> S\n  reflexion P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from \\<open>reflexion P1 C \\<sigma> k C'\\<close>"], ["proof (chain)\npicking this:\n  reflexion P1 C \\<sigma> k C'", "obtain T Cl_C E where\n        \"T = (get_trms Cl_C (dom_trms Cl_C (subst_set E \\<sigma>)) k)\"\n        \"Cl_C = (subst_cl C' \\<sigma>)\"\n        \"C = (Ecl Cl_C T)\""], ["proof (prove)\nusing this:\n  reflexion P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. (\\<And>T Cl_C E.\n        \\<lbrakk>T = get_trms Cl_C (dom_trms Cl_C (subst_set E \\<sigma>)) k;\n         Cl_C = subst_cl C' \\<sigma>; C = Ecl Cl_C T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding reflexion_def"], ["proof (prove)\nusing this:\n  \\<exists>L1 t s Cl_P Cl_C trms_C.\n     eligible_literal L1 P1 \\<sigma> \\<and>\n     L1 \\<in> cl_ecl P1 \\<and>\n     Cl_C = cl_ecl C \\<and>\n     Cl_P = cl_ecl P1 \\<and>\n     orient_lit_inst L1 t s neg \\<sigma> \\<and>\n     ck_unifier t s \\<sigma> k \\<and>\n     C = Ecl Cl_C trms_C \\<and>\n     trms_C =\n     get_trms Cl_C\n      (dom_trms Cl_C (subst_set (trms_ecl P1 \\<union> {t}) \\<sigma>))\n      k \\<and>\n     Cl_C = subst_cl C' \\<sigma> \\<and> C' = Cl_P - {L1}\n\ngoal (1 subgoal):\n 1. (\\<And>T Cl_C E.\n        \\<lbrakk>T = get_trms Cl_C (dom_trms Cl_C (subst_set E \\<sigma>)) k;\n         Cl_C = subst_cl C' \\<sigma>; C = Ecl Cl_C T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  T = get_trms Cl_C (dom_trms Cl_C (subst_set E \\<sigma>)) k\n  Cl_C = subst_cl C' \\<sigma>\n  C = Ecl Cl_C T\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from \\<open>T = (get_trms Cl_C (dom_trms Cl_C (subst_set E \\<sigma>)) k)\\<close>"], ["proof (chain)\npicking this:\n  T = get_trms Cl_C (dom_trms Cl_C (subst_set E \\<sigma>)) k", "have \"T \\<subseteq>(dom_trms Cl_C (subst_set E \\<sigma>))\""], ["proof (prove)\nusing this:\n  T = get_trms Cl_C (dom_trms Cl_C (subst_set E \\<sigma>)) k\n\ngoal (1 subgoal):\n 1. T \\<subseteq> dom_trms Cl_C (subst_set E \\<sigma>)", "using ck_trms_sound"], ["proof (prove)\nusing this:\n  T = get_trms Cl_C (dom_trms Cl_C (subst_set E \\<sigma>)) k\n  ?T = get_trms ?D (dom_trms ?C ?E) ?k \\<Longrightarrow>\n  ?T \\<subseteq> dom_trms ?C ?E\n\ngoal (1 subgoal):\n 1. T \\<subseteq> dom_trms Cl_C (subst_set E \\<sigma>)", "by metis"], ["proof (state)\nthis:\n  T \\<subseteq> dom_trms Cl_C (subst_set E \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from this and \\<open>y \\<in> trms_ecl C\\<close> and \\<open>C = (Ecl Cl_C T)\\<close>"], ["proof (chain)\npicking this:\n  T \\<subseteq> dom_trms Cl_C (subst_set E \\<sigma>)\n  y \\<in> trms_ecl C\n  C = Ecl Cl_C T", "have \n      \"y \\<in> (dom_trms (cl_ecl C) (subst_set E \\<sigma>))\""], ["proof (prove)\nusing this:\n  T \\<subseteq> dom_trms Cl_C (subst_set E \\<sigma>)\n  y \\<in> trms_ecl C\n  C = Ecl Cl_C T\n\ngoal (1 subgoal):\n 1. y \\<in> dom_trms (cl_ecl C) (subst_set E \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  y \\<in> dom_trms (cl_ecl C) (subst_set E \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from this and \\<open>\\<not> dom_trm y (cl_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> dom_trms (cl_ecl C) (subst_set E \\<sigma>)\n  \\<not> dom_trm y (cl_ecl C)", "show False"], ["proof (prove)\nusing this:\n  y \\<in> dom_trms (cl_ecl C) (subst_set E \\<sigma>)\n  \\<not> dom_trm y (cl_ecl C)\n\ngoal (1 subgoal):\n 1. False", "unfolding dom_trms_def"], ["proof (prove)\nusing this:\n  y \\<in> {x \\<in> subst_set E \\<sigma>. dom_trm x (cl_ecl C)}\n  \\<not> dom_trm y (cl_ecl C)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>P1. P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<not> well_constrained C \\<Longrightarrow> False", "have not_fact: \"\\<not> (\\<exists>P1. (P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>P1. P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "assume \"(\\<exists>P1. (P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C'))\""], ["proof (state)\nthis:\n  \\<exists>P1. P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>P1. P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C'", "obtain P1 where \"P1 \\<in> S\" \"factorization P1 C \\<sigma> k C'\""], ["proof (prove)\nusing this:\n  \\<exists>P1. P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. (\\<And>P1.\n        \\<lbrakk>P1 \\<in> S; factorization P1 C \\<sigma> k C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> S\n  factorization P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from \\<open>factorization P1 C \\<sigma> k C'\\<close>"], ["proof (chain)\npicking this:\n  factorization P1 C \\<sigma> k C'", "obtain T Cl_C E where\n        \"T = (get_trms Cl_C (dom_trms Cl_C (subst_set E \\<sigma>)) k)\"\n        \"Cl_C = (subst_cl C' \\<sigma>)\"\n        \"C = (Ecl Cl_C T)\""], ["proof (prove)\nusing this:\n  factorization P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. (\\<And>T Cl_C E.\n        \\<lbrakk>T = get_trms Cl_C (dom_trms Cl_C (subst_set E \\<sigma>)) k;\n         Cl_C = subst_cl C' \\<sigma>; C = Ecl Cl_C T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding factorization_def"], ["proof (prove)\nusing this:\n  \\<exists>L1 L2 L' t s u v Cl_P Cl_C trms_C.\n     eligible_literal L1 P1 \\<sigma> \\<and>\n     L1 \\<in> cl_ecl P1 \\<and>\n     L2 \\<in> cl_ecl P1 - {L1} \\<and>\n     Cl_C = cl_ecl C \\<and>\n     Cl_P = cl_ecl P1 \\<and>\n     orient_lit_inst L1 t s pos \\<sigma> \\<and>\n     orient_lit_inst L2 u v pos \\<sigma> \\<and>\n     t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma> \\<and>\n     t \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma> \\<and>\n     ck_unifier t u \\<sigma> k \\<and>\n     L' = Neg (Eq s v) \\<and>\n     (C = Ecl Cl_C trms_C \\<and>\n      trms_C =\n      get_trms Cl_C\n       (dom_trms Cl_C\n         (subst_set (trms_ecl P1 \\<union> proper_subterms_of t) \\<sigma>))\n       k) \\<and>\n     Cl_C = subst_cl C' \\<sigma> \\<and> C' = Cl_P - {L2} \\<union> {L'}\n\ngoal (1 subgoal):\n 1. (\\<And>T Cl_C E.\n        \\<lbrakk>T = get_trms Cl_C (dom_trms Cl_C (subst_set E \\<sigma>)) k;\n         Cl_C = subst_cl C' \\<sigma>; C = Ecl Cl_C T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  T = get_trms Cl_C (dom_trms Cl_C (subst_set E \\<sigma>)) k\n  Cl_C = subst_cl C' \\<sigma>\n  C = Ecl Cl_C T\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from \\<open>T = (get_trms Cl_C (dom_trms Cl_C (subst_set E \\<sigma>)) k)\\<close>"], ["proof (chain)\npicking this:\n  T = get_trms Cl_C (dom_trms Cl_C (subst_set E \\<sigma>)) k", "have \"T \\<subseteq>(dom_trms Cl_C (subst_set E \\<sigma>))\""], ["proof (prove)\nusing this:\n  T = get_trms Cl_C (dom_trms Cl_C (subst_set E \\<sigma>)) k\n\ngoal (1 subgoal):\n 1. T \\<subseteq> dom_trms Cl_C (subst_set E \\<sigma>)", "using ck_trms_sound"], ["proof (prove)\nusing this:\n  T = get_trms Cl_C (dom_trms Cl_C (subst_set E \\<sigma>)) k\n  ?T = get_trms ?D (dom_trms ?C ?E) ?k \\<Longrightarrow>\n  ?T \\<subseteq> dom_trms ?C ?E\n\ngoal (1 subgoal):\n 1. T \\<subseteq> dom_trms Cl_C (subst_set E \\<sigma>)", "by metis"], ["proof (state)\nthis:\n  T \\<subseteq> dom_trms Cl_C (subst_set E \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from this and \\<open>y \\<in> trms_ecl C\\<close> and \\<open>C = (Ecl Cl_C T)\\<close>"], ["proof (chain)\npicking this:\n  T \\<subseteq> dom_trms Cl_C (subst_set E \\<sigma>)\n  y \\<in> trms_ecl C\n  C = Ecl Cl_C T", "have \n      \"y \\<in> (dom_trms (cl_ecl C) (subst_set E \\<sigma>))\""], ["proof (prove)\nusing this:\n  T \\<subseteq> dom_trms Cl_C (subst_set E \\<sigma>)\n  y \\<in> trms_ecl C\n  C = Ecl Cl_C T\n\ngoal (1 subgoal):\n 1. y \\<in> dom_trms (cl_ecl C) (subst_set E \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  y \\<in> dom_trms (cl_ecl C) (subst_set E \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from this and \\<open>\\<not> dom_trm y (cl_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> dom_trms (cl_ecl C) (subst_set E \\<sigma>)\n  \\<not> dom_trm y (cl_ecl C)", "show False"], ["proof (prove)\nusing this:\n  y \\<in> dom_trms (cl_ecl C) (subst_set E \\<sigma>)\n  \\<not> dom_trm y (cl_ecl C)\n\ngoal (1 subgoal):\n 1. False", "unfolding dom_trms_def"], ["proof (prove)\nusing this:\n  y \\<in> {x \\<in> subst_set E \\<sigma>. dom_trm x (cl_ecl C)}\n  \\<not> dom_trm y (cl_ecl C)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>P1. P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<not> well_constrained C \\<Longrightarrow> False", "from not_sup not_ref not_fact and assms(1)"], ["proof (chain)\npicking this:\n  \\<nexists>P1 P2.\n     P1 \\<in> S \\<and> P2 \\<in> S \\<and> superposition P1 P2 C \\<sigma> k C'\n  \\<nexists>P1. P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C'\n  \\<nexists>P1. P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C'\n  derivable C P S \\<sigma> k C'", "show False"], ["proof (prove)\nusing this:\n  \\<nexists>P1 P2.\n     P1 \\<in> S \\<and> P2 \\<in> S \\<and> superposition P1 P2 C \\<sigma> k C'\n  \\<nexists>P1. P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C'\n  \\<nexists>P1. P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C'\n  derivable C P S \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. False", "unfolding derivable_def"], ["proof (prove)\nusing this:\n  \\<nexists>P1 P2.\n     P1 \\<in> S \\<and> P2 \\<in> S \\<and> superposition P1 P2 C \\<sigma> k C'\n  \\<nexists>P1. P1 \\<in> S \\<and> reflexion P1 C \\<sigma> k C'\n  \\<nexists>P1. P1 \\<in> S \\<and> factorization P1 C \\<sigma> k C'\n  (\\<exists>P1 P2.\n      P1 \\<in> S \\<and>\n      P2 \\<in> S \\<and>\n      P = {P1, P2} \\<and> superposition P1 P2 C \\<sigma> k C') \\<or>\n  (\\<exists>P1.\n      P1 \\<in> S \\<and>\n      P = {P1} \\<and> factorization P1 C \\<sigma> k C') \\<or>\n  (\\<exists>P1.\n      P1 \\<in> S \\<and> P = {P1} \\<and> reflexion P1 C \\<sigma> k C')\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma derivable_clauses_are_entailed:\n  assumes \"derivable C P S \\<sigma> k C'\"\n  assumes \"validate_clause_set I (cl_ecl ` P)\"\n  assumes \"fo_interpretation I\"\n  assumes \"\\<forall>x \\<in> P. (finite (cl_ecl x))\"\n  shows \"validate_clause I (cl_ecl C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. validate_clause I (cl_ecl C)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> validate_clause I (cl_ecl C) \\<Longrightarrow> False", "assume \"\\<not>validate_clause I (cl_ecl C)\""], ["proof (state)\nthis:\n  \\<not> validate_clause I (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause I (cl_ecl C) \\<Longrightarrow> False", "have not_sup: \"\\<not> (\\<exists>P1 P2. (P1 \\<in> S \\<and> P2 \\<in> S \\<and> P = { P1, P2 } \\<and> superposition P1 P2 C \\<sigma> k C'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>P1 P2.\n       P1 \\<in> S \\<and>\n       P2 \\<in> S \\<and>\n       P = {P1, P2} \\<and> superposition P1 P2 C \\<sigma> k C'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> S \\<and>\n       P2 \\<in> S \\<and>\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> k C' \\<Longrightarrow>\n    False", "assume \"(\\<exists>P1 P2. (P1 \\<in> S \\<and> P2 \\<in> S \\<and> P = { P1, P2 } \\<and> superposition P1 P2 C \\<sigma> k C'))\""], ["proof (state)\nthis:\n  \\<exists>P1 P2.\n     P1 \\<in> S \\<and>\n     P2 \\<in> S \\<and>\n     P = {P1, P2} \\<and> superposition P1 P2 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> S \\<and>\n       P2 \\<in> S \\<and>\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<exists>P1 P2.\n     P1 \\<in> S \\<and>\n     P2 \\<in> S \\<and>\n     P = {P1, P2} \\<and> superposition P1 P2 C \\<sigma> k C'", "obtain P1 P2 where \"P1 \\<in> P\" \"P2 \\<in> P\" and \"superposition P1 P2 C \\<sigma> k C'\""], ["proof (prove)\nusing this:\n  \\<exists>P1 P2.\n     P1 \\<in> S \\<and>\n     P2 \\<in> S \\<and>\n     P = {P1, P2} \\<and> superposition P1 P2 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2.\n        \\<lbrakk>P1 \\<in> P; P2 \\<in> P;\n         superposition P1 P2 C \\<sigma> k C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> P\n  P2 \\<in> P\n  superposition P1 P2 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> S \\<and>\n       P2 \\<in> S \\<and>\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from \\<open>P1 \\<in> P\\<close> and assms(2)"], ["proof (chain)\npicking this:\n  P1 \\<in> P\n  validate_clause_set I (cl_ecl ` P)", "have \"validate_clause I (cl_ecl P1)\""], ["proof (prove)\nusing this:\n  P1 \\<in> P\n  validate_clause_set I (cl_ecl ` P)\n\ngoal (1 subgoal):\n 1. validate_clause I (cl_ecl P1)", "by auto"], ["proof (state)\nthis:\n  validate_clause I (cl_ecl P1)\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> S \\<and>\n       P2 \\<in> S \\<and>\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from \\<open>P2 \\<in> P\\<close> and assms(2)"], ["proof (chain)\npicking this:\n  P2 \\<in> P\n  validate_clause_set I (cl_ecl ` P)", "have \"validate_clause I (cl_ecl P2)\""], ["proof (prove)\nusing this:\n  P2 \\<in> P\n  validate_clause_set I (cl_ecl ` P)\n\ngoal (1 subgoal):\n 1. validate_clause I (cl_ecl P2)", "by auto"], ["proof (state)\nthis:\n  validate_clause I (cl_ecl P2)\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> S \\<and>\n       P2 \\<in> S \\<and>\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from assms(4) and \\<open>P1 \\<in> P\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>P. finite (cl_ecl x)\n  P1 \\<in> P", "have \"finite (cl_ecl P1)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>P. finite (cl_ecl x)\n  P1 \\<in> P\n\ngoal (1 subgoal):\n 1. finite (cl_ecl P1)", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl P1)\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> S \\<and>\n       P2 \\<in> S \\<and>\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from assms(4) and \\<open>P2 \\<in> P\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>P. finite (cl_ecl x)\n  P2 \\<in> P", "have \"finite (cl_ecl P2)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>P. finite (cl_ecl x)\n  P2 \\<in> P\n\ngoal (1 subgoal):\n 1. finite (cl_ecl P2)", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl P2)\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> S \\<and>\n       P2 \\<in> S \\<and>\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from assms(3) and \\<open>finite (cl_ecl P1)\\<close> and \\<open>finite (cl_ecl P2)\\<close> \n      and \\<open>superposition P1 P2 C \\<sigma> k C'\\<close>"], ["proof (chain)\npicking this:\n  fo_interpretation I\n  finite (cl_ecl P1)\n  finite (cl_ecl P2)\n  superposition P1 P2 C \\<sigma> k C'", "have \"set_entails_clause { (cl_ecl P1), (cl_ecl P2) } (cl_ecl C)\""], ["proof (prove)\nusing this:\n  fo_interpretation I\n  finite (cl_ecl P1)\n  finite (cl_ecl P2)\n  superposition P1 P2 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. set_entails_clause {cl_ecl P1, cl_ecl P2} (cl_ecl C)", "using superposition_is_sound"], ["proof (prove)\nusing this:\n  fo_interpretation I\n  finite (cl_ecl P1)\n  finite (cl_ecl P2)\n  superposition P1 P2 C \\<sigma> k C'\n  \\<lbrakk>finite (cl_ecl ?P1.0); finite (cl_ecl ?P2.0);\n   superposition ?P1.0 ?P2.0 ?C ?\\<sigma> ?k ?C'\\<rbrakk>\n  \\<Longrightarrow> set_entails_clause {cl_ecl ?P1.0, cl_ecl ?P2.0}\n                     (cl_ecl ?C)\n\ngoal (1 subgoal):\n 1. set_entails_clause {cl_ecl P1, cl_ecl P2} (cl_ecl C)", "by blast"], ["proof (state)\nthis:\n  set_entails_clause {cl_ecl P1, cl_ecl P2} (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> S \\<and>\n       P2 \\<in> S \\<and>\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from this and assms(3) and \\<open>validate_clause I (cl_ecl P1)\\<close> and \\<open>validate_clause I (cl_ecl P2)\\<close>"], ["proof (chain)\npicking this:\n  set_entails_clause {cl_ecl P1, cl_ecl P2} (cl_ecl C)\n  fo_interpretation I\n  validate_clause I (cl_ecl P1)\n  validate_clause I (cl_ecl P2)", "have \"validate_clause I (cl_ecl C)\""], ["proof (prove)\nusing this:\n  set_entails_clause {cl_ecl P1, cl_ecl P2} (cl_ecl C)\n  fo_interpretation I\n  validate_clause I (cl_ecl P1)\n  validate_clause I (cl_ecl P2)\n\ngoal (1 subgoal):\n 1. validate_clause I (cl_ecl C)", "using set_entails_clause_def [of \"{ (cl_ecl P1), (cl_ecl P2) }\" \"cl_ecl C\"]"], ["proof (prove)\nusing this:\n  set_entails_clause {cl_ecl P1, cl_ecl P2} (cl_ecl C)\n  fo_interpretation I\n  validate_clause I (cl_ecl P1)\n  validate_clause I (cl_ecl P2)\n  set_entails_clause {cl_ecl P1, cl_ecl P2} (cl_ecl C) =\n  (\\<forall>I.\n      fo_interpretation I \\<longrightarrow>\n      validate_clause_set I {cl_ecl P1, cl_ecl P2} \\<longrightarrow>\n      validate_clause I (cl_ecl C))\n\ngoal (1 subgoal):\n 1. validate_clause I (cl_ecl C)", "by auto"], ["proof (state)\nthis:\n  validate_clause I (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> S \\<and>\n       P2 \\<in> S \\<and>\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from this and \\<open>\\<not>validate_clause I (cl_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  validate_clause I (cl_ecl C)\n  \\<not> validate_clause I (cl_ecl C)", "show False"], ["proof (prove)\nusing this:\n  validate_clause I (cl_ecl C)\n  \\<not> validate_clause I (cl_ecl C)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>P1 P2.\n     P1 \\<in> S \\<and>\n     P2 \\<in> S \\<and>\n     P = {P1, P2} \\<and> superposition P1 P2 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause I (cl_ecl C) \\<Longrightarrow> False", "have not_fact: \"\\<not> (\\<exists>P1. (P1 \\<in> S \\<and> P = { P1 } \\<and> factorization P1 C \\<sigma> k C'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>P1.\n       P1 \\<in> S \\<and> P = {P1} \\<and> factorization P1 C \\<sigma> k C'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and>\n       P = {P1} \\<and> factorization P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "assume \"(\\<exists>P1. (P1 \\<in> S \\<and> P = { P1 } \\<and> factorization P1 C \\<sigma> k C'))\""], ["proof (state)\nthis:\n  \\<exists>P1.\n     P1 \\<in> S \\<and> P = {P1} \\<and> factorization P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and>\n       P = {P1} \\<and> factorization P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<exists>P1.\n     P1 \\<in> S \\<and> P = {P1} \\<and> factorization P1 C \\<sigma> k C'", "obtain P1 where \"P1 \\<in> P\" and \"factorization P1 C \\<sigma> k C'\""], ["proof (prove)\nusing this:\n  \\<exists>P1.\n     P1 \\<in> S \\<and> P = {P1} \\<and> factorization P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. (\\<And>P1.\n        \\<lbrakk>P1 \\<in> P; factorization P1 C \\<sigma> k C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> P\n  factorization P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and>\n       P = {P1} \\<and> factorization P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from \\<open>P1 \\<in> P\\<close> and assms(2)"], ["proof (chain)\npicking this:\n  P1 \\<in> P\n  validate_clause_set I (cl_ecl ` P)", "have \"validate_clause I (cl_ecl P1)\""], ["proof (prove)\nusing this:\n  P1 \\<in> P\n  validate_clause_set I (cl_ecl ` P)\n\ngoal (1 subgoal):\n 1. validate_clause I (cl_ecl P1)", "by auto"], ["proof (state)\nthis:\n  validate_clause I (cl_ecl P1)\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and>\n       P = {P1} \\<and> factorization P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from assms(4) and \\<open>P1 \\<in> P\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>P. finite (cl_ecl x)\n  P1 \\<in> P", "have \"finite (cl_ecl P1)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>P. finite (cl_ecl x)\n  P1 \\<in> P\n\ngoal (1 subgoal):\n 1. finite (cl_ecl P1)", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl P1)\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and>\n       P = {P1} \\<and> factorization P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from assms(3) and \\<open>finite (cl_ecl P1)\\<close> and  \n      \\<open>factorization P1 C \\<sigma> k C'\\<close>"], ["proof (chain)\npicking this:\n  fo_interpretation I\n  finite (cl_ecl P1)\n  factorization P1 C \\<sigma> k C'", "have \"clause_entails_clause (cl_ecl P1) (cl_ecl C)\""], ["proof (prove)\nusing this:\n  fo_interpretation I\n  finite (cl_ecl P1)\n  factorization P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. clause_entails_clause (cl_ecl P1) (cl_ecl C)", "using factorization_is_sound"], ["proof (prove)\nusing this:\n  fo_interpretation I\n  finite (cl_ecl P1)\n  factorization P1 C \\<sigma> k C'\n  \\<lbrakk>finite (cl_ecl ?C); factorization ?C ?D ?\\<sigma> ?k ?C'\\<rbrakk>\n  \\<Longrightarrow> clause_entails_clause (cl_ecl ?C) (cl_ecl ?D)\n\ngoal (1 subgoal):\n 1. clause_entails_clause (cl_ecl P1) (cl_ecl C)", "by auto"], ["proof (state)\nthis:\n  clause_entails_clause (cl_ecl P1) (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and>\n       P = {P1} \\<and> factorization P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from this and assms(3) and \\<open>validate_clause I (cl_ecl P1)\\<close>"], ["proof (chain)\npicking this:\n  clause_entails_clause (cl_ecl P1) (cl_ecl C)\n  fo_interpretation I\n  validate_clause I (cl_ecl P1)", "have \"validate_clause I (cl_ecl C)\""], ["proof (prove)\nusing this:\n  clause_entails_clause (cl_ecl P1) (cl_ecl C)\n  fo_interpretation I\n  validate_clause I (cl_ecl P1)\n\ngoal (1 subgoal):\n 1. validate_clause I (cl_ecl C)", "unfolding clause_entails_clause_def"], ["proof (prove)\nusing this:\n  \\<forall>I.\n     fo_interpretation I \\<longrightarrow>\n     validate_clause I (cl_ecl P1) \\<longrightarrow>\n     validate_clause I (cl_ecl C)\n  fo_interpretation I\n  validate_clause I (cl_ecl P1)\n\ngoal (1 subgoal):\n 1. validate_clause I (cl_ecl C)", "by auto"], ["proof (state)\nthis:\n  validate_clause I (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and>\n       P = {P1} \\<and> factorization P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from this and \\<open>\\<not>validate_clause I (cl_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  validate_clause I (cl_ecl C)\n  \\<not> validate_clause I (cl_ecl C)", "show False"], ["proof (prove)\nusing this:\n  validate_clause I (cl_ecl C)\n  \\<not> validate_clause I (cl_ecl C)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>P1.\n     P1 \\<in> S \\<and> P = {P1} \\<and> factorization P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause I (cl_ecl C) \\<Longrightarrow> False", "have not_ref: \"\\<not> (\\<exists>P1. (P1 \\<in> S \\<and> P = { P1 } \\<and> reflexion P1 C \\<sigma> k C'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>P1.\n       P1 \\<in> S \\<and> P = {P1} \\<and> reflexion P1 C \\<sigma> k C'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and>\n       P = {P1} \\<and> reflexion P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "assume \"(\\<exists>P1. (P1 \\<in> S \\<and> P = { P1 } \\<and> reflexion P1 C \\<sigma> k C'))\""], ["proof (state)\nthis:\n  \\<exists>P1.\n     P1 \\<in> S \\<and> P = {P1} \\<and> reflexion P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and>\n       P = {P1} \\<and> reflexion P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<exists>P1.\n     P1 \\<in> S \\<and> P = {P1} \\<and> reflexion P1 C \\<sigma> k C'", "obtain P1 where \"P1 \\<in> P\" and \"reflexion  P1 C \\<sigma> k C'\""], ["proof (prove)\nusing this:\n  \\<exists>P1.\n     P1 \\<in> S \\<and> P = {P1} \\<and> reflexion P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. (\\<And>P1.\n        \\<lbrakk>P1 \\<in> P; reflexion P1 C \\<sigma> k C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> P\n  reflexion P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and>\n       P = {P1} \\<and> reflexion P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from \\<open>P1 \\<in> P\\<close> and assms(2)"], ["proof (chain)\npicking this:\n  P1 \\<in> P\n  validate_clause_set I (cl_ecl ` P)", "have \"validate_clause I (cl_ecl P1)\""], ["proof (prove)\nusing this:\n  P1 \\<in> P\n  validate_clause_set I (cl_ecl ` P)\n\ngoal (1 subgoal):\n 1. validate_clause I (cl_ecl P1)", "by auto"], ["proof (state)\nthis:\n  validate_clause I (cl_ecl P1)\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and>\n       P = {P1} \\<and> reflexion P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from assms(4) and \\<open>P1 \\<in> P\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>P. finite (cl_ecl x)\n  P1 \\<in> P", "have \"finite (cl_ecl P1)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>P. finite (cl_ecl x)\n  P1 \\<in> P\n\ngoal (1 subgoal):\n 1. finite (cl_ecl P1)", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl P1)\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and>\n       P = {P1} \\<and> reflexion P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from assms(3) and \\<open>finite (cl_ecl P1)\\<close> and  \n      \\<open>reflexion P1 C \\<sigma> k C'\\<close>"], ["proof (chain)\npicking this:\n  fo_interpretation I\n  finite (cl_ecl P1)\n  reflexion P1 C \\<sigma> k C'", "have \"clause_entails_clause (cl_ecl P1) (cl_ecl C)\""], ["proof (prove)\nusing this:\n  fo_interpretation I\n  finite (cl_ecl P1)\n  reflexion P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. clause_entails_clause (cl_ecl P1) (cl_ecl C)", "using reflexion_is_sound"], ["proof (prove)\nusing this:\n  fo_interpretation I\n  finite (cl_ecl P1)\n  reflexion P1 C \\<sigma> k C'\n  \\<lbrakk>finite (cl_ecl ?C); reflexion ?C ?D ?\\<sigma> ?k ?C'\\<rbrakk>\n  \\<Longrightarrow> clause_entails_clause (cl_ecl ?C) (cl_ecl ?D)\n\ngoal (1 subgoal):\n 1. clause_entails_clause (cl_ecl P1) (cl_ecl C)", "by auto"], ["proof (state)\nthis:\n  clause_entails_clause (cl_ecl P1) (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and>\n       P = {P1} \\<and> reflexion P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from this and assms(3) and \\<open>validate_clause I (cl_ecl P1)\\<close>"], ["proof (chain)\npicking this:\n  clause_entails_clause (cl_ecl P1) (cl_ecl C)\n  fo_interpretation I\n  validate_clause I (cl_ecl P1)", "have \"validate_clause I (cl_ecl C)\""], ["proof (prove)\nusing this:\n  clause_entails_clause (cl_ecl P1) (cl_ecl C)\n  fo_interpretation I\n  validate_clause I (cl_ecl P1)\n\ngoal (1 subgoal):\n 1. validate_clause I (cl_ecl C)", "unfolding clause_entails_clause_def"], ["proof (prove)\nusing this:\n  \\<forall>I.\n     fo_interpretation I \\<longrightarrow>\n     validate_clause I (cl_ecl P1) \\<longrightarrow>\n     validate_clause I (cl_ecl C)\n  fo_interpretation I\n  validate_clause I (cl_ecl P1)\n\ngoal (1 subgoal):\n 1. validate_clause I (cl_ecl C)", "by auto"], ["proof (state)\nthis:\n  validate_clause I (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> S \\<and>\n       P = {P1} \\<and> reflexion P1 C \\<sigma> k C' \\<Longrightarrow>\n    False", "from this and \\<open>\\<not>validate_clause I (cl_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  validate_clause I (cl_ecl C)\n  \\<not> validate_clause I (cl_ecl C)", "show False"], ["proof (prove)\nusing this:\n  validate_clause I (cl_ecl C)\n  \\<not> validate_clause I (cl_ecl C)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>P1.\n     P1 \\<in> S \\<and> P = {P1} \\<and> reflexion P1 C \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause I (cl_ecl C) \\<Longrightarrow> False", "from not_sup not_fact not_ref and assms(1)"], ["proof (chain)\npicking this:\n  \\<nexists>P1 P2.\n     P1 \\<in> S \\<and>\n     P2 \\<in> S \\<and>\n     P = {P1, P2} \\<and> superposition P1 P2 C \\<sigma> k C'\n  \\<nexists>P1.\n     P1 \\<in> S \\<and> P = {P1} \\<and> factorization P1 C \\<sigma> k C'\n  \\<nexists>P1.\n     P1 \\<in> S \\<and> P = {P1} \\<and> reflexion P1 C \\<sigma> k C'\n  derivable C P S \\<sigma> k C'", "show False"], ["proof (prove)\nusing this:\n  \\<nexists>P1 P2.\n     P1 \\<in> S \\<and>\n     P2 \\<in> S \\<and>\n     P = {P1, P2} \\<and> superposition P1 P2 C \\<sigma> k C'\n  \\<nexists>P1.\n     P1 \\<in> S \\<and> P = {P1} \\<and> factorization P1 C \\<sigma> k C'\n  \\<nexists>P1.\n     P1 \\<in> S \\<and> P = {P1} \\<and> reflexion P1 C \\<sigma> k C'\n  derivable C P S \\<sigma> k C'\n\ngoal (1 subgoal):\n 1. False", "unfolding derivable_def"], ["proof (prove)\nusing this:\n  \\<nexists>P1 P2.\n     P1 \\<in> S \\<and>\n     P2 \\<in> S \\<and>\n     P = {P1, P2} \\<and> superposition P1 P2 C \\<sigma> k C'\n  \\<nexists>P1.\n     P1 \\<in> S \\<and> P = {P1} \\<and> factorization P1 C \\<sigma> k C'\n  \\<nexists>P1.\n     P1 \\<in> S \\<and> P = {P1} \\<and> reflexion P1 C \\<sigma> k C'\n  (\\<exists>P1 P2.\n      P1 \\<in> S \\<and>\n      P2 \\<in> S \\<and>\n      P = {P1, P2} \\<and> superposition P1 P2 C \\<sigma> k C') \\<or>\n  (\\<exists>P1.\n      P1 \\<in> S \\<and>\n      P = {P1} \\<and> factorization P1 C \\<sigma> k C') \\<or>\n  (\\<exists>P1.\n      P1 \\<in> S \\<and> P = {P1} \\<and> reflexion P1 C \\<sigma> k C')\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma all_derived_clauses_are_finite:\n  shows \"derivable_ecl C S \\<Longrightarrow> \\<forall>x \\<in> S. (finite (cl_ecl x)) \\<Longrightarrow> finite (cl_ecl C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>derivable_ecl C S; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n    \\<Longrightarrow> finite (cl_ecl C)", "proof (induction rule: derivable_ecl.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>C S.\n       \\<lbrakk>C \\<in> S; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl C)\n 2. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        finite (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl D)\n 3. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    finite (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl C)", "fix C :: \"'a eclause\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>C S.\n       \\<lbrakk>C \\<in> S; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl C)\n 2. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        finite (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl D)\n 3. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    finite (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl C)", "fix S"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>C S.\n       \\<lbrakk>C \\<in> S; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl C)\n 2. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        finite (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl D)\n 3. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    finite (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl C)", "assume \"C \\<in> S\""], ["proof (state)\nthis:\n  C \\<in> S\n\ngoal (3 subgoals):\n 1. \\<And>C S.\n       \\<lbrakk>C \\<in> S; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl C)\n 2. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        finite (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl D)\n 3. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    finite (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl C)", "assume \"\\<forall>x \\<in> S. (finite (cl_ecl x))\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n\ngoal (3 subgoals):\n 1. \\<And>C S.\n       \\<lbrakk>C \\<in> S; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl C)\n 2. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        finite (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl D)\n 3. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    finite (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl C)", "from this \\<open>C \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  C \\<in> S", "show \"finite (cl_ecl C)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. finite (cl_ecl C)", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl C)\n\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        finite (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl D)\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    finite (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl C)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        finite (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl D)\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    finite (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl C)", "fix C S"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        finite (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl D)\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    finite (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl C)", "fix D :: \"'a eclause\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        finite (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl D)\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    finite (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl C)", "assume \"derivable_ecl C S\""], ["proof (state)\nthis:\n  derivable_ecl C S\n\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        finite (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl D)\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    finite (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl C)", "assume \"\\<forall>x \\<in> S. (finite (cl_ecl x))\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        finite (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl D)\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    finite (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl C)", "assume hyp_ind: \"\\<forall>x \\<in> S. (finite (cl_ecl x)) \\<Longrightarrow> finite (cl_ecl C)\"  \n    \"(renaming_cl C D)\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow> finite (cl_ecl C)\n  renaming_cl C D\n\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        finite (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl D)\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    finite (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl C)", "from \\<open>(renaming_cl C D)\\<close>"], ["proof (chain)\npicking this:\n  renaming_cl C D", "obtain \\<eta> where \"D = (subst_ecl C \\<eta>)\""], ["proof (prove)\nusing this:\n  renaming_cl C D\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>.\n        D = subst_ecl C \\<eta> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding renaming_cl_def"], ["proof (prove)\nusing this:\n  \\<exists>\\<eta>.\n     renaming \\<eta> (vars_of_cl (cl_ecl C)) \\<and> D = subst_ecl C \\<eta>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>.\n        D = subst_ecl C \\<eta> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  D = subst_ecl C \\<eta>\n\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        finite (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl D)\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    finite (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl C)", "obtain C_Cl T where \"C = (Ecl C_Cl T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C_Cl T.\n        C = Ecl C_Cl T \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \"eclause.exhaust\""], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = Ecl x1 x2 \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>C_Cl T.\n        C = Ecl C_Cl T \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C = Ecl C_Cl T\n\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        finite (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl D)\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    finite (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl C)", "from this and \\<open>D = (subst_ecl C \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  C = Ecl C_Cl T\n  D = subst_ecl C \\<eta>", "have \"(cl_ecl D) = (subst_cl (cl_ecl C) \\<eta>)\""], ["proof (prove)\nusing this:\n  C = Ecl C_Cl T\n  D = subst_ecl C \\<eta>\n\ngoal (1 subgoal):\n 1. cl_ecl D = subst_cl (cl_ecl C) \\<eta>", "by auto"], ["proof (state)\nthis:\n  cl_ecl D = subst_cl (cl_ecl C) \\<eta>\n\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        finite (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl D)\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    finite (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl C)", "from this hyp_ind \\<open>\\<forall>x \\<in> S. (finite (cl_ecl x))\\<close>"], ["proof (chain)\npicking this:\n  cl_ecl D = subst_cl (cl_ecl C) \\<eta>\n  \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow> finite (cl_ecl C)\n  renaming_cl C D\n  \\<forall>x\\<in>S. finite (cl_ecl x)", "show \"finite (cl_ecl D)\""], ["proof (prove)\nusing this:\n  cl_ecl D = subst_cl (cl_ecl C) \\<eta>\n  \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow> finite (cl_ecl C)\n  renaming_cl C D\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n\ngoal (1 subgoal):\n 1. finite (cl_ecl D)", "using substs_preserve_finiteness"], ["proof (prove)\nusing this:\n  cl_ecl D = subst_cl (cl_ecl C) \\<eta>\n  \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow> finite (cl_ecl C)\n  renaming_cl C D\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  finite ?C \\<Longrightarrow> finite (subst_cl ?C ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. finite (cl_ecl D)", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl D)\n\ngoal (1 subgoal):\n 1. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    finite (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl C)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    finite (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl C)", "fix P S C S' \\<sigma> C'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    finite (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl C)", "assume h: \"\\<forall>x. x \\<in> P \\<longrightarrow> derivable_ecl x S \\<and> ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow> finite (cl_ecl x))\""], ["proof (state)\nthis:\n  \\<forall>x.\n     x \\<in> P \\<longrightarrow>\n     derivable_ecl x S \\<and>\n     ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n      finite (cl_ecl x))\n\ngoal (1 subgoal):\n 1. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    finite (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl C)", "assume \"derivable C P S' \\<sigma> FirstOrder C'\""], ["proof (state)\nthis:\n  derivable C P S' \\<sigma> FirstOrder C'\n\ngoal (1 subgoal):\n 1. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    finite (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl C)", "assume \"\\<forall>x\\<in>S. finite (cl_ecl x)\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n\ngoal (1 subgoal):\n 1. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    finite (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl C)", "from h and \\<open>\\<forall>x\\<in>S. finite (cl_ecl x)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     x \\<in> P \\<longrightarrow>\n     derivable_ecl x S \\<and>\n     ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n      finite (cl_ecl x))\n  \\<forall>x\\<in>S. finite (cl_ecl x)", "have \"\\<forall>x \\<in> P. (finite (cl_ecl x))\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in> P \\<longrightarrow>\n     derivable_ecl x S \\<and>\n     ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n      finite (cl_ecl x))\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>P. finite (cl_ecl x)", "by metis"], ["proof (state)\nthis:\n  \\<forall>x\\<in>P. finite (cl_ecl x)\n\ngoal (1 subgoal):\n 1. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    finite (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> finite (cl_ecl C)", "from this and \\<open>derivable C P S' \\<sigma> FirstOrder C'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>P. finite (cl_ecl x)\n  derivable C P S' \\<sigma> FirstOrder C'", "show \"finite (cl_ecl C)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>P. finite (cl_ecl x)\n  derivable C P S' \\<sigma> FirstOrder C'\n\ngoal (1 subgoal):\n 1. finite (cl_ecl C)", "using derivable_clauses_are_finite"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>P. finite (cl_ecl x)\n  derivable C P S' \\<sigma> FirstOrder C'\n  \\<lbrakk>derivable ?C ?P ?S ?\\<sigma> ?k ?C';\n   \\<forall>x\\<in>?P. finite (cl_ecl x)\\<rbrakk>\n  \\<Longrightarrow> finite (cl_ecl ?C) \\<and> finite ?C'\n\ngoal (1 subgoal):\n 1. finite (cl_ecl C)", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl C)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma all_derived_clauses_are_wellconstrained:\n  shows \"derivable_ecl C S \\<Longrightarrow> \\<forall>x \\<in> S. (well_constrained x) \\<Longrightarrow> well_constrained C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>derivable_ecl C S; Ball S well_constrained\\<rbrakk>\n    \\<Longrightarrow> well_constrained C", "proof (induction rule: derivable_ecl.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>C S.\n       \\<lbrakk>C \\<in> S; Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained C\n 2. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        Ball S well_constrained \\<Longrightarrow> well_constrained C;\n        renaming_cl C D; Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained D\n 3. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   (Ball S well_constrained \\<longrightarrow>\n                    well_constrained x);\n        derivable C P S' \\<sigma> FirstOrder C';\n        Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained C", "fix C :: \"'a eclause\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>C S.\n       \\<lbrakk>C \\<in> S; Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained C\n 2. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        Ball S well_constrained \\<Longrightarrow> well_constrained C;\n        renaming_cl C D; Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained D\n 3. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   (Ball S well_constrained \\<longrightarrow>\n                    well_constrained x);\n        derivable C P S' \\<sigma> FirstOrder C';\n        Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained C", "fix S"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>C S.\n       \\<lbrakk>C \\<in> S; Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained C\n 2. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        Ball S well_constrained \\<Longrightarrow> well_constrained C;\n        renaming_cl C D; Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained D\n 3. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   (Ball S well_constrained \\<longrightarrow>\n                    well_constrained x);\n        derivable C P S' \\<sigma> FirstOrder C';\n        Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained C", "assume \"C \\<in> S\""], ["proof (state)\nthis:\n  C \\<in> S\n\ngoal (3 subgoals):\n 1. \\<And>C S.\n       \\<lbrakk>C \\<in> S; Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained C\n 2. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        Ball S well_constrained \\<Longrightarrow> well_constrained C;\n        renaming_cl C D; Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained D\n 3. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   (Ball S well_constrained \\<longrightarrow>\n                    well_constrained x);\n        derivable C P S' \\<sigma> FirstOrder C';\n        Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained C", "assume \"\\<forall>x \\<in> S. (well_constrained x)\""], ["proof (state)\nthis:\n  Ball S well_constrained\n\ngoal (3 subgoals):\n 1. \\<And>C S.\n       \\<lbrakk>C \\<in> S; Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained C\n 2. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        Ball S well_constrained \\<Longrightarrow> well_constrained C;\n        renaming_cl C D; Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained D\n 3. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   (Ball S well_constrained \\<longrightarrow>\n                    well_constrained x);\n        derivable C P S' \\<sigma> FirstOrder C';\n        Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained C", "from this \\<open>C \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  Ball S well_constrained\n  C \\<in> S", "show \"well_constrained C\""], ["proof (prove)\nusing this:\n  Ball S well_constrained\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. well_constrained C", "by auto"], ["proof (state)\nthis:\n  well_constrained C\n\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        Ball S well_constrained \\<Longrightarrow> well_constrained C;\n        renaming_cl C D; Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained D\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   (Ball S well_constrained \\<longrightarrow>\n                    well_constrained x);\n        derivable C P S' \\<sigma> FirstOrder C';\n        Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained C", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        Ball S well_constrained \\<Longrightarrow> well_constrained C;\n        renaming_cl C D; Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained D\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   (Ball S well_constrained \\<longrightarrow>\n                    well_constrained x);\n        derivable C P S' \\<sigma> FirstOrder C';\n        Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained C", "fix C S"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        Ball S well_constrained \\<Longrightarrow> well_constrained C;\n        renaming_cl C D; Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained D\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   (Ball S well_constrained \\<longrightarrow>\n                    well_constrained x);\n        derivable C P S' \\<sigma> FirstOrder C';\n        Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained C", "fix D :: \"'a eclause\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        Ball S well_constrained \\<Longrightarrow> well_constrained C;\n        renaming_cl C D; Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained D\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   (Ball S well_constrained \\<longrightarrow>\n                    well_constrained x);\n        derivable C P S' \\<sigma> FirstOrder C';\n        Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained C", "assume \"derivable_ecl C S\""], ["proof (state)\nthis:\n  derivable_ecl C S\n\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        Ball S well_constrained \\<Longrightarrow> well_constrained C;\n        renaming_cl C D; Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained D\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   (Ball S well_constrained \\<longrightarrow>\n                    well_constrained x);\n        derivable C P S' \\<sigma> FirstOrder C';\n        Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained C", "assume \"\\<forall>x \\<in> S. (well_constrained x)\""], ["proof (state)\nthis:\n  Ball S well_constrained\n\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        Ball S well_constrained \\<Longrightarrow> well_constrained C;\n        renaming_cl C D; Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained D\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   (Ball S well_constrained \\<longrightarrow>\n                    well_constrained x);\n        derivable C P S' \\<sigma> FirstOrder C';\n        Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained C", "assume hyp_ind: \"\\<forall>x \\<in> S. (well_constrained x) \\<Longrightarrow> well_constrained C\"  \n    \"(renaming_cl C D)\""], ["proof (state)\nthis:\n  Ball S well_constrained \\<Longrightarrow> well_constrained C\n  renaming_cl C D\n\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        Ball S well_constrained \\<Longrightarrow> well_constrained C;\n        renaming_cl C D; Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained D\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   (Ball S well_constrained \\<longrightarrow>\n                    well_constrained x);\n        derivable C P S' \\<sigma> FirstOrder C';\n        Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained C", "from \\<open>\\<forall>x \\<in> S. (well_constrained x)\\<close> and hyp_ind"], ["proof (chain)\npicking this:\n  Ball S well_constrained\n  Ball S well_constrained \\<Longrightarrow> well_constrained C\n  renaming_cl C D", "have \"well_constrained C\""], ["proof (prove)\nusing this:\n  Ball S well_constrained\n  Ball S well_constrained \\<Longrightarrow> well_constrained C\n  renaming_cl C D\n\ngoal (1 subgoal):\n 1. well_constrained C", "by auto"], ["proof (state)\nthis:\n  well_constrained C\n\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        Ball S well_constrained \\<Longrightarrow> well_constrained C;\n        renaming_cl C D; Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained D\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   (Ball S well_constrained \\<longrightarrow>\n                    well_constrained x);\n        derivable C P S' \\<sigma> FirstOrder C';\n        Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained C", "from \\<open>(renaming_cl C D)\\<close>"], ["proof (chain)\npicking this:\n  renaming_cl C D", "obtain \\<eta> where \"D = (subst_ecl C \\<eta>)\""], ["proof (prove)\nusing this:\n  renaming_cl C D\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>.\n        D = subst_ecl C \\<eta> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding renaming_cl_def"], ["proof (prove)\nusing this:\n  \\<exists>\\<eta>.\n     renaming \\<eta> (vars_of_cl (cl_ecl C)) \\<and> D = subst_ecl C \\<eta>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>.\n        D = subst_ecl C \\<eta> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  D = subst_ecl C \\<eta>\n\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        Ball S well_constrained \\<Longrightarrow> well_constrained C;\n        renaming_cl C D; Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained D\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   (Ball S well_constrained \\<longrightarrow>\n                    well_constrained x);\n        derivable C P S' \\<sigma> FirstOrder C';\n        Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained C", "from this and \\<open>well_constrained C\\<close>"], ["proof (chain)\npicking this:\n  D = subst_ecl C \\<eta>\n  well_constrained C", "show \"well_constrained D\""], ["proof (prove)\nusing this:\n  D = subst_ecl C \\<eta>\n  well_constrained C\n\ngoal (1 subgoal):\n 1. well_constrained D", "using substs_preserve_well_constrainedness"], ["proof (prove)\nusing this:\n  D = subst_ecl C \\<eta>\n  well_constrained C\n  well_constrained ?C \\<Longrightarrow>\n  well_constrained (subst_ecl ?C ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. well_constrained D", "by auto"], ["proof (state)\nthis:\n  well_constrained D\n\ngoal (1 subgoal):\n 1. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   (Ball S well_constrained \\<longrightarrow>\n                    well_constrained x);\n        derivable C P S' \\<sigma> FirstOrder C';\n        Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   (Ball S well_constrained \\<longrightarrow>\n                    well_constrained x);\n        derivable C P S' \\<sigma> FirstOrder C';\n        Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained C", "fix P S C S' \\<sigma> C'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   (Ball S well_constrained \\<longrightarrow>\n                    well_constrained x);\n        derivable C P S' \\<sigma> FirstOrder C';\n        Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained C", "assume \"\\<forall>x. x \\<in> P \\<longrightarrow> derivable_ecl x S \\<and> (Ball S well_constrained \\<longrightarrow> well_constrained x)\""], ["proof (state)\nthis:\n  \\<forall>x.\n     x \\<in> P \\<longrightarrow>\n     derivable_ecl x S \\<and>\n     (Ball S well_constrained \\<longrightarrow> well_constrained x)\n\ngoal (1 subgoal):\n 1. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   (Ball S well_constrained \\<longrightarrow>\n                    well_constrained x);\n        derivable C P S' \\<sigma> FirstOrder C';\n        Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained C", "assume \"derivable C P S' \\<sigma> FirstOrder C'\""], ["proof (state)\nthis:\n  derivable C P S' \\<sigma> FirstOrder C'\n\ngoal (1 subgoal):\n 1. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   (Ball S well_constrained \\<longrightarrow>\n                    well_constrained x);\n        derivable C P S' \\<sigma> FirstOrder C';\n        Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained C", "assume \"Ball S well_constrained\""], ["proof (state)\nthis:\n  Ball S well_constrained\n\ngoal (1 subgoal):\n 1. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   (Ball S well_constrained \\<longrightarrow>\n                    well_constrained x);\n        derivable C P S' \\<sigma> FirstOrder C';\n        Ball S well_constrained\\<rbrakk>\n       \\<Longrightarrow> well_constrained C", "from \\<open>derivable C P S' \\<sigma> FirstOrder C'\\<close>"], ["proof (chain)\npicking this:\n  derivable C P S' \\<sigma> FirstOrder C'", "show \"well_constrained C\""], ["proof (prove)\nusing this:\n  derivable C P S' \\<sigma> FirstOrder C'\n\ngoal (1 subgoal):\n 1. well_constrained C", "using derivable_clauses_are_well_constrained"], ["proof (prove)\nusing this:\n  derivable C P S' \\<sigma> FirstOrder C'\n  derivable ?C ?P ?S ?\\<sigma> ?k ?C' \\<Longrightarrow> well_constrained ?C\n\ngoal (1 subgoal):\n 1. well_constrained C", "by auto"], ["proof (state)\nthis:\n  well_constrained C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma SOUNDNESS:\n  shows \"derivable_ecl C S \\<Longrightarrow> \\<forall>x \\<in> S. (finite (cl_ecl x)) \n    \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>derivable_ecl C S; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n    \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)", "proof (induction rule: derivable_ecl.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>C S.\n       \\<lbrakk>C \\<in> S; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)\n 2. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        set_entails_clause (cl_ecl ` S) (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl D)\n 3. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    set_entails_clause (cl_ecl ` S) (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)", "fix C :: \"'a eclause\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>C S.\n       \\<lbrakk>C \\<in> S; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)\n 2. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        set_entails_clause (cl_ecl ` S) (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl D)\n 3. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    set_entails_clause (cl_ecl ` S) (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)", "fix S"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>C S.\n       \\<lbrakk>C \\<in> S; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)\n 2. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        set_entails_clause (cl_ecl ` S) (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl D)\n 3. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    set_entails_clause (cl_ecl ` S) (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)", "assume \"C \\<in> S\""], ["proof (state)\nthis:\n  C \\<in> S\n\ngoal (3 subgoals):\n 1. \\<And>C S.\n       \\<lbrakk>C \\<in> S; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)\n 2. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        set_entails_clause (cl_ecl ` S) (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl D)\n 3. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    set_entails_clause (cl_ecl ` S) (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)", "assume \"\\<forall>x \\<in> S. (finite (cl_ecl x))\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n\ngoal (3 subgoals):\n 1. \\<And>C S.\n       \\<lbrakk>C \\<in> S; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)\n 2. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        set_entails_clause (cl_ecl ` S) (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl D)\n 3. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    set_entails_clause (cl_ecl ` S) (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)", "from \\<open>C \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  C \\<in> S", "show \"set_entails_clause (cl_ecl ` S) (cl_ecl C)\""], ["proof (prove)\nusing this:\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. set_entails_clause (cl_ecl ` S) (cl_ecl C)", "unfolding set_entails_clause_def"], ["proof (prove)\nusing this:\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>I.\n       fo_interpretation I \\<longrightarrow>\n       validate_clause_set I (cl_ecl ` S) \\<longrightarrow>\n       validate_clause I (cl_ecl C)", "by auto"], ["proof (state)\nthis:\n  set_entails_clause (cl_ecl ` S) (cl_ecl C)\n\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        set_entails_clause (cl_ecl ` S) (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl D)\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    set_entails_clause (cl_ecl ` S) (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        set_entails_clause (cl_ecl ` S) (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl D)\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    set_entails_clause (cl_ecl ` S) (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)", "fix C S"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        set_entails_clause (cl_ecl ` S) (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl D)\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    set_entails_clause (cl_ecl ` S) (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)", "fix D :: \"'a eclause\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        set_entails_clause (cl_ecl ` S) (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl D)\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    set_entails_clause (cl_ecl ` S) (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)", "assume \"derivable_ecl C S\""], ["proof (state)\nthis:\n  derivable_ecl C S\n\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        set_entails_clause (cl_ecl ` S) (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl D)\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    set_entails_clause (cl_ecl ` S) (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)", "assume \"\\<forall>x \\<in> S. (finite (cl_ecl x))\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        set_entails_clause (cl_ecl ` S) (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl D)\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    set_entails_clause (cl_ecl ` S) (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)", "assume hyp_ind: \"\\<forall>x \\<in> S. (finite (cl_ecl x)) \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n  set_entails_clause (cl_ecl ` S) (cl_ecl C)\n\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        set_entails_clause (cl_ecl ` S) (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl D)\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    set_entails_clause (cl_ecl ` S) (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)", "assume  \"(renaming_cl C D)\""], ["proof (state)\nthis:\n  renaming_cl C D\n\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        set_entails_clause (cl_ecl ` S) (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl D)\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    set_entails_clause (cl_ecl ` S) (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)", "from \\<open>(renaming_cl C D)\\<close>"], ["proof (chain)\npicking this:\n  renaming_cl C D", "obtain \\<eta> where \"D = (subst_ecl C \\<eta>)\""], ["proof (prove)\nusing this:\n  renaming_cl C D\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>.\n        D = subst_ecl C \\<eta> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding renaming_cl_def"], ["proof (prove)\nusing this:\n  \\<exists>\\<eta>.\n     renaming \\<eta> (vars_of_cl (cl_ecl C)) \\<and> D = subst_ecl C \\<eta>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>.\n        D = subst_ecl C \\<eta> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  D = subst_ecl C \\<eta>\n\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        set_entails_clause (cl_ecl ` S) (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl D)\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    set_entails_clause (cl_ecl ` S) (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)", "obtain C_Cl T where \"C = (Ecl C_Cl T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C_Cl T.\n        C = Ecl C_Cl T \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \"eclause.exhaust\""], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = Ecl x1 x2 \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>C_Cl T.\n        C = Ecl C_Cl T \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C = Ecl C_Cl T\n\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        set_entails_clause (cl_ecl ` S) (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl D)\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    set_entails_clause (cl_ecl ` S) (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)", "from this and \\<open>D = (subst_ecl C \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  C = Ecl C_Cl T\n  D = subst_ecl C \\<eta>", "have \"(cl_ecl D) = (subst_cl (cl_ecl C) \\<eta>)\""], ["proof (prove)\nusing this:\n  C = Ecl C_Cl T\n  D = subst_ecl C \\<eta>\n\ngoal (1 subgoal):\n 1. cl_ecl D = subst_cl (cl_ecl C) \\<eta>", "by auto"], ["proof (state)\nthis:\n  cl_ecl D = subst_cl (cl_ecl C) \\<eta>\n\ngoal (2 subgoals):\n 1. \\<And>C S D.\n       \\<lbrakk>derivable_ecl C S;\n        \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n        set_entails_clause (cl_ecl ` S) (cl_ecl C);\n        renaming_cl C D; \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl D)\n 2. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    set_entails_clause (cl_ecl ` S) (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)", "show \"set_entails_clause (cl_ecl ` S) (cl_ecl D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_entails_clause (cl_ecl ` S) (cl_ecl D)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause (cl_ecl ` S) (cl_ecl D) \\<Longrightarrow>\n    False", "assume \"\\<not>?thesis\""], ["proof (state)\nthis:\n  \\<not> set_entails_clause (cl_ecl ` S) (cl_ecl D)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause (cl_ecl ` S) (cl_ecl D) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<not> set_entails_clause (cl_ecl ` S) (cl_ecl D)", "obtain I where \"fo_interpretation I\" and i: \"validate_clause_set I (cl_ecl `S)\" \n      \"\\<not>validate_clause I (cl_ecl D)\""], ["proof (prove)\nusing this:\n  \\<not> set_entails_clause (cl_ecl ` S) (cl_ecl D)\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        \\<lbrakk>fo_interpretation I; validate_clause_set I (cl_ecl ` S);\n         \\<not> validate_clause I (cl_ecl D)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_entails_clause_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>I.\n             fo_interpretation I \\<longrightarrow>\n             validate_clause_set I (cl_ecl ` S) \\<longrightarrow>\n             validate_clause I (cl_ecl D))\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        \\<lbrakk>fo_interpretation I; validate_clause_set I (cl_ecl ` S);\n         \\<not> validate_clause I (cl_ecl D)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  fo_interpretation I\n  validate_clause_set I (cl_ecl ` S)\n  \\<not> validate_clause I (cl_ecl D)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause (cl_ecl ` S) (cl_ecl D) \\<Longrightarrow>\n    False", "from \\<open>\\<not>validate_clause I (cl_ecl D)\\<close> and \\<open>(cl_ecl D) = (subst_cl (cl_ecl C) \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> validate_clause I (cl_ecl D)\n  cl_ecl D = subst_cl (cl_ecl C) \\<eta>", "have \"\\<not>validate_clause I (cl_ecl C)\""], ["proof (prove)\nusing this:\n  \\<not> validate_clause I (cl_ecl D)\n  cl_ecl D = subst_cl (cl_ecl C) \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause I (cl_ecl C)", "using instances_are_entailed"], ["proof (prove)\nusing this:\n  \\<not> validate_clause I (cl_ecl D)\n  cl_ecl D = subst_cl (cl_ecl C) \\<eta>\n  validate_clause ?I ?C \\<Longrightarrow>\n  validate_clause ?I (subst_cl ?C ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause I (cl_ecl C)", "by metis"], ["proof (state)\nthis:\n  \\<not> validate_clause I (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause (cl_ecl ` S) (cl_ecl D) \\<Longrightarrow>\n    False", "from this and \\<open>fo_interpretation I\\<close> i"], ["proof (chain)\npicking this:\n  \\<not> validate_clause I (cl_ecl C)\n  fo_interpretation I\n  validate_clause_set I (cl_ecl ` S)\n  \\<not> validate_clause I (cl_ecl D)", "have \"\\<not>set_entails_clause (cl_ecl ` S) (cl_ecl C)\""], ["proof (prove)\nusing this:\n  \\<not> validate_clause I (cl_ecl C)\n  fo_interpretation I\n  validate_clause_set I (cl_ecl ` S)\n  \\<not> validate_clause I (cl_ecl D)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause (cl_ecl ` S) (cl_ecl C)", "unfolding set_entails_clause_def"], ["proof (prove)\nusing this:\n  \\<not> validate_clause I (cl_ecl C)\n  fo_interpretation I\n  validate_clause_set I (cl_ecl ` S)\n  \\<not> validate_clause I (cl_ecl D)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>I.\n               fo_interpretation I \\<longrightarrow>\n               validate_clause_set I (cl_ecl ` S) \\<longrightarrow>\n               validate_clause I (cl_ecl C))", "by auto"], ["proof (state)\nthis:\n  \\<not> set_entails_clause (cl_ecl ` S) (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause (cl_ecl ` S) (cl_ecl D) \\<Longrightarrow>\n    False", "from this and \\<open>\\<forall>x \\<in> S. (finite (cl_ecl x))\\<close> hyp_ind"], ["proof (chain)\npicking this:\n  \\<not> set_entails_clause (cl_ecl ` S) (cl_ecl C)\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n  set_entails_clause (cl_ecl ` S) (cl_ecl C)", "show False"], ["proof (prove)\nusing this:\n  \\<not> set_entails_clause (cl_ecl ` S) (cl_ecl C)\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  \\<forall>x\\<in>S. finite (cl_ecl x) \\<Longrightarrow>\n  set_entails_clause (cl_ecl ` S) (cl_ecl C)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set_entails_clause (cl_ecl ` S) (cl_ecl D)\n\ngoal (1 subgoal):\n 1. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    set_entails_clause (cl_ecl ` S) (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    set_entails_clause (cl_ecl ` S) (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)", "fix P S C S' \\<sigma> C'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    set_entails_clause (cl_ecl ` S) (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)", "assume h: \"\\<forall>x. x \\<in> P \\<longrightarrow> derivable_ecl x S \\<and> ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl x))\""], ["proof (state)\nthis:\n  \\<forall>x.\n     x \\<in> P \\<longrightarrow>\n     derivable_ecl x S \\<and>\n     ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n      set_entails_clause (cl_ecl ` S) (cl_ecl x))\n\ngoal (1 subgoal):\n 1. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    set_entails_clause (cl_ecl ` S) (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)", "assume \"derivable C P S' \\<sigma> FirstOrder C'\""], ["proof (state)\nthis:\n  derivable C P S' \\<sigma> FirstOrder C'\n\ngoal (1 subgoal):\n 1. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    set_entails_clause (cl_ecl ` S) (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)", "assume \"\\<forall>x\\<in>S. finite (cl_ecl x)\""], ["proof (state)\nthis:\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n\ngoal (1 subgoal):\n 1. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    set_entails_clause (cl_ecl ` S) (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)", "from h and \\<open>\\<forall>x\\<in>S. finite (cl_ecl x)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     x \\<in> P \\<longrightarrow>\n     derivable_ecl x S \\<and>\n     ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n      set_entails_clause (cl_ecl ` S) (cl_ecl x))\n  \\<forall>x\\<in>S. finite (cl_ecl x)", "have i: \"\\<forall>x \\<in> P.  set_entails_clause (cl_ecl ` S) (cl_ecl x)\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in> P \\<longrightarrow>\n     derivable_ecl x S \\<and>\n     ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n      set_entails_clause (cl_ecl ` S) (cl_ecl x))\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>P. set_entails_clause (cl_ecl ` S) (cl_ecl x)", "by metis"], ["proof (state)\nthis:\n  \\<forall>x\\<in>P. set_entails_clause (cl_ecl ` S) (cl_ecl x)\n\ngoal (1 subgoal):\n 1. \\<And>P S C S' \\<sigma> C'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> P \\<longrightarrow>\n                   derivable_ecl x S \\<and>\n                   ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n                    set_entails_clause (cl_ecl ` S) (cl_ecl x));\n        derivable C P S' \\<sigma> FirstOrder C';\n        \\<forall>x\\<in>S. finite (cl_ecl x)\\<rbrakk>\n       \\<Longrightarrow> set_entails_clause (cl_ecl ` S) (cl_ecl C)", "show \"set_entails_clause (cl_ecl ` S) (cl_ecl C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_entails_clause (cl_ecl ` S) (cl_ecl C)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause (cl_ecl ` S) (cl_ecl C) \\<Longrightarrow>\n    False", "assume \"\\<not>?thesis\""], ["proof (state)\nthis:\n  \\<not> set_entails_clause (cl_ecl ` S) (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause (cl_ecl ` S) (cl_ecl C) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<not> set_entails_clause (cl_ecl ` S) (cl_ecl C)", "obtain I where \"fo_interpretation I\" and ii: \"validate_clause_set I (cl_ecl `S)\" \n      \"\\<not>validate_clause I (cl_ecl C)\""], ["proof (prove)\nusing this:\n  \\<not> set_entails_clause (cl_ecl ` S) (cl_ecl C)\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        \\<lbrakk>fo_interpretation I; validate_clause_set I (cl_ecl ` S);\n         \\<not> validate_clause I (cl_ecl C)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_entails_clause_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>I.\n             fo_interpretation I \\<longrightarrow>\n             validate_clause_set I (cl_ecl ` S) \\<longrightarrow>\n             validate_clause I (cl_ecl C))\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        \\<lbrakk>fo_interpretation I; validate_clause_set I (cl_ecl ` S);\n         \\<not> validate_clause I (cl_ecl C)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  fo_interpretation I\n  validate_clause_set I (cl_ecl ` S)\n  \\<not> validate_clause I (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause (cl_ecl ` S) (cl_ecl C) \\<Longrightarrow>\n    False", "from h \\<open>\\<forall>x\\<in>S. finite (cl_ecl x)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     x \\<in> P \\<longrightarrow>\n     derivable_ecl x S \\<and>\n     ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n      set_entails_clause (cl_ecl ` S) (cl_ecl x))\n  \\<forall>x\\<in>S. finite (cl_ecl x)", "have \"(\\<forall>x\\<in>P. finite (cl_ecl x))\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in> P \\<longrightarrow>\n     derivable_ecl x S \\<and>\n     ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n      set_entails_clause (cl_ecl ` S) (cl_ecl x))\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>P. finite (cl_ecl x)", "using all_derived_clauses_are_finite"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in> P \\<longrightarrow>\n     derivable_ecl x S \\<and>\n     ((\\<forall>x\\<in>S. finite (cl_ecl x)) \\<longrightarrow>\n      set_entails_clause (cl_ecl ` S) (cl_ecl x))\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  \\<lbrakk>derivable_ecl ?C ?S;\n   \\<forall>x\\<in>?S. finite (cl_ecl x)\\<rbrakk>\n  \\<Longrightarrow> finite (cl_ecl ?C)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>P. finite (cl_ecl x)", "by metis"], ["proof (state)\nthis:\n  \\<forall>x\\<in>P. finite (cl_ecl x)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause (cl_ecl ` S) (cl_ecl C) \\<Longrightarrow>\n    False", "from \\<open>fo_interpretation I\\<close>  i and ii"], ["proof (chain)\npicking this:\n  fo_interpretation I\n  \\<forall>x\\<in>P. set_entails_clause (cl_ecl ` S) (cl_ecl x)\n  validate_clause_set I (cl_ecl ` S)\n  \\<not> validate_clause I (cl_ecl C)", "have \"\\<forall>x \\<in> P.  (validate_clause I (cl_ecl x))\""], ["proof (prove)\nusing this:\n  fo_interpretation I\n  \\<forall>x\\<in>P. set_entails_clause (cl_ecl ` S) (cl_ecl x)\n  validate_clause_set I (cl_ecl ` S)\n  \\<not> validate_clause I (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>P. validate_clause I (cl_ecl x)", "unfolding set_entails_clause_def"], ["proof (prove)\nusing this:\n  fo_interpretation I\n  \\<forall>x\\<in>P.\n     \\<forall>I.\n        fo_interpretation I \\<longrightarrow>\n        validate_clause_set I (cl_ecl ` S) \\<longrightarrow>\n        validate_clause I (cl_ecl x)\n  validate_clause_set I (cl_ecl ` S)\n  \\<not> validate_clause I (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>P. validate_clause I (cl_ecl x)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>P. validate_clause I (cl_ecl x)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause (cl_ecl ` S) (cl_ecl C) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>P. validate_clause I (cl_ecl x)", "have \"validate_clause_set I (cl_ecl ` P)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>P. validate_clause I (cl_ecl x)\n\ngoal (1 subgoal):\n 1. validate_clause_set I (cl_ecl ` P)", "by auto"], ["proof (state)\nthis:\n  validate_clause_set I (cl_ecl ` P)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause (cl_ecl ` S) (cl_ecl C) \\<Longrightarrow>\n    False", "from this and \\<open>(\\<forall>x\\<in>P. finite (cl_ecl x))\\<close> \\<open>fo_interpretation I\\<close> \\<open>derivable C P S' \\<sigma> FirstOrder C'\\<close>"], ["proof (chain)\npicking this:\n  validate_clause_set I (cl_ecl ` P)\n  \\<forall>x\\<in>P. finite (cl_ecl x)\n  fo_interpretation I\n  derivable C P S' \\<sigma> FirstOrder C'", "have \"validate_clause I (cl_ecl C)\""], ["proof (prove)\nusing this:\n  validate_clause_set I (cl_ecl ` P)\n  \\<forall>x\\<in>P. finite (cl_ecl x)\n  fo_interpretation I\n  derivable C P S' \\<sigma> FirstOrder C'\n\ngoal (1 subgoal):\n 1. validate_clause I (cl_ecl C)", "using derivable_clauses_are_entailed [of C P S' \\<sigma> FirstOrder C' I]"], ["proof (prove)\nusing this:\n  validate_clause_set I (cl_ecl ` P)\n  \\<forall>x\\<in>P. finite (cl_ecl x)\n  fo_interpretation I\n  derivable C P S' \\<sigma> FirstOrder C'\n  \\<lbrakk>derivable C P S' \\<sigma> FirstOrder C';\n   validate_clause_set I (cl_ecl ` P); fo_interpretation I;\n   \\<forall>x\\<in>P. finite (cl_ecl x)\\<rbrakk>\n  \\<Longrightarrow> validate_clause I (cl_ecl C)\n\ngoal (1 subgoal):\n 1. validate_clause I (cl_ecl C)", "by blast"], ["proof (state)\nthis:\n  validate_clause I (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<not> set_entails_clause (cl_ecl ` S) (cl_ecl C) \\<Longrightarrow>\n    False", "from this and \\<open>\\<not>validate_clause I (cl_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  validate_clause I (cl_ecl C)\n  \\<not> validate_clause I (cl_ecl C)", "show False"], ["proof (prove)\nusing this:\n  validate_clause I (cl_ecl C)\n  \\<not> validate_clause I (cl_ecl C)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set_entails_clause (cl_ecl ` S) (cl_ecl C)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma REFUTABLE_SETS_ARE_UNSAT:\n  assumes \"\\<forall>x \\<in> S. (finite (cl_ecl x))\"\n  assumes \"derivable_ecl C S\"\n  assumes \"(cl_ecl C = {})\"\n  shows \"\\<not> (satisfiable_clause_set (cl_ecl ` S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> satisfiable_clause_set (cl_ecl ` S)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. satisfiable_clause_set (cl_ecl ` S) \\<Longrightarrow> False", "assume \"(satisfiable_clause_set (cl_ecl ` S))\""], ["proof (state)\nthis:\n  satisfiable_clause_set (cl_ecl ` S)\n\ngoal (1 subgoal):\n 1. satisfiable_clause_set (cl_ecl ` S) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  satisfiable_clause_set (cl_ecl ` S)", "obtain I where \"fo_interpretation I\" and model: \"validate_clause_set I (cl_ecl ` S)\""], ["proof (prove)\nusing this:\n  satisfiable_clause_set (cl_ecl ` S)\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        \\<lbrakk>fo_interpretation I;\n         validate_clause_set I (cl_ecl ` S)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding satisfiable_clause_set_def [of \"cl_ecl ` S\"]"], ["proof (prove)\nusing this:\n  \\<exists>I. fo_interpretation I \\<and> validate_clause_set I (cl_ecl ` S)\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        \\<lbrakk>fo_interpretation I;\n         validate_clause_set I (cl_ecl ` S)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  fo_interpretation I\n  validate_clause_set I (cl_ecl ` S)\n\ngoal (1 subgoal):\n 1. satisfiable_clause_set (cl_ecl ` S) \\<Longrightarrow> False", "from assms(1) assms(2)"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  derivable_ecl C S", "have \"set_entails_clause (cl_ecl ` S) (cl_ecl C)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  derivable_ecl C S\n\ngoal (1 subgoal):\n 1. set_entails_clause (cl_ecl ` S) (cl_ecl C)", "using SOUNDNESS"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  derivable_ecl C S\n  \\<lbrakk>derivable_ecl ?C ?S;\n   \\<forall>x\\<in>?S. finite (cl_ecl x)\\<rbrakk>\n  \\<Longrightarrow> set_entails_clause (cl_ecl ` ?S) (cl_ecl ?C)\n\ngoal (1 subgoal):\n 1. set_entails_clause (cl_ecl ` S) (cl_ecl C)", "by metis"], ["proof (state)\nthis:\n  set_entails_clause (cl_ecl ` S) (cl_ecl C)\n\ngoal (1 subgoal):\n 1. satisfiable_clause_set (cl_ecl ` S) \\<Longrightarrow> False", "from this \\<open>fo_interpretation I\\<close> and model"], ["proof (chain)\npicking this:\n  set_entails_clause (cl_ecl ` S) (cl_ecl C)\n  fo_interpretation I\n  validate_clause_set I (cl_ecl ` S)", "have \"validate_clause I (cl_ecl C)\""], ["proof (prove)\nusing this:\n  set_entails_clause (cl_ecl ` S) (cl_ecl C)\n  fo_interpretation I\n  validate_clause_set I (cl_ecl ` S)\n\ngoal (1 subgoal):\n 1. validate_clause I (cl_ecl C)", "unfolding set_entails_clause_def"], ["proof (prove)\nusing this:\n  \\<forall>I.\n     fo_interpretation I \\<longrightarrow>\n     validate_clause_set I (cl_ecl ` S) \\<longrightarrow>\n     validate_clause I (cl_ecl C)\n  fo_interpretation I\n  validate_clause_set I (cl_ecl ` S)\n\ngoal (1 subgoal):\n 1. validate_clause I (cl_ecl C)", "by auto"], ["proof (state)\nthis:\n  validate_clause I (cl_ecl C)\n\ngoal (1 subgoal):\n 1. satisfiable_clause_set (cl_ecl ` S) \\<Longrightarrow> False", "from this and assms(3)"], ["proof (chain)\npicking this:\n  validate_clause I (cl_ecl C)\n  cl_ecl C = {}", "show False"], ["proof (prove)\nusing this:\n  validate_clause I (cl_ecl C)\n  cl_ecl C = {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Redundancy Criteria and Saturated Sets\\<close>"], ["", "text \\<open>We define redundancy criteria. We use similar notions as in the Bachmair and Ganzinger\npaper, the only difference is that we have to handle the sets of irreducible terms associated\nwith the clauses. Indeed, to ensure completeness, we must guarantee that all the terms that are \nirreducible in the entailing clauses are also irreducible in the entailed one \n(otherwise some needed inferences could be blocked due the irreducibility condition, as in the basic \nsuperposition calculus). Of course, if the attached sets of terms are empty, then this condition \ntrivially holds and the definition collapses to the usual one. \n\nWe introduce the following relation:\\<close>"], ["", "definition subterms_inclusion :: \"'a trm set \\<Rightarrow> 'a trm set \\<Rightarrow> bool\"\n  where \"subterms_inclusion E1 E2 = (\\<forall>x1 \\<in> E1. \\<exists>x2 \\<in> E2. (occurs_in x1 x2))\""], ["", "lemma subterms_inclusion_refl:\n shows \"subterms_inclusion E E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subterms_inclusion E E", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> subterms_inclusion E E \\<Longrightarrow> False", "assume \"\\<not>subterms_inclusion E E\""], ["proof (state)\nthis:\n  \\<not> subterms_inclusion E E\n\ngoal (1 subgoal):\n 1. \\<not> subterms_inclusion E E \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  \\<not> subterms_inclusion E E", "obtain x1 where \"x1 \\<in> E\" and \"\\<not> occurs_in x1 x1\""], ["proof (prove)\nusing this:\n  \\<not> subterms_inclusion E E\n\ngoal (1 subgoal):\n 1. (\\<And>x1.\n        \\<lbrakk>x1 \\<in> E; \\<not> occurs_in x1 x1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding subterms_inclusion_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x1\\<in>E. Bex E (occurs_in x1))\n\ngoal (1 subgoal):\n 1. (\\<And>x1.\n        \\<lbrakk>x1 \\<in> E; \\<not> occurs_in x1 x1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  x1 \\<in> E\n  \\<not> occurs_in x1 x1\n\ngoal (1 subgoal):\n 1. \\<not> subterms_inclusion E E \\<Longrightarrow> False", "from \\<open>\\<not> occurs_in x1 x1\\<close>"], ["proof (chain)\npicking this:\n  \\<not> occurs_in x1 x1", "have \"\\<not> (\\<exists>p. subterm x1 p x1)\""], ["proof (prove)\nusing this:\n  \\<not> occurs_in x1 x1\n\ngoal (1 subgoal):\n 1. \\<nexists>p. subterm x1 p x1", "unfolding occurs_in_def"], ["proof (prove)\nusing this:\n  \\<nexists>p. subterm x1 p x1\n\ngoal (1 subgoal):\n 1. \\<nexists>p. subterm x1 p x1", "by auto"], ["proof (state)\nthis:\n  \\<nexists>p. subterm x1 p x1\n\ngoal (1 subgoal):\n 1. \\<not> subterms_inclusion E E \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  \\<nexists>p. subterm x1 p x1", "have \"\\<not>subterm x1 Nil x1\""], ["proof (prove)\nusing this:\n  \\<nexists>p. subterm x1 p x1\n\ngoal (1 subgoal):\n 1. \\<not> subterm x1 [] x1", "by metis"], ["proof (state)\nthis:\n  \\<not> subterm x1 [] x1\n\ngoal (1 subgoal):\n 1. \\<not> subterms_inclusion E E \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  \\<not> subterm x1 [] x1", "show False"], ["proof (prove)\nusing this:\n  \\<not> subterm x1 [] x1\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subterms_inclusion_subset:\n  assumes \"subterms_inclusion E1 E2\"\n  assumes \"E2 \\<subseteq> E2'\"\n  shows \"subterms_inclusion E1 E2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subterms_inclusion E1 E2'", "by (meson assms(1) assms(2) basic_superposition.subterms_inclusion_def basic_superposition_axioms \n      subsetD)"], ["", "lemma set_inclusion_preserve_normalization:\n  assumes \"all_trms_irreducible E f\"\n  assumes \"E' \\<subseteq> E\"\n  shows \"all_trms_irreducible E' f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_trms_irreducible E' f", "by (meson all_trms_irreducible_def assms(1) assms(2) subsetD)"], ["", "lemma subterms_inclusion_preserves_normalization:\n  assumes \"all_trms_irreducible E f\"\n  assumes \"subterms_inclusion E' E\"\n  shows \"all_trms_irreducible E' f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_trms_irreducible E' f", "by (meson all_trms_irreducible_def assms(1) assms(2) occur_in_subterm subterms_inclusion_def)"], ["", "text \\<open>We define two notions of redundancy, the first one is for inferences: any derivable clause \nmust be entailed by a set of clauses that are strictly smaller than one of the premises.\\<close>"], ["", "definition redundant_inference :: \n  \"'a eclause \\<Rightarrow> 'a eclause set \\<Rightarrow> 'a eclause set \\<Rightarrow> 'a subst \\<Rightarrow> bool\"\n  where \"(redundant_inference C S P \\<sigma>) = \n    (\\<exists>S'. (S' \\<subseteq> (instances S) \\<and> (set_entails_clause (clset_instances S') (cl_ecl C)) \\<and> \n            (\\<forall>x \\<in> S'. ( subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) \n              (trms_ecl C))) \\<and>\n            (\\<forall>x \\<in> S'. \\<exists>D' \\<in> P. (((fst x),(snd x)),(D',\\<sigma>)) \\<in> ecl_ord)))\""], ["", "text \\<open>The second one is the usual notion for clauses: a clause is redundant if it is entailed by\nsmaller (or equal) clauses.\\<close>"], ["", "definition redundant_clause :: \n  \"'a eclause \\<Rightarrow> 'a eclause set  \\<Rightarrow> 'a subst \\<Rightarrow> 'a clause \\<Rightarrow> bool\"\n  where \"(redundant_clause C S \\<sigma> C') = \n    (\\<exists>S'. (S' \\<subseteq> (instances S) \\<and> (set_entails_clause (clset_instances S') (cl_ecl C)) \\<and> \n            (\\<forall>x \\<in> S'. ( subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) \n              (trms_ecl C))) \\<and>\n            (\\<forall>x \\<in> S'. ( ((mset_ecl ((fst x),(snd x))),(mset_cl (C',\\<sigma>))) \\<in> (mult (mult trm_ord))\n              \\<or> (mset_ecl ((fst x),(snd x))) = mset_cl (C',\\<sigma>)))))\""], ["", "text \\<open>Note that according to the definition above, an extended clause is always \nredundant w.r.t.\\ a clause obtained from the initial one by adding in the attached set of \nterms a subterm of a term that already occurs in this set. This remark is important because \nexplicitly adding such subterms in the attached set may prune the search space, due to the fact \nthat the containing term can be removed at some point when calling the function @{term \"dom_trm\"}.\nAdding the subterm explicitly is thus useful in this case. In practice, the simplest solution may be \nto assume that the set of irreducible terms is closed under subterm. \n\nOf course, a clause is also redundant w.r.t.\\ any clause obtained by removing terms in the attached\nset. In particular, terms can be safely removed from the set of irreducible terms of the entailing \nclauses if needed to make a given clause redundant.\\<close>"], ["", "lemma self_redundant_clause:\n  assumes \"C \\<in> S\"\n  assumes \"C' = (cl_ecl C)\"\n  assumes \"ground_clause (subst_cl (cl_ecl C) \\<sigma>)\"\n  shows \"redundant_clause (subst_ecl C \\<sigma>) S \\<sigma> C'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redundant_clause (subst_ecl C \\<sigma>) S \\<sigma> C'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. redundant_clause (subst_ecl C \\<sigma>) S \\<sigma> C'", "obtain Cl_C and T where \"C = Ecl Cl_C T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Cl_C T.\n        C = Ecl Cl_C T \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using eclause.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = Ecl x1 x2 \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>Cl_C T.\n        C = Ecl Cl_C T \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C = Ecl Cl_C T\n\ngoal (1 subgoal):\n 1. redundant_clause (subst_ecl C \\<sigma>) S \\<sigma> C'", "from this"], ["proof (chain)\npicking this:\n  C = Ecl Cl_C T", "have \"cl_ecl C = Cl_C\" and \"trms_ecl C = T\""], ["proof (prove)\nusing this:\n  C = Ecl Cl_C T\n\ngoal (1 subgoal):\n 1. cl_ecl C = Cl_C &&& trms_ecl C = T", "by auto"], ["proof (state)\nthis:\n  cl_ecl C = Cl_C\n  trms_ecl C = T\n\ngoal (1 subgoal):\n 1. redundant_clause (subst_ecl C \\<sigma>) S \\<sigma> C'", "let ?Cl_C = \"subst_cl Cl_C \\<sigma>\""], ["proof (state)\ngoal (1 subgoal):\n 1. redundant_clause (subst_ecl C \\<sigma>) S \\<sigma> C'", "let ?T  = \"subst_set T \\<sigma>\""], ["proof (state)\ngoal (1 subgoal):\n 1. redundant_clause (subst_ecl C \\<sigma>) S \\<sigma> C'", "let ?C = \"subst_ecl C \\<sigma>\""], ["proof (state)\ngoal (1 subgoal):\n 1. redundant_clause (subst_ecl C \\<sigma>) S \\<sigma> C'", "from \\<open>C = Ecl Cl_C T\\<close>"], ["proof (chain)\npicking this:\n  C = Ecl Cl_C T", "have \"?C = (Ecl ?Cl_C ?T)\""], ["proof (prove)\nusing this:\n  C = Ecl Cl_C T\n\ngoal (1 subgoal):\n 1. subst_ecl C \\<sigma> =\n    Ecl (subst_cl Cl_C \\<sigma>) (subst_set T \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  subst_ecl C \\<sigma> = Ecl (subst_cl Cl_C \\<sigma>) (subst_set T \\<sigma>)\n\ngoal (1 subgoal):\n 1. redundant_clause (subst_ecl C \\<sigma>) S \\<sigma> C'", "from this"], ["proof (chain)\npicking this:\n  subst_ecl C \\<sigma> = Ecl (subst_cl Cl_C \\<sigma>) (subst_set T \\<sigma>)", "have \"cl_ecl ?C = ?Cl_C\" and \"trms_ecl ?C = ?T\""], ["proof (prove)\nusing this:\n  subst_ecl C \\<sigma> = Ecl (subst_cl Cl_C \\<sigma>) (subst_set T \\<sigma>)\n\ngoal (1 subgoal):\n 1. cl_ecl (subst_ecl C \\<sigma>) = subst_cl Cl_C \\<sigma> &&&\n    trms_ecl (subst_ecl C \\<sigma>) = subst_set T \\<sigma>", "by auto"], ["proof (state)\nthis:\n  cl_ecl (subst_ecl C \\<sigma>) = subst_cl Cl_C \\<sigma>\n  trms_ecl (subst_ecl C \\<sigma>) = subst_set T \\<sigma>\n\ngoal (1 subgoal):\n 1. redundant_clause (subst_ecl C \\<sigma>) S \\<sigma> C'", "let ?S = \"{ (C,\\<sigma>) }\""], ["proof (state)\ngoal (1 subgoal):\n 1. redundant_clause (subst_ecl C \\<sigma>) S \\<sigma> C'", "from assms(1) assms(3)"], ["proof (chain)\npicking this:\n  C \\<in> S\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)", "have i: \"?S \\<subseteq> (instances S)\""], ["proof (prove)\nusing this:\n  C \\<in> S\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. {(C, \\<sigma>)} \\<subseteq> instances S", "unfolding instances_def"], ["proof (prove)\nusing this:\n  C \\<in> S\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. {(C, \\<sigma>)}\n    \\<subseteq> {x. \\<exists>C \\<sigma>.\n                       C \\<in> S \\<and>\n                       ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<and>\n                       x = (C, \\<sigma>)}", "by auto"], ["proof (state)\nthis:\n  {(C, \\<sigma>)} \\<subseteq> instances S\n\ngoal (1 subgoal):\n 1. redundant_clause (subst_ecl C \\<sigma>) S \\<sigma> C'", "from \\<open>cl_ecl C = Cl_C\\<close>"], ["proof (chain)\npicking this:\n  cl_ecl C = Cl_C", "have \"clset_instances ?S = { ?Cl_C }\""], ["proof (prove)\nusing this:\n  cl_ecl C = Cl_C\n\ngoal (1 subgoal):\n 1. clset_instances {(C, \\<sigma>)} = {subst_cl Cl_C \\<sigma>}", "unfolding clset_instances_def"], ["proof (prove)\nusing this:\n  cl_ecl C = Cl_C\n\ngoal (1 subgoal):\n 1. {Ca.\n     \\<exists>x.\n        x \\<in> {(C, \\<sigma>)} \\<and>\n        Ca = subst_cl (cl_ecl (fst x)) (snd x)} =\n    {subst_cl Cl_C \\<sigma>}", "by auto"], ["proof (state)\nthis:\n  clset_instances {(C, \\<sigma>)} = {subst_cl Cl_C \\<sigma>}\n\ngoal (1 subgoal):\n 1. redundant_clause (subst_ecl C \\<sigma>) S \\<sigma> C'", "from this and \\<open>cl_ecl ?C = ?Cl_C\\<close>"], ["proof (chain)\npicking this:\n  clset_instances {(C, \\<sigma>)} = {subst_cl Cl_C \\<sigma>}\n  cl_ecl (subst_ecl C \\<sigma>) = subst_cl Cl_C \\<sigma>", "have ii: \"set_entails_clause (clset_instances ?S) (cl_ecl ?C)\""], ["proof (prove)\nusing this:\n  clset_instances {(C, \\<sigma>)} = {subst_cl Cl_C \\<sigma>}\n  cl_ecl (subst_ecl C \\<sigma>) = subst_cl Cl_C \\<sigma>\n\ngoal (1 subgoal):\n 1. set_entails_clause (clset_instances {(C, \\<sigma>)})\n     (cl_ecl (subst_ecl C \\<sigma>))", "using set_entails_clause_member"], ["proof (prove)\nusing this:\n  clset_instances {(C, \\<sigma>)} = {subst_cl Cl_C \\<sigma>}\n  cl_ecl (subst_ecl C \\<sigma>) = subst_cl Cl_C \\<sigma>\n  ?C \\<in> ?S \\<Longrightarrow> set_entails_clause ?S ?C\n\ngoal (1 subgoal):\n 1. set_entails_clause (clset_instances {(C, \\<sigma>)})\n     (cl_ecl (subst_ecl C \\<sigma>))", "by force"], ["proof (state)\nthis:\n  set_entails_clause (clset_instances {(C, \\<sigma>)})\n   (cl_ecl (subst_ecl C \\<sigma>))\n\ngoal (1 subgoal):\n 1. redundant_clause (subst_ecl C \\<sigma>) S \\<sigma> C'", "have iii: \"(\\<forall>x \\<in> ?S. ( subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) \n              (trms_ecl ?C)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{(C, \\<sigma>)}.\n       subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n        (trms_ecl (subst_ecl C \\<sigma>))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(C, \\<sigma>)} \\<Longrightarrow>\n       subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n        (trms_ecl (subst_ecl C \\<sigma>))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(C, \\<sigma>)} \\<Longrightarrow>\n       subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n        (trms_ecl (subst_ecl C \\<sigma>))", "assume \"x \\<in> ?S\""], ["proof (state)\nthis:\n  x \\<in> {(C, \\<sigma>)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(C, \\<sigma>)} \\<Longrightarrow>\n       subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n        (trms_ecl (subst_ecl C \\<sigma>))", "from this"], ["proof (chain)\npicking this:\n  x \\<in> {(C, \\<sigma>)}", "have \"x = (C,\\<sigma>)\""], ["proof (prove)\nusing this:\n  x \\<in> {(C, \\<sigma>)}\n\ngoal (1 subgoal):\n 1. x = (C, \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  x = (C, \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(C, \\<sigma>)} \\<Longrightarrow>\n       subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n        (trms_ecl (subst_ecl C \\<sigma>))", "from this \\<open>C = Ecl Cl_C T\\<close>"], ["proof (chain)\npicking this:\n  x = (C, \\<sigma>)\n  C = Ecl Cl_C T", "have \"subst_set (trms_ecl (fst x)) (snd x) = ?T\""], ["proof (prove)\nusing this:\n  x = (C, \\<sigma>)\n  C = Ecl Cl_C T\n\ngoal (1 subgoal):\n 1. subst_set (trms_ecl (fst x)) (snd x) = subst_set T \\<sigma>", "by auto"], ["proof (state)\nthis:\n  subst_set (trms_ecl (fst x)) (snd x) = subst_set T \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(C, \\<sigma>)} \\<Longrightarrow>\n       subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n        (trms_ecl (subst_ecl C \\<sigma>))", "from this and \\<open>trms_ecl ?C = ?T\\<close>"], ["proof (chain)\npicking this:\n  subst_set (trms_ecl (fst x)) (snd x) = subst_set T \\<sigma>\n  trms_ecl (subst_ecl C \\<sigma>) = subst_set T \\<sigma>", "have \"subst_set (trms_ecl (fst x)) (snd x) = (trms_ecl ?C)\""], ["proof (prove)\nusing this:\n  subst_set (trms_ecl (fst x)) (snd x) = subst_set T \\<sigma>\n  trms_ecl (subst_ecl C \\<sigma>) = subst_set T \\<sigma>\n\ngoal (1 subgoal):\n 1. subst_set (trms_ecl (fst x)) (snd x) = trms_ecl (subst_ecl C \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  subst_set (trms_ecl (fst x)) (snd x) = trms_ecl (subst_ecl C \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(C, \\<sigma>)} \\<Longrightarrow>\n       subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n        (trms_ecl (subst_ecl C \\<sigma>))", "from this"], ["proof (chain)\npicking this:\n  subst_set (trms_ecl (fst x)) (snd x) = trms_ecl (subst_ecl C \\<sigma>)", "show \"( subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) \n              (trms_ecl ?C))\""], ["proof (prove)\nusing this:\n  subst_set (trms_ecl (fst x)) (snd x) = trms_ecl (subst_ecl C \\<sigma>)\n\ngoal (1 subgoal):\n 1. subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n     (trms_ecl (subst_ecl C \\<sigma>))", "using subterms_inclusion_refl"], ["proof (prove)\nusing this:\n  subst_set (trms_ecl (fst x)) (snd x) = trms_ecl (subst_ecl C \\<sigma>)\n  subterms_inclusion ?E ?E\n\ngoal (1 subgoal):\n 1. subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n     (trms_ecl (subst_ecl C \\<sigma>))", "by auto"], ["proof (state)\nthis:\n  subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n   (trms_ecl (subst_ecl C \\<sigma>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{(C, \\<sigma>)}.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n      (trms_ecl (subst_ecl C \\<sigma>))\n\ngoal (1 subgoal):\n 1. redundant_clause (subst_ecl C \\<sigma>) S \\<sigma> C'", "have iv: \"(\\<forall>x \\<in> ?S. ( ((mset_ecl ((fst x),(snd x))),(mset_cl (C',\\<sigma>))) \\<in> (mult (mult trm_ord))\n              \\<or> (mset_ecl ((fst x),(snd x))) = mset_cl (C',\\<sigma>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{(C, \\<sigma>)}.\n       (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n       \\<in> mult (mult trm_ord) \\<or>\n       mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(C, \\<sigma>)} \\<Longrightarrow>\n       (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n       \\<in> mult (mult trm_ord) \\<or>\n       mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(C, \\<sigma>)} \\<Longrightarrow>\n       (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n       \\<in> mult (mult trm_ord) \\<or>\n       mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)", "assume \"x \\<in> ?S\""], ["proof (state)\nthis:\n  x \\<in> {(C, \\<sigma>)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(C, \\<sigma>)} \\<Longrightarrow>\n       (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n       \\<in> mult (mult trm_ord) \\<or>\n       mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)", "from this"], ["proof (chain)\npicking this:\n  x \\<in> {(C, \\<sigma>)}", "have \"x = (C,\\<sigma>)\""], ["proof (prove)\nusing this:\n  x \\<in> {(C, \\<sigma>)}\n\ngoal (1 subgoal):\n 1. x = (C, \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  x = (C, \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(C, \\<sigma>)} \\<Longrightarrow>\n       (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n       \\<in> mult (mult trm_ord) \\<or>\n       mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)", "from this \\<open>C = Ecl Cl_C T\\<close>"], ["proof (chain)\npicking this:\n  x = (C, \\<sigma>)\n  C = Ecl Cl_C T", "have \"(mset_ecl ((fst x),(snd x))) = (mset_ecl (C,\\<sigma>))\""], ["proof (prove)\nusing this:\n  x = (C, \\<sigma>)\n  C = Ecl Cl_C T\n\ngoal (1 subgoal):\n 1. mset_ecl (fst x, snd x) = mset_ecl (C, \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  mset_ecl (fst x, snd x) = mset_ecl (C, \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(C, \\<sigma>)} \\<Longrightarrow>\n       (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n       \\<in> mult (mult trm_ord) \\<or>\n       mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)", "from this \\<open>C' = (cl_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  mset_ecl (fst x, snd x) = mset_ecl (C, \\<sigma>)\n  C' = cl_ecl C", "have \"(mset_ecl ((fst x),(snd x))) = mset_cl (C',\\<sigma>)\""], ["proof (prove)\nusing this:\n  mset_ecl (fst x, snd x) = mset_ecl (C, \\<sigma>)\n  C' = cl_ecl C\n\ngoal (1 subgoal):\n 1. mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {(C, \\<sigma>)} \\<Longrightarrow>\n       (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n       \\<in> mult (mult trm_ord) \\<or>\n       mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)", "from this"], ["proof (chain)\npicking this:\n  mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)", "show \"( ((mset_ecl ((fst x),(snd x))),(mset_cl (C',\\<sigma>))) \\<in> (mult (mult trm_ord))\n              \\<or> (mset_ecl ((fst x),(snd x))) = mset_cl (C',\\<sigma>))\""], ["proof (prove)\nusing this:\n  mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)\n\ngoal (1 subgoal):\n 1. (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n    \\<in> mult (mult trm_ord) \\<or>\n    mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n  \\<in> mult (mult trm_ord) \\<or>\n  mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{(C, \\<sigma>)}.\n     (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n     \\<in> mult (mult trm_ord) \\<or>\n     mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)\n\ngoal (1 subgoal):\n 1. redundant_clause (subst_ecl C \\<sigma>) S \\<sigma> C'", "from i ii iii iv"], ["proof (chain)\npicking this:\n  {(C, \\<sigma>)} \\<subseteq> instances S\n  set_entails_clause (clset_instances {(C, \\<sigma>)})\n   (cl_ecl (subst_ecl C \\<sigma>))\n  \\<forall>x\\<in>{(C, \\<sigma>)}.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n      (trms_ecl (subst_ecl C \\<sigma>))\n  \\<forall>x\\<in>{(C, \\<sigma>)}.\n     (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n     \\<in> mult (mult trm_ord) \\<or>\n     mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)", "show ?thesis"], ["proof (prove)\nusing this:\n  {(C, \\<sigma>)} \\<subseteq> instances S\n  set_entails_clause (clset_instances {(C, \\<sigma>)})\n   (cl_ecl (subst_ecl C \\<sigma>))\n  \\<forall>x\\<in>{(C, \\<sigma>)}.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n      (trms_ecl (subst_ecl C \\<sigma>))\n  \\<forall>x\\<in>{(C, \\<sigma>)}.\n     (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n     \\<in> mult (mult trm_ord) \\<or>\n     mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)\n\ngoal (1 subgoal):\n 1. redundant_clause (subst_ecl C \\<sigma>) S \\<sigma> C'", "unfolding redundant_clause_def"], ["proof (prove)\nusing this:\n  {(C, \\<sigma>)} \\<subseteq> instances S\n  set_entails_clause (clset_instances {(C, \\<sigma>)})\n   (cl_ecl (subst_ecl C \\<sigma>))\n  \\<forall>x\\<in>{(C, \\<sigma>)}.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n      (trms_ecl (subst_ecl C \\<sigma>))\n  \\<forall>x\\<in>{(C, \\<sigma>)}.\n     (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n     \\<in> mult (mult trm_ord) \\<or>\n     mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>S'\\<subseteq>instances S.\n       set_entails_clause (clset_instances S')\n        (cl_ecl (subst_ecl C \\<sigma>)) \\<and>\n       (\\<forall>x\\<in>S'.\n           subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n            (trms_ecl (subst_ecl C \\<sigma>))) \\<and>\n       (\\<forall>x\\<in>S'.\n           (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n           \\<in> mult (mult trm_ord) \\<or>\n           mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>))", "by metis"], ["proof (state)\nthis:\n  redundant_clause (subst_ecl C \\<sigma>) S \\<sigma> C'\n\ngoal:\nNo subgoals!", "qed"], ["", "definition trms_subsumes\n  where \"trms_subsumes C D \\<sigma>\n    = ( (subst_cl (cl_ecl C) \\<sigma>) = (cl_ecl D) \n    \\<and> ((subst_set (trms_ecl C) \\<sigma>) \\<subseteq> trms_ecl D))\""], ["", "definition inference_closed \n  where \"inference_closed S  = (\\<forall> P C' D \\<theta>. \n      (derivable D P S \\<theta> FirstOrder C') \\<longrightarrow> (D \\<in> S))\""], ["", "text \\<open>Various notions of saturatedness are defined, depending on the kind of inferences that are \nconsidered and on the redundancy criterion.\\<close>"], ["", "text \\<open>The first definition is the weakest one: all ground inferences must be redundant (this \ndefinition is used for the completeness proof to make it the most general).\\<close>"], ["", "definition ground_inference_saturated :: \"'a eclause set \\<Rightarrow> bool\"\n  where \"(ground_inference_saturated S) = (\\<forall> C P \\<sigma> C'. (derivable C P S \\<sigma> Ground C') \\<longrightarrow> \n      (ground_clause (cl_ecl C)) \\<longrightarrow> (grounding_set P \\<sigma>) \\<longrightarrow> (redundant_inference C S P \\<sigma>))\""], ["", "text \\<open>The second one states that every ground instance of a first-order inference must be \nredundant.\\<close>"], ["", "definition inference_saturated :: \"'a eclause set \\<Rightarrow> bool\"\n  where \"(inference_saturated S) = (\\<forall> C P \\<sigma> C' D \\<theta> \\<eta>. \n     (derivable C P S \\<sigma> Ground C') \\<longrightarrow> (ground_clause (cl_ecl C)) \\<longrightarrow> (grounding_set P \\<sigma>) \n      \\<longrightarrow> (derivable D P S \\<theta> FirstOrder C') \\<longrightarrow> (trms_subsumes D C \\<eta>)\n      \\<longrightarrow> (\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>)\n      \\<longrightarrow> (redundant_inference (subst_ecl D \\<eta>) S P \\<sigma>))\""], ["", "text \\<open>The last definition is the most restrictive one: every derivable clause must be \nredundant.\\<close>"], ["", "definition clause_saturated :: \"'a eclause set \\<Rightarrow> bool\"\n  where \"(clause_saturated S) = (\\<forall> C P \\<sigma> C' D \\<theta> \\<eta>. \n     (derivable C P S \\<sigma> Ground C') \\<longrightarrow> (ground_clause (cl_ecl C)) \n      \\<longrightarrow> (derivable D P S \\<theta> FirstOrder C') \\<longrightarrow> (trms_subsumes D C \\<eta>)\n      \\<longrightarrow> (\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>)\n      \\<longrightarrow> (redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C'))\""], ["", "text \\<open>We now relate these various notions, so that the forthcoming completeness proof applies\nto all of them. To this purpose, we have to show that the conclusion of a (ground) inference rule \nis always strictly smaller than one of the premises.\\<close>"], ["", "lemma conclusion_is_smaller_than_premisses:\n  assumes \"derivable C P S \\<sigma> Ground C'\"\n  assumes \"\\<forall>x \\<in> S. (finite (cl_ecl x))\" \n  assumes \"grounding_set P \\<sigma>\" \n  shows \"\\<exists> D. (D \\<in> P \\<and> (( (mset_cl (C',\\<sigma>)), (mset_ecl (D,\\<sigma>))) \\<in> (mult (mult trm_ord))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>D.\n       D \\<in> P \\<and>\n       (mset_cl (C', \\<sigma>), mset_ecl (D, \\<sigma>))\n       \\<in> mult (mult trm_ord)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>D.\n       D \\<in> P \\<and>\n       (mset_cl (C', \\<sigma>), mset_ecl (D, \\<sigma>))\n       \\<in> mult (mult trm_ord) \\<Longrightarrow>\n    False", "assume hyp: \"\\<not> (\\<exists> D. (D \\<in> P \\<and> (( (mset_cl (C',\\<sigma>)), (mset_ecl (D,\\<sigma>))) \\<in> (mult (mult trm_ord)))))\""], ["proof (state)\nthis:\n  \\<nexists>D.\n     D \\<in> P \\<and>\n     (mset_cl (C', \\<sigma>), mset_ecl (D, \\<sigma>))\n     \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. \\<nexists>D.\n       D \\<in> P \\<and>\n       (mset_cl (C', \\<sigma>), mset_ecl (D, \\<sigma>))\n       \\<in> mult (mult trm_ord) \\<Longrightarrow>\n    False", "from assms(1)"], ["proof (chain)\npicking this:\n  derivable C P S \\<sigma> Ground C'", "have \"P \\<subseteq> S\""], ["proof (prove)\nusing this:\n  derivable C P S \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. P \\<subseteq> S", "unfolding derivable_def"], ["proof (prove)\nusing this:\n  (\\<exists>P1 P2.\n      P1 \\<in> S \\<and>\n      P2 \\<in> S \\<and>\n      P = {P1, P2} \\<and> superposition P1 P2 C \\<sigma> Ground C') \\<or>\n  (\\<exists>P1.\n      P1 \\<in> S \\<and>\n      P = {P1} \\<and> factorization P1 C \\<sigma> Ground C') \\<or>\n  (\\<exists>P1.\n      P1 \\<in> S \\<and> P = {P1} \\<and> reflexion P1 C \\<sigma> Ground C')\n\ngoal (1 subgoal):\n 1. P \\<subseteq> S", "by auto"], ["proof (state)\nthis:\n  P \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<nexists>D.\n       D \\<in> P \\<and>\n       (mset_cl (C', \\<sigma>), mset_ecl (D, \\<sigma>))\n       \\<in> mult (mult trm_ord) \\<Longrightarrow>\n    False", "have not_sup: \"\\<not> (\\<exists>P1 P2. (P1 \\<in> P \\<and> P2 \\<in> P \\<and> superposition P1 P2 C \\<sigma> Ground C'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and> superposition P1 P2 C \\<sigma> Ground C'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "assume \"(\\<exists>P1 P2. (P1 \\<in> P \\<and> P2 \\<in> P \\<and> superposition P1 P2 C \\<sigma> Ground C'))\""], ["proof (state)\nthis:\n  \\<exists>P1 P2.\n     P1 \\<in> P \\<and>\n     P2 \\<in> P \\<and> superposition P1 P2 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>P1 P2.\n     P1 \\<in> P \\<and>\n     P2 \\<in> P \\<and> superposition P1 P2 C \\<sigma> Ground C'", "obtain P1 P2 where \"P1 \\<in> P\" \"P2 \\<in> P\" \"superposition P1 P2 C \\<sigma> Ground C'\""], ["proof (prove)\nusing this:\n  \\<exists>P1 P2.\n     P1 \\<in> P \\<and>\n     P2 \\<in> P \\<and> superposition P1 P2 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2.\n        \\<lbrakk>P1 \\<in> P; P2 \\<in> P;\n         superposition P1 P2 C \\<sigma> Ground C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> P\n  P2 \\<in> P\n  superposition P1 P2 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>superposition P1 P2 C \\<sigma> Ground C'\\<close>"], ["proof (chain)\npicking this:\n  superposition P1 P2 C \\<sigma> Ground C'", "obtain L t s u v M  L' polarity u' p t' Cl_C NT where\n      \"M \\<in> (cl_ecl P2)\" \"L \\<in> (cl_ecl P1)\"\n      \"orient_lit_inst M u v pos \\<sigma>\" \n      \"orient_lit_inst L t s polarity \\<sigma>\" \n      \"subterm t p u'\"\n      \"ck_unifier u' u \\<sigma> Ground\"\n      \"replace_subterm t p v t'\"\n      \"L' = mk_lit polarity (Eq t' s)\" \n      \"(C = (Ecl Cl_C NT))\"\n      \"(subst u \\<sigma>) \\<noteq> (subst v \\<sigma>)\" \n      \"( (subst_lit M \\<sigma>),(subst_lit L \\<sigma>)) \n            \\<in> lit_ord\"\n      \"strictly_maximal_literal P2 M \\<sigma>\"\n      \"Cl_C = (subst_cl (((cl_ecl P1) - { L }) \\<union> (((cl_ecl P2) - { M }) \\<union> { L' } )) \\<sigma>)\"\n      \"C' = (((cl_ecl P1) - { L }) \\<union> (((cl_ecl P2) - { M }) \\<union> { L' } ))\""], ["proof (prove)\nusing this:\n  superposition P1 P2 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. (\\<And>M L u v t s polarity p u' t' L' Cl_C NT.\n        \\<lbrakk>M \\<in> cl_ecl P2; L \\<in> cl_ecl P1;\n         orient_lit_inst M u v pos \\<sigma>;\n         orient_lit_inst L t s polarity \\<sigma>; subterm t p u';\n         ck_unifier u' u \\<sigma> Ground; replace_subterm t p v t';\n         L' = mk_lit polarity (Eq t' s); C = Ecl Cl_C NT;\n         u \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>;\n         (subst_lit M \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord;\n         strictly_maximal_literal P2 M \\<sigma>;\n         Cl_C =\n         subst_cl (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))\n          \\<sigma>;\n         C' =\n         cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding superposition_def"], ["proof (prove)\nusing this:\n  \\<exists>L t s u v M p Cl_P1 Cl_P2 Cl_C polarity t' u' L' trms_C.\n     L \\<in> Cl_P1 \\<and>\n     M \\<in> Cl_P2 \\<and>\n     eligible_literal L P1 \\<sigma> \\<and>\n     eligible_literal M P2 \\<sigma> \\<and>\n     variable_disjoint P1 P2 \\<and>\n     Cl_P1 = cl_ecl P1 \\<and>\n     Cl_P2 = cl_ecl P2 \\<and>\n     \\<not> is_a_variable u' \\<and>\n     allowed_redex u' P1 \\<sigma> \\<and>\n     trms_C =\n     get_trms Cl_C\n      (dom_trms Cl_C\n        (subst_set\n          (trms_ecl P1 \\<union> trms_ecl P2 \\<union>\n           {r. \\<exists>q. (q, p) \\<in> pos_ord P1 t \\<and> subterm t q r})\n          \\<sigma>))\n      Ground \\<and>\n     C = Ecl Cl_C trms_C \\<and>\n     orient_lit_inst M u v pos \\<sigma> \\<and>\n     orient_lit_inst L t s polarity \\<sigma> \\<and>\n     u \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma> \\<and>\n     subterm t p u' \\<and>\n     ck_unifier u' u \\<sigma> Ground \\<and>\n     replace_subterm t p v t' \\<and>\n     (Ground = FirstOrder \\<or>\n      (subst_lit M \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord) \\<and>\n     (Ground = FirstOrder \\<or>\n      strictly_maximal_literal P2 M \\<sigma>) \\<and>\n     L' = mk_lit polarity (Eq t' s) \\<and>\n     Cl_C = subst_cl C' \\<sigma> \\<and>\n     C' = Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})\n\ngoal (1 subgoal):\n 1. (\\<And>M L u v t s polarity p u' t' L' Cl_C NT.\n        \\<lbrakk>M \\<in> cl_ecl P2; L \\<in> cl_ecl P1;\n         orient_lit_inst M u v pos \\<sigma>;\n         orient_lit_inst L t s polarity \\<sigma>; subterm t p u';\n         ck_unifier u' u \\<sigma> Ground; replace_subterm t p v t';\n         L' = mk_lit polarity (Eq t' s); C = Ecl Cl_C NT;\n         u \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>;\n         (subst_lit M \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord;\n         strictly_maximal_literal P2 M \\<sigma>;\n         Cl_C =\n         subst_cl (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))\n          \\<sigma>;\n         C' =\n         cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  M \\<in> cl_ecl P2\n  L \\<in> cl_ecl P1\n  orient_lit_inst M u v pos \\<sigma>\n  orient_lit_inst L t s polarity \\<sigma>\n  subterm t p u'\n  ck_unifier u' u \\<sigma> Ground\n  replace_subterm t p v t'\n  L' = mk_lit polarity (Eq t' s)\n  C = Ecl Cl_C NT\n  u \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>\n  (subst_lit M \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord\n  strictly_maximal_literal P2 M \\<sigma>\n  Cl_C =\n  subst_cl (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))\n   \\<sigma>\n  C' = cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'})\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>P1 \\<in> P\\<close> and assms(2) and \\<open>P \\<subseteq> S\\<close>"], ["proof (chain)\npicking this:\n  P1 \\<in> P\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  P \\<subseteq> S", "have \"finite (cl_ecl P1)\""], ["proof (prove)\nusing this:\n  P1 \\<in> P\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  P \\<subseteq> S\n\ngoal (1 subgoal):\n 1. finite (cl_ecl P1)", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl P1)\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>P2 \\<in> P\\<close> and assms(2) and \\<open>P \\<subseteq> S\\<close>"], ["proof (chain)\npicking this:\n  P2 \\<in> P\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  P \\<subseteq> S", "have \"finite (cl_ecl P2)\""], ["proof (prove)\nusing this:\n  P2 \\<in> P\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  P \\<subseteq> S\n\ngoal (1 subgoal):\n 1. finite (cl_ecl P2)", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl P2)\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from assms(3) and \\<open>P2 \\<in> P\\<close>"], ["proof (chain)\npicking this:\n  grounding_set P \\<sigma>\n  P2 \\<in> P", "have \"ground_clause (subst_cl (cl_ecl P2) \\<sigma>)\""], ["proof (prove)\nusing this:\n  grounding_set P \\<sigma>\n  P2 \\<in> P\n\ngoal (1 subgoal):\n 1. ground_clause (subst_cl (cl_ecl P2) \\<sigma>)", "unfolding grounding_set_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in> P \\<longrightarrow>\n     ground_clause (subst_cl (cl_ecl x) \\<sigma>)\n  P2 \\<in> P\n\ngoal (1 subgoal):\n 1. ground_clause (subst_cl (cl_ecl P2) \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  ground_clause (subst_cl (cl_ecl P2) \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  ground_clause (subst_cl (cl_ecl P2) \\<sigma>)", "have \"vars_of_cl (subst_cl (cl_ecl P2) \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  ground_clause (subst_cl (cl_ecl P2) \\<sigma>)\n\ngoal (1 subgoal):\n 1. vars_of_cl (subst_cl (cl_ecl P2) \\<sigma>) = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_cl (subst_cl (cl_ecl P2) \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>M \\<in> (cl_ecl P2)\\<close>"], ["proof (chain)\npicking this:\n  M \\<in> cl_ecl P2", "have \"(subst_lit M \\<sigma>) \\<in> (subst_cl (cl_ecl P2) \\<sigma>)\""], ["proof (prove)\nusing this:\n  M \\<in> cl_ecl P2\n\ngoal (1 subgoal):\n 1. subst_lit M \\<sigma> \\<in> subst_cl (cl_ecl P2) \\<sigma>", "by auto"], ["proof (state)\nthis:\n  subst_lit M \\<sigma> \\<in> subst_cl (cl_ecl P2) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this and \\<open>vars_of_cl (subst_cl (cl_ecl P2) \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  subst_lit M \\<sigma> \\<in> subst_cl (cl_ecl P2) \\<sigma>\n  vars_of_cl (subst_cl (cl_ecl P2) \\<sigma>) = {}", "have \"vars_of_lit (subst_lit M \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  subst_lit M \\<sigma> \\<in> subst_cl (cl_ecl P2) \\<sigma>\n  vars_of_cl (subst_cl (cl_ecl P2) \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. vars_of_lit (subst_lit M \\<sigma>) = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_lit (subst_lit M \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>orient_lit_inst M u v pos \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst M u v pos \\<sigma>", "have \n      \"orient_lit (subst_lit M \\<sigma>) (subst u \\<sigma>) (subst v \\<sigma>) pos\""], ["proof (prove)\nusing this:\n  orient_lit_inst M u v pos \\<sigma>\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit M \\<sigma>) (u \\<lhd> \\<sigma>)\n     (v \\<lhd> \\<sigma>) pos", "using lift_orient_lit"], ["proof (prove)\nusing this:\n  orient_lit_inst M u v pos \\<sigma>\n  orient_lit_inst ?L ?t ?s ?p ?\\<sigma> \\<Longrightarrow>\n  orient_lit (subst_lit ?L ?\\<sigma>) (?t \\<lhd> ?\\<sigma>)\n   (?s \\<lhd> ?\\<sigma>) ?p\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit M \\<sigma>) (u \\<lhd> \\<sigma>)\n     (v \\<lhd> \\<sigma>) pos", "by auto"], ["proof (state)\nthis:\n  orient_lit (subst_lit M \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   pos\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this and \\<open>vars_of_lit (subst_lit M \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  orient_lit (subst_lit M \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   pos\n  vars_of_lit (subst_lit M \\<sigma>) = {}", "have \"vars_of (subst u \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  orient_lit (subst_lit M \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   pos\n  vars_of_lit (subst_lit M \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. vars_of (u \\<lhd> \\<sigma>) = {}", "using orient_lit_vars"], ["proof (prove)\nusing this:\n  orient_lit (subst_lit M \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   pos\n  vars_of_lit (subst_lit M \\<sigma>) = {}\n  orient_lit ?L ?t ?s ?p \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of (u \\<lhd> \\<sigma>) = {}", "by blast"], ["proof (state)\nthis:\n  vars_of (u \\<lhd> \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>orient_lit (subst_lit M \\<sigma>) (subst u \\<sigma>) (subst v \\<sigma>) pos\\<close>\n      and \\<open>vars_of_lit (subst_lit M \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  orient_lit (subst_lit M \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   pos\n  vars_of_lit (subst_lit M \\<sigma>) = {}", "have \"vars_of (subst v \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  orient_lit (subst_lit M \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   pos\n  vars_of_lit (subst_lit M \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. vars_of (v \\<lhd> \\<sigma>) = {}", "using orient_lit_vars"], ["proof (prove)\nusing this:\n  orient_lit (subst_lit M \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   pos\n  vars_of_lit (subst_lit M \\<sigma>) = {}\n  orient_lit ?L ?t ?s ?p \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of (v \\<lhd> \\<sigma>) = {}", "by blast"], ["proof (state)\nthis:\n  vars_of (v \\<lhd> \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>orient_lit (subst_lit M \\<sigma>) (subst u \\<sigma>) (subst v \\<sigma>) pos\\<close>"], ["proof (chain)\npicking this:\n  orient_lit (subst_lit M \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   pos", "have \"((subst u \\<sigma>),(subst v \\<sigma>)) \\<notin> trm_ord\""], ["proof (prove)\nusing this:\n  orient_lit (subst_lit M \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   pos\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord", "unfolding orient_lit_def"], ["proof (prove)\nusing this:\n  (subst_lit M \\<sigma> =\n   Pos (Eq (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)) \\<or>\n   subst_lit M \\<sigma> =\n   Pos (Eq (v \\<lhd> \\<sigma>) (u \\<lhd> \\<sigma>))) \\<and>\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  pos = pos \\<or>\n  (subst_lit M \\<sigma> =\n   Neg (Eq (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)) \\<or>\n   subst_lit M \\<sigma> =\n   Neg (Eq (v \\<lhd> \\<sigma>) (u \\<lhd> \\<sigma>))) \\<and>\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and> pos = neg\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this and \\<open>(subst u \\<sigma>) \\<noteq> (subst v \\<sigma>)\\<close> \n      and \\<open>vars_of (subst u \\<sigma>) = {}\\<close> \\<open>vars_of (subst v \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n  u \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>\n  vars_of (u \\<lhd> \\<sigma>) = {}\n  vars_of (v \\<lhd> \\<sigma>) = {}", "have \"((subst v \\<sigma>),(subst u \\<sigma>)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n  u \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>\n  vars_of (u \\<lhd> \\<sigma>) = {}\n  vars_of (v \\<lhd> \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord", "using trm_ord_ground_total"], ["proof (prove)\nusing this:\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n  u \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>\n  vars_of (u \\<lhd> \\<sigma>) = {}\n  vars_of (v \\<lhd> \\<sigma>) = {}\n  \\<forall>x y.\n     ground_term x \\<longrightarrow>\n     ground_term y \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord", "unfolding ground_term_def"], ["proof (prove)\nusing this:\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n  u \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>\n  vars_of (u \\<lhd> \\<sigma>) = {}\n  vars_of (v \\<lhd> \\<sigma>) = {}\n  \\<forall>x y.\n     vars_of x = {} \\<longrightarrow>\n     vars_of y = {} \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord", "by blast"], ["proof (state)\nthis:\n  (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from assms(3) and \\<open>P1 \\<in> P\\<close>"], ["proof (chain)\npicking this:\n  grounding_set P \\<sigma>\n  P1 \\<in> P", "have \"ground_clause (subst_cl (cl_ecl P1) \\<sigma>)\""], ["proof (prove)\nusing this:\n  grounding_set P \\<sigma>\n  P1 \\<in> P\n\ngoal (1 subgoal):\n 1. ground_clause (subst_cl (cl_ecl P1) \\<sigma>)", "unfolding grounding_set_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in> P \\<longrightarrow>\n     ground_clause (subst_cl (cl_ecl x) \\<sigma>)\n  P1 \\<in> P\n\ngoal (1 subgoal):\n 1. ground_clause (subst_cl (cl_ecl P1) \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  ground_clause (subst_cl (cl_ecl P1) \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  ground_clause (subst_cl (cl_ecl P1) \\<sigma>)", "have \"vars_of_cl (subst_cl (cl_ecl P1) \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  ground_clause (subst_cl (cl_ecl P1) \\<sigma>)\n\ngoal (1 subgoal):\n 1. vars_of_cl (subst_cl (cl_ecl P1) \\<sigma>) = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_cl (subst_cl (cl_ecl P1) \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>L \\<in> (cl_ecl P1)\\<close>"], ["proof (chain)\npicking this:\n  L \\<in> cl_ecl P1", "have \"(subst_lit L \\<sigma>) \\<in> (subst_cl (cl_ecl P1) \\<sigma>)\""], ["proof (prove)\nusing this:\n  L \\<in> cl_ecl P1\n\ngoal (1 subgoal):\n 1. subst_lit L \\<sigma> \\<in> subst_cl (cl_ecl P1) \\<sigma>", "by auto"], ["proof (state)\nthis:\n  subst_lit L \\<sigma> \\<in> subst_cl (cl_ecl P1) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this and \\<open>vars_of_cl (subst_cl (cl_ecl P1) \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  subst_lit L \\<sigma> \\<in> subst_cl (cl_ecl P1) \\<sigma>\n  vars_of_cl (subst_cl (cl_ecl P1) \\<sigma>) = {}", "have \"vars_of_lit (subst_lit L \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  subst_lit L \\<sigma> \\<in> subst_cl (cl_ecl P1) \\<sigma>\n  vars_of_cl (subst_cl (cl_ecl P1) \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. vars_of_lit (subst_lit L \\<sigma>) = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>orient_lit_inst L t s polarity \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L t s polarity \\<sigma>", "have \n      \"orient_lit (subst_lit L \\<sigma>) (subst t \\<sigma>) (subst s \\<sigma>) polarity\""], ["proof (prove)\nusing this:\n  orient_lit_inst L t s polarity \\<sigma>\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>)\n     (s \\<lhd> \\<sigma>) polarity", "using lift_orient_lit"], ["proof (prove)\nusing this:\n  orient_lit_inst L t s polarity \\<sigma>\n  orient_lit_inst ?L ?t ?s ?p ?\\<sigma> \\<Longrightarrow>\n  orient_lit (subst_lit ?L ?\\<sigma>) (?t \\<lhd> ?\\<sigma>)\n   (?s \\<lhd> ?\\<sigma>) ?p\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>)\n     (s \\<lhd> \\<sigma>) polarity", "by auto"], ["proof (state)\nthis:\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   polarity\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this and \\<open>vars_of_lit (subst_lit L \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   polarity\n  vars_of_lit (subst_lit L \\<sigma>) = {}", "have \"vars_of (subst t \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   polarity\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. vars_of (t \\<lhd> \\<sigma>) = {}", "using orient_lit_vars"], ["proof (prove)\nusing this:\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   polarity\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  orient_lit ?L ?t ?s ?p \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of (t \\<lhd> \\<sigma>) = {}", "by blast"], ["proof (state)\nthis:\n  vars_of (t \\<lhd> \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>orient_lit (subst_lit L \\<sigma>) (subst t \\<sigma>) (subst s \\<sigma>) polarity\\<close> \n       and \\<open>vars_of_lit (subst_lit L \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   polarity\n  vars_of_lit (subst_lit L \\<sigma>) = {}", "have \"vars_of (subst s \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   polarity\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. vars_of (s \\<lhd> \\<sigma>) = {}", "using orient_lit_vars"], ["proof (prove)\nusing this:\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   polarity\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  orient_lit ?L ?t ?s ?p \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of (s \\<lhd> \\<sigma>) = {}", "by blast"], ["proof (state)\nthis:\n  vars_of (s \\<lhd> \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "let ?mC1 = \"mset_ecl (P1, \\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "let ?mC2 = \"mset_ecl (C, \\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>L \\<in> (cl_ecl P1)\\<close> \\<open>finite (cl_ecl P1)\\<close>"], ["proof (chain)\npicking this:\n  L \\<in> cl_ecl P1\n  finite (cl_ecl P1)", "have \"mset_set (cl_ecl P1) = mset_set ((cl_ecl P1)-{ L }) + mset_set { L }\""], ["proof (prove)\nusing this:\n  L \\<in> cl_ecl P1\n  finite (cl_ecl P1)\n\ngoal (1 subgoal):\n 1. mset_set (cl_ecl P1) = mset_set (cl_ecl P1 - {L}) + mset_set {L}", "using split_mset_set [of \"cl_ecl P1\" \"cl_ecl P1 - { L }\" \"{ L }\"]"], ["proof (prove)\nusing this:\n  L \\<in> cl_ecl P1\n  finite (cl_ecl P1)\n  \\<lbrakk>cl_ecl P1 = cl_ecl P1 - {L} \\<union> {L};\n   (cl_ecl P1 - {L}) \\<inter> {L} = {}; finite (cl_ecl P1 - {L});\n   finite {L}\\<rbrakk>\n  \\<Longrightarrow> mset_set (cl_ecl P1) =\n                    mset_set (cl_ecl P1 - {L}) + mset_set {L}\n\ngoal (1 subgoal):\n 1. mset_set (cl_ecl P1) = mset_set (cl_ecl P1 - {L}) + mset_set {L}", "by blast"], ["proof (state)\nthis:\n  mset_set (cl_ecl P1) = mset_set (cl_ecl P1 - {L}) + mset_set {L}\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  mset_set (cl_ecl P1) = mset_set (cl_ecl P1 - {L}) + mset_set {L}", "have  d1: \"{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set (cl_ecl P1)) #}\n      = {# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set ((cl_ecl P1) - { L })) #} \n        + {# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set { L }) #}\""], ["proof (prove)\nusing this:\n  mset_set (cl_ecl P1) = mset_set (cl_ecl P1 - {L}) + mset_set {L}\n\ngoal (1 subgoal):\n 1. {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#} =\n    {#mset_lit (subst_lit x \\<sigma>)\n    . x \\<in># mset_set (cl_ecl P1 - {L})#} +\n    {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L}#}", "using split_image_mset"], ["proof (prove)\nusing this:\n  mset_set (cl_ecl P1) = mset_set (cl_ecl P1 - {L}) + mset_set {L}\n  ?M = ?M1.0 + ?M2.0 \\<Longrightarrow>\n  image_mset ?f ?M = image_mset ?f ?M1.0 + image_mset ?f ?M2.0\n\ngoal (1 subgoal):\n 1. {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#} =\n    {#mset_lit (subst_lit x \\<sigma>)\n    . x \\<in># mset_set (cl_ecl P1 - {L})#} +\n    {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L}#}", "by auto"], ["proof (state)\nthis:\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#} =\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1 - {L})#} +\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L}#}\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "let ?C = \"(((cl_ecl P1) - { L }) \\<union> (((cl_ecl P2) - { M }) \\<union> { L' } ))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>finite (cl_ecl P1)\\<close> \\<open>finite (cl_ecl P2)\\<close>"], ["proof (chain)\npicking this:\n  finite (cl_ecl P1)\n  finite (cl_ecl P2)", "have \"finite ?C\""], ["proof (prove)\nusing this:\n  finite (cl_ecl P1)\n  finite (cl_ecl P2)\n\ngoal (1 subgoal):\n 1. finite (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "let ?C' = \"?C - ( (cl_ecl P1) - { L })\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>finite ?C\\<close>"], ["proof (chain)\npicking this:\n  finite (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))", "have \"finite ?C'\""], ["proof (prove)\nusing this:\n  finite (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))\n\ngoal (1 subgoal):\n 1. finite\n     (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n      (cl_ecl P1 - {L}))", "by auto"], ["proof (state)\nthis:\n  finite\n   (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n    (cl_ecl P1 - {L}))\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "have \"?C = ( (cl_ecl P1) - { L }) \\<union> ?C'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) =\n    cl_ecl P1 - {L} \\<union>\n    (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n     (cl_ecl P1 - {L}))", "by auto"], ["proof (state)\nthis:\n  cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) =\n  cl_ecl P1 - {L} \\<union>\n  (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n   (cl_ecl P1 - {L}))\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>finite (cl_ecl P1)\\<close> \\<open>finite ?C'\\<close>"], ["proof (chain)\npicking this:\n  finite (cl_ecl P1)\n  finite\n   (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n    (cl_ecl P1 - {L}))", "have \"mset_set ?C = mset_set ((cl_ecl P1)-{ L }) + mset_set ?C'\""], ["proof (prove)\nusing this:\n  finite (cl_ecl P1)\n  finite\n   (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n    (cl_ecl P1 - {L}))\n\ngoal (1 subgoal):\n 1. mset_set (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'})) =\n    mset_set (cl_ecl P1 - {L}) +\n    mset_set\n     (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n      (cl_ecl P1 - {L}))", "using split_mset_set [of \"?C\" \"cl_ecl P1 - { L }\" \"?C'\"]"], ["proof (prove)\nusing this:\n  finite (cl_ecl P1)\n  finite\n   (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n    (cl_ecl P1 - {L}))\n  \\<lbrakk>cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) =\n           cl_ecl P1 - {L} \\<union>\n           (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n            (cl_ecl P1 - {L}));\n   (cl_ecl P1 - {L}) \\<inter>\n   (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n    (cl_ecl P1 - {L})) =\n   {};\n   finite (cl_ecl P1 - {L});\n   finite\n    (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n     (cl_ecl P1 - {L}))\\<rbrakk>\n  \\<Longrightarrow> mset_set\n                     (cl_ecl P1 - {L} \\<union>\n                      (cl_ecl P2 - {M} \\<union> {L'})) =\n                    mset_set (cl_ecl P1 - {L}) +\n                    mset_set\n                     (cl_ecl P1 - {L} \\<union>\n                      (cl_ecl P2 - {M} \\<union> {L'}) -\n                      (cl_ecl P1 - {L}))\n\ngoal (1 subgoal):\n 1. mset_set (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'})) =\n    mset_set (cl_ecl P1 - {L}) +\n    mset_set\n     (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n      (cl_ecl P1 - {L}))", "by blast"], ["proof (state)\nthis:\n  mset_set (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'})) =\n  mset_set (cl_ecl P1 - {L}) +\n  mset_set\n   (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n    (cl_ecl P1 - {L}))\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  mset_set (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'})) =\n  mset_set (cl_ecl P1 - {L}) +\n  mset_set\n   (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n    (cl_ecl P1 - {L}))", "have  d2: \"{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set ?C) #}\n      = {# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set ((cl_ecl P1) - { L })) #} \n        + {# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set ?C') #}\""], ["proof (prove)\nusing this:\n  mset_set (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'})) =\n  mset_set (cl_ecl P1 - {L}) +\n  mset_set\n   (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n    (cl_ecl P1 - {L}))\n\ngoal (1 subgoal):\n 1. {#mset_lit (subst_lit x \\<sigma>)\n    . x \\<in># mset_set\n                (cl_ecl P1 - {L} \\<union>\n                 (cl_ecl P2 - {M} \\<union> {L'}))#} =\n    {#mset_lit (subst_lit x \\<sigma>)\n    . x \\<in># mset_set (cl_ecl P1 - {L})#} +\n    {#mset_lit (subst_lit x \\<sigma>)\n    . x \\<in># mset_set\n                (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n                 (cl_ecl P1 - {L}))#}", "using split_image_mset"], ["proof (prove)\nusing this:\n  mset_set (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'})) =\n  mset_set (cl_ecl P1 - {L}) +\n  mset_set\n   (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n    (cl_ecl P1 - {L}))\n  ?M = ?M1.0 + ?M2.0 \\<Longrightarrow>\n  image_mset ?f ?M = image_mset ?f ?M1.0 + image_mset ?f ?M2.0\n\ngoal (1 subgoal):\n 1. {#mset_lit (subst_lit x \\<sigma>)\n    . x \\<in># mset_set\n                (cl_ecl P1 - {L} \\<union>\n                 (cl_ecl P2 - {M} \\<union> {L'}))#} =\n    {#mset_lit (subst_lit x \\<sigma>)\n    . x \\<in># mset_set (cl_ecl P1 - {L})#} +\n    {#mset_lit (subst_lit x \\<sigma>)\n    . x \\<in># mset_set\n                (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n                 (cl_ecl P1 - {L}))#}", "by auto"], ["proof (state)\nthis:\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set\n              (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))#} =\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1 - {L})#} +\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set\n              (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n               (cl_ecl P1 - {L}))#}\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "have \"{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set { L }) #} \\<noteq> {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L}#} \\<noteq> {#}", "by auto"], ["proof (state)\nthis:\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L}#} \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "let ?K = \"{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set ?C') #}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "let ?J = \"{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set { L }) #}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "have \"(\\<forall>k \\<in> set_mset ?K. \\<exists>j \\<in> set_mset ?J. (k, j) \\<in> (mult trm_ord))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set\n                                (cl_ecl P1 - {L} \\<union>\n                                 (cl_ecl P2 - {M} \\<union> {L'}) -\n                                 (cl_ecl P1 - {L}))#}.\n       \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                       . x \\<in># mset_set {L}#}.\n          (k, j) \\<in> mult trm_ord", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n                . x \\<in># mset_set\n                            (cl_ecl P1 - {L} \\<union>\n                             (cl_ecl P2 - {M} \\<union> {L'}) -\n                             (cl_ecl P1 - {L}))#} \\<Longrightarrow>\n       \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                       . x \\<in># mset_set {L}#}.\n          (k, j) \\<in> mult trm_ord", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n                . x \\<in># mset_set\n                            (cl_ecl P1 - {L} \\<union>\n                             (cl_ecl P2 - {M} \\<union> {L'}) -\n                             (cl_ecl P1 - {L}))#} \\<Longrightarrow>\n       \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                       . x \\<in># mset_set {L}#}.\n          (k, j) \\<in> mult trm_ord", "assume \"k \\<in> set_mset ?K\""], ["proof (state)\nthis:\n  k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n           . x \\<in># mset_set\n                       (cl_ecl P1 - {L} \\<union>\n                        (cl_ecl P2 - {M} \\<union> {L'}) -\n                        (cl_ecl P1 - {L}))#}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n                . x \\<in># mset_set\n                            (cl_ecl P1 - {L} \\<union>\n                             (cl_ecl P2 - {M} \\<union> {L'}) -\n                             (cl_ecl P1 - {L}))#} \\<Longrightarrow>\n       \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                       . x \\<in># mset_set {L}#}.\n          (k, j) \\<in> mult trm_ord", "from this"], ["proof (chain)\npicking this:\n  k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n           . x \\<in># mset_set\n                       (cl_ecl P1 - {L} \\<union>\n                        (cl_ecl P2 - {M} \\<union> {L'}) -\n                        (cl_ecl P1 - {L}))#}", "have \"k \\<in># ?K\""], ["proof (prove)\nusing this:\n  k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n           . x \\<in># mset_set\n                       (cl_ecl P1 - {L} \\<union>\n                        (cl_ecl P2 - {M} \\<union> {L'}) -\n                        (cl_ecl P1 - {L}))#}\n\ngoal (1 subgoal):\n 1. k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n             . x \\<in># mset_set\n                         (cl_ecl P1 - {L} \\<union>\n                          (cl_ecl P2 - {M} \\<union> {L'}) -\n                          (cl_ecl P1 - {L}))#}", "by auto"], ["proof (state)\nthis:\n  k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n           . x \\<in># mset_set\n                       (cl_ecl P1 - {L} \\<union>\n                        (cl_ecl P2 - {M} \\<union> {L'}) -\n                        (cl_ecl P1 - {L}))#}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n                . x \\<in># mset_set\n                            (cl_ecl P1 - {L} \\<union>\n                             (cl_ecl P2 - {M} \\<union> {L'}) -\n                             (cl_ecl P1 - {L}))#} \\<Longrightarrow>\n       \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                       . x \\<in># mset_set {L}#}.\n          (k, j) \\<in> mult trm_ord", "from this"], ["proof (chain)\npicking this:\n  k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n           . x \\<in># mset_set\n                       (cl_ecl P1 - {L} \\<union>\n                        (cl_ecl P2 - {M} \\<union> {L'}) -\n                        (cl_ecl P1 - {L}))#}", "obtain M' where \"M' \\<in># (mset_set ?C')\" and \"k = (mset_lit (subst_lit M' \\<sigma>))\""], ["proof (prove)\nusing this:\n  k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n           . x \\<in># mset_set\n                       (cl_ecl P1 - {L} \\<union>\n                        (cl_ecl P2 - {M} \\<union> {L'}) -\n                        (cl_ecl P1 - {L}))#}\n\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        \\<lbrakk>M' \\<in># mset_set\n                            (cl_ecl P1 - {L} \\<union>\n                             (cl_ecl P2 - {M} \\<union> {L'}) -\n                             (cl_ecl P1 - {L}));\n         k = mset_lit (subst_lit M' \\<sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using image_mset_thm [of \"?K\"  \"\\<lambda>x. (mset_lit (subst_lit x \\<sigma>))\" \"(mset_set ?C')\"]"], ["proof (prove)\nusing this:\n  k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n           . x \\<in># mset_set\n                       (cl_ecl P1 - {L} \\<union>\n                        (cl_ecl P2 - {M} \\<union> {L'}) -\n                        (cl_ecl P1 - {L}))#}\n  \\<lbrakk>{#mset_lit (subst_lit x \\<sigma>)\n           . x \\<in># mset_set\n                       (cl_ecl P1 - {L} \\<union>\n                        (cl_ecl P2 - {M} \\<union> {L'}) -\n                        (cl_ecl P1 - {L}))#} =\n           {#mset_lit (subst_lit x \\<sigma>)\n           . x \\<in># mset_set\n                       (cl_ecl P1 - {L} \\<union>\n                        (cl_ecl P2 - {M} \\<union> {L'}) -\n                        (cl_ecl P1 - {L}))#};\n   ?x \\<in># {#mset_lit (subst_lit x \\<sigma>)\n             . x \\<in># mset_set\n                         (cl_ecl P1 - {L} \\<union>\n                          (cl_ecl P2 - {M} \\<union> {L'}) -\n                          (cl_ecl P1 - {L}))#}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y.\n                       y \\<in># mset_set\n                                 (cl_ecl P1 - {L} \\<union>\n                                  (cl_ecl P2 - {M} \\<union> {L'}) -\n                                  (cl_ecl P1 - {L})) \\<and>\n                       ?x = mset_lit (subst_lit y \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        \\<lbrakk>M' \\<in># mset_set\n                            (cl_ecl P1 - {L} \\<union>\n                             (cl_ecl P2 - {M} \\<union> {L'}) -\n                             (cl_ecl P1 - {L}));\n         k = mset_lit (subst_lit M' \\<sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  M' \\<in># mset_set\n             (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n              (cl_ecl P1 - {L}))\n  k = mset_lit (subst_lit M' \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n                . x \\<in># mset_set\n                            (cl_ecl P1 - {L} \\<union>\n                             (cl_ecl P2 - {M} \\<union> {L'}) -\n                             (cl_ecl P1 - {L}))#} \\<Longrightarrow>\n       \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                       . x \\<in># mset_set {L}#}.\n          (k, j) \\<in> mult trm_ord", "from \\<open>M' \\<in># (mset_set ?C')\\<close>and \\<open>finite ?C'\\<close>"], ["proof (chain)\npicking this:\n  M' \\<in># mset_set\n             (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n              (cl_ecl P1 - {L}))\n  finite\n   (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n    (cl_ecl P1 - {L}))", "have \"M' \\<in> ?C'\""], ["proof (prove)\nusing this:\n  M' \\<in># mset_set\n             (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n              (cl_ecl P1 - {L}))\n  finite\n   (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n    (cl_ecl P1 - {L}))\n\ngoal (1 subgoal):\n 1. M' \\<in> cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n             (cl_ecl P1 - {L})", "by auto"], ["proof (state)\nthis:\n  M' \\<in> cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n           (cl_ecl P1 - {L})\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n                . x \\<in># mset_set\n                            (cl_ecl P1 - {L} \\<union>\n                             (cl_ecl P2 - {M} \\<union> {L'}) -\n                             (cl_ecl P1 - {L}))#} \\<Longrightarrow>\n       \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                       . x \\<in># mset_set {L}#}.\n          (k, j) \\<in> mult trm_ord", "have \"L \\<in># (mset_set { L })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L \\<in># mset_set {L}", "by auto"], ["proof (state)\nthis:\n  L \\<in># mset_set {L}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n                . x \\<in># mset_set\n                            (cl_ecl P1 - {L} \\<union>\n                             (cl_ecl P2 - {M} \\<union> {L'}) -\n                             (cl_ecl P1 - {L}))#} \\<Longrightarrow>\n       \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                       . x \\<in># mset_set {L}#}.\n          (k, j) \\<in> mult trm_ord", "from this"], ["proof (chain)\npicking this:\n  L \\<in># mset_set {L}", "have \"(mset_lit (subst_lit L \\<sigma>) \\<in># ?J)\""], ["proof (prove)\nusing this:\n  L \\<in># mset_set {L}\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L \\<sigma>)\n    \\<in># {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L}#}", "by auto"], ["proof (state)\nthis:\n  mset_lit (subst_lit L \\<sigma>)\n  \\<in># {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L}#}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n                . x \\<in># mset_set\n                            (cl_ecl P1 - {L} \\<union>\n                             (cl_ecl P2 - {M} \\<union> {L'}) -\n                             (cl_ecl P1 - {L}))#} \\<Longrightarrow>\n       \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                       . x \\<in># mset_set {L}#}.\n          (k, j) \\<in> mult trm_ord", "from this"], ["proof (chain)\npicking this:\n  mset_lit (subst_lit L \\<sigma>)\n  \\<in># {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L}#}", "have \"(mset_lit (subst_lit L \\<sigma>) \\<in> set_mset ?J)\""], ["proof (prove)\nusing this:\n  mset_lit (subst_lit L \\<sigma>)\n  \\<in># {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L}#}\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L \\<sigma>)\n    \\<in># {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L}#}", "by auto"], ["proof (state)\nthis:\n  mset_lit (subst_lit L \\<sigma>)\n  \\<in># {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L}#}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n                . x \\<in># mset_set\n                            (cl_ecl P1 - {L} \\<union>\n                             (cl_ecl P2 - {M} \\<union> {L'}) -\n                             (cl_ecl P1 - {L}))#} \\<Longrightarrow>\n       \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                       . x \\<in># mset_set {L}#}.\n          (k, j) \\<in> mult trm_ord", "have \"{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set { L }) #} \\<noteq> {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L}#} \\<noteq> {#}", "by auto"], ["proof (state)\nthis:\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L}#} \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n                . x \\<in># mset_set\n                            (cl_ecl P1 - {L} \\<union>\n                             (cl_ecl P2 - {M} \\<union> {L'}) -\n                             (cl_ecl P1 - {L}))#} \\<Longrightarrow>\n       \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                       . x \\<in># mset_set {L}#}.\n          (k, j) \\<in> mult trm_ord", "show \"\\<exists>j \\<in> set_mset ?J. (k, j) \\<in> (mult trm_ord)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L}#}.\n       (k, j) \\<in> mult trm_ord", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L}#}.\n       (k, j) \\<in> mult trm_ord\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L}#}.\n       (k, j) \\<in> mult trm_ord", "assume \"M' \\<in> (cl_ecl P2) - { M }\""], ["proof (state)\nthis:\n  M' \\<in> cl_ecl P2 - {M}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L}#}.\n       (k, j) \\<in> mult trm_ord\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L}#}.\n       (k, j) \\<in> mult trm_ord", "from this and \\<open>strictly_maximal_literal P2 M \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  M' \\<in> cl_ecl P2 - {M}\n  strictly_maximal_literal P2 M \\<sigma>", "have \"((subst_lit M' \\<sigma>),(subst_lit M \\<sigma>)) \\<in> lit_ord\""], ["proof (prove)\nusing this:\n  M' \\<in> cl_ecl P2 - {M}\n  strictly_maximal_literal P2 M \\<sigma>\n\ngoal (1 subgoal):\n 1. (subst_lit M' \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord", "unfolding strictly_maximal_literal_def"], ["proof (prove)\nusing this:\n  M' \\<in> cl_ecl P2 - {M}\n  \\<forall>x\\<in>cl_ecl P2 - {M}.\n     (subst_lit x \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (subst_lit M' \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord", "by metis"], ["proof (state)\nthis:\n  (subst_lit M' \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L}#}.\n       (k, j) \\<in> mult trm_ord\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L}#}.\n       (k, j) \\<in> mult trm_ord", "from this and \\<open>( (subst_lit M \\<sigma>),(subst_lit L \\<sigma>)) \\<in> lit_ord\\<close>"], ["proof (chain)\npicking this:\n  (subst_lit M' \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord\n  (subst_lit M \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "have \"((subst_lit M' \\<sigma>),(subst_lit L \\<sigma>)) \\<in> lit_ord\""], ["proof (prove)\nusing this:\n  (subst_lit M' \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord\n  (subst_lit M \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (subst_lit M' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "using lit_ord_trans"], ["proof (prove)\nusing this:\n  (subst_lit M' \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord\n  (subst_lit M \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord\n  trans lit_ord\n\ngoal (1 subgoal):\n 1. (subst_lit M' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "unfolding trans_def"], ["proof (prove)\nusing this:\n  (subst_lit M' \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord\n  (subst_lit M \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord\n  \\<forall>x y z.\n     (x, y) \\<in> lit_ord \\<longrightarrow>\n     (y, z) \\<in> lit_ord \\<longrightarrow> (x, z) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (subst_lit M' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "by metis"], ["proof (state)\nthis:\n  (subst_lit M' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L}#}.\n       (k, j) \\<in> mult trm_ord\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L}#}.\n       (k, j) \\<in> mult trm_ord", "from this"], ["proof (chain)\npicking this:\n  (subst_lit M' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "have \"((mset_lit (subst_lit M' \\<sigma>)), \n                (mset_lit (subst_lit L \\<sigma>))) \\<in>  (mult trm_ord)\""], ["proof (prove)\nusing this:\n  (subst_lit M' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (mset_lit (subst_lit M' \\<sigma>), mset_lit (subst_lit L \\<sigma>))\n    \\<in> mult trm_ord", "unfolding lit_ord_def"], ["proof (prove)\nusing this:\n  (subst_lit M' \\<sigma>, subst_lit L \\<sigma>)\n  \\<in> {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}\n\ngoal (1 subgoal):\n 1. (mset_lit (subst_lit M' \\<sigma>), mset_lit (subst_lit L \\<sigma>))\n    \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  (mset_lit (subst_lit M' \\<sigma>), mset_lit (subst_lit L \\<sigma>))\n  \\<in> mult trm_ord\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L}#}.\n       (k, j) \\<in> mult trm_ord\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L}#}.\n       (k, j) \\<in> mult trm_ord", "from \\<open>(mset_lit (subst_lit L \\<sigma>) \\<in> set_mset ?J)\\<close> this \\<open>((mset_lit (subst_lit M' \\<sigma>)), \n                (mset_lit (subst_lit L \\<sigma>))) \\<in>  (mult trm_ord)\\<close> \n       and \\<open>k = (mset_lit (subst_lit M' \\<sigma>))\\<close>"], ["proof (chain)\npicking this:\n  mset_lit (subst_lit L \\<sigma>)\n  \\<in># {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L}#}\n  (mset_lit (subst_lit M' \\<sigma>), mset_lit (subst_lit L \\<sigma>))\n  \\<in> mult trm_ord\n  (mset_lit (subst_lit M' \\<sigma>), mset_lit (subst_lit L \\<sigma>))\n  \\<in> mult trm_ord\n  k = mset_lit (subst_lit M' \\<sigma>)", "show ?thesis"], ["proof (prove)\nusing this:\n  mset_lit (subst_lit L \\<sigma>)\n  \\<in># {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L}#}\n  (mset_lit (subst_lit M' \\<sigma>), mset_lit (subst_lit L \\<sigma>))\n  \\<in> mult trm_ord\n  (mset_lit (subst_lit M' \\<sigma>), mset_lit (subst_lit L \\<sigma>))\n  \\<in> mult trm_ord\n  k = mset_lit (subst_lit M' \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L}#}.\n       (k, j) \\<in> mult trm_ord", "by blast"], ["proof (state)\nthis:\n  \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                  . x \\<in># mset_set {L}#}.\n     (k, j) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. M' \\<notin> cl_ecl P2 - {M} \\<Longrightarrow>\n    \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L}#}.\n       (k, j) \\<in> mult trm_ord", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M' \\<notin> cl_ecl P2 - {M} \\<Longrightarrow>\n    \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L}#}.\n       (k, j) \\<in> mult trm_ord", "assume \"M' \\<notin> (cl_ecl P2) - { M }\""], ["proof (state)\nthis:\n  M' \\<notin> cl_ecl P2 - {M}\n\ngoal (1 subgoal):\n 1. M' \\<notin> cl_ecl P2 - {M} \\<Longrightarrow>\n    \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L}#}.\n       (k, j) \\<in> mult trm_ord", "from this and \\<open>M' \\<in> ?C'\\<close>"], ["proof (chain)\npicking this:\n  M' \\<notin> cl_ecl P2 - {M}\n  M' \\<in> cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n           (cl_ecl P1 - {L})", "have \"M' = L'\""], ["proof (prove)\nusing this:\n  M' \\<notin> cl_ecl P2 - {M}\n  M' \\<in> cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n           (cl_ecl P1 - {L})\n\ngoal (1 subgoal):\n 1. M' = L'", "by auto"], ["proof (state)\nthis:\n  M' = L'\n\ngoal (1 subgoal):\n 1. M' \\<notin> cl_ecl P2 - {M} \\<Longrightarrow>\n    \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L}#}.\n       (k, j) \\<in> mult trm_ord", "from \\<open>subterm t p u'\\<close>"], ["proof (chain)\npicking this:\n  subterm t p u'", "have \"subterm (subst t \\<sigma>) p  (subst u' \\<sigma>)\""], ["proof (prove)\nusing this:\n  subterm t p u'\n\ngoal (1 subgoal):\n 1. subterm (t \\<lhd> \\<sigma>) p (u' \\<lhd> \\<sigma>)", "using substs_preserve_subterms"], ["proof (prove)\nusing this:\n  subterm t p u'\n  subterm ?t ?p ?s \\<Longrightarrow>\n  subterm (?t \\<lhd> ?\\<sigma>) ?p (?s \\<lhd> ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. subterm (t \\<lhd> \\<sigma>) p (u' \\<lhd> \\<sigma>)", "by blast"], ["proof (state)\nthis:\n  subterm (t \\<lhd> \\<sigma>) p (u' \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. M' \\<notin> cl_ecl P2 - {M} \\<Longrightarrow>\n    \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L}#}.\n       (k, j) \\<in> mult trm_ord", "from \\<open>ck_unifier u' u \\<sigma> Ground\\<close>"], ["proof (chain)\npicking this:\n  ck_unifier u' u \\<sigma> Ground", "have \n      \"(subst u \\<sigma>) = (subst u' \\<sigma>)\""], ["proof (prove)\nusing this:\n  ck_unifier u' u \\<sigma> Ground\n\ngoal (1 subgoal):\n 1. u \\<lhd> \\<sigma> = u' \\<lhd> \\<sigma>", "unfolding ck_unifier_def Unifier_def"], ["proof (prove)\nusing this:\n  if Ground = FirstOrder then MGU \\<sigma> u' u\n  else u' \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. u \\<lhd> \\<sigma> = u' \\<lhd> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  u \\<lhd> \\<sigma> = u' \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. M' \\<notin> cl_ecl P2 - {M} \\<Longrightarrow>\n    \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L}#}.\n       (k, j) \\<in> mult trm_ord", "from this and \\<open>((subst v \\<sigma>),(subst u \\<sigma>)) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  u \\<lhd> \\<sigma> = u' \\<lhd> \\<sigma>\n  (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord", "have \"((subst v \\<sigma>),(subst u' \\<sigma>)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  u \\<lhd> \\<sigma> = u' \\<lhd> \\<sigma>\n  (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (v \\<lhd> \\<sigma>, u' \\<lhd> \\<sigma>) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (v \\<lhd> \\<sigma>, u' \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. M' \\<notin> cl_ecl P2 - {M} \\<Longrightarrow>\n    \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L}#}.\n       (k, j) \\<in> mult trm_ord", "from this \\<open>subterm t p u'\\<close> \\<open>replace_subterm t p v t'\\<close>"], ["proof (chain)\npicking this:\n  (v \\<lhd> \\<sigma>, u' \\<lhd> \\<sigma>) \\<in> trm_ord\n  subterm t p u'\n  replace_subterm t p v t'", "have \"((subst t' \\<sigma>),(subst t \\<sigma>)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (v \\<lhd> \\<sigma>, u' \\<lhd> \\<sigma>) \\<in> trm_ord\n  subterm t p u'\n  replace_subterm t p v t'\n\ngoal (1 subgoal):\n 1. (t' \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "using replacement_monotonic"], ["proof (prove)\nusing this:\n  (v \\<lhd> \\<sigma>, u' \\<lhd> \\<sigma>) \\<in> trm_ord\n  subterm t p u'\n  replace_subterm t p v t'\n  \\<lbrakk>(?v \\<lhd> ?\\<sigma>, ?u \\<lhd> ?\\<sigma>) \\<in> trm_ord;\n   subterm ?t ?p ?u; replace_subterm ?t ?p ?v ?s\\<rbrakk>\n  \\<Longrightarrow> (?s \\<lhd> ?\\<sigma>, ?t \\<lhd> ?\\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (t' \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (t' \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. M' \\<notin> cl_ecl P2 - {M} \\<Longrightarrow>\n    \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L}#}.\n       (k, j) \\<in> mult trm_ord", "have \"polarity = pos \\<or> polarity = neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polarity = pos \\<or> polarity = neg", "using sign.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = pos \\<Longrightarrow> ?P;\n   ?y = neg \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. polarity = pos \\<or> polarity = neg", "by auto"], ["proof (state)\nthis:\n  polarity = pos \\<or> polarity = neg\n\ngoal (1 subgoal):\n 1. M' \\<notin> cl_ecl P2 - {M} \\<Longrightarrow>\n    \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L}#}.\n       (k, j) \\<in> mult trm_ord", "then"], ["proof (chain)\npicking this:\n  polarity = pos \\<or> polarity = neg", "have \"((subst_lit L' \\<sigma>),(subst_lit L \\<sigma>)) \\<in> lit_ord\""], ["proof (prove)\nusing this:\n  polarity = pos \\<or> polarity = neg\n\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord\n 2. polarity = neg \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "assume \"polarity = pos\""], ["proof (state)\nthis:\n  polarity = pos\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord\n 2. polarity = neg \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from this and \\<open>orient_lit_inst L t s polarity \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  polarity = pos\n  orient_lit_inst L t s polarity \\<sigma>", "have i: \"(mset_lit (subst_lit L \\<sigma>)) = {# (subst s \\<sigma>) #} + {# (subst t \\<sigma>) #}\""], ["proof (prove)\nusing this:\n  polarity = pos\n  orient_lit_inst L t s polarity \\<sigma>\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L \\<sigma>) =\n    {#s \\<lhd> \\<sigma>#} + {#t \\<lhd> \\<sigma>#}", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  polarity = pos\n  (L = Pos (Eq t s) \\<or> L = Pos (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  polarity = pos \\<or>\n  (L = Neg (Eq t s) \\<or> L = Neg (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  polarity = neg\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L \\<sigma>) =\n    {#s \\<lhd> \\<sigma>#} + {#t \\<lhd> \\<sigma>#}", "using add.commute"], ["proof (prove)\nusing this:\n  polarity = pos\n  (L = Pos (Eq t s) \\<or> L = Pos (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  polarity = pos \\<or>\n  (L = Neg (Eq t s) \\<or> L = Neg (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  polarity = neg\n  ?a + ?b = ?b + ?a\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L \\<sigma>) =\n    {#s \\<lhd> \\<sigma>#} + {#t \\<lhd> \\<sigma>#}", "by force"], ["proof (state)\nthis:\n  mset_lit (subst_lit L \\<sigma>) =\n  {#s \\<lhd> \\<sigma>#} + {#t \\<lhd> \\<sigma>#}\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord\n 2. polarity = neg \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from  \\<open>L' = mk_lit polarity (Eq t' s)\\<close> \\<open>polarity = pos\\<close>"], ["proof (chain)\npicking this:\n  L' = mk_lit polarity (Eq t' s)\n  polarity = pos", "have ii: \"(mset_lit (subst_lit L' \\<sigma>)) = {# (subst s \\<sigma>) #} \n          + {# (subst t' \\<sigma>) #}\""], ["proof (prove)\nusing this:\n  L' = mk_lit polarity (Eq t' s)\n  polarity = pos\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L' \\<sigma>) =\n    {#s \\<lhd> \\<sigma>#} + {#t' \\<lhd> \\<sigma>#}", "using add.commute"], ["proof (prove)\nusing this:\n  L' = mk_lit polarity (Eq t' s)\n  polarity = pos\n  ?a + ?b = ?b + ?a\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L' \\<sigma>) =\n    {#s \\<lhd> \\<sigma>#} + {#t' \\<lhd> \\<sigma>#}", "by force"], ["proof (state)\nthis:\n  mset_lit (subst_lit L' \\<sigma>) =\n  {#s \\<lhd> \\<sigma>#} + {#t' \\<lhd> \\<sigma>#}\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord\n 2. polarity = neg \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "have \"{# (subst t \\<sigma>) #} \\<noteq> {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#t \\<lhd> \\<sigma>#} \\<noteq> {#}", "by auto"], ["proof (state)\nthis:\n  {#t \\<lhd> \\<sigma>#} \\<noteq> {#}\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord\n 2. polarity = neg \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "have \"(\\<forall>k' \\<in> set_mset {# (subst t' \\<sigma>) #}. \\<exists>j' \\<in> set_mset {# (subst t \\<sigma>) #}. (k', j') \\<in> (trm_ord))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k'\\<in>#{#t' \\<lhd> \\<sigma>#}.\n       \\<exists>j'\\<in>#{#t \\<lhd> \\<sigma>#}. (k', j') \\<in> trm_ord", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k'.\n       k' \\<in># {#t' \\<lhd> \\<sigma>#} \\<Longrightarrow>\n       \\<exists>j'\\<in>#{#t \\<lhd> \\<sigma>#}. (k', j') \\<in> trm_ord", "fix k'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k'.\n       k' \\<in># {#t' \\<lhd> \\<sigma>#} \\<Longrightarrow>\n       \\<exists>j'\\<in>#{#t \\<lhd> \\<sigma>#}. (k', j') \\<in> trm_ord", "assume \"k' \\<in>set_mset {# (subst t' \\<sigma>) #}\""], ["proof (state)\nthis:\n  k' \\<in># {#t' \\<lhd> \\<sigma>#}\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       k' \\<in># {#t' \\<lhd> \\<sigma>#} \\<Longrightarrow>\n       \\<exists>j'\\<in>#{#t \\<lhd> \\<sigma>#}. (k', j') \\<in> trm_ord", "from this"], ["proof (chain)\npicking this:\n  k' \\<in># {#t' \\<lhd> \\<sigma>#}", "have \"k' = (subst t' \\<sigma>)\""], ["proof (prove)\nusing this:\n  k' \\<in># {#t' \\<lhd> \\<sigma>#}\n\ngoal (1 subgoal):\n 1. k' = t' \\<lhd> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  k' = t' \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       k' \\<in># {#t' \\<lhd> \\<sigma>#} \\<Longrightarrow>\n       \\<exists>j'\\<in>#{#t \\<lhd> \\<sigma>#}. (k', j') \\<in> trm_ord", "have \"(subst t \\<sigma>) \\<in> set_mset {# (subst t \\<sigma>) #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> \\<in># {#t \\<lhd> \\<sigma>#}", "by auto"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> \\<in># {#t \\<lhd> \\<sigma>#}\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       k' \\<in># {#t' \\<lhd> \\<sigma>#} \\<Longrightarrow>\n       \\<exists>j'\\<in>#{#t \\<lhd> \\<sigma>#}. (k', j') \\<in> trm_ord", "from this \\<open>k' = (subst t' \\<sigma>)\\<close> \n            and \\<open>((subst t' \\<sigma>),(subst t \\<sigma>)) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<sigma> \\<in># {#t \\<lhd> \\<sigma>#}\n  k' = t' \\<lhd> \\<sigma>\n  (t' \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "show \"\\<exists>j' \\<in> set_mset {# (subst t \\<sigma>) #}. (k', j') \\<in> (trm_ord)\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> \\<in># {#t \\<lhd> \\<sigma>#}\n  k' = t' \\<lhd> \\<sigma>\n  (t' \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<exists>j'\\<in>#{#t \\<lhd> \\<sigma>#}. (k', j') \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  \\<exists>j'\\<in>#{#t \\<lhd> \\<sigma>#}. (k', j') \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>k'\\<in>#{#t' \\<lhd> \\<sigma>#}.\n     \\<exists>j'\\<in>#{#t \\<lhd> \\<sigma>#}. (k', j') \\<in> trm_ord\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord\n 2. polarity = neg \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from i ii \n          \\<open>((subst t' \\<sigma>),(subst t \\<sigma>)) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  mset_lit (subst_lit L \\<sigma>) =\n  {#s \\<lhd> \\<sigma>#} + {#t \\<lhd> \\<sigma>#}\n  mset_lit (subst_lit L' \\<sigma>) =\n  {#s \\<lhd> \\<sigma>#} + {#t' \\<lhd> \\<sigma>#}\n  (t' \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "have \"(mset_lit (subst_lit L' \\<sigma>),(mset_lit (subst_lit L \\<sigma>))) \n            \\<in> (mult trm_ord)\""], ["proof (prove)\nusing this:\n  mset_lit (subst_lit L \\<sigma>) =\n  {#s \\<lhd> \\<sigma>#} + {#t \\<lhd> \\<sigma>#}\n  mset_lit (subst_lit L' \\<sigma>) =\n  {#s \\<lhd> \\<sigma>#} + {#t' \\<lhd> \\<sigma>#}\n  (t' \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (mset_lit (subst_lit L' \\<sigma>), mset_lit (subst_lit L \\<sigma>))\n    \\<in> mult trm_ord", "by (metis one_step_implies_mult empty_iff insert_iff set_mset_add_mset_insert set_mset_empty)"], ["proof (state)\nthis:\n  (mset_lit (subst_lit L' \\<sigma>), mset_lit (subst_lit L \\<sigma>))\n  \\<in> mult trm_ord\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord\n 2. polarity = neg \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  (mset_lit (subst_lit L' \\<sigma>), mset_lit (subst_lit L \\<sigma>))\n  \\<in> mult trm_ord", "show ?thesis"], ["proof (prove)\nusing this:\n  (mset_lit (subst_lit L' \\<sigma>), mset_lit (subst_lit L \\<sigma>))\n  \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "unfolding lit_ord_def"], ["proof (prove)\nusing this:\n  (mset_lit (subst_lit L' \\<sigma>), mset_lit (subst_lit L \\<sigma>))\n  \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>)\n    \\<in> {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}", "by auto"], ["proof (state)\nthis:\n  (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "assume \"polarity = neg\""], ["proof (state)\nthis:\n  polarity = neg\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from this and \\<open>orient_lit_inst L t s polarity \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  polarity = neg\n  orient_lit_inst L t s polarity \\<sigma>", "have i: \"(mset_lit (subst_lit L \\<sigma>)) = {# (subst s \\<sigma>), (subst s \\<sigma>) #} \n          + {# (subst t \\<sigma>), (subst t \\<sigma>) #}\""], ["proof (prove)\nusing this:\n  polarity = neg\n  orient_lit_inst L t s polarity \\<sigma>\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L \\<sigma>) =\n    {#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>#} +\n    {#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#}", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  polarity = neg\n  (L = Pos (Eq t s) \\<or> L = Pos (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  polarity = pos \\<or>\n  (L = Neg (Eq t s) \\<or> L = Neg (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  polarity = neg\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L \\<sigma>) =\n    {#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>#} +\n    {#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#}", "by auto"], ["proof (state)\nthis:\n  mset_lit (subst_lit L \\<sigma>) =\n  {#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>#} +\n  {#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#}\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from  \\<open>L' = mk_lit polarity (Eq t' s)\\<close> \\<open>polarity = neg\\<close>"], ["proof (chain)\npicking this:\n  L' = mk_lit polarity (Eq t' s)\n  polarity = neg", "have \n          \"subst_lit L' \\<sigma> = (Neg (Eq (subst t' \\<sigma>) (subst s \\<sigma>)))\""], ["proof (prove)\nusing this:\n  L' = mk_lit polarity (Eq t' s)\n  polarity = neg\n\ngoal (1 subgoal):\n 1. subst_lit L' \\<sigma> =\n    Neg (Eq (t' \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))", "by auto"], ["proof (state)\nthis:\n  subst_lit L' \\<sigma> = Neg (Eq (t' \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  subst_lit L' \\<sigma> = Neg (Eq (t' \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))", "have \"(mset_lit (subst_lit L' \\<sigma>))\n          = {# (subst t' \\<sigma>), (subst t' \\<sigma>), (subst s \\<sigma>), (subst s \\<sigma>) #}\""], ["proof (prove)\nusing this:\n  subst_lit L' \\<sigma> = Neg (Eq (t' \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L' \\<sigma>) =\n    {#t' \\<lhd> \\<sigma>, t' \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>,\n      s \\<lhd> \\<sigma>#}", "by auto"], ["proof (state)\nthis:\n  mset_lit (subst_lit L' \\<sigma>) =\n  {#t' \\<lhd> \\<sigma>, t' \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>,\n    s \\<lhd> \\<sigma>#}\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  mset_lit (subst_lit L' \\<sigma>) =\n  {#t' \\<lhd> \\<sigma>, t' \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>,\n    s \\<lhd> \\<sigma>#}", "have ii: \"(mset_lit (subst_lit L' \\<sigma>))\n          = {# (subst s \\<sigma>), (subst s \\<sigma>) #} + {# (subst t' \\<sigma>), (subst t' \\<sigma>) #}\""], ["proof (prove)\nusing this:\n  mset_lit (subst_lit L' \\<sigma>) =\n  {#t' \\<lhd> \\<sigma>, t' \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>,\n    s \\<lhd> \\<sigma>#}\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L' \\<sigma>) =\n    {#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>#} +\n    {#t' \\<lhd> \\<sigma>, t' \\<lhd> \\<sigma>#}", "by (simp add: add.commute add.left_commute)"], ["proof (state)\nthis:\n  mset_lit (subst_lit L' \\<sigma>) =\n  {#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>#} +\n  {#t' \\<lhd> \\<sigma>, t' \\<lhd> \\<sigma>#}\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "have \"{# (subst t \\<sigma>), (subst t \\<sigma>) #} \\<noteq> {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#} \\<noteq> {#}", "by auto"], ["proof (state)\nthis:\n  {#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#} \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "have \"(\\<forall>k' \\<in> set_mset {# (subst t' \\<sigma>),(subst t' \\<sigma>) #}. \n          \\<exists>j' \\<in> set_mset {# (subst t \\<sigma>),(subst t \\<sigma>) #}. (k', j') \\<in> (trm_ord))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k'\\<in>#{#t' \\<lhd> \\<sigma>, t' \\<lhd> \\<sigma>#}.\n       \\<exists>j'\\<in>#{#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#}.\n          (k', j') \\<in> trm_ord", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k'.\n       k' \\<in># {#t' \\<lhd> \\<sigma>,\n                   t' \\<lhd> \\<sigma>#} \\<Longrightarrow>\n       \\<exists>j'\\<in>#{#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#}.\n          (k', j') \\<in> trm_ord", "fix k'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k'.\n       k' \\<in># {#t' \\<lhd> \\<sigma>,\n                   t' \\<lhd> \\<sigma>#} \\<Longrightarrow>\n       \\<exists>j'\\<in>#{#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#}.\n          (k', j') \\<in> trm_ord", "assume \"k' \\<in>set_mset {# (subst t' \\<sigma>),(subst t' \\<sigma>) #}\""], ["proof (state)\nthis:\n  k' \\<in># {#t' \\<lhd> \\<sigma>, t' \\<lhd> \\<sigma>#}\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       k' \\<in># {#t' \\<lhd> \\<sigma>,\n                   t' \\<lhd> \\<sigma>#} \\<Longrightarrow>\n       \\<exists>j'\\<in>#{#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#}.\n          (k', j') \\<in> trm_ord", "from this"], ["proof (chain)\npicking this:\n  k' \\<in># {#t' \\<lhd> \\<sigma>, t' \\<lhd> \\<sigma>#}", "have \"k' = (subst t' \\<sigma>)\""], ["proof (prove)\nusing this:\n  k' \\<in># {#t' \\<lhd> \\<sigma>, t' \\<lhd> \\<sigma>#}\n\ngoal (1 subgoal):\n 1. k' = t' \\<lhd> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  k' = t' \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       k' \\<in># {#t' \\<lhd> \\<sigma>,\n                   t' \\<lhd> \\<sigma>#} \\<Longrightarrow>\n       \\<exists>j'\\<in>#{#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#}.\n          (k', j') \\<in> trm_ord", "have \"(subst t \\<sigma>) \\<in> set_mset {# (subst t \\<sigma>),(subst t \\<sigma>) #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> \\<in># {#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#}", "by auto"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> \\<in># {#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#}\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       k' \\<in># {#t' \\<lhd> \\<sigma>,\n                   t' \\<lhd> \\<sigma>#} \\<Longrightarrow>\n       \\<exists>j'\\<in>#{#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#}.\n          (k', j') \\<in> trm_ord", "from this \\<open>k' = (subst t' \\<sigma>)\\<close> \n            and \\<open>((subst t' \\<sigma>),(subst t \\<sigma>)) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<sigma> \\<in># {#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#}\n  k' = t' \\<lhd> \\<sigma>\n  (t' \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "show \"\\<exists>j' \\<in> set_mset {# (subst t \\<sigma>),(subst t \\<sigma>) #}. (k', j') \\<in> (trm_ord)\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> \\<in># {#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#}\n  k' = t' \\<lhd> \\<sigma>\n  (t' \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<exists>j'\\<in>#{#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#}.\n       (k', j') \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  \\<exists>j'\\<in>#{#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#}.\n     (k', j') \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>k'\\<in>#{#t' \\<lhd> \\<sigma>, t' \\<lhd> \\<sigma>#}.\n     \\<exists>j'\\<in>#{#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#}.\n        (k', j') \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from this i ii \\<open>{# (subst t \\<sigma>), (subst t \\<sigma>) #} \\<noteq> {#}\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>k'\\<in>#{#t' \\<lhd> \\<sigma>, t' \\<lhd> \\<sigma>#}.\n     \\<exists>j'\\<in>#{#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#}.\n        (k', j') \\<in> trm_ord\n  mset_lit (subst_lit L \\<sigma>) =\n  {#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>#} +\n  {#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#}\n  mset_lit (subst_lit L' \\<sigma>) =\n  {#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>#} +\n  {#t' \\<lhd> \\<sigma>, t' \\<lhd> \\<sigma>#}\n  {#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#} \\<noteq> {#}", "have \"(mset_lit (subst_lit L' \\<sigma>),\n            (mset_lit (subst_lit L \\<sigma>))) \\<in> (mult trm_ord)\""], ["proof (prove)\nusing this:\n  \\<forall>k'\\<in>#{#t' \\<lhd> \\<sigma>, t' \\<lhd> \\<sigma>#}.\n     \\<exists>j'\\<in>#{#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#}.\n        (k', j') \\<in> trm_ord\n  mset_lit (subst_lit L \\<sigma>) =\n  {#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>#} +\n  {#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#}\n  mset_lit (subst_lit L' \\<sigma>) =\n  {#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>#} +\n  {#t' \\<lhd> \\<sigma>, t' \\<lhd> \\<sigma>#}\n  {#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#} \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. (mset_lit (subst_lit L' \\<sigma>), mset_lit (subst_lit L \\<sigma>))\n    \\<in> mult trm_ord", "using one_step_implies_mult  [of \"{# (subst t \\<sigma>), (subst t \\<sigma>) #}\"\n               \"{# (subst t' \\<sigma>),(subst t' \\<sigma>) #}\" trm_ord\n               \"{# (subst s \\<sigma>),(subst s \\<sigma>) #}\"] \n             trm_ord_trans"], ["proof (prove)\nusing this:\n  \\<forall>k'\\<in>#{#t' \\<lhd> \\<sigma>, t' \\<lhd> \\<sigma>#}.\n     \\<exists>j'\\<in>#{#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#}.\n        (k', j') \\<in> trm_ord\n  mset_lit (subst_lit L \\<sigma>) =\n  {#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>#} +\n  {#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#}\n  mset_lit (subst_lit L' \\<sigma>) =\n  {#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>#} +\n  {#t' \\<lhd> \\<sigma>, t' \\<lhd> \\<sigma>#}\n  {#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#} \\<noteq> {#}\n  \\<lbrakk>{#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#} \\<noteq> {#};\n   \\<forall>k\\<in>#{#t' \\<lhd> \\<sigma>, t' \\<lhd> \\<sigma>#}.\n      \\<exists>j\\<in>#{#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#}.\n         (k, j) \\<in> trm_ord\\<rbrakk>\n  \\<Longrightarrow> ({#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>#} +\n                     {#t' \\<lhd> \\<sigma>, t' \\<lhd> \\<sigma>#},\n                     {#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>#} +\n                     {#t \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>#})\n                    \\<in> mult trm_ord\n  trans trm_ord\n\ngoal (1 subgoal):\n 1. (mset_lit (subst_lit L' \\<sigma>), mset_lit (subst_lit L \\<sigma>))\n    \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  (mset_lit (subst_lit L' \\<sigma>), mset_lit (subst_lit L \\<sigma>))\n  \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  (mset_lit (subst_lit L' \\<sigma>), mset_lit (subst_lit L \\<sigma>))\n  \\<in> mult trm_ord", "show ?thesis"], ["proof (prove)\nusing this:\n  (mset_lit (subst_lit L' \\<sigma>), mset_lit (subst_lit L \\<sigma>))\n  \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "unfolding lit_ord_def"], ["proof (prove)\nusing this:\n  (mset_lit (subst_lit L' \\<sigma>), mset_lit (subst_lit L \\<sigma>))\n  \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>)\n    \\<in> {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}", "by auto"], ["proof (state)\nthis:\n  (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. M' \\<notin> cl_ecl P2 - {M} \\<Longrightarrow>\n    \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L}#}.\n       (k, j) \\<in> mult trm_ord", "from this and \n      \\<open>(mset_lit (subst_lit L \\<sigma>) \\<in> set_mset ?J)\\<close> \n      \\<open>k = (mset_lit (subst_lit M' \\<sigma>))\\<close>\n      \\<open>M' = L'\\<close>"], ["proof (chain)\npicking this:\n  (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord\n  mset_lit (subst_lit L \\<sigma>)\n  \\<in># {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L}#}\n  k = mset_lit (subst_lit M' \\<sigma>)\n  M' = L'", "show ?thesis"], ["proof (prove)\nusing this:\n  (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord\n  mset_lit (subst_lit L \\<sigma>)\n  \\<in># {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L}#}\n  k = mset_lit (subst_lit M' \\<sigma>)\n  M' = L'\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L}#}.\n       (k, j) \\<in> mult trm_ord", "unfolding lit_ord_def"], ["proof (prove)\nusing this:\n  (subst_lit L' \\<sigma>, subst_lit L \\<sigma>)\n  \\<in> {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}\n  mset_lit (subst_lit L \\<sigma>)\n  \\<in># {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L}#}\n  k = mset_lit (subst_lit M' \\<sigma>)\n  M' = L'\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L}#}.\n       (k, j) \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                  . x \\<in># mset_set {L}#}.\n     (k, j) \\<in> mult trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                  . x \\<in># mset_set {L}#}.\n     (k, j) \\<in> mult trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>k\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                  . x \\<in># mset_set\n                              (cl_ecl P1 - {L} \\<union>\n                               (cl_ecl P2 - {M} \\<union> {L'}) -\n                               (cl_ecl P1 - {L}))#}.\n     \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                     . x \\<in># mset_set {L}#}.\n        (k, j) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this d1 d2"], ["proof (chain)\npicking this:\n  \\<forall>k\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                  . x \\<in># mset_set\n                              (cl_ecl P1 - {L} \\<union>\n                               (cl_ecl P2 - {M} \\<union> {L'}) -\n                               (cl_ecl P1 - {L}))#}.\n     \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                     . x \\<in># mset_set {L}#}.\n        (k, j) \\<in> mult trm_ord\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#} =\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1 - {L})#} +\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L}#}\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set\n              (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))#} =\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1 - {L})#} +\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set\n              (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n               (cl_ecl P1 - {L}))#}", "have o: \"\n      ({#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set ?C #},\n      {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#})\n     \\<in> mult (mult trm_ord)\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                  . x \\<in># mset_set\n                              (cl_ecl P1 - {L} \\<union>\n                               (cl_ecl P2 - {M} \\<union> {L'}) -\n                               (cl_ecl P1 - {L}))#}.\n     \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                     . x \\<in># mset_set {L}#}.\n        (k, j) \\<in> mult trm_ord\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#} =\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1 - {L})#} +\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L}#}\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set\n              (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))#} =\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1 - {L})#} +\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set\n              (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n               (cl_ecl P1 - {L}))#}\n\ngoal (1 subgoal):\n 1. ({#mset_lit (subst_lit x \\<sigma>)\n     . x \\<in># mset_set\n                 (cl_ecl P1 - {L} \\<union>\n                  (cl_ecl P2 - {M} \\<union> {L'}))#},\n     {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#})\n    \\<in> mult (mult trm_ord)", "using  mult_trm_ord_trans one_step_implies_mult [of \"{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set { L }) #}\"\n      \"{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set ?C') #}\"  \"mult trm_ord\"\n      \"{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set ((cl_ecl P1) - { L })) #} \" ]"], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                  . x \\<in># mset_set\n                              (cl_ecl P1 - {L} \\<union>\n                               (cl_ecl P2 - {M} \\<union> {L'}) -\n                               (cl_ecl P1 - {L}))#}.\n     \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                     . x \\<in># mset_set {L}#}.\n        (k, j) \\<in> mult trm_ord\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#} =\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1 - {L})#} +\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L}#}\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set\n              (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))#} =\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1 - {L})#} +\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set\n              (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}) -\n               (cl_ecl P1 - {L}))#}\n  trans (mult trm_ord)\n  \\<lbrakk>{#mset_lit (subst_lit x \\<sigma>)\n           . x \\<in># mset_set {L}#} \\<noteq>\n           {#};\n   \\<forall>k\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                   . x \\<in># mset_set\n                               (cl_ecl P1 - {L} \\<union>\n                                (cl_ecl P2 - {M} \\<union> {L'}) -\n                                (cl_ecl P1 - {L}))#}.\n      \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                      . x \\<in># mset_set {L}#}.\n         (k, j) \\<in> mult trm_ord\\<rbrakk>\n  \\<Longrightarrow> ({#mset_lit (subst_lit x \\<sigma>)\n                     . x \\<in># mset_set (cl_ecl P1 - {L})#} +\n                     {#mset_lit (subst_lit x \\<sigma>)\n                     . x \\<in># mset_set\n                                 (cl_ecl P1 - {L} \\<union>\n                                  (cl_ecl P2 - {M} \\<union> {L'}) -\n                                  (cl_ecl P1 - {L}))#},\n                     {#mset_lit (subst_lit x \\<sigma>)\n                     . x \\<in># mset_set (cl_ecl P1 - {L})#} +\n                     {#mset_lit (subst_lit x \\<sigma>)\n                     . x \\<in># mset_set {L}#})\n                    \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. ({#mset_lit (subst_lit x \\<sigma>)\n     . x \\<in># mset_set\n                 (cl_ecl P1 - {L} \\<union>\n                  (cl_ecl P2 - {M} \\<union> {L'}))#},\n     {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#})\n    \\<in> mult (mult trm_ord)", "by auto"], ["proof (state)\nthis:\n  ({#mset_lit (subst_lit x \\<sigma>)\n   . x \\<in># mset_set\n               (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))#},\n   {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#})\n  \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P1 \\<in> P \\<and>\n       P2 \\<in> P \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this \\<open>C' = (((cl_ecl P1) - { L }) \\<union> (((cl_ecl P2) - { M }) \\<union> { L' } ))\\<close> and \\<open>P1 \\<in> P\\<close> \n    and hyp"], ["proof (chain)\npicking this:\n  ({#mset_lit (subst_lit x \\<sigma>)\n   . x \\<in># mset_set\n               (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))#},\n   {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#})\n  \\<in> mult (mult trm_ord)\n  C' = cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'})\n  P1 \\<in> P\n  \\<nexists>D.\n     D \\<in> P \\<and>\n     (mset_cl (C', \\<sigma>), mset_ecl (D, \\<sigma>))\n     \\<in> mult (mult trm_ord)", "show False"], ["proof (prove)\nusing this:\n  ({#mset_lit (subst_lit x \\<sigma>)\n   . x \\<in># mset_set\n               (cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'}))#},\n   {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#})\n  \\<in> mult (mult trm_ord)\n  C' = cl_ecl P1 - {L} \\<union> (cl_ecl P2 - {M} \\<union> {L'})\n  P1 \\<in> P\n  \\<nexists>D.\n     D \\<in> P \\<and>\n     (mset_cl (C', \\<sigma>), mset_ecl (D, \\<sigma>))\n     \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>P1 P2.\n     P1 \\<in> P \\<and>\n     P2 \\<in> P \\<and> superposition P1 P2 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. \\<nexists>D.\n       D \\<in> P \\<and>\n       (mset_cl (C', \\<sigma>), mset_ecl (D, \\<sigma>))\n       \\<in> mult (mult trm_ord) \\<Longrightarrow>\n    False", "have not_ref: \"\\<not> (\\<exists>P1. (P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>P1. P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "assume \"(\\<exists>P1. (P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C'))\""], ["proof (state)\nthis:\n  \\<exists>P1. P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>P1. P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C'", "obtain P1 where \"P1 \\<in> P\" \"reflexion P1 C \\<sigma> Ground C'\""], ["proof (prove)\nusing this:\n  \\<exists>P1. P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. (\\<And>P1.\n        \\<lbrakk>P1 \\<in> P; reflexion P1 C \\<sigma> Ground C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> P\n  reflexion P1 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>reflexion P1 C \\<sigma> Ground C'\\<close>"], ["proof (chain)\npicking this:\n  reflexion P1 C \\<sigma> Ground C'", "obtain L1 t s Cl_C Cl_P where\n      \"(eligible_literal L1 P1 \\<sigma>)\"\n      \"(L1 \\<in> (cl_ecl P1))\"  \"(Cl_C = (cl_ecl C))\" \"(Cl_P = (cl_ecl P1))\" \n      \"(orient_lit_inst L1 t s neg \\<sigma>)\"\n      \"(ck_unifier t s \\<sigma> Ground)\"\n      \"(Cl_C = (subst_cl ((Cl_P - { L1 }) )) \\<sigma>)\"\n      \"(C' = ((Cl_P - { L1 }) ))\""], ["proof (prove)\nusing this:\n  reflexion P1 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. (\\<And>L1 Cl_C Cl_P t s.\n        \\<lbrakk>eligible_literal L1 P1 \\<sigma>; L1 \\<in> cl_ecl P1;\n         Cl_C = cl_ecl C; Cl_P = cl_ecl P1;\n         orient_lit_inst L1 t s neg \\<sigma>;\n         ck_unifier t s \\<sigma> Ground;\n         Cl_C = subst_cl (Cl_P - {L1}) \\<sigma>; C' = Cl_P - {L1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding reflexion_def"], ["proof (prove)\nusing this:\n  \\<exists>L1 t s Cl_P Cl_C trms_C.\n     eligible_literal L1 P1 \\<sigma> \\<and>\n     L1 \\<in> cl_ecl P1 \\<and>\n     Cl_C = cl_ecl C \\<and>\n     Cl_P = cl_ecl P1 \\<and>\n     orient_lit_inst L1 t s neg \\<sigma> \\<and>\n     ck_unifier t s \\<sigma> Ground \\<and>\n     C = Ecl Cl_C trms_C \\<and>\n     trms_C =\n     get_trms Cl_C\n      (dom_trms Cl_C (subst_set (trms_ecl P1 \\<union> {t}) \\<sigma>))\n      Ground \\<and>\n     Cl_C = subst_cl C' \\<sigma> \\<and> C' = Cl_P - {L1}\n\ngoal (1 subgoal):\n 1. (\\<And>L1 Cl_C Cl_P t s.\n        \\<lbrakk>eligible_literal L1 P1 \\<sigma>; L1 \\<in> cl_ecl P1;\n         Cl_C = cl_ecl C; Cl_P = cl_ecl P1;\n         orient_lit_inst L1 t s neg \\<sigma>;\n         ck_unifier t s \\<sigma> Ground;\n         Cl_C = subst_cl (Cl_P - {L1}) \\<sigma>; C' = Cl_P - {L1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  eligible_literal L1 P1 \\<sigma>\n  L1 \\<in> cl_ecl P1\n  Cl_C = cl_ecl C\n  Cl_P = cl_ecl P1\n  orient_lit_inst L1 t s neg \\<sigma>\n  ck_unifier t s \\<sigma> Ground\n  Cl_C = subst_cl (Cl_P - {L1}) \\<sigma>\n  C' = Cl_P - {L1}\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>P1 \\<in> P\\<close> and assms(2) and \\<open>P \\<subseteq> S\\<close>"], ["proof (chain)\npicking this:\n  P1 \\<in> P\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  P \\<subseteq> S", "have \"finite (cl_ecl P1)\""], ["proof (prove)\nusing this:\n  P1 \\<in> P\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  P \\<subseteq> S\n\ngoal (1 subgoal):\n 1. finite (cl_ecl P1)", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl P1)\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "let ?mC1 = \"mset_ecl (P1, \\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "let ?mC2 = \"mset_ecl (C, \\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>L1 \\<in> (cl_ecl P1)\\<close> \\<open>finite (cl_ecl P1)\\<close>"], ["proof (chain)\npicking this:\n  L1 \\<in> cl_ecl P1\n  finite (cl_ecl P1)", "have \"mset_set (cl_ecl P1) = mset_set ((cl_ecl P1)-{ L1 }) + mset_set { L1 }\""], ["proof (prove)\nusing this:\n  L1 \\<in> cl_ecl P1\n  finite (cl_ecl P1)\n\ngoal (1 subgoal):\n 1. mset_set (cl_ecl P1) = mset_set (cl_ecl P1 - {L1}) + mset_set {L1}", "using split_mset_set [of \"cl_ecl P1\" \"cl_ecl P1 - { L1 }\" \"{ L1 }\"]"], ["proof (prove)\nusing this:\n  L1 \\<in> cl_ecl P1\n  finite (cl_ecl P1)\n  \\<lbrakk>cl_ecl P1 = cl_ecl P1 - {L1} \\<union> {L1};\n   (cl_ecl P1 - {L1}) \\<inter> {L1} = {}; finite (cl_ecl P1 - {L1});\n   finite {L1}\\<rbrakk>\n  \\<Longrightarrow> mset_set (cl_ecl P1) =\n                    mset_set (cl_ecl P1 - {L1}) + mset_set {L1}\n\ngoal (1 subgoal):\n 1. mset_set (cl_ecl P1) = mset_set (cl_ecl P1 - {L1}) + mset_set {L1}", "by blast"], ["proof (state)\nthis:\n  mset_set (cl_ecl P1) = mset_set (cl_ecl P1 - {L1}) + mset_set {L1}\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  mset_set (cl_ecl P1) = mset_set (cl_ecl P1 - {L1}) + mset_set {L1}", "have  d1: \"{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set (cl_ecl P1)) #}\n      = {# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set ((cl_ecl P1) - { L1 })) #} \n        + {# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set { L1 }) #}\""], ["proof (prove)\nusing this:\n  mset_set (cl_ecl P1) = mset_set (cl_ecl P1 - {L1}) + mset_set {L1}\n\ngoal (1 subgoal):\n 1. {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#} =\n    {#mset_lit (subst_lit x \\<sigma>)\n    . x \\<in># mset_set (cl_ecl P1 - {L1})#} +\n    {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L1}#}", "using split_image_mset"], ["proof (prove)\nusing this:\n  mset_set (cl_ecl P1) = mset_set (cl_ecl P1 - {L1}) + mset_set {L1}\n  ?M = ?M1.0 + ?M2.0 \\<Longrightarrow>\n  image_mset ?f ?M = image_mset ?f ?M1.0 + image_mset ?f ?M2.0\n\ngoal (1 subgoal):\n 1. {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#} =\n    {#mset_lit (subst_lit x \\<sigma>)\n    . x \\<in># mset_set (cl_ecl P1 - {L1})#} +\n    {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L1}#}", "by auto"], ["proof (state)\nthis:\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#} =\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set (cl_ecl P1 - {L1})#} +\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L1}#}\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "let ?C = \"((cl_ecl P1) - { L1 })\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>finite (cl_ecl P1)\\<close>"], ["proof (chain)\npicking this:\n  finite (cl_ecl P1)", "have \"finite ?C\""], ["proof (prove)\nusing this:\n  finite (cl_ecl P1)\n\ngoal (1 subgoal):\n 1. finite (cl_ecl P1 - {L1})", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl P1 - {L1})\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "let ?C' = \"{}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "have \"finite ?C'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {}", "by auto"], ["proof (state)\nthis:\n  finite {}\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "have \"?C = ( (cl_ecl P1) - { L1 }) \\<union> ?C'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_ecl P1 - {L1} = cl_ecl P1 - {L1} \\<union> {}", "by auto"], ["proof (state)\nthis:\n  cl_ecl P1 - {L1} = cl_ecl P1 - {L1} \\<union> {}\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>finite (cl_ecl P1)\\<close> \\<open>finite ?C'\\<close>"], ["proof (chain)\npicking this:\n  finite (cl_ecl P1)\n  finite {}", "have \"mset_set ?C = mset_set ((cl_ecl P1)-{ L1 }) + mset_set ?C'\""], ["proof (prove)\nusing this:\n  finite (cl_ecl P1)\n  finite {}\n\ngoal (1 subgoal):\n 1. mset_set (cl_ecl P1 - {L1}) = mset_set (cl_ecl P1 - {L1}) + mset_set {}", "using split_mset_set [of \"?C\" \"cl_ecl P1 - { L1 }\" \"?C'\"]"], ["proof (prove)\nusing this:\n  finite (cl_ecl P1)\n  finite {}\n  \\<lbrakk>cl_ecl P1 - {L1} = cl_ecl P1 - {L1} \\<union> {};\n   (cl_ecl P1 - {L1}) \\<inter> {} = {}; finite (cl_ecl P1 - {L1});\n   finite {}\\<rbrakk>\n  \\<Longrightarrow> mset_set (cl_ecl P1 - {L1}) =\n                    mset_set (cl_ecl P1 - {L1}) + mset_set {}\n\ngoal (1 subgoal):\n 1. mset_set (cl_ecl P1 - {L1}) = mset_set (cl_ecl P1 - {L1}) + mset_set {}", "by blast"], ["proof (state)\nthis:\n  mset_set (cl_ecl P1 - {L1}) = mset_set (cl_ecl P1 - {L1}) + mset_set {}\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  mset_set (cl_ecl P1 - {L1}) = mset_set (cl_ecl P1 - {L1}) + mset_set {}", "have  d2: \"{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set ?C) #}\n      = {# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set ((cl_ecl P1) - { L1 })) #} \n        + {# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set ?C') #}\""], ["proof (prove)\nusing this:\n  mset_set (cl_ecl P1 - {L1}) = mset_set (cl_ecl P1 - {L1}) + mset_set {}\n\ngoal (1 subgoal):\n 1. {#mset_lit (subst_lit x \\<sigma>)\n    . x \\<in># mset_set (cl_ecl P1 - {L1})#} =\n    {#mset_lit (subst_lit x \\<sigma>)\n    . x \\<in># mset_set (cl_ecl P1 - {L1})#} +\n    {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {}#}", "using split_image_mset"], ["proof (prove)\nusing this:\n  mset_set (cl_ecl P1 - {L1}) = mset_set (cl_ecl P1 - {L1}) + mset_set {}\n  ?M = ?M1.0 + ?M2.0 \\<Longrightarrow>\n  image_mset ?f ?M = image_mset ?f ?M1.0 + image_mset ?f ?M2.0\n\ngoal (1 subgoal):\n 1. {#mset_lit (subst_lit x \\<sigma>)\n    . x \\<in># mset_set (cl_ecl P1 - {L1})#} =\n    {#mset_lit (subst_lit x \\<sigma>)\n    . x \\<in># mset_set (cl_ecl P1 - {L1})#} +\n    {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {}#}", "by auto"], ["proof (state)\nthis:\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set (cl_ecl P1 - {L1})#} =\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set (cl_ecl P1 - {L1})#} +\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {}#}\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "have \"{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set { L1 }) #} \\<noteq> {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L1}#} \\<noteq> {#}", "by auto"], ["proof (state)\nthis:\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L1}#} \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "let ?K = \"{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set ?C') #}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "let ?J = \"{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set { L1 }) #}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "have \"(\\<forall>k \\<in> set_mset ?K. \\<exists>j \\<in> set_mset ?J. (k, j) \\<in> (mult trm_ord))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {}#}.\n       \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                       . x \\<in># mset_set {L1}#}.\n          (k, j) \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  \\<forall>k\\<in>#{#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {}#}.\n     \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                     . x \\<in># mset_set {L1}#}.\n        (k, j) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this d1 d2  \\<open>{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set { L1 }) #} \\<noteq> {#}\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>k\\<in>#{#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {}#}.\n     \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                     . x \\<in># mset_set {L1}#}.\n        (k, j) \\<in> mult trm_ord\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#} =\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set (cl_ecl P1 - {L1})#} +\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L1}#}\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set (cl_ecl P1 - {L1})#} =\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set (cl_ecl P1 - {L1})#} +\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {}#}\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L1}#} \\<noteq> {#}", "have o: \"\n      ({#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set ?C #},\n      {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#})\n     \\<in> mult (mult trm_ord)\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>#{#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {}#}.\n     \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                     . x \\<in># mset_set {L1}#}.\n        (k, j) \\<in> mult trm_ord\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#} =\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set (cl_ecl P1 - {L1})#} +\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L1}#}\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set (cl_ecl P1 - {L1})#} =\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set (cl_ecl P1 - {L1})#} +\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {}#}\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L1}#} \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. ({#mset_lit (subst_lit x \\<sigma>)\n     . x \\<in># mset_set (cl_ecl P1 - {L1})#},\n     {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#})\n    \\<in> mult (mult trm_ord)", "using  mult_trm_ord_trans one_step_implies_mult [of\n    \"{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set { L1 }) #}\"\n      \"{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set ?C') #}\"  \"mult trm_ord\" \n      \"{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set ((cl_ecl P1) - { L1 })) #} \" ]"], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>#{#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {}#}.\n     \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                     . x \\<in># mset_set {L1}#}.\n        (k, j) \\<in> mult trm_ord\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#} =\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set (cl_ecl P1 - {L1})#} +\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L1}#}\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set (cl_ecl P1 - {L1})#} =\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set (cl_ecl P1 - {L1})#} +\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {}#}\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L1}#} \\<noteq> {#}\n  trans (mult trm_ord)\n  \\<lbrakk>{#mset_lit (subst_lit x \\<sigma>)\n           . x \\<in># mset_set {L1}#} \\<noteq>\n           {#};\n   \\<forall>k\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                   . x \\<in># mset_set {}#}.\n      \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                      . x \\<in># mset_set {L1}#}.\n         (k, j) \\<in> mult trm_ord\\<rbrakk>\n  \\<Longrightarrow> ({#mset_lit (subst_lit x \\<sigma>)\n                     . x \\<in># mset_set (cl_ecl P1 - {L1})#} +\n                     {#mset_lit (subst_lit x \\<sigma>)\n                     . x \\<in># mset_set {}#},\n                     {#mset_lit (subst_lit x \\<sigma>)\n                     . x \\<in># mset_set (cl_ecl P1 - {L1})#} +\n                     {#mset_lit (subst_lit x \\<sigma>)\n                     . x \\<in># mset_set {L1}#})\n                    \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. ({#mset_lit (subst_lit x \\<sigma>)\n     . x \\<in># mset_set (cl_ecl P1 - {L1})#},\n     {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#})\n    \\<in> mult (mult trm_ord)", "by auto"], ["proof (state)\nthis:\n  ({#mset_lit (subst_lit x \\<sigma>)\n   . x \\<in># mset_set (cl_ecl P1 - {L1})#},\n   {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#})\n  \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this \\<open>Cl_P = (cl_ecl P1)\\<close> \\<open>C' = ((Cl_P - { L1 }) )\\<close> and \\<open>P1 \\<in> P\\<close> \n    and hyp"], ["proof (chain)\npicking this:\n  ({#mset_lit (subst_lit x \\<sigma>)\n   . x \\<in># mset_set (cl_ecl P1 - {L1})#},\n   {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#})\n  \\<in> mult (mult trm_ord)\n  Cl_P = cl_ecl P1\n  C' = Cl_P - {L1}\n  P1 \\<in> P\n  \\<nexists>D.\n     D \\<in> P \\<and>\n     (mset_cl (C', \\<sigma>), mset_ecl (D, \\<sigma>))\n     \\<in> mult (mult trm_ord)", "show False"], ["proof (prove)\nusing this:\n  ({#mset_lit (subst_lit x \\<sigma>)\n   . x \\<in># mset_set (cl_ecl P1 - {L1})#},\n   {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#})\n  \\<in> mult (mult trm_ord)\n  Cl_P = cl_ecl P1\n  C' = Cl_P - {L1}\n  P1 \\<in> P\n  \\<nexists>D.\n     D \\<in> P \\<and>\n     (mset_cl (C', \\<sigma>), mset_ecl (D, \\<sigma>))\n     \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>P1. P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. \\<nexists>D.\n       D \\<in> P \\<and>\n       (mset_cl (C', \\<sigma>), mset_ecl (D, \\<sigma>))\n       \\<in> mult (mult trm_ord) \\<Longrightarrow>\n    False", "have not_fact: \"\\<not> (\\<exists>P1. (P1 \\<in> P \\<and> factorization P1 C \\<sigma> Ground C'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>P1. P1 \\<in> P \\<and> factorization P1 C \\<sigma> Ground C'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "assume \"(\\<exists>P1. (P1 \\<in> P \\<and> factorization P1 C \\<sigma> Ground C'))\""], ["proof (state)\nthis:\n  \\<exists>P1. P1 \\<in> P \\<and> factorization P1 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>P1. P1 \\<in> P \\<and> factorization P1 C \\<sigma> Ground C'", "obtain P1 where \"P1 \\<in> P\" \"factorization  P1 C \\<sigma> Ground C'\""], ["proof (prove)\nusing this:\n  \\<exists>P1. P1 \\<in> P \\<and> factorization P1 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. (\\<And>P1.\n        \\<lbrakk>P1 \\<in> P; factorization P1 C \\<sigma> Ground C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P1 \\<in> P\n  factorization P1 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>factorization P1 C \\<sigma> Ground C'\\<close>"], ["proof (chain)\npicking this:\n  factorization P1 C \\<sigma> Ground C'", "obtain L1 L2 L' t s u v Cl_P Cl_C  where\n      \"(eligible_literal L1 P1 \\<sigma>)\"\n      \"(L1 \\<in> (cl_ecl P1))\" \"(L2 \\<in> (cl_ecl P1) - { L1 })\" \"(Cl_C = (cl_ecl C))\" \"(Cl_P = (cl_ecl P1))\" \n      \"(orient_lit_inst L1 t s pos \\<sigma>)\"\n      \"(orient_lit_inst L2 u v pos \\<sigma>)\"\n      \"((subst t \\<sigma>) \\<noteq> (subst s \\<sigma>))\"\n      \"((subst t \\<sigma>) \\<noteq> (subst v \\<sigma>))\"\n      \"(ck_unifier t u \\<sigma> Ground)\"\n      \"(L' = Neg (Eq s v))\"\n      \"(Cl_C = (subst_cl ( (Cl_P - { L2 }) \\<union> { L' } )) \\<sigma>)\"\n      \"(C' = ( (Cl_P - { L2 }) \\<union> { L' } ))\""], ["proof (prove)\nusing this:\n  factorization P1 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. (\\<And>L1 L2 Cl_C Cl_P t s u v L'.\n        \\<lbrakk>eligible_literal L1 P1 \\<sigma>; L1 \\<in> cl_ecl P1;\n         L2 \\<in> cl_ecl P1 - {L1}; Cl_C = cl_ecl C; Cl_P = cl_ecl P1;\n         orient_lit_inst L1 t s pos \\<sigma>;\n         orient_lit_inst L2 u v pos \\<sigma>;\n         t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>;\n         t \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>;\n         ck_unifier t u \\<sigma> Ground; L' = Neg (Eq s v);\n         Cl_C = subst_cl (Cl_P - {L2} \\<union> {L'}) \\<sigma>;\n         C' = Cl_P - {L2} \\<union> {L'}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding factorization_def"], ["proof (prove)\nusing this:\n  \\<exists>L1 L2 L' t s u v Cl_P Cl_C trms_C.\n     eligible_literal L1 P1 \\<sigma> \\<and>\n     L1 \\<in> cl_ecl P1 \\<and>\n     L2 \\<in> cl_ecl P1 - {L1} \\<and>\n     Cl_C = cl_ecl C \\<and>\n     Cl_P = cl_ecl P1 \\<and>\n     orient_lit_inst L1 t s pos \\<sigma> \\<and>\n     orient_lit_inst L2 u v pos \\<sigma> \\<and>\n     t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma> \\<and>\n     t \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma> \\<and>\n     ck_unifier t u \\<sigma> Ground \\<and>\n     L' = Neg (Eq s v) \\<and>\n     (C = Ecl Cl_C trms_C \\<and>\n      trms_C =\n      get_trms Cl_C\n       (dom_trms Cl_C\n         (subst_set (trms_ecl P1 \\<union> proper_subterms_of t) \\<sigma>))\n       Ground) \\<and>\n     Cl_C = subst_cl C' \\<sigma> \\<and> C' = Cl_P - {L2} \\<union> {L'}\n\ngoal (1 subgoal):\n 1. (\\<And>L1 L2 Cl_C Cl_P t s u v L'.\n        \\<lbrakk>eligible_literal L1 P1 \\<sigma>; L1 \\<in> cl_ecl P1;\n         L2 \\<in> cl_ecl P1 - {L1}; Cl_C = cl_ecl C; Cl_P = cl_ecl P1;\n         orient_lit_inst L1 t s pos \\<sigma>;\n         orient_lit_inst L2 u v pos \\<sigma>;\n         t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>;\n         t \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>;\n         ck_unifier t u \\<sigma> Ground; L' = Neg (Eq s v);\n         Cl_C = subst_cl (Cl_P - {L2} \\<union> {L'}) \\<sigma>;\n         C' = Cl_P - {L2} \\<union> {L'}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  eligible_literal L1 P1 \\<sigma>\n  L1 \\<in> cl_ecl P1\n  L2 \\<in> cl_ecl P1 - {L1}\n  Cl_C = cl_ecl C\n  Cl_P = cl_ecl P1\n  orient_lit_inst L1 t s pos \\<sigma>\n  orient_lit_inst L2 u v pos \\<sigma>\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n  t \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>\n  ck_unifier t u \\<sigma> Ground\n  L' = Neg (Eq s v)\n  Cl_C = subst_cl (Cl_P - {L2} \\<union> {L'}) \\<sigma>\n  C' = Cl_P - {L2} \\<union> {L'}\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>P1 \\<in> P\\<close> and assms(2) and \\<open>P \\<subseteq> S\\<close>"], ["proof (chain)\npicking this:\n  P1 \\<in> P\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  P \\<subseteq> S", "have \"finite (cl_ecl P1)\""], ["proof (prove)\nusing this:\n  P1 \\<in> P\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  P \\<subseteq> S\n\ngoal (1 subgoal):\n 1. finite (cl_ecl P1)", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl P1)\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from assms(3) and \\<open>P1 \\<in> P\\<close>"], ["proof (chain)\npicking this:\n  grounding_set P \\<sigma>\n  P1 \\<in> P", "have \"ground_clause (subst_cl (cl_ecl P1) \\<sigma>)\""], ["proof (prove)\nusing this:\n  grounding_set P \\<sigma>\n  P1 \\<in> P\n\ngoal (1 subgoal):\n 1. ground_clause (subst_cl (cl_ecl P1) \\<sigma>)", "unfolding grounding_set_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in> P \\<longrightarrow>\n     ground_clause (subst_cl (cl_ecl x) \\<sigma>)\n  P1 \\<in> P\n\ngoal (1 subgoal):\n 1. ground_clause (subst_cl (cl_ecl P1) \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  ground_clause (subst_cl (cl_ecl P1) \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  ground_clause (subst_cl (cl_ecl P1) \\<sigma>)", "have \"vars_of_cl (subst_cl (cl_ecl P1) \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  ground_clause (subst_cl (cl_ecl P1) \\<sigma>)\n\ngoal (1 subgoal):\n 1. vars_of_cl (subst_cl (cl_ecl P1) \\<sigma>) = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_cl (subst_cl (cl_ecl P1) \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>L1 \\<in> (cl_ecl P1)\\<close>"], ["proof (chain)\npicking this:\n  L1 \\<in> cl_ecl P1", "have \"(subst_lit L1 \\<sigma>) \\<in> (subst_cl (cl_ecl P1) \\<sigma>)\""], ["proof (prove)\nusing this:\n  L1 \\<in> cl_ecl P1\n\ngoal (1 subgoal):\n 1. subst_lit L1 \\<sigma> \\<in> subst_cl (cl_ecl P1) \\<sigma>", "by auto"], ["proof (state)\nthis:\n  subst_lit L1 \\<sigma> \\<in> subst_cl (cl_ecl P1) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this and \\<open>vars_of_cl (subst_cl (cl_ecl P1) \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  subst_lit L1 \\<sigma> \\<in> subst_cl (cl_ecl P1) \\<sigma>\n  vars_of_cl (subst_cl (cl_ecl P1) \\<sigma>) = {}", "have \"vars_of_lit (subst_lit L1 \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  subst_lit L1 \\<sigma> \\<in> subst_cl (cl_ecl P1) \\<sigma>\n  vars_of_cl (subst_cl (cl_ecl P1) \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. vars_of_lit (subst_lit L1 \\<sigma>) = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>orient_lit_inst L1 t s pos \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L1 t s pos \\<sigma>", "have \n      \"orient_lit (subst_lit L1 \\<sigma>) (subst t \\<sigma>) (subst s \\<sigma>) pos\""], ["proof (prove)\nusing this:\n  orient_lit_inst L1 t s pos \\<sigma>\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>)\n     (s \\<lhd> \\<sigma>) pos", "using lift_orient_lit"], ["proof (prove)\nusing this:\n  orient_lit_inst L1 t s pos \\<sigma>\n  orient_lit_inst ?L ?t ?s ?p ?\\<sigma> \\<Longrightarrow>\n  orient_lit (subst_lit ?L ?\\<sigma>) (?t \\<lhd> ?\\<sigma>)\n   (?s \\<lhd> ?\\<sigma>) ?p\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>)\n     (s \\<lhd> \\<sigma>) pos", "by auto"], ["proof (state)\nthis:\n  orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this and \\<open>vars_of_lit (subst_lit L1 \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}", "have \"vars_of (subst t \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. vars_of (t \\<lhd> \\<sigma>) = {}", "using orient_lit_vars"], ["proof (prove)\nusing this:\n  orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}\n  orient_lit ?L ?t ?s ?p \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of (t \\<lhd> \\<sigma>) = {}", "by blast"], ["proof (state)\nthis:\n  vars_of (t \\<lhd> \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>orient_lit (subst_lit L1 \\<sigma>) (subst t \\<sigma>) (subst s \\<sigma>) pos\\<close> \n       and \\<open>vars_of_lit (subst_lit L1 \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}", "have \"vars_of (subst s \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. vars_of (s \\<lhd> \\<sigma>) = {}", "using orient_lit_vars"], ["proof (prove)\nusing this:\n  orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}\n  orient_lit ?L ?t ?s ?p \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of (s \\<lhd> \\<sigma>) = {}", "by blast"], ["proof (state)\nthis:\n  vars_of (s \\<lhd> \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>(L2 \\<in> (cl_ecl P1) - { L1 })\\<close>"], ["proof (chain)\npicking this:\n  L2 \\<in> cl_ecl P1 - {L1}", "have \"L2 \\<in> (cl_ecl P1)\""], ["proof (prove)\nusing this:\n  L2 \\<in> cl_ecl P1 - {L1}\n\ngoal (1 subgoal):\n 1. L2 \\<in> cl_ecl P1", "by auto"], ["proof (state)\nthis:\n  L2 \\<in> cl_ecl P1\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>L2 \\<in> (cl_ecl P1)\\<close>"], ["proof (chain)\npicking this:\n  L2 \\<in> cl_ecl P1", "have \"(subst_lit L2 \\<sigma>) \\<in> (subst_cl (cl_ecl P1) \\<sigma>)\""], ["proof (prove)\nusing this:\n  L2 \\<in> cl_ecl P1\n\ngoal (1 subgoal):\n 1. subst_lit L2 \\<sigma> \\<in> subst_cl (cl_ecl P1) \\<sigma>", "by auto"], ["proof (state)\nthis:\n  subst_lit L2 \\<sigma> \\<in> subst_cl (cl_ecl P1) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this and \\<open>vars_of_cl (subst_cl (cl_ecl P1) \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  subst_lit L2 \\<sigma> \\<in> subst_cl (cl_ecl P1) \\<sigma>\n  vars_of_cl (subst_cl (cl_ecl P1) \\<sigma>) = {}", "have \"vars_of_lit (subst_lit L2 \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  subst_lit L2 \\<sigma> \\<in> subst_cl (cl_ecl P1) \\<sigma>\n  vars_of_cl (subst_cl (cl_ecl P1) \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. vars_of_lit (subst_lit L2 \\<sigma>) = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_lit (subst_lit L2 \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>orient_lit_inst L2 u v pos \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L2 u v pos \\<sigma>", "have \n      \"orient_lit (subst_lit L2 \\<sigma>) (subst u \\<sigma>) (subst v \\<sigma>) pos\""], ["proof (prove)\nusing this:\n  orient_lit_inst L2 u v pos \\<sigma>\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit L2 \\<sigma>) (u \\<lhd> \\<sigma>)\n     (v \\<lhd> \\<sigma>) pos", "using lift_orient_lit"], ["proof (prove)\nusing this:\n  orient_lit_inst L2 u v pos \\<sigma>\n  orient_lit_inst ?L ?t ?s ?p ?\\<sigma> \\<Longrightarrow>\n  orient_lit (subst_lit ?L ?\\<sigma>) (?t \\<lhd> ?\\<sigma>)\n   (?s \\<lhd> ?\\<sigma>) ?p\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit L2 \\<sigma>) (u \\<lhd> \\<sigma>)\n     (v \\<lhd> \\<sigma>) pos", "by auto"], ["proof (state)\nthis:\n  orient_lit (subst_lit L2 \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   pos\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this and \\<open>vars_of_lit (subst_lit L2 \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  orient_lit (subst_lit L2 \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   pos\n  vars_of_lit (subst_lit L2 \\<sigma>) = {}", "have \"vars_of (subst u \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  orient_lit (subst_lit L2 \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   pos\n  vars_of_lit (subst_lit L2 \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. vars_of (u \\<lhd> \\<sigma>) = {}", "using orient_lit_vars"], ["proof (prove)\nusing this:\n  orient_lit (subst_lit L2 \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   pos\n  vars_of_lit (subst_lit L2 \\<sigma>) = {}\n  orient_lit ?L ?t ?s ?p \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of (u \\<lhd> \\<sigma>) = {}", "by blast"], ["proof (state)\nthis:\n  vars_of (u \\<lhd> \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>orient_lit (subst_lit L2 \\<sigma>) (subst u \\<sigma>) (subst v \\<sigma>) pos\\<close> \n       and \\<open>vars_of_lit (subst_lit L2 \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  orient_lit (subst_lit L2 \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   pos\n  vars_of_lit (subst_lit L2 \\<sigma>) = {}", "have \"vars_of (subst v \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  orient_lit (subst_lit L2 \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   pos\n  vars_of_lit (subst_lit L2 \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. vars_of (v \\<lhd> \\<sigma>) = {}", "using orient_lit_vars"], ["proof (prove)\nusing this:\n  orient_lit (subst_lit L2 \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   pos\n  vars_of_lit (subst_lit L2 \\<sigma>) = {}\n  orient_lit ?L ?t ?s ?p \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of (v \\<lhd> \\<sigma>) = {}", "by blast"], ["proof (state)\nthis:\n  vars_of (v \\<lhd> \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>ck_unifier t u \\<sigma> Ground\\<close>"], ["proof (chain)\npicking this:\n  ck_unifier t u \\<sigma> Ground", "have \"(subst t \\<sigma>) = (subst u \\<sigma>)\""], ["proof (prove)\nusing this:\n  ck_unifier t u \\<sigma> Ground\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>", "unfolding ck_unifier_def Unifier_def"], ["proof (prove)\nusing this:\n  if Ground = FirstOrder then MGU \\<sigma> t u\n  else t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>orient_lit (subst_lit L1 \\<sigma>) (subst t \\<sigma>) (subst s \\<sigma>) pos\\<close>"], ["proof (chain)\npicking this:\n  orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos", "have \"((subst t \\<sigma>),(subst s \\<sigma>)) \\<notin> trm_ord\""], ["proof (prove)\nusing this:\n  orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord", "unfolding orient_lit_def"], ["proof (prove)\nusing this:\n  (subst_lit L1 \\<sigma> =\n   Pos (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)) \\<or>\n   subst_lit L1 \\<sigma> =\n   Pos (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  pos = pos \\<or>\n  (subst_lit L1 \\<sigma> =\n   Neg (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)) \\<or>\n   subst_lit L1 \\<sigma> =\n   Neg (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and> pos = neg\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this and \\<open>(subst t \\<sigma>) \\<noteq> (subst s \\<sigma>)\\<close> \n      and \\<open>vars_of (subst t \\<sigma>) = {}\\<close> \\<open>vars_of (subst s \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n  vars_of (t \\<lhd> \\<sigma>) = {}\n  vars_of (s \\<lhd> \\<sigma>) = {}", "have \"((subst s \\<sigma>),(subst t \\<sigma>)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n  vars_of (t \\<lhd> \\<sigma>) = {}\n  vars_of (s \\<lhd> \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "using trm_ord_ground_total"], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n  vars_of (t \\<lhd> \\<sigma>) = {}\n  vars_of (s \\<lhd> \\<sigma>) = {}\n  \\<forall>x y.\n     ground_term x \\<longrightarrow>\n     ground_term y \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "unfolding ground_term_def"], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n  vars_of (t \\<lhd> \\<sigma>) = {}\n  vars_of (s \\<lhd> \\<sigma>) = {}\n  \\<forall>x y.\n     vars_of x = {} \\<longrightarrow>\n     vars_of y = {} \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "by blast"], ["proof (state)\nthis:\n  (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this and \\<open>(subst t \\<sigma>) = (subst u \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>", "have \n      \"((subst s \\<sigma>),(subst u \\<sigma>)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. (s \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (s \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>orient_lit (subst_lit L2 \\<sigma>) (subst u \\<sigma>) (subst v \\<sigma>) pos\\<close>"], ["proof (chain)\npicking this:\n  orient_lit (subst_lit L2 \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   pos", "have \"((subst u \\<sigma>),(subst v \\<sigma>)) \\<notin> trm_ord\""], ["proof (prove)\nusing this:\n  orient_lit (subst_lit L2 \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   pos\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord", "unfolding orient_lit_def"], ["proof (prove)\nusing this:\n  (subst_lit L2 \\<sigma> =\n   Pos (Eq (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)) \\<or>\n   subst_lit L2 \\<sigma> =\n   Pos (Eq (v \\<lhd> \\<sigma>) (u \\<lhd> \\<sigma>))) \\<and>\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  pos = pos \\<or>\n  (subst_lit L2 \\<sigma> =\n   Neg (Eq (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)) \\<or>\n   subst_lit L2 \\<sigma> =\n   Neg (Eq (v \\<lhd> \\<sigma>) (u \\<lhd> \\<sigma>))) \\<and>\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and> pos = neg\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this and \\<open>(subst t \\<sigma>) \\<noteq> (subst v \\<sigma>)\\<close> \n      and \\<open>(subst t \\<sigma>) = (subst u \\<sigma>)\\<close>\n      and \\<open>vars_of (subst u \\<sigma>) = {}\\<close> \\<open>vars_of (subst v \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n  t \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n  vars_of (u \\<lhd> \\<sigma>) = {}\n  vars_of (v \\<lhd> \\<sigma>) = {}", "have \"((subst v \\<sigma>),(subst u \\<sigma>)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n  t \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n  vars_of (u \\<lhd> \\<sigma>) = {}\n  vars_of (v \\<lhd> \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord", "using trm_ord_ground_total"], ["proof (prove)\nusing this:\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n  t \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n  vars_of (u \\<lhd> \\<sigma>) = {}\n  vars_of (v \\<lhd> \\<sigma>) = {}\n  \\<forall>x y.\n     ground_term x \\<longrightarrow>\n     ground_term y \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord", "unfolding ground_term_def"], ["proof (prove)\nusing this:\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n  t \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n  vars_of (u \\<lhd> \\<sigma>) = {}\n  vars_of (v \\<lhd> \\<sigma>) = {}\n  \\<forall>x y.\n     vars_of x = {} \\<longrightarrow>\n     vars_of y = {} \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "let ?mC1 = \"mset_ecl (P1, \\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "let ?mC2 = \"mset_ecl (C, \\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>L2 \\<in> (cl_ecl P1)\\<close> \\<open>finite (cl_ecl P1)\\<close>"], ["proof (chain)\npicking this:\n  L2 \\<in> cl_ecl P1\n  finite (cl_ecl P1)", "have \"mset_set (cl_ecl P1) = mset_set ((cl_ecl P1)-{ L2 }) + mset_set { L2 }\""], ["proof (prove)\nusing this:\n  L2 \\<in> cl_ecl P1\n  finite (cl_ecl P1)\n\ngoal (1 subgoal):\n 1. mset_set (cl_ecl P1) = mset_set (cl_ecl P1 - {L2}) + mset_set {L2}", "using split_mset_set [of \"cl_ecl P1\" \"cl_ecl P1 - { L2 }\" \"{ L2 }\"]"], ["proof (prove)\nusing this:\n  L2 \\<in> cl_ecl P1\n  finite (cl_ecl P1)\n  \\<lbrakk>cl_ecl P1 = cl_ecl P1 - {L2} \\<union> {L2};\n   (cl_ecl P1 - {L2}) \\<inter> {L2} = {}; finite (cl_ecl P1 - {L2});\n   finite {L2}\\<rbrakk>\n  \\<Longrightarrow> mset_set (cl_ecl P1) =\n                    mset_set (cl_ecl P1 - {L2}) + mset_set {L2}\n\ngoal (1 subgoal):\n 1. mset_set (cl_ecl P1) = mset_set (cl_ecl P1 - {L2}) + mset_set {L2}", "by blast"], ["proof (state)\nthis:\n  mset_set (cl_ecl P1) = mset_set (cl_ecl P1 - {L2}) + mset_set {L2}\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  mset_set (cl_ecl P1) = mset_set (cl_ecl P1 - {L2}) + mset_set {L2}", "have  d1: \"{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set (cl_ecl P1)) #}\n      = {# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set ((cl_ecl P1) - { L2 })) #} \n        + {# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set { L2 }) #}\""], ["proof (prove)\nusing this:\n  mset_set (cl_ecl P1) = mset_set (cl_ecl P1 - {L2}) + mset_set {L2}\n\ngoal (1 subgoal):\n 1. {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#} =\n    {#mset_lit (subst_lit x \\<sigma>)\n    . x \\<in># mset_set (cl_ecl P1 - {L2})#} +\n    {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L2}#}", "using split_image_mset"], ["proof (prove)\nusing this:\n  mset_set (cl_ecl P1) = mset_set (cl_ecl P1 - {L2}) + mset_set {L2}\n  ?M = ?M1.0 + ?M2.0 \\<Longrightarrow>\n  image_mset ?f ?M = image_mset ?f ?M1.0 + image_mset ?f ?M2.0\n\ngoal (1 subgoal):\n 1. {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#} =\n    {#mset_lit (subst_lit x \\<sigma>)\n    . x \\<in># mset_set (cl_ecl P1 - {L2})#} +\n    {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L2}#}", "by auto"], ["proof (state)\nthis:\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#} =\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set (cl_ecl P1 - {L2})#} +\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L2}#}\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "let ?C = \"(((cl_ecl P1) - { L2 }) \\<union> { L' } )\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>finite (cl_ecl P1)\\<close>"], ["proof (chain)\npicking this:\n  finite (cl_ecl P1)", "have \"finite ?C\""], ["proof (prove)\nusing this:\n  finite (cl_ecl P1)\n\ngoal (1 subgoal):\n 1. finite (cl_ecl P1 - {L2} \\<union> {L'})", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl P1 - {L2} \\<union> {L'})\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "let ?C' = \"?C - ( (cl_ecl P1) - { L2 })\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>finite ?C\\<close>"], ["proof (chain)\npicking this:\n  finite (cl_ecl P1 - {L2} \\<union> {L'})", "have \"finite ?C'\""], ["proof (prove)\nusing this:\n  finite (cl_ecl P1 - {L2} \\<union> {L'})\n\ngoal (1 subgoal):\n 1. finite (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2}))", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2}))\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "have \"?C = ( (cl_ecl P1) - { L2 }) \\<union> ?C'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_ecl P1 - {L2} \\<union> {L'} =\n    cl_ecl P1 - {L2} \\<union>\n    (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2}))", "by auto"], ["proof (state)\nthis:\n  cl_ecl P1 - {L2} \\<union> {L'} =\n  cl_ecl P1 - {L2} \\<union>\n  (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2}))\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>finite (cl_ecl P1)\\<close> \\<open>finite ?C'\\<close>"], ["proof (chain)\npicking this:\n  finite (cl_ecl P1)\n  finite (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2}))", "have \"mset_set ?C = mset_set ((cl_ecl P1)-{ L2 }) + mset_set ?C'\""], ["proof (prove)\nusing this:\n  finite (cl_ecl P1)\n  finite (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2}))\n\ngoal (1 subgoal):\n 1. mset_set (cl_ecl P1 - {L2} \\<union> {L'}) =\n    mset_set (cl_ecl P1 - {L2}) +\n    mset_set (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2}))", "using split_mset_set [of \"?C\" \"cl_ecl P1 - { L2 }\" \"?C'\"]"], ["proof (prove)\nusing this:\n  finite (cl_ecl P1)\n  finite (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2}))\n  \\<lbrakk>cl_ecl P1 - {L2} \\<union> {L'} =\n           cl_ecl P1 - {L2} \\<union>\n           (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2}));\n   (cl_ecl P1 - {L2}) \\<inter>\n   (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2})) =\n   {};\n   finite (cl_ecl P1 - {L2});\n   finite (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2}))\\<rbrakk>\n  \\<Longrightarrow> mset_set (cl_ecl P1 - {L2} \\<union> {L'}) =\n                    mset_set (cl_ecl P1 - {L2}) +\n                    mset_set\n                     (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2}))\n\ngoal (1 subgoal):\n 1. mset_set (cl_ecl P1 - {L2} \\<union> {L'}) =\n    mset_set (cl_ecl P1 - {L2}) +\n    mset_set (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2}))", "by blast"], ["proof (state)\nthis:\n  mset_set (cl_ecl P1 - {L2} \\<union> {L'}) =\n  mset_set (cl_ecl P1 - {L2}) +\n  mset_set (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2}))\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  mset_set (cl_ecl P1 - {L2} \\<union> {L'}) =\n  mset_set (cl_ecl P1 - {L2}) +\n  mset_set (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2}))", "have  d2: \"{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set ?C) #}\n      = {# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set ((cl_ecl P1) - { L2 })) #} \n        + {# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set ?C') #}\""], ["proof (prove)\nusing this:\n  mset_set (cl_ecl P1 - {L2} \\<union> {L'}) =\n  mset_set (cl_ecl P1 - {L2}) +\n  mset_set (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2}))\n\ngoal (1 subgoal):\n 1. {#mset_lit (subst_lit x \\<sigma>)\n    . x \\<in># mset_set (cl_ecl P1 - {L2} \\<union> {L'})#} =\n    {#mset_lit (subst_lit x \\<sigma>)\n    . x \\<in># mset_set (cl_ecl P1 - {L2})#} +\n    {#mset_lit (subst_lit x \\<sigma>)\n    . x \\<in># mset_set\n                (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2}))#}", "using split_image_mset"], ["proof (prove)\nusing this:\n  mset_set (cl_ecl P1 - {L2} \\<union> {L'}) =\n  mset_set (cl_ecl P1 - {L2}) +\n  mset_set (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2}))\n  ?M = ?M1.0 + ?M2.0 \\<Longrightarrow>\n  image_mset ?f ?M = image_mset ?f ?M1.0 + image_mset ?f ?M2.0\n\ngoal (1 subgoal):\n 1. {#mset_lit (subst_lit x \\<sigma>)\n    . x \\<in># mset_set (cl_ecl P1 - {L2} \\<union> {L'})#} =\n    {#mset_lit (subst_lit x \\<sigma>)\n    . x \\<in># mset_set (cl_ecl P1 - {L2})#} +\n    {#mset_lit (subst_lit x \\<sigma>)\n    . x \\<in># mset_set\n                (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2}))#}", "by auto"], ["proof (state)\nthis:\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set (cl_ecl P1 - {L2} \\<union> {L'})#} =\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set (cl_ecl P1 - {L2})#} +\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set\n              (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2}))#}\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "have \"{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set { L2 }) #} \\<noteq> {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L2}#} \\<noteq> {#}", "by auto"], ["proof (state)\nthis:\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L2}#} \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "let ?K = \"{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set ?C') #}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "let ?J = \"{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set { L2 }) #}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "have \"(\\<forall>k \\<in> set_mset ?K. \\<exists>j \\<in> set_mset ?J. (k, j) \\<in> (mult trm_ord))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set\n                                (cl_ecl P1 - {L2} \\<union> {L'} -\n                                 (cl_ecl P1 - {L2}))#}.\n       \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                       . x \\<in># mset_set {L2}#}.\n          (k, j) \\<in> mult trm_ord", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n                . x \\<in># mset_set\n                            (cl_ecl P1 - {L2} \\<union> {L'} -\n                             (cl_ecl P1 - {L2}))#} \\<Longrightarrow>\n       \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                       . x \\<in># mset_set {L2}#}.\n          (k, j) \\<in> mult trm_ord", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n                . x \\<in># mset_set\n                            (cl_ecl P1 - {L2} \\<union> {L'} -\n                             (cl_ecl P1 - {L2}))#} \\<Longrightarrow>\n       \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                       . x \\<in># mset_set {L2}#}.\n          (k, j) \\<in> mult trm_ord", "assume \"k \\<in> set_mset ?K\""], ["proof (state)\nthis:\n  k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n           . x \\<in># mset_set\n                       (cl_ecl P1 - {L2} \\<union> {L'} -\n                        (cl_ecl P1 - {L2}))#}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n                . x \\<in># mset_set\n                            (cl_ecl P1 - {L2} \\<union> {L'} -\n                             (cl_ecl P1 - {L2}))#} \\<Longrightarrow>\n       \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                       . x \\<in># mset_set {L2}#}.\n          (k, j) \\<in> mult trm_ord", "from this"], ["proof (chain)\npicking this:\n  k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n           . x \\<in># mset_set\n                       (cl_ecl P1 - {L2} \\<union> {L'} -\n                        (cl_ecl P1 - {L2}))#}", "have \"k \\<in># ?K\""], ["proof (prove)\nusing this:\n  k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n           . x \\<in># mset_set\n                       (cl_ecl P1 - {L2} \\<union> {L'} -\n                        (cl_ecl P1 - {L2}))#}\n\ngoal (1 subgoal):\n 1. k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n             . x \\<in># mset_set\n                         (cl_ecl P1 - {L2} \\<union> {L'} -\n                          (cl_ecl P1 - {L2}))#}", "by simp"], ["proof (state)\nthis:\n  k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n           . x \\<in># mset_set\n                       (cl_ecl P1 - {L2} \\<union> {L'} -\n                        (cl_ecl P1 - {L2}))#}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n                . x \\<in># mset_set\n                            (cl_ecl P1 - {L2} \\<union> {L'} -\n                             (cl_ecl P1 - {L2}))#} \\<Longrightarrow>\n       \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                       . x \\<in># mset_set {L2}#}.\n          (k, j) \\<in> mult trm_ord", "from this"], ["proof (chain)\npicking this:\n  k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n           . x \\<in># mset_set\n                       (cl_ecl P1 - {L2} \\<union> {L'} -\n                        (cl_ecl P1 - {L2}))#}", "obtain M' where \"M' \\<in># (mset_set ?C')\" and \"k = (mset_lit (subst_lit M' \\<sigma>))\""], ["proof (prove)\nusing this:\n  k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n           . x \\<in># mset_set\n                       (cl_ecl P1 - {L2} \\<union> {L'} -\n                        (cl_ecl P1 - {L2}))#}\n\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        \\<lbrakk>M' \\<in># mset_set\n                            (cl_ecl P1 - {L2} \\<union> {L'} -\n                             (cl_ecl P1 - {L2}));\n         k = mset_lit (subst_lit M' \\<sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using image_mset_thm [of \"?K\"  \"\\<lambda>x. (mset_lit (subst_lit x \\<sigma>))\" \"(mset_set ?C')\"]"], ["proof (prove)\nusing this:\n  k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n           . x \\<in># mset_set\n                       (cl_ecl P1 - {L2} \\<union> {L'} -\n                        (cl_ecl P1 - {L2}))#}\n  \\<lbrakk>{#mset_lit (subst_lit x \\<sigma>)\n           . x \\<in># mset_set\n                       (cl_ecl P1 - {L2} \\<union> {L'} -\n                        (cl_ecl P1 - {L2}))#} =\n           {#mset_lit (subst_lit x \\<sigma>)\n           . x \\<in># mset_set\n                       (cl_ecl P1 - {L2} \\<union> {L'} -\n                        (cl_ecl P1 - {L2}))#};\n   ?x \\<in># {#mset_lit (subst_lit x \\<sigma>)\n             . x \\<in># mset_set\n                         (cl_ecl P1 - {L2} \\<union> {L'} -\n                          (cl_ecl P1 - {L2}))#}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y.\n                       y \\<in># mset_set\n                                 (cl_ecl P1 - {L2} \\<union> {L'} -\n                                  (cl_ecl P1 - {L2})) \\<and>\n                       ?x = mset_lit (subst_lit y \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        \\<lbrakk>M' \\<in># mset_set\n                            (cl_ecl P1 - {L2} \\<union> {L'} -\n                             (cl_ecl P1 - {L2}));\n         k = mset_lit (subst_lit M' \\<sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  M' \\<in># mset_set (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2}))\n  k = mset_lit (subst_lit M' \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n                . x \\<in># mset_set\n                            (cl_ecl P1 - {L2} \\<union> {L'} -\n                             (cl_ecl P1 - {L2}))#} \\<Longrightarrow>\n       \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                       . x \\<in># mset_set {L2}#}.\n          (k, j) \\<in> mult trm_ord", "from \\<open>M' \\<in># (mset_set ?C')\\<close>and \\<open>finite ?C'\\<close>"], ["proof (chain)\npicking this:\n  M' \\<in># mset_set (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2}))\n  finite (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2}))", "have \"M' \\<in> ?C'\""], ["proof (prove)\nusing this:\n  M' \\<in># mset_set (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2}))\n  finite (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2}))\n\ngoal (1 subgoal):\n 1. M' \\<in> cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2})", "by auto"], ["proof (state)\nthis:\n  M' \\<in> cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2})\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n                . x \\<in># mset_set\n                            (cl_ecl P1 - {L2} \\<union> {L'} -\n                             (cl_ecl P1 - {L2}))#} \\<Longrightarrow>\n       \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                       . x \\<in># mset_set {L2}#}.\n          (k, j) \\<in> mult trm_ord", "have \"L2 \\<in># (mset_set { L2 })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. L2 \\<in># mset_set {L2}", "by auto"], ["proof (state)\nthis:\n  L2 \\<in># mset_set {L2}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n                . x \\<in># mset_set\n                            (cl_ecl P1 - {L2} \\<union> {L'} -\n                             (cl_ecl P1 - {L2}))#} \\<Longrightarrow>\n       \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                       . x \\<in># mset_set {L2}#}.\n          (k, j) \\<in> mult trm_ord", "from this"], ["proof (chain)\npicking this:\n  L2 \\<in># mset_set {L2}", "have \"(mset_lit (subst_lit L2 \\<sigma>) \\<in># ?J)\""], ["proof (prove)\nusing this:\n  L2 \\<in># mset_set {L2}\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L2 \\<sigma>)\n    \\<in># {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L2}#}", "by auto"], ["proof (state)\nthis:\n  mset_lit (subst_lit L2 \\<sigma>)\n  \\<in># {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L2}#}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n                . x \\<in># mset_set\n                            (cl_ecl P1 - {L2} \\<union> {L'} -\n                             (cl_ecl P1 - {L2}))#} \\<Longrightarrow>\n       \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                       . x \\<in># mset_set {L2}#}.\n          (k, j) \\<in> mult trm_ord", "from this"], ["proof (chain)\npicking this:\n  mset_lit (subst_lit L2 \\<sigma>)\n  \\<in># {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L2}#}", "have \"(mset_lit (subst_lit L2 \\<sigma>) \\<in> set_mset ?J)\""], ["proof (prove)\nusing this:\n  mset_lit (subst_lit L2 \\<sigma>)\n  \\<in># {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L2}#}\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L2 \\<sigma>)\n    \\<in># {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L2}#}", "by auto"], ["proof (state)\nthis:\n  mset_lit (subst_lit L2 \\<sigma>)\n  \\<in># {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L2}#}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n                . x \\<in># mset_set\n                            (cl_ecl P1 - {L2} \\<union> {L'} -\n                             (cl_ecl P1 - {L2}))#} \\<Longrightarrow>\n       \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                       . x \\<in># mset_set {L2}#}.\n          (k, j) \\<in> mult trm_ord", "have \"{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set { L2 }) #} \\<noteq> {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L2}#} \\<noteq> {#}", "by auto"], ["proof (state)\nthis:\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L2}#} \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       k \\<in># {#mset_lit (subst_lit x \\<sigma>)\n                . x \\<in># mset_set\n                            (cl_ecl P1 - {L2} \\<union> {L'} -\n                             (cl_ecl P1 - {L2}))#} \\<Longrightarrow>\n       \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                       . x \\<in># mset_set {L2}#}.\n          (k, j) \\<in> mult trm_ord", "show \"\\<exists>j \\<in> set_mset ?J. (k, j) \\<in> (mult trm_ord)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L2}#}.\n       (k, j) \\<in> mult trm_ord", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L2}#}.\n       (k, j) \\<in> mult trm_ord", "from \\<open>M' \\<in> ?C'\\<close>"], ["proof (chain)\npicking this:\n  M' \\<in> cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2})", "have \"M' = L'\""], ["proof (prove)\nusing this:\n  M' \\<in> cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2})\n\ngoal (1 subgoal):\n 1. M' = L'", "by auto"], ["proof (state)\nthis:\n  M' = L'\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L2}#}.\n       (k, j) \\<in> mult trm_ord", "from  \\<open>orient_lit_inst L2 u v pos \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L2 u v pos \\<sigma>", "have i: \"(mset_lit (subst_lit L2 \\<sigma>)) \n          = {#} + {# (subst u \\<sigma>), (subst v \\<sigma>) #}\""], ["proof (prove)\nusing this:\n  orient_lit_inst L2 u v pos \\<sigma>\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L2 \\<sigma>) =\n    {#} + {#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  (L2 = Pos (Eq u v) \\<or> L2 = Pos (Eq v u)) \\<and>\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  pos = pos \\<or>\n  (L2 = Neg (Eq u v) \\<or> L2 = Neg (Eq v u)) \\<and>\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and> pos = neg\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L2 \\<sigma>) =\n    {#} + {#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}", "using add.commute"], ["proof (prove)\nusing this:\n  (L2 = Pos (Eq u v) \\<or> L2 = Pos (Eq v u)) \\<and>\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  pos = pos \\<or>\n  (L2 = Neg (Eq u v) \\<or> L2 = Neg (Eq v u)) \\<and>\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and> pos = neg\n  ?a + ?b = ?b + ?a\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L2 \\<sigma>) =\n    {#} + {#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}", "by force"], ["proof (state)\nthis:\n  mset_lit (subst_lit L2 \\<sigma>) =\n  {#} + {#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L2}#}.\n       (k, j) \\<in> mult trm_ord", "from  \\<open>L' = Neg (Eq s v)\\<close>"], ["proof (chain)\npicking this:\n  L' = Neg (Eq s v)", "have ii: \"(mset_lit (subst_lit L' \\<sigma>)) = \n          {#} + {# (subst s \\<sigma>), (subst s \\<sigma>), (subst v \\<sigma>), (subst v \\<sigma>) #}\""], ["proof (prove)\nusing this:\n  L' = Neg (Eq s v)\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L' \\<sigma>) =\n    {#} +\n    {#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>,\n      v \\<lhd> \\<sigma>#}", "by force"], ["proof (state)\nthis:\n  mset_lit (subst_lit L' \\<sigma>) =\n  {#} +\n  {#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>,\n    v \\<lhd> \\<sigma>#}\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L2}#}.\n       (k, j) \\<in> mult trm_ord", "have \"{# (subst u \\<sigma>), (subst v \\<sigma>) #} \\<noteq> {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#} \\<noteq> {#}", "by auto"], ["proof (state)\nthis:\n  {#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#} \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L2}#}.\n       (k, j) \\<in> mult trm_ord", "have \"(\\<forall>k' \\<in> set_mset {# (subst s \\<sigma>), (subst s \\<sigma>), (subst v \\<sigma>), (subst v \\<sigma>) #}. \n          \\<exists>j' \\<in> set_mset {# (subst u \\<sigma>), (subst v \\<sigma>) #}. (k', j') \\<in> (trm_ord))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k'\\<in>#{#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>,\n                       v \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n       \\<exists>j'\\<in>#{#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n          (k', j') \\<in> trm_ord", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k'.\n       k' \\<in># {#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>,\n                   v \\<lhd> \\<sigma>#} \\<Longrightarrow>\n       \\<exists>j'\\<in>#{#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n          (k', j') \\<in> trm_ord", "fix k'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k'.\n       k' \\<in># {#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>,\n                   v \\<lhd> \\<sigma>#} \\<Longrightarrow>\n       \\<exists>j'\\<in>#{#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n          (k', j') \\<in> trm_ord", "assume nh: \"k' \\<in>set_mset {# (subst s \\<sigma>), (subst s \\<sigma>), (subst v \\<sigma>), (subst v \\<sigma>) #}\""], ["proof (state)\nthis:\n  k' \\<in># {#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>,\n              v \\<lhd> \\<sigma>#}\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       k' \\<in># {#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>,\n                   v \\<lhd> \\<sigma>#} \\<Longrightarrow>\n       \\<exists>j'\\<in>#{#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n          (k', j') \\<in> trm_ord", "have \"(subst u \\<sigma>) \\<in> set_mset {# (subst u \\<sigma>), (subst v \\<sigma>) #}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<lhd> \\<sigma> \\<in># {#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}", "by auto"], ["proof (state)\nthis:\n  u \\<lhd> \\<sigma> \\<in># {#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       k' \\<in># {#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>,\n                   v \\<lhd> \\<sigma>#} \\<Longrightarrow>\n       \\<exists>j'\\<in>#{#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n          (k', j') \\<in> trm_ord", "from nh"], ["proof (chain)\npicking this:\n  k' \\<in># {#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>,\n              v \\<lhd> \\<sigma>#}", "have \"k' = (subst s \\<sigma>) \\<or> k' = (subst v \\<sigma>)\""], ["proof (prove)\nusing this:\n  k' \\<in># {#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>,\n              v \\<lhd> \\<sigma>#}\n\ngoal (1 subgoal):\n 1. k' = s \\<lhd> \\<sigma> \\<or> k' = v \\<lhd> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  k' = s \\<lhd> \\<sigma> \\<or> k' = v \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       k' \\<in># {#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>,\n                   v \\<lhd> \\<sigma>#} \\<Longrightarrow>\n       \\<exists>j'\\<in>#{#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n          (k', j') \\<in> trm_ord", "then"], ["proof (chain)\npicking this:\n  k' = s \\<lhd> \\<sigma> \\<or> k' = v \\<lhd> \\<sigma>", "show \"\\<exists>j' \\<in> set_mset {# (subst u \\<sigma>), (subst v \\<sigma>) #}. (k', j') \\<in> (trm_ord)\""], ["proof (prove)\nusing this:\n  k' = s \\<lhd> \\<sigma> \\<or> k' = v \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>j'\\<in>#{#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n       (k', j') \\<in> trm_ord", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. k' = s \\<lhd> \\<sigma> \\<Longrightarrow>\n    \\<exists>j'\\<in>#{#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n       (k', j') \\<in> trm_ord\n 2. k' = v \\<lhd> \\<sigma> \\<Longrightarrow>\n    \\<exists>j'\\<in>#{#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n       (k', j') \\<in> trm_ord", "assume \"k' = (subst s \\<sigma>)\""], ["proof (state)\nthis:\n  k' = s \\<lhd> \\<sigma>\n\ngoal (2 subgoals):\n 1. k' = s \\<lhd> \\<sigma> \\<Longrightarrow>\n    \\<exists>j'\\<in>#{#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n       (k', j') \\<in> trm_ord\n 2. k' = v \\<lhd> \\<sigma> \\<Longrightarrow>\n    \\<exists>j'\\<in>#{#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n       (k', j') \\<in> trm_ord", "from this and \\<open>((subst s \\<sigma>),(subst u \\<sigma>)) \\<in> trm_ord\\<close>\n              and \\<open>(subst u \\<sigma>) \\<in> set_mset {# (subst u \\<sigma>), (subst v \\<sigma>) #}\\<close>"], ["proof (chain)\npicking this:\n  k' = s \\<lhd> \\<sigma>\n  (s \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n  u \\<lhd> \\<sigma> \\<in># {#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}", "show ?thesis"], ["proof (prove)\nusing this:\n  k' = s \\<lhd> \\<sigma>\n  (s \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n  u \\<lhd> \\<sigma> \\<in># {#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}\n\ngoal (1 subgoal):\n 1. \\<exists>j'\\<in>#{#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n       (k', j') \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  \\<exists>j'\\<in>#{#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n     (k', j') \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. k' = v \\<lhd> \\<sigma> \\<Longrightarrow>\n    \\<exists>j'\\<in>#{#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n       (k', j') \\<in> trm_ord", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k' = v \\<lhd> \\<sigma> \\<Longrightarrow>\n    \\<exists>j'\\<in>#{#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n       (k', j') \\<in> trm_ord", "assume \"k' = (subst v \\<sigma>)\""], ["proof (state)\nthis:\n  k' = v \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. k' = v \\<lhd> \\<sigma> \\<Longrightarrow>\n    \\<exists>j'\\<in>#{#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n       (k', j') \\<in> trm_ord", "from this and \\<open>((subst v \\<sigma>),(subst u \\<sigma>)) \\<in> trm_ord\\<close>\n              and \\<open>(subst u \\<sigma>) \\<in> set_mset {# (subst u \\<sigma>), (subst v \\<sigma>) #}\\<close>"], ["proof (chain)\npicking this:\n  k' = v \\<lhd> \\<sigma>\n  (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n  u \\<lhd> \\<sigma> \\<in># {#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}", "show ?thesis"], ["proof (prove)\nusing this:\n  k' = v \\<lhd> \\<sigma>\n  (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n  u \\<lhd> \\<sigma> \\<in># {#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}\n\ngoal (1 subgoal):\n 1. \\<exists>j'\\<in>#{#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n       (k', j') \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  \\<exists>j'\\<in>#{#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n     (k', j') \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j'\\<in>#{#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n     (k', j') \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>k'\\<in>#{#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>,\n                     v \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n     \\<exists>j'\\<in>#{#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n        (k', j') \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L2}#}.\n       (k, j) \\<in> mult trm_ord", "from this i ii \\<open>{# (subst u \\<sigma>), (subst v \\<sigma>) #} \\<noteq> {#}\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>k'\\<in>#{#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>,\n                     v \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n     \\<exists>j'\\<in>#{#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n        (k', j') \\<in> trm_ord\n  mset_lit (subst_lit L2 \\<sigma>) =\n  {#} + {#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}\n  mset_lit (subst_lit L' \\<sigma>) =\n  {#} +\n  {#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>,\n    v \\<lhd> \\<sigma>#}\n  {#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#} \\<noteq> {#}", "have \"(mset_lit (subst_lit L' \\<sigma>),\n            (mset_lit (subst_lit L2 \\<sigma>))) \\<in> (mult trm_ord)\""], ["proof (prove)\nusing this:\n  \\<forall>k'\\<in>#{#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>,\n                     v \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n     \\<exists>j'\\<in>#{#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n        (k', j') \\<in> trm_ord\n  mset_lit (subst_lit L2 \\<sigma>) =\n  {#} + {#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}\n  mset_lit (subst_lit L' \\<sigma>) =\n  {#} +\n  {#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>,\n    v \\<lhd> \\<sigma>#}\n  {#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#} \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. (mset_lit (subst_lit L' \\<sigma>), mset_lit (subst_lit L2 \\<sigma>))\n    \\<in> mult trm_ord", "using one_step_implies_mult  [of \"{# (subst u \\<sigma>), (subst v \\<sigma>) #}\" \n               \"{#  (subst s \\<sigma>),(subst s \\<sigma>), (subst v \\<sigma>),(subst v \\<sigma>) #}\" \n               trm_ord \"{#}\"] \n             trm_ord_trans"], ["proof (prove)\nusing this:\n  \\<forall>k'\\<in>#{#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>,\n                     v \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n     \\<exists>j'\\<in>#{#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n        (k', j') \\<in> trm_ord\n  mset_lit (subst_lit L2 \\<sigma>) =\n  {#} + {#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}\n  mset_lit (subst_lit L' \\<sigma>) =\n  {#} +\n  {#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>,\n    v \\<lhd> \\<sigma>#}\n  {#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#} \\<noteq> {#}\n  \\<lbrakk>{#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#} \\<noteq> {#};\n   \\<forall>k\\<in>#{#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>,\n                     v \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n      \\<exists>j\\<in>#{#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#}.\n         (k, j) \\<in> trm_ord\\<rbrakk>\n  \\<Longrightarrow> ({#} +\n                     {#s \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>,\n                       v \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#},\n                     {#} + {#u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>#})\n                    \\<in> mult trm_ord\n  trans trm_ord\n\ngoal (1 subgoal):\n 1. (mset_lit (subst_lit L' \\<sigma>), mset_lit (subst_lit L2 \\<sigma>))\n    \\<in> mult trm_ord", "by metis"], ["proof (state)\nthis:\n  (mset_lit (subst_lit L' \\<sigma>), mset_lit (subst_lit L2 \\<sigma>))\n  \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L2}#}.\n       (k, j) \\<in> mult trm_ord", "from this \\<open>M' = L'\\<close> \\<open>k = (mset_lit (subst_lit M' \\<sigma>))\\<close>"], ["proof (chain)\npicking this:\n  (mset_lit (subst_lit L' \\<sigma>), mset_lit (subst_lit L2 \\<sigma>))\n  \\<in> mult trm_ord\n  M' = L'\n  k = mset_lit (subst_lit M' \\<sigma>)", "show ?thesis"], ["proof (prove)\nusing this:\n  (mset_lit (subst_lit L' \\<sigma>), mset_lit (subst_lit L2 \\<sigma>))\n  \\<in> mult trm_ord\n  M' = L'\n  k = mset_lit (subst_lit M' \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                    . x \\<in># mset_set {L2}#}.\n       (k, j) \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                  . x \\<in># mset_set {L2}#}.\n     (k, j) \\<in> mult trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                  . x \\<in># mset_set {L2}#}.\n     (k, j) \\<in> mult trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>k\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                  . x \\<in># mset_set\n                              (cl_ecl P1 - {L2} \\<union> {L'} -\n                               (cl_ecl P1 - {L2}))#}.\n     \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                     . x \\<in># mset_set {L2}#}.\n        (k, j) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this d1 d2 \\<open>{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set { L2 }) #} \\<noteq> {#}\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>k\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                  . x \\<in># mset_set\n                              (cl_ecl P1 - {L2} \\<union> {L'} -\n                               (cl_ecl P1 - {L2}))#}.\n     \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                     . x \\<in># mset_set {L2}#}.\n        (k, j) \\<in> mult trm_ord\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#} =\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set (cl_ecl P1 - {L2})#} +\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L2}#}\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set (cl_ecl P1 - {L2} \\<union> {L'})#} =\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set (cl_ecl P1 - {L2})#} +\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set\n              (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2}))#}\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L2}#} \\<noteq> {#}", "have o: \"\n      ({#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set ?C #},\n      {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#})\n     \\<in> mult (mult trm_ord)\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                  . x \\<in># mset_set\n                              (cl_ecl P1 - {L2} \\<union> {L'} -\n                               (cl_ecl P1 - {L2}))#}.\n     \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                     . x \\<in># mset_set {L2}#}.\n        (k, j) \\<in> mult trm_ord\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#} =\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set (cl_ecl P1 - {L2})#} +\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L2}#}\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set (cl_ecl P1 - {L2} \\<union> {L'})#} =\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set (cl_ecl P1 - {L2})#} +\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set\n              (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2}))#}\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L2}#} \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. ({#mset_lit (subst_lit x \\<sigma>)\n     . x \\<in># mset_set (cl_ecl P1 - {L2} \\<union> {L'})#},\n     {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#})\n    \\<in> mult (mult trm_ord)", "using  mult_trm_ord_trans one_step_implies_mult [of\n      \"{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set { L2 }) #}\"\n      \"{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set ?C') #}\"  \"mult trm_ord\" \n      \"{# (mset_lit (subst_lit x \\<sigma>)). x \\<in># (mset_set ((cl_ecl P1) - { L2 })) #} \" ]"], ["proof (prove)\nusing this:\n  \\<forall>k\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                  . x \\<in># mset_set\n                              (cl_ecl P1 - {L2} \\<union> {L'} -\n                               (cl_ecl P1 - {L2}))#}.\n     \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                     . x \\<in># mset_set {L2}#}.\n        (k, j) \\<in> mult trm_ord\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#} =\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set (cl_ecl P1 - {L2})#} +\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L2}#}\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set (cl_ecl P1 - {L2} \\<union> {L'})#} =\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set (cl_ecl P1 - {L2})#} +\n  {#mset_lit (subst_lit x \\<sigma>)\n  . x \\<in># mset_set\n              (cl_ecl P1 - {L2} \\<union> {L'} - (cl_ecl P1 - {L2}))#}\n  {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set {L2}#} \\<noteq> {#}\n  trans (mult trm_ord)\n  \\<lbrakk>{#mset_lit (subst_lit x \\<sigma>)\n           . x \\<in># mset_set {L2}#} \\<noteq>\n           {#};\n   \\<forall>k\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                   . x \\<in># mset_set\n                               (cl_ecl P1 - {L2} \\<union> {L'} -\n                                (cl_ecl P1 - {L2}))#}.\n      \\<exists>j\\<in>#{#mset_lit (subst_lit x \\<sigma>)\n                      . x \\<in># mset_set {L2}#}.\n         (k, j) \\<in> mult trm_ord\\<rbrakk>\n  \\<Longrightarrow> ({#mset_lit (subst_lit x \\<sigma>)\n                     . x \\<in># mset_set (cl_ecl P1 - {L2})#} +\n                     {#mset_lit (subst_lit x \\<sigma>)\n                     . x \\<in># mset_set\n                                 (cl_ecl P1 - {L2} \\<union> {L'} -\n                                  (cl_ecl P1 - {L2}))#},\n                     {#mset_lit (subst_lit x \\<sigma>)\n                     . x \\<in># mset_set (cl_ecl P1 - {L2})#} +\n                     {#mset_lit (subst_lit x \\<sigma>)\n                     . x \\<in># mset_set {L2}#})\n                    \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. ({#mset_lit (subst_lit x \\<sigma>)\n     . x \\<in># mset_set (cl_ecl P1 - {L2} \\<union> {L'})#},\n     {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#})\n    \\<in> mult (mult trm_ord)", "by metis"], ["proof (state)\nthis:\n  ({#mset_lit (subst_lit x \\<sigma>)\n   . x \\<in># mset_set (cl_ecl P1 - {L2} \\<union> {L'})#},\n   {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#})\n  \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       P1 \\<in> P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this \\<open>(Cl_P = (cl_ecl P1))\\<close> \\<open>C' = ( (Cl_P - { L2 }) \\<union> { L' } )\\<close> and \\<open>P1 \\<in> P\\<close> \n    and hyp"], ["proof (chain)\npicking this:\n  ({#mset_lit (subst_lit x \\<sigma>)\n   . x \\<in># mset_set (cl_ecl P1 - {L2} \\<union> {L'})#},\n   {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#})\n  \\<in> mult (mult trm_ord)\n  Cl_P = cl_ecl P1\n  C' = Cl_P - {L2} \\<union> {L'}\n  P1 \\<in> P\n  \\<nexists>D.\n     D \\<in> P \\<and>\n     (mset_cl (C', \\<sigma>), mset_ecl (D, \\<sigma>))\n     \\<in> mult (mult trm_ord)", "show False"], ["proof (prove)\nusing this:\n  ({#mset_lit (subst_lit x \\<sigma>)\n   . x \\<in># mset_set (cl_ecl P1 - {L2} \\<union> {L'})#},\n   {#mset_lit (subst_lit x \\<sigma>). x \\<in># mset_set (cl_ecl P1)#})\n  \\<in> mult (mult trm_ord)\n  Cl_P = cl_ecl P1\n  C' = Cl_P - {L2} \\<union> {L'}\n  P1 \\<in> P\n  \\<nexists>D.\n     D \\<in> P \\<and>\n     (mset_cl (C', \\<sigma>), mset_ecl (D, \\<sigma>))\n     \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>P1. P1 \\<in> P \\<and> factorization P1 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. \\<nexists>D.\n       D \\<in> P \\<and>\n       (mset_cl (C', \\<sigma>), mset_ecl (D, \\<sigma>))\n       \\<in> mult (mult trm_ord) \\<Longrightarrow>\n    False", "from not_sup not_ref not_fact and assms(1)"], ["proof (chain)\npicking this:\n  \\<nexists>P1 P2.\n     P1 \\<in> P \\<and>\n     P2 \\<in> P \\<and> superposition P1 P2 C \\<sigma> Ground C'\n  \\<nexists>P1. P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C'\n  \\<nexists>P1. P1 \\<in> P \\<and> factorization P1 C \\<sigma> Ground C'\n  derivable C P S \\<sigma> Ground C'", "show False"], ["proof (prove)\nusing this:\n  \\<nexists>P1 P2.\n     P1 \\<in> P \\<and>\n     P2 \\<in> P \\<and> superposition P1 P2 C \\<sigma> Ground C'\n  \\<nexists>P1. P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C'\n  \\<nexists>P1. P1 \\<in> P \\<and> factorization P1 C \\<sigma> Ground C'\n  derivable C P S \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. False", "unfolding derivable_def"], ["proof (prove)\nusing this:\n  \\<nexists>P1 P2.\n     P1 \\<in> P \\<and>\n     P2 \\<in> P \\<and> superposition P1 P2 C \\<sigma> Ground C'\n  \\<nexists>P1. P1 \\<in> P \\<and> reflexion P1 C \\<sigma> Ground C'\n  \\<nexists>P1. P1 \\<in> P \\<and> factorization P1 C \\<sigma> Ground C'\n  (\\<exists>P1 P2.\n      P1 \\<in> S \\<and>\n      P2 \\<in> S \\<and>\n      P = {P1, P2} \\<and> superposition P1 P2 C \\<sigma> Ground C') \\<or>\n  (\\<exists>P1.\n      P1 \\<in> S \\<and>\n      P = {P1} \\<and> factorization P1 C \\<sigma> Ground C') \\<or>\n  (\\<exists>P1.\n      P1 \\<in> S \\<and> P = {P1} \\<and> reflexion P1 C \\<sigma> Ground C')\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma redundant_inference_clause:\n  assumes \"redundant_clause E S \\<sigma> C'\"\n  assumes \"derivable C P S \\<sigma> Ground C'\"\n  assumes \"grounding_set P \\<sigma>\"\n  assumes \"\\<forall>x \\<in> S. (finite (cl_ecl x))\" \n  shows \"redundant_inference E S P \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redundant_inference E S P \\<sigma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. redundant_inference E S P \\<sigma>", "from assms(1)"], ["proof (chain)\npicking this:\n  redundant_clause E S \\<sigma> C'", "obtain S' where \"S' \\<subseteq> (instances S)\" \n    \"(set_entails_clause (clset_instances S') (cl_ecl E))\"\n    \"(\\<forall>x \\<in> S'. ( subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) \n              (trms_ecl E)))\"\n    \"(\\<forall>x \\<in> S'. ( ((mset_ecl ((fst x),(snd x))),(mset_cl (C',\\<sigma>))) \\<in> (mult (mult trm_ord))\n              \\<or> (mset_ecl ((fst x),(snd x))) = mset_cl (C',\\<sigma>)))\""], ["proof (prove)\nusing this:\n  redundant_clause E S \\<sigma> C'\n\ngoal (1 subgoal):\n 1. (\\<And>S'.\n        \\<lbrakk>S' \\<subseteq> instances S;\n         set_entails_clause (clset_instances S') (cl_ecl E);\n         \\<forall>x\\<in>S'.\n            subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n             (trms_ecl E);\n         \\<forall>x\\<in>S'.\n            (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n            \\<in> mult (mult trm_ord) \\<or>\n            mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding redundant_clause_def"], ["proof (prove)\nusing this:\n  \\<exists>S'\\<subseteq>instances S.\n     set_entails_clause (clset_instances S') (cl_ecl E) \\<and>\n     (\\<forall>x\\<in>S'.\n         subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n          (trms_ecl E)) \\<and>\n     (\\<forall>x\\<in>S'.\n         (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n         \\<in> mult (mult trm_ord) \\<or>\n         mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>))\n\ngoal (1 subgoal):\n 1. (\\<And>S'.\n        \\<lbrakk>S' \\<subseteq> instances S;\n         set_entails_clause (clset_instances S') (cl_ecl E);\n         \\<forall>x\\<in>S'.\n            subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n             (trms_ecl E);\n         \\<forall>x\\<in>S'.\n            (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n            \\<in> mult (mult trm_ord) \\<or>\n            mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  S' \\<subseteq> instances S\n  set_entails_clause (clset_instances S') (cl_ecl E)\n  \\<forall>x\\<in>S'.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) (trms_ecl E)\n  \\<forall>x\\<in>S'.\n     (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n     \\<in> mult (mult trm_ord) \\<or>\n     mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)\n\ngoal (1 subgoal):\n 1. redundant_inference E S P \\<sigma>", "from assms(3) assms(4) \\<open>derivable C P S \\<sigma> Ground C'\\<close>"], ["proof (chain)\npicking this:\n  grounding_set P \\<sigma>\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  derivable C P S \\<sigma> Ground C'", "obtain D where \"D \\<in> P\" \n      \"(( (mset_cl (C',\\<sigma>)), (mset_ecl (D,\\<sigma>))) \\<in> (mult (mult trm_ord)))\""], ["proof (prove)\nusing this:\n  grounding_set P \\<sigma>\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  derivable C P S \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>D \\<in> P;\n         (mset_cl (C', \\<sigma>), mset_ecl (D, \\<sigma>))\n         \\<in> mult (mult trm_ord)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using conclusion_is_smaller_than_premisses"], ["proof (prove)\nusing this:\n  grounding_set P \\<sigma>\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  derivable C P S \\<sigma> Ground C'\n  \\<lbrakk>derivable ?C ?P ?S ?\\<sigma> Ground ?C';\n   \\<forall>x\\<in>?S. finite (cl_ecl x); grounding_set ?P ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>D.\n                       D \\<in> ?P \\<and>\n                       (mset_cl (?C', ?\\<sigma>), mset_ecl (D, ?\\<sigma>))\n                       \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. (\\<And>D.\n        \\<lbrakk>D \\<in> P;\n         (mset_cl (C', \\<sigma>), mset_ecl (D, \\<sigma>))\n         \\<in> mult (mult trm_ord)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  D \\<in> P\n  (mset_cl (C', \\<sigma>), mset_ecl (D, \\<sigma>)) \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. redundant_inference E S P \\<sigma>", "have \"(\\<forall>x \\<in> S'. \\<exists>D' \\<in> P. (((fst x),(snd x)),(D',\\<sigma>)) \\<in> ecl_ord)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S'.\n       \\<exists>D'\\<in>P. ((fst x, snd x), D', \\<sigma>) \\<in> ecl_ord", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> S' \\<Longrightarrow>\n       \\<exists>D'\\<in>P. ((fst x, snd x), D', \\<sigma>) \\<in> ecl_ord", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> S' \\<Longrightarrow>\n       \\<exists>D'\\<in>P. ((fst x, snd x), D', \\<sigma>) \\<in> ecl_ord", "assume \"x \\<in> S'\""], ["proof (state)\nthis:\n  x \\<in> S'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> S' \\<Longrightarrow>\n       \\<exists>D'\\<in>P. ((fst x, snd x), D', \\<sigma>) \\<in> ecl_ord", "from this and \\<open>(\\<forall>x \\<in> S'. ( ((mset_ecl ((fst x),(snd x))),(mset_cl (C',\\<sigma>))) \\<in> (mult (mult trm_ord))\n              \\<or> (mset_ecl ((fst x),(snd x))) = mset_cl (C',\\<sigma>)))\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> S'\n  \\<forall>x\\<in>S'.\n     (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n     \\<in> mult (mult trm_ord) \\<or>\n     mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)", "have \"((mset_ecl ((fst x),(snd x))),(mset_cl (C',\\<sigma>))) \\<in> (mult (mult trm_ord)) \\<or>\n            (mset_ecl ((fst x),(snd x))) = mset_cl (C',\\<sigma>)\""], ["proof (prove)\nusing this:\n  x \\<in> S'\n  \\<forall>x\\<in>S'.\n     (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n     \\<in> mult (mult trm_ord) \\<or>\n     mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)\n\ngoal (1 subgoal):\n 1. (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n    \\<in> mult (mult trm_ord) \\<or>\n    mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n  \\<in> mult (mult trm_ord) \\<or>\n  mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> S' \\<Longrightarrow>\n       \\<exists>D'\\<in>P. ((fst x, snd x), D', \\<sigma>) \\<in> ecl_ord", "then"], ["proof (chain)\npicking this:\n  (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n  \\<in> mult (mult trm_ord) \\<or>\n  mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)", "have \"(((fst x),(snd x)),(D,\\<sigma>)) \\<in> ecl_ord\""], ["proof (prove)\nusing this:\n  (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n  \\<in> mult (mult trm_ord) \\<or>\n  mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)\n\ngoal (1 subgoal):\n 1. ((fst x, snd x), D, \\<sigma>) \\<in> ecl_ord", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n    \\<in> mult (mult trm_ord) \\<Longrightarrow>\n    ((fst x, snd x), D, \\<sigma>) \\<in> ecl_ord\n 2. mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>) \\<Longrightarrow>\n    ((fst x, snd x), D, \\<sigma>) \\<in> ecl_ord", "assume \"((mset_ecl ((fst x),(snd x))),(mset_cl (C',\\<sigma>))) \\<in> (mult (mult trm_ord))\""], ["proof (state)\nthis:\n  (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n  \\<in> mult (mult trm_ord)\n\ngoal (2 subgoals):\n 1. (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n    \\<in> mult (mult trm_ord) \\<Longrightarrow>\n    ((fst x, snd x), D, \\<sigma>) \\<in> ecl_ord\n 2. mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>) \\<Longrightarrow>\n    ((fst x, snd x), D, \\<sigma>) \\<in> ecl_ord", "from this and \\<open>(( (mset_cl (C',\\<sigma>)), (mset_ecl (D,\\<sigma>))) \\<in> (mult (mult trm_ord)))\\<close>"], ["proof (chain)\npicking this:\n  (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n  \\<in> mult (mult trm_ord)\n  (mset_cl (C', \\<sigma>), mset_ecl (D, \\<sigma>)) \\<in> mult (mult trm_ord)", "have \"((mset_ecl ((fst x),(snd x))),(mset_ecl (D,\\<sigma>))) \\<in> (mult (mult trm_ord))\""], ["proof (prove)\nusing this:\n  (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n  \\<in> mult (mult trm_ord)\n  (mset_cl (C', \\<sigma>), mset_ecl (D, \\<sigma>)) \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. (mset_ecl (fst x, snd x), mset_ecl (D, \\<sigma>))\n    \\<in> mult (mult trm_ord)", "using mult_mult_trm_ord_trans"], ["proof (prove)\nusing this:\n  (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n  \\<in> mult (mult trm_ord)\n  (mset_cl (C', \\<sigma>), mset_ecl (D, \\<sigma>)) \\<in> mult (mult trm_ord)\n  trans (mult (mult trm_ord))\n\ngoal (1 subgoal):\n 1. (mset_ecl (fst x, snd x), mset_ecl (D, \\<sigma>))\n    \\<in> mult (mult trm_ord)", "unfolding trans_def"], ["proof (prove)\nusing this:\n  (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n  \\<in> mult (mult trm_ord)\n  (mset_cl (C', \\<sigma>), mset_ecl (D, \\<sigma>)) \\<in> mult (mult trm_ord)\n  \\<forall>x y z.\n     (x, y) \\<in> mult (mult trm_ord) \\<longrightarrow>\n     (y, z) \\<in> mult (mult trm_ord) \\<longrightarrow>\n     (x, z) \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. (mset_ecl (fst x, snd x), mset_ecl (D, \\<sigma>))\n    \\<in> mult (mult trm_ord)", "by metis"], ["proof (state)\nthis:\n  (mset_ecl (fst x, snd x), mset_ecl (D, \\<sigma>))\n  \\<in> mult (mult trm_ord)\n\ngoal (2 subgoals):\n 1. (mset_ecl (fst x, snd x), mset_cl (C', \\<sigma>))\n    \\<in> mult (mult trm_ord) \\<Longrightarrow>\n    ((fst x, snd x), D, \\<sigma>) \\<in> ecl_ord\n 2. mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>) \\<Longrightarrow>\n    ((fst x, snd x), D, \\<sigma>) \\<in> ecl_ord", "from this"], ["proof (chain)\npicking this:\n  (mset_ecl (fst x, snd x), mset_ecl (D, \\<sigma>))\n  \\<in> mult (mult trm_ord)", "show ?thesis"], ["proof (prove)\nusing this:\n  (mset_ecl (fst x, snd x), mset_ecl (D, \\<sigma>))\n  \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. ((fst x, snd x), D, \\<sigma>) \\<in> ecl_ord", "unfolding ecl_ord_def"], ["proof (prove)\nusing this:\n  (mset_ecl (fst x, snd x), mset_ecl (D, \\<sigma>))\n  \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. ((fst x, snd x), D, \\<sigma>)\n    \\<in> {(x, y). (mset_ecl x, mset_ecl y) \\<in> mult (mult trm_ord)}", "by auto"], ["proof (state)\nthis:\n  ((fst x, snd x), D, \\<sigma>) \\<in> ecl_ord\n\ngoal (1 subgoal):\n 1. mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>) \\<Longrightarrow>\n    ((fst x, snd x), D, \\<sigma>) \\<in> ecl_ord", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>) \\<Longrightarrow>\n    ((fst x, snd x), D, \\<sigma>) \\<in> ecl_ord", "assume \"(mset_ecl ((fst x),(snd x))) = mset_cl (C',\\<sigma>)\""], ["proof (state)\nthis:\n  mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)\n\ngoal (1 subgoal):\n 1. mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>) \\<Longrightarrow>\n    ((fst x, snd x), D, \\<sigma>) \\<in> ecl_ord", "from this and \\<open>(( (mset_cl (C',\\<sigma>)), (mset_ecl (D,\\<sigma>))) \\<in> (mult (mult trm_ord)))\\<close>"], ["proof (chain)\npicking this:\n  mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)\n  (mset_cl (C', \\<sigma>), mset_ecl (D, \\<sigma>)) \\<in> mult (mult trm_ord)", "have \"((mset_ecl ((fst x),(snd x))),(mset_ecl (D,\\<sigma>))) \\<in> (mult (mult trm_ord))\""], ["proof (prove)\nusing this:\n  mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>)\n  (mset_cl (C', \\<sigma>), mset_ecl (D, \\<sigma>)) \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. (mset_ecl (fst x, snd x), mset_ecl (D, \\<sigma>))\n    \\<in> mult (mult trm_ord)", "by auto"], ["proof (state)\nthis:\n  (mset_ecl (fst x, snd x), mset_ecl (D, \\<sigma>))\n  \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. mset_ecl (fst x, snd x) = mset_cl (C', \\<sigma>) \\<Longrightarrow>\n    ((fst x, snd x), D, \\<sigma>) \\<in> ecl_ord", "from this"], ["proof (chain)\npicking this:\n  (mset_ecl (fst x, snd x), mset_ecl (D, \\<sigma>))\n  \\<in> mult (mult trm_ord)", "show ?thesis"], ["proof (prove)\nusing this:\n  (mset_ecl (fst x, snd x), mset_ecl (D, \\<sigma>))\n  \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. ((fst x, snd x), D, \\<sigma>) \\<in> ecl_ord", "unfolding ecl_ord_def"], ["proof (prove)\nusing this:\n  (mset_ecl (fst x, snd x), mset_ecl (D, \\<sigma>))\n  \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. ((fst x, snd x), D, \\<sigma>)\n    \\<in> {(x, y). (mset_ecl x, mset_ecl y) \\<in> mult (mult trm_ord)}", "by auto"], ["proof (state)\nthis:\n  ((fst x, snd x), D, \\<sigma>) \\<in> ecl_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((fst x, snd x), D, \\<sigma>) \\<in> ecl_ord\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> S' \\<Longrightarrow>\n       \\<exists>D'\\<in>P. ((fst x, snd x), D', \\<sigma>) \\<in> ecl_ord", "from this and \\<open>D \\<in> P\\<close>"], ["proof (chain)\npicking this:\n  ((fst x, snd x), D, \\<sigma>) \\<in> ecl_ord\n  D \\<in> P", "show \"\\<exists>D' \\<in> P. (((fst x),(snd x)),(D',\\<sigma>)) \\<in> ecl_ord\""], ["proof (prove)\nusing this:\n  ((fst x, snd x), D, \\<sigma>) \\<in> ecl_ord\n  D \\<in> P\n\ngoal (1 subgoal):\n 1. \\<exists>D'\\<in>P. ((fst x, snd x), D', \\<sigma>) \\<in> ecl_ord", "by auto"], ["proof (state)\nthis:\n  \\<exists>D'\\<in>P. ((fst x, snd x), D', \\<sigma>) \\<in> ecl_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S'.\n     \\<exists>D'\\<in>P. ((fst x, snd x), D', \\<sigma>) \\<in> ecl_ord\n\ngoal (1 subgoal):\n 1. redundant_inference E S P \\<sigma>", "from this and \\<open>S' \\<subseteq> (instances S)\\<close> and \\<open>(set_entails_clause (clset_instances S') (cl_ecl E))\\<close>\n    and \\<open>(\\<forall>x \\<in> S'. ( subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) \n              (trms_ecl E)))\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S'.\n     \\<exists>D'\\<in>P. ((fst x, snd x), D', \\<sigma>) \\<in> ecl_ord\n  S' \\<subseteq> instances S\n  set_entails_clause (clset_instances S') (cl_ecl E)\n  \\<forall>x\\<in>S'.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) (trms_ecl E)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S'.\n     \\<exists>D'\\<in>P. ((fst x, snd x), D', \\<sigma>) \\<in> ecl_ord\n  S' \\<subseteq> instances S\n  set_entails_clause (clset_instances S') (cl_ecl E)\n  \\<forall>x\\<in>S'.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) (trms_ecl E)\n\ngoal (1 subgoal):\n 1. redundant_inference E S P \\<sigma>", "unfolding redundant_inference_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S'.\n     \\<exists>D'\\<in>P. ((fst x, snd x), D', \\<sigma>) \\<in> ecl_ord\n  S' \\<subseteq> instances S\n  set_entails_clause (clset_instances S') (cl_ecl E)\n  \\<forall>x\\<in>S'.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) (trms_ecl E)\n\ngoal (1 subgoal):\n 1. \\<exists>S'\\<subseteq>instances S.\n       set_entails_clause (clset_instances S') (cl_ecl E) \\<and>\n       (\\<forall>x\\<in>S'.\n           subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n            (trms_ecl E)) \\<and>\n       (\\<forall>x\\<in>S'.\n           \\<exists>D'\\<in>P. ((fst x, snd x), D', \\<sigma>) \\<in> ecl_ord)", "by auto"], ["proof (state)\nthis:\n  redundant_inference E S P \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma clause_saturated_and_inference_saturated:\n  assumes \"clause_saturated S\"\n  assumes \"\\<forall>x \\<in> S. (finite (cl_ecl x))\" \n  shows \"inference_saturated S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inference_saturated S", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> inference_saturated S \\<Longrightarrow> False", "assume \"\\<not> inference_saturated S\""], ["proof (state)\nthis:\n  \\<not> inference_saturated S\n\ngoal (1 subgoal):\n 1. \\<not> inference_saturated S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> inference_saturated S", "obtain C P \\<sigma> C' D  \\<theta> \\<eta>\n    where \"derivable C P S \\<sigma> Ground C'\" \"ground_clause (cl_ecl C)\"\n          \"derivable D P S \\<theta> FirstOrder C'\" \"trms_subsumes D C \\<eta>\"\n          \"\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\" \"grounding_set P \\<sigma>\"\n          \"\\<not>redundant_inference (subst_ecl D \\<eta>) S P \\<sigma>\""], ["proof (prove)\nusing this:\n  \\<not> inference_saturated S\n\ngoal (1 subgoal):\n 1. (\\<And>C P \\<sigma> C' D \\<theta> \\<eta>.\n        \\<lbrakk>derivable C P S \\<sigma> Ground C';\n         ground_clause (cl_ecl C); derivable D P S \\<theta> FirstOrder C';\n         trms_subsumes D C \\<eta>;\n         \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>;\n         grounding_set P \\<sigma>;\n         \\<not> redundant_inference (subst_ecl D \\<eta>) S P\n                 \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding inference_saturated_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>C P \\<sigma> C' D \\<theta> \\<eta>.\n             derivable C P S \\<sigma> Ground C' \\<longrightarrow>\n             ground_clause (cl_ecl C) \\<longrightarrow>\n             grounding_set P \\<sigma> \\<longrightarrow>\n             derivable D P S \\<theta> FirstOrder C' \\<longrightarrow>\n             trms_subsumes D C \\<eta> \\<longrightarrow>\n             \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<longrightarrow>\n             redundant_inference (subst_ecl D \\<eta>) S P \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>C P \\<sigma> C' D \\<theta> \\<eta>.\n        \\<lbrakk>derivable C P S \\<sigma> Ground C';\n         ground_clause (cl_ecl C); derivable D P S \\<theta> FirstOrder C';\n         trms_subsumes D C \\<eta>;\n         \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>;\n         grounding_set P \\<sigma>;\n         \\<not> redundant_inference (subst_ecl D \\<eta>) S P\n                 \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  derivable C P S \\<sigma> Ground C'\n  ground_clause (cl_ecl C)\n  derivable D P S \\<theta> FirstOrder C'\n  trms_subsumes D C \\<eta>\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  grounding_set P \\<sigma>\n  \\<not> redundant_inference (subst_ecl D \\<eta>) S P \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> inference_saturated S \\<Longrightarrow> False", "from assms(2) \\<open>grounding_set P \\<sigma>\\<close> \\<open>derivable C P S \\<sigma> Ground C'\\<close> \n    \\<open>\\<not>redundant_inference (subst_ecl D \\<eta>) S P \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  grounding_set P \\<sigma>\n  derivable C P S \\<sigma> Ground C'\n  \\<not> redundant_inference (subst_ecl D \\<eta>) S P \\<sigma>", "have \"\\<not>redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C'\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  grounding_set P \\<sigma>\n  derivable C P S \\<sigma> Ground C'\n  \\<not> redundant_inference (subst_ecl D \\<eta>) S P \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C'", "using redundant_inference_clause"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  grounding_set P \\<sigma>\n  derivable C P S \\<sigma> Ground C'\n  \\<not> redundant_inference (subst_ecl D \\<eta>) S P \\<sigma>\n  \\<lbrakk>redundant_clause ?E ?S ?\\<sigma> ?C';\n   derivable ?C ?P ?S ?\\<sigma> Ground ?C'; grounding_set ?P ?\\<sigma>;\n   \\<forall>x\\<in>?S. finite (cl_ecl x)\\<rbrakk>\n  \\<Longrightarrow> redundant_inference ?E ?S ?P ?\\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C'", "by blast"], ["proof (state)\nthis:\n  \\<not> redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C'\n\ngoal (1 subgoal):\n 1. \\<not> inference_saturated S \\<Longrightarrow> False", "from assms(1)"], ["proof (chain)\npicking this:\n  clause_saturated S", "have \"\\<And>C P \\<sigma> C' D  \\<theta> \\<eta>. \n     (derivable C P S \\<sigma> Ground C') \\<longrightarrow> (ground_clause (cl_ecl C)) \n      \\<longrightarrow> (derivable D P S \\<theta> FirstOrder C') \\<longrightarrow> (trms_subsumes D C \\<eta>)\n      \\<longrightarrow> (\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>)\n      \\<longrightarrow> (redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C')\""], ["proof (prove)\nusing this:\n  clause_saturated S\n\ngoal (1 subgoal):\n 1. \\<And>C P \\<sigma> C' D \\<theta> \\<eta>.\n       derivable C P S \\<sigma> Ground C' \\<longrightarrow>\n       ground_clause (cl_ecl C) \\<longrightarrow>\n       derivable D P S \\<theta> FirstOrder C' \\<longrightarrow>\n       trms_subsumes D C \\<eta> \\<longrightarrow>\n       \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<longrightarrow>\n       redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C'", "unfolding clause_saturated_def"], ["proof (prove)\nusing this:\n  \\<forall>C P \\<sigma> C' D \\<theta> \\<eta>.\n     derivable C P S \\<sigma> Ground C' \\<longrightarrow>\n     ground_clause (cl_ecl C) \\<longrightarrow>\n     derivable D P S \\<theta> FirstOrder C' \\<longrightarrow>\n     trms_subsumes D C \\<eta> \\<longrightarrow>\n     \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<longrightarrow>\n     redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C'\n\ngoal (1 subgoal):\n 1. \\<And>C P \\<sigma> C' D \\<theta> \\<eta>.\n       derivable C P S \\<sigma> Ground C' \\<longrightarrow>\n       ground_clause (cl_ecl C) \\<longrightarrow>\n       derivable D P S \\<theta> FirstOrder C' \\<longrightarrow>\n       trms_subsumes D C \\<eta> \\<longrightarrow>\n       \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<longrightarrow>\n       redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C'", "by blast"], ["proof (state)\nthis:\n  derivable ?C ?P S ?\\<sigma> Ground ?C' \\<longrightarrow>\n  ground_clause (cl_ecl ?C) \\<longrightarrow>\n  derivable ?D ?P S ?\\<theta> FirstOrder ?C' \\<longrightarrow>\n  trms_subsumes ?D ?C ?\\<eta> \\<longrightarrow>\n  ?\\<sigma> \\<doteq> ?\\<theta> \\<lozenge> ?\\<eta> \\<longrightarrow>\n  redundant_clause (subst_ecl ?D ?\\<eta>) S ?\\<sigma> ?C'\n\ngoal (1 subgoal):\n 1. \\<not> inference_saturated S \\<Longrightarrow> False", "from this  and \\<open>derivable C P S \\<sigma> Ground C'\\<close> \\<open>ground_clause (cl_ecl C)\\<close> \n    \\<open>derivable D P S \\<theta> FirstOrder C'\\<close> \n    \\<open>trms_subsumes D C \\<eta>\\<close> \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close> assms(1)"], ["proof (chain)\npicking this:\n  derivable ?C ?P S ?\\<sigma> Ground ?C' \\<longrightarrow>\n  ground_clause (cl_ecl ?C) \\<longrightarrow>\n  derivable ?D ?P S ?\\<theta> FirstOrder ?C' \\<longrightarrow>\n  trms_subsumes ?D ?C ?\\<eta> \\<longrightarrow>\n  ?\\<sigma> \\<doteq> ?\\<theta> \\<lozenge> ?\\<eta> \\<longrightarrow>\n  redundant_clause (subst_ecl ?D ?\\<eta>) S ?\\<sigma> ?C'\n  derivable C P S \\<sigma> Ground C'\n  ground_clause (cl_ecl C)\n  derivable D P S \\<theta> FirstOrder C'\n  trms_subsumes D C \\<eta>\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  clause_saturated S", "have \"redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C'\""], ["proof (prove)\nusing this:\n  derivable ?C ?P S ?\\<sigma> Ground ?C' \\<longrightarrow>\n  ground_clause (cl_ecl ?C) \\<longrightarrow>\n  derivable ?D ?P S ?\\<theta> FirstOrder ?C' \\<longrightarrow>\n  trms_subsumes ?D ?C ?\\<eta> \\<longrightarrow>\n  ?\\<sigma> \\<doteq> ?\\<theta> \\<lozenge> ?\\<eta> \\<longrightarrow>\n  redundant_clause (subst_ecl ?D ?\\<eta>) S ?\\<sigma> ?C'\n  derivable C P S \\<sigma> Ground C'\n  ground_clause (cl_ecl C)\n  derivable D P S \\<theta> FirstOrder C'\n  trms_subsumes D C \\<eta>\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  clause_saturated S\n\ngoal (1 subgoal):\n 1. redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C'", "by auto"], ["proof (state)\nthis:\n  redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C'\n\ngoal (1 subgoal):\n 1. \\<not> inference_saturated S \\<Longrightarrow> False", "from this and \\<open>\\<not>redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C'\\<close>"], ["proof (chain)\npicking this:\n  redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C'\n  \\<not> redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C'", "show False"], ["proof (prove)\nusing this:\n  redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C'\n  \\<not> redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Refutational Completeness\\<close>"], ["", "text \\<open>We prove that our variant of the superposition calculus is complete under the \nredundancy criteria defined above. This is done as usual, by constructing a model of every\nsaturated set not containing the empty clause.\\<close>"], ["", "subsection \\<open>Model Construction\\<close>"], ["", "text \\<open>We associate as usual every set of extended clauses with an interpretation. \nThe interpretation is constructed in such a way that it is a model of the set of clauses \nif the latter is saturated and does not contain the empty clause.\nThe interpretation is constructed by defining directly a normalization function mapping every term \nto its normal form, i.e., to the minimal equivalent term. Note that we do not consider sets of \nrewrite rules explicitly.\\<close>"], ["", "text \\<open>The next function associates every normalization function with the corresponding \ninterpretation (two terms are in relation if they share the same normal form). \nThe obtained relation is an interpretation if the normalization function \nis compatible with the term combination operator.\\<close>"], ["", "definition same_values :: \"('a trm \\<Rightarrow> 'a trm) \\<Rightarrow> 'a trm \\<Rightarrow> 'a trm \\<Rightarrow> bool\"\n  where \"(same_values f) = \n           (\\<lambda>x y. (f x) = (f y))\""], ["", "definition value_is_compatible_with_structure :: \"('a trm \\<Rightarrow> 'a trm) \\<Rightarrow> bool\"\n  where \"(value_is_compatible_with_structure f) = (\\<forall> t s. (f (Comb t s)) = (f (Comb (f t) (f s))))\""], ["", "lemma same_values_fo_int:\n  assumes \"value_is_compatible_with_structure f\"\n  shows \"fo_interpretation (same_values f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fo_interpretation (same_values f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fo_interpretation (same_values f)", "let ?I = \"(same_values f)\""], ["proof (state)\ngoal (1 subgoal):\n 1. fo_interpretation (same_values f)", "have ref: \"reflexive ?I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflexive (same_values f)", "unfolding same_values_def reflexive_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. f y = f y", "by simp"], ["proof (state)\nthis:\n  reflexive (same_values f)\n\ngoal (1 subgoal):\n 1. fo_interpretation (same_values f)", "have sym: \"symmetric ?I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric (same_values f)", "unfolding same_values_def symmetric_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y z. (f y = f z) = (f z = f y)", "by auto"], ["proof (state)\nthis:\n  symmetric (same_values f)\n\ngoal (1 subgoal):\n 1. fo_interpretation (same_values f)", "have trans: \"transitive ?I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transitive (same_values f)", "unfolding same_values_def transitive_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y z u.\n       f y = f z \\<longrightarrow> f z = f u \\<longrightarrow> f y = f u", "by auto"], ["proof (state)\nthis:\n  transitive (same_values f)\n\ngoal (1 subgoal):\n 1. fo_interpretation (same_values f)", "from assms(1)"], ["proof (chain)\npicking this:\n  value_is_compatible_with_structure f", "have comp: \"compatible_with_structure ?I\""], ["proof (prove)\nusing this:\n  value_is_compatible_with_structure f\n\ngoal (1 subgoal):\n 1. compatible_with_structure (same_values f)", "unfolding same_values_def \n      compatible_with_structure_def value_is_compatible_with_structure_def [of f]"], ["proof (prove)\nusing this:\n  \\<forall>t s. f (t \\<cdot> s) = f (f t \\<cdot> f s)\n\ngoal (1 subgoal):\n 1. \\<forall>t1 t2 s1 s2.\n       f t1 = f s1 \\<longrightarrow>\n       f t2 = f s2 \\<longrightarrow> f (t1 \\<cdot> t2) = f (s1 \\<cdot> s2)", "by metis"], ["proof (state)\nthis:\n  compatible_with_structure (same_values f)\n\ngoal (1 subgoal):\n 1. fo_interpretation (same_values f)", "from ref trans sym comp"], ["proof (chain)\npicking this:\n  reflexive (same_values f)\n  transitive (same_values f)\n  symmetric (same_values f)\n  compatible_with_structure (same_values f)", "have \"congruence ?I\""], ["proof (prove)\nusing this:\n  reflexive (same_values f)\n  transitive (same_values f)\n  symmetric (same_values f)\n  compatible_with_structure (same_values f)\n\ngoal (1 subgoal):\n 1. congruence (same_values f)", "unfolding congruence_def equivalence_relation_def"], ["proof (prove)\nusing this:\n  reflexive (same_values f)\n  transitive (same_values f)\n  symmetric (same_values f)\n  compatible_with_structure (same_values f)\n\ngoal (1 subgoal):\n 1. (reflexive (same_values f) \\<and>\n     symmetric (same_values f) \\<and> transitive (same_values f)) \\<and>\n    compatible_with_structure (same_values f)", "by auto"], ["proof (state)\nthis:\n  congruence (same_values f)\n\ngoal (1 subgoal):\n 1. fo_interpretation (same_values f)", "then"], ["proof (chain)\npicking this:\n  congruence (same_values f)", "show ?thesis"], ["proof (prove)\nusing this:\n  congruence (same_values f)\n\ngoal (1 subgoal):\n 1. fo_interpretation (same_values f)", "unfolding fo_interpretation_def"], ["proof (prove)\nusing this:\n  congruence (same_values f)\n\ngoal (1 subgoal):\n 1. congruence (same_values f)", "by auto"], ["proof (state)\nthis:\n  fo_interpretation (same_values f)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The normalization function is defined by mapping each term to a set of pairs. Intuitively,\nthe second element of each pair represents the right hand side of a rule that can be used to rewrite \nthe considered term, and the first element of the pair denotes its normal form. \nThe value of the term is the first component of the pair with the smallest second component.\\<close>"], ["", "text \\<open>The following function returns the set of values for which the second component is minimal. \nWe then prove that this set is non-empty and define a function returning an arbitrary chosen \nelement.\\<close>"], ["", "definition min_trms :: \"('a trm \\<times> 'a trm) set \\<Rightarrow> 'a trm set\" \n  where \"(min_trms E) = ({ x. (\\<exists> pair. (pair \\<in> E \n  \\<and> (\\<forall>pair' \\<in> E. (snd pair',snd pair) \\<notin> trm_ord)) \\<and> x = fst pair) })\""], ["", "lemma min_trms_not_empty:\n  assumes \"E \\<noteq> {}\"\n  shows \"min_trms E \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_trms E \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. min_trms E \\<noteq> {}", "from assms(1)"], ["proof (chain)\npicking this:\n  E \\<noteq> {}", "obtain x where \"x \\<in> E\""], ["proof (prove)\nusing this:\n  E \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> E \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> E\n\ngoal (1 subgoal):\n 1. min_trms E \\<noteq> {}", "let ?pair_ordering = \"{ (x,y). ((snd x),(snd y)) \\<in> trm_ord }\""], ["proof (state)\ngoal (1 subgoal):\n 1. min_trms E \\<noteq> {}", "from trm_ord_wf"], ["proof (chain)\npicking this:\n  wf trm_ord", "have \"wf ?pair_ordering\""], ["proof (prove)\nusing this:\n  wf trm_ord\n\ngoal (1 subgoal):\n 1. wf {(x, y). (snd x, snd y) \\<in> trm_ord}", "using  measure_wf"], ["proof (prove)\nusing this:\n  wf trm_ord\n  \\<lbrakk>wf ?r; ?r' = {(x, y). (?m x, ?m y) \\<in> ?r}\\<rbrakk>\n  \\<Longrightarrow> wf ?r'\n\ngoal (1 subgoal):\n 1. wf {(x, y). (snd x, snd y) \\<in> trm_ord}", "by auto"], ["proof (state)\nthis:\n  wf {(x, y). (snd x, snd y) \\<in> trm_ord}\n\ngoal (1 subgoal):\n 1. min_trms E \\<noteq> {}", "from this \\<open>x \\<in> E\\<close>"], ["proof (chain)\npicking this:\n  wf {(x, y). (snd x, snd y) \\<in> trm_ord}\n  x \\<in> E", "obtain y where \"y \\<in> E\" and \"\\<forall>z. (z,y) \\<in> ?pair_ordering \\<longrightarrow> (z \\<notin> E)\""], ["proof (prove)\nusing this:\n  wf {(x, y). (snd x, snd y) \\<in> trm_ord}\n  x \\<in> E\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> E;\n         \\<forall>z.\n            (z, y)\n            \\<in> {(x, y). (snd x, snd y) \\<in> trm_ord} \\<longrightarrow>\n            z \\<notin> E\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using wfE_min [of ?pair_ordering ]"], ["proof (prove)\nusing this:\n  wf {(x, y). (snd x, snd y) \\<in> trm_ord}\n  x \\<in> E\n  \\<lbrakk>wf {(x, y). (snd x, snd y) \\<in> trm_ord}; ?x \\<in> ?Q;\n   \\<And>z.\n      \\<lbrakk>z \\<in> ?Q;\n       \\<And>y.\n          (y, z)\n          \\<in> {(x, y). (snd x, snd y) \\<in> trm_ord} \\<Longrightarrow>\n          y \\<notin> ?Q\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> E;\n         \\<forall>z.\n            (z, y)\n            \\<in> {(x, y). (snd x, snd y) \\<in> trm_ord} \\<longrightarrow>\n            z \\<notin> E\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  y \\<in> E\n  \\<forall>z.\n     (z, y) \\<in> {(x, y). (snd x, snd y) \\<in> trm_ord} \\<longrightarrow>\n     z \\<notin> E\n\ngoal (1 subgoal):\n 1. min_trms E \\<noteq> {}", "from this"], ["proof (chain)\npicking this:\n  y \\<in> E\n  \\<forall>z.\n     (z, y) \\<in> {(x, y). (snd x, snd y) \\<in> trm_ord} \\<longrightarrow>\n     z \\<notin> E", "have \"fst y \\<in> min_trms E\""], ["proof (prove)\nusing this:\n  y \\<in> E\n  \\<forall>z.\n     (z, y) \\<in> {(x, y). (snd x, snd y) \\<in> trm_ord} \\<longrightarrow>\n     z \\<notin> E\n\ngoal (1 subgoal):\n 1. fst y \\<in> min_trms E", "unfolding min_trms_def"], ["proof (prove)\nusing this:\n  y \\<in> E\n  \\<forall>z.\n     (z, y) \\<in> {(x, y). (snd x, snd y) \\<in> trm_ord} \\<longrightarrow>\n     z \\<notin> E\n\ngoal (1 subgoal):\n 1. fst y\n    \\<in> {x. \\<exists>pair.\n                 (pair \\<in> E \\<and>\n                  (\\<forall>pair'\\<in>E.\n                      (snd pair', snd pair) \\<notin> trm_ord)) \\<and>\n                 x = fst pair}", "by blast"], ["proof (state)\nthis:\n  fst y \\<in> min_trms E\n\ngoal (1 subgoal):\n 1. min_trms E \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  fst y \\<in> min_trms E", "show ?thesis"], ["proof (prove)\nusing this:\n  fst y \\<in> min_trms E\n\ngoal (1 subgoal):\n 1. min_trms E \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  min_trms E \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition get_min :: \"'a trm \\<Rightarrow> ('a trm \\<times> 'a trm) set \\<Rightarrow> 'a trm\" \n  where \"(get_min t E) = \n      (if ((min_trms E) = {}) then t else (SOME x. (x \\<in> min_trms E)))\""], ["", "text \\<open>We now define the normalization function. The definition is tuned to \nmake the termination proof straightforward. We will reformulate it afterward to get a simpler \ndefinition. \n\nWe first test whether a subterm of the considered term is reducible. If this is the case then \nthe value can be obtained by applying recursively the function on each subterm, and then again on \nthe term obtained by combining the obtained normal forms.\nIf not, then we collect all possible pairs (as explained above), and we use the one with the minimal \nsecond component. These pairs can be interpreted as rewrite rules, giving the value of the \nconsidered term: the second component is the right-hand side of the rule and the first component is \nthe normal form of the right-hand side. \nAs usual, such rewrite rules are obtained from ground clauses that have a strictly positive \nmaximal literal, no selected literals, and that are not validated by the constructed interpretation.\n\\<close>"], ["", "function trm_rep:: \"'a trm \\<Rightarrow> ('a eclause set \\<Rightarrow> 'a trm)\"\n  where\n    \"(trm_rep t) = \n      (\\<lambda>S. (if ((is_compound t) \\<and> ((lhs t),t) \\<in> trm_ord  \\<and> ((rhs t),t) \\<in> trm_ord\n      \\<and> ( ((lhs t,t) \\<in> trm_ord \\<longrightarrow> (trm_rep (lhs t) S) \\<noteq> (lhs t)) \n      \\<or> ((rhs t,t) \\<in> trm_ord \\<longrightarrow>(trm_rep (rhs t) S) \\<noteq> (rhs t))))\n        then (if ((Comb (trm_rep (lhs t) S) (trm_rep (rhs t) S)),t) \\<in> trm_ord \n                   then \n              (trm_rep (Comb (trm_rep (lhs t) S) (trm_rep (rhs t) S)) S)\n              else t)\n      else (get_min t \n         { pair. \\<exists>z CC C' C s L L' \\<sigma> t' s'. \n           pair = (z,s)\n          \\<and> CC \\<in> S \\<and> (t \\<notin> (subst_set (trms_ecl CC) \\<sigma>)) \n          \\<and> (\\<forall>x. (\\<exists>x' \\<in> (trms_ecl CC). occurs_in x (subst x' \\<sigma>)) \n            \\<longrightarrow> ( (x,t) \\<in> trm_ord \\<longrightarrow> (trm_rep x S) = x))         \n          \\<and> (C' = (cl_ecl CC)) \\<and> (s,t) \\<in> trm_ord \\<and> ((s,t) \\<in> trm_ord \\<longrightarrow> (z = trm_rep s S))\n          \\<and> (orient_lit_inst L' t' s' pos \\<sigma>) \\<and>  (sel C') = {} \\<and>  (L' \\<in> C')\n          \\<and> (maximal_literal L C) \\<and> (L = (subst_lit L' \\<sigma>)) \\<and>  (C = (subst_cl C' \\<sigma>))\n          \\<and> (ground_clause C) \\<and> (t = (subst t' \\<sigma>)) \\<and> (s = (subst s' \\<sigma>)) \\<and> (finite C') \n          \\<and>\n          (\\<forall> L u v. \n              (L \\<in> C \\<longrightarrow> orient_lit L u v pos \n                \\<longrightarrow> (u,t) \\<in> trm_ord \\<longrightarrow>  (v,t) \\<in> trm_ord\n                \\<longrightarrow> (trm_rep u S) \\<noteq>  (trm_rep v S)) \n          \\<and>\n            (L \\<in> C \\<longrightarrow> orient_lit L u v neg \\<longrightarrow> (u,t) \\<in> trm_ord \\<longrightarrow>  (v,t) \\<in> trm_ord\n                \\<longrightarrow> (trm_rep u S) = (trm_rep v S)))\n          \\<and> (\\<forall>s''. ( \n              (eq_occurs_in_cl t s'' (C'- { L' }) \\<sigma>) \\<longrightarrow> (s'',t) \\<in> trm_ord \\<longrightarrow>  (s,t) \\<in> trm_ord\n                \\<longrightarrow> (trm_rep s S) \\<noteq> (trm_rep s'' S))) })))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>t. x = t \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>t ta.\n       t = ta \\<Longrightarrow>\n       (\\<lambda>S.\n           if is_compound t \\<and>\n              (lhs t, t) \\<in> trm_ord \\<and>\n              (rhs t, t) \\<in> trm_ord \\<and>\n              (((lhs t, t) \\<in> trm_ord \\<longrightarrow>\n                trm_rep_sumC (lhs t) S \\<noteq> lhs t) \\<or>\n               ((rhs t, t) \\<in> trm_ord \\<longrightarrow>\n                trm_rep_sumC (rhs t) S \\<noteq> rhs t))\n           then if (trm_rep_sumC (lhs t) S \\<cdot> trm_rep_sumC (rhs t) S,\n                    t)\n                   \\<in> trm_ord\n                then trm_rep_sumC\n                      (trm_rep_sumC (lhs t) S \\<cdot>\n                       trm_rep_sumC (rhs t) S)\n                      S\n                else t\n           else get_min t\n                 {pair.\n                  \\<exists>z CC C' C s L L' \\<sigma> t' s'.\n                     pair = (z, s) \\<and>\n                     CC \\<in> S \\<and>\n                     t \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n                     (\\<forall>x.\n                         (\\<exists>x'\\<in>trms_ecl CC.\n                             occurs_in x\n                              (x' \\<lhd> \\<sigma>)) \\<longrightarrow>\n                         (x, t) \\<in> trm_ord \\<longrightarrow>\n                         trm_rep_sumC x S = x) \\<and>\n                     C' = cl_ecl CC \\<and>\n                     (s, t) \\<in> trm_ord \\<and>\n                     ((s, t) \\<in> trm_ord \\<longrightarrow>\n                      z = trm_rep_sumC s S) \\<and>\n                     orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n                     sel C' = {} \\<and>\n                     L' \\<in> C' \\<and>\n                     maximal_literal L C \\<and>\n                     L = subst_lit L' \\<sigma> \\<and>\n                     C = subst_cl C' \\<sigma> \\<and>\n                     ground_clause C \\<and>\n                     t = t' \\<lhd> \\<sigma> \\<and>\n                     s = s' \\<lhd> \\<sigma> \\<and>\n                     finite C' \\<and>\n                     (\\<forall>L u v.\n                         (L \\<in> C \\<longrightarrow>\n                          orient_lit L u v pos \\<longrightarrow>\n                          (u, t) \\<in> trm_ord \\<longrightarrow>\n                          (v, t) \\<in> trm_ord \\<longrightarrow>\n                          trm_rep_sumC u S \\<noteq> trm_rep_sumC v S) \\<and>\n                         (L \\<in> C \\<longrightarrow>\n                          orient_lit L u v neg \\<longrightarrow>\n                          (u, t) \\<in> trm_ord \\<longrightarrow>\n                          (v, t) \\<in> trm_ord \\<longrightarrow>\n                          trm_rep_sumC u S = trm_rep_sumC v S)) \\<and>\n                     (\\<forall>s''.\n                         eq_occurs_in_cl t s'' (C' - {L'})\n                          \\<sigma> \\<longrightarrow>\n                         (s'', t) \\<in> trm_ord \\<longrightarrow>\n                         (s, t) \\<in> trm_ord \\<longrightarrow>\n                         trm_rep_sumC s S \\<noteq> trm_rep_sumC s'' S)}) =\n       (\\<lambda>S.\n           if is_compound ta \\<and>\n              (lhs ta, ta) \\<in> trm_ord \\<and>\n              (rhs ta, ta) \\<in> trm_ord \\<and>\n              (((lhs ta, ta) \\<in> trm_ord \\<longrightarrow>\n                trm_rep_sumC (lhs ta) S \\<noteq> lhs ta) \\<or>\n               ((rhs ta, ta) \\<in> trm_ord \\<longrightarrow>\n                trm_rep_sumC (rhs ta) S \\<noteq> rhs ta))\n           then if (trm_rep_sumC (lhs ta) S \\<cdot> trm_rep_sumC (rhs ta) S,\n                    ta)\n                   \\<in> trm_ord\n                then trm_rep_sumC\n                      (trm_rep_sumC (lhs ta) S \\<cdot>\n                       trm_rep_sumC (rhs ta) S)\n                      S\n                else ta\n           else get_min ta\n                 {pair.\n                  \\<exists>z CC C' C s L L' \\<sigma> t' s'.\n                     pair = (z, s) \\<and>\n                     CC \\<in> S \\<and>\n                     ta \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n                     (\\<forall>x.\n                         (\\<exists>x'\\<in>trms_ecl CC.\n                             occurs_in x\n                              (x' \\<lhd> \\<sigma>)) \\<longrightarrow>\n                         (x, ta) \\<in> trm_ord \\<longrightarrow>\n                         trm_rep_sumC x S = x) \\<and>\n                     C' = cl_ecl CC \\<and>\n                     (s, ta) \\<in> trm_ord \\<and>\n                     ((s, ta) \\<in> trm_ord \\<longrightarrow>\n                      z = trm_rep_sumC s S) \\<and>\n                     orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n                     sel C' = {} \\<and>\n                     L' \\<in> C' \\<and>\n                     maximal_literal L C \\<and>\n                     L = subst_lit L' \\<sigma> \\<and>\n                     C = subst_cl C' \\<sigma> \\<and>\n                     ground_clause C \\<and>\n                     ta = t' \\<lhd> \\<sigma> \\<and>\n                     s = s' \\<lhd> \\<sigma> \\<and>\n                     finite C' \\<and>\n                     (\\<forall>L u v.\n                         (L \\<in> C \\<longrightarrow>\n                          orient_lit L u v pos \\<longrightarrow>\n                          (u, ta) \\<in> trm_ord \\<longrightarrow>\n                          (v, ta) \\<in> trm_ord \\<longrightarrow>\n                          trm_rep_sumC u S \\<noteq> trm_rep_sumC v S) \\<and>\n                         (L \\<in> C \\<longrightarrow>\n                          orient_lit L u v neg \\<longrightarrow>\n                          (u, ta) \\<in> trm_ord \\<longrightarrow>\n                          (v, ta) \\<in> trm_ord \\<longrightarrow>\n                          trm_rep_sumC u S = trm_rep_sumC v S)) \\<and>\n                     (\\<forall>s''.\n                         eq_occurs_in_cl ta s'' (C' - {L'})\n                          \\<sigma> \\<longrightarrow>\n                         (s'', ta) \\<in> trm_ord \\<longrightarrow>\n                         (s, ta) \\<in> trm_ord \\<longrightarrow>\n                         trm_rep_sumC s S \\<noteq> trm_rep_sumC s'' S)})", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All trm_rep_dom", "apply (relation \"trm_ord\")"], ["proof (prove)\ngoal (16 subgoals):\n 1. wf trm_ord\n 2. \\<And>t x.\n       (lhs t, t) \\<in> trm_ord \\<Longrightarrow> (lhs t, t) \\<in> trm_ord\n 3. \\<And>t x.\n       (rhs t, t) \\<in> trm_ord \\<Longrightarrow> (rhs t, t) \\<in> trm_ord\n 4. \\<And>t x.\n       \\<lbrakk>is_compound t \\<and>\n                (lhs t, t) \\<in> trm_ord \\<and>\n                (rhs t, t) \\<in> trm_ord \\<and>\n                (((lhs t, t) \\<in> trm_ord \\<longrightarrow>\n                  trm_rep (lhs t) x \\<noteq> lhs t) \\<or>\n                 ((rhs t, t) \\<in> trm_ord \\<longrightarrow>\n                  trm_rep (rhs t) x \\<noteq> rhs t));\n        (rhs t, t) \\<in> trm_ord \\<Longrightarrow> trm_rep_dom (rhs t);\n        (lhs t, t) \\<in> trm_ord \\<Longrightarrow>\n        trm_rep_dom (lhs t)\\<rbrakk>\n       \\<Longrightarrow> (lhs t, t) \\<in> trm_ord\n 5. \\<And>t x.\n       \\<lbrakk>is_compound t \\<and>\n                (lhs t, t) \\<in> trm_ord \\<and>\n                (rhs t, t) \\<in> trm_ord \\<and>\n                (((lhs t, t) \\<in> trm_ord \\<longrightarrow>\n                  trm_rep (lhs t) x \\<noteq> lhs t) \\<or>\n                 ((rhs t, t) \\<in> trm_ord \\<longrightarrow>\n                  trm_rep (rhs t) x \\<noteq> rhs t));\n        (rhs t, t) \\<in> trm_ord \\<Longrightarrow> trm_rep_dom (rhs t);\n        (lhs t, t) \\<in> trm_ord \\<Longrightarrow>\n        trm_rep_dom (lhs t)\\<rbrakk>\n       \\<Longrightarrow> (rhs t, t) \\<in> trm_ord\n 6. \\<And>t x.\n       \\<lbrakk>is_compound t \\<and>\n                (lhs t, t) \\<in> trm_ord \\<and>\n                (rhs t, t) \\<in> trm_ord \\<and>\n                (((lhs t, t) \\<in> trm_ord \\<longrightarrow>\n                  trm_rep (lhs t) x \\<noteq> lhs t) \\<or>\n                 ((rhs t, t) \\<in> trm_ord \\<longrightarrow>\n                  trm_rep (rhs t) x \\<noteq> rhs t));\n        (trm_rep (lhs t) x \\<cdot> trm_rep (rhs t) x, t) \\<in> trm_ord;\n        trm_rep_dom (rhs t); trm_rep_dom (lhs t);\n        (rhs t, t) \\<in> trm_ord \\<Longrightarrow> trm_rep_dom (rhs t);\n        (lhs t, t) \\<in> trm_ord \\<Longrightarrow>\n        trm_rep_dom (lhs t)\\<rbrakk>\n       \\<Longrightarrow> (lhs t, t) \\<in> trm_ord\n 7. \\<And>t x.\n       \\<lbrakk>is_compound t \\<and>\n                (lhs t, t) \\<in> trm_ord \\<and>\n                (rhs t, t) \\<in> trm_ord \\<and>\n                (((lhs t, t) \\<in> trm_ord \\<longrightarrow>\n                  trm_rep (lhs t) x \\<noteq> lhs t) \\<or>\n                 ((rhs t, t) \\<in> trm_ord \\<longrightarrow>\n                  trm_rep (rhs t) x \\<noteq> rhs t));\n        (trm_rep (lhs t) x \\<cdot> trm_rep (rhs t) x, t) \\<in> trm_ord;\n        trm_rep_dom (rhs t); trm_rep_dom (lhs t);\n        (rhs t, t) \\<in> trm_ord \\<Longrightarrow> trm_rep_dom (rhs t);\n        (lhs t, t) \\<in> trm_ord \\<Longrightarrow>\n        trm_rep_dom (lhs t)\\<rbrakk>\n       \\<Longrightarrow> (rhs t, t) \\<in> trm_ord\n 8. \\<And>t x.\n       \\<lbrakk>is_compound t \\<and>\n                (lhs t, t) \\<in> trm_ord \\<and>\n                (rhs t, t) \\<in> trm_ord \\<and>\n                (((lhs t, t) \\<in> trm_ord \\<longrightarrow>\n                  trm_rep (lhs t) x \\<noteq> lhs t) \\<or>\n                 ((rhs t, t) \\<in> trm_ord \\<longrightarrow>\n                  trm_rep (rhs t) x \\<noteq> rhs t));\n        (trm_rep (lhs t) x \\<cdot> trm_rep (rhs t) x, t) \\<in> trm_ord;\n        trm_rep_dom (rhs t); trm_rep_dom (lhs t);\n        (rhs t, t) \\<in> trm_ord \\<Longrightarrow> trm_rep_dom (rhs t);\n        (lhs t, t) \\<in> trm_ord \\<Longrightarrow> trm_rep_dom (lhs t);\n        trm_rep_dom (rhs t); trm_rep_dom (lhs t)\\<rbrakk>\n       \\<Longrightarrow> (trm_rep (lhs t) x \\<cdot> trm_rep (rhs t) x, t)\n                         \\<in> trm_ord\n 9. \\<And>t x xa xb xc xd xe xf xg xh xi xj xk xaa.\n       \\<lbrakk>\\<not> (is_compound t \\<and>\n                        (lhs t, t) \\<in> trm_ord \\<and>\n                        (rhs t, t) \\<in> trm_ord \\<and>\n                        (((lhs t, t) \\<in> trm_ord \\<longrightarrow>\n                          trm_rep (lhs t) x \\<noteq> lhs t) \\<or>\n                         ((rhs t, t) \\<in> trm_ord \\<longrightarrow>\n                          trm_rep (rhs t) x \\<noteq> rhs t)));\n        \\<exists>x'\\<in>trms_ecl xc. occurs_in xaa (x' \\<lhd> xi);\n        (xaa, t) \\<in> trm_ord;\n        (rhs t, t) \\<in> trm_ord \\<Longrightarrow> trm_rep_dom (rhs t);\n        (lhs t, t) \\<in> trm_ord \\<Longrightarrow>\n        trm_rep_dom (lhs t)\\<rbrakk>\n       \\<Longrightarrow> (xaa, t) \\<in> trm_ord\n 10. \\<And>t x xa xb xc xd xe xf xg xh xi xj xk.\n        \\<lbrakk>\\<not> (is_compound t \\<and>\n                         (lhs t, t) \\<in> trm_ord \\<and>\n                         (rhs t, t) \\<in> trm_ord \\<and>\n                         (((lhs t, t) \\<in> trm_ord \\<longrightarrow>\n                           trm_rep (lhs t) x \\<noteq> lhs t) \\<or>\n                          ((rhs t, t) \\<in> trm_ord \\<longrightarrow>\n                           trm_rep (rhs t) x \\<noteq> rhs t)));\n         (xf, t) \\<in> trm_ord;\n         (rhs t, t) \\<in> trm_ord \\<Longrightarrow> trm_rep_dom (rhs t);\n         (lhs t, t) \\<in> trm_ord \\<Longrightarrow>\n         trm_rep_dom (lhs t)\\<rbrakk>\n        \\<Longrightarrow> (xf, t) \\<in> trm_ord\nA total of 16 subgoals...", "by auto (simp add: trm_ord_wf)"], ["", "text \\<open>We now introduce a few shorthands and rewrite the previous definition into an equivalent \nsimpler form. The key point is to prove that a term is always greater than its normal form.\\<close>"], ["", "definition subterm_reduction_aux:: \"'a eclause set \\<Rightarrow> 'a trm \\<Rightarrow> 'a trm\"\nwhere\n  \"subterm_reduction_aux S t = \n        (if ((Comb (trm_rep (lhs t) S) (trm_rep (rhs t) S)),t) \\<in> trm_ord \n         then (trm_rep (Comb (trm_rep (lhs t) S) (trm_rep (rhs t) S)) S)\n         else t)\""], ["", "definition subterm_reduction:: \"'a eclause set \\<Rightarrow> 'a trm \\<Rightarrow> 'a trm\"\nwhere\n  \"subterm_reduction S t = \n              (trm_rep (Comb (trm_rep (lhs t) S) (trm_rep (rhs t) S)) S)\""], ["", "definition maximal_literal_is_unique \n  where \"(maximal_literal_is_unique t s C' L' S \\<sigma>) = \n    (\\<forall>s''. ( \n              (eq_occurs_in_cl t s'' (C'- { L' }) \\<sigma>) \\<longrightarrow> (s'',t) \\<in> trm_ord \\<longrightarrow>  (s,t) \\<in> trm_ord\n                \\<longrightarrow> (trm_rep s S) \\<noteq> (trm_rep s'' S)))\""], ["", "definition smaller_lits_are_false\n  where \"(smaller_lits_are_false t C S) = \n    (\\<forall> L u v. \n              (L \\<in> C \\<longrightarrow> orient_lit L u v pos \n                \\<longrightarrow> (u,t) \\<in> trm_ord \\<longrightarrow>  (v,t) \\<in> trm_ord\n                \\<longrightarrow> (trm_rep u S) \\<noteq>  (trm_rep v S)) \n          \\<and>\n            (L \\<in> C \\<longrightarrow> orient_lit L u v neg \\<longrightarrow> (u,t) \\<in> trm_ord \\<longrightarrow>  (v,t) \\<in> trm_ord\n                \\<longrightarrow> (trm_rep u S) = (trm_rep v S)))\""], ["", "definition int_clset\n  where \"int_clset S = (same_values (\\<lambda>x. (trm_rep x S)))\""], ["", "lemma smaller_lits_are_false_if_cl_not_valid:\n  assumes \"\\<not>(validate_ground_clause (int_clset S) C)\"\n  shows \"smaller_lits_are_false t C S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smaller_lits_are_false t C S", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> smaller_lits_are_false t C S \\<Longrightarrow> False", "let ?I = \"int_clset S\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> smaller_lits_are_false t C S \\<Longrightarrow> False", "assume \"\\<not>smaller_lits_are_false t C S\""], ["proof (state)\nthis:\n  \\<not> smaller_lits_are_false t C S\n\ngoal (1 subgoal):\n 1. \\<not> smaller_lits_are_false t C S \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  \\<not> smaller_lits_are_false t C S", "obtain L u v where \"L \\<in> C\"  \n    and \"(orient_lit L u v pos \\<and> (trm_rep u S) =  (trm_rep v S)) \n          \\<or> (orient_lit L u v neg \\<and> (trm_rep u S) \\<noteq> (trm_rep v S))\""], ["proof (prove)\nusing this:\n  \\<not> smaller_lits_are_false t C S\n\ngoal (1 subgoal):\n 1. (\\<And>L u v.\n        \\<lbrakk>L \\<in> C;\n         orient_lit L u v pos \\<and> trm_rep u S = trm_rep v S \\<or>\n         orient_lit L u v neg \\<and>\n         trm_rep u S \\<noteq> trm_rep v S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding smaller_lits_are_false_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>L u v.\n             (L \\<in> C \\<longrightarrow>\n              orient_lit L u v pos \\<longrightarrow>\n              (u, t) \\<in> trm_ord \\<longrightarrow>\n              (v, t) \\<in> trm_ord \\<longrightarrow>\n              trm_rep u S \\<noteq> trm_rep v S) \\<and>\n             (L \\<in> C \\<longrightarrow>\n              orient_lit L u v neg \\<longrightarrow>\n              (u, t) \\<in> trm_ord \\<longrightarrow>\n              (v, t) \\<in> trm_ord \\<longrightarrow>\n              trm_rep u S = trm_rep v S))\n\ngoal (1 subgoal):\n 1. (\\<And>L u v.\n        \\<lbrakk>L \\<in> C;\n         orient_lit L u v pos \\<and> trm_rep u S = trm_rep v S \\<or>\n         orient_lit L u v neg \\<and>\n         trm_rep u S \\<noteq> trm_rep v S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  L \\<in> C\n  orient_lit L u v pos \\<and> trm_rep u S = trm_rep v S \\<or>\n  orient_lit L u v neg \\<and> trm_rep u S \\<noteq> trm_rep v S\n\ngoal (1 subgoal):\n 1. \\<not> smaller_lits_are_false t C S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  L \\<in> C\n  orient_lit L u v pos \\<and> trm_rep u S = trm_rep v S \\<or>\n  orient_lit L u v neg \\<and> trm_rep u S \\<noteq> trm_rep v S", "have \"(orient_lit L u v pos \\<and> (trm_rep u S) =  (trm_rep v S)) \n          \\<or> (orient_lit L u v neg \\<and> (trm_rep u S) \\<noteq> (trm_rep v S))\""], ["proof (prove)\nusing this:\n  L \\<in> C\n  orient_lit L u v pos \\<and> trm_rep u S = trm_rep v S \\<or>\n  orient_lit L u v neg \\<and> trm_rep u S \\<noteq> trm_rep v S\n\ngoal (1 subgoal):\n 1. orient_lit L u v pos \\<and> trm_rep u S = trm_rep v S \\<or>\n    orient_lit L u v neg \\<and> trm_rep u S \\<noteq> trm_rep v S", "by blast"], ["proof (state)\nthis:\n  orient_lit L u v pos \\<and> trm_rep u S = trm_rep v S \\<or>\n  orient_lit L u v neg \\<and> trm_rep u S \\<noteq> trm_rep v S\n\ngoal (1 subgoal):\n 1. \\<not> smaller_lits_are_false t C S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  orient_lit L u v pos \\<and> trm_rep u S = trm_rep v S \\<or>\n  orient_lit L u v neg \\<and> trm_rep u S \\<noteq> trm_rep v S", "show False"], ["proof (prove)\nusing this:\n  orient_lit L u v pos \\<and> trm_rep u S = trm_rep v S \\<or>\n  orient_lit L u v neg \\<and> trm_rep u S \\<noteq> trm_rep v S\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. orient_lit L u v pos \\<and> trm_rep u S = trm_rep v S \\<Longrightarrow>\n    False\n 2. orient_lit L u v neg \\<and>\n    trm_rep u S \\<noteq> trm_rep v S \\<Longrightarrow>\n    False", "assume c_pos: \"(orient_lit L u v pos \\<and> (trm_rep u S) =  (trm_rep v S))\""], ["proof (state)\nthis:\n  orient_lit L u v pos \\<and> trm_rep u S = trm_rep v S\n\ngoal (2 subgoals):\n 1. orient_lit L u v pos \\<and> trm_rep u S = trm_rep v S \\<Longrightarrow>\n    False\n 2. orient_lit L u v neg \\<and>\n    trm_rep u S \\<noteq> trm_rep v S \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  orient_lit L u v pos \\<and> trm_rep u S = trm_rep v S", "have \"orient_lit L u v pos\""], ["proof (prove)\nusing this:\n  orient_lit L u v pos \\<and> trm_rep u S = trm_rep v S\n\ngoal (1 subgoal):\n 1. orient_lit L u v pos", "by blast"], ["proof (state)\nthis:\n  orient_lit L u v pos\n\ngoal (2 subgoals):\n 1. orient_lit L u v pos \\<and> trm_rep u S = trm_rep v S \\<Longrightarrow>\n    False\n 2. orient_lit L u v neg \\<and>\n    trm_rep u S \\<noteq> trm_rep v S \\<Longrightarrow>\n    False", "from c_pos"], ["proof (chain)\npicking this:\n  orient_lit L u v pos \\<and> trm_rep u S = trm_rep v S", "have \"(trm_rep u S) =  (trm_rep v S)\""], ["proof (prove)\nusing this:\n  orient_lit L u v pos \\<and> trm_rep u S = trm_rep v S\n\ngoal (1 subgoal):\n 1. trm_rep u S = trm_rep v S", "by blast"], ["proof (state)\nthis:\n  trm_rep u S = trm_rep v S\n\ngoal (2 subgoals):\n 1. orient_lit L u v pos \\<and> trm_rep u S = trm_rep v S \\<Longrightarrow>\n    False\n 2. orient_lit L u v neg \\<and>\n    trm_rep u S \\<noteq> trm_rep v S \\<Longrightarrow>\n    False", "from \\<open>orient_lit L u v pos\\<close>"], ["proof (chain)\npicking this:\n  orient_lit L u v pos", "have \"L = (Pos (Eq u v)) \\<or> L = (Pos (Eq v u))\""], ["proof (prove)\nusing this:\n  orient_lit L u v pos\n\ngoal (1 subgoal):\n 1. L = Pos (Eq u v) \\<or> L = Pos (Eq v u)", "unfolding orient_lit_def"], ["proof (prove)\nusing this:\n  (L = Pos (Eq u v) \\<or> L = Pos (Eq v u)) \\<and>\n  (u, v) \\<notin> trm_ord \\<and> pos = pos \\<or>\n  (L = Neg (Eq u v) \\<or> L = Neg (Eq v u)) \\<and>\n  (u, v) \\<notin> trm_ord \\<and> pos = neg\n\ngoal (1 subgoal):\n 1. L = Pos (Eq u v) \\<or> L = Pos (Eq v u)", "by auto"], ["proof (state)\nthis:\n  L = Pos (Eq u v) \\<or> L = Pos (Eq v u)\n\ngoal (2 subgoals):\n 1. orient_lit L u v pos \\<and> trm_rep u S = trm_rep v S \\<Longrightarrow>\n    False\n 2. orient_lit L u v neg \\<and>\n    trm_rep u S \\<noteq> trm_rep v S \\<Longrightarrow>\n    False", "from this and \\<open>(trm_rep u S) =  (trm_rep v S)\\<close>"], ["proof (chain)\npicking this:\n  L = Pos (Eq u v) \\<or> L = Pos (Eq v u)\n  trm_rep u S = trm_rep v S", "have \"validate_ground_lit ?I L\""], ["proof (prove)\nusing this:\n  L = Pos (Eq u v) \\<or> L = Pos (Eq v u)\n  trm_rep u S = trm_rep v S\n\ngoal (1 subgoal):\n 1. validate_ground_lit (int_clset S) L", "using validate_ground_lit.simps(1) validate_ground_eq.simps"], ["proof (prove)\nusing this:\n  L = Pos (Eq u v) \\<or> L = Pos (Eq v u)\n  trm_rep u S = trm_rep v S\n  validate_ground_lit ?I (Pos ?E) = validate_ground_eq ?I ?E\n  validate_ground_eq ?I (Eq ?t ?s) = ?I ?t ?s\n\ngoal (1 subgoal):\n 1. validate_ground_lit (int_clset S) L", "unfolding same_values_def int_clset_def"], ["proof (prove)\nusing this:\n  L = Pos (Eq u v) \\<or> L = Pos (Eq v u)\n  trm_rep u S = trm_rep v S\n  validate_ground_lit ?I (Pos ?E) = validate_ground_eq ?I ?E\n  validate_ground_eq ?I (Eq ?t ?s) = ?I ?t ?s\n\ngoal (1 subgoal):\n 1. validate_ground_lit (\\<lambda>x y. trm_rep x S = trm_rep y S) L", "by (metis (mono_tags, lifting))"], ["proof (state)\nthis:\n  validate_ground_lit (int_clset S) L\n\ngoal (2 subgoals):\n 1. orient_lit L u v pos \\<and> trm_rep u S = trm_rep v S \\<Longrightarrow>\n    False\n 2. orient_lit L u v neg \\<and>\n    trm_rep u S \\<noteq> trm_rep v S \\<Longrightarrow>\n    False", "from this and \\<open>L \\<in> C\\<close> and assms"], ["proof (chain)\npicking this:\n  validate_ground_lit (int_clset S) L\n  L \\<in> C\n  \\<not> validate_ground_clause (int_clset S) C", "show False"], ["proof (prove)\nusing this:\n  validate_ground_lit (int_clset S) L\n  L \\<in> C\n  \\<not> validate_ground_clause (int_clset S) C\n\ngoal (1 subgoal):\n 1. False", "unfolding int_clset_def"], ["proof (prove)\nusing this:\n  validate_ground_lit (same_values (\\<lambda>x. trm_rep x S)) L\n  L \\<in> C\n  \\<not> validate_ground_clause (same_values (\\<lambda>x. trm_rep x S)) C\n\ngoal (1 subgoal):\n 1. False", "using validate_ground_clause.simps"], ["proof (prove)\nusing this:\n  validate_ground_lit (same_values (\\<lambda>x. trm_rep x S)) L\n  L \\<in> C\n  \\<not> validate_ground_clause (same_values (\\<lambda>x. trm_rep x S)) C\n  validate_ground_clause ?I ?C =\n  (\\<exists>L. L \\<in> ?C \\<and> validate_ground_lit ?I L)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. orient_lit L u v neg \\<and>\n    trm_rep u S \\<noteq> trm_rep v S \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. orient_lit L u v neg \\<and>\n    trm_rep u S \\<noteq> trm_rep v S \\<Longrightarrow>\n    False", "assume c_neg: \"(orient_lit L u v neg \\<and> (trm_rep u S) \\<noteq> (trm_rep v S))\""], ["proof (state)\nthis:\n  orient_lit L u v neg \\<and> trm_rep u S \\<noteq> trm_rep v S\n\ngoal (1 subgoal):\n 1. orient_lit L u v neg \\<and>\n    trm_rep u S \\<noteq> trm_rep v S \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  orient_lit L u v neg \\<and> trm_rep u S \\<noteq> trm_rep v S", "have \"orient_lit L u v neg\""], ["proof (prove)\nusing this:\n  orient_lit L u v neg \\<and> trm_rep u S \\<noteq> trm_rep v S\n\ngoal (1 subgoal):\n 1. orient_lit L u v neg", "by blast"], ["proof (state)\nthis:\n  orient_lit L u v neg\n\ngoal (1 subgoal):\n 1. orient_lit L u v neg \\<and>\n    trm_rep u S \\<noteq> trm_rep v S \\<Longrightarrow>\n    False", "from c_neg"], ["proof (chain)\npicking this:\n  orient_lit L u v neg \\<and> trm_rep u S \\<noteq> trm_rep v S", "have \"(trm_rep u S) \\<noteq> (trm_rep v S)\""], ["proof (prove)\nusing this:\n  orient_lit L u v neg \\<and> trm_rep u S \\<noteq> trm_rep v S\n\ngoal (1 subgoal):\n 1. trm_rep u S \\<noteq> trm_rep v S", "by blast"], ["proof (state)\nthis:\n  trm_rep u S \\<noteq> trm_rep v S\n\ngoal (1 subgoal):\n 1. orient_lit L u v neg \\<and>\n    trm_rep u S \\<noteq> trm_rep v S \\<Longrightarrow>\n    False", "from \\<open>orient_lit L u v neg\\<close>"], ["proof (chain)\npicking this:\n  orient_lit L u v neg", "have \"L = (Neg (Eq u v)) \\<or> L = (Neg (Eq v u))\""], ["proof (prove)\nusing this:\n  orient_lit L u v neg\n\ngoal (1 subgoal):\n 1. L = Neg (Eq u v) \\<or> L = Neg (Eq v u)", "unfolding orient_lit_def"], ["proof (prove)\nusing this:\n  (L = Pos (Eq u v) \\<or> L = Pos (Eq v u)) \\<and>\n  (u, v) \\<notin> trm_ord \\<and> neg = pos \\<or>\n  (L = Neg (Eq u v) \\<or> L = Neg (Eq v u)) \\<and>\n  (u, v) \\<notin> trm_ord \\<and> neg = neg\n\ngoal (1 subgoal):\n 1. L = Neg (Eq u v) \\<or> L = Neg (Eq v u)", "by auto"], ["proof (state)\nthis:\n  L = Neg (Eq u v) \\<or> L = Neg (Eq v u)\n\ngoal (1 subgoal):\n 1. orient_lit L u v neg \\<and>\n    trm_rep u S \\<noteq> trm_rep v S \\<Longrightarrow>\n    False", "from this and \\<open>(trm_rep u S) \\<noteq> (trm_rep v S)\\<close>"], ["proof (chain)\npicking this:\n  L = Neg (Eq u v) \\<or> L = Neg (Eq v u)\n  trm_rep u S \\<noteq> trm_rep v S", "have \"validate_ground_lit ?I L\""], ["proof (prove)\nusing this:\n  L = Neg (Eq u v) \\<or> L = Neg (Eq v u)\n  trm_rep u S \\<noteq> trm_rep v S\n\ngoal (1 subgoal):\n 1. validate_ground_lit (int_clset S) L", "using validate_ground_lit.simps(2) validate_ground_eq.simps"], ["proof (prove)\nusing this:\n  L = Neg (Eq u v) \\<or> L = Neg (Eq v u)\n  trm_rep u S \\<noteq> trm_rep v S\n  validate_ground_lit ?I (Neg ?E) = (\\<not> validate_ground_eq ?I ?E)\n  validate_ground_eq ?I (Eq ?t ?s) = ?I ?t ?s\n\ngoal (1 subgoal):\n 1. validate_ground_lit (int_clset S) L", "unfolding same_values_def int_clset_def"], ["proof (prove)\nusing this:\n  L = Neg (Eq u v) \\<or> L = Neg (Eq v u)\n  trm_rep u S \\<noteq> trm_rep v S\n  validate_ground_lit ?I (Neg ?E) = (\\<not> validate_ground_eq ?I ?E)\n  validate_ground_eq ?I (Eq ?t ?s) = ?I ?t ?s\n\ngoal (1 subgoal):\n 1. validate_ground_lit (\\<lambda>x y. trm_rep x S = trm_rep y S) L", "by (metis (mono_tags, lifting))"], ["proof (state)\nthis:\n  validate_ground_lit (int_clset S) L\n\ngoal (1 subgoal):\n 1. orient_lit L u v neg \\<and>\n    trm_rep u S \\<noteq> trm_rep v S \\<Longrightarrow>\n    False", "from this and \\<open>L \\<in> C\\<close> and assms"], ["proof (chain)\npicking this:\n  validate_ground_lit (int_clset S) L\n  L \\<in> C\n  \\<not> validate_ground_clause (int_clset S) C", "show False"], ["proof (prove)\nusing this:\n  validate_ground_lit (int_clset S) L\n  L \\<in> C\n  \\<not> validate_ground_clause (int_clset S) C\n\ngoal (1 subgoal):\n 1. False", "unfolding int_clset_def"], ["proof (prove)\nusing this:\n  validate_ground_lit (same_values (\\<lambda>x. trm_rep x S)) L\n  L \\<in> C\n  \\<not> validate_ground_clause (same_values (\\<lambda>x. trm_rep x S)) C\n\ngoal (1 subgoal):\n 1. False", "using validate_ground_clause.simps"], ["proof (prove)\nusing this:\n  validate_ground_lit (same_values (\\<lambda>x. trm_rep x S)) L\n  L \\<in> C\n  \\<not> validate_ground_clause (same_values (\\<lambda>x. trm_rep x S)) C\n  validate_ground_clause ?I ?C =\n  (\\<exists>L. L \\<in> ?C \\<and> validate_ground_lit ?I L)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The following function states that all instances of the terms attached to a clause are in \nnormal form w.r.t.\\ the interpretation associated with @{term \"S\"}, up to some maximal term \n@{term \"t\"}\\<close>"], ["", "definition trms_irreducible\n  where \"trms_irreducible CC \\<sigma> S t = \n            (\\<forall>x. (\\<exists>x' \\<in> (trms_ecl CC). occurs_in x (subst x' \\<sigma>)) \\<longrightarrow> \n              ( (x,t) \\<in> trm_ord \\<longrightarrow> (trm_rep x S) = x))\""], ["", "lemma trms_irreducible_lemma:\n  assumes \"all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>) (\\<lambda>t. trm_rep t S)\"\n  shows \"trms_irreducible C \\<sigma> S t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trms_irreducible C \\<sigma> S t", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> trms_irreducible C \\<sigma> S t \\<Longrightarrow> False", "assume \"\\<not>trms_irreducible C \\<sigma> S t\""], ["proof (state)\nthis:\n  \\<not> trms_irreducible C \\<sigma> S t\n\ngoal (1 subgoal):\n 1. \\<not> trms_irreducible C \\<sigma> S t \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  \\<not> trms_irreducible C \\<sigma> S t", "obtain x where \"\\<exists>x'\\<in> trms_ecl C. occurs_in x (subst x' \\<sigma>)\" and\n          \"trm_rep x S \\<noteq> x\""], ["proof (prove)\nusing this:\n  \\<not> trms_irreducible C \\<sigma> S t\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>\\<exists>x'\\<in>trms_ecl C.\n                    occurs_in x (x' \\<lhd> \\<sigma>);\n         trm_rep x S \\<noteq> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding trms_irreducible_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x.\n             (\\<exists>x'\\<in>trms_ecl C.\n                 occurs_in x (x' \\<lhd> \\<sigma>)) \\<longrightarrow>\n             (x, t) \\<in> trm_ord \\<longrightarrow> trm_rep x S = x)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>\\<exists>x'\\<in>trms_ecl C.\n                    occurs_in x (x' \\<lhd> \\<sigma>);\n         trm_rep x S \\<noteq> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<exists>x'\\<in>trms_ecl C. occurs_in x (x' \\<lhd> \\<sigma>)\n  trm_rep x S \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<not> trms_irreducible C \\<sigma> S t \\<Longrightarrow> False", "from \\<open>\\<exists>x'\\<in> trms_ecl C. occurs_in x (subst x' \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>x'\\<in>trms_ecl C. occurs_in x (x' \\<lhd> \\<sigma>)", "obtain x' where\n    \"x' \\<in> trms_ecl C\" and \"occurs_in x (subst x' \\<sigma>)\""], ["proof (prove)\nusing this:\n  \\<exists>x'\\<in>trms_ecl C. occurs_in x (x' \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>x' \\<in> trms_ecl C;\n         occurs_in x (x' \\<lhd> \\<sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x' \\<in> trms_ecl C\n  occurs_in x (x' \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> trms_irreducible C \\<sigma> S t \\<Longrightarrow> False", "from \\<open>x' \\<in> trms_ecl C\\<close>"], ["proof (chain)\npicking this:\n  x' \\<in> trms_ecl C", "have \"(subst x' \\<sigma>) \\<in> (subst_set (trms_ecl C) \\<sigma>)\""], ["proof (prove)\nusing this:\n  x' \\<in> trms_ecl C\n\ngoal (1 subgoal):\n 1. x' \\<lhd> \\<sigma> \\<in> subst_set (trms_ecl C) \\<sigma>", "by auto"], ["proof (state)\nthis:\n  x' \\<lhd> \\<sigma> \\<in> subst_set (trms_ecl C) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> trms_irreducible C \\<sigma> S t \\<Longrightarrow> False", "from this and assms(1) \\<open>occurs_in x (subst x' \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  x' \\<lhd> \\<sigma> \\<in> subst_set (trms_ecl C) \\<sigma>\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n  occurs_in x (x' \\<lhd> \\<sigma>)", "have \"trm_rep x S = x\""], ["proof (prove)\nusing this:\n  x' \\<lhd> \\<sigma> \\<in> subst_set (trms_ecl C) \\<sigma>\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n  occurs_in x (x' \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. trm_rep x S = x", "unfolding all_trms_irreducible_def"], ["proof (prove)\nusing this:\n  x' \\<lhd> \\<sigma> \\<in> subst_set (trms_ecl C) \\<sigma>\n  \\<forall>x y.\n     x \\<in> subst_set (trms_ecl C) \\<sigma> \\<longrightarrow>\n     occurs_in y x \\<longrightarrow> trm_rep y S = y\n  occurs_in x (x' \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. trm_rep x S = x", "by metis"], ["proof (state)\nthis:\n  trm_rep x S = x\n\ngoal (1 subgoal):\n 1. \\<not> trms_irreducible C \\<sigma> S t \\<Longrightarrow> False", "from this and \\<open>trm_rep x S \\<noteq> x\\<close>"], ["proof (chain)\npicking this:\n  trm_rep x S = x\n  trm_rep x S \\<noteq> x", "show False"], ["proof (prove)\nusing this:\n  trm_rep x S = x\n  trm_rep x S \\<noteq> x\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The following predicate states that a term @{term \"z\"} is the normal form of the right-hand \nside of a rule of left-hand side @{term \"t\"}. It is used to define the set of possible values for \nterm @{term \"t\"}. The actual value is that corresponding to the smallest right-hand side.\\<close>"], ["", "definition candidate_values\n  where \"(candidate_values z CC C' C s L L' \\<sigma> t' s' t S) = \n           (CC \\<in> S \\<and> (t \\<notin> (subst_set (trms_ecl CC) \\<sigma>)) \\<and> (trms_irreducible CC \\<sigma> S t)\n          \\<and> (C' = (cl_ecl CC)) \\<and> (s,t) \\<in> trm_ord \\<and> ((s,t) \\<in> trm_ord \\<longrightarrow> (z = trm_rep s S))\n          \\<and> (orient_lit_inst L' t' s' pos \\<sigma>) \\<and> (sel C' = {}) \\<and> (L' \\<in> C') \\<and> (maximal_literal L C)\n          \\<and> (L = (subst_lit L' \\<sigma>)) \\<and> (C = (subst_cl C' \\<sigma>)) \\<and> (ground_clause C)\n          \\<and> (t = (subst t' \\<sigma>)) \\<and>  (s = (subst s' \\<sigma>)) \\<and> (finite C') \n          \\<and> (smaller_lits_are_false t C S)\n          \\<and> (maximal_literal_is_unique t s C' L' S \\<sigma>))\""], ["", "definition set_of_candidate_values:: \"'a eclause set \\<Rightarrow> 'a trm \\<Rightarrow> ('a trm \\<times> 'a trm) set\"\nwhere \"set_of_candidate_values S t  = \n         { pair. \\<exists>z CC C' C s L L' \\<sigma> t' s'. \n           pair = (z,s) \\<and> (candidate_values z CC C' C s L L' \\<sigma> t' s' t S) }\""], ["", "definition subterm_reduction_applicable_aux:: \"'a eclause set \\<Rightarrow> 'a trm \\<Rightarrow> bool\"\n  where \"subterm_reduction_applicable_aux S t =\n   (is_compound t \\<and> (lhs t,t) \\<in> trm_ord  \\<and> (rhs t,t) \\<in> trm_ord\n      \\<and> ( ((lhs t,t) \\<in> trm_ord \\<longrightarrow> (trm_rep (lhs t) S) \\<noteq> (lhs t)) \n      \\<or> ((rhs t,t) \\<in> trm_ord \\<longrightarrow>(trm_rep (rhs t) S) \\<noteq> (rhs t))))\""], ["", "definition subterm_reduction_applicable:: \"'a eclause set \\<Rightarrow> 'a trm \\<Rightarrow> bool\"\n  where \"subterm_reduction_applicable S t =\n   (is_compound t \\<and> ((trm_rep (lhs t) S) \\<noteq> (lhs t) \\<or> (trm_rep (rhs t) S) \\<noteq> (rhs t)))\""], ["", "lemma trm_rep_is_lower_aux:\n  assumes \"\\<forall>y. (y,t) \\<in> trm_ord \\<longrightarrow>\n      (y \\<noteq> (trm_rep y S) \\<longrightarrow> ((trm_rep y S),y) \\<in> trm_ord)\"\n  assumes \"(subterm_reduction_applicable S t)\"\n  shows \"((Comb (trm_rep (lhs t) S) (trm_rep (rhs t) S)),t) \\<in> trm_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "have \"(lhs t,t) \\<in> trm_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lhs t, t) \\<in> trm_ord", "using \\<open>subterm_reduction_applicable S t\\<close> args_are_strictly_lower \n      subterm_reduction_applicable_def"], ["proof (prove)\nusing this:\n  subterm_reduction_applicable S t\n  is_compound ?t \\<Longrightarrow>\n  (lhs ?t, ?t) \\<in> trm_ord \\<and> (rhs ?t, ?t) \\<in> trm_ord\n  subterm_reduction_applicable ?S ?t =\n  (is_compound ?t \\<and>\n   (trm_rep (lhs ?t) ?S \\<noteq> lhs ?t \\<or>\n    trm_rep (rhs ?t) ?S \\<noteq> rhs ?t))\n\ngoal (1 subgoal):\n 1. (lhs t, t) \\<in> trm_ord", "by blast"], ["proof (state)\nthis:\n  (lhs t, t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "have \"(rhs t,t) \\<in> trm_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rhs t, t) \\<in> trm_ord", "using \\<open>subterm_reduction_applicable S t\\<close> args_are_strictly_lower \n    subterm_reduction_applicable_def"], ["proof (prove)\nusing this:\n  subterm_reduction_applicable S t\n  is_compound ?t \\<Longrightarrow>\n  (lhs ?t, ?t) \\<in> trm_ord \\<and> (rhs ?t, ?t) \\<in> trm_ord\n  subterm_reduction_applicable ?S ?t =\n  (is_compound ?t \\<and>\n   (trm_rep (lhs ?t) ?S \\<noteq> lhs ?t \\<or>\n    trm_rep (rhs ?t) ?S \\<noteq> rhs ?t))\n\ngoal (1 subgoal):\n 1. (rhs t, t) \\<in> trm_ord", "by blast"], ["proof (state)\nthis:\n  (rhs t, t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "from assms(1) and \\<open>(lhs t,t) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>y.\n     (y, t) \\<in> trm_ord \\<longrightarrow>\n     y \\<noteq> trm_rep y S \\<longrightarrow> (trm_rep y S, y) \\<in> trm_ord\n  (lhs t, t) \\<in> trm_ord", "have \n    l: \"( (lhs t \\<noteq> (trm_rep (lhs t) S)) \\<longrightarrow> ((trm_rep  (lhs t) S), (lhs t)) \\<in> trm_ord)\""], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, t) \\<in> trm_ord \\<longrightarrow>\n     y \\<noteq> trm_rep y S \\<longrightarrow> (trm_rep y S, y) \\<in> trm_ord\n  (lhs t, t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. lhs t \\<noteq> trm_rep (lhs t) S \\<longrightarrow>\n    (trm_rep (lhs t) S, lhs t) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  lhs t \\<noteq> trm_rep (lhs t) S \\<longrightarrow>\n  (trm_rep (lhs t) S, lhs t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "from assms(1) and \\<open>(rhs t,t) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>y.\n     (y, t) \\<in> trm_ord \\<longrightarrow>\n     y \\<noteq> trm_rep y S \\<longrightarrow> (trm_rep y S, y) \\<in> trm_ord\n  (rhs t, t) \\<in> trm_ord", "have \n    r: \"(rhs t \\<noteq> (trm_rep (rhs t) S) \\<longrightarrow> ((trm_rep  (rhs t) S), (rhs t)) \\<in> trm_ord)\""], ["proof (prove)\nusing this:\n  \\<forall>y.\n     (y, t) \\<in> trm_ord \\<longrightarrow>\n     y \\<noteq> trm_rep y S \\<longrightarrow> (trm_rep y S, y) \\<in> trm_ord\n  (rhs t, t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. rhs t \\<noteq> trm_rep (rhs t) S \\<longrightarrow>\n    (trm_rep (rhs t) S, rhs t) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  rhs t \\<noteq> trm_rep (rhs t) S \\<longrightarrow>\n  (trm_rep (rhs t) S, rhs t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "from \\<open>subterm_reduction_applicable S t\\<close>"], ["proof (chain)\npicking this:\n  subterm_reduction_applicable S t", "have \"((trm_rep (lhs t) S) \\<noteq> (lhs t) \\<or> (trm_rep (rhs t) S) \\<noteq> (rhs t))\""], ["proof (prove)\nusing this:\n  subterm_reduction_applicable S t\n\ngoal (1 subgoal):\n 1. trm_rep (lhs t) S \\<noteq> lhs t \\<or> trm_rep (rhs t) S \\<noteq> rhs t", "unfolding subterm_reduction_applicable_def [of S t]"], ["proof (prove)\nusing this:\n  is_compound t \\<and>\n  (trm_rep (lhs t) S \\<noteq> lhs t \\<or> trm_rep (rhs t) S \\<noteq> rhs t)\n\ngoal (1 subgoal):\n 1. trm_rep (lhs t) S \\<noteq> lhs t \\<or> trm_rep (rhs t) S \\<noteq> rhs t", "by blast"], ["proof (state)\nthis:\n  trm_rep (lhs t) S \\<noteq> lhs t \\<or> trm_rep (rhs t) S \\<noteq> rhs t\n\ngoal (1 subgoal):\n 1. (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "then"], ["proof (chain)\npicking this:\n  trm_rep (lhs t) S \\<noteq> lhs t \\<or> trm_rep (rhs t) S \\<noteq> rhs t", "show ?thesis"], ["proof (prove)\nusing this:\n  trm_rep (lhs t) S \\<noteq> lhs t \\<or> trm_rep (rhs t) S \\<noteq> rhs t\n\ngoal (1 subgoal):\n 1. (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. trm_rep (lhs t) S \\<noteq> lhs t \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord\n 2. trm_rep (rhs t) S \\<noteq> rhs t \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "assume \"(trm_rep (lhs t) S) \\<noteq> (lhs t)\""], ["proof (state)\nthis:\n  trm_rep (lhs t) S \\<noteq> lhs t\n\ngoal (2 subgoals):\n 1. trm_rep (lhs t) S \\<noteq> lhs t \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord\n 2. trm_rep (rhs t) S \\<noteq> rhs t \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "from this and l"], ["proof (chain)\npicking this:\n  trm_rep (lhs t) S \\<noteq> lhs t\n  lhs t \\<noteq> trm_rep (lhs t) S \\<longrightarrow>\n  (trm_rep (lhs t) S, lhs t) \\<in> trm_ord", "have \"((trm_rep  (lhs t) S), (lhs t)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  trm_rep (lhs t) S \\<noteq> lhs t\n  lhs t \\<noteq> trm_rep (lhs t) S \\<longrightarrow>\n  (trm_rep (lhs t) S, lhs t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep (lhs t) S, lhs t) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (trm_rep (lhs t) S, lhs t) \\<in> trm_ord\n\ngoal (2 subgoals):\n 1. trm_rep (lhs t) S \\<noteq> lhs t \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord\n 2. trm_rep (rhs t) S \\<noteq> rhs t \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "from this"], ["proof (chain)\npicking this:\n  (trm_rep (lhs t) S, lhs t) \\<in> trm_ord", "have i: \"((Comb (trm_rep (lhs t) S) (trm_rep (rhs t) S)),(Comb (lhs t)  (trm_rep (rhs t) S))) \n      \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (trm_rep (lhs t) S, lhs t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S,\n     lhs t \\<cdot> trm_rep (rhs t) S)\n    \\<in> trm_ord", "using trm_ord_reduction_left"], ["proof (prove)\nusing this:\n  (trm_rep (lhs t) S, lhs t) \\<in> trm_ord\n  \\<forall>x1 x2 y.\n     (x1, x2) \\<in> trm_ord \\<longrightarrow>\n     (x1 \\<cdot> y, x2 \\<cdot> y) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S,\n     lhs t \\<cdot> trm_rep (rhs t) S)\n    \\<in> trm_ord", "by blast"], ["proof (state)\nthis:\n  (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S,\n   lhs t \\<cdot> trm_rep (rhs t) S)\n  \\<in> trm_ord\n\ngoal (2 subgoals):\n 1. trm_rep (lhs t) S \\<noteq> lhs t \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord\n 2. trm_rep (rhs t) S \\<noteq> rhs t \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "show \"((Comb (trm_rep (lhs t) S) (trm_rep (rhs t) S)),t) \\<in> trm_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord\n 2. \\<not> ?P \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "assume \"(trm_rep (rhs t) S) = (rhs t)\""], ["proof (state)\nthis:\n  trm_rep (rhs t) S = rhs t\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord\n 2. \\<not> ?P \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "from this \n        and \\<open>((Comb (trm_rep (lhs t) S) (trm_rep (rhs t) S)),(Comb (lhs t)  (trm_rep (rhs t) S))) \n          \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  trm_rep (rhs t) S = rhs t\n  (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S,\n   lhs t \\<cdot> trm_rep (rhs t) S)\n  \\<in> trm_ord", "show \"((Comb (trm_rep (lhs t) S) (trm_rep (rhs t) S)),t)  \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  trm_rep (rhs t) S = rhs t\n  (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S,\n   lhs t \\<cdot> trm_rep (rhs t) S)\n  \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "by (metis assms(2) is_compound.elims(2) lhs.simps(1) \n            rhs.simps(1) subterm_reduction_applicable_def)"], ["proof (state)\nthis:\n  (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep (rhs t) S \\<noteq> rhs t \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. trm_rep (rhs t) S \\<noteq> rhs t \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "assume \"(trm_rep (rhs t) S) \\<noteq> (rhs t)\""], ["proof (state)\nthis:\n  trm_rep (rhs t) S \\<noteq> rhs t\n\ngoal (1 subgoal):\n 1. trm_rep (rhs t) S \\<noteq> rhs t \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "from this and r"], ["proof (chain)\npicking this:\n  trm_rep (rhs t) S \\<noteq> rhs t\n  rhs t \\<noteq> trm_rep (rhs t) S \\<longrightarrow>\n  (trm_rep (rhs t) S, rhs t) \\<in> trm_ord", "have \"((trm_rep  (rhs t) S), (rhs t)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  trm_rep (rhs t) S \\<noteq> rhs t\n  rhs t \\<noteq> trm_rep (rhs t) S \\<longrightarrow>\n  (trm_rep (rhs t) S, rhs t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep (rhs t) S, rhs t) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (trm_rep (rhs t) S, rhs t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep (rhs t) S \\<noteq> rhs t \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "from this"], ["proof (chain)\npicking this:\n  (trm_rep (rhs t) S, rhs t) \\<in> trm_ord", "have \"((Comb (lhs t) (trm_rep (rhs t) S)), ((Comb (lhs t) (rhs t))))  \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (trm_rep (rhs t) S, rhs t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (lhs t \\<cdot> trm_rep (rhs t) S, lhs t \\<cdot> rhs t) \\<in> trm_ord", "using trm_ord_reduction_right"], ["proof (prove)\nusing this:\n  (trm_rep (rhs t) S, rhs t) \\<in> trm_ord\n  \\<forall>x1 x2 y.\n     (x1, x2) \\<in> trm_ord \\<longrightarrow>\n     (y \\<cdot> x1, y \\<cdot> x2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (lhs t \\<cdot> trm_rep (rhs t) S, lhs t \\<cdot> rhs t) \\<in> trm_ord", "by blast"], ["proof (state)\nthis:\n  (lhs t \\<cdot> trm_rep (rhs t) S, lhs t \\<cdot> rhs t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep (rhs t) S \\<noteq> rhs t \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "from this and i"], ["proof (chain)\npicking this:\n  (lhs t \\<cdot> trm_rep (rhs t) S, lhs t \\<cdot> rhs t) \\<in> trm_ord\n  (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S,\n   lhs t \\<cdot> trm_rep (rhs t) S)\n  \\<in> trm_ord", "show \"((Comb (trm_rep (lhs t) S) (trm_rep (rhs t) S)),t)  \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (lhs t \\<cdot> trm_rep (rhs t) S, lhs t \\<cdot> rhs t) \\<in> trm_ord\n  (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S,\n   lhs t \\<cdot> trm_rep (rhs t) S)\n  \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "by (metis assms(2) is_compound.elims(2) lhs.simps(1) rhs.simps(1) \n            subterm_reduction_applicable_def trm_ord_trans transE)"], ["proof (state)\nthis:\n  (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep (rhs t) S \\<noteq> rhs t \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. trm_rep (rhs t) S \\<noteq> rhs t \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "assume \"(trm_rep (rhs t) S) \\<noteq> (rhs t)\""], ["proof (state)\nthis:\n  trm_rep (rhs t) S \\<noteq> rhs t\n\ngoal (1 subgoal):\n 1. trm_rep (rhs t) S \\<noteq> rhs t \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "from this and r"], ["proof (chain)\npicking this:\n  trm_rep (rhs t) S \\<noteq> rhs t\n  rhs t \\<noteq> trm_rep (rhs t) S \\<longrightarrow>\n  (trm_rep (rhs t) S, rhs t) \\<in> trm_ord", "have \"((trm_rep  (rhs t) S), (rhs t)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  trm_rep (rhs t) S \\<noteq> rhs t\n  rhs t \\<noteq> trm_rep (rhs t) S \\<longrightarrow>\n  (trm_rep (rhs t) S, rhs t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep (rhs t) S, rhs t) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (trm_rep (rhs t) S, rhs t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep (rhs t) S \\<noteq> rhs t \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "from this"], ["proof (chain)\npicking this:\n  (trm_rep (rhs t) S, rhs t) \\<in> trm_ord", "have i: \"((Comb (trm_rep (lhs t) S) (trm_rep (rhs t) S)),(Comb (trm_rep (lhs t) S) (rhs t))) \n                \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (trm_rep (rhs t) S, rhs t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S,\n     trm_rep (lhs t) S \\<cdot> rhs t)\n    \\<in> trm_ord", "using trm_ord_reduction_right"], ["proof (prove)\nusing this:\n  (trm_rep (rhs t) S, rhs t) \\<in> trm_ord\n  \\<forall>x1 x2 y.\n     (x1, x2) \\<in> trm_ord \\<longrightarrow>\n     (y \\<cdot> x1, y \\<cdot> x2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S,\n     trm_rep (lhs t) S \\<cdot> rhs t)\n    \\<in> trm_ord", "by blast"], ["proof (state)\nthis:\n  (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S,\n   trm_rep (lhs t) S \\<cdot> rhs t)\n  \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep (rhs t) S \\<noteq> rhs t \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "show \"((Comb (trm_rep (lhs t) S) (trm_rep (rhs t) S)),t) \\<in> trm_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord\n 2. \\<not> ?P \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "assume \"(trm_rep (lhs t) S) = (lhs t)\""], ["proof (state)\nthis:\n  trm_rep (lhs t) S = lhs t\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord\n 2. \\<not> ?P \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "from this and \n     \\<open>((Comb (trm_rep (lhs t) S) (trm_rep (rhs t) S)),(Comb (trm_rep (lhs t) S) (rhs t))) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  trm_rep (lhs t) S = lhs t\n  (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S,\n   trm_rep (lhs t) S \\<cdot> rhs t)\n  \\<in> trm_ord", "show \"((Comb (trm_rep (lhs t) S) (trm_rep (rhs t) S)),t)  \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  trm_rep (lhs t) S = lhs t\n  (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S,\n   trm_rep (lhs t) S \\<cdot> rhs t)\n  \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "by (metis assms(2) basic_superposition.subterm_reduction_applicable_def  \n            basic_superposition_axioms is_compound.elims(2) lhs.simps(1) rhs.simps(1))"], ["proof (state)\nthis:\n  (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep (lhs t) S \\<noteq> lhs t \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. trm_rep (lhs t) S \\<noteq> lhs t \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "assume \"(trm_rep (lhs t) S) \\<noteq> (lhs t)\""], ["proof (state)\nthis:\n  trm_rep (lhs t) S \\<noteq> lhs t\n\ngoal (1 subgoal):\n 1. trm_rep (lhs t) S \\<noteq> lhs t \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "from this and l"], ["proof (chain)\npicking this:\n  trm_rep (lhs t) S \\<noteq> lhs t\n  lhs t \\<noteq> trm_rep (lhs t) S \\<longrightarrow>\n  (trm_rep (lhs t) S, lhs t) \\<in> trm_ord", "have \"((trm_rep  (lhs t) S), (lhs t)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  trm_rep (lhs t) S \\<noteq> lhs t\n  lhs t \\<noteq> trm_rep (lhs t) S \\<longrightarrow>\n  (trm_rep (lhs t) S, lhs t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep (lhs t) S, lhs t) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (trm_rep (lhs t) S, lhs t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep (lhs t) S \\<noteq> lhs t \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "from this"], ["proof (chain)\npicking this:\n  (trm_rep (lhs t) S, lhs t) \\<in> trm_ord", "have \"((Comb (trm_rep (lhs t) S)  (rhs t)), ((Comb (lhs t) (rhs t))))  \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (trm_rep (lhs t) S, lhs t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep (lhs t) S \\<cdot> rhs t, lhs t \\<cdot> rhs t) \\<in> trm_ord", "using trm_ord_reduction_left"], ["proof (prove)\nusing this:\n  (trm_rep (lhs t) S, lhs t) \\<in> trm_ord\n  \\<forall>x1 x2 y.\n     (x1, x2) \\<in> trm_ord \\<longrightarrow>\n     (x1 \\<cdot> y, x2 \\<cdot> y) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep (lhs t) S \\<cdot> rhs t, lhs t \\<cdot> rhs t) \\<in> trm_ord", "by blast"], ["proof (state)\nthis:\n  (trm_rep (lhs t) S \\<cdot> rhs t, lhs t \\<cdot> rhs t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep (lhs t) S \\<noteq> lhs t \\<Longrightarrow>\n    (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "from this and i"], ["proof (chain)\npicking this:\n  (trm_rep (lhs t) S \\<cdot> rhs t, lhs t \\<cdot> rhs t) \\<in> trm_ord\n  (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S,\n   trm_rep (lhs t) S \\<cdot> rhs t)\n  \\<in> trm_ord", "show \"((Comb (trm_rep (lhs t) S) (trm_rep (rhs t) S)),t)  \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (trm_rep (lhs t) S \\<cdot> rhs t, lhs t \\<cdot> rhs t) \\<in> trm_ord\n  (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S,\n   trm_rep (lhs t) S \\<cdot> rhs t)\n  \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "by (metis assms(2) basic_superposition.subterm_reduction_applicable_def \n            basic_superposition_axioms is_compound.elims(2) lhs.simps(1) rhs.simps(1) \n            trm_ord_trans transE)"], ["proof (state)\nthis:\n  (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The following lemma corresponds to the initial definition of the function \n@{term \"trm_rep\"}.\\<close>"], ["", "lemma trm_rep_init_def:\n  shows \"(trm_rep t) = (\\<lambda>S. (if (subterm_reduction_applicable_aux S t) \n                        then (subterm_reduction_aux S t)\n                        else (get_min t (set_of_candidate_values S t))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trm_rep t =\n    (\\<lambda>S.\n        if subterm_reduction_applicable_aux S t\n        then subterm_reduction_aux S t\n        else get_min t (set_of_candidate_values S t))", "unfolding subterm_reduction_aux_def set_of_candidate_values_def candidate_values_def \n   subterm_reduction_applicable_aux_def maximal_literal_is_unique_def smaller_lits_are_false_def \n   trms_irreducible_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. trm_rep t =\n    (\\<lambda>S.\n        if is_compound t \\<and>\n           (lhs t, t) \\<in> trm_ord \\<and>\n           (rhs t, t) \\<in> trm_ord \\<and>\n           (((lhs t, t) \\<in> trm_ord \\<longrightarrow>\n             trm_rep (lhs t) S \\<noteq> lhs t) \\<or>\n            ((rhs t, t) \\<in> trm_ord \\<longrightarrow>\n             trm_rep (rhs t) S \\<noteq> rhs t))\n        then if (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t)\n                \\<in> trm_ord\n             then trm_rep (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S) S\n             else t\n        else get_min t\n              {pair.\n               \\<exists>z CC C' C s L L' \\<sigma> t' s'.\n                  pair = (z, s) \\<and>\n                  CC \\<in> S \\<and>\n                  t \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n                  (\\<forall>x.\n                      (\\<exists>x'\\<in>trms_ecl CC.\n                          occurs_in x\n                           (x' \\<lhd> \\<sigma>)) \\<longrightarrow>\n                      (x, t) \\<in> trm_ord \\<longrightarrow>\n                      trm_rep x S = x) \\<and>\n                  C' = cl_ecl CC \\<and>\n                  (s, t) \\<in> trm_ord \\<and>\n                  ((s, t) \\<in> trm_ord \\<longrightarrow>\n                   z = trm_rep s S) \\<and>\n                  orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n                  sel C' = {} \\<and>\n                  L' \\<in> C' \\<and>\n                  maximal_literal L C \\<and>\n                  L = subst_lit L' \\<sigma> \\<and>\n                  C = subst_cl C' \\<sigma> \\<and>\n                  ground_clause C \\<and>\n                  t = t' \\<lhd> \\<sigma> \\<and>\n                  s = s' \\<lhd> \\<sigma> \\<and>\n                  finite C' \\<and>\n                  (\\<forall>L u v.\n                      (L \\<in> C \\<longrightarrow>\n                       orient_lit L u v pos \\<longrightarrow>\n                       (u, t) \\<in> trm_ord \\<longrightarrow>\n                       (v, t) \\<in> trm_ord \\<longrightarrow>\n                       trm_rep u S \\<noteq> trm_rep v S) \\<and>\n                      (L \\<in> C \\<longrightarrow>\n                       orient_lit L u v neg \\<longrightarrow>\n                       (u, t) \\<in> trm_ord \\<longrightarrow>\n                       (v, t) \\<in> trm_ord \\<longrightarrow>\n                       trm_rep u S = trm_rep v S)) \\<and>\n                  (\\<forall>s''.\n                      eq_occurs_in_cl t s'' (C' - {L'})\n                       \\<sigma> \\<longrightarrow>\n                      (s'', t) \\<in> trm_ord \\<longrightarrow>\n                      (s, t) \\<in> trm_ord \\<longrightarrow>\n                      trm_rep s S \\<noteq> trm_rep s'' S)})", "using trm_rep.simps [of t]"], ["proof (prove)\nusing this:\n  trm_rep t =\n  (\\<lambda>S.\n      if is_compound t \\<and>\n         (lhs t, t) \\<in> trm_ord \\<and>\n         (rhs t, t) \\<in> trm_ord \\<and>\n         (((lhs t, t) \\<in> trm_ord \\<longrightarrow>\n           trm_rep (lhs t) S \\<noteq> lhs t) \\<or>\n          ((rhs t, t) \\<in> trm_ord \\<longrightarrow>\n           trm_rep (rhs t) S \\<noteq> rhs t))\n      then if (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord\n           then trm_rep (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S) S\n           else t\n      else get_min t\n            {pair.\n             \\<exists>z CC C' C s L L' \\<sigma> t' s'.\n                pair = (z, s) \\<and>\n                CC \\<in> S \\<and>\n                t \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n                (\\<forall>x.\n                    (\\<exists>x'\\<in>trms_ecl CC.\n                        occurs_in x (x' \\<lhd> \\<sigma>)) \\<longrightarrow>\n                    (x, t) \\<in> trm_ord \\<longrightarrow>\n                    trm_rep x S = x) \\<and>\n                C' = cl_ecl CC \\<and>\n                (s, t) \\<in> trm_ord \\<and>\n                ((s, t) \\<in> trm_ord \\<longrightarrow>\n                 z = trm_rep s S) \\<and>\n                orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n                sel C' = {} \\<and>\n                L' \\<in> C' \\<and>\n                maximal_literal L C \\<and>\n                L = subst_lit L' \\<sigma> \\<and>\n                C = subst_cl C' \\<sigma> \\<and>\n                ground_clause C \\<and>\n                t = t' \\<lhd> \\<sigma> \\<and>\n                s = s' \\<lhd> \\<sigma> \\<and>\n                finite C' \\<and>\n                (\\<forall>L u v.\n                    (L \\<in> C \\<longrightarrow>\n                     orient_lit L u v pos \\<longrightarrow>\n                     (u, t) \\<in> trm_ord \\<longrightarrow>\n                     (v, t) \\<in> trm_ord \\<longrightarrow>\n                     trm_rep u S \\<noteq> trm_rep v S) \\<and>\n                    (L \\<in> C \\<longrightarrow>\n                     orient_lit L u v neg \\<longrightarrow>\n                     (u, t) \\<in> trm_ord \\<longrightarrow>\n                     (v, t) \\<in> trm_ord \\<longrightarrow>\n                     trm_rep u S = trm_rep v S)) \\<and>\n                (\\<forall>s''.\n                    eq_occurs_in_cl t s'' (C' - {L'})\n                     \\<sigma> \\<longrightarrow>\n                    (s'', t) \\<in> trm_ord \\<longrightarrow>\n                    (s, t) \\<in> trm_ord \\<longrightarrow>\n                    trm_rep s S \\<noteq> trm_rep s'' S)})\n\ngoal (1 subgoal):\n 1. trm_rep t =\n    (\\<lambda>S.\n        if is_compound t \\<and>\n           (lhs t, t) \\<in> trm_ord \\<and>\n           (rhs t, t) \\<in> trm_ord \\<and>\n           (((lhs t, t) \\<in> trm_ord \\<longrightarrow>\n             trm_rep (lhs t) S \\<noteq> lhs t) \\<or>\n            ((rhs t, t) \\<in> trm_ord \\<longrightarrow>\n             trm_rep (rhs t) S \\<noteq> rhs t))\n        then if (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t)\n                \\<in> trm_ord\n             then trm_rep (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S) S\n             else t\n        else get_min t\n              {pair.\n               \\<exists>z CC C' C s L L' \\<sigma> t' s'.\n                  pair = (z, s) \\<and>\n                  CC \\<in> S \\<and>\n                  t \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n                  (\\<forall>x.\n                      (\\<exists>x'\\<in>trms_ecl CC.\n                          occurs_in x\n                           (x' \\<lhd> \\<sigma>)) \\<longrightarrow>\n                      (x, t) \\<in> trm_ord \\<longrightarrow>\n                      trm_rep x S = x) \\<and>\n                  C' = cl_ecl CC \\<and>\n                  (s, t) \\<in> trm_ord \\<and>\n                  ((s, t) \\<in> trm_ord \\<longrightarrow>\n                   z = trm_rep s S) \\<and>\n                  orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n                  sel C' = {} \\<and>\n                  L' \\<in> C' \\<and>\n                  maximal_literal L C \\<and>\n                  L = subst_lit L' \\<sigma> \\<and>\n                  C = subst_cl C' \\<sigma> \\<and>\n                  ground_clause C \\<and>\n                  t = t' \\<lhd> \\<sigma> \\<and>\n                  s = s' \\<lhd> \\<sigma> \\<and>\n                  finite C' \\<and>\n                  (\\<forall>L u v.\n                      (L \\<in> C \\<longrightarrow>\n                       orient_lit L u v pos \\<longrightarrow>\n                       (u, t) \\<in> trm_ord \\<longrightarrow>\n                       (v, t) \\<in> trm_ord \\<longrightarrow>\n                       trm_rep u S \\<noteq> trm_rep v S) \\<and>\n                      (L \\<in> C \\<longrightarrow>\n                       orient_lit L u v neg \\<longrightarrow>\n                       (u, t) \\<in> trm_ord \\<longrightarrow>\n                       (v, t) \\<in> trm_ord \\<longrightarrow>\n                       trm_rep u S = trm_rep v S)) \\<and>\n                  (\\<forall>s''.\n                      eq_occurs_in_cl t s'' (C' - {L'})\n                       \\<sigma> \\<longrightarrow>\n                      (s'', t) \\<in> trm_ord \\<longrightarrow>\n                      (s, t) \\<in> trm_ord \\<longrightarrow>\n                      trm_rep s S \\<noteq> trm_rep s'' S)})", "by force"], ["", "lemma trm_rep_aux_def:\n  assumes \"\\<forall>y. (y,t) \\<in> trm_ord \\<longrightarrow>\n      (y \\<noteq> (trm_rep y S) \\<longrightarrow> ((trm_rep y S),y) \\<in> trm_ord)\"\n  shows \"(trm_rep t S) = (if (subterm_reduction_applicable S t) \n                        then (subterm_reduction S t)\n                        else (get_min t (set_of_candidate_values S t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trm_rep t S =\n    (if subterm_reduction_applicable S t then subterm_reduction S t\n     else get_min t (set_of_candidate_values S t))", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    trm_rep t S =\n    (if subterm_reduction_applicable S t then subterm_reduction S t\n     else get_min t (set_of_candidate_values S t))\n 2. \\<not> ?P \\<Longrightarrow>\n    trm_rep t S =\n    (if subterm_reduction_applicable S t then subterm_reduction S t\n     else get_min t (set_of_candidate_values S t))", "assume \"subterm_reduction_applicable S t\""], ["proof (state)\nthis:\n  subterm_reduction_applicable S t\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    trm_rep t S =\n    (if subterm_reduction_applicable S t then subterm_reduction S t\n     else get_min t (set_of_candidate_values S t))\n 2. \\<not> ?P \\<Longrightarrow>\n    trm_rep t S =\n    (if subterm_reduction_applicable S t then subterm_reduction S t\n     else get_min t (set_of_candidate_values S t))", "then"], ["proof (chain)\npicking this:\n  subterm_reduction_applicable S t", "have \"subterm_reduction_applicable_aux S t\""], ["proof (prove)\nusing this:\n  subterm_reduction_applicable S t\n\ngoal (1 subgoal):\n 1. subterm_reduction_applicable_aux S t", "using args_are_strictly_lower \n      subterm_reduction_applicable_def subterm_reduction_applicable_aux_def"], ["proof (prove)\nusing this:\n  subterm_reduction_applicable S t\n  is_compound ?t \\<Longrightarrow>\n  (lhs ?t, ?t) \\<in> trm_ord \\<and> (rhs ?t, ?t) \\<in> trm_ord\n  subterm_reduction_applicable ?S ?t =\n  (is_compound ?t \\<and>\n   (trm_rep (lhs ?t) ?S \\<noteq> lhs ?t \\<or>\n    trm_rep (rhs ?t) ?S \\<noteq> rhs ?t))\n  subterm_reduction_applicable_aux ?S ?t =\n  (is_compound ?t \\<and>\n   (lhs ?t, ?t) \\<in> trm_ord \\<and>\n   (rhs ?t, ?t) \\<in> trm_ord \\<and>\n   (((lhs ?t, ?t) \\<in> trm_ord \\<longrightarrow>\n     trm_rep (lhs ?t) ?S \\<noteq> lhs ?t) \\<or>\n    ((rhs ?t, ?t) \\<in> trm_ord \\<longrightarrow>\n     trm_rep (rhs ?t) ?S \\<noteq> rhs ?t)))\n\ngoal (1 subgoal):\n 1. subterm_reduction_applicable_aux S t", "by blast"], ["proof (state)\nthis:\n  subterm_reduction_applicable_aux S t\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    trm_rep t S =\n    (if subterm_reduction_applicable S t then subterm_reduction S t\n     else get_min t (set_of_candidate_values S t))\n 2. \\<not> ?P \\<Longrightarrow>\n    trm_rep t S =\n    (if subterm_reduction_applicable S t then subterm_reduction S t\n     else get_min t (set_of_candidate_values S t))", "from this"], ["proof (chain)\npicking this:\n  subterm_reduction_applicable_aux S t", "have \"(trm_rep t S) = (subterm_reduction_aux S t)\""], ["proof (prove)\nusing this:\n  subterm_reduction_applicable_aux S t\n\ngoal (1 subgoal):\n 1. trm_rep t S = subterm_reduction_aux S t", "using trm_rep_init_def [of t]"], ["proof (prove)\nusing this:\n  subterm_reduction_applicable_aux S t\n  trm_rep t =\n  (\\<lambda>S.\n      if subterm_reduction_applicable_aux S t then subterm_reduction_aux S t\n      else get_min t (set_of_candidate_values S t))\n\ngoal (1 subgoal):\n 1. trm_rep t S = subterm_reduction_aux S t", "by meson"], ["proof (state)\nthis:\n  trm_rep t S = subterm_reduction_aux S t\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    trm_rep t S =\n    (if subterm_reduction_applicable S t then subterm_reduction S t\n     else get_min t (set_of_candidate_values S t))\n 2. \\<not> ?P \\<Longrightarrow>\n    trm_rep t S =\n    (if subterm_reduction_applicable S t then subterm_reduction S t\n     else get_min t (set_of_candidate_values S t))", "then"], ["proof (chain)\npicking this:\n  trm_rep t S = subterm_reduction_aux S t", "have \"((Comb (trm_rep (lhs t) S) (trm_rep (rhs t) S)),t) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  trm_rep t S = subterm_reduction_aux S t\n\ngoal (1 subgoal):\n 1. (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "using \\<open>subterm_reduction_applicable S t\\<close> assms trm_rep_is_lower_aux"], ["proof (prove)\nusing this:\n  trm_rep t S = subterm_reduction_aux S t\n  subterm_reduction_applicable S t\n  \\<forall>y.\n     (y, t) \\<in> trm_ord \\<longrightarrow>\n     y \\<noteq> trm_rep y S \\<longrightarrow> (trm_rep y S, y) \\<in> trm_ord\n  \\<lbrakk>\\<forall>y.\n              (y, ?t) \\<in> trm_ord \\<longrightarrow>\n              y \\<noteq> trm_rep y ?S \\<longrightarrow>\n              (trm_rep y ?S, y) \\<in> trm_ord;\n   subterm_reduction_applicable ?S ?t\\<rbrakk>\n  \\<Longrightarrow> (trm_rep (lhs ?t) ?S \\<cdot> trm_rep (rhs ?t) ?S, ?t)\n                    \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "by blast"], ["proof (state)\nthis:\n  (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    trm_rep t S =\n    (if subterm_reduction_applicable S t then subterm_reduction S t\n     else get_min t (set_of_candidate_values S t))\n 2. \\<not> ?P \\<Longrightarrow>\n    trm_rep t S =\n    (if subterm_reduction_applicable S t then subterm_reduction S t\n     else get_min t (set_of_candidate_values S t))", "then"], ["proof (chain)\npicking this:\n  (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord", "show ?thesis"], ["proof (prove)\nusing this:\n  (trm_rep (lhs t) S \\<cdot> trm_rep (rhs t) S, t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep t S =\n    (if subterm_reduction_applicable S t then subterm_reduction S t\n     else get_min t (set_of_candidate_values S t))", "by (metis \\<open>trm_rep t S = subterm_reduction_aux S t\\<close> \n        \\<open>subterm_reduction_applicable S t\\<close> \n        subterm_reduction_def \n        subterm_reduction_aux_def)"], ["proof (state)\nthis:\n  trm_rep t S =\n  (if subterm_reduction_applicable S t then subterm_reduction S t\n   else get_min t (set_of_candidate_values S t))\n\ngoal (1 subgoal):\n 1. \\<not> subterm_reduction_applicable S t \\<Longrightarrow>\n    trm_rep t S =\n    (if subterm_reduction_applicable S t then subterm_reduction S t\n     else get_min t (set_of_candidate_values S t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> subterm_reduction_applicable S t \\<Longrightarrow>\n    trm_rep t S =\n    (if subterm_reduction_applicable S t then subterm_reduction S t\n     else get_min t (set_of_candidate_values S t))", "assume \"\\<not>subterm_reduction_applicable S t\""], ["proof (state)\nthis:\n  \\<not> subterm_reduction_applicable S t\n\ngoal (1 subgoal):\n 1. \\<not> subterm_reduction_applicable S t \\<Longrightarrow>\n    trm_rep t S =\n    (if subterm_reduction_applicable S t then subterm_reduction S t\n     else get_min t (set_of_candidate_values S t))", "then"], ["proof (chain)\npicking this:\n  \\<not> subterm_reduction_applicable S t", "have \"\\<not>subterm_reduction_applicable_aux S t\""], ["proof (prove)\nusing this:\n  \\<not> subterm_reduction_applicable S t\n\ngoal (1 subgoal):\n 1. \\<not> subterm_reduction_applicable_aux S t", "using subterm_reduction_applicable_def subterm_reduction_applicable_aux_def"], ["proof (prove)\nusing this:\n  \\<not> subterm_reduction_applicable S t\n  subterm_reduction_applicable ?S ?t =\n  (is_compound ?t \\<and>\n   (trm_rep (lhs ?t) ?S \\<noteq> lhs ?t \\<or>\n    trm_rep (rhs ?t) ?S \\<noteq> rhs ?t))\n  subterm_reduction_applicable_aux ?S ?t =\n  (is_compound ?t \\<and>\n   (lhs ?t, ?t) \\<in> trm_ord \\<and>\n   (rhs ?t, ?t) \\<in> trm_ord \\<and>\n   (((lhs ?t, ?t) \\<in> trm_ord \\<longrightarrow>\n     trm_rep (lhs ?t) ?S \\<noteq> lhs ?t) \\<or>\n    ((rhs ?t, ?t) \\<in> trm_ord \\<longrightarrow>\n     trm_rep (rhs ?t) ?S \\<noteq> rhs ?t)))\n\ngoal (1 subgoal):\n 1. \\<not> subterm_reduction_applicable_aux S t", "by blast"], ["proof (state)\nthis:\n  \\<not> subterm_reduction_applicable_aux S t\n\ngoal (1 subgoal):\n 1. \\<not> subterm_reduction_applicable S t \\<Longrightarrow>\n    trm_rep t S =\n    (if subterm_reduction_applicable S t then subterm_reduction S t\n     else get_min t (set_of_candidate_values S t))", "from this and \\<open>\\<not>subterm_reduction_applicable S t\\<close>"], ["proof (chain)\npicking this:\n  \\<not> subterm_reduction_applicable_aux S t\n  \\<not> subterm_reduction_applicable S t", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> subterm_reduction_applicable_aux S t\n  \\<not> subterm_reduction_applicable S t\n\ngoal (1 subgoal):\n 1. trm_rep t S =\n    (if subterm_reduction_applicable S t then subterm_reduction S t\n     else get_min t (set_of_candidate_values S t))", "by (meson trm_rep_init_def)"], ["proof (state)\nthis:\n  trm_rep t S =\n  (if subterm_reduction_applicable S t then subterm_reduction S t\n   else get_min t (set_of_candidate_values S t))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trm_rep_is_lower:  \n  shows \"(t \\<noteq> (trm_rep t S)) \\<longrightarrow> (((trm_rep t S),t) \\<in> trm_ord)\" (is \"?P t\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> trm_rep t S \\<longrightarrow> (trm_rep t S, t) \\<in> trm_ord", "proof ((rule wf_induct [of \"trm_ord\" \"?P\" \"t\"]),(simp add: trm_ord_wf))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> trm_ord \\<longrightarrow>\n          y \\<noteq> trm_rep y S \\<longrightarrow>\n          (trm_rep y S, y) \\<in> trm_ord \\<Longrightarrow>\n       x \\<noteq> trm_rep x S \\<longrightarrow>\n       (trm_rep x S, x) \\<in> trm_ord", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> trm_ord \\<longrightarrow>\n          y \\<noteq> trm_rep y S \\<longrightarrow>\n          (trm_rep y S, y) \\<in> trm_ord \\<Longrightarrow>\n       x \\<noteq> trm_rep x S \\<longrightarrow>\n       (trm_rep x S, x) \\<in> trm_ord", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> trm_ord \\<longrightarrow>\n          y \\<noteq> trm_rep y S \\<longrightarrow>\n          (trm_rep y S, y) \\<in> trm_ord \\<Longrightarrow>\n       x \\<noteq> trm_rep x S \\<longrightarrow>\n       (trm_rep x S, x) \\<in> trm_ord", "assume hyp_ind: \"\\<forall>y. (y,x) \\<in> trm_ord \\<longrightarrow> (?P y)\""], ["proof (state)\nthis:\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     y \\<noteq> trm_rep y S \\<longrightarrow> (trm_rep y S, y) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> trm_ord \\<longrightarrow>\n          y \\<noteq> trm_rep y S \\<longrightarrow>\n          (trm_rep y S, y) \\<in> trm_ord \\<Longrightarrow>\n       x \\<noteq> trm_rep x S \\<longrightarrow>\n       (trm_rep x S, x) \\<in> trm_ord", "let ?v = \"(Comb (trm_rep (lhs x) S) (trm_rep (rhs x) S))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> trm_ord \\<longrightarrow>\n          y \\<noteq> trm_rep y S \\<longrightarrow>\n          (trm_rep y S, y) \\<in> trm_ord \\<Longrightarrow>\n       x \\<noteq> trm_rep x S \\<longrightarrow>\n       (trm_rep x S, x) \\<in> trm_ord", "show \"(?P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> trm_rep x S \\<longrightarrow> (trm_rep x S, x) \\<in> trm_ord", "proof (rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> trm_rep x S \\<Longrightarrow> (trm_rep x S, x) \\<in> trm_ord", "assume \"x \\<noteq> (trm_rep x S)\""], ["proof (state)\nthis:\n  x \\<noteq> trm_rep x S\n\ngoal (1 subgoal):\n 1. x \\<noteq> trm_rep x S \\<Longrightarrow> (trm_rep x S, x) \\<in> trm_ord", "show \"((trm_rep x S),x) \\<in> trm_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (trm_rep x S, x) \\<in> trm_ord", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (trm_rep x S, x) \\<in> trm_ord\n 2. \\<not> ?P \\<Longrightarrow> (trm_rep x S, x) \\<in> trm_ord", "assume c1: \"subterm_reduction_applicable S x\""], ["proof (state)\nthis:\n  subterm_reduction_applicable S x\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (trm_rep x S, x) \\<in> trm_ord\n 2. \\<not> ?P \\<Longrightarrow> (trm_rep x S, x) \\<in> trm_ord", "from this and hyp_ind"], ["proof (chain)\npicking this:\n  subterm_reduction_applicable S x\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     y \\<noteq> trm_rep y S \\<longrightarrow> (trm_rep y S, y) \\<in> trm_ord", "have \"(?v,x) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  subterm_reduction_applicable S x\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     y \\<noteq> trm_rep y S \\<longrightarrow> (trm_rep y S, y) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S, x) \\<in> trm_ord", "using trm_rep_is_lower_aux"], ["proof (prove)\nusing this:\n  subterm_reduction_applicable S x\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     y \\<noteq> trm_rep y S \\<longrightarrow> (trm_rep y S, y) \\<in> trm_ord\n  \\<lbrakk>\\<forall>y.\n              (y, ?t) \\<in> trm_ord \\<longrightarrow>\n              y \\<noteq> trm_rep y ?S \\<longrightarrow>\n              (trm_rep y ?S, y) \\<in> trm_ord;\n   subterm_reduction_applicable ?S ?t\\<rbrakk>\n  \\<Longrightarrow> (trm_rep (lhs ?t) ?S \\<cdot> trm_rep (rhs ?t) ?S, ?t)\n                    \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S, x) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S, x) \\<in> trm_ord\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (trm_rep x S, x) \\<in> trm_ord\n 2. \\<not> ?P \\<Longrightarrow> (trm_rep x S, x) \\<in> trm_ord", "from c1 and hyp_ind"], ["proof (chain)\npicking this:\n  subterm_reduction_applicable S x\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     y \\<noteq> trm_rep y S \\<longrightarrow> (trm_rep y S, y) \\<in> trm_ord", "have \"(trm_rep x S) = (subterm_reduction S x)\""], ["proof (prove)\nusing this:\n  subterm_reduction_applicable S x\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     y \\<noteq> trm_rep y S \\<longrightarrow> (trm_rep y S, y) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep x S = subterm_reduction S x", "using trm_rep_aux_def [of x S]"], ["proof (prove)\nusing this:\n  subterm_reduction_applicable S x\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     y \\<noteq> trm_rep y S \\<longrightarrow> (trm_rep y S, y) \\<in> trm_ord\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     y \\<noteq> trm_rep y S \\<longrightarrow>\n     (trm_rep y S, y) \\<in> trm_ord \\<Longrightarrow>\n  trm_rep x S =\n  (if subterm_reduction_applicable S x then subterm_reduction S x\n   else get_min x (set_of_candidate_values S x))\n\ngoal (1 subgoal):\n 1. trm_rep x S = subterm_reduction S x", "by metis"], ["proof (state)\nthis:\n  trm_rep x S = subterm_reduction S x\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (trm_rep x S, x) \\<in> trm_ord\n 2. \\<not> ?P \\<Longrightarrow> (trm_rep x S, x) \\<in> trm_ord", "from this"], ["proof (chain)\npicking this:\n  trm_rep x S = subterm_reduction S x", "have \"(trm_rep x S) = (trm_rep ?v S)\""], ["proof (prove)\nusing this:\n  trm_rep x S = subterm_reduction S x\n\ngoal (1 subgoal):\n 1. trm_rep x S = trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S", "unfolding subterm_reduction_def"], ["proof (prove)\nusing this:\n  trm_rep x S = trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S\n\ngoal (1 subgoal):\n 1. trm_rep x S = trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S", "by metis"], ["proof (state)\nthis:\n  trm_rep x S = trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (trm_rep x S, x) \\<in> trm_ord\n 2. \\<not> ?P \\<Longrightarrow> (trm_rep x S, x) \\<in> trm_ord", "from \\<open>(?v,x) \\<in> trm_ord\\<close> and hyp_ind"], ["proof (chain)\npicking this:\n  (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S, x) \\<in> trm_ord\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     y \\<noteq> trm_rep y S \\<longrightarrow> (trm_rep y S, y) \\<in> trm_ord", "have \"?P ?v\""], ["proof (prove)\nusing this:\n  (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S, x) \\<in> trm_ord\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     y \\<noteq> trm_rep y S \\<longrightarrow> (trm_rep y S, y) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S \\<noteq>\n    trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S)\n     S \\<longrightarrow>\n    (trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S,\n     trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S)\n    \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S \\<noteq>\n  trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S \\<longrightarrow>\n  (trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S,\n   trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S)\n  \\<in> trm_ord\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> (trm_rep x S, x) \\<in> trm_ord\n 2. \\<not> ?P \\<Longrightarrow> (trm_rep x S, x) \\<in> trm_ord", "from this and \\<open>(trm_rep x S) = (trm_rep ?v S)\\<close>"], ["proof (chain)\npicking this:\n  trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S \\<noteq>\n  trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S \\<longrightarrow>\n  (trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S,\n   trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S)\n  \\<in> trm_ord\n  trm_rep x S = trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S", "show ?thesis"], ["proof (prove)\nusing this:\n  trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S \\<noteq>\n  trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S \\<longrightarrow>\n  (trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S,\n   trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S)\n  \\<in> trm_ord\n  trm_rep x S = trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S\n\ngoal (1 subgoal):\n 1. (trm_rep x S, x) \\<in> trm_ord", "by (metis \\<open>(trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S, x) \\<in> trm_ord\\<close> trm_ord_trans transE)"], ["proof (state)\nthis:\n  (trm_rep x S, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> subterm_reduction_applicable S x \\<Longrightarrow>\n    (trm_rep x S, x) \\<in> trm_ord", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> subterm_reduction_applicable S x \\<Longrightarrow>\n    (trm_rep x S, x) \\<in> trm_ord", "assume c2: \"\\<not>subterm_reduction_applicable S x\""], ["proof (state)\nthis:\n  \\<not> subterm_reduction_applicable S x\n\ngoal (1 subgoal):\n 1. \\<not> subterm_reduction_applicable S x \\<Longrightarrow>\n    (trm_rep x S, x) \\<in> trm_ord", "from c2 and hyp_ind"], ["proof (chain)\npicking this:\n  \\<not> subterm_reduction_applicable S x\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     y \\<noteq> trm_rep y S \\<longrightarrow> (trm_rep y S, y) \\<in> trm_ord", "have \"(trm_rep x S) = (get_min x (set_of_candidate_values S x))\""], ["proof (prove)\nusing this:\n  \\<not> subterm_reduction_applicable S x\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     y \\<noteq> trm_rep y S \\<longrightarrow> (trm_rep y S, y) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep x S = get_min x (set_of_candidate_values S x)", "using trm_rep_aux_def [of x S]"], ["proof (prove)\nusing this:\n  \\<not> subterm_reduction_applicable S x\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     y \\<noteq> trm_rep y S \\<longrightarrow> (trm_rep y S, y) \\<in> trm_ord\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     y \\<noteq> trm_rep y S \\<longrightarrow>\n     (trm_rep y S, y) \\<in> trm_ord \\<Longrightarrow>\n  trm_rep x S =\n  (if subterm_reduction_applicable S x then subterm_reduction S x\n   else get_min x (set_of_candidate_values S x))\n\ngoal (1 subgoal):\n 1. trm_rep x S = get_min x (set_of_candidate_values S x)", "by metis"], ["proof (state)\nthis:\n  trm_rep x S = get_min x (set_of_candidate_values S x)\n\ngoal (1 subgoal):\n 1. \\<not> subterm_reduction_applicable S x \\<Longrightarrow>\n    (trm_rep x S, x) \\<in> trm_ord", "from this and \\<open>x \\<noteq> (trm_rep x S)\\<close>"], ["proof (chain)\npicking this:\n  trm_rep x S = get_min x (set_of_candidate_values S x)\n  x \\<noteq> trm_rep x S", "have \"(trm_rep x S) \\<in> (min_trms (set_of_candidate_values S x))\""], ["proof (prove)\nusing this:\n  trm_rep x S = get_min x (set_of_candidate_values S x)\n  x \\<noteq> trm_rep x S\n\ngoal (1 subgoal):\n 1. trm_rep x S \\<in> min_trms (set_of_candidate_values S x)", "unfolding get_min_def"], ["proof (prove)\nusing this:\n  trm_rep x S =\n  (if min_trms (set_of_candidate_values S x) = {} then x\n   else SOME xa. xa \\<in> min_trms (set_of_candidate_values S x))\n  x \\<noteq> trm_rep x S\n\ngoal (1 subgoal):\n 1. trm_rep x S \\<in> min_trms (set_of_candidate_values S x)", "by (metis (full_types) some_in_eq)"], ["proof (state)\nthis:\n  trm_rep x S \\<in> min_trms (set_of_candidate_values S x)\n\ngoal (1 subgoal):\n 1. \\<not> subterm_reduction_applicable S x \\<Longrightarrow>\n    (trm_rep x S, x) \\<in> trm_ord", "then"], ["proof (chain)\npicking this:\n  trm_rep x S \\<in> min_trms (set_of_candidate_values S x)", "obtain pair where  \"pair \\<in> (set_of_candidate_values S x)\" \"(trm_rep x S) = fst pair\""], ["proof (prove)\nusing this:\n  trm_rep x S \\<in> min_trms (set_of_candidate_values S x)\n\ngoal (1 subgoal):\n 1. (\\<And>pair.\n        \\<lbrakk>pair \\<in> set_of_candidate_values S x;\n         trm_rep x S = fst pair\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding min_trms_def"], ["proof (prove)\nusing this:\n  trm_rep x S\n  \\<in> {xa.\n         \\<exists>pair.\n            (pair \\<in> set_of_candidate_values S x \\<and>\n             (\\<forall>pair'\\<in>set_of_candidate_values S x.\n                 (snd pair', snd pair) \\<notin> trm_ord)) \\<and>\n            xa = fst pair}\n\ngoal (1 subgoal):\n 1. (\\<And>pair.\n        \\<lbrakk>pair \\<in> set_of_candidate_values S x;\n         trm_rep x S = fst pair\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  pair \\<in> set_of_candidate_values S x\n  trm_rep x S = fst pair\n\ngoal (1 subgoal):\n 1. \\<not> subterm_reduction_applicable S x \\<Longrightarrow>\n    (trm_rep x S, x) \\<in> trm_ord", "from \\<open>pair \\<in> (set_of_candidate_values S x)\\<close>"], ["proof (chain)\npicking this:\n  pair \\<in> set_of_candidate_values S x", "have \n          \"\\<exists> CC C' C  L L' \\<sigma> t' s'. candidate_values (fst pair) CC C' C (snd pair) L L' \\<sigma> t' s' x S\""], ["proof (prove)\nusing this:\n  pair \\<in> set_of_candidate_values S x\n\ngoal (1 subgoal):\n 1. \\<exists>CC C' C L L' \\<sigma> t' s'.\n       candidate_values (fst pair) CC C' C (snd pair) L L' \\<sigma> t' s' x\n        S", "unfolding set_of_candidate_values_def"], ["proof (prove)\nusing this:\n  pair\n  \\<in> {pair.\n         \\<exists>z CC C' C s L L' \\<sigma> t' s'.\n            pair = (z, s) \\<and>\n            candidate_values z CC C' C s L L' \\<sigma> t' s' x S}\n\ngoal (1 subgoal):\n 1. \\<exists>CC C' C L L' \\<sigma> t' s'.\n       candidate_values (fst pair) CC C' C (snd pair) L L' \\<sigma> t' s' x\n        S", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>CC C' C L L' \\<sigma> t' s'.\n     candidate_values (fst pair) CC C' C (snd pair) L L' \\<sigma> t' s' x S\n\ngoal (1 subgoal):\n 1. \\<not> subterm_reduction_applicable S x \\<Longrightarrow>\n    (trm_rep x S, x) \\<in> trm_ord", "from this"], ["proof (chain)\npicking this:\n  \\<exists>CC C' C L L' \\<sigma> t' s'.\n     candidate_values (fst pair) CC C' C (snd pair) L L' \\<sigma> t' s' x S", "have \"(snd pair,x) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  \\<exists>CC C' C L L' \\<sigma> t' s'.\n     candidate_values (fst pair) CC C' C (snd pair) L L' \\<sigma> t' s' x S\n\ngoal (1 subgoal):\n 1. (snd pair, x) \\<in> trm_ord", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  \\<exists>CC C' C L L' \\<sigma> t' s'.\n     CC \\<in> S \\<and>\n     x \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n     trms_irreducible CC \\<sigma> S x \\<and>\n     C' = cl_ecl CC \\<and>\n     (snd pair, x) \\<in> trm_ord \\<and>\n     ((snd pair, x) \\<in> trm_ord \\<longrightarrow>\n      fst pair = trm_rep (snd pair) S) \\<and>\n     orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n     sel C' = {} \\<and>\n     L' \\<in> C' \\<and>\n     maximal_literal L C \\<and>\n     L = subst_lit L' \\<sigma> \\<and>\n     C = subst_cl C' \\<sigma> \\<and>\n     ground_clause C \\<and>\n     x = t' \\<lhd> \\<sigma> \\<and>\n     snd pair = s' \\<lhd> \\<sigma> \\<and>\n     finite C' \\<and>\n     smaller_lits_are_false x C S \\<and>\n     maximal_literal_is_unique x (snd pair) C' L' S \\<sigma>\n\ngoal (1 subgoal):\n 1. (snd pair, x) \\<in> trm_ord", "by blast"], ["proof (state)\nthis:\n  (snd pair, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> subterm_reduction_applicable S x \\<Longrightarrow>\n    (trm_rep x S, x) \\<in> trm_ord", "from \n          \\<open>\\<exists> CC C' C  L L' \\<sigma> t' s'. candidate_values (fst pair) CC C' C (snd pair) L L' \\<sigma> t' s' x S\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>CC C' C L L' \\<sigma> t' s'.\n     candidate_values (fst pair) CC C' C (snd pair) L L' \\<sigma> t' s' x S", "have \"((snd pair, x) \\<in> trm_ord \\<longrightarrow> fst pair = trm_rep (snd pair) S)\""], ["proof (prove)\nusing this:\n  \\<exists>CC C' C L L' \\<sigma> t' s'.\n     candidate_values (fst pair) CC C' C (snd pair) L L' \\<sigma> t' s' x S\n\ngoal (1 subgoal):\n 1. (snd pair, x) \\<in> trm_ord \\<longrightarrow>\n    fst pair = trm_rep (snd pair) S", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  \\<exists>CC C' C L L' \\<sigma> t' s'.\n     CC \\<in> S \\<and>\n     x \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n     trms_irreducible CC \\<sigma> S x \\<and>\n     C' = cl_ecl CC \\<and>\n     (snd pair, x) \\<in> trm_ord \\<and>\n     ((snd pair, x) \\<in> trm_ord \\<longrightarrow>\n      fst pair = trm_rep (snd pair) S) \\<and>\n     orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n     sel C' = {} \\<and>\n     L' \\<in> C' \\<and>\n     maximal_literal L C \\<and>\n     L = subst_lit L' \\<sigma> \\<and>\n     C = subst_cl C' \\<sigma> \\<and>\n     ground_clause C \\<and>\n     x = t' \\<lhd> \\<sigma> \\<and>\n     snd pair = s' \\<lhd> \\<sigma> \\<and>\n     finite C' \\<and>\n     smaller_lits_are_false x C S \\<and>\n     maximal_literal_is_unique x (snd pair) C' L' S \\<sigma>\n\ngoal (1 subgoal):\n 1. (snd pair, x) \\<in> trm_ord \\<longrightarrow>\n    fst pair = trm_rep (snd pair) S", "by blast"], ["proof (state)\nthis:\n  (snd pair, x) \\<in> trm_ord \\<longrightarrow>\n  fst pair = trm_rep (snd pair) S\n\ngoal (1 subgoal):\n 1. \\<not> subterm_reduction_applicable S x \\<Longrightarrow>\n    (trm_rep x S, x) \\<in> trm_ord", "from \\<open>(snd pair,x) \\<in> trm_ord\\<close> \\<open>((snd pair, x) \\<in> trm_ord \\<longrightarrow> fst pair = trm_rep (snd pair) S)\\<close>"], ["proof (chain)\npicking this:\n  (snd pair, x) \\<in> trm_ord\n  (snd pair, x) \\<in> trm_ord \\<longrightarrow>\n  fst pair = trm_rep (snd pair) S", "have \"fst pair = trm_rep (snd pair) S\""], ["proof (prove)\nusing this:\n  (snd pair, x) \\<in> trm_ord\n  (snd pair, x) \\<in> trm_ord \\<longrightarrow>\n  fst pair = trm_rep (snd pair) S\n\ngoal (1 subgoal):\n 1. fst pair = trm_rep (snd pair) S", "by blast"], ["proof (state)\nthis:\n  fst pair = trm_rep (snd pair) S\n\ngoal (1 subgoal):\n 1. \\<not> subterm_reduction_applicable S x \\<Longrightarrow>\n    (trm_rep x S, x) \\<in> trm_ord", "from \\<open>(snd pair,x) \\<in> trm_ord\\<close> and hyp_ind"], ["proof (chain)\npicking this:\n  (snd pair, x) \\<in> trm_ord\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     y \\<noteq> trm_rep y S \\<longrightarrow> (trm_rep y S, y) \\<in> trm_ord", "have \"(?P (snd pair))\""], ["proof (prove)\nusing this:\n  (snd pair, x) \\<in> trm_ord\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     y \\<noteq> trm_rep y S \\<longrightarrow> (trm_rep y S, y) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. snd pair \\<noteq> trm_rep (snd pair) S \\<longrightarrow>\n    (trm_rep (snd pair) S, snd pair) \\<in> trm_ord", "by blast"], ["proof (state)\nthis:\n  snd pair \\<noteq> trm_rep (snd pair) S \\<longrightarrow>\n  (trm_rep (snd pair) S, snd pair) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> subterm_reduction_applicable S x \\<Longrightarrow>\n    (trm_rep x S, x) \\<in> trm_ord", "from this and \\<open>fst pair = (trm_rep (snd pair) S)\\<close>"], ["proof (chain)\npicking this:\n  snd pair \\<noteq> trm_rep (snd pair) S \\<longrightarrow>\n  (trm_rep (snd pair) S, snd pair) \\<in> trm_ord\n  fst pair = trm_rep (snd pair) S", "have \"fst pair = snd pair \\<or> (fst pair,snd pair) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  snd pair \\<noteq> trm_rep (snd pair) S \\<longrightarrow>\n  (trm_rep (snd pair) S, snd pair) \\<in> trm_ord\n  fst pair = trm_rep (snd pair) S\n\ngoal (1 subgoal):\n 1. fst pair = snd pair \\<or> (fst pair, snd pair) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  fst pair = snd pair \\<or> (fst pair, snd pair) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> subterm_reduction_applicable S x \\<Longrightarrow>\n    (trm_rep x S, x) \\<in> trm_ord", "from this and \\<open>(trm_rep x S) = fst pair\\<close> and \\<open>(snd pair,x) \\<in> trm_ord\\<close> \\<open>x \\<noteq> (trm_rep x S)\\<close>"], ["proof (chain)\npicking this:\n  fst pair = snd pair \\<or> (fst pair, snd pair) \\<in> trm_ord\n  trm_rep x S = fst pair\n  (snd pair, x) \\<in> trm_ord\n  x \\<noteq> trm_rep x S", "show ?thesis"], ["proof (prove)\nusing this:\n  fst pair = snd pair \\<or> (fst pair, snd pair) \\<in> trm_ord\n  trm_rep x S = fst pair\n  (snd pair, x) \\<in> trm_ord\n  x \\<noteq> trm_rep x S\n\ngoal (1 subgoal):\n 1. (trm_rep x S, x) \\<in> trm_ord", "by (metis trm_ord_trans transD)"], ["proof (state)\nthis:\n  (trm_rep x S, x) \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (trm_rep x S, x) \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<noteq> trm_rep x S \\<longrightarrow> (trm_rep x S, x) \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trm_rep_is_lower_subt_red:  \n  assumes \"(subterm_reduction_applicable S x)\"\n  shows \"((trm_rep x S),x) \\<in> trm_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (trm_rep x S, x) \\<in> trm_ord", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (trm_rep x S, x) \\<in> trm_ord", "let ?v = \"(Comb (trm_rep (lhs x) S) (trm_rep (rhs x) S))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (trm_rep x S, x) \\<in> trm_ord", "from assms(1)"], ["proof (chain)\npicking this:\n  subterm_reduction_applicable S x", "have \"(?v,x) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  subterm_reduction_applicable S x\n\ngoal (1 subgoal):\n 1. (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S, x) \\<in> trm_ord", "using trm_rep_is_lower_aux trm_rep_is_lower"], ["proof (prove)\nusing this:\n  subterm_reduction_applicable S x\n  \\<lbrakk>\\<forall>y.\n              (y, ?t) \\<in> trm_ord \\<longrightarrow>\n              y \\<noteq> trm_rep y ?S \\<longrightarrow>\n              (trm_rep y ?S, y) \\<in> trm_ord;\n   subterm_reduction_applicable ?S ?t\\<rbrakk>\n  \\<Longrightarrow> (trm_rep (lhs ?t) ?S \\<cdot> trm_rep (rhs ?t) ?S, ?t)\n                    \\<in> trm_ord\n  ?t \\<noteq> trm_rep ?t ?S \\<longrightarrow>\n  (trm_rep ?t ?S, ?t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S, x) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep x S, x) \\<in> trm_ord", "from assms(1)"], ["proof (chain)\npicking this:\n  subterm_reduction_applicable S x", "have \"(trm_rep x S) = (subterm_reduction S x)\""], ["proof (prove)\nusing this:\n  subterm_reduction_applicable S x\n\ngoal (1 subgoal):\n 1. trm_rep x S = subterm_reduction S x", "using trm_rep_aux_def [of x S] trm_rep_is_lower"], ["proof (prove)\nusing this:\n  subterm_reduction_applicable S x\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     y \\<noteq> trm_rep y S \\<longrightarrow>\n     (trm_rep y S, y) \\<in> trm_ord \\<Longrightarrow>\n  trm_rep x S =\n  (if subterm_reduction_applicable S x then subterm_reduction S x\n   else get_min x (set_of_candidate_values S x))\n  ?t \\<noteq> trm_rep ?t ?S \\<longrightarrow>\n  (trm_rep ?t ?S, ?t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep x S = subterm_reduction S x", "by metis"], ["proof (state)\nthis:\n  trm_rep x S = subterm_reduction S x\n\ngoal (1 subgoal):\n 1. (trm_rep x S, x) \\<in> trm_ord", "from this"], ["proof (chain)\npicking this:\n  trm_rep x S = subterm_reduction S x", "have \"(trm_rep x S) = (trm_rep ?v S)\""], ["proof (prove)\nusing this:\n  trm_rep x S = subterm_reduction S x\n\ngoal (1 subgoal):\n 1. trm_rep x S = trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S", "unfolding subterm_reduction_def"], ["proof (prove)\nusing this:\n  trm_rep x S = trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S\n\ngoal (1 subgoal):\n 1. trm_rep x S = trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S", "by metis"], ["proof (state)\nthis:\n  trm_rep x S = trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S\n\ngoal (1 subgoal):\n 1. (trm_rep x S, x) \\<in> trm_ord", "have \"?v = trm_rep ?v S \\<or> (trm_rep ?v S,?v) \\<in> trm_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S =\n    trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S \\<or>\n    (trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S,\n     trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S)\n    \\<in> trm_ord", "using trm_rep_is_lower"], ["proof (prove)\nusing this:\n  ?t \\<noteq> trm_rep ?t ?S \\<longrightarrow>\n  (trm_rep ?t ?S, ?t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S =\n    trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S \\<or>\n    (trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S,\n     trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S)\n    \\<in> trm_ord", "by blast"], ["proof (state)\nthis:\n  trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S =\n  trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S \\<or>\n  (trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S,\n   trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S)\n  \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep x S, x) \\<in> trm_ord", "from this and \\<open>(trm_rep x S) = (trm_rep ?v S)\\<close>"], ["proof (chain)\npicking this:\n  trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S =\n  trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S \\<or>\n  (trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S,\n   trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S)\n  \\<in> trm_ord\n  trm_rep x S = trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S", "show \"(((trm_rep x S),x) \\<in> trm_ord)\""], ["proof (prove)\nusing this:\n  trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S =\n  trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S \\<or>\n  (trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S,\n   trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S)\n  \\<in> trm_ord\n  trm_rep x S = trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S\n\ngoal (1 subgoal):\n 1. (trm_rep x S, x) \\<in> trm_ord", "by (metis \\<open>(trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S, x) \\<in> trm_ord\\<close> trm_ord_trans transE)"], ["proof (state)\nthis:\n  (trm_rep x S, x) \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trm_rep_is_lower_root_red:  \n  assumes \"\\<not>(subterm_reduction_applicable S x)\"\n  assumes \"min_trms (set_of_candidate_values S x) \\<noteq> {}\"\n  shows \"(((trm_rep x S),x) \\<in> trm_ord)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (trm_rep x S, x) \\<in> trm_ord", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (trm_rep x S, x) \\<in> trm_ord", "from assms(1)"], ["proof (chain)\npicking this:\n  \\<not> subterm_reduction_applicable S x", "have \"(trm_rep x S) = (get_min x (set_of_candidate_values S x))\""], ["proof (prove)\nusing this:\n  \\<not> subterm_reduction_applicable S x\n\ngoal (1 subgoal):\n 1. trm_rep x S = get_min x (set_of_candidate_values S x)", "using trm_rep_aux_def [of x S] trm_rep_is_lower"], ["proof (prove)\nusing this:\n  \\<not> subterm_reduction_applicable S x\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     y \\<noteq> trm_rep y S \\<longrightarrow>\n     (trm_rep y S, y) \\<in> trm_ord \\<Longrightarrow>\n  trm_rep x S =\n  (if subterm_reduction_applicable S x then subterm_reduction S x\n   else get_min x (set_of_candidate_values S x))\n  ?t \\<noteq> trm_rep ?t ?S \\<longrightarrow>\n  (trm_rep ?t ?S, ?t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep x S = get_min x (set_of_candidate_values S x)", "by metis"], ["proof (state)\nthis:\n  trm_rep x S = get_min x (set_of_candidate_values S x)\n\ngoal (1 subgoal):\n 1. (trm_rep x S, x) \\<in> trm_ord", "from this and assms(2)"], ["proof (chain)\npicking this:\n  trm_rep x S = get_min x (set_of_candidate_values S x)\n  min_trms (set_of_candidate_values S x) \\<noteq> {}", "have \"(trm_rep x S) \\<in> (min_trms (set_of_candidate_values S x))\""], ["proof (prove)\nusing this:\n  trm_rep x S = get_min x (set_of_candidate_values S x)\n  min_trms (set_of_candidate_values S x) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. trm_rep x S \\<in> min_trms (set_of_candidate_values S x)", "unfolding get_min_def"], ["proof (prove)\nusing this:\n  trm_rep x S =\n  (if min_trms (set_of_candidate_values S x) = {} then x\n   else SOME xa. xa \\<in> min_trms (set_of_candidate_values S x))\n  min_trms (set_of_candidate_values S x) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. trm_rep x S \\<in> min_trms (set_of_candidate_values S x)", "by (metis (full_types) some_in_eq)"], ["proof (state)\nthis:\n  trm_rep x S \\<in> min_trms (set_of_candidate_values S x)\n\ngoal (1 subgoal):\n 1. (trm_rep x S, x) \\<in> trm_ord", "then"], ["proof (chain)\npicking this:\n  trm_rep x S \\<in> min_trms (set_of_candidate_values S x)", "obtain pair where  \"pair \\<in> (set_of_candidate_values S x)\" and \"(trm_rep x S) = fst pair\""], ["proof (prove)\nusing this:\n  trm_rep x S \\<in> min_trms (set_of_candidate_values S x)\n\ngoal (1 subgoal):\n 1. (\\<And>pair.\n        \\<lbrakk>pair \\<in> set_of_candidate_values S x;\n         trm_rep x S = fst pair\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding min_trms_def"], ["proof (prove)\nusing this:\n  trm_rep x S\n  \\<in> {xa.\n         \\<exists>pair.\n            (pair \\<in> set_of_candidate_values S x \\<and>\n             (\\<forall>pair'\\<in>set_of_candidate_values S x.\n                 (snd pair', snd pair) \\<notin> trm_ord)) \\<and>\n            xa = fst pair}\n\ngoal (1 subgoal):\n 1. (\\<And>pair.\n        \\<lbrakk>pair \\<in> set_of_candidate_values S x;\n         trm_rep x S = fst pair\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  pair \\<in> set_of_candidate_values S x\n  trm_rep x S = fst pair\n\ngoal (1 subgoal):\n 1. (trm_rep x S, x) \\<in> trm_ord", "from \\<open>pair \\<in> (set_of_candidate_values S x)\\<close>"], ["proof (chain)\npicking this:\n  pair \\<in> set_of_candidate_values S x", "have \"\\<exists> CC C' C  L L' \\<sigma> t' s'. candidate_values (fst pair) CC C' C (snd pair) L L' \\<sigma> t' s' x S\""], ["proof (prove)\nusing this:\n  pair \\<in> set_of_candidate_values S x\n\ngoal (1 subgoal):\n 1. \\<exists>CC C' C L L' \\<sigma> t' s'.\n       candidate_values (fst pair) CC C' C (snd pair) L L' \\<sigma> t' s' x\n        S", "unfolding set_of_candidate_values_def"], ["proof (prove)\nusing this:\n  pair\n  \\<in> {pair.\n         \\<exists>z CC C' C s L L' \\<sigma> t' s'.\n            pair = (z, s) \\<and>\n            candidate_values z CC C' C s L L' \\<sigma> t' s' x S}\n\ngoal (1 subgoal):\n 1. \\<exists>CC C' C L L' \\<sigma> t' s'.\n       candidate_values (fst pair) CC C' C (snd pair) L L' \\<sigma> t' s' x\n        S", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>CC C' C L L' \\<sigma> t' s'.\n     candidate_values (fst pair) CC C' C (snd pair) L L' \\<sigma> t' s' x S\n\ngoal (1 subgoal):\n 1. (trm_rep x S, x) \\<in> trm_ord", "from this"], ["proof (chain)\npicking this:\n  \\<exists>CC C' C L L' \\<sigma> t' s'.\n     candidate_values (fst pair) CC C' C (snd pair) L L' \\<sigma> t' s' x S", "have \"(snd pair,x) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  \\<exists>CC C' C L L' \\<sigma> t' s'.\n     candidate_values (fst pair) CC C' C (snd pair) L L' \\<sigma> t' s' x S\n\ngoal (1 subgoal):\n 1. (snd pair, x) \\<in> trm_ord", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  \\<exists>CC C' C L L' \\<sigma> t' s'.\n     CC \\<in> S \\<and>\n     x \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n     trms_irreducible CC \\<sigma> S x \\<and>\n     C' = cl_ecl CC \\<and>\n     (snd pair, x) \\<in> trm_ord \\<and>\n     ((snd pair, x) \\<in> trm_ord \\<longrightarrow>\n      fst pair = trm_rep (snd pair) S) \\<and>\n     orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n     sel C' = {} \\<and>\n     L' \\<in> C' \\<and>\n     maximal_literal L C \\<and>\n     L = subst_lit L' \\<sigma> \\<and>\n     C = subst_cl C' \\<sigma> \\<and>\n     ground_clause C \\<and>\n     x = t' \\<lhd> \\<sigma> \\<and>\n     snd pair = s' \\<lhd> \\<sigma> \\<and>\n     finite C' \\<and>\n     smaller_lits_are_false x C S \\<and>\n     maximal_literal_is_unique x (snd pair) C' L' S \\<sigma>\n\ngoal (1 subgoal):\n 1. (snd pair, x) \\<in> trm_ord", "by blast"], ["proof (state)\nthis:\n  (snd pair, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep x S, x) \\<in> trm_ord", "from \\<open>\\<exists> CC C' C  L L' \\<sigma> t' s'. candidate_values (fst pair) CC C' C (snd pair) L L' \\<sigma> t' s' x S\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>CC C' C L L' \\<sigma> t' s'.\n     candidate_values (fst pair) CC C' C (snd pair) L L' \\<sigma> t' s' x S", "have \"((snd pair, x) \\<in> trm_ord \\<longrightarrow> fst pair = trm_rep (snd pair) S)\""], ["proof (prove)\nusing this:\n  \\<exists>CC C' C L L' \\<sigma> t' s'.\n     candidate_values (fst pair) CC C' C (snd pair) L L' \\<sigma> t' s' x S\n\ngoal (1 subgoal):\n 1. (snd pair, x) \\<in> trm_ord \\<longrightarrow>\n    fst pair = trm_rep (snd pair) S", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  \\<exists>CC C' C L L' \\<sigma> t' s'.\n     CC \\<in> S \\<and>\n     x \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n     trms_irreducible CC \\<sigma> S x \\<and>\n     C' = cl_ecl CC \\<and>\n     (snd pair, x) \\<in> trm_ord \\<and>\n     ((snd pair, x) \\<in> trm_ord \\<longrightarrow>\n      fst pair = trm_rep (snd pair) S) \\<and>\n     orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n     sel C' = {} \\<and>\n     L' \\<in> C' \\<and>\n     maximal_literal L C \\<and>\n     L = subst_lit L' \\<sigma> \\<and>\n     C = subst_cl C' \\<sigma> \\<and>\n     ground_clause C \\<and>\n     x = t' \\<lhd> \\<sigma> \\<and>\n     snd pair = s' \\<lhd> \\<sigma> \\<and>\n     finite C' \\<and>\n     smaller_lits_are_false x C S \\<and>\n     maximal_literal_is_unique x (snd pair) C' L' S \\<sigma>\n\ngoal (1 subgoal):\n 1. (snd pair, x) \\<in> trm_ord \\<longrightarrow>\n    fst pair = trm_rep (snd pair) S", "by blast"], ["proof (state)\nthis:\n  (snd pair, x) \\<in> trm_ord \\<longrightarrow>\n  fst pair = trm_rep (snd pair) S\n\ngoal (1 subgoal):\n 1. (trm_rep x S, x) \\<in> trm_ord", "from \\<open>(snd pair,x) \\<in> trm_ord\\<close> and \\<open>((snd pair, x) \\<in> trm_ord \\<longrightarrow> fst pair = trm_rep (snd pair) S)\\<close>"], ["proof (chain)\npicking this:\n  (snd pair, x) \\<in> trm_ord\n  (snd pair, x) \\<in> trm_ord \\<longrightarrow>\n  fst pair = trm_rep (snd pair) S", "have \"fst pair = trm_rep (snd pair) S\""], ["proof (prove)\nusing this:\n  (snd pair, x) \\<in> trm_ord\n  (snd pair, x) \\<in> trm_ord \\<longrightarrow>\n  fst pair = trm_rep (snd pair) S\n\ngoal (1 subgoal):\n 1. fst pair = trm_rep (snd pair) S", "by blast"], ["proof (state)\nthis:\n  fst pair = trm_rep (snd pair) S\n\ngoal (1 subgoal):\n 1. (trm_rep x S, x) \\<in> trm_ord", "have \"snd pair = trm_rep (snd pair) S \\<or> (trm_rep (snd pair) S,snd pair) \\<in> trm_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd pair = trm_rep (snd pair) S \\<or>\n    (trm_rep (snd pair) S, snd pair) \\<in> trm_ord", "using trm_rep_is_lower"], ["proof (prove)\nusing this:\n  ?t \\<noteq> trm_rep ?t ?S \\<longrightarrow>\n  (trm_rep ?t ?S, ?t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. snd pair = trm_rep (snd pair) S \\<or>\n    (trm_rep (snd pair) S, snd pair) \\<in> trm_ord", "by blast"], ["proof (state)\nthis:\n  snd pair = trm_rep (snd pair) S \\<or>\n  (trm_rep (snd pair) S, snd pair) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep x S, x) \\<in> trm_ord", "from this and \\<open>(snd pair,x) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  snd pair = trm_rep (snd pair) S \\<or>\n  (trm_rep (snd pair) S, snd pair) \\<in> trm_ord\n  (snd pair, x) \\<in> trm_ord", "have \"(trm_rep (snd pair) S,x) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  snd pair = trm_rep (snd pair) S \\<or>\n  (trm_rep (snd pair) S, snd pair) \\<in> trm_ord\n  (snd pair, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep (snd pair) S, x) \\<in> trm_ord", "using trm_ord_trans trans_def"], ["proof (prove)\nusing this:\n  snd pair = trm_rep (snd pair) S \\<or>\n  (trm_rep (snd pair) S, snd pair) \\<in> trm_ord\n  (snd pair, x) \\<in> trm_ord\n  trans trm_ord\n  trans ?r =\n  (\\<forall>x y z.\n      (x, y) \\<in> ?r \\<longrightarrow>\n      (y, z) \\<in> ?r \\<longrightarrow> (x, z) \\<in> ?r)\n\ngoal (1 subgoal):\n 1. (trm_rep (snd pair) S, x) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (trm_rep (snd pair) S, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep x S, x) \\<in> trm_ord", "from this and \\<open>(trm_rep x S) = fst pair\\<close> and \\<open>fst pair = trm_rep (snd pair) S\\<close>"], ["proof (chain)\npicking this:\n  (trm_rep (snd pair) S, x) \\<in> trm_ord\n  trm_rep x S = fst pair\n  fst pair = trm_rep (snd pair) S", "show ?thesis"], ["proof (prove)\nusing this:\n  (trm_rep (snd pair) S, x) \\<in> trm_ord\n  trm_rep x S = fst pair\n  fst pair = trm_rep (snd pair) S\n\ngoal (1 subgoal):\n 1. (trm_rep x S, x) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (trm_rep x S, x) \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Finally, the next lemma gives a simpler and more convenient definition \nof the function @{term \"trm_rep\"}.\\<close>"], ["", "lemma trm_rep_simp_def:\n  shows \"(trm_rep t S) = (if (subterm_reduction_applicable S t) \n                        then (subterm_reduction S t)\n                        else (get_min t (set_of_candidate_values S t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trm_rep t S =\n    (if subterm_reduction_applicable S t then subterm_reduction S t\n     else get_min t (set_of_candidate_values S t))", "using trm_rep_is_lower  trm_rep_aux_def"], ["proof (prove)\nusing this:\n  ?t \\<noteq> trm_rep ?t ?S \\<longrightarrow>\n  (trm_rep ?t ?S, ?t) \\<in> trm_ord\n  \\<forall>y.\n     (y, ?t) \\<in> trm_ord \\<longrightarrow>\n     y \\<noteq> trm_rep y ?S \\<longrightarrow>\n     (trm_rep y ?S, y) \\<in> trm_ord \\<Longrightarrow>\n  trm_rep ?t ?S =\n  (if subterm_reduction_applicable ?S ?t then subterm_reduction ?S ?t\n   else get_min ?t (set_of_candidate_values ?S ?t))\n\ngoal (1 subgoal):\n 1. trm_rep t S =\n    (if subterm_reduction_applicable S t then subterm_reduction S t\n     else get_min t (set_of_candidate_values S t))", "by blast"], ["", "text \\<open>We now establish some useful properties of the normalization function.\\<close>"], ["", "lemma trm_rep_involutive:  \n  shows \"(trm_rep (trm_rep t S) S) = (trm_rep t S)\" (is \"?P t\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. trm_rep (trm_rep t S) S = trm_rep t S", "proof ((rule wf_induct [of \"trm_ord\" \"?P\" \"t\"]),(simp add: trm_ord_wf))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> trm_ord \\<longrightarrow>\n          trm_rep (trm_rep y S) S = trm_rep y S \\<Longrightarrow>\n       trm_rep (trm_rep x S) S = trm_rep x S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> trm_ord \\<longrightarrow>\n          trm_rep (trm_rep y S) S = trm_rep y S \\<Longrightarrow>\n       trm_rep (trm_rep x S) S = trm_rep x S", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> trm_ord \\<longrightarrow>\n          trm_rep (trm_rep y S) S = trm_rep y S \\<Longrightarrow>\n       trm_rep (trm_rep x S) S = trm_rep x S", "assume hyp_ind: \"\\<forall>y. (y,x) \\<in> trm_ord \\<longrightarrow> (?P y)\""], ["proof (state)\nthis:\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     trm_rep (trm_rep y S) S = trm_rep y S\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> trm_ord \\<longrightarrow>\n          trm_rep (trm_rep y S) S = trm_rep y S \\<Longrightarrow>\n       trm_rep (trm_rep x S) S = trm_rep x S", "let ?v = \"(Comb (trm_rep (lhs x) S) (trm_rep (rhs x) S))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> trm_ord \\<longrightarrow>\n          trm_rep (trm_rep y S) S = trm_rep y S \\<Longrightarrow>\n       trm_rep (trm_rep x S) S = trm_rep x S", "show \"(?P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trm_rep (trm_rep x S) S = trm_rep x S", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> trm_rep (trm_rep x S) S = trm_rep x S\n 2. \\<not> ?P \\<Longrightarrow> trm_rep (trm_rep x S) S = trm_rep x S", "assume c1: \"subterm_reduction_applicable S x\""], ["proof (state)\nthis:\n  subterm_reduction_applicable S x\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> trm_rep (trm_rep x S) S = trm_rep x S\n 2. \\<not> ?P \\<Longrightarrow> trm_rep (trm_rep x S) S = trm_rep x S", "from this and hyp_ind"], ["proof (chain)\npicking this:\n  subterm_reduction_applicable S x\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     trm_rep (trm_rep y S) S = trm_rep y S", "have \"(?v,x) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  subterm_reduction_applicable S x\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     trm_rep (trm_rep y S) S = trm_rep y S\n\ngoal (1 subgoal):\n 1. (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S, x) \\<in> trm_ord", "using trm_rep_is_lower_aux trm_rep_is_lower"], ["proof (prove)\nusing this:\n  subterm_reduction_applicable S x\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     trm_rep (trm_rep y S) S = trm_rep y S\n  \\<lbrakk>\\<forall>y.\n              (y, ?t) \\<in> trm_ord \\<longrightarrow>\n              y \\<noteq> trm_rep y ?S \\<longrightarrow>\n              (trm_rep y ?S, y) \\<in> trm_ord;\n   subterm_reduction_applicable ?S ?t\\<rbrakk>\n  \\<Longrightarrow> (trm_rep (lhs ?t) ?S \\<cdot> trm_rep (rhs ?t) ?S, ?t)\n                    \\<in> trm_ord\n  ?t \\<noteq> trm_rep ?t ?S \\<longrightarrow>\n  (trm_rep ?t ?S, ?t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S, x) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S, x) \\<in> trm_ord\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> trm_rep (trm_rep x S) S = trm_rep x S\n 2. \\<not> ?P \\<Longrightarrow> trm_rep (trm_rep x S) S = trm_rep x S", "from this hyp_ind"], ["proof (chain)\npicking this:\n  (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S, x) \\<in> trm_ord\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     trm_rep (trm_rep y S) S = trm_rep y S", "have \"(trm_rep (trm_rep ?v S) S) =  (trm_rep ?v S)\""], ["proof (prove)\nusing this:\n  (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S, x) \\<in> trm_ord\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     trm_rep (trm_rep y S) S = trm_rep y S\n\ngoal (1 subgoal):\n 1. trm_rep (trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S) S =\n    trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S", "using trm_rep_aux_def [of x S]"], ["proof (prove)\nusing this:\n  (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S, x) \\<in> trm_ord\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     trm_rep (trm_rep y S) S = trm_rep y S\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     y \\<noteq> trm_rep y S \\<longrightarrow>\n     (trm_rep y S, y) \\<in> trm_ord \\<Longrightarrow>\n  trm_rep x S =\n  (if subterm_reduction_applicable S x then subterm_reduction S x\n   else get_min x (set_of_candidate_values S x))\n\ngoal (1 subgoal):\n 1. trm_rep (trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S) S =\n    trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S", "by metis"], ["proof (state)\nthis:\n  trm_rep (trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S) S =\n  trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> trm_rep (trm_rep x S) S = trm_rep x S\n 2. \\<not> ?P \\<Longrightarrow> trm_rep (trm_rep x S) S = trm_rep x S", "from c1"], ["proof (chain)\npicking this:\n  subterm_reduction_applicable S x", "have \"trm_rep x S = trm_rep ?v S\""], ["proof (prove)\nusing this:\n  subterm_reduction_applicable S x\n\ngoal (1 subgoal):\n 1. trm_rep x S = trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S", "using trm_rep_simp_def [of x S]"], ["proof (prove)\nusing this:\n  subterm_reduction_applicable S x\n  trm_rep x S =\n  (if subterm_reduction_applicable S x then subterm_reduction S x\n   else get_min x (set_of_candidate_values S x))\n\ngoal (1 subgoal):\n 1. trm_rep x S = trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S", "unfolding subterm_reduction_def"], ["proof (prove)\nusing this:\n  subterm_reduction_applicable S x\n  trm_rep x S =\n  (if subterm_reduction_applicable S x\n   then trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S\n   else get_min x (set_of_candidate_values S x))\n\ngoal (1 subgoal):\n 1. trm_rep x S = trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S", "by metis"], ["proof (state)\nthis:\n  trm_rep x S = trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> trm_rep (trm_rep x S) S = trm_rep x S\n 2. \\<not> ?P \\<Longrightarrow> trm_rep (trm_rep x S) S = trm_rep x S", "from this and \\<open>(trm_rep (trm_rep ?v S) S) =  (trm_rep ?v S)\\<close> \\<open>trm_rep x S = trm_rep ?v S\\<close>"], ["proof (chain)\npicking this:\n  trm_rep x S = trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S\n  trm_rep (trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S) S =\n  trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S\n  trm_rep x S = trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S", "show ?thesis"], ["proof (prove)\nusing this:\n  trm_rep x S = trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S\n  trm_rep (trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S) S =\n  trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S\n  trm_rep x S = trm_rep (trm_rep (lhs x) S \\<cdot> trm_rep (rhs x) S) S\n\ngoal (1 subgoal):\n 1. trm_rep (trm_rep x S) S = trm_rep x S", "by metis"], ["proof (state)\nthis:\n  trm_rep (trm_rep x S) S = trm_rep x S\n\ngoal (1 subgoal):\n 1. \\<not> subterm_reduction_applicable S x \\<Longrightarrow>\n    trm_rep (trm_rep x S) S = trm_rep x S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> subterm_reduction_applicable S x \\<Longrightarrow>\n    trm_rep (trm_rep x S) S = trm_rep x S", "assume c2: \"\\<not>subterm_reduction_applicable S x\""], ["proof (state)\nthis:\n  \\<not> subterm_reduction_applicable S x\n\ngoal (1 subgoal):\n 1. \\<not> subterm_reduction_applicable S x \\<Longrightarrow>\n    trm_rep (trm_rep x S) S = trm_rep x S", "from c2"], ["proof (chain)\npicking this:\n  \\<not> subterm_reduction_applicable S x", "have \"(trm_rep x S) = (get_min x (set_of_candidate_values S x))\""], ["proof (prove)\nusing this:\n  \\<not> subterm_reduction_applicable S x\n\ngoal (1 subgoal):\n 1. trm_rep x S = get_min x (set_of_candidate_values S x)", "using trm_rep_simp_def [of x S]"], ["proof (prove)\nusing this:\n  \\<not> subterm_reduction_applicable S x\n  trm_rep x S =\n  (if subterm_reduction_applicable S x then subterm_reduction S x\n   else get_min x (set_of_candidate_values S x))\n\ngoal (1 subgoal):\n 1. trm_rep x S = get_min x (set_of_candidate_values S x)", "by metis"], ["proof (state)\nthis:\n  trm_rep x S = get_min x (set_of_candidate_values S x)\n\ngoal (1 subgoal):\n 1. \\<not> subterm_reduction_applicable S x \\<Longrightarrow>\n    trm_rep (trm_rep x S) S = trm_rep x S", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. trm_rep (trm_rep x S) S = trm_rep x S", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. trm_rep (trm_rep x S) S \\<noteq> trm_rep x S \\<Longrightarrow> False", "assume \"(trm_rep (trm_rep x S) S) \\<noteq> (trm_rep x S)\""], ["proof (state)\nthis:\n  trm_rep (trm_rep x S) S \\<noteq> trm_rep x S\n\ngoal (1 subgoal):\n 1. trm_rep (trm_rep x S) S \\<noteq> trm_rep x S \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  trm_rep (trm_rep x S) S \\<noteq> trm_rep x S", "have \"x \\<noteq> (trm_rep x S)\""], ["proof (prove)\nusing this:\n  trm_rep (trm_rep x S) S \\<noteq> trm_rep x S\n\ngoal (1 subgoal):\n 1. x \\<noteq> trm_rep x S", "by metis"], ["proof (state)\nthis:\n  x \\<noteq> trm_rep x S\n\ngoal (1 subgoal):\n 1. trm_rep (trm_rep x S) S \\<noteq> trm_rep x S \\<Longrightarrow> False", "from c2 and \\<open>x \\<noteq> (trm_rep x S)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> subterm_reduction_applicable S x\n  x \\<noteq> trm_rep x S", "have \"(trm_rep x S) \\<in> (min_trms (set_of_candidate_values S x))\""], ["proof (prove)\nusing this:\n  \\<not> subterm_reduction_applicable S x\n  x \\<noteq> trm_rep x S\n\ngoal (1 subgoal):\n 1. trm_rep x S \\<in> min_trms (set_of_candidate_values S x)", "using trm_rep_simp_def [of x S]"], ["proof (prove)\nusing this:\n  \\<not> subterm_reduction_applicable S x\n  x \\<noteq> trm_rep x S\n  trm_rep x S =\n  (if subterm_reduction_applicable S x then subterm_reduction S x\n   else get_min x (set_of_candidate_values S x))\n\ngoal (1 subgoal):\n 1. trm_rep x S \\<in> min_trms (set_of_candidate_values S x)", "unfolding get_min_def"], ["proof (prove)\nusing this:\n  \\<not> subterm_reduction_applicable S x\n  x \\<noteq> trm_rep x S\n  trm_rep x S =\n  (if subterm_reduction_applicable S x then subterm_reduction S x\n   else if min_trms (set_of_candidate_values S x) = {} then x\n        else SOME xa. xa \\<in> min_trms (set_of_candidate_values S x))\n\ngoal (1 subgoal):\n 1. trm_rep x S \\<in> min_trms (set_of_candidate_values S x)", "by (metis (full_types) some_in_eq)"], ["proof (state)\nthis:\n  trm_rep x S \\<in> min_trms (set_of_candidate_values S x)\n\ngoal (1 subgoal):\n 1. trm_rep (trm_rep x S) S \\<noteq> trm_rep x S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  trm_rep x S \\<in> min_trms (set_of_candidate_values S x)", "obtain pair where  \n            \"pair \\<in> (set_of_candidate_values S x)\" and \"(trm_rep x S) = fst pair\""], ["proof (prove)\nusing this:\n  trm_rep x S \\<in> min_trms (set_of_candidate_values S x)\n\ngoal (1 subgoal):\n 1. (\\<And>pair.\n        \\<lbrakk>pair \\<in> set_of_candidate_values S x;\n         trm_rep x S = fst pair\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding min_trms_def"], ["proof (prove)\nusing this:\n  trm_rep x S\n  \\<in> {xa.\n         \\<exists>pair.\n            (pair \\<in> set_of_candidate_values S x \\<and>\n             (\\<forall>pair'\\<in>set_of_candidate_values S x.\n                 (snd pair', snd pair) \\<notin> trm_ord)) \\<and>\n            xa = fst pair}\n\ngoal (1 subgoal):\n 1. (\\<And>pair.\n        \\<lbrakk>pair \\<in> set_of_candidate_values S x;\n         trm_rep x S = fst pair\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  pair \\<in> set_of_candidate_values S x\n  trm_rep x S = fst pair\n\ngoal (1 subgoal):\n 1. trm_rep (trm_rep x S) S \\<noteq> trm_rep x S \\<Longrightarrow> False", "from \\<open>pair \\<in> (set_of_candidate_values S x)\\<close>"], ["proof (chain)\npicking this:\n  pair \\<in> set_of_candidate_values S x", "have i: \"\\<exists> CC C' C  L L' \\<sigma> t' s'. \n                    candidate_values (fst pair) CC C' C (snd pair) L L' \\<sigma> t' s' x S\""], ["proof (prove)\nusing this:\n  pair \\<in> set_of_candidate_values S x\n\ngoal (1 subgoal):\n 1. \\<exists>CC C' C L L' \\<sigma> t' s'.\n       candidate_values (fst pair) CC C' C (snd pair) L L' \\<sigma> t' s' x\n        S", "unfolding set_of_candidate_values_def"], ["proof (prove)\nusing this:\n  pair\n  \\<in> {pair.\n         \\<exists>z CC C' C s L L' \\<sigma> t' s'.\n            pair = (z, s) \\<and>\n            candidate_values z CC C' C s L L' \\<sigma> t' s' x S}\n\ngoal (1 subgoal):\n 1. \\<exists>CC C' C L L' \\<sigma> t' s'.\n       candidate_values (fst pair) CC C' C (snd pair) L L' \\<sigma> t' s' x\n        S", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>CC C' C L L' \\<sigma> t' s'.\n     candidate_values (fst pair) CC C' C (snd pair) L L' \\<sigma> t' s' x S\n\ngoal (1 subgoal):\n 1. trm_rep (trm_rep x S) S \\<noteq> trm_rep x S \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  \\<exists>CC C' C L L' \\<sigma> t' s'.\n     candidate_values (fst pair) CC C' C (snd pair) L L' \\<sigma> t' s' x S", "have \"(snd pair,x) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  \\<exists>CC C' C L L' \\<sigma> t' s'.\n     candidate_values (fst pair) CC C' C (snd pair) L L' \\<sigma> t' s' x S\n\ngoal (1 subgoal):\n 1. (snd pair, x) \\<in> trm_ord", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  \\<exists>CC C' C L L' \\<sigma> t' s'.\n     CC \\<in> S \\<and>\n     x \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n     trms_irreducible CC \\<sigma> S x \\<and>\n     C' = cl_ecl CC \\<and>\n     (snd pair, x) \\<in> trm_ord \\<and>\n     ((snd pair, x) \\<in> trm_ord \\<longrightarrow>\n      fst pair = trm_rep (snd pair) S) \\<and>\n     orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n     sel C' = {} \\<and>\n     L' \\<in> C' \\<and>\n     maximal_literal L C \\<and>\n     L = subst_lit L' \\<sigma> \\<and>\n     C = subst_cl C' \\<sigma> \\<and>\n     ground_clause C \\<and>\n     x = t' \\<lhd> \\<sigma> \\<and>\n     snd pair = s' \\<lhd> \\<sigma> \\<and>\n     finite C' \\<and>\n     smaller_lits_are_false x C S \\<and>\n     maximal_literal_is_unique x (snd pair) C' L' S \\<sigma>\n\ngoal (1 subgoal):\n 1. (snd pair, x) \\<in> trm_ord", "by blast"], ["proof (state)\nthis:\n  (snd pair, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep (trm_rep x S) S \\<noteq> trm_rep x S \\<Longrightarrow> False", "from i"], ["proof (chain)\npicking this:\n  \\<exists>CC C' C L L' \\<sigma> t' s'.\n     candidate_values (fst pair) CC C' C (snd pair) L L' \\<sigma> t' s' x S", "have \"((snd pair, x) \\<in> trm_ord \\<longrightarrow> fst pair = trm_rep (snd pair) S)\""], ["proof (prove)\nusing this:\n  \\<exists>CC C' C L L' \\<sigma> t' s'.\n     candidate_values (fst pair) CC C' C (snd pair) L L' \\<sigma> t' s' x S\n\ngoal (1 subgoal):\n 1. (snd pair, x) \\<in> trm_ord \\<longrightarrow>\n    fst pair = trm_rep (snd pair) S", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  \\<exists>CC C' C L L' \\<sigma> t' s'.\n     CC \\<in> S \\<and>\n     x \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n     trms_irreducible CC \\<sigma> S x \\<and>\n     C' = cl_ecl CC \\<and>\n     (snd pair, x) \\<in> trm_ord \\<and>\n     ((snd pair, x) \\<in> trm_ord \\<longrightarrow>\n      fst pair = trm_rep (snd pair) S) \\<and>\n     orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n     sel C' = {} \\<and>\n     L' \\<in> C' \\<and>\n     maximal_literal L C \\<and>\n     L = subst_lit L' \\<sigma> \\<and>\n     C = subst_cl C' \\<sigma> \\<and>\n     ground_clause C \\<and>\n     x = t' \\<lhd> \\<sigma> \\<and>\n     snd pair = s' \\<lhd> \\<sigma> \\<and>\n     finite C' \\<and>\n     smaller_lits_are_false x C S \\<and>\n     maximal_literal_is_unique x (snd pair) C' L' S \\<sigma>\n\ngoal (1 subgoal):\n 1. (snd pair, x) \\<in> trm_ord \\<longrightarrow>\n    fst pair = trm_rep (snd pair) S", "by blast"], ["proof (state)\nthis:\n  (snd pair, x) \\<in> trm_ord \\<longrightarrow>\n  fst pair = trm_rep (snd pair) S\n\ngoal (1 subgoal):\n 1. trm_rep (trm_rep x S) S \\<noteq> trm_rep x S \\<Longrightarrow> False", "from \\<open>(snd pair,x) \\<in> trm_ord\\<close> \n            and \\<open>((snd pair, x) \\<in> trm_ord \\<longrightarrow> fst pair = trm_rep (snd pair) S)\\<close>"], ["proof (chain)\npicking this:\n  (snd pair, x) \\<in> trm_ord\n  (snd pair, x) \\<in> trm_ord \\<longrightarrow>\n  fst pair = trm_rep (snd pair) S", "have \"fst pair = trm_rep (snd pair) S\""], ["proof (prove)\nusing this:\n  (snd pair, x) \\<in> trm_ord\n  (snd pair, x) \\<in> trm_ord \\<longrightarrow>\n  fst pair = trm_rep (snd pair) S\n\ngoal (1 subgoal):\n 1. fst pair = trm_rep (snd pair) S", "by blast"], ["proof (state)\nthis:\n  fst pair = trm_rep (snd pair) S\n\ngoal (1 subgoal):\n 1. trm_rep (trm_rep x S) S \\<noteq> trm_rep x S \\<Longrightarrow> False", "from \\<open>(snd pair,x) \\<in> trm_ord\\<close> and hyp_ind"], ["proof (chain)\npicking this:\n  (snd pair, x) \\<in> trm_ord\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     trm_rep (trm_rep y S) S = trm_rep y S", "have \"(?P (snd pair))\""], ["proof (prove)\nusing this:\n  (snd pair, x) \\<in> trm_ord\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     trm_rep (trm_rep y S) S = trm_rep y S\n\ngoal (1 subgoal):\n 1. trm_rep (trm_rep (snd pair) S) S = trm_rep (snd pair) S", "by blast"], ["proof (state)\nthis:\n  trm_rep (trm_rep (snd pair) S) S = trm_rep (snd pair) S\n\ngoal (1 subgoal):\n 1. trm_rep (trm_rep x S) S \\<noteq> trm_rep x S \\<Longrightarrow> False", "from this and \\<open>fst pair = (trm_rep (snd pair) S)\\<close> and \\<open>(trm_rep x S) = fst pair\\<close> \n            and \\<open>(trm_rep (trm_rep x S) S) \\<noteq> (trm_rep x S)\\<close>"], ["proof (chain)\npicking this:\n  trm_rep (trm_rep (snd pair) S) S = trm_rep (snd pair) S\n  fst pair = trm_rep (snd pair) S\n  trm_rep x S = fst pair\n  trm_rep (trm_rep x S) S \\<noteq> trm_rep x S", "show False"], ["proof (prove)\nusing this:\n  trm_rep (trm_rep (snd pair) S) S = trm_rep (snd pair) S\n  fst pair = trm_rep (snd pair) S\n  trm_rep x S = fst pair\n  trm_rep (trm_rep x S) S \\<noteq> trm_rep x S\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trm_rep (trm_rep x S) S = trm_rep x S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trm_rep (trm_rep x S) S = trm_rep x S\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The following predicate is true if all proper subterms are in normal form.\\<close>"], ["", "definition root_term :: \"'a eclause set \\<Rightarrow> 'a trm \\<Rightarrow> bool\"\n  where\n    \"(root_term S t) = \n      ((trm_rep t S) = (get_min t (set_of_candidate_values S t)))\""], ["", "text \\<open>The following function checks that the considered term contains a subterm that can be \nreduced.\\<close>"], ["", "definition st_red :: \"'a eclause set \\<Rightarrow> 'a trm \\<Rightarrow> bool\"\n  where\n    \"(st_red S t) \n      = (\\<exists> t' p. ( (subterm t p t') \\<and> (root_term S t') \\<and> (trm_rep t' S \\<noteq> t')))\""], ["", "lemma red_arg_implies_red_trm :\n  assumes \"st_red S t1\"\n  assumes \"t = (Comb t1 t2) \\<or> t = (Comb t2 t1)\"\n  shows \"st_red S t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st_red S t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. st_red S t", "from assms(1)"], ["proof (chain)\npicking this:\n  st_red S t1", "obtain t' p where \"subterm t1 p t'\" and \"root_term S t'\" and \"trm_rep t' S \\<noteq> t'\""], ["proof (prove)\nusing this:\n  st_red S t1\n\ngoal (1 subgoal):\n 1. (\\<And>p t'.\n        \\<lbrakk>subterm t1 p t'; root_term S t';\n         trm_rep t' S \\<noteq> t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding st_red_def"], ["proof (prove)\nusing this:\n  \\<exists>t' p.\n     subterm t1 p t' \\<and> root_term S t' \\<and> trm_rep t' S \\<noteq> t'\n\ngoal (1 subgoal):\n 1. (\\<And>p t'.\n        \\<lbrakk>subterm t1 p t'; root_term S t';\n         trm_rep t' S \\<noteq> t'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  subterm t1 p t'\n  root_term S t'\n  trm_rep t' S \\<noteq> t'\n\ngoal (1 subgoal):\n 1. st_red S t", "from \\<open>subterm t1 p t'\\<close> and assms(2)"], ["proof (chain)\npicking this:\n  subterm t1 p t'\n  t = t1 \\<cdot> t2 \\<or> t = t2 \\<cdot> t1", "obtain q where \"subterm t q t'\""], ["proof (prove)\nusing this:\n  subterm t1 p t'\n  t = t1 \\<cdot> t2 \\<or> t = t2 \\<cdot> t1\n\ngoal (1 subgoal):\n 1. (\\<And>q. subterm t q t' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis subterm.simps(4) subterm.simps(5))"], ["proof (state)\nthis:\n  subterm t q t'\n\ngoal (1 subgoal):\n 1. st_red S t", "from this and \\<open>root_term S t'\\<close> and \\<open>trm_rep t' S \\<noteq> t'\\<close>"], ["proof (chain)\npicking this:\n  subterm t q t'\n  root_term S t'\n  trm_rep t' S \\<noteq> t'", "show ?thesis"], ["proof (prove)\nusing this:\n  subterm t q t'\n  root_term S t'\n  trm_rep t' S \\<noteq> t'\n\ngoal (1 subgoal):\n 1. st_red S t", "unfolding st_red_def"], ["proof (prove)\nusing this:\n  subterm t q t'\n  root_term S t'\n  trm_rep t' S \\<noteq> t'\n\ngoal (1 subgoal):\n 1. \\<exists>t' p.\n       subterm t p t' \\<and> root_term S t' \\<and> trm_rep t' S \\<noteq> t'", "by blast"], ["proof (state)\nthis:\n  st_red S t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subterms_of_irred_trms_are_irred: \n  \"(trm_rep t S) \\<noteq> t \\<longrightarrow> st_red S t\" (is \"(?P t)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. trm_rep t S \\<noteq> t \\<longrightarrow> st_red S t", "proof ((rule wf_induct [of \"trm_ord\" \"?P\" \"t\"]),(simp add: trm_ord_wf))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> trm_ord \\<longrightarrow>\n          trm_rep y S \\<noteq> y \\<longrightarrow>\n          st_red S y \\<Longrightarrow>\n       trm_rep x S \\<noteq> x \\<longrightarrow> st_red S x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> trm_ord \\<longrightarrow>\n          trm_rep y S \\<noteq> y \\<longrightarrow>\n          st_red S y \\<Longrightarrow>\n       trm_rep x S \\<noteq> x \\<longrightarrow> st_red S x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> trm_ord \\<longrightarrow>\n          trm_rep y S \\<noteq> y \\<longrightarrow>\n          st_red S y \\<Longrightarrow>\n       trm_rep x S \\<noteq> x \\<longrightarrow> st_red S x", "assume hyp_ind: \"\\<forall>y. (y,x) \\<in> trm_ord \\<longrightarrow> (?P y)\""], ["proof (state)\nthis:\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     trm_rep y S \\<noteq> y \\<longrightarrow> st_red S y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> trm_ord \\<longrightarrow>\n          trm_rep y S \\<noteq> y \\<longrightarrow>\n          st_red S y \\<Longrightarrow>\n       trm_rep x S \\<noteq> x \\<longrightarrow> st_red S x", "show \"(?P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trm_rep x S \\<noteq> x \\<longrightarrow> st_red S x", "proof (rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. trm_rep x S \\<noteq> x \\<Longrightarrow> st_red S x", "assume \"(trm_rep x S) \\<noteq> x\""], ["proof (state)\nthis:\n  trm_rep x S \\<noteq> x\n\ngoal (1 subgoal):\n 1. trm_rep x S \\<noteq> x \\<Longrightarrow> st_red S x", "show \"st_red S x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st_red S x", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> st_red S x \\<Longrightarrow> False", "assume neg_h: \"\\<not>st_red S x\""], ["proof (state)\nthis:\n  \\<not> st_red S x\n\ngoal (1 subgoal):\n 1. \\<not> st_red S x \\<Longrightarrow> False", "have i: \" \\<not>subterm_reduction_applicable S x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> subterm_reduction_applicable S x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. subterm_reduction_applicable S x \\<Longrightarrow> False", "assume decomp_case: \"subterm_reduction_applicable S x\""], ["proof (state)\nthis:\n  subterm_reduction_applicable S x\n\ngoal (1 subgoal):\n 1. subterm_reduction_applicable S x \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  subterm_reduction_applicable S x", "obtain x1 x2 where \"x = (Comb x1 x2)\""], ["proof (prove)\nusing this:\n  subterm_reduction_applicable S x\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        x = x1 \\<cdot> x2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using is_compound.elims(2)"], ["proof (prove)\nusing this:\n  subterm_reduction_applicable S x\n  \\<lbrakk>is_compound ?x;\n   \\<And>x y. ?x = x \\<cdot> y \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        x = x1 \\<cdot> x2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding subterm_reduction_applicable_def"], ["proof (prove)\nusing this:\n  is_compound x \\<and>\n  (trm_rep (lhs x) S \\<noteq> lhs x \\<or> trm_rep (rhs x) S \\<noteq> rhs x)\n  \\<lbrakk>is_compound ?x;\n   \\<And>x y. ?x = x \\<cdot> y \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        x = x1 \\<cdot> x2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = x1 \\<cdot> x2\n\ngoal (1 subgoal):\n 1. subterm_reduction_applicable S x \\<Longrightarrow> False", "from this and decomp_case"], ["proof (chain)\npicking this:\n  x = x1 \\<cdot> x2\n  subterm_reduction_applicable S x", "have \"((trm_rep x1 S) \\<noteq> x1 \\<or> (trm_rep x2 S) \\<noteq> x2)\""], ["proof (prove)\nusing this:\n  x = x1 \\<cdot> x2\n  subterm_reduction_applicable S x\n\ngoal (1 subgoal):\n 1. trm_rep x1 S \\<noteq> x1 \\<or> trm_rep x2 S \\<noteq> x2", "using lhs.simps(1) rhs.simps(1)"], ["proof (prove)\nusing this:\n  x = x1 \\<cdot> x2\n  subterm_reduction_applicable S x\n  lhs (?t1.0 \\<cdot> ?t2.0) = ?t1.0\n  rhs (?t1.0 \\<cdot> ?t2.0) = ?t2.0\n\ngoal (1 subgoal):\n 1. trm_rep x1 S \\<noteq> x1 \\<or> trm_rep x2 S \\<noteq> x2", "unfolding subterm_reduction_applicable_def"], ["proof (prove)\nusing this:\n  x = x1 \\<cdot> x2\n  is_compound x \\<and>\n  (trm_rep (lhs x) S \\<noteq> lhs x \\<or> trm_rep (rhs x) S \\<noteq> rhs x)\n  lhs (?t1.0 \\<cdot> ?t2.0) = ?t1.0\n  rhs (?t1.0 \\<cdot> ?t2.0) = ?t2.0\n\ngoal (1 subgoal):\n 1. trm_rep x1 S \\<noteq> x1 \\<or> trm_rep x2 S \\<noteq> x2", "by metis"], ["proof (state)\nthis:\n  trm_rep x1 S \\<noteq> x1 \\<or> trm_rep x2 S \\<noteq> x2\n\ngoal (1 subgoal):\n 1. subterm_reduction_applicable S x \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  trm_rep x1 S \\<noteq> x1 \\<or> trm_rep x2 S \\<noteq> x2", "show False"], ["proof (prove)\nusing this:\n  trm_rep x1 S \\<noteq> x1 \\<or> trm_rep x2 S \\<noteq> x2\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. trm_rep x1 S \\<noteq> x1 \\<Longrightarrow> False\n 2. trm_rep x2 S \\<noteq> x2 \\<Longrightarrow> False", "assume \"(trm_rep x1 S) \\<noteq> x1\""], ["proof (state)\nthis:\n  trm_rep x1 S \\<noteq> x1\n\ngoal (2 subgoals):\n 1. trm_rep x1 S \\<noteq> x1 \\<Longrightarrow> False\n 2. trm_rep x2 S \\<noteq> x2 \\<Longrightarrow> False", "from \\<open>x = (Comb x1 x2)\\<close> and trm_ord_subterm"], ["proof (chain)\npicking this:\n  x = x1 \\<cdot> x2\n  \\<forall>x1 x2.\n     (x1, x1 \\<cdot> x2) \\<in> trm_ord \\<and>\n     (x2, x1 \\<cdot> x2) \\<in> trm_ord", "have \"(x1,x) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  x = x1 \\<cdot> x2\n  \\<forall>x1 x2.\n     (x1, x1 \\<cdot> x2) \\<in> trm_ord \\<and>\n     (x2, x1 \\<cdot> x2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (x1, x) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (x1, x) \\<in> trm_ord\n\ngoal (2 subgoals):\n 1. trm_rep x1 S \\<noteq> x1 \\<Longrightarrow> False\n 2. trm_rep x2 S \\<noteq> x2 \\<Longrightarrow> False", "from this and hyp_ind and \\<open>(trm_rep x1 S) \\<noteq> x1\\<close>"], ["proof (chain)\npicking this:\n  (x1, x) \\<in> trm_ord\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     trm_rep y S \\<noteq> y \\<longrightarrow> st_red S y\n  trm_rep x1 S \\<noteq> x1", "have \"st_red S x1\""], ["proof (prove)\nusing this:\n  (x1, x) \\<in> trm_ord\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     trm_rep y S \\<noteq> y \\<longrightarrow> st_red S y\n  trm_rep x1 S \\<noteq> x1\n\ngoal (1 subgoal):\n 1. st_red S x1", "by blast"], ["proof (state)\nthis:\n  st_red S x1\n\ngoal (2 subgoals):\n 1. trm_rep x1 S \\<noteq> x1 \\<Longrightarrow> False\n 2. trm_rep x2 S \\<noteq> x2 \\<Longrightarrow> False", "from this and neg_h and \\<open>x = (Comb x1 x2)\\<close>"], ["proof (chain)\npicking this:\n  st_red S x1\n  \\<not> st_red S x\n  x = x1 \\<cdot> x2", "show False"], ["proof (prove)\nusing this:\n  st_red S x1\n  \\<not> st_red S x\n  x = x1 \\<cdot> x2\n\ngoal (1 subgoal):\n 1. False", "using red_arg_implies_red_trm [of S x1 x x2]"], ["proof (prove)\nusing this:\n  st_red S x1\n  \\<not> st_red S x\n  x = x1 \\<cdot> x2\n  \\<lbrakk>st_red S x1; x = x1 \\<cdot> x2 \\<or> x = x2 \\<cdot> x1\\<rbrakk>\n  \\<Longrightarrow> st_red S x\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. trm_rep x2 S \\<noteq> x2 \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. trm_rep x2 S \\<noteq> x2 \\<Longrightarrow> False", "assume \"(trm_rep x2 S) \\<noteq> x2\""], ["proof (state)\nthis:\n  trm_rep x2 S \\<noteq> x2\n\ngoal (1 subgoal):\n 1. trm_rep x2 S \\<noteq> x2 \\<Longrightarrow> False", "from \\<open>x = (Comb x1 x2)\\<close> and trm_ord_subterm"], ["proof (chain)\npicking this:\n  x = x1 \\<cdot> x2\n  \\<forall>x1 x2.\n     (x1, x1 \\<cdot> x2) \\<in> trm_ord \\<and>\n     (x2, x1 \\<cdot> x2) \\<in> trm_ord", "have \"(x2,x) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  x = x1 \\<cdot> x2\n  \\<forall>x1 x2.\n     (x1, x1 \\<cdot> x2) \\<in> trm_ord \\<and>\n     (x2, x1 \\<cdot> x2) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (x2, x) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (x2, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep x2 S \\<noteq> x2 \\<Longrightarrow> False", "from this and hyp_ind and \\<open>(trm_rep x2 S) \\<noteq> x2\\<close>"], ["proof (chain)\npicking this:\n  (x2, x) \\<in> trm_ord\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     trm_rep y S \\<noteq> y \\<longrightarrow> st_red S y\n  trm_rep x2 S \\<noteq> x2", "have \"st_red S x2\""], ["proof (prove)\nusing this:\n  (x2, x) \\<in> trm_ord\n  \\<forall>y.\n     (y, x) \\<in> trm_ord \\<longrightarrow>\n     trm_rep y S \\<noteq> y \\<longrightarrow> st_red S y\n  trm_rep x2 S \\<noteq> x2\n\ngoal (1 subgoal):\n 1. st_red S x2", "by metis"], ["proof (state)\nthis:\n  st_red S x2\n\ngoal (1 subgoal):\n 1. trm_rep x2 S \\<noteq> x2 \\<Longrightarrow> False", "from this and neg_h and \\<open>x = (Comb x1 x2)\\<close>"], ["proof (chain)\npicking this:\n  st_red S x2\n  \\<not> st_red S x\n  x = x1 \\<cdot> x2", "show False"], ["proof (prove)\nusing this:\n  st_red S x2\n  \\<not> st_red S x\n  x = x1 \\<cdot> x2\n\ngoal (1 subgoal):\n 1. False", "using red_arg_implies_red_trm [of S x2 x x1]"], ["proof (prove)\nusing this:\n  st_red S x2\n  \\<not> st_red S x\n  x = x1 \\<cdot> x2\n  \\<lbrakk>st_red S x2; x = x2 \\<cdot> x1 \\<or> x = x1 \\<cdot> x2\\<rbrakk>\n  \\<Longrightarrow> st_red S x\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> subterm_reduction_applicable S x\n\ngoal (1 subgoal):\n 1. \\<not> st_red S x \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> subterm_reduction_applicable S x", "have \"(trm_rep x S) = (get_min x (set_of_candidate_values S x))\""], ["proof (prove)\nusing this:\n  \\<not> subterm_reduction_applicable S x\n\ngoal (1 subgoal):\n 1. trm_rep x S = get_min x (set_of_candidate_values S x)", "using trm_rep_simp_def"], ["proof (prove)\nusing this:\n  \\<not> subterm_reduction_applicable S x\n  trm_rep ?t ?S =\n  (if subterm_reduction_applicable ?S ?t then subterm_reduction ?S ?t\n   else get_min ?t (set_of_candidate_values ?S ?t))\n\ngoal (1 subgoal):\n 1. trm_rep x S = get_min x (set_of_candidate_values S x)", "by metis"], ["proof (state)\nthis:\n  trm_rep x S = get_min x (set_of_candidate_values S x)\n\ngoal (1 subgoal):\n 1. \\<not> st_red S x \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  trm_rep x S = get_min x (set_of_candidate_values S x)", "have \"root_term S x\""], ["proof (prove)\nusing this:\n  trm_rep x S = get_min x (set_of_candidate_values S x)\n\ngoal (1 subgoal):\n 1. root_term S x", "unfolding root_term_def"], ["proof (prove)\nusing this:\n  trm_rep x S = get_min x (set_of_candidate_values S x)\n\ngoal (1 subgoal):\n 1. trm_rep x S = get_min x (set_of_candidate_values S x)", "by blast"], ["proof (state)\nthis:\n  root_term S x\n\ngoal (1 subgoal):\n 1. \\<not> st_red S x \\<Longrightarrow> False", "have \"subterm x [] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subterm x [] x", "by auto"], ["proof (state)\nthis:\n  subterm x [] x\n\ngoal (1 subgoal):\n 1. \\<not> st_red S x \\<Longrightarrow> False", "from this and \\<open>root_term S x\\<close> and \\<open>(trm_rep x S) \\<noteq> x\\<close>"], ["proof (chain)\npicking this:\n  subterm x [] x\n  root_term S x\n  trm_rep x S \\<noteq> x", "have \n          \"st_red S x\""], ["proof (prove)\nusing this:\n  subterm x [] x\n  root_term S x\n  trm_rep x S \\<noteq> x\n\ngoal (1 subgoal):\n 1. st_red S x", "unfolding st_red_def"], ["proof (prove)\nusing this:\n  subterm x [] x\n  root_term S x\n  trm_rep x S \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<exists>t' p.\n       subterm x p t' \\<and> root_term S t' \\<and> trm_rep t' S \\<noteq> t'", "by blast"], ["proof (state)\nthis:\n  st_red S x\n\ngoal (1 subgoal):\n 1. \\<not> st_red S x \\<Longrightarrow> False", "from this and neg_h"], ["proof (chain)\npicking this:\n  st_red S x\n  \\<not> st_red S x", "show False"], ["proof (prove)\nusing this:\n  st_red S x\n  \\<not> st_red S x\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  st_red S x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trm_rep x S \\<noteq> x \\<longrightarrow> st_red S x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trm_rep_compatible_with_structure:\n  shows \"value_is_compatible_with_structure (\\<lambda>x. trm_rep x S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. value_is_compatible_with_structure (\\<lambda>x. trm_rep x S)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> value_is_compatible_with_structure\n            (\\<lambda>x. trm_rep x S) \\<Longrightarrow>\n    False", "assume \"\\<not>value_is_compatible_with_structure (\\<lambda>x. trm_rep x S)\""], ["proof (state)\nthis:\n  \\<not> value_is_compatible_with_structure (\\<lambda>x. trm_rep x S)\n\ngoal (1 subgoal):\n 1. \\<not> value_is_compatible_with_structure\n            (\\<lambda>x. trm_rep x S) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<not> value_is_compatible_with_structure (\\<lambda>x. trm_rep x S)", "obtain t s \n    where neg_h:\"trm_rep (Comb t s) S \\<noteq> (trm_rep (Comb (trm_rep t S) (trm_rep s S)) S)\""], ["proof (prove)\nusing this:\n  \\<not> value_is_compatible_with_structure (\\<lambda>x. trm_rep x S)\n\ngoal (1 subgoal):\n 1. (\\<And>t s.\n        trm_rep (t \\<cdot> s) S \\<noteq>\n        trm_rep (trm_rep t S \\<cdot> trm_rep s S) S \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding value_is_compatible_with_structure_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>t s.\n             trm_rep (t \\<cdot> s) S =\n             trm_rep (trm_rep t S \\<cdot> trm_rep s S) S)\n\ngoal (1 subgoal):\n 1. (\\<And>t s.\n        trm_rep (t \\<cdot> s) S \\<noteq>\n        trm_rep (trm_rep t S \\<cdot> trm_rep s S) S \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  trm_rep (t \\<cdot> s) S \\<noteq>\n  trm_rep (trm_rep t S \\<cdot> trm_rep s S) S\n\ngoal (1 subgoal):\n 1. \\<not> value_is_compatible_with_structure\n            (\\<lambda>x. trm_rep x S) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  trm_rep (t \\<cdot> s) S \\<noteq>\n  trm_rep (trm_rep t S \\<cdot> trm_rep s S) S", "have \"(trm_rep t S) \\<noteq> t \\<or> (trm_rep s S) \\<noteq> s\""], ["proof (prove)\nusing this:\n  trm_rep (t \\<cdot> s) S \\<noteq>\n  trm_rep (trm_rep t S \\<cdot> trm_rep s S) S\n\ngoal (1 subgoal):\n 1. trm_rep t S \\<noteq> t \\<or> trm_rep s S \\<noteq> s", "by metis"], ["proof (state)\nthis:\n  trm_rep t S \\<noteq> t \\<or> trm_rep s S \\<noteq> s\n\ngoal (1 subgoal):\n 1. \\<not> value_is_compatible_with_structure\n            (\\<lambda>x. trm_rep x S) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  trm_rep t S \\<noteq> t \\<or> trm_rep s S \\<noteq> s", "have \"subterm_reduction_applicable S (Comb t s)\""], ["proof (prove)\nusing this:\n  trm_rep t S \\<noteq> t \\<or> trm_rep s S \\<noteq> s\n\ngoal (1 subgoal):\n 1. subterm_reduction_applicable S (t \\<cdot> s)", "unfolding subterm_reduction_applicable_def"], ["proof (prove)\nusing this:\n  trm_rep t S \\<noteq> t \\<or> trm_rep s S \\<noteq> s\n\ngoal (1 subgoal):\n 1. is_compound (t \\<cdot> s) \\<and>\n    (trm_rep (lhs (t \\<cdot> s)) S \\<noteq> lhs (t \\<cdot> s) \\<or>\n     trm_rep (rhs (t \\<cdot> s)) S \\<noteq> rhs (t \\<cdot> s))", "by (metis is_compound.simps(3) lhs.simps(1) rhs.simps(1))"], ["proof (state)\nthis:\n  subterm_reduction_applicable S (t \\<cdot> s)\n\ngoal (1 subgoal):\n 1. \\<not> value_is_compatible_with_structure\n            (\\<lambda>x. trm_rep x S) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  subterm_reduction_applicable S (t \\<cdot> s)", "have \"(trm_rep (Comb t s) S) = (subterm_reduction S (Comb t s))\""], ["proof (prove)\nusing this:\n  subterm_reduction_applicable S (t \\<cdot> s)\n\ngoal (1 subgoal):\n 1. trm_rep (t \\<cdot> s) S = subterm_reduction S (t \\<cdot> s)", "using trm_rep_simp_def"], ["proof (prove)\nusing this:\n  subterm_reduction_applicable S (t \\<cdot> s)\n  trm_rep ?t ?S =\n  (if subterm_reduction_applicable ?S ?t then subterm_reduction ?S ?t\n   else get_min ?t (set_of_candidate_values ?S ?t))\n\ngoal (1 subgoal):\n 1. trm_rep (t \\<cdot> s) S = subterm_reduction S (t \\<cdot> s)", "by metis"], ["proof (state)\nthis:\n  trm_rep (t \\<cdot> s) S = subterm_reduction S (t \\<cdot> s)\n\ngoal (1 subgoal):\n 1. \\<not> value_is_compatible_with_structure\n            (\\<lambda>x. trm_rep x S) \\<Longrightarrow>\n    False", "from this and neg_h"], ["proof (chain)\npicking this:\n  trm_rep (t \\<cdot> s) S = subterm_reduction S (t \\<cdot> s)\n  trm_rep (t \\<cdot> s) S \\<noteq>\n  trm_rep (trm_rep t S \\<cdot> trm_rep s S) S", "show False"], ["proof (prove)\nusing this:\n  trm_rep (t \\<cdot> s) S = subterm_reduction S (t \\<cdot> s)\n  trm_rep (t \\<cdot> s) S \\<noteq>\n  trm_rep (trm_rep t S \\<cdot> trm_rep s S) S\n\ngoal (1 subgoal):\n 1. False", "unfolding subterm_reduction_def"], ["proof (prove)\nusing this:\n  trm_rep (t \\<cdot> s) S =\n  trm_rep\n   (trm_rep (lhs (t \\<cdot> s)) S \\<cdot> trm_rep (rhs (t \\<cdot> s)) S) S\n  trm_rep (t \\<cdot> s) S \\<noteq>\n  trm_rep (trm_rep t S \\<cdot> trm_rep s S) S\n\ngoal (1 subgoal):\n 1. False", "by (metis lhs.simps(1) rhs.simps(1))"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The following function checks that a position can be reduced, taking into account the \norder on positions associated with the considered clause and term. A term is reducible when all \nterms occurring at smaller positions are irreducible.\\<close>"], ["", "definition minimal_redex \n  where \"minimal_redex p t C S t'\n    = (\\<forall>q s. ((q,p) \\<in> (pos_ord C t') \\<longrightarrow> (subterm t q s) \\<longrightarrow> (trm_rep s S = s)))\""], ["", "text \\<open>The next function checks that a given clause contains two equations with the same\nleft-hand side and whose right-hand sides are equivalent in a given interpretation. If no such \nequations exist then it is clear that the maximal literal is necessarily unique.\\<close>"], ["", "definition equivalent_eq_exists\n  where \"equivalent_eq_exists t s C I \\<sigma> L1 = (\\<exists>L\\<in> C - { L1 }. \\<exists> u v.\n    (orient_lit_inst L u v pos \\<sigma>) \\<and> ((subst t \\<sigma>) = (subst u \\<sigma>))\n    \\<and> (I  (subst s \\<sigma>) (subst v \\<sigma>)))\""], ["", "lemma maximal_literal_is_unique_lemma:\n  assumes \"\\<not>equivalent_eq_exists t s C (int_clset S) \\<sigma> L1\"\n  shows \"maximal_literal_is_unique (subst t \\<sigma>) (subst s \\<sigma>) C L1 S \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal_literal_is_unique (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>) C L1 S\n     \\<sigma>", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n            C L1 S \\<sigma> \\<Longrightarrow>\n    False", "let ?t = \"(subst t \\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n            C L1 S \\<sigma> \\<Longrightarrow>\n    False", "let ?s = \"(subst s \\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n            C L1 S \\<sigma> \\<Longrightarrow>\n    False", "let ?L = \"(subst_lit L \\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n            C L1 S \\<sigma> \\<Longrightarrow>\n    False", "let ?C = \"(subst_cl C \\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n            C L1 S \\<sigma> \\<Longrightarrow>\n    False", "assume \"\\<not>(maximal_literal_is_unique ?t ?s C L1 S \\<sigma>)\""], ["proof (state)\nthis:\n  \\<not> maximal_literal_is_unique (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>) C\n          L1 S \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n            C L1 S \\<sigma> \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<not> maximal_literal_is_unique (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>) C\n          L1 S \\<sigma>", "obtain s'' where \"(eq_occurs_in_cl ?t s'' (C- { L1 }) \\<sigma>)\" \n    and \"(trm_rep ?s  S) = (trm_rep s'' S)\""], ["proof (prove)\nusing this:\n  \\<not> maximal_literal_is_unique (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>) C\n          L1 S \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>s''.\n        \\<lbrakk>eq_occurs_in_cl (t \\<lhd> \\<sigma>) s'' (C - {L1})\n                  \\<sigma>;\n         trm_rep (s \\<lhd> \\<sigma>) S = trm_rep s'' S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding maximal_literal_is_unique_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>s''.\n             eq_occurs_in_cl (t \\<lhd> \\<sigma>) s'' (C - {L1})\n              \\<sigma> \\<longrightarrow>\n             (s'', t \\<lhd> \\<sigma>) \\<in> trm_ord \\<longrightarrow>\n             (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n             \\<in> trm_ord \\<longrightarrow>\n             trm_rep (s \\<lhd> \\<sigma>) S \\<noteq> trm_rep s'' S)\n\ngoal (1 subgoal):\n 1. (\\<And>s''.\n        \\<lbrakk>eq_occurs_in_cl (t \\<lhd> \\<sigma>) s'' (C - {L1})\n                  \\<sigma>;\n         trm_rep (s \\<lhd> \\<sigma>) S = trm_rep s'' S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  eq_occurs_in_cl (t \\<lhd> \\<sigma>) s'' (C - {L1}) \\<sigma>\n  trm_rep (s \\<lhd> \\<sigma>) S = trm_rep s'' S\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n            C L1 S \\<sigma> \\<Longrightarrow>\n    False", "from \\<open>(eq_occurs_in_cl ?t s'' (C- { L1 }) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  eq_occurs_in_cl (t \\<lhd> \\<sigma>) s'' (C - {L1}) \\<sigma>", "obtain L' t' s' where \"L' \\<in> (C- { L1 })\" \n      and \"orient_lit_inst L' t' s' pos \\<sigma>\" and \"(subst t' \\<sigma>) = ?t\" \n      and  \"s'' = subst s' \\<sigma>\""], ["proof (prove)\nusing this:\n  eq_occurs_in_cl (t \\<lhd> \\<sigma>) s'' (C - {L1}) \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>L' t' s'.\n        \\<lbrakk>L' \\<in> C - {L1}; orient_lit_inst L' t' s' pos \\<sigma>;\n         t' \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>;\n         s'' = s' \\<lhd> \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding eq_occurs_in_cl_def"], ["proof (prove)\nusing this:\n  \\<exists>L t' s'.\n     L \\<in> C - {L1} \\<and>\n     orient_lit_inst L t' s' pos \\<sigma> \\<and>\n     t \\<lhd> \\<sigma> = t' \\<lhd> \\<sigma> \\<and> s'' = s' \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>L' t' s'.\n        \\<lbrakk>L' \\<in> C - {L1}; orient_lit_inst L' t' s' pos \\<sigma>;\n         t' \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>;\n         s'' = s' \\<lhd> \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L' \\<in> C - {L1}\n  orient_lit_inst L' t' s' pos \\<sigma>\n  t' \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>\n  s'' = s' \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n            C L1 S \\<sigma> \\<Longrightarrow>\n    False", "from \\<open>s'' = subst s' \\<sigma>\\<close> and \\<open>(trm_rep ?s  S) = (trm_rep s'' S)\\<close>"], ["proof (chain)\npicking this:\n  s'' = s' \\<lhd> \\<sigma>\n  trm_rep (s \\<lhd> \\<sigma>) S = trm_rep s'' S", "have \"(trm_rep ?s  S) = (trm_rep (subst s' \\<sigma>) S)\""], ["proof (prove)\nusing this:\n  s'' = s' \\<lhd> \\<sigma>\n  trm_rep (s \\<lhd> \\<sigma>) S = trm_rep s'' S\n\ngoal (1 subgoal):\n 1. trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (s' \\<lhd> \\<sigma>) S", "by blast"], ["proof (state)\nthis:\n  trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (s' \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n            C L1 S \\<sigma> \\<Longrightarrow>\n    False", "from \\<open>L' \\<in> (C- { L1 })\\<close> \\<open>orient_lit_inst L' t' s' pos \\<sigma>\\<close> \\<open>(subst t' \\<sigma>) = ?t\\<close> \n  \\<open>(trm_rep ?s  S) = (trm_rep (subst s' \\<sigma>) S)\\<close>"], ["proof (chain)\npicking this:\n  L' \\<in> C - {L1}\n  orient_lit_inst L' t' s' pos \\<sigma>\n  t' \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>\n  trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (s' \\<lhd> \\<sigma>) S", "have \"equivalent_eq_exists t s C (int_clset S) \\<sigma> L1\""], ["proof (prove)\nusing this:\n  L' \\<in> C - {L1}\n  orient_lit_inst L' t' s' pos \\<sigma>\n  t' \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>\n  trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (s' \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. equivalent_eq_exists t s C (int_clset S) \\<sigma> L1", "unfolding equivalent_eq_exists_def same_values_def int_clset_def"], ["proof (prove)\nusing this:\n  L' \\<in> C - {L1}\n  orient_lit_inst L' t' s' pos \\<sigma>\n  t' \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>\n  trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (s' \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C - {L1}.\n       \\<exists>u v.\n          orient_lit_inst L u v pos \\<sigma> \\<and>\n          t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<and>\n          trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S", "by metis"], ["proof (state)\nthis:\n  equivalent_eq_exists t s C (int_clset S) \\<sigma> L1\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n            C L1 S \\<sigma> \\<Longrightarrow>\n    False", "from this and assms(1)"], ["proof (chain)\npicking this:\n  equivalent_eq_exists t s C (int_clset S) \\<sigma> L1\n  \\<not> equivalent_eq_exists t s C (int_clset S) \\<sigma> L1", "show False"], ["proof (prove)\nusing this:\n  equivalent_eq_exists t s C (int_clset S) \\<sigma> L1\n  \\<not> equivalent_eq_exists t s C (int_clset S) \\<sigma> L1\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma max_pos_lit_dominates_cl:\n  assumes \"maximal_literal (subst_lit L \\<sigma>) (subst_cl C \\<sigma>)\"\n  assumes \"orient_lit_inst L t s pos \\<sigma>\"\n  assumes \"L' \\<in> C - { L }\"\n  assumes \"\\<not>equivalent_eq_exists t s C I \\<sigma> L\"\n  assumes \"vars_of_lit (subst_lit L \\<sigma>) = {}\"\n  assumes \"vars_of_lit (subst_lit L' \\<sigma>) = {}\"\n  assumes \"fo_interpretation I\"\n  shows \"((subst_lit L' \\<sigma>),(subst_lit L \\<sigma>)) \\<in> lit_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "let ?L' = \"(subst_lit L' \\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "let ?L = \"(subst_lit L \\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "let ?t = \"(subst t \\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "let ?s = \"(subst s \\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from assms(2)"], ["proof (chain)\npicking this:\n  orient_lit_inst L t s pos \\<sigma>", "have \"(?t,?s) \\<notin> trm_ord\""], ["proof (prove)\nusing this:\n  orient_lit_inst L t s pos \\<sigma>\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  (L = Pos (Eq t s) \\<or> L = Pos (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  pos = pos \\<or>\n  (L = Neg (Eq t s) \\<or> L = Neg (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and> pos = neg\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "obtain u' v' where \"L' = (Pos (Eq u' v')) \\<or> L' = (Neg  (Eq u' v'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u' v'.\n        L' = Pos (Eq u' v') \\<or> L' = Neg (Eq u' v') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using literal.exhaust equation.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x1. ?y = Pos x1 \\<Longrightarrow> ?P;\n   \\<And>x2. ?y = Neg x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  (\\<And>x1 x2. ?y = Eq x1 x2 \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>u' v'.\n        L' = Pos (Eq u' v') \\<or> L' = Neg (Eq u' v') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  L' = Pos (Eq u' v') \\<or> L' = Neg (Eq u' v')\n\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  L' = Pos (Eq u' v') \\<or> L' = Neg (Eq u' v')", "obtain polarity u v where \"orient_lit_inst L' u v polarity \\<sigma>\" \n    and \"((subst u \\<sigma>),(subst v \\<sigma>)) \\<notin>  trm_ord\""], ["proof (prove)\nusing this:\n  L' = Pos (Eq u' v') \\<or> L' = Neg (Eq u' v')\n\ngoal (1 subgoal):\n 1. (\\<And>u v polarity.\n        \\<lbrakk>orient_lit_inst L' u v polarity \\<sigma>;\n         (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using  \n    trm_ord_trans trm_ord_irrefl"], ["proof (prove)\nusing this:\n  L' = Pos (Eq u' v') \\<or> L' = Neg (Eq u' v')\n  trans trm_ord\n  irrefl trm_ord\n\ngoal (1 subgoal):\n 1. (\\<And>u v polarity.\n        \\<lbrakk>orient_lit_inst L' u v polarity \\<sigma>;\n         (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding trans_def irrefl_def orient_lit_inst_def"], ["proof (prove)\nusing this:\n  L' = Pos (Eq u' v') \\<or> L' = Neg (Eq u' v')\n  \\<forall>x y z.\n     (x, y) \\<in> trm_ord \\<longrightarrow>\n     (y, z) \\<in> trm_ord \\<longrightarrow> (x, z) \\<in> trm_ord\n  \\<forall>a. (a, a) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. (\\<And>u v polarity.\n        \\<lbrakk>(L' = Pos (Eq u v) \\<or> L' = Pos (Eq v u)) \\<and>\n                 (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>)\n                 \\<notin> trm_ord \\<and>\n                 polarity = pos \\<or>\n                 (L' = Neg (Eq u v) \\<or> L' = Neg (Eq v u)) \\<and>\n                 (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>)\n                 \\<notin> trm_ord \\<and>\n                 polarity = neg;\n         (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  orient_lit_inst L' u v polarity \\<sigma>\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "let ?u = \"(subst u \\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "let ?v = \"(subst v \\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from \\<open>orient_lit_inst L' u v polarity \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L' u v polarity \\<sigma>", "have \"orient_lit ?L' ?u ?v polarity\""], ["proof (prove)\nusing this:\n  orient_lit_inst L' u v polarity \\<sigma>\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit L' \\<sigma>) (u \\<lhd> \\<sigma>)\n     (v \\<lhd> \\<sigma>) polarity", "using lift_orient_lit"], ["proof (prove)\nusing this:\n  orient_lit_inst L' u v polarity \\<sigma>\n  orient_lit_inst ?L ?t ?s ?p ?\\<sigma> \\<Longrightarrow>\n  orient_lit (subst_lit ?L ?\\<sigma>) (?t \\<lhd> ?\\<sigma>)\n   (?s \\<lhd> ?\\<sigma>) ?p\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit L' \\<sigma>) (u \\<lhd> \\<sigma>)\n     (v \\<lhd> \\<sigma>) polarity", "by auto"], ["proof (state)\nthis:\n  orient_lit (subst_lit L' \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   polarity\n\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from \\<open>orient_lit_inst L t s pos \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L t s pos \\<sigma>", "have \"orient_lit ?L ?t ?s pos\""], ["proof (prove)\nusing this:\n  orient_lit_inst L t s pos \\<sigma>\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>)\n     (s \\<lhd> \\<sigma>) pos", "using lift_orient_lit"], ["proof (prove)\nusing this:\n  orient_lit_inst L t s pos \\<sigma>\n  orient_lit_inst ?L ?t ?s ?p ?\\<sigma> \\<Longrightarrow>\n  orient_lit (subst_lit ?L ?\\<sigma>) (?t \\<lhd> ?\\<sigma>)\n   (?s \\<lhd> ?\\<sigma>) ?p\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>)\n     (s \\<lhd> \\<sigma>) pos", "by auto"], ["proof (state)\nthis:\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from assms(6) and \\<open>orient_lit ?L' ?u ?v polarity\\<close>"], ["proof (chain)\npicking this:\n  vars_of_lit (subst_lit L' \\<sigma>) = {}\n  orient_lit (subst_lit L' \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   polarity", "have \"vars_of ?u \\<subseteq> {}\""], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L' \\<sigma>) = {}\n  orient_lit (subst_lit L' \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   polarity\n\ngoal (1 subgoal):\n 1. vars_of (u \\<lhd> \\<sigma>) \\<subseteq> {}", "using orient_lit_vars"], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L' \\<sigma>) = {}\n  orient_lit (subst_lit L' \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   polarity\n  orient_lit ?L ?t ?s ?p \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of (u \\<lhd> \\<sigma>) \\<subseteq> {}", "by metis"], ["proof (state)\nthis:\n  vars_of (u \\<lhd> \\<sigma>) \\<subseteq> {}\n\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from assms(6) and \\<open>orient_lit ?L' ?u ?v polarity\\<close>"], ["proof (chain)\npicking this:\n  vars_of_lit (subst_lit L' \\<sigma>) = {}\n  orient_lit (subst_lit L' \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   polarity", "have \"vars_of ?v \\<subseteq> {}\""], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L' \\<sigma>) = {}\n  orient_lit (subst_lit L' \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   polarity\n\ngoal (1 subgoal):\n 1. vars_of (v \\<lhd> \\<sigma>) \\<subseteq> {}", "using orient_lit_vars"], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L' \\<sigma>) = {}\n  orient_lit (subst_lit L' \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   polarity\n  orient_lit ?L ?t ?s ?p \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of (v \\<lhd> \\<sigma>) \\<subseteq> {}", "by metis"], ["proof (state)\nthis:\n  vars_of (v \\<lhd> \\<sigma>) \\<subseteq> {}\n\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from assms(5) and \\<open>orient_lit ?L ?t ?s pos\\<close>"], ["proof (chain)\npicking this:\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos", "have \"vars_of ?t \\<subseteq> {}\""], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n\ngoal (1 subgoal):\n 1. vars_of (t \\<lhd> \\<sigma>) \\<subseteq> {}", "using orient_lit_vars"], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  orient_lit ?L ?t ?s ?p \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of (t \\<lhd> \\<sigma>) \\<subseteq> {}", "by metis"], ["proof (state)\nthis:\n  vars_of (t \\<lhd> \\<sigma>) \\<subseteq> {}\n\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from assms(5) and \\<open>orient_lit ?L ?t ?s pos\\<close>"], ["proof (chain)\npicking this:\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos", "have \"vars_of ?s \\<subseteq> {}\""], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n\ngoal (1 subgoal):\n 1. vars_of (s \\<lhd> \\<sigma>) \\<subseteq> {}", "using orient_lit_vars"], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  orient_lit ?L ?t ?s ?p \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of (s \\<lhd> \\<sigma>) \\<subseteq> {}", "by metis"], ["proof (state)\nthis:\n  vars_of (s \\<lhd> \\<sigma>) \\<subseteq> {}\n\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from assms(1) and \\<open>L' \\<in> C - { L }\\<close>"], ["proof (chain)\npicking this:\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl C \\<sigma>)\n  L' \\<in> C - {L}", "have \"(?L,?L') \\<notin> lit_ord\""], ["proof (prove)\nusing this:\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl C \\<sigma>)\n  L' \\<in> C - {L}\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit L' \\<sigma>) \\<notin> lit_ord", "unfolding maximal_literal_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in> subst_cl C \\<sigma> \\<longrightarrow>\n     (subst_lit L \\<sigma>, x) \\<notin> lit_ord\n  L' \\<in> C - {L}\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit L' \\<sigma>) \\<notin> lit_ord", "by auto"], ["proof (state)\nthis:\n  (subst_lit L \\<sigma>, subst_lit L' \\<sigma>) \\<notin> lit_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from this and \\<open>orient_lit ?L ?t ?s pos\\<close> \\<open>orient_lit ?L' ?u ?v polarity\\<close> and assms(5) assms(6)"], ["proof (chain)\npicking this:\n  (subst_lit L \\<sigma>, subst_lit L' \\<sigma>) \\<notin> lit_ord\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  orient_lit (subst_lit L' \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   polarity\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  vars_of_lit (subst_lit L' \\<sigma>) = {}", "have \"(?t,?u) \\<notin> trm_ord\""], ["proof (prove)\nusing this:\n  (subst_lit L \\<sigma>, subst_lit L' \\<sigma>) \\<notin> lit_ord\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  orient_lit (subst_lit L' \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   polarity\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  vars_of_lit (subst_lit L' \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<notin> trm_ord", "using lit_ord_dominating_term"], ["proof (prove)\nusing this:\n  (subst_lit L \\<sigma>, subst_lit L' \\<sigma>) \\<notin> lit_ord\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  orient_lit (subst_lit L' \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   polarity\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  vars_of_lit (subst_lit L' \\<sigma>) = {}\n  \\<lbrakk>(?s1.0, ?s2.0) \\<in> trm_ord \\<or> (?s1.0, ?t2.0) \\<in> trm_ord;\n   orient_lit ?x1.0 ?s1.0 ?t1.0 ?p1.0; orient_lit ?x2.0 ?s2.0 ?t2.0 ?p2.0;\n   vars_of_lit ?x1.0 = {}; vars_of_lit ?x2.0 = {}\\<rbrakk>\n  \\<Longrightarrow> (?x1.0, ?x2.0) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<notin> trm_ord", "by metis"], ["proof (state)\nthis:\n  (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from this and \\<open>vars_of ?t \\<subseteq> {}\\<close> \\<open>vars_of ?u \\<subseteq> {}\\<close>"], ["proof (chain)\npicking this:\n  (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (t \\<lhd> \\<sigma>) \\<subseteq> {}\n  vars_of (u \\<lhd> \\<sigma>) \\<subseteq> {}", "have \"?u = ?t \\<or> (?u,?t) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (t \\<lhd> \\<sigma>) \\<subseteq> {}\n  vars_of (u \\<lhd> \\<sigma>) \\<subseteq> {}\n\ngoal (1 subgoal):\n 1. u \\<lhd> \\<sigma> = t \\<lhd> \\<sigma> \\<or>\n    (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "using trm_ord_ground_total"], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (t \\<lhd> \\<sigma>) \\<subseteq> {}\n  vars_of (u \\<lhd> \\<sigma>) \\<subseteq> {}\n  \\<forall>x y.\n     ground_term x \\<longrightarrow>\n     ground_term y \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. u \\<lhd> \\<sigma> = t \\<lhd> \\<sigma> \\<or>\n    (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "unfolding ground_term_def"], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (t \\<lhd> \\<sigma>) \\<subseteq> {}\n  vars_of (u \\<lhd> \\<sigma>) \\<subseteq> {}\n  \\<forall>x y.\n     vars_of x = {} \\<longrightarrow>\n     vars_of y = {} \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. u \\<lhd> \\<sigma> = t \\<lhd> \\<sigma> \\<or>\n    (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "by blast"], ["proof (state)\nthis:\n  u \\<lhd> \\<sigma> = t \\<lhd> \\<sigma> \\<or>\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from \\<open>(?u,?v) \\<notin> trm_ord\\<close> and \\<open>vars_of ?u \\<subseteq> {}\\<close> \\<open>vars_of ?v \\<subseteq> {}\\<close>"], ["proof (chain)\npicking this:\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (u \\<lhd> \\<sigma>) \\<subseteq> {}\n  vars_of (v \\<lhd> \\<sigma>) \\<subseteq> {}", "have \"?u = ?v \\<or> (?v,?u) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (u \\<lhd> \\<sigma>) \\<subseteq> {}\n  vars_of (v \\<lhd> \\<sigma>) \\<subseteq> {}\n\ngoal (1 subgoal):\n 1. u \\<lhd> \\<sigma> = v \\<lhd> \\<sigma> \\<or>\n    (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord", "using trm_ord_ground_total"], ["proof (prove)\nusing this:\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (u \\<lhd> \\<sigma>) \\<subseteq> {}\n  vars_of (v \\<lhd> \\<sigma>) \\<subseteq> {}\n  \\<forall>x y.\n     ground_term x \\<longrightarrow>\n     ground_term y \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. u \\<lhd> \\<sigma> = v \\<lhd> \\<sigma> \\<or>\n    (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord", "unfolding ground_term_def"], ["proof (prove)\nusing this:\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (u \\<lhd> \\<sigma>) \\<subseteq> {}\n  vars_of (v \\<lhd> \\<sigma>) \\<subseteq> {}\n  \\<forall>x y.\n     vars_of x = {} \\<longrightarrow>\n     vars_of y = {} \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. u \\<lhd> \\<sigma> = v \\<lhd> \\<sigma> \\<or>\n    (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord", "by blast"], ["proof (state)\nthis:\n  u \\<lhd> \\<sigma> = v \\<lhd> \\<sigma> \\<or>\n  (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from \\<open>(?t,?s) \\<notin> trm_ord\\<close> and \\<open>vars_of ?t \\<subseteq> {}\\<close> \\<open>vars_of ?s \\<subseteq> {}\\<close>"], ["proof (chain)\npicking this:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (t \\<lhd> \\<sigma>) \\<subseteq> {}\n  vars_of (s \\<lhd> \\<sigma>) \\<subseteq> {}", "have \"?t = ?s \\<or> (?s,?t) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (t \\<lhd> \\<sigma>) \\<subseteq> {}\n  vars_of (s \\<lhd> \\<sigma>) \\<subseteq> {}\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<or>\n    (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "using trm_ord_ground_total"], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (t \\<lhd> \\<sigma>) \\<subseteq> {}\n  vars_of (s \\<lhd> \\<sigma>) \\<subseteq> {}\n  \\<forall>x y.\n     ground_term x \\<longrightarrow>\n     ground_term y \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<or>\n    (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "unfolding ground_term_def"], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (t \\<lhd> \\<sigma>) \\<subseteq> {}\n  vars_of (s \\<lhd> \\<sigma>) \\<subseteq> {}\n  \\<forall>x y.\n     vars_of x = {} \\<longrightarrow>\n     vars_of y = {} \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<or>\n    (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "by blast"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<or>\n  (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from \\<open>vars_of ?v \\<subseteq> {}\\<close> \\<open>vars_of ?s \\<subseteq> {}\\<close>"], ["proof (chain)\npicking this:\n  vars_of (v \\<lhd> \\<sigma>) \\<subseteq> {}\n  vars_of (s \\<lhd> \\<sigma>) \\<subseteq> {}", "have \"?v = ?s \\<or> (?v,?s) \\<in> trm_ord \\<or> (?s,?v) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  vars_of (v \\<lhd> \\<sigma>) \\<subseteq> {}\n  vars_of (s \\<lhd> \\<sigma>) \\<subseteq> {}\n\ngoal (1 subgoal):\n 1. v \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<or>\n    (v \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<in> trm_ord \\<or>\n    (s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<in> trm_ord", "using trm_ord_ground_total"], ["proof (prove)\nusing this:\n  vars_of (v \\<lhd> \\<sigma>) \\<subseteq> {}\n  vars_of (s \\<lhd> \\<sigma>) \\<subseteq> {}\n  \\<forall>x y.\n     ground_term x \\<longrightarrow>\n     ground_term y \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. v \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<or>\n    (v \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<in> trm_ord \\<or>\n    (s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<in> trm_ord", "unfolding ground_term_def"], ["proof (prove)\nusing this:\n  vars_of (v \\<lhd> \\<sigma>) \\<subseteq> {}\n  vars_of (s \\<lhd> \\<sigma>) \\<subseteq> {}\n  \\<forall>x y.\n     vars_of x = {} \\<longrightarrow>\n     vars_of y = {} \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. v \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<or>\n    (v \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<in> trm_ord \\<or>\n    (s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<in> trm_ord", "by blast"], ["proof (state)\nthis:\n  v \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<or>\n  (v \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<in> trm_ord \\<or>\n  (s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord\n 2. \\<not> ?P \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "assume \"(?u,?t) \\<in> trm_ord\""], ["proof (state)\nthis:\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord\n 2. \\<not> ?P \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from this and \\<open>?u = ?v \\<or> (?v,?u) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  u \\<lhd> \\<sigma> = v \\<lhd> \\<sigma> \\<or>\n  (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord", "have \"(?v,?t) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  u \\<lhd> \\<sigma> = v \\<lhd> \\<sigma> \\<or>\n  (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (v \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "using trm_ord_trans"], ["proof (prove)\nusing this:\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  u \\<lhd> \\<sigma> = v \\<lhd> \\<sigma> \\<or>\n  (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n  trans trm_ord\n\ngoal (1 subgoal):\n 1. (v \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "unfolding trans_def"], ["proof (prove)\nusing this:\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  u \\<lhd> \\<sigma> = v \\<lhd> \\<sigma> \\<or>\n  (v \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n  \\<forall>x y z.\n     (x, y) \\<in> trm_ord \\<longrightarrow>\n     (y, z) \\<in> trm_ord \\<longrightarrow> (x, z) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (v \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (v \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord\n 2. \\<not> ?P \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from this and \\<open>(?u,?t) \\<in> trm_ord\\<close> and \\<open>orient_lit ?L ?t ?s pos\\<close> \\<open>orient_lit ?L' ?u ?v polarity\\<close> \n      assms(5) assms(6)"], ["proof (chain)\npicking this:\n  (v \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  orient_lit (subst_lit L' \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   polarity\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  vars_of_lit (subst_lit L' \\<sigma>) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  (v \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  orient_lit (subst_lit L' \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   polarity\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  vars_of_lit (subst_lit L' \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "using  lit_ord_dominating_term"], ["proof (prove)\nusing this:\n  (v \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  orient_lit (subst_lit L' \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   polarity\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  vars_of_lit (subst_lit L' \\<sigma>) = {}\n  \\<lbrakk>(?s1.0, ?s2.0) \\<in> trm_ord \\<or> (?s1.0, ?t2.0) \\<in> trm_ord;\n   orient_lit ?x1.0 ?s1.0 ?t1.0 ?p1.0; orient_lit ?x2.0 ?s2.0 ?t2.0 ?p2.0;\n   vars_of_lit ?x1.0 = {}; vars_of_lit ?x2.0 = {}\\<rbrakk>\n  \\<Longrightarrow> (?x1.0, ?x2.0) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "by metis"], ["proof (state)\nthis:\n  (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n    \\<notin> trm_ord \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n    \\<notin> trm_ord \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "assume \"(?u,?t) \\<notin> trm_ord\""], ["proof (state)\nthis:\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n    \\<notin> trm_ord \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from this and \\<open>?u = ?t \\<or> (?u,?t) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<notin> trm_ord\n  u \\<lhd> \\<sigma> = t \\<lhd> \\<sigma> \\<or>\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "have \"?u = ?t\""], ["proof (prove)\nusing this:\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<notin> trm_ord\n  u \\<lhd> \\<sigma> = t \\<lhd> \\<sigma> \\<or>\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. u \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  u \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n    \\<notin> trm_ord \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "have \"polarity = pos\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polarity = pos", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. polarity \\<noteq> pos \\<Longrightarrow> False", "assume \"polarity \\<noteq> pos\""], ["proof (state)\nthis:\n  polarity \\<noteq> pos\n\ngoal (1 subgoal):\n 1. polarity \\<noteq> pos \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  polarity \\<noteq> pos", "have \"polarity = neg\""], ["proof (prove)\nusing this:\n  polarity \\<noteq> pos\n\ngoal (1 subgoal):\n 1. polarity = neg", "using sign.exhaust"], ["proof (prove)\nusing this:\n  polarity \\<noteq> pos\n  \\<lbrakk>?y = pos \\<Longrightarrow> ?P;\n   ?y = neg \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. polarity = neg", "by auto"], ["proof (state)\nthis:\n  polarity = neg\n\ngoal (1 subgoal):\n 1. polarity \\<noteq> pos \\<Longrightarrow> False", "from this and \\<open>?u = ?t\\<close> and  \\<open>orient_lit ?L ?t ?s pos\\<close> \n        \\<open>orient_lit ?L' ?u ?v polarity\\<close> assms(5) assms(6)"], ["proof (chain)\npicking this:\n  polarity = neg\n  u \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  orient_lit (subst_lit L' \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   polarity\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  vars_of_lit (subst_lit L' \\<sigma>) = {}", "have \"(?L,?L') \\<in> lit_ord\""], ["proof (prove)\nusing this:\n  polarity = neg\n  u \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  orient_lit (subst_lit L' \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   polarity\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  vars_of_lit (subst_lit L' \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit L' \\<sigma>) \\<in> lit_ord", "using lit_ord_neg_lit_lhs"], ["proof (prove)\nusing this:\n  polarity = neg\n  u \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  orient_lit (subst_lit L' \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   polarity\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  vars_of_lit (subst_lit L' \\<sigma>) = {}\n  \\<lbrakk>orient_lit ?x1.0 ?s ?t1.0 pos; orient_lit ?x2.0 ?s ?t2.0 neg;\n   vars_of_lit ?x1.0 = {}; vars_of_lit ?x2.0 = {}\\<rbrakk>\n  \\<Longrightarrow> (?x1.0, ?x2.0) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit L' \\<sigma>) \\<in> lit_ord", "by auto"], ["proof (state)\nthis:\n  (subst_lit L \\<sigma>, subst_lit L' \\<sigma>) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. polarity \\<noteq> pos \\<Longrightarrow> False", "from this and \\<open>(?L,?L') \\<notin> lit_ord\\<close>"], ["proof (chain)\npicking this:\n  (subst_lit L \\<sigma>, subst_lit L' \\<sigma>) \\<in> lit_ord\n  (subst_lit L \\<sigma>, subst_lit L' \\<sigma>) \\<notin> lit_ord", "show False"], ["proof (prove)\nusing this:\n  (subst_lit L \\<sigma>, subst_lit L' \\<sigma>) \\<in> lit_ord\n  (subst_lit L \\<sigma>, subst_lit L' \\<sigma>) \\<notin> lit_ord\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  polarity = pos\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n    \\<notin> trm_ord \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "have \"?v \\<noteq> ?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<Longrightarrow> False", "assume \"?v = ?s\""], ["proof (state)\nthis:\n  v \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. v \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<Longrightarrow> False", "from this assms(7)"], ["proof (chain)\npicking this:\n  v \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>\n  fo_interpretation I", "have \"I ?s ?v\""], ["proof (prove)\nusing this:\n  v \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>\n  fo_interpretation I\n\ngoal (1 subgoal):\n 1. I (s \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "unfolding fo_interpretation_def congruence_def \n        equivalence_relation_def reflexive_def"], ["proof (prove)\nusing this:\n  v \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>\n  ((\\<forall>y. I y y) \\<and> symmetric I \\<and> transitive I) \\<and>\n  compatible_with_structure I\n\ngoal (1 subgoal):\n 1. I (s \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  I (s \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. v \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<Longrightarrow> False", "from this and \\<open>orient_lit_inst L' u v polarity \\<sigma>\\<close> \\<open>polarity = pos\\<close> \\<open>?u = ?t\\<close>\n        and assms(3)"], ["proof (chain)\npicking this:\n  I (s \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n  orient_lit_inst L' u v polarity \\<sigma>\n  polarity = pos\n  u \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>\n  L' \\<in> C - {L}", "have \"equivalent_eq_exists t s C I \\<sigma> L\""], ["proof (prove)\nusing this:\n  I (s \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n  orient_lit_inst L' u v polarity \\<sigma>\n  polarity = pos\n  u \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>\n  L' \\<in> C - {L}\n\ngoal (1 subgoal):\n 1. equivalent_eq_exists t s C I \\<sigma> L", "unfolding equivalent_eq_exists_def"], ["proof (prove)\nusing this:\n  I (s \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n  orient_lit_inst L' u v polarity \\<sigma>\n  polarity = pos\n  u \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>\n  L' \\<in> C - {L}\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>C - {L}.\n       \\<exists>u v.\n          orient_lit_inst L u v pos \\<sigma> \\<and>\n          t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<and>\n          I (s \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "by metis"], ["proof (state)\nthis:\n  equivalent_eq_exists t s C I \\<sigma> L\n\ngoal (1 subgoal):\n 1. v \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<Longrightarrow> False", "from this and assms(4)"], ["proof (chain)\npicking this:\n  equivalent_eq_exists t s C I \\<sigma> L\n  \\<not> equivalent_eq_exists t s C I \\<sigma> L", "show False"], ["proof (prove)\nusing this:\n  equivalent_eq_exists t s C I \\<sigma> L\n  \\<not> equivalent_eq_exists t s C I \\<sigma> L\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n    \\<notin> trm_ord \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "have \"(?s,?v) \\<notin> trm_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<in> trm_ord \\<Longrightarrow>\n    False", "assume \"(?s,?v) \\<in> trm_ord\""], ["proof (state)\nthis:\n  (s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<in> trm_ord \\<Longrightarrow>\n    False", "from this and \\<open>?u = ?t\\<close> and  \\<open>orient_lit ?L ?t ?s pos\\<close> \\<open>orient_lit ?L' ?u ?v polarity\\<close> \n        and \\<open>polarity=pos\\<close> assms(5) assms(6)"], ["proof (chain)\npicking this:\n  (s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<in> trm_ord\n  u \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  orient_lit (subst_lit L' \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   polarity\n  polarity = pos\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  vars_of_lit (subst_lit L' \\<sigma>) = {}", "have \"(?L,?L') \\<in> lit_ord\""], ["proof (prove)\nusing this:\n  (s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<in> trm_ord\n  u \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  orient_lit (subst_lit L' \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   polarity\n  polarity = pos\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  vars_of_lit (subst_lit L' \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit L' \\<sigma>) \\<in> lit_ord", "using lit_ord_rhs"], ["proof (prove)\nusing this:\n  (s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<in> trm_ord\n  u \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  orient_lit (subst_lit L' \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   polarity\n  polarity = pos\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  vars_of_lit (subst_lit L' \\<sigma>) = {}\n  \\<lbrakk>(?t1.0, ?t2.0) \\<in> trm_ord; orient_lit ?x1.0 ?s ?t1.0 ?p;\n   orient_lit ?x2.0 ?s ?t2.0 ?p; vars_of_lit ?x1.0 = {};\n   vars_of_lit ?x2.0 = {}\\<rbrakk>\n  \\<Longrightarrow> (?x1.0, ?x2.0) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit L' \\<sigma>) \\<in> lit_ord", "by auto"], ["proof (state)\nthis:\n  (subst_lit L \\<sigma>, subst_lit L' \\<sigma>) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<in> trm_ord \\<Longrightarrow>\n    False", "from this and \\<open>(?L,?L') \\<notin> lit_ord\\<close>"], ["proof (chain)\npicking this:\n  (subst_lit L \\<sigma>, subst_lit L' \\<sigma>) \\<in> lit_ord\n  (subst_lit L \\<sigma>, subst_lit L' \\<sigma>) \\<notin> lit_ord", "show False"], ["proof (prove)\nusing this:\n  (subst_lit L \\<sigma>, subst_lit L' \\<sigma>) \\<in> lit_ord\n  (subst_lit L \\<sigma>, subst_lit L' \\<sigma>) \\<notin> lit_ord\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n    \\<notin> trm_ord \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from this and \\<open>?v \\<noteq> ?s\\<close> and \\<open>?v = ?s \\<or> (?v,?s) \\<in> trm_ord \\<or> (?s,?v) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  (s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n  v \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n  v \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<or>\n  (v \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<in> trm_ord \\<or>\n  (s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<in> trm_ord", "have \"(?v,?s) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n  v \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n  v \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<or>\n  (v \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<in> trm_ord \\<or>\n  (s \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (v \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (v \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>)\n    \\<notin> trm_ord \\<Longrightarrow>\n    (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "from this and \\<open>?u = ?t\\<close> and  \\<open>orient_lit ?L ?t ?s pos\\<close> \\<open>orient_lit ?L' ?u ?v polarity\\<close> \n        and \\<open>polarity=pos\\<close> assms(5) assms(6)"], ["proof (chain)\npicking this:\n  (v \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<in> trm_ord\n  u \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  orient_lit (subst_lit L' \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   polarity\n  polarity = pos\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  vars_of_lit (subst_lit L' \\<sigma>) = {}", "show \"(?L',?L) \\<in> lit_ord\""], ["proof (prove)\nusing this:\n  (v \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<in> trm_ord\n  u \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  orient_lit (subst_lit L' \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   polarity\n  polarity = pos\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  vars_of_lit (subst_lit L' \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "using lit_ord_rhs"], ["proof (prove)\nusing this:\n  (v \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<in> trm_ord\n  u \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  orient_lit (subst_lit L' \\<sigma>) (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n   polarity\n  polarity = pos\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  vars_of_lit (subst_lit L' \\<sigma>) = {}\n  \\<lbrakk>(?t1.0, ?t2.0) \\<in> trm_ord; orient_lit ?x1.0 ?s ?t1.0 ?p;\n   orient_lit ?x2.0 ?s ?t2.0 ?p; vars_of_lit ?x1.0 = {};\n   vars_of_lit ?x2.0 = {}\\<rbrakk>\n  \\<Longrightarrow> (?x1.0, ?x2.0) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord", "by auto"], ["proof (state)\nthis:\n  (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (subst_lit L' \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma if_all_smaller_are_false_then_cl_not_valid:\n  assumes \"(smaller_lits_are_false (subst t \\<sigma>) (subst_cl C \\<sigma>) S)\"\n  assumes \"(fo_interpretation (same_values (\\<lambda>t. (trm_rep t S))))\"\n  assumes \"orient_lit_inst L1 t s pos \\<sigma>\"\n  assumes \"maximal_literal (subst_lit L1 \\<sigma>) (subst_cl C \\<sigma>)\"\n  assumes \"ground_clause (subst_cl C \\<sigma>)\"\n  assumes \"(subst_lit L1 \\<sigma>) \\<in> (subst_cl C \\<sigma>)\"\n  assumes \"\\<not>equivalent_eq_exists t s C (same_values (\\<lambda>t. (trm_rep t S))) \\<sigma> L1\"\n  assumes \"trm_rep (subst t \\<sigma>) S = trm_rep (subst s \\<sigma>) S\"\n  shows \"(\\<not> validate_ground_clause (same_values (\\<lambda>t. (trm_rep t S))) (subst_cl ( C - { L1 } ) \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n            (subst_cl (C - {L1}) \\<sigma>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n     (subst_cl (C - {L1}) \\<sigma>) \\<Longrightarrow>\n    False", "let ?I = \"(same_values (\\<lambda>t. (trm_rep t S)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n     (subst_cl (C - {L1}) \\<sigma>) \\<Longrightarrow>\n    False", "assume \"validate_ground_clause ?I (subst_cl ( C - { L1 } ) \\<sigma>)\""], ["proof (state)\nthis:\n  validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n   (subst_cl (C - {L1}) \\<sigma>)\n\ngoal (1 subgoal):\n 1. validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n     (subst_cl (C - {L1}) \\<sigma>) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n   (subst_cl (C - {L1}) \\<sigma>)", "obtain L where \"L \\<in> (subst_cl ( C - { L1 } ) \\<sigma>)\" and \"validate_ground_lit ?I L\""], ["proof (prove)\nusing this:\n  validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n   (subst_cl (C - {L1}) \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>L \\<in> subst_cl (C - {L1}) \\<sigma>;\n         validate_ground_lit (same_values (\\<lambda>t. trm_rep t S))\n          L\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using validate_ground_clause.simps [of ?I \"(subst_cl ( C - { L1 } ) \\<sigma>)\"]"], ["proof (prove)\nusing this:\n  validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n   (subst_cl (C - {L1}) \\<sigma>)\n  validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n   (subst_cl (C - {L1}) \\<sigma>) =\n  (\\<exists>L.\n      L \\<in> subst_cl (C - {L1}) \\<sigma> \\<and>\n      validate_ground_lit (same_values (\\<lambda>t. trm_rep t S)) L)\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>L \\<in> subst_cl (C - {L1}) \\<sigma>;\n         validate_ground_lit (same_values (\\<lambda>t. trm_rep t S))\n          L\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  L \\<in> subst_cl (C - {L1}) \\<sigma>\n  validate_ground_lit (same_values (\\<lambda>t. trm_rep t S)) L\n\ngoal (1 subgoal):\n 1. validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n     (subst_cl (C - {L1}) \\<sigma>) \\<Longrightarrow>\n    False", "from \\<open>L \\<in> (subst_cl ( C - { L1 } ) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  L \\<in> subst_cl (C - {L1}) \\<sigma>", "obtain L' where \"L' \\<in> C - { L1 }\" and \n    \"L = (subst_lit L' \\<sigma>)\""], ["proof (prove)\nusing this:\n  L \\<in> subst_cl (C - {L1}) \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>L'.\n        \\<lbrakk>L' \\<in> C - {L1}; L = subst_lit L' \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L' \\<in> C - {L1}\n  L = subst_lit L' \\<sigma>\n\ngoal (1 subgoal):\n 1. validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n     (subst_cl (C - {L1}) \\<sigma>) \\<Longrightarrow>\n    False", "from \\<open>L' \\<in> C - { L1 }\\<close>  and \\<open>L = (subst_lit L' \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  L' \\<in> C - {L1}\n  L = subst_lit L' \\<sigma>", "have \"L \\<in>(subst_cl C \\<sigma>)\""], ["proof (prove)\nusing this:\n  L' \\<in> C - {L1}\n  L = subst_lit L' \\<sigma>\n\ngoal (1 subgoal):\n 1. L \\<in> subst_cl C \\<sigma>", "by auto"], ["proof (state)\nthis:\n  L \\<in> subst_cl C \\<sigma>\n\ngoal (1 subgoal):\n 1. validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n     (subst_cl (C - {L1}) \\<sigma>) \\<Longrightarrow>\n    False", "from \\<open>L \\<in>(subst_cl C \\<sigma>)\\<close> and assms(5)"], ["proof (chain)\npicking this:\n  L \\<in> subst_cl C \\<sigma>\n  ground_clause (subst_cl C \\<sigma>)", "have \"vars_of_lit L = {}\""], ["proof (prove)\nusing this:\n  L \\<in> subst_cl C \\<sigma>\n  ground_clause (subst_cl C \\<sigma>)\n\ngoal (1 subgoal):\n 1. vars_of_lit L = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_lit L = {}\n\ngoal (1 subgoal):\n 1. validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n     (subst_cl (C - {L1}) \\<sigma>) \\<Longrightarrow>\n    False", "from assms(6) and assms(5)"], ["proof (chain)\npicking this:\n  subst_lit L1 \\<sigma> \\<in> subst_cl C \\<sigma>\n  ground_clause (subst_cl C \\<sigma>)", "have \"vars_of_lit (subst_lit L1 \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  subst_lit L1 \\<sigma> \\<in> subst_cl C \\<sigma>\n  ground_clause (subst_cl C \\<sigma>)\n\ngoal (1 subgoal):\n 1. vars_of_lit (subst_lit L1 \\<sigma>) = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n     (subst_cl (C - {L1}) \\<sigma>) \\<Longrightarrow>\n    False", "obtain u v polarity where o: \"orient_lit_inst L' u v polarity \\<sigma>\" \n  and \"((subst u \\<sigma>), (subst v \\<sigma>)) \\<notin> trm_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v polarity.\n        \\<lbrakk>orient_lit_inst L' u v polarity \\<sigma>;\n         (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding orient_lit_inst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u v polarity.\n        \\<lbrakk>(L' = Pos (Eq u v) \\<or> L' = Pos (Eq v u)) \\<and>\n                 (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>)\n                 \\<notin> trm_ord \\<and>\n                 polarity = pos \\<or>\n                 (L' = Neg (Eq u v) \\<or> L' = Neg (Eq v u)) \\<and>\n                 (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>)\n                 \\<notin> trm_ord \\<and>\n                 polarity = neg;\n         (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using literal.exhaust equation.exhaust \n      trm_ord_trans trm_ord_irrefl"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x1. ?y = Pos x1 \\<Longrightarrow> ?P;\n   \\<And>x2. ?y = Neg x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  (\\<And>x1 x2. ?y = Eq x1 x2 \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n  trans trm_ord\n  irrefl trm_ord\n\ngoal (1 subgoal):\n 1. (\\<And>u v polarity.\n        \\<lbrakk>(L' = Pos (Eq u v) \\<or> L' = Pos (Eq v u)) \\<and>\n                 (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>)\n                 \\<notin> trm_ord \\<and>\n                 polarity = pos \\<or>\n                 (L' = Neg (Eq u v) \\<or> L' = Neg (Eq v u)) \\<and>\n                 (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>)\n                 \\<notin> trm_ord \\<and>\n                 polarity = neg;\n         (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding trans_def irrefl_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x1. ?y = Pos x1 \\<Longrightarrow> ?P;\n   \\<And>x2. ?y = Neg x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  (\\<And>x1 x2. ?y = Eq x1 x2 \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n  \\<forall>x y z.\n     (x, y) \\<in> trm_ord \\<longrightarrow>\n     (y, z) \\<in> trm_ord \\<longrightarrow> (x, z) \\<in> trm_ord\n  \\<forall>a. (a, a) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. (\\<And>u v polarity.\n        \\<lbrakk>(L' = Pos (Eq u v) \\<or> L' = Pos (Eq v u)) \\<and>\n                 (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>)\n                 \\<notin> trm_ord \\<and>\n                 polarity = pos \\<or>\n                 (L' = Neg (Eq u v) \\<or> L' = Neg (Eq v u)) \\<and>\n                 (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>)\n                 \\<notin> trm_ord \\<and>\n                 polarity = neg;\n         (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  orient_lit_inst L' u v polarity \\<sigma>\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n     (subst_cl (C - {L1}) \\<sigma>) \\<Longrightarrow>\n    False", "from o and \\<open>L = (subst_lit L' \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L' u v polarity \\<sigma>\n  L = subst_lit L' \\<sigma>", "have o' : \"orient_lit L (subst u \\<sigma>)  (subst v \\<sigma>) polarity\""], ["proof (prove)\nusing this:\n  orient_lit_inst L' u v polarity \\<sigma>\n  L = subst_lit L' \\<sigma>\n\ngoal (1 subgoal):\n 1. orient_lit L (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) polarity", "using lift_orient_lit"], ["proof (prove)\nusing this:\n  orient_lit_inst L' u v polarity \\<sigma>\n  L = subst_lit L' \\<sigma>\n  orient_lit_inst ?L ?t ?s ?p ?\\<sigma> \\<Longrightarrow>\n  orient_lit (subst_lit ?L ?\\<sigma>) (?t \\<lhd> ?\\<sigma>)\n   (?s \\<lhd> ?\\<sigma>) ?p\n\ngoal (1 subgoal):\n 1. orient_lit L (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) polarity", "by auto"], ["proof (state)\nthis:\n  orient_lit L (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) polarity\n\ngoal (1 subgoal):\n 1. validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n     (subst_cl (C - {L1}) \\<sigma>) \\<Longrightarrow>\n    False", "from o' and \\<open>vars_of_lit L = {}\\<close>"], ["proof (chain)\npicking this:\n  orient_lit L (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) polarity\n  vars_of_lit L = {}", "have \"vars_of (subst u \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  orient_lit L (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) polarity\n  vars_of_lit L = {}\n\ngoal (1 subgoal):\n 1. vars_of (u \\<lhd> \\<sigma>) = {}", "using orient_lit_vars"], ["proof (prove)\nusing this:\n  orient_lit L (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) polarity\n  vars_of_lit L = {}\n  orient_lit ?L ?t ?s ?p \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of (u \\<lhd> \\<sigma>) = {}", "by blast"], ["proof (state)\nthis:\n  vars_of (u \\<lhd> \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n     (subst_cl (C - {L1}) \\<sigma>) \\<Longrightarrow>\n    False", "from o' and \\<open>vars_of_lit L = {}\\<close>"], ["proof (chain)\npicking this:\n  orient_lit L (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) polarity\n  vars_of_lit L = {}", "have \"vars_of (subst v \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  orient_lit L (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) polarity\n  vars_of_lit L = {}\n\ngoal (1 subgoal):\n 1. vars_of (v \\<lhd> \\<sigma>) = {}", "using orient_lit_vars"], ["proof (prove)\nusing this:\n  orient_lit L (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) polarity\n  vars_of_lit L = {}\n  orient_lit ?L ?t ?s ?p \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of (v \\<lhd> \\<sigma>) = {}", "by blast"], ["proof (state)\nthis:\n  vars_of (v \\<lhd> \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n     (subst_cl (C - {L1}) \\<sigma>) \\<Longrightarrow>\n    False", "from assms(3)"], ["proof (chain)\npicking this:\n  orient_lit_inst L1 t s pos \\<sigma>", "have o1 : \"orient_lit (subst_lit L1 \\<sigma>) (subst t \\<sigma>) (subst s \\<sigma>) pos\""], ["proof (prove)\nusing this:\n  orient_lit_inst L1 t s pos \\<sigma>\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>)\n     (s \\<lhd> \\<sigma>) pos", "using lift_orient_lit [of L1 t s pos \\<sigma>]"], ["proof (prove)\nusing this:\n  orient_lit_inst L1 t s pos \\<sigma>\n  orient_lit_inst L1 t s pos \\<sigma> \\<Longrightarrow>\n  orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>)\n     (s \\<lhd> \\<sigma>) pos", "by auto"], ["proof (state)\nthis:\n  orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n\ngoal (1 subgoal):\n 1. validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n     (subst_cl (C - {L1}) \\<sigma>) \\<Longrightarrow>\n    False", "from o1 and \\<open>vars_of_lit (subst_lit L1 \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}", "have \"vars_of (subst t \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. vars_of (t \\<lhd> \\<sigma>) = {}", "using orient_lit_vars"], ["proof (prove)\nusing this:\n  orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}\n  orient_lit ?L ?t ?s ?p \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of (t \\<lhd> \\<sigma>) = {}", "by blast"], ["proof (state)\nthis:\n  vars_of (t \\<lhd> \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n     (subst_cl (C - {L1}) \\<sigma>) \\<Longrightarrow>\n    False", "have \"polarity = pos \\<or> polarity = neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polarity = pos \\<or> polarity = neg", "using sign.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = pos \\<Longrightarrow> ?P;\n   ?y = neg \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. polarity = pos \\<or> polarity = neg", "by auto"], ["proof (state)\nthis:\n  polarity = pos \\<or> polarity = neg\n\ngoal (1 subgoal):\n 1. validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n     (subst_cl (C - {L1}) \\<sigma>) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  polarity = pos \\<or> polarity = neg", "show False"], ["proof (prove)\nusing this:\n  polarity = pos \\<or> polarity = neg\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow> False\n 2. polarity = neg \\<Longrightarrow> False", "assume \"polarity = pos\""], ["proof (state)\nthis:\n  polarity = pos\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow> False\n 2. polarity = neg \\<Longrightarrow> False", "from this and o and assms(2) and \\<open>validate_ground_lit ?I L\\<close> and \\<open>L = (subst_lit L' \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  polarity = pos\n  orient_lit_inst L' u v polarity \\<sigma>\n  fo_interpretation (same_values (\\<lambda>t. trm_rep t S))\n  validate_ground_lit (same_values (\\<lambda>t. trm_rep t S)) L\n  L = subst_lit L' \\<sigma>", "have \"(trm_rep (subst u \\<sigma>) S) = (trm_rep (subst v \\<sigma>) S)\""], ["proof (prove)\nusing this:\n  polarity = pos\n  orient_lit_inst L' u v polarity \\<sigma>\n  fo_interpretation (same_values (\\<lambda>t. trm_rep t S))\n  validate_ground_lit (same_values (\\<lambda>t. trm_rep t S)) L\n  L = subst_lit L' \\<sigma>\n\ngoal (1 subgoal):\n 1. trm_rep (u \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S", "using orient_lit_semantics_pos [of ?I ]"], ["proof (prove)\nusing this:\n  polarity = pos\n  orient_lit_inst L' u v polarity \\<sigma>\n  fo_interpretation (same_values (\\<lambda>t. trm_rep t S))\n  validate_ground_lit (same_values (\\<lambda>t. trm_rep t S)) L\n  L = subst_lit L' \\<sigma>\n  \\<lbrakk>fo_interpretation (same_values (\\<lambda>t. trm_rep t S));\n   orient_lit_inst ?l ?u ?v pos ?\\<eta>;\n   validate_ground_lit (same_values (\\<lambda>t. trm_rep t S))\n    (subst_lit ?l ?\\<sigma>)\\<rbrakk>\n  \\<Longrightarrow> same_values (\\<lambda>t. trm_rep t S)\n                     (?u \\<lhd> ?\\<sigma>) (?v \\<lhd> ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. trm_rep (u \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S", "unfolding same_values_def"], ["proof (prove)\nusing this:\n  polarity = pos\n  orient_lit_inst L' u v polarity \\<sigma>\n  fo_interpretation (\\<lambda>x y. trm_rep x S = trm_rep y S)\n  validate_ground_lit (\\<lambda>x y. trm_rep x S = trm_rep y S) L\n  L = subst_lit L' \\<sigma>\n  \\<lbrakk>fo_interpretation (\\<lambda>x y. trm_rep x S = trm_rep y S);\n   orient_lit_inst ?l ?u ?v pos ?\\<eta>;\n   validate_ground_lit (\\<lambda>x y. trm_rep x S = trm_rep y S)\n    (subst_lit ?l ?\\<sigma>)\\<rbrakk>\n  \\<Longrightarrow> trm_rep (?u \\<lhd> ?\\<sigma>) S =\n                    trm_rep (?v \\<lhd> ?\\<sigma>) S\n\ngoal (1 subgoal):\n 1. trm_rep (u \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S", "by metis"], ["proof (state)\nthis:\n  trm_rep (u \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow> False\n 2. polarity = neg \\<Longrightarrow> False", "from assms(4) and \\<open>L \\<in>(subst_cl C \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  maximal_literal (subst_lit L1 \\<sigma>) (subst_cl C \\<sigma>)\n  L \\<in> subst_cl C \\<sigma>", "have \"((subst_lit L1 \\<sigma>),L) \\<notin> lit_ord\""], ["proof (prove)\nusing this:\n  maximal_literal (subst_lit L1 \\<sigma>) (subst_cl C \\<sigma>)\n  L \\<in> subst_cl C \\<sigma>\n\ngoal (1 subgoal):\n 1. (subst_lit L1 \\<sigma>, L) \\<notin> lit_ord", "unfolding maximal_literal_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in> subst_cl C \\<sigma> \\<longrightarrow>\n     (subst_lit L1 \\<sigma>, x) \\<notin> lit_ord\n  L \\<in> subst_cl C \\<sigma>\n\ngoal (1 subgoal):\n 1. (subst_lit L1 \\<sigma>, L) \\<notin> lit_ord", "by blast"], ["proof (state)\nthis:\n  (subst_lit L1 \\<sigma>, L) \\<notin> lit_ord\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow> False\n 2. polarity = neg \\<Longrightarrow> False", "from this and o' and o1 and \\<open>polarity=pos\\<close> and \\<open>vars_of_lit L = {}\\<close> and \\<open>L = (subst_lit L' \\<sigma>)\\<close> \n      and \\<open>vars_of_lit (subst_lit L1 \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  (subst_lit L1 \\<sigma>, L) \\<notin> lit_ord\n  orient_lit L (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) polarity\n  orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  polarity = pos\n  vars_of_lit L = {}\n  L = subst_lit L' \\<sigma>\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}", "have \"(subst t \\<sigma>, subst u \\<sigma>) \\<notin> trm_ord\"\n      and \"(subst t \\<sigma>, subst v \\<sigma>) \\<notin> trm_ord\""], ["proof (prove)\nusing this:\n  (subst_lit L1 \\<sigma>, L) \\<notin> lit_ord\n  orient_lit L (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) polarity\n  orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  polarity = pos\n  vars_of_lit L = {}\n  L = subst_lit L' \\<sigma>\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<notin> trm_ord &&&\n    (t \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord", "using lit_ord_dominating_term [of \"subst t \\<sigma>\" \"subst u \\<sigma>\"  \n          \"subst v \\<sigma>\" \"subst_lit L1 \\<sigma>\" \"subst s \\<sigma>\" pos]"], ["proof (prove)\nusing this:\n  (subst_lit L1 \\<sigma>, L) \\<notin> lit_ord\n  orient_lit L (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) polarity\n  orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  polarity = pos\n  vars_of_lit L = {}\n  L = subst_lit L' \\<sigma>\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}\n  \\<lbrakk>(t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord \\<or>\n           (t \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<in> trm_ord;\n   orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>)\n    (s \\<lhd> \\<sigma>) pos;\n   orient_lit ?x2.0 (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) ?p2.0;\n   vars_of_lit (subst_lit L1 \\<sigma>) = {}; vars_of_lit ?x2.0 = {}\\<rbrakk>\n  \\<Longrightarrow> (subst_lit L1 \\<sigma>, ?x2.0) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<notin> trm_ord &&&\n    (t \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<notin> trm_ord\n  (t \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow> False\n 2. polarity = neg \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "assume \"(subst t \\<sigma>) = (subst u \\<sigma>)\""], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "from this and assms(8) and \\<open>(trm_rep (subst u \\<sigma>) S) = (trm_rep (subst v \\<sigma>) S)\\<close>"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n  trm_rep (t \\<lhd> \\<sigma>) S = trm_rep (s \\<lhd> \\<sigma>) S\n  trm_rep (u \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S", "have \"(trm_rep (subst s \\<sigma>) S) = (trm_rep (subst v \\<sigma>) S)\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n  trm_rep (t \\<lhd> \\<sigma>) S = trm_rep (s \\<lhd> \\<sigma>) S\n  trm_rep (u \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S", "by metis"], ["proof (state)\nthis:\n  trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "from this o and \\<open>L' \\<in> C - { L1 }\\<close> \\<open>polarity = pos\\<close> \\<open>(subst t \\<sigma>) = (subst u \\<sigma>)\\<close> assms(7)"], ["proof (chain)\npicking this:\n  trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S\n  orient_lit_inst L' u v polarity \\<sigma>\n  L' \\<in> C - {L1}\n  polarity = pos\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n  \\<not> equivalent_eq_exists t s C (same_values (\\<lambda>t. trm_rep t S))\n          \\<sigma> L1", "show False"], ["proof (prove)\nusing this:\n  trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S\n  orient_lit_inst L' u v polarity \\<sigma>\n  L' \\<in> C - {L1}\n  polarity = pos\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n  \\<not> equivalent_eq_exists t s C (same_values (\\<lambda>t. trm_rep t S))\n          \\<sigma> L1\n\ngoal (1 subgoal):\n 1. False", "unfolding equivalent_eq_exists_def same_values_def"], ["proof (prove)\nusing this:\n  trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S\n  orient_lit_inst L' u v polarity \\<sigma>\n  L' \\<in> C - {L1}\n  polarity = pos\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n  \\<not> (\\<exists>L\\<in>C - {L1}.\n             \\<exists>u v.\n                orient_lit_inst L u v pos \\<sigma> \\<and>\n                t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<and>\n                trm_rep (s \\<lhd> \\<sigma>) S =\n                trm_rep (v \\<lhd> \\<sigma>) S)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> \\<noteq> u \\<lhd> \\<sigma> \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> \\<noteq> u \\<lhd> \\<sigma> \\<Longrightarrow> False", "assume \"(subst t \\<sigma>) \\<noteq> (subst u \\<sigma>)\""], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> \\<noteq> u \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> \\<noteq> u \\<lhd> \\<sigma> \\<Longrightarrow> False", "from this and \\<open>(subst t \\<sigma>, subst u \\<sigma>)  \\<notin> trm_ord\\<close>\n        and \\<open>vars_of (subst t \\<sigma>) = {}\\<close> and \\<open>vars_of (subst u \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<sigma> \\<noteq> u \\<lhd> \\<sigma>\n  (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (t \\<lhd> \\<sigma>) = {}\n  vars_of (u \\<lhd> \\<sigma>) = {}", "have \"(subst u \\<sigma>, subst t \\<sigma>) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> \\<noteq> u \\<lhd> \\<sigma>\n  (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (t \\<lhd> \\<sigma>) = {}\n  vars_of (u \\<lhd> \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "using trm_ord_ground_total"], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> \\<noteq> u \\<lhd> \\<sigma>\n  (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (t \\<lhd> \\<sigma>) = {}\n  vars_of (u \\<lhd> \\<sigma>) = {}\n  \\<forall>x y.\n     ground_term x \\<longrightarrow>\n     ground_term y \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "unfolding ground_term_def"], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> \\<noteq> u \\<lhd> \\<sigma>\n  (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (t \\<lhd> \\<sigma>) = {}\n  vars_of (u \\<lhd> \\<sigma>) = {}\n  \\<forall>x y.\n     vars_of x = {} \\<longrightarrow>\n     vars_of y = {} \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> \\<noteq> u \\<lhd> \\<sigma> \\<Longrightarrow> False", "from this and \\<open>(subst u \\<sigma>, subst v \\<sigma>)  \\<notin> trm_ord\\<close>\n        and \\<open>vars_of (subst v \\<sigma>) = {}\\<close> and \\<open>vars_of (subst t \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (v \\<lhd> \\<sigma>) = {}\n  vars_of (t \\<lhd> \\<sigma>) = {}", "have \"(subst v \\<sigma>, subst t \\<sigma>) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (v \\<lhd> \\<sigma>) = {}\n  vars_of (t \\<lhd> \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. (v \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "using trm_ord_ground_total trm_ord_trans"], ["proof (prove)\nusing this:\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (v \\<lhd> \\<sigma>) = {}\n  vars_of (t \\<lhd> \\<sigma>) = {}\n  \\<forall>x y.\n     ground_term x \\<longrightarrow>\n     ground_term y \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n  trans trm_ord\n\ngoal (1 subgoal):\n 1. (v \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "unfolding ground_term_def trans_def"], ["proof (prove)\nusing this:\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (v \\<lhd> \\<sigma>) = {}\n  vars_of (t \\<lhd> \\<sigma>) = {}\n  \\<forall>x y.\n     vars_of x = {} \\<longrightarrow>\n     vars_of y = {} \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n  \\<forall>x y z.\n     (x, y) \\<in> trm_ord \\<longrightarrow>\n     (y, z) \\<in> trm_ord \\<longrightarrow> (x, z) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (v \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (v \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> \\<noteq> u \\<lhd> \\<sigma> \\<Longrightarrow> False", "from \\<open>polarity = pos\\<close> and o' and assms(1) and \\<open>L \\<in>(subst_cl C \\<sigma>)\\<close> and \\<open>L = (subst_lit L' \\<sigma>)\\<close>\n          and \\<open>((subst u \\<sigma>), subst t \\<sigma>) \\<in> trm_ord\\<close>\n          and \\<open>((subst v \\<sigma>), subst t \\<sigma>) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  polarity = pos\n  orient_lit L (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) polarity\n  smaller_lits_are_false (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>) S\n  L \\<in> subst_cl C \\<sigma>\n  L = subst_lit L' \\<sigma>\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  (v \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "have \"trm_rep (subst u \\<sigma>) S \\<noteq> trm_rep (subst v \\<sigma>) S\""], ["proof (prove)\nusing this:\n  polarity = pos\n  orient_lit L (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) polarity\n  smaller_lits_are_false (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>) S\n  L \\<in> subst_cl C \\<sigma>\n  L = subst_lit L' \\<sigma>\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  (v \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep (u \\<lhd> \\<sigma>) S \\<noteq> trm_rep (v \\<lhd> \\<sigma>) S", "unfolding smaller_lits_are_false_def"], ["proof (prove)\nusing this:\n  polarity = pos\n  orient_lit L (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) polarity\n  \\<forall>L u v.\n     (L \\<in> subst_cl C \\<sigma> \\<longrightarrow>\n      orient_lit L u v pos \\<longrightarrow>\n      (u, t \\<lhd> \\<sigma>) \\<in> trm_ord \\<longrightarrow>\n      (v, t \\<lhd> \\<sigma>) \\<in> trm_ord \\<longrightarrow>\n      trm_rep u S \\<noteq> trm_rep v S) \\<and>\n     (L \\<in> subst_cl C \\<sigma> \\<longrightarrow>\n      orient_lit L u v neg \\<longrightarrow>\n      (u, t \\<lhd> \\<sigma>) \\<in> trm_ord \\<longrightarrow>\n      (v, t \\<lhd> \\<sigma>) \\<in> trm_ord \\<longrightarrow>\n      trm_rep u S = trm_rep v S)\n  L \\<in> subst_cl C \\<sigma>\n  L = subst_lit L' \\<sigma>\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  (v \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep (u \\<lhd> \\<sigma>) S \\<noteq> trm_rep (v \\<lhd> \\<sigma>) S", "by metis"], ["proof (state)\nthis:\n  trm_rep (u \\<lhd> \\<sigma>) S \\<noteq> trm_rep (v \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> \\<noteq> u \\<lhd> \\<sigma> \\<Longrightarrow> False", "from this and \\<open>trm_rep (subst u \\<sigma>) S = trm_rep (subst v \\<sigma>) S\\<close>"], ["proof (chain)\npicking this:\n  trm_rep (u \\<lhd> \\<sigma>) S \\<noteq> trm_rep (v \\<lhd> \\<sigma>) S\n  trm_rep (u \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S", "show False"], ["proof (prove)\nusing this:\n  trm_rep (u \\<lhd> \\<sigma>) S \\<noteq> trm_rep (v \\<lhd> \\<sigma>) S\n  trm_rep (u \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> False", "assume \"polarity = neg\""], ["proof (state)\nthis:\n  polarity = neg\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> False", "from this and o and assms(2) and \\<open>validate_ground_lit ?I L\\<close> and \\<open>L = (subst_lit L' \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  polarity = neg\n  orient_lit_inst L' u v polarity \\<sigma>\n  fo_interpretation (same_values (\\<lambda>t. trm_rep t S))\n  validate_ground_lit (same_values (\\<lambda>t. trm_rep t S)) L\n  L = subst_lit L' \\<sigma>", "have \"(trm_rep (subst u \\<sigma>) S) \\<noteq> (trm_rep (subst v \\<sigma>) S)\""], ["proof (prove)\nusing this:\n  polarity = neg\n  orient_lit_inst L' u v polarity \\<sigma>\n  fo_interpretation (same_values (\\<lambda>t. trm_rep t S))\n  validate_ground_lit (same_values (\\<lambda>t. trm_rep t S)) L\n  L = subst_lit L' \\<sigma>\n\ngoal (1 subgoal):\n 1. trm_rep (u \\<lhd> \\<sigma>) S \\<noteq> trm_rep (v \\<lhd> \\<sigma>) S", "using orient_lit_semantics_neg [of ?I ]"], ["proof (prove)\nusing this:\n  polarity = neg\n  orient_lit_inst L' u v polarity \\<sigma>\n  fo_interpretation (same_values (\\<lambda>t. trm_rep t S))\n  validate_ground_lit (same_values (\\<lambda>t. trm_rep t S)) L\n  L = subst_lit L' \\<sigma>\n  \\<lbrakk>fo_interpretation (same_values (\\<lambda>t. trm_rep t S));\n   orient_lit_inst ?l ?u ?v neg ?\\<theta>;\n   validate_ground_lit (same_values (\\<lambda>t. trm_rep t S))\n    (subst_lit ?l ?\\<sigma>)\\<rbrakk>\n  \\<Longrightarrow> \\<not> same_values (\\<lambda>t. trm_rep t S)\n                            (?u \\<lhd> ?\\<sigma>) (?v \\<lhd> ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. trm_rep (u \\<lhd> \\<sigma>) S \\<noteq> trm_rep (v \\<lhd> \\<sigma>) S", "unfolding same_values_def"], ["proof (prove)\nusing this:\n  polarity = neg\n  orient_lit_inst L' u v polarity \\<sigma>\n  fo_interpretation (\\<lambda>x y. trm_rep x S = trm_rep y S)\n  validate_ground_lit (\\<lambda>x y. trm_rep x S = trm_rep y S) L\n  L = subst_lit L' \\<sigma>\n  \\<lbrakk>fo_interpretation (\\<lambda>x y. trm_rep x S = trm_rep y S);\n   orient_lit_inst ?l ?u ?v neg ?\\<theta>;\n   validate_ground_lit (\\<lambda>x y. trm_rep x S = trm_rep y S)\n    (subst_lit ?l ?\\<sigma>)\\<rbrakk>\n  \\<Longrightarrow> trm_rep (?u \\<lhd> ?\\<sigma>) S \\<noteq>\n                    trm_rep (?v \\<lhd> ?\\<sigma>) S\n\ngoal (1 subgoal):\n 1. trm_rep (u \\<lhd> \\<sigma>) S \\<noteq> trm_rep (v \\<lhd> \\<sigma>) S", "by metis"], ["proof (state)\nthis:\n  trm_rep (u \\<lhd> \\<sigma>) S \\<noteq> trm_rep (v \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> False", "from assms(4) and \\<open>L \\<in>(subst_cl C \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  maximal_literal (subst_lit L1 \\<sigma>) (subst_cl C \\<sigma>)\n  L \\<in> subst_cl C \\<sigma>", "have \"((subst_lit L1 \\<sigma>),L) \\<notin> lit_ord\""], ["proof (prove)\nusing this:\n  maximal_literal (subst_lit L1 \\<sigma>) (subst_cl C \\<sigma>)\n  L \\<in> subst_cl C \\<sigma>\n\ngoal (1 subgoal):\n 1. (subst_lit L1 \\<sigma>, L) \\<notin> lit_ord", "unfolding maximal_literal_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in> subst_cl C \\<sigma> \\<longrightarrow>\n     (subst_lit L1 \\<sigma>, x) \\<notin> lit_ord\n  L \\<in> subst_cl C \\<sigma>\n\ngoal (1 subgoal):\n 1. (subst_lit L1 \\<sigma>, L) \\<notin> lit_ord", "by blast"], ["proof (state)\nthis:\n  (subst_lit L1 \\<sigma>, L) \\<notin> lit_ord\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> False", "from this and o' and o1 and \\<open>vars_of_lit L = {}\\<close> and \\<open>L = (subst_lit L' \\<sigma>)\\<close> \n      and \\<open>vars_of_lit (subst_lit L1 \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  (subst_lit L1 \\<sigma>, L) \\<notin> lit_ord\n  orient_lit L (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) polarity\n  orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  vars_of_lit L = {}\n  L = subst_lit L' \\<sigma>\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}", "have \"(subst t \\<sigma>, subst u \\<sigma>) \\<notin> trm_ord\"\n      and \"(subst t \\<sigma>, subst v \\<sigma>) \\<notin> trm_ord\""], ["proof (prove)\nusing this:\n  (subst_lit L1 \\<sigma>, L) \\<notin> lit_ord\n  orient_lit L (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) polarity\n  orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  vars_of_lit L = {}\n  L = subst_lit L' \\<sigma>\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<notin> trm_ord &&&\n    (t \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord", "using lit_ord_dominating_term [of \"subst t \\<sigma>\" \"subst u \\<sigma>\"  \n            \"subst v \\<sigma>\" \"subst_lit L1 \\<sigma>\" \"subst s \\<sigma>\" pos]"], ["proof (prove)\nusing this:\n  (subst_lit L1 \\<sigma>, L) \\<notin> lit_ord\n  orient_lit L (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) polarity\n  orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  vars_of_lit L = {}\n  L = subst_lit L' \\<sigma>\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}\n  \\<lbrakk>(t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord \\<or>\n           (t \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<in> trm_ord;\n   orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>)\n    (s \\<lhd> \\<sigma>) pos;\n   orient_lit ?x2.0 (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) ?p2.0;\n   vars_of_lit (subst_lit L1 \\<sigma>) = {}; vars_of_lit ?x2.0 = {}\\<rbrakk>\n  \\<Longrightarrow> (subst_lit L1 \\<sigma>, ?x2.0) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<notin> trm_ord &&&\n    (t \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<notin> trm_ord\n  (t \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> False", "from \\<open>((subst_lit L1 \\<sigma>),L) \\<notin> lit_ord\\<close> and o' and o1 and \\<open>polarity=neg\\<close> and \\<open>vars_of_lit L = {}\\<close> \n      and \\<open>L = (subst_lit L' \\<sigma>)\\<close> and \\<open>vars_of_lit (subst_lit L1 \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  (subst_lit L1 \\<sigma>, L) \\<notin> lit_ord\n  orient_lit L (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) polarity\n  orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  polarity = neg\n  vars_of_lit L = {}\n  L = subst_lit L' \\<sigma>\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}", "have \"subst t \\<sigma> \\<noteq> subst u \\<sigma>\""], ["proof (prove)\nusing this:\n  (subst_lit L1 \\<sigma>, L) \\<notin> lit_ord\n  orient_lit L (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) polarity\n  orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  polarity = neg\n  vars_of_lit L = {}\n  L = subst_lit L' \\<sigma>\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> \\<noteq> u \\<lhd> \\<sigma>", "using lit_ord_neg_lit_lhs"], ["proof (prove)\nusing this:\n  (subst_lit L1 \\<sigma>, L) \\<notin> lit_ord\n  orient_lit L (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) polarity\n  orient_lit (subst_lit L1 \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   pos\n  polarity = neg\n  vars_of_lit L = {}\n  L = subst_lit L' \\<sigma>\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}\n  \\<lbrakk>orient_lit ?x1.0 ?s ?t1.0 pos; orient_lit ?x2.0 ?s ?t2.0 neg;\n   vars_of_lit ?x1.0 = {}; vars_of_lit ?x2.0 = {}\\<rbrakk>\n  \\<Longrightarrow> (?x1.0, ?x2.0) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> \\<noteq> u \\<lhd> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> \\<noteq> u \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> False", "from this and \\<open>(subst t \\<sigma>, subst u \\<sigma>)  \\<notin> trm_ord\\<close> and \\<open>vars_of (subst t \\<sigma>) = {}\\<close> \n        and \\<open>vars_of (subst u \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<sigma> \\<noteq> u \\<lhd> \\<sigma>\n  (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (t \\<lhd> \\<sigma>) = {}\n  vars_of (u \\<lhd> \\<sigma>) = {}", "have \"(subst u \\<sigma>, subst t \\<sigma>) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> \\<noteq> u \\<lhd> \\<sigma>\n  (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (t \\<lhd> \\<sigma>) = {}\n  vars_of (u \\<lhd> \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "using trm_ord_ground_total"], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> \\<noteq> u \\<lhd> \\<sigma>\n  (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (t \\<lhd> \\<sigma>) = {}\n  vars_of (u \\<lhd> \\<sigma>) = {}\n  \\<forall>x y.\n     ground_term x \\<longrightarrow>\n     ground_term y \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "unfolding ground_term_def"], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> \\<noteq> u \\<lhd> \\<sigma>\n  (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (t \\<lhd> \\<sigma>) = {}\n  vars_of (u \\<lhd> \\<sigma>) = {}\n  \\<forall>x y.\n     vars_of x = {} \\<longrightarrow>\n     vars_of y = {} \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> False", "from this and \\<open>(subst u \\<sigma>, subst v \\<sigma>)  \\<notin> trm_ord\\<close> and \\<open>vars_of (subst v \\<sigma>) = {}\\<close> \n        and \\<open>vars_of (subst t \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (v \\<lhd> \\<sigma>) = {}\n  vars_of (t \\<lhd> \\<sigma>) = {}", "have \"(subst v \\<sigma>, subst t \\<sigma>) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (v \\<lhd> \\<sigma>) = {}\n  vars_of (t \\<lhd> \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. (v \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "using trm_ord_ground_total trm_ord_trans"], ["proof (prove)\nusing this:\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (v \\<lhd> \\<sigma>) = {}\n  vars_of (t \\<lhd> \\<sigma>) = {}\n  \\<forall>x y.\n     ground_term x \\<longrightarrow>\n     ground_term y \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n  trans trm_ord\n\ngoal (1 subgoal):\n 1. (v \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "unfolding ground_term_def trans_def"], ["proof (prove)\nusing this:\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (v \\<lhd> \\<sigma>) = {}\n  vars_of (t \\<lhd> \\<sigma>) = {}\n  \\<forall>x y.\n     vars_of x = {} \\<longrightarrow>\n     vars_of y = {} \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n  \\<forall>x y z.\n     (x, y) \\<in> trm_ord \\<longrightarrow>\n     (y, z) \\<in> trm_ord \\<longrightarrow> (x, z) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (v \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (v \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> False", "from \\<open>polarity = neg\\<close> and o' and assms(1) and \\<open>L \\<in>(subst_cl C \\<sigma>)\\<close> and \\<open>L = (subst_lit L' \\<sigma>)\\<close>\n          and \\<open>((subst u \\<sigma>), subst t \\<sigma>) \\<in> trm_ord\\<close> and \\<open>((subst v \\<sigma>), subst t \\<sigma>) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  polarity = neg\n  orient_lit L (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) polarity\n  smaller_lits_are_false (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>) S\n  L \\<in> subst_cl C \\<sigma>\n  L = subst_lit L' \\<sigma>\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  (v \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "have \"trm_rep (subst u \\<sigma>) S = trm_rep (subst v \\<sigma>) S\""], ["proof (prove)\nusing this:\n  polarity = neg\n  orient_lit L (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) polarity\n  smaller_lits_are_false (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>) S\n  L \\<in> subst_cl C \\<sigma>\n  L = subst_lit L' \\<sigma>\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  (v \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep (u \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S", "unfolding smaller_lits_are_false_def"], ["proof (prove)\nusing this:\n  polarity = neg\n  orient_lit L (u \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>) polarity\n  \\<forall>L u v.\n     (L \\<in> subst_cl C \\<sigma> \\<longrightarrow>\n      orient_lit L u v pos \\<longrightarrow>\n      (u, t \\<lhd> \\<sigma>) \\<in> trm_ord \\<longrightarrow>\n      (v, t \\<lhd> \\<sigma>) \\<in> trm_ord \\<longrightarrow>\n      trm_rep u S \\<noteq> trm_rep v S) \\<and>\n     (L \\<in> subst_cl C \\<sigma> \\<longrightarrow>\n      orient_lit L u v neg \\<longrightarrow>\n      (u, t \\<lhd> \\<sigma>) \\<in> trm_ord \\<longrightarrow>\n      (v, t \\<lhd> \\<sigma>) \\<in> trm_ord \\<longrightarrow>\n      trm_rep u S = trm_rep v S)\n  L \\<in> subst_cl C \\<sigma>\n  L = subst_lit L' \\<sigma>\n  (u \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  (v \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep (u \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S", "by metis"], ["proof (state)\nthis:\n  trm_rep (u \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> False", "from this and \\<open>trm_rep (subst u \\<sigma>) S \\<noteq> trm_rep (subst v \\<sigma>) S\\<close>"], ["proof (chain)\npicking this:\n  trm_rep (u \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S\n  trm_rep (u \\<lhd> \\<sigma>) S \\<noteq> trm_rep (v \\<lhd> \\<sigma>) S", "show False"], ["proof (prove)\nusing this:\n  trm_rep (u \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S\n  trm_rep (u \\<lhd> \\<sigma>) S \\<noteq> trm_rep (v \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We introduce the notion of a reduction, which is a ground superposition inference \nsatisfying some additional conditions: \n\n(i) the ``from'' clause is smaller than the ``into'' clause;\n\n(ii) its ``body'' (i.e., the part of the clause without the equation involved \nin the rule) is false in a given interpretation and strictly smaller than the involved equation.\\<close>"], ["", "definition reduction\nwhere \"(reduction L1 C \\<sigma>' t s polarity L2 u u' p v D I S \\<sigma>) =  \n       ( (D \\<in> S) \\<and> (eligible_literal L1 C \\<sigma>') \\<and> (eligible_literal L2 D \\<sigma>')\n       \\<and> ground_clause (subst_cl (cl_ecl D) \\<sigma>')\n       \\<and> (minimal_redex p (subst t \\<sigma>) C S t)\n       \\<and> (coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)))\n       \\<and> (allowed_redex u' C \\<sigma>)\n       \\<and> (\\<not> is_a_variable u')\n       \\<and> (L1 \\<in> (cl_ecl C)) \\<and> (L2 \\<in> (cl_ecl D))\n       \\<and> (orient_lit_inst L1 t s polarity \\<sigma>') \n       \\<and> (orient_lit_inst L2 u v pos \\<sigma>') \n       \\<and> (subst u \\<sigma>') \\<noteq> (subst v \\<sigma>')\n       \\<and> (subst u' \\<sigma>') = (subst u \\<sigma>')\n       \\<and> (\\<not> validate_ground_clause I (subst_cl ( (cl_ecl D) - { L2 } ) \\<sigma>'))\n       \\<and> ( (subst_lit L2 \\<sigma>'),(subst_lit L1 \\<sigma>')) \\<in> lit_ord\n       \\<and> (\\<forall>x \\<in> (cl_ecl D) - { L2 }. ( (subst_lit x \\<sigma>'),(subst_lit L2 \\<sigma>')) \n                                        \\<in> lit_ord)\n       \\<and> (all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>') \n                  (\\<lambda>t. (trm_rep t S)))\n       \\<and> (I (subst u \\<sigma>')  (subst v \\<sigma>')) \n       \\<and> (subterm t p u'))\""], ["", "text \\<open>The next lemma states that the rules used to evaluate terms can be renamed so that\nthey share no variable with the clause in which the term occurs.\\<close>"], ["", "lemma candidate_values_renaming:\n    assumes \"(candidate_values z CC C' C s L L' \\<sigma> t' s' t S)\"\n    assumes \"finite C'\"\n    assumes \"finite (cl_ecl (D:: 'a eclause))\"\n    assumes \"closed_under_renaming S\"\n    assumes \"Ball S well_constrained\"\n    shows \"\\<exists> CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n     (candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis s'_bis t S)\n     \\<and> (vars_of_cl (cl_ecl D)) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from assms(2)"], ["proof (chain)\npicking this:\n  finite C'", "have \"finite (vars_of_cl C')\""], ["proof (prove)\nusing this:\n  finite C'\n\ngoal (1 subgoal):\n 1. finite (vars_of_cl C')", "using set_of_variables_is_finite_cl"], ["proof (prove)\nusing this:\n  finite C'\n  finite ?C \\<Longrightarrow> finite (vars_of_cl ?C)\n\ngoal (1 subgoal):\n 1. finite (vars_of_cl C')", "by auto"], ["proof (state)\nthis:\n  finite (vars_of_cl C')\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from assms(3)"], ["proof (chain)\npicking this:\n  finite (cl_ecl D)", "have \"finite (vars_of_cl (cl_ecl D))\""], ["proof (prove)\nusing this:\n  finite (cl_ecl D)\n\ngoal (1 subgoal):\n 1. finite (vars_of_cl (cl_ecl D))", "using set_of_variables_is_finite_cl"], ["proof (prove)\nusing this:\n  finite (cl_ecl D)\n  finite ?C \\<Longrightarrow> finite (vars_of_cl ?C)\n\ngoal (1 subgoal):\n 1. finite (vars_of_cl (cl_ecl D))", "by auto"], ["proof (state)\nthis:\n  finite (vars_of_cl (cl_ecl D))\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from infinite_vars"], ["proof (chain)\npicking this:\n  infinite vars", "have \"\\<not> (finite vars)\""], ["proof (prove)\nusing this:\n  infinite vars\n\ngoal (1 subgoal):\n 1. infinite vars", "by auto"], ["proof (state)\nthis:\n  infinite vars\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from \\<open>finite (vars_of_cl C')\\<close> \\<open>finite (vars_of_cl (cl_ecl D))\\<close> \n    and \\<open>\\<not> (finite vars)\\<close>"], ["proof (chain)\npicking this:\n  finite (vars_of_cl C')\n  finite (vars_of_cl (cl_ecl D))\n  infinite vars", "obtain \\<eta> where \"renaming \\<eta> (vars_of_cl C')\"\n      and \"((subst_codomain \\<eta> (vars_of_cl C')) \\<inter> (vars_of_cl (cl_ecl D))) = {}\""], ["proof (prove)\nusing this:\n  finite (vars_of_cl C')\n  finite (vars_of_cl (cl_ecl D))\n  infinite vars\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>.\n        \\<lbrakk>renaming \\<eta> (vars_of_cl C');\n         subst_codomain \\<eta> (vars_of_cl C') \\<inter>\n         vars_of_cl (cl_ecl D) =\n         {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using renaming_exists [of vars ]"], ["proof (prove)\nusing this:\n  finite (vars_of_cl C')\n  finite (vars_of_cl (cl_ecl D))\n  infinite vars\n  \\<lbrakk>infinite vars; finite ?V\\<rbrakk>\n  \\<Longrightarrow> \\<forall>V'.\n                       finite V' \\<longrightarrow>\n                       (\\<exists>\\<eta>.\n                           renaming \\<eta> ?V \\<and>\n                           subst_codomain \\<eta> ?V \\<inter> V' = {})\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>.\n        \\<lbrakk>renaming \\<eta> (vars_of_cl C');\n         subst_codomain \\<eta> (vars_of_cl C') \\<inter>\n         vars_of_cl (cl_ecl D) =\n         {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by meson"], ["proof (state)\nthis:\n  renaming \\<eta> (vars_of_cl C')\n  subst_codomain \\<eta> (vars_of_cl C') \\<inter> vars_of_cl (cl_ecl D) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from this \\<open>finite (vars_of_cl C')\\<close>"], ["proof (chain)\npicking this:\n  renaming \\<eta> (vars_of_cl C')\n  subst_codomain \\<eta> (vars_of_cl C') \\<inter> vars_of_cl (cl_ecl D) = {}\n  finite (vars_of_cl C')", "obtain \\<eta>'\n    where i: \"(\\<forall> x \\<in> (vars_of_cl C'). (subst (subst (Var x) \\<eta> ) \\<eta>') \n                                      = (Var x))\""], ["proof (prove)\nusing this:\n  renaming \\<eta> (vars_of_cl C')\n  subst_codomain \\<eta> (vars_of_cl C') \\<inter> vars_of_cl (cl_ecl D) = {}\n  finite (vars_of_cl C')\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>'.\n        \\<forall>x\\<in>vars_of_cl C'.\n           Var x \\<lhd> \\<eta> \\<lhd> \\<eta>' = Var x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using renamings_admit_inverse"], ["proof (prove)\nusing this:\n  renaming \\<eta> (vars_of_cl C')\n  subst_codomain \\<eta> (vars_of_cl C') \\<inter> vars_of_cl (cl_ecl D) = {}\n  finite (vars_of_cl C')\n  \\<lbrakk>finite ?V; renaming ?\\<sigma> ?V\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<theta>.\n                       (\\<forall>x\\<in>?V.\n                           Var x \\<lhd> ?\\<sigma> \\<lhd> \\<theta> =\n                           Var x) \\<and>\n                       (\\<forall>x.\n                           x \\<notin> subst_codomain ?\\<sigma>\n ?V \\<longrightarrow>\n                           Var x \\<lhd> \\<theta> = Var x)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>'.\n        \\<forall>x\\<in>vars_of_cl C'.\n           Var x \\<lhd> \\<eta> \\<lhd> \\<eta>' = Var x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>vars_of_cl C'. Var x \\<lhd> \\<eta> \\<lhd> \\<eta>' = Var x\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "obtain CC_bis where \"CC_bis = (subst_ecl CC \\<eta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>CC_bis.\n        CC_bis = subst_ecl CC \\<eta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  CC_bis = subst_ecl CC \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "obtain C'_bis where \"C'_bis = (subst_cl C' \\<eta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C'_bis.\n        C'_bis = subst_cl C' \\<eta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C'_bis = subst_cl C' \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from assms(1)"], ["proof (chain)\npicking this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S", "have \"C' = (cl_ecl CC)\""], ["proof (prove)\nusing this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S\n\ngoal (1 subgoal):\n 1. C' = cl_ecl CC", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  CC \\<in> S \\<and>\n  t \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n  trms_irreducible CC \\<sigma> S t \\<and>\n  C' = cl_ecl CC \\<and>\n  (s, t) \\<in> trm_ord \\<and>\n  ((s, t) \\<in> trm_ord \\<longrightarrow> z = trm_rep s S) \\<and>\n  orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n  sel C' = {} \\<and>\n  L' \\<in> C' \\<and>\n  maximal_literal L C \\<and>\n  L = subst_lit L' \\<sigma> \\<and>\n  C = subst_cl C' \\<sigma> \\<and>\n  ground_clause C \\<and>\n  t = t' \\<lhd> \\<sigma> \\<and>\n  s = s' \\<lhd> \\<sigma> \\<and>\n  finite C' \\<and>\n  smaller_lits_are_false t C S \\<and>\n  maximal_literal_is_unique t s C' L' S \\<sigma>\n\ngoal (1 subgoal):\n 1. C' = cl_ecl CC", "by metis"], ["proof (state)\nthis:\n  C' = cl_ecl CC\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from this"], ["proof (chain)\npicking this:\n  C' = cl_ecl CC", "obtain T where \"CC = (Ecl C' T)\""], ["proof (prove)\nusing this:\n  C' = cl_ecl CC\n\ngoal (1 subgoal):\n 1. (\\<And>T. CC = Ecl C' T \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis cl_ecl.simps trms_ecl.elims)"], ["proof (state)\nthis:\n  CC = Ecl C' T\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from this and \\<open>CC_bis = (subst_ecl CC \\<eta>)\\<close> \n    and \\<open>C'_bis = (subst_cl C' \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  CC = Ecl C' T\n  CC_bis = subst_ecl CC \\<eta>\n  C'_bis = subst_cl C' \\<eta>", "have \"C'_bis = (cl_ecl CC_bis)\""], ["proof (prove)\nusing this:\n  CC = Ecl C' T\n  CC_bis = subst_ecl CC \\<eta>\n  C'_bis = subst_cl C' \\<eta>\n\ngoal (1 subgoal):\n 1. C'_bis = cl_ecl CC_bis", "by auto"], ["proof (state)\nthis:\n  C'_bis = cl_ecl CC_bis\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from assms(1)"], ["proof (chain)\npicking this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S", "have \"CC \\<in> S\""], ["proof (prove)\nusing this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S\n\ngoal (1 subgoal):\n 1. CC \\<in> S", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  CC \\<in> S \\<and>\n  t \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n  trms_irreducible CC \\<sigma> S t \\<and>\n  C' = cl_ecl CC \\<and>\n  (s, t) \\<in> trm_ord \\<and>\n  ((s, t) \\<in> trm_ord \\<longrightarrow> z = trm_rep s S) \\<and>\n  orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n  sel C' = {} \\<and>\n  L' \\<in> C' \\<and>\n  maximal_literal L C \\<and>\n  L = subst_lit L' \\<sigma> \\<and>\n  C = subst_cl C' \\<sigma> \\<and>\n  ground_clause C \\<and>\n  t = t' \\<lhd> \\<sigma> \\<and>\n  s = s' \\<lhd> \\<sigma> \\<and>\n  finite C' \\<and>\n  smaller_lits_are_false t C S \\<and>\n  maximal_literal_is_unique t s C' L' S \\<sigma>\n\ngoal (1 subgoal):\n 1. CC \\<in> S", "by metis"], ["proof (state)\nthis:\n  CC \\<in> S\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from assms(1)"], ["proof (chain)\npicking this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S", "have \"(s,t) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> trm_ord", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  CC \\<in> S \\<and>\n  t \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n  trms_irreducible CC \\<sigma> S t \\<and>\n  C' = cl_ecl CC \\<and>\n  (s, t) \\<in> trm_ord \\<and>\n  ((s, t) \\<in> trm_ord \\<longrightarrow> z = trm_rep s S) \\<and>\n  orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n  sel C' = {} \\<and>\n  L' \\<in> C' \\<and>\n  maximal_literal L C \\<and>\n  L = subst_lit L' \\<sigma> \\<and>\n  C = subst_cl C' \\<sigma> \\<and>\n  ground_clause C \\<and>\n  t = t' \\<lhd> \\<sigma> \\<and>\n  s = s' \\<lhd> \\<sigma> \\<and>\n  finite C' \\<and>\n  smaller_lits_are_false t C S \\<and>\n  maximal_literal_is_unique t s C' L' S \\<sigma>\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (s, t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from assms(1)"], ["proof (chain)\npicking this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S", "have \"((s,t) \\<in> trm_ord \\<longrightarrow> (z = trm_rep s S))\""], ["proof (prove)\nusing this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> trm_ord \\<longrightarrow> z = trm_rep s S", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  CC \\<in> S \\<and>\n  t \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n  trms_irreducible CC \\<sigma> S t \\<and>\n  C' = cl_ecl CC \\<and>\n  (s, t) \\<in> trm_ord \\<and>\n  ((s, t) \\<in> trm_ord \\<longrightarrow> z = trm_rep s S) \\<and>\n  orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n  sel C' = {} \\<and>\n  L' \\<in> C' \\<and>\n  maximal_literal L C \\<and>\n  L = subst_lit L' \\<sigma> \\<and>\n  C = subst_cl C' \\<sigma> \\<and>\n  ground_clause C \\<and>\n  t = t' \\<lhd> \\<sigma> \\<and>\n  s = s' \\<lhd> \\<sigma> \\<and>\n  finite C' \\<and>\n  smaller_lits_are_false t C S \\<and>\n  maximal_literal_is_unique t s C' L' S \\<sigma>\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> trm_ord \\<longrightarrow> z = trm_rep s S", "by metis"], ["proof (state)\nthis:\n  (s, t) \\<in> trm_ord \\<longrightarrow> z = trm_rep s S\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from assms(1)"], ["proof (chain)\npicking this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S", "have \"(maximal_literal L C)\""], ["proof (prove)\nusing this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S\n\ngoal (1 subgoal):\n 1. maximal_literal L C", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  CC \\<in> S \\<and>\n  t \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n  trms_irreducible CC \\<sigma> S t \\<and>\n  C' = cl_ecl CC \\<and>\n  (s, t) \\<in> trm_ord \\<and>\n  ((s, t) \\<in> trm_ord \\<longrightarrow> z = trm_rep s S) \\<and>\n  orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n  sel C' = {} \\<and>\n  L' \\<in> C' \\<and>\n  maximal_literal L C \\<and>\n  L = subst_lit L' \\<sigma> \\<and>\n  C = subst_cl C' \\<sigma> \\<and>\n  ground_clause C \\<and>\n  t = t' \\<lhd> \\<sigma> \\<and>\n  s = s' \\<lhd> \\<sigma> \\<and>\n  finite C' \\<and>\n  smaller_lits_are_false t C S \\<and>\n  maximal_literal_is_unique t s C' L' S \\<sigma>\n\ngoal (1 subgoal):\n 1. maximal_literal L C", "by metis"], ["proof (state)\nthis:\n  maximal_literal L C\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from assms(1)"], ["proof (chain)\npicking this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S", "have \"(ground_clause C)\""], ["proof (prove)\nusing this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S\n\ngoal (1 subgoal):\n 1. ground_clause C", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  CC \\<in> S \\<and>\n  t \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n  trms_irreducible CC \\<sigma> S t \\<and>\n  C' = cl_ecl CC \\<and>\n  (s, t) \\<in> trm_ord \\<and>\n  ((s, t) \\<in> trm_ord \\<longrightarrow> z = trm_rep s S) \\<and>\n  orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n  sel C' = {} \\<and>\n  L' \\<in> C' \\<and>\n  maximal_literal L C \\<and>\n  L = subst_lit L' \\<sigma> \\<and>\n  C = subst_cl C' \\<sigma> \\<and>\n  ground_clause C \\<and>\n  t = t' \\<lhd> \\<sigma> \\<and>\n  s = s' \\<lhd> \\<sigma> \\<and>\n  finite C' \\<and>\n  smaller_lits_are_false t C S \\<and>\n  maximal_literal_is_unique t s C' L' S \\<sigma>\n\ngoal (1 subgoal):\n 1. ground_clause C", "by metis"], ["proof (state)\nthis:\n  ground_clause C\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from assms(1)"], ["proof (chain)\npicking this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S", "have \"L' \\<in> C'\""], ["proof (prove)\nusing this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S\n\ngoal (1 subgoal):\n 1. L' \\<in> C'", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  CC \\<in> S \\<and>\n  t \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n  trms_irreducible CC \\<sigma> S t \\<and>\n  C' = cl_ecl CC \\<and>\n  (s, t) \\<in> trm_ord \\<and>\n  ((s, t) \\<in> trm_ord \\<longrightarrow> z = trm_rep s S) \\<and>\n  orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n  sel C' = {} \\<and>\n  L' \\<in> C' \\<and>\n  maximal_literal L C \\<and>\n  L = subst_lit L' \\<sigma> \\<and>\n  C = subst_cl C' \\<sigma> \\<and>\n  ground_clause C \\<and>\n  t = t' \\<lhd> \\<sigma> \\<and>\n  s = s' \\<lhd> \\<sigma> \\<and>\n  finite C' \\<and>\n  smaller_lits_are_false t C S \\<and>\n  maximal_literal_is_unique t s C' L' S \\<sigma>\n\ngoal (1 subgoal):\n 1. L' \\<in> C'", "by metis"], ["proof (state)\nthis:\n  L' \\<in> C'\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from assms(1)"], ["proof (chain)\npicking this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S", "have \"L = (subst_lit L' \\<sigma>)\""], ["proof (prove)\nusing this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S\n\ngoal (1 subgoal):\n 1. L = subst_lit L' \\<sigma>", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  CC \\<in> S \\<and>\n  t \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n  trms_irreducible CC \\<sigma> S t \\<and>\n  C' = cl_ecl CC \\<and>\n  (s, t) \\<in> trm_ord \\<and>\n  ((s, t) \\<in> trm_ord \\<longrightarrow> z = trm_rep s S) \\<and>\n  orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n  sel C' = {} \\<and>\n  L' \\<in> C' \\<and>\n  maximal_literal L C \\<and>\n  L = subst_lit L' \\<sigma> \\<and>\n  C = subst_cl C' \\<sigma> \\<and>\n  ground_clause C \\<and>\n  t = t' \\<lhd> \\<sigma> \\<and>\n  s = s' \\<lhd> \\<sigma> \\<and>\n  finite C' \\<and>\n  smaller_lits_are_false t C S \\<and>\n  maximal_literal_is_unique t s C' L' S \\<sigma>\n\ngoal (1 subgoal):\n 1. L = subst_lit L' \\<sigma>", "by metis"], ["proof (state)\nthis:\n  L = subst_lit L' \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from assms(1)"], ["proof (chain)\npicking this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S", "have \"(smaller_lits_are_false t C S)\""], ["proof (prove)\nusing this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S\n\ngoal (1 subgoal):\n 1. smaller_lits_are_false t C S", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  CC \\<in> S \\<and>\n  t \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n  trms_irreducible CC \\<sigma> S t \\<and>\n  C' = cl_ecl CC \\<and>\n  (s, t) \\<in> trm_ord \\<and>\n  ((s, t) \\<in> trm_ord \\<longrightarrow> z = trm_rep s S) \\<and>\n  orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n  sel C' = {} \\<and>\n  L' \\<in> C' \\<and>\n  maximal_literal L C \\<and>\n  L = subst_lit L' \\<sigma> \\<and>\n  C = subst_cl C' \\<sigma> \\<and>\n  ground_clause C \\<and>\n  t = t' \\<lhd> \\<sigma> \\<and>\n  s = s' \\<lhd> \\<sigma> \\<and>\n  finite C' \\<and>\n  smaller_lits_are_false t C S \\<and>\n  maximal_literal_is_unique t s C' L' S \\<sigma>\n\ngoal (1 subgoal):\n 1. smaller_lits_are_false t C S", "by metis"], ["proof (state)\nthis:\n  smaller_lits_are_false t C S\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from assms(1)"], ["proof (chain)\npicking this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S", "have \"C = (subst_cl C' \\<sigma>)\""], ["proof (prove)\nusing this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S\n\ngoal (1 subgoal):\n 1. C = subst_cl C' \\<sigma>", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  CC \\<in> S \\<and>\n  t \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n  trms_irreducible CC \\<sigma> S t \\<and>\n  C' = cl_ecl CC \\<and>\n  (s, t) \\<in> trm_ord \\<and>\n  ((s, t) \\<in> trm_ord \\<longrightarrow> z = trm_rep s S) \\<and>\n  orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n  sel C' = {} \\<and>\n  L' \\<in> C' \\<and>\n  maximal_literal L C \\<and>\n  L = subst_lit L' \\<sigma> \\<and>\n  C = subst_cl C' \\<sigma> \\<and>\n  ground_clause C \\<and>\n  t = t' \\<lhd> \\<sigma> \\<and>\n  s = s' \\<lhd> \\<sigma> \\<and>\n  finite C' \\<and>\n  smaller_lits_are_false t C S \\<and>\n  maximal_literal_is_unique t s C' L' S \\<sigma>\n\ngoal (1 subgoal):\n 1. C = subst_cl C' \\<sigma>", "by metis"], ["proof (state)\nthis:\n  C = subst_cl C' \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from assms(1)"], ["proof (chain)\npicking this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S", "have \"(orient_lit_inst L' t' s' pos \\<sigma>)\""], ["proof (prove)\nusing this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S\n\ngoal (1 subgoal):\n 1. orient_lit_inst L' t' s' pos \\<sigma>", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  CC \\<in> S \\<and>\n  t \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n  trms_irreducible CC \\<sigma> S t \\<and>\n  C' = cl_ecl CC \\<and>\n  (s, t) \\<in> trm_ord \\<and>\n  ((s, t) \\<in> trm_ord \\<longrightarrow> z = trm_rep s S) \\<and>\n  orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n  sel C' = {} \\<and>\n  L' \\<in> C' \\<and>\n  maximal_literal L C \\<and>\n  L = subst_lit L' \\<sigma> \\<and>\n  C = subst_cl C' \\<sigma> \\<and>\n  ground_clause C \\<and>\n  t = t' \\<lhd> \\<sigma> \\<and>\n  s = s' \\<lhd> \\<sigma> \\<and>\n  finite C' \\<and>\n  smaller_lits_are_false t C S \\<and>\n  maximal_literal_is_unique t s C' L' S \\<sigma>\n\ngoal (1 subgoal):\n 1. orient_lit_inst L' t' s' pos \\<sigma>", "by metis"], ["proof (state)\nthis:\n  orient_lit_inst L' t' s' pos \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from assms(1)"], ["proof (chain)\npicking this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S", "have \"(trms_irreducible CC \\<sigma> S t)\""], ["proof (prove)\nusing this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S\n\ngoal (1 subgoal):\n 1. trms_irreducible CC \\<sigma> S t", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  CC \\<in> S \\<and>\n  t \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n  trms_irreducible CC \\<sigma> S t \\<and>\n  C' = cl_ecl CC \\<and>\n  (s, t) \\<in> trm_ord \\<and>\n  ((s, t) \\<in> trm_ord \\<longrightarrow> z = trm_rep s S) \\<and>\n  orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n  sel C' = {} \\<and>\n  L' \\<in> C' \\<and>\n  maximal_literal L C \\<and>\n  L = subst_lit L' \\<sigma> \\<and>\n  C = subst_cl C' \\<sigma> \\<and>\n  ground_clause C \\<and>\n  t = t' \\<lhd> \\<sigma> \\<and>\n  s = s' \\<lhd> \\<sigma> \\<and>\n  finite C' \\<and>\n  smaller_lits_are_false t C S \\<and>\n  maximal_literal_is_unique t s C' L' S \\<sigma>\n\ngoal (1 subgoal):\n 1. trms_irreducible CC \\<sigma> S t", "by metis"], ["proof (state)\nthis:\n  trms_irreducible CC \\<sigma> S t\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from assms(1)"], ["proof (chain)\npicking this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S", "have \"t = subst t' \\<sigma>\""], ["proof (prove)\nusing this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S\n\ngoal (1 subgoal):\n 1. t = t' \\<lhd> \\<sigma>", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  CC \\<in> S \\<and>\n  t \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n  trms_irreducible CC \\<sigma> S t \\<and>\n  C' = cl_ecl CC \\<and>\n  (s, t) \\<in> trm_ord \\<and>\n  ((s, t) \\<in> trm_ord \\<longrightarrow> z = trm_rep s S) \\<and>\n  orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n  sel C' = {} \\<and>\n  L' \\<in> C' \\<and>\n  maximal_literal L C \\<and>\n  L = subst_lit L' \\<sigma> \\<and>\n  C = subst_cl C' \\<sigma> \\<and>\n  ground_clause C \\<and>\n  t = t' \\<lhd> \\<sigma> \\<and>\n  s = s' \\<lhd> \\<sigma> \\<and>\n  finite C' \\<and>\n  smaller_lits_are_false t C S \\<and>\n  maximal_literal_is_unique t s C' L' S \\<sigma>\n\ngoal (1 subgoal):\n 1. t = t' \\<lhd> \\<sigma>", "by metis"], ["proof (state)\nthis:\n  t = t' \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from assms(1)"], ["proof (chain)\npicking this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S", "have \"s = subst s' \\<sigma>\""], ["proof (prove)\nusing this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S\n\ngoal (1 subgoal):\n 1. s = s' \\<lhd> \\<sigma>", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  CC \\<in> S \\<and>\n  t \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n  trms_irreducible CC \\<sigma> S t \\<and>\n  C' = cl_ecl CC \\<and>\n  (s, t) \\<in> trm_ord \\<and>\n  ((s, t) \\<in> trm_ord \\<longrightarrow> z = trm_rep s S) \\<and>\n  orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n  sel C' = {} \\<and>\n  L' \\<in> C' \\<and>\n  maximal_literal L C \\<and>\n  L = subst_lit L' \\<sigma> \\<and>\n  C = subst_cl C' \\<sigma> \\<and>\n  ground_clause C \\<and>\n  t = t' \\<lhd> \\<sigma> \\<and>\n  s = s' \\<lhd> \\<sigma> \\<and>\n  finite C' \\<and>\n  smaller_lits_are_false t C S \\<and>\n  maximal_literal_is_unique t s C' L' S \\<sigma>\n\ngoal (1 subgoal):\n 1. s = s' \\<lhd> \\<sigma>", "by metis"], ["proof (state)\nthis:\n  s = s' \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from \\<open>CC \\<in> S\\<close> and assms(4) and \\<open>renaming \\<eta> (vars_of_cl C')\\<close> and \\<open>C' = (cl_ecl CC)\\<close> \n    \\<open>CC_bis = (subst_ecl CC \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  CC \\<in> S\n  closed_under_renaming S\n  renaming \\<eta> (vars_of_cl C')\n  C' = cl_ecl CC\n  CC_bis = subst_ecl CC \\<eta>", "have \"CC_bis \\<in> S\""], ["proof (prove)\nusing this:\n  CC \\<in> S\n  closed_under_renaming S\n  renaming \\<eta> (vars_of_cl C')\n  C' = cl_ecl CC\n  CC_bis = subst_ecl CC \\<eta>\n\ngoal (1 subgoal):\n 1. CC_bis \\<in> S", "unfolding closed_under_renaming_def renaming_cl_def"], ["proof (prove)\nusing this:\n  CC \\<in> S\n  \\<forall>C D.\n     C \\<in> S \\<longrightarrow>\n     (\\<exists>\\<eta>.\n         renaming \\<eta> (vars_of_cl (cl_ecl C)) \\<and>\n         D = subst_ecl C \\<eta>) \\<longrightarrow>\n     D \\<in> S\n  renaming \\<eta> (vars_of_cl C')\n  C' = cl_ecl CC\n  CC_bis = subst_ecl CC \\<eta>\n\ngoal (1 subgoal):\n 1. CC_bis \\<in> S", "by auto"], ["proof (state)\nthis:\n  CC_bis \\<in> S\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from assms(1)"], ["proof (chain)\npicking this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S", "have \"(sel C' = {})\""], ["proof (prove)\nusing this:\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S\n\ngoal (1 subgoal):\n 1. sel C' = {}", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  CC \\<in> S \\<and>\n  t \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n  trms_irreducible CC \\<sigma> S t \\<and>\n  C' = cl_ecl CC \\<and>\n  (s, t) \\<in> trm_ord \\<and>\n  ((s, t) \\<in> trm_ord \\<longrightarrow> z = trm_rep s S) \\<and>\n  orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n  sel C' = {} \\<and>\n  L' \\<in> C' \\<and>\n  maximal_literal L C \\<and>\n  L = subst_lit L' \\<sigma> \\<and>\n  C = subst_cl C' \\<sigma> \\<and>\n  ground_clause C \\<and>\n  t = t' \\<lhd> \\<sigma> \\<and>\n  s = s' \\<lhd> \\<sigma> \\<and>\n  finite C' \\<and>\n  smaller_lits_are_false t C S \\<and>\n  maximal_literal_is_unique t s C' L' S \\<sigma>\n\ngoal (1 subgoal):\n 1. sel C' = {}", "by metis"], ["proof (state)\nthis:\n  sel C' = {}\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from this and \\<open>renaming \\<eta> (vars_of_cl C')\\<close> \\<open>C' = (cl_ecl CC)\\<close> \n    \\<open>C'_bis = (subst_cl C' \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  sel C' = {}\n  renaming \\<eta> (vars_of_cl C')\n  C' = cl_ecl CC\n  C'_bis = subst_cl C' \\<eta>", "have \"sel C'_bis = {}\""], ["proof (prove)\nusing this:\n  sel C' = {}\n  renaming \\<eta> (vars_of_cl C')\n  C' = cl_ecl CC\n  C'_bis = subst_cl C' \\<eta>\n\ngoal (1 subgoal):\n 1. sel C'_bis = {}", "using sel_renaming"], ["proof (prove)\nusing this:\n  sel C' = {}\n  renaming \\<eta> (vars_of_cl C')\n  C' = cl_ecl CC\n  C'_bis = subst_cl C' \\<eta>\n  \\<forall>\\<eta> C.\n     renaming \\<eta> (vars_of_cl C) \\<longrightarrow>\n     sel C = {} \\<longrightarrow> sel (subst_cl C \\<eta>) = {}\n\ngoal (1 subgoal):\n 1. sel C'_bis = {}", "by auto"], ["proof (state)\nthis:\n  sel C'_bis = {}\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "obtain L'_bis where \"L'_bis = (subst_lit L' \\<eta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>L'_bis.\n        L'_bis = subst_lit L' \\<eta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L'_bis = subst_lit L' \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from this and \\<open>L' \\<in> C'\\<close> \\<open>C'_bis = (subst_cl C' \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  L'_bis = subst_lit L' \\<eta>\n  L' \\<in> C'\n  C'_bis = subst_cl C' \\<eta>", "have \"L'_bis \\<in> C'_bis\""], ["proof (prove)\nusing this:\n  L'_bis = subst_lit L' \\<eta>\n  L' \\<in> C'\n  C'_bis = subst_cl C' \\<eta>\n\ngoal (1 subgoal):\n 1. L'_bis \\<in> C'_bis", "by auto"], ["proof (state)\nthis:\n  L'_bis \\<in> C'_bis\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "let ?\\<theta> = \"(comp (comp \\<eta> \\<eta>') \\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "let ?\\<theta>' = \"(comp \\<eta>' \\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "have \"coincide_on \\<sigma> ?\\<theta> (vars_of_cl C')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n     (vars_of_cl C')", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> coincide_on \\<sigma>\n            (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n            (vars_of_cl C') \\<Longrightarrow>\n    False", "assume \"\\<not>coincide_on \\<sigma> ?\\<theta> (vars_of_cl C')\""], ["proof (state)\nthis:\n  \\<not> coincide_on \\<sigma>\n          (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) (vars_of_cl C')\n\ngoal (1 subgoal):\n 1. \\<not> coincide_on \\<sigma>\n            (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n            (vars_of_cl C') \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<not> coincide_on \\<sigma>\n          (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) (vars_of_cl C')", "obtain x where \"(subst (Var x) \\<sigma>) \\<noteq> (subst (Var x) ?\\<theta>)\"\n      and \"x \\<in> vars_of_cl C'\""], ["proof (prove)\nusing this:\n  \\<not> coincide_on \\<sigma>\n          (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) (vars_of_cl C')\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>Var x \\<lhd> \\<sigma> \\<noteq>\n                 Var x \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>;\n         x \\<in> vars_of_cl C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x\\<in>vars_of_cl C'.\n             Var x \\<lhd> \\<sigma> =\n             Var x \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>Var x \\<lhd> \\<sigma> \\<noteq>\n                 Var x \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>;\n         x \\<in> vars_of_cl C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Var x \\<lhd> \\<sigma> \\<noteq>\n  Var x \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>\n  x \\<in> vars_of_cl C'\n\ngoal (1 subgoal):\n 1. \\<not> coincide_on \\<sigma>\n            (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n            (vars_of_cl C') \\<Longrightarrow>\n    False", "from \\<open>x \\<in> vars_of_cl C'\\<close> i"], ["proof (chain)\npicking this:\n  x \\<in> vars_of_cl C'\n  \\<forall>x\\<in>vars_of_cl C'. Var x \\<lhd> \\<eta> \\<lhd> \\<eta>' = Var x", "have \"(subst (subst (Var x) \\<eta> ) \\<eta>') = (Var x)\""], ["proof (prove)\nusing this:\n  x \\<in> vars_of_cl C'\n  \\<forall>x\\<in>vars_of_cl C'. Var x \\<lhd> \\<eta> \\<lhd> \\<eta>' = Var x\n\ngoal (1 subgoal):\n 1. Var x \\<lhd> \\<eta> \\<lhd> \\<eta>' = Var x", "by blast"], ["proof (state)\nthis:\n  Var x \\<lhd> \\<eta> \\<lhd> \\<eta>' = Var x\n\ngoal (1 subgoal):\n 1. \\<not> coincide_on \\<sigma>\n            (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n            (vars_of_cl C') \\<Longrightarrow>\n    False", "from this and \\<open>(subst (Var x) \\<sigma>) \\<noteq> (subst (Var x) ?\\<theta>)\\<close>"], ["proof (chain)\npicking this:\n  Var x \\<lhd> \\<eta> \\<lhd> \\<eta>' = Var x\n  Var x \\<lhd> \\<sigma> \\<noteq>\n  Var x \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>", "show False"], ["proof (prove)\nusing this:\n  Var x \\<lhd> \\<eta> \\<lhd> \\<eta>' = Var x\n  Var x \\<lhd> \\<sigma> \\<noteq>\n  Var x \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of_cl C')\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from \\<open>L' \\<in> C'\\<close>"], ["proof (chain)\npicking this:\n  L' \\<in> C'", "have \"vars_of_lit L' \\<subseteq> vars_of_cl C'\""], ["proof (prove)\nusing this:\n  L' \\<in> C'\n\ngoal (1 subgoal):\n 1. vars_of_lit L' \\<subseteq> vars_of_cl C'", "by auto"], ["proof (state)\nthis:\n  vars_of_lit L' \\<subseteq> vars_of_cl C'\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from this and \\<open>coincide_on \\<sigma> ?\\<theta> (vars_of_cl C')\\<close>"], ["proof (chain)\npicking this:\n  vars_of_lit L' \\<subseteq> vars_of_cl C'\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of_cl C')", "have \"coincide_on \\<sigma> ?\\<theta> (vars_of_lit L')\""], ["proof (prove)\nusing this:\n  vars_of_lit L' \\<subseteq> vars_of_cl C'\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of_cl C')\n\ngoal (1 subgoal):\n 1. coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n     (vars_of_lit L')", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  vars_of_lit L' \\<subseteq> vars_of_cl C'\n  \\<forall>x\\<in>vars_of_cl C'.\n     Var x \\<lhd> \\<sigma> =\n     Var x \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of_lit L'.\n       Var x \\<lhd> \\<sigma> =\n       Var x \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of_lit L')\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from this and \\<open>L = (subst_lit L' \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of_lit L')\n  L = subst_lit L' \\<sigma>", "have \"L = (subst_lit L' ?\\<theta>)\""], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of_lit L')\n  L = subst_lit L' \\<sigma>\n\ngoal (1 subgoal):\n 1. L = subst_lit L' (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)", "using coincide_on_lit"], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of_lit L')\n  L = subst_lit L' \\<sigma>\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of_lit ?l) \\<Longrightarrow>\n  subst_lit ?l ?\\<sigma> = subst_lit ?l ?\\<eta>\n\ngoal (1 subgoal):\n 1. L = subst_lit L' (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  L = subst_lit L' (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "have \"subst_lit L' ?\\<theta>\n    = subst_lit (subst_lit L' \\<eta>) ?\\<theta>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_lit L' (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) =\n    subst_lit (subst_lit L' \\<eta>) (\\<eta>' \\<lozenge> \\<sigma>)", "by (simp add: coincide_on_def coincide_on_lit composition_of_substs_lit)"], ["proof (state)\nthis:\n  subst_lit L' (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) =\n  subst_lit (subst_lit L' \\<eta>) (\\<eta>' \\<lozenge> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from this and \\<open>L = (subst_lit L' ?\\<theta>)\\<close> and \n    \\<open>L'_bis = (subst_lit L' \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  subst_lit L' (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) =\n  subst_lit (subst_lit L' \\<eta>) (\\<eta>' \\<lozenge> \\<sigma>)\n  L = subst_lit L' (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n  L'_bis = subst_lit L' \\<eta>", "have \"L = (subst_lit L'_bis ?\\<theta>')\""], ["proof (prove)\nusing this:\n  subst_lit L' (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) =\n  subst_lit (subst_lit L' \\<eta>) (\\<eta>' \\<lozenge> \\<sigma>)\n  L = subst_lit L' (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n  L'_bis = subst_lit L' \\<eta>\n\ngoal (1 subgoal):\n 1. L = subst_lit L'_bis (\\<eta>' \\<lozenge> \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  L = subst_lit L'_bis (\\<eta>' \\<lozenge> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from \\<open>coincide_on \\<sigma> ?\\<theta> (vars_of_cl C')\\<close> and \\<open>C = (subst_cl C' \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of_cl C')\n  C = subst_cl C' \\<sigma>", "have \"C  = subst_cl C' ?\\<theta>\""], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of_cl C')\n  C = subst_cl C' \\<sigma>\n\ngoal (1 subgoal):\n 1. C = subst_cl C' (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)", "using coincide_on_cl"], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of_cl C')\n  C = subst_cl C' \\<sigma>\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of_cl ?C) \\<Longrightarrow>\n  subst_cl ?C ?\\<sigma> = subst_cl ?C ?\\<eta>\n\ngoal (1 subgoal):\n 1. C = subst_cl C' (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)", "by blast"], ["proof (state)\nthis:\n  C = subst_cl C' (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "have \"subst_cl C' ?\\<theta>\n    = subst_cl (subst_cl C' \\<eta>) ?\\<theta>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_cl C' (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) =\n    subst_cl (subst_cl C' \\<eta>) (\\<eta>' \\<lozenge> \\<sigma>)", "by (metis composition_of_substs_cl)"], ["proof (state)\nthis:\n  subst_cl C' (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) =\n  subst_cl (subst_cl C' \\<eta>) (\\<eta>' \\<lozenge> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from this and \\<open>C  = subst_cl C' ?\\<theta>\\<close> and \\<open>C'_bis = (subst_cl C' \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  subst_cl C' (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) =\n  subst_cl (subst_cl C' \\<eta>) (\\<eta>' \\<lozenge> \\<sigma>)\n  C = subst_cl C' (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n  C'_bis = subst_cl C' \\<eta>", "have \"C = subst_cl C'_bis ?\\<theta>'\""], ["proof (prove)\nusing this:\n  subst_cl C' (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) =\n  subst_cl (subst_cl C' \\<eta>) (\\<eta>' \\<lozenge> \\<sigma>)\n  C = subst_cl C' (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n  C'_bis = subst_cl C' \\<eta>\n\ngoal (1 subgoal):\n 1. C = subst_cl C'_bis (\\<eta>' \\<lozenge> \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  C = subst_cl C'_bis (\\<eta>' \\<lozenge> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from \\<open>(finite C')\\<close> and \\<open>C'_bis = (subst_cl C' \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  finite C'\n  C'_bis = subst_cl C' \\<eta>", "have \"finite C'_bis\""], ["proof (prove)\nusing this:\n  finite C'\n  C'_bis = subst_cl C' \\<eta>\n\ngoal (1 subgoal):\n 1. finite C'_bis", "by auto"], ["proof (state)\nthis:\n  finite C'_bis\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "have \"t \\<notin> (subst_set (trms_ecl CC_bis) ?\\<theta>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<notin> subst_set (trms_ecl CC_bis) (\\<eta>' \\<lozenge> \\<sigma>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> subst_set (trms_ecl CC_bis)\n             (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "assume \"t \\<in> (subst_set (trms_ecl CC_bis) ?\\<theta>')\""], ["proof (state)\nthis:\n  t \\<in> subst_set (trms_ecl CC_bis) (\\<eta>' \\<lozenge> \\<sigma>)\n\ngoal (1 subgoal):\n 1. t \\<in> subst_set (trms_ecl CC_bis)\n             (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  t \\<in> subst_set (trms_ecl CC_bis) (\\<eta>' \\<lozenge> \\<sigma>)", "obtain u where \"u \\<in> (trms_ecl CC_bis)\" \n      and \"t = (subst u ?\\<theta>')\""], ["proof (prove)\nusing this:\n  t \\<in> subst_set (trms_ecl CC_bis) (\\<eta>' \\<lozenge> \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> trms_ecl CC_bis;\n         t = u \\<lhd> \\<eta>' \\<lozenge> \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u \\<in> trms_ecl CC_bis\n  t = u \\<lhd> \\<eta>' \\<lozenge> \\<sigma>\n\ngoal (1 subgoal):\n 1. t \\<in> subst_set (trms_ecl CC_bis)\n             (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from \\<open>u \\<in> (trms_ecl CC_bis)\\<close> and \\<open>CC_bis = (subst_ecl CC \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  u \\<in> trms_ecl CC_bis\n  CC_bis = subst_ecl CC \\<eta>", "obtain v where \"v \\<in> trms_ecl CC\" and \"u = (subst v \\<eta>)\""], ["proof (prove)\nusing this:\n  u \\<in> trms_ecl CC_bis\n  CC_bis = subst_ecl CC \\<eta>\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> trms_ecl CC; u = v \\<lhd> \\<eta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>CC = Ecl C' T\\<close>"], ["proof (prove)\nusing this:\n  u \\<in> trms_ecl CC_bis\n  CC_bis = subst_ecl CC \\<eta>\n  CC = Ecl C' T\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> trms_ecl CC; u = v \\<lhd> \\<eta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> trms_ecl CC\n  u = v \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. t \\<in> subst_set (trms_ecl CC_bis)\n             (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from \\<open>u = (subst v \\<eta>)\\<close> \\<open>t = (subst u ?\\<theta>')\\<close>"], ["proof (chain)\npicking this:\n  u = v \\<lhd> \\<eta>\n  t = u \\<lhd> \\<eta>' \\<lozenge> \\<sigma>", "have \"subst v ?\\<theta> = t\""], ["proof (prove)\nusing this:\n  u = v \\<lhd> \\<eta>\n  t = u \\<lhd> \\<eta>' \\<lozenge> \\<sigma>\n\ngoal (1 subgoal):\n 1. v \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> = t", "by simp"], ["proof (state)\nthis:\n  v \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> = t\n\ngoal (1 subgoal):\n 1. t \\<in> subst_set (trms_ecl CC_bis)\n             (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from \\<open>v \\<in> trms_ecl CC\\<close> \\<open>CC \\<in> S\\<close> assms(5)"], ["proof (chain)\npicking this:\n  v \\<in> trms_ecl CC\n  CC \\<in> S\n  Ball S well_constrained", "have \"dom_trm v (cl_ecl CC)\""], ["proof (prove)\nusing this:\n  v \\<in> trms_ecl CC\n  CC \\<in> S\n  Ball S well_constrained\n\ngoal (1 subgoal):\n 1. dom_trm v (cl_ecl CC)", "unfolding Ball_def well_constrained_def"], ["proof (prove)\nusing this:\n  v \\<in> trms_ecl CC\n  CC \\<in> S\n  \\<forall>x.\n     x \\<in> S \\<longrightarrow>\n     (\\<forall>y. y \\<in> trms_ecl x \\<longrightarrow> dom_trm y (cl_ecl x))\n\ngoal (1 subgoal):\n 1. dom_trm v (cl_ecl CC)", "by metis"], ["proof (state)\nthis:\n  dom_trm v (cl_ecl CC)\n\ngoal (1 subgoal):\n 1. t \\<in> subst_set (trms_ecl CC_bis)\n             (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  dom_trm v (cl_ecl CC)", "have \"vars_of v \\<subseteq> vars_of_cl (cl_ecl CC)\""], ["proof (prove)\nusing this:\n  dom_trm v (cl_ecl CC)\n\ngoal (1 subgoal):\n 1. vars_of v \\<subseteq> vars_of_cl (cl_ecl CC)", "using dom_trm_vars"], ["proof (prove)\nusing this:\n  dom_trm v (cl_ecl CC)\n  dom_trm ?t ?C \\<Longrightarrow> vars_of ?t \\<subseteq> vars_of_cl ?C\n\ngoal (1 subgoal):\n 1. vars_of v \\<subseteq> vars_of_cl (cl_ecl CC)", "by auto"], ["proof (state)\nthis:\n  vars_of v \\<subseteq> vars_of_cl (cl_ecl CC)\n\ngoal (1 subgoal):\n 1. t \\<in> subst_set (trms_ecl CC_bis)\n             (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from this and \\<open>C' = (cl_ecl CC)\\<close> \\<open>coincide_on \\<sigma> ?\\<theta> (vars_of_cl C')\\<close>"], ["proof (chain)\npicking this:\n  vars_of v \\<subseteq> vars_of_cl (cl_ecl CC)\n  C' = cl_ecl CC\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of_cl C')", "have \"coincide_on \\<sigma> ?\\<theta> (vars_of v)\""], ["proof (prove)\nusing this:\n  vars_of v \\<subseteq> vars_of_cl (cl_ecl CC)\n  C' = cl_ecl CC\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of_cl C')\n\ngoal (1 subgoal):\n 1. coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n     (vars_of v)", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  vars_of v \\<subseteq> vars_of_cl (cl_ecl CC)\n  C' = cl_ecl CC\n  \\<forall>x\\<in>vars_of_cl C'.\n     Var x \\<lhd> \\<sigma> =\n     Var x \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of v.\n       Var x \\<lhd> \\<sigma> =\n       Var x \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of v)\n\ngoal (1 subgoal):\n 1. t \\<in> subst_set (trms_ecl CC_bis)\n             (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from this and \\<open>subst v ?\\<theta> = t\\<close>"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of v)\n  v \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> = t", "have \"(subst v \\<sigma>) = t\""], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of v)\n  v \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> = t\n\ngoal (1 subgoal):\n 1. v \\<lhd> \\<sigma> = t", "using coincide_on_term"], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of v)\n  v \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> = t\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of ?t) \\<Longrightarrow>\n  ?t \\<lhd> ?\\<sigma> = ?t \\<lhd> ?\\<eta>\n\ngoal (1 subgoal):\n 1. v \\<lhd> \\<sigma> = t", "by metis"], ["proof (state)\nthis:\n  v \\<lhd> \\<sigma> = t\n\ngoal (1 subgoal):\n 1. t \\<in> subst_set (trms_ecl CC_bis)\n             (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from this and \\<open>v \\<in> trms_ecl CC\\<close>"], ["proof (chain)\npicking this:\n  v \\<lhd> \\<sigma> = t\n  v \\<in> trms_ecl CC", "have \n      \"(t \\<in> (subst_set (trms_ecl CC) \\<sigma>))\""], ["proof (prove)\nusing this:\n  v \\<lhd> \\<sigma> = t\n  v \\<in> trms_ecl CC\n\ngoal (1 subgoal):\n 1. t \\<in> subst_set (trms_ecl CC) \\<sigma>", "by auto"], ["proof (state)\nthis:\n  t \\<in> subst_set (trms_ecl CC) \\<sigma>\n\ngoal (1 subgoal):\n 1. t \\<in> subst_set (trms_ecl CC_bis)\n             (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from this and assms(1)"], ["proof (chain)\npicking this:\n  t \\<in> subst_set (trms_ecl CC) \\<sigma>\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S", "show False"], ["proof (prove)\nusing this:\n  t \\<in> subst_set (trms_ecl CC) \\<sigma>\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S\n\ngoal (1 subgoal):\n 1. False", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  t \\<in> subst_set (trms_ecl CC) \\<sigma>\n  CC \\<in> S \\<and>\n  t \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n  trms_irreducible CC \\<sigma> S t \\<and>\n  C' = cl_ecl CC \\<and>\n  (s, t) \\<in> trm_ord \\<and>\n  ((s, t) \\<in> trm_ord \\<longrightarrow> z = trm_rep s S) \\<and>\n  orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n  sel C' = {} \\<and>\n  L' \\<in> C' \\<and>\n  maximal_literal L C \\<and>\n  L = subst_lit L' \\<sigma> \\<and>\n  C = subst_cl C' \\<sigma> \\<and>\n  ground_clause C \\<and>\n  t = t' \\<lhd> \\<sigma> \\<and>\n  s = s' \\<lhd> \\<sigma> \\<and>\n  finite C' \\<and>\n  smaller_lits_are_false t C S \\<and>\n  maximal_literal_is_unique t s C' L' S \\<sigma>\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<notin> subst_set (trms_ecl CC_bis) (\\<eta>' \\<lozenge> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "have \"(trms_irreducible CC_bis ?\\<theta>' S t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trms_irreducible CC_bis (\\<eta>' \\<lozenge> \\<sigma>) S t", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> trms_irreducible CC_bis (\\<eta>' \\<lozenge> \\<sigma>) S\n            t \\<Longrightarrow>\n    False", "assume \"\\<not>(trms_irreducible CC_bis ?\\<theta>' S t)\""], ["proof (state)\nthis:\n  \\<not> trms_irreducible CC_bis (\\<eta>' \\<lozenge> \\<sigma>) S t\n\ngoal (1 subgoal):\n 1. \\<not> trms_irreducible CC_bis (\\<eta>' \\<lozenge> \\<sigma>) S\n            t \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> trms_irreducible CC_bis (\\<eta>' \\<lozenge> \\<sigma>) S t", "obtain x x' where \"x' \\<in> trms_ecl CC_bis\" \n            \"occurs_in x (subst x' ?\\<theta>')\"\n            \"(x,t) \\<in> trm_ord\" \"(trm_rep x S) \\<noteq> x\""], ["proof (prove)\nusing this:\n  \\<not> trms_irreducible CC_bis (\\<eta>' \\<lozenge> \\<sigma>) S t\n\ngoal (1 subgoal):\n 1. (\\<And>x' x.\n        \\<lbrakk>x' \\<in> trms_ecl CC_bis;\n         occurs_in x (x' \\<lhd> \\<eta>' \\<lozenge> \\<sigma>);\n         (x, t) \\<in> trm_ord; trm_rep x S \\<noteq> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using trms_irreducible_def"], ["proof (prove)\nusing this:\n  \\<not> trms_irreducible CC_bis (\\<eta>' \\<lozenge> \\<sigma>) S t\n  trms_irreducible ?CC ?\\<sigma> ?S ?t =\n  (\\<forall>x.\n      (\\<exists>x'\\<in>trms_ecl ?CC.\n          occurs_in x (x' \\<lhd> ?\\<sigma>)) \\<longrightarrow>\n      (x, ?t) \\<in> trm_ord \\<longrightarrow> trm_rep x ?S = x)\n\ngoal (1 subgoal):\n 1. (\\<And>x' x.\n        \\<lbrakk>x' \\<in> trms_ecl CC_bis;\n         occurs_in x (x' \\<lhd> \\<eta>' \\<lozenge> \\<sigma>);\n         (x, t) \\<in> trm_ord; trm_rep x S \\<noteq> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x' \\<in> trms_ecl CC_bis\n  occurs_in x (x' \\<lhd> \\<eta>' \\<lozenge> \\<sigma>)\n  (x, t) \\<in> trm_ord\n  trm_rep x S \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<not> trms_irreducible CC_bis (\\<eta>' \\<lozenge> \\<sigma>) S\n            t \\<Longrightarrow>\n    False", "from \\<open>x' \\<in> (trms_ecl CC_bis)\\<close> and \\<open>CC_bis = (subst_ecl CC \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  x' \\<in> trms_ecl CC_bis\n  CC_bis = subst_ecl CC \\<eta>", "obtain v where \"v \\<in> trms_ecl CC\" and \"x' = (subst v \\<eta>)\""], ["proof (prove)\nusing this:\n  x' \\<in> trms_ecl CC_bis\n  CC_bis = subst_ecl CC \\<eta>\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> trms_ecl CC; x' = v \\<lhd> \\<eta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>CC = Ecl C' T\\<close>"], ["proof (prove)\nusing this:\n  x' \\<in> trms_ecl CC_bis\n  CC_bis = subst_ecl CC \\<eta>\n  CC = Ecl C' T\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> trms_ecl CC; x' = v \\<lhd> \\<eta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> trms_ecl CC\n  x' = v \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> trms_irreducible CC_bis (\\<eta>' \\<lozenge> \\<sigma>) S\n            t \\<Longrightarrow>\n    False", "from \\<open>occurs_in x (subst x' ?\\<theta>')\\<close> \\<open>x' = subst v \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  occurs_in x (x' \\<lhd> \\<eta>' \\<lozenge> \\<sigma>)\n  x' = v \\<lhd> \\<eta>", "have \"occurs_in x (subst v ?\\<theta>)\""], ["proof (prove)\nusing this:\n  occurs_in x (x' \\<lhd> \\<eta>' \\<lozenge> \\<sigma>)\n  x' = v \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. occurs_in x (v \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)", "by simp"], ["proof (state)\nthis:\n  occurs_in x (v \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> trms_irreducible CC_bis (\\<eta>' \\<lozenge> \\<sigma>) S\n            t \\<Longrightarrow>\n    False", "from \\<open>v \\<in> trms_ecl CC\\<close> \\<open>CC \\<in> S\\<close> assms(5)"], ["proof (chain)\npicking this:\n  v \\<in> trms_ecl CC\n  CC \\<in> S\n  Ball S well_constrained", "have \"dom_trm v (cl_ecl CC)\""], ["proof (prove)\nusing this:\n  v \\<in> trms_ecl CC\n  CC \\<in> S\n  Ball S well_constrained\n\ngoal (1 subgoal):\n 1. dom_trm v (cl_ecl CC)", "unfolding Ball_def well_constrained_def"], ["proof (prove)\nusing this:\n  v \\<in> trms_ecl CC\n  CC \\<in> S\n  \\<forall>x.\n     x \\<in> S \\<longrightarrow>\n     (\\<forall>y. y \\<in> trms_ecl x \\<longrightarrow> dom_trm y (cl_ecl x))\n\ngoal (1 subgoal):\n 1. dom_trm v (cl_ecl CC)", "by auto"], ["proof (state)\nthis:\n  dom_trm v (cl_ecl CC)\n\ngoal (1 subgoal):\n 1. \\<not> trms_irreducible CC_bis (\\<eta>' \\<lozenge> \\<sigma>) S\n            t \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  dom_trm v (cl_ecl CC)", "have \"vars_of v \\<subseteq> vars_of_cl (cl_ecl CC)\""], ["proof (prove)\nusing this:\n  dom_trm v (cl_ecl CC)\n\ngoal (1 subgoal):\n 1. vars_of v \\<subseteq> vars_of_cl (cl_ecl CC)", "using dom_trm_vars"], ["proof (prove)\nusing this:\n  dom_trm v (cl_ecl CC)\n  dom_trm ?t ?C \\<Longrightarrow> vars_of ?t \\<subseteq> vars_of_cl ?C\n\ngoal (1 subgoal):\n 1. vars_of v \\<subseteq> vars_of_cl (cl_ecl CC)", "by auto"], ["proof (state)\nthis:\n  vars_of v \\<subseteq> vars_of_cl (cl_ecl CC)\n\ngoal (1 subgoal):\n 1. \\<not> trms_irreducible CC_bis (\\<eta>' \\<lozenge> \\<sigma>) S\n            t \\<Longrightarrow>\n    False", "from this and \\<open>C' = (cl_ecl CC)\\<close> \\<open>coincide_on \\<sigma> ?\\<theta> (vars_of_cl C')\\<close>"], ["proof (chain)\npicking this:\n  vars_of v \\<subseteq> vars_of_cl (cl_ecl CC)\n  C' = cl_ecl CC\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of_cl C')", "have \"coincide_on \\<sigma> ?\\<theta> (vars_of v)\""], ["proof (prove)\nusing this:\n  vars_of v \\<subseteq> vars_of_cl (cl_ecl CC)\n  C' = cl_ecl CC\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of_cl C')\n\ngoal (1 subgoal):\n 1. coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n     (vars_of v)", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  vars_of v \\<subseteq> vars_of_cl (cl_ecl CC)\n  C' = cl_ecl CC\n  \\<forall>x\\<in>vars_of_cl C'.\n     Var x \\<lhd> \\<sigma> =\n     Var x \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of v.\n       Var x \\<lhd> \\<sigma> =\n       Var x \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of v)\n\ngoal (1 subgoal):\n 1. \\<not> trms_irreducible CC_bis (\\<eta>' \\<lozenge> \\<sigma>) S\n            t \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of v)", "have \"(subst v \\<sigma>) = (subst v ?\\<theta>)\""], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of v)\n\ngoal (1 subgoal):\n 1. v \\<lhd> \\<sigma> =\n    v \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>", "using coincide_on_term"], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of v)\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of ?t) \\<Longrightarrow>\n  ?t \\<lhd> ?\\<sigma> = ?t \\<lhd> ?\\<eta>\n\ngoal (1 subgoal):\n 1. v \\<lhd> \\<sigma> =\n    v \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>", "by metis"], ["proof (state)\nthis:\n  v \\<lhd> \\<sigma> = v \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> trms_irreducible CC_bis (\\<eta>' \\<lozenge> \\<sigma>) S\n            t \\<Longrightarrow>\n    False", "from this and \\<open>occurs_in x (subst v ?\\<theta>)\\<close>"], ["proof (chain)\npicking this:\n  v \\<lhd> \\<sigma> = v \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>\n  occurs_in x (v \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)", "have \"occurs_in x (subst v \\<sigma>)\""], ["proof (prove)\nusing this:\n  v \\<lhd> \\<sigma> = v \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>\n  occurs_in x (v \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n\ngoal (1 subgoal):\n 1. occurs_in x (v \\<lhd> \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  occurs_in x (v \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> trms_irreducible CC_bis (\\<eta>' \\<lozenge> \\<sigma>) S\n            t \\<Longrightarrow>\n    False", "from this and \\<open>v \\<in> trms_ecl CC\\<close> and \\<open>(x,t) \\<in> trm_ord\\<close> \n      \\<open>(trm_rep x S) \\<noteq> x\\<close> and \\<open>(trms_irreducible CC \\<sigma> S t)\\<close>"], ["proof (chain)\npicking this:\n  occurs_in x (v \\<lhd> \\<sigma>)\n  v \\<in> trms_ecl CC\n  (x, t) \\<in> trm_ord\n  trm_rep x S \\<noteq> x\n  trms_irreducible CC \\<sigma> S t", "show False"], ["proof (prove)\nusing this:\n  occurs_in x (v \\<lhd> \\<sigma>)\n  v \\<in> trms_ecl CC\n  (x, t) \\<in> trm_ord\n  trm_rep x S \\<noteq> x\n  trms_irreducible CC \\<sigma> S t\n\ngoal (1 subgoal):\n 1. False", "unfolding trms_irreducible_def"], ["proof (prove)\nusing this:\n  occurs_in x (v \\<lhd> \\<sigma>)\n  v \\<in> trms_ecl CC\n  (x, t) \\<in> trm_ord\n  trm_rep x S \\<noteq> x\n  \\<forall>x.\n     (\\<exists>x'\\<in>trms_ecl CC.\n         occurs_in x (x' \\<lhd> \\<sigma>)) \\<longrightarrow>\n     (x, t) \\<in> trm_ord \\<longrightarrow> trm_rep x S = x\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trms_irreducible CC_bis (\\<eta>' \\<lozenge> \\<sigma>) S t\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "obtain t'_bis where \"t'_bis = (subst t' \\<eta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t'_bis.\n        t'_bis = t' \\<lhd> \\<eta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t'_bis = t' \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "obtain s'_bis where \"s'_bis = (subst s' \\<eta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s'_bis.\n        s'_bis = s' \\<lhd> \\<eta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s'_bis = s' \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from \\<open>(orient_lit_inst L' t' s' pos \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L' t' s' pos \\<sigma>", "have \"vars_of t' \\<subseteq> vars_of_lit L'\""], ["proof (prove)\nusing this:\n  orient_lit_inst L' t' s' pos \\<sigma>\n\ngoal (1 subgoal):\n 1. vars_of t' \\<subseteq> vars_of_lit L'", "using orient_lit_inst_vars"], ["proof (prove)\nusing this:\n  orient_lit_inst L' t' s' pos \\<sigma>\n  orient_lit_inst ?L ?t ?s ?p ?\\<sigma> \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of t' \\<subseteq> vars_of_lit L'", "by auto"], ["proof (state)\nthis:\n  vars_of t' \\<subseteq> vars_of_lit L'\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from this \\<open>coincide_on \\<sigma> ?\\<theta> (vars_of_lit L')\\<close>"], ["proof (chain)\npicking this:\n  vars_of t' \\<subseteq> vars_of_lit L'\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of_lit L')", "have \"coincide_on \\<sigma> ?\\<theta> (vars_of t')\""], ["proof (prove)\nusing this:\n  vars_of t' \\<subseteq> vars_of_lit L'\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of_lit L')\n\ngoal (1 subgoal):\n 1. coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n     (vars_of t')", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  vars_of t' \\<subseteq> vars_of_lit L'\n  \\<forall>x\\<in>vars_of_lit L'.\n     Var x \\<lhd> \\<sigma> =\n     Var x \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of t'.\n       Var x \\<lhd> \\<sigma> =\n       Var x \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>", "by blast"], ["proof (state)\nthis:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of t')\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from this"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of t')", "have \"subst t' ?\\<theta> = subst t' \\<sigma>\""], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of t')\n\ngoal (1 subgoal):\n 1. t' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> =\n    t' \\<lhd> \\<sigma>", "using coincide_on_term"], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of t')\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of ?t) \\<Longrightarrow>\n  ?t \\<lhd> ?\\<sigma> = ?t \\<lhd> ?\\<eta>\n\ngoal (1 subgoal):\n 1. t' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> =\n    t' \\<lhd> \\<sigma>", "by metis"], ["proof (state)\nthis:\n  t' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> =\n  t' \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from this \\<open>t'_bis = (subst t' \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  t' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> =\n  t' \\<lhd> \\<sigma>\n  t'_bis = t' \\<lhd> \\<eta>", "have \"subst t'_bis ?\\<theta>' = subst t' \\<sigma>\""], ["proof (prove)\nusing this:\n  t' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> =\n  t' \\<lhd> \\<sigma>\n  t'_bis = t' \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. t'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma> = t' \\<lhd> \\<sigma>", "by simp"], ["proof (state)\nthis:\n  t'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma> = t' \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from \\<open>(orient_lit_inst L' t' s' pos \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L' t' s' pos \\<sigma>", "have \"vars_of s' \\<subseteq> vars_of_lit L'\""], ["proof (prove)\nusing this:\n  orient_lit_inst L' t' s' pos \\<sigma>\n\ngoal (1 subgoal):\n 1. vars_of s' \\<subseteq> vars_of_lit L'", "using orient_lit_inst_vars"], ["proof (prove)\nusing this:\n  orient_lit_inst L' t' s' pos \\<sigma>\n  orient_lit_inst ?L ?t ?s ?p ?\\<sigma> \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of s' \\<subseteq> vars_of_lit L'", "by auto"], ["proof (state)\nthis:\n  vars_of s' \\<subseteq> vars_of_lit L'\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from this \\<open>coincide_on \\<sigma> ?\\<theta> (vars_of_lit L')\\<close>"], ["proof (chain)\npicking this:\n  vars_of s' \\<subseteq> vars_of_lit L'\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of_lit L')", "have \"coincide_on \\<sigma> ?\\<theta> (vars_of s')\""], ["proof (prove)\nusing this:\n  vars_of s' \\<subseteq> vars_of_lit L'\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of_lit L')\n\ngoal (1 subgoal):\n 1. coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n     (vars_of s')", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  vars_of s' \\<subseteq> vars_of_lit L'\n  \\<forall>x\\<in>vars_of_lit L'.\n     Var x \\<lhd> \\<sigma> =\n     Var x \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of s'.\n       Var x \\<lhd> \\<sigma> =\n       Var x \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>", "by blast"], ["proof (state)\nthis:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of s')\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from this"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of s')", "have \"subst s' ?\\<theta> = subst s' \\<sigma>\""], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of s')\n\ngoal (1 subgoal):\n 1. s' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> =\n    s' \\<lhd> \\<sigma>", "using coincide_on_term"], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of s')\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of ?t) \\<Longrightarrow>\n  ?t \\<lhd> ?\\<sigma> = ?t \\<lhd> ?\\<eta>\n\ngoal (1 subgoal):\n 1. s' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> =\n    s' \\<lhd> \\<sigma>", "by metis"], ["proof (state)\nthis:\n  s' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> =\n  s' \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from this \\<open>s'_bis = (subst s' \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  s' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> =\n  s' \\<lhd> \\<sigma>\n  s'_bis = s' \\<lhd> \\<eta>", "have \"subst s'_bis ?\\<theta>' = subst s' \\<sigma>\""], ["proof (prove)\nusing this:\n  s' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> =\n  s' \\<lhd> \\<sigma>\n  s'_bis = s' \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. s'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma> = s' \\<lhd> \\<sigma>", "by simp"], ["proof (state)\nthis:\n  s'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma> = s' \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "have \"(orient_lit_inst L'_bis t'_bis s'_bis pos ?\\<theta>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orient_lit_inst L'_bis t'_bis s'_bis pos (\\<eta>' \\<lozenge> \\<sigma>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. orient_lit_inst L'_bis t'_bis s'_bis pos (\\<eta>' \\<lozenge> \\<sigma>)", "from \\<open>(orient_lit_inst L' t' s' pos \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L' t' s' pos \\<sigma>", "have \"((subst t' \\<sigma>),(subst s' \\<sigma>)) \\<notin> trm_ord\""], ["proof (prove)\nusing this:\n  orient_lit_inst L' t' s' pos \\<sigma>\n\ngoal (1 subgoal):\n 1. (t' \\<lhd> \\<sigma>, s' \\<lhd> \\<sigma>) \\<notin> trm_ord", "using orient_lit_inst_def"], ["proof (prove)\nusing this:\n  orient_lit_inst L' t' s' pos \\<sigma>\n  orient_lit_inst ?L ?u ?v ?s ?\\<sigma> =\n  ((?L = Pos (Eq ?u ?v) \\<or> ?L = Pos (Eq ?v ?u)) \\<and>\n   (?u \\<lhd> ?\\<sigma>, ?v \\<lhd> ?\\<sigma>) \\<notin> trm_ord \\<and>\n   ?s = pos \\<or>\n   (?L = Neg (Eq ?u ?v) \\<or> ?L = Neg (Eq ?v ?u)) \\<and>\n   (?u \\<lhd> ?\\<sigma>, ?v \\<lhd> ?\\<sigma>) \\<notin> trm_ord \\<and>\n   ?s = neg)\n\ngoal (1 subgoal):\n 1. (t' \\<lhd> \\<sigma>, s' \\<lhd> \\<sigma>) \\<notin> trm_ord", "by simp"], ["proof (state)\nthis:\n  (t' \\<lhd> \\<sigma>, s' \\<lhd> \\<sigma>) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. orient_lit_inst L'_bis t'_bis s'_bis pos (\\<eta>' \\<lozenge> \\<sigma>)", "from \\<open>(orient_lit_inst L' t' s' pos \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L' t' s' pos \\<sigma>", "have \"L' = (Pos (Eq t' s')) \\<or> L' = (Pos (Eq s' t'))\""], ["proof (prove)\nusing this:\n  orient_lit_inst L' t' s' pos \\<sigma>\n\ngoal (1 subgoal):\n 1. L' = Pos (Eq t' s') \\<or> L' = Pos (Eq s' t')", "by (simp add: orient_lit_inst_def)"], ["proof (state)\nthis:\n  L' = Pos (Eq t' s') \\<or> L' = Pos (Eq s' t')\n\ngoal (1 subgoal):\n 1. orient_lit_inst L'_bis t'_bis s'_bis pos (\\<eta>' \\<lozenge> \\<sigma>)", "from this \n      \\<open>L'_bis = (subst_lit L' \\<eta>)\\<close>\n      \\<open>t'_bis = (subst t' \\<eta>)\\<close>\n      \\<open>s'_bis = (subst s' \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  L' = Pos (Eq t' s') \\<or> L' = Pos (Eq s' t')\n  L'_bis = subst_lit L' \\<eta>\n  t'_bis = t' \\<lhd> \\<eta>\n  s'_bis = s' \\<lhd> \\<eta>", "have \"L'_bis = (Pos (Eq t'_bis s'_bis)) \\<or> L'_bis = (Pos (Eq s'_bis t'_bis))\""], ["proof (prove)\nusing this:\n  L' = Pos (Eq t' s') \\<or> L' = Pos (Eq s' t')\n  L'_bis = subst_lit L' \\<eta>\n  t'_bis = t' \\<lhd> \\<eta>\n  s'_bis = s' \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. L'_bis = Pos (Eq t'_bis s'_bis) \\<or> L'_bis = Pos (Eq s'_bis t'_bis)", "by auto"], ["proof (state)\nthis:\n  L'_bis = Pos (Eq t'_bis s'_bis) \\<or> L'_bis = Pos (Eq s'_bis t'_bis)\n\ngoal (1 subgoal):\n 1. orient_lit_inst L'_bis t'_bis s'_bis pos (\\<eta>' \\<lozenge> \\<sigma>)", "from \\<open>subst s'_bis ?\\<theta>' = subst s' \\<sigma>\\<close> \n      and \\<open>subst t'_bis ?\\<theta>' = subst t' \\<sigma>\\<close> \n      and \\<open>((subst t' \\<sigma>),(subst s' \\<sigma>)) \\<notin> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  s'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma> = s' \\<lhd> \\<sigma>\n  t'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma> = t' \\<lhd> \\<sigma>\n  (t' \\<lhd> \\<sigma>, s' \\<lhd> \\<sigma>) \\<notin> trm_ord", "have \"((subst t'_bis ?\\<theta>'),(subst s'_bis ?\\<theta>')) \\<notin> trm_ord\""], ["proof (prove)\nusing this:\n  s'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma> = s' \\<lhd> \\<sigma>\n  t'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma> = t' \\<lhd> \\<sigma>\n  (t' \\<lhd> \\<sigma>, s' \\<lhd> \\<sigma>) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. (t'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma>,\n     s'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma>)\n    \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  (t'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma>,\n   s'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma>)\n  \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. orient_lit_inst L'_bis t'_bis s'_bis pos (\\<eta>' \\<lozenge> \\<sigma>)", "from this and \\<open>L'_bis = (Pos (Eq t'_bis s'_bis)) \\<or> L'_bis = (Pos (Eq s'_bis t'_bis))\\<close>"], ["proof (chain)\npicking this:\n  (t'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma>,\n   s'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma>)\n  \\<notin> trm_ord\n  L'_bis = Pos (Eq t'_bis s'_bis) \\<or> L'_bis = Pos (Eq s'_bis t'_bis)", "show ?thesis"], ["proof (prove)\nusing this:\n  (t'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma>,\n   s'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma>)\n  \\<notin> trm_ord\n  L'_bis = Pos (Eq t'_bis s'_bis) \\<or> L'_bis = Pos (Eq s'_bis t'_bis)\n\ngoal (1 subgoal):\n 1. orient_lit_inst L'_bis t'_bis s'_bis pos (\\<eta>' \\<lozenge> \\<sigma>)", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  (t'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma>,\n   s'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma>)\n  \\<notin> trm_ord\n  L'_bis = Pos (Eq t'_bis s'_bis) \\<or> L'_bis = Pos (Eq s'_bis t'_bis)\n\ngoal (1 subgoal):\n 1. (L'_bis = Pos (Eq t'_bis s'_bis) \\<or>\n     L'_bis = Pos (Eq s'_bis t'_bis)) \\<and>\n    (t'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma>,\n     s'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma>)\n    \\<notin> trm_ord \\<and>\n    pos = pos \\<or>\n    (L'_bis = Neg (Eq t'_bis s'_bis) \\<or>\n     L'_bis = Neg (Eq s'_bis t'_bis)) \\<and>\n    (t'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma>,\n     s'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma>)\n    \\<notin> trm_ord \\<and>\n    pos = neg", "by auto"], ["proof (state)\nthis:\n  orient_lit_inst L'_bis t'_bis s'_bis pos (\\<eta>' \\<lozenge> \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  orient_lit_inst L'_bis t'_bis s'_bis pos (\\<eta>' \\<lozenge> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "have \"(maximal_literal_is_unique t s C'_bis L'_bis S ?\\<theta>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal_literal_is_unique t s C'_bis L'_bis S\n     (\\<eta>' \\<lozenge> \\<sigma>)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n            (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "assume \"\\<not>(maximal_literal_is_unique t s C'_bis L'_bis S ?\\<theta>')\""], ["proof (state)\nthis:\n  \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n          (\\<eta>' \\<lozenge> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n            (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n          (\\<eta>' \\<lozenge> \\<sigma>)", "obtain s'' where \"(eq_occurs_in_cl t s'' (C'_bis- { L'_bis }) ?\\<theta>')\"\n                \"(s'',t) \\<in> trm_ord\" \n                \"(s,t) \\<in> trm_ord\"\n                \"(trm_rep s S) = (trm_rep s'' S)\""], ["proof (prove)\nusing this:\n  \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n          (\\<eta>' \\<lozenge> \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>s''.\n        \\<lbrakk>eq_occurs_in_cl t s'' (C'_bis - {L'_bis})\n                  (\\<eta>' \\<lozenge> \\<sigma>);\n         (s'', t) \\<in> trm_ord; (s, t) \\<in> trm_ord;\n         trm_rep s S = trm_rep s'' S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding  maximal_literal_is_unique_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>s''.\n             eq_occurs_in_cl t s'' (C'_bis - {L'_bis})\n              (\\<eta>' \\<lozenge> \\<sigma>) \\<longrightarrow>\n             (s'', t) \\<in> trm_ord \\<longrightarrow>\n             (s, t) \\<in> trm_ord \\<longrightarrow>\n             trm_rep s S \\<noteq> trm_rep s'' S)\n\ngoal (1 subgoal):\n 1. (\\<And>s''.\n        \\<lbrakk>eq_occurs_in_cl t s'' (C'_bis - {L'_bis})\n                  (\\<eta>' \\<lozenge> \\<sigma>);\n         (s'', t) \\<in> trm_ord; (s, t) \\<in> trm_ord;\n         trm_rep s S = trm_rep s'' S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  eq_occurs_in_cl t s'' (C'_bis - {L'_bis}) (\\<eta>' \\<lozenge> \\<sigma>)\n  (s'', t) \\<in> trm_ord\n  (s, t) \\<in> trm_ord\n  trm_rep s S = trm_rep s'' S\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n            (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from \\<open>(eq_occurs_in_cl t s'' (C'_bis- { L'_bis }) ?\\<theta>')\\<close>"], ["proof (chain)\npicking this:\n  eq_occurs_in_cl t s'' (C'_bis - {L'_bis}) (\\<eta>' \\<lozenge> \\<sigma>)", "obtain M u v where \n      \"M \\<in> C'_bis - { L'_bis }\" \"orient_lit_inst M u v pos ?\\<theta>'\" \n      \"t = (subst u ?\\<theta>')\" \"s'' = (subst v ?\\<theta>')\""], ["proof (prove)\nusing this:\n  eq_occurs_in_cl t s'' (C'_bis - {L'_bis}) (\\<eta>' \\<lozenge> \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>M u v.\n        \\<lbrakk>M \\<in> C'_bis - {L'_bis};\n         orient_lit_inst M u v pos (\\<eta>' \\<lozenge> \\<sigma>);\n         t = u \\<lhd> \\<eta>' \\<lozenge> \\<sigma>;\n         s'' = v \\<lhd> \\<eta>' \\<lozenge> \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding eq_occurs_in_cl_def"], ["proof (prove)\nusing this:\n  \\<exists>L t' s'.\n     L \\<in> C'_bis - {L'_bis} \\<and>\n     orient_lit_inst L t' s' pos (\\<eta>' \\<lozenge> \\<sigma>) \\<and>\n     t = t' \\<lhd> \\<eta>' \\<lozenge> \\<sigma> \\<and>\n     s'' = s' \\<lhd> \\<eta>' \\<lozenge> \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>M u v.\n        \\<lbrakk>M \\<in> C'_bis - {L'_bis};\n         orient_lit_inst M u v pos (\\<eta>' \\<lozenge> \\<sigma>);\n         t = u \\<lhd> \\<eta>' \\<lozenge> \\<sigma>;\n         s'' = v \\<lhd> \\<eta>' \\<lozenge> \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  M \\<in> C'_bis - {L'_bis}\n  orient_lit_inst M u v pos (\\<eta>' \\<lozenge> \\<sigma>)\n  t = u \\<lhd> \\<eta>' \\<lozenge> \\<sigma>\n  s'' = v \\<lhd> \\<eta>' \\<lozenge> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n            (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from \\<open>M \\<in> C'_bis - { L'_bis }\\<close> \n      and \\<open>C'_bis = (subst_cl C' \\<eta>)\\<close> and \\<open>L'_bis = (subst_lit L' \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  M \\<in> C'_bis - {L'_bis}\n  C'_bis = subst_cl C' \\<eta>\n  L'_bis = subst_lit L' \\<eta>", "obtain M' where \"M' \\<in> C'- { L' }\" and \"subst_lit M' \\<eta> =  M\""], ["proof (prove)\nusing this:\n  M \\<in> C'_bis - {L'_bis}\n  C'_bis = subst_cl C' \\<eta>\n  L'_bis = subst_lit L' \\<eta>\n\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        \\<lbrakk>M' \\<in> C' - {L'}; subst_lit M' \\<eta> = M\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M' \\<in> C' - {L'}\n  subst_lit M' \\<eta> = M\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n            (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from \\<open>orient_lit_inst M u v pos ?\\<theta>'\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst M u v pos (\\<eta>' \\<lozenge> \\<sigma>)", "obtain e where \"M = (Pos e)\""], ["proof (prove)\nusing this:\n  orient_lit_inst M u v pos (\\<eta>' \\<lozenge> \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>e. M = Pos e \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  (M = Pos (Eq u v) \\<or> M = Pos (Eq v u)) \\<and>\n  (u \\<lhd> \\<eta>' \\<lozenge> \\<sigma>,\n   v \\<lhd> \\<eta>' \\<lozenge> \\<sigma>)\n  \\<notin> trm_ord \\<and>\n  pos = pos \\<or>\n  (M = Neg (Eq u v) \\<or> M = Neg (Eq v u)) \\<and>\n  (u \\<lhd> \\<eta>' \\<lozenge> \\<sigma>,\n   v \\<lhd> \\<eta>' \\<lozenge> \\<sigma>)\n  \\<notin> trm_ord \\<and>\n  pos = neg\n\ngoal (1 subgoal):\n 1. (\\<And>e. M = Pos e \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  M = Pos e\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n            (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from this and  \\<open>orient_lit_inst M u v pos ?\\<theta>'\\<close>"], ["proof (chain)\npicking this:\n  M = Pos e\n  orient_lit_inst M u v pos (\\<eta>' \\<lozenge> \\<sigma>)", "have \"e = (Eq u v) \\<or> e = (Eq v u)\""], ["proof (prove)\nusing this:\n  M = Pos e\n  orient_lit_inst M u v pos (\\<eta>' \\<lozenge> \\<sigma>)\n\ngoal (1 subgoal):\n 1. e = Eq u v \\<or> e = Eq v u", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  M = Pos e\n  (M = Pos (Eq u v) \\<or> M = Pos (Eq v u)) \\<and>\n  (u \\<lhd> \\<eta>' \\<lozenge> \\<sigma>,\n   v \\<lhd> \\<eta>' \\<lozenge> \\<sigma>)\n  \\<notin> trm_ord \\<and>\n  pos = pos \\<or>\n  (M = Neg (Eq u v) \\<or> M = Neg (Eq v u)) \\<and>\n  (u \\<lhd> \\<eta>' \\<lozenge> \\<sigma>,\n   v \\<lhd> \\<eta>' \\<lozenge> \\<sigma>)\n  \\<notin> trm_ord \\<and>\n  pos = neg\n\ngoal (1 subgoal):\n 1. e = Eq u v \\<or> e = Eq v u", "by auto"], ["proof (state)\nthis:\n  e = Eq u v \\<or> e = Eq v u\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n            (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from \\<open>orient_lit_inst M u v pos ?\\<theta>'\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst M u v pos (\\<eta>' \\<lozenge> \\<sigma>)", "have \n      \"( (subst u ?\\<theta>'),(subst v ?\\<theta>')) \\<notin> trm_ord\""], ["proof (prove)\nusing this:\n  orient_lit_inst M u v pos (\\<eta>' \\<lozenge> \\<sigma>)\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<eta>' \\<lozenge> \\<sigma>,\n     v \\<lhd> \\<eta>' \\<lozenge> \\<sigma>)\n    \\<notin> trm_ord", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  (M = Pos (Eq u v) \\<or> M = Pos (Eq v u)) \\<and>\n  (u \\<lhd> \\<eta>' \\<lozenge> \\<sigma>,\n   v \\<lhd> \\<eta>' \\<lozenge> \\<sigma>)\n  \\<notin> trm_ord \\<and>\n  pos = pos \\<or>\n  (M = Neg (Eq u v) \\<or> M = Neg (Eq v u)) \\<and>\n  (u \\<lhd> \\<eta>' \\<lozenge> \\<sigma>,\n   v \\<lhd> \\<eta>' \\<lozenge> \\<sigma>)\n  \\<notin> trm_ord \\<and>\n  pos = neg\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<eta>' \\<lozenge> \\<sigma>,\n     v \\<lhd> \\<eta>' \\<lozenge> \\<sigma>)\n    \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  (u \\<lhd> \\<eta>' \\<lozenge> \\<sigma>,\n   v \\<lhd> \\<eta>' \\<lozenge> \\<sigma>)\n  \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n            (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from \\<open>M = (Pos e)\\<close> and \\<open>subst_lit M' \\<eta> =  M\\<close>"], ["proof (chain)\npicking this:\n  M = Pos e\n  subst_lit M' \\<eta> = M", "obtain e' where \"(subst_equation e' \\<eta>)  = e\" and \"M' = (Pos e')\""], ["proof (prove)\nusing this:\n  M = Pos e\n  subst_lit M' \\<eta> = M\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>subst_equation e' \\<eta> = e; M' = Pos e'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (no_types, hide_lams) subst_lit.simps(1) subst_lit.simps(2) atom.simps(1) \n          literal.distinct(1) positive_literal.elims(1))"], ["proof (state)\nthis:\n  subst_equation e' \\<eta> = e\n  M' = Pos e'\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n            (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from \\<open>e = (Eq u v) \\<or> e = (Eq v u)\\<close> and \\<open>(subst_equation e' \\<eta>)  = e\\<close>"], ["proof (chain)\npicking this:\n  e = Eq u v \\<or> e = Eq v u\n  subst_equation e' \\<eta> = e", "obtain u' v' where \"e' = (Eq u' v') \\<or> (e' = (Eq v' u'))\" and \"(subst u' \\<eta>) = u\" and \n        \"(subst v' \\<eta>) = v\""], ["proof (prove)\nusing this:\n  e = Eq u v \\<or> e = Eq v u\n  subst_equation e' \\<eta> = e\n\ngoal (1 subgoal):\n 1. (\\<And>u' v'.\n        \\<lbrakk>e' = Eq u' v' \\<or> e' = Eq v' u'; u' \\<lhd> \\<eta> = u;\n         v' \\<lhd> \\<eta> = v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis subst_equation.simps equation.inject subterms_of_eq.cases)"], ["proof (state)\nthis:\n  e' = Eq u' v' \\<or> e' = Eq v' u'\n  u' \\<lhd> \\<eta> = u\n  v' \\<lhd> \\<eta> = v\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n            (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from \\<open>( (subst u ?\\<theta>'),(subst v ?\\<theta>')) \\<notin> trm_ord\\<close>\n      \\<open>(subst u' \\<eta>) = u\\<close>\n      \\<open>(subst v' \\<eta>) = v\\<close>"], ["proof (chain)\npicking this:\n  (u \\<lhd> \\<eta>' \\<lozenge> \\<sigma>,\n   v \\<lhd> \\<eta>' \\<lozenge> \\<sigma>)\n  \\<notin> trm_ord\n  u' \\<lhd> \\<eta> = u\n  v' \\<lhd> \\<eta> = v", "have \"( (subst u' ?\\<theta>),(subst v' ?\\<theta>)) \\<notin> trm_ord\""], ["proof (prove)\nusing this:\n  (u \\<lhd> \\<eta>' \\<lozenge> \\<sigma>,\n   v \\<lhd> \\<eta>' \\<lozenge> \\<sigma>)\n  \\<notin> trm_ord\n  u' \\<lhd> \\<eta> = u\n  v' \\<lhd> \\<eta> = v\n\ngoal (1 subgoal):\n 1. (u' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>,\n     v' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n    \\<notin> trm_ord", "by simp"], ["proof (state)\nthis:\n  (u' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>,\n   v' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n  \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n            (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from this and \\<open>M' = (Pos e')\\<close> and \\<open>e' = (Eq u' v') \\<or> (e' = (Eq v' u'))\\<close>"], ["proof (chain)\npicking this:\n  (u' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>,\n   v' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n  \\<notin> trm_ord\n  M' = Pos e'\n  e' = Eq u' v' \\<or> e' = Eq v' u'", "have \"orient_lit_inst M' u' v' pos ?\\<theta>\""], ["proof (prove)\nusing this:\n  (u' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>,\n   v' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n  \\<notin> trm_ord\n  M' = Pos e'\n  e' = Eq u' v' \\<or> e' = Eq v' u'\n\ngoal (1 subgoal):\n 1. orient_lit_inst M' u' v' pos\n     (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  (u' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>,\n   v' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n  \\<notin> trm_ord\n  M' = Pos e'\n  e' = Eq u' v' \\<or> e' = Eq v' u'\n\ngoal (1 subgoal):\n 1. (M' = Pos (Eq u' v') \\<or> M' = Pos (Eq v' u')) \\<and>\n    (u' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>,\n     v' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n    \\<notin> trm_ord \\<and>\n    pos = pos \\<or>\n    (M' = Neg (Eq u' v') \\<or> M' = Neg (Eq v' u')) \\<and>\n    (u' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>,\n     v' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n    \\<notin> trm_ord \\<and>\n    pos = neg", "by auto"], ["proof (state)\nthis:\n  orient_lit_inst M' u' v' pos\n   (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n            (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from \\<open>M' \\<in> C' - { L' }\\<close>"], ["proof (chain)\npicking this:\n  M' \\<in> C' - {L'}", "have \"vars_of_lit M' \\<subseteq> vars_of_cl C'\""], ["proof (prove)\nusing this:\n  M' \\<in> C' - {L'}\n\ngoal (1 subgoal):\n 1. vars_of_lit M' \\<subseteq> vars_of_cl C'", "by auto"], ["proof (state)\nthis:\n  vars_of_lit M' \\<subseteq> vars_of_cl C'\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n            (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from this and \\<open>coincide_on \\<sigma> ?\\<theta> (vars_of_cl C')\\<close>"], ["proof (chain)\npicking this:\n  vars_of_lit M' \\<subseteq> vars_of_cl C'\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of_cl C')", "have \"coincide_on \\<sigma> ?\\<theta> (vars_of_lit M')\""], ["proof (prove)\nusing this:\n  vars_of_lit M' \\<subseteq> vars_of_cl C'\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of_cl C')\n\ngoal (1 subgoal):\n 1. coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n     (vars_of_lit M')", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  vars_of_lit M' \\<subseteq> vars_of_cl C'\n  \\<forall>x\\<in>vars_of_cl C'.\n     Var x \\<lhd> \\<sigma> =\n     Var x \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of_lit M'.\n       Var x \\<lhd> \\<sigma> =\n       Var x \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of_lit M')\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n            (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of_lit M')", "have \"coincide_on ?\\<theta> \\<sigma> (vars_of_lit M')\""], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of_lit M')\n\ngoal (1 subgoal):\n 1. coincide_on (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) \\<sigma>\n     (vars_of_lit M')", "using coincide_sym"], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n   (vars_of_lit M')\n  coincide_on ?\\<sigma> ?\\<eta> ?V \\<Longrightarrow>\n  coincide_on ?\\<eta> ?\\<sigma> ?V\n\ngoal (1 subgoal):\n 1. coincide_on (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) \\<sigma>\n     (vars_of_lit M')", "by auto"], ["proof (state)\nthis:\n  coincide_on (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) \\<sigma>\n   (vars_of_lit M')\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n            (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from this and \\<open>orient_lit_inst M' u' v' pos ?\\<theta>\\<close>"], ["proof (chain)\npicking this:\n  coincide_on (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) \\<sigma>\n   (vars_of_lit M')\n  orient_lit_inst M' u' v' pos\n   (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)", "have \"orient_lit_inst M' u' v' pos \\<sigma>\""], ["proof (prove)\nusing this:\n  coincide_on (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) \\<sigma>\n   (vars_of_lit M')\n  orient_lit_inst M' u' v' pos\n   (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n\ngoal (1 subgoal):\n 1. orient_lit_inst M' u' v' pos \\<sigma>", "using orient_lit_inst_coincide"], ["proof (prove)\nusing this:\n  coincide_on (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) \\<sigma>\n   (vars_of_lit M')\n  orient_lit_inst M' u' v' pos\n   (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n  \\<lbrakk>orient_lit_inst ?L1.0 ?t ?s ?polarity ?\\<sigma>;\n   coincide_on ?\\<sigma> ?\\<eta> (vars_of_lit ?L1.0)\\<rbrakk>\n  \\<Longrightarrow> orient_lit_inst ?L1.0 ?t ?s ?polarity ?\\<eta>\n\ngoal (1 subgoal):\n 1. orient_lit_inst M' u' v' pos \\<sigma>", "by auto"], ["proof (state)\nthis:\n  orient_lit_inst M' u' v' pos \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n            (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from \\<open>orient_lit_inst M' u' v' pos ?\\<theta>\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst M' u' v' pos\n   (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)", "have \"vars_of u' \\<subseteq> vars_of_lit M'\" and \n       \"vars_of v' \\<subseteq> vars_of_lit M'\""], ["proof (prove)\nusing this:\n  orient_lit_inst M' u' v' pos\n   (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n\ngoal (1 subgoal):\n 1. vars_of u' \\<subseteq> vars_of_lit M' &&&\n    vars_of v' \\<subseteq> vars_of_lit M'", "using orient_lit_inst_vars"], ["proof (prove)\nusing this:\n  orient_lit_inst M' u' v' pos\n   (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>)\n  orient_lit_inst ?L ?t ?s ?p ?\\<sigma> \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of u' \\<subseteq> vars_of_lit M' &&&\n    vars_of v' \\<subseteq> vars_of_lit M'", "by auto"], ["proof (state)\nthis:\n  vars_of u' \\<subseteq> vars_of_lit M'\n  vars_of v' \\<subseteq> vars_of_lit M'\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n            (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from \\<open>vars_of u' \\<subseteq> vars_of_lit M'\\<close> and \\<open>coincide_on ?\\<theta> \\<sigma> (vars_of_lit M')\\<close>"], ["proof (chain)\npicking this:\n  vars_of u' \\<subseteq> vars_of_lit M'\n  coincide_on (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) \\<sigma>\n   (vars_of_lit M')", "have \"coincide_on ?\\<theta> \\<sigma> (vars_of u')\""], ["proof (prove)\nusing this:\n  vars_of u' \\<subseteq> vars_of_lit M'\n  coincide_on (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) \\<sigma>\n   (vars_of_lit M')\n\ngoal (1 subgoal):\n 1. coincide_on (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) \\<sigma>\n     (vars_of u')", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  vars_of u' \\<subseteq> vars_of_lit M'\n  \\<forall>x\\<in>vars_of_lit M'.\n     Var x \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> =\n     Var x \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of u'.\n       Var x \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> =\n       Var x \\<lhd> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  coincide_on (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) \\<sigma>\n   (vars_of u')\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n            (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  coincide_on (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) \\<sigma>\n   (vars_of u')", "have \"subst u' ?\\<theta> = subst u' \\<sigma>\""], ["proof (prove)\nusing this:\n  coincide_on (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) \\<sigma>\n   (vars_of u')\n\ngoal (1 subgoal):\n 1. u' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> =\n    u' \\<lhd> \\<sigma>", "using coincide_on_term"], ["proof (prove)\nusing this:\n  coincide_on (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) \\<sigma>\n   (vars_of u')\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of ?t) \\<Longrightarrow>\n  ?t \\<lhd> ?\\<sigma> = ?t \\<lhd> ?\\<eta>\n\ngoal (1 subgoal):\n 1. u' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> =\n    u' \\<lhd> \\<sigma>", "by metis"], ["proof (state)\nthis:\n  u' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> =\n  u' \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n            (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from this and \\<open>(subst u' \\<eta>) = u\\<close>"], ["proof (chain)\npicking this:\n  u' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> =\n  u' \\<lhd> \\<sigma>\n  u' \\<lhd> \\<eta> = u", "have \"subst u ?\\<theta>' = subst u' \\<sigma>\""], ["proof (prove)\nusing this:\n  u' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> =\n  u' \\<lhd> \\<sigma>\n  u' \\<lhd> \\<eta> = u\n\ngoal (1 subgoal):\n 1. u \\<lhd> \\<eta>' \\<lozenge> \\<sigma> = u' \\<lhd> \\<sigma>", "by simp"], ["proof (state)\nthis:\n  u \\<lhd> \\<eta>' \\<lozenge> \\<sigma> = u' \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n            (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from \\<open>vars_of v' \\<subseteq> vars_of_lit M'\\<close> and \\<open>coincide_on ?\\<theta> \\<sigma> (vars_of_lit M')\\<close>"], ["proof (chain)\npicking this:\n  vars_of v' \\<subseteq> vars_of_lit M'\n  coincide_on (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) \\<sigma>\n   (vars_of_lit M')", "have \"coincide_on ?\\<theta> \\<sigma> (vars_of v')\""], ["proof (prove)\nusing this:\n  vars_of v' \\<subseteq> vars_of_lit M'\n  coincide_on (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) \\<sigma>\n   (vars_of_lit M')\n\ngoal (1 subgoal):\n 1. coincide_on (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) \\<sigma>\n     (vars_of v')", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  vars_of v' \\<subseteq> vars_of_lit M'\n  \\<forall>x\\<in>vars_of_lit M'.\n     Var x \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> =\n     Var x \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of v'.\n       Var x \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> =\n       Var x \\<lhd> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  coincide_on (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) \\<sigma>\n   (vars_of v')\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n            (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  coincide_on (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) \\<sigma>\n   (vars_of v')", "have \"subst v' ?\\<theta> = subst v' \\<sigma>\""], ["proof (prove)\nusing this:\n  coincide_on (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) \\<sigma>\n   (vars_of v')\n\ngoal (1 subgoal):\n 1. v' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> =\n    v' \\<lhd> \\<sigma>", "using coincide_on_term"], ["proof (prove)\nusing this:\n  coincide_on (\\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma>) \\<sigma>\n   (vars_of v')\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of ?t) \\<Longrightarrow>\n  ?t \\<lhd> ?\\<sigma> = ?t \\<lhd> ?\\<eta>\n\ngoal (1 subgoal):\n 1. v' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> =\n    v' \\<lhd> \\<sigma>", "by metis"], ["proof (state)\nthis:\n  v' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> =\n  v' \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n            (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from this and \\<open>(subst v' \\<eta>) = v\\<close>"], ["proof (chain)\npicking this:\n  v' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> =\n  v' \\<lhd> \\<sigma>\n  v' \\<lhd> \\<eta> = v", "have \"subst v ?\\<theta>' = subst v' \\<sigma>\""], ["proof (prove)\nusing this:\n  v' \\<lhd> \\<eta> \\<lozenge> \\<eta>' \\<lozenge> \\<sigma> =\n  v' \\<lhd> \\<sigma>\n  v' \\<lhd> \\<eta> = v\n\ngoal (1 subgoal):\n 1. v \\<lhd> \\<eta>' \\<lozenge> \\<sigma> = v' \\<lhd> \\<sigma>", "by simp"], ["proof (state)\nthis:\n  v \\<lhd> \\<eta>' \\<lozenge> \\<sigma> = v' \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n            (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from \\<open>subst v ?\\<theta>' = subst v' \\<sigma>\\<close> \\<open>s'' = (subst v ?\\<theta>')\\<close>"], ["proof (chain)\npicking this:\n  v \\<lhd> \\<eta>' \\<lozenge> \\<sigma> = v' \\<lhd> \\<sigma>\n  s'' = v \\<lhd> \\<eta>' \\<lozenge> \\<sigma>", "have \"s'' = (subst v' \\<sigma>)\""], ["proof (prove)\nusing this:\n  v \\<lhd> \\<eta>' \\<lozenge> \\<sigma> = v' \\<lhd> \\<sigma>\n  s'' = v \\<lhd> \\<eta>' \\<lozenge> \\<sigma>\n\ngoal (1 subgoal):\n 1. s'' = v' \\<lhd> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  s'' = v' \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n            (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from \\<open>subst u ?\\<theta>' = subst u' \\<sigma>\\<close> \\<open>t = (subst u ?\\<theta>')\\<close>"], ["proof (chain)\npicking this:\n  u \\<lhd> \\<eta>' \\<lozenge> \\<sigma> = u' \\<lhd> \\<sigma>\n  t = u \\<lhd> \\<eta>' \\<lozenge> \\<sigma>", "have \"t = (subst u' \\<sigma>)\""], ["proof (prove)\nusing this:\n  u \\<lhd> \\<eta>' \\<lozenge> \\<sigma> = u' \\<lhd> \\<sigma>\n  t = u \\<lhd> \\<eta>' \\<lozenge> \\<sigma>\n\ngoal (1 subgoal):\n 1. t = u' \\<lhd> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  t = u' \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n            (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from \\<open>s'' = (subst v' \\<sigma>)\\<close> \\<open>t = (subst u' \\<sigma>)\\<close> \n      \\<open>orient_lit_inst M' u' v' pos \\<sigma>\\<close> \\<open>M' \\<in> C' - { L'}\\<close>"], ["proof (chain)\npicking this:\n  s'' = v' \\<lhd> \\<sigma>\n  t = u' \\<lhd> \\<sigma>\n  orient_lit_inst M' u' v' pos \\<sigma>\n  M' \\<in> C' - {L'}", "have \"eq_occurs_in_cl t s'' (C'- { L' }) \\<sigma>\""], ["proof (prove)\nusing this:\n  s'' = v' \\<lhd> \\<sigma>\n  t = u' \\<lhd> \\<sigma>\n  orient_lit_inst M' u' v' pos \\<sigma>\n  M' \\<in> C' - {L'}\n\ngoal (1 subgoal):\n 1. eq_occurs_in_cl t s'' (C' - {L'}) \\<sigma>", "unfolding eq_occurs_in_cl_def"], ["proof (prove)\nusing this:\n  s'' = v' \\<lhd> \\<sigma>\n  t = u' \\<lhd> \\<sigma>\n  orient_lit_inst M' u' v' pos \\<sigma>\n  M' \\<in> C' - {L'}\n\ngoal (1 subgoal):\n 1. \\<exists>L t' s'.\n       L \\<in> C' - {L'} \\<and>\n       orient_lit_inst L t' s' pos \\<sigma> \\<and>\n       t = t' \\<lhd> \\<sigma> \\<and> s'' = s' \\<lhd> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  eq_occurs_in_cl t s'' (C' - {L'}) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n            (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from this and \\<open>(s'',t) \\<in> trm_ord\\<close> and \\<open>(s,t) \\<in> trm_ord\\<close> and \\<open>(trm_rep s S) = (trm_rep s'' S)\\<close>"], ["proof (chain)\npicking this:\n  eq_occurs_in_cl t s'' (C' - {L'}) \\<sigma>\n  (s'', t) \\<in> trm_ord\n  (s, t) \\<in> trm_ord\n  trm_rep s S = trm_rep s'' S", "have \"\\<not>(maximal_literal_is_unique t s C' L' S \\<sigma>)\""], ["proof (prove)\nusing this:\n  eq_occurs_in_cl t s'' (C' - {L'}) \\<sigma>\n  (s'', t) \\<in> trm_ord\n  (s, t) \\<in> trm_ord\n  trm_rep s S = trm_rep s'' S\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C' L' S \\<sigma>", "unfolding maximal_literal_is_unique_def"], ["proof (prove)\nusing this:\n  eq_occurs_in_cl t s'' (C' - {L'}) \\<sigma>\n  (s'', t) \\<in> trm_ord\n  (s, t) \\<in> trm_ord\n  trm_rep s S = trm_rep s'' S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>s''.\n               eq_occurs_in_cl t s'' (C' - {L'}) \\<sigma> \\<longrightarrow>\n               (s'', t) \\<in> trm_ord \\<longrightarrow>\n               (s, t) \\<in> trm_ord \\<longrightarrow>\n               trm_rep s S \\<noteq> trm_rep s'' S)", "by blast"], ["proof (state)\nthis:\n  \\<not> maximal_literal_is_unique t s C' L' S \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal_is_unique t s C'_bis L'_bis S\n            (\\<eta>' \\<lozenge> \\<sigma>) \\<Longrightarrow>\n    False", "from this and assms(1)"], ["proof (chain)\npicking this:\n  \\<not> maximal_literal_is_unique t s C' L' S \\<sigma>\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S", "show False"], ["proof (prove)\nusing this:\n  \\<not> maximal_literal_is_unique t s C' L' S \\<sigma>\n  candidate_values z CC C' C s L L' \\<sigma> t' s' t S\n\ngoal (1 subgoal):\n 1. False", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  \\<not> maximal_literal_is_unique t s C' L' S \\<sigma>\n  CC \\<in> S \\<and>\n  t \\<notin> subst_set (trms_ecl CC) \\<sigma> \\<and>\n  trms_irreducible CC \\<sigma> S t \\<and>\n  C' = cl_ecl CC \\<and>\n  (s, t) \\<in> trm_ord \\<and>\n  ((s, t) \\<in> trm_ord \\<longrightarrow> z = trm_rep s S) \\<and>\n  orient_lit_inst L' t' s' pos \\<sigma> \\<and>\n  sel C' = {} \\<and>\n  L' \\<in> C' \\<and>\n  maximal_literal L C \\<and>\n  L = subst_lit L' \\<sigma> \\<and>\n  C = subst_cl C' \\<sigma> \\<and>\n  ground_clause C \\<and>\n  t = t' \\<lhd> \\<sigma> \\<and>\n  s = s' \\<lhd> \\<sigma> \\<and>\n  finite C' \\<and>\n  smaller_lits_are_false t C S \\<and>\n  maximal_literal_is_unique t s C' L' S \\<sigma>\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  maximal_literal_is_unique t s C'_bis L'_bis S\n   (\\<eta>' \\<lozenge> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from \\<open>t'_bis = (subst t' \\<eta>)\\<close> \n    and \\<open>t = subst t' \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  t'_bis = t' \\<lhd> \\<eta>\n  t = t' \\<lhd> \\<sigma>", "have \"t = subst t'_bis (comp \\<eta>' \\<sigma>)\""], ["proof (prove)\nusing this:\n  t'_bis = t' \\<lhd> \\<eta>\n  t = t' \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. t = t'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma>", "using \\<open>subst t'_bis (comp \\<eta>' \\<sigma>) = subst t' \\<sigma>\\<close>"], ["proof (prove)\nusing this:\n  t'_bis = t' \\<lhd> \\<eta>\n  t = t' \\<lhd> \\<sigma>\n  t'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma> = t' \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. t = t'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  t = t'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from \\<open>s'_bis = (subst s' \\<eta>)\\<close> \n    and \\<open>s = subst s' \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  s'_bis = s' \\<lhd> \\<eta>\n  s = s' \\<lhd> \\<sigma>", "have \"s = subst s'_bis (comp \\<eta>' \\<sigma>)\""], ["proof (prove)\nusing this:\n  s'_bis = s' \\<lhd> \\<eta>\n  s = s' \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. s = s'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma>", "using \\<open>subst s'_bis (comp \\<eta>' \\<sigma>) = subst s' \\<sigma>\\<close>"], ["proof (prove)\nusing this:\n  s'_bis = s' \\<lhd> \\<eta>\n  s = s' \\<lhd> \\<sigma>\n  s'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma> = s' \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. s = s'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  s = s'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from \\<open>CC_bis \\<in> S\\<close> \\<open>t \\<notin> subst_set (trms_ecl CC_bis) (comp \\<eta>' \\<sigma>)\\<close>\n    \\<open>trms_irreducible CC_bis (comp \\<eta>' \\<sigma>) S t\\<close>\n    \\<open>C'_bis = cl_ecl CC_bis\\<close> \\<open>(s, t) \\<in> trm_ord\\<close> \\<open>((s, t) \\<in> trm_ord \\<longrightarrow> z = trm_rep s S)\\<close>\n    \\<open>orient_lit_inst L'_bis t'_bis s'_bis pos (comp \\<eta>' \\<sigma>)\\<close>\n    \\<open>sel C'_bis = {}\\<close> \\<open>L'_bis \\<in> C'_bis\\<close> \\<open>maximal_literal L C\\<close> \n    \\<open>L = subst_lit L'_bis (comp \\<eta>' \\<sigma>)\\<close>\n    \\<open>C = subst_cl C'_bis (comp \\<eta>' \\<sigma>)\\<close>\n    \\<open>ground_clause C\\<close> \\<open>t = subst t'_bis (comp \\<eta>' \\<sigma>)\\<close>\n    \\<open>s = subst s'_bis (comp \\<eta>' \\<sigma>)\\<close>\n    \\<open>finite C'_bis\\<close> \\<open>smaller_lits_are_false t C S\\<close> \n    \\<open>maximal_literal_is_unique t s C'_bis L'_bis S (comp \\<eta>' \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  CC_bis \\<in> S\n  t \\<notin> subst_set (trms_ecl CC_bis) (\\<eta>' \\<lozenge> \\<sigma>)\n  trms_irreducible CC_bis (\\<eta>' \\<lozenge> \\<sigma>) S t\n  C'_bis = cl_ecl CC_bis\n  (s, t) \\<in> trm_ord\n  (s, t) \\<in> trm_ord \\<longrightarrow> z = trm_rep s S\n  orient_lit_inst L'_bis t'_bis s'_bis pos (\\<eta>' \\<lozenge> \\<sigma>)\n  sel C'_bis = {}\n  L'_bis \\<in> C'_bis\n  maximal_literal L C\n  L = subst_lit L'_bis (\\<eta>' \\<lozenge> \\<sigma>)\n  C = subst_cl C'_bis (\\<eta>' \\<lozenge> \\<sigma>)\n  ground_clause C\n  t = t'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma>\n  s = s'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma>\n  finite C'_bis\n  smaller_lits_are_false t C S\n  maximal_literal_is_unique t s C'_bis L'_bis S\n   (\\<eta>' \\<lozenge> \\<sigma>)", "have \"(candidate_values z CC_bis C'_bis C s L L'_bis ?\\<theta>' t'_bis s'_bis t S)\""], ["proof (prove)\nusing this:\n  CC_bis \\<in> S\n  t \\<notin> subst_set (trms_ecl CC_bis) (\\<eta>' \\<lozenge> \\<sigma>)\n  trms_irreducible CC_bis (\\<eta>' \\<lozenge> \\<sigma>) S t\n  C'_bis = cl_ecl CC_bis\n  (s, t) \\<in> trm_ord\n  (s, t) \\<in> trm_ord \\<longrightarrow> z = trm_rep s S\n  orient_lit_inst L'_bis t'_bis s'_bis pos (\\<eta>' \\<lozenge> \\<sigma>)\n  sel C'_bis = {}\n  L'_bis \\<in> C'_bis\n  maximal_literal L C\n  L = subst_lit L'_bis (\\<eta>' \\<lozenge> \\<sigma>)\n  C = subst_cl C'_bis (\\<eta>' \\<lozenge> \\<sigma>)\n  ground_clause C\n  t = t'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma>\n  s = s'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma>\n  finite C'_bis\n  smaller_lits_are_false t C S\n  maximal_literal_is_unique t s C'_bis L'_bis S\n   (\\<eta>' \\<lozenge> \\<sigma>)\n\ngoal (1 subgoal):\n 1. candidate_values z CC_bis C'_bis C s L L'_bis\n     (\\<eta>' \\<lozenge> \\<sigma>) t'_bis s'_bis t S", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  CC_bis \\<in> S\n  t \\<notin> subst_set (trms_ecl CC_bis) (\\<eta>' \\<lozenge> \\<sigma>)\n  trms_irreducible CC_bis (\\<eta>' \\<lozenge> \\<sigma>) S t\n  C'_bis = cl_ecl CC_bis\n  (s, t) \\<in> trm_ord\n  (s, t) \\<in> trm_ord \\<longrightarrow> z = trm_rep s S\n  orient_lit_inst L'_bis t'_bis s'_bis pos (\\<eta>' \\<lozenge> \\<sigma>)\n  sel C'_bis = {}\n  L'_bis \\<in> C'_bis\n  maximal_literal L C\n  L = subst_lit L'_bis (\\<eta>' \\<lozenge> \\<sigma>)\n  C = subst_cl C'_bis (\\<eta>' \\<lozenge> \\<sigma>)\n  ground_clause C\n  t = t'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma>\n  s = s'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma>\n  finite C'_bis\n  smaller_lits_are_false t C S\n  maximal_literal_is_unique t s C'_bis L'_bis S\n   (\\<eta>' \\<lozenge> \\<sigma>)\n\ngoal (1 subgoal):\n 1. CC_bis \\<in> S \\<and>\n    t \\<notin> subst_set (trms_ecl CC_bis)\n                (\\<eta>' \\<lozenge> \\<sigma>) \\<and>\n    trms_irreducible CC_bis (\\<eta>' \\<lozenge> \\<sigma>) S t \\<and>\n    C'_bis = cl_ecl CC_bis \\<and>\n    (s, t) \\<in> trm_ord \\<and>\n    ((s, t) \\<in> trm_ord \\<longrightarrow> z = trm_rep s S) \\<and>\n    orient_lit_inst L'_bis t'_bis s'_bis pos\n     (\\<eta>' \\<lozenge> \\<sigma>) \\<and>\n    sel C'_bis = {} \\<and>\n    L'_bis \\<in> C'_bis \\<and>\n    maximal_literal L C \\<and>\n    L = subst_lit L'_bis (\\<eta>' \\<lozenge> \\<sigma>) \\<and>\n    C = subst_cl C'_bis (\\<eta>' \\<lozenge> \\<sigma>) \\<and>\n    ground_clause C \\<and>\n    t = t'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma> \\<and>\n    s = s'_bis \\<lhd> \\<eta>' \\<lozenge> \\<sigma> \\<and>\n    finite C'_bis \\<and>\n    smaller_lits_are_false t C S \\<and>\n    maximal_literal_is_unique t s C'_bis L'_bis S\n     (\\<eta>' \\<lozenge> \\<sigma>)", "by metis"], ["proof (state)\nthis:\n  candidate_values z CC_bis C'_bis C s L L'_bis\n   (\\<eta>' \\<lozenge> \\<sigma>) t'_bis s'_bis t S\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "have \"vars_of_cl (cl_ecl D) \\<inter> (vars_of_cl (cl_ecl CC_bis)) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "assume \"vars_of_cl (cl_ecl D) \\<inter> (vars_of_cl (cl_ecl CC_bis)) \\<noteq> {}\""], ["proof (state)\nthis:\n  vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "from this and \\<open>C'_bis = (cl_ecl CC_bis)\\<close>"], ["proof (chain)\npicking this:\n  vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) \\<noteq> {}\n  C'_bis = cl_ecl CC_bis", "obtain x where \"x \\<in> vars_of_cl C'_bis\" and \"x \\<in> vars_of_cl (cl_ecl D)\""], ["proof (prove)\nusing this:\n  vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) \\<noteq> {}\n  C'_bis = cl_ecl CC_bis\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> vars_of_cl C'_bis;\n         x \\<in> vars_of_cl (cl_ecl D)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> vars_of_cl C'_bis\n  x \\<in> vars_of_cl (cl_ecl D)\n\ngoal (1 subgoal):\n 1. vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "from \\<open>x \\<in> vars_of_cl C'_bis\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> vars_of_cl C'_bis", "obtain N where \"N \\<in> C'_bis\" and \"x \\<in> vars_of_lit N\""], ["proof (prove)\nusing this:\n  x \\<in> vars_of_cl C'_bis\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        \\<lbrakk>N \\<in> C'_bis; x \\<in> vars_of_lit N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  N \\<in> C'_bis\n  x \\<in> vars_of_lit N\n\ngoal (1 subgoal):\n 1. vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "from \\<open>N \\<in> C'_bis\\<close> and \\<open>C'_bis = (subst_cl C' \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  N \\<in> C'_bis\n  C'_bis = subst_cl C' \\<eta>", "obtain N' where\n        \"N' \\<in> C'\" and \"N = subst_lit N' \\<eta>\""], ["proof (prove)\nusing this:\n  N \\<in> C'_bis\n  C'_bis = subst_cl C' \\<eta>\n\ngoal (1 subgoal):\n 1. (\\<And>N'.\n        \\<lbrakk>N' \\<in> C'; N = subst_lit N' \\<eta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  N' \\<in> C'\n  N = subst_lit N' \\<eta>\n\ngoal (1 subgoal):\n 1. vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "from \\<open>x \\<in> vars_of_lit N\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> vars_of_lit N", "obtain e where \"N = (Pos e) \\<or> (N = (Neg e))\" \n        and \"x \\<in> vars_of_eq e\""], ["proof (prove)\nusing this:\n  x \\<in> vars_of_lit N\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>N = Pos e \\<or> N = Neg e; x \\<in> vars_of_eq e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis negative_literal.elims(2) negative_literal.elims(3) vars_of_lit.simps(1) \n            vars_of_lit.simps(2))"], ["proof (state)\nthis:\n  N = Pos e \\<or> N = Neg e\n  x \\<in> vars_of_eq e\n\ngoal (1 subgoal):\n 1. vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "from \\<open>N = (Pos e) \\<or> (N = (Neg e))\\<close> and \\<open>N = subst_lit N' \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  N = Pos e \\<or> N = Neg e\n  N = subst_lit N' \\<eta>", "obtain e' where\n        \"N' = (Pos e') \\<or> (N' = (Neg e'))\" and \"e = subst_equation e' \\<eta>\""], ["proof (prove)\nusing this:\n  N = Pos e \\<or> N = Neg e\n  N = subst_lit N' \\<eta>\n\ngoal (1 subgoal):\n 1. (\\<And>e'.\n        \\<lbrakk>N' = Pos e' \\<or> N' = Neg e';\n         e = subst_equation e' \\<eta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis subst_lit.elims atom.simps(1) atom.simps(2))"], ["proof (state)\nthis:\n  N' = Pos e' \\<or> N' = Neg e'\n  e = subst_equation e' \\<eta>\n\ngoal (1 subgoal):\n 1. vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "from \\<open>x \\<in> vars_of_eq e\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> vars_of_eq e", "obtain u v where \"e = (Eq u v)\" and \"x \\<in> vars_of u \\<union> vars_of v\""], ["proof (prove)\nusing this:\n  x \\<in> vars_of_eq e\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>e = Eq u v; x \\<in> vars_of u \\<union> vars_of v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis equation.exhaust vars_of_eq.simps)"], ["proof (state)\nthis:\n  e = Eq u v\n  x \\<in> vars_of u \\<union> vars_of v\n\ngoal (1 subgoal):\n 1. vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "from \\<open>e = (Eq u v)\\<close> and \\<open>e = subst_equation e' \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  e = Eq u v\n  e = subst_equation e' \\<eta>", "obtain u' v' where \"e' = (Eq u' v')\"\n        \"u = (subst u' \\<eta>)\" and \"v = (subst v' \\<eta>)\""], ["proof (prove)\nusing this:\n  e = Eq u v\n  e = subst_equation e' \\<eta>\n\ngoal (1 subgoal):\n 1. (\\<And>u' v'.\n        \\<lbrakk>e' = Eq u' v'; u = u' \\<lhd> \\<eta>;\n         v = v' \\<lhd> \\<eta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis subst_equation.simps equation.exhaust equation.inject)"], ["proof (state)\nthis:\n  e' = Eq u' v'\n  u = u' \\<lhd> \\<eta>\n  v = v' \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "from \\<open>x \\<in> vars_of u \\<union> vars_of v\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> vars_of u \\<union> vars_of v", "have \"x \\<in> vars_of u \\<or> x \\<in> vars_of v\""], ["proof (prove)\nusing this:\n  x \\<in> vars_of u \\<union> vars_of v\n\ngoal (1 subgoal):\n 1. x \\<in> vars_of u \\<or> x \\<in> vars_of v", "by auto"], ["proof (state)\nthis:\n  x \\<in> vars_of u \\<or> x \\<in> vars_of v\n\ngoal (1 subgoal):\n 1. vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) \\<noteq>\n    {} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  x \\<in> vars_of u \\<or> x \\<in> vars_of v", "show False"], ["proof (prove)\nusing this:\n  x \\<in> vars_of u \\<or> x \\<in> vars_of v\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> vars_of u \\<Longrightarrow> False\n 2. x \\<in> vars_of v \\<Longrightarrow> False", "assume \"x \\<in> vars_of u\""], ["proof (state)\nthis:\n  x \\<in> vars_of u\n\ngoal (2 subgoals):\n 1. x \\<in> vars_of u \\<Longrightarrow> False\n 2. x \\<in> vars_of v \\<Longrightarrow> False", "from this and \\<open>u = (subst u' \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> vars_of u\n  u = u' \\<lhd> \\<eta>", "obtain y where \"y \\<in> vars_of u'\" and \"x \\<in> vars_of (subst (Var y) \\<eta>)\""], ["proof (prove)\nusing this:\n  x \\<in> vars_of u\n  u = u' \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> vars_of u';\n         x \\<in> vars_of (Var y \\<lhd> \\<eta>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using vars_of_instances [of u' \\<eta>]"], ["proof (prove)\nusing this:\n  x \\<in> vars_of u\n  u = u' \\<lhd> \\<eta>\n  vars_of (u' \\<lhd> \\<eta>) =\n  \\<Union>\n   {V. \\<exists>x.\n          x \\<in> vars_of u' \\<and> V = vars_of (Var x \\<lhd> \\<eta>)}\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> vars_of u';\n         x \\<in> vars_of (Var y \\<lhd> \\<eta>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> vars_of u'\n  x \\<in> vars_of (Var y \\<lhd> \\<eta>)\n\ngoal (2 subgoals):\n 1. x \\<in> vars_of u \\<Longrightarrow> False\n 2. x \\<in> vars_of v \\<Longrightarrow> False", "from \\<open>y \\<in> vars_of u'\\<close> and \\<open>e' = (Eq u' v')\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> vars_of u'\n  e' = Eq u' v'", "have \"y \\<in> vars_of_eq e'\""], ["proof (prove)\nusing this:\n  y \\<in> vars_of u'\n  e' = Eq u' v'\n\ngoal (1 subgoal):\n 1. y \\<in> vars_of_eq e'", "by auto"], ["proof (state)\nthis:\n  y \\<in> vars_of_eq e'\n\ngoal (2 subgoals):\n 1. x \\<in> vars_of u \\<Longrightarrow> False\n 2. x \\<in> vars_of v \\<Longrightarrow> False", "from this and \\<open>N' = (Pos e') \\<or> (N' = (Neg e'))\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> vars_of_eq e'\n  N' = Pos e' \\<or> N' = Neg e'", "have \"y \\<in> vars_of_lit N'\""], ["proof (prove)\nusing this:\n  y \\<in> vars_of_eq e'\n  N' = Pos e' \\<or> N' = Neg e'\n\ngoal (1 subgoal):\n 1. y \\<in> vars_of_lit N'", "by auto"], ["proof (state)\nthis:\n  y \\<in> vars_of_lit N'\n\ngoal (2 subgoals):\n 1. x \\<in> vars_of u \\<Longrightarrow> False\n 2. x \\<in> vars_of v \\<Longrightarrow> False", "from this and \\<open>N' \\<in> C'\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> vars_of_lit N'\n  N' \\<in> C'", "have \"y \\<in> vars_of_cl C'\""], ["proof (prove)\nusing this:\n  y \\<in> vars_of_lit N'\n  N' \\<in> C'\n\ngoal (1 subgoal):\n 1. y \\<in> vars_of_cl C'", "by auto"], ["proof (state)\nthis:\n  y \\<in> vars_of_cl C'\n\ngoal (2 subgoals):\n 1. x \\<in> vars_of u \\<Longrightarrow> False\n 2. x \\<in> vars_of v \\<Longrightarrow> False", "from this and \\<open>renaming \\<eta> (vars_of_cl C')\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> vars_of_cl C'\n  renaming \\<eta> (vars_of_cl C')", "have \"is_a_variable (subst (Var y) \\<eta>)\""], ["proof (prove)\nusing this:\n  y \\<in> vars_of_cl C'\n  renaming \\<eta> (vars_of_cl C')\n\ngoal (1 subgoal):\n 1. is_a_variable (Var y \\<lhd> \\<eta>)", "unfolding renaming_def"], ["proof (prove)\nusing this:\n  y \\<in> vars_of_cl C'\n  \\<forall>x\\<in>vars_of_cl C'.\n     is_a_variable (Var x \\<lhd> \\<eta>) \\<and>\n     (\\<forall>x y.\n         x \\<in> vars_of_cl C' \\<longrightarrow>\n         y \\<in> vars_of_cl C' \\<longrightarrow>\n         x \\<noteq> y \\<longrightarrow>\n         Var x \\<lhd> \\<eta> \\<noteq> Var y \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. is_a_variable (Var y \\<lhd> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  is_a_variable (Var y \\<lhd> \\<eta>)\n\ngoal (2 subgoals):\n 1. x \\<in> vars_of u \\<Longrightarrow> False\n 2. x \\<in> vars_of v \\<Longrightarrow> False", "from this and \\<open>x \\<in> vars_of (subst (Var y) \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  is_a_variable (Var y \\<lhd> \\<eta>)\n  x \\<in> vars_of (Var y \\<lhd> \\<eta>)", "have \n          \"Var x = (subst (Var y) \\<eta>)\""], ["proof (prove)\nusing this:\n  is_a_variable (Var y \\<lhd> \\<eta>)\n  x \\<in> vars_of (Var y \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. Var x = Var y \\<lhd> \\<eta>", "by (metis is_a_variable.elims(2) singletonD vars_of.simps(1))"], ["proof (state)\nthis:\n  Var x = Var y \\<lhd> \\<eta>\n\ngoal (2 subgoals):\n 1. x \\<in> vars_of u \\<Longrightarrow> False\n 2. x \\<in> vars_of v \\<Longrightarrow> False", "from this and \\<open>y \\<in> vars_of_cl C'\\<close>"], ["proof (chain)\npicking this:\n  Var x = Var y \\<lhd> \\<eta>\n  y \\<in> vars_of_cl C'", "have \"x \\<in> (subst_codomain \\<eta> (vars_of_cl C'))\""], ["proof (prove)\nusing this:\n  Var x = Var y \\<lhd> \\<eta>\n  y \\<in> vars_of_cl C'\n\ngoal (1 subgoal):\n 1. x \\<in> subst_codomain \\<eta> (vars_of_cl C')", "unfolding subst_codomain_def"], ["proof (prove)\nusing this:\n  Var x = Var y \\<lhd> \\<eta>\n  y \\<in> vars_of_cl C'\n\ngoal (1 subgoal):\n 1. x \\<in> {x. \\<exists>y.\n                   Var y \\<lhd> \\<eta> = Var x \\<and> y \\<in> vars_of_cl C'}", "by auto"], ["proof (state)\nthis:\n  x \\<in> subst_codomain \\<eta> (vars_of_cl C')\n\ngoal (2 subgoals):\n 1. x \\<in> vars_of u \\<Longrightarrow> False\n 2. x \\<in> vars_of v \\<Longrightarrow> False", "from this and \\<open>x \\<in> vars_of_cl (cl_ecl D)\\<close> \n          and \\<open>((subst_codomain \\<eta> (vars_of_cl C')) \\<inter> (vars_of_cl (cl_ecl D))) = {}\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> subst_codomain \\<eta> (vars_of_cl C')\n  x \\<in> vars_of_cl (cl_ecl D)\n  subst_codomain \\<eta> (vars_of_cl C') \\<inter> vars_of_cl (cl_ecl D) = {}", "show False"], ["proof (prove)\nusing this:\n  x \\<in> subst_codomain \\<eta> (vars_of_cl C')\n  x \\<in> vars_of_cl (cl_ecl D)\n  subst_codomain \\<eta> (vars_of_cl C') \\<inter> vars_of_cl (cl_ecl D) = {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. x \\<in> vars_of v \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> vars_of v \\<Longrightarrow> False", "assume \"x \\<in> vars_of v\""], ["proof (state)\nthis:\n  x \\<in> vars_of v\n\ngoal (1 subgoal):\n 1. x \\<in> vars_of v \\<Longrightarrow> False", "from this and \\<open>v = (subst v' \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> vars_of v\n  v = v' \\<lhd> \\<eta>", "obtain y where \"y \\<in> vars_of v'\" and \"x \\<in> vars_of (subst (Var y) \\<eta>)\""], ["proof (prove)\nusing this:\n  x \\<in> vars_of v\n  v = v' \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> vars_of v';\n         x \\<in> vars_of (Var y \\<lhd> \\<eta>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using vars_of_instances [of v' \\<eta>]"], ["proof (prove)\nusing this:\n  x \\<in> vars_of v\n  v = v' \\<lhd> \\<eta>\n  vars_of (v' \\<lhd> \\<eta>) =\n  \\<Union>\n   {V. \\<exists>x.\n          x \\<in> vars_of v' \\<and> V = vars_of (Var x \\<lhd> \\<eta>)}\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> vars_of v';\n         x \\<in> vars_of (Var y \\<lhd> \\<eta>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> vars_of v'\n  x \\<in> vars_of (Var y \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. x \\<in> vars_of v \\<Longrightarrow> False", "from \\<open>y \\<in> vars_of v'\\<close> and \\<open>e' = (Eq u' v')\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> vars_of v'\n  e' = Eq u' v'", "have \"y \\<in> vars_of_eq e'\""], ["proof (prove)\nusing this:\n  y \\<in> vars_of v'\n  e' = Eq u' v'\n\ngoal (1 subgoal):\n 1. y \\<in> vars_of_eq e'", "by auto"], ["proof (state)\nthis:\n  y \\<in> vars_of_eq e'\n\ngoal (1 subgoal):\n 1. x \\<in> vars_of v \\<Longrightarrow> False", "from this and \\<open>N' = (Pos e') \\<or> (N' = (Neg e'))\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> vars_of_eq e'\n  N' = Pos e' \\<or> N' = Neg e'", "have \"y \\<in> vars_of_lit N'\""], ["proof (prove)\nusing this:\n  y \\<in> vars_of_eq e'\n  N' = Pos e' \\<or> N' = Neg e'\n\ngoal (1 subgoal):\n 1. y \\<in> vars_of_lit N'", "by auto"], ["proof (state)\nthis:\n  y \\<in> vars_of_lit N'\n\ngoal (1 subgoal):\n 1. x \\<in> vars_of v \\<Longrightarrow> False", "from this and \\<open>N' \\<in> C'\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> vars_of_lit N'\n  N' \\<in> C'", "have \"y \\<in> vars_of_cl C'\""], ["proof (prove)\nusing this:\n  y \\<in> vars_of_lit N'\n  N' \\<in> C'\n\ngoal (1 subgoal):\n 1. y \\<in> vars_of_cl C'", "by auto"], ["proof (state)\nthis:\n  y \\<in> vars_of_cl C'\n\ngoal (1 subgoal):\n 1. x \\<in> vars_of v \\<Longrightarrow> False", "from this and \\<open>renaming \\<eta> (vars_of_cl C')\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> vars_of_cl C'\n  renaming \\<eta> (vars_of_cl C')", "have \"is_a_variable (subst (Var y) \\<eta>)\""], ["proof (prove)\nusing this:\n  y \\<in> vars_of_cl C'\n  renaming \\<eta> (vars_of_cl C')\n\ngoal (1 subgoal):\n 1. is_a_variable (Var y \\<lhd> \\<eta>)", "unfolding renaming_def"], ["proof (prove)\nusing this:\n  y \\<in> vars_of_cl C'\n  \\<forall>x\\<in>vars_of_cl C'.\n     is_a_variable (Var x \\<lhd> \\<eta>) \\<and>\n     (\\<forall>x y.\n         x \\<in> vars_of_cl C' \\<longrightarrow>\n         y \\<in> vars_of_cl C' \\<longrightarrow>\n         x \\<noteq> y \\<longrightarrow>\n         Var x \\<lhd> \\<eta> \\<noteq> Var y \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. is_a_variable (Var y \\<lhd> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  is_a_variable (Var y \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. x \\<in> vars_of v \\<Longrightarrow> False", "from this and \\<open>x \\<in> vars_of (subst (Var y) \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  is_a_variable (Var y \\<lhd> \\<eta>)\n  x \\<in> vars_of (Var y \\<lhd> \\<eta>)", "have \n          \"Var x = (subst (Var y) \\<eta>)\""], ["proof (prove)\nusing this:\n  is_a_variable (Var y \\<lhd> \\<eta>)\n  x \\<in> vars_of (Var y \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. Var x = Var y \\<lhd> \\<eta>", "by (metis is_a_variable.elims(2) singletonD vars_of.simps(1))"], ["proof (state)\nthis:\n  Var x = Var y \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. x \\<in> vars_of v \\<Longrightarrow> False", "from this and \\<open>y \\<in> vars_of_cl C'\\<close>"], ["proof (chain)\npicking this:\n  Var x = Var y \\<lhd> \\<eta>\n  y \\<in> vars_of_cl C'", "have \"x \\<in> (subst_codomain \\<eta> (vars_of_cl C'))\""], ["proof (prove)\nusing this:\n  Var x = Var y \\<lhd> \\<eta>\n  y \\<in> vars_of_cl C'\n\ngoal (1 subgoal):\n 1. x \\<in> subst_codomain \\<eta> (vars_of_cl C')", "unfolding subst_codomain_def"], ["proof (prove)\nusing this:\n  Var x = Var y \\<lhd> \\<eta>\n  y \\<in> vars_of_cl C'\n\ngoal (1 subgoal):\n 1. x \\<in> {x. \\<exists>y.\n                   Var y \\<lhd> \\<eta> = Var x \\<and> y \\<in> vars_of_cl C'}", "by auto"], ["proof (state)\nthis:\n  x \\<in> subst_codomain \\<eta> (vars_of_cl C')\n\ngoal (1 subgoal):\n 1. x \\<in> vars_of v \\<Longrightarrow> False", "from this and \\<open>x \\<in> vars_of_cl (cl_ecl D)\\<close> \n          and \\<open>((subst_codomain \\<eta> (vars_of_cl C')) \\<inter> (vars_of_cl (cl_ecl D))) = {}\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> subst_codomain \\<eta> (vars_of_cl C')\n  x \\<in> vars_of_cl (cl_ecl D)\n  subst_codomain \\<eta> (vars_of_cl C') \\<inter> vars_of_cl (cl_ecl D) = {}", "show False"], ["proof (prove)\nusing this:\n  x \\<in> subst_codomain \\<eta> (vars_of_cl C')\n  x \\<in> vars_of_cl (cl_ecl D)\n  subst_codomain \\<eta> (vars_of_cl C') \\<inter> vars_of_cl (cl_ecl D) = {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "from this and \\<open>(candidate_values z CC_bis C'_bis C s L L'_bis ?\\<theta>' t'_bis s'_bis t S)\\<close>"], ["proof (chain)\npicking this:\n  vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}\n  candidate_values z CC_bis C'_bis C s L L'_bis\n   (\\<eta>' \\<lozenge> \\<sigma>) t'_bis s'_bis t S", "show ?thesis"], ["proof (prove)\nusing this:\n  vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}\n  candidate_values z CC_bis C'_bis C s L L'_bis\n   (\\<eta>' \\<lozenge> \\<sigma>) t'_bis s'_bis t S\n\ngoal (1 subgoal):\n 1. \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n       candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n        s'_bis t S \\<and>\n       vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}", "by blast"], ["proof (state)\nthis:\n  \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis t_bis.\n     candidate_values z CC_bis C'_bis C s L L'_bis \\<sigma>_bis t'_bis\n      s'_bis t S \\<and>\n     vars_of_cl (cl_ecl D) \\<inter> vars_of_cl (cl_ecl CC_bis) = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pos_ord_acyclic:\n  shows \"acyclic (pos_ord C t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic (pos_ord C t)", "by (simp add: acyclic_irrefl pos_ord_irrefl pos_ord_trans)"], ["", "definition proper_subterm_red\n  where \"proper_subterm_red t S \\<sigma> = \n    (\\<exists>p s. (subterm t p s \\<and> p \\<noteq> Nil \\<and> (trm_rep (subst s \\<sigma>) S \\<noteq> (subst s \\<sigma>))))\""], ["", "text \\<open>The following lemma states that if an eligible term in a clause instance \nis not in normal form, then the clause instance must be reducible (according to the previous\ndefinition of @{term \"reduction\"}). This is the key lemma for proving completeness. \nNote that we assume that the considered substitution is in normal form, so that the reduction \ncannot occur inside a variable. We also rename the clause used for the reduction, to ensure that it \nshares no variable with the provided clause.  \nThe proof requires an additional hypothesis in the case where the reducible term occurs at the root\nposition in an eligible term of a positive literal, see the first hypothesis below \nand function @{term \"equivalent_eq_exists\"}.\\<close>"], ["", "lemma reduction_exists: \n  assumes \"polarity = neg \\<or> \\<not> equivalent_eq_exists t s (cl_ecl C) (int_clset S) \\<sigma> L1\n    \\<or> proper_subterm_red t S \\<sigma>\"\n  assumes \"\\<forall>x y. (( x \\<in> vars_of_cl (cl_ecl C)) \\<longrightarrow> (occurs_in y (subst (Var x) \\<sigma>)) \n            \\<longrightarrow> trm_rep y S = y)\"\n  assumes \"eligible_literal L1 C \\<sigma>\"\n  assumes \"(trm_rep (subst t \\<sigma>) S) \\<noteq>  (subst t \\<sigma>)\"\n  assumes \"L1 \\<in> (cl_ecl C)\"\n  assumes \"(orient_lit_inst L1 t s polarity \\<sigma>)\"\n  assumes \"\\<forall>x \\<in> S. finite (cl_ecl x)\"\n  assumes \"ground_clause (subst_cl (cl_ecl C) \\<sigma>)\"\n  assumes \"(fo_interpretation (same_values (\\<lambda>t. (trm_rep t S))))\"\n  assumes \"C \\<in> S\"\n  assumes \"Ball S well_constrained\"\n  assumes \"all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>) (\\<lambda>t. trm_rep t S)\"\n  assumes \"\\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\"\n  assumes \"closed_under_renaming S\"\n\n  shows \"\\<exists>\\<sigma>' u u' p v D L2. \n    ((reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (same_values (\\<lambda>t. (trm_rep t S))) S \\<sigma>)\n    \\<and> (variable_disjoint C D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "text \\<open>The first step is to get the minimal reducible position in @{term \"(subst t \\<sigma>)\"} and \nthe corresponding subterm @{term \"v\"}.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "let ?Redexes = \"{ p. \\<exists>v. subterm (subst t \\<sigma>) p v \\<and> root_term S v \\<and> trm_rep v S \\<noteq> v }\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "have \"?Redexes \\<subseteq> pos_of (subst t \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. \\<exists>v.\n           subterm (t \\<lhd> \\<sigma>) p v \\<and>\n           root_term S v \\<and> trm_rep v S \\<noteq> v}\n    \\<subseteq> pos_of (t \\<lhd> \\<sigma>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. \\<exists>v.\n                      subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                      root_term S v \\<and>\n                      trm_rep v S \\<noteq> v} \\<Longrightarrow>\n       x \\<in> pos_of (t \\<lhd> \\<sigma>)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. \\<exists>v.\n                      subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                      root_term S v \\<and>\n                      trm_rep v S \\<noteq> v} \\<Longrightarrow>\n       x \\<in> pos_of (t \\<lhd> \\<sigma>)", "assume \"x \\<in> ?Redexes\""], ["proof (state)\nthis:\n  x \\<in> {p. \\<exists>v.\n                 subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                 root_term S v \\<and> trm_rep v S \\<noteq> v}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. \\<exists>v.\n                      subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                      root_term S v \\<and>\n                      trm_rep v S \\<noteq> v} \\<Longrightarrow>\n       x \\<in> pos_of (t \\<lhd> \\<sigma>)", "then"], ["proof (chain)\npicking this:\n  x \\<in> {p. \\<exists>v.\n                 subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                 root_term S v \\<and> trm_rep v S \\<noteq> v}", "have \"\\<exists>v. subterm (subst t \\<sigma>) x v\""], ["proof (prove)\nusing this:\n  x \\<in> {p. \\<exists>v.\n                 subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                 root_term S v \\<and> trm_rep v S \\<noteq> v}\n\ngoal (1 subgoal):\n 1. \\<exists>v. subterm (t \\<lhd> \\<sigma>) x v", "by blast"], ["proof (state)\nthis:\n  \\<exists>v. subterm (t \\<lhd> \\<sigma>) x v\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. \\<exists>v.\n                      subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                      root_term S v \\<and>\n                      trm_rep v S \\<noteq> v} \\<Longrightarrow>\n       x \\<in> pos_of (t \\<lhd> \\<sigma>)", "then"], ["proof (chain)\npicking this:\n  \\<exists>v. subterm (t \\<lhd> \\<sigma>) x v", "have \"position_in x (subst t \\<sigma>)\""], ["proof (prove)\nusing this:\n  \\<exists>v. subterm (t \\<lhd> \\<sigma>) x v\n\ngoal (1 subgoal):\n 1. position_in x (t \\<lhd> \\<sigma>)", "unfolding position_in_def"], ["proof (prove)\nusing this:\n  \\<exists>v. subterm (t \\<lhd> \\<sigma>) x v\n\ngoal (1 subgoal):\n 1. Ex (subterm (t \\<lhd> \\<sigma>) x)", "by metis"], ["proof (state)\nthis:\n  position_in x (t \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {p. \\<exists>v.\n                      subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                      root_term S v \\<and>\n                      trm_rep v S \\<noteq> v} \\<Longrightarrow>\n       x \\<in> pos_of (t \\<lhd> \\<sigma>)", "then"], ["proof (chain)\npicking this:\n  position_in x (t \\<lhd> \\<sigma>)", "show \"x \\<in> pos_of (subst t \\<sigma>)\""], ["proof (prove)\nusing this:\n  position_in x (t \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. x \\<in> pos_of (t \\<lhd> \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  x \\<in> pos_of (t \\<lhd> \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {p. \\<exists>v.\n         subterm (t \\<lhd> \\<sigma>) p v \\<and>\n         root_term S v \\<and> trm_rep v S \\<noteq> v}\n  \\<subseteq> pos_of (t \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from this"], ["proof (chain)\npicking this:\n  {p. \\<exists>v.\n         subterm (t \\<lhd> \\<sigma>) p v \\<and>\n         root_term S v \\<and> trm_rep v S \\<noteq> v}\n  \\<subseteq> pos_of (t \\<lhd> \\<sigma>)", "have \"finite ?Redexes\""], ["proof (prove)\nusing this:\n  {p. \\<exists>v.\n         subterm (t \\<lhd> \\<sigma>) p v \\<and>\n         root_term S v \\<and> trm_rep v S \\<noteq> v}\n  \\<subseteq> pos_of (t \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. finite\n     {p. \\<exists>v.\n            subterm (t \\<lhd> \\<sigma>) p v \\<and>\n            root_term S v \\<and> trm_rep v S \\<noteq> v}", "using set_of_positions_is_finite [of \"(subst t \\<sigma>)\" ]"], ["proof (prove)\nusing this:\n  {p. \\<exists>v.\n         subterm (t \\<lhd> \\<sigma>) p v \\<and>\n         root_term S v \\<and> trm_rep v S \\<noteq> v}\n  \\<subseteq> pos_of (t \\<lhd> \\<sigma>)\n  finite (pos_of (t \\<lhd> \\<sigma>))\n\ngoal (1 subgoal):\n 1. finite\n     {p. \\<exists>v.\n            subterm (t \\<lhd> \\<sigma>) p v \\<and>\n            root_term S v \\<and> trm_rep v S \\<noteq> v}", "using finite_subset"], ["proof (prove)\nusing this:\n  {p. \\<exists>v.\n         subterm (t \\<lhd> \\<sigma>) p v \\<and>\n         root_term S v \\<and> trm_rep v S \\<noteq> v}\n  \\<subseteq> pos_of (t \\<lhd> \\<sigma>)\n  finite (pos_of (t \\<lhd> \\<sigma>))\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite\n     {p. \\<exists>v.\n            subterm (t \\<lhd> \\<sigma>) p v \\<and>\n            root_term S v \\<and> trm_rep v S \\<noteq> v}", "by blast"], ["proof (state)\nthis:\n  finite\n   {p. \\<exists>v.\n          subterm (t \\<lhd> \\<sigma>) p v \\<and>\n          root_term S v \\<and> trm_rep v S \\<noteq> v}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from assms(4)"], ["proof (chain)\npicking this:\n  trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> t \\<lhd> \\<sigma>", "have \"st_red S (subst t \\<sigma>)\""], ["proof (prove)\nusing this:\n  trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> t \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. st_red S (t \\<lhd> \\<sigma>)", "using subterms_of_irred_trms_are_irred"], ["proof (prove)\nusing this:\n  trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> t \\<lhd> \\<sigma>\n  trm_rep ?t ?S \\<noteq> ?t \\<longrightarrow> st_red ?S ?t\n\ngoal (1 subgoal):\n 1. st_red S (t \\<lhd> \\<sigma>)", "by blast"], ["proof (state)\nthis:\n  st_red S (t \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from this"], ["proof (chain)\npicking this:\n  st_red S (t \\<lhd> \\<sigma>)", "obtain p' where \"p' \\<in> ?Redexes\""], ["proof (prove)\nusing this:\n  st_red S (t \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        p' \\<in> {p. \\<exists>v.\n                        subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                        root_term S v \\<and>\n                        trm_rep v S \\<noteq> v} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding st_red_def"], ["proof (prove)\nusing this:\n  \\<exists>t' p.\n     subterm (t \\<lhd> \\<sigma>) p t' \\<and>\n     root_term S t' \\<and> trm_rep t' S \\<noteq> t'\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        p' \\<in> {p. \\<exists>v.\n                        subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                        root_term S v \\<and>\n                        trm_rep v S \\<noteq> v} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p' \\<in> {p. \\<exists>v.\n                  subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                  root_term S v \\<and> trm_rep v S \\<noteq> v}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>finite ?Redexes\\<close> this"], ["proof (chain)\npicking this:\n  finite\n   {p. \\<exists>v.\n          subterm (t \\<lhd> \\<sigma>) p v \\<and>\n          root_term S v \\<and> trm_rep v S \\<noteq> v}\n  p' \\<in> {p. \\<exists>v.\n                  subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                  root_term S v \\<and> trm_rep v S \\<noteq> v}", "obtain mp where \"mp \\<in> ?Redexes\" \n    and \"\\<And>p'. (p', mp) \\<in> (pos_ord C t) \\<Longrightarrow> p' \\<notin> ?Redexes\""], ["proof (prove)\nusing this:\n  finite\n   {p. \\<exists>v.\n          subterm (t \\<lhd> \\<sigma>) p v \\<and>\n          root_term S v \\<and> trm_rep v S \\<noteq> v}\n  p' \\<in> {p. \\<exists>v.\n                  subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                  root_term S v \\<and> trm_rep v S \\<noteq> v}\n\ngoal (1 subgoal):\n 1. (\\<And>mp.\n        \\<lbrakk>mp \\<in> {p. \\<exists>v.\n                                 subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                                 root_term S v \\<and>\n                                 trm_rep v S \\<noteq> v};\n         \\<And>p'.\n            (p', mp) \\<in> pos_ord C t \\<Longrightarrow>\n            p' \\<notin> {p. \\<exists>v.\n                               subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                               root_term S v \\<and>\n                               trm_rep v S \\<noteq> v}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using pos_ord_acyclic [of C t] finite_proj_wf [of ?Redexes p' \"pos_ord C t\"]"], ["proof (prove)\nusing this:\n  finite\n   {p. \\<exists>v.\n          subterm (t \\<lhd> \\<sigma>) p v \\<and>\n          root_term S v \\<and> trm_rep v S \\<noteq> v}\n  p' \\<in> {p. \\<exists>v.\n                  subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                  root_term S v \\<and> trm_rep v S \\<noteq> v}\n  acyclic (pos_ord C t)\n  \\<lbrakk>finite\n            {p. \\<exists>v.\n                   subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                   root_term S v \\<and> trm_rep v S \\<noteq> v};\n   p' \\<in> {p. \\<exists>v.\n                   subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                   root_term S v \\<and> trm_rep v S \\<noteq> v};\n   acyclic (pos_ord C t)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>y.\n                       y \\<in> {p. \\<exists>v.\nsubterm (t \\<lhd> \\<sigma>) p v \\<and>\nroot_term S v \\<and> trm_rep v S \\<noteq> v} \\<and>\n                       (\\<forall>z.\n                           (z, y) \\<in> pos_ord C t \\<longrightarrow>\n                           z \\<notin> {p.\n \\<exists>v.\n    subterm (t \\<lhd> \\<sigma>) p v \\<and>\n    root_term S v \\<and> trm_rep v S \\<noteq> v})\n\ngoal (1 subgoal):\n 1. (\\<And>mp.\n        \\<lbrakk>mp \\<in> {p. \\<exists>v.\n                                 subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                                 root_term S v \\<and>\n                                 trm_rep v S \\<noteq> v};\n         \\<And>p'.\n            (p', mp) \\<in> pos_ord C t \\<Longrightarrow>\n            p' \\<notin> {p. \\<exists>v.\n                               subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                               root_term S v \\<and>\n                               trm_rep v S \\<noteq> v}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  mp \\<in> {p. \\<exists>v.\n                  subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                  root_term S v \\<and> trm_rep v S \\<noteq> v}\n  (?p', mp) \\<in> pos_ord C t \\<Longrightarrow>\n  ?p'\n  \\<notin> {p. \\<exists>v.\n                  subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                  root_term S v \\<and> trm_rep v S \\<noteq> v}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "have mr: \"minimal_redex mp (subst t \\<sigma>) C S t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minimal_redex mp (t \\<lhd> \\<sigma>) C S t", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> minimal_redex mp (t \\<lhd> \\<sigma>) C S t \\<Longrightarrow>\n    False", "assume \"\\<not>minimal_redex mp (subst t \\<sigma>) C S t\""], ["proof (state)\nthis:\n  \\<not> minimal_redex mp (t \\<lhd> \\<sigma>) C S t\n\ngoal (1 subgoal):\n 1. \\<not> minimal_redex mp (t \\<lhd> \\<sigma>) C S t \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<not> minimal_redex mp (t \\<lhd> \\<sigma>) C S t", "obtain p'' v' where \"(p'',mp) \\<in> (pos_ord C t)\" \"subterm (subst t \\<sigma>) p'' v'\" \n      and \"trm_rep v' S \\<noteq> v'\""], ["proof (prove)\nusing this:\n  \\<not> minimal_redex mp (t \\<lhd> \\<sigma>) C S t\n\ngoal (1 subgoal):\n 1. (\\<And>p'' v'.\n        \\<lbrakk>(p'', mp) \\<in> pos_ord C t;\n         subterm (t \\<lhd> \\<sigma>) p'' v';\n         trm_rep v' S \\<noteq> v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding minimal_redex_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>q s.\n             (q, mp) \\<in> pos_ord C t \\<longrightarrow>\n             subterm (t \\<lhd> \\<sigma>) q s \\<longrightarrow>\n             trm_rep s S = s)\n\ngoal (1 subgoal):\n 1. (\\<And>p'' v'.\n        \\<lbrakk>(p'', mp) \\<in> pos_ord C t;\n         subterm (t \\<lhd> \\<sigma>) p'' v';\n         trm_rep v' S \\<noteq> v'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (p'', mp) \\<in> pos_ord C t\n  subterm (t \\<lhd> \\<sigma>) p'' v'\n  trm_rep v' S \\<noteq> v'\n\ngoal (1 subgoal):\n 1. \\<not> minimal_redex mp (t \\<lhd> \\<sigma>) C S t \\<Longrightarrow>\n    False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "assume \"(root_term S v')\""], ["proof (state)\nthis:\n  root_term S v'\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "from this and \\<open>subterm (subst t \\<sigma>) p'' v'\\<close> \\<open>trm_rep v' S \\<noteq> v'\\<close>"], ["proof (chain)\npicking this:\n  root_term S v'\n  subterm (t \\<lhd> \\<sigma>) p'' v'\n  trm_rep v' S \\<noteq> v'", "have \"p'' \\<in>?Redexes\""], ["proof (prove)\nusing this:\n  root_term S v'\n  subterm (t \\<lhd> \\<sigma>) p'' v'\n  trm_rep v' S \\<noteq> v'\n\ngoal (1 subgoal):\n 1. p''\n    \\<in> {p. \\<exists>v.\n                 subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                 root_term S v \\<and> trm_rep v S \\<noteq> v}", "by blast"], ["proof (state)\nthis:\n  p''\n  \\<in> {p. \\<exists>v.\n               subterm (t \\<lhd> \\<sigma>) p v \\<and>\n               root_term S v \\<and> trm_rep v S \\<noteq> v}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "from this and \\<open>\\<And>p'. (p', mp) \\<in> (pos_ord C t) \\<Longrightarrow> p' \\<notin> ?Redexes\\<close> and \\<open>(p'',mp) \\<in> (pos_ord C t)\\<close>"], ["proof (chain)\npicking this:\n  p''\n  \\<in> {p. \\<exists>v.\n               subterm (t \\<lhd> \\<sigma>) p v \\<and>\n               root_term S v \\<and> trm_rep v S \\<noteq> v}\n  (?p', mp) \\<in> pos_ord C t \\<Longrightarrow>\n  ?p'\n  \\<notin> {p. \\<exists>v.\n                  subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                  root_term S v \\<and> trm_rep v S \\<noteq> v}\n  (p'', mp) \\<in> pos_ord C t", "show False"], ["proof (prove)\nusing this:\n  p''\n  \\<in> {p. \\<exists>v.\n               subterm (t \\<lhd> \\<sigma>) p v \\<and>\n               root_term S v \\<and> trm_rep v S \\<noteq> v}\n  (?p', mp) \\<in> pos_ord C t \\<Longrightarrow>\n  ?p'\n  \\<notin> {p. \\<exists>v.\n                  subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                  root_term S v \\<and> trm_rep v S \\<noteq> v}\n  (p'', mp) \\<in> pos_ord C t\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> root_term S v' \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> root_term S v' \\<Longrightarrow> False", "assume \"\\<not>(root_term S v')\""], ["proof (state)\nthis:\n  \\<not> root_term S v'\n\ngoal (1 subgoal):\n 1. \\<not> root_term S v' \\<Longrightarrow> False", "from \\<open>trm_rep v' S \\<noteq> v'\\<close>"], ["proof (chain)\npicking this:\n  trm_rep v' S \\<noteq> v'", "have \"st_red S v'\""], ["proof (prove)\nusing this:\n  trm_rep v' S \\<noteq> v'\n\ngoal (1 subgoal):\n 1. st_red S v'", "using subterms_of_irred_trms_are_irred"], ["proof (prove)\nusing this:\n  trm_rep v' S \\<noteq> v'\n  trm_rep ?t ?S \\<noteq> ?t \\<longrightarrow> st_red ?S ?t\n\ngoal (1 subgoal):\n 1. st_red S v'", "by blast"], ["proof (state)\nthis:\n  st_red S v'\n\ngoal (1 subgoal):\n 1. \\<not> root_term S v' \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  st_red S v'", "obtain p''' v'' where \"subterm v' p''' v''\" \"root_term S v''\" \"trm_rep v'' S \\<noteq> v''\""], ["proof (prove)\nusing this:\n  st_red S v'\n\ngoal (1 subgoal):\n 1. (\\<And>p''' v''.\n        \\<lbrakk>subterm v' p''' v''; root_term S v'';\n         trm_rep v'' S \\<noteq> v''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding st_red_def"], ["proof (prove)\nusing this:\n  \\<exists>t' p.\n     subterm v' p t' \\<and> root_term S t' \\<and> trm_rep t' S \\<noteq> t'\n\ngoal (1 subgoal):\n 1. (\\<And>p''' v''.\n        \\<lbrakk>subterm v' p''' v''; root_term S v'';\n         trm_rep v'' S \\<noteq> v''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  subterm v' p''' v''\n  root_term S v''\n  trm_rep v'' S \\<noteq> v''\n\ngoal (1 subgoal):\n 1. \\<not> root_term S v' \\<Longrightarrow> False", "from \\<open>subterm v' p''' v''\\<close> and \\<open>subterm (subst t \\<sigma>) p'' v'\\<close>"], ["proof (chain)\npicking this:\n  subterm v' p''' v''\n  subterm (t \\<lhd> \\<sigma>) p'' v'", "have \"subterm (subst t \\<sigma>) (append p'' p''') v''\""], ["proof (prove)\nusing this:\n  subterm v' p''' v''\n  subterm (t \\<lhd> \\<sigma>) p'' v'\n\ngoal (1 subgoal):\n 1. subterm (t \\<lhd> \\<sigma>) (p'' @ p''') v''", "using subterm_of_a_subterm_is_a_subterm"], ["proof (prove)\nusing this:\n  subterm v' p''' v''\n  subterm (t \\<lhd> \\<sigma>) p'' v'\n  \\<lbrakk>subterm ?u ?q ?v; subterm ?t ?p ?u\\<rbrakk>\n  \\<Longrightarrow> subterm ?t (?p @ ?q) ?v\n\ngoal (1 subgoal):\n 1. subterm (t \\<lhd> \\<sigma>) (p'' @ p''') v''", "by metis"], ["proof (state)\nthis:\n  subterm (t \\<lhd> \\<sigma>) (p'' @ p''') v''\n\ngoal (1 subgoal):\n 1. \\<not> root_term S v' \\<Longrightarrow> False", "from this and \\<open>trm_rep v'' S \\<noteq> v''\\<close> \\<open>root_term S v''\\<close>"], ["proof (chain)\npicking this:\n  subterm (t \\<lhd> \\<sigma>) (p'' @ p''') v''\n  trm_rep v'' S \\<noteq> v''\n  root_term S v''", "have \"(append p'' p''') \\<in> ?Redexes\""], ["proof (prove)\nusing this:\n  subterm (t \\<lhd> \\<sigma>) (p'' @ p''') v''\n  trm_rep v'' S \\<noteq> v''\n  root_term S v''\n\ngoal (1 subgoal):\n 1. p'' @ p'''\n    \\<in> {p. \\<exists>v.\n                 subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                 root_term S v \\<and> trm_rep v S \\<noteq> v}", "by blast"], ["proof (state)\nthis:\n  p'' @ p'''\n  \\<in> {p. \\<exists>v.\n               subterm (t \\<lhd> \\<sigma>) p v \\<and>\n               root_term S v \\<and> trm_rep v S \\<noteq> v}\n\ngoal (1 subgoal):\n 1. \\<not> root_term S v' \\<Longrightarrow> False", "from this and \\<open>\\<And>p'. (p', mp) \\<in> (pos_ord C t) \\<Longrightarrow> p' \\<notin> ?Redexes\\<close>"], ["proof (chain)\npicking this:\n  p'' @ p'''\n  \\<in> {p. \\<exists>v.\n               subterm (t \\<lhd> \\<sigma>) p v \\<and>\n               root_term S v \\<and> trm_rep v S \\<noteq> v}\n  (?p', mp) \\<in> pos_ord C t \\<Longrightarrow>\n  ?p'\n  \\<notin> {p. \\<exists>v.\n                  subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                  root_term S v \\<and> trm_rep v S \\<noteq> v}", "have \"(append p'' p''',mp) \\<notin> (pos_ord C t)\""], ["proof (prove)\nusing this:\n  p'' @ p'''\n  \\<in> {p. \\<exists>v.\n               subterm (t \\<lhd> \\<sigma>) p v \\<and>\n               root_term S v \\<and> trm_rep v S \\<noteq> v}\n  (?p', mp) \\<in> pos_ord C t \\<Longrightarrow>\n  ?p'\n  \\<notin> {p. \\<exists>v.\n                  subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                  root_term S v \\<and> trm_rep v S \\<noteq> v}\n\ngoal (1 subgoal):\n 1. (p'' @ p''', mp) \\<notin> pos_ord C t", "by blast"], ["proof (state)\nthis:\n  (p'' @ p''', mp) \\<notin> pos_ord C t\n\ngoal (1 subgoal):\n 1. \\<not> root_term S v' \\<Longrightarrow> False", "from this and \\<open>(p'',mp) \\<in> (pos_ord C t)\\<close>"], ["proof (chain)\npicking this:\n  (p'' @ p''', mp) \\<notin> pos_ord C t\n  (p'', mp) \\<in> pos_ord C t", "show False"], ["proof (prove)\nusing this:\n  (p'' @ p''', mp) \\<notin> pos_ord C t\n  (p'', mp) \\<in> pos_ord C t\n\ngoal (1 subgoal):\n 1. False", "using pos_ord_prefix"], ["proof (prove)\nusing this:\n  (p'' @ p''', mp) \\<notin> pos_ord C t\n  (p'', mp) \\<in> pos_ord C t\n  \\<forall>x y p q r.\n     (q, p) \\<in> pos_ord x y \\<longrightarrow> (q @ r, p) \\<in> pos_ord x y\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  minimal_redex mp (t \\<lhd> \\<sigma>) C S t\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>mp \\<in> ?Redexes\\<close>"], ["proof (chain)\npicking this:\n  mp \\<in> {p. \\<exists>v.\n                  subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                  root_term S v \\<and> trm_rep v S \\<noteq> v}", "obtain p v where \"mp=p\" \"subterm (subst t \\<sigma>) p v\" and \"root_term S v\"\n    and \"trm_rep v S \\<noteq> v\""], ["proof (prove)\nusing this:\n  mp \\<in> {p. \\<exists>v.\n                  subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                  root_term S v \\<and> trm_rep v S \\<noteq> v}\n\ngoal (1 subgoal):\n 1. (\\<And>p v.\n        \\<lbrakk>mp = p; subterm (t \\<lhd> \\<sigma>) p v; root_term S v;\n         trm_rep v S \\<noteq> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding st_red_def"], ["proof (prove)\nusing this:\n  mp \\<in> {p. \\<exists>v.\n                  subterm (t \\<lhd> \\<sigma>) p v \\<and>\n                  root_term S v \\<and> trm_rep v S \\<noteq> v}\n\ngoal (1 subgoal):\n 1. (\\<And>p v.\n        \\<lbrakk>mp = p; subterm (t \\<lhd> \\<sigma>) p v; root_term S v;\n         trm_rep v S \\<noteq> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  mp = p\n  subterm (t \\<lhd> \\<sigma>) p v\n  root_term S v\n  trm_rep v S \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "text \\<open>Second, we find the clause @{term \"C2\"} and substitution @{term \"\\<eta>\"} that are used to \ndetermine the value of @{term \"v\"} according to the definition of @{term \"trm_rep\"},\n and we prove that they satisfy all the desired properties. \nIn particular, clause @{term \"C2\"}  is renamed to ensure that it shares no variable\nwith @{term \"C\"}.\\<close>"], ["proof (state)\nthis:\n  mp = p\n  subterm (t \\<lhd> \\<sigma>) p v\n  root_term S v\n  trm_rep v S \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>subterm (subst t \\<sigma>) p v\\<close>"], ["proof (chain)\npicking this:\n  subterm (t \\<lhd> \\<sigma>) p v", "have \n    si: \"(\\<exists>x q1 q2. (is_a_variable x) \\<and> (subterm (subst x \\<sigma>) q1 v) \\<and> \n                      (subterm t q2 x) \\<and> (p = (append q2 q1))) \\<or> \n        ((\\<exists> u. (\\<not>(is_a_variable u) \\<and> (subterm t p u) \\<and> (v = (subst u \\<sigma>)))))\""], ["proof (prove)\nusing this:\n  subterm (t \\<lhd> \\<sigma>) p v\n\ngoal (1 subgoal):\n 1. (\\<exists>x q1 q2.\n        is_a_variable x \\<and>\n        subterm (x \\<lhd> \\<sigma>) q1 v \\<and>\n        subterm t q2 x \\<and> p = q2 @ q1) \\<or>\n    (\\<exists>u.\n        \\<not> is_a_variable u \\<and>\n        subterm t p u \\<and> v = u \\<lhd> \\<sigma>)", "using subterms_of_instances"], ["proof (prove)\nusing this:\n  subterm (t \\<lhd> \\<sigma>) p v\n  \\<forall>u v u' s.\n     u = v \\<lhd> s \\<longrightarrow>\n     subterm u ?p u' \\<longrightarrow>\n     (\\<exists>x q1 q2.\n         is_a_variable x \\<and>\n         subterm (x \\<lhd> s) q1 u' \\<and>\n         subterm v q2 x \\<and> ?p = q2 @ q1) \\<or>\n     (\\<exists>v'.\n         \\<not> is_a_variable v' \\<and>\n         subterm v ?p v' \\<and> u' = v' \\<lhd> s)\n\ngoal (1 subgoal):\n 1. (\\<exists>x q1 q2.\n        is_a_variable x \\<and>\n        subterm (x \\<lhd> \\<sigma>) q1 v \\<and>\n        subterm t q2 x \\<and> p = q2 @ q1) \\<or>\n    (\\<exists>u.\n        \\<not> is_a_variable u \\<and>\n        subterm t p u \\<and> v = u \\<lhd> \\<sigma>)", "by metis"], ["proof (state)\nthis:\n  (\\<exists>x q1 q2.\n      is_a_variable x \\<and>\n      subterm (x \\<lhd> \\<sigma>) q1 v \\<and>\n      subterm t q2 x \\<and> p = q2 @ q1) \\<or>\n  (\\<exists>u.\n      \\<not> is_a_variable u \\<and>\n      subterm t p u \\<and> v = u \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "let ?v = \"trm_rep v S\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>trm_rep v S \\<noteq> v\\<close> and \\<open>root_term S v\\<close>"], ["proof (chain)\npicking this:\n  trm_rep v S \\<noteq> v\n  root_term S v", "have \"?v \\<in> min_trms (set_of_candidate_values S v)\""], ["proof (prove)\nusing this:\n  trm_rep v S \\<noteq> v\n  root_term S v\n\ngoal (1 subgoal):\n 1. trm_rep v S \\<in> min_trms (set_of_candidate_values S v)", "unfolding root_term_def get_min_def"], ["proof (prove)\nusing this:\n  trm_rep v S \\<noteq> v\n  trm_rep v S =\n  (if min_trms (set_of_candidate_values S v) = {} then v\n   else SOME x. x \\<in> min_trms (set_of_candidate_values S v))\n\ngoal (1 subgoal):\n 1. trm_rep v S \\<in> min_trms (set_of_candidate_values S v)", "by (metis some_in_eq)"], ["proof (state)\nthis:\n  trm_rep v S \\<in> min_trms (set_of_candidate_values S v)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>?v \\<in> min_trms (set_of_candidate_values S v)\\<close>"], ["proof (chain)\npicking this:\n  trm_rep v S \\<in> min_trms (set_of_candidate_values S v)", "obtain pair where \"?v = fst pair\" \n    and \"pair \\<in> (set_of_candidate_values S v)\" and \n    min_pair: \"(\\<forall>pair'\\<in>set_of_candidate_values S v. (snd pair', snd pair) \\<notin> trm_ord)\""], ["proof (prove)\nusing this:\n  trm_rep v S \\<in> min_trms (set_of_candidate_values S v)\n\ngoal (1 subgoal):\n 1. (\\<And>pair.\n        \\<lbrakk>trm_rep v S = fst pair;\n         pair \\<in> set_of_candidate_values S v;\n         \\<forall>pair'\\<in>set_of_candidate_values S v.\n            (snd pair', snd pair) \\<notin> trm_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding min_trms_def"], ["proof (prove)\nusing this:\n  trm_rep v S\n  \\<in> {x. \\<exists>pair.\n               (pair \\<in> set_of_candidate_values S v \\<and>\n                (\\<forall>pair'\\<in>set_of_candidate_values S v.\n                    (snd pair', snd pair) \\<notin> trm_ord)) \\<and>\n               x = fst pair}\n\ngoal (1 subgoal):\n 1. (\\<And>pair.\n        \\<lbrakk>trm_rep v S = fst pair;\n         pair \\<in> set_of_candidate_values S v;\n         \\<forall>pair'\\<in>set_of_candidate_values S v.\n            (snd pair', snd pair) \\<notin> trm_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  trm_rep v S = fst pair\n  pair \\<in> set_of_candidate_values S v\n  \\<forall>pair'\\<in>set_of_candidate_values S v.\n     (snd pair', snd pair) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>pair \\<in> (set_of_candidate_values S v)\\<close>"], ["proof (chain)\npicking this:\n  pair \\<in> set_of_candidate_values S v", "have \n  \"\\<exists>z CC C' C s L L' \\<sigma> t' s'. pair = (z, s) \\<and> (candidate_values z CC C' C s L L' \\<sigma> t' s' v S)\""], ["proof (prove)\nusing this:\n  pair \\<in> set_of_candidate_values S v\n\ngoal (1 subgoal):\n 1. \\<exists>z CC C' C s L L' \\<sigma> t' s'.\n       pair = (z, s) \\<and>\n       candidate_values z CC C' C s L L' \\<sigma> t' s' v S", "unfolding set_of_candidate_values_def [of S v]"], ["proof (prove)\nusing this:\n  pair\n  \\<in> {pair.\n         \\<exists>z CC C' C s L L' \\<sigma> t' s'.\n            pair = (z, s) \\<and>\n            candidate_values z CC C' C s L L' \\<sigma> t' s' v S}\n\ngoal (1 subgoal):\n 1. \\<exists>z CC C' C s L L' \\<sigma> t' s'.\n       pair = (z, s) \\<and>\n       candidate_values z CC C' C s L L' \\<sigma> t' s' v S", "by blast"], ["proof (state)\nthis:\n  \\<exists>z CC C' C s L L' \\<sigma> t' s'.\n     pair = (z, s) \\<and>\n     candidate_values z CC C' C s L L' \\<sigma> t' s' v S\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from this"], ["proof (chain)\npicking this:\n  \\<exists>z CC C' C s L L' \\<sigma> t' s'.\n     pair = (z, s) \\<and>\n     candidate_values z CC C' C s L L' \\<sigma> t' s' v S", "obtain zz C2_init Cl_C2_init gr_Cl_C2 gr_rhs gr_L2 L2_init \\<eta>_init lhs_init rhs_init  \n    where \"pair = (zz,  gr_rhs)\" \n    and \"(candidate_values zz C2_init Cl_C2_init gr_Cl_C2 gr_rhs gr_L2 L2_init\n          \\<eta>_init lhs_init rhs_init v S)\""], ["proof (prove)\nusing this:\n  \\<exists>z CC C' C s L L' \\<sigma> t' s'.\n     pair = (z, s) \\<and>\n     candidate_values z CC C' C s L L' \\<sigma> t' s' v S\n\ngoal (1 subgoal):\n 1. (\\<And>zz gr_rhs C2_init Cl_C2_init gr_Cl_C2 gr_L2 L2_init \\<eta>_init\n        lhs_init rhs_init.\n        \\<lbrakk>pair = (zz, gr_rhs);\n         candidate_values zz C2_init Cl_C2_init gr_Cl_C2 gr_rhs gr_L2\n          L2_init \\<eta>_init lhs_init rhs_init v S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  pair = (zz, gr_rhs)\n  candidate_values zz C2_init Cl_C2_init gr_Cl_C2 gr_rhs gr_L2 L2_init\n   \\<eta>_init lhs_init rhs_init v S\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from assms(7) and \\<open>C \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  C \\<in> S", "have \"finite (cl_ecl C)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. finite (cl_ecl C)", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>(candidate_values zz C2_init Cl_C2_init gr_Cl_C2 gr_rhs gr_L2 L2_init \n            \\<eta>_init lhs_init rhs_init v S)\\<close>"], ["proof (chain)\npicking this:\n  candidate_values zz C2_init Cl_C2_init gr_Cl_C2 gr_rhs gr_L2 L2_init\n   \\<eta>_init lhs_init rhs_init v S", "have \"finite Cl_C2_init\""], ["proof (prove)\nusing this:\n  candidate_values zz C2_init Cl_C2_init gr_Cl_C2 gr_rhs gr_L2 L2_init\n   \\<eta>_init lhs_init rhs_init v S\n\ngoal (1 subgoal):\n 1. finite Cl_C2_init", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  C2_init \\<in> S \\<and>\n  v \\<notin> subst_set (trms_ecl C2_init) \\<eta>_init \\<and>\n  trms_irreducible C2_init \\<eta>_init S v \\<and>\n  Cl_C2_init = cl_ecl C2_init \\<and>\n  (gr_rhs, v) \\<in> trm_ord \\<and>\n  ((gr_rhs, v) \\<in> trm_ord \\<longrightarrow> zz = trm_rep gr_rhs S) \\<and>\n  orient_lit_inst L2_init lhs_init rhs_init pos \\<eta>_init \\<and>\n  sel Cl_C2_init = {} \\<and>\n  L2_init \\<in> Cl_C2_init \\<and>\n  maximal_literal gr_L2 gr_Cl_C2 \\<and>\n  gr_L2 = subst_lit L2_init \\<eta>_init \\<and>\n  gr_Cl_C2 = subst_cl Cl_C2_init \\<eta>_init \\<and>\n  ground_clause gr_Cl_C2 \\<and>\n  v = lhs_init \\<lhd> \\<eta>_init \\<and>\n  gr_rhs = rhs_init \\<lhd> \\<eta>_init \\<and>\n  finite Cl_C2_init \\<and>\n  smaller_lits_are_false v gr_Cl_C2 S \\<and>\n  maximal_literal_is_unique v gr_rhs Cl_C2_init L2_init S \\<eta>_init\n\ngoal (1 subgoal):\n 1. finite Cl_C2_init", "by metis"], ["proof (state)\nthis:\n  finite Cl_C2_init\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from assms(11) \\<open>closed_under_renaming S\\<close> \\<open>finite Cl_C2_init\\<close> \\<open>finite (cl_ecl C)\\<close>\n    \\<open>(candidate_values zz C2_init Cl_C2_init gr_Cl_C2 gr_rhs gr_L2 L2_init \n        \\<eta>_init lhs_init rhs_init v S)\\<close>"], ["proof (chain)\npicking this:\n  Ball S well_constrained\n  closed_under_renaming S\n  finite Cl_C2_init\n  finite (cl_ecl C)\n  candidate_values zz C2_init Cl_C2_init gr_Cl_C2 gr_rhs gr_L2 L2_init\n   \\<eta>_init lhs_init rhs_init v S", "obtain C2 Cl_C2 \\<eta> L2 lhs rhs where\n    \"(candidate_values zz C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta> lhs rhs v S)\"\n    and \"(vars_of_cl (cl_ecl C) \\<inter> vars_of_cl (cl_ecl C2)) = {}\""], ["proof (prove)\nusing this:\n  Ball S well_constrained\n  closed_under_renaming S\n  finite Cl_C2_init\n  finite (cl_ecl C)\n  candidate_values zz C2_init Cl_C2_init gr_Cl_C2 gr_rhs gr_L2 L2_init\n   \\<eta>_init lhs_init rhs_init v S\n\ngoal (1 subgoal):\n 1. (\\<And>C2 Cl_C2 L2 \\<eta> lhs rhs.\n        \\<lbrakk>candidate_values zz C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2\n                  \\<eta> lhs rhs v S;\n         vars_of_cl (cl_ecl C) \\<inter> vars_of_cl (cl_ecl C2) = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using candidate_values_renaming [of zz C2_init Cl_C2_init gr_Cl_C2 gr_rhs gr_L2 L2_init\n        \\<eta>_init lhs_init rhs_init v S C]"], ["proof (prove)\nusing this:\n  Ball S well_constrained\n  closed_under_renaming S\n  finite Cl_C2_init\n  finite (cl_ecl C)\n  candidate_values zz C2_init Cl_C2_init gr_Cl_C2 gr_rhs gr_L2 L2_init\n   \\<eta>_init lhs_init rhs_init v S\n  \\<lbrakk>candidate_values zz C2_init Cl_C2_init gr_Cl_C2 gr_rhs gr_L2\n            L2_init \\<eta>_init lhs_init rhs_init v S;\n   finite Cl_C2_init; finite (cl_ecl C); closed_under_renaming S;\n   Ball S well_constrained\\<rbrakk>\n  \\<Longrightarrow> \\<exists>CC_bis C'_bis L'_bis \\<sigma>_bis t'_bis s'_bis\n                       t_bis.\n                       candidate_values zz CC_bis C'_bis gr_Cl_C2 gr_rhs\n                        gr_L2 L'_bis \\<sigma>_bis t'_bis s'_bis v S \\<and>\n                       vars_of_cl (cl_ecl C) \\<inter>\n                       vars_of_cl (cl_ecl CC_bis) =\n                       {}\n\ngoal (1 subgoal):\n 1. (\\<And>C2 Cl_C2 L2 \\<eta> lhs rhs.\n        \\<lbrakk>candidate_values zz C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2\n                  \\<eta> lhs rhs v S;\n         vars_of_cl (cl_ecl C) \\<inter> vars_of_cl (cl_ecl C2) = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  candidate_values zz C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta> lhs rhs v S\n  vars_of_cl (cl_ecl C) \\<inter> vars_of_cl (cl_ecl C2) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>(candidate_values zz C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta> lhs rhs v S)\\<close>\n    and \\<open>pair = (zz,  gr_rhs)\\<close> and \\<open>?v = fst pair\\<close>"], ["proof (chain)\npicking this:\n  candidate_values zz C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta> lhs rhs v S\n  pair = (zz, gr_rhs)\n  trm_rep v S = fst pair", "have cv: \"(candidate_values ?v C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta> lhs rhs v S)\""], ["proof (prove)\nusing this:\n  candidate_values zz C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta> lhs rhs v S\n  pair = (zz, gr_rhs)\n  trm_rep v S = fst pair\n\ngoal (1 subgoal):\n 1. candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n     lhs rhs v S", "by (metis fst_conv)"], ["proof (state)\nthis:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from cv"], ["proof (chain)\npicking this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S", "have \"C2 \\<in> S\""], ["proof (prove)\nusing this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S\n\ngoal (1 subgoal):\n 1. C2 \\<in> S", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  C2 \\<in> S \\<and>\n  v \\<notin> subst_set (trms_ecl C2) \\<eta> \\<and>\n  trms_irreducible C2 \\<eta> S v \\<and>\n  Cl_C2 = cl_ecl C2 \\<and>\n  (gr_rhs, v) \\<in> trm_ord \\<and>\n  ((gr_rhs, v) \\<in> trm_ord \\<longrightarrow>\n   trm_rep v S = trm_rep gr_rhs S) \\<and>\n  orient_lit_inst L2 lhs rhs pos \\<eta> \\<and>\n  sel Cl_C2 = {} \\<and>\n  L2 \\<in> Cl_C2 \\<and>\n  maximal_literal gr_L2 gr_Cl_C2 \\<and>\n  gr_L2 = subst_lit L2 \\<eta> \\<and>\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta> \\<and>\n  ground_clause gr_Cl_C2 \\<and>\n  v = lhs \\<lhd> \\<eta> \\<and>\n  gr_rhs = rhs \\<lhd> \\<eta> \\<and>\n  finite Cl_C2 \\<and>\n  smaller_lits_are_false v gr_Cl_C2 S \\<and>\n  maximal_literal_is_unique v gr_rhs Cl_C2 L2 S \\<eta>\n\ngoal (1 subgoal):\n 1. C2 \\<in> S", "by metis"], ["proof (state)\nthis:\n  C2 \\<in> S\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from cv"], ["proof (chain)\npicking this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S", "have \"ground_clause gr_Cl_C2\""], ["proof (prove)\nusing this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S\n\ngoal (1 subgoal):\n 1. ground_clause gr_Cl_C2", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  C2 \\<in> S \\<and>\n  v \\<notin> subst_set (trms_ecl C2) \\<eta> \\<and>\n  trms_irreducible C2 \\<eta> S v \\<and>\n  Cl_C2 = cl_ecl C2 \\<and>\n  (gr_rhs, v) \\<in> trm_ord \\<and>\n  ((gr_rhs, v) \\<in> trm_ord \\<longrightarrow>\n   trm_rep v S = trm_rep gr_rhs S) \\<and>\n  orient_lit_inst L2 lhs rhs pos \\<eta> \\<and>\n  sel Cl_C2 = {} \\<and>\n  L2 \\<in> Cl_C2 \\<and>\n  maximal_literal gr_L2 gr_Cl_C2 \\<and>\n  gr_L2 = subst_lit L2 \\<eta> \\<and>\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta> \\<and>\n  ground_clause gr_Cl_C2 \\<and>\n  v = lhs \\<lhd> \\<eta> \\<and>\n  gr_rhs = rhs \\<lhd> \\<eta> \\<and>\n  finite Cl_C2 \\<and>\n  smaller_lits_are_false v gr_Cl_C2 S \\<and>\n  maximal_literal_is_unique v gr_rhs Cl_C2 L2 S \\<eta>\n\ngoal (1 subgoal):\n 1. ground_clause gr_Cl_C2", "by metis"], ["proof (state)\nthis:\n  ground_clause gr_Cl_C2\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from assms(7) and assms(10)"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  C \\<in> S", "have \"finite (vars_of_cl (cl_ecl C))\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. finite (vars_of_cl (cl_ecl C))", "using set_of_variables_is_finite_cl"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  C \\<in> S\n  finite ?C \\<Longrightarrow> finite (vars_of_cl ?C)\n\ngoal (1 subgoal):\n 1. finite (vars_of_cl (cl_ecl C))", "by blast"], ["proof (state)\nthis:\n  finite (vars_of_cl (cl_ecl C))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from cv"], ["proof (chain)\npicking this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S", "have \"smaller_lits_are_false v gr_Cl_C2 S\""], ["proof (prove)\nusing this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S\n\ngoal (1 subgoal):\n 1. smaller_lits_are_false v gr_Cl_C2 S", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  C2 \\<in> S \\<and>\n  v \\<notin> subst_set (trms_ecl C2) \\<eta> \\<and>\n  trms_irreducible C2 \\<eta> S v \\<and>\n  Cl_C2 = cl_ecl C2 \\<and>\n  (gr_rhs, v) \\<in> trm_ord \\<and>\n  ((gr_rhs, v) \\<in> trm_ord \\<longrightarrow>\n   trm_rep v S = trm_rep gr_rhs S) \\<and>\n  orient_lit_inst L2 lhs rhs pos \\<eta> \\<and>\n  sel Cl_C2 = {} \\<and>\n  L2 \\<in> Cl_C2 \\<and>\n  maximal_literal gr_L2 gr_Cl_C2 \\<and>\n  gr_L2 = subst_lit L2 \\<eta> \\<and>\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta> \\<and>\n  ground_clause gr_Cl_C2 \\<and>\n  v = lhs \\<lhd> \\<eta> \\<and>\n  gr_rhs = rhs \\<lhd> \\<eta> \\<and>\n  finite Cl_C2 \\<and>\n  smaller_lits_are_false v gr_Cl_C2 S \\<and>\n  maximal_literal_is_unique v gr_rhs Cl_C2 L2 S \\<eta>\n\ngoal (1 subgoal):\n 1. smaller_lits_are_false v gr_Cl_C2 S", "by metis"], ["proof (state)\nthis:\n  smaller_lits_are_false v gr_Cl_C2 S\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from cv"], ["proof (chain)\npicking this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S", "have \"gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\""], ["proof (prove)\nusing this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S\n\ngoal (1 subgoal):\n 1. gr_Cl_C2 = subst_cl Cl_C2 \\<eta>", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  C2 \\<in> S \\<and>\n  v \\<notin> subst_set (trms_ecl C2) \\<eta> \\<and>\n  trms_irreducible C2 \\<eta> S v \\<and>\n  Cl_C2 = cl_ecl C2 \\<and>\n  (gr_rhs, v) \\<in> trm_ord \\<and>\n  ((gr_rhs, v) \\<in> trm_ord \\<longrightarrow>\n   trm_rep v S = trm_rep gr_rhs S) \\<and>\n  orient_lit_inst L2 lhs rhs pos \\<eta> \\<and>\n  sel Cl_C2 = {} \\<and>\n  L2 \\<in> Cl_C2 \\<and>\n  maximal_literal gr_L2 gr_Cl_C2 \\<and>\n  gr_L2 = subst_lit L2 \\<eta> \\<and>\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta> \\<and>\n  ground_clause gr_Cl_C2 \\<and>\n  v = lhs \\<lhd> \\<eta> \\<and>\n  gr_rhs = rhs \\<lhd> \\<eta> \\<and>\n  finite Cl_C2 \\<and>\n  smaller_lits_are_false v gr_Cl_C2 S \\<and>\n  maximal_literal_is_unique v gr_rhs Cl_C2 L2 S \\<eta>\n\ngoal (1 subgoal):\n 1. gr_Cl_C2 = subst_cl Cl_C2 \\<eta>", "by metis"], ["proof (state)\nthis:\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from cv"], ["proof (chain)\npicking this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S", "have \"orient_lit_inst L2 lhs rhs pos \\<eta>\""], ["proof (prove)\nusing this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S\n\ngoal (1 subgoal):\n 1. orient_lit_inst L2 lhs rhs pos \\<eta>", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  C2 \\<in> S \\<and>\n  v \\<notin> subst_set (trms_ecl C2) \\<eta> \\<and>\n  trms_irreducible C2 \\<eta> S v \\<and>\n  Cl_C2 = cl_ecl C2 \\<and>\n  (gr_rhs, v) \\<in> trm_ord \\<and>\n  ((gr_rhs, v) \\<in> trm_ord \\<longrightarrow>\n   trm_rep v S = trm_rep gr_rhs S) \\<and>\n  orient_lit_inst L2 lhs rhs pos \\<eta> \\<and>\n  sel Cl_C2 = {} \\<and>\n  L2 \\<in> Cl_C2 \\<and>\n  maximal_literal gr_L2 gr_Cl_C2 \\<and>\n  gr_L2 = subst_lit L2 \\<eta> \\<and>\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta> \\<and>\n  ground_clause gr_Cl_C2 \\<and>\n  v = lhs \\<lhd> \\<eta> \\<and>\n  gr_rhs = rhs \\<lhd> \\<eta> \\<and>\n  finite Cl_C2 \\<and>\n  smaller_lits_are_false v gr_Cl_C2 S \\<and>\n  maximal_literal_is_unique v gr_rhs Cl_C2 L2 S \\<eta>\n\ngoal (1 subgoal):\n 1. orient_lit_inst L2 lhs rhs pos \\<eta>", "by metis"], ["proof (state)\nthis:\n  orient_lit_inst L2 lhs rhs pos \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from cv"], ["proof (chain)\npicking this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S", "have \"maximal_literal gr_L2 gr_Cl_C2\""], ["proof (prove)\nusing this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S\n\ngoal (1 subgoal):\n 1. maximal_literal gr_L2 gr_Cl_C2", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  C2 \\<in> S \\<and>\n  v \\<notin> subst_set (trms_ecl C2) \\<eta> \\<and>\n  trms_irreducible C2 \\<eta> S v \\<and>\n  Cl_C2 = cl_ecl C2 \\<and>\n  (gr_rhs, v) \\<in> trm_ord \\<and>\n  ((gr_rhs, v) \\<in> trm_ord \\<longrightarrow>\n   trm_rep v S = trm_rep gr_rhs S) \\<and>\n  orient_lit_inst L2 lhs rhs pos \\<eta> \\<and>\n  sel Cl_C2 = {} \\<and>\n  L2 \\<in> Cl_C2 \\<and>\n  maximal_literal gr_L2 gr_Cl_C2 \\<and>\n  gr_L2 = subst_lit L2 \\<eta> \\<and>\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta> \\<and>\n  ground_clause gr_Cl_C2 \\<and>\n  v = lhs \\<lhd> \\<eta> \\<and>\n  gr_rhs = rhs \\<lhd> \\<eta> \\<and>\n  finite Cl_C2 \\<and>\n  smaller_lits_are_false v gr_Cl_C2 S \\<and>\n  maximal_literal_is_unique v gr_rhs Cl_C2 L2 S \\<eta>\n\ngoal (1 subgoal):\n 1. maximal_literal gr_L2 gr_Cl_C2", "by metis"], ["proof (state)\nthis:\n  maximal_literal gr_L2 gr_Cl_C2\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from cv"], ["proof (chain)\npicking this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S", "have \"gr_L2 = subst_lit L2 \\<eta>\""], ["proof (prove)\nusing this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S\n\ngoal (1 subgoal):\n 1. gr_L2 = subst_lit L2 \\<eta>", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  C2 \\<in> S \\<and>\n  v \\<notin> subst_set (trms_ecl C2) \\<eta> \\<and>\n  trms_irreducible C2 \\<eta> S v \\<and>\n  Cl_C2 = cl_ecl C2 \\<and>\n  (gr_rhs, v) \\<in> trm_ord \\<and>\n  ((gr_rhs, v) \\<in> trm_ord \\<longrightarrow>\n   trm_rep v S = trm_rep gr_rhs S) \\<and>\n  orient_lit_inst L2 lhs rhs pos \\<eta> \\<and>\n  sel Cl_C2 = {} \\<and>\n  L2 \\<in> Cl_C2 \\<and>\n  maximal_literal gr_L2 gr_Cl_C2 \\<and>\n  gr_L2 = subst_lit L2 \\<eta> \\<and>\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta> \\<and>\n  ground_clause gr_Cl_C2 \\<and>\n  v = lhs \\<lhd> \\<eta> \\<and>\n  gr_rhs = rhs \\<lhd> \\<eta> \\<and>\n  finite Cl_C2 \\<and>\n  smaller_lits_are_false v gr_Cl_C2 S \\<and>\n  maximal_literal_is_unique v gr_rhs Cl_C2 L2 S \\<eta>\n\ngoal (1 subgoal):\n 1. gr_L2 = subst_lit L2 \\<eta>", "by metis"], ["proof (state)\nthis:\n  gr_L2 = subst_lit L2 \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from cv"], ["proof (chain)\npicking this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S", "have \"ground_clause gr_Cl_C2\""], ["proof (prove)\nusing this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S\n\ngoal (1 subgoal):\n 1. ground_clause gr_Cl_C2", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  C2 \\<in> S \\<and>\n  v \\<notin> subst_set (trms_ecl C2) \\<eta> \\<and>\n  trms_irreducible C2 \\<eta> S v \\<and>\n  Cl_C2 = cl_ecl C2 \\<and>\n  (gr_rhs, v) \\<in> trm_ord \\<and>\n  ((gr_rhs, v) \\<in> trm_ord \\<longrightarrow>\n   trm_rep v S = trm_rep gr_rhs S) \\<and>\n  orient_lit_inst L2 lhs rhs pos \\<eta> \\<and>\n  sel Cl_C2 = {} \\<and>\n  L2 \\<in> Cl_C2 \\<and>\n  maximal_literal gr_L2 gr_Cl_C2 \\<and>\n  gr_L2 = subst_lit L2 \\<eta> \\<and>\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta> \\<and>\n  ground_clause gr_Cl_C2 \\<and>\n  v = lhs \\<lhd> \\<eta> \\<and>\n  gr_rhs = rhs \\<lhd> \\<eta> \\<and>\n  finite Cl_C2 \\<and>\n  smaller_lits_are_false v gr_Cl_C2 S \\<and>\n  maximal_literal_is_unique v gr_rhs Cl_C2 L2 S \\<eta>\n\ngoal (1 subgoal):\n 1. ground_clause gr_Cl_C2", "by metis"], ["proof (state)\nthis:\n  ground_clause gr_Cl_C2\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from cv"], ["proof (chain)\npicking this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S", "have \"L2 \\<in> Cl_C2\""], ["proof (prove)\nusing this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S\n\ngoal (1 subgoal):\n 1. L2 \\<in> Cl_C2", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  C2 \\<in> S \\<and>\n  v \\<notin> subst_set (trms_ecl C2) \\<eta> \\<and>\n  trms_irreducible C2 \\<eta> S v \\<and>\n  Cl_C2 = cl_ecl C2 \\<and>\n  (gr_rhs, v) \\<in> trm_ord \\<and>\n  ((gr_rhs, v) \\<in> trm_ord \\<longrightarrow>\n   trm_rep v S = trm_rep gr_rhs S) \\<and>\n  orient_lit_inst L2 lhs rhs pos \\<eta> \\<and>\n  sel Cl_C2 = {} \\<and>\n  L2 \\<in> Cl_C2 \\<and>\n  maximal_literal gr_L2 gr_Cl_C2 \\<and>\n  gr_L2 = subst_lit L2 \\<eta> \\<and>\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta> \\<and>\n  ground_clause gr_Cl_C2 \\<and>\n  v = lhs \\<lhd> \\<eta> \\<and>\n  gr_rhs = rhs \\<lhd> \\<eta> \\<and>\n  finite Cl_C2 \\<and>\n  smaller_lits_are_false v gr_Cl_C2 S \\<and>\n  maximal_literal_is_unique v gr_rhs Cl_C2 L2 S \\<eta>\n\ngoal (1 subgoal):\n 1. L2 \\<in> Cl_C2", "by metis"], ["proof (state)\nthis:\n  L2 \\<in> Cl_C2\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from this and \\<open>gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\\<close> and \\<open>gr_L2 = subst_lit L2 \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  L2 \\<in> Cl_C2\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\n  gr_L2 = subst_lit L2 \\<eta>", "have \"gr_L2 \\<in> gr_Cl_C2\""], ["proof (prove)\nusing this:\n  L2 \\<in> Cl_C2\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\n  gr_L2 = subst_lit L2 \\<eta>\n\ngoal (1 subgoal):\n 1. gr_L2 \\<in> gr_Cl_C2", "by auto"], ["proof (state)\nthis:\n  gr_L2 \\<in> gr_Cl_C2\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from cv"], ["proof (chain)\npicking this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S", "have \"trm_rep v S = trm_rep gr_rhs S\""], ["proof (prove)\nusing this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S\n\ngoal (1 subgoal):\n 1. trm_rep v S = trm_rep gr_rhs S", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  C2 \\<in> S \\<and>\n  v \\<notin> subst_set (trms_ecl C2) \\<eta> \\<and>\n  trms_irreducible C2 \\<eta> S v \\<and>\n  Cl_C2 = cl_ecl C2 \\<and>\n  (gr_rhs, v) \\<in> trm_ord \\<and>\n  ((gr_rhs, v) \\<in> trm_ord \\<longrightarrow>\n   trm_rep v S = trm_rep gr_rhs S) \\<and>\n  orient_lit_inst L2 lhs rhs pos \\<eta> \\<and>\n  sel Cl_C2 = {} \\<and>\n  L2 \\<in> Cl_C2 \\<and>\n  maximal_literal gr_L2 gr_Cl_C2 \\<and>\n  gr_L2 = subst_lit L2 \\<eta> \\<and>\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta> \\<and>\n  ground_clause gr_Cl_C2 \\<and>\n  v = lhs \\<lhd> \\<eta> \\<and>\n  gr_rhs = rhs \\<lhd> \\<eta> \\<and>\n  finite Cl_C2 \\<and>\n  smaller_lits_are_false v gr_Cl_C2 S \\<and>\n  maximal_literal_is_unique v gr_rhs Cl_C2 L2 S \\<eta>\n\ngoal (1 subgoal):\n 1. trm_rep v S = trm_rep gr_rhs S", "by metis"], ["proof (state)\nthis:\n  trm_rep v S = trm_rep gr_rhs S\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from cv"], ["proof (chain)\npicking this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S", "have \"(gr_rhs, v) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S\n\ngoal (1 subgoal):\n 1. (gr_rhs, v) \\<in> trm_ord", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  C2 \\<in> S \\<and>\n  v \\<notin> subst_set (trms_ecl C2) \\<eta> \\<and>\n  trms_irreducible C2 \\<eta> S v \\<and>\n  Cl_C2 = cl_ecl C2 \\<and>\n  (gr_rhs, v) \\<in> trm_ord \\<and>\n  ((gr_rhs, v) \\<in> trm_ord \\<longrightarrow>\n   trm_rep v S = trm_rep gr_rhs S) \\<and>\n  orient_lit_inst L2 lhs rhs pos \\<eta> \\<and>\n  sel Cl_C2 = {} \\<and>\n  L2 \\<in> Cl_C2 \\<and>\n  maximal_literal gr_L2 gr_Cl_C2 \\<and>\n  gr_L2 = subst_lit L2 \\<eta> \\<and>\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta> \\<and>\n  ground_clause gr_Cl_C2 \\<and>\n  v = lhs \\<lhd> \\<eta> \\<and>\n  gr_rhs = rhs \\<lhd> \\<eta> \\<and>\n  finite Cl_C2 \\<and>\n  smaller_lits_are_false v gr_Cl_C2 S \\<and>\n  maximal_literal_is_unique v gr_rhs Cl_C2 L2 S \\<eta>\n\ngoal (1 subgoal):\n 1. (gr_rhs, v) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (gr_rhs, v) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from cv"], ["proof (chain)\npicking this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S", "have \"Cl_C2 = cl_ecl C2\""], ["proof (prove)\nusing this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S\n\ngoal (1 subgoal):\n 1. Cl_C2 = cl_ecl C2", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  C2 \\<in> S \\<and>\n  v \\<notin> subst_set (trms_ecl C2) \\<eta> \\<and>\n  trms_irreducible C2 \\<eta> S v \\<and>\n  Cl_C2 = cl_ecl C2 \\<and>\n  (gr_rhs, v) \\<in> trm_ord \\<and>\n  ((gr_rhs, v) \\<in> trm_ord \\<longrightarrow>\n   trm_rep v S = trm_rep gr_rhs S) \\<and>\n  orient_lit_inst L2 lhs rhs pos \\<eta> \\<and>\n  sel Cl_C2 = {} \\<and>\n  L2 \\<in> Cl_C2 \\<and>\n  maximal_literal gr_L2 gr_Cl_C2 \\<and>\n  gr_L2 = subst_lit L2 \\<eta> \\<and>\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta> \\<and>\n  ground_clause gr_Cl_C2 \\<and>\n  v = lhs \\<lhd> \\<eta> \\<and>\n  gr_rhs = rhs \\<lhd> \\<eta> \\<and>\n  finite Cl_C2 \\<and>\n  smaller_lits_are_false v gr_Cl_C2 S \\<and>\n  maximal_literal_is_unique v gr_rhs Cl_C2 L2 S \\<eta>\n\ngoal (1 subgoal):\n 1. Cl_C2 = cl_ecl C2", "by metis"], ["proof (state)\nthis:\n  Cl_C2 = cl_ecl C2\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from cv"], ["proof (chain)\npicking this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S", "have \"v \\<notin> subst_set (trms_ecl C2) \\<eta>\""], ["proof (prove)\nusing this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S\n\ngoal (1 subgoal):\n 1. v \\<notin> subst_set (trms_ecl C2) \\<eta>", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  C2 \\<in> S \\<and>\n  v \\<notin> subst_set (trms_ecl C2) \\<eta> \\<and>\n  trms_irreducible C2 \\<eta> S v \\<and>\n  Cl_C2 = cl_ecl C2 \\<and>\n  (gr_rhs, v) \\<in> trm_ord \\<and>\n  ((gr_rhs, v) \\<in> trm_ord \\<longrightarrow>\n   trm_rep v S = trm_rep gr_rhs S) \\<and>\n  orient_lit_inst L2 lhs rhs pos \\<eta> \\<and>\n  sel Cl_C2 = {} \\<and>\n  L2 \\<in> Cl_C2 \\<and>\n  maximal_literal gr_L2 gr_Cl_C2 \\<and>\n  gr_L2 = subst_lit L2 \\<eta> \\<and>\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta> \\<and>\n  ground_clause gr_Cl_C2 \\<and>\n  v = lhs \\<lhd> \\<eta> \\<and>\n  gr_rhs = rhs \\<lhd> \\<eta> \\<and>\n  finite Cl_C2 \\<and>\n  smaller_lits_are_false v gr_Cl_C2 S \\<and>\n  maximal_literal_is_unique v gr_rhs Cl_C2 L2 S \\<eta>\n\ngoal (1 subgoal):\n 1. v \\<notin> subst_set (trms_ecl C2) \\<eta>", "by metis"], ["proof (state)\nthis:\n  v \\<notin> subst_set (trms_ecl C2) \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from cv"], ["proof (chain)\npicking this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S", "have \"sel (cl_ecl C2) = {}\""], ["proof (prove)\nusing this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C2) = {}", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  C2 \\<in> S \\<and>\n  v \\<notin> subst_set (trms_ecl C2) \\<eta> \\<and>\n  trms_irreducible C2 \\<eta> S v \\<and>\n  Cl_C2 = cl_ecl C2 \\<and>\n  (gr_rhs, v) \\<in> trm_ord \\<and>\n  ((gr_rhs, v) \\<in> trm_ord \\<longrightarrow>\n   trm_rep v S = trm_rep gr_rhs S) \\<and>\n  orient_lit_inst L2 lhs rhs pos \\<eta> \\<and>\n  sel Cl_C2 = {} \\<and>\n  L2 \\<in> Cl_C2 \\<and>\n  maximal_literal gr_L2 gr_Cl_C2 \\<and>\n  gr_L2 = subst_lit L2 \\<eta> \\<and>\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta> \\<and>\n  ground_clause gr_Cl_C2 \\<and>\n  v = lhs \\<lhd> \\<eta> \\<and>\n  gr_rhs = rhs \\<lhd> \\<eta> \\<and>\n  finite Cl_C2 \\<and>\n  smaller_lits_are_false v gr_Cl_C2 S \\<and>\n  maximal_literal_is_unique v gr_rhs Cl_C2 L2 S \\<eta>\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C2) = {}", "by metis"], ["proof (state)\nthis:\n  sel (cl_ecl C2) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from this and \\<open>maximal_literal gr_L2 gr_Cl_C2\\<close> and \\<open>gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\\<close>\n    and \\<open>Cl_C2 = (cl_ecl C2)\\<close> and \\<open>gr_L2 = subst_lit L2 \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  sel (cl_ecl C2) = {}\n  maximal_literal gr_L2 gr_Cl_C2\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\n  Cl_C2 = cl_ecl C2\n  gr_L2 = subst_lit L2 \\<eta>", "have \"eligible_literal L2 C2 \\<eta>\""], ["proof (prove)\nusing this:\n  sel (cl_ecl C2) = {}\n  maximal_literal gr_L2 gr_Cl_C2\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\n  Cl_C2 = cl_ecl C2\n  gr_L2 = subst_lit L2 \\<eta>\n\ngoal (1 subgoal):\n 1. eligible_literal L2 C2 \\<eta>", "unfolding eligible_literal_def"], ["proof (prove)\nusing this:\n  sel (cl_ecl C2) = {}\n  maximal_literal gr_L2 gr_Cl_C2\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\n  Cl_C2 = cl_ecl C2\n  gr_L2 = subst_lit L2 \\<eta>\n\ngoal (1 subgoal):\n 1. L2 \\<in> sel (cl_ecl C2) \\<or>\n    sel (cl_ecl C2) = {} \\<and>\n    maximal_literal (subst_lit L2 \\<eta>) (subst_cl (cl_ecl C2) \\<eta>)", "by auto"], ["proof (state)\nthis:\n  eligible_literal L2 C2 \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from cv"], ["proof (chain)\npicking this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S", "have \"(gr_rhs, v) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S\n\ngoal (1 subgoal):\n 1. (gr_rhs, v) \\<in> trm_ord", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  C2 \\<in> S \\<and>\n  v \\<notin> subst_set (trms_ecl C2) \\<eta> \\<and>\n  trms_irreducible C2 \\<eta> S v \\<and>\n  Cl_C2 = cl_ecl C2 \\<and>\n  (gr_rhs, v) \\<in> trm_ord \\<and>\n  ((gr_rhs, v) \\<in> trm_ord \\<longrightarrow>\n   trm_rep v S = trm_rep gr_rhs S) \\<and>\n  orient_lit_inst L2 lhs rhs pos \\<eta> \\<and>\n  sel Cl_C2 = {} \\<and>\n  L2 \\<in> Cl_C2 \\<and>\n  maximal_literal gr_L2 gr_Cl_C2 \\<and>\n  gr_L2 = subst_lit L2 \\<eta> \\<and>\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta> \\<and>\n  ground_clause gr_Cl_C2 \\<and>\n  v = lhs \\<lhd> \\<eta> \\<and>\n  gr_rhs = rhs \\<lhd> \\<eta> \\<and>\n  finite Cl_C2 \\<and>\n  smaller_lits_are_false v gr_Cl_C2 S \\<and>\n  maximal_literal_is_unique v gr_rhs Cl_C2 L2 S \\<eta>\n\ngoal (1 subgoal):\n 1. (gr_rhs, v) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (gr_rhs, v) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from cv"], ["proof (chain)\npicking this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S", "have norm: \"(\\<forall>x. (\\<exists>x'\\<in> trms_ecl C2. occurs_in x (subst x' \\<eta>)) \\<longrightarrow>\n       (x, v) \\<in> trm_ord \\<longrightarrow> trm_rep x S = x)\""], ["proof (prove)\nusing this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<exists>x'\\<in>trms_ecl C2.\n           occurs_in x (x' \\<lhd> \\<eta>)) \\<longrightarrow>\n       (x, v) \\<in> trm_ord \\<longrightarrow> trm_rep x S = x", "unfolding candidate_values_def trms_irreducible_def"], ["proof (prove)\nusing this:\n  C2 \\<in> S \\<and>\n  v \\<notin> subst_set (trms_ecl C2) \\<eta> \\<and>\n  (\\<forall>x.\n      (\\<exists>x'\\<in>trms_ecl C2.\n          occurs_in x (x' \\<lhd> \\<eta>)) \\<longrightarrow>\n      (x, v) \\<in> trm_ord \\<longrightarrow> trm_rep x S = x) \\<and>\n  Cl_C2 = cl_ecl C2 \\<and>\n  (gr_rhs, v) \\<in> trm_ord \\<and>\n  ((gr_rhs, v) \\<in> trm_ord \\<longrightarrow>\n   trm_rep v S = trm_rep gr_rhs S) \\<and>\n  orient_lit_inst L2 lhs rhs pos \\<eta> \\<and>\n  sel Cl_C2 = {} \\<and>\n  L2 \\<in> Cl_C2 \\<and>\n  maximal_literal gr_L2 gr_Cl_C2 \\<and>\n  gr_L2 = subst_lit L2 \\<eta> \\<and>\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta> \\<and>\n  ground_clause gr_Cl_C2 \\<and>\n  v = lhs \\<lhd> \\<eta> \\<and>\n  gr_rhs = rhs \\<lhd> \\<eta> \\<and>\n  finite Cl_C2 \\<and>\n  smaller_lits_are_false v gr_Cl_C2 S \\<and>\n  maximal_literal_is_unique v gr_rhs Cl_C2 L2 S \\<eta>\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (\\<exists>x'\\<in>trms_ecl C2.\n           occurs_in x (x' \\<lhd> \\<eta>)) \\<longrightarrow>\n       (x, v) \\<in> trm_ord \\<longrightarrow> trm_rep x S = x", "by metis"], ["proof (state)\nthis:\n  \\<forall>x.\n     (\\<exists>x'\\<in>trms_ecl C2.\n         occurs_in x (x' \\<lhd> \\<eta>)) \\<longrightarrow>\n     (x, v) \\<in> trm_ord \\<longrightarrow> trm_rep x S = x\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>ground_clause gr_Cl_C2\\<close> and \\<open>gr_L2 \\<in> gr_Cl_C2\\<close>"], ["proof (chain)\npicking this:\n  ground_clause gr_Cl_C2\n  gr_L2 \\<in> gr_Cl_C2", "have \"vars_of_lit gr_L2 = {}\""], ["proof (prove)\nusing this:\n  ground_clause gr_Cl_C2\n  gr_L2 \\<in> gr_Cl_C2\n\ngoal (1 subgoal):\n 1. vars_of_lit gr_L2 = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_lit gr_L2 = {}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from cv"], ["proof (chain)\npicking this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S", "have \"v = subst lhs \\<eta>\""], ["proof (prove)\nusing this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S\n\ngoal (1 subgoal):\n 1. v = lhs \\<lhd> \\<eta>", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  C2 \\<in> S \\<and>\n  v \\<notin> subst_set (trms_ecl C2) \\<eta> \\<and>\n  trms_irreducible C2 \\<eta> S v \\<and>\n  Cl_C2 = cl_ecl C2 \\<and>\n  (gr_rhs, v) \\<in> trm_ord \\<and>\n  ((gr_rhs, v) \\<in> trm_ord \\<longrightarrow>\n   trm_rep v S = trm_rep gr_rhs S) \\<and>\n  orient_lit_inst L2 lhs rhs pos \\<eta> \\<and>\n  sel Cl_C2 = {} \\<and>\n  L2 \\<in> Cl_C2 \\<and>\n  maximal_literal gr_L2 gr_Cl_C2 \\<and>\n  gr_L2 = subst_lit L2 \\<eta> \\<and>\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta> \\<and>\n  ground_clause gr_Cl_C2 \\<and>\n  v = lhs \\<lhd> \\<eta> \\<and>\n  gr_rhs = rhs \\<lhd> \\<eta> \\<and>\n  finite Cl_C2 \\<and>\n  smaller_lits_are_false v gr_Cl_C2 S \\<and>\n  maximal_literal_is_unique v gr_rhs Cl_C2 L2 S \\<eta>\n\ngoal (1 subgoal):\n 1. v = lhs \\<lhd> \\<eta>", "by metis"], ["proof (state)\nthis:\n  v = lhs \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from cv"], ["proof (chain)\npicking this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S", "have \"gr_rhs = subst rhs \\<eta>\""], ["proof (prove)\nusing this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S\n\ngoal (1 subgoal):\n 1. gr_rhs = rhs \\<lhd> \\<eta>", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  C2 \\<in> S \\<and>\n  v \\<notin> subst_set (trms_ecl C2) \\<eta> \\<and>\n  trms_irreducible C2 \\<eta> S v \\<and>\n  Cl_C2 = cl_ecl C2 \\<and>\n  (gr_rhs, v) \\<in> trm_ord \\<and>\n  ((gr_rhs, v) \\<in> trm_ord \\<longrightarrow>\n   trm_rep v S = trm_rep gr_rhs S) \\<and>\n  orient_lit_inst L2 lhs rhs pos \\<eta> \\<and>\n  sel Cl_C2 = {} \\<and>\n  L2 \\<in> Cl_C2 \\<and>\n  maximal_literal gr_L2 gr_Cl_C2 \\<and>\n  gr_L2 = subst_lit L2 \\<eta> \\<and>\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta> \\<and>\n  ground_clause gr_Cl_C2 \\<and>\n  v = lhs \\<lhd> \\<eta> \\<and>\n  gr_rhs = rhs \\<lhd> \\<eta> \\<and>\n  finite Cl_C2 \\<and>\n  smaller_lits_are_false v gr_Cl_C2 S \\<and>\n  maximal_literal_is_unique v gr_rhs Cl_C2 L2 S \\<eta>\n\ngoal (1 subgoal):\n 1. gr_rhs = rhs \\<lhd> \\<eta>", "by metis"], ["proof (state)\nthis:\n  gr_rhs = rhs \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "let ?I = \"(same_values (\\<lambda>t. (trm_rep t S)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "have no_fact: \"\\<not> equivalent_eq_exists lhs rhs Cl_C2 (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> equivalent_eq_exists lhs rhs Cl_C2\n            (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. equivalent_eq_exists lhs rhs Cl_C2\n     (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2 \\<Longrightarrow>\n    False", "assume \"equivalent_eq_exists lhs rhs Cl_C2 (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2\""], ["proof (state)\nthis:\n  equivalent_eq_exists lhs rhs Cl_C2 (same_values (\\<lambda>t. trm_rep t S))\n   \\<eta> L2\n\ngoal (1 subgoal):\n 1. equivalent_eq_exists lhs rhs Cl_C2\n     (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2 \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  equivalent_eq_exists lhs rhs Cl_C2 (same_values (\\<lambda>t. trm_rep t S))\n   \\<eta> L2", "have \"\\<exists>L\\<in>Cl_C2 - {L2}.\\<exists>u v. orient_lit_inst L u v pos \\<eta> \\<and>\n           subst lhs \\<eta> = subst u \\<eta> \\<and> same_values (\\<lambda>t. trm_rep t S) (subst rhs \\<eta>) (subst v \\<eta>)\""], ["proof (prove)\nusing this:\n  equivalent_eq_exists lhs rhs Cl_C2 (same_values (\\<lambda>t. trm_rep t S))\n   \\<eta> L2\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>Cl_C2 - {L2}.\n       \\<exists>u v.\n          orient_lit_inst L u v pos \\<eta> \\<and>\n          lhs \\<lhd> \\<eta> = u \\<lhd> \\<eta> \\<and>\n          same_values (\\<lambda>t. trm_rep t S) (rhs \\<lhd> \\<eta>)\n           (v \\<lhd> \\<eta>)", "unfolding equivalent_eq_exists_def"], ["proof (prove)\nusing this:\n  \\<exists>L\\<in>Cl_C2 - {L2}.\n     \\<exists>u v.\n        orient_lit_inst L u v pos \\<eta> \\<and>\n        lhs \\<lhd> \\<eta> = u \\<lhd> \\<eta> \\<and>\n        same_values (\\<lambda>t. trm_rep t S) (rhs \\<lhd> \\<eta>)\n         (v \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<exists>L\\<in>Cl_C2 - {L2}.\n       \\<exists>u v.\n          orient_lit_inst L u v pos \\<eta> \\<and>\n          lhs \\<lhd> \\<eta> = u \\<lhd> \\<eta> \\<and>\n          same_values (\\<lambda>t. trm_rep t S) (rhs \\<lhd> \\<eta>)\n           (v \\<lhd> \\<eta>)", "by blast"], ["proof (state)\nthis:\n  \\<exists>L\\<in>Cl_C2 - {L2}.\n     \\<exists>u v.\n        orient_lit_inst L u v pos \\<eta> \\<and>\n        lhs \\<lhd> \\<eta> = u \\<lhd> \\<eta> \\<and>\n        same_values (\\<lambda>t. trm_rep t S) (rhs \\<lhd> \\<eta>)\n         (v \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. equivalent_eq_exists lhs rhs Cl_C2\n     (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2 \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<exists>L\\<in>Cl_C2 - {L2}.\n     \\<exists>u v.\n        orient_lit_inst L u v pos \\<eta> \\<and>\n        lhs \\<lhd> \\<eta> = u \\<lhd> \\<eta> \\<and>\n        same_values (\\<lambda>t. trm_rep t S) (rhs \\<lhd> \\<eta>)\n         (v \\<lhd> \\<eta>)", "obtain M where \"M\\<in>Cl_C2 - {L2}\" and e: \"\\<exists>u v. orient_lit_inst M u v pos \\<eta> \\<and>\n           subst lhs \\<eta> = subst u \\<eta> \\<and> same_values (\\<lambda>t. trm_rep t S) (subst rhs \\<eta>) (subst v \\<eta>)\""], ["proof (prove)\nusing this:\n  \\<exists>L\\<in>Cl_C2 - {L2}.\n     \\<exists>u v.\n        orient_lit_inst L u v pos \\<eta> \\<and>\n        lhs \\<lhd> \\<eta> = u \\<lhd> \\<eta> \\<and>\n        same_values (\\<lambda>t. trm_rep t S) (rhs \\<lhd> \\<eta>)\n         (v \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>M \\<in> Cl_C2 - {L2};\n         \\<exists>u v.\n            orient_lit_inst M u v pos \\<eta> \\<and>\n            lhs \\<lhd> \\<eta> = u \\<lhd> \\<eta> \\<and>\n            same_values (\\<lambda>t. trm_rep t S) (rhs \\<lhd> \\<eta>)\n             (v \\<lhd> \\<eta>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  M \\<in> Cl_C2 - {L2}\n  \\<exists>u v.\n     orient_lit_inst M u v pos \\<eta> \\<and>\n     lhs \\<lhd> \\<eta> = u \\<lhd> \\<eta> \\<and>\n     same_values (\\<lambda>t. trm_rep t S) (rhs \\<lhd> \\<eta>)\n      (v \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. equivalent_eq_exists lhs rhs Cl_C2\n     (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2 \\<Longrightarrow>\n    False", "from e"], ["proof (chain)\npicking this:\n  \\<exists>u v.\n     orient_lit_inst M u v pos \\<eta> \\<and>\n     lhs \\<lhd> \\<eta> = u \\<lhd> \\<eta> \\<and>\n     same_values (\\<lambda>t. trm_rep t S) (rhs \\<lhd> \\<eta>)\n      (v \\<lhd> \\<eta>)", "obtain u' v' where \"orient_lit_inst M u' v' pos \\<eta>\" \n        and i: \"subst lhs \\<eta> = subst u' \\<eta> \\<and> same_values (\\<lambda>t. trm_rep t S) (subst rhs \\<eta>) (subst v' \\<eta>)\""], ["proof (prove)\nusing this:\n  \\<exists>u v.\n     orient_lit_inst M u v pos \\<eta> \\<and>\n     lhs \\<lhd> \\<eta> = u \\<lhd> \\<eta> \\<and>\n     same_values (\\<lambda>t. trm_rep t S) (rhs \\<lhd> \\<eta>)\n      (v \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. (\\<And>u' v'.\n        \\<lbrakk>orient_lit_inst M u' v' pos \\<eta>;\n         lhs \\<lhd> \\<eta> = u' \\<lhd> \\<eta> \\<and>\n         same_values (\\<lambda>t. trm_rep t S) (rhs \\<lhd> \\<eta>)\n          (v' \\<lhd> \\<eta>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  orient_lit_inst M u' v' pos \\<eta>\n  lhs \\<lhd> \\<eta> = u' \\<lhd> \\<eta> \\<and>\n  same_values (\\<lambda>t. trm_rep t S) (rhs \\<lhd> \\<eta>)\n   (v' \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. equivalent_eq_exists lhs rhs Cl_C2\n     (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2 \\<Longrightarrow>\n    False", "from i"], ["proof (chain)\npicking this:\n  lhs \\<lhd> \\<eta> = u' \\<lhd> \\<eta> \\<and>\n  same_values (\\<lambda>t. trm_rep t S) (rhs \\<lhd> \\<eta>)\n   (v' \\<lhd> \\<eta>)", "have \"subst lhs \\<eta> = subst u' \\<eta>\""], ["proof (prove)\nusing this:\n  lhs \\<lhd> \\<eta> = u' \\<lhd> \\<eta> \\<and>\n  same_values (\\<lambda>t. trm_rep t S) (rhs \\<lhd> \\<eta>)\n   (v' \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. lhs \\<lhd> \\<eta> = u' \\<lhd> \\<eta>", "by blast"], ["proof (state)\nthis:\n  lhs \\<lhd> \\<eta> = u' \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. equivalent_eq_exists lhs rhs Cl_C2\n     (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2 \\<Longrightarrow>\n    False", "from i"], ["proof (chain)\npicking this:\n  lhs \\<lhd> \\<eta> = u' \\<lhd> \\<eta> \\<and>\n  same_values (\\<lambda>t. trm_rep t S) (rhs \\<lhd> \\<eta>)\n   (v' \\<lhd> \\<eta>)", "have \"trm_rep (subst rhs \\<eta>) S = trm_rep (subst v' \\<eta>) S\""], ["proof (prove)\nusing this:\n  lhs \\<lhd> \\<eta> = u' \\<lhd> \\<eta> \\<and>\n  same_values (\\<lambda>t. trm_rep t S) (rhs \\<lhd> \\<eta>)\n   (v' \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. trm_rep (rhs \\<lhd> \\<eta>) S = trm_rep (v' \\<lhd> \\<eta>) S", "unfolding same_values_def"], ["proof (prove)\nusing this:\n  lhs \\<lhd> \\<eta> = u' \\<lhd> \\<eta> \\<and>\n  trm_rep (rhs \\<lhd> \\<eta>) S = trm_rep (v' \\<lhd> \\<eta>) S\n\ngoal (1 subgoal):\n 1. trm_rep (rhs \\<lhd> \\<eta>) S = trm_rep (v' \\<lhd> \\<eta>) S", "by blast"], ["proof (state)\nthis:\n  trm_rep (rhs \\<lhd> \\<eta>) S = trm_rep (v' \\<lhd> \\<eta>) S\n\ngoal (1 subgoal):\n 1. equivalent_eq_exists lhs rhs Cl_C2\n     (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2 \\<Longrightarrow>\n    False", "let ?u' = \"(subst u' \\<eta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. equivalent_eq_exists lhs rhs Cl_C2\n     (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2 \\<Longrightarrow>\n    False", "let ?v' = \"(subst v' \\<eta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. equivalent_eq_exists lhs rhs Cl_C2\n     (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2 \\<Longrightarrow>\n    False", "from \\<open>orient_lit_inst M u' v' pos \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst M u' v' pos \\<eta>", "have \"orient_lit (subst_lit M \\<eta>) ?u' ?v' pos\""], ["proof (prove)\nusing this:\n  orient_lit_inst M u' v' pos \\<eta>\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit M \\<eta>) (u' \\<lhd> \\<eta>) (v' \\<lhd> \\<eta>)\n     pos", "using lift_orient_lit"], ["proof (prove)\nusing this:\n  orient_lit_inst M u' v' pos \\<eta>\n  orient_lit_inst ?L ?t ?s ?p ?\\<sigma> \\<Longrightarrow>\n  orient_lit (subst_lit ?L ?\\<sigma>) (?t \\<lhd> ?\\<sigma>)\n   (?s \\<lhd> ?\\<sigma>) ?p\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit M \\<eta>) (u' \\<lhd> \\<eta>) (v' \\<lhd> \\<eta>)\n     pos", "by auto"], ["proof (state)\nthis:\n  orient_lit (subst_lit M \\<eta>) (u' \\<lhd> \\<eta>) (v' \\<lhd> \\<eta>) pos\n\ngoal (1 subgoal):\n 1. equivalent_eq_exists lhs rhs Cl_C2\n     (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2 \\<Longrightarrow>\n    False", "from \\<open>orient_lit_inst L2 lhs rhs pos \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L2 lhs rhs pos \\<eta>", "have \"orient_lit (subst_lit L2 \\<eta>) (subst lhs \\<eta>) \n      (subst rhs \\<eta>) pos\""], ["proof (prove)\nusing this:\n  orient_lit_inst L2 lhs rhs pos \\<eta>\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit L2 \\<eta>) (lhs \\<lhd> \\<eta>) (rhs \\<lhd> \\<eta>)\n     pos", "using lift_orient_lit"], ["proof (prove)\nusing this:\n  orient_lit_inst L2 lhs rhs pos \\<eta>\n  orient_lit_inst ?L ?t ?s ?p ?\\<sigma> \\<Longrightarrow>\n  orient_lit (subst_lit ?L ?\\<sigma>) (?t \\<lhd> ?\\<sigma>)\n   (?s \\<lhd> ?\\<sigma>) ?p\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit L2 \\<eta>) (lhs \\<lhd> \\<eta>) (rhs \\<lhd> \\<eta>)\n     pos", "by auto"], ["proof (state)\nthis:\n  orient_lit (subst_lit L2 \\<eta>) (lhs \\<lhd> \\<eta>) (rhs \\<lhd> \\<eta>)\n   pos\n\ngoal (1 subgoal):\n 1. equivalent_eq_exists lhs rhs Cl_C2\n     (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2 \\<Longrightarrow>\n    False", "from \\<open>orient_lit_inst M u' v' pos \\<eta>\\<close> and \\<open>M \\<in> (Cl_C2 - {L2})\\<close> and \n    \\<open>gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst M u' v' pos \\<eta>\n  M \\<in> Cl_C2 - {L2}\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>", "have \"eq_occurs_in_cl ?u' ?v' (Cl_C2 - {L2}) \\<eta>\""], ["proof (prove)\nusing this:\n  orient_lit_inst M u' v' pos \\<eta>\n  M \\<in> Cl_C2 - {L2}\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\n\ngoal (1 subgoal):\n 1. eq_occurs_in_cl (u' \\<lhd> \\<eta>) (v' \\<lhd> \\<eta>) (Cl_C2 - {L2})\n     \\<eta>", "unfolding eq_occurs_in_cl_def"], ["proof (prove)\nusing this:\n  orient_lit_inst M u' v' pos \\<eta>\n  M \\<in> Cl_C2 - {L2}\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>L t' s'.\n       L \\<in> Cl_C2 - {L2} \\<and>\n       orient_lit_inst L t' s' pos \\<eta> \\<and>\n       u' \\<lhd> \\<eta> = t' \\<lhd> \\<eta> \\<and>\n       v' \\<lhd> \\<eta> = s' \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  eq_occurs_in_cl (u' \\<lhd> \\<eta>) (v' \\<lhd> \\<eta>) (Cl_C2 - {L2})\n   \\<eta>\n\ngoal (1 subgoal):\n 1. equivalent_eq_exists lhs rhs Cl_C2\n     (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2 \\<Longrightarrow>\n    False", "from \\<open>M\\<in>Cl_C2 - {L2}\\<close> and \\<open>gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  M \\<in> Cl_C2 - {L2}\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>", "have \"(subst_lit M \\<eta>) \\<in> (subst_cl (Cl_C2 - { L2 }) \\<eta>)\""], ["proof (prove)\nusing this:\n  M \\<in> Cl_C2 - {L2}\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\n\ngoal (1 subgoal):\n 1. subst_lit M \\<eta> \\<in> subst_cl (Cl_C2 - {L2}) \\<eta>", "by auto"], ["proof (state)\nthis:\n  subst_lit M \\<eta> \\<in> subst_cl (Cl_C2 - {L2}) \\<eta>\n\ngoal (1 subgoal):\n 1. equivalent_eq_exists lhs rhs Cl_C2\n     (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2 \\<Longrightarrow>\n    False", "from \\<open>M\\<in>Cl_C2 - {L2}\\<close> and \\<open>gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  M \\<in> Cl_C2 - {L2}\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>", "have \"(subst_lit M \\<eta>) \\<in> gr_Cl_C2\""], ["proof (prove)\nusing this:\n  M \\<in> Cl_C2 - {L2}\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\n\ngoal (1 subgoal):\n 1. subst_lit M \\<eta> \\<in> gr_Cl_C2", "by auto"], ["proof (state)\nthis:\n  subst_lit M \\<eta> \\<in> gr_Cl_C2\n\ngoal (1 subgoal):\n 1. equivalent_eq_exists lhs rhs Cl_C2\n     (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2 \\<Longrightarrow>\n    False", "from \\<open>vars_of_lit gr_L2 = {}\\<close> and \\<open>gr_L2 = subst_lit L2 \\<eta>\\<close>  \n      \\<open>orient_lit (subst_lit L2 \\<eta>) (subst lhs \\<eta>) (subst rhs \\<eta>) pos\\<close>"], ["proof (chain)\npicking this:\n  vars_of_lit gr_L2 = {}\n  gr_L2 = subst_lit L2 \\<eta>\n  orient_lit (subst_lit L2 \\<eta>) (lhs \\<lhd> \\<eta>) (rhs \\<lhd> \\<eta>)\n   pos", "have \"vars_of (subst rhs \\<eta>) = {}\""], ["proof (prove)\nusing this:\n  vars_of_lit gr_L2 = {}\n  gr_L2 = subst_lit L2 \\<eta>\n  orient_lit (subst_lit L2 \\<eta>) (lhs \\<lhd> \\<eta>) (rhs \\<lhd> \\<eta>)\n   pos\n\ngoal (1 subgoal):\n 1. vars_of (rhs \\<lhd> \\<eta>) = {}", "using orient_lit_vars"], ["proof (prove)\nusing this:\n  vars_of_lit gr_L2 = {}\n  gr_L2 = subst_lit L2 \\<eta>\n  orient_lit (subst_lit L2 \\<eta>) (lhs \\<lhd> \\<eta>) (rhs \\<lhd> \\<eta>)\n   pos\n  orient_lit ?L ?t ?s ?p \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of (rhs \\<lhd> \\<eta>) = {}", "by blast"], ["proof (state)\nthis:\n  vars_of (rhs \\<lhd> \\<eta>) = {}\n\ngoal (1 subgoal):\n 1. equivalent_eq_exists lhs rhs Cl_C2\n     (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2 \\<Longrightarrow>\n    False", "from \\<open>ground_clause gr_Cl_C2\\<close> and \\<open>(subst_lit M \\<eta>) \\<in> gr_Cl_C2\\<close>"], ["proof (chain)\npicking this:\n  ground_clause gr_Cl_C2\n  subst_lit M \\<eta> \\<in> gr_Cl_C2", "have \"vars_of_lit (subst_lit M \\<eta>) = {}\""], ["proof (prove)\nusing this:\n  ground_clause gr_Cl_C2\n  subst_lit M \\<eta> \\<in> gr_Cl_C2\n\ngoal (1 subgoal):\n 1. vars_of_lit (subst_lit M \\<eta>) = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_lit (subst_lit M \\<eta>) = {}\n\ngoal (1 subgoal):\n 1. equivalent_eq_exists lhs rhs Cl_C2\n     (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2 \\<Longrightarrow>\n    False", "from this and \\<open>orient_lit (subst_lit M \\<eta>) ?u' ?v' pos\\<close>"], ["proof (chain)\npicking this:\n  vars_of_lit (subst_lit M \\<eta>) = {}\n  orient_lit (subst_lit M \\<eta>) (u' \\<lhd> \\<eta>) (v' \\<lhd> \\<eta>) pos", "have \"vars_of ?v' = {}\""], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit M \\<eta>) = {}\n  orient_lit (subst_lit M \\<eta>) (u' \\<lhd> \\<eta>) (v' \\<lhd> \\<eta>) pos\n\ngoal (1 subgoal):\n 1. vars_of (v' \\<lhd> \\<eta>) = {}", "using orient_lit_vars"], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit M \\<eta>) = {}\n  orient_lit (subst_lit M \\<eta>) (u' \\<lhd> \\<eta>) (v' \\<lhd> \\<eta>) pos\n  orient_lit ?L ?t ?s ?p \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of (v' \\<lhd> \\<eta>) = {}", "by blast"], ["proof (state)\nthis:\n  vars_of (v' \\<lhd> \\<eta>) = {}\n\ngoal (1 subgoal):\n 1. equivalent_eq_exists lhs rhs Cl_C2\n     (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2 \\<Longrightarrow>\n    False", "from \\<open>maximal_literal gr_L2 gr_Cl_C2\\<close> and \\<open>(subst_lit M \\<eta>) \\<in> gr_Cl_C2\\<close>"], ["proof (chain)\npicking this:\n  maximal_literal gr_L2 gr_Cl_C2\n  subst_lit M \\<eta> \\<in> gr_Cl_C2", "have \"(gr_L2,(subst_lit M \\<eta>)) \\<notin> lit_ord\""], ["proof (prove)\nusing this:\n  maximal_literal gr_L2 gr_Cl_C2\n  subst_lit M \\<eta> \\<in> gr_Cl_C2\n\ngoal (1 subgoal):\n 1. (gr_L2, subst_lit M \\<eta>) \\<notin> lit_ord", "unfolding maximal_literal_def"], ["proof (prove)\nusing this:\n  \\<forall>x. x \\<in> gr_Cl_C2 \\<longrightarrow> (gr_L2, x) \\<notin> lit_ord\n  subst_lit M \\<eta> \\<in> gr_Cl_C2\n\ngoal (1 subgoal):\n 1. (gr_L2, subst_lit M \\<eta>) \\<notin> lit_ord", "by auto"], ["proof (state)\nthis:\n  (gr_L2, subst_lit M \\<eta>) \\<notin> lit_ord\n\ngoal (1 subgoal):\n 1. equivalent_eq_exists lhs rhs Cl_C2\n     (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2 \\<Longrightarrow>\n    False", "from this and \\<open>orient_lit (subst_lit M \\<eta>) ?u' ?v' pos\\<close> \n      and \\<open>orient_lit (subst_lit L2 \\<eta>) (subst lhs \\<eta>) (subst rhs \\<eta>) pos\\<close>\n      and \\<open>subst lhs \\<eta> = subst u' \\<eta>\\<close> \n      and \\<open>vars_of_lit gr_L2 = {}\\<close> and  \\<open>vars_of_lit (subst_lit M \\<eta>) = {}\\<close> \n      and \\<open>gr_L2 = subst_lit L2 \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  (gr_L2, subst_lit M \\<eta>) \\<notin> lit_ord\n  orient_lit (subst_lit M \\<eta>) (u' \\<lhd> \\<eta>) (v' \\<lhd> \\<eta>) pos\n  orient_lit (subst_lit L2 \\<eta>) (lhs \\<lhd> \\<eta>) (rhs \\<lhd> \\<eta>)\n   pos\n  lhs \\<lhd> \\<eta> = u' \\<lhd> \\<eta>\n  vars_of_lit gr_L2 = {}\n  vars_of_lit (subst_lit M \\<eta>) = {}\n  gr_L2 = subst_lit L2 \\<eta>", "have \"((subst rhs \\<eta>),?v') \\<notin>  trm_ord\""], ["proof (prove)\nusing this:\n  (gr_L2, subst_lit M \\<eta>) \\<notin> lit_ord\n  orient_lit (subst_lit M \\<eta>) (u' \\<lhd> \\<eta>) (v' \\<lhd> \\<eta>) pos\n  orient_lit (subst_lit L2 \\<eta>) (lhs \\<lhd> \\<eta>) (rhs \\<lhd> \\<eta>)\n   pos\n  lhs \\<lhd> \\<eta> = u' \\<lhd> \\<eta>\n  vars_of_lit gr_L2 = {}\n  vars_of_lit (subst_lit M \\<eta>) = {}\n  gr_L2 = subst_lit L2 \\<eta>\n\ngoal (1 subgoal):\n 1. (rhs \\<lhd> \\<eta>, v' \\<lhd> \\<eta>) \\<notin> trm_ord", "using lit_ord_rhs"], ["proof (prove)\nusing this:\n  (gr_L2, subst_lit M \\<eta>) \\<notin> lit_ord\n  orient_lit (subst_lit M \\<eta>) (u' \\<lhd> \\<eta>) (v' \\<lhd> \\<eta>) pos\n  orient_lit (subst_lit L2 \\<eta>) (lhs \\<lhd> \\<eta>) (rhs \\<lhd> \\<eta>)\n   pos\n  lhs \\<lhd> \\<eta> = u' \\<lhd> \\<eta>\n  vars_of_lit gr_L2 = {}\n  vars_of_lit (subst_lit M \\<eta>) = {}\n  gr_L2 = subst_lit L2 \\<eta>\n  \\<lbrakk>(?t1.0, ?t2.0) \\<in> trm_ord; orient_lit ?x1.0 ?s ?t1.0 ?p;\n   orient_lit ?x2.0 ?s ?t2.0 ?p; vars_of_lit ?x1.0 = {};\n   vars_of_lit ?x2.0 = {}\\<rbrakk>\n  \\<Longrightarrow> (?x1.0, ?x2.0) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (rhs \\<lhd> \\<eta>, v' \\<lhd> \\<eta>) \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  (rhs \\<lhd> \\<eta>, v' \\<lhd> \\<eta>) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. equivalent_eq_exists lhs rhs Cl_C2\n     (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2 \\<Longrightarrow>\n    False", "from this and \\<open>vars_of ?v' = {}\\<close> and \\<open>vars_of (subst rhs \\<eta>) = {}\\<close>"], ["proof (chain)\npicking this:\n  (rhs \\<lhd> \\<eta>, v' \\<lhd> \\<eta>) \\<notin> trm_ord\n  vars_of (v' \\<lhd> \\<eta>) = {}\n  vars_of (rhs \\<lhd> \\<eta>) = {}", "have \"?v' = (subst rhs \\<eta>) \\<or> (?v',(subst rhs \\<eta>)) \\<in>  trm_ord\""], ["proof (prove)\nusing this:\n  (rhs \\<lhd> \\<eta>, v' \\<lhd> \\<eta>) \\<notin> trm_ord\n  vars_of (v' \\<lhd> \\<eta>) = {}\n  vars_of (rhs \\<lhd> \\<eta>) = {}\n\ngoal (1 subgoal):\n 1. v' \\<lhd> \\<eta> = rhs \\<lhd> \\<eta> \\<or>\n    (v' \\<lhd> \\<eta>, rhs \\<lhd> \\<eta>) \\<in> trm_ord", "using trm_ord_ground_total"], ["proof (prove)\nusing this:\n  (rhs \\<lhd> \\<eta>, v' \\<lhd> \\<eta>) \\<notin> trm_ord\n  vars_of (v' \\<lhd> \\<eta>) = {}\n  vars_of (rhs \\<lhd> \\<eta>) = {}\n  \\<forall>x y.\n     ground_term x \\<longrightarrow>\n     ground_term y \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. v' \\<lhd> \\<eta> = rhs \\<lhd> \\<eta> \\<or>\n    (v' \\<lhd> \\<eta>, rhs \\<lhd> \\<eta>) \\<in> trm_ord", "unfolding ground_term_def"], ["proof (prove)\nusing this:\n  (rhs \\<lhd> \\<eta>, v' \\<lhd> \\<eta>) \\<notin> trm_ord\n  vars_of (v' \\<lhd> \\<eta>) = {}\n  vars_of (rhs \\<lhd> \\<eta>) = {}\n  \\<forall>x y.\n     vars_of x = {} \\<longrightarrow>\n     vars_of y = {} \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. v' \\<lhd> \\<eta> = rhs \\<lhd> \\<eta> \\<or>\n    (v' \\<lhd> \\<eta>, rhs \\<lhd> \\<eta>) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  v' \\<lhd> \\<eta> = rhs \\<lhd> \\<eta> \\<or>\n  (v' \\<lhd> \\<eta>, rhs \\<lhd> \\<eta>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. equivalent_eq_exists lhs rhs Cl_C2\n     (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2 \\<Longrightarrow>\n    False", "from this and \\<open>(gr_rhs,v) \\<in> trm_ord\\<close> and \\<open>gr_rhs = subst rhs \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  v' \\<lhd> \\<eta> = rhs \\<lhd> \\<eta> \\<or>\n  (v' \\<lhd> \\<eta>, rhs \\<lhd> \\<eta>) \\<in> trm_ord\n  (gr_rhs, v) \\<in> trm_ord\n  gr_rhs = rhs \\<lhd> \\<eta>", "have \n     \"(?v',v) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  v' \\<lhd> \\<eta> = rhs \\<lhd> \\<eta> \\<or>\n  (v' \\<lhd> \\<eta>, rhs \\<lhd> \\<eta>) \\<in> trm_ord\n  (gr_rhs, v) \\<in> trm_ord\n  gr_rhs = rhs \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. (v' \\<lhd> \\<eta>, v) \\<in> trm_ord", "using trm_ord_trans"], ["proof (prove)\nusing this:\n  v' \\<lhd> \\<eta> = rhs \\<lhd> \\<eta> \\<or>\n  (v' \\<lhd> \\<eta>, rhs \\<lhd> \\<eta>) \\<in> trm_ord\n  (gr_rhs, v) \\<in> trm_ord\n  gr_rhs = rhs \\<lhd> \\<eta>\n  trans trm_ord\n\ngoal (1 subgoal):\n 1. (v' \\<lhd> \\<eta>, v) \\<in> trm_ord", "unfolding trans_def"], ["proof (prove)\nusing this:\n  v' \\<lhd> \\<eta> = rhs \\<lhd> \\<eta> \\<or>\n  (v' \\<lhd> \\<eta>, rhs \\<lhd> \\<eta>) \\<in> trm_ord\n  (gr_rhs, v) \\<in> trm_ord\n  gr_rhs = rhs \\<lhd> \\<eta>\n  \\<forall>x y z.\n     (x, y) \\<in> trm_ord \\<longrightarrow>\n     (y, z) \\<in> trm_ord \\<longrightarrow> (x, z) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (v' \\<lhd> \\<eta>, v) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (v' \\<lhd> \\<eta>, v) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. equivalent_eq_exists lhs rhs Cl_C2\n     (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2 \\<Longrightarrow>\n    False", "from cv"], ["proof (chain)\npicking this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S", "have \"maximal_literal_is_unique v gr_rhs Cl_C2 L2 S \\<eta>\""], ["proof (prove)\nusing this:\n  candidate_values (trm_rep v S) C2 Cl_C2 gr_Cl_C2 gr_rhs gr_L2 L2 \\<eta>\n   lhs rhs v S\n\ngoal (1 subgoal):\n 1. maximal_literal_is_unique v gr_rhs Cl_C2 L2 S \\<eta>", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  C2 \\<in> S \\<and>\n  v \\<notin> subst_set (trms_ecl C2) \\<eta> \\<and>\n  trms_irreducible C2 \\<eta> S v \\<and>\n  Cl_C2 = cl_ecl C2 \\<and>\n  (gr_rhs, v) \\<in> trm_ord \\<and>\n  ((gr_rhs, v) \\<in> trm_ord \\<longrightarrow>\n   trm_rep v S = trm_rep gr_rhs S) \\<and>\n  orient_lit_inst L2 lhs rhs pos \\<eta> \\<and>\n  sel Cl_C2 = {} \\<and>\n  L2 \\<in> Cl_C2 \\<and>\n  maximal_literal gr_L2 gr_Cl_C2 \\<and>\n  gr_L2 = subst_lit L2 \\<eta> \\<and>\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta> \\<and>\n  ground_clause gr_Cl_C2 \\<and>\n  v = lhs \\<lhd> \\<eta> \\<and>\n  gr_rhs = rhs \\<lhd> \\<eta> \\<and>\n  finite Cl_C2 \\<and>\n  smaller_lits_are_false v gr_Cl_C2 S \\<and>\n  maximal_literal_is_unique v gr_rhs Cl_C2 L2 S \\<eta>\n\ngoal (1 subgoal):\n 1. maximal_literal_is_unique v gr_rhs Cl_C2 L2 S \\<eta>", "by metis"], ["proof (state)\nthis:\n  maximal_literal_is_unique v gr_rhs Cl_C2 L2 S \\<eta>\n\ngoal (1 subgoal):\n 1. equivalent_eq_exists lhs rhs Cl_C2\n     (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2 \\<Longrightarrow>\n    False", "from \\<open>orient_lit_inst M u' v' pos \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst M u' v' pos \\<eta>", "have \"((subst u' \\<eta>),(subst v' \\<eta>)) \\<notin> trm_ord\""], ["proof (prove)\nusing this:\n  orient_lit_inst M u' v' pos \\<eta>\n\ngoal (1 subgoal):\n 1. (u' \\<lhd> \\<eta>, v' \\<lhd> \\<eta>) \\<notin> trm_ord", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  (M = Pos (Eq u' v') \\<or> M = Pos (Eq v' u')) \\<and>\n  (u' \\<lhd> \\<eta>, v' \\<lhd> \\<eta>) \\<notin> trm_ord \\<and>\n  pos = pos \\<or>\n  (M = Neg (Eq u' v') \\<or> M = Neg (Eq v' u')) \\<and>\n  (u' \\<lhd> \\<eta>, v' \\<lhd> \\<eta>) \\<notin> trm_ord \\<and> pos = neg\n\ngoal (1 subgoal):\n 1. (u' \\<lhd> \\<eta>, v' \\<lhd> \\<eta>) \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  (u' \\<lhd> \\<eta>, v' \\<lhd> \\<eta>) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. equivalent_eq_exists lhs rhs Cl_C2\n     (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2 \\<Longrightarrow>\n    False", "have \"trm_rep gr_rhs S \\<noteq> trm_rep (subst v' \\<eta>) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trm_rep gr_rhs S \\<noteq> trm_rep (v' \\<lhd> \\<eta>) S", "by (metis \\<open>(subst v' \\<eta>, v) \\<in> trm_ord\\<close> \\<open>(gr_rhs, v) \\<in> trm_ord\\<close> \n          \\<open>subst lhs \\<eta> = subst u' \\<eta>\\<close> \n          \\<open>eq_occurs_in_cl (subst u' \\<eta>) (subst v' \\<eta>) (Cl_C2 - {L2}) \\<eta>\\<close> \n          \\<open>maximal_literal_is_unique v gr_rhs Cl_C2 L2 S \\<eta>\\<close> \\<open>v = subst lhs \\<eta>\\<close> \n            maximal_literal_is_unique_def)"], ["proof (state)\nthis:\n  trm_rep gr_rhs S \\<noteq> trm_rep (v' \\<lhd> \\<eta>) S\n\ngoal (1 subgoal):\n 1. equivalent_eq_exists lhs rhs Cl_C2\n     (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2 \\<Longrightarrow>\n    False", "from this and \\<open>trm_rep (subst rhs \\<eta>) S = trm_rep (subst v' \\<eta>) S\\<close>\n      and \\<open>gr_rhs = (subst rhs \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  trm_rep gr_rhs S \\<noteq> trm_rep (v' \\<lhd> \\<eta>) S\n  trm_rep (rhs \\<lhd> \\<eta>) S = trm_rep (v' \\<lhd> \\<eta>) S\n  gr_rhs = rhs \\<lhd> \\<eta>", "show False"], ["proof (prove)\nusing this:\n  trm_rep gr_rhs S \\<noteq> trm_rep (v' \\<lhd> \\<eta>) S\n  trm_rep (rhs \\<lhd> \\<eta>) S = trm_rep (v' \\<lhd> \\<eta>) S\n  gr_rhs = rhs \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> equivalent_eq_exists lhs rhs Cl_C2\n          (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from  this \\<open>gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\\<close>  \n   and  \\<open>gr_L2 = subst_lit L2 \\<eta>\\<close>  \n   and \\<open>smaller_lits_are_false v gr_Cl_C2 S\\<close> and assms(9) and \\<open>orient_lit_inst L2 lhs rhs pos \\<eta>\\<close>\n   and \\<open>maximal_literal gr_L2 gr_Cl_C2\\<close> \n   and \\<open>ground_clause gr_Cl_C2\\<close>\n   and \\<open>gr_L2 \\<in> gr_Cl_C2\\<close> and \\<open>v = subst lhs \\<eta>\\<close> \\<open>gr_rhs = subst rhs \\<eta>\\<close>\n   and \\<open>trm_rep v S = trm_rep gr_rhs S\\<close>"], ["proof (chain)\npicking this:\n  \\<not> equivalent_eq_exists lhs rhs Cl_C2\n          (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\n  gr_L2 = subst_lit L2 \\<eta>\n  smaller_lits_are_false v gr_Cl_C2 S\n  fo_interpretation (same_values (\\<lambda>t. trm_rep t S))\n  orient_lit_inst L2 lhs rhs pos \\<eta>\n  maximal_literal gr_L2 gr_Cl_C2\n  ground_clause gr_Cl_C2\n  gr_L2 \\<in> gr_Cl_C2\n  v = lhs \\<lhd> \\<eta>\n  gr_rhs = rhs \\<lhd> \\<eta>\n  trm_rep v S = trm_rep gr_rhs S", "have \"(\\<not> validate_ground_clause ?I (subst_cl ( Cl_C2 - { L2 } ) \\<eta>))\""], ["proof (prove)\nusing this:\n  \\<not> equivalent_eq_exists lhs rhs Cl_C2\n          (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\n  gr_L2 = subst_lit L2 \\<eta>\n  smaller_lits_are_false v gr_Cl_C2 S\n  fo_interpretation (same_values (\\<lambda>t. trm_rep t S))\n  orient_lit_inst L2 lhs rhs pos \\<eta>\n  maximal_literal gr_L2 gr_Cl_C2\n  ground_clause gr_Cl_C2\n  gr_L2 \\<in> gr_Cl_C2\n  v = lhs \\<lhd> \\<eta>\n  gr_rhs = rhs \\<lhd> \\<eta>\n  trm_rep v S = trm_rep gr_rhs S\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n            (subst_cl (Cl_C2 - {L2}) \\<eta>)", "using if_all_smaller_are_false_then_cl_not_valid [of lhs \\<eta> \"Cl_C2\" S L2 rhs]"], ["proof (prove)\nusing this:\n  \\<not> equivalent_eq_exists lhs rhs Cl_C2\n          (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\n  gr_L2 = subst_lit L2 \\<eta>\n  smaller_lits_are_false v gr_Cl_C2 S\n  fo_interpretation (same_values (\\<lambda>t. trm_rep t S))\n  orient_lit_inst L2 lhs rhs pos \\<eta>\n  maximal_literal gr_L2 gr_Cl_C2\n  ground_clause gr_Cl_C2\n  gr_L2 \\<in> gr_Cl_C2\n  v = lhs \\<lhd> \\<eta>\n  gr_rhs = rhs \\<lhd> \\<eta>\n  trm_rep v S = trm_rep gr_rhs S\n  \\<lbrakk>smaller_lits_are_false (lhs \\<lhd> \\<eta>)\n            (subst_cl Cl_C2 \\<eta>) S;\n   fo_interpretation (same_values (\\<lambda>t. trm_rep t S));\n   orient_lit_inst L2 lhs rhs pos \\<eta>;\n   maximal_literal (subst_lit L2 \\<eta>) (subst_cl Cl_C2 \\<eta>);\n   ground_clause (subst_cl Cl_C2 \\<eta>);\n   subst_lit L2 \\<eta> \\<in> subst_cl Cl_C2 \\<eta>;\n   \\<not> equivalent_eq_exists lhs rhs Cl_C2\n           (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2;\n   trm_rep (lhs \\<lhd> \\<eta>) S = trm_rep (rhs \\<lhd> \\<eta>) S\\<rbrakk>\n  \\<Longrightarrow> \\<not> validate_ground_clause\n                            (same_values (\\<lambda>t. trm_rep t S))\n                            (subst_cl (Cl_C2 - {L2}) \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n            (subst_cl (Cl_C2 - {L2}) \\<eta>)", "by blast"], ["proof (state)\nthis:\n  \\<not> validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n          (subst_cl (Cl_C2 - {L2}) \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "text \\<open>We fuse the substitutions @{term \"\\<sigma>\"} and @{term \"\\<eta>\"} so that the superposition rule \ncan be applied:\\<close>"], ["proof (state)\nthis:\n  \\<not> validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n          (subst_cl (Cl_C2 - {L2}) \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>ground_clause (subst_cl (cl_ecl C) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)", "have \"ground_on (vars_of_cl (cl_ecl C)) \\<sigma>\""], ["proof (prove)\nusing this:\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. ground_on (vars_of_cl (cl_ecl C)) \\<sigma>", "using ground_clauses_and_ground_substs"], ["proof (prove)\nusing this:\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n  ground_clause (subst_cl ?C ?\\<sigma>) \\<Longrightarrow>\n  ground_on (vars_of_cl ?C) ?\\<sigma>\n\ngoal (1 subgoal):\n 1. ground_on (vars_of_cl (cl_ecl C)) \\<sigma>", "by auto"], ["proof (state)\nthis:\n  ground_on (vars_of_cl (cl_ecl C)) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>finite (vars_of_cl (cl_ecl C))\\<close> \\<open>(vars_of_cl (cl_ecl C) \\<inter> vars_of_cl (cl_ecl C2)) = {}\\<close>\n    \\<open>ground_on (vars_of_cl (cl_ecl C)) \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  finite (vars_of_cl (cl_ecl C))\n  vars_of_cl (cl_ecl C) \\<inter> vars_of_cl (cl_ecl C2) = {}\n  ground_on (vars_of_cl (cl_ecl C)) \\<sigma>", "obtain \\<sigma>' where\n      \"coincide_on \\<sigma>' \\<sigma> (vars_of_cl (cl_ecl C))\" and \"coincide_on \\<sigma>' \\<eta> (vars_of_cl (cl_ecl C2))\""], ["proof (prove)\nusing this:\n  finite (vars_of_cl (cl_ecl C))\n  vars_of_cl (cl_ecl C) \\<inter> vars_of_cl (cl_ecl C2) = {}\n  ground_on (vars_of_cl (cl_ecl C)) \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>'.\n        \\<lbrakk>coincide_on \\<sigma>' \\<sigma> (vars_of_cl (cl_ecl C));\n         coincide_on \\<sigma>' \\<eta> (vars_of_cl (cl_ecl C2))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using combine_substs [of \"(vars_of_cl (cl_ecl C))\" \"(vars_of_cl (cl_ecl C2))\" \\<sigma> \\<eta>]"], ["proof (prove)\nusing this:\n  finite (vars_of_cl (cl_ecl C))\n  vars_of_cl (cl_ecl C) \\<inter> vars_of_cl (cl_ecl C2) = {}\n  ground_on (vars_of_cl (cl_ecl C)) \\<sigma>\n  \\<lbrakk>finite (vars_of_cl (cl_ecl C));\n   vars_of_cl (cl_ecl C) \\<inter> vars_of_cl (cl_ecl C2) = {};\n   ground_on (vars_of_cl (cl_ecl C)) \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<sigma>'.\n                       coincide_on \\<sigma>' \\<sigma>\n                        (vars_of_cl (cl_ecl C)) \\<and>\n                       coincide_on \\<sigma>' \\<eta> (vars_of_cl (cl_ecl C2))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>'.\n        \\<lbrakk>coincide_on \\<sigma>' \\<sigma> (vars_of_cl (cl_ecl C));\n         coincide_on \\<sigma>' \\<eta> (vars_of_cl (cl_ecl C2))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  coincide_on \\<sigma>' \\<sigma> (vars_of_cl (cl_ecl C))\n  coincide_on \\<sigma>' \\<eta> (vars_of_cl (cl_ecl C2))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>coincide_on \\<sigma>' \\<sigma> (vars_of_cl (cl_ecl C))\\<close>"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma>' \\<sigma> (vars_of_cl (cl_ecl C))", "have \"coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\""], ["proof (prove)\nusing this:\n  coincide_on \\<sigma>' \\<sigma> (vars_of_cl (cl_ecl C))\n\ngoal (1 subgoal):\n 1. coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))", "using coincide_sym"], ["proof (prove)\nusing this:\n  coincide_on \\<sigma>' \\<sigma> (vars_of_cl (cl_ecl C))\n  coincide_on ?\\<sigma> ?\\<eta> ?V \\<Longrightarrow>\n  coincide_on ?\\<eta> ?\\<sigma> ?V\n\ngoal (1 subgoal):\n 1. coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))", "by auto"], ["proof (state)\nthis:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>coincide_on \\<sigma>' \\<eta> (vars_of_cl (cl_ecl C2))\\<close>"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma>' \\<eta> (vars_of_cl (cl_ecl C2))", "have \"coincide_on \\<eta> \\<sigma>' (vars_of_cl (cl_ecl C2))\""], ["proof (prove)\nusing this:\n  coincide_on \\<sigma>' \\<eta> (vars_of_cl (cl_ecl C2))\n\ngoal (1 subgoal):\n 1. coincide_on \\<eta> \\<sigma>' (vars_of_cl (cl_ecl C2))", "using coincide_sym"], ["proof (prove)\nusing this:\n  coincide_on \\<sigma>' \\<eta> (vars_of_cl (cl_ecl C2))\n  coincide_on ?\\<sigma> ?\\<eta> ?V \\<Longrightarrow>\n  coincide_on ?\\<eta> ?\\<sigma> ?V\n\ngoal (1 subgoal):\n 1. coincide_on \\<eta> \\<sigma>' (vars_of_cl (cl_ecl C2))", "by auto"], ["proof (state)\nthis:\n  coincide_on \\<eta> \\<sigma>' (vars_of_cl (cl_ecl C2))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>eligible_literal L1 C \\<sigma>\\<close> \\<open>L1 \\<in> (cl_ecl C)\\<close> \\<open>coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\\<close>"], ["proof (chain)\npicking this:\n  eligible_literal L1 C \\<sigma>\n  L1 \\<in> cl_ecl C\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))", "have \"eligible_literal L1 C \\<sigma>'\""], ["proof (prove)\nusing this:\n  eligible_literal L1 C \\<sigma>\n  L1 \\<in> cl_ecl C\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\n\ngoal (1 subgoal):\n 1. eligible_literal L1 C \\<sigma>'", "using eligible_literal_coincide"], ["proof (prove)\nusing this:\n  eligible_literal L1 C \\<sigma>\n  L1 \\<in> cl_ecl C\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\n  \\<lbrakk>coincide_on ?\\<sigma> ?\\<sigma>' (vars_of_cl (cl_ecl ?C));\n   eligible_literal ?L ?C ?\\<sigma>; ?L \\<in> cl_ecl ?C\\<rbrakk>\n  \\<Longrightarrow> eligible_literal ?L ?C ?\\<sigma>'\n\ngoal (1 subgoal):\n 1. eligible_literal L1 C \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  eligible_literal L1 C \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>eligible_literal L2 C2 \\<eta>\\<close> \\<open>L2 \\<in> Cl_C2\\<close> \\<open>Cl_C2 = (cl_ecl C2)\\<close> \\<open>coincide_on \\<eta> \\<sigma>' \n          (vars_of_cl (cl_ecl C2))\\<close>"], ["proof (chain)\npicking this:\n  eligible_literal L2 C2 \\<eta>\n  L2 \\<in> Cl_C2\n  Cl_C2 = cl_ecl C2\n  coincide_on \\<eta> \\<sigma>' (vars_of_cl (cl_ecl C2))", "have \"eligible_literal L2 C2 \\<sigma>'\""], ["proof (prove)\nusing this:\n  eligible_literal L2 C2 \\<eta>\n  L2 \\<in> Cl_C2\n  Cl_C2 = cl_ecl C2\n  coincide_on \\<eta> \\<sigma>' (vars_of_cl (cl_ecl C2))\n\ngoal (1 subgoal):\n 1. eligible_literal L2 C2 \\<sigma>'", "using eligible_literal_coincide"], ["proof (prove)\nusing this:\n  eligible_literal L2 C2 \\<eta>\n  L2 \\<in> Cl_C2\n  Cl_C2 = cl_ecl C2\n  coincide_on \\<eta> \\<sigma>' (vars_of_cl (cl_ecl C2))\n  \\<lbrakk>coincide_on ?\\<sigma> ?\\<sigma>' (vars_of_cl (cl_ecl ?C));\n   eligible_literal ?L ?C ?\\<sigma>; ?L \\<in> cl_ecl ?C\\<rbrakk>\n  \\<Longrightarrow> eligible_literal ?L ?C ?\\<sigma>'\n\ngoal (1 subgoal):\n 1. eligible_literal L2 C2 \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  eligible_literal L2 C2 \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>ground_clause gr_Cl_C2\\<close> and \\<open>gr_Cl_C2 = (subst_cl Cl_C2 \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  ground_clause gr_Cl_C2\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>", "have \"ground_clause (subst_cl Cl_C2 \\<sigma>')\""], ["proof (prove)\nusing this:\n  ground_clause gr_Cl_C2\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\n\ngoal (1 subgoal):\n 1. ground_clause (subst_cl Cl_C2 \\<sigma>')", "by (metis \\<open>Cl_C2 = cl_ecl C2\\<close> \\<open>coincide_on \\<sigma>' \\<eta> (vars_of_cl (cl_ecl C2))\\<close> coincide_on_cl)"], ["proof (state)\nthis:\n  ground_clause (subst_cl Cl_C2 \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\\<close> \\<open>L1 \\<in> (cl_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\n  L1 \\<in> cl_ecl C", "have\n      \"coincide_on \\<sigma> \\<sigma>' (vars_of_lit L1)\""], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\n  L1 \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. coincide_on \\<sigma> \\<sigma>' (vars_of_lit L1)", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>vars_of_cl (cl_ecl C).\n     Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<sigma>'\n  L1 \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of_lit L1.\n       Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_lit L1)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>coincide_on \\<eta> \\<sigma>' (vars_of_cl (cl_ecl C2))\\<close> \\<open>L2 \\<in> Cl_C2\\<close> and \\<open>Cl_C2 = (cl_ecl C2)\\<close>"], ["proof (chain)\npicking this:\n  coincide_on \\<eta> \\<sigma>' (vars_of_cl (cl_ecl C2))\n  L2 \\<in> Cl_C2\n  Cl_C2 = cl_ecl C2", "have \"coincide_on \\<eta> \\<sigma>' (vars_of_lit L2)\""], ["proof (prove)\nusing this:\n  coincide_on \\<eta> \\<sigma>' (vars_of_cl (cl_ecl C2))\n  L2 \\<in> Cl_C2\n  Cl_C2 = cl_ecl C2\n\ngoal (1 subgoal):\n 1. coincide_on \\<eta> \\<sigma>' (vars_of_lit L2)", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>vars_of_cl (cl_ecl C2).\n     Var x \\<lhd> \\<eta> = Var x \\<lhd> \\<sigma>'\n  L2 \\<in> Cl_C2\n  Cl_C2 = cl_ecl C2\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of_lit L2.\n       Var x \\<lhd> \\<eta> = Var x \\<lhd> \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  coincide_on \\<eta> \\<sigma>' (vars_of_lit L2)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>(orient_lit_inst L1 t s polarity \\<sigma>)\\<close> and  \\<open>coincide_on \\<sigma> \\<sigma>' (vars_of_lit L1)\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L1 t s polarity \\<sigma>\n  coincide_on \\<sigma> \\<sigma>' (vars_of_lit L1)", "have \"(orient_lit_inst L1 t s polarity \\<sigma>')\""], ["proof (prove)\nusing this:\n  orient_lit_inst L1 t s polarity \\<sigma>\n  coincide_on \\<sigma> \\<sigma>' (vars_of_lit L1)\n\ngoal (1 subgoal):\n 1. orient_lit_inst L1 t s polarity \\<sigma>'", "using orient_lit_inst_coincide [of L1 t s polarity \\<sigma> \\<sigma>']"], ["proof (prove)\nusing this:\n  orient_lit_inst L1 t s polarity \\<sigma>\n  coincide_on \\<sigma> \\<sigma>' (vars_of_lit L1)\n  \\<lbrakk>orient_lit_inst L1 t s polarity \\<sigma>;\n   coincide_on \\<sigma> \\<sigma>' (vars_of_lit L1)\\<rbrakk>\n  \\<Longrightarrow> orient_lit_inst L1 t s polarity \\<sigma>'\n\ngoal (1 subgoal):\n 1. orient_lit_inst L1 t s polarity \\<sigma>'", "by blast"], ["proof (state)\nthis:\n  orient_lit_inst L1 t s polarity \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>(orient_lit_inst L2 lhs rhs pos \\<eta>)\\<close> and  \\<open>coincide_on \\<eta> \\<sigma>' (vars_of_lit L2)\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L2 lhs rhs pos \\<eta>\n  coincide_on \\<eta> \\<sigma>' (vars_of_lit L2)", "have \"(orient_lit_inst L2 lhs rhs pos \\<sigma>')\""], ["proof (prove)\nusing this:\n  orient_lit_inst L2 lhs rhs pos \\<eta>\n  coincide_on \\<eta> \\<sigma>' (vars_of_lit L2)\n\ngoal (1 subgoal):\n 1. orient_lit_inst L2 lhs rhs pos \\<sigma>'", "using orient_lit_inst_coincide"], ["proof (prove)\nusing this:\n  orient_lit_inst L2 lhs rhs pos \\<eta>\n  coincide_on \\<eta> \\<sigma>' (vars_of_lit L2)\n  \\<lbrakk>orient_lit_inst ?L1.0 ?t ?s ?polarity ?\\<sigma>;\n   coincide_on ?\\<sigma> ?\\<eta> (vars_of_lit ?L1.0)\\<rbrakk>\n  \\<Longrightarrow> orient_lit_inst ?L1.0 ?t ?s ?polarity ?\\<eta>\n\ngoal (1 subgoal):\n 1. orient_lit_inst L2 lhs rhs pos \\<sigma>'", "by blast"], ["proof (state)\nthis:\n  orient_lit_inst L2 lhs rhs pos \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "text \\<open>To prove that the superposition rule is applicable, we need to show that @{term \"v\"}\ndoes not occur inside a variable:\\<close>"], ["proof (state)\nthis:\n  orient_lit_inst L2 lhs rhs pos \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "have \"\\<not>(\\<exists>x q1 q2. (is_a_variable x) \\<and> (subterm (subst x \\<sigma>) q1 v) \\<and> \n                      (subterm t q2 x) \\<and> (p = (append q2 q1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>x q1 q2.\n       is_a_variable x \\<and>\n       subterm (x \\<lhd> \\<sigma>) q1 v \\<and>\n       subterm t q2 x \\<and> p = q2 @ q1", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x q1 q2.\n       is_a_variable x \\<and>\n       subterm (x \\<lhd> \\<sigma>) q1 v \\<and>\n       subterm t q2 x \\<and> p = q2 @ q1 \\<Longrightarrow>\n    False", "assume \"(\\<exists>x q1 q2. (is_a_variable x) \\<and> (subterm (subst x \\<sigma>) q1 v) \\<and> \n                      (subterm t q2 x) \\<and> (p = (append q2 q1)))\""], ["proof (state)\nthis:\n  \\<exists>x q1 q2.\n     is_a_variable x \\<and>\n     subterm (x \\<lhd> \\<sigma>) q1 v \\<and>\n     subterm t q2 x \\<and> p = q2 @ q1\n\ngoal (1 subgoal):\n 1. \\<exists>x q1 q2.\n       is_a_variable x \\<and>\n       subterm (x \\<lhd> \\<sigma>) q1 v \\<and>\n       subterm t q2 x \\<and> p = q2 @ q1 \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>x q1 q2.\n     is_a_variable x \\<and>\n     subterm (x \\<lhd> \\<sigma>) q1 v \\<and>\n     subterm t q2 x \\<and> p = q2 @ q1", "obtain x q1 q2 where \"is_a_variable x\" \"subterm (subst x \\<sigma>) q1 v\" \n      \"(subterm (subst x \\<sigma>) q1 v)\" \"(subterm t q2 x)\""], ["proof (prove)\nusing this:\n  \\<exists>x q1 q2.\n     is_a_variable x \\<and>\n     subterm (x \\<lhd> \\<sigma>) q1 v \\<and>\n     subterm t q2 x \\<and> p = q2 @ q1\n\ngoal (1 subgoal):\n 1. (\\<And>x q1 q2.\n        \\<lbrakk>is_a_variable x; subterm (x \\<lhd> \\<sigma>) q1 v;\n         subterm (x \\<lhd> \\<sigma>) q1 v; subterm t q2 x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_a_variable x\n  subterm (x \\<lhd> \\<sigma>) q1 v\n  subterm (x \\<lhd> \\<sigma>) q1 v\n  subterm t q2 x\n\ngoal (1 subgoal):\n 1. \\<exists>x q1 q2.\n       is_a_variable x \\<and>\n       subterm (x \\<lhd> \\<sigma>) q1 v \\<and>\n       subterm t q2 x \\<and> p = q2 @ q1 \\<Longrightarrow>\n    False", "from \\<open>(subterm (subst x \\<sigma>) q1 v)\\<close>"], ["proof (chain)\npicking this:\n  subterm (x \\<lhd> \\<sigma>) q1 v", "have \"occurs_in v (subst x \\<sigma>)\""], ["proof (prove)\nusing this:\n  subterm (x \\<lhd> \\<sigma>) q1 v\n\ngoal (1 subgoal):\n 1. occurs_in v (x \\<lhd> \\<sigma>)", "unfolding occurs_in_def"], ["proof (prove)\nusing this:\n  subterm (x \\<lhd> \\<sigma>) q1 v\n\ngoal (1 subgoal):\n 1. \\<exists>p. subterm (x \\<lhd> \\<sigma>) p v", "by auto"], ["proof (state)\nthis:\n  occurs_in v (x \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>x q1 q2.\n       is_a_variable x \\<and>\n       subterm (x \\<lhd> \\<sigma>) q1 v \\<and>\n       subterm t q2 x \\<and> p = q2 @ q1 \\<Longrightarrow>\n    False", "from \\<open>is_a_variable x\\<close>"], ["proof (chain)\npicking this:\n  is_a_variable x", "obtain x' where \"x = Var x'\""], ["proof (prove)\nusing this:\n  is_a_variable x\n\ngoal (1 subgoal):\n 1. (\\<And>x'. x = Var x' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using is_a_variable.elims(2)"], ["proof (prove)\nusing this:\n  is_a_variable x\n  \\<lbrakk>is_a_variable ?x;\n   \\<And>x. ?x = Var x \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>x'. x = Var x' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  x = Var x'\n\ngoal (1 subgoal):\n 1. \\<exists>x q1 q2.\n       is_a_variable x \\<and>\n       subterm (x \\<lhd> \\<sigma>) q1 v \\<and>\n       subterm t q2 x \\<and> p = q2 @ q1 \\<Longrightarrow>\n    False", "from \\<open>subterm t q2 x\\<close>"], ["proof (chain)\npicking this:\n  subterm t q2 x", "have \"x \\<in> subterms_of t\""], ["proof (prove)\nusing this:\n  subterm t q2 x\n\ngoal (1 subgoal):\n 1. x \\<in> subterms_of t", "using subterms_of.simps"], ["proof (prove)\nusing this:\n  subterm t q2 x\n  subterms_of ?t = {s. occurs_in s ?t}\n\ngoal (1 subgoal):\n 1. x \\<in> subterms_of t", "unfolding  occurs_in_def"], ["proof (prove)\nusing this:\n  subterm t q2 x\n  subterms_of ?t = {s. \\<exists>p. subterm ?t p s}\n\ngoal (1 subgoal):\n 1. x \\<in> subterms_of t", "by blast"], ["proof (state)\nthis:\n  x \\<in> subterms_of t\n\ngoal (1 subgoal):\n 1. \\<exists>x q1 q2.\n       is_a_variable x \\<and>\n       subterm (x \\<lhd> \\<sigma>) q1 v \\<and>\n       subterm t q2 x \\<and> p = q2 @ q1 \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  x \\<in> subterms_of t", "have \"x \\<in> subterms_of_lit L1\""], ["proof (prove)\nusing this:\n  x \\<in> subterms_of t\n\ngoal (1 subgoal):\n 1. x \\<in> subterms_of_lit L1", "using assms(6)"], ["proof (prove)\nusing this:\n  x \\<in> subterms_of t\n  orient_lit_inst L1 t s polarity \\<sigma>\n\ngoal (1 subgoal):\n 1. x \\<in> subterms_of_lit L1", "by (simp add: orient_lit_inst_subterms)"], ["proof (state)\nthis:\n  x \\<in> subterms_of_lit L1\n\ngoal (1 subgoal):\n 1. \\<exists>x q1 q2.\n       is_a_variable x \\<and>\n       subterm (x \\<lhd> \\<sigma>) q1 v \\<and>\n       subterm t q2 x \\<and> p = q2 @ q1 \\<Longrightarrow>\n    False", "from this \\<open>L1 \\<in> (cl_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> subterms_of_lit L1\n  L1 \\<in> cl_ecl C", "have \"x \\<in> subterms_of_cl (cl_ecl C)\""], ["proof (prove)\nusing this:\n  x \\<in> subterms_of_lit L1\n  L1 \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. x \\<in> subterms_of_cl (cl_ecl C)", "by auto"], ["proof (state)\nthis:\n  x \\<in> subterms_of_cl (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<exists>x q1 q2.\n       is_a_variable x \\<and>\n       subterm (x \\<lhd> \\<sigma>) q1 v \\<and>\n       subterm t q2 x \\<and> p = q2 @ q1 \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  x \\<in> subterms_of_cl (cl_ecl C)", "have \"vars_of x \\<subseteq> vars_of_cl (cl_ecl C)\""], ["proof (prove)\nusing this:\n  x \\<in> subterms_of_cl (cl_ecl C)\n\ngoal (1 subgoal):\n 1. vars_of x \\<subseteq> vars_of_cl (cl_ecl C)", "using subterm_vars"], ["proof (prove)\nusing this:\n  x \\<in> subterms_of_cl (cl_ecl C)\n  ?u \\<in> subterms_of_cl ?C \\<Longrightarrow>\n  vars_of ?u \\<subseteq> vars_of_cl ?C\n\ngoal (1 subgoal):\n 1. vars_of x \\<subseteq> vars_of_cl (cl_ecl C)", "by blast"], ["proof (state)\nthis:\n  vars_of x \\<subseteq> vars_of_cl (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<exists>x q1 q2.\n       is_a_variable x \\<and>\n       subterm (x \\<lhd> \\<sigma>) q1 v \\<and>\n       subterm t q2 x \\<and> p = q2 @ q1 \\<Longrightarrow>\n    False", "from this and \\<open>x = (Var x')\\<close>"], ["proof (chain)\npicking this:\n  vars_of x \\<subseteq> vars_of_cl (cl_ecl C)\n  x = Var x'", "have \"x' \\<in> vars_of_cl (cl_ecl C)\""], ["proof (prove)\nusing this:\n  vars_of x \\<subseteq> vars_of_cl (cl_ecl C)\n  x = Var x'\n\ngoal (1 subgoal):\n 1. x' \\<in> vars_of_cl (cl_ecl C)", "by auto"], ["proof (state)\nthis:\n  x' \\<in> vars_of_cl (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<exists>x q1 q2.\n       is_a_variable x \\<and>\n       subterm (x \\<lhd> \\<sigma>) q1 v \\<and>\n       subterm t q2 x \\<and> p = q2 @ q1 \\<Longrightarrow>\n    False", "from \\<open>x' \\<in> vars_of_cl (cl_ecl C)\\<close> \\<open>occurs_in v (subst x \\<sigma>)\\<close> \n      \\<open>x = Var x'\\<close> assms(2)"], ["proof (chain)\npicking this:\n  x' \\<in> vars_of_cl (cl_ecl C)\n  occurs_in v (x \\<lhd> \\<sigma>)\n  x = Var x'\n  \\<forall>x y.\n     x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n     occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow> trm_rep y S = y", "have \"trm_rep v S = v\""], ["proof (prove)\nusing this:\n  x' \\<in> vars_of_cl (cl_ecl C)\n  occurs_in v (x \\<lhd> \\<sigma>)\n  x = Var x'\n  \\<forall>x y.\n     x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n     occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow> trm_rep y S = y\n\ngoal (1 subgoal):\n 1. trm_rep v S = v", "by blast"], ["proof (state)\nthis:\n  trm_rep v S = v\n\ngoal (1 subgoal):\n 1. \\<exists>x q1 q2.\n       is_a_variable x \\<and>\n       subterm (x \\<lhd> \\<sigma>) q1 v \\<and>\n       subterm t q2 x \\<and> p = q2 @ q1 \\<Longrightarrow>\n    False", "from this and \\<open>trm_rep v S \\<noteq> v\\<close>"], ["proof (chain)\npicking this:\n  trm_rep v S = v\n  trm_rep v S \\<noteq> v", "show False"], ["proof (prove)\nusing this:\n  trm_rep v S = v\n  trm_rep v S \\<noteq> v\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>x q1 q2.\n     is_a_variable x \\<and>\n     subterm (x \\<lhd> \\<sigma>) q1 v \\<and>\n     subterm t q2 x \\<and> p = q2 @ q1\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from this and si"], ["proof (chain)\npicking this:\n  \\<nexists>x q1 q2.\n     is_a_variable x \\<and>\n     subterm (x \\<lhd> \\<sigma>) q1 v \\<and>\n     subterm t q2 x \\<and> p = q2 @ q1\n  (\\<exists>x q1 q2.\n      is_a_variable x \\<and>\n      subterm (x \\<lhd> \\<sigma>) q1 v \\<and>\n      subterm t q2 x \\<and> p = q2 @ q1) \\<or>\n  (\\<exists>u.\n      \\<not> is_a_variable u \\<and>\n      subterm t p u \\<and> v = u \\<lhd> \\<sigma>)", "obtain u where \"\\<not> (is_a_variable u)\" \"(subterm t p u)\" and \"v = (subst u \\<sigma>)\""], ["proof (prove)\nusing this:\n  \\<nexists>x q1 q2.\n     is_a_variable x \\<and>\n     subterm (x \\<lhd> \\<sigma>) q1 v \\<and>\n     subterm t q2 x \\<and> p = q2 @ q1\n  (\\<exists>x q1 q2.\n      is_a_variable x \\<and>\n      subterm (x \\<lhd> \\<sigma>) q1 v \\<and>\n      subterm t q2 x \\<and> p = q2 @ q1) \\<or>\n  (\\<exists>u.\n      \\<not> is_a_variable u \\<and>\n      subterm t p u \\<and> v = u \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>\\<not> is_a_variable u; subterm t p u;\n         v = u \\<lhd> \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<not> is_a_variable u\n  subterm t p u\n  v = u \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>orient_lit_inst L1 t s polarity \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L1 t s polarity \\<sigma>", "have \"vars_of t \\<subseteq> vars_of_lit L1\""], ["proof (prove)\nusing this:\n  orient_lit_inst L1 t s polarity \\<sigma>\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L1", "using orient_lit_inst_vars"], ["proof (prove)\nusing this:\n  orient_lit_inst L1 t s polarity \\<sigma>\n  orient_lit_inst ?L ?t ?s ?p ?\\<sigma> \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L1", "by auto"], ["proof (state)\nthis:\n  vars_of t \\<subseteq> vars_of_lit L1\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>subterm t p u\\<close>"], ["proof (chain)\npicking this:\n  subterm t p u", "have \"vars_of u \\<subseteq> vars_of t\""], ["proof (prove)\nusing this:\n  subterm t p u\n\ngoal (1 subgoal):\n 1. vars_of u \\<subseteq> vars_of t", "using vars_subterm"], ["proof (prove)\nusing this:\n  subterm t p u\n  subterm ?t ?p ?s \\<Longrightarrow> vars_of ?s \\<subseteq> vars_of ?t\n\ngoal (1 subgoal):\n 1. vars_of u \\<subseteq> vars_of t", "by auto"], ["proof (state)\nthis:\n  vars_of u \\<subseteq> vars_of t\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>vars_of t \\<subseteq> vars_of_lit L1\\<close> \\<open>vars_of u \\<subseteq> vars_of t\\<close> \\<open>coincide_on \\<sigma> \\<sigma>' (vars_of_lit L1)\\<close>"], ["proof (chain)\npicking this:\n  vars_of t \\<subseteq> vars_of_lit L1\n  vars_of u \\<subseteq> vars_of t\n  coincide_on \\<sigma> \\<sigma>' (vars_of_lit L1)", "have \"coincide_on \\<sigma> \\<sigma>' (vars_of u)\""], ["proof (prove)\nusing this:\n  vars_of t \\<subseteq> vars_of_lit L1\n  vars_of u \\<subseteq> vars_of t\n  coincide_on \\<sigma> \\<sigma>' (vars_of_lit L1)\n\ngoal (1 subgoal):\n 1. coincide_on \\<sigma> \\<sigma>' (vars_of u)", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  vars_of t \\<subseteq> vars_of_lit L1\n  vars_of u \\<subseteq> vars_of t\n  \\<forall>x\\<in>vars_of_lit L1.\n     Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of u. Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<sigma>'", "by blast"], ["proof (state)\nthis:\n  coincide_on \\<sigma> \\<sigma>' (vars_of u)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from this"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of u)", "have \"subst u \\<sigma> = subst u \\<sigma>'\""], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of u)\n\ngoal (1 subgoal):\n 1. u \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>'", "using coincide_on_term"], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of u)\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of ?t) \\<Longrightarrow>\n  ?t \\<lhd> ?\\<sigma> = ?t \\<lhd> ?\\<eta>\n\ngoal (1 subgoal):\n 1. u \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  u \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>orient_lit_inst L2 lhs rhs pos \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L2 lhs rhs pos \\<eta>", "have \"vars_of lhs \\<subseteq> vars_of_lit L2\" \n      and \"vars_of rhs \\<subseteq> vars_of_lit L2\""], ["proof (prove)\nusing this:\n  orient_lit_inst L2 lhs rhs pos \\<eta>\n\ngoal (1 subgoal):\n 1. vars_of lhs \\<subseteq> vars_of_lit L2 &&&\n    vars_of rhs \\<subseteq> vars_of_lit L2", "using orient_lit_inst_vars"], ["proof (prove)\nusing this:\n  orient_lit_inst L2 lhs rhs pos \\<eta>\n  orient_lit_inst ?L ?t ?s ?p ?\\<sigma> \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of lhs \\<subseteq> vars_of_lit L2 &&&\n    vars_of rhs \\<subseteq> vars_of_lit L2", "by auto"], ["proof (state)\nthis:\n  vars_of lhs \\<subseteq> vars_of_lit L2\n  vars_of rhs \\<subseteq> vars_of_lit L2\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>vars_of lhs \\<subseteq> vars_of_lit L2\\<close> \\<open>coincide_on \\<eta> \\<sigma>' (vars_of_lit L2)\\<close>"], ["proof (chain)\npicking this:\n  vars_of lhs \\<subseteq> vars_of_lit L2\n  coincide_on \\<eta> \\<sigma>' (vars_of_lit L2)", "have \"coincide_on \\<eta> \\<sigma>' (vars_of lhs)\""], ["proof (prove)\nusing this:\n  vars_of lhs \\<subseteq> vars_of_lit L2\n  coincide_on \\<eta> \\<sigma>' (vars_of_lit L2)\n\ngoal (1 subgoal):\n 1. coincide_on \\<eta> \\<sigma>' (vars_of lhs)", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  vars_of lhs \\<subseteq> vars_of_lit L2\n  \\<forall>x\\<in>vars_of_lit L2.\n     Var x \\<lhd> \\<eta> = Var x \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of lhs. Var x \\<lhd> \\<eta> = Var x \\<lhd> \\<sigma>'", "by blast"], ["proof (state)\nthis:\n  coincide_on \\<eta> \\<sigma>' (vars_of lhs)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from this"], ["proof (chain)\npicking this:\n  coincide_on \\<eta> \\<sigma>' (vars_of lhs)", "have \"subst lhs \\<eta> = subst lhs \\<sigma>'\""], ["proof (prove)\nusing this:\n  coincide_on \\<eta> \\<sigma>' (vars_of lhs)\n\ngoal (1 subgoal):\n 1. lhs \\<lhd> \\<eta> = lhs \\<lhd> \\<sigma>'", "using coincide_on_term"], ["proof (prove)\nusing this:\n  coincide_on \\<eta> \\<sigma>' (vars_of lhs)\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of ?t) \\<Longrightarrow>\n  ?t \\<lhd> ?\\<sigma> = ?t \\<lhd> ?\\<eta>\n\ngoal (1 subgoal):\n 1. lhs \\<lhd> \\<eta> = lhs \\<lhd> \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  lhs \\<lhd> \\<eta> = lhs \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>vars_of rhs \\<subseteq> vars_of_lit L2\\<close> \\<open>coincide_on \\<eta> \\<sigma>' (vars_of_lit L2)\\<close>"], ["proof (chain)\npicking this:\n  vars_of rhs \\<subseteq> vars_of_lit L2\n  coincide_on \\<eta> \\<sigma>' (vars_of_lit L2)", "have \"coincide_on \\<eta> \\<sigma>' (vars_of rhs)\""], ["proof (prove)\nusing this:\n  vars_of rhs \\<subseteq> vars_of_lit L2\n  coincide_on \\<eta> \\<sigma>' (vars_of_lit L2)\n\ngoal (1 subgoal):\n 1. coincide_on \\<eta> \\<sigma>' (vars_of rhs)", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  vars_of rhs \\<subseteq> vars_of_lit L2\n  \\<forall>x\\<in>vars_of_lit L2.\n     Var x \\<lhd> \\<eta> = Var x \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of rhs. Var x \\<lhd> \\<eta> = Var x \\<lhd> \\<sigma>'", "by blast"], ["proof (state)\nthis:\n  coincide_on \\<eta> \\<sigma>' (vars_of rhs)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from this"], ["proof (chain)\npicking this:\n  coincide_on \\<eta> \\<sigma>' (vars_of rhs)", "have \"subst rhs \\<eta> = subst rhs \\<sigma>'\""], ["proof (prove)\nusing this:\n  coincide_on \\<eta> \\<sigma>' (vars_of rhs)\n\ngoal (1 subgoal):\n 1. rhs \\<lhd> \\<eta> = rhs \\<lhd> \\<sigma>'", "using coincide_on_term"], ["proof (prove)\nusing this:\n  coincide_on \\<eta> \\<sigma>' (vars_of rhs)\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of ?t) \\<Longrightarrow>\n  ?t \\<lhd> ?\\<sigma> = ?t \\<lhd> ?\\<eta>\n\ngoal (1 subgoal):\n 1. rhs \\<lhd> \\<eta> = rhs \\<lhd> \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  rhs \\<lhd> \\<eta> = rhs \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>trm_rep v S = trm_rep gr_rhs S\\<close> and \\<open>v= subst lhs \\<eta>\\<close> and \\<open>gr_rhs = (subst rhs \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  trm_rep v S = trm_rep gr_rhs S\n  v = lhs \\<lhd> \\<eta>\n  gr_rhs = rhs \\<lhd> \\<eta>", "have \"trm_rep (subst rhs \\<eta>) S = trm_rep (subst lhs \\<eta>) S\""], ["proof (prove)\nusing this:\n  trm_rep v S = trm_rep gr_rhs S\n  v = lhs \\<lhd> \\<eta>\n  gr_rhs = rhs \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. trm_rep (rhs \\<lhd> \\<eta>) S = trm_rep (lhs \\<lhd> \\<eta>) S", "by metis"], ["proof (state)\nthis:\n  trm_rep (rhs \\<lhd> \\<eta>) S = trm_rep (lhs \\<lhd> \\<eta>) S\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from this and \\<open>subst rhs \\<eta> = subst rhs \\<sigma>'\\<close>  \\<open>subst lhs \\<eta> = subst lhs \\<sigma>'\\<close>"], ["proof (chain)\npicking this:\n  trm_rep (rhs \\<lhd> \\<eta>) S = trm_rep (lhs \\<lhd> \\<eta>) S\n  rhs \\<lhd> \\<eta> = rhs \\<lhd> \\<sigma>'\n  lhs \\<lhd> \\<eta> = lhs \\<lhd> \\<sigma>'", "have  \"trm_rep (subst rhs \\<sigma>') S = trm_rep (subst lhs \\<sigma>') S\""], ["proof (prove)\nusing this:\n  trm_rep (rhs \\<lhd> \\<eta>) S = trm_rep (lhs \\<lhd> \\<eta>) S\n  rhs \\<lhd> \\<eta> = rhs \\<lhd> \\<sigma>'\n  lhs \\<lhd> \\<eta> = lhs \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. trm_rep (rhs \\<lhd> \\<sigma>') S = trm_rep (lhs \\<lhd> \\<sigma>') S", "by metis"], ["proof (state)\nthis:\n  trm_rep (rhs \\<lhd> \\<sigma>') S = trm_rep (lhs \\<lhd> \\<sigma>') S\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>subst lhs \\<eta> = subst lhs \\<sigma>'\\<close> \\<open>subst u \\<sigma> = subst u \\<sigma>'\\<close> \\<open>v = subst u \\<sigma>\\<close> and \\<open>v = subst lhs \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  lhs \\<lhd> \\<eta> = lhs \\<lhd> \\<sigma>'\n  u \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>'\n  v = u \\<lhd> \\<sigma>\n  v = lhs \\<lhd> \\<eta>", "have \"subst u \\<sigma>' = subst lhs \\<sigma>'\""], ["proof (prove)\nusing this:\n  lhs \\<lhd> \\<eta> = lhs \\<lhd> \\<sigma>'\n  u \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>'\n  v = u \\<lhd> \\<sigma>\n  v = lhs \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. u \\<lhd> \\<sigma>' = lhs \\<lhd> \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  u \\<lhd> \\<sigma>' = lhs \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>coincide_on \\<sigma>' \\<eta> (vars_of_cl (cl_ecl C2))\\<close> and \\<open>Cl_C2 = (cl_ecl C2)\\<close>"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma>' \\<eta> (vars_of_cl (cl_ecl C2))\n  Cl_C2 = cl_ecl C2", "have \"coincide_on \\<sigma>' \\<eta>  (vars_of_cl (Cl_C2 - { L2 }))\""], ["proof (prove)\nusing this:\n  coincide_on \\<sigma>' \\<eta> (vars_of_cl (cl_ecl C2))\n  Cl_C2 = cl_ecl C2\n\ngoal (1 subgoal):\n 1. coincide_on \\<sigma>' \\<eta> (vars_of_cl (Cl_C2 - {L2}))", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>vars_of_cl (cl_ecl C2).\n     Var x \\<lhd> \\<sigma>' = Var x \\<lhd> \\<eta>\n  Cl_C2 = cl_ecl C2\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of_cl (Cl_C2 - {L2}).\n       Var x \\<lhd> \\<sigma>' = Var x \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  coincide_on \\<sigma>' \\<eta> (vars_of_cl (Cl_C2 - {L2}))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from this and \\<open>(\\<not> validate_ground_clause ?I (subst_cl ( Cl_C2 - { L2 } ) \\<eta>))\\<close>"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma>' \\<eta> (vars_of_cl (Cl_C2 - {L2}))\n  \\<not> validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n          (subst_cl (Cl_C2 - {L2}) \\<eta>)", "have \"(\\<not> validate_ground_clause ?I (subst_cl ( Cl_C2 - { L2 } ) \\<sigma>'))\""], ["proof (prove)\nusing this:\n  coincide_on \\<sigma>' \\<eta> (vars_of_cl (Cl_C2 - {L2}))\n  \\<not> validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n          (subst_cl (Cl_C2 - {L2}) \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n            (subst_cl (Cl_C2 - {L2}) \\<sigma>')", "using coincide_on_cl"], ["proof (prove)\nusing this:\n  coincide_on \\<sigma>' \\<eta> (vars_of_cl (Cl_C2 - {L2}))\n  \\<not> validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n          (subst_cl (Cl_C2 - {L2}) \\<eta>)\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of_cl ?C) \\<Longrightarrow>\n  subst_cl ?C ?\\<sigma> = subst_cl ?C ?\\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n            (subst_cl (Cl_C2 - {L2}) \\<sigma>')", "by metis"], ["proof (state)\nthis:\n  \\<not> validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n          (subst_cl (Cl_C2 - {L2}) \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "have \"(\\<forall>x\\<in>cl_ecl C2 - {L2}. (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>cl_ecl C2 - {L2}.\n       (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cl_ecl C2 - {L2} \\<Longrightarrow>\n       (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cl_ecl C2 - {L2} \\<Longrightarrow>\n       (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord", "assume \"x \\<in>cl_ecl C2 - {L2}\""], ["proof (state)\nthis:\n  x \\<in> cl_ecl C2 - {L2}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cl_ecl C2 - {L2} \\<Longrightarrow>\n       (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord", "from \\<open>L2 \\<in> Cl_C2\\<close> and  \\<open>gr_L2 = (subst_lit L2 \\<eta>)\\<close>  \n      \\<open>gr_Cl_C2 = (subst_cl Cl_C2 \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  L2 \\<in> Cl_C2\n  gr_L2 = subst_lit L2 \\<eta>\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>", "have \"gr_L2 \\<in> gr_Cl_C2\""], ["proof (prove)\nusing this:\n  L2 \\<in> Cl_C2\n  gr_L2 = subst_lit L2 \\<eta>\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\n\ngoal (1 subgoal):\n 1. gr_L2 \\<in> gr_Cl_C2", "by auto"], ["proof (state)\nthis:\n  gr_L2 \\<in> gr_Cl_C2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cl_ecl C2 - {L2} \\<Longrightarrow>\n       (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord", "from this and \\<open>ground_clause gr_Cl_C2\\<close>"], ["proof (chain)\npicking this:\n  gr_L2 \\<in> gr_Cl_C2\n  ground_clause gr_Cl_C2", "have \"vars_of_lit gr_L2 = {}\""], ["proof (prove)\nusing this:\n  gr_L2 \\<in> gr_Cl_C2\n  ground_clause gr_Cl_C2\n\ngoal (1 subgoal):\n 1. vars_of_lit gr_L2 = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_lit gr_L2 = {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cl_ecl C2 - {L2} \\<Longrightarrow>\n       (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord", "from \\<open>x \\<in> cl_ecl C2 - {L2}\\<close> and \\<open>Cl_C2 = (cl_ecl C2)\\<close>  \\<open>gr_Cl_C2 = (subst_cl Cl_C2 \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> cl_ecl C2 - {L2}\n  Cl_C2 = cl_ecl C2\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>", "have \"(subst_lit x \\<eta>) \\<in> gr_Cl_C2\""], ["proof (prove)\nusing this:\n  x \\<in> cl_ecl C2 - {L2}\n  Cl_C2 = cl_ecl C2\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\n\ngoal (1 subgoal):\n 1. subst_lit x \\<eta> \\<in> gr_Cl_C2", "by auto"], ["proof (state)\nthis:\n  subst_lit x \\<eta> \\<in> gr_Cl_C2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cl_ecl C2 - {L2} \\<Longrightarrow>\n       (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord", "from this and \\<open>ground_clause gr_Cl_C2\\<close>"], ["proof (chain)\npicking this:\n  subst_lit x \\<eta> \\<in> gr_Cl_C2\n  ground_clause gr_Cl_C2", "have \"vars_of_lit (subst_lit x \\<eta>) = {}\""], ["proof (prove)\nusing this:\n  subst_lit x \\<eta> \\<in> gr_Cl_C2\n  ground_clause gr_Cl_C2\n\ngoal (1 subgoal):\n 1. vars_of_lit (subst_lit x \\<eta>) = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_lit (subst_lit x \\<eta>) = {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cl_ecl C2 - {L2} \\<Longrightarrow>\n       (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord", "from this \\<open>x \\<in> cl_ecl C2 - {L2}\\<close> \\<open>maximal_literal gr_L2 gr_Cl_C2\\<close> \\<open>Cl_C2 = cl_ecl C2\\<close> \n    \\<open>gr_L2 = (subst_lit L2 \\<eta>)\\<close>  \n    \\<open>gr_Cl_C2 = (subst_cl Cl_C2 \\<eta>)\\<close> \\<open>orient_lit_inst L2 lhs rhs pos \\<eta>\\<close> no_fact assms(9)\n    \\<open>vars_of_lit gr_L2 = {}\\<close> \\<open>vars_of_lit (subst_lit x \\<eta>) = {}\\<close>"], ["proof (chain)\npicking this:\n  vars_of_lit (subst_lit x \\<eta>) = {}\n  x \\<in> cl_ecl C2 - {L2}\n  maximal_literal gr_L2 gr_Cl_C2\n  Cl_C2 = cl_ecl C2\n  gr_L2 = subst_lit L2 \\<eta>\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\n  orient_lit_inst L2 lhs rhs pos \\<eta>\n  \\<not> equivalent_eq_exists lhs rhs Cl_C2\n          (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2\n  fo_interpretation (same_values (\\<lambda>t. trm_rep t S))\n  vars_of_lit gr_L2 = {}\n  vars_of_lit (subst_lit x \\<eta>) = {}", "have \"(subst_lit x \\<eta>, subst_lit L2 \\<eta>) \\<in> lit_ord\""], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit x \\<eta>) = {}\n  x \\<in> cl_ecl C2 - {L2}\n  maximal_literal gr_L2 gr_Cl_C2\n  Cl_C2 = cl_ecl C2\n  gr_L2 = subst_lit L2 \\<eta>\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\n  orient_lit_inst L2 lhs rhs pos \\<eta>\n  \\<not> equivalent_eq_exists lhs rhs Cl_C2\n          (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2\n  fo_interpretation (same_values (\\<lambda>t. trm_rep t S))\n  vars_of_lit gr_L2 = {}\n  vars_of_lit (subst_lit x \\<eta>) = {}\n\ngoal (1 subgoal):\n 1. (subst_lit x \\<eta>, subst_lit L2 \\<eta>) \\<in> lit_ord", "using max_pos_lit_dominates_cl [of L2 \\<eta> Cl_C2 lhs rhs x ?I]"], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit x \\<eta>) = {}\n  x \\<in> cl_ecl C2 - {L2}\n  maximal_literal gr_L2 gr_Cl_C2\n  Cl_C2 = cl_ecl C2\n  gr_L2 = subst_lit L2 \\<eta>\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\n  orient_lit_inst L2 lhs rhs pos \\<eta>\n  \\<not> equivalent_eq_exists lhs rhs Cl_C2\n          (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2\n  fo_interpretation (same_values (\\<lambda>t. trm_rep t S))\n  vars_of_lit gr_L2 = {}\n  vars_of_lit (subst_lit x \\<eta>) = {}\n  \\<lbrakk>maximal_literal (subst_lit L2 \\<eta>) (subst_cl Cl_C2 \\<eta>);\n   orient_lit_inst L2 lhs rhs pos \\<eta>; x \\<in> Cl_C2 - {L2};\n   \\<not> equivalent_eq_exists lhs rhs Cl_C2\n           (same_values (\\<lambda>t. trm_rep t S)) \\<eta> L2;\n   vars_of_lit (subst_lit L2 \\<eta>) = {};\n   vars_of_lit (subst_lit x \\<eta>) = {};\n   fo_interpretation (same_values (\\<lambda>t. trm_rep t S))\\<rbrakk>\n  \\<Longrightarrow> (subst_lit x \\<eta>, subst_lit L2 \\<eta>) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (subst_lit x \\<eta>, subst_lit L2 \\<eta>) \\<in> lit_ord", "by metis"], ["proof (state)\nthis:\n  (subst_lit x \\<eta>, subst_lit L2 \\<eta>) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cl_ecl C2 - {L2} \\<Longrightarrow>\n       (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord", "from \\<open>L2 \\<in> Cl_C2\\<close>"], ["proof (chain)\npicking this:\n  L2 \\<in> Cl_C2", "have \"vars_of_lit L2 \\<subseteq> vars_of_cl Cl_C2\""], ["proof (prove)\nusing this:\n  L2 \\<in> Cl_C2\n\ngoal (1 subgoal):\n 1. vars_of_lit L2 \\<subseteq> vars_of_cl Cl_C2", "by auto"], ["proof (state)\nthis:\n  vars_of_lit L2 \\<subseteq> vars_of_cl Cl_C2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cl_ecl C2 - {L2} \\<Longrightarrow>\n       (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord", "from this and \\<open>coincide_on \\<sigma>' \\<eta> (vars_of_cl (cl_ecl C2))\\<close> and \\<open>Cl_C2 = cl_ecl C2\\<close>"], ["proof (chain)\npicking this:\n  vars_of_lit L2 \\<subseteq> vars_of_cl Cl_C2\n  coincide_on \\<sigma>' \\<eta> (vars_of_cl (cl_ecl C2))\n  Cl_C2 = cl_ecl C2", "have \"coincide_on \\<sigma>' \\<eta> (vars_of_lit L2)\""], ["proof (prove)\nusing this:\n  vars_of_lit L2 \\<subseteq> vars_of_cl Cl_C2\n  coincide_on \\<sigma>' \\<eta> (vars_of_cl (cl_ecl C2))\n  Cl_C2 = cl_ecl C2\n\ngoal (1 subgoal):\n 1. coincide_on \\<sigma>' \\<eta> (vars_of_lit L2)", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  vars_of_lit L2 \\<subseteq> vars_of_cl Cl_C2\n  \\<forall>x\\<in>vars_of_cl (cl_ecl C2).\n     Var x \\<lhd> \\<sigma>' = Var x \\<lhd> \\<eta>\n  Cl_C2 = cl_ecl C2\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of_lit L2.\n       Var x \\<lhd> \\<sigma>' = Var x \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  coincide_on \\<sigma>' \\<eta> (vars_of_lit L2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cl_ecl C2 - {L2} \\<Longrightarrow>\n       (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma>' \\<eta> (vars_of_lit L2)", "have \"subst_lit L2 \\<sigma>' = subst_lit L2 \\<eta>\""], ["proof (prove)\nusing this:\n  coincide_on \\<sigma>' \\<eta> (vars_of_lit L2)\n\ngoal (1 subgoal):\n 1. subst_lit L2 \\<sigma>' = subst_lit L2 \\<eta>", "using coincide_on_lit"], ["proof (prove)\nusing this:\n  coincide_on \\<sigma>' \\<eta> (vars_of_lit L2)\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of_lit ?l) \\<Longrightarrow>\n  subst_lit ?l ?\\<sigma> = subst_lit ?l ?\\<eta>\n\ngoal (1 subgoal):\n 1. subst_lit L2 \\<sigma>' = subst_lit L2 \\<eta>", "by auto"], ["proof (state)\nthis:\n  subst_lit L2 \\<sigma>' = subst_lit L2 \\<eta>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cl_ecl C2 - {L2} \\<Longrightarrow>\n       (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord", "from \\<open>x \\<in> (cl_ecl C2) - {L2}\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> cl_ecl C2 - {L2}", "have \"x \\<in> cl_ecl C2\""], ["proof (prove)\nusing this:\n  x \\<in> cl_ecl C2 - {L2}\n\ngoal (1 subgoal):\n 1. x \\<in> cl_ecl C2", "by auto"], ["proof (state)\nthis:\n  x \\<in> cl_ecl C2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cl_ecl C2 - {L2} \\<Longrightarrow>\n       (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  x \\<in> cl_ecl C2", "have \"vars_of_lit x \\<subseteq> vars_of_cl (cl_ecl C2)\""], ["proof (prove)\nusing this:\n  x \\<in> cl_ecl C2\n\ngoal (1 subgoal):\n 1. vars_of_lit x \\<subseteq> vars_of_cl (cl_ecl C2)", "by auto"], ["proof (state)\nthis:\n  vars_of_lit x \\<subseteq> vars_of_cl (cl_ecl C2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cl_ecl C2 - {L2} \\<Longrightarrow>\n       (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord", "from this and \\<open>coincide_on \\<sigma>' \\<eta> (vars_of_cl (cl_ecl C2))\\<close>"], ["proof (chain)\npicking this:\n  vars_of_lit x \\<subseteq> vars_of_cl (cl_ecl C2)\n  coincide_on \\<sigma>' \\<eta> (vars_of_cl (cl_ecl C2))", "have \"coincide_on \\<sigma>' \\<eta> (vars_of_lit x)\""], ["proof (prove)\nusing this:\n  vars_of_lit x \\<subseteq> vars_of_cl (cl_ecl C2)\n  coincide_on \\<sigma>' \\<eta> (vars_of_cl (cl_ecl C2))\n\ngoal (1 subgoal):\n 1. coincide_on \\<sigma>' \\<eta> (vars_of_lit x)", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  vars_of_lit x \\<subseteq> vars_of_cl (cl_ecl C2)\n  \\<forall>x\\<in>vars_of_cl (cl_ecl C2).\n     Var x \\<lhd> \\<sigma>' = Var x \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of_lit x.\n       Var x \\<lhd> \\<sigma>' = Var x \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  coincide_on \\<sigma>' \\<eta> (vars_of_lit x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cl_ecl C2 - {L2} \\<Longrightarrow>\n       (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord", "from this"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma>' \\<eta> (vars_of_lit x)", "have \"subst_lit x \\<sigma>' = subst_lit x \\<eta>\""], ["proof (prove)\nusing this:\n  coincide_on \\<sigma>' \\<eta> (vars_of_lit x)\n\ngoal (1 subgoal):\n 1. subst_lit x \\<sigma>' = subst_lit x \\<eta>", "using coincide_on_lit"], ["proof (prove)\nusing this:\n  coincide_on \\<sigma>' \\<eta> (vars_of_lit x)\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of_lit ?l) \\<Longrightarrow>\n  subst_lit ?l ?\\<sigma> = subst_lit ?l ?\\<eta>\n\ngoal (1 subgoal):\n 1. subst_lit x \\<sigma>' = subst_lit x \\<eta>", "by auto"], ["proof (state)\nthis:\n  subst_lit x \\<sigma>' = subst_lit x \\<eta>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> cl_ecl C2 - {L2} \\<Longrightarrow>\n       (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord", "from \\<open>(subst_lit x \\<eta>, subst_lit L2 \\<eta>) \\<in> lit_ord\\<close>\n      \\<open>subst_lit L2 \\<sigma>' = subst_lit L2 \\<eta>\\<close> \n      \\<open>subst_lit x \\<sigma>' = subst_lit x \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  (subst_lit x \\<eta>, subst_lit L2 \\<eta>) \\<in> lit_ord\n  subst_lit L2 \\<sigma>' = subst_lit L2 \\<eta>\n  subst_lit x \\<sigma>' = subst_lit x \\<eta>", "show \"(subst_lit x \\<sigma>',subst_lit L2 \\<sigma>') \\<in> lit_ord\""], ["proof (prove)\nusing this:\n  (subst_lit x \\<eta>, subst_lit L2 \\<eta>) \\<in> lit_ord\n  subst_lit L2 \\<sigma>' = subst_lit L2 \\<eta>\n  subst_lit x \\<sigma>' = subst_lit x \\<eta>\n\ngoal (1 subgoal):\n 1. (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord", "by metis"], ["proof (state)\nthis:\n  (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>cl_ecl C2 - {L2}.\n     (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "have \"all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>') (\\<lambda>t. trm_rep t S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n     (\\<lambda>t. trm_rep t S)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "assume \"\\<not>all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>') (\\<lambda>t. trm_rep t S)\""], ["proof (state)\nthis:\n  \\<not> all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n          (\\<lambda>t. trm_rep t S)\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<not> all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n          (\\<lambda>t. trm_rep t S)", "obtain x y where \"x \\<in> (subst_set (trms_ecl C2) \\<sigma>')\" and \"occurs_in y x\"\n      and \"trm_rep y S \\<noteq> y\""], ["proof (prove)\nusing this:\n  \\<not> all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n          (\\<lambda>t. trm_rep t S)\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<in> subst_set (trms_ecl C2) \\<sigma>'; occurs_in y x;\n         trm_rep y S \\<noteq> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding all_trms_irreducible_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x y.\n             x \\<in> subst_set (trms_ecl C2) \\<sigma>' \\<longrightarrow>\n             occurs_in y x \\<longrightarrow> trm_rep y S = y)\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<in> subst_set (trms_ecl C2) \\<sigma>'; occurs_in y x;\n         trm_rep y S \\<noteq> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> subst_set (trms_ecl C2) \\<sigma>'\n  occurs_in y x\n  trm_rep y S \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from \\<open>x \\<in> (subst_set (trms_ecl C2) \\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> subst_set (trms_ecl C2) \\<sigma>'", "obtain x' where \"x' \\<in> trms_ecl C2\"\n      and \"x = (subst x' \\<sigma>')\""], ["proof (prove)\nusing this:\n  x \\<in> subst_set (trms_ecl C2) \\<sigma>'\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>x' \\<in> trms_ecl C2; x = x' \\<lhd> \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x' \\<in> trms_ecl C2\n  x = x' \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from assms(11) and \\<open>x' \\<in> (trms_ecl C2)\\<close> and \\<open>C2 \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  Ball S well_constrained\n  x' \\<in> trms_ecl C2\n  C2 \\<in> S", "have \"dom_trm x' (cl_ecl C2)\""], ["proof (prove)\nusing this:\n  Ball S well_constrained\n  x' \\<in> trms_ecl C2\n  C2 \\<in> S\n\ngoal (1 subgoal):\n 1. dom_trm x' (cl_ecl C2)", "unfolding Ball_def well_constrained_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in> S \\<longrightarrow>\n     (\\<forall>y. y \\<in> trms_ecl x \\<longrightarrow> dom_trm y (cl_ecl x))\n  x' \\<in> trms_ecl C2\n  C2 \\<in> S\n\ngoal (1 subgoal):\n 1. dom_trm x' (cl_ecl C2)", "by blast"], ["proof (state)\nthis:\n  dom_trm x' (cl_ecl C2)\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  dom_trm x' (cl_ecl C2)", "obtain x'' \n       where \"x'' \\<in> subterms_of_cl (cl_ecl C2)\" and \"x'' = x' \\<or> (x',x'') \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  dom_trm x' (cl_ecl C2)\n\ngoal (1 subgoal):\n 1. (\\<And>x''.\n        \\<lbrakk>x'' \\<in> subterms_of_cl (cl_ecl C2);\n         x'' = x' \\<or> (x', x'') \\<in> trm_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using dom_trm_lemma"], ["proof (prove)\nusing this:\n  dom_trm x' (cl_ecl C2)\n  dom_trm ?t ?C \\<Longrightarrow>\n  \\<exists>u.\n     u \\<in> subterms_of_cl ?C \\<and> (u = ?t \\<or> (?t, u) \\<in> trm_ord)\n\ngoal (1 subgoal):\n 1. (\\<And>x''.\n        \\<lbrakk>x'' \\<in> subterms_of_cl (cl_ecl C2);\n         x'' = x' \\<or> (x', x'') \\<in> trm_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x'' \\<in> subterms_of_cl (cl_ecl C2)\n  x'' = x' \\<or> (x', x'') \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from \\<open>dom_trm x' (cl_ecl C2)\\<close>"], ["proof (chain)\npicking this:\n  dom_trm x' (cl_ecl C2)", "have \"vars_of x'  \\<subseteq> vars_of_cl (cl_ecl C2)\""], ["proof (prove)\nusing this:\n  dom_trm x' (cl_ecl C2)\n\ngoal (1 subgoal):\n 1. vars_of x' \\<subseteq> vars_of_cl (cl_ecl C2)", "using dom_trm_vars"], ["proof (prove)\nusing this:\n  dom_trm x' (cl_ecl C2)\n  dom_trm ?t ?C \\<Longrightarrow> vars_of ?t \\<subseteq> vars_of_cl ?C\n\ngoal (1 subgoal):\n 1. vars_of x' \\<subseteq> vars_of_cl (cl_ecl C2)", "by blast"], ["proof (state)\nthis:\n  vars_of x' \\<subseteq> vars_of_cl (cl_ecl C2)\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from this and \\<open>coincide_on \\<sigma>' \\<eta> (vars_of_cl (cl_ecl C2))\\<close>"], ["proof (chain)\npicking this:\n  vars_of x' \\<subseteq> vars_of_cl (cl_ecl C2)\n  coincide_on \\<sigma>' \\<eta> (vars_of_cl (cl_ecl C2))", "have \"coincide_on \\<sigma>' \\<eta> (vars_of x')\""], ["proof (prove)\nusing this:\n  vars_of x' \\<subseteq> vars_of_cl (cl_ecl C2)\n  coincide_on \\<sigma>' \\<eta> (vars_of_cl (cl_ecl C2))\n\ngoal (1 subgoal):\n 1. coincide_on \\<sigma>' \\<eta> (vars_of x')", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  vars_of x' \\<subseteq> vars_of_cl (cl_ecl C2)\n  \\<forall>x\\<in>vars_of_cl (cl_ecl C2).\n     Var x \\<lhd> \\<sigma>' = Var x \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of x'. Var x \\<lhd> \\<sigma>' = Var x \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  coincide_on \\<sigma>' \\<eta> (vars_of x')\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma>' \\<eta> (vars_of x')", "have \"(subst x' \\<eta>) = (subst x' \\<sigma>')\""], ["proof (prove)\nusing this:\n  coincide_on \\<sigma>' \\<eta> (vars_of x')\n\ngoal (1 subgoal):\n 1. x' \\<lhd> \\<eta> = x' \\<lhd> \\<sigma>'", "using coincide_on_term"], ["proof (prove)\nusing this:\n  coincide_on \\<sigma>' \\<eta> (vars_of x')\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of ?t) \\<Longrightarrow>\n  ?t \\<lhd> ?\\<sigma> = ?t \\<lhd> ?\\<eta>\n\ngoal (1 subgoal):\n 1. x' \\<lhd> \\<eta> = x' \\<lhd> \\<sigma>'", "by metis"], ["proof (state)\nthis:\n  x' \\<lhd> \\<eta> = x' \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from this and \\<open>x = (subst x' \\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  x' \\<lhd> \\<eta> = x' \\<lhd> \\<sigma>'\n  x = x' \\<lhd> \\<sigma>'", "have \"x = (subst x' \\<eta>)\""], ["proof (prove)\nusing this:\n  x' \\<lhd> \\<eta> = x' \\<lhd> \\<sigma>'\n  x = x' \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. x = x' \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  x = x' \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from this and \\<open>x' \\<in> trms_ecl C2\\<close>"], ["proof (chain)\npicking this:\n  x = x' \\<lhd> \\<eta>\n  x' \\<in> trms_ecl C2", "have \"x \\<in>(subst_set (trms_ecl C2) \\<eta>)\""], ["proof (prove)\nusing this:\n  x = x' \\<lhd> \\<eta>\n  x' \\<in> trms_ecl C2\n\ngoal (1 subgoal):\n 1. x \\<in> subst_set (trms_ecl C2) \\<eta>", "by auto"], ["proof (state)\nthis:\n  x \\<in> subst_set (trms_ecl C2) \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from \\<open>x'' \\<in> (subterms_of_cl (cl_ecl C2))\\<close>"], ["proof (chain)\npicking this:\n  x'' \\<in> subterms_of_cl (cl_ecl C2)", "have \n        \"(subst x'' \\<eta>) \\<in> (subterms_of_cl (subst_cl (cl_ecl C2) \\<eta>))\""], ["proof (prove)\nusing this:\n  x'' \\<in> subterms_of_cl (cl_ecl C2)\n\ngoal (1 subgoal):\n 1. x'' \\<lhd> \\<eta> \\<in> subterms_of_cl (subst_cl (cl_ecl C2) \\<eta>)", "using subterm_cl_subst [of x'' \"cl_ecl C2\"]"], ["proof (prove)\nusing this:\n  x'' \\<in> subterms_of_cl (cl_ecl C2)\n  x'' \\<in> subterms_of_cl (cl_ecl C2) \\<Longrightarrow>\n  x'' \\<lhd> ?\\<sigma> \\<in> subterms_of_cl (subst_cl (cl_ecl C2) ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. x'' \\<lhd> \\<eta> \\<in> subterms_of_cl (subst_cl (cl_ecl C2) \\<eta>)", "by auto"], ["proof (state)\nthis:\n  x'' \\<lhd> \\<eta> \\<in> subterms_of_cl (subst_cl (cl_ecl C2) \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from \\<open>orient_lit_inst L2 lhs rhs pos \\<eta>\\<close> \\<open>gr_rhs = (subst rhs \\<eta>)\\<close> \n      \\<open>gr_L2 = (subst_lit L2 \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L2 lhs rhs pos \\<eta>\n  gr_rhs = rhs \\<lhd> \\<eta>\n  gr_L2 = subst_lit L2 \\<eta>", "have \"orient_lit gr_L2  (subst lhs \\<eta>) gr_rhs pos\""], ["proof (prove)\nusing this:\n  orient_lit_inst L2 lhs rhs pos \\<eta>\n  gr_rhs = rhs \\<lhd> \\<eta>\n  gr_L2 = subst_lit L2 \\<eta>\n\ngoal (1 subgoal):\n 1. orient_lit gr_L2 (lhs \\<lhd> \\<eta>) gr_rhs pos", "using lift_orient_lit"], ["proof (prove)\nusing this:\n  orient_lit_inst L2 lhs rhs pos \\<eta>\n  gr_rhs = rhs \\<lhd> \\<eta>\n  gr_L2 = subst_lit L2 \\<eta>\n  orient_lit_inst ?L ?t ?s ?p ?\\<sigma> \\<Longrightarrow>\n  orient_lit (subst_lit ?L ?\\<sigma>) (?t \\<lhd> ?\\<sigma>)\n   (?s \\<lhd> ?\\<sigma>) ?p\n\ngoal (1 subgoal):\n 1. orient_lit gr_L2 (lhs \\<lhd> \\<eta>) gr_rhs pos", "by auto"], ["proof (state)\nthis:\n  orient_lit gr_L2 (lhs \\<lhd> \\<eta>) gr_rhs pos\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from \\<open>ground_clause gr_Cl_C2\\<close>"], ["proof (chain)\npicking this:\n  ground_clause gr_Cl_C2", "have \"vars_of_cl gr_Cl_C2 = {}\""], ["proof (prove)\nusing this:\n  ground_clause gr_Cl_C2\n\ngoal (1 subgoal):\n 1. vars_of_cl gr_Cl_C2 = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_cl gr_Cl_C2 = {}\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from  \\<open>vars_of_lit gr_L2 = {}\\<close> \\<open>vars_of_cl gr_Cl_C2 = {}\\<close> \n    \\<open>(subst x'' \\<eta>) \\<in> (subterms_of_cl (subst_cl (cl_ecl C2) \\<eta>))\\<close> \n    \\<open>orient_lit gr_L2 (subst lhs \\<eta>) gr_rhs pos\\<close> \\<open>maximal_literal gr_L2 gr_Cl_C2\\<close>  \n    \\<open>Cl_C2 = cl_ecl C2\\<close> \\<open>gr_L2 = (subst_lit L2 \\<eta>)\\<close>  \n    \\<open>gr_Cl_C2 = (subst_cl Cl_C2 \\<eta>)\\<close> \\<open>v = (subst lhs \\<eta>)\\<close> \\<open>v = (subst lhs \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  vars_of_lit gr_L2 = {}\n  vars_of_cl gr_Cl_C2 = {}\n  x'' \\<lhd> \\<eta> \\<in> subterms_of_cl (subst_cl (cl_ecl C2) \\<eta>)\n  orient_lit gr_L2 (lhs \\<lhd> \\<eta>) gr_rhs pos\n  maximal_literal gr_L2 gr_Cl_C2\n  Cl_C2 = cl_ecl C2\n  gr_L2 = subst_lit L2 \\<eta>\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\n  v = lhs \\<lhd> \\<eta>\n  v = lhs \\<lhd> \\<eta>", "have \"(subst x'' \\<eta>) = v \\<or> (((subst x'' \\<eta>),v) \\<in> trm_ord)\""], ["proof (prove)\nusing this:\n  vars_of_lit gr_L2 = {}\n  vars_of_cl gr_Cl_C2 = {}\n  x'' \\<lhd> \\<eta> \\<in> subterms_of_cl (subst_cl (cl_ecl C2) \\<eta>)\n  orient_lit gr_L2 (lhs \\<lhd> \\<eta>) gr_rhs pos\n  maximal_literal gr_L2 gr_Cl_C2\n  Cl_C2 = cl_ecl C2\n  gr_L2 = subst_lit L2 \\<eta>\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\n  v = lhs \\<lhd> \\<eta>\n  v = lhs \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. x'' \\<lhd> \\<eta> = v \\<or> (x'' \\<lhd> \\<eta>, v) \\<in> trm_ord", "using subterms_dominated [of gr_L2 gr_Cl_C2  \"(subst lhs \\<eta>)\" gr_rhs pos \"subst x'' \\<eta>\"]"], ["proof (prove)\nusing this:\n  vars_of_lit gr_L2 = {}\n  vars_of_cl gr_Cl_C2 = {}\n  x'' \\<lhd> \\<eta> \\<in> subterms_of_cl (subst_cl (cl_ecl C2) \\<eta>)\n  orient_lit gr_L2 (lhs \\<lhd> \\<eta>) gr_rhs pos\n  maximal_literal gr_L2 gr_Cl_C2\n  Cl_C2 = cl_ecl C2\n  gr_L2 = subst_lit L2 \\<eta>\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\n  v = lhs \\<lhd> \\<eta>\n  v = lhs \\<lhd> \\<eta>\n  \\<lbrakk>maximal_literal gr_L2 gr_Cl_C2;\n   orient_lit gr_L2 (lhs \\<lhd> \\<eta>) gr_rhs pos;\n   x'' \\<lhd> \\<eta> \\<in> subterms_of_cl gr_Cl_C2; vars_of_lit gr_L2 = {};\n   vars_of_cl gr_Cl_C2 = {}\\<rbrakk>\n  \\<Longrightarrow> x'' \\<lhd> \\<eta> = lhs \\<lhd> \\<eta> \\<or>\n                    (x'' \\<lhd> \\<eta>, lhs \\<lhd> \\<eta>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. x'' \\<lhd> \\<eta> = v \\<or> (x'' \\<lhd> \\<eta>, v) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  x'' \\<lhd> \\<eta> = v \\<or> (x'' \\<lhd> \\<eta>, v) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from \\<open>x'' = x' \\<or> (x',x'') \\<in> trm_ord\\<close>  \\<open>x = (subst x' \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  x'' = x' \\<or> (x', x'') \\<in> trm_ord\n  x = x' \\<lhd> \\<eta>", "have\n      \"(subst x'' \\<eta>) = x \\<or> (x,(subst x'' \\<eta>)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  x'' = x' \\<or> (x', x'') \\<in> trm_ord\n  x = x' \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. x'' \\<lhd> \\<eta> = x \\<or> (x, x'' \\<lhd> \\<eta>) \\<in> trm_ord", "using trm_ord_subst"], ["proof (prove)\nusing this:\n  x'' = x' \\<or> (x', x'') \\<in> trm_ord\n  x = x' \\<lhd> \\<eta>\n  \\<forall>s x y.\n     (x, y) \\<in> trm_ord \\<longrightarrow>\n     (x \\<lhd> s, y \\<lhd> s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. x'' \\<lhd> \\<eta> = x \\<or> (x, x'' \\<lhd> \\<eta>) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  x'' \\<lhd> \\<eta> = x \\<or> (x, x'' \\<lhd> \\<eta>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from this and \\<open>(subst x'' \\<eta>) = v \\<or> (((subst x'' \\<eta>),v) \\<in> trm_ord)\\<close>"], ["proof (chain)\npicking this:\n  x'' \\<lhd> \\<eta> = x \\<or> (x, x'' \\<lhd> \\<eta>) \\<in> trm_ord\n  x'' \\<lhd> \\<eta> = v \\<or> (x'' \\<lhd> \\<eta>, v) \\<in> trm_ord", "have \"x = v \\<or> ((x,v) \\<in> trm_ord)\""], ["proof (prove)\nusing this:\n  x'' \\<lhd> \\<eta> = x \\<or> (x, x'' \\<lhd> \\<eta>) \\<in> trm_ord\n  x'' \\<lhd> \\<eta> = v \\<or> (x'' \\<lhd> \\<eta>, v) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. x = v \\<or> (x, v) \\<in> trm_ord", "using trm_ord_trans trans_def"], ["proof (prove)\nusing this:\n  x'' \\<lhd> \\<eta> = x \\<or> (x, x'' \\<lhd> \\<eta>) \\<in> trm_ord\n  x'' \\<lhd> \\<eta> = v \\<or> (x'' \\<lhd> \\<eta>, v) \\<in> trm_ord\n  trans trm_ord\n  trans ?r =\n  (\\<forall>x y z.\n      (x, y) \\<in> ?r \\<longrightarrow>\n      (y, z) \\<in> ?r \\<longrightarrow> (x, z) \\<in> ?r)\n\ngoal (1 subgoal):\n 1. x = v \\<or> (x, v) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  x = v \\<or> (x, v) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  x = v \\<or> (x, v) \\<in> trm_ord", "show False"], ["proof (prove)\nusing this:\n  x = v \\<or> (x, v) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x = v \\<Longrightarrow> False\n 2. (x, v) \\<in> trm_ord \\<Longrightarrow> False", "assume \"x = v\""], ["proof (state)\nthis:\n  x = v\n\ngoal (2 subgoals):\n 1. x = v \\<Longrightarrow> False\n 2. (x, v) \\<in> trm_ord \\<Longrightarrow> False", "from this and \\<open>v \\<notin> subst_set (trms_ecl C2) \\<eta>\\<close> \n      \\<open>x \\<in> (subst_set (trms_ecl C2) \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  x = v\n  v \\<notin> subst_set (trms_ecl C2) \\<eta>\n  x \\<in> subst_set (trms_ecl C2) \\<eta>", "show False"], ["proof (prove)\nusing this:\n  x = v\n  v \\<notin> subst_set (trms_ecl C2) \\<eta>\n  x \\<in> subst_set (trms_ecl C2) \\<eta>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. (x, v) \\<in> trm_ord \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (x, v) \\<in> trm_ord \\<Longrightarrow> False", "assume \"(x,v) \\<in> trm_ord\""], ["proof (state)\nthis:\n  (x, v) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (x, v) \\<in> trm_ord \\<Longrightarrow> False", "from \\<open>occurs_in y x\\<close>"], ["proof (chain)\npicking this:\n  occurs_in y x", "have \"y = x \\<or> (y,x) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  occurs_in y x\n\ngoal (1 subgoal):\n 1. y = x \\<or> (y, x) \\<in> trm_ord", "unfolding occurs_in_def"], ["proof (prove)\nusing this:\n  \\<exists>p. subterm x p y\n\ngoal (1 subgoal):\n 1. y = x \\<or> (y, x) \\<in> trm_ord", "using subterm_trm_ord_eq"], ["proof (prove)\nusing this:\n  \\<exists>p. subterm x p y\n  subterm ?t ?p ?s \\<Longrightarrow> ?s = ?t \\<or> (?s, ?t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. y = x \\<or> (y, x) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  y = x \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (x, v) \\<in> trm_ord \\<Longrightarrow> False", "from this and \\<open>(x,v) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  y = x \\<or> (y, x) \\<in> trm_ord\n  (x, v) \\<in> trm_ord", "have \"(y,v) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  y = x \\<or> (y, x) \\<in> trm_ord\n  (x, v) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (y, v) \\<in> trm_ord", "using trm_ord_trans"], ["proof (prove)\nusing this:\n  y = x \\<or> (y, x) \\<in> trm_ord\n  (x, v) \\<in> trm_ord\n  trans trm_ord\n\ngoal (1 subgoal):\n 1. (y, v) \\<in> trm_ord", "unfolding trans_def"], ["proof (prove)\nusing this:\n  y = x \\<or> (y, x) \\<in> trm_ord\n  (x, v) \\<in> trm_ord\n  \\<forall>x y z.\n     (x, y) \\<in> trm_ord \\<longrightarrow>\n     (y, z) \\<in> trm_ord \\<longrightarrow> (x, z) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (y, v) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (y, v) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (x, v) \\<in> trm_ord \\<Longrightarrow> False", "from this and norm and \\<open>trm_rep y S \\<noteq> y\\<close> and \\<open>occurs_in y x\\<close> and \\<open>x' \\<in> trms_ecl C2\\<close>\n        and \\<open>x = (subst x' \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  (y, v) \\<in> trm_ord\n  \\<forall>x.\n     (\\<exists>x'\\<in>trms_ecl C2.\n         occurs_in x (x' \\<lhd> \\<eta>)) \\<longrightarrow>\n     (x, v) \\<in> trm_ord \\<longrightarrow> trm_rep x S = x\n  trm_rep y S \\<noteq> y\n  occurs_in y x\n  x' \\<in> trms_ecl C2\n  x = x' \\<lhd> \\<eta>", "show False"], ["proof (prove)\nusing this:\n  (y, v) \\<in> trm_ord\n  \\<forall>x.\n     (\\<exists>x'\\<in>trms_ecl C2.\n         occurs_in x (x' \\<lhd> \\<eta>)) \\<longrightarrow>\n     (x, v) \\<in> trm_ord \\<longrightarrow> trm_rep x S = x\n  trm_rep y S \\<noteq> y\n  occurs_in y x\n  x' \\<in> trms_ecl C2\n  x = x' \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n   (\\<lambda>t. trm_rep t S)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>subterm t p u\\<close>"], ["proof (chain)\npicking this:\n  subterm t p u", "have \"u = t \\<or> (u,t) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  subterm t p u\n\ngoal (1 subgoal):\n 1. u = t \\<or> (u, t) \\<in> trm_ord", "using subterm_trm_ord_eq"], ["proof (prove)\nusing this:\n  subterm t p u\n  subterm ?t ?p ?s \\<Longrightarrow> ?s = ?t \\<or> (?s, ?t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. u = t \\<or> (u, t) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  u = t \\<or> (u, t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from assms(8) and \\<open>L1 \\<in> (cl_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n  L1 \\<in> cl_ecl C", "have \"vars_of_lit (subst_lit L1 \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n  L1 \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. vars_of_lit (subst_lit L1 \\<sigma>) = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>coincide_on \\<sigma> \\<sigma>' (vars_of_lit L1)\\<close>"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_lit L1)", "have \"(subst_lit L1 \\<sigma>) = (subst_lit L1 \\<sigma>')\""], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_lit L1)\n\ngoal (1 subgoal):\n 1. subst_lit L1 \\<sigma> = subst_lit L1 \\<sigma>'", "using  coincide_on_lit"], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_lit L1)\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of_lit ?l) \\<Longrightarrow>\n  subst_lit ?l ?\\<sigma> = subst_lit ?l ?\\<eta>\n\ngoal (1 subgoal):\n 1. subst_lit L1 \\<sigma> = subst_lit L1 \\<sigma>'", "by metis"], ["proof (state)\nthis:\n  subst_lit L1 \\<sigma> = subst_lit L1 \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from this and  \\<open>vars_of_lit (subst_lit L1 \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  subst_lit L1 \\<sigma> = subst_lit L1 \\<sigma>'\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}", "have \"vars_of_lit (subst_lit L1 \\<sigma>') = {}\""], ["proof (prove)\nusing this:\n  subst_lit L1 \\<sigma> = subst_lit L1 \\<sigma>'\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. vars_of_lit (subst_lit L1 \\<sigma>') = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_lit (subst_lit L1 \\<sigma>') = {}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>coincide_on \\<eta> \\<sigma>' (vars_of_lit L2)\\<close>"], ["proof (chain)\npicking this:\n  coincide_on \\<eta> \\<sigma>' (vars_of_lit L2)", "have \"(subst_lit L2 \\<eta>) = (subst_lit L2 \\<sigma>')\""], ["proof (prove)\nusing this:\n  coincide_on \\<eta> \\<sigma>' (vars_of_lit L2)\n\ngoal (1 subgoal):\n 1. subst_lit L2 \\<eta> = subst_lit L2 \\<sigma>'", "using  coincide_on_lit"], ["proof (prove)\nusing this:\n  coincide_on \\<eta> \\<sigma>' (vars_of_lit L2)\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of_lit ?l) \\<Longrightarrow>\n  subst_lit ?l ?\\<sigma> = subst_lit ?l ?\\<eta>\n\ngoal (1 subgoal):\n 1. subst_lit L2 \\<eta> = subst_lit L2 \\<sigma>'", "by metis"], ["proof (state)\nthis:\n  subst_lit L2 \\<eta> = subst_lit L2 \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>vars_of_lit gr_L2 = {}\\<close> \\<open>ground_clause gr_Cl_C2\\<close> \\<open>gr_Cl_C2 = (subst_cl Cl_C2 \\<eta>)\\<close> \n    \\<open>L2 \\<in> Cl_C2\\<close>"], ["proof (chain)\npicking this:\n  vars_of_lit gr_L2 = {}\n  ground_clause gr_Cl_C2\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\n  L2 \\<in> Cl_C2", "have \"vars_of_lit (subst_lit L2 \\<eta>) = {}\""], ["proof (prove)\nusing this:\n  vars_of_lit gr_L2 = {}\n  ground_clause gr_Cl_C2\n  gr_Cl_C2 = subst_cl Cl_C2 \\<eta>\n  L2 \\<in> Cl_C2\n\ngoal (1 subgoal):\n 1. vars_of_lit (subst_lit L2 \\<eta>) = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_lit (subst_lit L2 \\<eta>) = {}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from this and \\<open>(subst_lit L2 \\<eta>) = (subst_lit L2 \\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  vars_of_lit (subst_lit L2 \\<eta>) = {}\n  subst_lit L2 \\<eta> = subst_lit L2 \\<sigma>'", "have \"vars_of_lit (subst_lit L2 \\<sigma>') = {}\""], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L2 \\<eta>) = {}\n  subst_lit L2 \\<eta> = subst_lit L2 \\<sigma>'\n\ngoal (1 subgoal):\n 1. vars_of_lit (subst_lit L2 \\<sigma>') = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_lit (subst_lit L2 \\<sigma>') = {}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "text \\<open>We now prove that the ``into'' clause is strictly smaller than the ``from'' clause. This is\neasy if the rewritten literal is negative or if the reduction does not occur at root level. \nOtherwise, we must use the fact that the function @{term \"trm_rep\"} selects the smallest right-hand\nside to compute the value of a term.\\<close>"], ["proof (state)\nthis:\n  vars_of_lit (subst_lit L2 \\<sigma>') = {}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "have \"(subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>')\n    \\<notin> lit_ord \\<Longrightarrow>\n    False", "assume \"\\<not>(subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord\""], ["proof (state)\nthis:\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<notin> lit_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>')\n    \\<notin> lit_ord \\<Longrightarrow>\n    False", "from \\<open>orient_lit_inst L1 t s polarity \\<sigma>'\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L1 t s polarity \\<sigma>'", "have \"orient_lit (subst_lit L1 \\<sigma>') \n          (subst t \\<sigma>') (subst s \\<sigma>') polarity\""], ["proof (prove)\nusing this:\n  orient_lit_inst L1 t s polarity \\<sigma>'\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit L1 \\<sigma>') (t \\<lhd> \\<sigma>')\n     (s \\<lhd> \\<sigma>') polarity", "using lift_orient_lit [of L1 t s polarity \\<sigma>']"], ["proof (prove)\nusing this:\n  orient_lit_inst L1 t s polarity \\<sigma>'\n  orient_lit_inst L1 t s polarity \\<sigma>' \\<Longrightarrow>\n  orient_lit (subst_lit L1 \\<sigma>') (t \\<lhd> \\<sigma>')\n   (s \\<lhd> \\<sigma>') polarity\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit L1 \\<sigma>') (t \\<lhd> \\<sigma>')\n     (s \\<lhd> \\<sigma>') polarity", "by auto"], ["proof (state)\nthis:\n  orient_lit (subst_lit L1 \\<sigma>') (t \\<lhd> \\<sigma>')\n   (s \\<lhd> \\<sigma>') polarity\n\ngoal (1 subgoal):\n 1. (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>')\n    \\<notin> lit_ord \\<Longrightarrow>\n    False", "from \\<open>orient_lit_inst L2 lhs rhs pos \\<sigma>'\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L2 lhs rhs pos \\<sigma>'", "have \"orient_lit (subst_lit L2 \\<sigma>') \n          (subst lhs \\<sigma>') (subst rhs \\<sigma>') pos\""], ["proof (prove)\nusing this:\n  orient_lit_inst L2 lhs rhs pos \\<sigma>'\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit L2 \\<sigma>') (lhs \\<lhd> \\<sigma>')\n     (rhs \\<lhd> \\<sigma>') pos", "using lift_orient_lit"], ["proof (prove)\nusing this:\n  orient_lit_inst L2 lhs rhs pos \\<sigma>'\n  orient_lit_inst ?L ?t ?s ?p ?\\<sigma> \\<Longrightarrow>\n  orient_lit (subst_lit ?L ?\\<sigma>) (?t \\<lhd> ?\\<sigma>)\n   (?s \\<lhd> ?\\<sigma>) ?p\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit L2 \\<sigma>') (lhs \\<lhd> \\<sigma>')\n     (rhs \\<lhd> \\<sigma>') pos", "by auto"], ["proof (state)\nthis:\n  orient_lit (subst_lit L2 \\<sigma>') (lhs \\<lhd> \\<sigma>')\n   (rhs \\<lhd> \\<sigma>') pos\n\ngoal (1 subgoal):\n 1. (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>')\n    \\<notin> lit_ord \\<Longrightarrow>\n    False", "have \"(u,t) \\<notin> trm_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, t) \\<notin> trm_ord", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (u, t) \\<in> trm_ord \\<Longrightarrow> False", "assume \"(u,t) \\<in> trm_ord\""], ["proof (state)\nthis:\n  (u, t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (u, t) \\<in> trm_ord \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  (u, t) \\<in> trm_ord", "have \"(subst u \\<sigma>', subst t \\<sigma>') \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (u, t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<sigma>', t \\<lhd> \\<sigma>') \\<in> trm_ord", "using trm_ord_subst"], ["proof (prove)\nusing this:\n  (u, t) \\<in> trm_ord\n  \\<forall>s x y.\n     (x, y) \\<in> trm_ord \\<longrightarrow>\n     (x \\<lhd> s, y \\<lhd> s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (u \\<lhd> \\<sigma>', t \\<lhd> \\<sigma>') \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (u \\<lhd> \\<sigma>', t \\<lhd> \\<sigma>') \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (u, t) \\<in> trm_ord \\<Longrightarrow> False", "have False \"subst u \\<sigma>' = subst lhs \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False &&& u \\<lhd> \\<sigma>' = lhs \\<lhd> \\<sigma>'", "using \\<open>(subst u \\<sigma>', subst t \\<sigma>') \\<in> trm_ord\\<close> \n        \\<open>(subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<notin> lit_ord\\<close> \\<open>subst lhs \\<eta> = subst lhs \\<sigma>'\\<close> \n        \\<open>subst u \\<sigma> = subst u \\<sigma>'\\<close> \\<open>subst_lit L2 \\<eta> = subst_lit L2 \\<sigma>'\\<close> \\<open>gr_L2 = subst_lit L2 \\<eta>\\<close> \n        \\<open>orient_lit (subst_lit L1 \\<sigma>') (subst t \\<sigma>') (subst s \\<sigma>') polarity\\<close> \n        \\<open>orient_lit (subst_lit L2 \\<sigma>') (subst lhs \\<sigma>') (subst rhs \\<sigma>') pos\\<close> \\<open>v = subst lhs \\<eta>\\<close> \n        \\<open>v = subst u \\<sigma>\\<close> \\<open>vars_of_lit (subst_lit L1 \\<sigma>') = {}\\<close> \\<open>vars_of_lit gr_L2 = {}\\<close> \n        lit_ord_dominating_term"], ["proof (prove)\nusing this:\n  (u \\<lhd> \\<sigma>', t \\<lhd> \\<sigma>') \\<in> trm_ord\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<notin> lit_ord\n  lhs \\<lhd> \\<eta> = lhs \\<lhd> \\<sigma>'\n  u \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>'\n  subst_lit L2 \\<eta> = subst_lit L2 \\<sigma>'\n  gr_L2 = subst_lit L2 \\<eta>\n  orient_lit (subst_lit L1 \\<sigma>') (t \\<lhd> \\<sigma>')\n   (s \\<lhd> \\<sigma>') polarity\n  orient_lit (subst_lit L2 \\<sigma>') (lhs \\<lhd> \\<sigma>')\n   (rhs \\<lhd> \\<sigma>') pos\n  v = lhs \\<lhd> \\<eta>\n  v = u \\<lhd> \\<sigma>\n  vars_of_lit (subst_lit L1 \\<sigma>') = {}\n  vars_of_lit gr_L2 = {}\n  \\<lbrakk>(?s1.0, ?s2.0) \\<in> trm_ord \\<or> (?s1.0, ?t2.0) \\<in> trm_ord;\n   orient_lit ?x1.0 ?s1.0 ?t1.0 ?p1.0; orient_lit ?x2.0 ?s2.0 ?t2.0 ?p2.0;\n   vars_of_lit ?x1.0 = {}; vars_of_lit ?x2.0 = {}\\<rbrakk>\n  \\<Longrightarrow> (?x1.0, ?x2.0) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. False &&& u \\<lhd> \\<sigma>' = lhs \\<lhd> \\<sigma>'", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<lhd> \\<sigma>' = lhs \\<lhd> \\<sigma>'", "using \\<open>(subst u \\<sigma>', subst t \\<sigma>') \\<in> trm_ord\\<close> \n        \\<open>(subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<notin> lit_ord\\<close> \n        \\<open>subst u \\<sigma>' = subst lhs \\<sigma>'\\<close> \n        \\<open>orient_lit (subst_lit L1 \\<sigma>') (subst t \\<sigma>') (subst s \\<sigma>') polarity\\<close> \n        \\<open>orient_lit (subst_lit L2 \\<sigma>') (subst lhs \\<sigma>') (subst rhs \\<sigma>') pos\\<close> \n        \\<open>vars_of_lit (subst_lit L1 \\<sigma>') = {}\\<close> \\<open>vars_of_lit (subst_lit L2 \\<sigma>') = {}\\<close> \n        lit_ord_dominating_term"], ["proof (prove)\nusing this:\n  (u \\<lhd> \\<sigma>', t \\<lhd> \\<sigma>') \\<in> trm_ord\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<notin> lit_ord\n  u \\<lhd> \\<sigma>' = lhs \\<lhd> \\<sigma>'\n  orient_lit (subst_lit L1 \\<sigma>') (t \\<lhd> \\<sigma>')\n   (s \\<lhd> \\<sigma>') polarity\n  orient_lit (subst_lit L2 \\<sigma>') (lhs \\<lhd> \\<sigma>')\n   (rhs \\<lhd> \\<sigma>') pos\n  vars_of_lit (subst_lit L1 \\<sigma>') = {}\n  vars_of_lit (subst_lit L2 \\<sigma>') = {}\n  \\<lbrakk>(?s1.0, ?s2.0) \\<in> trm_ord \\<or> (?s1.0, ?t2.0) \\<in> trm_ord;\n   orient_lit ?x1.0 ?s1.0 ?t1.0 ?p1.0; orient_lit ?x2.0 ?s2.0 ?t2.0 ?p2.0;\n   vars_of_lit ?x1.0 = {}; vars_of_lit ?x2.0 = {}\\<rbrakk>\n  \\<Longrightarrow> (?x1.0, ?x2.0) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. u \\<lhd> \\<sigma>' = lhs \\<lhd> \\<sigma>'", "by fastforce"], ["proof (state)\nthis:\n  False\n  u \\<lhd> \\<sigma>' = lhs \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. (u, t) \\<in> trm_ord \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  False\n  u \\<lhd> \\<sigma>' = lhs \\<lhd> \\<sigma>'", "show False"], ["proof (prove)\nusing this:\n  False\n  u \\<lhd> \\<sigma>' = lhs \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (u, t) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>')\n    \\<notin> lit_ord \\<Longrightarrow>\n    False", "from this and \\<open>subterm t p u\\<close>"], ["proof (chain)\npicking this:\n  (u, t) \\<notin> trm_ord\n  subterm t p u", "have \"p = Nil\""], ["proof (prove)\nusing this:\n  (u, t) \\<notin> trm_ord\n  subterm t p u\n\ngoal (1 subgoal):\n 1. p = []", "using subterm_trm_ord"], ["proof (prove)\nusing this:\n  (u, t) \\<notin> trm_ord\n  subterm t p u\n  \\<lbrakk>subterm ?t ?p ?s; ?p \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> (?s, ?t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. p = []", "by auto"], ["proof (state)\nthis:\n  p = []\n\ngoal (1 subgoal):\n 1. (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>')\n    \\<notin> lit_ord \\<Longrightarrow>\n    False", "have \"\\<not> proper_subterm_red t S \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> proper_subterm_red t S \\<sigma>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. proper_subterm_red t S \\<sigma> \\<Longrightarrow> False", "assume \"proper_subterm_red t S \\<sigma>\""], ["proof (state)\nthis:\n  proper_subterm_red t S \\<sigma>\n\ngoal (1 subgoal):\n 1. proper_subterm_red t S \\<sigma> \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  proper_subterm_red t S \\<sigma>", "obtain p' s where \"p' \\<noteq> Nil\" and \"subterm t p' s\" \n        \"trm_rep (subst s \\<sigma>) S \\<noteq> (subst s \\<sigma>)\""], ["proof (prove)\nusing this:\n  proper_subterm_red t S \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>p' s.\n        \\<lbrakk>p' \\<noteq> []; subterm t p' s;\n         trm_rep (s \\<lhd> \\<sigma>) S \\<noteq> s \\<lhd> \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding proper_subterm_red_def"], ["proof (prove)\nusing this:\n  \\<exists>p s.\n     subterm t p s \\<and>\n     p \\<noteq> [] \\<and>\n     trm_rep (s \\<lhd> \\<sigma>) S \\<noteq> s \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>p' s.\n        \\<lbrakk>p' \\<noteq> []; subterm t p' s;\n         trm_rep (s \\<lhd> \\<sigma>) S \\<noteq> s \\<lhd> \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  p' \\<noteq> []\n  subterm t p' s\n  trm_rep (s \\<lhd> \\<sigma>) S \\<noteq> s \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. proper_subterm_red t S \\<sigma> \\<Longrightarrow> False", "from \\<open>p = Nil\\<close> and \\<open>p' \\<noteq> Nil\\<close>"], ["proof (chain)\npicking this:\n  p = []\n  p' \\<noteq> []", "have \"(p',p) \\<in> (pos_ord C t)\""], ["proof (prove)\nusing this:\n  p = []\n  p' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (p', p) \\<in> pos_ord C t", "using pos_ord_nil"], ["proof (prove)\nusing this:\n  p = []\n  p' \\<noteq> []\n  \\<forall>x y p. p \\<noteq> [] \\<longrightarrow> (p, []) \\<in> pos_ord x y\n\ngoal (1 subgoal):\n 1. (p', p) \\<in> pos_ord C t", "by auto"], ["proof (state)\nthis:\n  (p', p) \\<in> pos_ord C t\n\ngoal (1 subgoal):\n 1. proper_subterm_red t S \\<sigma> \\<Longrightarrow> False", "from \\<open>subterm t p' s\\<close>"], ["proof (chain)\npicking this:\n  subterm t p' s", "have \"subterm (subst t \\<sigma>) p' (subst s \\<sigma>)\""], ["proof (prove)\nusing this:\n  subterm t p' s\n\ngoal (1 subgoal):\n 1. subterm (t \\<lhd> \\<sigma>) p' (s \\<lhd> \\<sigma>)", "by (simp add: substs_preserve_subterms)"], ["proof (state)\nthis:\n  subterm (t \\<lhd> \\<sigma>) p' (s \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. proper_subterm_red t S \\<sigma> \\<Longrightarrow> False", "from this and \\<open>(p',p) \\<in> (pos_ord C t)\\<close> mr and \\<open>trm_rep (subst s \\<sigma>) S \\<noteq> (subst s \\<sigma>)\\<close> \\<open>mp=p\\<close>"], ["proof (chain)\npicking this:\n  subterm (t \\<lhd> \\<sigma>) p' (s \\<lhd> \\<sigma>)\n  (p', p) \\<in> pos_ord C t\n  minimal_redex mp (t \\<lhd> \\<sigma>) C S t\n  trm_rep (s \\<lhd> \\<sigma>) S \\<noteq> s \\<lhd> \\<sigma>\n  mp = p", "show False"], ["proof (prove)\nusing this:\n  subterm (t \\<lhd> \\<sigma>) p' (s \\<lhd> \\<sigma>)\n  (p', p) \\<in> pos_ord C t\n  minimal_redex mp (t \\<lhd> \\<sigma>) C S t\n  trm_rep (s \\<lhd> \\<sigma>) S \\<noteq> s \\<lhd> \\<sigma>\n  mp = p\n\ngoal (1 subgoal):\n 1. False", "using minimal_redex_def"], ["proof (prove)\nusing this:\n  subterm (t \\<lhd> \\<sigma>) p' (s \\<lhd> \\<sigma>)\n  (p', p) \\<in> pos_ord C t\n  minimal_redex mp (t \\<lhd> \\<sigma>) C S t\n  trm_rep (s \\<lhd> \\<sigma>) S \\<noteq> s \\<lhd> \\<sigma>\n  mp = p\n  minimal_redex ?p ?t ?C ?S ?t' =\n  (\\<forall>q s.\n      (q, ?p) \\<in> pos_ord ?C ?t' \\<longrightarrow>\n      subterm ?t q s \\<longrightarrow> trm_rep s ?S = s)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> proper_subterm_red t S \\<sigma>\n\ngoal (1 subgoal):\n 1. (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>')\n    \\<notin> lit_ord \\<Longrightarrow>\n    False", "from \\<open>(u,t) \\<notin> trm_ord\\<close> and \\<open>u = t \\<or> (u,t) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  (u, t) \\<notin> trm_ord\n  u = t \\<or> (u, t) \\<in> trm_ord", "have \"u = t\""], ["proof (prove)\nusing this:\n  (u, t) \\<notin> trm_ord\n  u = t \\<or> (u, t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. u = t", "by auto"], ["proof (state)\nthis:\n  u = t\n\ngoal (1 subgoal):\n 1. (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>')\n    \\<notin> lit_ord \\<Longrightarrow>\n    False", "have \"polarity = pos\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polarity = pos", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. polarity \\<noteq> pos \\<Longrightarrow> False", "assume \"polarity \\<noteq> pos\""], ["proof (state)\nthis:\n  polarity \\<noteq> pos\n\ngoal (1 subgoal):\n 1. polarity \\<noteq> pos \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  polarity \\<noteq> pos", "have \"polarity = neg\""], ["proof (prove)\nusing this:\n  polarity \\<noteq> pos\n\ngoal (1 subgoal):\n 1. polarity = neg", "using sign.exhaust"], ["proof (prove)\nusing this:\n  polarity \\<noteq> pos\n  \\<lbrakk>?y = pos \\<Longrightarrow> ?P;\n   ?y = neg \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. polarity = neg", "by auto"], ["proof (state)\nthis:\n  polarity = neg\n\ngoal (1 subgoal):\n 1. polarity \\<noteq> pos \\<Longrightarrow> False", "from \\<open>u = t\\<close>"], ["proof (chain)\npicking this:\n  u = t", "have \"subst t \\<sigma>' = subst u \\<sigma>'\""], ["proof (prove)\nusing this:\n  u = t\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. polarity \\<noteq> pos \\<Longrightarrow> False", "from this and \\<open>v = (subst u \\<sigma>)\\<close> and \\<open>v = (subst lhs \\<eta>)\\<close>\n          and \\<open>subst lhs \\<eta> = subst lhs \\<sigma>'\\<close> \n          and \\<open>(subst u \\<sigma>) = (subst u \\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>'\n  v = u \\<lhd> \\<sigma>\n  v = lhs \\<lhd> \\<eta>\n  lhs \\<lhd> \\<eta> = lhs \\<lhd> \\<sigma>'\n  u \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>'", "have \"(subst t \\<sigma>') = (subst lhs \\<sigma>')\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>'\n  v = u \\<lhd> \\<sigma>\n  v = lhs \\<lhd> \\<eta>\n  lhs \\<lhd> \\<eta> = lhs \\<lhd> \\<sigma>'\n  u \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma>' = lhs \\<lhd> \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma>' = lhs \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. polarity \\<noteq> pos \\<Longrightarrow> False", "from this and \\<open>polarity = neg\\<close> \\<open>orient_lit (subst_lit L1 \\<sigma>') \n          (subst t \\<sigma>') (subst s \\<sigma>') polarity\\<close> \n           and \\<open>orient_lit (subst_lit L2 \\<sigma>') \n          (subst lhs \\<sigma>') (subst rhs \\<sigma>') pos\\<close> \n          \\<open>(subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<notin> lit_ord\\<close>\n          \\<open>vars_of_lit (subst_lit L1 \\<sigma>')  = {}\\<close> \n          \\<open>vars_of_lit (subst_lit L2 \\<sigma>') = {}\\<close>"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<sigma>' = lhs \\<lhd> \\<sigma>'\n  polarity = neg\n  orient_lit (subst_lit L1 \\<sigma>') (t \\<lhd> \\<sigma>')\n   (s \\<lhd> \\<sigma>') polarity\n  orient_lit (subst_lit L2 \\<sigma>') (lhs \\<lhd> \\<sigma>')\n   (rhs \\<lhd> \\<sigma>') pos\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<notin> lit_ord\n  vars_of_lit (subst_lit L1 \\<sigma>') = {}\n  vars_of_lit (subst_lit L2 \\<sigma>') = {}", "show False"], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma>' = lhs \\<lhd> \\<sigma>'\n  polarity = neg\n  orient_lit (subst_lit L1 \\<sigma>') (t \\<lhd> \\<sigma>')\n   (s \\<lhd> \\<sigma>') polarity\n  orient_lit (subst_lit L2 \\<sigma>') (lhs \\<lhd> \\<sigma>')\n   (rhs \\<lhd> \\<sigma>') pos\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<notin> lit_ord\n  vars_of_lit (subst_lit L1 \\<sigma>') = {}\n  vars_of_lit (subst_lit L2 \\<sigma>') = {}\n\ngoal (1 subgoal):\n 1. False", "using lit_ord_neg_lit_lhs"], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma>' = lhs \\<lhd> \\<sigma>'\n  polarity = neg\n  orient_lit (subst_lit L1 \\<sigma>') (t \\<lhd> \\<sigma>')\n   (s \\<lhd> \\<sigma>') polarity\n  orient_lit (subst_lit L2 \\<sigma>') (lhs \\<lhd> \\<sigma>')\n   (rhs \\<lhd> \\<sigma>') pos\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<notin> lit_ord\n  vars_of_lit (subst_lit L1 \\<sigma>') = {}\n  vars_of_lit (subst_lit L2 \\<sigma>') = {}\n  \\<lbrakk>orient_lit ?x1.0 ?s ?t1.0 pos; orient_lit ?x2.0 ?s ?t2.0 neg;\n   vars_of_lit ?x1.0 = {}; vars_of_lit ?x2.0 = {}\\<rbrakk>\n  \\<Longrightarrow> (?x1.0, ?x2.0) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  polarity = pos\n\ngoal (1 subgoal):\n 1. (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>')\n    \\<notin> lit_ord \\<Longrightarrow>\n    False", "from  \\<open>vars_of_lit (subst_lit L1 \\<sigma>) = {}\\<close> assms(6)"], ["proof (chain)\npicking this:\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}\n  orient_lit_inst L1 t s polarity \\<sigma>", "have \"vars_of (subst t \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}\n  orient_lit_inst L1 t s polarity \\<sigma>\n\ngoal (1 subgoal):\n 1. vars_of (t \\<lhd> \\<sigma>) = {}", "using lift_orient_lit orient_lit_vars"], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}\n  orient_lit_inst L1 t s polarity \\<sigma>\n  orient_lit_inst ?L ?t ?s ?p ?\\<sigma> \\<Longrightarrow>\n  orient_lit (subst_lit ?L ?\\<sigma>) (?t \\<lhd> ?\\<sigma>)\n   (?s \\<lhd> ?\\<sigma>) ?p\n  orient_lit ?L ?t ?s ?p \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of (t \\<lhd> \\<sigma>) = {}", "by blast"], ["proof (state)\nthis:\n  vars_of (t \\<lhd> \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>')\n    \\<notin> lit_ord \\<Longrightarrow>\n    False", "from  \\<open>vars_of_lit (subst_lit L1 \\<sigma>) = {}\\<close> assms(6)"], ["proof (chain)\npicking this:\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}\n  orient_lit_inst L1 t s polarity \\<sigma>", "have \"vars_of (subst s \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}\n  orient_lit_inst L1 t s polarity \\<sigma>\n\ngoal (1 subgoal):\n 1. vars_of (s \\<lhd> \\<sigma>) = {}", "using lift_orient_lit orient_lit_vars"], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}\n  orient_lit_inst L1 t s polarity \\<sigma>\n  orient_lit_inst ?L ?t ?s ?p ?\\<sigma> \\<Longrightarrow>\n  orient_lit (subst_lit ?L ?\\<sigma>) (?t \\<lhd> ?\\<sigma>)\n   (?s \\<lhd> ?\\<sigma>) ?p\n  orient_lit ?L ?t ?s ?p \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of (s \\<lhd> \\<sigma>) = {}", "by blast"], ["proof (state)\nthis:\n  vars_of (s \\<lhd> \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>')\n    \\<notin> lit_ord \\<Longrightarrow>\n    False", "have \"trm_rep (subst t \\<sigma>) S \\<noteq> trm_rep (subst s \\<sigma>) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> trm_rep (s \\<lhd> \\<sigma>) S", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S =\n    trm_rep (s \\<lhd> \\<sigma>) S \\<Longrightarrow>\n    False", "assume \"trm_rep (subst t \\<sigma>) S = trm_rep (subst s \\<sigma>) S\""], ["proof (state)\nthis:\n  trm_rep (t \\<lhd> \\<sigma>) S = trm_rep (s \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S =\n    trm_rep (s \\<lhd> \\<sigma>) S \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  trm_rep (t \\<lhd> \\<sigma>) S = trm_rep (s \\<lhd> \\<sigma>) S", "have \"validate_ground_eq ?I (Eq (subst t \\<sigma>) (subst s \\<sigma>))\""], ["proof (prove)\nusing this:\n  trm_rep (t \\<lhd> \\<sigma>) S = trm_rep (s \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. validate_ground_eq (same_values (\\<lambda>t. trm_rep t S))\n     (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))", "unfolding same_values_def"], ["proof (prove)\nusing this:\n  trm_rep (t \\<lhd> \\<sigma>) S = trm_rep (s \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. validate_ground_eq (\\<lambda>x y. trm_rep x S = trm_rep y S)\n     (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))", "using validate_ground_eq.simps"], ["proof (prove)\nusing this:\n  trm_rep (t \\<lhd> \\<sigma>) S = trm_rep (s \\<lhd> \\<sigma>) S\n  validate_ground_eq ?I (Eq ?t ?s) = ?I ?t ?s\n\ngoal (1 subgoal):\n 1. validate_ground_eq (\\<lambda>x y. trm_rep x S = trm_rep y S)\n     (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))", "by (metis (mono_tags, lifting))"], ["proof (state)\nthis:\n  validate_ground_eq (same_values (\\<lambda>t. trm_rep t S))\n   (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))\n\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S =\n    trm_rep (s \\<lhd> \\<sigma>) S \\<Longrightarrow>\n    False", "from \\<open>trm_rep (subst t \\<sigma>) S = trm_rep (subst s \\<sigma>) S\\<close>"], ["proof (chain)\npicking this:\n  trm_rep (t \\<lhd> \\<sigma>) S = trm_rep (s \\<lhd> \\<sigma>) S", "have \"validate_ground_eq ?I (Eq (subst s \\<sigma>) (subst t \\<sigma>))\""], ["proof (prove)\nusing this:\n  trm_rep (t \\<lhd> \\<sigma>) S = trm_rep (s \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. validate_ground_eq (same_values (\\<lambda>t. trm_rep t S))\n     (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))", "unfolding same_values_def"], ["proof (prove)\nusing this:\n  trm_rep (t \\<lhd> \\<sigma>) S = trm_rep (s \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. validate_ground_eq (\\<lambda>x y. trm_rep x S = trm_rep y S)\n     (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))", "using validate_ground_eq.simps"], ["proof (prove)\nusing this:\n  trm_rep (t \\<lhd> \\<sigma>) S = trm_rep (s \\<lhd> \\<sigma>) S\n  validate_ground_eq ?I (Eq ?t ?s) = ?I ?t ?s\n\ngoal (1 subgoal):\n 1. validate_ground_eq (\\<lambda>x y. trm_rep x S = trm_rep y S)\n     (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))", "by (metis (mono_tags, lifting))"], ["proof (state)\nthis:\n  validate_ground_eq (same_values (\\<lambda>t. trm_rep t S))\n   (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))\n\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S =\n    trm_rep (s \\<lhd> \\<sigma>) S \\<Longrightarrow>\n    False", "from \\<open>orient_lit_inst L1 t s polarity \\<sigma>\\<close> and \\<open>polarity=pos\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L1 t s polarity \\<sigma>\n  polarity = pos", "have \"L1 = (Pos (Eq t s)) \\<or> L1 = (Pos (Eq s t))\""], ["proof (prove)\nusing this:\n  orient_lit_inst L1 t s polarity \\<sigma>\n  polarity = pos\n\ngoal (1 subgoal):\n 1. L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  (L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  polarity = pos \\<or>\n  (L1 = Neg (Eq t s) \\<or> L1 = Neg (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  polarity = neg\n  polarity = pos\n\ngoal (1 subgoal):\n 1. L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)", "by auto"], ["proof (state)\nthis:\n  L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)\n\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S =\n    trm_rep (s \\<lhd> \\<sigma>) S \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)", "have \"subst_lit L1 \\<sigma> = (Pos (Eq (subst t \\<sigma>)  (subst s \\<sigma>))) \\<or>\n        subst_lit L1 \\<sigma> = (Pos (Eq (subst s \\<sigma>)  (subst t \\<sigma>)))\""], ["proof (prove)\nusing this:\n  L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)\n\ngoal (1 subgoal):\n 1. subst_lit L1 \\<sigma> =\n    Pos (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)) \\<or>\n    subst_lit L1 \\<sigma> = Pos (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))", "by auto"], ["proof (state)\nthis:\n  subst_lit L1 \\<sigma> =\n  Pos (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)) \\<or>\n  subst_lit L1 \\<sigma> = Pos (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))\n\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S =\n    trm_rep (s \\<lhd> \\<sigma>) S \\<Longrightarrow>\n    False", "from this and \\<open>validate_ground_eq ?I (Eq (subst s \\<sigma>) (subst t \\<sigma>))\\<close>\n        and \\<open>validate_ground_eq ?I (Eq (subst t \\<sigma>) (subst s \\<sigma>))\\<close>"], ["proof (chain)\npicking this:\n  subst_lit L1 \\<sigma> =\n  Pos (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)) \\<or>\n  subst_lit L1 \\<sigma> = Pos (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))\n  validate_ground_eq (same_values (\\<lambda>t. trm_rep t S))\n   (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))\n  validate_ground_eq (same_values (\\<lambda>t. trm_rep t S))\n   (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))", "have \"validate_ground_lit ?I (subst_lit L1 \\<sigma>)\""], ["proof (prove)\nusing this:\n  subst_lit L1 \\<sigma> =\n  Pos (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)) \\<or>\n  subst_lit L1 \\<sigma> = Pos (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))\n  validate_ground_eq (same_values (\\<lambda>t. trm_rep t S))\n   (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))\n  validate_ground_eq (same_values (\\<lambda>t. trm_rep t S))\n   (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))\n\ngoal (1 subgoal):\n 1. validate_ground_lit (same_values (\\<lambda>t. trm_rep t S))\n     (subst_lit L1 \\<sigma>)", "using validate_ground_lit.simps(1)"], ["proof (prove)\nusing this:\n  subst_lit L1 \\<sigma> =\n  Pos (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)) \\<or>\n  subst_lit L1 \\<sigma> = Pos (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))\n  validate_ground_eq (same_values (\\<lambda>t. trm_rep t S))\n   (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))\n  validate_ground_eq (same_values (\\<lambda>t. trm_rep t S))\n   (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))\n  validate_ground_lit ?I (Pos ?E) = validate_ground_eq ?I ?E\n\ngoal (1 subgoal):\n 1. validate_ground_lit (same_values (\\<lambda>t. trm_rep t S))\n     (subst_lit L1 \\<sigma>)", "by metis"], ["proof (state)\nthis:\n  validate_ground_lit (same_values (\\<lambda>t. trm_rep t S))\n   (subst_lit L1 \\<sigma>)\n\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S =\n    trm_rep (s \\<lhd> \\<sigma>) S \\<Longrightarrow>\n    False", "from \\<open>L1 \\<in> (cl_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  L1 \\<in> cl_ecl C", "have \"(subst_lit L1 \\<sigma>) \\<in> (subst_cl (cl_ecl C) \\<sigma>)\""], ["proof (prove)\nusing this:\n  L1 \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. subst_lit L1 \\<sigma> \\<in> subst_cl (cl_ecl C) \\<sigma>", "by auto"], ["proof (state)\nthis:\n  subst_lit L1 \\<sigma> \\<in> subst_cl (cl_ecl C) \\<sigma>\n\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S =\n    trm_rep (s \\<lhd> \\<sigma>) S \\<Longrightarrow>\n    False", "from this and \\<open>validate_ground_lit ?I (subst_lit L1 \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  subst_lit L1 \\<sigma> \\<in> subst_cl (cl_ecl C) \\<sigma>\n  validate_ground_lit (same_values (\\<lambda>t. trm_rep t S))\n   (subst_lit L1 \\<sigma>)", "have \"validate_ground_clause ?I (subst_cl (cl_ecl C) \\<sigma>)\""], ["proof (prove)\nusing this:\n  subst_lit L1 \\<sigma> \\<in> subst_cl (cl_ecl C) \\<sigma>\n  validate_ground_lit (same_values (\\<lambda>t. trm_rep t S))\n   (subst_lit L1 \\<sigma>)\n\ngoal (1 subgoal):\n 1. validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n     (subst_cl (cl_ecl C) \\<sigma>)", "using validate_ground_clause.simps"], ["proof (prove)\nusing this:\n  subst_lit L1 \\<sigma> \\<in> subst_cl (cl_ecl C) \\<sigma>\n  validate_ground_lit (same_values (\\<lambda>t. trm_rep t S))\n   (subst_lit L1 \\<sigma>)\n  validate_ground_clause ?I ?C =\n  (\\<exists>L. L \\<in> ?C \\<and> validate_ground_lit ?I L)\n\ngoal (1 subgoal):\n 1. validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n     (subst_cl (cl_ecl C) \\<sigma>)", "by metis"], ["proof (state)\nthis:\n  validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n   (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S =\n    trm_rep (s \\<lhd> \\<sigma>) S \\<Longrightarrow>\n    False", "from this and \\<open>\\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n   (subst_cl (cl_ecl C) \\<sigma>)\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)", "show False"], ["proof (prove)\nusing this:\n  validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n   (subst_cl (cl_ecl C) \\<sigma>)\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. False", "unfolding int_clset_def"], ["proof (prove)\nusing this:\n  validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n   (subst_cl (cl_ecl C) \\<sigma>)\n  \\<not> validate_ground_clause (same_values (\\<lambda>x. trm_rep x S))\n          (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> trm_rep (s \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>')\n    \\<notin> lit_ord \\<Longrightarrow>\n    False", "have cv': \"(candidate_values (trm_rep (subst s \\<sigma>) S) C (cl_ecl C) (subst_cl (cl_ecl C) \\<sigma>) \n                  (subst s \\<sigma>) (subst_lit L1 \\<sigma>) L1 \\<sigma> t s v S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. candidate_values (trm_rep (s \\<lhd> \\<sigma>) S) C (cl_ecl C)\n     (subst_cl (cl_ecl C) \\<sigma>) (s \\<lhd> \\<sigma>)\n     (subst_lit L1 \\<sigma>) L1 \\<sigma> t s v S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. candidate_values (trm_rep (s \\<lhd> \\<sigma>) S) C (cl_ecl C)\n     (subst_cl (cl_ecl C) \\<sigma>) (s \\<lhd> \\<sigma>)\n     (subst_lit L1 \\<sigma>) L1 \\<sigma> t s v S", "from \\<open>polarity=pos\\<close> and \\<open>orient_lit_inst L1 t s polarity \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  polarity = pos\n  orient_lit_inst L1 t s polarity \\<sigma>", "have \"\\<not>negative_literal L1\""], ["proof (prove)\nusing this:\n  polarity = pos\n  orient_lit_inst L1 t s polarity \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> negative_literal L1", "unfolding  orient_lit_inst_def"], ["proof (prove)\nusing this:\n  polarity = pos\n  (L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  polarity = pos \\<or>\n  (L1 = Neg (Eq t s) \\<or> L1 = Neg (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  polarity = neg\n\ngoal (1 subgoal):\n 1. \\<not> negative_literal L1", "by auto"], ["proof (state)\nthis:\n  \\<not> negative_literal L1\n\ngoal (1 subgoal):\n 1. candidate_values (trm_rep (s \\<lhd> \\<sigma>) S) C (cl_ecl C)\n     (subst_cl (cl_ecl C) \\<sigma>) (s \\<lhd> \\<sigma>)\n     (subst_lit L1 \\<sigma>) L1 \\<sigma> t s v S", "from this and \\<open>eligible_literal L1 C \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  \\<not> negative_literal L1\n  eligible_literal L1 C \\<sigma>", "have \"sel(cl_ecl C) = {}\" and \"maximal_literal (subst_lit L1 \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\""], ["proof (prove)\nusing this:\n  \\<not> negative_literal L1\n  eligible_literal L1 C \\<sigma>\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C) = {} &&&\n    maximal_literal (subst_lit L1 \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)", "using sel_neg"], ["proof (prove)\nusing this:\n  \\<not> negative_literal L1\n  eligible_literal L1 C \\<sigma>\n  \\<forall>x.\n     sel (cl_ecl x) \\<subseteq> cl_ecl x \\<and>\n     (\\<forall>y\\<in>sel (cl_ecl x). negative_literal y)\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C) = {} &&&\n    maximal_literal (subst_lit L1 \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)", "unfolding eligible_literal_def"], ["proof (prove)\nusing this:\n  \\<not> negative_literal L1\n  L1 \\<in> sel (cl_ecl C) \\<or>\n  sel (cl_ecl C) = {} \\<and>\n  maximal_literal (subst_lit L1 \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n  \\<forall>x.\n     sel (cl_ecl x) \\<subseteq> cl_ecl x \\<and>\n     (\\<forall>y\\<in>sel (cl_ecl x). negative_literal y)\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C) = {} &&&\n    maximal_literal (subst_lit L1 \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  sel (cl_ecl C) = {}\n  maximal_literal (subst_lit L1 \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. candidate_values (trm_rep (s \\<lhd> \\<sigma>) S) C (cl_ecl C)\n     (subst_cl (cl_ecl C) \\<sigma>) (s \\<lhd> \\<sigma>)\n     (subst_lit L1 \\<sigma>) L1 \\<sigma> t s v S", "from  \\<open>v = subst u \\<sigma>\\<close> and \\<open>u = t\\<close>"], ["proof (chain)\npicking this:\n  v = u \\<lhd> \\<sigma>\n  u = t", "have \"v = subst t \\<sigma>\""], ["proof (prove)\nusing this:\n  v = u \\<lhd> \\<sigma>\n  u = t\n\ngoal (1 subgoal):\n 1. v = t \\<lhd> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  v = t \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. candidate_values (trm_rep (s \\<lhd> \\<sigma>) S) C (cl_ecl C)\n     (subst_cl (cl_ecl C) \\<sigma>) (s \\<lhd> \\<sigma>)\n     (subst_lit L1 \\<sigma>) L1 \\<sigma> t s v S", "from assms(7) \\<open>C \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  C \\<in> S", "have \"finite (cl_ecl C)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. finite (cl_ecl C)", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl C)\n\ngoal (1 subgoal):\n 1. candidate_values (trm_rep (s \\<lhd> \\<sigma>) S) C (cl_ecl C)\n     (subst_cl (cl_ecl C) \\<sigma>) (s \\<lhd> \\<sigma>)\n     (subst_lit L1 \\<sigma>) L1 \\<sigma> t s v S", "have \"v \\<notin> subst_set (trms_ecl C) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> subst_set (trms_ecl C) \\<sigma>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> subst_set (trms_ecl C) \\<sigma> \\<Longrightarrow> False", "assume \"v \\<in> subst_set (trms_ecl C) \\<sigma>\""], ["proof (state)\nthis:\n  v \\<in> subst_set (trms_ecl C) \\<sigma>\n\ngoal (1 subgoal):\n 1. v \\<in> subst_set (trms_ecl C) \\<sigma> \\<Longrightarrow> False", "from this and assms(12) \\<open>subterm (subst t \\<sigma>) p v\\<close> \\<open>v = subst t \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  v \\<in> subst_set (trms_ecl C) \\<sigma>\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n  subterm (t \\<lhd> \\<sigma>) p v\n  v = t \\<lhd> \\<sigma>", "have \"trm_rep v S = v\""], ["proof (prove)\nusing this:\n  v \\<in> subst_set (trms_ecl C) \\<sigma>\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n  subterm (t \\<lhd> \\<sigma>) p v\n  v = t \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. trm_rep v S = v", "unfolding all_trms_irreducible_def occurs_in_def"], ["proof (prove)\nusing this:\n  v \\<in> subst_set (trms_ecl C) \\<sigma>\n  \\<forall>x y.\n     x \\<in> subst_set (trms_ecl C) \\<sigma> \\<longrightarrow>\n     (\\<exists>p. subterm x p y) \\<longrightarrow> trm_rep y S = y\n  subterm (t \\<lhd> \\<sigma>) p v\n  v = t \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. trm_rep v S = v", "by blast"], ["proof (state)\nthis:\n  trm_rep v S = v\n\ngoal (1 subgoal):\n 1. v \\<in> subst_set (trms_ecl C) \\<sigma> \\<Longrightarrow> False", "from this \\<open>v = subst t \\<sigma>\\<close> \\<open>trm_rep (subst t \\<sigma>) S \\<noteq> (subst t \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  trm_rep v S = v\n  v = t \\<lhd> \\<sigma>\n  trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> t \\<lhd> \\<sigma>", "show False"], ["proof (prove)\nusing this:\n  trm_rep v S = v\n  v = t \\<lhd> \\<sigma>\n  trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> t \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<notin> subst_set (trms_ecl C) \\<sigma>\n\ngoal (1 subgoal):\n 1. candidate_values (trm_rep (s \\<lhd> \\<sigma>) S) C (cl_ecl C)\n     (subst_cl (cl_ecl C) \\<sigma>) (s \\<lhd> \\<sigma>)\n     (subst_lit L1 \\<sigma>) L1 \\<sigma> t s v S", "from assms(13)"], ["proof (chain)\npicking this:\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)", "have \"smaller_lits_are_false v (subst_cl (cl_ecl C) \\<sigma>) S\""], ["proof (prove)\nusing this:\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. smaller_lits_are_false v (subst_cl (cl_ecl C) \\<sigma>) S", "using smaller_lits_are_false_if_cl_not_valid [of S \"(subst_cl (cl_ecl C) \\<sigma>)\" ]"], ["proof (prove)\nusing this:\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl C) \\<sigma>) \\<Longrightarrow>\n  smaller_lits_are_false ?t (subst_cl (cl_ecl C) \\<sigma>) S\n\ngoal (1 subgoal):\n 1. smaller_lits_are_false v (subst_cl (cl_ecl C) \\<sigma>) S", "by blast"], ["proof (state)\nthis:\n  smaller_lits_are_false v (subst_cl (cl_ecl C) \\<sigma>) S\n\ngoal (1 subgoal):\n 1. candidate_values (trm_rep (s \\<lhd> \\<sigma>) S) C (cl_ecl C)\n     (subst_cl (cl_ecl C) \\<sigma>) (s \\<lhd> \\<sigma>)\n     (subst_lit L1 \\<sigma>) L1 \\<sigma> t s v S", "from assms(1) \\<open>\\<not> proper_subterm_red t S \\<sigma>\\<close> \\<open>polarity=pos\\<close> \\<open>v = subst t \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  polarity = neg \\<or>\n  \\<not> equivalent_eq_exists t s (cl_ecl C) (int_clset S) \\<sigma> L1 \\<or>\n  proper_subterm_red t S \\<sigma>\n  \\<not> proper_subterm_red t S \\<sigma>\n  polarity = pos\n  v = t \\<lhd> \\<sigma>", "have \n          \"maximal_literal_is_unique v (subst s \\<sigma>) (cl_ecl C) L1 S \\<sigma>\""], ["proof (prove)\nusing this:\n  polarity = neg \\<or>\n  \\<not> equivalent_eq_exists t s (cl_ecl C) (int_clset S) \\<sigma> L1 \\<or>\n  proper_subterm_red t S \\<sigma>\n  \\<not> proper_subterm_red t S \\<sigma>\n  polarity = pos\n  v = t \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. maximal_literal_is_unique v (s \\<lhd> \\<sigma>) (cl_ecl C) L1 S \\<sigma>", "using maximal_literal_is_unique_lemma [of t s \"(cl_ecl C)\" S \\<sigma> L1]"], ["proof (prove)\nusing this:\n  polarity = neg \\<or>\n  \\<not> equivalent_eq_exists t s (cl_ecl C) (int_clset S) \\<sigma> L1 \\<or>\n  proper_subterm_red t S \\<sigma>\n  \\<not> proper_subterm_red t S \\<sigma>\n  polarity = pos\n  v = t \\<lhd> \\<sigma>\n  \\<not> equivalent_eq_exists t s (cl_ecl C) (int_clset S) \\<sigma>\n          L1 \\<Longrightarrow>\n  maximal_literal_is_unique (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   (cl_ecl C) L1 S \\<sigma>\n\ngoal (1 subgoal):\n 1. maximal_literal_is_unique v (s \\<lhd> \\<sigma>) (cl_ecl C) L1 S \\<sigma>", "by blast"], ["proof (state)\nthis:\n  maximal_literal_is_unique v (s \\<lhd> \\<sigma>) (cl_ecl C) L1 S \\<sigma>\n\ngoal (1 subgoal):\n 1. candidate_values (trm_rep (s \\<lhd> \\<sigma>) S) C (cl_ecl C)\n     (subst_cl (cl_ecl C) \\<sigma>) (s \\<lhd> \\<sigma>)\n     (subst_lit L1 \\<sigma>) L1 \\<sigma> t s v S", "from \\<open>all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>) (\\<lambda>t. trm_rep t S)\\<close>"], ["proof (chain)\npicking this:\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)", "have \"trms_irreducible C \\<sigma> S v\""], ["proof (prove)\nusing this:\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n\ngoal (1 subgoal):\n 1. trms_irreducible C \\<sigma> S v", "using trms_irreducible_lemma [of C \\<sigma> S v]"], ["proof (prove)\nusing this:\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n  trms_irreducible C \\<sigma> S v\n\ngoal (1 subgoal):\n 1. trms_irreducible C \\<sigma> S v", "by blast"], ["proof (state)\nthis:\n  trms_irreducible C \\<sigma> S v\n\ngoal (1 subgoal):\n 1. candidate_values (trm_rep (s \\<lhd> \\<sigma>) S) C (cl_ecl C)\n     (subst_cl (cl_ecl C) \\<sigma>) (s \\<lhd> \\<sigma>)\n     (subst_lit L1 \\<sigma>) L1 \\<sigma> t s v S", "have \"(subst s \\<sigma>, subst t \\<sigma>) \\<in> trm_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "from \\<open>orient_lit_inst L1 t s polarity \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L1 t s polarity \\<sigma>", "have \"(subst t \\<sigma>, subst s \\<sigma>) \\<notin> trm_ord\""], ["proof (prove)\nusing this:\n  orient_lit_inst L1 t s polarity \\<sigma>\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  (L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  polarity = pos \\<or>\n  (L1 = Neg (Eq t s) \\<or> L1 = Neg (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  polarity = neg\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "from \\<open>trm_rep (subst t \\<sigma>) S \\<noteq> trm_rep (subst s \\<sigma>) S\\<close>"], ["proof (chain)\npicking this:\n  trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> trm_rep (s \\<lhd> \\<sigma>) S", "have \"(subst t \\<sigma>) \\<noteq> (subst s \\<sigma>)\""], ["proof (prove)\nusing this:\n  trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> trm_rep (s \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>", "by metis"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "from this and \\<open>(subst t \\<sigma>, subst s \\<sigma>) \\<notin> trm_ord\\<close> \n            \\<open>vars_of (subst t \\<sigma>) = {}\\<close>\n            \\<open>vars_of (subst s \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (t \\<lhd> \\<sigma>) = {}\n  vars_of (s \\<lhd> \\<sigma>) = {}", "show \"(subst s \\<sigma>, subst t \\<sigma>) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (t \\<lhd> \\<sigma>) = {}\n  vars_of (s \\<lhd> \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "using trm_ord_ground_total"], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (t \\<lhd> \\<sigma>) = {}\n  vars_of (s \\<lhd> \\<sigma>) = {}\n  \\<forall>x y.\n     ground_term x \\<longrightarrow>\n     ground_term y \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "unfolding ground_term_def"], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (t \\<lhd> \\<sigma>) = {}\n  vars_of (s \\<lhd> \\<sigma>) = {}\n  \\<forall>x y.\n     vars_of x = {} \\<longrightarrow>\n     vars_of y = {} \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. candidate_values (trm_rep (s \\<lhd> \\<sigma>) S) C (cl_ecl C)\n     (subst_cl (cl_ecl C) \\<sigma>) (s \\<lhd> \\<sigma>)\n     (subst_lit L1 \\<sigma>) L1 \\<sigma> t s v S", "from \\<open>C \\<in> S\\<close> \\<open>(subst s \\<sigma>, subst t \\<sigma>) \\<in> trm_ord\\<close> \n          and \\<open>polarity=pos\\<close> \\<open>orient_lit_inst L1 t s polarity \\<sigma>\\<close> and \\<open>sel (cl_ecl C) = {}\\<close> \n          and \\<open>L1 \\<in> cl_ecl C\\<close> \n          and \\<open>maximal_literal (subst_lit L1 \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\\<close>\n          and \\<open>ground_clause (subst_cl (cl_ecl C) \\<sigma>)\\<close> and \\<open>v = subst t \\<sigma>\\<close> \n          and \\<open>finite (cl_ecl C)\\<close> \n          and \\<open>v \\<notin> subst_set (trms_ecl C) \\<sigma>\\<close>\n          and \\<open>smaller_lits_are_false v (subst_cl (cl_ecl C) \\<sigma>) S\\<close> \n          and \\<open>maximal_literal_is_unique v (subst s \\<sigma>) (cl_ecl C) L1 S \\<sigma>\\<close>\n          and \\<open>trms_irreducible C \\<sigma> S v\\<close>"], ["proof (chain)\npicking this:\n  C \\<in> S\n  (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  polarity = pos\n  orient_lit_inst L1 t s polarity \\<sigma>\n  sel (cl_ecl C) = {}\n  L1 \\<in> cl_ecl C\n  maximal_literal (subst_lit L1 \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n  v = t \\<lhd> \\<sigma>\n  finite (cl_ecl C)\n  v \\<notin> subst_set (trms_ecl C) \\<sigma>\n  smaller_lits_are_false v (subst_cl (cl_ecl C) \\<sigma>) S\n  maximal_literal_is_unique v (s \\<lhd> \\<sigma>) (cl_ecl C) L1 S \\<sigma>\n  trms_irreducible C \\<sigma> S v", "show cv': \"(candidate_values (trm_rep (subst s \\<sigma>) S) C (cl_ecl C) (subst_cl (cl_ecl C) \\<sigma>) \n            (subst s \\<sigma>) (subst_lit L1 \\<sigma>) L1 \\<sigma> t s v S)\""], ["proof (prove)\nusing this:\n  C \\<in> S\n  (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  polarity = pos\n  orient_lit_inst L1 t s polarity \\<sigma>\n  sel (cl_ecl C) = {}\n  L1 \\<in> cl_ecl C\n  maximal_literal (subst_lit L1 \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n  v = t \\<lhd> \\<sigma>\n  finite (cl_ecl C)\n  v \\<notin> subst_set (trms_ecl C) \\<sigma>\n  smaller_lits_are_false v (subst_cl (cl_ecl C) \\<sigma>) S\n  maximal_literal_is_unique v (s \\<lhd> \\<sigma>) (cl_ecl C) L1 S \\<sigma>\n  trms_irreducible C \\<sigma> S v\n\ngoal (1 subgoal):\n 1. candidate_values (trm_rep (s \\<lhd> \\<sigma>) S) C (cl_ecl C)\n     (subst_cl (cl_ecl C) \\<sigma>) (s \\<lhd> \\<sigma>)\n     (subst_lit L1 \\<sigma>) L1 \\<sigma> t s v S", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  C \\<in> S\n  (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  polarity = pos\n  orient_lit_inst L1 t s polarity \\<sigma>\n  sel (cl_ecl C) = {}\n  L1 \\<in> cl_ecl C\n  maximal_literal (subst_lit L1 \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n  v = t \\<lhd> \\<sigma>\n  finite (cl_ecl C)\n  v \\<notin> subst_set (trms_ecl C) \\<sigma>\n  smaller_lits_are_false v (subst_cl (cl_ecl C) \\<sigma>) S\n  maximal_literal_is_unique v (s \\<lhd> \\<sigma>) (cl_ecl C) L1 S \\<sigma>\n  trms_irreducible C \\<sigma> S v\n\ngoal (1 subgoal):\n 1. C \\<in> S \\<and>\n    v \\<notin> subst_set (trms_ecl C) \\<sigma> \\<and>\n    trms_irreducible C \\<sigma> S v \\<and>\n    cl_ecl C = cl_ecl C \\<and>\n    (s \\<lhd> \\<sigma>, v) \\<in> trm_ord \\<and>\n    ((s \\<lhd> \\<sigma>, v) \\<in> trm_ord \\<longrightarrow>\n     trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (s \\<lhd> \\<sigma>) S) \\<and>\n    orient_lit_inst L1 t s pos \\<sigma> \\<and>\n    sel (cl_ecl C) = {} \\<and>\n    L1 \\<in> cl_ecl C \\<and>\n    maximal_literal (subst_lit L1 \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) \\<and>\n    subst_lit L1 \\<sigma> = subst_lit L1 \\<sigma> \\<and>\n    subst_cl (cl_ecl C) \\<sigma> = subst_cl (cl_ecl C) \\<sigma> \\<and>\n    ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<and>\n    v = t \\<lhd> \\<sigma> \\<and>\n    s \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<and>\n    finite (cl_ecl C) \\<and>\n    smaller_lits_are_false v (subst_cl (cl_ecl C) \\<sigma>) S \\<and>\n    maximal_literal_is_unique v (s \\<lhd> \\<sigma>) (cl_ecl C) L1 S \\<sigma>", "by blast"], ["proof (state)\nthis:\n  candidate_values (trm_rep (s \\<lhd> \\<sigma>) S) C (cl_ecl C)\n   (subst_cl (cl_ecl C) \\<sigma>) (s \\<lhd> \\<sigma>)\n   (subst_lit L1 \\<sigma>) L1 \\<sigma> t s v S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  candidate_values (trm_rep (s \\<lhd> \\<sigma>) S) C (cl_ecl C)\n   (subst_cl (cl_ecl C) \\<sigma>) (s \\<lhd> \\<sigma>)\n   (subst_lit L1 \\<sigma>) L1 \\<sigma> t s v S\n\ngoal (1 subgoal):\n 1. (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>')\n    \\<notin> lit_ord \\<Longrightarrow>\n    False", "from cv'"], ["proof (chain)\npicking this:\n  candidate_values (trm_rep (s \\<lhd> \\<sigma>) S) C (cl_ecl C)\n   (subst_cl (cl_ecl C) \\<sigma>) (s \\<lhd> \\<sigma>)\n   (subst_lit L1 \\<sigma>) L1 \\<sigma> t s v S", "have \"(trm_rep (subst s \\<sigma>) S,(subst s \\<sigma>)) \\<in> set_of_candidate_values S v\""], ["proof (prove)\nusing this:\n  candidate_values (trm_rep (s \\<lhd> \\<sigma>) S) C (cl_ecl C)\n   (subst_cl (cl_ecl C) \\<sigma>) (s \\<lhd> \\<sigma>)\n   (subst_lit L1 \\<sigma>) L1 \\<sigma> t s v S\n\ngoal (1 subgoal):\n 1. (trm_rep (s \\<lhd> \\<sigma>) S, s \\<lhd> \\<sigma>)\n    \\<in> set_of_candidate_values S v", "unfolding set_of_candidate_values_def"], ["proof (prove)\nusing this:\n  candidate_values (trm_rep (s \\<lhd> \\<sigma>) S) C (cl_ecl C)\n   (subst_cl (cl_ecl C) \\<sigma>) (s \\<lhd> \\<sigma>)\n   (subst_lit L1 \\<sigma>) L1 \\<sigma> t s v S\n\ngoal (1 subgoal):\n 1. (trm_rep (s \\<lhd> \\<sigma>) S, s \\<lhd> \\<sigma>)\n    \\<in> {pair.\n           \\<exists>z CC C' C s L L' \\<sigma> t' s'.\n              pair = (z, s) \\<and>\n              candidate_values z CC C' C s L L' \\<sigma> t' s' v S}", "by blast"], ["proof (state)\nthis:\n  (trm_rep (s \\<lhd> \\<sigma>) S, s \\<lhd> \\<sigma>)\n  \\<in> set_of_candidate_values S v\n\ngoal (1 subgoal):\n 1. (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>')\n    \\<notin> lit_ord \\<Longrightarrow>\n    False", "from this and min_pair and \\<open>pair = (zz,  gr_rhs)\\<close>"], ["proof (chain)\npicking this:\n  (trm_rep (s \\<lhd> \\<sigma>) S, s \\<lhd> \\<sigma>)\n  \\<in> set_of_candidate_values S v\n  \\<forall>pair'\\<in>set_of_candidate_values S v.\n     (snd pair', snd pair) \\<notin> trm_ord\n  pair = (zz, gr_rhs)", "have \"((subst s \\<sigma>),gr_rhs) \\<notin> trm_ord\""], ["proof (prove)\nusing this:\n  (trm_rep (s \\<lhd> \\<sigma>) S, s \\<lhd> \\<sigma>)\n  \\<in> set_of_candidate_values S v\n  \\<forall>pair'\\<in>set_of_candidate_values S v.\n     (snd pair', snd pair) \\<notin> trm_ord\n  pair = (zz, gr_rhs)\n\ngoal (1 subgoal):\n 1. (s \\<lhd> \\<sigma>, gr_rhs) \\<notin> trm_ord", "by (metis snd_conv)"], ["proof (state)\nthis:\n  (s \\<lhd> \\<sigma>, gr_rhs) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>')\n    \\<notin> lit_ord \\<Longrightarrow>\n    False", "have \"(subst s \\<sigma>)  \\<noteq> gr_rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<lhd> \\<sigma> \\<noteq> gr_rhs", "using \\<open>trm_rep v S = trm_rep gr_rhs S\\<close> \\<open>u = t\\<close> \\<open>v = subst u \\<sigma>\\<close>   \n            \\<open>trm_rep (subst t \\<sigma>) S \\<noteq> trm_rep (subst s \\<sigma>) S\\<close>"], ["proof (prove)\nusing this:\n  trm_rep v S = trm_rep gr_rhs S\n  u = t\n  v = u \\<lhd> \\<sigma>\n  trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> trm_rep (s \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. s \\<lhd> \\<sigma> \\<noteq> gr_rhs", "by blast"], ["proof (state)\nthis:\n  s \\<lhd> \\<sigma> \\<noteq> gr_rhs\n\ngoal (1 subgoal):\n 1. (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>')\n    \\<notin> lit_ord \\<Longrightarrow>\n    False", "have \"vars_of gr_rhs = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_of gr_rhs = {}", "using \\<open>subst rhs \\<eta> = subst rhs \\<sigma>'\\<close> \n      \\<open>subst_lit L2 \\<eta> = subst_lit L2 \\<sigma>'\\<close> \n      \\<open>gr_L2 = subst_lit L2 \\<eta>\\<close> \\<open>gr_rhs = subst rhs \\<eta>\\<close> \n      \\<open>orient_lit (subst_lit L2 \\<sigma>') (subst lhs \\<sigma>') (subst rhs \\<sigma>') pos\\<close> \n      \\<open>vars_of_lit gr_L2 = {}\\<close> orient_lit_vars"], ["proof (prove)\nusing this:\n  rhs \\<lhd> \\<eta> = rhs \\<lhd> \\<sigma>'\n  subst_lit L2 \\<eta> = subst_lit L2 \\<sigma>'\n  gr_L2 = subst_lit L2 \\<eta>\n  gr_rhs = rhs \\<lhd> \\<eta>\n  orient_lit (subst_lit L2 \\<sigma>') (lhs \\<lhd> \\<sigma>')\n   (rhs \\<lhd> \\<sigma>') pos\n  vars_of_lit gr_L2 = {}\n  orient_lit ?L ?t ?s ?p \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of gr_rhs = {}", "by fastforce"], ["proof (state)\nthis:\n  vars_of gr_rhs = {}\n\ngoal (1 subgoal):\n 1. (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>')\n    \\<notin> lit_ord \\<Longrightarrow>\n    False", "from \\<open>(subst s \\<sigma>)  \\<noteq> gr_rhs\\<close> and \\<open>vars_of (subst s \\<sigma>) = {}\\<close> \\<open>vars_of gr_rhs = {}\\<close> \n        \\<open>((subst s \\<sigma>),gr_rhs) \\<notin> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  s \\<lhd> \\<sigma> \\<noteq> gr_rhs\n  vars_of (s \\<lhd> \\<sigma>) = {}\n  vars_of gr_rhs = {}\n  (s \\<lhd> \\<sigma>, gr_rhs) \\<notin> trm_ord", "have \"(gr_rhs,(subst s \\<sigma>)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  s \\<lhd> \\<sigma> \\<noteq> gr_rhs\n  vars_of (s \\<lhd> \\<sigma>) = {}\n  vars_of gr_rhs = {}\n  (s \\<lhd> \\<sigma>, gr_rhs) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. (gr_rhs, s \\<lhd> \\<sigma>) \\<in> trm_ord", "using trm_ord_ground_total"], ["proof (prove)\nusing this:\n  s \\<lhd> \\<sigma> \\<noteq> gr_rhs\n  vars_of (s \\<lhd> \\<sigma>) = {}\n  vars_of gr_rhs = {}\n  (s \\<lhd> \\<sigma>, gr_rhs) \\<notin> trm_ord\n  \\<forall>x y.\n     ground_term x \\<longrightarrow>\n     ground_term y \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (gr_rhs, s \\<lhd> \\<sigma>) \\<in> trm_ord", "unfolding ground_term_def"], ["proof (prove)\nusing this:\n  s \\<lhd> \\<sigma> \\<noteq> gr_rhs\n  vars_of (s \\<lhd> \\<sigma>) = {}\n  vars_of gr_rhs = {}\n  (s \\<lhd> \\<sigma>, gr_rhs) \\<notin> trm_ord\n  \\<forall>x y.\n     vars_of x = {} \\<longrightarrow>\n     vars_of y = {} \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (gr_rhs, s \\<lhd> \\<sigma>) \\<in> trm_ord", "by blast"], ["proof (state)\nthis:\n  (gr_rhs, s \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>')\n    \\<notin> lit_ord \\<Longrightarrow>\n    False", "have \"(subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord", "using \\<open>(gr_rhs, subst s \\<sigma>) \\<in> trm_ord\\<close> \n        \\<open>subst lhs \\<eta> = subst lhs \\<sigma>'\\<close> \\<open>subst rhs \\<eta> = subst rhs \\<sigma>'\\<close> \n        \\<open>subst_lit L1 \\<sigma> = subst_lit L1 \\<sigma>'\\<close> \n        \\<open>gr_rhs = subst rhs \\<eta>\\<close> \n        \\<open>orient_lit (subst_lit L2 \\<sigma>') (subst lhs \\<sigma>') (subst rhs \\<sigma>') pos\\<close> \n        \\<open>polarity = pos\\<close> \\<open>u = t\\<close> \\<open>v = subst lhs \\<eta>\\<close> \\<open>v = subst u \\<sigma>\\<close> \n        \\<open>vars_of_lit (subst_lit L1 \\<sigma>') = {}\\<close> \\<open>vars_of_lit (subst_lit L2 \\<sigma>') = {}\\<close> \n        assms(6) lit_ord_rhs lift_orient_lit"], ["proof (prove)\nusing this:\n  (gr_rhs, s \\<lhd> \\<sigma>) \\<in> trm_ord\n  lhs \\<lhd> \\<eta> = lhs \\<lhd> \\<sigma>'\n  rhs \\<lhd> \\<eta> = rhs \\<lhd> \\<sigma>'\n  subst_lit L1 \\<sigma> = subst_lit L1 \\<sigma>'\n  gr_rhs = rhs \\<lhd> \\<eta>\n  orient_lit (subst_lit L2 \\<sigma>') (lhs \\<lhd> \\<sigma>')\n   (rhs \\<lhd> \\<sigma>') pos\n  polarity = pos\n  u = t\n  v = lhs \\<lhd> \\<eta>\n  v = u \\<lhd> \\<sigma>\n  vars_of_lit (subst_lit L1 \\<sigma>') = {}\n  vars_of_lit (subst_lit L2 \\<sigma>') = {}\n  orient_lit_inst L1 t s polarity \\<sigma>\n  \\<lbrakk>(?t1.0, ?t2.0) \\<in> trm_ord; orient_lit ?x1.0 ?s ?t1.0 ?p;\n   orient_lit ?x2.0 ?s ?t2.0 ?p; vars_of_lit ?x1.0 = {};\n   vars_of_lit ?x2.0 = {}\\<rbrakk>\n  \\<Longrightarrow> (?x1.0, ?x2.0) \\<in> lit_ord\n  orient_lit_inst ?L ?t ?s ?p ?\\<sigma> \\<Longrightarrow>\n  orient_lit (subst_lit ?L ?\\<sigma>) (?t \\<lhd> ?\\<sigma>)\n   (?s \\<lhd> ?\\<sigma>) ?p\n\ngoal (1 subgoal):\n 1. (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord", "by fastforce"], ["proof (state)\nthis:\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>')\n    \\<notin> lit_ord \\<Longrightarrow>\n    False", "from this and \\<open>(subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<notin> lit_ord\\<close>"], ["proof (chain)\npicking this:\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<notin> lit_ord", "show False"], ["proof (prove)\nusing this:\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<notin> lit_ord\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "have \"trm_rep (subst u \\<sigma>) S \\<noteq> (subst u \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trm_rep (u \\<lhd> \\<sigma>) S \\<noteq> u \\<lhd> \\<sigma>", "using \\<open>trm_rep v S \\<noteq> v\\<close> \\<open>v = subst u \\<sigma>\\<close>"], ["proof (prove)\nusing this:\n  trm_rep v S \\<noteq> v\n  v = u \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. trm_rep (u \\<lhd> \\<sigma>) S \\<noteq> u \\<lhd> \\<sigma>", "by blast"], ["proof (state)\nthis:\n  trm_rep (u \\<lhd> \\<sigma>) S \\<noteq> u \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "have \"allowed_redex u C \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. allowed_redex u C \\<sigma>", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> allowed_redex u C \\<sigma> \\<Longrightarrow> False", "assume \"\\<not>allowed_redex u C \\<sigma>\""], ["proof (state)\nthis:\n  \\<not> allowed_redex u C \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> allowed_redex u C \\<sigma> \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  \\<not> allowed_redex u C \\<sigma>", "obtain ss where \"ss \\<in> trms_ecl C\" \n      and \"occurs_in (subst u \\<sigma>) (subst ss \\<sigma>)\""], ["proof (prove)\nusing this:\n  \\<not> allowed_redex u C \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>ss.\n        \\<lbrakk>ss \\<in> trms_ecl C;\n         occurs_in (u \\<lhd> \\<sigma>) (ss \\<lhd> \\<sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding allowed_redex_def"], ["proof (prove)\nusing this:\n  \\<not> \\<not> (\\<exists>s\\<in>trms_ecl C.\n                    occurs_in (u \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))\n\ngoal (1 subgoal):\n 1. (\\<And>ss.\n        \\<lbrakk>ss \\<in> trms_ecl C;\n         occurs_in (u \\<lhd> \\<sigma>) (ss \\<lhd> \\<sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ss \\<in> trms_ecl C\n  occurs_in (u \\<lhd> \\<sigma>) (ss \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> allowed_redex u C \\<sigma> \\<Longrightarrow> False", "from \\<open>ss \\<in> trms_ecl C\\<close>"], ["proof (chain)\npicking this:\n  ss \\<in> trms_ecl C", "have \"(subst ss \\<sigma>) \\<in> (subst_set (trms_ecl C) \\<sigma>)\""], ["proof (prove)\nusing this:\n  ss \\<in> trms_ecl C\n\ngoal (1 subgoal):\n 1. ss \\<lhd> \\<sigma> \\<in> subst_set (trms_ecl C) \\<sigma>", "by auto"], ["proof (state)\nthis:\n  ss \\<lhd> \\<sigma> \\<in> subst_set (trms_ecl C) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> allowed_redex u C \\<sigma> \\<Longrightarrow> False", "from this and assms(12) and \\<open>occurs_in (subst u \\<sigma>) (subst ss \\<sigma>)\\<close> \n      \\<open>trm_rep (subst u \\<sigma>) S \\<noteq> (subst u \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  ss \\<lhd> \\<sigma> \\<in> subst_set (trms_ecl C) \\<sigma>\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n  occurs_in (u \\<lhd> \\<sigma>) (ss \\<lhd> \\<sigma>)\n  trm_rep (u \\<lhd> \\<sigma>) S \\<noteq> u \\<lhd> \\<sigma>", "show False"], ["proof (prove)\nusing this:\n  ss \\<lhd> \\<sigma> \\<in> subst_set (trms_ecl C) \\<sigma>\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n  occurs_in (u \\<lhd> \\<sigma>) (ss \\<lhd> \\<sigma>)\n  trm_rep (u \\<lhd> \\<sigma>) S \\<noteq> u \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. False", "unfolding all_trms_irreducible_def"], ["proof (prove)\nusing this:\n  ss \\<lhd> \\<sigma> \\<in> subst_set (trms_ecl C) \\<sigma>\n  \\<forall>x y.\n     x \\<in> subst_set (trms_ecl C) \\<sigma> \\<longrightarrow>\n     occurs_in y x \\<longrightarrow> trm_rep y S = y\n  occurs_in (u \\<lhd> \\<sigma>) (ss \\<lhd> \\<sigma>)\n  trm_rep (u \\<lhd> \\<sigma>) S \\<noteq> u \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  allowed_redex u C \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "have \"subst lhs \\<sigma>' \\<noteq> subst rhs \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhs \\<lhd> \\<sigma>' \\<noteq> rhs \\<lhd> \\<sigma>'", "using \\<open>(gr_rhs, v) \\<in> trm_ord\\<close> \n    \\<open>subst lhs \\<eta> = subst lhs \\<sigma>'\\<close> \n    \\<open>subst rhs \\<eta> = subst rhs \\<sigma>'\\<close> \n    \\<open>gr_rhs = subst rhs \\<eta>\\<close> \\<open>v = subst lhs \\<eta>\\<close> trm_ord_wf"], ["proof (prove)\nusing this:\n  (gr_rhs, v) \\<in> trm_ord\n  lhs \\<lhd> \\<eta> = lhs \\<lhd> \\<sigma>'\n  rhs \\<lhd> \\<eta> = rhs \\<lhd> \\<sigma>'\n  gr_rhs = rhs \\<lhd> \\<eta>\n  v = lhs \\<lhd> \\<eta>\n  wf trm_ord\n\ngoal (1 subgoal):\n 1. lhs \\<lhd> \\<sigma>' \\<noteq> rhs \\<lhd> \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  lhs \\<lhd> \\<sigma>' \\<noteq> rhs \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from this \\<open>mp=p\\<close> \\<open>\\<not> (is_a_variable u)\\<close>\n   \\<open>all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>') (\\<lambda>t. trm_rep t S)\\<close>\n   \\<open>(subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord\\<close> \n   \\<open>all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>') (\\<lambda>t. trm_rep t S)\\<close>  \n   \\<open>(\\<forall>x\\<in>cl_ecl C2 - {L2}. (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord)\\<close> \n   \\<open>C2 \\<in> S\\<close> \\<open>eligible_literal L1 C \\<sigma>'\\<close> \\<open>eligible_literal L2 C2 \\<sigma>'\\<close> \n   \\<open>ground_clause (subst_cl Cl_C2 \\<sigma>')\\<close> \\<open>Cl_C2 = cl_ecl C2\\<close> \n    mr \\<open>coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\\<close> \\<open>L1 \\<in> cl_ecl C\\<close> \\<open>L2 \\<in> Cl_C2\\<close>  \n    \\<open>orient_lit_inst L1 t s polarity \\<sigma>'\\<close> \\<open>(orient_lit_inst L2 lhs rhs pos \\<sigma>')\\<close>\n    \\<open>(subterm t p u)\\<close> \\<open>subst u \\<sigma>' = subst lhs \\<sigma>'\\<close> \n    \\<open>trm_rep (subst rhs \\<sigma>') S = trm_rep (subst lhs \\<sigma>') S\\<close> \n    \\<open>(\\<not> validate_ground_clause ?I (subst_cl ( Cl_C2 - { L2 } ) \\<sigma>'))\\<close>\n    \\<open>allowed_redex u C \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  lhs \\<lhd> \\<sigma>' \\<noteq> rhs \\<lhd> \\<sigma>'\n  mp = p\n  \\<not> is_a_variable u\n  all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n   (\\<lambda>t. trm_rep t S)\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord\n  all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n   (\\<lambda>t. trm_rep t S)\n  \\<forall>x\\<in>cl_ecl C2 - {L2}.\n     (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord\n  C2 \\<in> S\n  eligible_literal L1 C \\<sigma>'\n  eligible_literal L2 C2 \\<sigma>'\n  ground_clause (subst_cl Cl_C2 \\<sigma>')\n  Cl_C2 = cl_ecl C2\n  minimal_redex mp (t \\<lhd> \\<sigma>) C S t\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\n  L1 \\<in> cl_ecl C\n  L2 \\<in> Cl_C2\n  orient_lit_inst L1 t s polarity \\<sigma>'\n  orient_lit_inst L2 lhs rhs pos \\<sigma>'\n  subterm t p u\n  u \\<lhd> \\<sigma>' = lhs \\<lhd> \\<sigma>'\n  trm_rep (rhs \\<lhd> \\<sigma>') S = trm_rep (lhs \\<lhd> \\<sigma>') S\n  \\<not> validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n          (subst_cl (Cl_C2 - {L2}) \\<sigma>')\n  allowed_redex u C \\<sigma>", "have \"(reduction L1 C \\<sigma>' t s polarity L2 lhs u mp rhs C2 (same_values (\\<lambda>t. (trm_rep t S))) S \\<sigma>)\""], ["proof (prove)\nusing this:\n  lhs \\<lhd> \\<sigma>' \\<noteq> rhs \\<lhd> \\<sigma>'\n  mp = p\n  \\<not> is_a_variable u\n  all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n   (\\<lambda>t. trm_rep t S)\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord\n  all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n   (\\<lambda>t. trm_rep t S)\n  \\<forall>x\\<in>cl_ecl C2 - {L2}.\n     (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord\n  C2 \\<in> S\n  eligible_literal L1 C \\<sigma>'\n  eligible_literal L2 C2 \\<sigma>'\n  ground_clause (subst_cl Cl_C2 \\<sigma>')\n  Cl_C2 = cl_ecl C2\n  minimal_redex mp (t \\<lhd> \\<sigma>) C S t\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\n  L1 \\<in> cl_ecl C\n  L2 \\<in> Cl_C2\n  orient_lit_inst L1 t s polarity \\<sigma>'\n  orient_lit_inst L2 lhs rhs pos \\<sigma>'\n  subterm t p u\n  u \\<lhd> \\<sigma>' = lhs \\<lhd> \\<sigma>'\n  trm_rep (rhs \\<lhd> \\<sigma>') S = trm_rep (lhs \\<lhd> \\<sigma>') S\n  \\<not> validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n          (subst_cl (Cl_C2 - {L2}) \\<sigma>')\n  allowed_redex u C \\<sigma>\n\ngoal (1 subgoal):\n 1. reduction L1 C \\<sigma>' t s polarity L2 lhs u mp rhs C2\n     (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma>", "unfolding reduction_def same_values_def"], ["proof (prove)\nusing this:\n  lhs \\<lhd> \\<sigma>' \\<noteq> rhs \\<lhd> \\<sigma>'\n  mp = p\n  \\<not> is_a_variable u\n  all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n   (\\<lambda>t. trm_rep t S)\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord\n  all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n   (\\<lambda>t. trm_rep t S)\n  \\<forall>x\\<in>cl_ecl C2 - {L2}.\n     (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord\n  C2 \\<in> S\n  eligible_literal L1 C \\<sigma>'\n  eligible_literal L2 C2 \\<sigma>'\n  ground_clause (subst_cl Cl_C2 \\<sigma>')\n  Cl_C2 = cl_ecl C2\n  minimal_redex mp (t \\<lhd> \\<sigma>) C S t\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\n  L1 \\<in> cl_ecl C\n  L2 \\<in> Cl_C2\n  orient_lit_inst L1 t s polarity \\<sigma>'\n  orient_lit_inst L2 lhs rhs pos \\<sigma>'\n  subterm t p u\n  u \\<lhd> \\<sigma>' = lhs \\<lhd> \\<sigma>'\n  trm_rep (rhs \\<lhd> \\<sigma>') S = trm_rep (lhs \\<lhd> \\<sigma>') S\n  \\<not> validate_ground_clause (\\<lambda>x y. trm_rep x S = trm_rep y S)\n          (subst_cl (Cl_C2 - {L2}) \\<sigma>')\n  allowed_redex u C \\<sigma>\n\ngoal (1 subgoal):\n 1. C2 \\<in> S \\<and>\n    eligible_literal L1 C \\<sigma>' \\<and>\n    eligible_literal L2 C2 \\<sigma>' \\<and>\n    ground_clause (subst_cl (cl_ecl C2) \\<sigma>') \\<and>\n    minimal_redex mp (t \\<lhd> \\<sigma>) C S t \\<and>\n    coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)) \\<and>\n    allowed_redex u C \\<sigma> \\<and>\n    \\<not> is_a_variable u \\<and>\n    L1 \\<in> cl_ecl C \\<and>\n    L2 \\<in> cl_ecl C2 \\<and>\n    orient_lit_inst L1 t s polarity \\<sigma>' \\<and>\n    orient_lit_inst L2 lhs rhs pos \\<sigma>' \\<and>\n    lhs \\<lhd> \\<sigma>' \\<noteq> rhs \\<lhd> \\<sigma>' \\<and>\n    u \\<lhd> \\<sigma>' = lhs \\<lhd> \\<sigma>' \\<and>\n    \\<not> validate_ground_clause (\\<lambda>x y. trm_rep x S = trm_rep y S)\n            (subst_cl (cl_ecl C2 - {L2}) \\<sigma>') \\<and>\n    (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord \\<and>\n    (\\<forall>x\\<in>cl_ecl C2 - {L2}.\n        (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>')\n        \\<in> lit_ord) \\<and>\n    all_trms_irreducible (subst_set (trms_ecl C2) \\<sigma>')\n     (\\<lambda>t. trm_rep t S) \\<and>\n    trm_rep (lhs \\<lhd> \\<sigma>') S =\n    trm_rep (rhs \\<lhd> \\<sigma>') S \\<and>\n    subterm t mp u", "by metis"], ["proof (state)\nthis:\n  reduction L1 C \\<sigma>' t s polarity L2 lhs u mp rhs C2\n   (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from \\<open>vars_of_cl (cl_ecl C) \\<inter> vars_of_cl (cl_ecl C2) = {}\\<close>"], ["proof (chain)\npicking this:\n  vars_of_cl (cl_ecl C) \\<inter> vars_of_cl (cl_ecl C2) = {}", "have \"variable_disjoint C C2\""], ["proof (prove)\nusing this:\n  vars_of_cl (cl_ecl C) \\<inter> vars_of_cl (cl_ecl C2) = {}\n\ngoal (1 subgoal):\n 1. variable_disjoint C C2", "unfolding variable_disjoint_def"], ["proof (prove)\nusing this:\n  vars_of_cl (cl_ecl C) \\<inter> vars_of_cl (cl_ecl C2) = {}\n\ngoal (1 subgoal):\n 1. vars_of_cl (cl_ecl C) \\<inter> vars_of_cl (cl_ecl C2) = {}", "by auto"], ["proof (state)\nthis:\n  variable_disjoint C C2\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "from this and \n    \\<open>(reduction L1 C \\<sigma>' t s polarity L2 lhs u mp rhs C2 (same_values (\\<lambda>t. (trm_rep t S))) S \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  variable_disjoint C C2\n  reduction L1 C \\<sigma>' t s polarity L2 lhs u mp rhs C2\n   (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma>", "show ?thesis"], ["proof (prove)\nusing this:\n  variable_disjoint C C2\n  reduction L1 C \\<sigma>' t s polarity L2 lhs u mp rhs C2\n   (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>' u u' p v D L2.\n       reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>' u u' p v D L2.\n     reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n      (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n     variable_disjoint C D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subts_of_irred_trms_are_irred:\n  assumes \"trm_rep y S \\<noteq> y\"\n  shows \"\\<And> x. subterm x p y \\<longrightarrow> trm_rep x S \\<noteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. subterm x p y \\<longrightarrow> trm_rep x S \\<noteq> x", "proof (induction p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. subterm x [] y \\<longrightarrow> trm_rep x S \\<noteq> x\n 2. \\<And>a p x.\n       (\\<And>x.\n           subterm x p y \\<longrightarrow>\n           trm_rep x S \\<noteq> x) \\<Longrightarrow>\n       subterm x (a # p) y \\<longrightarrow> trm_rep x S \\<noteq> x", "case (Nil)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x. subterm x [] y \\<longrightarrow> trm_rep x S \\<noteq> x\n 2. \\<And>a p x.\n       (\\<And>x.\n           subterm x p y \\<longrightarrow>\n           trm_rep x S \\<noteq> x) \\<Longrightarrow>\n       subterm x (a # p) y \\<longrightarrow> trm_rep x S \\<noteq> x", "from assms(1)"], ["proof (chain)\npicking this:\n  trm_rep y S \\<noteq> y", "show ?case"], ["proof (prove)\nusing this:\n  trm_rep y S \\<noteq> y\n\ngoal (1 subgoal):\n 1. subterm x [] y \\<longrightarrow> trm_rep x S \\<noteq> x", "by (metis subterm.simps(1))"], ["proof (state)\nthis:\n  subterm x [] y \\<longrightarrow> trm_rep x S \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>a p x.\n       (\\<And>x.\n           subterm x p y \\<longrightarrow>\n           trm_rep x S \\<noteq> x) \\<Longrightarrow>\n       subterm x (a # p) y \\<longrightarrow> trm_rep x S \\<noteq> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p x.\n       (\\<And>x.\n           subterm x p y \\<longrightarrow>\n           trm_rep x S \\<noteq> x) \\<Longrightarrow>\n       subterm x (a # p) y \\<longrightarrow> trm_rep x S \\<noteq> x", "case (Cons i p)"], ["proof (state)\nthis:\n  subterm ?x p y \\<longrightarrow> trm_rep ?x S \\<noteq> ?x\n\ngoal (1 subgoal):\n 1. \\<And>a p x.\n       (\\<And>x.\n           subterm x p y \\<longrightarrow>\n           trm_rep x S \\<noteq> x) \\<Longrightarrow>\n       subterm x (a # p) y \\<longrightarrow> trm_rep x S \\<noteq> x", "show \"\\<And> x. subterm x (Cons i p) y \\<longrightarrow> trm_rep x S \\<noteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. subterm x (i # p) y \\<longrightarrow> trm_rep x S \\<noteq> x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. subterm x (i # p) y \\<Longrightarrow> trm_rep x S \\<noteq> x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. subterm x (i # p) y \\<Longrightarrow> trm_rep x S \\<noteq> x", "assume \"subterm x (Cons i p) y\""], ["proof (state)\nthis:\n  subterm x (i # p) y\n\ngoal (1 subgoal):\n 1. \\<And>x. subterm x (i # p) y \\<Longrightarrow> trm_rep x S \\<noteq> x", "from this"], ["proof (chain)\npicking this:\n  subterm x (i # p) y", "obtain x1 x2 where \"x = Comb x1 x2\""], ["proof (prove)\nusing this:\n  subterm x (i # p) y\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        x = x1 \\<cdot> x2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using subterm.elims(2)"], ["proof (prove)\nusing this:\n  subterm x (i # p) y\n  \\<lbrakk>subterm ?x ?xa ?xb;\n   \\<And>T S.\n      \\<lbrakk>?x = T; ?xa = []; ?xb = S; T = S\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>x y next S.\n      \\<lbrakk>?x = x \\<cdot> y; ?xa = indices.Left # next; ?xb = S;\n       subterm x next S\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>x y next S.\n      \\<lbrakk>?x = x \\<cdot> y; ?xa = indices.Right # next; ?xb = S;\n       subterm y next S\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        x = x1 \\<cdot> x2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = x1 \\<cdot> x2\n\ngoal (1 subgoal):\n 1. \\<And>x. subterm x (i # p) y \\<Longrightarrow> trm_rep x S \\<noteq> x", "have \"i = Left | i = Right\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = indices.Left \\<or> i = indices.Right", "using indices.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = indices.Left \\<Longrightarrow> ?P;\n   ?y = indices.Right \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. i = indices.Left \\<or> i = indices.Right", "by auto"], ["proof (state)\nthis:\n  i = indices.Left \\<or> i = indices.Right\n\ngoal (1 subgoal):\n 1. \\<And>x. subterm x (i # p) y \\<Longrightarrow> trm_rep x S \\<noteq> x", "then"], ["proof (chain)\npicking this:\n  i = indices.Left \\<or> i = indices.Right", "show \"trm_rep x S \\<noteq> x\""], ["proof (prove)\nusing this:\n  i = indices.Left \\<or> i = indices.Right\n\ngoal (1 subgoal):\n 1. trm_rep x S \\<noteq> x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. i = indices.Left \\<Longrightarrow> trm_rep x S \\<noteq> x\n 2. i = indices.Right \\<Longrightarrow> trm_rep x S \\<noteq> x", "assume \"i = Left\""], ["proof (state)\nthis:\n  i = indices.Left\n\ngoal (2 subgoals):\n 1. i = indices.Left \\<Longrightarrow> trm_rep x S \\<noteq> x\n 2. i = indices.Right \\<Longrightarrow> trm_rep x S \\<noteq> x", "from this and \\<open>subterm x (Cons i p) y\\<close> \\<open>x = Comb x1 x2\\<close>"], ["proof (chain)\npicking this:\n  i = indices.Left\n  subterm x (i # p) y\n  x = x1 \\<cdot> x2", "have \"subterm x1 p y\""], ["proof (prove)\nusing this:\n  i = indices.Left\n  subterm x (i # p) y\n  x = x1 \\<cdot> x2\n\ngoal (1 subgoal):\n 1. subterm x1 p y", "by auto"], ["proof (state)\nthis:\n  subterm x1 p y\n\ngoal (2 subgoals):\n 1. i = indices.Left \\<Longrightarrow> trm_rep x S \\<noteq> x\n 2. i = indices.Right \\<Longrightarrow> trm_rep x S \\<noteq> x", "from this and Cons.IH"], ["proof (chain)\npicking this:\n  subterm x1 p y\n  subterm ?x p y \\<longrightarrow> trm_rep ?x S \\<noteq> ?x", "have \"trm_rep x1 S \\<noteq> x1\""], ["proof (prove)\nusing this:\n  subterm x1 p y\n  subterm ?x p y \\<longrightarrow> trm_rep ?x S \\<noteq> ?x\n\ngoal (1 subgoal):\n 1. trm_rep x1 S \\<noteq> x1", "by blast"], ["proof (state)\nthis:\n  trm_rep x1 S \\<noteq> x1\n\ngoal (2 subgoals):\n 1. i = indices.Left \\<Longrightarrow> trm_rep x S \\<noteq> x\n 2. i = indices.Right \\<Longrightarrow> trm_rep x S \\<noteq> x", "from this and \\<open>x = Comb x1 x2\\<close>"], ["proof (chain)\npicking this:\n  trm_rep x1 S \\<noteq> x1\n  x = x1 \\<cdot> x2", "have \"subterm_reduction_applicable S x\""], ["proof (prove)\nusing this:\n  trm_rep x1 S \\<noteq> x1\n  x = x1 \\<cdot> x2\n\ngoal (1 subgoal):\n 1. subterm_reduction_applicable S x", "unfolding subterm_reduction_applicable_def"], ["proof (prove)\nusing this:\n  trm_rep x1 S \\<noteq> x1\n  x = x1 \\<cdot> x2\n\ngoal (1 subgoal):\n 1. is_compound x \\<and>\n    (trm_rep (lhs x) S \\<noteq> lhs x \\<or>\n     trm_rep (rhs x) S \\<noteq> rhs x)", "by (metis is_compound.simps(3) lhs.simps(1))"], ["proof (state)\nthis:\n  subterm_reduction_applicable S x\n\ngoal (2 subgoals):\n 1. i = indices.Left \\<Longrightarrow> trm_rep x S \\<noteq> x\n 2. i = indices.Right \\<Longrightarrow> trm_rep x S \\<noteq> x", "from this"], ["proof (chain)\npicking this:\n  subterm_reduction_applicable S x", "have \"(trm_rep x S, x) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  subterm_reduction_applicable S x\n\ngoal (1 subgoal):\n 1. (trm_rep x S, x) \\<in> trm_ord", "using  trm_rep_is_lower_subt_red"], ["proof (prove)\nusing this:\n  subterm_reduction_applicable S x\n  subterm_reduction_applicable ?S ?x \\<Longrightarrow>\n  (trm_rep ?x ?S, ?x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep x S, x) \\<in> trm_ord", "by blast"], ["proof (state)\nthis:\n  (trm_rep x S, x) \\<in> trm_ord\n\ngoal (2 subgoals):\n 1. i = indices.Left \\<Longrightarrow> trm_rep x S \\<noteq> x\n 2. i = indices.Right \\<Longrightarrow> trm_rep x S \\<noteq> x", "from this"], ["proof (chain)\npicking this:\n  (trm_rep x S, x) \\<in> trm_ord", "show ?thesis"], ["proof (prove)\nusing this:\n  (trm_rep x S, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep x S \\<noteq> x", "using trm_ord_irrefl"], ["proof (prove)\nusing this:\n  (trm_rep x S, x) \\<in> trm_ord\n  irrefl trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep x S \\<noteq> x", "unfolding irrefl_def"], ["proof (prove)\nusing this:\n  (trm_rep x S, x) \\<in> trm_ord\n  \\<forall>a. (a, a) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep x S \\<noteq> x", "by metis"], ["proof (state)\nthis:\n  trm_rep x S \\<noteq> x\n\ngoal (1 subgoal):\n 1. i = indices.Right \\<Longrightarrow> trm_rep x S \\<noteq> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i = indices.Right \\<Longrightarrow> trm_rep x S \\<noteq> x", "assume \"i = Right\""], ["proof (state)\nthis:\n  i = indices.Right\n\ngoal (1 subgoal):\n 1. i = indices.Right \\<Longrightarrow> trm_rep x S \\<noteq> x", "from this and \\<open>subterm x (Cons i p) y\\<close> \\<open>x = Comb x1 x2\\<close>"], ["proof (chain)\npicking this:\n  i = indices.Right\n  subterm x (i # p) y\n  x = x1 \\<cdot> x2", "have \"subterm x2 p y\""], ["proof (prove)\nusing this:\n  i = indices.Right\n  subterm x (i # p) y\n  x = x1 \\<cdot> x2\n\ngoal (1 subgoal):\n 1. subterm x2 p y", "by auto"], ["proof (state)\nthis:\n  subterm x2 p y\n\ngoal (1 subgoal):\n 1. i = indices.Right \\<Longrightarrow> trm_rep x S \\<noteq> x", "from this and Cons.IH"], ["proof (chain)\npicking this:\n  subterm x2 p y\n  subterm ?x p y \\<longrightarrow> trm_rep ?x S \\<noteq> ?x", "have \"trm_rep x2 S \\<noteq> x2\""], ["proof (prove)\nusing this:\n  subterm x2 p y\n  subterm ?x p y \\<longrightarrow> trm_rep ?x S \\<noteq> ?x\n\ngoal (1 subgoal):\n 1. trm_rep x2 S \\<noteq> x2", "by blast"], ["proof (state)\nthis:\n  trm_rep x2 S \\<noteq> x2\n\ngoal (1 subgoal):\n 1. i = indices.Right \\<Longrightarrow> trm_rep x S \\<noteq> x", "from this and \\<open>x = Comb x1 x2\\<close>"], ["proof (chain)\npicking this:\n  trm_rep x2 S \\<noteq> x2\n  x = x1 \\<cdot> x2", "have \"subterm_reduction_applicable S x\""], ["proof (prove)\nusing this:\n  trm_rep x2 S \\<noteq> x2\n  x = x1 \\<cdot> x2\n\ngoal (1 subgoal):\n 1. subterm_reduction_applicable S x", "unfolding subterm_reduction_applicable_def"], ["proof (prove)\nusing this:\n  trm_rep x2 S \\<noteq> x2\n  x = x1 \\<cdot> x2\n\ngoal (1 subgoal):\n 1. is_compound x \\<and>\n    (trm_rep (lhs x) S \\<noteq> lhs x \\<or>\n     trm_rep (rhs x) S \\<noteq> rhs x)", "by (metis is_compound.simps(3) rhs.simps(1))"], ["proof (state)\nthis:\n  subterm_reduction_applicable S x\n\ngoal (1 subgoal):\n 1. i = indices.Right \\<Longrightarrow> trm_rep x S \\<noteq> x", "from this"], ["proof (chain)\npicking this:\n  subterm_reduction_applicable S x", "have \"(trm_rep x S, x) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  subterm_reduction_applicable S x\n\ngoal (1 subgoal):\n 1. (trm_rep x S, x) \\<in> trm_ord", "using  trm_rep_is_lower_subt_red"], ["proof (prove)\nusing this:\n  subterm_reduction_applicable S x\n  subterm_reduction_applicable ?S ?x \\<Longrightarrow>\n  (trm_rep ?x ?S, ?x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep x S, x) \\<in> trm_ord", "by blast"], ["proof (state)\nthis:\n  (trm_rep x S, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. i = indices.Right \\<Longrightarrow> trm_rep x S \\<noteq> x", "from this"], ["proof (chain)\npicking this:\n  (trm_rep x S, x) \\<in> trm_ord", "show ?thesis"], ["proof (prove)\nusing this:\n  (trm_rep x S, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep x S \\<noteq> x", "using trm_ord_irrefl"], ["proof (prove)\nusing this:\n  (trm_rep x S, x) \\<in> trm_ord\n  irrefl trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep x S \\<noteq> x", "unfolding irrefl_def"], ["proof (prove)\nusing this:\n  (trm_rep x S, x) \\<in> trm_ord\n  \\<forall>a. (a, a) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep x S \\<noteq> x", "by metis"], ["proof (state)\nthis:\n  trm_rep x S \\<noteq> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trm_rep x S \\<noteq> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subterm ?x (i # p) y \\<longrightarrow> trm_rep ?x S \\<noteq> ?x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma allowed_redex_coincide:\n  assumes \"allowed_redex t C \\<sigma>\"\n  assumes \"t \\<in> subterms_of_cl (cl_ecl C)\" \n  assumes \"coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\"\n  assumes \"well_constrained C\"\n  shows \"allowed_redex t C \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. allowed_redex t C \\<sigma>'", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> allowed_redex t C \\<sigma>' \\<Longrightarrow> False", "assume \"\\<not>allowed_redex t C \\<sigma>'\""], ["proof (state)\nthis:\n  \\<not> allowed_redex t C \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<not> allowed_redex t C \\<sigma>' \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  \\<not> allowed_redex t C \\<sigma>'", "obtain s \n    where \"s \\<in> trms_ecl C\" and \"occurs_in (subst t \\<sigma>') (subst s \\<sigma>')\""], ["proof (prove)\nusing this:\n  \\<not> allowed_redex t C \\<sigma>'\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> trms_ecl C;\n         occurs_in (t \\<lhd> \\<sigma>') (s \\<lhd> \\<sigma>')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding allowed_redex_def"], ["proof (prove)\nusing this:\n  \\<not> \\<not> (\\<exists>s\\<in>trms_ecl C.\n                    occurs_in (t \\<lhd> \\<sigma>') (s \\<lhd> \\<sigma>'))\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> trms_ecl C;\n         occurs_in (t \\<lhd> \\<sigma>') (s \\<lhd> \\<sigma>')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s \\<in> trms_ecl C\n  occurs_in (t \\<lhd> \\<sigma>') (s \\<lhd> \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<not> allowed_redex t C \\<sigma>' \\<Longrightarrow> False", "from \\<open>s \\<in> trms_ecl C\\<close> and assms(4)"], ["proof (chain)\npicking this:\n  s \\<in> trms_ecl C\n  well_constrained C", "have \"vars_of s \\<subseteq> vars_of_cl (cl_ecl C)\""], ["proof (prove)\nusing this:\n  s \\<in> trms_ecl C\n  well_constrained C\n\ngoal (1 subgoal):\n 1. vars_of s \\<subseteq> vars_of_cl (cl_ecl C)", "using dom_trm_vars"], ["proof (prove)\nusing this:\n  s \\<in> trms_ecl C\n  well_constrained C\n  dom_trm ?t ?C \\<Longrightarrow> vars_of ?t \\<subseteq> vars_of_cl ?C\n\ngoal (1 subgoal):\n 1. vars_of s \\<subseteq> vars_of_cl (cl_ecl C)", "unfolding well_constrained_def"], ["proof (prove)\nusing this:\n  s \\<in> trms_ecl C\n  \\<forall>y. y \\<in> trms_ecl C \\<longrightarrow> dom_trm y (cl_ecl C)\n  dom_trm ?t ?C \\<Longrightarrow> vars_of ?t \\<subseteq> vars_of_cl ?C\n\ngoal (1 subgoal):\n 1. vars_of s \\<subseteq> vars_of_cl (cl_ecl C)", "by blast"], ["proof (state)\nthis:\n  vars_of s \\<subseteq> vars_of_cl (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<not> allowed_redex t C \\<sigma>' \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  vars_of s \\<subseteq> vars_of_cl (cl_ecl C)", "have \"vars_of s \\<subseteq> vars_of_cl (cl_ecl C)\""], ["proof (prove)\nusing this:\n  vars_of s \\<subseteq> vars_of_cl (cl_ecl C)\n\ngoal (1 subgoal):\n 1. vars_of s \\<subseteq> vars_of_cl (cl_ecl C)", "using subterm_vars"], ["proof (prove)\nusing this:\n  vars_of s \\<subseteq> vars_of_cl (cl_ecl C)\n  ?u \\<in> subterms_of_cl ?C \\<Longrightarrow>\n  vars_of ?u \\<subseteq> vars_of_cl ?C\n\ngoal (1 subgoal):\n 1. vars_of s \\<subseteq> vars_of_cl (cl_ecl C)", "by blast"], ["proof (state)\nthis:\n  vars_of s \\<subseteq> vars_of_cl (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<not> allowed_redex t C \\<sigma>' \\<Longrightarrow> False", "from this and assms(3)"], ["proof (chain)\npicking this:\n  vars_of s \\<subseteq> vars_of_cl (cl_ecl C)\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))", "have \"coincide_on \\<sigma> \\<sigma>' (vars_of s)\""], ["proof (prove)\nusing this:\n  vars_of s \\<subseteq> vars_of_cl (cl_ecl C)\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\n\ngoal (1 subgoal):\n 1. coincide_on \\<sigma> \\<sigma>' (vars_of s)", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  vars_of s \\<subseteq> vars_of_cl (cl_ecl C)\n  \\<forall>x\\<in>vars_of_cl (cl_ecl C).\n     Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of s. Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  coincide_on \\<sigma> \\<sigma>' (vars_of s)\n\ngoal (1 subgoal):\n 1. \\<not> allowed_redex t C \\<sigma>' \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of s)", "have \"(subst s \\<sigma>) = (subst s \\<sigma>')\""], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of s)\n\ngoal (1 subgoal):\n 1. s \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>'", "using coincide_on_term"], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of s)\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of ?t) \\<Longrightarrow>\n  ?t \\<lhd> ?\\<sigma> = ?t \\<lhd> ?\\<eta>\n\ngoal (1 subgoal):\n 1. s \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  s \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<not> allowed_redex t C \\<sigma>' \\<Longrightarrow> False", "from assms(2)"], ["proof (chain)\npicking this:\n  t \\<in> subterms_of_cl (cl_ecl C)", "have \"vars_of t \\<subseteq> vars_of_cl (cl_ecl C)\""], ["proof (prove)\nusing this:\n  t \\<in> subterms_of_cl (cl_ecl C)\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_cl (cl_ecl C)", "using subterm_vars"], ["proof (prove)\nusing this:\n  t \\<in> subterms_of_cl (cl_ecl C)\n  ?u \\<in> subterms_of_cl ?C \\<Longrightarrow>\n  vars_of ?u \\<subseteq> vars_of_cl ?C\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_cl (cl_ecl C)", "by blast"], ["proof (state)\nthis:\n  vars_of t \\<subseteq> vars_of_cl (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<not> allowed_redex t C \\<sigma>' \\<Longrightarrow> False", "from this and assms(3)"], ["proof (chain)\npicking this:\n  vars_of t \\<subseteq> vars_of_cl (cl_ecl C)\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))", "have \"coincide_on \\<sigma> \\<sigma>' (vars_of t)\""], ["proof (prove)\nusing this:\n  vars_of t \\<subseteq> vars_of_cl (cl_ecl C)\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\n\ngoal (1 subgoal):\n 1. coincide_on \\<sigma> \\<sigma>' (vars_of t)", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  vars_of t \\<subseteq> vars_of_cl (cl_ecl C)\n  \\<forall>x\\<in>vars_of_cl (cl_ecl C).\n     Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of t. Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  coincide_on \\<sigma> \\<sigma>' (vars_of t)\n\ngoal (1 subgoal):\n 1. \\<not> allowed_redex t C \\<sigma>' \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of t)", "have \"(subst t \\<sigma>) = (subst t \\<sigma>')\""], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of t)\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>'", "using coincide_on_term"], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of t)\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of ?t) \\<Longrightarrow>\n  ?t \\<lhd> ?\\<sigma> = ?t \\<lhd> ?\\<eta>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<not> allowed_redex t C \\<sigma>' \\<Longrightarrow> False", "from this and \\<open>(subst s \\<sigma>) = (subst s \\<sigma>')\\<close> and \\<open>occurs_in (subst t \\<sigma>') (subst s \\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>'\n  s \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>'\n  occurs_in (t \\<lhd> \\<sigma>') (s \\<lhd> \\<sigma>')", "have \"occurs_in (subst t \\<sigma>) (subst s \\<sigma>)\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>'\n  s \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>'\n  occurs_in (t \\<lhd> \\<sigma>') (s \\<lhd> \\<sigma>')\n\ngoal (1 subgoal):\n 1. occurs_in (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  occurs_in (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> allowed_redex t C \\<sigma>' \\<Longrightarrow> False", "from this and \\<open>s \\<in> trms_ecl C\\<close>"], ["proof (chain)\npicking this:\n  occurs_in (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n  s \\<in> trms_ecl C", "have \"\\<not>allowed_redex t C \\<sigma>\""], ["proof (prove)\nusing this:\n  occurs_in (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n  s \\<in> trms_ecl C\n\ngoal (1 subgoal):\n 1. \\<not> allowed_redex t C \\<sigma>", "unfolding allowed_redex_def"], ["proof (prove)\nusing this:\n  occurs_in (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n  s \\<in> trms_ecl C\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> (\\<exists>s\\<in>trms_ecl C.\n                      occurs_in (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))", "by auto"], ["proof (state)\nthis:\n  \\<not> allowed_redex t C \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> allowed_redex t C \\<sigma>' \\<Longrightarrow> False", "from this and assms(1)"], ["proof (chain)\npicking this:\n  \\<not> allowed_redex t C \\<sigma>\n  allowed_redex t C \\<sigma>", "show False"], ["proof (prove)\nusing this:\n  \\<not> allowed_redex t C \\<sigma>\n  allowed_redex t C \\<sigma>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The next lemma states that the irreducibility of an instance of a set of terms \nis preserved when the substitution is replaced by its equivalent normal form.\\<close>"], ["", "lemma irred_terms_and_reduced_subst:\n  assumes \"f = (\\<lambda>t. (trm_rep t S))\"\n  assumes \"\\<eta> = (map_subst f \\<sigma>)\"\n  assumes \"all_trms_irreducible (subst_set E \\<sigma>) f\"\n  assumes \"I = int_clset S\"\n  assumes \"equivalent_on  \\<sigma> \\<eta> (vars_of_cl (cl_ecl C)) I\"\n  assumes \"lower_on \\<eta> \\<sigma>  (vars_of_cl (cl_ecl C))\"\n  assumes \"E = (trms_ecl C)\"\n  assumes \"\\<forall>x \\<in> S. \\<forall>y. (y \\<in> trms_ecl x \\<longrightarrow> dom_trm y (cl_ecl x))\"\n  assumes \"C \\<in> S\"\n  assumes \"fo_interpretation I\"\n  shows \"all_trms_irreducible (subst_set E \\<eta> ) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_trms_irreducible (subst_set E \\<eta>) f", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set E \\<eta>) f \\<Longrightarrow>\n    False", "assume \"\\<not>all_trms_irreducible (subst_set E \\<eta>) f\""], ["proof (state)\nthis:\n  \\<not> all_trms_irreducible (subst_set E \\<eta>) f\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set E \\<eta>) f \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<not> all_trms_irreducible (subst_set E \\<eta>) f", "obtain t y where \"y \\<in> (subst_set E \\<eta>)\" \"occurs_in t y\" \"f t \\<noteq> t\""], ["proof (prove)\nusing this:\n  \\<not> all_trms_irreducible (subst_set E \\<eta>) f\n\ngoal (1 subgoal):\n 1. (\\<And>y t.\n        \\<lbrakk>y \\<in> subst_set E \\<eta>; occurs_in t y;\n         f t \\<noteq> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding all_trms_irreducible_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x y.\n             x \\<in> subst_set E \\<eta> \\<longrightarrow>\n             occurs_in y x \\<longrightarrow> f y = y)\n\ngoal (1 subgoal):\n 1. (\\<And>y t.\n        \\<lbrakk>y \\<in> subst_set E \\<eta>; occurs_in t y;\n         f t \\<noteq> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  y \\<in> subst_set E \\<eta>\n  occurs_in t y\n  f t \\<noteq> t\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set E \\<eta>) f \\<Longrightarrow>\n    False", "from \\<open>occurs_in t y\\<close>"], ["proof (chain)\npicking this:\n  occurs_in t y", "obtain p where \"subterm y p t\""], ["proof (prove)\nusing this:\n  occurs_in t y\n\ngoal (1 subgoal):\n 1. (\\<And>p. subterm y p t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding occurs_in_def"], ["proof (prove)\nusing this:\n  \\<exists>p. subterm y p t\n\ngoal (1 subgoal):\n 1. (\\<And>p. subterm y p t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  subterm y p t\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set E \\<eta>) f \\<Longrightarrow>\n    False", "from this and \\<open>f t \\<noteq> t\\<close> and assms(1)"], ["proof (chain)\npicking this:\n  subterm y p t\n  f t \\<noteq> t\n  f = (\\<lambda>t. trm_rep t S)", "have \"f y \\<noteq> y\""], ["proof (prove)\nusing this:\n  subterm y p t\n  f t \\<noteq> t\n  f = (\\<lambda>t. trm_rep t S)\n\ngoal (1 subgoal):\n 1. f y \\<noteq> y", "using subts_of_irred_trms_are_irred"], ["proof (prove)\nusing this:\n  subterm y p t\n  f t \\<noteq> t\n  f = (\\<lambda>t. trm_rep t S)\n  trm_rep ?y ?S \\<noteq> ?y \\<Longrightarrow>\n  subterm ?x ?p ?y \\<longrightarrow> trm_rep ?x ?S \\<noteq> ?x\n\ngoal (1 subgoal):\n 1. f y \\<noteq> y", "by blast"], ["proof (state)\nthis:\n  f y \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set E \\<eta>) f \\<Longrightarrow>\n    False", "from \\<open>y \\<in> (subst_set E \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> subst_set E \\<eta>", "obtain z where \"z \\<in> E\" and \"y = (subst z \\<eta>)\""], ["proof (prove)\nusing this:\n  y \\<in> subst_set E \\<eta>\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> E; y = z \\<lhd> \\<eta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  z \\<in> E\n  y = z \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set E \\<eta>) f \\<Longrightarrow>\n    False", "from \\<open>z \\<in> E\\<close>"], ["proof (chain)\npicking this:\n  z \\<in> E", "have \"(subst z \\<sigma>) \\<in> (subst_set E \\<sigma>)\""], ["proof (prove)\nusing this:\n  z \\<in> E\n\ngoal (1 subgoal):\n 1. z \\<lhd> \\<sigma> \\<in> subst_set E \\<sigma>", "by auto"], ["proof (state)\nthis:\n  z \\<lhd> \\<sigma> \\<in> subst_set E \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set E \\<eta>) f \\<Longrightarrow>\n    False", "have \"subterm (subst z \\<sigma>) [] (subst z \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subterm (z \\<lhd> \\<sigma>) [] (z \\<lhd> \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  subterm (z \\<lhd> \\<sigma>) [] (z \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set E \\<eta>) f \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  subterm (z \\<lhd> \\<sigma>) [] (z \\<lhd> \\<sigma>)", "have \"occurs_in (subst z \\<sigma>) (subst z \\<sigma>)\""], ["proof (prove)\nusing this:\n  subterm (z \\<lhd> \\<sigma>) [] (z \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. occurs_in (z \\<lhd> \\<sigma>) (z \\<lhd> \\<sigma>)", "unfolding occurs_in_def"], ["proof (prove)\nusing this:\n  subterm (z \\<lhd> \\<sigma>) [] (z \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>p. subterm (z \\<lhd> \\<sigma>) p (z \\<lhd> \\<sigma>)", "by blast"], ["proof (state)\nthis:\n  occurs_in (z \\<lhd> \\<sigma>) (z \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set E \\<eta>) f \\<Longrightarrow>\n    False", "from this and assms(3) and \\<open>(subst z \\<sigma>) \\<in> (subst_set E \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  occurs_in (z \\<lhd> \\<sigma>) (z \\<lhd> \\<sigma>)\n  all_trms_irreducible (subst_set E \\<sigma>) f\n  z \\<lhd> \\<sigma> \\<in> subst_set E \\<sigma>", "have \"f (subst z \\<sigma>) = (subst z \\<sigma>)\""], ["proof (prove)\nusing this:\n  occurs_in (z \\<lhd> \\<sigma>) (z \\<lhd> \\<sigma>)\n  all_trms_irreducible (subst_set E \\<sigma>) f\n  z \\<lhd> \\<sigma> \\<in> subst_set E \\<sigma>\n\ngoal (1 subgoal):\n 1. f (z \\<lhd> \\<sigma>) = z \\<lhd> \\<sigma>", "unfolding all_trms_irreducible_def"], ["proof (prove)\nusing this:\n  occurs_in (z \\<lhd> \\<sigma>) (z \\<lhd> \\<sigma>)\n  \\<forall>x y.\n     x \\<in> subst_set E \\<sigma> \\<longrightarrow>\n     occurs_in y x \\<longrightarrow> f y = y\n  z \\<lhd> \\<sigma> \\<in> subst_set E \\<sigma>\n\ngoal (1 subgoal):\n 1. f (z \\<lhd> \\<sigma>) = z \\<lhd> \\<sigma>", "by metis"], ["proof (state)\nthis:\n  f (z \\<lhd> \\<sigma>) = z \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set E \\<eta>) f \\<Longrightarrow>\n    False", "from this and \\<open>f y \\<noteq> y\\<close> and \\<open>y = (subst z \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  f (z \\<lhd> \\<sigma>) = z \\<lhd> \\<sigma>\n  f y \\<noteq> y\n  y = z \\<lhd> \\<eta>", "have \"(subst z \\<sigma>) \\<noteq> (subst z \\<eta>)\""], ["proof (prove)\nusing this:\n  f (z \\<lhd> \\<sigma>) = z \\<lhd> \\<sigma>\n  f y \\<noteq> y\n  y = z \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. z \\<lhd> \\<sigma> \\<noteq> z \\<lhd> \\<eta>", "by metis"], ["proof (state)\nthis:\n  z \\<lhd> \\<sigma> \\<noteq> z \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set E \\<eta>) f \\<Longrightarrow>\n    False", "from \\<open>z \\<in> E\\<close> and assms(7) assms(8) assms(9)"], ["proof (chain)\npicking this:\n  z \\<in> E\n  E = trms_ecl C\n  \\<forall>x\\<in>S.\n     \\<forall>y. y \\<in> trms_ecl x \\<longrightarrow> dom_trm y (cl_ecl x)\n  C \\<in> S", "have \"dom_trm z (cl_ecl C)\""], ["proof (prove)\nusing this:\n  z \\<in> E\n  E = trms_ecl C\n  \\<forall>x\\<in>S.\n     \\<forall>y. y \\<in> trms_ecl x \\<longrightarrow> dom_trm y (cl_ecl x)\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. dom_trm z (cl_ecl C)", "by metis"], ["proof (state)\nthis:\n  dom_trm z (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set E \\<eta>) f \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  dom_trm z (cl_ecl C)", "have \"vars_of z \\<subseteq> vars_of_cl (cl_ecl C)\""], ["proof (prove)\nusing this:\n  dom_trm z (cl_ecl C)\n\ngoal (1 subgoal):\n 1. vars_of z \\<subseteq> vars_of_cl (cl_ecl C)", "using dom_trm_vars"], ["proof (prove)\nusing this:\n  dom_trm z (cl_ecl C)\n  dom_trm ?t ?C \\<Longrightarrow> vars_of ?t \\<subseteq> vars_of_cl ?C\n\ngoal (1 subgoal):\n 1. vars_of z \\<subseteq> vars_of_cl (cl_ecl C)", "by auto"], ["proof (state)\nthis:\n  vars_of z \\<subseteq> vars_of_cl (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set E \\<eta>) f \\<Longrightarrow>\n    False", "from this assms(5)"], ["proof (chain)\npicking this:\n  vars_of z \\<subseteq> vars_of_cl (cl_ecl C)\n  equivalent_on \\<sigma> \\<eta> (vars_of_cl (cl_ecl C)) I", "have \"equivalent_on \\<sigma> \\<eta> (vars_of z) I\""], ["proof (prove)\nusing this:\n  vars_of z \\<subseteq> vars_of_cl (cl_ecl C)\n  equivalent_on \\<sigma> \\<eta> (vars_of_cl (cl_ecl C)) I\n\ngoal (1 subgoal):\n 1. equivalent_on \\<sigma> \\<eta> (vars_of z) I", "unfolding equivalent_on_def"], ["proof (prove)\nusing this:\n  vars_of z \\<subseteq> vars_of_cl (cl_ecl C)\n  \\<forall>x\\<in>vars_of_cl (cl_ecl C).\n     I (Var x \\<lhd> \\<sigma>) (Var x \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of z.\n       I (Var x \\<lhd> \\<sigma>) (Var x \\<lhd> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  equivalent_on \\<sigma> \\<eta> (vars_of z) I\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set E \\<eta>) f \\<Longrightarrow>\n    False", "from \\<open>vars_of z \\<subseteq> vars_of_cl (cl_ecl C)\\<close> assms(6)"], ["proof (chain)\npicking this:\n  vars_of z \\<subseteq> vars_of_cl (cl_ecl C)\n  lower_on \\<eta> \\<sigma> (vars_of_cl (cl_ecl C))", "have \"lower_on \\<eta> \\<sigma>  (vars_of z)\""], ["proof (prove)\nusing this:\n  vars_of z \\<subseteq> vars_of_cl (cl_ecl C)\n  lower_on \\<eta> \\<sigma> (vars_of_cl (cl_ecl C))\n\ngoal (1 subgoal):\n 1. lower_on \\<eta> \\<sigma> (vars_of z)", "unfolding lower_on_def"], ["proof (prove)\nusing this:\n  vars_of z \\<subseteq> vars_of_cl (cl_ecl C)\n  \\<forall>x\\<in>vars_of_cl (cl_ecl C).\n     lower_or_eq (Var x \\<lhd> \\<eta>) (Var x \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of z.\n       lower_or_eq (Var x \\<lhd> \\<eta>) (Var x \\<lhd> \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  lower_on \\<eta> \\<sigma> (vars_of z)\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set E \\<eta>) f \\<Longrightarrow>\n    False", "from \\<open>(subst z \\<sigma>) \\<noteq> (subst z \\<eta>)\\<close> \n       \\<open>lower_on \\<eta> \\<sigma>  (vars_of z)\\<close>"], ["proof (chain)\npicking this:\n  z \\<lhd> \\<sigma> \\<noteq> z \\<lhd> \\<eta>\n  lower_on \\<eta> \\<sigma> (vars_of z)", "have \"( (subst z \\<eta>),(subst z \\<sigma>) ) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  z \\<lhd> \\<sigma> \\<noteq> z \\<lhd> \\<eta>\n  lower_on \\<eta> \\<sigma> (vars_of z)\n\ngoal (1 subgoal):\n 1. (z \\<lhd> \\<eta>, z \\<lhd> \\<sigma>) \\<in> trm_ord", "using lower_on_term"], ["proof (prove)\nusing this:\n  z \\<lhd> \\<sigma> \\<noteq> z \\<lhd> \\<eta>\n  lower_on \\<eta> \\<sigma> (vars_of z)\n  lower_on ?\\<sigma> ?\\<eta> (vars_of ?t) \\<Longrightarrow>\n  lower_or_eq (?t \\<lhd> ?\\<sigma>) (?t \\<lhd> ?\\<eta>)\n\ngoal (1 subgoal):\n 1. (z \\<lhd> \\<eta>, z \\<lhd> \\<sigma>) \\<in> trm_ord", "unfolding lower_or_eq_def"], ["proof (prove)\nusing this:\n  z \\<lhd> \\<sigma> \\<noteq> z \\<lhd> \\<eta>\n  lower_on \\<eta> \\<sigma> (vars_of z)\n  lower_on ?\\<sigma> ?\\<eta> (vars_of ?t) \\<Longrightarrow>\n  ?t \\<lhd> ?\\<sigma> = ?t \\<lhd> ?\\<eta> \\<or>\n  (?t \\<lhd> ?\\<sigma>, ?t \\<lhd> ?\\<eta>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (z \\<lhd> \\<eta>, z \\<lhd> \\<sigma>) \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (z \\<lhd> \\<eta>, z \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set E \\<eta>) f \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  (z \\<lhd> \\<eta>, z \\<lhd> \\<sigma>) \\<in> trm_ord", "have \"( (subst z \\<sigma>),(subst z \\<eta>) ) \\<notin> trm_ord\""], ["proof (prove)\nusing this:\n  (z \\<lhd> \\<eta>, z \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (z \\<lhd> \\<sigma>, z \\<lhd> \\<eta>) \\<notin> trm_ord", "using trm_ord_trans trm_ord_irrefl irrefl_def trans_def"], ["proof (prove)\nusing this:\n  (z \\<lhd> \\<eta>, z \\<lhd> \\<sigma>) \\<in> trm_ord\n  trans trm_ord\n  irrefl trm_ord\n  irrefl ?r = (\\<forall>a. (a, a) \\<notin> ?r)\n  trans ?r =\n  (\\<forall>x y z.\n      (x, y) \\<in> ?r \\<longrightarrow>\n      (y, z) \\<in> ?r \\<longrightarrow> (x, z) \\<in> ?r)\n\ngoal (1 subgoal):\n 1. (z \\<lhd> \\<sigma>, z \\<lhd> \\<eta>) \\<notin> trm_ord", "by metis"], ["proof (state)\nthis:\n  (z \\<lhd> \\<sigma>, z \\<lhd> \\<eta>) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set E \\<eta>) f \\<Longrightarrow>\n    False", "from assms(10) \\<open>equivalent_on \\<sigma> \\<eta> (vars_of z) I\\<close>"], ["proof (chain)\npicking this:\n  fo_interpretation I\n  equivalent_on \\<sigma> \\<eta> (vars_of z) I", "have \"(I (subst z \\<sigma>) (subst z \\<eta>))\""], ["proof (prove)\nusing this:\n  fo_interpretation I\n  equivalent_on \\<sigma> \\<eta> (vars_of z) I\n\ngoal (1 subgoal):\n 1. I (z \\<lhd> \\<sigma>) (z \\<lhd> \\<eta>)", "using equivalent_on_term"], ["proof (prove)\nusing this:\n  fo_interpretation I\n  equivalent_on \\<sigma> \\<eta> (vars_of z) I\n  \\<lbrakk>congruence ?I;\n   equivalent_on ?\\<sigma> ?\\<eta> (vars_of ?t) ?I\\<rbrakk>\n  \\<Longrightarrow> ?I (?t \\<lhd> ?\\<sigma>) (?t \\<lhd> ?\\<eta>)\n\ngoal (1 subgoal):\n 1. I (z \\<lhd> \\<sigma>) (z \\<lhd> \\<eta>)", "unfolding fo_interpretation_def"], ["proof (prove)\nusing this:\n  congruence I\n  equivalent_on \\<sigma> \\<eta> (vars_of z) I\n  \\<lbrakk>congruence ?I;\n   equivalent_on ?\\<sigma> ?\\<eta> (vars_of ?t) ?I\\<rbrakk>\n  \\<Longrightarrow> ?I (?t \\<lhd> ?\\<sigma>) (?t \\<lhd> ?\\<eta>)\n\ngoal (1 subgoal):\n 1. I (z \\<lhd> \\<sigma>) (z \\<lhd> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  I (z \\<lhd> \\<sigma>) (z \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set E \\<eta>) f \\<Longrightarrow>\n    False", "from this and assms(4) assms(1) \\<open>f (subst z \\<sigma>) = (subst z \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  I (z \\<lhd> \\<sigma>) (z \\<lhd> \\<eta>)\n  I = int_clset S\n  f = (\\<lambda>t. trm_rep t S)\n  f (z \\<lhd> \\<sigma>) = z \\<lhd> \\<sigma>", "have \"(subst z \\<sigma>) = f (subst z \\<eta>)\""], ["proof (prove)\nusing this:\n  I (z \\<lhd> \\<sigma>) (z \\<lhd> \\<eta>)\n  I = int_clset S\n  f = (\\<lambda>t. trm_rep t S)\n  f (z \\<lhd> \\<sigma>) = z \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. z \\<lhd> \\<sigma> = f (z \\<lhd> \\<eta>)", "unfolding same_values_def int_clset_def"], ["proof (prove)\nusing this:\n  I (z \\<lhd> \\<sigma>) (z \\<lhd> \\<eta>)\n  I = (\\<lambda>x y. trm_rep x S = trm_rep y S)\n  f = (\\<lambda>t. trm_rep t S)\n  f (z \\<lhd> \\<sigma>) = z \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. z \\<lhd> \\<sigma> = f (z \\<lhd> \\<eta>)", "by metis"], ["proof (state)\nthis:\n  z \\<lhd> \\<sigma> = f (z \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible (subst_set E \\<eta>) f \\<Longrightarrow>\n    False", "from this \\<open>( (subst z \\<sigma>),(subst z \\<eta>) ) \\<notin> trm_ord\\<close> \n    \\<open>(subst z \\<sigma>) \\<noteq> (subst z \\<eta>)\\<close> assms(1)"], ["proof (chain)\npicking this:\n  z \\<lhd> \\<sigma> = f (z \\<lhd> \\<eta>)\n  (z \\<lhd> \\<sigma>, z \\<lhd> \\<eta>) \\<notin> trm_ord\n  z \\<lhd> \\<sigma> \\<noteq> z \\<lhd> \\<eta>\n  f = (\\<lambda>t. trm_rep t S)", "show False"], ["proof (prove)\nusing this:\n  z \\<lhd> \\<sigma> = f (z \\<lhd> \\<eta>)\n  (z \\<lhd> \\<sigma>, z \\<lhd> \\<eta>) \\<notin> trm_ord\n  z \\<lhd> \\<sigma> \\<noteq> z \\<lhd> \\<eta>\n  f = (\\<lambda>t. trm_rep t S)\n\ngoal (1 subgoal):\n 1. False", "using trm_rep_is_lower"], ["proof (prove)\nusing this:\n  z \\<lhd> \\<sigma> = f (z \\<lhd> \\<eta>)\n  (z \\<lhd> \\<sigma>, z \\<lhd> \\<eta>) \\<notin> trm_ord\n  z \\<lhd> \\<sigma> \\<noteq> z \\<lhd> \\<eta>\n  f = (\\<lambda>t. trm_rep t S)\n  ?t \\<noteq> trm_rep ?t ?S \\<longrightarrow>\n  (trm_rep ?t ?S, ?t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_valid_literal:\n  assumes \"L \\<in> C\"\n  assumes \"orient_lit_inst L t s pos \\<sigma>\"\n  assumes \"\\<not>(validate_ground_clause (int_clset S) (subst_cl C \\<sigma>))\"\n  shows \"trm_rep (subst t \\<sigma>) S \\<noteq> trm_rep (subst s \\<sigma>) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> trm_rep (s \\<lhd> \\<sigma>) S", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S =\n    trm_rep (s \\<lhd> \\<sigma>) S \\<Longrightarrow>\n    False", "assume neg_hyp: \"trm_rep (subst t \\<sigma>) S = trm_rep (subst s \\<sigma>) S\""], ["proof (state)\nthis:\n  trm_rep (t \\<lhd> \\<sigma>) S = trm_rep (s \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S =\n    trm_rep (s \\<lhd> \\<sigma>) S \\<Longrightarrow>\n    False", "let ?I = \"int_clset S\""], ["proof (state)\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S =\n    trm_rep (s \\<lhd> \\<sigma>) S \\<Longrightarrow>\n    False", "from neg_hyp"], ["proof (chain)\npicking this:\n  trm_rep (t \\<lhd> \\<sigma>) S = trm_rep (s \\<lhd> \\<sigma>) S", "have \"validate_ground_eq ?I (Eq (subst t \\<sigma>) (subst s \\<sigma>))\""], ["proof (prove)\nusing this:\n  trm_rep (t \\<lhd> \\<sigma>) S = trm_rep (s \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. validate_ground_eq (int_clset S)\n     (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))", "unfolding same_values_def int_clset_def"], ["proof (prove)\nusing this:\n  trm_rep (t \\<lhd> \\<sigma>) S = trm_rep (s \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. validate_ground_eq (\\<lambda>x y. trm_rep x S = trm_rep y S)\n     (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))", "using validate_ground_eq.simps"], ["proof (prove)\nusing this:\n  trm_rep (t \\<lhd> \\<sigma>) S = trm_rep (s \\<lhd> \\<sigma>) S\n  validate_ground_eq ?I (Eq ?t ?s) = ?I ?t ?s\n\ngoal (1 subgoal):\n 1. validate_ground_eq (\\<lambda>x y. trm_rep x S = trm_rep y S)\n     (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))", "by (metis (mono_tags, lifting))"], ["proof (state)\nthis:\n  validate_ground_eq (int_clset S)\n   (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))\n\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S =\n    trm_rep (s \\<lhd> \\<sigma>) S \\<Longrightarrow>\n    False", "from \\<open>trm_rep (subst t \\<sigma>) S = trm_rep (subst s \\<sigma>) S\\<close>"], ["proof (chain)\npicking this:\n  trm_rep (t \\<lhd> \\<sigma>) S = trm_rep (s \\<lhd> \\<sigma>) S", "have \"validate_ground_eq ?I (Eq (subst s \\<sigma>) (subst t \\<sigma>))\""], ["proof (prove)\nusing this:\n  trm_rep (t \\<lhd> \\<sigma>) S = trm_rep (s \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. validate_ground_eq (int_clset S)\n     (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))", "unfolding same_values_def  int_clset_def"], ["proof (prove)\nusing this:\n  trm_rep (t \\<lhd> \\<sigma>) S = trm_rep (s \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. validate_ground_eq (\\<lambda>x y. trm_rep x S = trm_rep y S)\n     (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))", "using validate_ground_eq.simps"], ["proof (prove)\nusing this:\n  trm_rep (t \\<lhd> \\<sigma>) S = trm_rep (s \\<lhd> \\<sigma>) S\n  validate_ground_eq ?I (Eq ?t ?s) = ?I ?t ?s\n\ngoal (1 subgoal):\n 1. validate_ground_eq (\\<lambda>x y. trm_rep x S = trm_rep y S)\n     (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))", "by (metis (mono_tags, lifting))"], ["proof (state)\nthis:\n  validate_ground_eq (int_clset S)\n   (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))\n\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S =\n    trm_rep (s \\<lhd> \\<sigma>) S \\<Longrightarrow>\n    False", "from \\<open>orient_lit_inst L t s pos \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L t s pos \\<sigma>", "have \"L = (Pos (Eq t s)) \\<or> L = (Pos (Eq s t))\""], ["proof (prove)\nusing this:\n  orient_lit_inst L t s pos \\<sigma>\n\ngoal (1 subgoal):\n 1. L = Pos (Eq t s) \\<or> L = Pos (Eq s t)", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  (L = Pos (Eq t s) \\<or> L = Pos (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  pos = pos \\<or>\n  (L = Neg (Eq t s) \\<or> L = Neg (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and> pos = neg\n\ngoal (1 subgoal):\n 1. L = Pos (Eq t s) \\<or> L = Pos (Eq s t)", "by auto"], ["proof (state)\nthis:\n  L = Pos (Eq t s) \\<or> L = Pos (Eq s t)\n\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S =\n    trm_rep (s \\<lhd> \\<sigma>) S \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  L = Pos (Eq t s) \\<or> L = Pos (Eq s t)", "have \"subst_lit L \\<sigma> = (Pos (Eq (subst t \\<sigma>)  (subst s \\<sigma>))) \\<or>\n            subst_lit L \\<sigma> = (Pos (Eq (subst s \\<sigma>)  (subst t \\<sigma>)))\""], ["proof (prove)\nusing this:\n  L = Pos (Eq t s) \\<or> L = Pos (Eq s t)\n\ngoal (1 subgoal):\n 1. subst_lit L \\<sigma> =\n    Pos (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)) \\<or>\n    subst_lit L \\<sigma> = Pos (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))", "by auto"], ["proof (state)\nthis:\n  subst_lit L \\<sigma> =\n  Pos (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)) \\<or>\n  subst_lit L \\<sigma> = Pos (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))\n\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S =\n    trm_rep (s \\<lhd> \\<sigma>) S \\<Longrightarrow>\n    False", "from this and \\<open>validate_ground_eq ?I (Eq (subst s \\<sigma>) (subst t \\<sigma>))\\<close> \n        and \\<open>validate_ground_eq ?I (Eq (subst t \\<sigma>) (subst s \\<sigma>))\\<close>"], ["proof (chain)\npicking this:\n  subst_lit L \\<sigma> =\n  Pos (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)) \\<or>\n  subst_lit L \\<sigma> = Pos (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))\n  validate_ground_eq (int_clset S)\n   (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))\n  validate_ground_eq (int_clset S)\n   (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))", "have \"validate_ground_lit ?I (subst_lit L \\<sigma>)\""], ["proof (prove)\nusing this:\n  subst_lit L \\<sigma> =\n  Pos (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)) \\<or>\n  subst_lit L \\<sigma> = Pos (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))\n  validate_ground_eq (int_clset S)\n   (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))\n  validate_ground_eq (int_clset S)\n   (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))\n\ngoal (1 subgoal):\n 1. validate_ground_lit (int_clset S) (subst_lit L \\<sigma>)", "using validate_ground_lit.simps(1)"], ["proof (prove)\nusing this:\n  subst_lit L \\<sigma> =\n  Pos (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)) \\<or>\n  subst_lit L \\<sigma> = Pos (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))\n  validate_ground_eq (int_clset S)\n   (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))\n  validate_ground_eq (int_clset S)\n   (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))\n  validate_ground_lit ?I (Pos ?E) = validate_ground_eq ?I ?E\n\ngoal (1 subgoal):\n 1. validate_ground_lit (int_clset S) (subst_lit L \\<sigma>)", "by metis"], ["proof (state)\nthis:\n  validate_ground_lit (int_clset S) (subst_lit L \\<sigma>)\n\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S =\n    trm_rep (s \\<lhd> \\<sigma>) S \\<Longrightarrow>\n    False", "from assms(1)"], ["proof (chain)\npicking this:\n  L \\<in> C", "have \"(subst_lit L \\<sigma>) \\<in> (subst_cl C \\<sigma>)\""], ["proof (prove)\nusing this:\n  L \\<in> C\n\ngoal (1 subgoal):\n 1. subst_lit L \\<sigma> \\<in> subst_cl C \\<sigma>", "by auto"], ["proof (state)\nthis:\n  subst_lit L \\<sigma> \\<in> subst_cl C \\<sigma>\n\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S =\n    trm_rep (s \\<lhd> \\<sigma>) S \\<Longrightarrow>\n    False", "from \\<open>(subst_lit L \\<sigma>) \\<in> (subst_cl C \\<sigma>)\\<close> \n          and \\<open>validate_ground_lit ?I (subst_lit L \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  subst_lit L \\<sigma> \\<in> subst_cl C \\<sigma>\n  validate_ground_lit (int_clset S) (subst_lit L \\<sigma>)", "have \"validate_ground_clause ?I (subst_cl C \\<sigma>)\""], ["proof (prove)\nusing this:\n  subst_lit L \\<sigma> \\<in> subst_cl C \\<sigma>\n  validate_ground_lit (int_clset S) (subst_lit L \\<sigma>)\n\ngoal (1 subgoal):\n 1. validate_ground_clause (int_clset S) (subst_cl C \\<sigma>)", "using validate_ground_clause.elims(3)"], ["proof (prove)\nusing this:\n  subst_lit L \\<sigma> \\<in> subst_cl C \\<sigma>\n  validate_ground_lit (int_clset S) (subst_lit L \\<sigma>)\n  \\<lbrakk>\\<not> validate_ground_clause ?x ?xa;\n   \\<And>I C.\n      \\<lbrakk>?x = I; ?xa = C;\n       \\<nexists>L. L \\<in> C \\<and> validate_ground_lit I L\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. validate_ground_clause (int_clset S) (subst_cl C \\<sigma>)", "by blast"], ["proof (state)\nthis:\n  validate_ground_clause (int_clset S) (subst_cl C \\<sigma>)\n\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S =\n    trm_rep (s \\<lhd> \\<sigma>) S \\<Longrightarrow>\n    False", "from this and \\<open>\\<not> validate_ground_clause ?I (subst_cl C \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  validate_ground_clause (int_clset S) (subst_cl C \\<sigma>)\n  \\<not> validate_ground_clause (int_clset S) (subst_cl C \\<sigma>)", "show False"], ["proof (prove)\nusing this:\n  validate_ground_clause (int_clset S) (subst_cl C \\<sigma>)\n  \\<not> validate_ground_clause (int_clset S) (subst_cl C \\<sigma>)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Lifting\\<close>"], ["", "text \\<open>This section contains all the necessary lemmata for transforming ground inferences into \nfirst-order inferences. We show that all the necessary properties can be lifted.\\<close>"], ["", "lemma lift_orient_lit_inst:\n  assumes \"orient_lit_inst  L t s polarity \\<theta>\"\n  assumes \"subst_eq \\<theta> (comp \\<sigma> \\<eta>)\" \n  shows \"orient_lit_inst L t s polarity \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orient_lit_inst L t s polarity \\<sigma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. orient_lit_inst L t s polarity \\<sigma>", "let ?\\<theta> = \"(comp \\<sigma> \\<eta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. orient_lit_inst L t s polarity \\<sigma>", "have \"polarity = pos \\<or> polarity = neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polarity = pos \\<or> polarity = neg", "using sign.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = pos \\<Longrightarrow> ?P;\n   ?y = neg \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. polarity = pos \\<or> polarity = neg", "by auto"], ["proof (state)\nthis:\n  polarity = pos \\<or> polarity = neg\n\ngoal (1 subgoal):\n 1. orient_lit_inst L t s polarity \\<sigma>", "then"], ["proof (chain)\npicking this:\n  polarity = pos \\<or> polarity = neg", "show ?thesis"], ["proof (prove)\nusing this:\n  polarity = pos \\<or> polarity = neg\n\ngoal (1 subgoal):\n 1. orient_lit_inst L t s polarity \\<sigma>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow> orient_lit_inst L t s polarity \\<sigma>\n 2. polarity = neg \\<Longrightarrow> orient_lit_inst L t s polarity \\<sigma>", "assume \"polarity = pos\""], ["proof (state)\nthis:\n  polarity = pos\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow> orient_lit_inst L t s polarity \\<sigma>\n 2. polarity = neg \\<Longrightarrow> orient_lit_inst L t s polarity \\<sigma>", "from this and assms(1)"], ["proof (chain)\npicking this:\n  polarity = pos\n  orient_lit_inst L t s polarity \\<theta>", "have \"L = Pos (Eq t s) \\<or> L = Pos (Eq s t)\"\n      and \"( (subst t \\<theta>),  (subst s \\<theta>)) \\<notin> trm_ord\""], ["proof (prove)\nusing this:\n  polarity = pos\n  orient_lit_inst L t s polarity \\<theta>\n\ngoal (1 subgoal):\n 1. L = Pos (Eq t s) \\<or> L = Pos (Eq s t) &&&\n    (t \\<lhd> \\<theta>, s \\<lhd> \\<theta>) \\<notin> trm_ord", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  polarity = pos\n  (L = Pos (Eq t s) \\<or> L = Pos (Eq s t)) \\<and>\n  (t \\<lhd> \\<theta>, s \\<lhd> \\<theta>) \\<notin> trm_ord \\<and>\n  polarity = pos \\<or>\n  (L = Neg (Eq t s) \\<or> L = Neg (Eq s t)) \\<and>\n  (t \\<lhd> \\<theta>, s \\<lhd> \\<theta>) \\<notin> trm_ord \\<and>\n  polarity = neg\n\ngoal (1 subgoal):\n 1. L = Pos (Eq t s) \\<or> L = Pos (Eq s t) &&&\n    (t \\<lhd> \\<theta>, s \\<lhd> \\<theta>) \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  L = Pos (Eq t s) \\<or> L = Pos (Eq s t)\n  (t \\<lhd> \\<theta>, s \\<lhd> \\<theta>) \\<notin> trm_ord\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow> orient_lit_inst L t s polarity \\<sigma>\n 2. polarity = neg \\<Longrightarrow> orient_lit_inst L t s polarity \\<sigma>", "from assms(2)"], ["proof (chain)\npicking this:\n  \\<theta> \\<doteq> \\<sigma> \\<lozenge> \\<eta>", "have \"(subst t \\<theta>) = (subst (subst t \\<sigma>) \\<eta>)\""], ["proof (prove)\nusing this:\n  \\<theta> \\<doteq> \\<sigma> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<theta> = t \\<lhd> \\<sigma> \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  t \\<lhd> \\<theta> = t \\<lhd> \\<sigma> \\<lhd> \\<eta>\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow> orient_lit_inst L t s polarity \\<sigma>\n 2. polarity = neg \\<Longrightarrow> orient_lit_inst L t s polarity \\<sigma>", "from assms(2)"], ["proof (chain)\npicking this:\n  \\<theta> \\<doteq> \\<sigma> \\<lozenge> \\<eta>", "have \"(subst s \\<theta>) = (subst (subst s \\<sigma>) \\<eta>)\""], ["proof (prove)\nusing this:\n  \\<theta> \\<doteq> \\<sigma> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. s \\<lhd> \\<theta> = s \\<lhd> \\<sigma> \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  s \\<lhd> \\<theta> = s \\<lhd> \\<sigma> \\<lhd> \\<eta>\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow> orient_lit_inst L t s polarity \\<sigma>\n 2. polarity = neg \\<Longrightarrow> orient_lit_inst L t s polarity \\<sigma>", "from \\<open>(subst t \\<theta>) = (subst (subst t \\<sigma>) \\<eta>)\\<close>\n         \\<open>(subst s \\<theta>) = (subst (subst s \\<sigma>) \\<eta>)\\<close>\n         \\<open>( (subst t \\<theta>),  (subst s \\<theta>)) \\<notin> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<theta> = t \\<lhd> \\<sigma> \\<lhd> \\<eta>\n  s \\<lhd> \\<theta> = s \\<lhd> \\<sigma> \\<lhd> \\<eta>\n  (t \\<lhd> \\<theta>, s \\<lhd> \\<theta>) \\<notin> trm_ord", "have \"( (subst (subst t \\<sigma>) \\<eta>),(subst (subst s \\<sigma>) \\<eta>)) \\<notin> trm_ord\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<theta> = t \\<lhd> \\<sigma> \\<lhd> \\<eta>\n  s \\<lhd> \\<theta> = s \\<lhd> \\<sigma> \\<lhd> \\<eta>\n  (t \\<lhd> \\<theta>, s \\<lhd> \\<theta>) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma> \\<lhd> \\<eta>, s \\<lhd> \\<sigma> \\<lhd> \\<eta>)\n    \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  (t \\<lhd> \\<sigma> \\<lhd> \\<eta>, s \\<lhd> \\<sigma> \\<lhd> \\<eta>)\n  \\<notin> trm_ord\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow> orient_lit_inst L t s polarity \\<sigma>\n 2. polarity = neg \\<Longrightarrow> orient_lit_inst L t s polarity \\<sigma>", "from this"], ["proof (chain)\npicking this:\n  (t \\<lhd> \\<sigma> \\<lhd> \\<eta>, s \\<lhd> \\<sigma> \\<lhd> \\<eta>)\n  \\<notin> trm_ord", "have \"( (subst t \\<sigma>),  (subst s \\<sigma>)) \\<notin> trm_ord\""], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<sigma> \\<lhd> \\<eta>, s \\<lhd> \\<sigma> \\<lhd> \\<eta>)\n  \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord", "using trm_ord_subst"], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<sigma> \\<lhd> \\<eta>, s \\<lhd> \\<sigma> \\<lhd> \\<eta>)\n  \\<notin> trm_ord\n  \\<forall>s x y.\n     (x, y) \\<in> trm_ord \\<longrightarrow>\n     (x \\<lhd> s, y \\<lhd> s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow> orient_lit_inst L t s polarity \\<sigma>\n 2. polarity = neg \\<Longrightarrow> orient_lit_inst L t s polarity \\<sigma>", "from this and \\<open>polarity = pos\\<close> \\<open>L = Pos (Eq t s) \\<or> L = Pos (Eq s t)\\<close>"], ["proof (chain)\npicking this:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  polarity = pos\n  L = Pos (Eq t s) \\<or> L = Pos (Eq s t)", "show ?thesis"], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  polarity = pos\n  L = Pos (Eq t s) \\<or> L = Pos (Eq s t)\n\ngoal (1 subgoal):\n 1. orient_lit_inst L t s polarity \\<sigma>", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  polarity = pos\n  L = Pos (Eq t s) \\<or> L = Pos (Eq s t)\n\ngoal (1 subgoal):\n 1. (L = Pos (Eq t s) \\<or> L = Pos (Eq s t)) \\<and>\n    (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n    polarity = pos \\<or>\n    (L = Neg (Eq t s) \\<or> L = Neg (Eq s t)) \\<and>\n    (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n    polarity = neg", "by blast"], ["proof (state)\nthis:\n  orient_lit_inst L t s polarity \\<sigma>\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> orient_lit_inst L t s polarity \\<sigma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> orient_lit_inst L t s polarity \\<sigma>", "assume \"polarity = neg\""], ["proof (state)\nthis:\n  polarity = neg\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> orient_lit_inst L t s polarity \\<sigma>", "from this and assms(1)"], ["proof (chain)\npicking this:\n  polarity = neg\n  orient_lit_inst L t s polarity \\<theta>", "have \"L = Neg (Eq t s) \\<or> L = Neg (Eq s t)\"\n      and \"( (subst t \\<theta>),  (subst s \\<theta>)) \\<notin> trm_ord\""], ["proof (prove)\nusing this:\n  polarity = neg\n  orient_lit_inst L t s polarity \\<theta>\n\ngoal (1 subgoal):\n 1. L = Neg (Eq t s) \\<or> L = Neg (Eq s t) &&&\n    (t \\<lhd> \\<theta>, s \\<lhd> \\<theta>) \\<notin> trm_ord", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  polarity = neg\n  (L = Pos (Eq t s) \\<or> L = Pos (Eq s t)) \\<and>\n  (t \\<lhd> \\<theta>, s \\<lhd> \\<theta>) \\<notin> trm_ord \\<and>\n  polarity = pos \\<or>\n  (L = Neg (Eq t s) \\<or> L = Neg (Eq s t)) \\<and>\n  (t \\<lhd> \\<theta>, s \\<lhd> \\<theta>) \\<notin> trm_ord \\<and>\n  polarity = neg\n\ngoal (1 subgoal):\n 1. L = Neg (Eq t s) \\<or> L = Neg (Eq s t) &&&\n    (t \\<lhd> \\<theta>, s \\<lhd> \\<theta>) \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  L = Neg (Eq t s) \\<or> L = Neg (Eq s t)\n  (t \\<lhd> \\<theta>, s \\<lhd> \\<theta>) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> orient_lit_inst L t s polarity \\<sigma>", "from assms(2)"], ["proof (chain)\npicking this:\n  \\<theta> \\<doteq> \\<sigma> \\<lozenge> \\<eta>", "have \"(subst t \\<theta>) = (subst (subst t \\<sigma>) \\<eta>)\""], ["proof (prove)\nusing this:\n  \\<theta> \\<doteq> \\<sigma> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<theta> = t \\<lhd> \\<sigma> \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  t \\<lhd> \\<theta> = t \\<lhd> \\<sigma> \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> orient_lit_inst L t s polarity \\<sigma>", "from assms(2)"], ["proof (chain)\npicking this:\n  \\<theta> \\<doteq> \\<sigma> \\<lozenge> \\<eta>", "have \"(subst s \\<theta>) = (subst (subst s \\<sigma>) \\<eta>)\""], ["proof (prove)\nusing this:\n  \\<theta> \\<doteq> \\<sigma> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. s \\<lhd> \\<theta> = s \\<lhd> \\<sigma> \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  s \\<lhd> \\<theta> = s \\<lhd> \\<sigma> \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> orient_lit_inst L t s polarity \\<sigma>", "from \\<open>(subst t \\<theta>) = (subst (subst t \\<sigma>) \\<eta>)\\<close>\n         \\<open>(subst s \\<theta>) = (subst (subst s \\<sigma>) \\<eta>)\\<close>\n         \\<open>( (subst t \\<theta>),  (subst s \\<theta>)) \\<notin> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<theta> = t \\<lhd> \\<sigma> \\<lhd> \\<eta>\n  s \\<lhd> \\<theta> = s \\<lhd> \\<sigma> \\<lhd> \\<eta>\n  (t \\<lhd> \\<theta>, s \\<lhd> \\<theta>) \\<notin> trm_ord", "have \"( (subst (subst t \\<sigma>) \\<eta>),(subst (subst s \\<sigma>) \\<eta>)) \\<notin> trm_ord\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<theta> = t \\<lhd> \\<sigma> \\<lhd> \\<eta>\n  s \\<lhd> \\<theta> = s \\<lhd> \\<sigma> \\<lhd> \\<eta>\n  (t \\<lhd> \\<theta>, s \\<lhd> \\<theta>) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma> \\<lhd> \\<eta>, s \\<lhd> \\<sigma> \\<lhd> \\<eta>)\n    \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  (t \\<lhd> \\<sigma> \\<lhd> \\<eta>, s \\<lhd> \\<sigma> \\<lhd> \\<eta>)\n  \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> orient_lit_inst L t s polarity \\<sigma>", "from this"], ["proof (chain)\npicking this:\n  (t \\<lhd> \\<sigma> \\<lhd> \\<eta>, s \\<lhd> \\<sigma> \\<lhd> \\<eta>)\n  \\<notin> trm_ord", "have \"( (subst t \\<sigma>),  (subst s \\<sigma>)) \\<notin> trm_ord\""], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<sigma> \\<lhd> \\<eta>, s \\<lhd> \\<sigma> \\<lhd> \\<eta>)\n  \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord", "using trm_ord_subst"], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<sigma> \\<lhd> \\<eta>, s \\<lhd> \\<sigma> \\<lhd> \\<eta>)\n  \\<notin> trm_ord\n  \\<forall>s x y.\n     (x, y) \\<in> trm_ord \\<longrightarrow>\n     (x \\<lhd> s, y \\<lhd> s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow> orient_lit_inst L t s polarity \\<sigma>", "from this and \\<open>polarity = neg\\<close> \\<open>L = Neg (Eq t s) \\<or> L = Neg (Eq s t)\\<close>"], ["proof (chain)\npicking this:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  polarity = neg\n  L = Neg (Eq t s) \\<or> L = Neg (Eq s t)", "show ?thesis"], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  polarity = neg\n  L = Neg (Eq t s) \\<or> L = Neg (Eq s t)\n\ngoal (1 subgoal):\n 1. orient_lit_inst L t s polarity \\<sigma>", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  polarity = neg\n  L = Neg (Eq t s) \\<or> L = Neg (Eq s t)\n\ngoal (1 subgoal):\n 1. (L = Pos (Eq t s) \\<or> L = Pos (Eq s t)) \\<and>\n    (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n    polarity = pos \\<or>\n    (L = Neg (Eq t s) \\<or> L = Neg (Eq s t)) \\<and>\n    (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n    polarity = neg", "by blast"], ["proof (state)\nthis:\n  orient_lit_inst L t s polarity \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  orient_lit_inst L t s polarity \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_maximal_literal:\n  assumes \"maximal_literal (subst_lit L \\<sigma>) (subst_cl C \\<sigma>)\"\n  shows \"maximal_literal L C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal_literal L C", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> maximal_literal L C \\<Longrightarrow> False", "assume \"\\<not>maximal_literal L C\""], ["proof (state)\nthis:\n  \\<not> maximal_literal L C\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal L C \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> maximal_literal L C", "obtain M where \"M \\<in> C\" and \"(L,M) \\<in> lit_ord\""], ["proof (prove)\nusing this:\n  \\<not> maximal_literal L C\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>M \\<in> C; (L, M) \\<in> lit_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding maximal_literal_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x. x \\<in> C \\<longrightarrow> (L, x) \\<notin> lit_ord)\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>M \\<in> C; (L, M) \\<in> lit_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M \\<in> C\n  (L, M) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal L C \\<Longrightarrow> False", "from \\<open>M \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  M \\<in> C", "have \"(subst_lit M \\<sigma>) \\<in> (subst_cl C \\<sigma>)\""], ["proof (prove)\nusing this:\n  M \\<in> C\n\ngoal (1 subgoal):\n 1. subst_lit M \\<sigma> \\<in> subst_cl C \\<sigma>", "by auto"], ["proof (state)\nthis:\n  subst_lit M \\<sigma> \\<in> subst_cl C \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal L C \\<Longrightarrow> False", "from \\<open>(L,M) \\<in> lit_ord\\<close>"], ["proof (chain)\npicking this:\n  (L, M) \\<in> lit_ord", "have \"((subst_lit L \\<sigma>),(subst_lit M \\<sigma>)) \\<in> lit_ord\""], ["proof (prove)\nusing this:\n  (L, M) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord", "using lit_ord_subst"], ["proof (prove)\nusing this:\n  (L, M) \\<in> lit_ord\n  (?L, ?M) \\<in> lit_ord \\<Longrightarrow>\n  (subst_lit ?L ?\\<sigma>, subst_lit ?M ?\\<sigma>) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord", "by auto"], ["proof (state)\nthis:\n  (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. \\<not> maximal_literal L C \\<Longrightarrow> False", "from this and \\<open>(subst_lit M \\<sigma>) \\<in> (subst_cl C \\<sigma>)\\<close> and assms(1)"], ["proof (chain)\npicking this:\n  (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord\n  subst_lit M \\<sigma> \\<in> subst_cl C \\<sigma>\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl C \\<sigma>)", "show False"], ["proof (prove)\nusing this:\n  (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord\n  subst_lit M \\<sigma> \\<in> subst_cl C \\<sigma>\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl C \\<sigma>)\n\ngoal (1 subgoal):\n 1. False", "unfolding maximal_literal_def"], ["proof (prove)\nusing this:\n  (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord\n  subst_lit M \\<sigma> \\<in> subst_cl C \\<sigma>\n  \\<forall>x.\n     x \\<in> subst_cl C \\<sigma> \\<longrightarrow>\n     (subst_lit L \\<sigma>, x) \\<notin> lit_ord\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_eligible_literal:\n  assumes \"eligible_literal L C \\<sigma>\"\n  assumes \"\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\"\n  shows \"eligible_literal L C \\<theta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eligible_literal L C \\<theta>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eligible_literal L C \\<theta>", "from assms(1)"], ["proof (chain)\npicking this:\n  eligible_literal L C \\<sigma>", "have \"(L \\<in> sel (cl_ecl C) \\<or> \n    (sel(cl_ecl C) = {} \n    \\<and> (maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>))))\""], ["proof (prove)\nusing this:\n  eligible_literal L C \\<sigma>\n\ngoal (1 subgoal):\n 1. L \\<in> sel (cl_ecl C) \\<or>\n    sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)", "unfolding eligible_literal_def"], ["proof (prove)\nusing this:\n  L \\<in> sel (cl_ecl C) \\<or>\n  sel (cl_ecl C) = {} \\<and>\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. L \\<in> sel (cl_ecl C) \\<or>\n    sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  L \\<in> sel (cl_ecl C) \\<or>\n  sel (cl_ecl C) = {} \\<and>\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. eligible_literal L C \\<theta>", "then"], ["proof (chain)\npicking this:\n  L \\<in> sel (cl_ecl C) \\<or>\n  sel (cl_ecl C) = {} \\<and>\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)", "show ?thesis"], ["proof (prove)\nusing this:\n  L \\<in> sel (cl_ecl C) \\<or>\n  sel (cl_ecl C) = {} \\<and>\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. eligible_literal L C \\<theta>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. L \\<in> sel (cl_ecl C) \\<Longrightarrow> eligible_literal L C \\<theta>\n 2. sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) \\<Longrightarrow>\n    eligible_literal L C \\<theta>", "assume \"L \\<in> sel (cl_ecl C)\""], ["proof (state)\nthis:\n  L \\<in> sel (cl_ecl C)\n\ngoal (2 subgoals):\n 1. L \\<in> sel (cl_ecl C) \\<Longrightarrow> eligible_literal L C \\<theta>\n 2. sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) \\<Longrightarrow>\n    eligible_literal L C \\<theta>", "then"], ["proof (chain)\npicking this:\n  L \\<in> sel (cl_ecl C)", "show ?thesis"], ["proof (prove)\nusing this:\n  L \\<in> sel (cl_ecl C)\n\ngoal (1 subgoal):\n 1. eligible_literal L C \\<theta>", "unfolding eligible_literal_def"], ["proof (prove)\nusing this:\n  L \\<in> sel (cl_ecl C)\n\ngoal (1 subgoal):\n 1. L \\<in> sel (cl_ecl C) \\<or>\n    sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<theta>) (subst_cl (cl_ecl C) \\<theta>)", "by auto"], ["proof (state)\nthis:\n  eligible_literal L C \\<theta>\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) \\<Longrightarrow>\n    eligible_literal L C \\<theta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) \\<Longrightarrow>\n    eligible_literal L C \\<theta>", "assume \"sel(cl_ecl C) = {} \n     \\<and> (maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>))\""], ["proof (state)\nthis:\n  sel (cl_ecl C) = {} \\<and>\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) \\<Longrightarrow>\n    eligible_literal L C \\<theta>", "then"], ["proof (chain)\npicking this:\n  sel (cl_ecl C) = {} \\<and>\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)", "have \"sel (cl_ecl C) = {}\" and \"maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\""], ["proof (prove)\nusing this:\n  sel (cl_ecl C) = {} \\<and>\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C) = {} &&&\n    maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  sel (cl_ecl C) = {}\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) \\<Longrightarrow>\n    eligible_literal L C \\<theta>", "let ?\\<sigma> = \"\\<theta> \\<lozenge> \\<eta>\""], ["proof (state)\ngoal (1 subgoal):\n 1. sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) \\<Longrightarrow>\n    eligible_literal L C \\<theta>", "from assms(2)"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>", "have \"(subst_lit L \\<sigma>) = (subst_lit L ?\\<sigma>)\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. subst_lit L \\<sigma> = subst_lit L (\\<theta> \\<lozenge> \\<eta>)", "using subst_eq_lit"], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  ?\\<sigma> \\<doteq> ?\\<eta> \\<Longrightarrow>\n  subst_lit ?l ?\\<sigma> = subst_lit ?l ?\\<eta>\n\ngoal (1 subgoal):\n 1. subst_lit L \\<sigma> = subst_lit L (\\<theta> \\<lozenge> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  subst_lit L \\<sigma> = subst_lit L (\\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) \\<Longrightarrow>\n    eligible_literal L C \\<theta>", "then"], ["proof (chain)\npicking this:\n  subst_lit L \\<sigma> = subst_lit L (\\<theta> \\<lozenge> \\<eta>)", "have \"(subst_lit L \\<sigma>) = (subst_lit (subst_lit L \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  subst_lit L \\<sigma> = subst_lit L (\\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. subst_lit L \\<sigma> = subst_lit (subst_lit L \\<theta>) \\<eta>", "using composition_of_substs_lit [of L \\<theta> \\<eta>]"], ["proof (prove)\nusing this:\n  subst_lit L \\<sigma> = subst_lit L (\\<theta> \\<lozenge> \\<eta>)\n  subst_lit (subst_lit L \\<theta>) \\<eta> =\n  subst_lit L (\\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. subst_lit L \\<sigma> = subst_lit (subst_lit L \\<theta>) \\<eta>", "by auto"], ["proof (state)\nthis:\n  subst_lit L \\<sigma> = subst_lit (subst_lit L \\<theta>) \\<eta>\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) \\<Longrightarrow>\n    eligible_literal L C \\<theta>", "from assms(2)"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>", "have \"(subst_cl (cl_ecl C) \\<sigma>) = (subst_cl (cl_ecl C) ?\\<sigma>)\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl C) \\<sigma> =\n    subst_cl (cl_ecl C) (\\<theta> \\<lozenge> \\<eta>)", "using subst_eq_cl [of \\<sigma> \"?\\<sigma>\" \"(cl_ecl C)\"]"], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<Longrightarrow>\n  subst_cl (cl_ecl C) \\<sigma> =\n  subst_cl (cl_ecl C) (\\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl C) \\<sigma> =\n    subst_cl (cl_ecl C) (\\<theta> \\<lozenge> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  subst_cl (cl_ecl C) \\<sigma> =\n  subst_cl (cl_ecl C) (\\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) \\<Longrightarrow>\n    eligible_literal L C \\<theta>", "then"], ["proof (chain)\npicking this:\n  subst_cl (cl_ecl C) \\<sigma> =\n  subst_cl (cl_ecl C) (\\<theta> \\<lozenge> \\<eta>)", "have \"(subst_cl (cl_ecl C) \\<sigma>) = (subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  subst_cl (cl_ecl C) \\<sigma> =\n  subst_cl (cl_ecl C) (\\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl C) \\<sigma> =\n    subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>", "using composition_of_substs_cl [of \"cl_ecl C\" \\<theta> \\<eta>]"], ["proof (prove)\nusing this:\n  subst_cl (cl_ecl C) \\<sigma> =\n  subst_cl (cl_ecl C) (\\<theta> \\<lozenge> \\<eta>)\n  subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta> =\n  subst_cl (cl_ecl C) (\\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl C) \\<sigma> =\n    subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>", "by auto"], ["proof (state)\nthis:\n  subst_cl (cl_ecl C) \\<sigma> =\n  subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) \\<Longrightarrow>\n    eligible_literal L C \\<theta>", "from \\<open>maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\\<close> \n      \\<open>(subst_lit L \\<sigma>) = (subst_lit (subst_lit L \\<theta>) \\<eta>)\\<close> \n      \\<open>(subst_cl (cl_ecl C) \\<sigma>) = (subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n  subst_lit L \\<sigma> = subst_lit (subst_lit L \\<theta>) \\<eta>\n  subst_cl (cl_ecl C) \\<sigma> =\n  subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>", "have \"maximal_literal (subst_lit (subst_lit L \\<theta>) \\<eta>) \n         (subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n  subst_lit L \\<sigma> = subst_lit (subst_lit L \\<theta>) \\<eta>\n  subst_cl (cl_ecl C) \\<sigma> =\n  subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>\n\ngoal (1 subgoal):\n 1. maximal_literal (subst_lit (subst_lit L \\<theta>) \\<eta>)\n     (subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>)", "by auto"], ["proof (state)\nthis:\n  maximal_literal (subst_lit (subst_lit L \\<theta>) \\<eta>)\n   (subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) \\<Longrightarrow>\n    eligible_literal L C \\<theta>", "from this"], ["proof (chain)\npicking this:\n  maximal_literal (subst_lit (subst_lit L \\<theta>) \\<eta>)\n   (subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>)", "have \"maximal_literal (subst_lit L \\<theta>) (subst_cl (cl_ecl C) \\<theta>)\""], ["proof (prove)\nusing this:\n  maximal_literal (subst_lit (subst_lit L \\<theta>) \\<eta>)\n   (subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>)\n\ngoal (1 subgoal):\n 1. maximal_literal (subst_lit L \\<theta>) (subst_cl (cl_ecl C) \\<theta>)", "using lift_maximal_literal"], ["proof (prove)\nusing this:\n  maximal_literal (subst_lit (subst_lit L \\<theta>) \\<eta>)\n   (subst_cl (subst_cl (cl_ecl C) \\<theta>) \\<eta>)\n  maximal_literal (subst_lit ?L ?\\<sigma>)\n   (subst_cl ?C ?\\<sigma>) \\<Longrightarrow>\n  maximal_literal ?L ?C\n\ngoal (1 subgoal):\n 1. maximal_literal (subst_lit L \\<theta>) (subst_cl (cl_ecl C) \\<theta>)", "by metis"], ["proof (state)\nthis:\n  maximal_literal (subst_lit L \\<theta>) (subst_cl (cl_ecl C) \\<theta>)\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) \\<Longrightarrow>\n    eligible_literal L C \\<theta>", "from this and \\<open>sel (cl_ecl C) = {}\\<close>"], ["proof (chain)\npicking this:\n  maximal_literal (subst_lit L \\<theta>) (subst_cl (cl_ecl C) \\<theta>)\n  sel (cl_ecl C) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  maximal_literal (subst_lit L \\<theta>) (subst_cl (cl_ecl C) \\<theta>)\n  sel (cl_ecl C) = {}\n\ngoal (1 subgoal):\n 1. eligible_literal L C \\<theta>", "unfolding eligible_literal_def"], ["proof (prove)\nusing this:\n  maximal_literal (subst_lit L \\<theta>) (subst_cl (cl_ecl C) \\<theta>)\n  sel (cl_ecl C) = {}\n\ngoal (1 subgoal):\n 1. L \\<in> sel (cl_ecl C) \\<or>\n    sel (cl_ecl C) = {} \\<and>\n    maximal_literal (subst_lit L \\<theta>) (subst_cl (cl_ecl C) \\<theta>)", "by auto"], ["proof (state)\nthis:\n  eligible_literal L C \\<theta>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eligible_literal L C \\<theta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_allowed_redex:  \n    assumes \"\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\"\n    assumes \"(allowed_redex u C \\<sigma>)\"\n    shows \"(allowed_redex u C \\<theta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. allowed_redex u C \\<theta>", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> allowed_redex u C \\<theta> \\<Longrightarrow> False", "assume \"\\<not>(allowed_redex u C \\<theta>)\""], ["proof (state)\nthis:\n  \\<not> allowed_redex u C \\<theta>\n\ngoal (1 subgoal):\n 1. \\<not> allowed_redex u C \\<theta> \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  \\<not> allowed_redex u C \\<theta>", "obtain s where \"s \\<in> (trms_ecl C)\" and \"(occurs_in (subst u \\<theta>) (subst s \\<theta>))\""], ["proof (prove)\nusing this:\n  \\<not> allowed_redex u C \\<theta>\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> trms_ecl C;\n         occurs_in (u \\<lhd> \\<theta>) (s \\<lhd> \\<theta>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding allowed_redex_def"], ["proof (prove)\nusing this:\n  \\<not> \\<not> (\\<exists>s\\<in>trms_ecl C.\n                    occurs_in (u \\<lhd> \\<theta>) (s \\<lhd> \\<theta>))\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<in> trms_ecl C;\n         occurs_in (u \\<lhd> \\<theta>) (s \\<lhd> \\<theta>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  s \\<in> trms_ecl C\n  occurs_in (u \\<lhd> \\<theta>) (s \\<lhd> \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<not> allowed_redex u C \\<theta> \\<Longrightarrow> False", "from \\<open>(occurs_in (subst u \\<theta>) (subst s \\<theta>))\\<close>"], ["proof (chain)\npicking this:\n  occurs_in (u \\<lhd> \\<theta>) (s \\<lhd> \\<theta>)", "have \"(occurs_in (subst (subst u \\<theta>) \\<eta>) (subst (subst s \\<theta>) \\<eta>))\""], ["proof (prove)\nusing this:\n  occurs_in (u \\<lhd> \\<theta>) (s \\<lhd> \\<theta>)\n\ngoal (1 subgoal):\n 1. occurs_in (u \\<lhd> \\<theta> \\<lhd> \\<eta>)\n     (s \\<lhd> \\<theta> \\<lhd> \\<eta>)", "using substs_preserve_occurs_in"], ["proof (prove)\nusing this:\n  occurs_in (u \\<lhd> \\<theta>) (s \\<lhd> \\<theta>)\n  occurs_in ?s ?t \\<Longrightarrow>\n  occurs_in (?s \\<lhd> ?\\<sigma>) (?t \\<lhd> ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. occurs_in (u \\<lhd> \\<theta> \\<lhd> \\<eta>)\n     (s \\<lhd> \\<theta> \\<lhd> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  occurs_in (u \\<lhd> \\<theta> \\<lhd> \\<eta>)\n   (s \\<lhd> \\<theta> \\<lhd> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> allowed_redex u C \\<theta> \\<Longrightarrow> False", "from \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>", "have \"(subst u \\<sigma>) = (subst (subst u \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. u \\<lhd> \\<sigma> = u \\<lhd> \\<theta> \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  u \\<lhd> \\<sigma> = u \\<lhd> \\<theta> \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> allowed_redex u C \\<theta> \\<Longrightarrow> False", "from \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>", "have \"(subst s \\<sigma>) = (subst (subst s \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. s \\<lhd> \\<sigma> = s \\<lhd> \\<theta> \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  s \\<lhd> \\<sigma> = s \\<lhd> \\<theta> \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> allowed_redex u C \\<theta> \\<Longrightarrow> False", "from \\<open>(occurs_in (subst (subst u \\<theta>) \\<eta>) (subst (subst s \\<theta>) \\<eta>))\\<close> \n    \\<open>(subst u \\<sigma>) = (subst (subst u \\<theta>) \\<eta>)\\<close> \n    \\<open>(subst s \\<sigma>) = (subst (subst s \\<theta>) \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  occurs_in (u \\<lhd> \\<theta> \\<lhd> \\<eta>)\n   (s \\<lhd> \\<theta> \\<lhd> \\<eta>)\n  u \\<lhd> \\<sigma> = u \\<lhd> \\<theta> \\<lhd> \\<eta>\n  s \\<lhd> \\<sigma> = s \\<lhd> \\<theta> \\<lhd> \\<eta>", "have \"(occurs_in (subst u \\<sigma>) (subst s \\<sigma>))\""], ["proof (prove)\nusing this:\n  occurs_in (u \\<lhd> \\<theta> \\<lhd> \\<eta>)\n   (s \\<lhd> \\<theta> \\<lhd> \\<eta>)\n  u \\<lhd> \\<sigma> = u \\<lhd> \\<theta> \\<lhd> \\<eta>\n  s \\<lhd> \\<sigma> = s \\<lhd> \\<theta> \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. occurs_in (u \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  occurs_in (u \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> allowed_redex u C \\<theta> \\<Longrightarrow> False", "from this and \\<open>s \\<in> (trms_ecl C)\\<close> assms(2)"], ["proof (chain)\npicking this:\n  occurs_in (u \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n  s \\<in> trms_ecl C\n  allowed_redex u C \\<sigma>", "show False"], ["proof (prove)\nusing this:\n  occurs_in (u \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n  s \\<in> trms_ecl C\n  allowed_redex u C \\<sigma>\n\ngoal (1 subgoal):\n 1. False", "unfolding allowed_redex_def"], ["proof (prove)\nusing this:\n  occurs_in (u \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n  s \\<in> trms_ecl C\n  \\<not> (\\<exists>s\\<in>trms_ecl C.\n             occurs_in (u \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_decompose_literal:\n  assumes \"decompose_literal (subst_lit L \\<sigma>) t s polarity\"\n  assumes \"subst_eq \\<theta> (comp \\<sigma> \\<eta>)\" \n  shows \"decompose_literal (subst_lit L \\<theta>) (subst t \\<eta>) (subst s \\<eta>) polarity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "let ?L = \"(subst_lit L \\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "let ?t' = \"(subst t \\<eta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "let ?s' = \"(subst s \\<eta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "let ?\\<theta> = \"(comp \\<sigma> \\<eta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "let ?L' = \"(subst_lit ?L \\<eta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "from assms(2)"], ["proof (chain)\npicking this:\n  \\<theta> \\<doteq> \\<sigma> \\<lozenge> \\<eta>", "have \"(subst_lit L \\<theta>) = (subst_lit L ?\\<theta>)\""], ["proof (prove)\nusing this:\n  \\<theta> \\<doteq> \\<sigma> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. subst_lit L \\<theta> = subst_lit L (\\<sigma> \\<lozenge> \\<eta>)", "using \n      subst_eq_lit"], ["proof (prove)\nusing this:\n  \\<theta> \\<doteq> \\<sigma> \\<lozenge> \\<eta>\n  ?\\<sigma> \\<doteq> ?\\<eta> \\<Longrightarrow>\n  subst_lit ?l ?\\<sigma> = subst_lit ?l ?\\<eta>\n\ngoal (1 subgoal):\n 1. subst_lit L \\<theta> = subst_lit L (\\<sigma> \\<lozenge> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  subst_lit L \\<theta> = subst_lit L (\\<sigma> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "from this"], ["proof (chain)\npicking this:\n  subst_lit L \\<theta> = subst_lit L (\\<sigma> \\<lozenge> \\<eta>)", "have \"(subst_lit L \\<theta>) = ?L'\""], ["proof (prove)\nusing this:\n  subst_lit L \\<theta> = subst_lit L (\\<sigma> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. subst_lit L \\<theta> = subst_lit (subst_lit L \\<sigma>) \\<eta>", "using composition_of_substs_lit"], ["proof (prove)\nusing this:\n  subst_lit L \\<theta> = subst_lit L (\\<sigma> \\<lozenge> \\<eta>)\n  subst_lit (subst_lit ?l ?\\<sigma>) ?\\<eta> =\n  subst_lit ?l (?\\<sigma> \\<lozenge> ?\\<eta>)\n\ngoal (1 subgoal):\n 1. subst_lit L \\<theta> = subst_lit (subst_lit L \\<sigma>) \\<eta>", "by metis"], ["proof (state)\nthis:\n  subst_lit L \\<theta> = subst_lit (subst_lit L \\<sigma>) \\<eta>\n\ngoal (1 subgoal):\n 1. decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "have \"polarity = pos \\<or> polarity = neg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. polarity = pos \\<or> polarity = neg", "using sign.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = pos \\<Longrightarrow> ?P;\n   ?y = neg \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. polarity = pos \\<or> polarity = neg", "by auto"], ["proof (state)\nthis:\n  polarity = pos \\<or> polarity = neg\n\ngoal (1 subgoal):\n 1. decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "then"], ["proof (chain)\npicking this:\n  polarity = pos \\<or> polarity = neg", "show ?thesis"], ["proof (prove)\nusing this:\n  polarity = pos \\<or> polarity = neg\n\ngoal (1 subgoal):\n 1. decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity\n 2. polarity = neg \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "assume \"polarity = pos\""], ["proof (state)\nthis:\n  polarity = pos\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity\n 2. polarity = neg \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "from this and assms(1)"], ["proof (chain)\npicking this:\n  polarity = pos\n  decompose_literal (subst_lit L \\<sigma>) t s polarity", "have \"?L = Pos (Eq t s) \\<or> ?L = Pos (Eq s t)\""], ["proof (prove)\nusing this:\n  polarity = pos\n  decompose_literal (subst_lit L \\<sigma>) t s polarity\n\ngoal (1 subgoal):\n 1. subst_lit L \\<sigma> = Pos (Eq t s) \\<or>\n    subst_lit L \\<sigma> = Pos (Eq s t)", "unfolding decompose_literal_def decompose_equation_def"], ["proof (prove)\nusing this:\n  polarity = pos\n  \\<exists>e.\n     polarity = pos \\<and>\n     subst_lit L \\<sigma> = Pos e \\<and> (e = Eq t s \\<or> e = Eq s t) \\<or>\n     polarity = neg \\<and>\n     subst_lit L \\<sigma> = Neg e \\<and> (e = Eq t s \\<or> e = Eq s t)\n\ngoal (1 subgoal):\n 1. subst_lit L \\<sigma> = Pos (Eq t s) \\<or>\n    subst_lit L \\<sigma> = Pos (Eq s t)", "by auto"], ["proof (state)\nthis:\n  subst_lit L \\<sigma> = Pos (Eq t s) \\<or>\n  subst_lit L \\<sigma> = Pos (Eq s t)\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity\n 2. polarity = neg \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "from \\<open>?L = Pos (Eq t s) \\<or> ?L = Pos (Eq s t)\\<close>"], ["proof (chain)\npicking this:\n  subst_lit L \\<sigma> = Pos (Eq t s) \\<or>\n  subst_lit L \\<sigma> = Pos (Eq s t)", "have \"?L' = Pos (Eq ?t' ?s') \\<or> ?L' = Pos (Eq ?s' ?t')\""], ["proof (prove)\nusing this:\n  subst_lit L \\<sigma> = Pos (Eq t s) \\<or>\n  subst_lit L \\<sigma> = Pos (Eq s t)\n\ngoal (1 subgoal):\n 1. subst_lit (subst_lit L \\<sigma>) \\<eta> =\n    Pos (Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>)) \\<or>\n    subst_lit (subst_lit L \\<sigma>) \\<eta> =\n    Pos (Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>))", "by auto"], ["proof (state)\nthis:\n  subst_lit (subst_lit L \\<sigma>) \\<eta> =\n  Pos (Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>)) \\<or>\n  subst_lit (subst_lit L \\<sigma>) \\<eta> =\n  Pos (Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>))\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity\n 2. polarity = neg \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "from this  \\<open>(subst_lit L \\<theta>) = ?L'\\<close>"], ["proof (chain)\npicking this:\n  subst_lit (subst_lit L \\<sigma>) \\<eta> =\n  Pos (Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>)) \\<or>\n  subst_lit (subst_lit L \\<sigma>) \\<eta> =\n  Pos (Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>))\n  subst_lit L \\<theta> = subst_lit (subst_lit L \\<sigma>) \\<eta>", "have \"(subst_lit L \\<theta>) = Pos (Eq ?t' ?s') \\<or> (subst_lit L \\<theta>) = Pos (Eq ?s' ?t')\""], ["proof (prove)\nusing this:\n  subst_lit (subst_lit L \\<sigma>) \\<eta> =\n  Pos (Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>)) \\<or>\n  subst_lit (subst_lit L \\<sigma>) \\<eta> =\n  Pos (Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>))\n  subst_lit L \\<theta> = subst_lit (subst_lit L \\<sigma>) \\<eta>\n\ngoal (1 subgoal):\n 1. subst_lit L \\<theta> =\n    Pos (Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>)) \\<or>\n    subst_lit L \\<theta> = Pos (Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>))", "by auto"], ["proof (state)\nthis:\n  subst_lit L \\<theta> = Pos (Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>)) \\<or>\n  subst_lit L \\<theta> = Pos (Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>))\n\ngoal (2 subgoals):\n 1. polarity = pos \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity\n 2. polarity = neg \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "from this \\<open>polarity = pos\\<close>"], ["proof (chain)\npicking this:\n  subst_lit L \\<theta> = Pos (Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>)) \\<or>\n  subst_lit L \\<theta> = Pos (Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>))\n  polarity = pos", "show ?thesis"], ["proof (prove)\nusing this:\n  subst_lit L \\<theta> = Pos (Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>)) \\<or>\n  subst_lit L \\<theta> = Pos (Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>))\n  polarity = pos\n\ngoal (1 subgoal):\n 1. decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "unfolding decompose_literal_def \n      decompose_equation_def"], ["proof (prove)\nusing this:\n  subst_lit L \\<theta> = Pos (Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>)) \\<or>\n  subst_lit L \\<theta> = Pos (Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>))\n  polarity = pos\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       polarity = pos \\<and>\n       subst_lit L \\<theta> = Pos e \\<and>\n       (e = Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>) \\<or>\n        e = Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>)) \\<or>\n       polarity = neg \\<and>\n       subst_lit L \\<theta> = Neg e \\<and>\n       (e = Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>) \\<or>\n        e = Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>))", "by auto"], ["proof (state)\nthis:\n  decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n   (s \\<lhd> \\<eta>) polarity\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "assume \"polarity = neg\""], ["proof (state)\nthis:\n  polarity = neg\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "from this and assms(1)"], ["proof (chain)\npicking this:\n  polarity = neg\n  decompose_literal (subst_lit L \\<sigma>) t s polarity", "have \"?L = Neg (Eq t s) \\<or> ?L = Neg (Eq s t)\""], ["proof (prove)\nusing this:\n  polarity = neg\n  decompose_literal (subst_lit L \\<sigma>) t s polarity\n\ngoal (1 subgoal):\n 1. subst_lit L \\<sigma> = Neg (Eq t s) \\<or>\n    subst_lit L \\<sigma> = Neg (Eq s t)", "unfolding decompose_literal_def decompose_equation_def"], ["proof (prove)\nusing this:\n  polarity = neg\n  \\<exists>e.\n     polarity = pos \\<and>\n     subst_lit L \\<sigma> = Pos e \\<and> (e = Eq t s \\<or> e = Eq s t) \\<or>\n     polarity = neg \\<and>\n     subst_lit L \\<sigma> = Neg e \\<and> (e = Eq t s \\<or> e = Eq s t)\n\ngoal (1 subgoal):\n 1. subst_lit L \\<sigma> = Neg (Eq t s) \\<or>\n    subst_lit L \\<sigma> = Neg (Eq s t)", "by auto"], ["proof (state)\nthis:\n  subst_lit L \\<sigma> = Neg (Eq t s) \\<or>\n  subst_lit L \\<sigma> = Neg (Eq s t)\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "from \\<open>?L = Neg (Eq t s) \\<or> ?L = Neg (Eq s t)\\<close>"], ["proof (chain)\npicking this:\n  subst_lit L \\<sigma> = Neg (Eq t s) \\<or>\n  subst_lit L \\<sigma> = Neg (Eq s t)", "have \"?L' = Neg (Eq ?t' ?s') \\<or> ?L' = Neg (Eq ?s' ?t')\""], ["proof (prove)\nusing this:\n  subst_lit L \\<sigma> = Neg (Eq t s) \\<or>\n  subst_lit L \\<sigma> = Neg (Eq s t)\n\ngoal (1 subgoal):\n 1. subst_lit (subst_lit L \\<sigma>) \\<eta> =\n    Neg (Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>)) \\<or>\n    subst_lit (subst_lit L \\<sigma>) \\<eta> =\n    Neg (Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>))", "by auto"], ["proof (state)\nthis:\n  subst_lit (subst_lit L \\<sigma>) \\<eta> =\n  Neg (Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>)) \\<or>\n  subst_lit (subst_lit L \\<sigma>) \\<eta> =\n  Neg (Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>))\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "from this and \\<open>(subst_lit L \\<theta>) = ?L'\\<close>"], ["proof (chain)\npicking this:\n  subst_lit (subst_lit L \\<sigma>) \\<eta> =\n  Neg (Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>)) \\<or>\n  subst_lit (subst_lit L \\<sigma>) \\<eta> =\n  Neg (Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>))\n  subst_lit L \\<theta> = subst_lit (subst_lit L \\<sigma>) \\<eta>", "have \"(subst_lit L \\<theta>) = Neg (Eq ?t' ?s') \\<or> (subst_lit L \\<theta>) = Neg (Eq ?s' ?t')\""], ["proof (prove)\nusing this:\n  subst_lit (subst_lit L \\<sigma>) \\<eta> =\n  Neg (Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>)) \\<or>\n  subst_lit (subst_lit L \\<sigma>) \\<eta> =\n  Neg (Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>))\n  subst_lit L \\<theta> = subst_lit (subst_lit L \\<sigma>) \\<eta>\n\ngoal (1 subgoal):\n 1. subst_lit L \\<theta> =\n    Neg (Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>)) \\<or>\n    subst_lit L \\<theta> = Neg (Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>))", "by auto"], ["proof (state)\nthis:\n  subst_lit L \\<theta> = Neg (Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>)) \\<or>\n  subst_lit L \\<theta> = Neg (Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>))\n\ngoal (1 subgoal):\n 1. polarity = neg \\<Longrightarrow>\n    decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "from this \\<open>polarity = neg\\<close>"], ["proof (chain)\npicking this:\n  subst_lit L \\<theta> = Neg (Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>)) \\<or>\n  subst_lit L \\<theta> = Neg (Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>))\n  polarity = neg", "show ?thesis"], ["proof (prove)\nusing this:\n  subst_lit L \\<theta> = Neg (Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>)) \\<or>\n  subst_lit L \\<theta> = Neg (Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>))\n  polarity = neg\n\ngoal (1 subgoal):\n 1. decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n     (s \\<lhd> \\<eta>) polarity", "unfolding decompose_literal_def \n      decompose_equation_def"], ["proof (prove)\nusing this:\n  subst_lit L \\<theta> = Neg (Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>)) \\<or>\n  subst_lit L \\<theta> = Neg (Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>))\n  polarity = neg\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       polarity = pos \\<and>\n       subst_lit L \\<theta> = Pos e \\<and>\n       (e = Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>) \\<or>\n        e = Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>)) \\<or>\n       polarity = neg \\<and>\n       subst_lit L \\<theta> = Neg e \\<and>\n       (e = Eq (t \\<lhd> \\<eta>) (s \\<lhd> \\<eta>) \\<or>\n        e = Eq (s \\<lhd> \\<eta>) (t \\<lhd> \\<eta>))", "by auto"], ["proof (state)\nthis:\n  decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n   (s \\<lhd> \\<eta>) polarity\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  decompose_literal (subst_lit L \\<theta>) (t \\<lhd> \\<eta>)\n   (s \\<lhd> \\<eta>) polarity\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_dom_trm:\n  assumes \"dom_trm (subst t \\<theta>) (subst_cl C \\<theta>)\"\n  assumes \"\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\"\n  shows \"dom_trm (subst t \\<sigma>) (subst_cl C \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "let ?t = \"(subst t \\<theta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "let ?t' = \"(subst ?t \\<eta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "let ?t'' = \"(subst t \\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "have \"?t' = (subst t (\\<theta> \\<lozenge> \\<eta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<lhd> \\<theta> \\<lhd> \\<eta> = t \\<lhd> \\<theta> \\<lozenge> \\<eta>", "by auto"], ["proof (state)\nthis:\n  t \\<lhd> \\<theta> \\<lhd> \\<eta> = t \\<lhd> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "from assms(2)"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>", "have \"?t'' = (subst t (\\<theta> \\<lozenge> \\<eta>))\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = t \\<lhd> \\<theta> \\<lozenge> \\<eta>", "by auto"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> = t \\<lhd> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "from this and \\<open>?t' = (subst t (\\<theta> \\<lozenge> \\<eta>))\\<close>"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<sigma> = t \\<lhd> \\<theta> \\<lozenge> \\<eta>\n  t \\<lhd> \\<theta> \\<lhd> \\<eta> = t \\<lhd> \\<theta> \\<lozenge> \\<eta>", "have \"?t' = ?t''\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> = t \\<lhd> \\<theta> \\<lozenge> \\<eta>\n  t \\<lhd> \\<theta> \\<lhd> \\<eta> = t \\<lhd> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<theta> \\<lhd> \\<eta> = t \\<lhd> \\<sigma>", "by metis"], ["proof (state)\nthis:\n  t \\<lhd> \\<theta> \\<lhd> \\<eta> = t \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "from assms(1)"], ["proof (chain)\npicking this:\n  dom_trm (t \\<lhd> \\<theta>) (subst_cl C \\<theta>)", "have \"(\\<exists> L u v p. (L \\<in> (subst_cl C \\<theta>) \\<and> (decompose_literal L u v p) \n        \\<and> (( (p = neg \\<and> ?t = u) \\<or> (?t,u) \\<in> trm_ord))))\""], ["proof (prove)\nusing this:\n  dom_trm (t \\<lhd> \\<theta>) (subst_cl C \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<exists>L u v p.\n       L \\<in> subst_cl C \\<theta> \\<and>\n       decompose_literal L u v p \\<and>\n       (p = neg \\<and> t \\<lhd> \\<theta> = u \\<or>\n        (t \\<lhd> \\<theta>, u) \\<in> trm_ord)", "unfolding dom_trm_def"], ["proof (prove)\nusing this:\n  \\<exists>L u v p.\n     L \\<in> subst_cl C \\<theta> \\<and>\n     decompose_literal L u v p \\<and>\n     (p = neg \\<and> t \\<lhd> \\<theta> = u \\<or>\n      (t \\<lhd> \\<theta>, u) \\<in> trm_ord)\n\ngoal (1 subgoal):\n 1. \\<exists>L u v p.\n       L \\<in> subst_cl C \\<theta> \\<and>\n       decompose_literal L u v p \\<and>\n       (p = neg \\<and> t \\<lhd> \\<theta> = u \\<or>\n        (t \\<lhd> \\<theta>, u) \\<in> trm_ord)", "by auto"], ["proof (state)\nthis:\n  \\<exists>L u v p.\n     L \\<in> subst_cl C \\<theta> \\<and>\n     decompose_literal L u v p \\<and>\n     (p = neg \\<and> t \\<lhd> \\<theta> = u \\<or>\n      (t \\<lhd> \\<theta>, u) \\<in> trm_ord)\n\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>L u v p.\n     L \\<in> subst_cl C \\<theta> \\<and>\n     decompose_literal L u v p \\<and>\n     (p = neg \\<and> t \\<lhd> \\<theta> = u \\<or>\n      (t \\<lhd> \\<theta>, u) \\<in> trm_ord)", "obtain L u v p where  \"L \\<in> (subst_cl C \\<theta>)\" \n    \"decompose_literal L u v p\" \"(( (p = neg \\<and> ?t = u) \\<or> (?t,u) \\<in> trm_ord))\""], ["proof (prove)\nusing this:\n  \\<exists>L u v p.\n     L \\<in> subst_cl C \\<theta> \\<and>\n     decompose_literal L u v p \\<and>\n     (p = neg \\<and> t \\<lhd> \\<theta> = u \\<or>\n      (t \\<lhd> \\<theta>, u) \\<in> trm_ord)\n\ngoal (1 subgoal):\n 1. (\\<And>L u v p.\n        \\<lbrakk>L \\<in> subst_cl C \\<theta>; decompose_literal L u v p;\n         p = neg \\<and> t \\<lhd> \\<theta> = u \\<or>\n         (t \\<lhd> \\<theta>, u) \\<in> trm_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dom_trm_def"], ["proof (prove)\nusing this:\n  \\<exists>L u v p.\n     L \\<in> subst_cl C \\<theta> \\<and>\n     decompose_literal L u v p \\<and>\n     (p = neg \\<and> t \\<lhd> \\<theta> = u \\<or>\n      (t \\<lhd> \\<theta>, u) \\<in> trm_ord)\n\ngoal (1 subgoal):\n 1. (\\<And>L u v p.\n        \\<lbrakk>L \\<in> subst_cl C \\<theta>; decompose_literal L u v p;\n         p = neg \\<and> t \\<lhd> \\<theta> = u \\<or>\n         (t \\<lhd> \\<theta>, u) \\<in> trm_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  L \\<in> subst_cl C \\<theta>\n  decompose_literal L u v p\n  p = neg \\<and> t \\<lhd> \\<theta> = u \\<or>\n  (t \\<lhd> \\<theta>, u) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "from \\<open>L \\<in> (subst_cl C \\<theta>)\\<close>"], ["proof (chain)\npicking this:\n  L \\<in> subst_cl C \\<theta>", "obtain L' where \"L' \\<in> C\" \n    \"L = (subst_lit L' \\<theta>)\""], ["proof (prove)\nusing this:\n  L \\<in> subst_cl C \\<theta>\n\ngoal (1 subgoal):\n 1. (\\<And>L'.\n        \\<lbrakk>L' \\<in> C; L = subst_lit L' \\<theta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L' \\<in> C\n  L = subst_lit L' \\<theta>\n\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "from this and \\<open>decompose_literal L u v p\\<close>"], ["proof (chain)\npicking this:\n  L' \\<in> C\n  L = subst_lit L' \\<theta>\n  decompose_literal L u v p", "have \"decompose_literal (subst_lit L' \\<theta>) u v p\""], ["proof (prove)\nusing this:\n  L' \\<in> C\n  L = subst_lit L' \\<theta>\n  decompose_literal L u v p\n\ngoal (1 subgoal):\n 1. decompose_literal (subst_lit L' \\<theta>) u v p", "by auto"], ["proof (state)\nthis:\n  decompose_literal (subst_lit L' \\<theta>) u v p\n\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "from this assms(2)  \\<open>L = (subst_lit L' \\<theta>)\\<close>"], ["proof (chain)\npicking this:\n  decompose_literal (subst_lit L' \\<theta>) u v p\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  L = subst_lit L' \\<theta>", "have \"decompose_literal (subst_lit L' \\<sigma>) (subst u \\<eta>) (subst v \\<eta>) p\""], ["proof (prove)\nusing this:\n  decompose_literal (subst_lit L' \\<theta>) u v p\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  L = subst_lit L' \\<theta>\n\ngoal (1 subgoal):\n 1. decompose_literal (subst_lit L' \\<sigma>) (u \\<lhd> \\<eta>)\n     (v \\<lhd> \\<eta>) p", "using lift_decompose_literal [of L' \\<theta> u v p \\<sigma> \\<eta>]"], ["proof (prove)\nusing this:\n  decompose_literal (subst_lit L' \\<theta>) u v p\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  L = subst_lit L' \\<theta>\n  \\<lbrakk>decompose_literal (subst_lit L' \\<theta>) u v p;\n   \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<rbrakk>\n  \\<Longrightarrow> decompose_literal (subst_lit L' \\<sigma>)\n                     (u \\<lhd> \\<eta>) (v \\<lhd> \\<eta>) p\n\ngoal (1 subgoal):\n 1. decompose_literal (subst_lit L' \\<sigma>) (u \\<lhd> \\<eta>)\n     (v \\<lhd> \\<eta>) p", "by auto"], ["proof (state)\nthis:\n  decompose_literal (subst_lit L' \\<sigma>) (u \\<lhd> \\<eta>)\n   (v \\<lhd> \\<eta>) p\n\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "let ?u = \"(subst u \\<eta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "from \\<open>L' \\<in> C\\<close>"], ["proof (chain)\npicking this:\n  L' \\<in> C", "have \"(subst_lit L' \\<sigma>) \\<in> (subst_cl C \\<sigma>)\""], ["proof (prove)\nusing this:\n  L' \\<in> C\n\ngoal (1 subgoal):\n 1. subst_lit L' \\<sigma> \\<in> subst_cl C \\<sigma>", "by auto"], ["proof (state)\nthis:\n  subst_lit L' \\<sigma> \\<in> subst_cl C \\<sigma>\n\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "from \\<open>(( (p = neg \\<and> ?t = u) \\<or> (?t,u) \\<in> trm_ord))\\<close>"], ["proof (chain)\npicking this:\n  p = neg \\<and> t \\<lhd> \\<theta> = u \\<or>\n  (t \\<lhd> \\<theta>, u) \\<in> trm_ord", "have \"(( (p = neg \\<and> ?t' = ?u) \\<or> (?t',?u) \\<in> trm_ord))\""], ["proof (prove)\nusing this:\n  p = neg \\<and> t \\<lhd> \\<theta> = u \\<or>\n  (t \\<lhd> \\<theta>, u) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. p = neg \\<and> t \\<lhd> \\<theta> \\<lhd> \\<eta> = u \\<lhd> \\<eta> \\<or>\n    (t \\<lhd> \\<theta> \\<lhd> \\<eta>, u \\<lhd> \\<eta>) \\<in> trm_ord", "using trm_ord_subst"], ["proof (prove)\nusing this:\n  p = neg \\<and> t \\<lhd> \\<theta> = u \\<or>\n  (t \\<lhd> \\<theta>, u) \\<in> trm_ord\n  \\<forall>s x y.\n     (x, y) \\<in> trm_ord \\<longrightarrow>\n     (x \\<lhd> s, y \\<lhd> s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. p = neg \\<and> t \\<lhd> \\<theta> \\<lhd> \\<eta> = u \\<lhd> \\<eta> \\<or>\n    (t \\<lhd> \\<theta> \\<lhd> \\<eta>, u \\<lhd> \\<eta>) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  p = neg \\<and> t \\<lhd> \\<theta> \\<lhd> \\<eta> = u \\<lhd> \\<eta> \\<or>\n  (t \\<lhd> \\<theta> \\<lhd> \\<eta>, u \\<lhd> \\<eta>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "from this and \\<open>?t' = ?t''\\<close>"], ["proof (chain)\npicking this:\n  p = neg \\<and> t \\<lhd> \\<theta> \\<lhd> \\<eta> = u \\<lhd> \\<eta> \\<or>\n  (t \\<lhd> \\<theta> \\<lhd> \\<eta>, u \\<lhd> \\<eta>) \\<in> trm_ord\n  t \\<lhd> \\<theta> \\<lhd> \\<eta> = t \\<lhd> \\<sigma>", "have \"(( (p = neg \\<and> ?t'' = ?u) \\<or> (?t'',?u) \\<in> trm_ord))\""], ["proof (prove)\nusing this:\n  p = neg \\<and> t \\<lhd> \\<theta> \\<lhd> \\<eta> = u \\<lhd> \\<eta> \\<or>\n  (t \\<lhd> \\<theta> \\<lhd> \\<eta>, u \\<lhd> \\<eta>) \\<in> trm_ord\n  t \\<lhd> \\<theta> \\<lhd> \\<eta> = t \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. p = neg \\<and> t \\<lhd> \\<sigma> = u \\<lhd> \\<eta> \\<or>\n    (t \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  p = neg \\<and> t \\<lhd> \\<sigma> = u \\<lhd> \\<eta> \\<or>\n  (t \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "from this \\<open>(subst_lit L' \\<sigma>) \\<in> (subst_cl C \\<sigma>)\\<close> \n    \\<open>decompose_literal (subst_lit L' \\<sigma>) (subst u \\<eta>) (subst v \\<eta>) p\\<close>"], ["proof (chain)\npicking this:\n  p = neg \\<and> t \\<lhd> \\<sigma> = u \\<lhd> \\<eta> \\<or>\n  (t \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord\n  subst_lit L' \\<sigma> \\<in> subst_cl C \\<sigma>\n  decompose_literal (subst_lit L' \\<sigma>) (u \\<lhd> \\<eta>)\n   (v \\<lhd> \\<eta>) p", "show \"dom_trm (subst t \\<sigma>) (subst_cl C \\<sigma>)\""], ["proof (prove)\nusing this:\n  p = neg \\<and> t \\<lhd> \\<sigma> = u \\<lhd> \\<eta> \\<or>\n  (t \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord\n  subst_lit L' \\<sigma> \\<in> subst_cl C \\<sigma>\n  decompose_literal (subst_lit L' \\<sigma>) (u \\<lhd> \\<eta>)\n   (v \\<lhd> \\<eta>) p\n\ngoal (1 subgoal):\n 1. dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)", "unfolding dom_trm_def"], ["proof (prove)\nusing this:\n  p = neg \\<and> t \\<lhd> \\<sigma> = u \\<lhd> \\<eta> \\<or>\n  (t \\<lhd> \\<sigma>, u \\<lhd> \\<eta>) \\<in> trm_ord\n  subst_lit L' \\<sigma> \\<in> subst_cl C \\<sigma>\n  decompose_literal (subst_lit L' \\<sigma>) (u \\<lhd> \\<eta>)\n   (v \\<lhd> \\<eta>) p\n\ngoal (1 subgoal):\n 1. \\<exists>L u v p.\n       L \\<in> subst_cl C \\<sigma> \\<and>\n       decompose_literal L u v p \\<and>\n       (p = neg \\<and> t \\<lhd> \\<sigma> = u \\<or>\n        (t \\<lhd> \\<sigma>, u) \\<in> trm_ord)", "by auto"], ["proof (state)\nthis:\n  dom_trm (t \\<lhd> \\<sigma>) (subst_cl C \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_irreducible_terms:\n  assumes \"T = get_trms C (dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)) Ground\"\n  assumes \"\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\"\n  shows \"\\<exists>T'. ( (subst_set T' \\<eta>) \\<subseteq> T \\<and> T' = get_trms C' \n    (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)) FirstOrder)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T'.\n       subst_set T' \\<eta> \\<subseteq> T \\<and>\n       T' =\n       get_trms C' (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>))\n        FirstOrder", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>T'.\n       subst_set T' \\<eta> \\<subseteq> T \\<and>\n       T' =\n       get_trms C' (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>))\n        FirstOrder", "let ?E = \"(dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>T'.\n       subst_set T' \\<eta> \\<subseteq> T \\<and>\n       T' =\n       get_trms C' (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>))\n        FirstOrder", "let ?E' = \"(dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>T'.\n       subst_set T' \\<eta> \\<subseteq> T \\<and>\n       T' =\n       get_trms C' (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>))\n        FirstOrder", "let ?T' = \"(filter_trms C' ?E)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>T'.\n       subst_set T' \\<eta> \\<subseteq> T \\<and>\n       T' =\n       get_trms C' (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>))\n        FirstOrder", "have \"?T' = get_trms C' ?E FirstOrder\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_trms C' (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)) =\n    get_trms C' (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>))\n     FirstOrder", "unfolding get_trms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter_trms C' (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)) =\n    (if FirstOrder = FirstOrder\n     then filter_trms C'\n           (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>))\n     else dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>))", "by auto"], ["proof (state)\nthis:\n  filter_trms C' (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)) =\n  get_trms C' (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>))\n   FirstOrder\n\ngoal (1 subgoal):\n 1. \\<exists>T'.\n       subst_set T' \\<eta> \\<subseteq> T \\<and>\n       T' =\n       get_trms C' (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>))\n        FirstOrder", "from assms(1)"], ["proof (chain)\npicking this:\n  T =\n  get_trms C (dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)) Ground", "have \"T = ?E'\""], ["proof (prove)\nusing this:\n  T =\n  get_trms C (dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)) Ground\n\ngoal (1 subgoal):\n 1. T = dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)", "unfolding get_trms_def"], ["proof (prove)\nusing this:\n  T =\n  (if Ground = FirstOrder\n   then filter_trms C\n         (dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>))\n   else dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>))\n\ngoal (1 subgoal):\n 1. T = dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  T = dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>T'.\n       subst_set T' \\<eta> \\<subseteq> T \\<and>\n       T' =\n       get_trms C' (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>))\n        FirstOrder", "have \"(subst_set ?T' \\<eta>) \\<subseteq> ?E'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_set\n     (filter_trms C'\n       (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)))\n     \\<eta>\n    \\<subseteq> dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> subst_set\n                (filter_trms C'\n                  (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)))\n                \\<eta> \\<Longrightarrow>\n       x \\<in> dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> subst_set\n                (filter_trms C'\n                  (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)))\n                \\<eta> \\<Longrightarrow>\n       x \\<in> dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)", "assume \"x \\<in> (subst_set ?T' \\<eta>)\""], ["proof (state)\nthis:\n  x \\<in> subst_set\n           (filter_trms C'\n             (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)))\n           \\<eta>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> subst_set\n                (filter_trms C'\n                  (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)))\n                \\<eta> \\<Longrightarrow>\n       x \\<in> dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)", "from this"], ["proof (chain)\npicking this:\n  x \\<in> subst_set\n           (filter_trms C'\n             (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)))\n           \\<eta>", "obtain x' where \"x = (subst x' \\<eta>)\" and \"x' \\<in> ?T'\""], ["proof (prove)\nusing this:\n  x \\<in> subst_set\n           (filter_trms C'\n             (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)))\n           \\<eta>\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>x = x' \\<lhd> \\<eta>;\n         x' \\<in> filter_trms C'\n                   (dom_trms (subst_cl D \\<theta>)\n                     (subst_set E \\<theta>))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = x' \\<lhd> \\<eta>\n  x' \\<in> filter_trms C'\n            (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> subst_set\n                (filter_trms C'\n                  (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)))\n                \\<eta> \\<Longrightarrow>\n       x \\<in> dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)", "from \\<open>x' \\<in> ?T'\\<close>"], ["proof (chain)\npicking this:\n  x' \\<in> filter_trms C'\n            (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>))", "have \"x' \\<in> ?E\""], ["proof (prove)\nusing this:\n  x' \\<in> filter_trms C'\n            (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>))\n\ngoal (1 subgoal):\n 1. x' \\<in> dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)", "using filter_trms_inclusion"], ["proof (prove)\nusing this:\n  x' \\<in> filter_trms C'\n            (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>))\n  filter_trms ?C ?E \\<subseteq> ?E\n\ngoal (1 subgoal):\n 1. x' \\<in> dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)", "by auto"], ["proof (state)\nthis:\n  x' \\<in> dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> subst_set\n                (filter_trms C'\n                  (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)))\n                \\<eta> \\<Longrightarrow>\n       x \\<in> dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)", "from \\<open>x' \\<in> ?E\\<close>"], ["proof (chain)\npicking this:\n  x' \\<in> dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)", "have \"x' \\<in> (subst_set E \\<theta>)\" \n      and \"dom_trm x' (subst_cl D \\<theta>)\""], ["proof (prove)\nusing this:\n  x' \\<in> dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)\n\ngoal (1 subgoal):\n 1. x' \\<in> subst_set E \\<theta> &&& dom_trm x' (subst_cl D \\<theta>)", "unfolding dom_trms_def"], ["proof (prove)\nusing this:\n  x' \\<in> {x \\<in> subst_set E \\<theta>. dom_trm x (subst_cl D \\<theta>)}\n\ngoal (1 subgoal):\n 1. x' \\<in> subst_set E \\<theta> &&& dom_trm x' (subst_cl D \\<theta>)", "by auto"], ["proof (state)\nthis:\n  x' \\<in> subst_set E \\<theta>\n  dom_trm x' (subst_cl D \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> subst_set\n                (filter_trms C'\n                  (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)))\n                \\<eta> \\<Longrightarrow>\n       x \\<in> dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)", "from \\<open>x' \\<in> (subst_set E \\<theta>)\\<close>"], ["proof (chain)\npicking this:\n  x' \\<in> subst_set E \\<theta>", "obtain y where \"y \\<in> E\"\n      and \"x' = (subst y \\<theta>)\""], ["proof (prove)\nusing this:\n  x' \\<in> subst_set E \\<theta>\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> E; x' = y \\<lhd> \\<theta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in> E\n  x' = y \\<lhd> \\<theta>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> subst_set\n                (filter_trms C'\n                  (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)))\n                \\<eta> \\<Longrightarrow>\n       x \\<in> dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)", "from \\<open>x' = (subst y \\<theta>)\\<close> and \\<open>dom_trm x' (subst_cl D \\<theta>)\\<close>"], ["proof (chain)\npicking this:\n  x' = y \\<lhd> \\<theta>\n  dom_trm x' (subst_cl D \\<theta>)", "have \"dom_trm (subst y \\<theta>) (subst_cl D \\<theta>)\""], ["proof (prove)\nusing this:\n  x' = y \\<lhd> \\<theta>\n  dom_trm x' (subst_cl D \\<theta>)\n\ngoal (1 subgoal):\n 1. dom_trm (y \\<lhd> \\<theta>) (subst_cl D \\<theta>)", "by auto"], ["proof (state)\nthis:\n  dom_trm (y \\<lhd> \\<theta>) (subst_cl D \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> subst_set\n                (filter_trms C'\n                  (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)))\n                \\<eta> \\<Longrightarrow>\n       x \\<in> dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)", "from this assms(2)"], ["proof (chain)\npicking this:\n  dom_trm (y \\<lhd> \\<theta>) (subst_cl D \\<theta>)\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>", "have \"dom_trm (subst y \\<sigma>) (subst_cl D \\<sigma>)\""], ["proof (prove)\nusing this:\n  dom_trm (y \\<lhd> \\<theta>) (subst_cl D \\<theta>)\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. dom_trm (y \\<lhd> \\<sigma>) (subst_cl D \\<sigma>)", "using lift_dom_trm"], ["proof (prove)\nusing this:\n  dom_trm (y \\<lhd> \\<theta>) (subst_cl D \\<theta>)\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  \\<lbrakk>dom_trm (?t \\<lhd> ?\\<theta>) (subst_cl ?C ?\\<theta>);\n   ?\\<sigma> \\<doteq> ?\\<theta> \\<lozenge> ?\\<eta>\\<rbrakk>\n  \\<Longrightarrow> dom_trm (?t \\<lhd> ?\\<sigma>) (subst_cl ?C ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. dom_trm (y \\<lhd> \\<sigma>) (subst_cl D \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  dom_trm (y \\<lhd> \\<sigma>) (subst_cl D \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> subst_set\n                (filter_trms C'\n                  (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)))\n                \\<eta> \\<Longrightarrow>\n       x \\<in> dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)", "from \\<open>y \\<in> E\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> E", "have \"(subst y \\<sigma>) \\<in> (subst_set E \\<sigma>)\""], ["proof (prove)\nusing this:\n  y \\<in> E\n\ngoal (1 subgoal):\n 1. y \\<lhd> \\<sigma> \\<in> subst_set E \\<sigma>", "by auto"], ["proof (state)\nthis:\n  y \\<lhd> \\<sigma> \\<in> subst_set E \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> subst_set\n                (filter_trms C'\n                  (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)))\n                \\<eta> \\<Longrightarrow>\n       x \\<in> dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)", "from this and \\<open>dom_trm (subst y \\<sigma>) (subst_cl D \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  y \\<lhd> \\<sigma> \\<in> subst_set E \\<sigma>\n  dom_trm (y \\<lhd> \\<sigma>) (subst_cl D \\<sigma>)", "have \"(subst y \\<sigma>) \\<in> ?E'\""], ["proof (prove)\nusing this:\n  y \\<lhd> \\<sigma> \\<in> subst_set E \\<sigma>\n  dom_trm (y \\<lhd> \\<sigma>) (subst_cl D \\<sigma>)\n\ngoal (1 subgoal):\n 1. y \\<lhd> \\<sigma>\n    \\<in> dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)", "unfolding dom_trms_def"], ["proof (prove)\nusing this:\n  y \\<lhd> \\<sigma> \\<in> subst_set E \\<sigma>\n  dom_trm (y \\<lhd> \\<sigma>) (subst_cl D \\<sigma>)\n\ngoal (1 subgoal):\n 1. y \\<lhd> \\<sigma>\n    \\<in> {x \\<in> subst_set E \\<sigma>. dom_trm x (subst_cl D \\<sigma>)}", "by auto"], ["proof (state)\nthis:\n  y \\<lhd> \\<sigma>\n  \\<in> dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> subst_set\n                (filter_trms C'\n                  (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)))\n                \\<eta> \\<Longrightarrow>\n       x \\<in> dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)", "from assms(2)"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>", "have \"(subst y \\<sigma>) = (subst y (\\<theta> \\<lozenge> \\<eta>))\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. y \\<lhd> \\<sigma> = y \\<lhd> \\<theta> \\<lozenge> \\<eta>", "by auto"], ["proof (state)\nthis:\n  y \\<lhd> \\<sigma> = y \\<lhd> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> subst_set\n                (filter_trms C'\n                  (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)))\n                \\<eta> \\<Longrightarrow>\n       x \\<in> dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)", "from this \\<open>x = (subst x' \\<eta>)\\<close> and \\<open>x' = (subst y \\<theta>)\\<close>"], ["proof (chain)\npicking this:\n  y \\<lhd> \\<sigma> = y \\<lhd> \\<theta> \\<lozenge> \\<eta>\n  x = x' \\<lhd> \\<eta>\n  x' = y \\<lhd> \\<theta>", "have \"x = (subst y \\<sigma>)\""], ["proof (prove)\nusing this:\n  y \\<lhd> \\<sigma> = y \\<lhd> \\<theta> \\<lozenge> \\<eta>\n  x = x' \\<lhd> \\<eta>\n  x' = y \\<lhd> \\<theta>\n\ngoal (1 subgoal):\n 1. x = y \\<lhd> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  x = y \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> subst_set\n                (filter_trms C'\n                  (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)))\n                \\<eta> \\<Longrightarrow>\n       x \\<in> dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)", "from this and \\<open>(subst y \\<sigma>) \\<in> ?E'\\<close>"], ["proof (chain)\npicking this:\n  x = y \\<lhd> \\<sigma>\n  y \\<lhd> \\<sigma>\n  \\<in> dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)", "show \"x \\<in> ?E'\""], ["proof (prove)\nusing this:\n  x = y \\<lhd> \\<sigma>\n  y \\<lhd> \\<sigma>\n  \\<in> dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)\n\ngoal (1 subgoal):\n 1. x \\<in> dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  x \\<in> dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst_set\n   (filter_trms C' (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)))\n   \\<eta>\n  \\<subseteq> dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>T'.\n       subst_set T' \\<eta> \\<subseteq> T \\<and>\n       T' =\n       get_trms C' (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>))\n        FirstOrder", "from this and \\<open>T = ?E'\\<close> \\<open>?T' = get_trms C' ?E FirstOrder\\<close>"], ["proof (chain)\npicking this:\n  subst_set\n   (filter_trms C' (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)))\n   \\<eta>\n  \\<subseteq> dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)\n  T = dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)\n  filter_trms C' (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)) =\n  get_trms C' (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>))\n   FirstOrder", "show ?thesis"], ["proof (prove)\nusing this:\n  subst_set\n   (filter_trms C' (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)))\n   \\<eta>\n  \\<subseteq> dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)\n  T = dom_trms (subst_cl D \\<sigma>) (subst_set E \\<sigma>)\n  filter_trms C' (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>)) =\n  get_trms C' (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>))\n   FirstOrder\n\ngoal (1 subgoal):\n 1. \\<exists>T'.\n       subst_set T' \\<eta> \\<subseteq> T \\<and>\n       T' =\n       get_trms C' (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>))\n        FirstOrder", "by auto"], ["proof (state)\nthis:\n  \\<exists>T'.\n     subst_set T' \\<eta> \\<subseteq> T \\<and>\n     T' =\n     get_trms C' (dom_trms (subst_cl D \\<theta>) (subst_set E \\<theta>))\n      FirstOrder\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We eventually deduce the following lemma, which allows one to transform ground derivations\ninto first-order derivations.\\<close>"], ["", "lemma lifting_lemma:\n  assumes \"derivable C P S \\<sigma> Ground C'\"\n  shows \"\\<exists> D \\<theta> \\<eta>. ((derivable D P S \\<theta> FirstOrder C') \\<and> (\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>) \\<and> (trms_subsumes D C \\<eta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>D \\<theta> \\<eta>.\n       derivable D P S \\<theta> FirstOrder C' \\<and>\n       \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<and>\n       trms_subsumes D C \\<eta>", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>D \\<theta> \\<eta>.\n       derivable D P S \\<theta> FirstOrder C' \\<and>\n       \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<and>\n       trms_subsumes D C \\<eta> \\<Longrightarrow>\n    False", "assume hyp: \"\\<not> (\\<exists> D \\<theta> \\<eta>. ((derivable D P S \\<theta> FirstOrder C') \\<and> (\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>) \n                \\<and> (trms_subsumes D C \\<eta>)))\""], ["proof (state)\nthis:\n  \\<nexists>D \\<theta> \\<eta>.\n     derivable D P S \\<theta> FirstOrder C' \\<and>\n     \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<and>\n     trms_subsumes D C \\<eta>\n\ngoal (1 subgoal):\n 1. \\<nexists>D \\<theta> \\<eta>.\n       derivable D P S \\<theta> FirstOrder C' \\<and>\n       \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<and>\n       trms_subsumes D C \\<eta> \\<Longrightarrow>\n    False", "from assms(1)"], ["proof (chain)\npicking this:\n  derivable C P S \\<sigma> Ground C'", "have \"P \\<subseteq> S\""], ["proof (prove)\nusing this:\n  derivable C P S \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. P \\<subseteq> S", "unfolding derivable_def"], ["proof (prove)\nusing this:\n  (\\<exists>P1 P2.\n      P1 \\<in> S \\<and>\n      P2 \\<in> S \\<and>\n      P = {P1, P2} \\<and> superposition P1 P2 C \\<sigma> Ground C') \\<or>\n  (\\<exists>P1.\n      P1 \\<in> S \\<and>\n      P = {P1} \\<and> factorization P1 C \\<sigma> Ground C') \\<or>\n  (\\<exists>P1.\n      P1 \\<in> S \\<and> P = {P1} \\<and> reflexion P1 C \\<sigma> Ground C')\n\ngoal (1 subgoal):\n 1. P \\<subseteq> S", "by auto"], ["proof (state)\nthis:\n  P \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<nexists>D \\<theta> \\<eta>.\n       derivable D P S \\<theta> FirstOrder C' \\<and>\n       \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<and>\n       trms_subsumes D C \\<eta> \\<Longrightarrow>\n    False", "have not_sup: \"\\<not> (\\<exists>P1 P2. (P = { P1, P2 } \\<and> superposition P1 P2 C \\<sigma> Ground C'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>P1 P2.\n       P = {P1, P2} \\<and> superposition P1 P2 C \\<sigma> Ground C'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "assume \"(\\<exists>P1 P2. (P = { P1, P2 } \\<and> superposition P1 P2 C \\<sigma> Ground C'))\""], ["proof (state)\nthis:\n  \\<exists>P1 P2.\n     P = {P1, P2} \\<and> superposition P1 P2 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>P1 P2.\n     P = {P1, P2} \\<and> superposition P1 P2 C \\<sigma> Ground C'", "obtain P1 P2 where \"P = { P1, P2 }\" \"superposition P1 P2 C \\<sigma> Ground C'\""], ["proof (prove)\nusing this:\n  \\<exists>P1 P2.\n     P = {P1, P2} \\<and> superposition P1 P2 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. (\\<And>P1 P2.\n        \\<lbrakk>P = {P1, P2};\n         superposition P1 P2 C \\<sigma> Ground C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P = {P1, P2}\n  superposition P1 P2 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  P = {P1, P2}\n  superposition P1 P2 C \\<sigma> Ground C'", "obtain L t s u v M p Cl_P1 Cl_P2 Cl_C polarity t' u' L' trms_C\n      where \"L \\<in> Cl_P1\" \"(M \\<in> Cl_P2)\" \"(eligible_literal L P1 \\<sigma>)\" \"(eligible_literal M P2 \\<sigma>)\"\n      \"(variable_disjoint P1 P2)\"\n      \"(Cl_P1 = (cl_ecl P1))\" \"(Cl_P2 = (cl_ecl P2))\" \n      \"(\\<not> is_a_variable u')\"\n      \"(allowed_redex u' P1 \\<sigma>)\"\n      \"(C = (Ecl Cl_C trms_C))\" \n      \"(orient_lit_inst M u v pos \\<sigma>)\" \n      \"(orient_lit_inst L t s polarity \\<sigma>)\" \n      \"((subst u \\<sigma>) \\<noteq> (subst v \\<sigma>))\"\n      \"(subterm t p u')\"\n      \"(ck_unifier u' u \\<sigma> Ground)\"\n      \"(replace_subterm t p v t')\" \n      \"(L' = mk_lit polarity (Eq t' s))\"\n      \"(trms_C = get_trms Cl_C (dom_trms Cl_C (subst_set \n        ((trms_ecl P1) \\<union> (trms_ecl P2) \\<union> \n          { r. \\<exists> q. (q,p) \\<in> (pos_ord P1 t) \\<and> (subterm t q r) }) \\<sigma>)) Ground)\" \n      \"(Cl_C = (subst_cl ((Cl_P1 - { L }) \\<union> ((Cl_P2 - { M }) \\<union> { L' } )) \\<sigma>))\"\n      \"(C' = (Cl_P1 - { L }) \\<union> ((Cl_P2 - { M }) \\<union> { L' } ))\""], ["proof (prove)\nusing this:\n  P = {P1, P2}\n  superposition P1 P2 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. (\\<And>L Cl_P1 M Cl_P2 u' Cl_C trms_C u v t s polarity p t' L'.\n        \\<lbrakk>L \\<in> Cl_P1; M \\<in> Cl_P2;\n         eligible_literal L P1 \\<sigma>; eligible_literal M P2 \\<sigma>;\n         variable_disjoint P1 P2; Cl_P1 = cl_ecl P1; Cl_P2 = cl_ecl P2;\n         \\<not> is_a_variable u'; allowed_redex u' P1 \\<sigma>;\n         C = Ecl Cl_C trms_C; orient_lit_inst M u v pos \\<sigma>;\n         orient_lit_inst L t s polarity \\<sigma>;\n         u \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>; subterm t p u';\n         ck_unifier u' u \\<sigma> Ground; replace_subterm t p v t';\n         L' = mk_lit polarity (Eq t' s);\n         trms_C =\n         get_trms Cl_C\n          (dom_trms Cl_C\n            (subst_set\n              (trms_ecl P1 \\<union> trms_ecl P2 \\<union>\n               {r. \\<exists>q.\n                      (q, p) \\<in> pos_ord P1 t \\<and> subterm t q r})\n              \\<sigma>))\n          Ground;\n         Cl_C =\n         subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'}))\n          \\<sigma>;\n         C' = Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding superposition_def get_trms_def"], ["proof (prove)\nusing this:\n  P = {P1, P2}\n  \\<exists>L t s u v M p Cl_P1 Cl_P2 Cl_C polarity t' u' L' trms_C.\n     L \\<in> Cl_P1 \\<and>\n     M \\<in> Cl_P2 \\<and>\n     eligible_literal L P1 \\<sigma> \\<and>\n     eligible_literal M P2 \\<sigma> \\<and>\n     variable_disjoint P1 P2 \\<and>\n     Cl_P1 = cl_ecl P1 \\<and>\n     Cl_P2 = cl_ecl P2 \\<and>\n     \\<not> is_a_variable u' \\<and>\n     allowed_redex u' P1 \\<sigma> \\<and>\n     trms_C =\n     (if Ground = FirstOrder\n      then filter_trms Cl_C\n            (dom_trms Cl_C\n              (subst_set\n                (trms_ecl P1 \\<union> trms_ecl P2 \\<union>\n                 {r. \\<exists>q.\n                        (q, p) \\<in> pos_ord P1 t \\<and> subterm t q r})\n                \\<sigma>))\n      else dom_trms Cl_C\n            (subst_set\n              (trms_ecl P1 \\<union> trms_ecl P2 \\<union>\n               {r. \\<exists>q.\n                      (q, p) \\<in> pos_ord P1 t \\<and> subterm t q r})\n              \\<sigma>)) \\<and>\n     C = Ecl Cl_C trms_C \\<and>\n     orient_lit_inst M u v pos \\<sigma> \\<and>\n     orient_lit_inst L t s polarity \\<sigma> \\<and>\n     u \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma> \\<and>\n     subterm t p u' \\<and>\n     ck_unifier u' u \\<sigma> Ground \\<and>\n     replace_subterm t p v t' \\<and>\n     (Ground = FirstOrder \\<or>\n      (subst_lit M \\<sigma>, subst_lit L \\<sigma>) \\<in> lit_ord) \\<and>\n     (Ground = FirstOrder \\<or>\n      strictly_maximal_literal P2 M \\<sigma>) \\<and>\n     L' = mk_lit polarity (Eq t' s) \\<and>\n     Cl_C = subst_cl C' \\<sigma> \\<and>\n     C' = Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})\n\ngoal (1 subgoal):\n 1. (\\<And>L Cl_P1 M Cl_P2 u' Cl_C trms_C u v t s polarity p t' L'.\n        \\<lbrakk>L \\<in> Cl_P1; M \\<in> Cl_P2;\n         eligible_literal L P1 \\<sigma>; eligible_literal M P2 \\<sigma>;\n         variable_disjoint P1 P2; Cl_P1 = cl_ecl P1; Cl_P2 = cl_ecl P2;\n         \\<not> is_a_variable u'; allowed_redex u' P1 \\<sigma>;\n         C = Ecl Cl_C trms_C; orient_lit_inst M u v pos \\<sigma>;\n         orient_lit_inst L t s polarity \\<sigma>;\n         u \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>; subterm t p u';\n         ck_unifier u' u \\<sigma> Ground; replace_subterm t p v t';\n         L' = mk_lit polarity (Eq t' s);\n         trms_C =\n         (if Ground = FirstOrder\n          then filter_trms Cl_C\n                (dom_trms Cl_C\n                  (subst_set\n                    (trms_ecl P1 \\<union> trms_ecl P2 \\<union>\n                     {r. \\<exists>q.\n                            (q, p) \\<in> pos_ord P1 t \\<and> subterm t q r})\n                    \\<sigma>))\n          else dom_trms Cl_C\n                (subst_set\n                  (trms_ecl P1 \\<union> trms_ecl P2 \\<union>\n                   {r. \\<exists>q.\n                          (q, p) \\<in> pos_ord P1 t \\<and> subterm t q r})\n                  \\<sigma>));\n         Cl_C =\n         subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'}))\n          \\<sigma>;\n         C' = Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L \\<in> Cl_P1\n  M \\<in> Cl_P2\n  eligible_literal L P1 \\<sigma>\n  eligible_literal M P2 \\<sigma>\n  variable_disjoint P1 P2\n  Cl_P1 = cl_ecl P1\n  Cl_P2 = cl_ecl P2\n  \\<not> is_a_variable u'\n  allowed_redex u' P1 \\<sigma>\n  C = Ecl Cl_C trms_C\n  orient_lit_inst M u v pos \\<sigma>\n  orient_lit_inst L t s polarity \\<sigma>\n  u \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>\n  subterm t p u'\n  ck_unifier u' u \\<sigma> Ground\n  replace_subterm t p v t'\n  L' = mk_lit polarity (Eq t' s)\n  trms_C =\n  get_trms Cl_C\n   (dom_trms Cl_C\n     (subst_set\n       (trms_ecl P1 \\<union> trms_ecl P2 \\<union>\n        {r. \\<exists>q. (q, p) \\<in> pos_ord P1 t \\<and> subterm t q r})\n       \\<sigma>))\n   Ground\n  Cl_C =\n  subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<sigma>\n  C' = Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>(ck_unifier u' u \\<sigma> Ground)\\<close>"], ["proof (chain)\npicking this:\n  ck_unifier u' u \\<sigma> Ground", "have \" Unifier \\<sigma> u' u\""], ["proof (prove)\nusing this:\n  ck_unifier u' u \\<sigma> Ground\n\ngoal (1 subgoal):\n 1. Unifier \\<sigma> u' u", "unfolding ck_unifier_def"], ["proof (prove)\nusing this:\n  if Ground = FirstOrder then MGU \\<sigma> u' u else Unifier \\<sigma> u' u\n\ngoal (1 subgoal):\n 1. Unifier \\<sigma> u' u", "by auto"], ["proof (state)\nthis:\n  Unifier \\<sigma> u' u\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  Unifier \\<sigma> u' u", "have \"(subst u' \\<sigma>) = (subst u \\<sigma>)\""], ["proof (prove)\nusing this:\n  Unifier \\<sigma> u' u\n\ngoal (1 subgoal):\n 1. u' \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>", "unfolding Unifier_def"], ["proof (prove)\nusing this:\n  u' \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. u' \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  u' \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  u' \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>", "have \"unify u' u \\<noteq> None\""], ["proof (prove)\nusing this:\n  u' \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. unify u' u \\<noteq> None", "using MGU_exists"], ["proof (prove)\nusing this:\n  u' \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n  \\<forall>\\<sigma>.\n     ?t \\<lhd> \\<sigma> = ?s \\<lhd> \\<sigma> \\<longrightarrow>\n     unify ?t ?s \\<noteq> None\n\ngoal (1 subgoal):\n 1. unify u' u \\<noteq> None", "by auto"], ["proof (state)\nthis:\n  unify u' u \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  unify u' u \\<noteq> None", "obtain \\<theta> where \"unify u' u = Some \\<theta>\""], ["proof (prove)\nusing this:\n  unify u' u \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>\\<theta>.\n        unify u' u = Some \\<theta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  unify u' u = Some \\<theta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  unify u' u = Some \\<theta>", "have \"MGU \\<theta> u' u\""], ["proof (prove)\nusing this:\n  unify u' u = Some \\<theta>\n\ngoal (1 subgoal):\n 1. MGU \\<theta> u' u", "using unify_computes_MGU"], ["proof (prove)\nusing this:\n  unify u' u = Some \\<theta>\n  unify ?M ?N = Some ?\\<sigma> \\<Longrightarrow> MGU ?\\<sigma> ?M ?N\n\ngoal (1 subgoal):\n 1. MGU \\<theta> u' u", "by auto"], ["proof (state)\nthis:\n  MGU \\<theta> u' u\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this and \\<open>Unifier \\<sigma> u' u\\<close>"], ["proof (chain)\npicking this:\n  MGU \\<theta> u' u\n  Unifier \\<sigma> u' u", "obtain \\<eta> where \"\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\""], ["proof (prove)\nusing this:\n  MGU \\<theta> u' u\n  Unifier \\<sigma> u' u\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>.\n        \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding MGU_def"], ["proof (prove)\nusing this:\n  Unifier \\<theta> u' u \\<and>\n  (\\<forall>\\<theta>'.\n      Unifier \\<theta>' u' u \\<longrightarrow>\n      (\\<exists>\\<gamma>. \\<theta>' \\<doteq> \\<theta> \\<lozenge> \\<gamma>))\n  Unifier \\<sigma> u' u\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>.\n        \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close> and \\<open>(eligible_literal L P1 \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  eligible_literal L P1 \\<sigma>", "have \"eligible_literal L P1 \\<theta>\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  eligible_literal L P1 \\<sigma>\n\ngoal (1 subgoal):\n 1. eligible_literal L P1 \\<theta>", "using lift_eligible_literal"], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  eligible_literal L P1 \\<sigma>\n  \\<lbrakk>eligible_literal ?L ?C ?\\<sigma>;\n   ?\\<sigma> \\<doteq> ?\\<theta> \\<lozenge> ?\\<eta>\\<rbrakk>\n  \\<Longrightarrow> eligible_literal ?L ?C ?\\<theta>\n\ngoal (1 subgoal):\n 1. eligible_literal L P1 \\<theta>", "by auto"], ["proof (state)\nthis:\n  eligible_literal L P1 \\<theta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close> and \\<open>(eligible_literal M P2 \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  eligible_literal M P2 \\<sigma>", "have \"eligible_literal M P2 \\<theta>\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  eligible_literal M P2 \\<sigma>\n\ngoal (1 subgoal):\n 1. eligible_literal M P2 \\<theta>", "using lift_eligible_literal"], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  eligible_literal M P2 \\<sigma>\n  \\<lbrakk>eligible_literal ?L ?C ?\\<sigma>;\n   ?\\<sigma> \\<doteq> ?\\<theta> \\<lozenge> ?\\<eta>\\<rbrakk>\n  \\<Longrightarrow> eligible_literal ?L ?C ?\\<theta>\n\ngoal (1 subgoal):\n 1. eligible_literal M P2 \\<theta>", "by auto"], ["proof (state)\nthis:\n  eligible_literal M P2 \\<theta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>MGU \\<theta> u' u\\<close>"], ["proof (chain)\npicking this:\n  MGU \\<theta> u' u", "have \"ck_unifier u' u \\<theta> FirstOrder\""], ["proof (prove)\nusing this:\n  MGU \\<theta> u' u\n\ngoal (1 subgoal):\n 1. ck_unifier u' u \\<theta> FirstOrder", "unfolding ck_unifier_def"], ["proof (prove)\nusing this:\n  MGU \\<theta> u' u\n\ngoal (1 subgoal):\n 1. if FirstOrder = FirstOrder then MGU \\<theta> u' u\n    else Unifier \\<theta> u' u", "by auto"], ["proof (state)\nthis:\n  ck_unifier u' u \\<theta> FirstOrder\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>", "have \"(subst u \\<sigma>) = (subst (subst u \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. u \\<lhd> \\<sigma> = u \\<lhd> \\<theta> \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  u \\<lhd> \\<sigma> = u \\<lhd> \\<theta> \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>", "have \"(subst v \\<sigma>) = (subst (subst v \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. v \\<lhd> \\<sigma> = v \\<lhd> \\<theta> \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  v \\<lhd> \\<sigma> = v \\<lhd> \\<theta> \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>((subst u \\<sigma>) \\<noteq> (subst v \\<sigma>))\\<close> \n      \\<open>(subst u \\<sigma>) = (subst (subst u \\<theta>) \\<eta>)\\<close> \n      \\<open>(subst v \\<sigma>) = (subst (subst v \\<theta>) \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  u \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>\n  u \\<lhd> \\<sigma> = u \\<lhd> \\<theta> \\<lhd> \\<eta>\n  v \\<lhd> \\<sigma> = v \\<lhd> \\<theta> \\<lhd> \\<eta>", "have \"(subst (subst u \\<theta>) \\<eta>) \\<noteq> (subst (subst v \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  u \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>\n  u \\<lhd> \\<sigma> = u \\<lhd> \\<theta> \\<lhd> \\<eta>\n  v \\<lhd> \\<sigma> = v \\<lhd> \\<theta> \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. u \\<lhd> \\<theta> \\<lhd> \\<eta> \\<noteq> v \\<lhd> \\<theta> \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  u \\<lhd> \\<theta> \\<lhd> \\<eta> \\<noteq> v \\<lhd> \\<theta> \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  u \\<lhd> \\<theta> \\<lhd> \\<eta> \\<noteq> v \\<lhd> \\<theta> \\<lhd> \\<eta>", "have \"(subst u \\<theta>) \\<noteq> (subst v \\<theta>)\""], ["proof (prove)\nusing this:\n  u \\<lhd> \\<theta> \\<lhd> \\<eta> \\<noteq> v \\<lhd> \\<theta> \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. u \\<lhd> \\<theta> \\<noteq> v \\<lhd> \\<theta>", "by auto"], ["proof (state)\nthis:\n  u \\<lhd> \\<theta> \\<noteq> v \\<lhd> \\<theta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close> \\<open>(allowed_redex u' P1 \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  allowed_redex u' P1 \\<sigma>", "have \"(allowed_redex u' P1 \\<theta>)\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  allowed_redex u' P1 \\<sigma>\n\ngoal (1 subgoal):\n 1. allowed_redex u' P1 \\<theta>", "using lift_allowed_redex [of \\<sigma> \\<theta> \\<eta> ]"], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  allowed_redex u' P1 \\<sigma>\n  \\<lbrakk>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>;\n   allowed_redex ?u ?C \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> allowed_redex ?u ?C \\<theta>\n\ngoal (1 subgoal):\n 1. allowed_redex u' P1 \\<theta>", "by auto"], ["proof (state)\nthis:\n  allowed_redex u' P1 \\<theta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close> \\<open>orient_lit_inst M u v pos \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  orient_lit_inst M u v pos \\<sigma>", "have \"orient_lit_inst M u v pos \\<theta>\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  orient_lit_inst M u v pos \\<sigma>\n\ngoal (1 subgoal):\n 1. orient_lit_inst M u v pos \\<theta>", "using lift_orient_lit_inst"], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  orient_lit_inst M u v pos \\<sigma>\n  \\<lbrakk>orient_lit_inst ?L ?t ?s ?polarity ?\\<theta>;\n   ?\\<theta> \\<doteq> ?\\<sigma> \\<lozenge> ?\\<eta>\\<rbrakk>\n  \\<Longrightarrow> orient_lit_inst ?L ?t ?s ?polarity ?\\<sigma>\n\ngoal (1 subgoal):\n 1. orient_lit_inst M u v pos \\<theta>", "by auto"], ["proof (state)\nthis:\n  orient_lit_inst M u v pos \\<theta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close> \\<open>orient_lit_inst L t s polarity \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  orient_lit_inst L t s polarity \\<sigma>", "have \"orient_lit_inst L t s polarity \\<theta>\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  orient_lit_inst L t s polarity \\<sigma>\n\ngoal (1 subgoal):\n 1. orient_lit_inst L t s polarity \\<theta>", "using lift_orient_lit_inst"], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  orient_lit_inst L t s polarity \\<sigma>\n  \\<lbrakk>orient_lit_inst ?L ?t ?s ?polarity ?\\<theta>;\n   ?\\<theta> \\<doteq> ?\\<sigma> \\<lozenge> ?\\<eta>\\<rbrakk>\n  \\<Longrightarrow> orient_lit_inst ?L ?t ?s ?polarity ?\\<sigma>\n\ngoal (1 subgoal):\n 1. orient_lit_inst L t s polarity \\<theta>", "by auto"], ["proof (state)\nthis:\n  orient_lit_inst L t s polarity \\<theta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>(Cl_C = (subst_cl ((Cl_P1 - { L }) \\<union> ((Cl_P2 - { M }) \\<union> { L' } )) \\<sigma>))\\<close> \n      and \\<open>C' = (Cl_P1 - { L }) \\<union> ((Cl_P2 - { M }) \\<union> { L' } )\\<close>"], ["proof (chain)\npicking this:\n  Cl_C =\n  subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<sigma>\n  C' = Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})", "have \"(Cl_C = (subst_cl C' \\<sigma>))\""], ["proof (prove)\nusing this:\n  Cl_C =\n  subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<sigma>\n  C' = Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})\n\ngoal (1 subgoal):\n 1. Cl_C = subst_cl C' \\<sigma>", "by auto"], ["proof (state)\nthis:\n  Cl_C = subst_cl C' \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "obtain E where \"E = ((trms_ecl P1) \\<union> (trms_ecl P2) \\<union> \n          { r. \\<exists> q. (q,p) \\<in> (pos_ord P1 t) \\<and> (subterm t q r) })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>E.\n        E =\n        trms_ecl P1 \\<union> trms_ecl P2 \\<union>\n        {r. \\<exists>q.\n               (q, p) \\<in> pos_ord P1 t \\<and>\n               subterm t q r} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  E =\n  trms_ecl P1 \\<union> trms_ecl P2 \\<union>\n  {r. \\<exists>q. (q, p) \\<in> pos_ord P1 t \\<and> subterm t q r}\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this and \\<open>(Cl_C = (subst_cl C' \\<sigma>))\\<close> \n      \\<open>trms_C = (get_trms  Cl_C (dom_trms Cl_C (subst_set \n        ((trms_ecl P1) \\<union> (trms_ecl P2) \\<union> \n          { r. \\<exists> q. (q,p) \\<in> (pos_ord P1 t) \\<and> (subterm t q r) }) \\<sigma>)) Ground)\\<close>"], ["proof (chain)\npicking this:\n  E =\n  trms_ecl P1 \\<union> trms_ecl P2 \\<union>\n  {r. \\<exists>q. (q, p) \\<in> pos_ord P1 t \\<and> subterm t q r}\n  Cl_C = subst_cl C' \\<sigma>\n  trms_C =\n  get_trms Cl_C\n   (dom_trms Cl_C\n     (subst_set\n       (trms_ecl P1 \\<union> trms_ecl P2 \\<union>\n        {r. \\<exists>q. (q, p) \\<in> pos_ord P1 t \\<and> subterm t q r})\n       \\<sigma>))\n   Ground", "have \"trms_C = (get_trms Cl_C \n        (dom_trms (subst_cl C' \\<sigma>) (subst_set \n        E  \\<sigma>)) Ground)\""], ["proof (prove)\nusing this:\n  E =\n  trms_ecl P1 \\<union> trms_ecl P2 \\<union>\n  {r. \\<exists>q. (q, p) \\<in> pos_ord P1 t \\<and> subterm t q r}\n  Cl_C = subst_cl C' \\<sigma>\n  trms_C =\n  get_trms Cl_C\n   (dom_trms Cl_C\n     (subst_set\n       (trms_ecl P1 \\<union> trms_ecl P2 \\<union>\n        {r. \\<exists>q. (q, p) \\<in> pos_ord P1 t \\<and> subterm t q r})\n       \\<sigma>))\n   Ground\n\ngoal (1 subgoal):\n 1. trms_C =\n    get_trms Cl_C (dom_trms (subst_cl C' \\<sigma>) (subst_set E \\<sigma>))\n     Ground", "by auto"], ["proof (state)\nthis:\n  trms_C =\n  get_trms Cl_C (dom_trms (subst_cl C' \\<sigma>) (subst_set E \\<sigma>))\n   Ground\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "let ?Cl_C' = \"(subst_cl C' \\<theta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from  \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close> \\<open>trms_C = (get_trms Cl_C \n        (dom_trms (subst_cl C' \\<sigma>) (subst_set \n        E  \\<sigma>)) Ground)\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  trms_C =\n  get_trms Cl_C (dom_trms (subst_cl C' \\<sigma>) (subst_set E \\<sigma>))\n   Ground", "obtain \"\\<exists>T'. ( (subst_set T' \\<eta>) \\<subseteq> trms_C \\<and> T' = get_trms ?Cl_C' \n    (dom_trms (subst_cl C' \\<theta>) (subst_set E \\<theta>)) FirstOrder)\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  trms_C =\n  get_trms Cl_C (dom_trms (subst_cl C' \\<sigma>) (subst_set E \\<sigma>))\n   Ground\n\ngoal (1 subgoal):\n 1. (\\<exists>T'.\n        subst_set T' \\<eta> \\<subseteq> trms_C \\<and>\n        T' =\n        get_trms (subst_cl C' \\<theta>)\n         (dom_trms (subst_cl C' \\<theta>) (subst_set E \\<theta>))\n         FirstOrder \\<Longrightarrow>\n     thesis) \\<Longrightarrow>\n    thesis", "using lift_irreducible_terms"], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  trms_C =\n  get_trms Cl_C (dom_trms (subst_cl C' \\<sigma>) (subst_set E \\<sigma>))\n   Ground\n  \\<lbrakk>?T =\n           get_trms ?C\n            (dom_trms (subst_cl ?D ?\\<sigma>) (subst_set ?E ?\\<sigma>))\n            Ground;\n   ?\\<sigma> \\<doteq> ?\\<theta> \\<lozenge> ?\\<eta>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>T'.\n                       subst_set T' ?\\<eta> \\<subseteq> ?T \\<and>\n                       T' =\n                       get_trms ?C'\n                        (dom_trms (subst_cl ?D ?\\<theta>)\n                          (subst_set ?E ?\\<theta>))\n                        FirstOrder\n\ngoal (1 subgoal):\n 1. (\\<exists>T'.\n        subst_set T' \\<eta> \\<subseteq> trms_C \\<and>\n        T' =\n        get_trms (subst_cl C' \\<theta>)\n         (dom_trms (subst_cl C' \\<theta>) (subst_set E \\<theta>))\n         FirstOrder \\<Longrightarrow>\n     thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<exists>T'.\n     subst_set T' \\<eta> \\<subseteq> trms_C \\<and>\n     T' =\n     get_trms (subst_cl C' \\<theta>)\n      (dom_trms (subst_cl C' \\<theta>) (subst_set E \\<theta>)) FirstOrder\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<exists>T'.\n     subst_set T' \\<eta> \\<subseteq> trms_C \\<and>\n     T' =\n     get_trms (subst_cl C' \\<theta>)\n      (dom_trms (subst_cl C' \\<theta>) (subst_set E \\<theta>)) FirstOrder", "obtain T' where \"(subst_set T' \\<eta>) \\<subseteq> trms_C\" \n      and \"T' = get_trms ?Cl_C' \n    (dom_trms (subst_cl C' \\<theta>) (subst_set E \\<theta>)) FirstOrder\""], ["proof (prove)\nusing this:\n  \\<exists>T'.\n     subst_set T' \\<eta> \\<subseteq> trms_C \\<and>\n     T' =\n     get_trms (subst_cl C' \\<theta>)\n      (dom_trms (subst_cl C' \\<theta>) (subst_set E \\<theta>)) FirstOrder\n\ngoal (1 subgoal):\n 1. (\\<And>T'.\n        \\<lbrakk>subst_set T' \\<eta> \\<subseteq> trms_C;\n         T' =\n         get_trms (subst_cl C' \\<theta>)\n          (dom_trms (subst_cl C' \\<theta>) (subst_set E \\<theta>))\n          FirstOrder\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  subst_set T' \\<eta> \\<subseteq> trms_C\n  T' =\n  get_trms (subst_cl C' \\<theta>)\n   (dom_trms (subst_cl C' \\<theta>) (subst_set E \\<theta>)) FirstOrder\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "obtain C_fo where \"C_fo = (Ecl ?Cl_C' T')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C_fo.\n        C_fo = Ecl (subst_cl C' \\<theta>) T' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C_fo = Ecl (subst_cl C' \\<theta>) T'\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>C' = (Cl_P1 - { L }) \\<union> ((Cl_P2 - { M }) \\<union> { L' } )\\<close>"], ["proof (chain)\npicking this:\n  C' = Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})", "have \"(?Cl_C' = (subst_cl ((Cl_P1 - { L }) \\<union> ((Cl_P2 - { M }) \\<union> { L' } )) \\<theta>))\""], ["proof (prove)\nusing this:\n  C' = Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})\n\ngoal (1 subgoal):\n 1. subst_cl C' \\<theta> =\n    subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<theta>", "by auto"], ["proof (state)\nthis:\n  subst_cl C' \\<theta> =\n  subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<theta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>L \\<in> Cl_P1\\<close> \\<open>(M \\<in> Cl_P2)\\<close> \\<open>(eligible_literal L P1 \\<theta>)\\<close> \\<open>(eligible_literal M P2 \\<theta>)\\<close>\n      \\<open>(variable_disjoint P1 P2)\\<close>\n      \\<open>(Cl_P1 = (cl_ecl P1))\\<close> \\<open>(Cl_P2 = (cl_ecl P2))\\<close> \n      \\<open>(\\<not> is_a_variable u')\\<close>\n      \\<open>(allowed_redex u' P1 \\<theta>)\\<close>\n      \\<open>(C_fo = (Ecl ?Cl_C' T'))\\<close> \n      \\<open>(orient_lit_inst M u v pos \\<theta>)\\<close> \n      \\<open>(orient_lit_inst L t s polarity \\<theta>)\\<close> \n      \\<open>((subst u \\<theta>) \\<noteq> (subst v \\<theta>))\\<close>\n      \\<open>(subterm t p u')\\<close>\n      \\<open>(ck_unifier u' u \\<theta> FirstOrder)\\<close>\n      \\<open>(replace_subterm t p v t')\\<close> \n      \\<open>(L' = mk_lit polarity (Eq t' s))\\<close>\n      \\<open>T' = (get_trms ?Cl_C' (dom_trms (subst_cl C' \\<theta>) (subst_set E \\<theta>)) FirstOrder)\\<close>\n      \\<open>(?Cl_C' = (subst_cl ((Cl_P1 - { L }) \\<union> ((Cl_P2 - { M }) \\<union> { L' } )) \\<theta>))\\<close>\n      \\<open>(C' = (Cl_P1 - { L }) \\<union> ((Cl_P2 - { M }) \\<union> { L' } ))\\<close> \n      \\<open>E = ((trms_ecl P1) \\<union> (trms_ecl P2) \\<union> \n          { r. \\<exists> q. (q,p) \\<in> (pos_ord P1 t) \\<and> (subterm t q r) })\\<close>"], ["proof (chain)\npicking this:\n  L \\<in> Cl_P1\n  M \\<in> Cl_P2\n  eligible_literal L P1 \\<theta>\n  eligible_literal M P2 \\<theta>\n  variable_disjoint P1 P2\n  Cl_P1 = cl_ecl P1\n  Cl_P2 = cl_ecl P2\n  \\<not> is_a_variable u'\n  allowed_redex u' P1 \\<theta>\n  C_fo = Ecl (subst_cl C' \\<theta>) T'\n  orient_lit_inst M u v pos \\<theta>\n  orient_lit_inst L t s polarity \\<theta>\n  u \\<lhd> \\<theta> \\<noteq> v \\<lhd> \\<theta>\n  subterm t p u'\n  ck_unifier u' u \\<theta> FirstOrder\n  replace_subterm t p v t'\n  L' = mk_lit polarity (Eq t' s)\n  T' =\n  get_trms (subst_cl C' \\<theta>)\n   (dom_trms (subst_cl C' \\<theta>) (subst_set E \\<theta>)) FirstOrder\n  subst_cl C' \\<theta> =\n  subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<theta>\n  C' = Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})\n  E =\n  trms_ecl P1 \\<union> trms_ecl P2 \\<union>\n  {r. \\<exists>q. (q, p) \\<in> pos_ord P1 t \\<and> subterm t q r}", "have \"superposition P1 P2 C_fo \\<theta> FirstOrder C'\""], ["proof (prove)\nusing this:\n  L \\<in> Cl_P1\n  M \\<in> Cl_P2\n  eligible_literal L P1 \\<theta>\n  eligible_literal M P2 \\<theta>\n  variable_disjoint P1 P2\n  Cl_P1 = cl_ecl P1\n  Cl_P2 = cl_ecl P2\n  \\<not> is_a_variable u'\n  allowed_redex u' P1 \\<theta>\n  C_fo = Ecl (subst_cl C' \\<theta>) T'\n  orient_lit_inst M u v pos \\<theta>\n  orient_lit_inst L t s polarity \\<theta>\n  u \\<lhd> \\<theta> \\<noteq> v \\<lhd> \\<theta>\n  subterm t p u'\n  ck_unifier u' u \\<theta> FirstOrder\n  replace_subterm t p v t'\n  L' = mk_lit polarity (Eq t' s)\n  T' =\n  get_trms (subst_cl C' \\<theta>)\n   (dom_trms (subst_cl C' \\<theta>) (subst_set E \\<theta>)) FirstOrder\n  subst_cl C' \\<theta> =\n  subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<theta>\n  C' = Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})\n  E =\n  trms_ecl P1 \\<union> trms_ecl P2 \\<union>\n  {r. \\<exists>q. (q, p) \\<in> pos_ord P1 t \\<and> subterm t q r}\n\ngoal (1 subgoal):\n 1. superposition P1 P2 C_fo \\<theta> FirstOrder C'", "unfolding superposition_def"], ["proof (prove)\nusing this:\n  L \\<in> Cl_P1\n  M \\<in> Cl_P2\n  eligible_literal L P1 \\<theta>\n  eligible_literal M P2 \\<theta>\n  variable_disjoint P1 P2\n  Cl_P1 = cl_ecl P1\n  Cl_P2 = cl_ecl P2\n  \\<not> is_a_variable u'\n  allowed_redex u' P1 \\<theta>\n  C_fo = Ecl (subst_cl C' \\<theta>) T'\n  orient_lit_inst M u v pos \\<theta>\n  orient_lit_inst L t s polarity \\<theta>\n  u \\<lhd> \\<theta> \\<noteq> v \\<lhd> \\<theta>\n  subterm t p u'\n  ck_unifier u' u \\<theta> FirstOrder\n  replace_subterm t p v t'\n  L' = mk_lit polarity (Eq t' s)\n  T' =\n  get_trms (subst_cl C' \\<theta>)\n   (dom_trms (subst_cl C' \\<theta>) (subst_set E \\<theta>)) FirstOrder\n  subst_cl C' \\<theta> =\n  subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<theta>\n  C' = Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})\n  E =\n  trms_ecl P1 \\<union> trms_ecl P2 \\<union>\n  {r. \\<exists>q. (q, p) \\<in> pos_ord P1 t \\<and> subterm t q r}\n\ngoal (1 subgoal):\n 1. \\<exists>L t s u v M p Cl_P1 Cl_P2 Cl_C polarity t' u' L' trms_C.\n       L \\<in> Cl_P1 \\<and>\n       M \\<in> Cl_P2 \\<and>\n       eligible_literal L P1 \\<theta> \\<and>\n       eligible_literal M P2 \\<theta> \\<and>\n       variable_disjoint P1 P2 \\<and>\n       Cl_P1 = cl_ecl P1 \\<and>\n       Cl_P2 = cl_ecl P2 \\<and>\n       \\<not> is_a_variable u' \\<and>\n       allowed_redex u' P1 \\<theta> \\<and>\n       trms_C =\n       get_trms Cl_C\n        (dom_trms Cl_C\n          (subst_set\n            (trms_ecl P1 \\<union> trms_ecl P2 \\<union>\n             {r. \\<exists>q.\n                    (q, p) \\<in> pos_ord P1 t \\<and> subterm t q r})\n            \\<theta>))\n        FirstOrder \\<and>\n       C_fo = Ecl Cl_C trms_C \\<and>\n       orient_lit_inst M u v pos \\<theta> \\<and>\n       orient_lit_inst L t s polarity \\<theta> \\<and>\n       u \\<lhd> \\<theta> \\<noteq> v \\<lhd> \\<theta> \\<and>\n       subterm t p u' \\<and>\n       ck_unifier u' u \\<theta> FirstOrder \\<and>\n       replace_subterm t p v t' \\<and>\n       (FirstOrder = FirstOrder \\<or>\n        (subst_lit M \\<theta>, subst_lit L \\<theta>) \\<in> lit_ord) \\<and>\n       (FirstOrder = FirstOrder \\<or>\n        strictly_maximal_literal P2 M \\<theta>) \\<and>\n       L' = mk_lit polarity (Eq t' s) \\<and>\n       Cl_C = subst_cl C' \\<theta> \\<and>\n       C' = Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})", "by blast"], ["proof (state)\nthis:\n  superposition P1 P2 C_fo \\<theta> FirstOrder C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this \\<open>P = { P1, P2 }\\<close>  \\<open>P \\<subseteq> S\\<close>"], ["proof (chain)\npicking this:\n  superposition P1 P2 C_fo \\<theta> FirstOrder C'\n  P = {P1, P2}\n  P \\<subseteq> S", "have \"(derivable C_fo P S \\<theta> FirstOrder C')\""], ["proof (prove)\nusing this:\n  superposition P1 P2 C_fo \\<theta> FirstOrder C'\n  P = {P1, P2}\n  P \\<subseteq> S\n\ngoal (1 subgoal):\n 1. derivable C_fo P S \\<theta> FirstOrder C'", "unfolding derivable_def"], ["proof (prove)\nusing this:\n  superposition P1 P2 C_fo \\<theta> FirstOrder C'\n  P = {P1, P2}\n  P \\<subseteq> S\n\ngoal (1 subgoal):\n 1. (\\<exists>P1 P2.\n        P1 \\<in> S \\<and>\n        P2 \\<in> S \\<and>\n        P = {P1, P2} \\<and>\n        superposition P1 P2 C_fo \\<theta> FirstOrder C') \\<or>\n    (\\<exists>P1.\n        P1 \\<in> S \\<and>\n        P = {P1} \\<and> factorization P1 C_fo \\<theta> FirstOrder C') \\<or>\n    (\\<exists>P1.\n        P1 \\<in> S \\<and>\n        P = {P1} \\<and> reflexion P1 C_fo \\<theta> FirstOrder C')", "by auto"], ["proof (state)\nthis:\n  derivable C_fo P S \\<theta> FirstOrder C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>(?Cl_C' = (subst_cl ((Cl_P1 - { L }) \\<union> ((Cl_P2 - { M }) \\<union> { L' } )) \\<theta>))\\<close>"], ["proof (chain)\npicking this:\n  subst_cl C' \\<theta> =\n  subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<theta>", "have \n      i: \"(subst_cl ?Cl_C' \\<eta>) = \n      (subst_cl (subst_cl ((Cl_P1 - { L }) \\<union> ((Cl_P2 - { M }) \\<union> { L' } )) \\<theta>)) \\<eta>\""], ["proof (prove)\nusing this:\n  subst_cl C' \\<theta> =\n  subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<theta>\n\ngoal (1 subgoal):\n 1. subst_cl (subst_cl C' \\<theta>) \\<eta> =\n    subst_cl\n     (subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<theta>)\n     \\<eta>", "by auto"], ["proof (state)\nthis:\n  subst_cl (subst_cl C' \\<theta>) \\<eta> =\n  subst_cl\n   (subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<theta>)\n   \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "have ii: \"(subst_cl (subst_cl ((Cl_P1 - { L }) \\<union> ((Cl_P2 - { M }) \\<union> { L' } )) \\<theta>) \\<eta>)\n      =  (subst_cl ((Cl_P1 - { L }) \\<union> ((Cl_P2 - { M }) \\<union> { L' } )) (\\<theta> \\<lozenge> \\<eta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_cl\n     (subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<theta>)\n     \\<eta> =\n    subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'}))\n     (\\<theta> \\<lozenge> \\<eta>)", "using composition_of_substs_cl [of \"((Cl_P1 - { L }) \\<union> ((Cl_P2 - { M }) \\<union> { L' } ))\" ]"], ["proof (prove)\nusing this:\n  subst_cl\n   (subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) ?\\<sigma>)\n   ?\\<eta> =\n  subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'}))\n   (?\\<sigma> \\<lozenge> ?\\<eta>)\n\ngoal (1 subgoal):\n 1. subst_cl\n     (subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<theta>)\n     \\<eta> =\n    subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'}))\n     (\\<theta> \\<lozenge> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  subst_cl\n   (subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<theta>)\n   \\<eta> =\n  subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'}))\n   (\\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>", "have \"(subst_cl ((Cl_P1 - { L }) \\<union> ((Cl_P2 - { M }) \\<union> { L' } )) \\<sigma>) \n      = (subst_cl ((Cl_P1 - { L }) \\<union> ((Cl_P2 - { M }) \\<union> { L' } )) (\\<theta> \\<lozenge> \\<eta>))\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<sigma> =\n    subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'}))\n     (\\<theta> \\<lozenge> \\<eta>)", "using subst_eq_cl [of \\<sigma> \"\\<theta> \\<lozenge> \\<eta>\" \"((Cl_P1 - { L }) \\<union> ((Cl_P2 - { M }) \\<union> { L' } ))\" ]"], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<Longrightarrow>\n  subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<sigma> =\n  subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'}))\n   (\\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<sigma> =\n    subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'}))\n     (\\<theta> \\<lozenge> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<sigma> =\n  subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'}))\n   (\\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this and i ii  \\<open>Cl_C = (subst_cl ((Cl_P1 - { L }) \\<union> ((Cl_P2 - { M }) \\<union> { L' } )) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<sigma> =\n  subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'}))\n   (\\<theta> \\<lozenge> \\<eta>)\n  subst_cl (subst_cl C' \\<theta>) \\<eta> =\n  subst_cl\n   (subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<theta>)\n   \\<eta>\n  subst_cl\n   (subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<theta>)\n   \\<eta> =\n  subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'}))\n   (\\<theta> \\<lozenge> \\<eta>)\n  Cl_C =\n  subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<sigma>", "have \"(subst_cl ?Cl_C' \\<eta>) = Cl_C\""], ["proof (prove)\nusing this:\n  subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<sigma> =\n  subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'}))\n   (\\<theta> \\<lozenge> \\<eta>)\n  subst_cl (subst_cl C' \\<theta>) \\<eta> =\n  subst_cl\n   (subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<theta>)\n   \\<eta>\n  subst_cl\n   (subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<theta>)\n   \\<eta> =\n  subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'}))\n   (\\<theta> \\<lozenge> \\<eta>)\n  Cl_C =\n  subst_cl (Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'})) \\<sigma>\n\ngoal (1 subgoal):\n 1. subst_cl (subst_cl C' \\<theta>) \\<eta> = Cl_C", "by metis"], ["proof (state)\nthis:\n  subst_cl (subst_cl C' \\<theta>) \\<eta> = Cl_C\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this and \\<open>(C = (Ecl Cl_C trms_C))\\<close> and \\<open>(C_fo = (Ecl ?Cl_C' T'))\\<close>"], ["proof (chain)\npicking this:\n  subst_cl (subst_cl C' \\<theta>) \\<eta> = Cl_C\n  C = Ecl Cl_C trms_C\n  C_fo = Ecl (subst_cl C' \\<theta>) T'", "have \"(subst_cl (cl_ecl C_fo) \\<eta>) = (cl_ecl C)\""], ["proof (prove)\nusing this:\n  subst_cl (subst_cl C' \\<theta>) \\<eta> = Cl_C\n  C = Ecl Cl_C trms_C\n  C_fo = Ecl (subst_cl C' \\<theta>) T'\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl C_fo) \\<eta> = cl_ecl C", "by auto"], ["proof (state)\nthis:\n  subst_cl (cl_ecl C_fo) \\<eta> = cl_ecl C\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>(subst_set T' \\<eta>) \\<subseteq> trms_C\\<close> \n      and \\<open>(C = (Ecl Cl_C trms_C))\\<close> and \\<open>(C_fo = (Ecl ?Cl_C' T'))\\<close>"], ["proof (chain)\npicking this:\n  subst_set T' \\<eta> \\<subseteq> trms_C\n  C = Ecl Cl_C trms_C\n  C_fo = Ecl (subst_cl C' \\<theta>) T'", "have \"(subst_set (trms_ecl C_fo) \\<eta>) \\<subseteq> (trms_ecl C)\""], ["proof (prove)\nusing this:\n  subst_set T' \\<eta> \\<subseteq> trms_C\n  C = Ecl Cl_C trms_C\n  C_fo = Ecl (subst_cl C' \\<theta>) T'\n\ngoal (1 subgoal):\n 1. subst_set (trms_ecl C_fo) \\<eta> \\<subseteq> trms_ecl C", "by auto"], ["proof (state)\nthis:\n  subst_set (trms_ecl C_fo) \\<eta> \\<subseteq> trms_ecl C\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>(subst_cl (cl_ecl C_fo) \\<eta>) = (cl_ecl C)\\<close> \\<open>(subst_set (trms_ecl C_fo) \\<eta>) \\<subseteq> (trms_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  subst_cl (cl_ecl C_fo) \\<eta> = cl_ecl C\n  subst_set (trms_ecl C_fo) \\<eta> \\<subseteq> trms_ecl C", "have \"(trms_subsumes C_fo C \\<eta>)\""], ["proof (prove)\nusing this:\n  subst_cl (cl_ecl C_fo) \\<eta> = cl_ecl C\n  subst_set (trms_ecl C_fo) \\<eta> \\<subseteq> trms_ecl C\n\ngoal (1 subgoal):\n 1. trms_subsumes C_fo C \\<eta>", "unfolding trms_subsumes_def"], ["proof (prove)\nusing this:\n  subst_cl (cl_ecl C_fo) \\<eta> = cl_ecl C\n  subst_set (trms_ecl C_fo) \\<eta> \\<subseteq> trms_ecl C\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl C_fo) \\<eta> = cl_ecl C \\<and>\n    subst_set (trms_ecl C_fo) \\<eta> \\<subseteq> trms_ecl C", "by auto"], ["proof (state)\nthis:\n  trms_subsumes C_fo C \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1 P2.\n       P = {P1, P2} \\<and>\n       superposition P1 P2 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this and \\<open>(derivable C_fo P S \\<theta> FirstOrder C')\\<close> and \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close> and hyp"], ["proof (chain)\npicking this:\n  trms_subsumes C_fo C \\<eta>\n  derivable C_fo P S \\<theta> FirstOrder C'\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  \\<nexists>D \\<theta> \\<eta>.\n     derivable D P S \\<theta> FirstOrder C' \\<and>\n     \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<and>\n     trms_subsumes D C \\<eta>", "show False"], ["proof (prove)\nusing this:\n  trms_subsumes C_fo C \\<eta>\n  derivable C_fo P S \\<theta> FirstOrder C'\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  \\<nexists>D \\<theta> \\<eta>.\n     derivable D P S \\<theta> FirstOrder C' \\<and>\n     \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<and>\n     trms_subsumes D C \\<eta>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>P1 P2.\n     P = {P1, P2} \\<and> superposition P1 P2 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. \\<nexists>D \\<theta> \\<eta>.\n       derivable D P S \\<theta> FirstOrder C' \\<and>\n       \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<and>\n       trms_subsumes D C \\<eta> \\<Longrightarrow>\n    False", "have not_fact: \"\\<not> (\\<exists>P1. ({ P1 } =  P \\<and> factorization P1 C \\<sigma> Ground C'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>P1. {P1} = P \\<and> factorization P1 C \\<sigma> Ground C'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "assume \"(\\<exists>P1. ({ P1 } = P \\<and> factorization P1 C \\<sigma> Ground C'))\""], ["proof (state)\nthis:\n  \\<exists>P1. {P1} = P \\<and> factorization P1 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>P1. {P1} = P \\<and> factorization P1 C \\<sigma> Ground C'", "obtain P1 where \"P = { P1 }\" \"factorization P1 C \\<sigma> Ground C'\""], ["proof (prove)\nusing this:\n  \\<exists>P1. {P1} = P \\<and> factorization P1 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. (\\<And>P1.\n        \\<lbrakk>P = {P1}; factorization P1 C \\<sigma> Ground C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  P = {P1}\n  factorization P1 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  P = {P1}\n  factorization P1 C \\<sigma> Ground C'", "obtain L1 L2 L' t s u v Cl_P Cl_C trms_C where\n      \"eligible_literal L1 P1 \\<sigma>\"\n      \"L1 \\<in> (cl_ecl P1)\" \"L2 \\<in> (cl_ecl P1) - { L1 }\" \"Cl_C = (cl_ecl C)\" \"(Cl_P = (cl_ecl P1))\" \n      \"(orient_lit_inst L1 t s pos \\<sigma>)\"\n      \"(orient_lit_inst L2 u v pos \\<sigma>)\"\n      \"((subst t \\<sigma>) \\<noteq> (subst s \\<sigma>))\"\n      \"(subst t \\<sigma>) \\<noteq> (subst v \\<sigma>)\"\n      \"(ck_unifier t u \\<sigma> Ground)\"\n      \"(L' = Neg (Eq s v))\"\n      \"C = (Ecl Cl_C trms_C)\"\n      \"trms_C  = (get_trms Cl_C \n          (dom_trms Cl_C (subst_set ( (trms_ecl P1) \\<union> (proper_subterms_of t) ) \\<sigma>))) Ground\"\n      \"(Cl_C = (subst_cl ( (Cl_P - { L2 }) \\<union> { L' } )) \\<sigma>)\"\n      \"(C' = ( (Cl_P - { L2 }) \\<union> { L' } ))\""], ["proof (prove)\nusing this:\n  P = {P1}\n  factorization P1 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. (\\<And>L1 L2 Cl_C Cl_P t s u v L' trms_C.\n        \\<lbrakk>eligible_literal L1 P1 \\<sigma>; L1 \\<in> cl_ecl P1;\n         L2 \\<in> cl_ecl P1 - {L1}; Cl_C = cl_ecl C; Cl_P = cl_ecl P1;\n         orient_lit_inst L1 t s pos \\<sigma>;\n         orient_lit_inst L2 u v pos \\<sigma>;\n         t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>;\n         t \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>;\n         ck_unifier t u \\<sigma> Ground; L' = Neg (Eq s v);\n         C = Ecl Cl_C trms_C;\n         trms_C =\n         get_trms Cl_C\n          (dom_trms Cl_C\n            (subst_set (trms_ecl P1 \\<union> proper_subterms_of t)\n              \\<sigma>))\n          Ground;\n         Cl_C = subst_cl (Cl_P - {L2} \\<union> {L'}) \\<sigma>;\n         C' = Cl_P - {L2} \\<union> {L'}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding factorization_def get_trms_def"], ["proof (prove)\nusing this:\n  P = {P1}\n  \\<exists>L1 L2 L' t s u v Cl_P Cl_C trms_C.\n     eligible_literal L1 P1 \\<sigma> \\<and>\n     L1 \\<in> cl_ecl P1 \\<and>\n     L2 \\<in> cl_ecl P1 - {L1} \\<and>\n     Cl_C = cl_ecl C \\<and>\n     Cl_P = cl_ecl P1 \\<and>\n     orient_lit_inst L1 t s pos \\<sigma> \\<and>\n     orient_lit_inst L2 u v pos \\<sigma> \\<and>\n     t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma> \\<and>\n     t \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma> \\<and>\n     ck_unifier t u \\<sigma> Ground \\<and>\n     L' = Neg (Eq s v) \\<and>\n     (C = Ecl Cl_C trms_C \\<and>\n      trms_C =\n      (if Ground = FirstOrder\n       then filter_trms Cl_C\n             (dom_trms Cl_C\n               (subst_set (trms_ecl P1 \\<union> proper_subterms_of t)\n                 \\<sigma>))\n       else dom_trms Cl_C\n             (subst_set (trms_ecl P1 \\<union> proper_subterms_of t)\n               \\<sigma>))) \\<and>\n     Cl_C = subst_cl C' \\<sigma> \\<and> C' = Cl_P - {L2} \\<union> {L'}\n\ngoal (1 subgoal):\n 1. (\\<And>L1 L2 Cl_C Cl_P t s u v L' trms_C.\n        \\<lbrakk>eligible_literal L1 P1 \\<sigma>; L1 \\<in> cl_ecl P1;\n         L2 \\<in> cl_ecl P1 - {L1}; Cl_C = cl_ecl C; Cl_P = cl_ecl P1;\n         orient_lit_inst L1 t s pos \\<sigma>;\n         orient_lit_inst L2 u v pos \\<sigma>;\n         t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>;\n         t \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>;\n         ck_unifier t u \\<sigma> Ground; L' = Neg (Eq s v);\n         C = Ecl Cl_C trms_C;\n         trms_C =\n         (if Ground = FirstOrder\n          then filter_trms Cl_C\n                (dom_trms Cl_C\n                  (subst_set (trms_ecl P1 \\<union> proper_subterms_of t)\n                    \\<sigma>))\n          else dom_trms Cl_C\n                (subst_set (trms_ecl P1 \\<union> proper_subterms_of t)\n                  \\<sigma>));\n         Cl_C = subst_cl (Cl_P - {L2} \\<union> {L'}) \\<sigma>;\n         C' = Cl_P - {L2} \\<union> {L'}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eligible_literal L1 P1 \\<sigma>\n  L1 \\<in> cl_ecl P1\n  L2 \\<in> cl_ecl P1 - {L1}\n  Cl_C = cl_ecl C\n  Cl_P = cl_ecl P1\n  orient_lit_inst L1 t s pos \\<sigma>\n  orient_lit_inst L2 u v pos \\<sigma>\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n  t \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>\n  ck_unifier t u \\<sigma> Ground\n  L' = Neg (Eq s v)\n  C = Ecl Cl_C trms_C\n  trms_C =\n  get_trms Cl_C\n   (dom_trms Cl_C\n     (subst_set (trms_ecl P1 \\<union> proper_subterms_of t) \\<sigma>))\n   Ground\n  Cl_C = subst_cl (Cl_P - {L2} \\<union> {L'}) \\<sigma>\n  C' = Cl_P - {L2} \\<union> {L'}\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>(ck_unifier t u \\<sigma> Ground)\\<close>"], ["proof (chain)\npicking this:\n  ck_unifier t u \\<sigma> Ground", "have \" Unifier \\<sigma> t u\""], ["proof (prove)\nusing this:\n  ck_unifier t u \\<sigma> Ground\n\ngoal (1 subgoal):\n 1. Unifier \\<sigma> t u", "unfolding ck_unifier_def Unifier_def"], ["proof (prove)\nusing this:\n  if Ground = FirstOrder then MGU \\<sigma> t u\n  else t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  Unifier \\<sigma> t u\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  Unifier \\<sigma> t u", "have \"(subst t \\<sigma>) = (subst u \\<sigma>)\""], ["proof (prove)\nusing this:\n  Unifier \\<sigma> t u\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>", "unfolding Unifier_def"], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>", "have \"unify t u \\<noteq> None\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. unify t u \\<noteq> None", "using MGU_exists"], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n  \\<forall>\\<sigma>.\n     ?t \\<lhd> \\<sigma> = ?s \\<lhd> \\<sigma> \\<longrightarrow>\n     unify ?t ?s \\<noteq> None\n\ngoal (1 subgoal):\n 1. unify t u \\<noteq> None", "by auto"], ["proof (state)\nthis:\n  unify t u \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  unify t u \\<noteq> None", "obtain \\<theta> where \"unify t u = Some \\<theta>\""], ["proof (prove)\nusing this:\n  unify t u \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>\\<theta>.\n        unify t u = Some \\<theta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  unify t u = Some \\<theta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  unify t u = Some \\<theta>", "have \"MGU \\<theta> t u\""], ["proof (prove)\nusing this:\n  unify t u = Some \\<theta>\n\ngoal (1 subgoal):\n 1. MGU \\<theta> t u", "using unify_computes_MGU"], ["proof (prove)\nusing this:\n  unify t u = Some \\<theta>\n  unify ?M ?N = Some ?\\<sigma> \\<Longrightarrow> MGU ?\\<sigma> ?M ?N\n\ngoal (1 subgoal):\n 1. MGU \\<theta> t u", "by auto"], ["proof (state)\nthis:\n  MGU \\<theta> t u\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this and \\<open>Unifier \\<sigma> t u\\<close>"], ["proof (chain)\npicking this:\n  MGU \\<theta> t u\n  Unifier \\<sigma> t u", "obtain \\<eta> where \"\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\""], ["proof (prove)\nusing this:\n  MGU \\<theta> t u\n  Unifier \\<sigma> t u\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>.\n        \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding MGU_def"], ["proof (prove)\nusing this:\n  Unifier \\<theta> t u \\<and>\n  (\\<forall>\\<theta>'.\n      Unifier \\<theta>' t u \\<longrightarrow>\n      (\\<exists>\\<gamma>. \\<theta>' \\<doteq> \\<theta> \\<lozenge> \\<gamma>))\n  Unifier \\<sigma> t u\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>.\n        \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close> and \\<open>(eligible_literal L1 P1 \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  eligible_literal L1 P1 \\<sigma>", "have \"eligible_literal L1 P1 \\<theta>\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  eligible_literal L1 P1 \\<sigma>\n\ngoal (1 subgoal):\n 1. eligible_literal L1 P1 \\<theta>", "using lift_eligible_literal"], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  eligible_literal L1 P1 \\<sigma>\n  \\<lbrakk>eligible_literal ?L ?C ?\\<sigma>;\n   ?\\<sigma> \\<doteq> ?\\<theta> \\<lozenge> ?\\<eta>\\<rbrakk>\n  \\<Longrightarrow> eligible_literal ?L ?C ?\\<theta>\n\ngoal (1 subgoal):\n 1. eligible_literal L1 P1 \\<theta>", "by auto"], ["proof (state)\nthis:\n  eligible_literal L1 P1 \\<theta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>MGU \\<theta> t u\\<close>"], ["proof (chain)\npicking this:\n  MGU \\<theta> t u", "have \"ck_unifier t u \\<theta> FirstOrder\""], ["proof (prove)\nusing this:\n  MGU \\<theta> t u\n\ngoal (1 subgoal):\n 1. ck_unifier t u \\<theta> FirstOrder", "unfolding ck_unifier_def"], ["proof (prove)\nusing this:\n  MGU \\<theta> t u\n\ngoal (1 subgoal):\n 1. if FirstOrder = FirstOrder then MGU \\<theta> t u\n    else Unifier \\<theta> t u", "by auto"], ["proof (state)\nthis:\n  ck_unifier t u \\<theta> FirstOrder\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>", "have \"(subst t \\<sigma>) = (subst (subst t \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = t \\<lhd> \\<theta> \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> = t \\<lhd> \\<theta> \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>", "have \"(subst s \\<sigma>) = (subst (subst s \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. s \\<lhd> \\<sigma> = s \\<lhd> \\<theta> \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  s \\<lhd> \\<sigma> = s \\<lhd> \\<theta> \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>", "have \"(subst v \\<sigma>) = (subst (subst v \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. v \\<lhd> \\<sigma> = v \\<lhd> \\<theta> \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  v \\<lhd> \\<sigma> = v \\<lhd> \\<theta> \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>((subst t \\<sigma>) \\<noteq> (subst s \\<sigma>))\\<close> \n      \\<open>(subst t \\<sigma>) = (subst (subst t \\<theta>) \\<eta>)\\<close> \n      \\<open>(subst s \\<sigma>) = (subst (subst s \\<theta>) \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n  t \\<lhd> \\<sigma> = t \\<lhd> \\<theta> \\<lhd> \\<eta>\n  s \\<lhd> \\<sigma> = s \\<lhd> \\<theta> \\<lhd> \\<eta>", "have \"(subst (subst t \\<theta>) \\<eta>) \\<noteq> (subst (subst s \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n  t \\<lhd> \\<sigma> = t \\<lhd> \\<theta> \\<lhd> \\<eta>\n  s \\<lhd> \\<sigma> = s \\<lhd> \\<theta> \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<theta> \\<lhd> \\<eta> \\<noteq> s \\<lhd> \\<theta> \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  t \\<lhd> \\<theta> \\<lhd> \\<eta> \\<noteq> s \\<lhd> \\<theta> \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<theta> \\<lhd> \\<eta> \\<noteq> s \\<lhd> \\<theta> \\<lhd> \\<eta>", "have \"(subst t \\<theta>) \\<noteq> (subst s \\<theta>)\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<theta> \\<lhd> \\<eta> \\<noteq> s \\<lhd> \\<theta> \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<theta> \\<noteq> s \\<lhd> \\<theta>", "by auto"], ["proof (state)\nthis:\n  t \\<lhd> \\<theta> \\<noteq> s \\<lhd> \\<theta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>((subst t \\<sigma>) \\<noteq> (subst v \\<sigma>))\\<close> \n      \\<open>(subst t \\<sigma>) = (subst (subst t \\<theta>) \\<eta>)\\<close> \n      \\<open>(subst v \\<sigma>) = (subst (subst v \\<theta>) \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>\n  t \\<lhd> \\<sigma> = t \\<lhd> \\<theta> \\<lhd> \\<eta>\n  v \\<lhd> \\<sigma> = v \\<lhd> \\<theta> \\<lhd> \\<eta>", "have \"(subst (subst t \\<theta>) \\<eta>) \\<noteq> (subst (subst v \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>\n  t \\<lhd> \\<sigma> = t \\<lhd> \\<theta> \\<lhd> \\<eta>\n  v \\<lhd> \\<sigma> = v \\<lhd> \\<theta> \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<theta> \\<lhd> \\<eta> \\<noteq> v \\<lhd> \\<theta> \\<lhd> \\<eta>", "by auto"], ["proof (state)\nthis:\n  t \\<lhd> \\<theta> \\<lhd> \\<eta> \\<noteq> v \\<lhd> \\<theta> \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<theta> \\<lhd> \\<eta> \\<noteq> v \\<lhd> \\<theta> \\<lhd> \\<eta>", "have \"(subst t \\<theta>) \\<noteq> (subst v \\<theta>)\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<theta> \\<lhd> \\<eta> \\<noteq> v \\<lhd> \\<theta> \\<lhd> \\<eta>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<theta> \\<noteq> v \\<lhd> \\<theta>", "by auto"], ["proof (state)\nthis:\n  t \\<lhd> \\<theta> \\<noteq> v \\<lhd> \\<theta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close> \\<open>orient_lit_inst L1 t s pos \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  orient_lit_inst L1 t s pos \\<sigma>", "have \"orient_lit_inst L1 t s pos \\<theta>\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  orient_lit_inst L1 t s pos \\<sigma>\n\ngoal (1 subgoal):\n 1. orient_lit_inst L1 t s pos \\<theta>", "using lift_orient_lit_inst"], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  orient_lit_inst L1 t s pos \\<sigma>\n  \\<lbrakk>orient_lit_inst ?L ?t ?s ?polarity ?\\<theta>;\n   ?\\<theta> \\<doteq> ?\\<sigma> \\<lozenge> ?\\<eta>\\<rbrakk>\n  \\<Longrightarrow> orient_lit_inst ?L ?t ?s ?polarity ?\\<sigma>\n\ngoal (1 subgoal):\n 1. orient_lit_inst L1 t s pos \\<theta>", "by auto"], ["proof (state)\nthis:\n  orient_lit_inst L1 t s pos \\<theta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close> \\<open>orient_lit_inst L2 u v pos \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  orient_lit_inst L2 u v pos \\<sigma>", "have \"orient_lit_inst L2 u v pos \\<theta>\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  orient_lit_inst L2 u v pos \\<sigma>\n\ngoal (1 subgoal):\n 1. orient_lit_inst L2 u v pos \\<theta>", "using lift_orient_lit_inst"], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  orient_lit_inst L2 u v pos \\<sigma>\n  \\<lbrakk>orient_lit_inst ?L ?t ?s ?polarity ?\\<theta>;\n   ?\\<theta> \\<doteq> ?\\<sigma> \\<lozenge> ?\\<eta>\\<rbrakk>\n  \\<Longrightarrow> orient_lit_inst ?L ?t ?s ?polarity ?\\<sigma>\n\ngoal (1 subgoal):\n 1. orient_lit_inst L2 u v pos \\<theta>", "by auto"], ["proof (state)\nthis:\n  orient_lit_inst L2 u v pos \\<theta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>(Cl_C = (subst_cl ( (Cl_P - { L2 }) \\<union> { L' } )) \\<sigma>)\\<close> \n      and \\<open>C' = ( (Cl_P - { L2 }) \\<union> { L' } )\\<close>"], ["proof (chain)\npicking this:\n  Cl_C = subst_cl (Cl_P - {L2} \\<union> {L'}) \\<sigma>\n  C' = Cl_P - {L2} \\<union> {L'}", "have \"(Cl_C = (subst_cl C' \\<sigma>))\""], ["proof (prove)\nusing this:\n  Cl_C = subst_cl (Cl_P - {L2} \\<union> {L'}) \\<sigma>\n  C' = Cl_P - {L2} \\<union> {L'}\n\ngoal (1 subgoal):\n 1. Cl_C = subst_cl C' \\<sigma>", "by auto"], ["proof (state)\nthis:\n  Cl_C = subst_cl C' \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "obtain E where \"E = (trms_ecl P1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>E. E = trms_ecl P1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  E = trms_ecl P1\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this and \\<open>(Cl_C = (subst_cl C' \\<sigma>))\\<close> \n      \\<open>trms_C = (get_trms  Cl_C \n          (dom_trms Cl_C (subst_set ( (trms_ecl P1) \\<union> (proper_subterms_of t) ) \\<sigma>))) Ground\\<close>"], ["proof (chain)\npicking this:\n  E = trms_ecl P1\n  Cl_C = subst_cl C' \\<sigma>\n  trms_C =\n  get_trms Cl_C\n   (dom_trms Cl_C\n     (subst_set (trms_ecl P1 \\<union> proper_subterms_of t) \\<sigma>))\n   Ground", "have \"trms_C = (get_trms Cl_C \n        (dom_trms (subst_cl C' \\<sigma>) (subst_set \n        (E \\<union> (proper_subterms_of t))  \\<sigma>)) Ground)\""], ["proof (prove)\nusing this:\n  E = trms_ecl P1\n  Cl_C = subst_cl C' \\<sigma>\n  trms_C =\n  get_trms Cl_C\n   (dom_trms Cl_C\n     (subst_set (trms_ecl P1 \\<union> proper_subterms_of t) \\<sigma>))\n   Ground\n\ngoal (1 subgoal):\n 1. trms_C =\n    get_trms Cl_C\n     (dom_trms (subst_cl C' \\<sigma>)\n       (subst_set (E \\<union> proper_subterms_of t) \\<sigma>))\n     Ground", "by auto"], ["proof (state)\nthis:\n  trms_C =\n  get_trms Cl_C\n   (dom_trms (subst_cl C' \\<sigma>)\n     (subst_set (E \\<union> proper_subterms_of t) \\<sigma>))\n   Ground\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "let ?Cl_C' = \"(subst_cl C' \\<theta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from  \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close> \\<open>trms_C = (get_trms Cl_C \n        (dom_trms (subst_cl C' \\<sigma>) (subst_set \n        (E \\<union> (proper_subterms_of t))  \\<sigma>)) Ground)\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  trms_C =\n  get_trms Cl_C\n   (dom_trms (subst_cl C' \\<sigma>)\n     (subst_set (E \\<union> proper_subterms_of t) \\<sigma>))\n   Ground", "have \"\\<exists>T'. ( (subst_set T' \\<eta>) \\<subseteq> trms_C \\<and> T' = get_trms ?Cl_C' \n    (dom_trms (subst_cl C' \\<theta>) (subst_set (E \\<union> (proper_subterms_of t)) \\<theta>)) FirstOrder)\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  trms_C =\n  get_trms Cl_C\n   (dom_trms (subst_cl C' \\<sigma>)\n     (subst_set (E \\<union> proper_subterms_of t) \\<sigma>))\n   Ground\n\ngoal (1 subgoal):\n 1. \\<exists>T'.\n       subst_set T' \\<eta> \\<subseteq> trms_C \\<and>\n       T' =\n       get_trms (subst_cl C' \\<theta>)\n        (dom_trms (subst_cl C' \\<theta>)\n          (subst_set (E \\<union> proper_subterms_of t) \\<theta>))\n        FirstOrder", "using lift_irreducible_terms"], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  trms_C =\n  get_trms Cl_C\n   (dom_trms (subst_cl C' \\<sigma>)\n     (subst_set (E \\<union> proper_subterms_of t) \\<sigma>))\n   Ground\n  \\<lbrakk>?T =\n           get_trms ?C\n            (dom_trms (subst_cl ?D ?\\<sigma>) (subst_set ?E ?\\<sigma>))\n            Ground;\n   ?\\<sigma> \\<doteq> ?\\<theta> \\<lozenge> ?\\<eta>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>T'.\n                       subst_set T' ?\\<eta> \\<subseteq> ?T \\<and>\n                       T' =\n                       get_trms ?C'\n                        (dom_trms (subst_cl ?D ?\\<theta>)\n                          (subst_set ?E ?\\<theta>))\n                        FirstOrder\n\ngoal (1 subgoal):\n 1. \\<exists>T'.\n       subst_set T' \\<eta> \\<subseteq> trms_C \\<and>\n       T' =\n       get_trms (subst_cl C' \\<theta>)\n        (dom_trms (subst_cl C' \\<theta>)\n          (subst_set (E \\<union> proper_subterms_of t) \\<theta>))\n        FirstOrder", "by blast"], ["proof (state)\nthis:\n  \\<exists>T'.\n     subst_set T' \\<eta> \\<subseteq> trms_C \\<and>\n     T' =\n     get_trms (subst_cl C' \\<theta>)\n      (dom_trms (subst_cl C' \\<theta>)\n        (subst_set (E \\<union> proper_subterms_of t) \\<theta>))\n      FirstOrder\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<exists>T'.\n     subst_set T' \\<eta> \\<subseteq> trms_C \\<and>\n     T' =\n     get_trms (subst_cl C' \\<theta>)\n      (dom_trms (subst_cl C' \\<theta>)\n        (subst_set (E \\<union> proper_subterms_of t) \\<theta>))\n      FirstOrder", "obtain T' where \"(subst_set T' \\<eta>) \\<subseteq> trms_C\" \n      and \"T' = get_trms ?Cl_C' \n    (dom_trms (subst_cl C' \\<theta>) (subst_set (E \\<union> (proper_subterms_of t)) \\<theta>)) FirstOrder\""], ["proof (prove)\nusing this:\n  \\<exists>T'.\n     subst_set T' \\<eta> \\<subseteq> trms_C \\<and>\n     T' =\n     get_trms (subst_cl C' \\<theta>)\n      (dom_trms (subst_cl C' \\<theta>)\n        (subst_set (E \\<union> proper_subterms_of t) \\<theta>))\n      FirstOrder\n\ngoal (1 subgoal):\n 1. (\\<And>T'.\n        \\<lbrakk>subst_set T' \\<eta> \\<subseteq> trms_C;\n         T' =\n         get_trms (subst_cl C' \\<theta>)\n          (dom_trms (subst_cl C' \\<theta>)\n            (subst_set (E \\<union> proper_subterms_of t) \\<theta>))\n          FirstOrder\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  subst_set T' \\<eta> \\<subseteq> trms_C\n  T' =\n  get_trms (subst_cl C' \\<theta>)\n   (dom_trms (subst_cl C' \\<theta>)\n     (subst_set (E \\<union> proper_subterms_of t) \\<theta>))\n   FirstOrder\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "obtain C_fo where \"C_fo = (Ecl ?Cl_C' T')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C_fo.\n        C_fo = Ecl (subst_cl C' \\<theta>) T' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C_fo = Ecl (subst_cl C' \\<theta>) T'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>C' = ( (Cl_P - { L2 }) \\<union> { L' } )\\<close>"], ["proof (chain)\npicking this:\n  C' = Cl_P - {L2} \\<union> {L'}", "have \"(?Cl_C' = (subst_cl ( (Cl_P - { L2 }) \\<union> { L' } ) \\<theta>))\""], ["proof (prove)\nusing this:\n  C' = Cl_P - {L2} \\<union> {L'}\n\ngoal (1 subgoal):\n 1. subst_cl C' \\<theta> = subst_cl (Cl_P - {L2} \\<union> {L'}) \\<theta>", "by auto"], ["proof (state)\nthis:\n  subst_cl C' \\<theta> = subst_cl (Cl_P - {L2} \\<union> {L'}) \\<theta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>C_fo = (Ecl ?Cl_C' T')\\<close>"], ["proof (chain)\npicking this:\n  C_fo = Ecl (subst_cl C' \\<theta>) T'", "have \"?Cl_C' = (cl_ecl C_fo)\""], ["proof (prove)\nusing this:\n  C_fo = Ecl (subst_cl C' \\<theta>) T'\n\ngoal (1 subgoal):\n 1. subst_cl C' \\<theta> = cl_ecl C_fo", "by auto"], ["proof (state)\nthis:\n  subst_cl C' \\<theta> = cl_ecl C_fo\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "have \"?Cl_C' = (subst_cl C' \\<theta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_cl C' \\<theta> = subst_cl C' \\<theta>", "by auto"], ["proof (state)\nthis:\n  subst_cl C' \\<theta> = subst_cl C' \\<theta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \n      \\<open>eligible_literal L1 P1 \\<theta>\\<close>\n      \\<open>L1 \\<in> (cl_ecl P1)\\<close> \\<open>L2 \\<in> (cl_ecl P1) - { L1 }\\<close> \\<open>?Cl_C' = (cl_ecl C_fo)\\<close> \\<open>(Cl_P = (cl_ecl P1))\\<close> \n      \\<open>(orient_lit_inst L1 t s pos \\<theta>)\\<close>\n      \\<open>(orient_lit_inst L2 u v pos \\<theta>)\\<close>\n      \\<open>((subst t \\<theta>) \\<noteq> (subst s \\<theta>))\\<close>\n      \\<open>(subst t \\<theta>) \\<noteq> (subst v \\<theta>)\\<close>\n      \\<open>(ck_unifier t u \\<theta> FirstOrder)\\<close>\n      \\<open>(L' = Neg (Eq s v))\\<close>\n      \\<open>C_fo = (Ecl ?Cl_C' T')\\<close>\n      \\<open>T' = get_trms?Cl_C' \n        (dom_trms ?Cl_C' (subst_set (E \\<union> (proper_subterms_of t)) \\<theta>)) FirstOrder\\<close>\n      \\<open>(?Cl_C' = (subst_cl ( (Cl_P - { L2 }) \\<union> { L' } ) \\<theta>))\\<close>\n      \\<open>C' = ( (Cl_P - { L2 }) \\<union> { L' } )\\<close>\n      \\<open>E = (trms_ecl P1)\\<close>"], ["proof (chain)\npicking this:\n  eligible_literal L1 P1 \\<theta>\n  L1 \\<in> cl_ecl P1\n  L2 \\<in> cl_ecl P1 - {L1}\n  subst_cl C' \\<theta> = cl_ecl C_fo\n  Cl_P = cl_ecl P1\n  orient_lit_inst L1 t s pos \\<theta>\n  orient_lit_inst L2 u v pos \\<theta>\n  t \\<lhd> \\<theta> \\<noteq> s \\<lhd> \\<theta>\n  t \\<lhd> \\<theta> \\<noteq> v \\<lhd> \\<theta>\n  ck_unifier t u \\<theta> FirstOrder\n  L' = Neg (Eq s v)\n  C_fo = Ecl (subst_cl C' \\<theta>) T'\n  T' =\n  get_trms (subst_cl C' \\<theta>)\n   (dom_trms (subst_cl C' \\<theta>)\n     (subst_set (E \\<union> proper_subterms_of t) \\<theta>))\n   FirstOrder\n  subst_cl C' \\<theta> = subst_cl (Cl_P - {L2} \\<union> {L'}) \\<theta>\n  C' = Cl_P - {L2} \\<union> {L'}\n  E = trms_ecl P1", "have \"factorization P1 C_fo \\<theta> FirstOrder C'\""], ["proof (prove)\nusing this:\n  eligible_literal L1 P1 \\<theta>\n  L1 \\<in> cl_ecl P1\n  L2 \\<in> cl_ecl P1 - {L1}\n  subst_cl C' \\<theta> = cl_ecl C_fo\n  Cl_P = cl_ecl P1\n  orient_lit_inst L1 t s pos \\<theta>\n  orient_lit_inst L2 u v pos \\<theta>\n  t \\<lhd> \\<theta> \\<noteq> s \\<lhd> \\<theta>\n  t \\<lhd> \\<theta> \\<noteq> v \\<lhd> \\<theta>\n  ck_unifier t u \\<theta> FirstOrder\n  L' = Neg (Eq s v)\n  C_fo = Ecl (subst_cl C' \\<theta>) T'\n  T' =\n  get_trms (subst_cl C' \\<theta>)\n   (dom_trms (subst_cl C' \\<theta>)\n     (subst_set (E \\<union> proper_subterms_of t) \\<theta>))\n   FirstOrder\n  subst_cl C' \\<theta> = subst_cl (Cl_P - {L2} \\<union> {L'}) \\<theta>\n  C' = Cl_P - {L2} \\<union> {L'}\n  E = trms_ecl P1\n\ngoal (1 subgoal):\n 1. factorization P1 C_fo \\<theta> FirstOrder C'", "unfolding factorization_def"], ["proof (prove)\nusing this:\n  eligible_literal L1 P1 \\<theta>\n  L1 \\<in> cl_ecl P1\n  L2 \\<in> cl_ecl P1 - {L1}\n  subst_cl C' \\<theta> = cl_ecl C_fo\n  Cl_P = cl_ecl P1\n  orient_lit_inst L1 t s pos \\<theta>\n  orient_lit_inst L2 u v pos \\<theta>\n  t \\<lhd> \\<theta> \\<noteq> s \\<lhd> \\<theta>\n  t \\<lhd> \\<theta> \\<noteq> v \\<lhd> \\<theta>\n  ck_unifier t u \\<theta> FirstOrder\n  L' = Neg (Eq s v)\n  C_fo = Ecl (subst_cl C' \\<theta>) T'\n  T' =\n  get_trms (subst_cl C' \\<theta>)\n   (dom_trms (subst_cl C' \\<theta>)\n     (subst_set (E \\<union> proper_subterms_of t) \\<theta>))\n   FirstOrder\n  subst_cl C' \\<theta> = subst_cl (Cl_P - {L2} \\<union> {L'}) \\<theta>\n  C' = Cl_P - {L2} \\<union> {L'}\n  E = trms_ecl P1\n\ngoal (1 subgoal):\n 1. \\<exists>L1 L2 L' t s u v Cl_P Cl_C trms_C.\n       eligible_literal L1 P1 \\<theta> \\<and>\n       L1 \\<in> cl_ecl P1 \\<and>\n       L2 \\<in> cl_ecl P1 - {L1} \\<and>\n       Cl_C = cl_ecl C_fo \\<and>\n       Cl_P = cl_ecl P1 \\<and>\n       orient_lit_inst L1 t s pos \\<theta> \\<and>\n       orient_lit_inst L2 u v pos \\<theta> \\<and>\n       t \\<lhd> \\<theta> \\<noteq> s \\<lhd> \\<theta> \\<and>\n       t \\<lhd> \\<theta> \\<noteq> v \\<lhd> \\<theta> \\<and>\n       ck_unifier t u \\<theta> FirstOrder \\<and>\n       L' = Neg (Eq s v) \\<and>\n       (C_fo = Ecl Cl_C trms_C \\<and>\n        trms_C =\n        get_trms Cl_C\n         (dom_trms Cl_C\n           (subst_set (trms_ecl P1 \\<union> proper_subterms_of t) \\<theta>))\n         FirstOrder) \\<and>\n       Cl_C = subst_cl C' \\<theta> \\<and> C' = Cl_P - {L2} \\<union> {L'}", "by blast"], ["proof (state)\nthis:\n  factorization P1 C_fo \\<theta> FirstOrder C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this \\<open>P = { P1 }\\<close>  \\<open>P \\<subseteq> S\\<close>"], ["proof (chain)\npicking this:\n  factorization P1 C_fo \\<theta> FirstOrder C'\n  P = {P1}\n  P \\<subseteq> S", "have \"(derivable C_fo P S \\<theta> FirstOrder C')\""], ["proof (prove)\nusing this:\n  factorization P1 C_fo \\<theta> FirstOrder C'\n  P = {P1}\n  P \\<subseteq> S\n\ngoal (1 subgoal):\n 1. derivable C_fo P S \\<theta> FirstOrder C'", "unfolding derivable_def"], ["proof (prove)\nusing this:\n  factorization P1 C_fo \\<theta> FirstOrder C'\n  P = {P1}\n  P \\<subseteq> S\n\ngoal (1 subgoal):\n 1. (\\<exists>P1 P2.\n        P1 \\<in> S \\<and>\n        P2 \\<in> S \\<and>\n        P = {P1, P2} \\<and>\n        superposition P1 P2 C_fo \\<theta> FirstOrder C') \\<or>\n    (\\<exists>P1.\n        P1 \\<in> S \\<and>\n        P = {P1} \\<and> factorization P1 C_fo \\<theta> FirstOrder C') \\<or>\n    (\\<exists>P1.\n        P1 \\<in> S \\<and>\n        P = {P1} \\<and> reflexion P1 C_fo \\<theta> FirstOrder C')", "by auto"], ["proof (state)\nthis:\n  derivable C_fo P S \\<theta> FirstOrder C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>(?Cl_C' = (subst_cl ( (Cl_P - { L2 }) \\<union> { L' } ) \\<theta>))\\<close>"], ["proof (chain)\npicking this:\n  subst_cl C' \\<theta> = subst_cl (Cl_P - {L2} \\<union> {L'}) \\<theta>", "have \n      i: \"(subst_cl ?Cl_C' \\<eta>) = \n      (subst_cl (subst_cl ( (Cl_P - { L2 }) \\<union> { L' } ) \\<theta>)) \\<eta>\""], ["proof (prove)\nusing this:\n  subst_cl C' \\<theta> = subst_cl (Cl_P - {L2} \\<union> {L'}) \\<theta>\n\ngoal (1 subgoal):\n 1. subst_cl (subst_cl C' \\<theta>) \\<eta> =\n    subst_cl (subst_cl (Cl_P - {L2} \\<union> {L'}) \\<theta>) \\<eta>", "by auto"], ["proof (state)\nthis:\n  subst_cl (subst_cl C' \\<theta>) \\<eta> =\n  subst_cl (subst_cl (Cl_P - {L2} \\<union> {L'}) \\<theta>) \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "have ii: \"(subst_cl (subst_cl ( (Cl_P - { L2 }) \\<union> { L' } ) \\<theta>) \\<eta>)\n      =  (subst_cl ( (Cl_P - { L2 }) \\<union> { L' } ) (\\<theta> \\<lozenge> \\<eta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_cl (subst_cl (Cl_P - {L2} \\<union> {L'}) \\<theta>) \\<eta> =\n    subst_cl (Cl_P - {L2} \\<union> {L'}) (\\<theta> \\<lozenge> \\<eta>)", "using composition_of_substs_cl [of \"( (Cl_P - { L2 }) \\<union> { L' } )\" ]"], ["proof (prove)\nusing this:\n  subst_cl (subst_cl (Cl_P - {L2} \\<union> {L'}) ?\\<sigma>) ?\\<eta> =\n  subst_cl (Cl_P - {L2} \\<union> {L'}) (?\\<sigma> \\<lozenge> ?\\<eta>)\n\ngoal (1 subgoal):\n 1. subst_cl (subst_cl (Cl_P - {L2} \\<union> {L'}) \\<theta>) \\<eta> =\n    subst_cl (Cl_P - {L2} \\<union> {L'}) (\\<theta> \\<lozenge> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  subst_cl (subst_cl (Cl_P - {L2} \\<union> {L'}) \\<theta>) \\<eta> =\n  subst_cl (Cl_P - {L2} \\<union> {L'}) (\\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>", "have \"(subst_cl ( (Cl_P - { L2 }) \\<union> { L' } ) \\<sigma>) \n      = (subst_cl ( (Cl_P - { L2 }) \\<union> { L' } ) (\\<theta> \\<lozenge> \\<eta>))\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. subst_cl (Cl_P - {L2} \\<union> {L'}) \\<sigma> =\n    subst_cl (Cl_P - {L2} \\<union> {L'}) (\\<theta> \\<lozenge> \\<eta>)", "using subst_eq_cl [of \\<sigma> \"\\<theta> \\<lozenge> \\<eta>\" \"( (Cl_P - { L2 }) \\<union> { L' } )\" ]"], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<Longrightarrow>\n  subst_cl (Cl_P - {L2} \\<union> {L'}) \\<sigma> =\n  subst_cl (Cl_P - {L2} \\<union> {L'}) (\\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. subst_cl (Cl_P - {L2} \\<union> {L'}) \\<sigma> =\n    subst_cl (Cl_P - {L2} \\<union> {L'}) (\\<theta> \\<lozenge> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  subst_cl (Cl_P - {L2} \\<union> {L'}) \\<sigma> =\n  subst_cl (Cl_P - {L2} \\<union> {L'}) (\\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this and i ii  \\<open>Cl_C = (subst_cl ( (Cl_P - { L2 }) \\<union> { L' } ) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  subst_cl (Cl_P - {L2} \\<union> {L'}) \\<sigma> =\n  subst_cl (Cl_P - {L2} \\<union> {L'}) (\\<theta> \\<lozenge> \\<eta>)\n  subst_cl (subst_cl C' \\<theta>) \\<eta> =\n  subst_cl (subst_cl (Cl_P - {L2} \\<union> {L'}) \\<theta>) \\<eta>\n  subst_cl (subst_cl (Cl_P - {L2} \\<union> {L'}) \\<theta>) \\<eta> =\n  subst_cl (Cl_P - {L2} \\<union> {L'}) (\\<theta> \\<lozenge> \\<eta>)\n  Cl_C = subst_cl (Cl_P - {L2} \\<union> {L'}) \\<sigma>", "have \"(subst_cl ?Cl_C' \\<eta>) = Cl_C\""], ["proof (prove)\nusing this:\n  subst_cl (Cl_P - {L2} \\<union> {L'}) \\<sigma> =\n  subst_cl (Cl_P - {L2} \\<union> {L'}) (\\<theta> \\<lozenge> \\<eta>)\n  subst_cl (subst_cl C' \\<theta>) \\<eta> =\n  subst_cl (subst_cl (Cl_P - {L2} \\<union> {L'}) \\<theta>) \\<eta>\n  subst_cl (subst_cl (Cl_P - {L2} \\<union> {L'}) \\<theta>) \\<eta> =\n  subst_cl (Cl_P - {L2} \\<union> {L'}) (\\<theta> \\<lozenge> \\<eta>)\n  Cl_C = subst_cl (Cl_P - {L2} \\<union> {L'}) \\<sigma>\n\ngoal (1 subgoal):\n 1. subst_cl (subst_cl C' \\<theta>) \\<eta> = Cl_C", "by metis"], ["proof (state)\nthis:\n  subst_cl (subst_cl C' \\<theta>) \\<eta> = Cl_C\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this and \\<open>(C = (Ecl Cl_C trms_C))\\<close> and \\<open>(C_fo = (Ecl ?Cl_C' T'))\\<close>"], ["proof (chain)\npicking this:\n  subst_cl (subst_cl C' \\<theta>) \\<eta> = Cl_C\n  C = Ecl Cl_C trms_C\n  C_fo = Ecl (subst_cl C' \\<theta>) T'", "have \"(subst_cl (cl_ecl C_fo) \\<eta>) = (cl_ecl C)\""], ["proof (prove)\nusing this:\n  subst_cl (subst_cl C' \\<theta>) \\<eta> = Cl_C\n  C = Ecl Cl_C trms_C\n  C_fo = Ecl (subst_cl C' \\<theta>) T'\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl C_fo) \\<eta> = cl_ecl C", "by auto"], ["proof (state)\nthis:\n  subst_cl (cl_ecl C_fo) \\<eta> = cl_ecl C\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>(subst_set T' \\<eta>) \\<subseteq> trms_C\\<close> \n      and \\<open>(C = (Ecl Cl_C trms_C))\\<close> and \\<open>(C_fo = (Ecl ?Cl_C' T'))\\<close>"], ["proof (chain)\npicking this:\n  subst_set T' \\<eta> \\<subseteq> trms_C\n  C = Ecl Cl_C trms_C\n  C_fo = Ecl (subst_cl C' \\<theta>) T'", "have \"(subst_set (trms_ecl C_fo) \\<eta>) \\<subseteq> (trms_ecl C)\""], ["proof (prove)\nusing this:\n  subst_set T' \\<eta> \\<subseteq> trms_C\n  C = Ecl Cl_C trms_C\n  C_fo = Ecl (subst_cl C' \\<theta>) T'\n\ngoal (1 subgoal):\n 1. subst_set (trms_ecl C_fo) \\<eta> \\<subseteq> trms_ecl C", "by auto"], ["proof (state)\nthis:\n  subst_set (trms_ecl C_fo) \\<eta> \\<subseteq> trms_ecl C\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>(subst_cl (cl_ecl C_fo) \\<eta>) = (cl_ecl C)\\<close> \\<open>(subst_set (trms_ecl C_fo) \\<eta>) \\<subseteq> (trms_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  subst_cl (cl_ecl C_fo) \\<eta> = cl_ecl C\n  subst_set (trms_ecl C_fo) \\<eta> \\<subseteq> trms_ecl C", "have \"(trms_subsumes C_fo C \\<eta>)\""], ["proof (prove)\nusing this:\n  subst_cl (cl_ecl C_fo) \\<eta> = cl_ecl C\n  subst_set (trms_ecl C_fo) \\<eta> \\<subseteq> trms_ecl C\n\ngoal (1 subgoal):\n 1. trms_subsumes C_fo C \\<eta>", "unfolding trms_subsumes_def"], ["proof (prove)\nusing this:\n  subst_cl (cl_ecl C_fo) \\<eta> = cl_ecl C\n  subst_set (trms_ecl C_fo) \\<eta> \\<subseteq> trms_ecl C\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl C_fo) \\<eta> = cl_ecl C \\<and>\n    subst_set (trms_ecl C_fo) \\<eta> \\<subseteq> trms_ecl C", "by auto"], ["proof (state)\nthis:\n  trms_subsumes C_fo C \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and>\n       factorization P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this and \\<open>(derivable C_fo P S \\<theta> FirstOrder C')\\<close> and \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close> and hyp"], ["proof (chain)\npicking this:\n  trms_subsumes C_fo C \\<eta>\n  derivable C_fo P S \\<theta> FirstOrder C'\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  \\<nexists>D \\<theta> \\<eta>.\n     derivable D P S \\<theta> FirstOrder C' \\<and>\n     \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<and>\n     trms_subsumes D C \\<eta>", "show False"], ["proof (prove)\nusing this:\n  trms_subsumes C_fo C \\<eta>\n  derivable C_fo P S \\<theta> FirstOrder C'\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  \\<nexists>D \\<theta> \\<eta>.\n     derivable D P S \\<theta> FirstOrder C' \\<and>\n     \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<and>\n     trms_subsumes D C \\<eta>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>P1. {P1} = P \\<and> factorization P1 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. \\<nexists>D \\<theta> \\<eta>.\n       derivable D P S \\<theta> FirstOrder C' \\<and>\n       \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<and>\n       trms_subsumes D C \\<eta> \\<Longrightarrow>\n    False", "have not_ref: \"\\<not> (\\<exists>P1. ({ P1 } = P \\<and> reflexion P1 C \\<sigma> Ground C'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>P1. {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "assume \"(\\<exists>P1. ({ P1 } = P  \\<and> reflexion P1 C \\<sigma> Ground C'))\""], ["proof (state)\nthis:\n  \\<exists>P1. {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>P1. {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C'", "obtain P1 where \"{ P1 } = P\" \"reflexion P1 C \\<sigma> Ground C'\""], ["proof (prove)\nusing this:\n  \\<exists>P1. {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. (\\<And>P1.\n        \\<lbrakk>{P1} = P; reflexion P1 C \\<sigma> Ground C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  {P1} = P\n  reflexion P1 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  {P1} = P\n  reflexion P1 C \\<sigma> Ground C'", "obtain L1 t s Cl_P Cl_C trms_C\n  where \"(eligible_literal L1 P1 \\<sigma>)\"\n      \"(L1 \\<in> (cl_ecl P1))\"  \"(Cl_C = (cl_ecl C))\" \"(Cl_P = (cl_ecl P1))\" \n      \"(orient_lit_inst L1 t s neg \\<sigma>)\"\n      \"(ck_unifier t s \\<sigma> Ground)\"\n      \"(C = (Ecl Cl_C trms_C))\"\n      \"(trms_C = get_trms Cl_C\n          (dom_trms Cl_C (subst_set ( (trms_ecl P1) \\<union> { t } ) \\<sigma>)) Ground)\" \n     \"(Cl_C = (subst_cl ((Cl_P - { L1 }) )) \\<sigma>)\"\n     \"(C' = ((Cl_P - { L1 }) ))\""], ["proof (prove)\nusing this:\n  {P1} = P\n  reflexion P1 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. (\\<And>L1 Cl_C Cl_P t s trms_C.\n        \\<lbrakk>eligible_literal L1 P1 \\<sigma>; L1 \\<in> cl_ecl P1;\n         Cl_C = cl_ecl C; Cl_P = cl_ecl P1;\n         orient_lit_inst L1 t s neg \\<sigma>;\n         ck_unifier t s \\<sigma> Ground; C = Ecl Cl_C trms_C;\n         trms_C =\n         get_trms Cl_C\n          (dom_trms Cl_C (subst_set (trms_ecl P1 \\<union> {t}) \\<sigma>))\n          Ground;\n         Cl_C = subst_cl (Cl_P - {L1}) \\<sigma>; C' = Cl_P - {L1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding reflexion_def get_trms_def"], ["proof (prove)\nusing this:\n  {P1} = P\n  \\<exists>L1 t s Cl_P Cl_C trms_C.\n     eligible_literal L1 P1 \\<sigma> \\<and>\n     L1 \\<in> cl_ecl P1 \\<and>\n     Cl_C = cl_ecl C \\<and>\n     Cl_P = cl_ecl P1 \\<and>\n     orient_lit_inst L1 t s neg \\<sigma> \\<and>\n     ck_unifier t s \\<sigma> Ground \\<and>\n     C = Ecl Cl_C trms_C \\<and>\n     trms_C =\n     (if Ground = FirstOrder\n      then filter_trms Cl_C\n            (dom_trms Cl_C (subst_set (trms_ecl P1 \\<union> {t}) \\<sigma>))\n      else dom_trms Cl_C\n            (subst_set (trms_ecl P1 \\<union> {t}) \\<sigma>)) \\<and>\n     Cl_C = subst_cl C' \\<sigma> \\<and> C' = Cl_P - {L1}\n\ngoal (1 subgoal):\n 1. (\\<And>L1 Cl_C Cl_P t s trms_C.\n        \\<lbrakk>eligible_literal L1 P1 \\<sigma>; L1 \\<in> cl_ecl P1;\n         Cl_C = cl_ecl C; Cl_P = cl_ecl P1;\n         orient_lit_inst L1 t s neg \\<sigma>;\n         ck_unifier t s \\<sigma> Ground; C = Ecl Cl_C trms_C;\n         trms_C =\n         (if Ground = FirstOrder\n          then filter_trms Cl_C\n                (dom_trms Cl_C\n                  (subst_set (trms_ecl P1 \\<union> {t}) \\<sigma>))\n          else dom_trms Cl_C\n                (subst_set (trms_ecl P1 \\<union> {t}) \\<sigma>));\n         Cl_C = subst_cl (Cl_P - {L1}) \\<sigma>; C' = Cl_P - {L1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eligible_literal L1 P1 \\<sigma>\n  L1 \\<in> cl_ecl P1\n  Cl_C = cl_ecl C\n  Cl_P = cl_ecl P1\n  orient_lit_inst L1 t s neg \\<sigma>\n  ck_unifier t s \\<sigma> Ground\n  C = Ecl Cl_C trms_C\n  trms_C =\n  get_trms Cl_C\n   (dom_trms Cl_C (subst_set (trms_ecl P1 \\<union> {t}) \\<sigma>)) Ground\n  Cl_C = subst_cl (Cl_P - {L1}) \\<sigma>\n  C' = Cl_P - {L1}\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>(ck_unifier t s \\<sigma> Ground)\\<close>"], ["proof (chain)\npicking this:\n  ck_unifier t s \\<sigma> Ground", "have \" Unifier \\<sigma> t s\""], ["proof (prove)\nusing this:\n  ck_unifier t s \\<sigma> Ground\n\ngoal (1 subgoal):\n 1. Unifier \\<sigma> t s", "unfolding ck_unifier_def Unifier_def"], ["proof (prove)\nusing this:\n  if Ground = FirstOrder then MGU \\<sigma> t s\n  else t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  Unifier \\<sigma> t s\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  Unifier \\<sigma> t s", "have \"(subst t \\<sigma>) = (subst s \\<sigma>)\""], ["proof (prove)\nusing this:\n  Unifier \\<sigma> t s\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>", "unfolding Unifier_def"], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>", "have \"unify t s \\<noteq> None\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. unify t s \\<noteq> None", "using MGU_exists"], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>\n  \\<forall>\\<sigma>.\n     ?t \\<lhd> \\<sigma> = ?s \\<lhd> \\<sigma> \\<longrightarrow>\n     unify ?t ?s \\<noteq> None\n\ngoal (1 subgoal):\n 1. unify t s \\<noteq> None", "by auto"], ["proof (state)\nthis:\n  unify t s \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  unify t s \\<noteq> None", "obtain \\<theta> where \"unify t s = Some \\<theta>\""], ["proof (prove)\nusing this:\n  unify t s \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>\\<theta>.\n        unify t s = Some \\<theta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  unify t s = Some \\<theta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  unify t s = Some \\<theta>", "have \"MGU \\<theta> t s\""], ["proof (prove)\nusing this:\n  unify t s = Some \\<theta>\n\ngoal (1 subgoal):\n 1. MGU \\<theta> t s", "using unify_computes_MGU"], ["proof (prove)\nusing this:\n  unify t s = Some \\<theta>\n  unify ?M ?N = Some ?\\<sigma> \\<Longrightarrow> MGU ?\\<sigma> ?M ?N\n\ngoal (1 subgoal):\n 1. MGU \\<theta> t s", "by auto"], ["proof (state)\nthis:\n  MGU \\<theta> t s\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this and \\<open>Unifier \\<sigma> t s\\<close>"], ["proof (chain)\npicking this:\n  MGU \\<theta> t s\n  Unifier \\<sigma> t s", "obtain \\<eta> where \"\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\""], ["proof (prove)\nusing this:\n  MGU \\<theta> t s\n  Unifier \\<sigma> t s\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>.\n        \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding MGU_def"], ["proof (prove)\nusing this:\n  Unifier \\<theta> t s \\<and>\n  (\\<forall>\\<theta>'.\n      Unifier \\<theta>' t s \\<longrightarrow>\n      (\\<exists>\\<gamma>. \\<theta>' \\<doteq> \\<theta> \\<lozenge> \\<gamma>))\n  Unifier \\<sigma> t s\n\ngoal (1 subgoal):\n 1. (\\<And>\\<eta>.\n        \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close> and \\<open>(eligible_literal L1 P1 \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  eligible_literal L1 P1 \\<sigma>", "have \"eligible_literal L1 P1 \\<theta>\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  eligible_literal L1 P1 \\<sigma>\n\ngoal (1 subgoal):\n 1. eligible_literal L1 P1 \\<theta>", "using lift_eligible_literal"], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  eligible_literal L1 P1 \\<sigma>\n  \\<lbrakk>eligible_literal ?L ?C ?\\<sigma>;\n   ?\\<sigma> \\<doteq> ?\\<theta> \\<lozenge> ?\\<eta>\\<rbrakk>\n  \\<Longrightarrow> eligible_literal ?L ?C ?\\<theta>\n\ngoal (1 subgoal):\n 1. eligible_literal L1 P1 \\<theta>", "by auto"], ["proof (state)\nthis:\n  eligible_literal L1 P1 \\<theta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>MGU \\<theta> t s\\<close>"], ["proof (chain)\npicking this:\n  MGU \\<theta> t s", "have \"ck_unifier t s \\<theta> FirstOrder\""], ["proof (prove)\nusing this:\n  MGU \\<theta> t s\n\ngoal (1 subgoal):\n 1. ck_unifier t s \\<theta> FirstOrder", "unfolding ck_unifier_def"], ["proof (prove)\nusing this:\n  MGU \\<theta> t s\n\ngoal (1 subgoal):\n 1. if FirstOrder = FirstOrder then MGU \\<theta> t s\n    else Unifier \\<theta> t s", "by auto"], ["proof (state)\nthis:\n  ck_unifier t s \\<theta> FirstOrder\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close> \\<open>orient_lit_inst L1 t s neg \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  orient_lit_inst L1 t s neg \\<sigma>", "have \"orient_lit_inst L1 t s neg \\<theta>\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  orient_lit_inst L1 t s neg \\<sigma>\n\ngoal (1 subgoal):\n 1. orient_lit_inst L1 t s neg \\<theta>", "using lift_orient_lit_inst"], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  orient_lit_inst L1 t s neg \\<sigma>\n  \\<lbrakk>orient_lit_inst ?L ?t ?s ?polarity ?\\<theta>;\n   ?\\<theta> \\<doteq> ?\\<sigma> \\<lozenge> ?\\<eta>\\<rbrakk>\n  \\<Longrightarrow> orient_lit_inst ?L ?t ?s ?polarity ?\\<sigma>\n\ngoal (1 subgoal):\n 1. orient_lit_inst L1 t s neg \\<theta>", "by auto"], ["proof (state)\nthis:\n  orient_lit_inst L1 t s neg \\<theta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>(Cl_C = (subst_cl ((Cl_P - { L1 }) )) \\<sigma>)\\<close> \n      and \\<open>C' = ((Cl_P - { L1 }) )\\<close>"], ["proof (chain)\npicking this:\n  Cl_C = subst_cl (Cl_P - {L1}) \\<sigma>\n  C' = Cl_P - {L1}", "have \"(Cl_C = (subst_cl C' \\<sigma>))\""], ["proof (prove)\nusing this:\n  Cl_C = subst_cl (Cl_P - {L1}) \\<sigma>\n  C' = Cl_P - {L1}\n\ngoal (1 subgoal):\n 1. Cl_C = subst_cl C' \\<sigma>", "by auto"], ["proof (state)\nthis:\n  Cl_C = subst_cl C' \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "obtain E where \"E = (trms_ecl P1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>E. E = trms_ecl P1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  E = trms_ecl P1\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this and \\<open>(Cl_C = (subst_cl C' \\<sigma>))\\<close> \n      \\<open>trms_C = (get_trms Cl_C \n          (dom_trms Cl_C (subst_set ( (trms_ecl P1)  \\<union> { t } ) \\<sigma>))) Ground\\<close>"], ["proof (chain)\npicking this:\n  E = trms_ecl P1\n  Cl_C = subst_cl C' \\<sigma>\n  trms_C =\n  get_trms Cl_C\n   (dom_trms Cl_C (subst_set (trms_ecl P1 \\<union> {t}) \\<sigma>)) Ground", "have \"trms_C = (get_trms Cl_C \n        (dom_trms (subst_cl C' \\<sigma>) (subst_set \n        (E  \\<union> { t })  \\<sigma>)) Ground)\""], ["proof (prove)\nusing this:\n  E = trms_ecl P1\n  Cl_C = subst_cl C' \\<sigma>\n  trms_C =\n  get_trms Cl_C\n   (dom_trms Cl_C (subst_set (trms_ecl P1 \\<union> {t}) \\<sigma>)) Ground\n\ngoal (1 subgoal):\n 1. trms_C =\n    get_trms Cl_C\n     (dom_trms (subst_cl C' \\<sigma>) (subst_set (E \\<union> {t}) \\<sigma>))\n     Ground", "by auto"], ["proof (state)\nthis:\n  trms_C =\n  get_trms Cl_C\n   (dom_trms (subst_cl C' \\<sigma>) (subst_set (E \\<union> {t}) \\<sigma>))\n   Ground\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "let ?Cl_C' = \"(subst_cl C' \\<theta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from  \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close> \\<open>trms_C = (get_trms  Cl_C \n        (dom_trms (subst_cl C' \\<sigma>) (subst_set \n        (E  \\<union> { t })  \\<sigma>)) Ground)\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  trms_C =\n  get_trms Cl_C\n   (dom_trms (subst_cl C' \\<sigma>) (subst_set (E \\<union> {t}) \\<sigma>))\n   Ground", "have \"\\<exists>T'. ( (subst_set T' \\<eta>) \\<subseteq> trms_C \\<and> T' = get_trms ?Cl_C' \n    (dom_trms (subst_cl C' \\<theta>) (subst_set (E  \\<union> { t }) \\<theta>)) FirstOrder)\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  trms_C =\n  get_trms Cl_C\n   (dom_trms (subst_cl C' \\<sigma>) (subst_set (E \\<union> {t}) \\<sigma>))\n   Ground\n\ngoal (1 subgoal):\n 1. \\<exists>T'.\n       subst_set T' \\<eta> \\<subseteq> trms_C \\<and>\n       T' =\n       get_trms (subst_cl C' \\<theta>)\n        (dom_trms (subst_cl C' \\<theta>)\n          (subst_set (E \\<union> {t}) \\<theta>))\n        FirstOrder", "using lift_irreducible_terms"], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  trms_C =\n  get_trms Cl_C\n   (dom_trms (subst_cl C' \\<sigma>) (subst_set (E \\<union> {t}) \\<sigma>))\n   Ground\n  \\<lbrakk>?T =\n           get_trms ?C\n            (dom_trms (subst_cl ?D ?\\<sigma>) (subst_set ?E ?\\<sigma>))\n            Ground;\n   ?\\<sigma> \\<doteq> ?\\<theta> \\<lozenge> ?\\<eta>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>T'.\n                       subst_set T' ?\\<eta> \\<subseteq> ?T \\<and>\n                       T' =\n                       get_trms ?C'\n                        (dom_trms (subst_cl ?D ?\\<theta>)\n                          (subst_set ?E ?\\<theta>))\n                        FirstOrder\n\ngoal (1 subgoal):\n 1. \\<exists>T'.\n       subst_set T' \\<eta> \\<subseteq> trms_C \\<and>\n       T' =\n       get_trms (subst_cl C' \\<theta>)\n        (dom_trms (subst_cl C' \\<theta>)\n          (subst_set (E \\<union> {t}) \\<theta>))\n        FirstOrder", "by blast"], ["proof (state)\nthis:\n  \\<exists>T'.\n     subst_set T' \\<eta> \\<subseteq> trms_C \\<and>\n     T' =\n     get_trms (subst_cl C' \\<theta>)\n      (dom_trms (subst_cl C' \\<theta>)\n        (subst_set (E \\<union> {t}) \\<theta>))\n      FirstOrder\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<exists>T'.\n     subst_set T' \\<eta> \\<subseteq> trms_C \\<and>\n     T' =\n     get_trms (subst_cl C' \\<theta>)\n      (dom_trms (subst_cl C' \\<theta>)\n        (subst_set (E \\<union> {t}) \\<theta>))\n      FirstOrder", "obtain T' where \"(subst_set T' \\<eta>) \\<subseteq> trms_C\" \n      and \"T' = get_trms ?Cl_C' \n    (dom_trms (subst_cl C' \\<theta>) (subst_set (E  \\<union> { t }) \\<theta>)) FirstOrder\""], ["proof (prove)\nusing this:\n  \\<exists>T'.\n     subst_set T' \\<eta> \\<subseteq> trms_C \\<and>\n     T' =\n     get_trms (subst_cl C' \\<theta>)\n      (dom_trms (subst_cl C' \\<theta>)\n        (subst_set (E \\<union> {t}) \\<theta>))\n      FirstOrder\n\ngoal (1 subgoal):\n 1. (\\<And>T'.\n        \\<lbrakk>subst_set T' \\<eta> \\<subseteq> trms_C;\n         T' =\n         get_trms (subst_cl C' \\<theta>)\n          (dom_trms (subst_cl C' \\<theta>)\n            (subst_set (E \\<union> {t}) \\<theta>))\n          FirstOrder\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  subst_set T' \\<eta> \\<subseteq> trms_C\n  T' =\n  get_trms (subst_cl C' \\<theta>)\n   (dom_trms (subst_cl C' \\<theta>) (subst_set (E \\<union> {t}) \\<theta>))\n   FirstOrder\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "obtain C_fo where \"C_fo = (Ecl ?Cl_C' T')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C_fo.\n        C_fo = Ecl (subst_cl C' \\<theta>) T' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C_fo = Ecl (subst_cl C' \\<theta>) T'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>C' = ((Cl_P - { L1 }) )\\<close>"], ["proof (chain)\npicking this:\n  C' = Cl_P - {L1}", "have \"(?Cl_C' = (subst_cl ((Cl_P - { L1 }) ) \\<theta>))\""], ["proof (prove)\nusing this:\n  C' = Cl_P - {L1}\n\ngoal (1 subgoal):\n 1. subst_cl C' \\<theta> = subst_cl (Cl_P - {L1}) \\<theta>", "by auto"], ["proof (state)\nthis:\n  subst_cl C' \\<theta> = subst_cl (Cl_P - {L1}) \\<theta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>C_fo = (Ecl ?Cl_C' T')\\<close>"], ["proof (chain)\npicking this:\n  C_fo = Ecl (subst_cl C' \\<theta>) T'", "have \"?Cl_C' = (cl_ecl C_fo)\""], ["proof (prove)\nusing this:\n  C_fo = Ecl (subst_cl C' \\<theta>) T'\n\ngoal (1 subgoal):\n 1. subst_cl C' \\<theta> = cl_ecl C_fo", "by auto"], ["proof (state)\nthis:\n  subst_cl C' \\<theta> = cl_ecl C_fo\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "have \"?Cl_C' = (subst_cl C' \\<theta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_cl C' \\<theta> = subst_cl C' \\<theta>", "by auto"], ["proof (state)\nthis:\n  subst_cl C' \\<theta> = subst_cl C' \\<theta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \n      \\<open>(eligible_literal L1 P1 \\<theta>)\\<close>\n      \\<open>(L1 \\<in> (cl_ecl P1))\\<close> \\<open>?Cl_C' = (cl_ecl C_fo)\\<close> \\<open>(Cl_P = (cl_ecl P1))\\<close> \n      \\<open>(orient_lit_inst L1 t s neg \\<theta>)\\<close>\n      \\<open>(ck_unifier t s \\<theta> FirstOrder)\\<close>\n      \\<open>(C_fo = (Ecl ?Cl_C' T'))\\<close>\n      \\<open>(T' = get_trms  ?Cl_C'\n          (dom_trms (subst_cl C' \\<theta>) (subst_set (E \\<union> { t }) \\<theta>)) FirstOrder)\\<close> \n     \\<open>(?Cl_C' = (subst_cl ((Cl_P - { L1 }) )) \\<theta>)\\<close>\n     \\<open>(C' = ((Cl_P - { L1 }) ))\\<close>\n     \\<open>E = (trms_ecl P1)\\<close>"], ["proof (chain)\npicking this:\n  eligible_literal L1 P1 \\<theta>\n  L1 \\<in> cl_ecl P1\n  subst_cl C' \\<theta> = cl_ecl C_fo\n  Cl_P = cl_ecl P1\n  orient_lit_inst L1 t s neg \\<theta>\n  ck_unifier t s \\<theta> FirstOrder\n  C_fo = Ecl (subst_cl C' \\<theta>) T'\n  T' =\n  get_trms (subst_cl C' \\<theta>)\n   (dom_trms (subst_cl C' \\<theta>) (subst_set (E \\<union> {t}) \\<theta>))\n   FirstOrder\n  subst_cl C' \\<theta> = subst_cl (Cl_P - {L1}) \\<theta>\n  C' = Cl_P - {L1}\n  E = trms_ecl P1", "have \"reflexion P1 C_fo \\<theta> FirstOrder C'\""], ["proof (prove)\nusing this:\n  eligible_literal L1 P1 \\<theta>\n  L1 \\<in> cl_ecl P1\n  subst_cl C' \\<theta> = cl_ecl C_fo\n  Cl_P = cl_ecl P1\n  orient_lit_inst L1 t s neg \\<theta>\n  ck_unifier t s \\<theta> FirstOrder\n  C_fo = Ecl (subst_cl C' \\<theta>) T'\n  T' =\n  get_trms (subst_cl C' \\<theta>)\n   (dom_trms (subst_cl C' \\<theta>) (subst_set (E \\<union> {t}) \\<theta>))\n   FirstOrder\n  subst_cl C' \\<theta> = subst_cl (Cl_P - {L1}) \\<theta>\n  C' = Cl_P - {L1}\n  E = trms_ecl P1\n\ngoal (1 subgoal):\n 1. reflexion P1 C_fo \\<theta> FirstOrder C'", "unfolding reflexion_def"], ["proof (prove)\nusing this:\n  eligible_literal L1 P1 \\<theta>\n  L1 \\<in> cl_ecl P1\n  subst_cl C' \\<theta> = cl_ecl C_fo\n  Cl_P = cl_ecl P1\n  orient_lit_inst L1 t s neg \\<theta>\n  ck_unifier t s \\<theta> FirstOrder\n  C_fo = Ecl (subst_cl C' \\<theta>) T'\n  T' =\n  get_trms (subst_cl C' \\<theta>)\n   (dom_trms (subst_cl C' \\<theta>) (subst_set (E \\<union> {t}) \\<theta>))\n   FirstOrder\n  subst_cl C' \\<theta> = subst_cl (Cl_P - {L1}) \\<theta>\n  C' = Cl_P - {L1}\n  E = trms_ecl P1\n\ngoal (1 subgoal):\n 1. \\<exists>L1 t s Cl_P Cl_C trms_C.\n       eligible_literal L1 P1 \\<theta> \\<and>\n       L1 \\<in> cl_ecl P1 \\<and>\n       Cl_C = cl_ecl C_fo \\<and>\n       Cl_P = cl_ecl P1 \\<and>\n       orient_lit_inst L1 t s neg \\<theta> \\<and>\n       ck_unifier t s \\<theta> FirstOrder \\<and>\n       C_fo = Ecl Cl_C trms_C \\<and>\n       trms_C =\n       get_trms Cl_C\n        (dom_trms Cl_C (subst_set (trms_ecl P1 \\<union> {t}) \\<theta>))\n        FirstOrder \\<and>\n       Cl_C = subst_cl C' \\<theta> \\<and> C' = Cl_P - {L1}", "by metis"], ["proof (state)\nthis:\n  reflexion P1 C_fo \\<theta> FirstOrder C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this \\<open>{ P1 } = P\\<close>  \\<open>P \\<subseteq> S\\<close>"], ["proof (chain)\npicking this:\n  reflexion P1 C_fo \\<theta> FirstOrder C'\n  {P1} = P\n  P \\<subseteq> S", "have \"(derivable C_fo P S \\<theta> FirstOrder C')\""], ["proof (prove)\nusing this:\n  reflexion P1 C_fo \\<theta> FirstOrder C'\n  {P1} = P\n  P \\<subseteq> S\n\ngoal (1 subgoal):\n 1. derivable C_fo P S \\<theta> FirstOrder C'", "unfolding derivable_def"], ["proof (prove)\nusing this:\n  reflexion P1 C_fo \\<theta> FirstOrder C'\n  {P1} = P\n  P \\<subseteq> S\n\ngoal (1 subgoal):\n 1. (\\<exists>P1 P2.\n        P1 \\<in> S \\<and>\n        P2 \\<in> S \\<and>\n        P = {P1, P2} \\<and>\n        superposition P1 P2 C_fo \\<theta> FirstOrder C') \\<or>\n    (\\<exists>P1.\n        P1 \\<in> S \\<and>\n        P = {P1} \\<and> factorization P1 C_fo \\<theta> FirstOrder C') \\<or>\n    (\\<exists>P1.\n        P1 \\<in> S \\<and>\n        P = {P1} \\<and> reflexion P1 C_fo \\<theta> FirstOrder C')", "by auto"], ["proof (state)\nthis:\n  derivable C_fo P S \\<theta> FirstOrder C'\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>(?Cl_C' = (subst_cl ((Cl_P - { L1 }) )) \\<theta>)\\<close>"], ["proof (chain)\npicking this:\n  subst_cl C' \\<theta> = subst_cl (Cl_P - {L1}) \\<theta>", "have \n      i: \"(subst_cl ?Cl_C' \\<eta>) = \n      (subst_cl (subst_cl ((Cl_P - { L1 }) ) \\<theta>)) \\<eta>\""], ["proof (prove)\nusing this:\n  subst_cl C' \\<theta> = subst_cl (Cl_P - {L1}) \\<theta>\n\ngoal (1 subgoal):\n 1. subst_cl (subst_cl C' \\<theta>) \\<eta> =\n    subst_cl (subst_cl (Cl_P - {L1}) \\<theta>) \\<eta>", "by auto"], ["proof (state)\nthis:\n  subst_cl (subst_cl C' \\<theta>) \\<eta> =\n  subst_cl (subst_cl (Cl_P - {L1}) \\<theta>) \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "have ii: \"(subst_cl (subst_cl ((Cl_P - { L1 }) ) \\<theta>) \\<eta>)\n      =  (subst_cl ((Cl_P - { L1 }) ) (\\<theta> \\<lozenge> \\<eta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_cl (subst_cl (Cl_P - {L1}) \\<theta>) \\<eta> =\n    subst_cl (Cl_P - {L1}) (\\<theta> \\<lozenge> \\<eta>)", "using composition_of_substs_cl [of \"((Cl_P - { L1 }) )\" ]"], ["proof (prove)\nusing this:\n  subst_cl (subst_cl (Cl_P - {L1}) ?\\<sigma>) ?\\<eta> =\n  subst_cl (Cl_P - {L1}) (?\\<sigma> \\<lozenge> ?\\<eta>)\n\ngoal (1 subgoal):\n 1. subst_cl (subst_cl (Cl_P - {L1}) \\<theta>) \\<eta> =\n    subst_cl (Cl_P - {L1}) (\\<theta> \\<lozenge> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  subst_cl (subst_cl (Cl_P - {L1}) \\<theta>) \\<eta> =\n  subst_cl (Cl_P - {L1}) (\\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>", "have \"(subst_cl((Cl_P - { L1 }) ) \\<sigma>) \n      = (subst_cl ((Cl_P - { L1 }) ) (\\<theta> \\<lozenge> \\<eta>))\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. subst_cl (Cl_P - {L1}) \\<sigma> =\n    subst_cl (Cl_P - {L1}) (\\<theta> \\<lozenge> \\<eta>)", "using subst_eq_cl [of \\<sigma> \"\\<theta> \\<lozenge> \\<eta>\" \"((Cl_P - { L1 }) )\" ]"], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<Longrightarrow>\n  subst_cl (Cl_P - {L1}) \\<sigma> =\n  subst_cl (Cl_P - {L1}) (\\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. subst_cl (Cl_P - {L1}) \\<sigma> =\n    subst_cl (Cl_P - {L1}) (\\<theta> \\<lozenge> \\<eta>)", "by auto"], ["proof (state)\nthis:\n  subst_cl (Cl_P - {L1}) \\<sigma> =\n  subst_cl (Cl_P - {L1}) (\\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this and i ii  \\<open>Cl_C = (subst_cl ((Cl_P - { L1 }) ) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  subst_cl (Cl_P - {L1}) \\<sigma> =\n  subst_cl (Cl_P - {L1}) (\\<theta> \\<lozenge> \\<eta>)\n  subst_cl (subst_cl C' \\<theta>) \\<eta> =\n  subst_cl (subst_cl (Cl_P - {L1}) \\<theta>) \\<eta>\n  subst_cl (subst_cl (Cl_P - {L1}) \\<theta>) \\<eta> =\n  subst_cl (Cl_P - {L1}) (\\<theta> \\<lozenge> \\<eta>)\n  Cl_C = subst_cl (Cl_P - {L1}) \\<sigma>", "have \"(subst_cl ?Cl_C' \\<eta>) = Cl_C\""], ["proof (prove)\nusing this:\n  subst_cl (Cl_P - {L1}) \\<sigma> =\n  subst_cl (Cl_P - {L1}) (\\<theta> \\<lozenge> \\<eta>)\n  subst_cl (subst_cl C' \\<theta>) \\<eta> =\n  subst_cl (subst_cl (Cl_P - {L1}) \\<theta>) \\<eta>\n  subst_cl (subst_cl (Cl_P - {L1}) \\<theta>) \\<eta> =\n  subst_cl (Cl_P - {L1}) (\\<theta> \\<lozenge> \\<eta>)\n  Cl_C = subst_cl (Cl_P - {L1}) \\<sigma>\n\ngoal (1 subgoal):\n 1. subst_cl (subst_cl C' \\<theta>) \\<eta> = Cl_C", "by metis"], ["proof (state)\nthis:\n  subst_cl (subst_cl C' \\<theta>) \\<eta> = Cl_C\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this and \\<open>(C = (Ecl Cl_C trms_C))\\<close> and \\<open>(C_fo = (Ecl ?Cl_C' T'))\\<close>"], ["proof (chain)\npicking this:\n  subst_cl (subst_cl C' \\<theta>) \\<eta> = Cl_C\n  C = Ecl Cl_C trms_C\n  C_fo = Ecl (subst_cl C' \\<theta>) T'", "have \"(subst_cl (cl_ecl C_fo) \\<eta>) = (cl_ecl C)\""], ["proof (prove)\nusing this:\n  subst_cl (subst_cl C' \\<theta>) \\<eta> = Cl_C\n  C = Ecl Cl_C trms_C\n  C_fo = Ecl (subst_cl C' \\<theta>) T'\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl C_fo) \\<eta> = cl_ecl C", "by auto"], ["proof (state)\nthis:\n  subst_cl (cl_ecl C_fo) \\<eta> = cl_ecl C\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>(subst_set T' \\<eta>) \\<subseteq> trms_C\\<close> \n      and \\<open>(C = (Ecl Cl_C trms_C))\\<close> and \\<open>(C_fo = (Ecl ?Cl_C' T'))\\<close>"], ["proof (chain)\npicking this:\n  subst_set T' \\<eta> \\<subseteq> trms_C\n  C = Ecl Cl_C trms_C\n  C_fo = Ecl (subst_cl C' \\<theta>) T'", "have \"(subst_set (trms_ecl C_fo) \\<eta>) \\<subseteq> (trms_ecl C)\""], ["proof (prove)\nusing this:\n  subst_set T' \\<eta> \\<subseteq> trms_C\n  C = Ecl Cl_C trms_C\n  C_fo = Ecl (subst_cl C' \\<theta>) T'\n\ngoal (1 subgoal):\n 1. subst_set (trms_ecl C_fo) \\<eta> \\<subseteq> trms_ecl C", "by auto"], ["proof (state)\nthis:\n  subst_set (trms_ecl C_fo) \\<eta> \\<subseteq> trms_ecl C\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from \\<open>(subst_cl (cl_ecl C_fo) \\<eta>) = (cl_ecl C)\\<close> \n        \\<open>(subst_set (trms_ecl C_fo) \\<eta>) \\<subseteq> (trms_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  subst_cl (cl_ecl C_fo) \\<eta> = cl_ecl C\n  subst_set (trms_ecl C_fo) \\<eta> \\<subseteq> trms_ecl C", "have \"(trms_subsumes C_fo C \\<eta>)\""], ["proof (prove)\nusing this:\n  subst_cl (cl_ecl C_fo) \\<eta> = cl_ecl C\n  subst_set (trms_ecl C_fo) \\<eta> \\<subseteq> trms_ecl C\n\ngoal (1 subgoal):\n 1. trms_subsumes C_fo C \\<eta>", "unfolding trms_subsumes_def"], ["proof (prove)\nusing this:\n  subst_cl (cl_ecl C_fo) \\<eta> = cl_ecl C\n  subst_set (trms_ecl C_fo) \\<eta> \\<subseteq> trms_ecl C\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl C_fo) \\<eta> = cl_ecl C \\<and>\n    subst_set (trms_ecl C_fo) \\<eta> \\<subseteq> trms_ecl C", "by auto"], ["proof (state)\nthis:\n  trms_subsumes C_fo C \\<eta>\n\ngoal (1 subgoal):\n 1. \\<exists>P1.\n       {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C' \\<Longrightarrow>\n    False", "from this and \\<open>(derivable C_fo P S \\<theta> FirstOrder C')\\<close> and \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close> and hyp"], ["proof (chain)\npicking this:\n  trms_subsumes C_fo C \\<eta>\n  derivable C_fo P S \\<theta> FirstOrder C'\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  \\<nexists>D \\<theta> \\<eta>.\n     derivable D P S \\<theta> FirstOrder C' \\<and>\n     \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<and>\n     trms_subsumes D C \\<eta>", "show False"], ["proof (prove)\nusing this:\n  trms_subsumes C_fo C \\<eta>\n  derivable C_fo P S \\<theta> FirstOrder C'\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  \\<nexists>D \\<theta> \\<eta>.\n     derivable D P S \\<theta> FirstOrder C' \\<and>\n     \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<and>\n     trms_subsumes D C \\<eta>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>P1. {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. \\<nexists>D \\<theta> \\<eta>.\n       derivable D P S \\<theta> FirstOrder C' \\<and>\n       \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<and>\n       trms_subsumes D C \\<eta> \\<Longrightarrow>\n    False", "from not_sup not_ref not_fact and assms(1)"], ["proof (chain)\npicking this:\n  \\<nexists>P1 P2.\n     P = {P1, P2} \\<and> superposition P1 P2 C \\<sigma> Ground C'\n  \\<nexists>P1. {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C'\n  \\<nexists>P1. {P1} = P \\<and> factorization P1 C \\<sigma> Ground C'\n  derivable C P S \\<sigma> Ground C'", "show False"], ["proof (prove)\nusing this:\n  \\<nexists>P1 P2.\n     P = {P1, P2} \\<and> superposition P1 P2 C \\<sigma> Ground C'\n  \\<nexists>P1. {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C'\n  \\<nexists>P1. {P1} = P \\<and> factorization P1 C \\<sigma> Ground C'\n  derivable C P S \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. False", "unfolding derivable_def"], ["proof (prove)\nusing this:\n  \\<nexists>P1 P2.\n     P = {P1, P2} \\<and> superposition P1 P2 C \\<sigma> Ground C'\n  \\<nexists>P1. {P1} = P \\<and> reflexion P1 C \\<sigma> Ground C'\n  \\<nexists>P1. {P1} = P \\<and> factorization P1 C \\<sigma> Ground C'\n  (\\<exists>P1 P2.\n      P1 \\<in> S \\<and>\n      P2 \\<in> S \\<and>\n      P = {P1, P2} \\<and> superposition P1 P2 C \\<sigma> Ground C') \\<or>\n  (\\<exists>P1.\n      P1 \\<in> S \\<and>\n      P = {P1} \\<and> factorization P1 C \\<sigma> Ground C') \\<or>\n  (\\<exists>P1.\n      P1 \\<in> S \\<and> P = {P1} \\<and> reflexion P1 C \\<sigma> Ground C')\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trms_subsumes_and_red_inf:\n  assumes \"trms_subsumes D C \\<eta>\"\n  assumes \"redundant_inference (subst_ecl D \\<eta>) S P \\<sigma>\"\n  assumes \"\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\"\n  shows \"redundant_inference C S P \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redundant_inference C S P \\<sigma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. redundant_inference C S P \\<sigma>", "from assms(2)"], ["proof (chain)\npicking this:\n  redundant_inference (subst_ecl D \\<eta>) S P \\<sigma>", "obtain S' where \"S' \\<subseteq> (instances S)\" \n    \"(set_entails_clause (clset_instances S') (cl_ecl (subst_ecl D \\<eta>)))\"\n    \"(\\<forall>x \\<in> S'. ( subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) \n              (trms_ecl (subst_ecl D \\<eta>))))\"\n    \"(\\<forall>x \\<in> S'. \\<exists>D' \\<in> P. (((fst x),(snd x)),(D',\\<sigma>)) \\<in> ecl_ord)\""], ["proof (prove)\nusing this:\n  redundant_inference (subst_ecl D \\<eta>) S P \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>S'.\n        \\<lbrakk>S' \\<subseteq> instances S;\n         set_entails_clause (clset_instances S')\n          (cl_ecl (subst_ecl D \\<eta>));\n         \\<forall>x\\<in>S'.\n            subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n             (trms_ecl (subst_ecl D \\<eta>));\n         \\<forall>x\\<in>S'.\n            \\<exists>D'\\<in>P.\n               ((fst x, snd x), D', \\<sigma>) \\<in> ecl_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding redundant_inference_def"], ["proof (prove)\nusing this:\n  \\<exists>S'\\<subseteq>instances S.\n     set_entails_clause (clset_instances S')\n      (cl_ecl (subst_ecl D \\<eta>)) \\<and>\n     (\\<forall>x\\<in>S'.\n         subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n          (trms_ecl (subst_ecl D \\<eta>))) \\<and>\n     (\\<forall>x\\<in>S'.\n         \\<exists>D'\\<in>P. ((fst x, snd x), D', \\<sigma>) \\<in> ecl_ord)\n\ngoal (1 subgoal):\n 1. (\\<And>S'.\n        \\<lbrakk>S' \\<subseteq> instances S;\n         set_entails_clause (clset_instances S')\n          (cl_ecl (subst_ecl D \\<eta>));\n         \\<forall>x\\<in>S'.\n            subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n             (trms_ecl (subst_ecl D \\<eta>));\n         \\<forall>x\\<in>S'.\n            \\<exists>D'\\<in>P.\n               ((fst x, snd x), D', \\<sigma>) \\<in> ecl_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  S' \\<subseteq> instances S\n  set_entails_clause (clset_instances S') (cl_ecl (subst_ecl D \\<eta>))\n  \\<forall>x\\<in>S'.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n      (trms_ecl (subst_ecl D \\<eta>))\n  \\<forall>x\\<in>S'.\n     \\<exists>D'\\<in>P. ((fst x, snd x), D', \\<sigma>) \\<in> ecl_ord\n\ngoal (1 subgoal):\n 1. redundant_inference C S P \\<sigma>", "from assms(1)"], ["proof (chain)\npicking this:\n  trms_subsumes D C \\<eta>", "have \"(subst_cl (cl_ecl D) \\<eta>) = (cl_ecl C)\""], ["proof (prove)\nusing this:\n  trms_subsumes D C \\<eta>\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl D) \\<eta> = cl_ecl C", "unfolding trms_subsumes_def"], ["proof (prove)\nusing this:\n  subst_cl (cl_ecl D) \\<eta> = cl_ecl C \\<and>\n  subst_set (trms_ecl D) \\<eta> \\<subseteq> trms_ecl C\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl D) \\<eta> = cl_ecl C", "by auto"], ["proof (state)\nthis:\n  subst_cl (cl_ecl D) \\<eta> = cl_ecl C\n\ngoal (1 subgoal):\n 1. redundant_inference C S P \\<sigma>", "obtain Cl_D T where \"D = Ecl Cl_D T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Cl_D T.\n        D = Ecl Cl_D T \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using eclause.exhaust"], ["proof (prove)\nusing this:\n  (\\<And>x1 x2. ?y = Ecl x1 x2 \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>Cl_D T.\n        D = Ecl Cl_D T \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  D = Ecl Cl_D T\n\ngoal (1 subgoal):\n 1. redundant_inference C S P \\<sigma>", "from this"], ["proof (chain)\npicking this:\n  D = Ecl Cl_D T", "have \"(cl_ecl D) = Cl_D\" and \"trms_ecl D = T\""], ["proof (prove)\nusing this:\n  D = Ecl Cl_D T\n\ngoal (1 subgoal):\n 1. cl_ecl D = Cl_D &&& trms_ecl D = T", "by auto"], ["proof (state)\nthis:\n  cl_ecl D = Cl_D\n  trms_ecl D = T\n\ngoal (1 subgoal):\n 1. redundant_inference C S P \\<sigma>", "from \\<open>D = Ecl Cl_D T\\<close>"], ["proof (chain)\npicking this:\n  D = Ecl Cl_D T", "have \"subst_ecl D \\<eta> = Ecl (subst_cl Cl_D \\<eta>) (subst_set T \\<eta>)\""], ["proof (prove)\nusing this:\n  D = Ecl Cl_D T\n\ngoal (1 subgoal):\n 1. subst_ecl D \\<eta> = Ecl (subst_cl Cl_D \\<eta>) (subst_set T \\<eta>)", "by auto"], ["proof (state)\nthis:\n  subst_ecl D \\<eta> = Ecl (subst_cl Cl_D \\<eta>) (subst_set T \\<eta>)\n\ngoal (1 subgoal):\n 1. redundant_inference C S P \\<sigma>", "from this"], ["proof (chain)\npicking this:\n  subst_ecl D \\<eta> = Ecl (subst_cl Cl_D \\<eta>) (subst_set T \\<eta>)", "have \"(cl_ecl (subst_ecl D \\<eta>)) = (subst_cl Cl_D \\<eta>)\" \n    and \"trms_ecl (subst_ecl D \\<eta>) = (subst_set T \\<eta>)\""], ["proof (prove)\nusing this:\n  subst_ecl D \\<eta> = Ecl (subst_cl Cl_D \\<eta>) (subst_set T \\<eta>)\n\ngoal (1 subgoal):\n 1. cl_ecl (subst_ecl D \\<eta>) = subst_cl Cl_D \\<eta> &&&\n    trms_ecl (subst_ecl D \\<eta>) = subst_set T \\<eta>", "by auto"], ["proof (state)\nthis:\n  cl_ecl (subst_ecl D \\<eta>) = subst_cl Cl_D \\<eta>\n  trms_ecl (subst_ecl D \\<eta>) = subst_set T \\<eta>\n\ngoal (1 subgoal):\n 1. redundant_inference C S P \\<sigma>", "from \\<open>(cl_ecl (subst_ecl D \\<eta>)) = (subst_cl Cl_D \\<eta>)\\<close>\n    and \\<open>(cl_ecl D) = Cl_D\\<close> \\<open>(subst_cl (cl_ecl D) \\<eta>) = (cl_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  cl_ecl (subst_ecl D \\<eta>) = subst_cl Cl_D \\<eta>\n  cl_ecl D = Cl_D\n  subst_cl (cl_ecl D) \\<eta> = cl_ecl C", "have \"(cl_ecl (subst_ecl D \\<eta>)) = (cl_ecl C)\""], ["proof (prove)\nusing this:\n  cl_ecl (subst_ecl D \\<eta>) = subst_cl Cl_D \\<eta>\n  cl_ecl D = Cl_D\n  subst_cl (cl_ecl D) \\<eta> = cl_ecl C\n\ngoal (1 subgoal):\n 1. cl_ecl (subst_ecl D \\<eta>) = cl_ecl C", "by auto"], ["proof (state)\nthis:\n  cl_ecl (subst_ecl D \\<eta>) = cl_ecl C\n\ngoal (1 subgoal):\n 1. redundant_inference C S P \\<sigma>", "from this and \\<open>(set_entails_clause (clset_instances S') (cl_ecl (subst_ecl D \\<eta>)))\\<close>"], ["proof (chain)\npicking this:\n  cl_ecl (subst_ecl D \\<eta>) = cl_ecl C\n  set_entails_clause (clset_instances S') (cl_ecl (subst_ecl D \\<eta>))", "have \"(set_entails_clause (clset_instances S') (cl_ecl C))\""], ["proof (prove)\nusing this:\n  cl_ecl (subst_ecl D \\<eta>) = cl_ecl C\n  set_entails_clause (clset_instances S') (cl_ecl (subst_ecl D \\<eta>))\n\ngoal (1 subgoal):\n 1. set_entails_clause (clset_instances S') (cl_ecl C)", "by auto"], ["proof (state)\nthis:\n  set_entails_clause (clset_instances S') (cl_ecl C)\n\ngoal (1 subgoal):\n 1. redundant_inference C S P \\<sigma>", "from \\<open>trms_ecl D = T\\<close> and \\<open>trms_ecl (subst_ecl D \\<eta>) = (subst_set T \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  trms_ecl D = T\n  trms_ecl (subst_ecl D \\<eta>) = subst_set T \\<eta>", "have \"trms_ecl (subst_ecl D \\<eta>) = (subst_set (trms_ecl D) \\<eta>)\""], ["proof (prove)\nusing this:\n  trms_ecl D = T\n  trms_ecl (subst_ecl D \\<eta>) = subst_set T \\<eta>\n\ngoal (1 subgoal):\n 1. trms_ecl (subst_ecl D \\<eta>) = subst_set (trms_ecl D) \\<eta>", "by auto"], ["proof (state)\nthis:\n  trms_ecl (subst_ecl D \\<eta>) = subst_set (trms_ecl D) \\<eta>\n\ngoal (1 subgoal):\n 1. redundant_inference C S P \\<sigma>", "from assms(1)"], ["proof (chain)\npicking this:\n  trms_subsumes D C \\<eta>", "have \"(subst_set (trms_ecl D) \\<eta>) \\<subseteq> (trms_ecl C)\""], ["proof (prove)\nusing this:\n  trms_subsumes D C \\<eta>\n\ngoal (1 subgoal):\n 1. subst_set (trms_ecl D) \\<eta> \\<subseteq> trms_ecl C", "unfolding trms_subsumes_def"], ["proof (prove)\nusing this:\n  subst_cl (cl_ecl D) \\<eta> = cl_ecl C \\<and>\n  subst_set (trms_ecl D) \\<eta> \\<subseteq> trms_ecl C\n\ngoal (1 subgoal):\n 1. subst_set (trms_ecl D) \\<eta> \\<subseteq> trms_ecl C", "by auto"], ["proof (state)\nthis:\n  subst_set (trms_ecl D) \\<eta> \\<subseteq> trms_ecl C\n\ngoal (1 subgoal):\n 1. redundant_inference C S P \\<sigma>", "have ii: \"(\\<forall>x \\<in> S'. ( subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) \n              (trms_ecl C)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S'.\n       subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n        (trms_ecl C)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>S'.\n               subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n                (trms_ecl C)) \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<forall>x \\<in> S'. ( subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) \n              (trms_ecl C)))\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>x\\<in>S'.\n             subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n              (trms_ecl C))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>S'.\n               subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n                (trms_ecl C)) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>x\\<in>S'.\n             subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n              (trms_ecl C))", "obtain x where \"x \\<in> S'\" and \n      \"\\<not>( subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) (trms_ecl C))\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x\\<in>S'.\n             subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n              (trms_ecl C))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> S';\n         \\<not> subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n                 (trms_ecl C)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> S'\n  \\<not> subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n          (trms_ecl C)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>S'.\n               subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n                (trms_ecl C)) \\<Longrightarrow>\n    False", "from \\<open>x \\<in> S'\\<close> and \\<open>(\\<forall>x \\<in> S'. ( subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) \n              (trms_ecl (subst_ecl D \\<eta>))))\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> S'\n  \\<forall>x\\<in>S'.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n      (trms_ecl (subst_ecl D \\<eta>))", "have \"( subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) \n              (trms_ecl (subst_ecl D \\<eta>)))\""], ["proof (prove)\nusing this:\n  x \\<in> S'\n  \\<forall>x\\<in>S'.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n      (trms_ecl (subst_ecl D \\<eta>))\n\ngoal (1 subgoal):\n 1. subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n     (trms_ecl (subst_ecl D \\<eta>))", "by auto"], ["proof (state)\nthis:\n  subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n   (trms_ecl (subst_ecl D \\<eta>))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>S'.\n               subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n                (trms_ecl C)) \\<Longrightarrow>\n    False", "obtain E1 where \"E1 = (subst_set (trms_ecl (fst x)) (snd x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>E1.\n        E1 = subst_set (trms_ecl (fst x)) (snd x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  E1 = subst_set (trms_ecl (fst x)) (snd x)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>S'.\n               subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n                (trms_ecl C)) \\<Longrightarrow>\n    False", "obtain E2 where \"E2 = (subst_set (trms_ecl D) \\<eta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>E2.\n        E2 = subst_set (trms_ecl D) \\<eta> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  E2 = subst_set (trms_ecl D) \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>S'.\n               subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n                (trms_ecl C)) \\<Longrightarrow>\n    False", "obtain E2' where \"E2' = (trms_ecl C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>E2'. E2' = trms_ecl C \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  E2' = trms_ecl C\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>S'.\n               subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n                (trms_ecl C)) \\<Longrightarrow>\n    False", "from \\<open>E2 = (subst_set (trms_ecl D) \\<eta>)\\<close> \\<open>E2' = (trms_ecl C)\\<close> \n          \\<open>(subst_set (trms_ecl D) \\<eta>) \\<subseteq> (trms_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  E2 = subst_set (trms_ecl D) \\<eta>\n  E2' = trms_ecl C\n  subst_set (trms_ecl D) \\<eta> \\<subseteq> trms_ecl C", "have \"E2 \\<subseteq> E2'\""], ["proof (prove)\nusing this:\n  E2 = subst_set (trms_ecl D) \\<eta>\n  E2' = trms_ecl C\n  subst_set (trms_ecl D) \\<eta> \\<subseteq> trms_ecl C\n\ngoal (1 subgoal):\n 1. E2 \\<subseteq> E2'", "by auto"], ["proof (state)\nthis:\n  E2 \\<subseteq> E2'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>S'.\n               subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n                (trms_ecl C)) \\<Longrightarrow>\n    False", "from \\<open>E1 = (subst_set (trms_ecl (fst x)) (snd x))\\<close> \n         \\<open>E2 = (subst_set (trms_ecl D) \\<eta>)\\<close> \n         \\<open>trms_ecl (subst_ecl D \\<eta>) = (subst_set (trms_ecl D) \\<eta>)\\<close> \n         \\<open>( subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) \n              (trms_ecl (subst_ecl D \\<eta>)))\\<close>"], ["proof (chain)\npicking this:\n  E1 = subst_set (trms_ecl (fst x)) (snd x)\n  E2 = subst_set (trms_ecl D) \\<eta>\n  trms_ecl (subst_ecl D \\<eta>) = subst_set (trms_ecl D) \\<eta>\n  subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n   (trms_ecl (subst_ecl D \\<eta>))", "have \"subterms_inclusion E1 E2\""], ["proof (prove)\nusing this:\n  E1 = subst_set (trms_ecl (fst x)) (snd x)\n  E2 = subst_set (trms_ecl D) \\<eta>\n  trms_ecl (subst_ecl D \\<eta>) = subst_set (trms_ecl D) \\<eta>\n  subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n   (trms_ecl (subst_ecl D \\<eta>))\n\ngoal (1 subgoal):\n 1. subterms_inclusion E1 E2", "by auto"], ["proof (state)\nthis:\n  subterms_inclusion E1 E2\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>S'.\n               subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n                (trms_ecl C)) \\<Longrightarrow>\n    False", "from this and \\<open>E2 \\<subseteq> E2'\\<close>"], ["proof (chain)\npicking this:\n  subterms_inclusion E1 E2\n  E2 \\<subseteq> E2'", "have \"subterms_inclusion E1 E2'\""], ["proof (prove)\nusing this:\n  subterms_inclusion E1 E2\n  E2 \\<subseteq> E2'\n\ngoal (1 subgoal):\n 1. subterms_inclusion E1 E2'", "using subterms_inclusion_subset"], ["proof (prove)\nusing this:\n  subterms_inclusion E1 E2\n  E2 \\<subseteq> E2'\n  \\<lbrakk>subterms_inclusion ?E1.0 ?E2.0; ?E2.0 \\<subseteq> ?E2'\\<rbrakk>\n  \\<Longrightarrow> subterms_inclusion ?E1.0 ?E2'\n\ngoal (1 subgoal):\n 1. subterms_inclusion E1 E2'", "by auto"], ["proof (state)\nthis:\n  subterms_inclusion E1 E2'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>S'.\n               subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n                (trms_ecl C)) \\<Longrightarrow>\n    False", "from this and \\<open>E1 = (subst_set (trms_ecl (fst x)) (snd x))\\<close> \\<open>E2' = (trms_ecl C)\\<close>\n      and \\<open>\\<not>( subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) \n              (trms_ecl C))\\<close>"], ["proof (chain)\npicking this:\n  subterms_inclusion E1 E2'\n  E1 = subst_set (trms_ecl (fst x)) (snd x)\n  E2' = trms_ecl C\n  \\<not> subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n          (trms_ecl C)", "show False"], ["proof (prove)\nusing this:\n  subterms_inclusion E1 E2'\n  E1 = subst_set (trms_ecl (fst x)) (snd x)\n  E2' = trms_ecl C\n  \\<not> subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n          (trms_ecl C)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S'.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) (trms_ecl C)\n\ngoal (1 subgoal):\n 1. redundant_inference C S P \\<sigma>", "from this and \\<open>(set_entails_clause (clset_instances S') (cl_ecl C))\\<close> \n      and \\<open>(\\<forall>x \\<in> S'. \\<exists>D' \\<in> P. (((fst x),(snd x)),(D',\\<sigma>)) \\<in> ecl_ord)\\<close>\n      and \\<open>S' \\<subseteq> (instances S)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S'.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) (trms_ecl C)\n  set_entails_clause (clset_instances S') (cl_ecl C)\n  \\<forall>x\\<in>S'.\n     \\<exists>D'\\<in>P. ((fst x, snd x), D', \\<sigma>) \\<in> ecl_ord\n  S' \\<subseteq> instances S", "show \"redundant_inference C S P \\<sigma>\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S'.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) (trms_ecl C)\n  set_entails_clause (clset_instances S') (cl_ecl C)\n  \\<forall>x\\<in>S'.\n     \\<exists>D'\\<in>P. ((fst x, snd x), D', \\<sigma>) \\<in> ecl_ord\n  S' \\<subseteq> instances S\n\ngoal (1 subgoal):\n 1. redundant_inference C S P \\<sigma>", "unfolding redundant_inference_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S'.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) (trms_ecl C)\n  set_entails_clause (clset_instances S') (cl_ecl C)\n  \\<forall>x\\<in>S'.\n     \\<exists>D'\\<in>P. ((fst x, snd x), D', \\<sigma>) \\<in> ecl_ord\n  S' \\<subseteq> instances S\n\ngoal (1 subgoal):\n 1. \\<exists>S'\\<subseteq>instances S.\n       set_entails_clause (clset_instances S') (cl_ecl C) \\<and>\n       (\\<forall>x\\<in>S'.\n           subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n            (trms_ecl C)) \\<and>\n       (\\<forall>x\\<in>S'.\n           \\<exists>D'\\<in>P. ((fst x, snd x), D', \\<sigma>) \\<in> ecl_ord)", "by auto"], ["proof (state)\nthis:\n  redundant_inference C S P \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_inference:\n  assumes \"inference_saturated S\"\n  shows \"ground_inference_saturated S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ground_inference_saturated S", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ground_inference_saturated S \\<Longrightarrow> False", "assume \"\\<not> (ground_inference_saturated S)\""], ["proof (state)\nthis:\n  \\<not> ground_inference_saturated S\n\ngoal (1 subgoal):\n 1. \\<not> ground_inference_saturated S \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  \\<not> ground_inference_saturated S", "obtain C P \\<sigma> C' where \"derivable C P S \\<sigma> Ground C'\" \"ground_clause (cl_ecl C)\" \n    \"grounding_set P \\<sigma>\" \"\\<not>redundant_inference C S P \\<sigma>\""], ["proof (prove)\nusing this:\n  \\<not> ground_inference_saturated S\n\ngoal (1 subgoal):\n 1. (\\<And>C P \\<sigma> C'.\n        \\<lbrakk>derivable C P S \\<sigma> Ground C';\n         ground_clause (cl_ecl C); grounding_set P \\<sigma>;\n         \\<not> redundant_inference C S P \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ground_inference_saturated_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>C P \\<sigma> C'.\n             derivable C P S \\<sigma> Ground C' \\<longrightarrow>\n             ground_clause (cl_ecl C) \\<longrightarrow>\n             grounding_set P \\<sigma> \\<longrightarrow>\n             redundant_inference C S P \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>C P \\<sigma> C'.\n        \\<lbrakk>derivable C P S \\<sigma> Ground C';\n         ground_clause (cl_ecl C); grounding_set P \\<sigma>;\n         \\<not> redundant_inference C S P \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  derivable C P S \\<sigma> Ground C'\n  ground_clause (cl_ecl C)\n  grounding_set P \\<sigma>\n  \\<not> redundant_inference C S P \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> ground_inference_saturated S \\<Longrightarrow> False", "from \\<open>derivable C P S \\<sigma> Ground C'\\<close>"], ["proof (chain)\npicking this:\n  derivable C P S \\<sigma> Ground C'", "obtain D \\<theta> \\<eta> where \"derivable D P S \\<theta> FirstOrder C'\" \n    \"\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\" \"trms_subsumes D C \\<eta>\""], ["proof (prove)\nusing this:\n  derivable C P S \\<sigma> Ground C'\n\ngoal (1 subgoal):\n 1. (\\<And>D \\<theta> \\<eta>.\n        \\<lbrakk>derivable D P S \\<theta> FirstOrder C';\n         \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>;\n         trms_subsumes D C \\<eta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using lifting_lemma"], ["proof (prove)\nusing this:\n  derivable C P S \\<sigma> Ground C'\n  derivable ?C ?P ?S ?\\<sigma> Ground ?C' \\<Longrightarrow>\n  \\<exists>D \\<theta> \\<eta>.\n     derivable D ?P ?S \\<theta> FirstOrder ?C' \\<and>\n     ?\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<and>\n     trms_subsumes D ?C \\<eta>\n\ngoal (1 subgoal):\n 1. (\\<And>D \\<theta> \\<eta>.\n        \\<lbrakk>derivable D P S \\<theta> FirstOrder C';\n         \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>;\n         trms_subsumes D C \\<eta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  derivable D P S \\<theta> FirstOrder C'\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  trms_subsumes D C \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> ground_inference_saturated S \\<Longrightarrow> False", "from \\<open>trms_subsumes D C \\<eta>\\<close> and \\<open>\\<not>redundant_inference C S P \\<sigma>\\<close>  \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  trms_subsumes D C \\<eta>\n  \\<not> redundant_inference C S P \\<sigma>\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>", "have \"\\<not> redundant_inference (subst_ecl D \\<eta>) S P \\<sigma>\""], ["proof (prove)\nusing this:\n  trms_subsumes D C \\<eta>\n  \\<not> redundant_inference C S P \\<sigma>\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> redundant_inference (subst_ecl D \\<eta>) S P \\<sigma>", "using trms_subsumes_and_red_inf"], ["proof (prove)\nusing this:\n  trms_subsumes D C \\<eta>\n  \\<not> redundant_inference C S P \\<sigma>\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  \\<lbrakk>trms_subsumes ?D ?C ?\\<eta>;\n   redundant_inference (subst_ecl ?D ?\\<eta>) ?S ?P ?\\<sigma>;\n   ?\\<sigma> \\<doteq> ?\\<theta> \\<lozenge> ?\\<eta>\\<rbrakk>\n  \\<Longrightarrow> redundant_inference ?C ?S ?P ?\\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> redundant_inference (subst_ecl D \\<eta>) S P \\<sigma>", "by auto"], ["proof (state)\nthis:\n  \\<not> redundant_inference (subst_ecl D \\<eta>) S P \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> ground_inference_saturated S \\<Longrightarrow> False", "from this and \\<open>derivable C P S \\<sigma> Ground C'\\<close> \\<open>derivable D P S \\<theta> FirstOrder C'\\<close> \\<open>trms_subsumes D C \\<eta>\\<close>\n   \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close> \\<open>ground_clause (cl_ecl C)\\<close> \\<open>grounding_set P \\<sigma>\\<close> \n   \\<open>\\<not> redundant_inference (subst_ecl D \\<eta>) S P \\<sigma>\\<close>\n    assms(1)"], ["proof (chain)\npicking this:\n  \\<not> redundant_inference (subst_ecl D \\<eta>) S P \\<sigma>\n  derivable C P S \\<sigma> Ground C'\n  derivable D P S \\<theta> FirstOrder C'\n  trms_subsumes D C \\<eta>\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  ground_clause (cl_ecl C)\n  grounding_set P \\<sigma>\n  \\<not> redundant_inference (subst_ecl D \\<eta>) S P \\<sigma>\n  inference_saturated S", "show False"], ["proof (prove)\nusing this:\n  \\<not> redundant_inference (subst_ecl D \\<eta>) S P \\<sigma>\n  derivable C P S \\<sigma> Ground C'\n  derivable D P S \\<theta> FirstOrder C'\n  trms_subsumes D C \\<eta>\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  ground_clause (cl_ecl C)\n  grounding_set P \\<sigma>\n  \\<not> redundant_inference (subst_ecl D \\<eta>) S P \\<sigma>\n  inference_saturated S\n\ngoal (1 subgoal):\n 1. False", "unfolding inference_saturated_def"], ["proof (prove)\nusing this:\n  \\<not> redundant_inference (subst_ecl D \\<eta>) S P \\<sigma>\n  derivable C P S \\<sigma> Ground C'\n  derivable D P S \\<theta> FirstOrder C'\n  trms_subsumes D C \\<eta>\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  ground_clause (cl_ecl C)\n  grounding_set P \\<sigma>\n  \\<not> redundant_inference (subst_ecl D \\<eta>) S P \\<sigma>\n  \\<forall>C P \\<sigma> C' D \\<theta> \\<eta>.\n     derivable C P S \\<sigma> Ground C' \\<longrightarrow>\n     ground_clause (cl_ecl C) \\<longrightarrow>\n     grounding_set P \\<sigma> \\<longrightarrow>\n     derivable D P S \\<theta> FirstOrder C' \\<longrightarrow>\n     trms_subsumes D C \\<eta> \\<longrightarrow>\n     \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<longrightarrow>\n     redundant_inference (subst_ecl D \\<eta>) S P \\<sigma>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_redundant_cl :\n  assumes \"C' = subst_cl D \\<theta>\" \n  assumes \"redundant_clause C S \\<eta> C'\" \n  assumes \"\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\"\n  assumes \"finite D\"\n  shows \"redundant_clause C S \\<sigma> D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. redundant_clause C S \\<sigma> D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. redundant_clause C S \\<sigma> D", "from assms(2)"], ["proof (chain)\npicking this:\n  redundant_clause C S \\<eta> C'", "have \n    \"(\\<exists>S'. (S' \\<subseteq> (instances S) \\<and> (set_entails_clause (clset_instances S') (cl_ecl C)) \\<and> \n            (\\<forall>x \\<in> S'. ( subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) \n              (trms_ecl C))) \\<and>\n            (\\<forall>x \\<in> S'. ( ((mset_ecl ((fst x),(snd x))),(mset_cl (C',\\<eta>))) \\<in> (mult (mult trm_ord))\n              \\<or> (mset_ecl ((fst x),(snd x))) = mset_cl (C',\\<eta>)))))\""], ["proof (prove)\nusing this:\n  redundant_clause C S \\<eta> C'\n\ngoal (1 subgoal):\n 1. \\<exists>S'\\<subseteq>instances S.\n       set_entails_clause (clset_instances S') (cl_ecl C) \\<and>\n       (\\<forall>x\\<in>S'.\n           subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n            (trms_ecl C)) \\<and>\n       (\\<forall>x\\<in>S'.\n           (mset_ecl (fst x, snd x), mset_cl (C', \\<eta>))\n           \\<in> mult (mult trm_ord) \\<or>\n           mset_ecl (fst x, snd x) = mset_cl (C', \\<eta>))", "unfolding  redundant_clause_def"], ["proof (prove)\nusing this:\n  \\<exists>S'\\<subseteq>instances S.\n     set_entails_clause (clset_instances S') (cl_ecl C) \\<and>\n     (\\<forall>x\\<in>S'.\n         subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n          (trms_ecl C)) \\<and>\n     (\\<forall>x\\<in>S'.\n         (mset_ecl (fst x, snd x), mset_cl (C', \\<eta>))\n         \\<in> mult (mult trm_ord) \\<or>\n         mset_ecl (fst x, snd x) = mset_cl (C', \\<eta>))\n\ngoal (1 subgoal):\n 1. \\<exists>S'\\<subseteq>instances S.\n       set_entails_clause (clset_instances S') (cl_ecl C) \\<and>\n       (\\<forall>x\\<in>S'.\n           subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n            (trms_ecl C)) \\<and>\n       (\\<forall>x\\<in>S'.\n           (mset_ecl (fst x, snd x), mset_cl (C', \\<eta>))\n           \\<in> mult (mult trm_ord) \\<or>\n           mset_ecl (fst x, snd x) = mset_cl (C', \\<eta>))", "by auto"], ["proof (state)\nthis:\n  \\<exists>S'\\<subseteq>instances S.\n     set_entails_clause (clset_instances S') (cl_ecl C) \\<and>\n     (\\<forall>x\\<in>S'.\n         subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n          (trms_ecl C)) \\<and>\n     (\\<forall>x\\<in>S'.\n         (mset_ecl (fst x, snd x), mset_cl (C', \\<eta>))\n         \\<in> mult (mult trm_ord) \\<or>\n         mset_ecl (fst x, snd x) = mset_cl (C', \\<eta>))\n\ngoal (1 subgoal):\n 1. redundant_clause C S \\<sigma> D", "from this"], ["proof (chain)\npicking this:\n  \\<exists>S'\\<subseteq>instances S.\n     set_entails_clause (clset_instances S') (cl_ecl C) \\<and>\n     (\\<forall>x\\<in>S'.\n         subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n          (trms_ecl C)) \\<and>\n     (\\<forall>x\\<in>S'.\n         (mset_ecl (fst x, snd x), mset_cl (C', \\<eta>))\n         \\<in> mult (mult trm_ord) \\<or>\n         mset_ecl (fst x, snd x) = mset_cl (C', \\<eta>))", "obtain S' where i: \"S' \\<subseteq> (instances S)\" \n    and ii: \"(set_entails_clause (clset_instances S') (cl_ecl C))\"\n  and iii: \"(\\<forall>x \\<in> S'. ( subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) \n              (trms_ecl C)))\"\n  and \n  iv: \"(\\<forall>x \\<in> S'. ( ((mset_ecl ((fst x),(snd x))),(mset_cl (C',\\<eta>))) \\<in> (mult (mult trm_ord))\n              \\<or> (mset_ecl ((fst x),(snd x))) = mset_cl (C',\\<eta>)))\""], ["proof (prove)\nusing this:\n  \\<exists>S'\\<subseteq>instances S.\n     set_entails_clause (clset_instances S') (cl_ecl C) \\<and>\n     (\\<forall>x\\<in>S'.\n         subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n          (trms_ecl C)) \\<and>\n     (\\<forall>x\\<in>S'.\n         (mset_ecl (fst x, snd x), mset_cl (C', \\<eta>))\n         \\<in> mult (mult trm_ord) \\<or>\n         mset_ecl (fst x, snd x) = mset_cl (C', \\<eta>))\n\ngoal (1 subgoal):\n 1. (\\<And>S'.\n        \\<lbrakk>S' \\<subseteq> instances S;\n         set_entails_clause (clset_instances S') (cl_ecl C);\n         \\<forall>x\\<in>S'.\n            subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n             (trms_ecl C);\n         \\<forall>x\\<in>S'.\n            (mset_ecl (fst x, snd x), mset_cl (C', \\<eta>))\n            \\<in> mult (mult trm_ord) \\<or>\n            mset_ecl (fst x, snd x) = mset_cl (C', \\<eta>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  S' \\<subseteq> instances S\n  set_entails_clause (clset_instances S') (cl_ecl C)\n  \\<forall>x\\<in>S'.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) (trms_ecl C)\n  \\<forall>x\\<in>S'.\n     (mset_ecl (fst x, snd x), mset_cl (C', \\<eta>))\n     \\<in> mult (mult trm_ord) \\<or>\n     mset_ecl (fst x, snd x) = mset_cl (C', \\<eta>)\n\ngoal (1 subgoal):\n 1. redundant_clause C S \\<sigma> D", "let ?m1 = \"mset_cl (C',\\<eta>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. redundant_clause C S \\<sigma> D", "let ?m2 = \"mset_cl (D,\\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. redundant_clause C S \\<sigma> D", "from assms(1) assms(3) assms(4)"], ["proof (chain)\npicking this:\n  C' = subst_cl D \\<theta>\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  finite D", "have \"mset_cl (C',\\<eta>) = mset_cl (D,\\<sigma>) \\<or> (mset_cl (C',\\<eta>),mset_cl (D,\\<sigma>)) \\<in> (mult (mult trm_ord))\""], ["proof (prove)\nusing this:\n  C' = subst_cl D \\<theta>\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  finite D\n\ngoal (1 subgoal):\n 1. mset_cl (C', \\<eta>) = mset_cl (D, \\<sigma>) \\<or>\n    (mset_cl (C', \\<eta>), mset_cl (D, \\<sigma>)) \\<in> mult (mult trm_ord)", "using mset_subst"], ["proof (prove)\nusing this:\n  C' = subst_cl D \\<theta>\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  finite D\n  \\<lbrakk>?C' = subst_cl ?D ?\\<theta>;\n   ?\\<sigma> \\<doteq> ?\\<theta> \\<lozenge> ?\\<eta>; finite ?D\\<rbrakk>\n  \\<Longrightarrow> mset_cl (?C', ?\\<eta>) = mset_cl (?D, ?\\<sigma>) \\<or>\n                    (mset_cl (?C', ?\\<eta>), mset_cl (?D, ?\\<sigma>))\n                    \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. mset_cl (C', \\<eta>) = mset_cl (D, \\<sigma>) \\<or>\n    (mset_cl (C', \\<eta>), mset_cl (D, \\<sigma>)) \\<in> mult (mult trm_ord)", "by auto"], ["proof (state)\nthis:\n  mset_cl (C', \\<eta>) = mset_cl (D, \\<sigma>) \\<or>\n  (mset_cl (C', \\<eta>), mset_cl (D, \\<sigma>)) \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. redundant_clause C S \\<sigma> D", "from this iv"], ["proof (chain)\npicking this:\n  mset_cl (C', \\<eta>) = mset_cl (D, \\<sigma>) \\<or>\n  (mset_cl (C', \\<eta>), mset_cl (D, \\<sigma>)) \\<in> mult (mult trm_ord)\n  \\<forall>x\\<in>S'.\n     (mset_ecl (fst x, snd x), mset_cl (C', \\<eta>))\n     \\<in> mult (mult trm_ord) \\<or>\n     mset_ecl (fst x, snd x) = mset_cl (C', \\<eta>)", "have \"(\\<forall>x \\<in> S'. ( ((mset_ecl ((fst x),(snd x))),(mset_cl (D,\\<sigma>))) \\<in> (mult (mult trm_ord))\n            \\<or> (mset_ecl ((fst x),(snd x))) = mset_cl (D,\\<sigma>)))\""], ["proof (prove)\nusing this:\n  mset_cl (C', \\<eta>) = mset_cl (D, \\<sigma>) \\<or>\n  (mset_cl (C', \\<eta>), mset_cl (D, \\<sigma>)) \\<in> mult (mult trm_ord)\n  \\<forall>x\\<in>S'.\n     (mset_ecl (fst x, snd x), mset_cl (C', \\<eta>))\n     \\<in> mult (mult trm_ord) \\<or>\n     mset_ecl (fst x, snd x) = mset_cl (C', \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S'.\n       (mset_ecl (fst x, snd x), mset_cl (D, \\<sigma>))\n       \\<in> mult (mult trm_ord) \\<or>\n       mset_ecl (fst x, snd x) = mset_cl (D, \\<sigma>)", "using mult_mult_trm_ord_trans"], ["proof (prove)\nusing this:\n  mset_cl (C', \\<eta>) = mset_cl (D, \\<sigma>) \\<or>\n  (mset_cl (C', \\<eta>), mset_cl (D, \\<sigma>)) \\<in> mult (mult trm_ord)\n  \\<forall>x\\<in>S'.\n     (mset_ecl (fst x, snd x), mset_cl (C', \\<eta>))\n     \\<in> mult (mult trm_ord) \\<or>\n     mset_ecl (fst x, snd x) = mset_cl (C', \\<eta>)\n  trans (mult (mult trm_ord))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S'.\n       (mset_ecl (fst x, snd x), mset_cl (D, \\<sigma>))\n       \\<in> mult (mult trm_ord) \\<or>\n       mset_ecl (fst x, snd x) = mset_cl (D, \\<sigma>)", "unfolding trans_def"], ["proof (prove)\nusing this:\n  mset_cl (C', \\<eta>) = mset_cl (D, \\<sigma>) \\<or>\n  (mset_cl (C', \\<eta>), mset_cl (D, \\<sigma>)) \\<in> mult (mult trm_ord)\n  \\<forall>x\\<in>S'.\n     (mset_ecl (fst x, snd x), mset_cl (C', \\<eta>))\n     \\<in> mult (mult trm_ord) \\<or>\n     mset_ecl (fst x, snd x) = mset_cl (C', \\<eta>)\n  \\<forall>x y z.\n     (x, y) \\<in> mult (mult trm_ord) \\<longrightarrow>\n     (y, z) \\<in> mult (mult trm_ord) \\<longrightarrow>\n     (x, z) \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S'.\n       (mset_ecl (fst x, snd x), mset_cl (D, \\<sigma>))\n       \\<in> mult (mult trm_ord) \\<or>\n       mset_ecl (fst x, snd x) = mset_cl (D, \\<sigma>)", "by metis"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S'.\n     (mset_ecl (fst x, snd x), mset_cl (D, \\<sigma>))\n     \\<in> mult (mult trm_ord) \\<or>\n     mset_ecl (fst x, snd x) = mset_cl (D, \\<sigma>)\n\ngoal (1 subgoal):\n 1. redundant_clause C S \\<sigma> D", "from this and i ii iii"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S'.\n     (mset_ecl (fst x, snd x), mset_cl (D, \\<sigma>))\n     \\<in> mult (mult trm_ord) \\<or>\n     mset_ecl (fst x, snd x) = mset_cl (D, \\<sigma>)\n  S' \\<subseteq> instances S\n  set_entails_clause (clset_instances S') (cl_ecl C)\n  \\<forall>x\\<in>S'.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) (trms_ecl C)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S'.\n     (mset_ecl (fst x, snd x), mset_cl (D, \\<sigma>))\n     \\<in> mult (mult trm_ord) \\<or>\n     mset_ecl (fst x, snd x) = mset_cl (D, \\<sigma>)\n  S' \\<subseteq> instances S\n  set_entails_clause (clset_instances S') (cl_ecl C)\n  \\<forall>x\\<in>S'.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) (trms_ecl C)\n\ngoal (1 subgoal):\n 1. redundant_clause C S \\<sigma> D", "unfolding  redundant_clause_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S'.\n     (mset_ecl (fst x, snd x), mset_cl (D, \\<sigma>))\n     \\<in> mult (mult trm_ord) \\<or>\n     mset_ecl (fst x, snd x) = mset_cl (D, \\<sigma>)\n  S' \\<subseteq> instances S\n  set_entails_clause (clset_instances S') (cl_ecl C)\n  \\<forall>x\\<in>S'.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) (trms_ecl C)\n\ngoal (1 subgoal):\n 1. \\<exists>S'\\<subseteq>instances S.\n       set_entails_clause (clset_instances S') (cl_ecl C) \\<and>\n       (\\<forall>x\\<in>S'.\n           subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n            (trms_ecl C)) \\<and>\n       (\\<forall>x\\<in>S'.\n           (mset_ecl (fst x, snd x), mset_cl (D, \\<sigma>))\n           \\<in> mult (mult trm_ord) \\<or>\n           mset_ecl (fst x, snd x) = mset_cl (D, \\<sigma>))", "by meson"], ["proof (state)\nthis:\n  redundant_clause C S \\<sigma> D\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We deduce the following (trivial) lemma, stating that sets that are closed under all \ninferences are also saturated.\\<close>"], ["", "lemma inference_closed_sets_are_saturated:\n  assumes \"inference_closed S\"\n  assumes \"\\<forall>x \\<in> S. (finite (cl_ecl x))\"\n  shows \"clause_saturated S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. clause_saturated S", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> clause_saturated S \\<Longrightarrow> False", "assume \"\\<not>?thesis\""], ["proof (state)\nthis:\n  \\<not> clause_saturated S\n\ngoal (1 subgoal):\n 1. \\<not> clause_saturated S \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  \\<not> clause_saturated S", "obtain C P \\<sigma> C' D \\<theta> \\<eta> \n    where \n     \"(derivable C P S \\<sigma> Ground C')\" \"(ground_clause (cl_ecl C))\" \n     \"(derivable D P S \\<theta> FirstOrder C')\" \"(trms_subsumes D C \\<eta>)\"\n     \"(\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>)\"\n     \"\\<not>(redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C')\""], ["proof (prove)\nusing this:\n  \\<not> clause_saturated S\n\ngoal (1 subgoal):\n 1. (\\<And>C P \\<sigma> C' D \\<theta> \\<eta>.\n        \\<lbrakk>derivable C P S \\<sigma> Ground C';\n         ground_clause (cl_ecl C); derivable D P S \\<theta> FirstOrder C';\n         trms_subsumes D C \\<eta>;\n         \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>;\n         \\<not> redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding clause_saturated_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>C P \\<sigma> C' D \\<theta> \\<eta>.\n             derivable C P S \\<sigma> Ground C' \\<longrightarrow>\n             ground_clause (cl_ecl C) \\<longrightarrow>\n             derivable D P S \\<theta> FirstOrder C' \\<longrightarrow>\n             trms_subsumes D C \\<eta> \\<longrightarrow>\n             \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta> \\<longrightarrow>\n             redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C')\n\ngoal (1 subgoal):\n 1. (\\<And>C P \\<sigma> C' D \\<theta> \\<eta>.\n        \\<lbrakk>derivable C P S \\<sigma> Ground C';\n         ground_clause (cl_ecl C); derivable D P S \\<theta> FirstOrder C';\n         trms_subsumes D C \\<eta>;\n         \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>;\n         \\<not> redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  derivable C P S \\<sigma> Ground C'\n  ground_clause (cl_ecl C)\n  derivable D P S \\<theta> FirstOrder C'\n  trms_subsumes D C \\<eta>\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  \\<not> redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C'\n\ngoal (1 subgoal):\n 1. \\<not> clause_saturated S \\<Longrightarrow> False", "from \\<open>(derivable D P S \\<theta> FirstOrder C')\\<close> assms(1)"], ["proof (chain)\npicking this:\n  derivable D P S \\<theta> FirstOrder C'\n  inference_closed S", "have \"D \\<in> S\""], ["proof (prove)\nusing this:\n  derivable D P S \\<theta> FirstOrder C'\n  inference_closed S\n\ngoal (1 subgoal):\n 1. D \\<in> S", "unfolding inference_closed_def"], ["proof (prove)\nusing this:\n  derivable D P S \\<theta> FirstOrder C'\n  \\<forall>P C' D \\<theta>.\n     derivable D P S \\<theta> FirstOrder C' \\<longrightarrow> D \\<in> S\n\ngoal (1 subgoal):\n 1. D \\<in> S", "by auto"], ["proof (state)\nthis:\n  D \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> clause_saturated S \\<Longrightarrow> False", "from \\<open>derivable D P S \\<theta> FirstOrder C'\\<close>"], ["proof (chain)\npicking this:\n  derivable D P S \\<theta> FirstOrder C'", "have \"(cl_ecl D) = (subst_cl C' \\<theta>)\""], ["proof (prove)\nusing this:\n  derivable D P S \\<theta> FirstOrder C'\n\ngoal (1 subgoal):\n 1. cl_ecl D = subst_cl C' \\<theta>", "using derivable_clauses_lemma"], ["proof (prove)\nusing this:\n  derivable D P S \\<theta> FirstOrder C'\n  derivable ?C ?P ?S ?\\<sigma> ?k ?C' \\<Longrightarrow>\n  cl_ecl ?C = subst_cl ?C' ?\\<sigma>\n\ngoal (1 subgoal):\n 1. cl_ecl D = subst_cl C' \\<theta>", "by auto"], ["proof (state)\nthis:\n  cl_ecl D = subst_cl C' \\<theta>\n\ngoal (1 subgoal):\n 1. \\<not> clause_saturated S \\<Longrightarrow> False", "from \\<open>trms_subsumes D C \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  trms_subsumes D C \\<eta>", "have \"(cl_ecl C) = (subst_cl (cl_ecl D) \\<eta>)\""], ["proof (prove)\nusing this:\n  trms_subsumes D C \\<eta>\n\ngoal (1 subgoal):\n 1. cl_ecl C = subst_cl (cl_ecl D) \\<eta>", "unfolding trms_subsumes_def"], ["proof (prove)\nusing this:\n  subst_cl (cl_ecl D) \\<eta> = cl_ecl C \\<and>\n  subst_set (trms_ecl D) \\<eta> \\<subseteq> trms_ecl C\n\ngoal (1 subgoal):\n 1. cl_ecl C = subst_cl (cl_ecl D) \\<eta>", "by blast"], ["proof (state)\nthis:\n  cl_ecl C = subst_cl (cl_ecl D) \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> clause_saturated S \\<Longrightarrow> False", "from \\<open>\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>", "have \"subst_cl (cl_ecl D) \\<sigma> = subst_cl (cl_ecl D) (\\<theta> \\<lozenge> \\<eta>)\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl D) \\<sigma> =\n    subst_cl (cl_ecl D) (\\<theta> \\<lozenge> \\<eta>)", "using subst_eq_cl"], ["proof (prove)\nusing this:\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  ?\\<sigma> \\<doteq> ?\\<eta> \\<Longrightarrow>\n  subst_cl ?C ?\\<sigma> = subst_cl ?C ?\\<eta>\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl D) \\<sigma> =\n    subst_cl (cl_ecl D) (\\<theta> \\<lozenge> \\<eta>)", "by blast"], ["proof (state)\nthis:\n  subst_cl (cl_ecl D) \\<sigma> =\n  subst_cl (cl_ecl D) (\\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_saturated S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  subst_cl (cl_ecl D) \\<sigma> =\n  subst_cl (cl_ecl D) (\\<theta> \\<lozenge> \\<eta>)", "have \"(subst_cl (cl_ecl D) \\<sigma>) = (subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>)\""], ["proof (prove)\nusing this:\n  subst_cl (cl_ecl D) \\<sigma> =\n  subst_cl (cl_ecl D) (\\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl D) \\<sigma> =\n    subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>", "using composition_of_substs_cl [of \"cl_ecl D\" \\<theta> \\<eta>]"], ["proof (prove)\nusing this:\n  subst_cl (cl_ecl D) \\<sigma> =\n  subst_cl (cl_ecl D) (\\<theta> \\<lozenge> \\<eta>)\n  subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta> =\n  subst_cl (cl_ecl D) (\\<theta> \\<lozenge> \\<eta>)\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl D) \\<sigma> =\n    subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>", "by auto"], ["proof (state)\nthis:\n  subst_cl (cl_ecl D) \\<sigma> =\n  subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>\n\ngoal (1 subgoal):\n 1. \\<not> clause_saturated S \\<Longrightarrow> False", "from this and \\<open>(cl_ecl C) = (subst_cl (cl_ecl D) \\<eta>)\\<close> \n    \\<open>(ground_clause (cl_ecl C))\\<close>"], ["proof (chain)\npicking this:\n  subst_cl (cl_ecl D) \\<sigma> =\n  subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>\n  cl_ecl C = subst_cl (cl_ecl D) \\<eta>\n  ground_clause (cl_ecl C)", "have \"ground_clause (subst_cl (cl_ecl D) \\<eta>)\""], ["proof (prove)\nusing this:\n  subst_cl (cl_ecl D) \\<sigma> =\n  subst_cl (subst_cl (cl_ecl D) \\<theta>) \\<eta>\n  cl_ecl C = subst_cl (cl_ecl D) \\<eta>\n  ground_clause (cl_ecl C)\n\ngoal (1 subgoal):\n 1. ground_clause (subst_cl (cl_ecl D) \\<eta>)", "by auto"], ["proof (state)\nthis:\n  ground_clause (subst_cl (cl_ecl D) \\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_saturated S \\<Longrightarrow> False", "from this \\<open>D \\<in> S\\<close> \\<open>(cl_ecl D) = (subst_cl C' \\<theta>)\\<close>\n    \\<open>(cl_ecl D) = (subst_cl C' \\<theta>)\\<close>"], ["proof (chain)\npicking this:\n  ground_clause (subst_cl (cl_ecl D) \\<eta>)\n  D \\<in> S\n  cl_ecl D = subst_cl C' \\<theta>\n  cl_ecl D = subst_cl C' \\<theta>", "have \"redundant_clause (subst_ecl D \\<eta>) S \\<eta> (subst_cl C' \\<theta>)\""], ["proof (prove)\nusing this:\n  ground_clause (subst_cl (cl_ecl D) \\<eta>)\n  D \\<in> S\n  cl_ecl D = subst_cl C' \\<theta>\n  cl_ecl D = subst_cl C' \\<theta>\n\ngoal (1 subgoal):\n 1. redundant_clause (subst_ecl D \\<eta>) S \\<eta> (subst_cl C' \\<theta>)", "using self_redundant_clause"], ["proof (prove)\nusing this:\n  ground_clause (subst_cl (cl_ecl D) \\<eta>)\n  D \\<in> S\n  cl_ecl D = subst_cl C' \\<theta>\n  cl_ecl D = subst_cl C' \\<theta>\n  \\<lbrakk>?C \\<in> ?S; ?C' = cl_ecl ?C;\n   ground_clause (subst_cl (cl_ecl ?C) ?\\<sigma>)\\<rbrakk>\n  \\<Longrightarrow> redundant_clause (subst_ecl ?C ?\\<sigma>) ?S ?\\<sigma>\n                     ?C'\n\ngoal (1 subgoal):\n 1. redundant_clause (subst_ecl D \\<eta>) S \\<eta> (subst_cl C' \\<theta>)", "by metis"], ["proof (state)\nthis:\n  redundant_clause (subst_ecl D \\<eta>) S \\<eta> (subst_cl C' \\<theta>)\n\ngoal (1 subgoal):\n 1. \\<not> clause_saturated S \\<Longrightarrow> False", "from \\<open>derivable D P S \\<theta> FirstOrder C'\\<close>"], ["proof (chain)\npicking this:\n  derivable D P S \\<theta> FirstOrder C'", "have \"P \\<subseteq> S\""], ["proof (prove)\nusing this:\n  derivable D P S \\<theta> FirstOrder C'\n\ngoal (1 subgoal):\n 1. P \\<subseteq> S", "unfolding derivable_def"], ["proof (prove)\nusing this:\n  (\\<exists>P1 P2.\n      P1 \\<in> S \\<and>\n      P2 \\<in> S \\<and>\n      P = {P1, P2} \\<and>\n      superposition P1 P2 D \\<theta> FirstOrder C') \\<or>\n  (\\<exists>P1.\n      P1 \\<in> S \\<and>\n      P = {P1} \\<and> factorization P1 D \\<theta> FirstOrder C') \\<or>\n  (\\<exists>P1.\n      P1 \\<in> S \\<and>\n      P = {P1} \\<and> reflexion P1 D \\<theta> FirstOrder C')\n\ngoal (1 subgoal):\n 1. P \\<subseteq> S", "by auto"], ["proof (state)\nthis:\n  P \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<not> clause_saturated S \\<Longrightarrow> False", "from this assms(2)"], ["proof (chain)\npicking this:\n  P \\<subseteq> S\n  \\<forall>x\\<in>S. finite (cl_ecl x)", "have \"\\<forall>x \\<in> P. (finite (cl_ecl x))\""], ["proof (prove)\nusing this:\n  P \\<subseteq> S\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>P. finite (cl_ecl x)", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>P. finite (cl_ecl x)\n\ngoal (1 subgoal):\n 1. \\<not> clause_saturated S \\<Longrightarrow> False", "from this  \\<open>derivable D P S \\<theta> FirstOrder C'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>P. finite (cl_ecl x)\n  derivable D P S \\<theta> FirstOrder C'", "have  \"finite C'\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>P. finite (cl_ecl x)\n  derivable D P S \\<theta> FirstOrder C'\n\ngoal (1 subgoal):\n 1. finite C'", "using derivable_clauses_are_finite"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>P. finite (cl_ecl x)\n  derivable D P S \\<theta> FirstOrder C'\n  \\<lbrakk>derivable ?C ?P ?S ?\\<sigma> ?k ?C';\n   \\<forall>x\\<in>?P. finite (cl_ecl x)\\<rbrakk>\n  \\<Longrightarrow> finite (cl_ecl ?C) \\<and> finite ?C'\n\ngoal (1 subgoal):\n 1. finite C'", "by auto"], ["proof (state)\nthis:\n  finite C'\n\ngoal (1 subgoal):\n 1. \\<not> clause_saturated S \\<Longrightarrow> False", "from this \\<open>(cl_ecl D) = subst_cl C' \\<theta>\\<close> \n      \\<open>redundant_clause (subst_ecl D \\<eta>) S \\<eta> (subst_cl C' \\<theta>)\\<close> \\<open>(\\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>)\\<close>"], ["proof (chain)\npicking this:\n  finite C'\n  cl_ecl D = subst_cl C' \\<theta>\n  redundant_clause (subst_ecl D \\<eta>) S \\<eta> (subst_cl C' \\<theta>)\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>", "have \"redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C'\""], ["proof (prove)\nusing this:\n  finite C'\n  cl_ecl D = subst_cl C' \\<theta>\n  redundant_clause (subst_ecl D \\<eta>) S \\<eta> (subst_cl C' \\<theta>)\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n\ngoal (1 subgoal):\n 1. redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C'", "using lift_redundant_cl"], ["proof (prove)\nusing this:\n  finite C'\n  cl_ecl D = subst_cl C' \\<theta>\n  redundant_clause (subst_ecl D \\<eta>) S \\<eta> (subst_cl C' \\<theta>)\n  \\<sigma> \\<doteq> \\<theta> \\<lozenge> \\<eta>\n  \\<lbrakk>?C' = subst_cl ?D ?\\<theta>; redundant_clause ?C ?S ?\\<eta> ?C';\n   ?\\<sigma> \\<doteq> ?\\<theta> \\<lozenge> ?\\<eta>; finite ?D\\<rbrakk>\n  \\<Longrightarrow> redundant_clause ?C ?S ?\\<sigma> ?D\n\ngoal (1 subgoal):\n 1. redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C'", "by metis"], ["proof (state)\nthis:\n  redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C'\n\ngoal (1 subgoal):\n 1. \\<not> clause_saturated S \\<Longrightarrow> False", "from this and \\<open>\\<not>(redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C')\\<close>"], ["proof (chain)\npicking this:\n  redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C'\n  \\<not> redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C'", "show False"], ["proof (prove)\nusing this:\n  redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C'\n  \\<not> redundant_clause (subst_ecl D \\<eta>) S \\<sigma> C'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Satisfiability of Saturated Sets with No Empty Clause\\<close>"], ["", "text \\<open>We are now in the position to prove that the previously constructed interpretation \nis indeed a model of the set of extended clauses, if the latter is saturated and does not contain\nan extended clause with empty clausal part. More precisely, the constructed interpretation satisfies \nthe clausal part of every extended clause whose attached set of terms is in normal form. This is the \ncase in particular if this set is empty, hence if the clause is an input clause. \n\nNote that we do not provide any function for explicitly \nconstructing such saturated sets, except by generating all derivable clauses (see below).\\<close>"], ["", "lemma int_clset_is_a_model:\n  assumes \"ground_inference_saturated S\"\n  assumes all_finite: \"\\<forall>x \\<in> S. (finite (cl_ecl x))\"\n  assumes \"Ball S well_constrained\"\n  assumes all_non_empty: \"\\<forall>x \\<in> S. (cl_ecl x) \\<noteq> {}\"\n  assumes \"closed_under_renaming S\"\n  shows \"\\<forall> C \\<sigma>. (fst pair = C) \\<longrightarrow> \\<sigma> = (snd pair) \\<longrightarrow> C \\<in> S \\<longrightarrow> \n    ground_clause (subst_cl (cl_ecl C) \\<sigma>) \n    \\<longrightarrow> (all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>) (\\<lambda>t. (trm_rep t S))) \n          \\<longrightarrow> validate_ground_clause (same_values (\\<lambda>t. (trm_rep t S))) (subst_cl (cl_ecl C) \\<sigma>)\" \n          (is \"?P pair\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C \\<sigma>.\n       fst pair = C \\<longrightarrow>\n       \\<sigma> = snd pair \\<longrightarrow>\n       C \\<in> S \\<longrightarrow>\n       ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n       all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n        (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n       validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n        (subst_cl (cl_ecl C) \\<sigma>)", "proof ((rule wf_induct [of \"ecl_ord\" \"?P\" \"pair\"]),(simp add: wf_ecl_ord))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> ecl_ord \\<longrightarrow>\n          (\\<forall>C \\<sigma>.\n              fst y = C \\<longrightarrow>\n              \\<sigma> = snd y \\<longrightarrow>\n              C \\<in> S \\<longrightarrow>\n              ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n              all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n               (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n              validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n               (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n       \\<forall>C \\<sigma>.\n          fst x = C \\<longrightarrow>\n          \\<sigma> = snd x \\<longrightarrow>\n          C \\<in> S \\<longrightarrow>\n          ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n          all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n           (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n          validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n           (subst_cl (cl_ecl C) \\<sigma>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> ecl_ord \\<longrightarrow>\n          (\\<forall>C \\<sigma>.\n              fst y = C \\<longrightarrow>\n              \\<sigma> = snd y \\<longrightarrow>\n              C \\<in> S \\<longrightarrow>\n              ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n              all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n               (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n              validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n               (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n       \\<forall>C \\<sigma>.\n          fst x = C \\<longrightarrow>\n          \\<sigma> = snd x \\<longrightarrow>\n          C \\<in> S \\<longrightarrow>\n          ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n          all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n           (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n          validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n           (subst_cl (cl_ecl C) \\<sigma>)", "text \\<open>The proof is by induction and contradiction. We consider a minimal instance  \nthat is not true in the interpretation and we derive a contradiction.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> ecl_ord \\<longrightarrow>\n          (\\<forall>C \\<sigma>.\n              fst y = C \\<longrightarrow>\n              \\<sigma> = snd y \\<longrightarrow>\n              C \\<in> S \\<longrightarrow>\n              ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n              all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n               (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n              validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n               (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n       \\<forall>C \\<sigma>.\n          fst x = C \\<longrightarrow>\n          \\<sigma> = snd x \\<longrightarrow>\n          C \\<in> S \\<longrightarrow>\n          ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n          all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n           (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n          validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n           (subst_cl (cl_ecl C) \\<sigma>)", "fix pair"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> ecl_ord \\<longrightarrow>\n          (\\<forall>C \\<sigma>.\n              fst y = C \\<longrightarrow>\n              \\<sigma> = snd y \\<longrightarrow>\n              C \\<in> S \\<longrightarrow>\n              ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n              all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n               (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n              validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n               (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n       \\<forall>C \\<sigma>.\n          fst x = C \\<longrightarrow>\n          \\<sigma> = snd x \\<longrightarrow>\n          C \\<in> S \\<longrightarrow>\n          ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n          all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n           (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n          validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n           (subst_cl (cl_ecl C) \\<sigma>)", "assume hyp_ind: \"\\<forall>y. (y,pair) \\<in> ecl_ord \\<longrightarrow> (?P y)\""], ["proof (state)\nthis:\n  \\<forall>y.\n     (y, pair) \\<in> ecl_ord \\<longrightarrow>\n     (\\<forall>C \\<sigma>.\n         fst y = C \\<longrightarrow>\n         \\<sigma> = snd y \\<longrightarrow>\n         C \\<in> S \\<longrightarrow>\n         ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n         all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n          (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n         validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n          (subst_cl (cl_ecl C) \\<sigma>))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> ecl_ord \\<longrightarrow>\n          (\\<forall>C \\<sigma>.\n              fst y = C \\<longrightarrow>\n              \\<sigma> = snd y \\<longrightarrow>\n              C \\<in> S \\<longrightarrow>\n              ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n              all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n               (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n              validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n               (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n       \\<forall>C \\<sigma>.\n          fst x = C \\<longrightarrow>\n          \\<sigma> = snd x \\<longrightarrow>\n          C \\<in> S \\<longrightarrow>\n          ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n          all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n           (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n          validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n           (subst_cl (cl_ecl C) \\<sigma>)", "let ?I = \"(int_clset S)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> ecl_ord \\<longrightarrow>\n          (\\<forall>C \\<sigma>.\n              fst y = C \\<longrightarrow>\n              \\<sigma> = snd y \\<longrightarrow>\n              C \\<in> S \\<longrightarrow>\n              ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n              all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n               (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n              validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n               (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n       \\<forall>C \\<sigma>.\n          fst x = C \\<longrightarrow>\n          \\<sigma> = snd x \\<longrightarrow>\n          C \\<in> S \\<longrightarrow>\n          ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n          all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n           (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n          validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n           (subst_cl (cl_ecl C) \\<sigma>)", "have \"fo_interpretation ?I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fo_interpretation (int_clset S)", "unfolding int_clset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fo_interpretation (same_values (\\<lambda>x. trm_rep x S))", "using trm_rep_compatible_with_structure same_values_fo_int"], ["proof (prove)\nusing this:\n  value_is_compatible_with_structure (\\<lambda>x. trm_rep x ?S)\n  value_is_compatible_with_structure ?f \\<Longrightarrow>\n  fo_interpretation (same_values ?f)\n\ngoal (1 subgoal):\n 1. fo_interpretation (same_values (\\<lambda>x. trm_rep x S))", "by metis"], ["proof (state)\nthis:\n  fo_interpretation (int_clset S)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> ecl_ord \\<longrightarrow>\n          (\\<forall>C \\<sigma>.\n              fst y = C \\<longrightarrow>\n              \\<sigma> = snd y \\<longrightarrow>\n              C \\<in> S \\<longrightarrow>\n              ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n              all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n               (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n              validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n               (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n       \\<forall>C \\<sigma>.\n          fst x = C \\<longrightarrow>\n          \\<sigma> = snd x \\<longrightarrow>\n          C \\<in> S \\<longrightarrow>\n          ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n          all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n           (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n          validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n           (subst_cl (cl_ecl C) \\<sigma>)", "show \"(?P pair)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C \\<sigma>.\n       fst pair = C \\<longrightarrow>\n       \\<sigma> = snd pair \\<longrightarrow>\n       C \\<in> S \\<longrightarrow>\n       ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n       all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n        (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n       validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n        (subst_cl (cl_ecl C) \\<sigma>)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "assume \"\\<not>(?P pair)\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>C \\<sigma>.\n             fst pair = C \\<longrightarrow>\n             \\<sigma> = snd pair \\<longrightarrow>\n             C \\<in> S \\<longrightarrow>\n             ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n             all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n              (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n             validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n              (subst_cl (cl_ecl C) \\<sigma>))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>C \\<sigma>.\n             fst pair = C \\<longrightarrow>\n             \\<sigma> = snd pair \\<longrightarrow>\n             C \\<in> S \\<longrightarrow>\n             ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n             all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n              (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n             validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n              (subst_cl (cl_ecl C) \\<sigma>))", "obtain C \\<sigma> where \"C = (fst pair)\" and \"\\<sigma> = (snd pair)\" and \"C \\<in> S\" \n            and \"ground_clause (subst_cl (cl_ecl C) \\<sigma>)\" \n            and \"(all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>) \n                  (\\<lambda>t. (trm_rep t S)))\"\n            and cm: \"\\<not>validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>C \\<sigma>.\n             fst pair = C \\<longrightarrow>\n             \\<sigma> = snd pair \\<longrightarrow>\n             C \\<in> S \\<longrightarrow>\n             ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n             all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n              (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n             validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n              (subst_cl (cl_ecl C) \\<sigma>))\n\ngoal (1 subgoal):\n 1. (\\<And>C \\<sigma>.\n        \\<lbrakk>C = fst pair; \\<sigma> = snd pair; C \\<in> S;\n         ground_clause (subst_cl (cl_ecl C) \\<sigma>);\n         all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n          (\\<lambda>t. trm_rep t S);\n         \\<not> validate_ground_clause (int_clset S)\n                 (subst_cl (cl_ecl C) \\<sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding int_clset_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>C \\<sigma>.\n             fst pair = C \\<longrightarrow>\n             \\<sigma> = snd pair \\<longrightarrow>\n             C \\<in> S \\<longrightarrow>\n             ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n             all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n              (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n             validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n              (subst_cl (cl_ecl C) \\<sigma>))\n\ngoal (1 subgoal):\n 1. (\\<And>C \\<sigma>.\n        \\<lbrakk>C = fst pair; \\<sigma> = snd pair; C \\<in> S;\n         ground_clause (subst_cl (cl_ecl C) \\<sigma>);\n         all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n          (\\<lambda>t. trm_rep t S);\n         \\<not> validate_ground_clause\n                 (same_values (\\<lambda>x. trm_rep x S))\n                 (subst_cl (cl_ecl C) \\<sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  C = fst pair\n  \\<sigma> = snd pair\n  C \\<in> S\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "text \\<open>First, we prove that no reduction is possible (otherwise the superposition rule applies).\\<close>"], ["proof (state)\nthis:\n  C = fst pair\n  \\<sigma> = snd pair\n  C \\<in> S\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "let ?nored = \"(\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'. \n      \\<not> ((reduction L1 C \\<sigma>' t s polarity L2 u u' p v D ?I S \\<sigma>) \\<and> (variable_disjoint C D)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "have ?nored"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n       \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                (int_clset S) S \\<sigma> \\<and>\n               variable_disjoint C D)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "assume \"\\<not> ?nored\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n             \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                      (int_clset S) S \\<sigma> \\<and>\n                     variable_disjoint C D))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n             \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                      (int_clset S) S \\<sigma> \\<and>\n                     variable_disjoint C D))", "obtain L1 L2 D t s u' u v p polarity \\<sigma>'\n          where red: \"reduction L1 C \\<sigma>' t s polarity L2 u u' p v D ?I S \\<sigma>\" \n            and \"variable_disjoint C D\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n             \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                      (int_clset S) S \\<sigma> \\<and>\n                     variable_disjoint C D))\n\ngoal (1 subgoal):\n 1. (\\<And>L1 \\<sigma>' t s polarity L2 u u' p v D.\n        \\<lbrakk>reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                  (int_clset S) S \\<sigma>;\n         variable_disjoint C D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>\n  variable_disjoint C D\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from red"], ["proof (chain)\npicking this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>", "have \"(subst u \\<sigma>') \\<noteq> (subst v \\<sigma>')\""], ["proof (prove)\nusing this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>'", "unfolding reduction_def"], ["proof (prove)\nusing this:\n  D \\<in> S \\<and>\n  eligible_literal L1 C \\<sigma>' \\<and>\n  eligible_literal L2 D \\<sigma>' \\<and>\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>') \\<and>\n  minimal_redex p (t \\<lhd> \\<sigma>) C S t \\<and>\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)) \\<and>\n  allowed_redex u' C \\<sigma> \\<and>\n  \\<not> is_a_variable u' \\<and>\n  L1 \\<in> cl_ecl C \\<and>\n  L2 \\<in> cl_ecl D \\<and>\n  orient_lit_inst L1 t s polarity \\<sigma>' \\<and>\n  orient_lit_inst L2 u v pos \\<sigma>' \\<and>\n  u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>' \\<and>\n  u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>' \\<and>\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl D - {L2}) \\<sigma>') \\<and>\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord \\<and>\n  (\\<forall>x\\<in>cl_ecl D - {L2}.\n      (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord) \\<and>\n  all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>')\n   (\\<lambda>t. trm_rep t S) \\<and>\n  int_clset S (u \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>') \\<and>\n  subterm t p u'\n\ngoal (1 subgoal):\n 1. u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>'", "by blast"], ["proof (state)\nthis:\n  u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from red"], ["proof (chain)\npicking this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>", "have \"ground_clause (subst_cl (cl_ecl D) \\<sigma>')\""], ["proof (prove)\nusing this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. ground_clause (subst_cl (cl_ecl D) \\<sigma>')", "unfolding reduction_def"], ["proof (prove)\nusing this:\n  D \\<in> S \\<and>\n  eligible_literal L1 C \\<sigma>' \\<and>\n  eligible_literal L2 D \\<sigma>' \\<and>\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>') \\<and>\n  minimal_redex p (t \\<lhd> \\<sigma>) C S t \\<and>\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)) \\<and>\n  allowed_redex u' C \\<sigma> \\<and>\n  \\<not> is_a_variable u' \\<and>\n  L1 \\<in> cl_ecl C \\<and>\n  L2 \\<in> cl_ecl D \\<and>\n  orient_lit_inst L1 t s polarity \\<sigma>' \\<and>\n  orient_lit_inst L2 u v pos \\<sigma>' \\<and>\n  u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>' \\<and>\n  u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>' \\<and>\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl D - {L2}) \\<sigma>') \\<and>\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord \\<and>\n  (\\<forall>x\\<in>cl_ecl D - {L2}.\n      (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord) \\<and>\n  all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>')\n   (\\<lambda>t. trm_rep t S) \\<and>\n  int_clset S (u \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>') \\<and>\n  subterm t p u'\n\ngoal (1 subgoal):\n 1. ground_clause (subst_cl (cl_ecl D) \\<sigma>')", "by blast"], ["proof (state)\nthis:\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from red"], ["proof (chain)\npicking this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>", "have \"(coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)))\""], ["proof (prove)\nusing this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))", "unfolding reduction_def"], ["proof (prove)\nusing this:\n  D \\<in> S \\<and>\n  eligible_literal L1 C \\<sigma>' \\<and>\n  eligible_literal L2 D \\<sigma>' \\<and>\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>') \\<and>\n  minimal_redex p (t \\<lhd> \\<sigma>) C S t \\<and>\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)) \\<and>\n  allowed_redex u' C \\<sigma> \\<and>\n  \\<not> is_a_variable u' \\<and>\n  L1 \\<in> cl_ecl C \\<and>\n  L2 \\<in> cl_ecl D \\<and>\n  orient_lit_inst L1 t s polarity \\<sigma>' \\<and>\n  orient_lit_inst L2 u v pos \\<sigma>' \\<and>\n  u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>' \\<and>\n  u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>' \\<and>\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl D - {L2}) \\<sigma>') \\<and>\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord \\<and>\n  (\\<forall>x\\<in>cl_ecl D - {L2}.\n      (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord) \\<and>\n  all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>')\n   (\\<lambda>t. trm_rep t S) \\<and>\n  int_clset S (u \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>') \\<and>\n  subterm t p u'\n\ngoal (1 subgoal):\n 1. coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))", "by blast"], ["proof (state)\nthis:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from red"], ["proof (chain)\npicking this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>", "have \"\\<not> is_a_variable u'\""], ["proof (prove)\nusing this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> is_a_variable u'", "unfolding reduction_def"], ["proof (prove)\nusing this:\n  D \\<in> S \\<and>\n  eligible_literal L1 C \\<sigma>' \\<and>\n  eligible_literal L2 D \\<sigma>' \\<and>\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>') \\<and>\n  minimal_redex p (t \\<lhd> \\<sigma>) C S t \\<and>\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)) \\<and>\n  allowed_redex u' C \\<sigma> \\<and>\n  \\<not> is_a_variable u' \\<and>\n  L1 \\<in> cl_ecl C \\<and>\n  L2 \\<in> cl_ecl D \\<and>\n  orient_lit_inst L1 t s polarity \\<sigma>' \\<and>\n  orient_lit_inst L2 u v pos \\<sigma>' \\<and>\n  u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>' \\<and>\n  u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>' \\<and>\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl D - {L2}) \\<sigma>') \\<and>\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord \\<and>\n  (\\<forall>x\\<in>cl_ecl D - {L2}.\n      (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord) \\<and>\n  all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>')\n   (\\<lambda>t. trm_rep t S) \\<and>\n  int_clset S (u \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>') \\<and>\n  subterm t p u'\n\ngoal (1 subgoal):\n 1. \\<not> is_a_variable u'", "by blast"], ["proof (state)\nthis:\n  \\<not> is_a_variable u'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from red"], ["proof (chain)\npicking this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>", "have \"D \\<in> S\""], ["proof (prove)\nusing this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. D \\<in> S", "unfolding reduction_def"], ["proof (prove)\nusing this:\n  D \\<in> S \\<and>\n  eligible_literal L1 C \\<sigma>' \\<and>\n  eligible_literal L2 D \\<sigma>' \\<and>\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>') \\<and>\n  minimal_redex p (t \\<lhd> \\<sigma>) C S t \\<and>\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)) \\<and>\n  allowed_redex u' C \\<sigma> \\<and>\n  \\<not> is_a_variable u' \\<and>\n  L1 \\<in> cl_ecl C \\<and>\n  L2 \\<in> cl_ecl D \\<and>\n  orient_lit_inst L1 t s polarity \\<sigma>' \\<and>\n  orient_lit_inst L2 u v pos \\<sigma>' \\<and>\n  u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>' \\<and>\n  u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>' \\<and>\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl D - {L2}) \\<sigma>') \\<and>\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord \\<and>\n  (\\<forall>x\\<in>cl_ecl D - {L2}.\n      (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord) \\<and>\n  all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>')\n   (\\<lambda>t. trm_rep t S) \\<and>\n  int_clset S (u \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>') \\<and>\n  subterm t p u'\n\ngoal (1 subgoal):\n 1. D \\<in> S", "by blast"], ["proof (state)\nthis:\n  D \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from red"], ["proof (chain)\npicking this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>", "have el1: \"(eligible_literal L1 C \\<sigma>')\""], ["proof (prove)\nusing this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. eligible_literal L1 C \\<sigma>'", "unfolding reduction_def"], ["proof (prove)\nusing this:\n  D \\<in> S \\<and>\n  eligible_literal L1 C \\<sigma>' \\<and>\n  eligible_literal L2 D \\<sigma>' \\<and>\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>') \\<and>\n  minimal_redex p (t \\<lhd> \\<sigma>) C S t \\<and>\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)) \\<and>\n  allowed_redex u' C \\<sigma> \\<and>\n  \\<not> is_a_variable u' \\<and>\n  L1 \\<in> cl_ecl C \\<and>\n  L2 \\<in> cl_ecl D \\<and>\n  orient_lit_inst L1 t s polarity \\<sigma>' \\<and>\n  orient_lit_inst L2 u v pos \\<sigma>' \\<and>\n  u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>' \\<and>\n  u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>' \\<and>\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl D - {L2}) \\<sigma>') \\<and>\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord \\<and>\n  (\\<forall>x\\<in>cl_ecl D - {L2}.\n      (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord) \\<and>\n  all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>')\n   (\\<lambda>t. trm_rep t S) \\<and>\n  int_clset S (u \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>') \\<and>\n  subterm t p u'\n\ngoal (1 subgoal):\n 1. eligible_literal L1 C \\<sigma>'", "by blast"], ["proof (state)\nthis:\n  eligible_literal L1 C \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from red"], ["proof (chain)\npicking this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>", "have el2: \"(eligible_literal L2 D \\<sigma>')\""], ["proof (prove)\nusing this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. eligible_literal L2 D \\<sigma>'", "unfolding reduction_def"], ["proof (prove)\nusing this:\n  D \\<in> S \\<and>\n  eligible_literal L1 C \\<sigma>' \\<and>\n  eligible_literal L2 D \\<sigma>' \\<and>\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>') \\<and>\n  minimal_redex p (t \\<lhd> \\<sigma>) C S t \\<and>\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)) \\<and>\n  allowed_redex u' C \\<sigma> \\<and>\n  \\<not> is_a_variable u' \\<and>\n  L1 \\<in> cl_ecl C \\<and>\n  L2 \\<in> cl_ecl D \\<and>\n  orient_lit_inst L1 t s polarity \\<sigma>' \\<and>\n  orient_lit_inst L2 u v pos \\<sigma>' \\<and>\n  u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>' \\<and>\n  u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>' \\<and>\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl D - {L2}) \\<sigma>') \\<and>\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord \\<and>\n  (\\<forall>x\\<in>cl_ecl D - {L2}.\n      (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord) \\<and>\n  all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>')\n   (\\<lambda>t. trm_rep t S) \\<and>\n  int_clset S (u \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>') \\<and>\n  subterm t p u'\n\ngoal (1 subgoal):\n 1. eligible_literal L2 D \\<sigma>'", "by blast"], ["proof (state)\nthis:\n  eligible_literal L2 D \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from red"], ["proof (chain)\npicking this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>", "have \"D \\<in> S\""], ["proof (prove)\nusing this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. D \\<in> S", "unfolding reduction_def"], ["proof (prove)\nusing this:\n  D \\<in> S \\<and>\n  eligible_literal L1 C \\<sigma>' \\<and>\n  eligible_literal L2 D \\<sigma>' \\<and>\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>') \\<and>\n  minimal_redex p (t \\<lhd> \\<sigma>) C S t \\<and>\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)) \\<and>\n  allowed_redex u' C \\<sigma> \\<and>\n  \\<not> is_a_variable u' \\<and>\n  L1 \\<in> cl_ecl C \\<and>\n  L2 \\<in> cl_ecl D \\<and>\n  orient_lit_inst L1 t s polarity \\<sigma>' \\<and>\n  orient_lit_inst L2 u v pos \\<sigma>' \\<and>\n  u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>' \\<and>\n  u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>' \\<and>\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl D - {L2}) \\<sigma>') \\<and>\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord \\<and>\n  (\\<forall>x\\<in>cl_ecl D - {L2}.\n      (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord) \\<and>\n  all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>')\n   (\\<lambda>t. trm_rep t S) \\<and>\n  int_clset S (u \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>') \\<and>\n  subterm t p u'\n\ngoal (1 subgoal):\n 1. D \\<in> S", "by blast"], ["proof (state)\nthis:\n  D \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from red"], ["proof (chain)\npicking this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>", "have \"(minimal_redex p (subst t \\<sigma>) C S t)\""], ["proof (prove)\nusing this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. minimal_redex p (t \\<lhd> \\<sigma>) C S t", "unfolding reduction_def"], ["proof (prove)\nusing this:\n  D \\<in> S \\<and>\n  eligible_literal L1 C \\<sigma>' \\<and>\n  eligible_literal L2 D \\<sigma>' \\<and>\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>') \\<and>\n  minimal_redex p (t \\<lhd> \\<sigma>) C S t \\<and>\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)) \\<and>\n  allowed_redex u' C \\<sigma> \\<and>\n  \\<not> is_a_variable u' \\<and>\n  L1 \\<in> cl_ecl C \\<and>\n  L2 \\<in> cl_ecl D \\<and>\n  orient_lit_inst L1 t s polarity \\<sigma>' \\<and>\n  orient_lit_inst L2 u v pos \\<sigma>' \\<and>\n  u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>' \\<and>\n  u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>' \\<and>\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl D - {L2}) \\<sigma>') \\<and>\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord \\<and>\n  (\\<forall>x\\<in>cl_ecl D - {L2}.\n      (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord) \\<and>\n  all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>')\n   (\\<lambda>t. trm_rep t S) \\<and>\n  int_clset S (u \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>') \\<and>\n  subterm t p u'\n\ngoal (1 subgoal):\n 1. minimal_redex p (t \\<lhd> \\<sigma>) C S t", "by blast"], ["proof (state)\nthis:\n  minimal_redex p (t \\<lhd> \\<sigma>) C S t\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from red"], ["proof (chain)\npicking this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>", "have l1: \"L1 \\<in> (cl_ecl C)\""], ["proof (prove)\nusing this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. L1 \\<in> cl_ecl C", "unfolding reduction_def"], ["proof (prove)\nusing this:\n  D \\<in> S \\<and>\n  eligible_literal L1 C \\<sigma>' \\<and>\n  eligible_literal L2 D \\<sigma>' \\<and>\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>') \\<and>\n  minimal_redex p (t \\<lhd> \\<sigma>) C S t \\<and>\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)) \\<and>\n  allowed_redex u' C \\<sigma> \\<and>\n  \\<not> is_a_variable u' \\<and>\n  L1 \\<in> cl_ecl C \\<and>\n  L2 \\<in> cl_ecl D \\<and>\n  orient_lit_inst L1 t s polarity \\<sigma>' \\<and>\n  orient_lit_inst L2 u v pos \\<sigma>' \\<and>\n  u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>' \\<and>\n  u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>' \\<and>\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl D - {L2}) \\<sigma>') \\<and>\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord \\<and>\n  (\\<forall>x\\<in>cl_ecl D - {L2}.\n      (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord) \\<and>\n  all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>')\n   (\\<lambda>t. trm_rep t S) \\<and>\n  int_clset S (u \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>') \\<and>\n  subterm t p u'\n\ngoal (1 subgoal):\n 1. L1 \\<in> cl_ecl C", "by blast"], ["proof (state)\nthis:\n  L1 \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from red"], ["proof (chain)\npicking this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>", "have l2: \"L2 \\<in> (cl_ecl D)\""], ["proof (prove)\nusing this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. L2 \\<in> cl_ecl D", "unfolding reduction_def"], ["proof (prove)\nusing this:\n  D \\<in> S \\<and>\n  eligible_literal L1 C \\<sigma>' \\<and>\n  eligible_literal L2 D \\<sigma>' \\<and>\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>') \\<and>\n  minimal_redex p (t \\<lhd> \\<sigma>) C S t \\<and>\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)) \\<and>\n  allowed_redex u' C \\<sigma> \\<and>\n  \\<not> is_a_variable u' \\<and>\n  L1 \\<in> cl_ecl C \\<and>\n  L2 \\<in> cl_ecl D \\<and>\n  orient_lit_inst L1 t s polarity \\<sigma>' \\<and>\n  orient_lit_inst L2 u v pos \\<sigma>' \\<and>\n  u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>' \\<and>\n  u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>' \\<and>\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl D - {L2}) \\<sigma>') \\<and>\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord \\<and>\n  (\\<forall>x\\<in>cl_ecl D - {L2}.\n      (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord) \\<and>\n  all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>')\n   (\\<lambda>t. trm_rep t S) \\<and>\n  int_clset S (u \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>') \\<and>\n  subterm t p u'\n\ngoal (1 subgoal):\n 1. L2 \\<in> cl_ecl D", "by blast"], ["proof (state)\nthis:\n  L2 \\<in> cl_ecl D\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from red"], ["proof (chain)\npicking this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>", "have  o1: \"(orient_lit_inst L1 t s polarity \\<sigma>')\""], ["proof (prove)\nusing this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. orient_lit_inst L1 t s polarity \\<sigma>'", "unfolding reduction_def"], ["proof (prove)\nusing this:\n  D \\<in> S \\<and>\n  eligible_literal L1 C \\<sigma>' \\<and>\n  eligible_literal L2 D \\<sigma>' \\<and>\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>') \\<and>\n  minimal_redex p (t \\<lhd> \\<sigma>) C S t \\<and>\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)) \\<and>\n  allowed_redex u' C \\<sigma> \\<and>\n  \\<not> is_a_variable u' \\<and>\n  L1 \\<in> cl_ecl C \\<and>\n  L2 \\<in> cl_ecl D \\<and>\n  orient_lit_inst L1 t s polarity \\<sigma>' \\<and>\n  orient_lit_inst L2 u v pos \\<sigma>' \\<and>\n  u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>' \\<and>\n  u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>' \\<and>\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl D - {L2}) \\<sigma>') \\<and>\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord \\<and>\n  (\\<forall>x\\<in>cl_ecl D - {L2}.\n      (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord) \\<and>\n  all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>')\n   (\\<lambda>t. trm_rep t S) \\<and>\n  int_clset S (u \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>') \\<and>\n  subterm t p u'\n\ngoal (1 subgoal):\n 1. orient_lit_inst L1 t s polarity \\<sigma>'", "by blast"], ["proof (state)\nthis:\n  orient_lit_inst L1 t s polarity \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from red"], ["proof (chain)\npicking this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>", "have  o2: \"(orient_lit_inst L2 u v pos \\<sigma>')\""], ["proof (prove)\nusing this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. orient_lit_inst L2 u v pos \\<sigma>'", "unfolding reduction_def"], ["proof (prove)\nusing this:\n  D \\<in> S \\<and>\n  eligible_literal L1 C \\<sigma>' \\<and>\n  eligible_literal L2 D \\<sigma>' \\<and>\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>') \\<and>\n  minimal_redex p (t \\<lhd> \\<sigma>) C S t \\<and>\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)) \\<and>\n  allowed_redex u' C \\<sigma> \\<and>\n  \\<not> is_a_variable u' \\<and>\n  L1 \\<in> cl_ecl C \\<and>\n  L2 \\<in> cl_ecl D \\<and>\n  orient_lit_inst L1 t s polarity \\<sigma>' \\<and>\n  orient_lit_inst L2 u v pos \\<sigma>' \\<and>\n  u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>' \\<and>\n  u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>' \\<and>\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl D - {L2}) \\<sigma>') \\<and>\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord \\<and>\n  (\\<forall>x\\<in>cl_ecl D - {L2}.\n      (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord) \\<and>\n  all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>')\n   (\\<lambda>t. trm_rep t S) \\<and>\n  int_clset S (u \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>') \\<and>\n  subterm t p u'\n\ngoal (1 subgoal):\n 1. orient_lit_inst L2 u v pos \\<sigma>'", "by blast"], ["proof (state)\nthis:\n  orient_lit_inst L2 u v pos \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from red"], ["proof (chain)\npicking this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>", "have  e:\"(subst u' \\<sigma>') = (subst u \\<sigma>')\""], ["proof (prove)\nusing this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>'", "unfolding reduction_def"], ["proof (prove)\nusing this:\n  D \\<in> S \\<and>\n  eligible_literal L1 C \\<sigma>' \\<and>\n  eligible_literal L2 D \\<sigma>' \\<and>\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>') \\<and>\n  minimal_redex p (t \\<lhd> \\<sigma>) C S t \\<and>\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)) \\<and>\n  allowed_redex u' C \\<sigma> \\<and>\n  \\<not> is_a_variable u' \\<and>\n  L1 \\<in> cl_ecl C \\<and>\n  L2 \\<in> cl_ecl D \\<and>\n  orient_lit_inst L1 t s polarity \\<sigma>' \\<and>\n  orient_lit_inst L2 u v pos \\<sigma>' \\<and>\n  u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>' \\<and>\n  u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>' \\<and>\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl D - {L2}) \\<sigma>') \\<and>\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord \\<and>\n  (\\<forall>x\\<in>cl_ecl D - {L2}.\n      (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord) \\<and>\n  all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>')\n   (\\<lambda>t. trm_rep t S) \\<and>\n  int_clset S (u \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>') \\<and>\n  subterm t p u'\n\ngoal (1 subgoal):\n 1. u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>'", "by blast"], ["proof (state)\nthis:\n  u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from red"], ["proof (chain)\npicking this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>", "have \"(\\<not> validate_ground_clause ?I (subst_cl ( (cl_ecl D) - { L2 } ) \\<sigma>'))\""], ["proof (prove)\nusing this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_clause (int_clset S)\n            (subst_cl (cl_ecl D - {L2}) \\<sigma>')", "unfolding reduction_def"], ["proof (prove)\nusing this:\n  D \\<in> S \\<and>\n  eligible_literal L1 C \\<sigma>' \\<and>\n  eligible_literal L2 D \\<sigma>' \\<and>\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>') \\<and>\n  minimal_redex p (t \\<lhd> \\<sigma>) C S t \\<and>\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)) \\<and>\n  allowed_redex u' C \\<sigma> \\<and>\n  \\<not> is_a_variable u' \\<and>\n  L1 \\<in> cl_ecl C \\<and>\n  L2 \\<in> cl_ecl D \\<and>\n  orient_lit_inst L1 t s polarity \\<sigma>' \\<and>\n  orient_lit_inst L2 u v pos \\<sigma>' \\<and>\n  u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>' \\<and>\n  u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>' \\<and>\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl D - {L2}) \\<sigma>') \\<and>\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord \\<and>\n  (\\<forall>x\\<in>cl_ecl D - {L2}.\n      (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord) \\<and>\n  all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>')\n   (\\<lambda>t. trm_rep t S) \\<and>\n  int_clset S (u \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>') \\<and>\n  subterm t p u'\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_clause (int_clset S)\n            (subst_cl (cl_ecl D - {L2}) \\<sigma>')", "by blast"], ["proof (state)\nthis:\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl D - {L2}) \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from red"], ["proof (chain)\npicking this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>", "have \"(\\<forall>x \\<in> (cl_ecl D) - { L2 }. ( (subst_lit x \\<sigma>'),(subst_lit L2 \\<sigma>')) \n                                        \\<in> lit_ord)\""], ["proof (prove)\nusing this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>cl_ecl D - {L2}.\n       (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord", "unfolding reduction_def"], ["proof (prove)\nusing this:\n  D \\<in> S \\<and>\n  eligible_literal L1 C \\<sigma>' \\<and>\n  eligible_literal L2 D \\<sigma>' \\<and>\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>') \\<and>\n  minimal_redex p (t \\<lhd> \\<sigma>) C S t \\<and>\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)) \\<and>\n  allowed_redex u' C \\<sigma> \\<and>\n  \\<not> is_a_variable u' \\<and>\n  L1 \\<in> cl_ecl C \\<and>\n  L2 \\<in> cl_ecl D \\<and>\n  orient_lit_inst L1 t s polarity \\<sigma>' \\<and>\n  orient_lit_inst L2 u v pos \\<sigma>' \\<and>\n  u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>' \\<and>\n  u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>' \\<and>\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl D - {L2}) \\<sigma>') \\<and>\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord \\<and>\n  (\\<forall>x\\<in>cl_ecl D - {L2}.\n      (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord) \\<and>\n  all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>')\n   (\\<lambda>t. trm_rep t S) \\<and>\n  int_clset S (u \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>') \\<and>\n  subterm t p u'\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>cl_ecl D - {L2}.\n       (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>cl_ecl D - {L2}.\n     (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from red"], ["proof (chain)\npicking this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>", "have st: \"(subterm t p u')\""], ["proof (prove)\nusing this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. subterm t p u'", "unfolding reduction_def"], ["proof (prove)\nusing this:\n  D \\<in> S \\<and>\n  eligible_literal L1 C \\<sigma>' \\<and>\n  eligible_literal L2 D \\<sigma>' \\<and>\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>') \\<and>\n  minimal_redex p (t \\<lhd> \\<sigma>) C S t \\<and>\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)) \\<and>\n  allowed_redex u' C \\<sigma> \\<and>\n  \\<not> is_a_variable u' \\<and>\n  L1 \\<in> cl_ecl C \\<and>\n  L2 \\<in> cl_ecl D \\<and>\n  orient_lit_inst L1 t s polarity \\<sigma>' \\<and>\n  orient_lit_inst L2 u v pos \\<sigma>' \\<and>\n  u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>' \\<and>\n  u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>' \\<and>\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl D - {L2}) \\<sigma>') \\<and>\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord \\<and>\n  (\\<forall>x\\<in>cl_ecl D - {L2}.\n      (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord) \\<and>\n  all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>')\n   (\\<lambda>t. trm_rep t S) \\<and>\n  int_clset S (u \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>') \\<and>\n  subterm t p u'\n\ngoal (1 subgoal):\n 1. subterm t p u'", "by blast"], ["proof (state)\nthis:\n  subterm t p u'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from red"], ["proof (chain)\npicking this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>", "have \"(allowed_redex u' C \\<sigma>)\""], ["proof (prove)\nusing this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. allowed_redex u' C \\<sigma>", "unfolding reduction_def"], ["proof (prove)\nusing this:\n  D \\<in> S \\<and>\n  eligible_literal L1 C \\<sigma>' \\<and>\n  eligible_literal L2 D \\<sigma>' \\<and>\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>') \\<and>\n  minimal_redex p (t \\<lhd> \\<sigma>) C S t \\<and>\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)) \\<and>\n  allowed_redex u' C \\<sigma> \\<and>\n  \\<not> is_a_variable u' \\<and>\n  L1 \\<in> cl_ecl C \\<and>\n  L2 \\<in> cl_ecl D \\<and>\n  orient_lit_inst L1 t s polarity \\<sigma>' \\<and>\n  orient_lit_inst L2 u v pos \\<sigma>' \\<and>\n  u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>' \\<and>\n  u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>' \\<and>\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl D - {L2}) \\<sigma>') \\<and>\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord \\<and>\n  (\\<forall>x\\<in>cl_ecl D - {L2}.\n      (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord) \\<and>\n  all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>')\n   (\\<lambda>t. trm_rep t S) \\<and>\n  int_clset S (u \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>') \\<and>\n  subterm t p u'\n\ngoal (1 subgoal):\n 1. allowed_redex u' C \\<sigma>", "by blast"], ["proof (state)\nthis:\n  allowed_redex u' C \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from st"], ["proof (chain)\npicking this:\n  subterm t p u'", "have \"u' \\<in> (subterms_of t)\""], ["proof (prove)\nusing this:\n  subterm t p u'\n\ngoal (1 subgoal):\n 1. u' \\<in> subterms_of t", "using occurs_in_def"], ["proof (prove)\nusing this:\n  subterm t p u'\n  occurs_in ?t ?s = (\\<exists>p. subterm ?s p ?t)\n\ngoal (1 subgoal):\n 1. u' \\<in> subterms_of t", "by auto"], ["proof (state)\nthis:\n  u' \\<in> subterms_of t\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from this and o1"], ["proof (chain)\npicking this:\n  u' \\<in> subterms_of t\n  orient_lit_inst L1 t s polarity \\<sigma>'", "have \"u' \\<in> (subterms_of_lit L1)\""], ["proof (prove)\nusing this:\n  u' \\<in> subterms_of t\n  orient_lit_inst L1 t s polarity \\<sigma>'\n\ngoal (1 subgoal):\n 1. u' \\<in> subterms_of_lit L1", "using orient_lit_inst_subterms"], ["proof (prove)\nusing this:\n  u' \\<in> subterms_of t\n  orient_lit_inst L1 t s polarity \\<sigma>'\n  \\<lbrakk>orient_lit_inst ?L ?t ?s ?polarity ?\\<sigma>;\n   ?u \\<in> subterms_of ?t\\<rbrakk>\n  \\<Longrightarrow> ?u \\<in> subterms_of_lit ?L\n\ngoal (1 subgoal):\n 1. u' \\<in> subterms_of_lit L1", "by auto"], ["proof (state)\nthis:\n  u' \\<in> subterms_of_lit L1\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from this and \\<open>L1 \\<in> (cl_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  u' \\<in> subterms_of_lit L1\n  L1 \\<in> cl_ecl C", "have \"u' \\<in> (subterms_of_cl (cl_ecl C))\""], ["proof (prove)\nusing this:\n  u' \\<in> subterms_of_lit L1\n  L1 \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. u' \\<in> subterms_of_cl (cl_ecl C)", "by auto"], ["proof (state)\nthis:\n  u' \\<in> subterms_of_cl (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from this and \\<open>(allowed_redex u' C \\<sigma>)\\<close> and \\<open>C \\<in> S\\<close> \n          and \\<open>(coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)))\\<close> \n          assms(3)"], ["proof (chain)\npicking this:\n  u' \\<in> subterms_of_cl (cl_ecl C)\n  allowed_redex u' C \\<sigma>\n  C \\<in> S\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\n  Ball S well_constrained", "have rte: \"(allowed_redex u' C \\<sigma>')\""], ["proof (prove)\nusing this:\n  u' \\<in> subterms_of_cl (cl_ecl C)\n  allowed_redex u' C \\<sigma>\n  C \\<in> S\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\n  Ball S well_constrained\n\ngoal (1 subgoal):\n 1. allowed_redex u' C \\<sigma>'", "using allowed_redex_coincide [of u' C \\<sigma> \\<sigma>']"], ["proof (prove)\nusing this:\n  u' \\<in> subterms_of_cl (cl_ecl C)\n  allowed_redex u' C \\<sigma>\n  C \\<in> S\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\n  Ball S well_constrained\n  \\<lbrakk>allowed_redex u' C \\<sigma>; u' \\<in> subterms_of_cl (cl_ecl C);\n   coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C));\n   well_constrained C\\<rbrakk>\n  \\<Longrightarrow> allowed_redex u' C \\<sigma>'\n\ngoal (1 subgoal):\n 1. allowed_redex u' C \\<sigma>'", "by metis"], ["proof (state)\nthis:\n  allowed_redex u' C \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from red"], ["proof (chain)\npicking this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>", "have \"( (subst_lit L2 \\<sigma>'),(subst_lit L1 \\<sigma>')) \n            \\<in> lit_ord\""], ["proof (prove)\nusing this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord", "unfolding reduction_def"], ["proof (prove)\nusing this:\n  D \\<in> S \\<and>\n  eligible_literal L1 C \\<sigma>' \\<and>\n  eligible_literal L2 D \\<sigma>' \\<and>\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>') \\<and>\n  minimal_redex p (t \\<lhd> \\<sigma>) C S t \\<and>\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)) \\<and>\n  allowed_redex u' C \\<sigma> \\<and>\n  \\<not> is_a_variable u' \\<and>\n  L1 \\<in> cl_ecl C \\<and>\n  L2 \\<in> cl_ecl D \\<and>\n  orient_lit_inst L1 t s polarity \\<sigma>' \\<and>\n  orient_lit_inst L2 u v pos \\<sigma>' \\<and>\n  u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>' \\<and>\n  u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>' \\<and>\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl D - {L2}) \\<sigma>') \\<and>\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord \\<and>\n  (\\<forall>x\\<in>cl_ecl D - {L2}.\n      (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord) \\<and>\n  all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>')\n   (\\<lambda>t. trm_rep t S) \\<and>\n  int_clset S (u \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>') \\<and>\n  subterm t p u'\n\ngoal (1 subgoal):\n 1. (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord", "by blast"], ["proof (state)\nthis:\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from red"], ["proof (chain)\npicking this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>", "have \"(all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>') \n                  (\\<lambda>t. (trm_rep t S)))\""], ["proof (prove)\nusing this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>')\n     (\\<lambda>t. trm_rep t S)", "unfolding reduction_def"], ["proof (prove)\nusing this:\n  D \\<in> S \\<and>\n  eligible_literal L1 C \\<sigma>' \\<and>\n  eligible_literal L2 D \\<sigma>' \\<and>\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>') \\<and>\n  minimal_redex p (t \\<lhd> \\<sigma>) C S t \\<and>\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)) \\<and>\n  allowed_redex u' C \\<sigma> \\<and>\n  \\<not> is_a_variable u' \\<and>\n  L1 \\<in> cl_ecl C \\<and>\n  L2 \\<in> cl_ecl D \\<and>\n  orient_lit_inst L1 t s polarity \\<sigma>' \\<and>\n  orient_lit_inst L2 u v pos \\<sigma>' \\<and>\n  u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>' \\<and>\n  u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>' \\<and>\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl D - {L2}) \\<sigma>') \\<and>\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord \\<and>\n  (\\<forall>x\\<in>cl_ecl D - {L2}.\n      (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord) \\<and>\n  all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>')\n   (\\<lambda>t. trm_rep t S) \\<and>\n  int_clset S (u \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>') \\<and>\n  subterm t p u'\n\ngoal (1 subgoal):\n 1. all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>')\n     (\\<lambda>t. trm_rep t S)", "by blast"], ["proof (state)\nthis:\n  all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>')\n   (\\<lambda>t. trm_rep t S)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from red"], ["proof (chain)\npicking this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>", "have \"?I (subst u \\<sigma>')  (subst v \\<sigma>')\""], ["proof (prove)\nusing this:\n  reduction L1 C \\<sigma>' t s polarity L2 u u' p v D (int_clset S) S\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. int_clset S (u \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>')", "unfolding reduction_def"], ["proof (prove)\nusing this:\n  D \\<in> S \\<and>\n  eligible_literal L1 C \\<sigma>' \\<and>\n  eligible_literal L2 D \\<sigma>' \\<and>\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>') \\<and>\n  minimal_redex p (t \\<lhd> \\<sigma>) C S t \\<and>\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)) \\<and>\n  allowed_redex u' C \\<sigma> \\<and>\n  \\<not> is_a_variable u' \\<and>\n  L1 \\<in> cl_ecl C \\<and>\n  L2 \\<in> cl_ecl D \\<and>\n  orient_lit_inst L1 t s polarity \\<sigma>' \\<and>\n  orient_lit_inst L2 u v pos \\<sigma>' \\<and>\n  u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>' \\<and>\n  u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>' \\<and>\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl D - {L2}) \\<sigma>') \\<and>\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord \\<and>\n  (\\<forall>x\\<in>cl_ecl D - {L2}.\n      (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord) \\<and>\n  all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>')\n   (\\<lambda>t. trm_rep t S) \\<and>\n  int_clset S (u \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>') \\<and>\n  subterm t p u'\n\ngoal (1 subgoal):\n 1. int_clset S (u \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>')", "by blast"], ["proof (state)\nthis:\n  int_clset S (u \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from e"], ["proof (chain)\npicking this:\n  u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>'", "have t: \"ck_unifier u' u \\<sigma>' Ground\""], ["proof (prove)\nusing this:\n  u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. ck_unifier u' u \\<sigma>' Ground", "unfolding ck_unifier_def Unifier_def"], ["proof (prove)\nusing this:\n  u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. if Ground = FirstOrder then MGU \\<sigma>' u' u\n    else u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  ck_unifier u' u \\<sigma>' Ground\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "have \"\\<forall>x \\<in> (cl_ecl D). ( (mset_lit (subst_lit x \\<sigma>')),(mset_lit (subst_lit L1 \\<sigma>'))) \n                                        \\<in> (mult trm_ord)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>cl_ecl D.\n       (mset_lit (subst_lit x \\<sigma>'), mset_lit (subst_lit L1 \\<sigma>'))\n       \\<in> mult trm_ord", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>cl_ecl D.\n               (mset_lit (subst_lit x \\<sigma>'),\n                mset_lit (subst_lit L1 \\<sigma>'))\n               \\<in> mult trm_ord) \\<Longrightarrow>\n    False", "assume \"\\<not>(\\<forall>x \\<in> (cl_ecl D). ( (mset_lit (subst_lit x \\<sigma>')),(mset_lit (subst_lit L1 \\<sigma>'))) \n                                        \\<in> (mult trm_ord))\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>x\\<in>cl_ecl D.\n             (mset_lit (subst_lit x \\<sigma>'),\n              mset_lit (subst_lit L1 \\<sigma>'))\n             \\<in> mult trm_ord)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>cl_ecl D.\n               (mset_lit (subst_lit x \\<sigma>'),\n                mset_lit (subst_lit L1 \\<sigma>'))\n               \\<in> mult trm_ord) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>x\\<in>cl_ecl D.\n             (mset_lit (subst_lit x \\<sigma>'),\n              mset_lit (subst_lit L1 \\<sigma>'))\n             \\<in> mult trm_ord)", "obtain x where \"x \\<in> (cl_ecl D)\" \n          and \"( (mset_lit (subst_lit x \\<sigma>')),(mset_lit (subst_lit L1 \\<sigma>'))) \n                                        \\<notin> (mult trm_ord)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x\\<in>cl_ecl D.\n             (mset_lit (subst_lit x \\<sigma>'),\n              mset_lit (subst_lit L1 \\<sigma>'))\n             \\<in> mult trm_ord)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> cl_ecl D;\n         (mset_lit (subst_lit x \\<sigma>'),\n          mset_lit (subst_lit L1 \\<sigma>'))\n         \\<notin> mult trm_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> cl_ecl D\n  (mset_lit (subst_lit x \\<sigma>'), mset_lit (subst_lit L1 \\<sigma>'))\n  \\<notin> mult trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>cl_ecl D.\n               (mset_lit (subst_lit x \\<sigma>'),\n                mset_lit (subst_lit L1 \\<sigma>'))\n               \\<in> mult trm_ord) \\<Longrightarrow>\n    False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "assume \"x = L2\""], ["proof (state)\nthis:\n  x = L2\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "from this and \\<open>((subst_lit L2 \\<sigma>'),(subst_lit L1 \\<sigma>')) \n            \\<in> lit_ord\\<close> and \\<open>( (mset_lit (subst_lit x \\<sigma>')),(mset_lit (subst_lit L1 \\<sigma>'))) \n                                        \\<notin> (mult trm_ord)\\<close>"], ["proof (chain)\npicking this:\n  x = L2\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord\n  (mset_lit (subst_lit x \\<sigma>'), mset_lit (subst_lit L1 \\<sigma>'))\n  \\<notin> mult trm_ord", "show False"], ["proof (prove)\nusing this:\n  x = L2\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord\n  (mset_lit (subst_lit x \\<sigma>'), mset_lit (subst_lit L1 \\<sigma>'))\n  \\<notin> mult trm_ord\n\ngoal (1 subgoal):\n 1. False", "unfolding lit_ord_def"], ["proof (prove)\nusing this:\n  x = L2\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>')\n  \\<in> {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}\n  (mset_lit (subst_lit x \\<sigma>'), mset_lit (subst_lit L1 \\<sigma>'))\n  \\<notin> mult trm_ord\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. x \\<noteq> L2 \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> L2 \\<Longrightarrow> False", "assume \"x \\<noteq> L2\""], ["proof (state)\nthis:\n  x \\<noteq> L2\n\ngoal (1 subgoal):\n 1. x \\<noteq> L2 \\<Longrightarrow> False", "from this and \\<open>x \\<in> (cl_ecl D)\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> L2\n  x \\<in> cl_ecl D", "have \"x \\<in> (cl_ecl D) - { L2 }\""], ["proof (prove)\nusing this:\n  x \\<noteq> L2\n  x \\<in> cl_ecl D\n\ngoal (1 subgoal):\n 1. x \\<in> cl_ecl D - {L2}", "by auto"], ["proof (state)\nthis:\n  x \\<in> cl_ecl D - {L2}\n\ngoal (1 subgoal):\n 1. x \\<noteq> L2 \\<Longrightarrow> False", "from this and \\<open>(\\<forall>x \\<in> (cl_ecl D) - { L2 }. ( (subst_lit x \\<sigma>'),(subst_lit L2 \\<sigma>')) \n                                        \\<in> lit_ord)\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> cl_ecl D - {L2}\n  \\<forall>x\\<in>cl_ecl D - {L2}.\n     (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord", "have \"( (subst_lit x \\<sigma>'),(subst_lit L2 \\<sigma>')) \n                                        \\<in> lit_ord\""], ["proof (prove)\nusing this:\n  x \\<in> cl_ecl D - {L2}\n  \\<forall>x\\<in>cl_ecl D - {L2}.\n     (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord", "by auto"], ["proof (state)\nthis:\n  (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. x \\<noteq> L2 \\<Longrightarrow> False", "from \\<open>((mset_lit (subst_lit x \\<sigma>')),(mset_lit (subst_lit L1 \\<sigma>'))) \n                                        \\<notin> (mult trm_ord)\\<close>"], ["proof (chain)\npicking this:\n  (mset_lit (subst_lit x \\<sigma>'), mset_lit (subst_lit L1 \\<sigma>'))\n  \\<notin> mult trm_ord", "have \"((subst_lit x \\<sigma>'),(subst_lit L1 \\<sigma>')) \n                                        \\<notin> lit_ord\""], ["proof (prove)\nusing this:\n  (mset_lit (subst_lit x \\<sigma>'), mset_lit (subst_lit L1 \\<sigma>'))\n  \\<notin> mult trm_ord\n\ngoal (1 subgoal):\n 1. (subst_lit x \\<sigma>', subst_lit L1 \\<sigma>') \\<notin> lit_ord", "unfolding lit_ord_def"], ["proof (prove)\nusing this:\n  (mset_lit (subst_lit x \\<sigma>'), mset_lit (subst_lit L1 \\<sigma>'))\n  \\<notin> mult trm_ord\n\ngoal (1 subgoal):\n 1. (subst_lit x \\<sigma>', subst_lit L1 \\<sigma>')\n    \\<notin> {(x, y). (mset_lit x, mset_lit y) \\<in> mult trm_ord}", "by auto"], ["proof (state)\nthis:\n  (subst_lit x \\<sigma>', subst_lit L1 \\<sigma>') \\<notin> lit_ord\n\ngoal (1 subgoal):\n 1. x \\<noteq> L2 \\<Longrightarrow> False", "from this and \\<open>( (subst_lit x \\<sigma>'),(subst_lit L2 \\<sigma>')) \n                                        \\<in> lit_ord\\<close>  \n             and \\<open>((subst_lit L2 \\<sigma>'),(subst_lit L1 \\<sigma>')) \n            \\<in> lit_ord\\<close>"], ["proof (chain)\npicking this:\n  (subst_lit x \\<sigma>', subst_lit L1 \\<sigma>') \\<notin> lit_ord\n  (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord", "show False"], ["proof (prove)\nusing this:\n  (subst_lit x \\<sigma>', subst_lit L1 \\<sigma>') \\<notin> lit_ord\n  (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. False", "using lit_ord_trans"], ["proof (prove)\nusing this:\n  (subst_lit x \\<sigma>', subst_lit L1 \\<sigma>') \\<notin> lit_ord\n  (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord\n  trans lit_ord\n\ngoal (1 subgoal):\n 1. False", "unfolding trans_def"], ["proof (prove)\nusing this:\n  (subst_lit x \\<sigma>', subst_lit L1 \\<sigma>') \\<notin> lit_ord\n  (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord\n  \\<forall>x y z.\n     (x, y) \\<in> lit_ord \\<longrightarrow>\n     (y, z) \\<in> lit_ord \\<longrightarrow> (x, z) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>cl_ecl D.\n     (mset_lit (subst_lit x \\<sigma>'), mset_lit (subst_lit L1 \\<sigma>'))\n     \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from all_finite and \\<open>C \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  C \\<in> S", "have \"finite (cl_ecl C)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. finite (cl_ecl C)", "by auto"], ["proof (state)\nthis:\n  finite (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from this and \\<open>L1 \\<in> (cl_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  finite (cl_ecl C)\n  L1 \\<in> cl_ecl C", "have \"(mset_lit (subst_lit L1 \\<sigma>')) \\<in>#  mset_ecl (C,\\<sigma>')\""], ["proof (prove)\nusing this:\n  finite (cl_ecl C)\n  L1 \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L1 \\<sigma>') \\<in># mset_ecl (C, \\<sigma>')", "using mset_ecl_and_mset_lit"], ["proof (prove)\nusing this:\n  finite (cl_ecl C)\n  L1 \\<in> cl_ecl C\n  \\<lbrakk>?L \\<in> cl_ecl ?C; finite (cl_ecl ?C)\\<rbrakk>\n  \\<Longrightarrow> mset_lit (subst_lit ?L ?\\<sigma>)\n                    \\<in># mset_ecl (?C, ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L1 \\<sigma>') \\<in># mset_ecl (C, \\<sigma>')", "by auto"], ["proof (state)\nthis:\n  mset_lit (subst_lit L1 \\<sigma>') \\<in># mset_ecl (C, \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  mset_lit (subst_lit L1 \\<sigma>') \\<in># mset_ecl (C, \\<sigma>')", "have \"(mset_lit (subst_lit L1 \\<sigma>')) \\<in> (set_mset (mset_ecl (C,\\<sigma>')))\""], ["proof (prove)\nusing this:\n  mset_lit (subst_lit L1 \\<sigma>') \\<in># mset_ecl (C, \\<sigma>')\n\ngoal (1 subgoal):\n 1. mset_lit (subst_lit L1 \\<sigma>') \\<in># mset_ecl (C, \\<sigma>')", "by simp"], ["proof (state)\nthis:\n  mset_lit (subst_lit L1 \\<sigma>') \\<in># mset_ecl (C, \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "have \"\\<forall>x. (x \\<in> (set_mset (mset_ecl (D,\\<sigma>'))) \n          \\<longrightarrow> (\\<exists>y \\<in> set_mset (mset_ecl (C,\\<sigma>')). (x,y) \\<in> (mult trm_ord)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<in># mset_ecl (D, \\<sigma>') \\<longrightarrow>\n       (\\<exists>y\\<in>#mset_ecl (C, \\<sigma>'). (x, y) \\<in> mult trm_ord)", "proof ((rule allI),(rule impI))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># mset_ecl (D, \\<sigma>') \\<Longrightarrow>\n       \\<exists>y\\<in>#mset_ecl (C, \\<sigma>'). (x, y) \\<in> mult trm_ord", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># mset_ecl (D, \\<sigma>') \\<Longrightarrow>\n       \\<exists>y\\<in>#mset_ecl (C, \\<sigma>'). (x, y) \\<in> mult trm_ord", "assume \"x \\<in> (set_mset (mset_ecl (D,\\<sigma>')))\""], ["proof (state)\nthis:\n  x \\<in># mset_ecl (D, \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># mset_ecl (D, \\<sigma>') \\<Longrightarrow>\n       \\<exists>y\\<in>#mset_ecl (C, \\<sigma>'). (x, y) \\<in> mult trm_ord", "then"], ["proof (chain)\npicking this:\n  x \\<in># mset_ecl (D, \\<sigma>')", "have \"x \\<in># mset_ecl (D,\\<sigma>')\""], ["proof (prove)\nusing this:\n  x \\<in># mset_ecl (D, \\<sigma>')\n\ngoal (1 subgoal):\n 1. x \\<in># mset_ecl (D, \\<sigma>')", "by simp"], ["proof (state)\nthis:\n  x \\<in># mset_ecl (D, \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># mset_ecl (D, \\<sigma>') \\<Longrightarrow>\n       \\<exists>y\\<in>#mset_ecl (C, \\<sigma>'). (x, y) \\<in> mult trm_ord", "from \\<open>x \\<in># mset_ecl (D,\\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  x \\<in># mset_ecl (D, \\<sigma>')", "obtain x' \n            where \"x' \\<in># (mset_set (cl_ecl D))\" \n            and \"x = (mset_lit (subst_lit x' \\<sigma>'))\""], ["proof (prove)\nusing this:\n  x \\<in># mset_ecl (D, \\<sigma>')\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>x' \\<in># mset_set (cl_ecl D);\n         x = mset_lit (subst_lit x' \\<sigma>')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x' \\<in># mset_set (cl_ecl D)\n  x = mset_lit (subst_lit x' \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># mset_ecl (D, \\<sigma>') \\<Longrightarrow>\n       \\<exists>y\\<in>#mset_ecl (C, \\<sigma>'). (x, y) \\<in> mult trm_ord", "from \\<open>x' \\<in># (mset_set (cl_ecl D))\\<close>"], ["proof (chain)\npicking this:\n  x' \\<in># mset_set (cl_ecl D)", "have \"x' \\<in> (cl_ecl D)\""], ["proof (prove)\nusing this:\n  x' \\<in># mset_set (cl_ecl D)\n\ngoal (1 subgoal):\n 1. x' \\<in> cl_ecl D", "using count_mset_set(3)"], ["proof (prove)\nusing this:\n  x' \\<in># mset_set (cl_ecl D)\n  ?x \\<notin> ?A \\<Longrightarrow> count (mset_set ?A) ?x = 0\n\ngoal (1 subgoal):\n 1. x' \\<in> cl_ecl D", "by (fastforce simp: count_eq_zero_iff)"], ["proof (state)\nthis:\n  x' \\<in> cl_ecl D\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># mset_ecl (D, \\<sigma>') \\<Longrightarrow>\n       \\<exists>y\\<in>#mset_ecl (C, \\<sigma>'). (x, y) \\<in> mult trm_ord", "from this \n          and \\<open>\\<forall>x \\<in> (cl_ecl D). \n          ( (mset_lit (subst_lit x \\<sigma>')),(mset_lit (subst_lit L1 \\<sigma>'))) \n                                        \\<in> (mult trm_ord)\\<close> \n                  and \\<open>x = (mset_lit (subst_lit x' \\<sigma>'))\\<close>"], ["proof (chain)\npicking this:\n  x' \\<in> cl_ecl D\n  \\<forall>x\\<in>cl_ecl D.\n     (mset_lit (subst_lit x \\<sigma>'), mset_lit (subst_lit L1 \\<sigma>'))\n     \\<in> mult trm_ord\n  x = mset_lit (subst_lit x' \\<sigma>')", "have \"(x,(mset_lit (subst_lit L1 \\<sigma>'))) \\<in> (mult trm_ord)\""], ["proof (prove)\nusing this:\n  x' \\<in> cl_ecl D\n  \\<forall>x\\<in>cl_ecl D.\n     (mset_lit (subst_lit x \\<sigma>'), mset_lit (subst_lit L1 \\<sigma>'))\n     \\<in> mult trm_ord\n  x = mset_lit (subst_lit x' \\<sigma>')\n\ngoal (1 subgoal):\n 1. (x, mset_lit (subst_lit L1 \\<sigma>')) \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  (x, mset_lit (subst_lit L1 \\<sigma>')) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in># mset_ecl (D, \\<sigma>') \\<Longrightarrow>\n       \\<exists>y\\<in>#mset_ecl (C, \\<sigma>'). (x, y) \\<in> mult trm_ord", "from \\<open>(mset_lit (subst_lit L1 \\<sigma>')) \\<in> (set_mset (mset_ecl (C,\\<sigma>')))\\<close>\n          and \\<open>(x,(mset_lit (subst_lit L1 \\<sigma>'))) \\<in> (mult trm_ord)\\<close>"], ["proof (chain)\npicking this:\n  mset_lit (subst_lit L1 \\<sigma>') \\<in># mset_ecl (C, \\<sigma>')\n  (x, mset_lit (subst_lit L1 \\<sigma>')) \\<in> mult trm_ord", "show \n          \"(\\<exists>y \\<in> set_mset (mset_ecl (C,\\<sigma>')). (x,y) \\<in> (mult trm_ord))\""], ["proof (prove)\nusing this:\n  mset_lit (subst_lit L1 \\<sigma>') \\<in># mset_ecl (C, \\<sigma>')\n  (x, mset_lit (subst_lit L1 \\<sigma>')) \\<in> mult trm_ord\n\ngoal (1 subgoal):\n 1. \\<exists>y\\<in>#mset_ecl (C, \\<sigma>'). (x, y) \\<in> mult trm_ord", "by auto"], ["proof (state)\nthis:\n  \\<exists>y\\<in>#mset_ecl (C, \\<sigma>'). (x, y) \\<in> mult trm_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x.\n     x \\<in># mset_ecl (D, \\<sigma>') \\<longrightarrow>\n     (\\<exists>y\\<in>#mset_ecl (C, \\<sigma>'). (x, y) \\<in> mult trm_ord)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     x \\<in># mset_ecl (D, \\<sigma>') \\<longrightarrow>\n     (\\<exists>y\\<in>#mset_ecl (C, \\<sigma>'). (x, y) \\<in> mult trm_ord)", "have \n          dom: \"\\<And>I J K. J \\<noteq> {#} \\<and> (\\<forall>k\\<in>set_mset K. \\<exists>j\\<in>set_mset J. (k, j) \\<in> (mult trm_ord)) \\<longrightarrow>\n          (I + K, I + J) \\<in> mult (mult trm_ord)\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in># mset_ecl (D, \\<sigma>') \\<longrightarrow>\n     (\\<exists>y\\<in>#mset_ecl (C, \\<sigma>'). (x, y) \\<in> mult trm_ord)\n\ngoal (1 subgoal):\n 1. \\<And>I J K.\n       J \\<noteq> {#} \\<and>\n       (\\<forall>k\\<in>#K.\n           \\<exists>j\\<in>#J. (k, j) \\<in> mult trm_ord) \\<longrightarrow>\n       (I + K, I + J) \\<in> mult (mult trm_ord)", "by (blast intro: one_step_implies_mult)"], ["proof (state)\nthis:\n  ?J \\<noteq> {#} \\<and>\n  (\\<forall>k\\<in>#?K.\n      \\<exists>j\\<in>#?J. (k, j) \\<in> mult trm_ord) \\<longrightarrow>\n  (?I + ?K, ?I + ?J) \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from \\<open>(mset_lit (subst_lit L1 \\<sigma>')) \\<in>#  mset_ecl (C,\\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  mset_lit (subst_lit L1 \\<sigma>') \\<in># mset_ecl (C, \\<sigma>')", "have \"mset_ecl (C,\\<sigma>') \\<noteq> {#}\""], ["proof (prove)\nusing this:\n  mset_lit (subst_lit L1 \\<sigma>') \\<in># mset_ecl (C, \\<sigma>')\n\ngoal (1 subgoal):\n 1. mset_ecl (C, \\<sigma>') \\<noteq> {#}", "by auto"], ["proof (state)\nthis:\n  mset_ecl (C, \\<sigma>') \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from \\<open>\\<forall>x. (x \\<in> (set_mset (mset_ecl (D,\\<sigma>')))   \n                \\<longrightarrow> (\\<exists>y \\<in> set_mset (mset_ecl (C,\\<sigma>')). (x,y) \\<in> (mult trm_ord)))\\<close>\n             and \\<open>mset_ecl (C,\\<sigma>') \\<noteq> {#}\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     x \\<in># mset_ecl (D, \\<sigma>') \\<longrightarrow>\n     (\\<exists>y\\<in>#mset_ecl (C, \\<sigma>'). (x, y) \\<in> mult trm_ord)\n  mset_ecl (C, \\<sigma>') \\<noteq> {#}", "have \"({#} + mset_ecl (D, \\<sigma>'), {#} + mset_ecl (C, \\<sigma>')) \\<in> mult (mult trm_ord)\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in># mset_ecl (D, \\<sigma>') \\<longrightarrow>\n     (\\<exists>y\\<in>#mset_ecl (C, \\<sigma>'). (x, y) \\<in> mult trm_ord)\n  mset_ecl (C, \\<sigma>') \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. ({#} + mset_ecl (D, \\<sigma>'), {#} + mset_ecl (C, \\<sigma>'))\n    \\<in> mult (mult trm_ord)", "using dom [of \"(mset_ecl (C,\\<sigma>'))\" \"mset_ecl (D,\\<sigma>')\" \"{#}\"]"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in># mset_ecl (D, \\<sigma>') \\<longrightarrow>\n     (\\<exists>y\\<in>#mset_ecl (C, \\<sigma>'). (x, y) \\<in> mult trm_ord)\n  mset_ecl (C, \\<sigma>') \\<noteq> {#}\n  mset_ecl (C, \\<sigma>') \\<noteq> {#} \\<and>\n  (\\<forall>k\\<in>#mset_ecl (D, \\<sigma>').\n      \\<exists>j\\<in>#mset_ecl (C, \\<sigma>').\n         (k, j) \\<in> mult trm_ord) \\<longrightarrow>\n  ({#} + mset_ecl (D, \\<sigma>'), {#} + mset_ecl (C, \\<sigma>'))\n  \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. ({#} + mset_ecl (D, \\<sigma>'), {#} + mset_ecl (C, \\<sigma>'))\n    \\<in> mult (mult trm_ord)", "by auto"], ["proof (state)\nthis:\n  ({#} + mset_ecl (D, \\<sigma>'), {#} + mset_ecl (C, \\<sigma>'))\n  \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  ({#} + mset_ecl (D, \\<sigma>'), {#} + mset_ecl (C, \\<sigma>'))\n  \\<in> mult (mult trm_ord)", "have \"(mset_ecl (D, \\<sigma>'), mset_ecl (C, \\<sigma>')) \\<in> mult (mult trm_ord)\""], ["proof (prove)\nusing this:\n  ({#} + mset_ecl (D, \\<sigma>'), {#} + mset_ecl (C, \\<sigma>'))\n  \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. (mset_ecl (D, \\<sigma>'), mset_ecl (C, \\<sigma>'))\n    \\<in> mult (mult trm_ord)", "by auto"], ["proof (state)\nthis:\n  (mset_ecl (D, \\<sigma>'), mset_ecl (C, \\<sigma>'))\n  \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  (mset_ecl (D, \\<sigma>'), mset_ecl (C, \\<sigma>'))\n  \\<in> mult (mult trm_ord)", "have \"( (D,\\<sigma>'), (C,\\<sigma>') ) \\<in> ecl_ord\""], ["proof (prove)\nusing this:\n  (mset_ecl (D, \\<sigma>'), mset_ecl (C, \\<sigma>'))\n  \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. ((D, \\<sigma>'), C, \\<sigma>') \\<in> ecl_ord", "unfolding ecl_ord_def"], ["proof (prove)\nusing this:\n  (mset_ecl (D, \\<sigma>'), mset_ecl (C, \\<sigma>'))\n  \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. ((D, \\<sigma>'), C, \\<sigma>')\n    \\<in> {(x, y). (mset_ecl x, mset_ecl y) \\<in> mult (mult trm_ord)}", "by auto"], ["proof (state)\nthis:\n  ((D, \\<sigma>'), C, \\<sigma>') \\<in> ecl_ord\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from st"], ["proof (chain)\npicking this:\n  subterm t p u'", "obtain t' where rt: \"(replace_subterm t p v t')\""], ["proof (prove)\nusing this:\n  subterm t p u'\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        replace_subterm t p v t' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using replace_subterm_is_a_function"], ["proof (prove)\nusing this:\n  subterm t p u'\n  subterm ?t ?p ?u \\<Longrightarrow> \\<exists>s. replace_subterm ?t ?p ?v s\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        replace_subterm t p v t' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  replace_subterm t p v t'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from st"], ["proof (chain)\npicking this:\n  subterm t p u'", "obtain R Cl_R nt_R L' Cl_C Cl_D  where \n            ntr: \"nt_R = (dom_trms Cl_R (subst_set \n              ((trms_ecl C) \\<union> (trms_ecl D) \\<union> \n              { r. \\<exists> q. (q,p) \\<in> (pos_ord C t) \\<and> (subterm t q r) }) \\<sigma>'))\"\n            and r: \"R = Ecl Cl_R nt_R\" \n            and clc: \"Cl_C = (cl_ecl C)\"\n            and cld: \"Cl_D = (cl_ecl D)\"\n            and clr: \"Cl_R = (subst_cl ((Cl_C - { L1 }) \\<union> ((Cl_D - { L2 }) \\<union> { L' } )) \\<sigma>')\"\n            and l': \"L' = mk_lit polarity (Eq t' s)\""], ["proof (prove)\nusing this:\n  subterm t p u'\n\ngoal (1 subgoal):\n 1. (\\<And>nt_R Cl_R R Cl_C Cl_D L'.\n        \\<lbrakk>nt_R =\n                 dom_trms Cl_R\n                  (subst_set\n                    (trms_ecl C \\<union> trms_ecl D \\<union>\n                     {r. \\<exists>q.\n                            (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n                    \\<sigma>');\n         R = Ecl Cl_R nt_R; Cl_C = cl_ecl C; Cl_D = cl_ecl D;\n         Cl_R =\n         subst_cl (Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'}))\n          \\<sigma>';\n         L' = mk_lit polarity (Eq t' s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  nt_R =\n  dom_trms Cl_R\n   (subst_set\n     (trms_ecl C \\<union> trms_ecl D \\<union>\n      {r. \\<exists>q. (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n     \\<sigma>')\n  R = Ecl Cl_R nt_R\n  Cl_C = cl_ecl C\n  Cl_D = cl_ecl D\n  Cl_R =\n  subst_cl (Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'})) \\<sigma>'\n  L' = mk_lit polarity (Eq t' s)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from \\<open>orient_lit_inst L1 t s polarity \\<sigma>'\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L1 t s polarity \\<sigma>'", "have \"vars_of t \\<subseteq> vars_of_lit L1\""], ["proof (prove)\nusing this:\n  orient_lit_inst L1 t s polarity \\<sigma>'\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L1", "using orient_lit_inst_vars"], ["proof (prove)\nusing this:\n  orient_lit_inst L1 t s polarity \\<sigma>'\n  orient_lit_inst ?L ?t ?s ?p ?\\<sigma> \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_lit L1", "by auto"], ["proof (state)\nthis:\n  vars_of t \\<subseteq> vars_of_lit L1\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from \\<open>L1 \\<in> (cl_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  L1 \\<in> cl_ecl C", "have \"vars_of_lit L1 \\<subseteq> vars_of_cl (cl_ecl C)\""], ["proof (prove)\nusing this:\n  L1 \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. vars_of_lit L1 \\<subseteq> vars_of_cl (cl_ecl C)", "by auto"], ["proof (state)\nthis:\n  vars_of_lit L1 \\<subseteq> vars_of_cl (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from this and \\<open>vars_of t \\<subseteq> vars_of_lit L1\\<close>"], ["proof (chain)\npicking this:\n  vars_of_lit L1 \\<subseteq> vars_of_cl (cl_ecl C)\n  vars_of t \\<subseteq> vars_of_lit L1", "have \"vars_of t \\<subseteq>vars_of_cl (cl_ecl C)\""], ["proof (prove)\nusing this:\n  vars_of_lit L1 \\<subseteq> vars_of_cl (cl_ecl C)\n  vars_of t \\<subseteq> vars_of_lit L1\n\ngoal (1 subgoal):\n 1. vars_of t \\<subseteq> vars_of_cl (cl_ecl C)", "by auto"], ["proof (state)\nthis:\n  vars_of t \\<subseteq> vars_of_cl (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from this and \\<open>coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\\<close>"], ["proof (chain)\npicking this:\n  vars_of t \\<subseteq> vars_of_cl (cl_ecl C)\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))", "have \"coincide_on \\<sigma> \\<sigma>' (vars_of t)\""], ["proof (prove)\nusing this:\n  vars_of t \\<subseteq> vars_of_cl (cl_ecl C)\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\n\ngoal (1 subgoal):\n 1. coincide_on \\<sigma> \\<sigma>' (vars_of t)", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  vars_of t \\<subseteq> vars_of_cl (cl_ecl C)\n  \\<forall>x\\<in>vars_of_cl (cl_ecl C).\n     Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of t. Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  coincide_on \\<sigma> \\<sigma>' (vars_of t)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of t)", "have \"subst t \\<sigma> = subst t \\<sigma>'\""], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of t)\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>'", "using coincide_on_term"], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of t)\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of ?t) \\<Longrightarrow>\n  ?t \\<lhd> ?\\<sigma> = ?t \\<lhd> ?\\<eta>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from \\<open>(\\<forall>x \\<in> (cl_ecl D) - { L2 }. ( (subst_lit x \\<sigma>'),(subst_lit L2 \\<sigma>')) \n                                        \\<in> lit_ord)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>cl_ecl D - {L2}.\n     (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord", "have \"strictly_maximal_literal D L2 \\<sigma>'\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>cl_ecl D - {L2}.\n     (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. strictly_maximal_literal D L2 \\<sigma>'", "unfolding strictly_maximal_literal_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>cl_ecl D - {L2}.\n     (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>cl_ecl D - {L2}.\n       (subst_lit x \\<sigma>', subst_lit L2 \\<sigma>') \\<in> lit_ord", "by metis"], ["proof (state)\nthis:\n  strictly_maximal_literal D L2 \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from ntr"], ["proof (chain)\npicking this:\n  nt_R =\n  dom_trms Cl_R\n   (subst_set\n     (trms_ecl C \\<union> trms_ecl D \\<union>\n      {r. \\<exists>q. (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n     \\<sigma>')", "have \"nt_R = get_trms Cl_R (dom_trms Cl_R (subst_set \n              ((trms_ecl C) \\<union> (trms_ecl D) \\<union> \n              { r. \\<exists> q. (q,p) \\<in> (pos_ord C t) \\<and> (subterm t q r) }) \\<sigma>')) Ground\""], ["proof (prove)\nusing this:\n  nt_R =\n  dom_trms Cl_R\n   (subst_set\n     (trms_ecl C \\<union> trms_ecl D \\<union>\n      {r. \\<exists>q. (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n     \\<sigma>')\n\ngoal (1 subgoal):\n 1. nt_R =\n    get_trms Cl_R\n     (dom_trms Cl_R\n       (subst_set\n         (trms_ecl C \\<union> trms_ecl D \\<union>\n          {r. \\<exists>q. (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n         \\<sigma>'))\n     Ground", "unfolding get_trms_def"], ["proof (prove)\nusing this:\n  nt_R =\n  dom_trms Cl_R\n   (subst_set\n     (trms_ecl C \\<union> trms_ecl D \\<union>\n      {r. \\<exists>q. (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n     \\<sigma>')\n\ngoal (1 subgoal):\n 1. nt_R =\n    (if Ground = FirstOrder\n     then filter_trms Cl_R\n           (dom_trms Cl_R\n             (subst_set\n               (trms_ecl C \\<union> trms_ecl D \\<union>\n                {r. \\<exists>q.\n                       (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n               \\<sigma>'))\n     else dom_trms Cl_R\n           (subst_set\n             (trms_ecl C \\<union> trms_ecl D \\<union>\n              {r. \\<exists>q.\n                     (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n             \\<sigma>'))", "by auto"], ["proof (state)\nthis:\n  nt_R =\n  get_trms Cl_R\n   (dom_trms Cl_R\n     (subst_set\n       (trms_ecl C \\<union> trms_ecl D \\<union>\n        {r. \\<exists>q. (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n       \\<sigma>'))\n   Ground\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from this \\<open>(subst u \\<sigma>') \\<noteq> (subst v \\<sigma>')\\<close> \\<open>\\<not> is_a_variable u'\\<close> l1 l2 el1 el2  \n        \\<open>variable_disjoint C D\\<close> rte r o1 o2 t st rt l' clr ntr clr clc cld \\<open>R = Ecl Cl_R nt_R\\<close>\n        \\<open>( (subst_lit L2 \\<sigma>'),(subst_lit L1 \\<sigma>')) \n            \\<in> lit_ord\\<close>  \n        \\<open>strictly_maximal_literal D L2 \\<sigma>' \\<close>"], ["proof (chain)\npicking this:\n  nt_R =\n  get_trms Cl_R\n   (dom_trms Cl_R\n     (subst_set\n       (trms_ecl C \\<union> trms_ecl D \\<union>\n        {r. \\<exists>q. (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n       \\<sigma>'))\n   Ground\n  u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>'\n  \\<not> is_a_variable u'\n  L1 \\<in> cl_ecl C\n  L2 \\<in> cl_ecl D\n  eligible_literal L1 C \\<sigma>'\n  eligible_literal L2 D \\<sigma>'\n  variable_disjoint C D\n  allowed_redex u' C \\<sigma>'\n  R = Ecl Cl_R nt_R\n  orient_lit_inst L1 t s polarity \\<sigma>'\n  orient_lit_inst L2 u v pos \\<sigma>'\n  ck_unifier u' u \\<sigma>' Ground\n  subterm t p u'\n  replace_subterm t p v t'\n  L' = mk_lit polarity (Eq t' s)\n  Cl_R =\n  subst_cl (Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'})) \\<sigma>'\n  nt_R =\n  dom_trms Cl_R\n   (subst_set\n     (trms_ecl C \\<union> trms_ecl D \\<union>\n      {r. \\<exists>q. (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n     \\<sigma>')\n  Cl_R =\n  subst_cl (Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'})) \\<sigma>'\n  Cl_C = cl_ecl C\n  Cl_D = cl_ecl D\n  R = Ecl Cl_R nt_R\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord\n  strictly_maximal_literal D L2 \\<sigma>'", "have \"superposition C D R \\<sigma>' Ground ((Cl_C - { L1 }) \\<union> ((Cl_D - { L2 }) \\<union> { L' } ))\""], ["proof (prove)\nusing this:\n  nt_R =\n  get_trms Cl_R\n   (dom_trms Cl_R\n     (subst_set\n       (trms_ecl C \\<union> trms_ecl D \\<union>\n        {r. \\<exists>q. (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n       \\<sigma>'))\n   Ground\n  u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>'\n  \\<not> is_a_variable u'\n  L1 \\<in> cl_ecl C\n  L2 \\<in> cl_ecl D\n  eligible_literal L1 C \\<sigma>'\n  eligible_literal L2 D \\<sigma>'\n  variable_disjoint C D\n  allowed_redex u' C \\<sigma>'\n  R = Ecl Cl_R nt_R\n  orient_lit_inst L1 t s polarity \\<sigma>'\n  orient_lit_inst L2 u v pos \\<sigma>'\n  ck_unifier u' u \\<sigma>' Ground\n  subterm t p u'\n  replace_subterm t p v t'\n  L' = mk_lit polarity (Eq t' s)\n  Cl_R =\n  subst_cl (Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'})) \\<sigma>'\n  nt_R =\n  dom_trms Cl_R\n   (subst_set\n     (trms_ecl C \\<union> trms_ecl D \\<union>\n      {r. \\<exists>q. (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n     \\<sigma>')\n  Cl_R =\n  subst_cl (Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'})) \\<sigma>'\n  Cl_C = cl_ecl C\n  Cl_D = cl_ecl D\n  R = Ecl Cl_R nt_R\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord\n  strictly_maximal_literal D L2 \\<sigma>'\n\ngoal (1 subgoal):\n 1. superposition C D R \\<sigma>' Ground\n     (Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'}))", "unfolding superposition_def"], ["proof (prove)\nusing this:\n  nt_R =\n  get_trms Cl_R\n   (dom_trms Cl_R\n     (subst_set\n       (trms_ecl C \\<union> trms_ecl D \\<union>\n        {r. \\<exists>q. (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n       \\<sigma>'))\n   Ground\n  u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>'\n  \\<not> is_a_variable u'\n  L1 \\<in> cl_ecl C\n  L2 \\<in> cl_ecl D\n  eligible_literal L1 C \\<sigma>'\n  eligible_literal L2 D \\<sigma>'\n  variable_disjoint C D\n  allowed_redex u' C \\<sigma>'\n  R = Ecl Cl_R nt_R\n  orient_lit_inst L1 t s polarity \\<sigma>'\n  orient_lit_inst L2 u v pos \\<sigma>'\n  ck_unifier u' u \\<sigma>' Ground\n  subterm t p u'\n  replace_subterm t p v t'\n  L' = mk_lit polarity (Eq t' s)\n  Cl_R =\n  subst_cl (Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'})) \\<sigma>'\n  nt_R =\n  dom_trms Cl_R\n   (subst_set\n     (trms_ecl C \\<union> trms_ecl D \\<union>\n      {r. \\<exists>q. (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n     \\<sigma>')\n  Cl_R =\n  subst_cl (Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'})) \\<sigma>'\n  Cl_C = cl_ecl C\n  Cl_D = cl_ecl D\n  R = Ecl Cl_R nt_R\n  (subst_lit L2 \\<sigma>', subst_lit L1 \\<sigma>') \\<in> lit_ord\n  strictly_maximal_literal D L2 \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<exists>L t s u v M p Cl_P1 Cl_P2 Cl_Ca polarity t' u' L'a trms_C.\n       L \\<in> Cl_P1 \\<and>\n       M \\<in> Cl_P2 \\<and>\n       eligible_literal L C \\<sigma>' \\<and>\n       eligible_literal M D \\<sigma>' \\<and>\n       variable_disjoint C D \\<and>\n       Cl_P1 = cl_ecl C \\<and>\n       Cl_P2 = cl_ecl D \\<and>\n       \\<not> is_a_variable u' \\<and>\n       allowed_redex u' C \\<sigma>' \\<and>\n       trms_C =\n       get_trms Cl_Ca\n        (dom_trms Cl_Ca\n          (subst_set\n            (trms_ecl C \\<union> trms_ecl D \\<union>\n             {r. \\<exists>q. (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n            \\<sigma>'))\n        Ground \\<and>\n       R = Ecl Cl_Ca trms_C \\<and>\n       orient_lit_inst M u v pos \\<sigma>' \\<and>\n       orient_lit_inst L t s polarity \\<sigma>' \\<and>\n       u \\<lhd> \\<sigma>' \\<noteq> v \\<lhd> \\<sigma>' \\<and>\n       subterm t p u' \\<and>\n       ck_unifier u' u \\<sigma>' Ground \\<and>\n       replace_subterm t p v t' \\<and>\n       (Ground = FirstOrder \\<or>\n        (subst_lit M \\<sigma>', subst_lit L \\<sigma>') \\<in> lit_ord) \\<and>\n       (Ground = FirstOrder \\<or>\n        strictly_maximal_literal D M \\<sigma>') \\<and>\n       L'a = mk_lit polarity (Eq t' s) \\<and>\n       Cl_Ca =\n       subst_cl (Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'}))\n        \\<sigma>' \\<and>\n       Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'}) =\n       Cl_P1 - {L} \\<union> (Cl_P2 - {M} \\<union> {L'a})", "by blast"], ["proof (state)\nthis:\n  superposition C D R \\<sigma>' Ground\n   (Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'}))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from l2"], ["proof (chain)\npicking this:\n  L2 \\<in> cl_ecl D", "have \"(subst_lit L2 \\<sigma>') \\<in> (subst_cl (cl_ecl D) \\<sigma>')\""], ["proof (prove)\nusing this:\n  L2 \\<in> cl_ecl D\n\ngoal (1 subgoal):\n 1. subst_lit L2 \\<sigma>' \\<in> subst_cl (cl_ecl D) \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  subst_lit L2 \\<sigma>' \\<in> subst_cl (cl_ecl D) \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from this and \\<open>ground_clause (subst_cl (cl_ecl D) \\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  subst_lit L2 \\<sigma>' \\<in> subst_cl (cl_ecl D) \\<sigma>'\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>')", "have \"vars_of_lit (subst_lit L2 \\<sigma>') = {}\""], ["proof (prove)\nusing this:\n  subst_lit L2 \\<sigma>' \\<in> subst_cl (cl_ecl D) \\<sigma>'\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>')\n\ngoal (1 subgoal):\n 1. vars_of_lit (subst_lit L2 \\<sigma>') = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_lit (subst_lit L2 \\<sigma>') = {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from this and o2"], ["proof (chain)\npicking this:\n  vars_of_lit (subst_lit L2 \\<sigma>') = {}\n  orient_lit_inst L2 u v pos \\<sigma>'", "have \"vars_of (subst v \\<sigma>') = {}\""], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L2 \\<sigma>') = {}\n  orient_lit_inst L2 u v pos \\<sigma>'\n\ngoal (1 subgoal):\n 1. vars_of (v \\<lhd> \\<sigma>') = {}", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L2 \\<sigma>') = {}\n  (L2 = Pos (Eq u v) \\<or> L2 = Pos (Eq v u)) \\<and>\n  (u \\<lhd> \\<sigma>', v \\<lhd> \\<sigma>') \\<notin> trm_ord \\<and>\n  pos = pos \\<or>\n  (L2 = Neg (Eq u v) \\<or> L2 = Neg (Eq v u)) \\<and>\n  (u \\<lhd> \\<sigma>', v \\<lhd> \\<sigma>') \\<notin> trm_ord \\<and> pos = neg\n\ngoal (1 subgoal):\n 1. vars_of (v \\<lhd> \\<sigma>') = {}", "using vars_of_lit.simps vars_of_eq.simps"], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L2 \\<sigma>') = {}\n  (L2 = Pos (Eq u v) \\<or> L2 = Pos (Eq v u)) \\<and>\n  (u \\<lhd> \\<sigma>', v \\<lhd> \\<sigma>') \\<notin> trm_ord \\<and>\n  pos = pos \\<or>\n  (L2 = Neg (Eq u v) \\<or> L2 = Neg (Eq v u)) \\<and>\n  (u \\<lhd> \\<sigma>', v \\<lhd> \\<sigma>') \\<notin> trm_ord \\<and> pos = neg\n  vars_of_lit (Pos ?e) = vars_of_eq ?e\n  vars_of_lit (Neg ?e) = vars_of_eq ?e\n  vars_of_eq (Eq ?t ?s) = vars_of ?t \\<union> vars_of ?s\n\ngoal (1 subgoal):\n 1. vars_of (v \\<lhd> \\<sigma>') = {}", "by force"], ["proof (state)\nthis:\n  vars_of (v \\<lhd> \\<sigma>') = {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from \\<open>(coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)))\\<close>"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))", "have \"(subst_cl (cl_ecl C) \\<sigma>') = (subst_cl (cl_ecl C) \\<sigma>)\""], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl C) \\<sigma>' = subst_cl (cl_ecl C) \\<sigma>", "using  coincide_on_cl [of  \\<sigma> \\<sigma>' \"(cl_ecl C)\"]"], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)) \\<Longrightarrow>\n  subst_cl (cl_ecl C) \\<sigma> = subst_cl (cl_ecl C) \\<sigma>'\n\ngoal (1 subgoal):\n 1. subst_cl (cl_ecl C) \\<sigma>' = subst_cl (cl_ecl C) \\<sigma>", "by auto"], ["proof (state)\nthis:\n  subst_cl (cl_ecl C) \\<sigma>' = subst_cl (cl_ecl C) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from this and \\<open>ground_clause (subst_cl (cl_ecl C) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  subst_cl (cl_ecl C) \\<sigma>' = subst_cl (cl_ecl C) \\<sigma>\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)", "have \"ground_clause (subst_cl (cl_ecl C) \\<sigma>')\""], ["proof (prove)\nusing this:\n  subst_cl (cl_ecl C) \\<sigma>' = subst_cl (cl_ecl C) \\<sigma>\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. ground_clause (subst_cl (cl_ecl C) \\<sigma>')", "using  \n              coincide_on_cl"], ["proof (prove)\nusing this:\n  subst_cl (cl_ecl C) \\<sigma>' = subst_cl (cl_ecl C) \\<sigma>\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of_cl ?C) \\<Longrightarrow>\n  subst_cl ?C ?\\<sigma> = subst_cl ?C ?\\<eta>\n\ngoal (1 subgoal):\n 1. ground_clause (subst_cl (cl_ecl C) \\<sigma>')", "by auto"], ["proof (state)\nthis:\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from l1"], ["proof (chain)\npicking this:\n  L1 \\<in> cl_ecl C", "have \"(subst_lit L1 \\<sigma>') \\<in> (subst_cl (cl_ecl C) \\<sigma>')\""], ["proof (prove)\nusing this:\n  L1 \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. subst_lit L1 \\<sigma>' \\<in> subst_cl (cl_ecl C) \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  subst_lit L1 \\<sigma>' \\<in> subst_cl (cl_ecl C) \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from this and \\<open>ground_clause (subst_cl (cl_ecl C) \\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  subst_lit L1 \\<sigma>' \\<in> subst_cl (cl_ecl C) \\<sigma>'\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>')", "have \"vars_of_lit (subst_lit L1 \\<sigma>') = {}\""], ["proof (prove)\nusing this:\n  subst_lit L1 \\<sigma>' \\<in> subst_cl (cl_ecl C) \\<sigma>'\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>')\n\ngoal (1 subgoal):\n 1. vars_of_lit (subst_lit L1 \\<sigma>') = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_lit (subst_lit L1 \\<sigma>') = {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from this and o1"], ["proof (chain)\npicking this:\n  vars_of_lit (subst_lit L1 \\<sigma>') = {}\n  orient_lit_inst L1 t s polarity \\<sigma>'", "have \"vars_of (subst t \\<sigma>') = {}\""], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L1 \\<sigma>') = {}\n  orient_lit_inst L1 t s polarity \\<sigma>'\n\ngoal (1 subgoal):\n 1. vars_of (t \\<lhd> \\<sigma>') = {}", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L1 \\<sigma>') = {}\n  (L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>', s \\<lhd> \\<sigma>') \\<notin> trm_ord \\<and>\n  polarity = pos \\<or>\n  (L1 = Neg (Eq t s) \\<or> L1 = Neg (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>', s \\<lhd> \\<sigma>') \\<notin> trm_ord \\<and>\n  polarity = neg\n\ngoal (1 subgoal):\n 1. vars_of (t \\<lhd> \\<sigma>') = {}", "using vars_of_lit.simps vars_of_eq.simps"], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L1 \\<sigma>') = {}\n  (L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>', s \\<lhd> \\<sigma>') \\<notin> trm_ord \\<and>\n  polarity = pos \\<or>\n  (L1 = Neg (Eq t s) \\<or> L1 = Neg (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>', s \\<lhd> \\<sigma>') \\<notin> trm_ord \\<and>\n  polarity = neg\n  vars_of_lit (Pos ?e) = vars_of_eq ?e\n  vars_of_lit (Neg ?e) = vars_of_eq ?e\n  vars_of_eq (Eq ?t ?s) = vars_of ?t \\<union> vars_of ?s\n\ngoal (1 subgoal):\n 1. vars_of (t \\<lhd> \\<sigma>') = {}", "by force"], ["proof (state)\nthis:\n  vars_of (t \\<lhd> \\<sigma>') = {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from \\<open>vars_of_lit (subst_lit L1 \\<sigma>') = {}\\<close>\n          and o1"], ["proof (chain)\npicking this:\n  vars_of_lit (subst_lit L1 \\<sigma>') = {}\n  orient_lit_inst L1 t s polarity \\<sigma>'", "have \"vars_of (subst s \\<sigma>') = {}\""], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L1 \\<sigma>') = {}\n  orient_lit_inst L1 t s polarity \\<sigma>'\n\ngoal (1 subgoal):\n 1. vars_of (s \\<lhd> \\<sigma>') = {}", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L1 \\<sigma>') = {}\n  (L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>', s \\<lhd> \\<sigma>') \\<notin> trm_ord \\<and>\n  polarity = pos \\<or>\n  (L1 = Neg (Eq t s) \\<or> L1 = Neg (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>', s \\<lhd> \\<sigma>') \\<notin> trm_ord \\<and>\n  polarity = neg\n\ngoal (1 subgoal):\n 1. vars_of (s \\<lhd> \\<sigma>') = {}", "using vars_of_lit.simps vars_of_eq.simps"], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L1 \\<sigma>') = {}\n  (L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>', s \\<lhd> \\<sigma>') \\<notin> trm_ord \\<and>\n  polarity = pos \\<or>\n  (L1 = Neg (Eq t s) \\<or> L1 = Neg (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>', s \\<lhd> \\<sigma>') \\<notin> trm_ord \\<and>\n  polarity = neg\n  vars_of_lit (Pos ?e) = vars_of_eq ?e\n  vars_of_lit (Neg ?e) = vars_of_eq ?e\n  vars_of_eq (Eq ?t ?s) = vars_of ?t \\<union> vars_of ?s\n\ngoal (1 subgoal):\n 1. vars_of (s \\<lhd> \\<sigma>') = {}", "by force"], ["proof (state)\nthis:\n  vars_of (s \\<lhd> \\<sigma>') = {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from \\<open>vars_of (subst t \\<sigma>') = {}\\<close> and \\<open>vars_of (subst v \\<sigma>') = {}\\<close>\n          and rt"], ["proof (chain)\npicking this:\n  vars_of (t \\<lhd> \\<sigma>') = {}\n  vars_of (v \\<lhd> \\<sigma>') = {}\n  replace_subterm t p v t'", "have \"vars_of (subst t' \\<sigma>') = {}\""], ["proof (prove)\nusing this:\n  vars_of (t \\<lhd> \\<sigma>') = {}\n  vars_of (v \\<lhd> \\<sigma>') = {}\n  replace_subterm t p v t'\n\ngoal (1 subgoal):\n 1. vars_of (t' \\<lhd> \\<sigma>') = {}", "using ground_replacement [of t p v t' \\<sigma>']"], ["proof (prove)\nusing this:\n  vars_of (t \\<lhd> \\<sigma>') = {}\n  vars_of (v \\<lhd> \\<sigma>') = {}\n  replace_subterm t p v t'\n  \\<lbrakk>replace_subterm t p v t'; ground_term (t \\<lhd> \\<sigma>');\n   ground_term (v \\<lhd> \\<sigma>')\\<rbrakk>\n  \\<Longrightarrow> ground_term (t' \\<lhd> \\<sigma>')\n\ngoal (1 subgoal):\n 1. vars_of (t' \\<lhd> \\<sigma>') = {}", "unfolding ground_term_def"], ["proof (prove)\nusing this:\n  vars_of (t \\<lhd> \\<sigma>') = {}\n  vars_of (v \\<lhd> \\<sigma>') = {}\n  replace_subterm t p v t'\n  \\<lbrakk>replace_subterm t p v t'; vars_of (t \\<lhd> \\<sigma>') = {};\n   vars_of (v \\<lhd> \\<sigma>') = {}\\<rbrakk>\n  \\<Longrightarrow> vars_of (t' \\<lhd> \\<sigma>') = {}\n\ngoal (1 subgoal):\n 1. vars_of (t' \\<lhd> \\<sigma>') = {}", "by blast"], ["proof (state)\nthis:\n  vars_of (t' \\<lhd> \\<sigma>') = {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from \\<open>vars_of (subst t' \\<sigma>') = {}\\<close> and \\<open>vars_of (subst s \\<sigma>') = {}\\<close>"], ["proof (chain)\npicking this:\n  vars_of (t' \\<lhd> \\<sigma>') = {}\n  vars_of (s \\<lhd> \\<sigma>') = {}", "have \"vars_of_eq (subst_equation (Eq t' s) \\<sigma>') = {}\""], ["proof (prove)\nusing this:\n  vars_of (t' \\<lhd> \\<sigma>') = {}\n  vars_of (s \\<lhd> \\<sigma>') = {}\n\ngoal (1 subgoal):\n 1. vars_of_eq (subst_equation (Eq t' s) \\<sigma>') = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_eq (subst_equation (Eq t' s) \\<sigma>') = {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from l'"], ["proof (chain)\npicking this:\n  L' = mk_lit polarity (Eq t' s)", "have \"L' = (Pos (Eq t' s)) \\<or> L' = (Neg (Eq t' s))\""], ["proof (prove)\nusing this:\n  L' = mk_lit polarity (Eq t' s)\n\ngoal (1 subgoal):\n 1. L' = Pos (Eq t' s) \\<or> L' = Neg (Eq t' s)", "using mk_lit.elims"], ["proof (prove)\nusing this:\n  L' = mk_lit polarity (Eq t' s)\n  \\<lbrakk>mk_lit ?x ?xa = ?y;\n   \\<And>x.\n      \\<lbrakk>?x = pos; ?xa = x; ?y = Pos x\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>x.\n      \\<lbrakk>?x = neg; ?xa = x; ?y = Neg x\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. L' = Pos (Eq t' s) \\<or> L' = Neg (Eq t' s)", "by auto"], ["proof (state)\nthis:\n  L' = Pos (Eq t' s) \\<or> L' = Neg (Eq t' s)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from this and \\<open>vars_of_eq (subst_equation (Eq t' s) \\<sigma>') = {}\\<close>"], ["proof (chain)\npicking this:\n  L' = Pos (Eq t' s) \\<or> L' = Neg (Eq t' s)\n  vars_of_eq (subst_equation (Eq t' s) \\<sigma>') = {}", "have \"vars_of_lit (subst_lit L' \\<sigma>') = {}\""], ["proof (prove)\nusing this:\n  L' = Pos (Eq t' s) \\<or> L' = Neg (Eq t' s)\n  vars_of_eq (subst_equation (Eq t' s) \\<sigma>') = {}\n\ngoal (1 subgoal):\n 1. vars_of_lit (subst_lit L' \\<sigma>') = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_lit (subst_lit L' \\<sigma>') = {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from \\<open>C \\<in> S\\<close> and \\<open>D \\<in> S\\<close> and \n          \\<open>superposition C D R \\<sigma>' Ground ((Cl_C - { L1 }) \\<union> ((Cl_D - { L2 }) \\<union> { L' } ))\\<close>"], ["proof (chain)\npicking this:\n  C \\<in> S\n  D \\<in> S\n  superposition C D R \\<sigma>' Ground\n   (Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'}))", "have \"derivable R { C,D } S \\<sigma>' Ground ((Cl_C - { L1 }) \\<union> ((Cl_D - { L2 }) \\<union> { L' } ))\""], ["proof (prove)\nusing this:\n  C \\<in> S\n  D \\<in> S\n  superposition C D R \\<sigma>' Ground\n   (Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'}))\n\ngoal (1 subgoal):\n 1. derivable R {C, D} S \\<sigma>' Ground\n     (Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'}))", "unfolding derivable_def"], ["proof (prove)\nusing this:\n  C \\<in> S\n  D \\<in> S\n  superposition C D R \\<sigma>' Ground\n   (Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'}))\n\ngoal (1 subgoal):\n 1. (\\<exists>P1 P2.\n        P1 \\<in> S \\<and>\n        P2 \\<in> S \\<and>\n        {C, D} = {P1, P2} \\<and>\n        superposition P1 P2 R \\<sigma>' Ground\n         (Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'}))) \\<or>\n    (\\<exists>P1.\n        P1 \\<in> S \\<and>\n        {C, D} = {P1} \\<and>\n        factorization P1 R \\<sigma>' Ground\n         (Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'}))) \\<or>\n    (\\<exists>P1.\n        P1 \\<in> S \\<and>\n        {C, D} = {P1} \\<and>\n        reflexion P1 R \\<sigma>' Ground\n         (Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'})))", "by auto"], ["proof (state)\nthis:\n  derivable R {C, D} S \\<sigma>' Ground\n   (Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'}))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "have \"ground_clause Cl_R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ground_clause Cl_R", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ground_clause Cl_R \\<Longrightarrow> False", "assume \"\\<not>ground_clause Cl_R\""], ["proof (state)\nthis:\n  \\<not> ground_clause Cl_R\n\ngoal (1 subgoal):\n 1. \\<not> ground_clause Cl_R \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> ground_clause Cl_R", "have \"vars_of_cl Cl_R \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<not> ground_clause Cl_R\n\ngoal (1 subgoal):\n 1. vars_of_cl Cl_R \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  vars_of_cl Cl_R \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> ground_clause Cl_R \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  vars_of_cl Cl_R \\<noteq> {}", "obtain M where \"M \\<in> Cl_R\" and \"vars_of_lit M \\<noteq> {}\""], ["proof (prove)\nusing this:\n  vars_of_cl Cl_R \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>M \\<in> Cl_R; vars_of_lit M \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M \\<in> Cl_R\n  vars_of_lit M \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> ground_clause Cl_R \\<Longrightarrow> False", "from \\<open>M \\<in> Cl_R\\<close> and clr"], ["proof (chain)\npicking this:\n  M \\<in> Cl_R\n  Cl_R =\n  subst_cl (Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'})) \\<sigma>'", "obtain M' where \"M = (subst_lit M' \\<sigma>')\" \n          and \"M' \\<in> ((Cl_C - { L1 }) \\<union> ((Cl_D - { L2 }) \\<union> { L' } )) \""], ["proof (prove)\nusing this:\n  M \\<in> Cl_R\n  Cl_R =\n  subst_cl (Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'})) \\<sigma>'\n\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        \\<lbrakk>M = subst_lit M' \\<sigma>';\n         M' \\<in> Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'})\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M = subst_lit M' \\<sigma>'\n  M' \\<in> Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'})\n\ngoal (1 subgoal):\n 1. \\<not> ground_clause Cl_R \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "assume \"M' = L'\""], ["proof (state)\nthis:\n  M' = L'\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "from this and \\<open>vars_of_lit (subst_lit L' \\<sigma>') = {}\\<close> and \\<open>vars_of_lit M \\<noteq> {}\\<close>\n              and \\<open>M = (subst_lit M' \\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  M' = L'\n  vars_of_lit (subst_lit L' \\<sigma>') = {}\n  vars_of_lit M \\<noteq> {}\n  M = subst_lit M' \\<sigma>'", "show False"], ["proof (prove)\nusing this:\n  M' = L'\n  vars_of_lit (subst_lit L' \\<sigma>') = {}\n  vars_of_lit M \\<noteq> {}\n  M = subst_lit M' \\<sigma>'\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. M' \\<noteq> L' \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M' \\<noteq> L' \\<Longrightarrow> False", "assume \"M' \\<noteq> L'\""], ["proof (state)\nthis:\n  M' \\<noteq> L'\n\ngoal (1 subgoal):\n 1. M' \\<noteq> L' \\<Longrightarrow> False", "from this and l1 clc cld and \\<open>M' \\<in>(Cl_C - { L1 }) \\<union> ((Cl_D - { L2 }) \\<union> { L' } )\\<close>"], ["proof (chain)\npicking this:\n  M' \\<noteq> L'\n  L1 \\<in> cl_ecl C\n  Cl_C = cl_ecl C\n  Cl_D = cl_ecl D\n  M' \\<in> Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'})", "have \"M' \\<in> (cl_ecl C) \\<or> M' \\<in> (cl_ecl D)\""], ["proof (prove)\nusing this:\n  M' \\<noteq> L'\n  L1 \\<in> cl_ecl C\n  Cl_C = cl_ecl C\n  Cl_D = cl_ecl D\n  M' \\<in> Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'})\n\ngoal (1 subgoal):\n 1. M' \\<in> cl_ecl C \\<or> M' \\<in> cl_ecl D", "by auto"], ["proof (state)\nthis:\n  M' \\<in> cl_ecl C \\<or> M' \\<in> cl_ecl D\n\ngoal (1 subgoal):\n 1. M' \\<noteq> L' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  M' \\<in> cl_ecl C \\<or> M' \\<in> cl_ecl D", "show False"], ["proof (prove)\nusing this:\n  M' \\<in> cl_ecl C \\<or> M' \\<in> cl_ecl D\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. M' \\<in> cl_ecl C \\<Longrightarrow> False\n 2. M' \\<in> cl_ecl D \\<Longrightarrow> False", "assume \"M' \\<in> (cl_ecl C)\""], ["proof (state)\nthis:\n  M' \\<in> cl_ecl C\n\ngoal (2 subgoals):\n 1. M' \\<in> cl_ecl C \\<Longrightarrow> False\n 2. M' \\<in> cl_ecl D \\<Longrightarrow> False", "from this and \\<open>ground_clause (subst_cl (cl_ecl C) \\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  M' \\<in> cl_ecl C\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>')", "have \n              \"vars_of_lit (subst_lit M' \\<sigma>') = {}\""], ["proof (prove)\nusing this:\n  M' \\<in> cl_ecl C\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>')\n\ngoal (1 subgoal):\n 1. vars_of_lit (subst_lit M' \\<sigma>') = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_lit (subst_lit M' \\<sigma>') = {}\n\ngoal (2 subgoals):\n 1. M' \\<in> cl_ecl C \\<Longrightarrow> False\n 2. M' \\<in> cl_ecl D \\<Longrightarrow> False", "from this and \\<open>M = (subst_lit M' \\<sigma>')\\<close> and\n              \\<open>vars_of_lit M \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  vars_of_lit (subst_lit M' \\<sigma>') = {}\n  M = subst_lit M' \\<sigma>'\n  vars_of_lit M \\<noteq> {}", "show False"], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit M' \\<sigma>') = {}\n  M = subst_lit M' \\<sigma>'\n  vars_of_lit M \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. M' \\<in> cl_ecl D \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M' \\<in> cl_ecl D \\<Longrightarrow> False", "assume \"M' \\<in> (cl_ecl D)\""], ["proof (state)\nthis:\n  M' \\<in> cl_ecl D\n\ngoal (1 subgoal):\n 1. M' \\<in> cl_ecl D \\<Longrightarrow> False", "from this and \\<open>ground_clause (subst_cl (cl_ecl D) \\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  M' \\<in> cl_ecl D\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>')", "have \n              \"vars_of_lit (subst_lit M' \\<sigma>') = {}\""], ["proof (prove)\nusing this:\n  M' \\<in> cl_ecl D\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>')\n\ngoal (1 subgoal):\n 1. vars_of_lit (subst_lit M' \\<sigma>') = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_lit (subst_lit M' \\<sigma>') = {}\n\ngoal (1 subgoal):\n 1. M' \\<in> cl_ecl D \\<Longrightarrow> False", "from this and \\<open>M = (subst_lit M' \\<sigma>')\\<close> and\n              \\<open>vars_of_lit M \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  vars_of_lit (subst_lit M' \\<sigma>') = {}\n  M = subst_lit M' \\<sigma>'\n  vars_of_lit M \\<noteq> {}", "show False"], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit M' \\<sigma>') = {}\n  M = subst_lit M' \\<sigma>'\n  vars_of_lit M \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ground_clause Cl_R\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from \\<open>ground_clause (subst_cl (cl_ecl C) \\<sigma>')\\<close> and \\<open>ground_clause (subst_cl (cl_ecl D) \\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>')\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>')", "have \"grounding_set { C,D } \\<sigma>'\""], ["proof (prove)\nusing this:\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>')\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>')\n\ngoal (1 subgoal):\n 1. grounding_set {C, D} \\<sigma>'", "unfolding grounding_set_def"], ["proof (prove)\nusing this:\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>')\n  ground_clause (subst_cl (cl_ecl D) \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<in> {C, D} \\<longrightarrow>\n       ground_clause (subst_cl (cl_ecl x) \\<sigma>')", "by auto"], ["proof (state)\nthis:\n  grounding_set {C, D} \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from \\<open>ground_clause Cl_R\\<close> and \\<open>R = Ecl Cl_R nt_R\\<close>"], ["proof (chain)\npicking this:\n  ground_clause Cl_R\n  R = Ecl Cl_R nt_R", "have \"ground_clause (cl_ecl R)\""], ["proof (prove)\nusing this:\n  ground_clause Cl_R\n  R = Ecl Cl_R nt_R\n\ngoal (1 subgoal):\n 1. ground_clause (cl_ecl R)", "by auto"], ["proof (state)\nthis:\n  ground_clause (cl_ecl R)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from this and \\<open>derivable R { C,D } S \\<sigma>' Ground ((Cl_C - { L1 }) \\<union> ((Cl_D - { L2 }) \\<union> { L' } ))\\<close>\n          and \\<open>ground_inference_saturated S\\<close> \\<open>grounding_set { C,D } \\<sigma>'\\<close>"], ["proof (chain)\npicking this:\n  ground_clause (cl_ecl R)\n  derivable R {C, D} S \\<sigma>' Ground\n   (Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'}))\n  ground_inference_saturated S\n  grounding_set {C, D} \\<sigma>'", "have \"(redundant_inference R S { C,D } \\<sigma>')\""], ["proof (prove)\nusing this:\n  ground_clause (cl_ecl R)\n  derivable R {C, D} S \\<sigma>' Ground\n   (Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'}))\n  ground_inference_saturated S\n  grounding_set {C, D} \\<sigma>'\n\ngoal (1 subgoal):\n 1. redundant_inference R S {C, D} \\<sigma>'", "unfolding ground_inference_saturated_def"], ["proof (prove)\nusing this:\n  ground_clause (cl_ecl R)\n  derivable R {C, D} S \\<sigma>' Ground\n   (Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'}))\n  \\<forall>C P \\<sigma> C'.\n     derivable C P S \\<sigma> Ground C' \\<longrightarrow>\n     ground_clause (cl_ecl C) \\<longrightarrow>\n     grounding_set P \\<sigma> \\<longrightarrow>\n     redundant_inference C S P \\<sigma>\n  grounding_set {C, D} \\<sigma>'\n\ngoal (1 subgoal):\n 1. redundant_inference R S {C, D} \\<sigma>'", "by blast"], ["proof (state)\nthis:\n  redundant_inference R S {C, D} \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  redundant_inference R S {C, D} \\<sigma>'", "obtain S' where \"S' \\<subseteq> (instances S)\" and \n          \"(set_entails_clause (clset_instances S') (cl_ecl R))\"\n          and order: \"(\\<forall>x \\<in> S'. (((fst x),(snd x)),(C,\\<sigma>')) \\<in> ecl_ord \n          \\<or> (((fst x),(snd x)),(D,\\<sigma>')) \\<in> ecl_ord)\"\n          and all_normalized_term_included: \"(\\<forall>x \\<in> S'. \n          (subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))  \n              (trms_ecl R)))\""], ["proof (prove)\nusing this:\n  redundant_inference R S {C, D} \\<sigma>'\n\ngoal (1 subgoal):\n 1. (\\<And>S'.\n        \\<lbrakk>S' \\<subseteq> instances S;\n         set_entails_clause (clset_instances S') (cl_ecl R);\n         \\<forall>x\\<in>S'.\n            ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord \\<or>\n            ((fst x, snd x), D, \\<sigma>') \\<in> ecl_ord;\n         \\<forall>x\\<in>S'.\n            subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n             (trms_ecl R)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding redundant_inference_def"], ["proof (prove)\nusing this:\n  \\<exists>S'\\<subseteq>instances S.\n     set_entails_clause (clset_instances S') (cl_ecl R) \\<and>\n     (\\<forall>x\\<in>S'.\n         subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n          (trms_ecl R)) \\<and>\n     (\\<forall>x\\<in>S'.\n         \\<exists>D'\\<in>{C, D}.\n            ((fst x, snd x), D', \\<sigma>') \\<in> ecl_ord)\n\ngoal (1 subgoal):\n 1. (\\<And>S'.\n        \\<lbrakk>S' \\<subseteq> instances S;\n         set_entails_clause (clset_instances S') (cl_ecl R);\n         \\<forall>x\\<in>S'.\n            ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord \\<or>\n            ((fst x, snd x), D, \\<sigma>') \\<in> ecl_ord;\n         \\<forall>x\\<in>S'.\n            subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n             (trms_ecl R)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  S' \\<subseteq> instances S\n  set_entails_clause (clset_instances S') (cl_ecl R)\n  \\<forall>x\\<in>S'.\n     ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord \\<or>\n     ((fst x, snd x), D, \\<sigma>') \\<in> ecl_ord\n  \\<forall>x\\<in>S'.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) (trms_ecl R)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "have all_smaller: \"(\\<forall>x \\<in> S'. (((fst x),(snd x)),(C,\\<sigma>)) \\<in> ecl_ord)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S'. ((fst x, snd x), C, \\<sigma>) \\<in> ecl_ord", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>S'.\n               ((fst x, snd x), C, \\<sigma>)\n               \\<in> ecl_ord) \\<Longrightarrow>\n    False", "assume \"\\<not>(\\<forall>x \\<in> S'. (((fst x),(snd x)),(C,\\<sigma>)) \\<in> ecl_ord)\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>x\\<in>S'. ((fst x, snd x), C, \\<sigma>) \\<in> ecl_ord)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>S'.\n               ((fst x, snd x), C, \\<sigma>)\n               \\<in> ecl_ord) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>x\\<in>S'. ((fst x, snd x), C, \\<sigma>) \\<in> ecl_ord)", "obtain x where \"x \\<in> S'\" and \"(((fst x),(snd x)),(C,\\<sigma>)) \\<notin> ecl_ord\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x\\<in>S'. ((fst x, snd x), C, \\<sigma>) \\<in> ecl_ord)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> S';\n         ((fst x, snd x), C, \\<sigma>) \\<notin> ecl_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> S'\n  ((fst x, snd x), C, \\<sigma>) \\<notin> ecl_ord\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>S'.\n               ((fst x, snd x), C, \\<sigma>)\n               \\<in> ecl_ord) \\<Longrightarrow>\n    False", "from \\<open>x \\<in> S'\\<close> and order"], ["proof (chain)\npicking this:\n  x \\<in> S'\n  \\<forall>x\\<in>S'.\n     ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord \\<or>\n     ((fst x, snd x), D, \\<sigma>') \\<in> ecl_ord", "have \"(((fst x),(snd x)),(C,\\<sigma>')) \\<in> ecl_ord \n          \\<or> (((fst x),(snd x)),(D,\\<sigma>')) \\<in> ecl_ord\""], ["proof (prove)\nusing this:\n  x \\<in> S'\n  \\<forall>x\\<in>S'.\n     ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord \\<or>\n     ((fst x, snd x), D, \\<sigma>') \\<in> ecl_ord\n\ngoal (1 subgoal):\n 1. ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord \\<or>\n    ((fst x, snd x), D, \\<sigma>') \\<in> ecl_ord", "by auto"], ["proof (state)\nthis:\n  ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord \\<or>\n  ((fst x, snd x), D, \\<sigma>') \\<in> ecl_ord\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>S'.\n               ((fst x, snd x), C, \\<sigma>)\n               \\<in> ecl_ord) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord \\<or>\n  ((fst x, snd x), D, \\<sigma>') \\<in> ecl_ord", "have \"(((fst x),(snd x)),(C,\\<sigma>')) \\<in> ecl_ord\""], ["proof (prove)\nusing this:\n  ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord \\<or>\n  ((fst x, snd x), D, \\<sigma>') \\<in> ecl_ord\n\ngoal (1 subgoal):\n 1. ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord \\<Longrightarrow>\n    ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord\n 2. ((fst x, snd x), D, \\<sigma>') \\<in> ecl_ord \\<Longrightarrow>\n    ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord", "assume \"(((fst x),(snd x)),(C,\\<sigma>')) \\<in> ecl_ord\""], ["proof (state)\nthis:\n  ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord\n\ngoal (2 subgoals):\n 1. ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord \\<Longrightarrow>\n    ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord\n 2. ((fst x, snd x), D, \\<sigma>') \\<in> ecl_ord \\<Longrightarrow>\n    ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord", "from this"], ["proof (chain)\npicking this:\n  ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord", "show ?thesis"], ["proof (prove)\nusing this:\n  ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord\n\ngoal (1 subgoal):\n 1. ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord", "by auto"], ["proof (state)\nthis:\n  ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord\n\ngoal (1 subgoal):\n 1. ((fst x, snd x), D, \\<sigma>') \\<in> ecl_ord \\<Longrightarrow>\n    ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ((fst x, snd x), D, \\<sigma>') \\<in> ecl_ord \\<Longrightarrow>\n    ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord", "assume \"(((fst x),(snd x)),(D,\\<sigma>')) \\<in> ecl_ord\""], ["proof (state)\nthis:\n  ((fst x, snd x), D, \\<sigma>') \\<in> ecl_ord\n\ngoal (1 subgoal):\n 1. ((fst x, snd x), D, \\<sigma>') \\<in> ecl_ord \\<Longrightarrow>\n    ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord", "from this and \\<open>( (D,\\<sigma>'),(C,\\<sigma>')) \\<in> ecl_ord\\<close>"], ["proof (chain)\npicking this:\n  ((fst x, snd x), D, \\<sigma>') \\<in> ecl_ord\n  ((D, \\<sigma>'), C, \\<sigma>') \\<in> ecl_ord", "show \n              \"(((fst x),(snd x)),(C,\\<sigma>')) \\<in> ecl_ord\""], ["proof (prove)\nusing this:\n  ((fst x, snd x), D, \\<sigma>') \\<in> ecl_ord\n  ((D, \\<sigma>'), C, \\<sigma>') \\<in> ecl_ord\n\ngoal (1 subgoal):\n 1. ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord", "using ecl_ord_trans"], ["proof (prove)\nusing this:\n  ((fst x, snd x), D, \\<sigma>') \\<in> ecl_ord\n  ((D, \\<sigma>'), C, \\<sigma>') \\<in> ecl_ord\n  trans ecl_ord\n\ngoal (1 subgoal):\n 1. ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord", "unfolding trans_def"], ["proof (prove)\nusing this:\n  ((fst x, snd x), D, \\<sigma>') \\<in> ecl_ord\n  ((D, \\<sigma>'), C, \\<sigma>') \\<in> ecl_ord\n  \\<forall>x y z.\n     (x, y) \\<in> ecl_ord \\<longrightarrow>\n     (y, z) \\<in> ecl_ord \\<longrightarrow> (x, z) \\<in> ecl_ord\n\ngoal (1 subgoal):\n 1. ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord", "by metis"], ["proof (state)\nthis:\n  ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>S'.\n               ((fst x, snd x), C, \\<sigma>)\n               \\<in> ecl_ord) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord", "have \n            \"((mset_ecl x), (mset_ecl (C,\\<sigma>'))) \\<in> (mult (mult trm_ord))\""], ["proof (prove)\nusing this:\n  ((fst x, snd x), C, \\<sigma>') \\<in> ecl_ord\n\ngoal (1 subgoal):\n 1. (mset_ecl x, mset_ecl (C, \\<sigma>')) \\<in> mult (mult trm_ord)", "unfolding ecl_ord_def"], ["proof (prove)\nusing this:\n  ((fst x, snd x), C, \\<sigma>')\n  \\<in> {(x, y). (mset_ecl x, mset_ecl y) \\<in> mult (mult trm_ord)}\n\ngoal (1 subgoal):\n 1. (mset_ecl x, mset_ecl (C, \\<sigma>')) \\<in> mult (mult trm_ord)", "by auto"], ["proof (state)\nthis:\n  (mset_ecl x, mset_ecl (C, \\<sigma>')) \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>S'.\n               ((fst x, snd x), C, \\<sigma>)\n               \\<in> ecl_ord) \\<Longrightarrow>\n    False", "from \\<open>(coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)))\\<close>"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))", "have \"(mset_ecl (C,\\<sigma>')) = (mset_ecl (C,\\<sigma>))\""], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\n\ngoal (1 subgoal):\n 1. mset_ecl (C, \\<sigma>') = mset_ecl (C, \\<sigma>)", "using ecl_ord_coincide [of \\<sigma> \\<sigma>' C]"], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C)) \\<Longrightarrow>\n  mset_ecl (C, \\<sigma>) = mset_ecl (C, \\<sigma>')\n\ngoal (1 subgoal):\n 1. mset_ecl (C, \\<sigma>') = mset_ecl (C, \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  mset_ecl (C, \\<sigma>') = mset_ecl (C, \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>S'.\n               ((fst x, snd x), C, \\<sigma>)\n               \\<in> ecl_ord) \\<Longrightarrow>\n    False", "from this and \\<open>((mset_ecl x), (mset_ecl (C,\\<sigma>'))) \\<in> (mult (mult trm_ord))\\<close>"], ["proof (chain)\npicking this:\n  mset_ecl (C, \\<sigma>') = mset_ecl (C, \\<sigma>)\n  (mset_ecl x, mset_ecl (C, \\<sigma>')) \\<in> mult (mult trm_ord)", "have \"((mset_ecl x), (mset_ecl (C,\\<sigma>))) \\<in> (mult (mult trm_ord))\""], ["proof (prove)\nusing this:\n  mset_ecl (C, \\<sigma>') = mset_ecl (C, \\<sigma>)\n  (mset_ecl x, mset_ecl (C, \\<sigma>')) \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. (mset_ecl x, mset_ecl (C, \\<sigma>)) \\<in> mult (mult trm_ord)", "by simp"], ["proof (state)\nthis:\n  (mset_ecl x, mset_ecl (C, \\<sigma>)) \\<in> mult (mult trm_ord)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>S'.\n               ((fst x, snd x), C, \\<sigma>)\n               \\<in> ecl_ord) \\<Longrightarrow>\n    False", "from this and \\<open>\\<not>(((fst x),(snd x)),(C,\\<sigma>)) \\<in> ecl_ord\\<close>"], ["proof (chain)\npicking this:\n  (mset_ecl x, mset_ecl (C, \\<sigma>)) \\<in> mult (mult trm_ord)\n  ((fst x, snd x), C, \\<sigma>) \\<notin> ecl_ord", "show False"], ["proof (prove)\nusing this:\n  (mset_ecl x, mset_ecl (C, \\<sigma>)) \\<in> mult (mult trm_ord)\n  ((fst x, snd x), C, \\<sigma>) \\<notin> ecl_ord\n\ngoal (1 subgoal):\n 1. False", "unfolding ecl_ord_def"], ["proof (prove)\nusing this:\n  (mset_ecl x, mset_ecl (C, \\<sigma>)) \\<in> mult (mult trm_ord)\n  ((fst x, snd x), C, \\<sigma>)\n  \\<notin> {(x, y). (mset_ecl x, mset_ecl y) \\<in> mult (mult trm_ord)}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S'. ((fst x, snd x), C, \\<sigma>) \\<in> ecl_ord\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "have \"validate_clause_set ?I (clset_instances S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. validate_clause_set (int_clset S) (clset_instances S')", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "assume \"\\<not> validate_clause_set ?I (clset_instances S')\""], ["proof (state)\nthis:\n  \\<not> validate_clause_set (int_clset S) (clset_instances S')\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> validate_clause_set (int_clset S) (clset_instances S')", "obtain x where \"x \\<in>(clset_instances S')\" and \"\\<not>validate_clause ?I x\""], ["proof (prove)\nusing this:\n  \\<not> validate_clause_set (int_clset S) (clset_instances S')\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> clset_instances S';\n         \\<not> validate_clause (int_clset S) x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using validate_clause_set.simps"], ["proof (prove)\nusing this:\n  \\<not> validate_clause_set (int_clset S) (clset_instances S')\n  validate_clause_set ?I ?S =\n  (\\<forall>C. C \\<in> ?S \\<longrightarrow> validate_clause ?I C)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> clset_instances S';\n         \\<not> validate_clause (int_clset S) x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> clset_instances S'\n  \\<not> validate_clause (int_clset S) x\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from \\<open>x \\<in>(clset_instances S')\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> clset_instances S'", "obtain pair' where \"pair' \\<in> S'\" \n          and \"x = (subst_cl (cl_ecl (fst pair')) (snd pair'))\""], ["proof (prove)\nusing this:\n  x \\<in> clset_instances S'\n\ngoal (1 subgoal):\n 1. (\\<And>pair'.\n        \\<lbrakk>pair' \\<in> S';\n         x = subst_cl (cl_ecl (fst pair')) (snd pair')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding clset_instances_def"], ["proof (prove)\nusing this:\n  x \\<in> {C. \\<exists>x.\n                 x \\<in> S' \\<and> C = subst_cl (cl_ecl (fst x)) (snd x)}\n\ngoal (1 subgoal):\n 1. (\\<And>pair'.\n        \\<lbrakk>pair' \\<in> S';\n         x = subst_cl (cl_ecl (fst pair')) (snd pair')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  pair' \\<in> S'\n  x = subst_cl (cl_ecl (fst pair')) (snd pair')\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from all_smaller and \\<open>pair' \\<in> S'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S'. ((fst x, snd x), C, \\<sigma>) \\<in> ecl_ord\n  pair' \\<in> S'", "have \"(pair',(C,\\<sigma>)) \\<in> ecl_ord\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S'. ((fst x, snd x), C, \\<sigma>) \\<in> ecl_ord\n  pair' \\<in> S'\n\ngoal (1 subgoal):\n 1. (pair', C, \\<sigma>) \\<in> ecl_ord", "by auto"], ["proof (state)\nthis:\n  (pair', C, \\<sigma>) \\<in> ecl_ord\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from this and  \\<open>C = fst pair\\<close> and \\<open>\\<sigma> = snd pair\\<close>"], ["proof (chain)\npicking this:\n  (pair', C, \\<sigma>) \\<in> ecl_ord\n  C = fst pair\n  \\<sigma> = snd pair", "have \"(pair',pair) \\<in> ecl_ord\""], ["proof (prove)\nusing this:\n  (pair', C, \\<sigma>) \\<in> ecl_ord\n  C = fst pair\n  \\<sigma> = snd pair\n\ngoal (1 subgoal):\n 1. (pair', pair) \\<in> ecl_ord", "by auto"], ["proof (state)\nthis:\n  (pair', pair) \\<in> ecl_ord\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from this and hyp_ind"], ["proof (chain)\npicking this:\n  (pair', pair) \\<in> ecl_ord\n  \\<forall>y.\n     (y, pair) \\<in> ecl_ord \\<longrightarrow>\n     (\\<forall>C \\<sigma>.\n         fst y = C \\<longrightarrow>\n         \\<sigma> = snd y \\<longrightarrow>\n         C \\<in> S \\<longrightarrow>\n         ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n         all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n          (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n         validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n          (subst_cl (cl_ecl C) \\<sigma>))", "have \"?P pair'\""], ["proof (prove)\nusing this:\n  (pair', pair) \\<in> ecl_ord\n  \\<forall>y.\n     (y, pair) \\<in> ecl_ord \\<longrightarrow>\n     (\\<forall>C \\<sigma>.\n         fst y = C \\<longrightarrow>\n         \\<sigma> = snd y \\<longrightarrow>\n         C \\<in> S \\<longrightarrow>\n         ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n         all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n          (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n         validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n          (subst_cl (cl_ecl C) \\<sigma>))\n\ngoal (1 subgoal):\n 1. \\<forall>C \\<sigma>.\n       fst pair' = C \\<longrightarrow>\n       \\<sigma> = snd pair' \\<longrightarrow>\n       C \\<in> S \\<longrightarrow>\n       ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n       all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n        (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n       validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n        (subst_cl (cl_ecl C) \\<sigma>)", "by blast"], ["proof (state)\nthis:\n  \\<forall>C \\<sigma>.\n     fst pair' = C \\<longrightarrow>\n     \\<sigma> = snd pair' \\<longrightarrow>\n     C \\<in> S \\<longrightarrow>\n     ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n     all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n      (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n     validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n      (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from \\<open>pair' \\<in> S'\\<close> and all_normalized_term_included"], ["proof (chain)\npicking this:\n  pair' \\<in> S'\n  \\<forall>x\\<in>S'.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) (trms_ecl R)", "have \n          \"(subterms_inclusion (subst_set (trms_ecl (fst pair')) (snd pair')) \n             (trms_ecl R))\""], ["proof (prove)\nusing this:\n  pair' \\<in> S'\n  \\<forall>x\\<in>S'.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) (trms_ecl R)\n\ngoal (1 subgoal):\n 1. subterms_inclusion (subst_set (trms_ecl (fst pair')) (snd pair'))\n     (trms_ecl R)", "by auto"], ["proof (state)\nthis:\n  subterms_inclusion (subst_set (trms_ecl (fst pair')) (snd pair'))\n   (trms_ecl R)\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "have i: \"(all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair')) \n                  (\\<lambda>t. (trm_rep t S)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair'))\n     (\\<lambda>t. trm_rep t S)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "assume \"\\<not>(all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair')) \n                  (\\<lambda>t. (trm_rep t S)))\""], ["proof (state)\nthis:\n  \\<not> all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair'))\n          (\\<lambda>t. trm_rep t S)\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair'))\n          (\\<lambda>t. trm_rep t S)", "obtain w w' where \"w \\<in> subst_set (trms_ecl (fst pair')) (snd pair')\"\n           and \"occurs_in w' w\"\n            \"trm_rep w' S \\<noteq> w'\""], ["proof (prove)\nusing this:\n  \\<not> all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair'))\n          (\\<lambda>t. trm_rep t S)\n\ngoal (1 subgoal):\n 1. (\\<And>w w'.\n        \\<lbrakk>w \\<in> subst_set (trms_ecl (fst pair')) (snd pair');\n         occurs_in w' w; trm_rep w' S \\<noteq> w'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding all_trms_irreducible_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x y.\n             x \\<in> subst_set (trms_ecl (fst pair'))\n                      (snd pair') \\<longrightarrow>\n             occurs_in y x \\<longrightarrow> trm_rep y S = y)\n\ngoal (1 subgoal):\n 1. (\\<And>w w'.\n        \\<lbrakk>w \\<in> subst_set (trms_ecl (fst pair')) (snd pair');\n         occurs_in w' w; trm_rep w' S \\<noteq> w'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  w \\<in> subst_set (trms_ecl (fst pair')) (snd pair')\n  occurs_in w' w\n  trm_rep w' S \\<noteq> w'\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from \\<open>w \\<in> subst_set (trms_ecl (fst pair')) (snd pair')\\<close> and \n          \\<open>(subterms_inclusion (subst_set (trms_ecl (fst pair')) (snd pair')) \n             (trms_ecl R))\\<close>"], ["proof (chain)\npicking this:\n  w \\<in> subst_set (trms_ecl (fst pair')) (snd pair')\n  subterms_inclusion (subst_set (trms_ecl (fst pair')) (snd pair'))\n   (trms_ecl R)", "obtain w'' where \"w'' \\<in> trms_ecl R\" and \"occurs_in w w''\""], ["proof (prove)\nusing this:\n  w \\<in> subst_set (trms_ecl (fst pair')) (snd pair')\n  subterms_inclusion (subst_set (trms_ecl (fst pair')) (snd pair'))\n   (trms_ecl R)\n\ngoal (1 subgoal):\n 1. (\\<And>w''.\n        \\<lbrakk>w'' \\<in> trms_ecl R; occurs_in w w''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding subterms_inclusion_def"], ["proof (prove)\nusing this:\n  w \\<in> subst_set (trms_ecl (fst pair')) (snd pair')\n  \\<forall>x1\\<in>subst_set (trms_ecl (fst pair')) (snd pair').\n     Bex (trms_ecl R) (occurs_in x1)\n\ngoal (1 subgoal):\n 1. (\\<And>w''.\n        \\<lbrakk>w'' \\<in> trms_ecl R; occurs_in w w''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w'' \\<in> trms_ecl R\n  occurs_in w w''\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from \\<open>occurs_in w w''\\<close> and \\<open>occurs_in w' w\\<close>"], ["proof (chain)\npicking this:\n  occurs_in w w''\n  occurs_in w' w", "have \"occurs_in w' w''\""], ["proof (prove)\nusing this:\n  occurs_in w w''\n  occurs_in w' w\n\ngoal (1 subgoal):\n 1. occurs_in w' w''", "using occur_in_subterm"], ["proof (prove)\nusing this:\n  occurs_in w w''\n  occurs_in w' w\n  \\<lbrakk>occurs_in ?u ?t; occurs_in ?t ?s\\<rbrakk>\n  \\<Longrightarrow> occurs_in ?u ?s\n\ngoal (1 subgoal):\n 1. occurs_in w' w''", "by blast"], ["proof (state)\nthis:\n  occurs_in w' w''\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from  ntr"], ["proof (chain)\npicking this:\n  nt_R =\n  dom_trms Cl_R\n   (subst_set\n     (trms_ecl C \\<union> trms_ecl D \\<union>\n      {r. \\<exists>q. (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n     \\<sigma>')", "have \"nt_R \\<subseteq> (subst_set ((trms_ecl C) \\<union> (trms_ecl D) \\<union> \n              { r. \\<exists> q. (q,p) \\<in> (pos_ord C t) \\<and> (subterm t q r) }) \\<sigma>')\""], ["proof (prove)\nusing this:\n  nt_R =\n  dom_trms Cl_R\n   (subst_set\n     (trms_ecl C \\<union> trms_ecl D \\<union>\n      {r. \\<exists>q. (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n     \\<sigma>')\n\ngoal (1 subgoal):\n 1. nt_R\n    \\<subseteq> subst_set\n                 (trms_ecl C \\<union> trms_ecl D \\<union>\n                  {r. \\<exists>q.\n                         (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n                 \\<sigma>'", "using dom_trms_subset [of Cl_R \"(subst_set ((trms_ecl C) \\<union> (trms_ecl D) \\<union> \n              { r. \\<exists> q. (q,p) \\<in> (pos_ord C t) \\<and> (subterm t q r) }) \\<sigma>')\"]"], ["proof (prove)\nusing this:\n  nt_R =\n  dom_trms Cl_R\n   (subst_set\n     (trms_ecl C \\<union> trms_ecl D \\<union>\n      {r. \\<exists>q. (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n     \\<sigma>')\n  dom_trms Cl_R\n   (subst_set\n     (trms_ecl C \\<union> trms_ecl D \\<union>\n      {r. \\<exists>q. (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n     \\<sigma>')\n  \\<subseteq> subst_set\n               (trms_ecl C \\<union> trms_ecl D \\<union>\n                {r. \\<exists>q.\n                       (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n               \\<sigma>'\n\ngoal (1 subgoal):\n 1. nt_R\n    \\<subseteq> subst_set\n                 (trms_ecl C \\<union> trms_ecl D \\<union>\n                  {r. \\<exists>q.\n                         (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n                 \\<sigma>'", "by blast"], ["proof (state)\nthis:\n  nt_R\n  \\<subseteq> subst_set\n               (trms_ecl C \\<union> trms_ecl D \\<union>\n                {r. \\<exists>q.\n                       (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n               \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from this and r"], ["proof (chain)\npicking this:\n  nt_R\n  \\<subseteq> subst_set\n               (trms_ecl C \\<union> trms_ecl D \\<union>\n                {r. \\<exists>q.\n                       (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n               \\<sigma>'\n  R = Ecl Cl_R nt_R", "have \"trms_ecl R \\<subseteq> (subst_set ((trms_ecl C) \\<union> (trms_ecl D) \\<union> \n              { r. \\<exists> q. (q,p) \\<in> (pos_ord C t) \\<and> (subterm t q r) }) \\<sigma>')\""], ["proof (prove)\nusing this:\n  nt_R\n  \\<subseteq> subst_set\n               (trms_ecl C \\<union> trms_ecl D \\<union>\n                {r. \\<exists>q.\n                       (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n               \\<sigma>'\n  R = Ecl Cl_R nt_R\n\ngoal (1 subgoal):\n 1. trms_ecl R\n    \\<subseteq> subst_set\n                 (trms_ecl C \\<union> trms_ecl D \\<union>\n                  {r. \\<exists>q.\n                         (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n                 \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  trms_ecl R\n  \\<subseteq> subst_set\n               (trms_ecl C \\<union> trms_ecl D \\<union>\n                {r. \\<exists>q.\n                       (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n               \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from this and \\<open>w'' \\<in> trms_ecl R\\<close>"], ["proof (chain)\npicking this:\n  trms_ecl R\n  \\<subseteq> subst_set\n               (trms_ecl C \\<union> trms_ecl D \\<union>\n                {r. \\<exists>q.\n                       (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n               \\<sigma>'\n  w'' \\<in> trms_ecl R", "have\n            \"w'' \\<in> (subst_set ((trms_ecl C) \\<union> (trms_ecl D) \\<union> \n              { r. \\<exists> q. (q,p) \\<in> (pos_ord C t) \\<and> (subterm t q r) }) \\<sigma>')\""], ["proof (prove)\nusing this:\n  trms_ecl R\n  \\<subseteq> subst_set\n               (trms_ecl C \\<union> trms_ecl D \\<union>\n                {r. \\<exists>q.\n                       (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n               \\<sigma>'\n  w'' \\<in> trms_ecl R\n\ngoal (1 subgoal):\n 1. w''\n    \\<in> subst_set\n           (trms_ecl C \\<union> trms_ecl D \\<union>\n            {r. \\<exists>q. (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n           \\<sigma>'", "by blast"], ["proof (state)\nthis:\n  w''\n  \\<in> subst_set\n         (trms_ecl C \\<union> trms_ecl D \\<union>\n          {r. \\<exists>q. (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n         \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  w''\n  \\<in> subst_set\n         (trms_ecl C \\<union> trms_ecl D \\<union>\n          {r. \\<exists>q. (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n         \\<sigma>'", "obtain w'''\n            where \"w''' \\<in> ((trms_ecl C) \\<union> (trms_ecl D) \\<union> \n              { r. \\<exists> q. (q,p) \\<in> (pos_ord C t) \\<and> (subterm t q r) })\" and \"w'' = subst w''' \\<sigma>'\""], ["proof (prove)\nusing this:\n  w''\n  \\<in> subst_set\n         (trms_ecl C \\<union> trms_ecl D \\<union>\n          {r. \\<exists>q. (q, p) \\<in> pos_ord C t \\<and> subterm t q r})\n         \\<sigma>'\n\ngoal (1 subgoal):\n 1. (\\<And>w'''.\n        \\<lbrakk>w'''\n                 \\<in> trms_ecl C \\<union> trms_ecl D \\<union>\n                       {r. \\<exists>q.\n                              (q, p) \\<in> pos_ord C t \\<and>\n                              subterm t q r};\n         w'' = w''' \\<lhd> \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w'''\n  \\<in> trms_ecl C \\<union> trms_ecl D \\<union>\n        {r. \\<exists>q. (q, p) \\<in> pos_ord C t \\<and> subterm t q r}\n  w'' = w''' \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from this and \\<open>occurs_in w' w''\\<close>"], ["proof (chain)\npicking this:\n  w'''\n  \\<in> trms_ecl C \\<union> trms_ecl D \\<union>\n        {r. \\<exists>q. (q, p) \\<in> pos_ord C t \\<and> subterm t q r}\n  w'' = w''' \\<lhd> \\<sigma>'\n  occurs_in w' w''", "have \"occurs_in w' (subst w''' \\<sigma>')\""], ["proof (prove)\nusing this:\n  w'''\n  \\<in> trms_ecl C \\<union> trms_ecl D \\<union>\n        {r. \\<exists>q. (q, p) \\<in> pos_ord C t \\<and> subterm t q r}\n  w'' = w''' \\<lhd> \\<sigma>'\n  occurs_in w' w''\n\ngoal (1 subgoal):\n 1. occurs_in w' (w''' \\<lhd> \\<sigma>')", "by auto"], ["proof (state)\nthis:\n  occurs_in w' (w''' \\<lhd> \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "have \"\\<not> (w''' \\<in> trms_ecl C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w''' \\<notin> trms_ecl C", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. w''' \\<in> trms_ecl C \\<Longrightarrow> False", "assume \"w''' \\<in> trms_ecl C\""], ["proof (state)\nthis:\n  w''' \\<in> trms_ecl C\n\ngoal (1 subgoal):\n 1. w''' \\<in> trms_ecl C \\<Longrightarrow> False", "from this and \\<open>occurs_in w' w''\\<close> and \\<open>w'' = subst w''' \\<sigma>'\\<close>"], ["proof (chain)\npicking this:\n  w''' \\<in> trms_ecl C\n  occurs_in w' w''\n  w'' = w''' \\<lhd> \\<sigma>'", "have\n              \"occurs_in w' (subst w''' \\<sigma>')\""], ["proof (prove)\nusing this:\n  w''' \\<in> trms_ecl C\n  occurs_in w' w''\n  w'' = w''' \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. occurs_in w' (w''' \\<lhd> \\<sigma>')", "by auto"], ["proof (state)\nthis:\n  occurs_in w' (w''' \\<lhd> \\<sigma>')\n\ngoal (1 subgoal):\n 1. w''' \\<in> trms_ecl C \\<Longrightarrow> False", "from assms(3) and \\<open>C \\<in> S\\<close> and \\<open>w''' \\<in> trms_ecl C\\<close>"], ["proof (chain)\npicking this:\n  Ball S well_constrained\n  C \\<in> S\n  w''' \\<in> trms_ecl C", "have \"vars_of w''' \\<subseteq> vars_of_cl (cl_ecl C)\""], ["proof (prove)\nusing this:\n  Ball S well_constrained\n  C \\<in> S\n  w''' \\<in> trms_ecl C\n\ngoal (1 subgoal):\n 1. vars_of w''' \\<subseteq> vars_of_cl (cl_ecl C)", "using dom_trm_vars"], ["proof (prove)\nusing this:\n  Ball S well_constrained\n  C \\<in> S\n  w''' \\<in> trms_ecl C\n  dom_trm ?t ?C \\<Longrightarrow> vars_of ?t \\<subseteq> vars_of_cl ?C\n\ngoal (1 subgoal):\n 1. vars_of w''' \\<subseteq> vars_of_cl (cl_ecl C)", "unfolding Ball_def well_constrained_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     x \\<in> S \\<longrightarrow>\n     (\\<forall>y. y \\<in> trms_ecl x \\<longrightarrow> dom_trm y (cl_ecl x))\n  C \\<in> S\n  w''' \\<in> trms_ecl C\n  dom_trm ?t ?C \\<Longrightarrow> vars_of ?t \\<subseteq> vars_of_cl ?C\n\ngoal (1 subgoal):\n 1. vars_of w''' \\<subseteq> vars_of_cl (cl_ecl C)", "by blast"], ["proof (state)\nthis:\n  vars_of w''' \\<subseteq> vars_of_cl (cl_ecl C)\n\ngoal (1 subgoal):\n 1. w''' \\<in> trms_ecl C \\<Longrightarrow> False", "from this and \\<open>coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\\<close>"], ["proof (chain)\npicking this:\n  vars_of w''' \\<subseteq> vars_of_cl (cl_ecl C)\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))", "have \"coincide_on \\<sigma> \\<sigma>' (vars_of w''')\""], ["proof (prove)\nusing this:\n  vars_of w''' \\<subseteq> vars_of_cl (cl_ecl C)\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\n\ngoal (1 subgoal):\n 1. coincide_on \\<sigma> \\<sigma>' (vars_of w''')", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  vars_of w''' \\<subseteq> vars_of_cl (cl_ecl C)\n  \\<forall>x\\<in>vars_of_cl (cl_ecl C).\n     Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of w'''.\n       Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  coincide_on \\<sigma> \\<sigma>' (vars_of w''')\n\ngoal (1 subgoal):\n 1. w''' \\<in> trms_ecl C \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of w''')", "have \"subst w''' \\<sigma> = subst w''' \\<sigma>'\""], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of w''')\n\ngoal (1 subgoal):\n 1. w''' \\<lhd> \\<sigma> = w''' \\<lhd> \\<sigma>'", "using coincide_on_term"], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of w''')\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of ?t) \\<Longrightarrow>\n  ?t \\<lhd> ?\\<sigma> = ?t \\<lhd> ?\\<eta>\n\ngoal (1 subgoal):\n 1. w''' \\<lhd> \\<sigma> = w''' \\<lhd> \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  w''' \\<lhd> \\<sigma> = w''' \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. w''' \\<in> trms_ecl C \\<Longrightarrow> False", "from this \n              and \\<open>occurs_in w' (subst w''' \\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  w''' \\<lhd> \\<sigma> = w''' \\<lhd> \\<sigma>'\n  occurs_in w' (w''' \\<lhd> \\<sigma>')", "have \"occurs_in w' (subst w''' \\<sigma>)\""], ["proof (prove)\nusing this:\n  w''' \\<lhd> \\<sigma> = w''' \\<lhd> \\<sigma>'\n  occurs_in w' (w''' \\<lhd> \\<sigma>')\n\ngoal (1 subgoal):\n 1. occurs_in w' (w''' \\<lhd> \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  occurs_in w' (w''' \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. w''' \\<in> trms_ecl C \\<Longrightarrow> False", "from this and \\<open>w''' \\<in> trms_ecl C\\<close> \n              \\<open>(all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>) \n                  (\\<lambda>t. (trm_rep t S)))\\<close>"], ["proof (chain)\npicking this:\n  occurs_in w' (w''' \\<lhd> \\<sigma>)\n  w''' \\<in> trms_ecl C\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)", "have \"trm_rep w' S = w'\""], ["proof (prove)\nusing this:\n  occurs_in w' (w''' \\<lhd> \\<sigma>)\n  w''' \\<in> trms_ecl C\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n\ngoal (1 subgoal):\n 1. trm_rep w' S = w'", "unfolding all_trms_irreducible_def"], ["proof (prove)\nusing this:\n  occurs_in w' (w''' \\<lhd> \\<sigma>)\n  w''' \\<in> trms_ecl C\n  \\<forall>x y.\n     x \\<in> subst_set (trms_ecl C) \\<sigma> \\<longrightarrow>\n     occurs_in y x \\<longrightarrow> trm_rep y S = y\n\ngoal (1 subgoal):\n 1. trm_rep w' S = w'", "using subst_set.simps"], ["proof (prove)\nusing this:\n  occurs_in w' (w''' \\<lhd> \\<sigma>)\n  w''' \\<in> trms_ecl C\n  \\<forall>x y.\n     x \\<in> subst_set (trms_ecl C) \\<sigma> \\<longrightarrow>\n     occurs_in y x \\<longrightarrow> trm_rep y S = y\n  subst_set ?S ?\\<sigma> = {t \\<lhd> ?\\<sigma> |t. t \\<in> ?S}\n\ngoal (1 subgoal):\n 1. trm_rep w' S = w'", "by blast"], ["proof (state)\nthis:\n  trm_rep w' S = w'\n\ngoal (1 subgoal):\n 1. w''' \\<in> trms_ecl C \\<Longrightarrow> False", "from this and \\<open>trm_rep w' S \\<noteq> w'\\<close>"], ["proof (chain)\npicking this:\n  trm_rep w' S = w'\n  trm_rep w' S \\<noteq> w'", "show False"], ["proof (prove)\nusing this:\n  trm_rep w' S = w'\n  trm_rep w' S \\<noteq> w'\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w''' \\<notin> trms_ecl C\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "have \"\\<not> (w''' \\<in> trms_ecl D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w''' \\<notin> trms_ecl D", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. w''' \\<in> trms_ecl D \\<Longrightarrow> False", "assume \"w''' \\<in> trms_ecl D\""], ["proof (state)\nthis:\n  w''' \\<in> trms_ecl D\n\ngoal (1 subgoal):\n 1. w''' \\<in> trms_ecl D \\<Longrightarrow> False", "from this and \\<open>occurs_in w' w''\\<close> and \\<open>w'' = subst w''' \\<sigma>'\\<close>"], ["proof (chain)\npicking this:\n  w''' \\<in> trms_ecl D\n  occurs_in w' w''\n  w'' = w''' \\<lhd> \\<sigma>'", "have\n              \"occurs_in w' (subst w''' \\<sigma>')\""], ["proof (prove)\nusing this:\n  w''' \\<in> trms_ecl D\n  occurs_in w' w''\n  w'' = w''' \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. occurs_in w' (w''' \\<lhd> \\<sigma>')", "by auto"], ["proof (state)\nthis:\n  occurs_in w' (w''' \\<lhd> \\<sigma>')\n\ngoal (1 subgoal):\n 1. w''' \\<in> trms_ecl D \\<Longrightarrow> False", "from this and \\<open>w''' \\<in> trms_ecl D\\<close> \n              \\<open>(all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>') \n                  (\\<lambda>t. (trm_rep t S)))\\<close>"], ["proof (chain)\npicking this:\n  occurs_in w' (w''' \\<lhd> \\<sigma>')\n  w''' \\<in> trms_ecl D\n  all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>')\n   (\\<lambda>t. trm_rep t S)", "have \"trm_rep w' S = w'\""], ["proof (prove)\nusing this:\n  occurs_in w' (w''' \\<lhd> \\<sigma>')\n  w''' \\<in> trms_ecl D\n  all_trms_irreducible (subst_set (trms_ecl D) \\<sigma>')\n   (\\<lambda>t. trm_rep t S)\n\ngoal (1 subgoal):\n 1. trm_rep w' S = w'", "unfolding all_trms_irreducible_def"], ["proof (prove)\nusing this:\n  occurs_in w' (w''' \\<lhd> \\<sigma>')\n  w''' \\<in> trms_ecl D\n  \\<forall>x y.\n     x \\<in> subst_set (trms_ecl D) \\<sigma>' \\<longrightarrow>\n     occurs_in y x \\<longrightarrow> trm_rep y S = y\n\ngoal (1 subgoal):\n 1. trm_rep w' S = w'", "using subst_set.simps"], ["proof (prove)\nusing this:\n  occurs_in w' (w''' \\<lhd> \\<sigma>')\n  w''' \\<in> trms_ecl D\n  \\<forall>x y.\n     x \\<in> subst_set (trms_ecl D) \\<sigma>' \\<longrightarrow>\n     occurs_in y x \\<longrightarrow> trm_rep y S = y\n  subst_set ?S ?\\<sigma> = {t \\<lhd> ?\\<sigma> |t. t \\<in> ?S}\n\ngoal (1 subgoal):\n 1. trm_rep w' S = w'", "by blast"], ["proof (state)\nthis:\n  trm_rep w' S = w'\n\ngoal (1 subgoal):\n 1. w''' \\<in> trms_ecl D \\<Longrightarrow> False", "from this and \\<open>trm_rep w' S \\<noteq> w'\\<close>"], ["proof (chain)\npicking this:\n  trm_rep w' S = w'\n  trm_rep w' S \\<noteq> w'", "show False"], ["proof (prove)\nusing this:\n  trm_rep w' S = w'\n  trm_rep w' S \\<noteq> w'\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w''' \\<notin> trms_ecl D\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from this and \n          \\<open>w''' \\<in> ((trms_ecl C) \\<union> (trms_ecl D) \n            \\<union> { r. \\<exists> q. (q,p) \\<in> (pos_ord C t) \\<and> (subterm t q r) })\\<close> \n          and \\<open>\\<not> (w''' \\<in> trms_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  w''' \\<notin> trms_ecl D\n  w'''\n  \\<in> trms_ecl C \\<union> trms_ecl D \\<union>\n        {r. \\<exists>q. (q, p) \\<in> pos_ord C t \\<and> subterm t q r}\n  w''' \\<notin> trms_ecl C", "obtain q_w where \"(subterm t q_w w''')\" and \"(q_w,p) \\<in> (pos_ord C t)\""], ["proof (prove)\nusing this:\n  w''' \\<notin> trms_ecl D\n  w'''\n  \\<in> trms_ecl C \\<union> trms_ecl D \\<union>\n        {r. \\<exists>q. (q, p) \\<in> pos_ord C t \\<and> subterm t q r}\n  w''' \\<notin> trms_ecl C\n\ngoal (1 subgoal):\n 1. (\\<And>q_w.\n        \\<lbrakk>subterm t q_w w'''; (q_w, p) \\<in> pos_ord C t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  subterm t q_w w'''\n  (q_w, p) \\<in> pos_ord C t\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from \\<open>subterm t q_w w'''\\<close>"], ["proof (chain)\npicking this:\n  subterm t q_w w'''", "have \"subterm (subst t \\<sigma>') q_w (subst w''' \\<sigma>')\""], ["proof (prove)\nusing this:\n  subterm t q_w w'''\n\ngoal (1 subgoal):\n 1. subterm (t \\<lhd> \\<sigma>') q_w (w''' \\<lhd> \\<sigma>')", "using substs_preserve_subterms"], ["proof (prove)\nusing this:\n  subterm t q_w w'''\n  subterm ?t ?p ?s \\<Longrightarrow>\n  subterm (?t \\<lhd> ?\\<sigma>) ?p (?s \\<lhd> ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. subterm (t \\<lhd> \\<sigma>') q_w (w''' \\<lhd> \\<sigma>')", "by auto"], ["proof (state)\nthis:\n  subterm (t \\<lhd> \\<sigma>') q_w (w''' \\<lhd> \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from \\<open>occurs_in w' (subst w''' \\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  occurs_in w' (w''' \\<lhd> \\<sigma>')", "obtain q \n            where \"(subterm  (subst w''' \\<sigma>') q w')\""], ["proof (prove)\nusing this:\n  occurs_in w' (w''' \\<lhd> \\<sigma>')\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        subterm (w''' \\<lhd> \\<sigma>') q w' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding occurs_in_def"], ["proof (prove)\nusing this:\n  \\<exists>p. subterm (w''' \\<lhd> \\<sigma>') p w'\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        subterm (w''' \\<lhd> \\<sigma>') q w' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  subterm (w''' \\<lhd> \\<sigma>') q w'\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from this and \\<open>subterm (subst t \\<sigma>') q_w (subst w''' \\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  subterm (w''' \\<lhd> \\<sigma>') q w'\n  subterm (t \\<lhd> \\<sigma>') q_w (w''' \\<lhd> \\<sigma>')", "have \"subterm (subst t \\<sigma>') (append q_w q) w'\""], ["proof (prove)\nusing this:\n  subterm (w''' \\<lhd> \\<sigma>') q w'\n  subterm (t \\<lhd> \\<sigma>') q_w (w''' \\<lhd> \\<sigma>')\n\ngoal (1 subgoal):\n 1. subterm (t \\<lhd> \\<sigma>') (q_w @ q) w'", "using subterm_of_a_subterm_is_a_subterm"], ["proof (prove)\nusing this:\n  subterm (w''' \\<lhd> \\<sigma>') q w'\n  subterm (t \\<lhd> \\<sigma>') q_w (w''' \\<lhd> \\<sigma>')\n  \\<lbrakk>subterm ?u ?q ?v; subterm ?t ?p ?u\\<rbrakk>\n  \\<Longrightarrow> subterm ?t (?p @ ?q) ?v\n\ngoal (1 subgoal):\n 1. subterm (t \\<lhd> \\<sigma>') (q_w @ q) w'", "by blast"], ["proof (state)\nthis:\n  subterm (t \\<lhd> \\<sigma>') (q_w @ q) w'\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from this and \\<open>(subst t \\<sigma>) = (subst t \\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  subterm (t \\<lhd> \\<sigma>') (q_w @ q) w'\n  t \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>'", "have \"subterm (subst t \\<sigma>) (append q_w q) w'\""], ["proof (prove)\nusing this:\n  subterm (t \\<lhd> \\<sigma>') (q_w @ q) w'\n  t \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. subterm (t \\<lhd> \\<sigma>) (q_w @ q) w'", "by auto"], ["proof (state)\nthis:\n  subterm (t \\<lhd> \\<sigma>) (q_w @ q) w'\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from \\<open>(q_w,p) \\<in> (pos_ord C t)\\<close>"], ["proof (chain)\npicking this:\n  (q_w, p) \\<in> pos_ord C t", "have \"((append q_w q),p) \\<in> (pos_ord C t)\""], ["proof (prove)\nusing this:\n  (q_w, p) \\<in> pos_ord C t\n\ngoal (1 subgoal):\n 1. (q_w @ q, p) \\<in> pos_ord C t", "using pos_ord_prefix"], ["proof (prove)\nusing this:\n  (q_w, p) \\<in> pos_ord C t\n  \\<forall>x y p q r.\n     (q, p) \\<in> pos_ord x y \\<longrightarrow> (q @ r, p) \\<in> pos_ord x y\n\ngoal (1 subgoal):\n 1. (q_w @ q, p) \\<in> pos_ord C t", "by blast"], ["proof (state)\nthis:\n  (q_w @ q, p) \\<in> pos_ord C t\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from this and \\<open>minimal_redex p (subst t \\<sigma>) C S t\\<close>\n            and \\<open>subterm (subst t \\<sigma>) (append q_w q) w'\\<close>"], ["proof (chain)\npicking this:\n  (q_w @ q, p) \\<in> pos_ord C t\n  minimal_redex p (t \\<lhd> \\<sigma>) C S t\n  subterm (t \\<lhd> \\<sigma>) (q_w @ q) w'", "have \"trm_rep w' S = w'\""], ["proof (prove)\nusing this:\n  (q_w @ q, p) \\<in> pos_ord C t\n  minimal_redex p (t \\<lhd> \\<sigma>) C S t\n  subterm (t \\<lhd> \\<sigma>) (q_w @ q) w'\n\ngoal (1 subgoal):\n 1. trm_rep w' S = w'", "unfolding minimal_redex_def"], ["proof (prove)\nusing this:\n  (q_w @ q, p) \\<in> pos_ord C t\n  \\<forall>q s.\n     (q, p) \\<in> pos_ord C t \\<longrightarrow>\n     subterm (t \\<lhd> \\<sigma>) q s \\<longrightarrow> trm_rep s S = s\n  subterm (t \\<lhd> \\<sigma>) (q_w @ q) w'\n\ngoal (1 subgoal):\n 1. trm_rep w' S = w'", "by blast"], ["proof (state)\nthis:\n  trm_rep w' S = w'\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from this and \\<open>trm_rep w' S \\<noteq> w'\\<close>"], ["proof (chain)\npicking this:\n  trm_rep w' S = w'\n  trm_rep w' S \\<noteq> w'", "show False"], ["proof (prove)\nusing this:\n  trm_rep w' S = w'\n  trm_rep w' S \\<noteq> w'\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair'))\n   (\\<lambda>t. trm_rep t S)\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from \\<open>S' \\<subseteq> (instances S)\\<close> and \\<open>pair' \\<in> S'\\<close>"], ["proof (chain)\npicking this:\n  S' \\<subseteq> instances S\n  pair' \\<in> S'", "have \n          ii: \"ground_clause (subst_cl (cl_ecl (fst pair')) (snd pair'))\""], ["proof (prove)\nusing this:\n  S' \\<subseteq> instances S\n  pair' \\<in> S'\n\ngoal (1 subgoal):\n 1. ground_clause (subst_cl (cl_ecl (fst pair')) (snd pair'))", "unfolding instances_def [of S]"], ["proof (prove)\nusing this:\n  S' \\<subseteq> {x. \\<exists>C \\<sigma>.\n                        C \\<in> S \\<and>\n                        ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<and>\n                        x = (C, \\<sigma>)}\n  pair' \\<in> S'\n\ngoal (1 subgoal):\n 1. ground_clause (subst_cl (cl_ecl (fst pair')) (snd pair'))", "by fastforce"], ["proof (state)\nthis:\n  ground_clause (subst_cl (cl_ecl (fst pair')) (snd pair'))\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from \\<open>S' \\<subseteq> (instances S)\\<close> and \\<open>pair' \\<in> S'\\<close>"], ["proof (chain)\npicking this:\n  S' \\<subseteq> instances S\n  pair' \\<in> S'", "have \n          iii: \"(fst pair') \\<in> S\""], ["proof (prove)\nusing this:\n  S' \\<subseteq> instances S\n  pair' \\<in> S'\n\ngoal (1 subgoal):\n 1. fst pair' \\<in> S", "unfolding instances_def [of S]"], ["proof (prove)\nusing this:\n  S' \\<subseteq> {x. \\<exists>C \\<sigma>.\n                        C \\<in> S \\<and>\n                        ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<and>\n                        x = (C, \\<sigma>)}\n  pair' \\<in> S'\n\ngoal (1 subgoal):\n 1. fst pair' \\<in> S", "by fastforce"], ["proof (state)\nthis:\n  fst pair' \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from \\<open>?P pair'\\<close> and i ii iii"], ["proof (chain)\npicking this:\n  \\<forall>C \\<sigma>.\n     fst pair' = C \\<longrightarrow>\n     \\<sigma> = snd pair' \\<longrightarrow>\n     C \\<in> S \\<longrightarrow>\n     ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n     all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n      (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n     validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n      (subst_cl (cl_ecl C) \\<sigma>)\n  all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair'))\n   (\\<lambda>t. trm_rep t S)\n  ground_clause (subst_cl (cl_ecl (fst pair')) (snd pair'))\n  fst pair' \\<in> S", "have \"validate_ground_clause ?I \n          (subst_cl (cl_ecl (fst pair')) (snd pair'))\""], ["proof (prove)\nusing this:\n  \\<forall>C \\<sigma>.\n     fst pair' = C \\<longrightarrow>\n     \\<sigma> = snd pair' \\<longrightarrow>\n     C \\<in> S \\<longrightarrow>\n     ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n     all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n      (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n     validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n      (subst_cl (cl_ecl C) \\<sigma>)\n  all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair'))\n   (\\<lambda>t. trm_rep t S)\n  ground_clause (subst_cl (cl_ecl (fst pair')) (snd pair'))\n  fst pair' \\<in> S\n\ngoal (1 subgoal):\n 1. validate_ground_clause (int_clset S)\n     (subst_cl (cl_ecl (fst pair')) (snd pair'))", "unfolding int_clset_def"], ["proof (prove)\nusing this:\n  \\<forall>C \\<sigma>.\n     fst pair' = C \\<longrightarrow>\n     \\<sigma> = snd pair' \\<longrightarrow>\n     C \\<in> S \\<longrightarrow>\n     ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n     all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n      (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n     validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n      (subst_cl (cl_ecl C) \\<sigma>)\n  all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair'))\n   (\\<lambda>t. trm_rep t S)\n  ground_clause (subst_cl (cl_ecl (fst pair')) (snd pair'))\n  fst pair' \\<in> S\n\ngoal (1 subgoal):\n 1. validate_ground_clause (same_values (\\<lambda>x. trm_rep x S))\n     (subst_cl (cl_ecl (fst pair')) (snd pair'))", "by blast"], ["proof (state)\nthis:\n  validate_ground_clause (int_clset S)\n   (subst_cl (cl_ecl (fst pair')) (snd pair'))\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from this and \\<open>x = (subst_cl (cl_ecl (fst pair')) (snd pair'))\\<close> \n          and \\<open>\\<not>validate_clause ?I x\\<close>"], ["proof (chain)\npicking this:\n  validate_ground_clause (int_clset S)\n   (subst_cl (cl_ecl (fst pair')) (snd pair'))\n  x = subst_cl (cl_ecl (fst pair')) (snd pair')\n  \\<not> validate_clause (int_clset S) x", "show False"], ["proof (prove)\nusing this:\n  validate_ground_clause (int_clset S)\n   (subst_cl (cl_ecl (fst pair')) (snd pair'))\n  x = subst_cl (cl_ecl (fst pair')) (snd pair')\n  \\<not> validate_clause (int_clset S) x\n\ngoal (1 subgoal):\n 1. False", "by (metis ii substs_preserve_ground_clause validate_clause.simps)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  validate_clause_set (int_clset S) (clset_instances S')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from this and \\<open>fo_interpretation ?I\\<close> and \n        \\<open>(set_entails_clause (clset_instances S') (cl_ecl R))\\<close>"], ["proof (chain)\npicking this:\n  validate_clause_set (int_clset S) (clset_instances S')\n  fo_interpretation (int_clset S)\n  set_entails_clause (clset_instances S') (cl_ecl R)", "have \"validate_clause ?I (cl_ecl R)\""], ["proof (prove)\nusing this:\n  validate_clause_set (int_clset S) (clset_instances S')\n  fo_interpretation (int_clset S)\n  set_entails_clause (clset_instances S') (cl_ecl R)\n\ngoal (1 subgoal):\n 1. validate_clause (int_clset S) (cl_ecl R)", "unfolding set_entails_clause_def"], ["proof (prove)\nusing this:\n  validate_clause_set (int_clset S) (clset_instances S')\n  fo_interpretation (int_clset S)\n  \\<forall>I.\n     fo_interpretation I \\<longrightarrow>\n     validate_clause_set I (clset_instances S') \\<longrightarrow>\n     validate_clause I (cl_ecl R)\n\ngoal (1 subgoal):\n 1. validate_clause (int_clset S) (cl_ecl R)", "by blast"], ["proof (state)\nthis:\n  validate_clause (int_clset S) (cl_ecl R)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  validate_clause (int_clset S) (cl_ecl R)", "have \"validate_ground_clause ?I (cl_ecl R)\""], ["proof (prove)\nusing this:\n  validate_clause (int_clset S) (cl_ecl R)\n\ngoal (1 subgoal):\n 1. validate_ground_clause (int_clset S) (cl_ecl R)", "by (metis \\<open>R = Ecl Cl_R nt_R\\<close> \\<open>ground_clause Cl_R\\<close> \n            cl_ecl.simps substs_preserve_ground_clause validate_clause.simps)"], ["proof (state)\nthis:\n  validate_ground_clause (int_clset S) (cl_ecl R)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  validate_ground_clause (int_clset S) (cl_ecl R)", "obtain L'' where \"L'' \\<in> (cl_ecl R)\" and \"validate_ground_lit ?I L''\""], ["proof (prove)\nusing this:\n  validate_ground_clause (int_clset S) (cl_ecl R)\n\ngoal (1 subgoal):\n 1. (\\<And>L''.\n        \\<lbrakk>L'' \\<in> cl_ecl R;\n         validate_ground_lit (int_clset S) L''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using validate_ground_clause.simps"], ["proof (prove)\nusing this:\n  validate_ground_clause (int_clset S) (cl_ecl R)\n  validate_ground_clause ?I ?C =\n  (\\<exists>L. L \\<in> ?C \\<and> validate_ground_lit ?I L)\n\ngoal (1 subgoal):\n 1. (\\<And>L''.\n        \\<lbrakk>L'' \\<in> cl_ecl R;\n         validate_ground_lit (int_clset S) L''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  L'' \\<in> cl_ecl R\n  validate_ground_lit (int_clset S) L''\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from \\<open>L'' \\<in> (cl_ecl R)\\<close> and \\<open>R = Ecl Cl_R nt_R\\<close> and\n          \\<open>Cl_R = (subst_cl ((Cl_C - { L1 }) \\<union> ((Cl_D - { L2 }) \\<union> { L' } )) \\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  L'' \\<in> cl_ecl R\n  R = Ecl Cl_R nt_R\n  Cl_R =\n  subst_cl (Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'})) \\<sigma>'", "obtain M where m: \"M \\<in> ((Cl_C - { L1 }) \\<union> ((Cl_D - { L2 }) \\<union> { L' } ))\" \n          and \"L'' = subst_lit M \\<sigma>'\""], ["proof (prove)\nusing this:\n  L'' \\<in> cl_ecl R\n  R = Ecl Cl_R nt_R\n  Cl_R =\n  subst_cl (Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'})) \\<sigma>'\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>M \\<in> Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'});\n         L'' = subst_lit M \\<sigma>'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M \\<in> Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'})\n  L'' = subst_lit M \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "have \"M \\<notin> cl_ecl C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<notin> cl_ecl C", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. M \\<in> cl_ecl C \\<Longrightarrow> False", "assume \"M \\<in> cl_ecl C\""], ["proof (state)\nthis:\n  M \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. M \\<in> cl_ecl C \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  M \\<in> cl_ecl C", "have \"vars_of_lit M \\<subseteq> vars_of_cl (cl_ecl C)\""], ["proof (prove)\nusing this:\n  M \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. vars_of_lit M \\<subseteq> vars_of_cl (cl_ecl C)", "by auto"], ["proof (state)\nthis:\n  vars_of_lit M \\<subseteq> vars_of_cl (cl_ecl C)\n\ngoal (1 subgoal):\n 1. M \\<in> cl_ecl C \\<Longrightarrow> False", "from this and \\<open>coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\\<close>"], ["proof (chain)\npicking this:\n  vars_of_lit M \\<subseteq> vars_of_cl (cl_ecl C)\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))", "have \"coincide_on \\<sigma> \\<sigma>' (vars_of_lit M)\""], ["proof (prove)\nusing this:\n  vars_of_lit M \\<subseteq> vars_of_cl (cl_ecl C)\n  coincide_on \\<sigma> \\<sigma>' (vars_of_cl (cl_ecl C))\n\ngoal (1 subgoal):\n 1. coincide_on \\<sigma> \\<sigma>' (vars_of_lit M)", "unfolding coincide_on_def"], ["proof (prove)\nusing this:\n  vars_of_lit M \\<subseteq> vars_of_cl (cl_ecl C)\n  \\<forall>x\\<in>vars_of_cl (cl_ecl C).\n     Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_of_lit M.\n       Var x \\<lhd> \\<sigma> = Var x \\<lhd> \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_lit M)\n\ngoal (1 subgoal):\n 1. M \\<in> cl_ecl C \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_lit M)", "have \"subst_lit M \\<sigma> = subst_lit M \\<sigma>'\""], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_lit M)\n\ngoal (1 subgoal):\n 1. subst_lit M \\<sigma> = subst_lit M \\<sigma>'", "using coincide_on_lit"], ["proof (prove)\nusing this:\n  coincide_on \\<sigma> \\<sigma>' (vars_of_lit M)\n  coincide_on ?\\<sigma> ?\\<eta> (vars_of_lit ?l) \\<Longrightarrow>\n  subst_lit ?l ?\\<sigma> = subst_lit ?l ?\\<eta>\n\ngoal (1 subgoal):\n 1. subst_lit M \\<sigma> = subst_lit M \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  subst_lit M \\<sigma> = subst_lit M \\<sigma>'\n\ngoal (1 subgoal):\n 1. M \\<in> cl_ecl C \\<Longrightarrow> False", "from this and \\<open>L'' = subst_lit M \\<sigma>'\\<close>"], ["proof (chain)\npicking this:\n  subst_lit M \\<sigma> = subst_lit M \\<sigma>'\n  L'' = subst_lit M \\<sigma>'", "have \"L'' = subst_lit M \\<sigma>\""], ["proof (prove)\nusing this:\n  subst_lit M \\<sigma> = subst_lit M \\<sigma>'\n  L'' = subst_lit M \\<sigma>'\n\ngoal (1 subgoal):\n 1. L'' = subst_lit M \\<sigma>", "by auto"], ["proof (state)\nthis:\n  L'' = subst_lit M \\<sigma>\n\ngoal (1 subgoal):\n 1. M \\<in> cl_ecl C \\<Longrightarrow> False", "from \\<open>M \\<in> cl_ecl C\\<close> and \\<open>L'' = subst_lit M \\<sigma>\\<close>and \\<open>validate_ground_lit ?I L''\\<close>"], ["proof (chain)\npicking this:\n  M \\<in> cl_ecl C\n  L'' = subst_lit M \\<sigma>\n  validate_ground_lit (int_clset S) L''", "have \"validate_ground_clause ?I (subst_cl (cl_ecl C) \\<sigma>)\""], ["proof (prove)\nusing this:\n  M \\<in> cl_ecl C\n  L'' = subst_lit M \\<sigma>\n  validate_ground_lit (int_clset S) L''\n\ngoal (1 subgoal):\n 1. validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)", "by (metis (mono_tags, lifting) subst_cl.simps mem_Collect_eq \n              validate_ground_clause.simps)"], ["proof (state)\nthis:\n  validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. M \\<in> cl_ecl C \\<Longrightarrow> False", "from this and cm"], ["proof (chain)\npicking this:\n  validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)", "show False"], ["proof (prove)\nusing this:\n  validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  M \\<notin> cl_ecl C\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "have \"M \\<notin> Cl_D - { L2 }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<notin> Cl_D - {L2}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. M \\<in> Cl_D - {L2} \\<Longrightarrow> False", "assume \"M \\<in> Cl_D - { L2 }\""], ["proof (state)\nthis:\n  M \\<in> Cl_D - {L2}\n\ngoal (1 subgoal):\n 1. M \\<in> Cl_D - {L2} \\<Longrightarrow> False", "from this  and cld and \\<open>L'' = subst_lit M \\<sigma>'\\<close> and \\<open>validate_ground_lit ?I L''\\<close>"], ["proof (chain)\npicking this:\n  M \\<in> Cl_D - {L2}\n  Cl_D = cl_ecl D\n  L'' = subst_lit M \\<sigma>'\n  validate_ground_lit (int_clset S) L''", "have \"validate_ground_clause ?I (subst_cl ( (cl_ecl D) - { L2 } ) \\<sigma>')\""], ["proof (prove)\nusing this:\n  M \\<in> Cl_D - {L2}\n  Cl_D = cl_ecl D\n  L'' = subst_lit M \\<sigma>'\n  validate_ground_lit (int_clset S) L''\n\ngoal (1 subgoal):\n 1. validate_ground_clause (int_clset S)\n     (subst_cl (cl_ecl D - {L2}) \\<sigma>')", "by (metis (mono_tags, lifting) subst_cl.simps mem_Collect_eq validate_ground_clause.simps)"], ["proof (state)\nthis:\n  validate_ground_clause (int_clset S)\n   (subst_cl (cl_ecl D - {L2}) \\<sigma>')\n\ngoal (1 subgoal):\n 1. M \\<in> Cl_D - {L2} \\<Longrightarrow> False", "from this and \\<open>\\<not>validate_ground_clause ?I (subst_cl ( (cl_ecl D) - { L2 } ) \\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  validate_ground_clause (int_clset S)\n   (subst_cl (cl_ecl D - {L2}) \\<sigma>')\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl D - {L2}) \\<sigma>')", "show False"], ["proof (prove)\nusing this:\n  validate_ground_clause (int_clset S)\n   (subst_cl (cl_ecl D - {L2}) \\<sigma>')\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl D - {L2}) \\<sigma>')\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  M \\<notin> Cl_D - {L2}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "have \"M \\<noteq> L'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<noteq> L'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. M = L' \\<Longrightarrow> False", "assume \"M = L'\""], ["proof (state)\nthis:\n  M = L'\n\ngoal (1 subgoal):\n 1. M = L' \\<Longrightarrow> False", "from \\<open>?I (subst u \\<sigma>')  (subst v \\<sigma>')\\<close> \n            and e"], ["proof (chain)\npicking this:\n  int_clset S (u \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>')\n  u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>'", "have \"?I (subst u' \\<sigma>')  (subst v \\<sigma>')\""], ["proof (prove)\nusing this:\n  int_clset S (u \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>')\n  u' \\<lhd> \\<sigma>' = u \\<lhd> \\<sigma>'\n\ngoal (1 subgoal):\n 1. int_clset S (u' \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>')", "by metis"], ["proof (state)\nthis:\n  int_clset S (u' \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>')\n\ngoal (1 subgoal):\n 1. M = L' \\<Longrightarrow> False", "from rt and st \\<open>fo_interpretation ?I\\<close> \\<open>?I (subst u' \\<sigma>')  (subst v \\<sigma>')\\<close>"], ["proof (chain)\npicking this:\n  replace_subterm t p v t'\n  subterm t p u'\n  fo_interpretation (int_clset S)\n  int_clset S (u' \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>')", "have \"?I (subst t \\<sigma>') (subst t' \\<sigma>')\""], ["proof (prove)\nusing this:\n  replace_subterm t p v t'\n  subterm t p u'\n  fo_interpretation (int_clset S)\n  int_clset S (u' \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>')\n\ngoal (1 subgoal):\n 1. int_clset S (t \\<lhd> \\<sigma>') (t' \\<lhd> \\<sigma>')", "using replacement_preserves_congruences [of ?I u' \\<sigma>' v t p t']"], ["proof (prove)\nusing this:\n  replace_subterm t p v t'\n  subterm t p u'\n  fo_interpretation (int_clset S)\n  int_clset S (u' \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>')\n  \\<lbrakk>congruence (int_clset S);\n   int_clset S (u' \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>'); subterm t p u';\n   replace_subterm t p v t'\\<rbrakk>\n  \\<Longrightarrow> int_clset S (t \\<lhd> \\<sigma>') (t' \\<lhd> \\<sigma>')\n\ngoal (1 subgoal):\n 1. int_clset S (t \\<lhd> \\<sigma>') (t' \\<lhd> \\<sigma>')", "unfolding fo_interpretation_def"], ["proof (prove)\nusing this:\n  replace_subterm t p v t'\n  subterm t p u'\n  congruence (int_clset S)\n  int_clset S (u' \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>')\n  \\<lbrakk>congruence (int_clset S);\n   int_clset S (u' \\<lhd> \\<sigma>') (v \\<lhd> \\<sigma>'); subterm t p u';\n   replace_subterm t p v t'\\<rbrakk>\n  \\<Longrightarrow> int_clset S (t \\<lhd> \\<sigma>') (t' \\<lhd> \\<sigma>')\n\ngoal (1 subgoal):\n 1. int_clset S (t \\<lhd> \\<sigma>') (t' \\<lhd> \\<sigma>')", "by metis"], ["proof (state)\nthis:\n  int_clset S (t \\<lhd> \\<sigma>') (t' \\<lhd> \\<sigma>')\n\ngoal (1 subgoal):\n 1. M = L' \\<Longrightarrow> False", "from l1 and cm"], ["proof (chain)\npicking this:\n  L1 \\<in> cl_ecl C\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)", "have \"\\<not> (validate_ground_lit ?I (subst_lit L1 \\<sigma>'))\""], ["proof (prove)\nusing this:\n  L1 \\<in> cl_ecl C\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_lit (int_clset S) (subst_lit L1 \\<sigma>')", "using \\<open>subst_cl (cl_ecl C) \\<sigma>' = subst_cl (cl_ecl C) \\<sigma>\\<close> \n            \\<open>subst_lit L1 \\<sigma>' \\<in> subst_cl (cl_ecl C) \\<sigma>'\\<close> \n            validate_ground_clause.simps"], ["proof (prove)\nusing this:\n  L1 \\<in> cl_ecl C\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n  subst_cl (cl_ecl C) \\<sigma>' = subst_cl (cl_ecl C) \\<sigma>\n  subst_lit L1 \\<sigma>' \\<in> subst_cl (cl_ecl C) \\<sigma>'\n  validate_ground_clause ?I ?C =\n  (\\<exists>L. L \\<in> ?C \\<and> validate_ground_lit ?I L)\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_lit (int_clset S) (subst_lit L1 \\<sigma>')", "by blast"], ["proof (state)\nthis:\n  \\<not> validate_ground_lit (int_clset S) (subst_lit L1 \\<sigma>')\n\ngoal (1 subgoal):\n 1. M = L' \\<Longrightarrow> False", "from this and \\<open>?I (subst t \\<sigma>') (subst t' \\<sigma>')\\<close> and \\<open>fo_interpretation ?I\\<close> \n            and l' \\<open>orient_lit_inst L1 t s polarity \\<sigma>'\\<close>"], ["proof (chain)\npicking this:\n  \\<not> validate_ground_lit (int_clset S) (subst_lit L1 \\<sigma>')\n  int_clset S (t \\<lhd> \\<sigma>') (t' \\<lhd> \\<sigma>')\n  fo_interpretation (int_clset S)\n  L' = mk_lit polarity (Eq t' s)\n  orient_lit_inst L1 t s polarity \\<sigma>'", "have \"\\<not>validate_ground_lit ?I (subst_lit L' \\<sigma>')\""], ["proof (prove)\nusing this:\n  \\<not> validate_ground_lit (int_clset S) (subst_lit L1 \\<sigma>')\n  int_clset S (t \\<lhd> \\<sigma>') (t' \\<lhd> \\<sigma>')\n  fo_interpretation (int_clset S)\n  L' = mk_lit polarity (Eq t' s)\n  orient_lit_inst L1 t s polarity \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_lit (int_clset S) (subst_lit L' \\<sigma>')", "using trm_rep_preserves_lit_semantics [of ?I t \\<sigma>' t' L1 s polarity \\<sigma>']"], ["proof (prove)\nusing this:\n  \\<not> validate_ground_lit (int_clset S) (subst_lit L1 \\<sigma>')\n  int_clset S (t \\<lhd> \\<sigma>') (t' \\<lhd> \\<sigma>')\n  fo_interpretation (int_clset S)\n  L' = mk_lit polarity (Eq t' s)\n  orient_lit_inst L1 t s polarity \\<sigma>'\n  \\<lbrakk>fo_interpretation (int_clset S);\n   int_clset S (t \\<lhd> \\<sigma>') (t' \\<lhd> \\<sigma>');\n   orient_lit_inst L1 t s polarity \\<sigma>';\n   \\<not> validate_ground_lit (int_clset S)\n           (subst_lit L1 \\<sigma>')\\<rbrakk>\n  \\<Longrightarrow> \\<not> validate_ground_lit (int_clset S)\n                            (subst_lit (mk_lit polarity (Eq t' s))\n                              \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_lit (int_clset S) (subst_lit L' \\<sigma>')", "by metis"], ["proof (state)\nthis:\n  \\<not> validate_ground_lit (int_clset S) (subst_lit L' \\<sigma>')\n\ngoal (1 subgoal):\n 1. M = L' \\<Longrightarrow> False", "from this and \\<open>M = L'\\<close> and \\<open>validate_ground_lit ?I L''\\<close> and \\<open>L'' = subst_lit M \\<sigma>'\\<close>"], ["proof (chain)\npicking this:\n  \\<not> validate_ground_lit (int_clset S) (subst_lit L' \\<sigma>')\n  M = L'\n  validate_ground_lit (int_clset S) L''\n  L'' = subst_lit M \\<sigma>'", "show False"], ["proof (prove)\nusing this:\n  \\<not> validate_ground_lit (int_clset S) (subst_lit L' \\<sigma>')\n  M = L'\n  validate_ground_lit (int_clset S) L''\n  L'' = subst_lit M \\<sigma>'\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  M \\<noteq> L'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n               \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n                        (int_clset S) S \\<sigma> \\<and>\n                       variable_disjoint C D)) \\<Longrightarrow>\n    False", "from this and \\<open>M \\<notin> Cl_D - { L2 }\\<close> \\<open>M \\<notin> (cl_ecl C)\\<close> and m clc"], ["proof (chain)\npicking this:\n  M \\<noteq> L'\n  M \\<notin> Cl_D - {L2}\n  M \\<notin> cl_ecl C\n  M \\<in> Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'})\n  Cl_C = cl_ecl C", "show False"], ["proof (prove)\nusing this:\n  M \\<noteq> L'\n  M \\<notin> Cl_D - {L2}\n  M \\<notin> cl_ecl C\n  M \\<in> Cl_C - {L1} \\<union> (Cl_D - {L2} \\<union> {L'})\n  Cl_C = cl_ecl C\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n     \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n              (int_clset S) S \\<sigma> \\<and>\n             variable_disjoint C D)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "text \\<open>Second, we show that the clause contains no contradictory literal (otherwise the reflexion \nrule applies).\\<close>"], ["proof (state)\nthis:\n  \\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n     \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n              (int_clset S) S \\<sigma> \\<and>\n             variable_disjoint C D)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "let ?no_cont = \"\\<forall>L t s. (L \\<in> (cl_ecl C)) \\<longrightarrow> (eligible_literal L C \\<sigma>) \n        \\<longrightarrow> (orient_lit_inst L t s neg \\<sigma>) \\<longrightarrow> (trm_rep (subst t \\<sigma>)  S) =  (subst t \\<sigma>) \n        \\<longrightarrow> (subst t \\<sigma>) \\<noteq> (subst s \\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "have ?no_cont"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>L t s.\n       L \\<in> cl_ecl C \\<longrightarrow>\n       eligible_literal L C \\<sigma> \\<longrightarrow>\n       orient_lit_inst L t s neg \\<sigma> \\<longrightarrow>\n       trm_rep (t \\<lhd> \\<sigma>) S = t \\<lhd> \\<sigma> \\<longrightarrow>\n       t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L t s.\n               L \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L C \\<sigma> \\<longrightarrow>\n               orient_lit_inst L t s neg \\<sigma> \\<longrightarrow>\n               trm_rep (t \\<lhd> \\<sigma>) S =\n               t \\<lhd> \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> \\<noteq>\n               s \\<lhd> \\<sigma>) \\<Longrightarrow>\n    False", "assume \"\\<not> ?no_cont\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>L t s.\n             L \\<in> cl_ecl C \\<longrightarrow>\n             eligible_literal L C \\<sigma> \\<longrightarrow>\n             orient_lit_inst L t s neg \\<sigma> \\<longrightarrow>\n             trm_rep (t \\<lhd> \\<sigma>) S =\n             t \\<lhd> \\<sigma> \\<longrightarrow>\n             t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L t s.\n               L \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L C \\<sigma> \\<longrightarrow>\n               orient_lit_inst L t s neg \\<sigma> \\<longrightarrow>\n               trm_rep (t \\<lhd> \\<sigma>) S =\n               t \\<lhd> \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> \\<noteq>\n               s \\<lhd> \\<sigma>) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>L t s.\n             L \\<in> cl_ecl C \\<longrightarrow>\n             eligible_literal L C \\<sigma> \\<longrightarrow>\n             orient_lit_inst L t s neg \\<sigma> \\<longrightarrow>\n             trm_rep (t \\<lhd> \\<sigma>) S =\n             t \\<lhd> \\<sigma> \\<longrightarrow>\n             t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>)", "obtain L t s where l: \"L \\<in> (cl_ecl C)\" and e: \"(eligible_literal L C \\<sigma>)\" \n          and o: \"orient_lit_inst L t s neg \\<sigma>\"\n          and \"(trm_rep (subst t \\<sigma>)  S) =  (subst t \\<sigma>)\"\n          and \"(subst t \\<sigma>) = (subst s \\<sigma>)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>L t s.\n             L \\<in> cl_ecl C \\<longrightarrow>\n             eligible_literal L C \\<sigma> \\<longrightarrow>\n             orient_lit_inst L t s neg \\<sigma> \\<longrightarrow>\n             trm_rep (t \\<lhd> \\<sigma>) S =\n             t \\<lhd> \\<sigma> \\<longrightarrow>\n             t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>L t s.\n        \\<lbrakk>L \\<in> cl_ecl C; eligible_literal L C \\<sigma>;\n         orient_lit_inst L t s neg \\<sigma>;\n         trm_rep (t \\<lhd> \\<sigma>) S = t \\<lhd> \\<sigma>;\n         t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  L \\<in> cl_ecl C\n  eligible_literal L C \\<sigma>\n  orient_lit_inst L t s neg \\<sigma>\n  trm_rep (t \\<lhd> \\<sigma>) S = t \\<lhd> \\<sigma>\n  t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L t s.\n               L \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L C \\<sigma> \\<longrightarrow>\n               orient_lit_inst L t s neg \\<sigma> \\<longrightarrow>\n               trm_rep (t \\<lhd> \\<sigma>) S =\n               t \\<lhd> \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> \\<noteq>\n               s \\<lhd> \\<sigma>) \\<Longrightarrow>\n    False", "from \\<open>(subst t \\<sigma>) = (subst s \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>", "have t: \"ck_unifier t s \\<sigma> Ground\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. ck_unifier t s \\<sigma> Ground", "unfolding ck_unifier_def Unifier_def"], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. if Ground = FirstOrder then MGU \\<sigma> t s\n    else t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  ck_unifier t s \\<sigma> Ground\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L t s.\n               L \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L C \\<sigma> \\<longrightarrow>\n               orient_lit_inst L t s neg \\<sigma> \\<longrightarrow>\n               trm_rep (t \\<lhd> \\<sigma>) S =\n               t \\<lhd> \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> \\<noteq>\n               s \\<lhd> \\<sigma>) \\<Longrightarrow>\n    False", "from l and e and o and t"], ["proof (chain)\npicking this:\n  L \\<in> cl_ecl C\n  eligible_literal L C \\<sigma>\n  orient_lit_inst L t s neg \\<sigma>\n  ck_unifier t s \\<sigma> Ground", "obtain R Cl_R nt_R where \n            \"R = Ecl Cl_R nt_R\" and \"Cl_R = (subst_cl ((cl_ecl C) - { L }) \\<sigma>)\" and \n            \"reflexion C R \\<sigma> Ground ((cl_ecl C) - { L })\" \n            and \"trms_ecl R = (dom_trms (cl_ecl R) (subst_set ((trms_ecl C) \\<union> { t }) \\<sigma>))\""], ["proof (prove)\nusing this:\n  L \\<in> cl_ecl C\n  eligible_literal L C \\<sigma>\n  orient_lit_inst L t s neg \\<sigma>\n  ck_unifier t s \\<sigma> Ground\n\ngoal (1 subgoal):\n 1. (\\<And>R Cl_R nt_R.\n        \\<lbrakk>R = Ecl Cl_R nt_R;\n         Cl_R = subst_cl (cl_ecl C - {L}) \\<sigma>;\n         reflexion C R \\<sigma> Ground (cl_ecl C - {L});\n         trms_ecl R =\n         dom_trms (cl_ecl R)\n          (subst_set (trms_ecl C \\<union> {t}) \\<sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding reflexion_def get_trms_def"], ["proof (prove)\nusing this:\n  L \\<in> cl_ecl C\n  eligible_literal L C \\<sigma>\n  orient_lit_inst L t s neg \\<sigma>\n  ck_unifier t s \\<sigma> Ground\n\ngoal (1 subgoal):\n 1. (\\<And>R Cl_R nt_R.\n        \\<lbrakk>R = Ecl Cl_R nt_R;\n         Cl_R = subst_cl (cl_ecl C - {L}) \\<sigma>;\n         \\<exists>L1 t s Cl_P Cl_C trms_C.\n            eligible_literal L1 C \\<sigma> \\<and>\n            L1 \\<in> cl_ecl C \\<and>\n            Cl_C = cl_ecl R \\<and>\n            Cl_P = cl_ecl C \\<and>\n            orient_lit_inst L1 t s neg \\<sigma> \\<and>\n            ck_unifier t s \\<sigma> Ground \\<and>\n            R = Ecl Cl_C trms_C \\<and>\n            trms_C =\n            (if Ground = FirstOrder\n             then filter_trms Cl_C\n                   (dom_trms Cl_C\n                     (subst_set (trms_ecl C \\<union> {t}) \\<sigma>))\n             else dom_trms Cl_C\n                   (subst_set (trms_ecl C \\<union> {t}) \\<sigma>)) \\<and>\n            Cl_C = subst_cl (cl_ecl C - {L}) \\<sigma> \\<and>\n            cl_ecl C - {L} = Cl_P - {L1};\n         trms_ecl R =\n         dom_trms (cl_ecl R)\n          (subst_set (trms_ecl C \\<union> {t}) \\<sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  R = Ecl Cl_R nt_R\n  Cl_R = subst_cl (cl_ecl C - {L}) \\<sigma>\n  reflexion C R \\<sigma> Ground (cl_ecl C - {L})\n  trms_ecl R =\n  dom_trms (cl_ecl R) (subst_set (trms_ecl C \\<union> {t}) \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L t s.\n               L \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L C \\<sigma> \\<longrightarrow>\n               orient_lit_inst L t s neg \\<sigma> \\<longrightarrow>\n               trm_rep (t \\<lhd> \\<sigma>) S =\n               t \\<lhd> \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> \\<noteq>\n               s \\<lhd> \\<sigma>) \\<Longrightarrow>\n    False", "from \\<open>C \\<in> S\\<close> and \\<open>reflexion C R \\<sigma> Ground ((cl_ecl C) - { L })\\<close>"], ["proof (chain)\npicking this:\n  C \\<in> S\n  reflexion C R \\<sigma> Ground (cl_ecl C - {L})", "have \"derivable R { C } S \\<sigma> Ground ((cl_ecl C) - { L })\""], ["proof (prove)\nusing this:\n  C \\<in> S\n  reflexion C R \\<sigma> Ground (cl_ecl C - {L})\n\ngoal (1 subgoal):\n 1. derivable R {C} S \\<sigma> Ground (cl_ecl C - {L})", "unfolding derivable_def"], ["proof (prove)\nusing this:\n  C \\<in> S\n  reflexion C R \\<sigma> Ground (cl_ecl C - {L})\n\ngoal (1 subgoal):\n 1. (\\<exists>P1 P2.\n        P1 \\<in> S \\<and>\n        P2 \\<in> S \\<and>\n        {C} = {P1, P2} \\<and>\n        superposition P1 P2 R \\<sigma> Ground (cl_ecl C - {L})) \\<or>\n    (\\<exists>P1.\n        P1 \\<in> S \\<and>\n        {C} = {P1} \\<and>\n        factorization P1 R \\<sigma> Ground (cl_ecl C - {L})) \\<or>\n    (\\<exists>P1.\n        P1 \\<in> S \\<and>\n        {C} = {P1} \\<and> reflexion P1 R \\<sigma> Ground (cl_ecl C - {L}))", "by auto"], ["proof (state)\nthis:\n  derivable R {C} S \\<sigma> Ground (cl_ecl C - {L})\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L t s.\n               L \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L C \\<sigma> \\<longrightarrow>\n               orient_lit_inst L t s neg \\<sigma> \\<longrightarrow>\n               trm_rep (t \\<lhd> \\<sigma>) S =\n               t \\<lhd> \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> \\<noteq>\n               s \\<lhd> \\<sigma>) \\<Longrightarrow>\n    False", "from \\<open>ground_clause (subst_cl (cl_ecl C) \\<sigma>)\\<close> \n          and \\<open>Cl_R = (subst_cl ((cl_ecl C) - { L }) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n  Cl_R = subst_cl (cl_ecl C - {L}) \\<sigma>", "have \"ground_clause Cl_R\""], ["proof (prove)\nusing this:\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n  Cl_R = subst_cl (cl_ecl C - {L}) \\<sigma>\n\ngoal (1 subgoal):\n 1. ground_clause Cl_R", "using ground_clause.simps"], ["proof (prove)\nusing this:\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n  Cl_R = subst_cl (cl_ecl C - {L}) \\<sigma>\n  ground_clause ?C = (vars_of_cl ?C = {})\n\ngoal (1 subgoal):\n 1. ground_clause Cl_R", "by auto"], ["proof (state)\nthis:\n  ground_clause Cl_R\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L t s.\n               L \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L C \\<sigma> \\<longrightarrow>\n               orient_lit_inst L t s neg \\<sigma> \\<longrightarrow>\n               trm_rep (t \\<lhd> \\<sigma>) S =\n               t \\<lhd> \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> \\<noteq>\n               s \\<lhd> \\<sigma>) \\<Longrightarrow>\n    False", "from this and \\<open>R = Ecl Cl_R nt_R\\<close>"], ["proof (chain)\npicking this:\n  ground_clause Cl_R\n  R = Ecl Cl_R nt_R", "have \"ground_clause (cl_ecl R)\""], ["proof (prove)\nusing this:\n  ground_clause Cl_R\n  R = Ecl Cl_R nt_R\n\ngoal (1 subgoal):\n 1. ground_clause (cl_ecl R)", "by auto"], ["proof (state)\nthis:\n  ground_clause (cl_ecl R)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L t s.\n               L \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L C \\<sigma> \\<longrightarrow>\n               orient_lit_inst L t s neg \\<sigma> \\<longrightarrow>\n               trm_rep (t \\<lhd> \\<sigma>) S =\n               t \\<lhd> \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> \\<noteq>\n               s \\<lhd> \\<sigma>) \\<Longrightarrow>\n    False", "from \\<open>ground_clause (subst_cl (cl_ecl C) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)", "have \"grounding_set { C } \\<sigma>\""], ["proof (prove)\nusing this:\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. grounding_set {C} \\<sigma>", "unfolding grounding_set_def"], ["proof (prove)\nusing this:\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<in> {C} \\<longrightarrow>\n       ground_clause (subst_cl (cl_ecl x) \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  grounding_set {C} \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L t s.\n               L \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L C \\<sigma> \\<longrightarrow>\n               orient_lit_inst L t s neg \\<sigma> \\<longrightarrow>\n               trm_rep (t \\<lhd> \\<sigma>) S =\n               t \\<lhd> \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> \\<noteq>\n               s \\<lhd> \\<sigma>) \\<Longrightarrow>\n    False", "from this and \\<open>ground_clause (cl_ecl R)\\<close>\n         \\<open>derivable R { C } S \\<sigma> Ground ((cl_ecl C) - { L })\\<close> and \\<open>ground_inference_saturated S\\<close>"], ["proof (chain)\npicking this:\n  grounding_set {C} \\<sigma>\n  ground_clause (cl_ecl R)\n  derivable R {C} S \\<sigma> Ground (cl_ecl C - {L})\n  ground_inference_saturated S", "have \"(redundant_inference R S { C } \\<sigma>)\""], ["proof (prove)\nusing this:\n  grounding_set {C} \\<sigma>\n  ground_clause (cl_ecl R)\n  derivable R {C} S \\<sigma> Ground (cl_ecl C - {L})\n  ground_inference_saturated S\n\ngoal (1 subgoal):\n 1. redundant_inference R S {C} \\<sigma>", "unfolding ground_inference_saturated_def"], ["proof (prove)\nusing this:\n  grounding_set {C} \\<sigma>\n  ground_clause (cl_ecl R)\n  derivable R {C} S \\<sigma> Ground (cl_ecl C - {L})\n  \\<forall>C P \\<sigma> C'.\n     derivable C P S \\<sigma> Ground C' \\<longrightarrow>\n     ground_clause (cl_ecl C) \\<longrightarrow>\n     grounding_set P \\<sigma> \\<longrightarrow>\n     redundant_inference C S P \\<sigma>\n\ngoal (1 subgoal):\n 1. redundant_inference R S {C} \\<sigma>", "by blast"], ["proof (state)\nthis:\n  redundant_inference R S {C} \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L t s.\n               L \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L C \\<sigma> \\<longrightarrow>\n               orient_lit_inst L t s neg \\<sigma> \\<longrightarrow>\n               trm_rep (t \\<lhd> \\<sigma>) S =\n               t \\<lhd> \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> \\<noteq>\n               s \\<lhd> \\<sigma>) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  redundant_inference R S {C} \\<sigma>", "obtain S' where \"S' \\<subseteq> (instances S)\" and \n          \"(set_entails_clause (clset_instances S') (cl_ecl R))\"\n          and all_smaller: \"(\\<forall>x \\<in> S'. (((fst x),(snd x)),(C,\\<sigma>)) \\<in> ecl_ord)\"\n          and all_normalized_term_included: \"(\\<forall>x \\<in> S'. \n          (subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))  \n              (trms_ecl R)))\""], ["proof (prove)\nusing this:\n  redundant_inference R S {C} \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>S'.\n        \\<lbrakk>S' \\<subseteq> instances S;\n         set_entails_clause (clset_instances S') (cl_ecl R);\n         \\<forall>x\\<in>S'. ((fst x, snd x), C, \\<sigma>) \\<in> ecl_ord;\n         \\<forall>x\\<in>S'.\n            subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n             (trms_ecl R)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding redundant_inference_def"], ["proof (prove)\nusing this:\n  \\<exists>S'\\<subseteq>instances S.\n     set_entails_clause (clset_instances S') (cl_ecl R) \\<and>\n     (\\<forall>x\\<in>S'.\n         subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n          (trms_ecl R)) \\<and>\n     (\\<forall>x\\<in>S'.\n         \\<exists>D'\\<in>{C}. ((fst x, snd x), D', \\<sigma>) \\<in> ecl_ord)\n\ngoal (1 subgoal):\n 1. (\\<And>S'.\n        \\<lbrakk>S' \\<subseteq> instances S;\n         set_entails_clause (clset_instances S') (cl_ecl R);\n         \\<forall>x\\<in>S'. ((fst x, snd x), C, \\<sigma>) \\<in> ecl_ord;\n         \\<forall>x\\<in>S'.\n            subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n             (trms_ecl R)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  S' \\<subseteq> instances S\n  set_entails_clause (clset_instances S') (cl_ecl R)\n  \\<forall>x\\<in>S'. ((fst x, snd x), C, \\<sigma>) \\<in> ecl_ord\n  \\<forall>x\\<in>S'.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) (trms_ecl R)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L t s.\n               L \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L C \\<sigma> \\<longrightarrow>\n               orient_lit_inst L t s neg \\<sigma> \\<longrightarrow>\n               trm_rep (t \\<lhd> \\<sigma>) S =\n               t \\<lhd> \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> \\<noteq>\n               s \\<lhd> \\<sigma>) \\<Longrightarrow>\n    False", "have \"validate_clause_set ?I (clset_instances S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. validate_clause_set (int_clset S) (clset_instances S')", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "assume \"\\<not> validate_clause_set ?I (clset_instances S')\""], ["proof (state)\nthis:\n  \\<not> validate_clause_set (int_clset S) (clset_instances S')\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> validate_clause_set (int_clset S) (clset_instances S')", "obtain x where \"x \\<in>(clset_instances S')\" and \"\\<not>validate_clause ?I x\""], ["proof (prove)\nusing this:\n  \\<not> validate_clause_set (int_clset S) (clset_instances S')\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> clset_instances S';\n         \\<not> validate_clause (int_clset S) x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using validate_clause_set.simps"], ["proof (prove)\nusing this:\n  \\<not> validate_clause_set (int_clset S) (clset_instances S')\n  validate_clause_set ?I ?S =\n  (\\<forall>C. C \\<in> ?S \\<longrightarrow> validate_clause ?I C)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> clset_instances S';\n         \\<not> validate_clause (int_clset S) x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> clset_instances S'\n  \\<not> validate_clause (int_clset S) x\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from \\<open>x \\<in>(clset_instances S')\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> clset_instances S'", "obtain pair' where \"pair' \\<in> S'\" \n          and \"x = (subst_cl (cl_ecl (fst pair')) (snd pair'))\""], ["proof (prove)\nusing this:\n  x \\<in> clset_instances S'\n\ngoal (1 subgoal):\n 1. (\\<And>pair'.\n        \\<lbrakk>pair' \\<in> S';\n         x = subst_cl (cl_ecl (fst pair')) (snd pair')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding clset_instances_def"], ["proof (prove)\nusing this:\n  x \\<in> {C. \\<exists>x.\n                 x \\<in> S' \\<and> C = subst_cl (cl_ecl (fst x)) (snd x)}\n\ngoal (1 subgoal):\n 1. (\\<And>pair'.\n        \\<lbrakk>pair' \\<in> S';\n         x = subst_cl (cl_ecl (fst pair')) (snd pair')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  pair' \\<in> S'\n  x = subst_cl (cl_ecl (fst pair')) (snd pair')\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from all_smaller and \\<open>pair' \\<in> S'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S'. ((fst x, snd x), C, \\<sigma>) \\<in> ecl_ord\n  pair' \\<in> S'", "have \"(pair',(C,\\<sigma>)) \\<in> ecl_ord\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S'. ((fst x, snd x), C, \\<sigma>) \\<in> ecl_ord\n  pair' \\<in> S'\n\ngoal (1 subgoal):\n 1. (pair', C, \\<sigma>) \\<in> ecl_ord", "by auto"], ["proof (state)\nthis:\n  (pair', C, \\<sigma>) \\<in> ecl_ord\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from this and  \\<open>C = fst pair\\<close> and \\<open>\\<sigma> = snd pair\\<close>"], ["proof (chain)\npicking this:\n  (pair', C, \\<sigma>) \\<in> ecl_ord\n  C = fst pair\n  \\<sigma> = snd pair", "have \"(pair',pair) \\<in> ecl_ord\""], ["proof (prove)\nusing this:\n  (pair', C, \\<sigma>) \\<in> ecl_ord\n  C = fst pair\n  \\<sigma> = snd pair\n\ngoal (1 subgoal):\n 1. (pair', pair) \\<in> ecl_ord", "by auto"], ["proof (state)\nthis:\n  (pair', pair) \\<in> ecl_ord\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from this and hyp_ind"], ["proof (chain)\npicking this:\n  (pair', pair) \\<in> ecl_ord\n  \\<forall>y.\n     (y, pair) \\<in> ecl_ord \\<longrightarrow>\n     (\\<forall>C \\<sigma>.\n         fst y = C \\<longrightarrow>\n         \\<sigma> = snd y \\<longrightarrow>\n         C \\<in> S \\<longrightarrow>\n         ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n         all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n          (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n         validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n          (subst_cl (cl_ecl C) \\<sigma>))", "have \"?P pair'\""], ["proof (prove)\nusing this:\n  (pair', pair) \\<in> ecl_ord\n  \\<forall>y.\n     (y, pair) \\<in> ecl_ord \\<longrightarrow>\n     (\\<forall>C \\<sigma>.\n         fst y = C \\<longrightarrow>\n         \\<sigma> = snd y \\<longrightarrow>\n         C \\<in> S \\<longrightarrow>\n         ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n         all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n          (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n         validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n          (subst_cl (cl_ecl C) \\<sigma>))\n\ngoal (1 subgoal):\n 1. \\<forall>C \\<sigma>.\n       fst pair' = C \\<longrightarrow>\n       \\<sigma> = snd pair' \\<longrightarrow>\n       C \\<in> S \\<longrightarrow>\n       ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n       all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n        (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n       validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n        (subst_cl (cl_ecl C) \\<sigma>)", "by blast"], ["proof (state)\nthis:\n  \\<forall>C \\<sigma>.\n     fst pair' = C \\<longrightarrow>\n     \\<sigma> = snd pair' \\<longrightarrow>\n     C \\<in> S \\<longrightarrow>\n     ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n     all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n      (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n     validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n      (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from \\<open>trms_ecl R = (dom_trms (cl_ecl R) (subst_set ((trms_ecl C) \\<union> { t }) \\<sigma>))\\<close>"], ["proof (chain)\npicking this:\n  trms_ecl R =\n  dom_trms (cl_ecl R) (subst_set (trms_ecl C \\<union> {t}) \\<sigma>)", "have \"trms_ecl R \\<subseteq> (subst_set ((trms_ecl C) \\<union> { t }) \\<sigma>)\""], ["proof (prove)\nusing this:\n  trms_ecl R =\n  dom_trms (cl_ecl R) (subst_set (trms_ecl C \\<union> {t}) \\<sigma>)\n\ngoal (1 subgoal):\n 1. trms_ecl R \\<subseteq> subst_set (trms_ecl C \\<union> {t}) \\<sigma>", "using dom_trms_subset"], ["proof (prove)\nusing this:\n  trms_ecl R =\n  dom_trms (cl_ecl R) (subst_set (trms_ecl C \\<union> {t}) \\<sigma>)\n  dom_trms ?C ?E \\<subseteq> ?E\n\ngoal (1 subgoal):\n 1. trms_ecl R \\<subseteq> subst_set (trms_ecl C \\<union> {t}) \\<sigma>", "by metis"], ["proof (state)\nthis:\n  trms_ecl R \\<subseteq> subst_set (trms_ecl C \\<union> {t}) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from \\<open>pair' \\<in> S'\\<close> and all_normalized_term_included"], ["proof (chain)\npicking this:\n  pair' \\<in> S'\n  \\<forall>x\\<in>S'.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) (trms_ecl R)", "have \n          \"(subterms_inclusion (subst_set (trms_ecl (fst pair')) (snd pair')) \n             (trms_ecl R))\""], ["proof (prove)\nusing this:\n  pair' \\<in> S'\n  \\<forall>x\\<in>S'.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) (trms_ecl R)\n\ngoal (1 subgoal):\n 1. subterms_inclusion (subst_set (trms_ecl (fst pair')) (snd pair'))\n     (trms_ecl R)", "by auto"], ["proof (state)\nthis:\n  subterms_inclusion (subst_set (trms_ecl (fst pair')) (snd pair'))\n   (trms_ecl R)\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "have i: \"(all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair')) \n                  (\\<lambda>t. (trm_rep t S)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair'))\n     (\\<lambda>t. trm_rep t S)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "assume \"\\<not>(all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair')) \n                  (\\<lambda>t. (trm_rep t S)))\""], ["proof (state)\nthis:\n  \\<not> all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair'))\n          (\\<lambda>t. trm_rep t S)\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair'))\n          (\\<lambda>t. trm_rep t S)", "obtain t' t'' where \"t' \\<in> (subst_set (trms_ecl (fst pair')) (snd pair'))\" \n            \"occurs_in t'' t'\" and \"trm_rep t'' S \\<noteq> t''\""], ["proof (prove)\nusing this:\n  \\<not> all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair'))\n          (\\<lambda>t. trm_rep t S)\n\ngoal (1 subgoal):\n 1. (\\<And>t' t''.\n        \\<lbrakk>t' \\<in> subst_set (trms_ecl (fst pair')) (snd pair');\n         occurs_in t'' t'; trm_rep t'' S \\<noteq> t''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding all_trms_irreducible_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x y.\n             x \\<in> subst_set (trms_ecl (fst pair'))\n                      (snd pair') \\<longrightarrow>\n             occurs_in y x \\<longrightarrow> trm_rep y S = y)\n\ngoal (1 subgoal):\n 1. (\\<And>t' t''.\n        \\<lbrakk>t' \\<in> subst_set (trms_ecl (fst pair')) (snd pair');\n         occurs_in t'' t'; trm_rep t'' S \\<noteq> t''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t' \\<in> subst_set (trms_ecl (fst pair')) (snd pair')\n  occurs_in t'' t'\n  trm_rep t'' S \\<noteq> t''\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from \\<open>t' \\<in> (subst_set (trms_ecl (fst pair')) (snd pair'))\\<close> \n            and \\<open>(subterms_inclusion (subst_set (trms_ecl (fst pair')) (snd pair')) (trms_ecl R))\\<close>"], ["proof (chain)\npicking this:\n  t' \\<in> subst_set (trms_ecl (fst pair')) (snd pair')\n  subterms_inclusion (subst_set (trms_ecl (fst pair')) (snd pair'))\n   (trms_ecl R)", "obtain s' where \"s' \\<in> (trms_ecl R)\" and \"occurs_in t' s'\""], ["proof (prove)\nusing this:\n  t' \\<in> subst_set (trms_ecl (fst pair')) (snd pair')\n  subterms_inclusion (subst_set (trms_ecl (fst pair')) (snd pair'))\n   (trms_ecl R)\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>s' \\<in> trms_ecl R; occurs_in t' s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding subterms_inclusion_def"], ["proof (prove)\nusing this:\n  t' \\<in> subst_set (trms_ecl (fst pair')) (snd pair')\n  \\<forall>x1\\<in>subst_set (trms_ecl (fst pair')) (snd pair').\n     Bex (trms_ecl R) (occurs_in x1)\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>s' \\<in> trms_ecl R; occurs_in t' s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s' \\<in> trms_ecl R\n  occurs_in t' s'\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from \\<open>s' \\<in> (trms_ecl R)\\<close> and \\<open>trms_ecl R \\<subseteq> (subst_set ((trms_ecl C) \\<union> { t }) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  s' \\<in> trms_ecl R\n  trms_ecl R \\<subseteq> subst_set (trms_ecl C \\<union> {t}) \\<sigma>", "obtain s'' where \"s' = subst s'' \\<sigma>\" and \"s'' \\<in> ((trms_ecl C) \\<union> { t })\""], ["proof (prove)\nusing this:\n  s' \\<in> trms_ecl R\n  trms_ecl R \\<subseteq> subst_set (trms_ecl C \\<union> {t}) \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>s''.\n        \\<lbrakk>s' = s'' \\<lhd> \\<sigma>;\n         s'' \\<in> trms_ecl C \\<union> {t}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s' = s'' \\<lhd> \\<sigma>\n  s'' \\<in> trms_ecl C \\<union> {t}\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from \\<open>s'' \\<in> ((trms_ecl C) \\<union> { t })\\<close>"], ["proof (chain)\npicking this:\n  s'' \\<in> trms_ecl C \\<union> {t}", "have \"s'' \\<in> trms_ecl C \\<or> s'' = t\""], ["proof (prove)\nusing this:\n  s'' \\<in> trms_ecl C \\<union> {t}\n\ngoal (1 subgoal):\n 1. s'' \\<in> trms_ecl C \\<or> s'' = t", "by auto"], ["proof (state)\nthis:\n  s'' \\<in> trms_ecl C \\<or> s'' = t\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  s'' \\<in> trms_ecl C \\<or> s'' = t\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. s'' \\<in> trms_ecl C \\<Longrightarrow> False\n 2. s'' = t \\<Longrightarrow> False", "assume \"s'' \\<in> trms_ecl C\""], ["proof (state)\nthis:\n  s'' \\<in> trms_ecl C\n\ngoal (2 subgoals):\n 1. s'' \\<in> trms_ecl C \\<Longrightarrow> False\n 2. s'' = t \\<Longrightarrow> False", "from this and \\<open>s' = subst s'' \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  s'' \\<in> trms_ecl C\n  s' = s'' \\<lhd> \\<sigma>", "have \"s' \\<in> (subst_set (trms_ecl C) \\<sigma>)\""], ["proof (prove)\nusing this:\n  s'' \\<in> trms_ecl C\n  s' = s'' \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. s' \\<in> subst_set (trms_ecl C) \\<sigma>", "by auto"], ["proof (state)\nthis:\n  s' \\<in> subst_set (trms_ecl C) \\<sigma>\n\ngoal (2 subgoals):\n 1. s'' \\<in> trms_ecl C \\<Longrightarrow> False\n 2. s'' = t \\<Longrightarrow> False", "from this and \\<open>(all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>) \n                  (\\<lambda>t. (trm_rep t S)))\\<close> and \\<open>occurs_in t' s'\\<close>"], ["proof (chain)\npicking this:\n  s' \\<in> subst_set (trms_ecl C) \\<sigma>\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n  occurs_in t' s'", "have \"trm_rep t' S = t'\""], ["proof (prove)\nusing this:\n  s' \\<in> subst_set (trms_ecl C) \\<sigma>\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n  occurs_in t' s'\n\ngoal (1 subgoal):\n 1. trm_rep t' S = t'", "unfolding all_trms_irreducible_def"], ["proof (prove)\nusing this:\n  s' \\<in> subst_set (trms_ecl C) \\<sigma>\n  \\<forall>x y.\n     x \\<in> subst_set (trms_ecl C) \\<sigma> \\<longrightarrow>\n     occurs_in y x \\<longrightarrow> trm_rep y S = y\n  occurs_in t' s'\n\ngoal (1 subgoal):\n 1. trm_rep t' S = t'", "by blast"], ["proof (state)\nthis:\n  trm_rep t' S = t'\n\ngoal (2 subgoals):\n 1. s'' \\<in> trms_ecl C \\<Longrightarrow> False\n 2. s'' = t \\<Longrightarrow> False", "from this and \\<open>occurs_in t'' t'\\<close> and \\<open>trm_rep t'' S \\<noteq> t''\\<close>"], ["proof (chain)\npicking this:\n  trm_rep t' S = t'\n  occurs_in t'' t'\n  trm_rep t'' S \\<noteq> t''", "show False"], ["proof (prove)\nusing this:\n  trm_rep t' S = t'\n  occurs_in t'' t'\n  trm_rep t'' S \\<noteq> t''\n\ngoal (1 subgoal):\n 1. False", "using occurs_in_def subts_of_irred_trms_are_irred"], ["proof (prove)\nusing this:\n  trm_rep t' S = t'\n  occurs_in t'' t'\n  trm_rep t'' S \\<noteq> t''\n  occurs_in ?t ?s = (\\<exists>p. subterm ?s p ?t)\n  trm_rep ?y ?S \\<noteq> ?y \\<Longrightarrow>\n  subterm ?x ?p ?y \\<longrightarrow> trm_rep ?x ?S \\<noteq> ?x\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. s'' = t \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s'' = t \\<Longrightarrow> False", "assume \"s'' = t\""], ["proof (state)\nthis:\n  s'' = t\n\ngoal (1 subgoal):\n 1. s'' = t \\<Longrightarrow> False", "from this and \\<open>s' = subst s'' \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  s'' = t\n  s' = s'' \\<lhd> \\<sigma>", "have \"s' = subst t \\<sigma>\""], ["proof (prove)\nusing this:\n  s'' = t\n  s' = s'' \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. s' = t \\<lhd> \\<sigma>", "by auto"], ["proof (state)\nthis:\n  s' = t \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. s'' = t \\<Longrightarrow> False", "from this and \\<open>(trm_rep (subst t \\<sigma>)  S) =  (subst t \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  s' = t \\<lhd> \\<sigma>\n  trm_rep (t \\<lhd> \\<sigma>) S = t \\<lhd> \\<sigma>", "have \"trm_rep s' S = s'\""], ["proof (prove)\nusing this:\n  s' = t \\<lhd> \\<sigma>\n  trm_rep (t \\<lhd> \\<sigma>) S = t \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. trm_rep s' S = s'", "by blast"], ["proof (state)\nthis:\n  trm_rep s' S = s'\n\ngoal (1 subgoal):\n 1. s'' = t \\<Longrightarrow> False", "from \\<open>trm_rep s' S = s'\\<close> \\<open>trm_rep t'' S \\<noteq> t''\\<close> \\<open>occurs_in t' s'\\<close> \\<open>occurs_in t'' t'\\<close>"], ["proof (chain)\npicking this:\n  trm_rep s' S = s'\n  trm_rep t'' S \\<noteq> t''\n  occurs_in t' s'\n  occurs_in t'' t'", "show False"], ["proof (prove)\nusing this:\n  trm_rep s' S = s'\n  trm_rep t'' S \\<noteq> t''\n  occurs_in t' s'\n  occurs_in t'' t'\n\ngoal (1 subgoal):\n 1. False", "using occurs_in_def subts_of_irred_trms_are_irred"], ["proof (prove)\nusing this:\n  trm_rep s' S = s'\n  trm_rep t'' S \\<noteq> t''\n  occurs_in t' s'\n  occurs_in t'' t'\n  occurs_in ?t ?s = (\\<exists>p. subterm ?s p ?t)\n  trm_rep ?y ?S \\<noteq> ?y \\<Longrightarrow>\n  subterm ?x ?p ?y \\<longrightarrow> trm_rep ?x ?S \\<noteq> ?x\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair'))\n   (\\<lambda>t. trm_rep t S)\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from \\<open>S' \\<subseteq> (instances S)\\<close> and \\<open>pair' \\<in> S'\\<close>"], ["proof (chain)\npicking this:\n  S' \\<subseteq> instances S\n  pair' \\<in> S'", "have \n          ii: \"ground_clause (subst_cl (cl_ecl (fst pair')) (snd pair'))\""], ["proof (prove)\nusing this:\n  S' \\<subseteq> instances S\n  pair' \\<in> S'\n\ngoal (1 subgoal):\n 1. ground_clause (subst_cl (cl_ecl (fst pair')) (snd pair'))", "unfolding instances_def [of S]"], ["proof (prove)\nusing this:\n  S' \\<subseteq> {x. \\<exists>C \\<sigma>.\n                        C \\<in> S \\<and>\n                        ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<and>\n                        x = (C, \\<sigma>)}\n  pair' \\<in> S'\n\ngoal (1 subgoal):\n 1. ground_clause (subst_cl (cl_ecl (fst pair')) (snd pair'))", "by fastforce"], ["proof (state)\nthis:\n  ground_clause (subst_cl (cl_ecl (fst pair')) (snd pair'))\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from \\<open>S' \\<subseteq> (instances S)\\<close> and \\<open>pair' \\<in> S'\\<close>"], ["proof (chain)\npicking this:\n  S' \\<subseteq> instances S\n  pair' \\<in> S'", "have \n          iii: \"(fst pair') \\<in> S\""], ["proof (prove)\nusing this:\n  S' \\<subseteq> instances S\n  pair' \\<in> S'\n\ngoal (1 subgoal):\n 1. fst pair' \\<in> S", "unfolding instances_def [of S]"], ["proof (prove)\nusing this:\n  S' \\<subseteq> {x. \\<exists>C \\<sigma>.\n                        C \\<in> S \\<and>\n                        ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<and>\n                        x = (C, \\<sigma>)}\n  pair' \\<in> S'\n\ngoal (1 subgoal):\n 1. fst pair' \\<in> S", "by fastforce"], ["proof (state)\nthis:\n  fst pair' \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from \\<open>?P pair'\\<close> and i ii iii"], ["proof (chain)\npicking this:\n  \\<forall>C \\<sigma>.\n     fst pair' = C \\<longrightarrow>\n     \\<sigma> = snd pair' \\<longrightarrow>\n     C \\<in> S \\<longrightarrow>\n     ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n     all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n      (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n     validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n      (subst_cl (cl_ecl C) \\<sigma>)\n  all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair'))\n   (\\<lambda>t. trm_rep t S)\n  ground_clause (subst_cl (cl_ecl (fst pair')) (snd pair'))\n  fst pair' \\<in> S", "have \"validate_ground_clause ?I \n          (subst_cl (cl_ecl (fst pair')) (snd pair'))\""], ["proof (prove)\nusing this:\n  \\<forall>C \\<sigma>.\n     fst pair' = C \\<longrightarrow>\n     \\<sigma> = snd pair' \\<longrightarrow>\n     C \\<in> S \\<longrightarrow>\n     ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n     all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n      (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n     validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n      (subst_cl (cl_ecl C) \\<sigma>)\n  all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair'))\n   (\\<lambda>t. trm_rep t S)\n  ground_clause (subst_cl (cl_ecl (fst pair')) (snd pair'))\n  fst pair' \\<in> S\n\ngoal (1 subgoal):\n 1. validate_ground_clause (int_clset S)\n     (subst_cl (cl_ecl (fst pair')) (snd pair'))", "unfolding int_clset_def"], ["proof (prove)\nusing this:\n  \\<forall>C \\<sigma>.\n     fst pair' = C \\<longrightarrow>\n     \\<sigma> = snd pair' \\<longrightarrow>\n     C \\<in> S \\<longrightarrow>\n     ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n     all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n      (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n     validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n      (subst_cl (cl_ecl C) \\<sigma>)\n  all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair'))\n   (\\<lambda>t. trm_rep t S)\n  ground_clause (subst_cl (cl_ecl (fst pair')) (snd pair'))\n  fst pair' \\<in> S\n\ngoal (1 subgoal):\n 1. validate_ground_clause (same_values (\\<lambda>x. trm_rep x S))\n     (subst_cl (cl_ecl (fst pair')) (snd pair'))", "by blast"], ["proof (state)\nthis:\n  validate_ground_clause (int_clset S)\n   (subst_cl (cl_ecl (fst pair')) (snd pair'))\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from this and \\<open>x = (subst_cl (cl_ecl (fst pair')) (snd pair'))\\<close> \n          and \\<open>\\<not>validate_clause ?I x\\<close>"], ["proof (chain)\npicking this:\n  validate_ground_clause (int_clset S)\n   (subst_cl (cl_ecl (fst pair')) (snd pair'))\n  x = subst_cl (cl_ecl (fst pair')) (snd pair')\n  \\<not> validate_clause (int_clset S) x", "show False"], ["proof (prove)\nusing this:\n  validate_ground_clause (int_clset S)\n   (subst_cl (cl_ecl (fst pair')) (snd pair'))\n  x = subst_cl (cl_ecl (fst pair')) (snd pair')\n  \\<not> validate_clause (int_clset S) x\n\ngoal (1 subgoal):\n 1. False", "by (metis ii substs_preserve_ground_clause validate_clause.simps)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  validate_clause_set (int_clset S) (clset_instances S')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L t s.\n               L \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L C \\<sigma> \\<longrightarrow>\n               orient_lit_inst L t s neg \\<sigma> \\<longrightarrow>\n               trm_rep (t \\<lhd> \\<sigma>) S =\n               t \\<lhd> \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> \\<noteq>\n               s \\<lhd> \\<sigma>) \\<Longrightarrow>\n    False", "from this and \\<open>fo_interpretation ?I\\<close> and \n        \\<open>(set_entails_clause (clset_instances S') (cl_ecl R))\\<close>"], ["proof (chain)\npicking this:\n  validate_clause_set (int_clset S) (clset_instances S')\n  fo_interpretation (int_clset S)\n  set_entails_clause (clset_instances S') (cl_ecl R)", "have \"validate_clause ?I (cl_ecl R)\""], ["proof (prove)\nusing this:\n  validate_clause_set (int_clset S) (clset_instances S')\n  fo_interpretation (int_clset S)\n  set_entails_clause (clset_instances S') (cl_ecl R)\n\ngoal (1 subgoal):\n 1. validate_clause (int_clset S) (cl_ecl R)", "unfolding set_entails_clause_def"], ["proof (prove)\nusing this:\n  validate_clause_set (int_clset S) (clset_instances S')\n  fo_interpretation (int_clset S)\n  \\<forall>I.\n     fo_interpretation I \\<longrightarrow>\n     validate_clause_set I (clset_instances S') \\<longrightarrow>\n     validate_clause I (cl_ecl R)\n\ngoal (1 subgoal):\n 1. validate_clause (int_clset S) (cl_ecl R)", "by blast"], ["proof (state)\nthis:\n  validate_clause (int_clset S) (cl_ecl R)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L t s.\n               L \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L C \\<sigma> \\<longrightarrow>\n               orient_lit_inst L t s neg \\<sigma> \\<longrightarrow>\n               trm_rep (t \\<lhd> \\<sigma>) S =\n               t \\<lhd> \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> \\<noteq>\n               s \\<lhd> \\<sigma>) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  validate_clause (int_clset S) (cl_ecl R)", "have \"validate_ground_clause ?I (cl_ecl R)\""], ["proof (prove)\nusing this:\n  validate_clause (int_clset S) (cl_ecl R)\n\ngoal (1 subgoal):\n 1. validate_ground_clause (int_clset S) (cl_ecl R)", "by (metis \\<open>R = Ecl Cl_R nt_R\\<close> \\<open>ground_clause Cl_R\\<close> \n            cl_ecl.simps substs_preserve_ground_clause validate_clause.simps)"], ["proof (state)\nthis:\n  validate_ground_clause (int_clset S) (cl_ecl R)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L t s.\n               L \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L C \\<sigma> \\<longrightarrow>\n               orient_lit_inst L t s neg \\<sigma> \\<longrightarrow>\n               trm_rep (t \\<lhd> \\<sigma>) S =\n               t \\<lhd> \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> \\<noteq>\n               s \\<lhd> \\<sigma>) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  validate_ground_clause (int_clset S) (cl_ecl R)", "obtain L' where \"L' \\<in> (cl_ecl R)\" and \"validate_ground_lit ?I L'\""], ["proof (prove)\nusing this:\n  validate_ground_clause (int_clset S) (cl_ecl R)\n\ngoal (1 subgoal):\n 1. (\\<And>L'.\n        \\<lbrakk>L' \\<in> cl_ecl R;\n         validate_ground_lit (int_clset S) L'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using validate_ground_clause.simps"], ["proof (prove)\nusing this:\n  validate_ground_clause (int_clset S) (cl_ecl R)\n  validate_ground_clause ?I ?C =\n  (\\<exists>L. L \\<in> ?C \\<and> validate_ground_lit ?I L)\n\ngoal (1 subgoal):\n 1. (\\<And>L'.\n        \\<lbrakk>L' \\<in> cl_ecl R;\n         validate_ground_lit (int_clset S) L'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  L' \\<in> cl_ecl R\n  validate_ground_lit (int_clset S) L'\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L t s.\n               L \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L C \\<sigma> \\<longrightarrow>\n               orient_lit_inst L t s neg \\<sigma> \\<longrightarrow>\n               trm_rep (t \\<lhd> \\<sigma>) S =\n               t \\<lhd> \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> \\<noteq>\n               s \\<lhd> \\<sigma>) \\<Longrightarrow>\n    False", "from \\<open>L' \\<in> (cl_ecl R)\\<close> and \\<open>R = Ecl Cl_R nt_R\\<close> and\n          \\<open>Cl_R = (subst_cl ((cl_ecl C) - { L }) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  L' \\<in> cl_ecl R\n  R = Ecl Cl_R nt_R\n  Cl_R = subst_cl (cl_ecl C - {L}) \\<sigma>", "obtain L'' where \"L'' \\<in> cl_ecl C\" and \"L' = subst_lit L'' \\<sigma>\""], ["proof (prove)\nusing this:\n  L' \\<in> cl_ecl R\n  R = Ecl Cl_R nt_R\n  Cl_R = subst_cl (cl_ecl C - {L}) \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>L''.\n        \\<lbrakk>L'' \\<in> cl_ecl C; L' = subst_lit L'' \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  L'' \\<in> cl_ecl C\n  L' = subst_lit L'' \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L t s.\n               L \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L C \\<sigma> \\<longrightarrow>\n               orient_lit_inst L t s neg \\<sigma> \\<longrightarrow>\n               trm_rep (t \\<lhd> \\<sigma>) S =\n               t \\<lhd> \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> \\<noteq>\n               s \\<lhd> \\<sigma>) \\<Longrightarrow>\n    False", "from \\<open>L'' \\<in> cl_ecl C\\<close> and \\<open>L' = subst_lit L'' \\<sigma>\\<close>and \\<open>validate_ground_lit ?I L'\\<close>"], ["proof (chain)\npicking this:\n  L'' \\<in> cl_ecl C\n  L' = subst_lit L'' \\<sigma>\n  validate_ground_lit (int_clset S) L'", "have \"validate_ground_clause ?I (subst_cl (cl_ecl C) \\<sigma>)\""], ["proof (prove)\nusing this:\n  L'' \\<in> cl_ecl C\n  L' = subst_lit L'' \\<sigma>\n  validate_ground_lit (int_clset S) L'\n\ngoal (1 subgoal):\n 1. validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)", "by (metis (mono_tags, lifting) subst_cl.simps mem_Collect_eq \n              validate_ground_clause.simps)"], ["proof (state)\nthis:\n  validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L t s.\n               L \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L C \\<sigma> \\<longrightarrow>\n               orient_lit_inst L t s neg \\<sigma> \\<longrightarrow>\n               trm_rep (t \\<lhd> \\<sigma>) S =\n               t \\<lhd> \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> \\<noteq>\n               s \\<lhd> \\<sigma>) \\<Longrightarrow>\n    False", "from this and cm"], ["proof (chain)\npicking this:\n  validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)", "show False"], ["proof (prove)\nusing this:\n  validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. False", "unfolding int_clset_def"], ["proof (prove)\nusing this:\n  validate_ground_clause (same_values (\\<lambda>x. trm_rep x S))\n   (subst_cl (cl_ecl C) \\<sigma>)\n  \\<not> validate_ground_clause (same_values (\\<lambda>x. trm_rep x S))\n          (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>L t s.\n     L \\<in> cl_ecl C \\<longrightarrow>\n     eligible_literal L C \\<sigma> \\<longrightarrow>\n     orient_lit_inst L t s neg \\<sigma> \\<longrightarrow>\n     trm_rep (t \\<lhd> \\<sigma>) S = t \\<lhd> \\<sigma> \\<longrightarrow>\n     t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "text \\<open>Third, we prove that the clause contains no pair of equations with the same left-hand side\nand equivalent right-hand sides (otherwise the factorization rule applies and a smaller false clause\nis derived).\\<close>"], ["proof (state)\nthis:\n  \\<forall>L t s.\n     L \\<in> cl_ecl C \\<longrightarrow>\n     eligible_literal L C \\<sigma> \\<longrightarrow>\n     orient_lit_inst L t s neg \\<sigma> \\<longrightarrow>\n     trm_rep (t \\<lhd> \\<sigma>) S = t \\<lhd> \\<sigma> \\<longrightarrow>\n     t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "let ?no_fact = \"\\<forall>L1 L2 t s u v. (L1 \\<in> (cl_ecl C)) \\<longrightarrow> (eligible_literal L1 C \\<sigma>) \n       \\<longrightarrow> (L2 \\<in> (cl_ecl C) - { L1 }) \\<longrightarrow> (orient_lit_inst L1 t s pos \\<sigma>) \n       \\<longrightarrow> (orient_lit_inst L2 u v pos \\<sigma>) \\<longrightarrow> (subst t \\<sigma>) = (subst u \\<sigma>)\n       \\<longrightarrow> (\\<not> (proper_subterm_red t S \\<sigma>))\n       \\<longrightarrow> (trm_rep ((subst s) \\<sigma>) S) \\<noteq>  (trm_rep ((subst v) \\<sigma>) S)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "have ?no_fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>L1 L2 t s u v.\n       L1 \\<in> cl_ecl C \\<longrightarrow>\n       eligible_literal L1 C \\<sigma> \\<longrightarrow>\n       L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n       orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n       orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n       t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n       \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n       trm_rep (s \\<lhd> \\<sigma>) S \\<noteq> trm_rep (v \\<lhd> \\<sigma>) S", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "assume \"\\<not> ?no_fact\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>L1 L2 t s u v.\n             L1 \\<in> cl_ecl C \\<longrightarrow>\n             eligible_literal L1 C \\<sigma> \\<longrightarrow>\n             L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n             orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n             orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n             t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n             \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n             trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n             trm_rep (v \\<lhd> \\<sigma>) S)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>L1 L2 t s u v.\n             L1 \\<in> cl_ecl C \\<longrightarrow>\n             eligible_literal L1 C \\<sigma> \\<longrightarrow>\n             L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n             orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n             orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n             t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n             \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n             trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n             trm_rep (v \\<lhd> \\<sigma>) S)", "obtain L1 L2 t s u v where l1: \"L1 \\<in> (cl_ecl C)\" and l2: \"L2 \\<in> (cl_ecl C) - { L1 }\" \n       and e1: \"(eligible_literal L1 C \\<sigma>)\" and o1: \"(orient_lit_inst L1 t s pos \\<sigma>)\" \n       and o2: \"(orient_lit_inst L2 u v pos \\<sigma>)\" and e: \"(subst t \\<sigma>) = (subst u \\<sigma>)\"\n       and \"(\\<not> (proper_subterm_red t S \\<sigma>))\"\n       and i: \"(trm_rep ((subst s) \\<sigma>) S) =  (trm_rep ((subst v) \\<sigma>) S)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>L1 L2 t s u v.\n             L1 \\<in> cl_ecl C \\<longrightarrow>\n             eligible_literal L1 C \\<sigma> \\<longrightarrow>\n             L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n             orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n             orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n             t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n             \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n             trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n             trm_rep (v \\<lhd> \\<sigma>) S)\n\ngoal (1 subgoal):\n 1. (\\<And>L1 L2 t s u v.\n        \\<lbrakk>L1 \\<in> cl_ecl C; L2 \\<in> cl_ecl C - {L1};\n         eligible_literal L1 C \\<sigma>;\n         orient_lit_inst L1 t s pos \\<sigma>;\n         orient_lit_inst L2 u v pos \\<sigma>;\n         t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>;\n         \\<not> proper_subterm_red t S \\<sigma>;\n         trm_rep (s \\<lhd> \\<sigma>) S =\n         trm_rep (v \\<lhd> \\<sigma>) S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  L1 \\<in> cl_ecl C\n  L2 \\<in> cl_ecl C - {L1}\n  eligible_literal L1 C \\<sigma>\n  orient_lit_inst L1 t s pos \\<sigma>\n  orient_lit_inst L2 u v pos \\<sigma>\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n  \\<not> proper_subterm_red t S \\<sigma>\n  trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "from e"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>", "have t: \"ck_unifier t u \\<sigma> Ground\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. ck_unifier t u \\<sigma> Ground", "unfolding ck_unifier_def Unifier_def"], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. if Ground = FirstOrder then MGU \\<sigma> t u\n    else t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>", "using \"inferences.distinct\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n  Ground \\<noteq> FirstOrder\n  FirstOrder \\<noteq> Ground\n\ngoal (1 subgoal):\n 1. if Ground = FirstOrder then MGU \\<sigma> t u\n    else t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>", "by metis"], ["proof (state)\nthis:\n  ck_unifier t u \\<sigma> Ground\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "from \\<open>L1 \\<in> (cl_ecl C)\\<close> o1 \\<open>\\<not>(validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>))\\<close>"], ["proof (chain)\npicking this:\n  L1 \\<in> cl_ecl C\n  orient_lit_inst L1 t s pos \\<sigma>\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)", "have \"trm_rep (subst t \\<sigma>) S \\<noteq> trm_rep (subst s \\<sigma>) S\""], ["proof (prove)\nusing this:\n  L1 \\<in> cl_ecl C\n  orient_lit_inst L1 t s pos \\<sigma>\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> trm_rep (s \\<lhd> \\<sigma>) S", "using no_valid_literal"], ["proof (prove)\nusing this:\n  L1 \\<in> cl_ecl C\n  orient_lit_inst L1 t s pos \\<sigma>\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n  \\<lbrakk>?L \\<in> ?C; orient_lit_inst ?L ?t ?s pos ?\\<sigma>;\n   \\<not> validate_ground_clause (int_clset ?S)\n           (subst_cl ?C ?\\<sigma>)\\<rbrakk>\n  \\<Longrightarrow> trm_rep (?t \\<lhd> ?\\<sigma>) ?S \\<noteq>\n                    trm_rep (?s \\<lhd> ?\\<sigma>) ?S\n\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> trm_rep (s \\<lhd> \\<sigma>) S", "by metis"], ["proof (state)\nthis:\n  trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> trm_rep (s \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> trm_rep (s \\<lhd> \\<sigma>) S", "have \"subst t \\<sigma> \\<noteq> subst s \\<sigma>\""], ["proof (prove)\nusing this:\n  trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> trm_rep (s \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>", "by metis"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "from \\<open>L2 \\<in> (cl_ecl C) - { L1 }\\<close>"], ["proof (chain)\npicking this:\n  L2 \\<in> cl_ecl C - {L1}", "have \"L2 \\<in> (cl_ecl C)\""], ["proof (prove)\nusing this:\n  L2 \\<in> cl_ecl C - {L1}\n\ngoal (1 subgoal):\n 1. L2 \\<in> cl_ecl C", "by auto"], ["proof (state)\nthis:\n  L2 \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "from this o2 \\<open>\\<not>(validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>))\\<close>"], ["proof (chain)\npicking this:\n  L2 \\<in> cl_ecl C\n  orient_lit_inst L2 u v pos \\<sigma>\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)", "have \"trm_rep (subst u \\<sigma>) S \\<noteq> trm_rep (subst v \\<sigma>) S\""], ["proof (prove)\nusing this:\n  L2 \\<in> cl_ecl C\n  orient_lit_inst L2 u v pos \\<sigma>\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. trm_rep (u \\<lhd> \\<sigma>) S \\<noteq> trm_rep (v \\<lhd> \\<sigma>) S", "using no_valid_literal"], ["proof (prove)\nusing this:\n  L2 \\<in> cl_ecl C\n  orient_lit_inst L2 u v pos \\<sigma>\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n  \\<lbrakk>?L \\<in> ?C; orient_lit_inst ?L ?t ?s pos ?\\<sigma>;\n   \\<not> validate_ground_clause (int_clset ?S)\n           (subst_cl ?C ?\\<sigma>)\\<rbrakk>\n  \\<Longrightarrow> trm_rep (?t \\<lhd> ?\\<sigma>) ?S \\<noteq>\n                    trm_rep (?s \\<lhd> ?\\<sigma>) ?S\n\ngoal (1 subgoal):\n 1. trm_rep (u \\<lhd> \\<sigma>) S \\<noteq> trm_rep (v \\<lhd> \\<sigma>) S", "by metis"], ["proof (state)\nthis:\n  trm_rep (u \\<lhd> \\<sigma>) S \\<noteq> trm_rep (v \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "from this and e"], ["proof (chain)\npicking this:\n  trm_rep (u \\<lhd> \\<sigma>) S \\<noteq> trm_rep (v \\<lhd> \\<sigma>) S\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>", "have \"subst t \\<sigma> \\<noteq> subst v \\<sigma>\""], ["proof (prove)\nusing this:\n  trm_rep (u \\<lhd> \\<sigma>) S \\<noteq> trm_rep (v \\<lhd> \\<sigma>) S\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>", "by metis"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "obtain R Cl_R nt_R L' where \n            ntr: \"nt_R = (dom_trms Cl_R (subst_set ((trms_ecl C) \\<union> (proper_subterms_of t)) \\<sigma>))\"\n            and r: \"R = Ecl Cl_R nt_R\" \n            and clr: \"Cl_R = (subst_cl ( ((cl_ecl C) - { L2 }) \\<union> { L' } ) \\<sigma>)\"\n            and l': \"L' = Neg (Eq s v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>nt_R Cl_R R L'.\n        \\<lbrakk>nt_R =\n                 dom_trms Cl_R\n                  (subst_set (trms_ecl C \\<union> proper_subterms_of t)\n                    \\<sigma>);\n         R = Ecl Cl_R nt_R;\n         Cl_R = subst_cl (cl_ecl C - {L2} \\<union> {L'}) \\<sigma>;\n         L' = Neg (Eq s v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  nt_R =\n  dom_trms Cl_R\n   (subst_set (trms_ecl C \\<union> proper_subterms_of t) \\<sigma>)\n  R = Ecl Cl_R nt_R\n  Cl_R = subst_cl (cl_ecl C - {L2} \\<union> {L'}) \\<sigma>\n  L' = Neg (Eq s v)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "from ntr r l' clr l1 l2 o1 o2 e1 t\n        \\<open>subst t \\<sigma> \\<noteq> subst s \\<sigma>\\<close> \\<open>subst t \\<sigma> \\<noteq> subst v \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  nt_R =\n  dom_trms Cl_R\n   (subst_set (trms_ecl C \\<union> proper_subterms_of t) \\<sigma>)\n  R = Ecl Cl_R nt_R\n  L' = Neg (Eq s v)\n  Cl_R = subst_cl (cl_ecl C - {L2} \\<union> {L'}) \\<sigma>\n  L1 \\<in> cl_ecl C\n  L2 \\<in> cl_ecl C - {L1}\n  orient_lit_inst L1 t s pos \\<sigma>\n  orient_lit_inst L2 u v pos \\<sigma>\n  eligible_literal L1 C \\<sigma>\n  ck_unifier t u \\<sigma> Ground\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n  t \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>", "have \"factorization C R \\<sigma> Ground (((cl_ecl C) - { L2 }) \\<union> { L' } )\""], ["proof (prove)\nusing this:\n  nt_R =\n  dom_trms Cl_R\n   (subst_set (trms_ecl C \\<union> proper_subterms_of t) \\<sigma>)\n  R = Ecl Cl_R nt_R\n  L' = Neg (Eq s v)\n  Cl_R = subst_cl (cl_ecl C - {L2} \\<union> {L'}) \\<sigma>\n  L1 \\<in> cl_ecl C\n  L2 \\<in> cl_ecl C - {L1}\n  orient_lit_inst L1 t s pos \\<sigma>\n  orient_lit_inst L2 u v pos \\<sigma>\n  eligible_literal L1 C \\<sigma>\n  ck_unifier t u \\<sigma> Ground\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n  t \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. factorization C R \\<sigma> Ground (cl_ecl C - {L2} \\<union> {L'})", "unfolding factorization_def get_trms_def"], ["proof (prove)\nusing this:\n  nt_R =\n  dom_trms Cl_R\n   (subst_set (trms_ecl C \\<union> proper_subterms_of t) \\<sigma>)\n  R = Ecl Cl_R nt_R\n  L' = Neg (Eq s v)\n  Cl_R = subst_cl (cl_ecl C - {L2} \\<union> {L'}) \\<sigma>\n  L1 \\<in> cl_ecl C\n  L2 \\<in> cl_ecl C - {L1}\n  orient_lit_inst L1 t s pos \\<sigma>\n  orient_lit_inst L2 u v pos \\<sigma>\n  eligible_literal L1 C \\<sigma>\n  ck_unifier t u \\<sigma> Ground\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n  t \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>L1 L2a L'a t s u v Cl_P Cl_C trms_C.\n       eligible_literal L1 C \\<sigma> \\<and>\n       L1 \\<in> cl_ecl C \\<and>\n       L2a \\<in> cl_ecl C - {L1} \\<and>\n       Cl_C = cl_ecl R \\<and>\n       Cl_P = cl_ecl C \\<and>\n       orient_lit_inst L1 t s pos \\<sigma> \\<and>\n       orient_lit_inst L2a u v pos \\<sigma> \\<and>\n       t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma> \\<and>\n       t \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma> \\<and>\n       ck_unifier t u \\<sigma> Ground \\<and>\n       L'a = Neg (Eq s v) \\<and>\n       (R = Ecl Cl_C trms_C \\<and>\n        trms_C =\n        (if Ground = FirstOrder\n         then filter_trms Cl_C\n               (dom_trms Cl_C\n                 (subst_set (trms_ecl C \\<union> proper_subterms_of t)\n                   \\<sigma>))\n         else dom_trms Cl_C\n               (subst_set (trms_ecl C \\<union> proper_subterms_of t)\n                 \\<sigma>))) \\<and>\n       Cl_C = subst_cl (cl_ecl C - {L2} \\<union> {L'}) \\<sigma> \\<and>\n       cl_ecl C - {L2} \\<union> {L'} = Cl_P - {L2a} \\<union> {L'a}", "using inferences.distinct"], ["proof (prove)\nusing this:\n  nt_R =\n  dom_trms Cl_R\n   (subst_set (trms_ecl C \\<union> proper_subterms_of t) \\<sigma>)\n  R = Ecl Cl_R nt_R\n  L' = Neg (Eq s v)\n  Cl_R = subst_cl (cl_ecl C - {L2} \\<union> {L'}) \\<sigma>\n  L1 \\<in> cl_ecl C\n  L2 \\<in> cl_ecl C - {L1}\n  orient_lit_inst L1 t s pos \\<sigma>\n  orient_lit_inst L2 u v pos \\<sigma>\n  eligible_literal L1 C \\<sigma>\n  ck_unifier t u \\<sigma> Ground\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n  t \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma>\n  Ground \\<noteq> FirstOrder\n  FirstOrder \\<noteq> Ground\n\ngoal (1 subgoal):\n 1. \\<exists>L1 L2a L'a t s u v Cl_P Cl_C trms_C.\n       eligible_literal L1 C \\<sigma> \\<and>\n       L1 \\<in> cl_ecl C \\<and>\n       L2a \\<in> cl_ecl C - {L1} \\<and>\n       Cl_C = cl_ecl R \\<and>\n       Cl_P = cl_ecl C \\<and>\n       orient_lit_inst L1 t s pos \\<sigma> \\<and>\n       orient_lit_inst L2a u v pos \\<sigma> \\<and>\n       t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma> \\<and>\n       t \\<lhd> \\<sigma> \\<noteq> v \\<lhd> \\<sigma> \\<and>\n       ck_unifier t u \\<sigma> Ground \\<and>\n       L'a = Neg (Eq s v) \\<and>\n       (R = Ecl Cl_C trms_C \\<and>\n        trms_C =\n        (if Ground = FirstOrder\n         then filter_trms Cl_C\n               (dom_trms Cl_C\n                 (subst_set (trms_ecl C \\<union> proper_subterms_of t)\n                   \\<sigma>))\n         else dom_trms Cl_C\n               (subst_set (trms_ecl C \\<union> proper_subterms_of t)\n                 \\<sigma>))) \\<and>\n       Cl_C = subst_cl (cl_ecl C - {L2} \\<union> {L'}) \\<sigma> \\<and>\n       cl_ecl C - {L2} \\<union> {L'} = Cl_P - {L2a} \\<union> {L'a}", "by (metis cl_ecl.simps)"], ["proof (state)\nthis:\n  factorization C R \\<sigma> Ground (cl_ecl C - {L2} \\<union> {L'})\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "from l2"], ["proof (chain)\npicking this:\n  L2 \\<in> cl_ecl C - {L1}", "have \"(subst_lit L2 \\<sigma>) \\<in> (subst_cl (cl_ecl C) \\<sigma>)\""], ["proof (prove)\nusing this:\n  L2 \\<in> cl_ecl C - {L1}\n\ngoal (1 subgoal):\n 1. subst_lit L2 \\<sigma> \\<in> subst_cl (cl_ecl C) \\<sigma>", "by auto"], ["proof (state)\nthis:\n  subst_lit L2 \\<sigma> \\<in> subst_cl (cl_ecl C) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "from this and \\<open>ground_clause (subst_cl (cl_ecl C) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  subst_lit L2 \\<sigma> \\<in> subst_cl (cl_ecl C) \\<sigma>\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)", "have \"vars_of_lit (subst_lit L2 \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  subst_lit L2 \\<sigma> \\<in> subst_cl (cl_ecl C) \\<sigma>\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. vars_of_lit (subst_lit L2 \\<sigma>) = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_lit (subst_lit L2 \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "from this and o2"], ["proof (chain)\npicking this:\n  vars_of_lit (subst_lit L2 \\<sigma>) = {}\n  orient_lit_inst L2 u v pos \\<sigma>", "have \"vars_of (subst v \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L2 \\<sigma>) = {}\n  orient_lit_inst L2 u v pos \\<sigma>\n\ngoal (1 subgoal):\n 1. vars_of (v \\<lhd> \\<sigma>) = {}", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L2 \\<sigma>) = {}\n  (L2 = Pos (Eq u v) \\<or> L2 = Pos (Eq v u)) \\<and>\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  pos = pos \\<or>\n  (L2 = Neg (Eq u v) \\<or> L2 = Neg (Eq v u)) \\<and>\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and> pos = neg\n\ngoal (1 subgoal):\n 1. vars_of (v \\<lhd> \\<sigma>) = {}", "using vars_of_lit.simps vars_of_eq.simps"], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L2 \\<sigma>) = {}\n  (L2 = Pos (Eq u v) \\<or> L2 = Pos (Eq v u)) \\<and>\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  pos = pos \\<or>\n  (L2 = Neg (Eq u v) \\<or> L2 = Neg (Eq v u)) \\<and>\n  (u \\<lhd> \\<sigma>, v \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and> pos = neg\n  vars_of_lit (Pos ?e) = vars_of_eq ?e\n  vars_of_lit (Neg ?e) = vars_of_eq ?e\n  vars_of_eq (Eq ?t ?s) = vars_of ?t \\<union> vars_of ?s\n\ngoal (1 subgoal):\n 1. vars_of (v \\<lhd> \\<sigma>) = {}", "by force"], ["proof (state)\nthis:\n  vars_of (v \\<lhd> \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "from l1"], ["proof (chain)\npicking this:\n  L1 \\<in> cl_ecl C", "have \"(subst_lit L1 \\<sigma>) \\<in> (subst_cl (cl_ecl C) \\<sigma>)\""], ["proof (prove)\nusing this:\n  L1 \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. subst_lit L1 \\<sigma> \\<in> subst_cl (cl_ecl C) \\<sigma>", "by auto"], ["proof (state)\nthis:\n  subst_lit L1 \\<sigma> \\<in> subst_cl (cl_ecl C) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "from this and \\<open>ground_clause (subst_cl (cl_ecl C) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  subst_lit L1 \\<sigma> \\<in> subst_cl (cl_ecl C) \\<sigma>\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)", "have \"vars_of_lit (subst_lit L1 \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  subst_lit L1 \\<sigma> \\<in> subst_cl (cl_ecl C) \\<sigma>\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. vars_of_lit (subst_lit L1 \\<sigma>) = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "from this and o1"], ["proof (chain)\npicking this:\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}\n  orient_lit_inst L1 t s pos \\<sigma>", "have \"vars_of (subst s \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}\n  orient_lit_inst L1 t s pos \\<sigma>\n\ngoal (1 subgoal):\n 1. vars_of (s \\<lhd> \\<sigma>) = {}", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}\n  (L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  pos = pos \\<or>\n  (L1 = Neg (Eq t s) \\<or> L1 = Neg (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and> pos = neg\n\ngoal (1 subgoal):\n 1. vars_of (s \\<lhd> \\<sigma>) = {}", "using vars_of_lit.simps vars_of_eq.simps"], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit L1 \\<sigma>) = {}\n  (L1 = Pos (Eq t s) \\<or> L1 = Pos (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  pos = pos \\<or>\n  (L1 = Neg (Eq t s) \\<or> L1 = Neg (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and> pos = neg\n  vars_of_lit (Pos ?e) = vars_of_eq ?e\n  vars_of_lit (Neg ?e) = vars_of_eq ?e\n  vars_of_eq (Eq ?t ?s) = vars_of ?t \\<union> vars_of ?s\n\ngoal (1 subgoal):\n 1. vars_of (s \\<lhd> \\<sigma>) = {}", "by force"], ["proof (state)\nthis:\n  vars_of (s \\<lhd> \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "from \\<open>vars_of (subst v \\<sigma>) = {}\\<close> and \\<open>vars_of (subst s \\<sigma>) = {}\\<close>\n          and l'"], ["proof (chain)\npicking this:\n  vars_of (v \\<lhd> \\<sigma>) = {}\n  vars_of (s \\<lhd> \\<sigma>) = {}\n  L' = Neg (Eq s v)", "have \"vars_of_lit (subst_lit L' \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  vars_of (v \\<lhd> \\<sigma>) = {}\n  vars_of (s \\<lhd> \\<sigma>) = {}\n  L' = Neg (Eq s v)\n\ngoal (1 subgoal):\n 1. vars_of_lit (subst_lit L' \\<sigma>) = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_lit (subst_lit L' \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "from \\<open>C \\<in> S\\<close> and \\<open>factorization C R \\<sigma> Ground (((cl_ecl C) - { L2 }) \\<union> { L' } )\\<close>"], ["proof (chain)\npicking this:\n  C \\<in> S\n  factorization C R \\<sigma> Ground (cl_ecl C - {L2} \\<union> {L'})", "have \"derivable R { C } S \\<sigma> Ground (((cl_ecl C) - { L2 }) \\<union> { L' } )\""], ["proof (prove)\nusing this:\n  C \\<in> S\n  factorization C R \\<sigma> Ground (cl_ecl C - {L2} \\<union> {L'})\n\ngoal (1 subgoal):\n 1. derivable R {C} S \\<sigma> Ground (cl_ecl C - {L2} \\<union> {L'})", "unfolding derivable_def"], ["proof (prove)\nusing this:\n  C \\<in> S\n  factorization C R \\<sigma> Ground (cl_ecl C - {L2} \\<union> {L'})\n\ngoal (1 subgoal):\n 1. (\\<exists>P1 P2.\n        P1 \\<in> S \\<and>\n        P2 \\<in> S \\<and>\n        {C} = {P1, P2} \\<and>\n        superposition P1 P2 R \\<sigma> Ground\n         (cl_ecl C - {L2} \\<union> {L'})) \\<or>\n    (\\<exists>P1.\n        P1 \\<in> S \\<and>\n        {C} = {P1} \\<and>\n        factorization P1 R \\<sigma> Ground\n         (cl_ecl C - {L2} \\<union> {L'})) \\<or>\n    (\\<exists>P1.\n        P1 \\<in> S \\<and>\n        {C} = {P1} \\<and>\n        reflexion P1 R \\<sigma> Ground (cl_ecl C - {L2} \\<union> {L'}))", "by auto"], ["proof (state)\nthis:\n  derivable R {C} S \\<sigma> Ground (cl_ecl C - {L2} \\<union> {L'})\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "have \"ground_clause Cl_R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ground_clause Cl_R", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ground_clause Cl_R \\<Longrightarrow> False", "assume \"\\<not>ground_clause Cl_R\""], ["proof (state)\nthis:\n  \\<not> ground_clause Cl_R\n\ngoal (1 subgoal):\n 1. \\<not> ground_clause Cl_R \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> ground_clause Cl_R", "have \"vars_of_cl Cl_R \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<not> ground_clause Cl_R\n\ngoal (1 subgoal):\n 1. vars_of_cl Cl_R \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  vars_of_cl Cl_R \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> ground_clause Cl_R \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  vars_of_cl Cl_R \\<noteq> {}", "obtain M where \"M \\<in> Cl_R\" and \"vars_of_lit M \\<noteq> {}\""], ["proof (prove)\nusing this:\n  vars_of_cl Cl_R \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>M \\<in> Cl_R; vars_of_lit M \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M \\<in> Cl_R\n  vars_of_lit M \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> ground_clause Cl_R \\<Longrightarrow> False", "from \\<open>M \\<in> Cl_R\\<close> and clr"], ["proof (chain)\npicking this:\n  M \\<in> Cl_R\n  Cl_R = subst_cl (cl_ecl C - {L2} \\<union> {L'}) \\<sigma>", "obtain M' where \"M = (subst_lit M' \\<sigma>)\" \n          and \"M' \\<in>((cl_ecl C) - { L2, L1 }) \\<union> { L', L1 } \""], ["proof (prove)\nusing this:\n  M \\<in> Cl_R\n  Cl_R = subst_cl (cl_ecl C - {L2} \\<union> {L'}) \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        \\<lbrakk>M = subst_lit M' \\<sigma>;\n         M' \\<in> cl_ecl C - {L2, L1} \\<union> {L', L1}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M = subst_lit M' \\<sigma>\n  M' \\<in> cl_ecl C - {L2, L1} \\<union> {L', L1}\n\ngoal (1 subgoal):\n 1. \\<not> ground_clause Cl_R \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "assume \"M' = L'\""], ["proof (state)\nthis:\n  M' = L'\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "from this and \\<open>vars_of_lit (subst_lit L' \\<sigma>) = {}\\<close> and \\<open>vars_of_lit M \\<noteq> {}\\<close>\n              and \\<open>M = (subst_lit M' \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  M' = L'\n  vars_of_lit (subst_lit L' \\<sigma>) = {}\n  vars_of_lit M \\<noteq> {}\n  M = subst_lit M' \\<sigma>", "show False"], ["proof (prove)\nusing this:\n  M' = L'\n  vars_of_lit (subst_lit L' \\<sigma>) = {}\n  vars_of_lit M \\<noteq> {}\n  M = subst_lit M' \\<sigma>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. M' \\<noteq> L' \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M' \\<noteq> L' \\<Longrightarrow> False", "assume \"M' \\<noteq> L'\""], ["proof (state)\nthis:\n  M' \\<noteq> L'\n\ngoal (1 subgoal):\n 1. M' \\<noteq> L' \\<Longrightarrow> False", "from this and l1 and \\<open>M' \\<in>((cl_ecl C) - { L2, L1 }) \\<union> { L', L1 }\\<close>"], ["proof (chain)\npicking this:\n  M' \\<noteq> L'\n  L1 \\<in> cl_ecl C\n  M' \\<in> cl_ecl C - {L2, L1} \\<union> {L', L1}", "have \"M' \\<in> (cl_ecl C)\""], ["proof (prove)\nusing this:\n  M' \\<noteq> L'\n  L1 \\<in> cl_ecl C\n  M' \\<in> cl_ecl C - {L2, L1} \\<union> {L', L1}\n\ngoal (1 subgoal):\n 1. M' \\<in> cl_ecl C", "by auto"], ["proof (state)\nthis:\n  M' \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. M' \\<noteq> L' \\<Longrightarrow> False", "from this and \\<open>ground_clause (subst_cl (cl_ecl C) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  M' \\<in> cl_ecl C\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)", "have \n              \"vars_of_lit (subst_lit M' \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  M' \\<in> cl_ecl C\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. vars_of_lit (subst_lit M' \\<sigma>) = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_lit (subst_lit M' \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. M' \\<noteq> L' \\<Longrightarrow> False", "from this and \\<open>M = (subst_lit M' \\<sigma>)\\<close> and\n              \\<open>vars_of_lit M \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  vars_of_lit (subst_lit M' \\<sigma>) = {}\n  M = subst_lit M' \\<sigma>\n  vars_of_lit M \\<noteq> {}", "show False"], ["proof (prove)\nusing this:\n  vars_of_lit (subst_lit M' \\<sigma>) = {}\n  M = subst_lit M' \\<sigma>\n  vars_of_lit M \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ground_clause Cl_R\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "from \\<open>ground_clause Cl_R\\<close> and \\<open>R = Ecl Cl_R nt_R\\<close>"], ["proof (chain)\npicking this:\n  ground_clause Cl_R\n  R = Ecl Cl_R nt_R", "have \"ground_clause (cl_ecl R)\""], ["proof (prove)\nusing this:\n  ground_clause Cl_R\n  R = Ecl Cl_R nt_R\n\ngoal (1 subgoal):\n 1. ground_clause (cl_ecl R)", "by auto"], ["proof (state)\nthis:\n  ground_clause (cl_ecl R)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "from \\<open>ground_clause (subst_cl (cl_ecl C) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)", "have \"grounding_set { C } \\<sigma>\""], ["proof (prove)\nusing this:\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. grounding_set {C} \\<sigma>", "unfolding grounding_set_def"], ["proof (prove)\nusing this:\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<in> {C} \\<longrightarrow>\n       ground_clause (subst_cl (cl_ecl x) \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  grounding_set {C} \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "from this \\<open>ground_clause (cl_ecl R)\\<close> \n          and \\<open>derivable R { C } S \\<sigma> Ground (((cl_ecl C) - { L2 }) \\<union> { L' } )\\<close> \n          and \\<open>ground_inference_saturated S\\<close>"], ["proof (chain)\npicking this:\n  grounding_set {C} \\<sigma>\n  ground_clause (cl_ecl R)\n  derivable R {C} S \\<sigma> Ground (cl_ecl C - {L2} \\<union> {L'})\n  ground_inference_saturated S", "have \"(redundant_inference R S { C } \\<sigma>)\""], ["proof (prove)\nusing this:\n  grounding_set {C} \\<sigma>\n  ground_clause (cl_ecl R)\n  derivable R {C} S \\<sigma> Ground (cl_ecl C - {L2} \\<union> {L'})\n  ground_inference_saturated S\n\ngoal (1 subgoal):\n 1. redundant_inference R S {C} \\<sigma>", "unfolding ground_inference_saturated_def"], ["proof (prove)\nusing this:\n  grounding_set {C} \\<sigma>\n  ground_clause (cl_ecl R)\n  derivable R {C} S \\<sigma> Ground (cl_ecl C - {L2} \\<union> {L'})\n  \\<forall>C P \\<sigma> C'.\n     derivable C P S \\<sigma> Ground C' \\<longrightarrow>\n     ground_clause (cl_ecl C) \\<longrightarrow>\n     grounding_set P \\<sigma> \\<longrightarrow>\n     redundant_inference C S P \\<sigma>\n\ngoal (1 subgoal):\n 1. redundant_inference R S {C} \\<sigma>", "by blast"], ["proof (state)\nthis:\n  redundant_inference R S {C} \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  redundant_inference R S {C} \\<sigma>", "obtain S' where \"S' \\<subseteq> (instances S)\" and \n          \"(set_entails_clause (clset_instances S') (cl_ecl R))\"\n          and all_smaller: \"(\\<forall>x \\<in> S'. (((fst x),(snd x)),(C,\\<sigma>)) \\<in> ecl_ord)\"\n          and all_normalized_term_included: \"(\\<forall>x \\<in> S'. \n          (subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n            (trms_ecl R)))\""], ["proof (prove)\nusing this:\n  redundant_inference R S {C} \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>S'.\n        \\<lbrakk>S' \\<subseteq> instances S;\n         set_entails_clause (clset_instances S') (cl_ecl R);\n         \\<forall>x\\<in>S'. ((fst x, snd x), C, \\<sigma>) \\<in> ecl_ord;\n         \\<forall>x\\<in>S'.\n            subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n             (trms_ecl R)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding redundant_inference_def"], ["proof (prove)\nusing this:\n  \\<exists>S'\\<subseteq>instances S.\n     set_entails_clause (clset_instances S') (cl_ecl R) \\<and>\n     (\\<forall>x\\<in>S'.\n         subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n          (trms_ecl R)) \\<and>\n     (\\<forall>x\\<in>S'.\n         \\<exists>D'\\<in>{C}. ((fst x, snd x), D', \\<sigma>) \\<in> ecl_ord)\n\ngoal (1 subgoal):\n 1. (\\<And>S'.\n        \\<lbrakk>S' \\<subseteq> instances S;\n         set_entails_clause (clset_instances S') (cl_ecl R);\n         \\<forall>x\\<in>S'. ((fst x, snd x), C, \\<sigma>) \\<in> ecl_ord;\n         \\<forall>x\\<in>S'.\n            subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x))\n             (trms_ecl R)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  S' \\<subseteq> instances S\n  set_entails_clause (clset_instances S') (cl_ecl R)\n  \\<forall>x\\<in>S'. ((fst x, snd x), C, \\<sigma>) \\<in> ecl_ord\n  \\<forall>x\\<in>S'.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) (trms_ecl R)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "have \"validate_clause_set ?I (clset_instances S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. validate_clause_set (int_clset S) (clset_instances S')", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "assume \"\\<not> validate_clause_set ?I (clset_instances S')\""], ["proof (state)\nthis:\n  \\<not> validate_clause_set (int_clset S) (clset_instances S')\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> validate_clause_set (int_clset S) (clset_instances S')", "obtain x where \"x \\<in>(clset_instances S')\" and \"\\<not>validate_clause ?I x\""], ["proof (prove)\nusing this:\n  \\<not> validate_clause_set (int_clset S) (clset_instances S')\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> clset_instances S';\n         \\<not> validate_clause (int_clset S) x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using validate_clause_set.simps"], ["proof (prove)\nusing this:\n  \\<not> validate_clause_set (int_clset S) (clset_instances S')\n  validate_clause_set ?I ?S =\n  (\\<forall>C. C \\<in> ?S \\<longrightarrow> validate_clause ?I C)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> clset_instances S';\n         \\<not> validate_clause (int_clset S) x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> clset_instances S'\n  \\<not> validate_clause (int_clset S) x\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from \\<open>x \\<in>(clset_instances S')\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> clset_instances S'", "obtain pair' where \"pair' \\<in> S'\" \n          and \"x = (subst_cl (cl_ecl (fst pair')) (snd pair'))\""], ["proof (prove)\nusing this:\n  x \\<in> clset_instances S'\n\ngoal (1 subgoal):\n 1. (\\<And>pair'.\n        \\<lbrakk>pair' \\<in> S';\n         x = subst_cl (cl_ecl (fst pair')) (snd pair')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding clset_instances_def"], ["proof (prove)\nusing this:\n  x \\<in> {C. \\<exists>x.\n                 x \\<in> S' \\<and> C = subst_cl (cl_ecl (fst x)) (snd x)}\n\ngoal (1 subgoal):\n 1. (\\<And>pair'.\n        \\<lbrakk>pair' \\<in> S';\n         x = subst_cl (cl_ecl (fst pair')) (snd pair')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  pair' \\<in> S'\n  x = subst_cl (cl_ecl (fst pair')) (snd pair')\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from all_smaller and \\<open>pair' \\<in> S'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S'. ((fst x, snd x), C, \\<sigma>) \\<in> ecl_ord\n  pair' \\<in> S'", "have \"(pair',(C,\\<sigma>)) \\<in> ecl_ord\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S'. ((fst x, snd x), C, \\<sigma>) \\<in> ecl_ord\n  pair' \\<in> S'\n\ngoal (1 subgoal):\n 1. (pair', C, \\<sigma>) \\<in> ecl_ord", "by auto"], ["proof (state)\nthis:\n  (pair', C, \\<sigma>) \\<in> ecl_ord\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from this and  \\<open>C = fst pair\\<close> and \\<open>\\<sigma> = snd pair\\<close>"], ["proof (chain)\npicking this:\n  (pair', C, \\<sigma>) \\<in> ecl_ord\n  C = fst pair\n  \\<sigma> = snd pair", "have \"(pair',pair) \\<in> ecl_ord\""], ["proof (prove)\nusing this:\n  (pair', C, \\<sigma>) \\<in> ecl_ord\n  C = fst pair\n  \\<sigma> = snd pair\n\ngoal (1 subgoal):\n 1. (pair', pair) \\<in> ecl_ord", "by auto"], ["proof (state)\nthis:\n  (pair', pair) \\<in> ecl_ord\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from this and hyp_ind"], ["proof (chain)\npicking this:\n  (pair', pair) \\<in> ecl_ord\n  \\<forall>y.\n     (y, pair) \\<in> ecl_ord \\<longrightarrow>\n     (\\<forall>C \\<sigma>.\n         fst y = C \\<longrightarrow>\n         \\<sigma> = snd y \\<longrightarrow>\n         C \\<in> S \\<longrightarrow>\n         ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n         all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n          (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n         validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n          (subst_cl (cl_ecl C) \\<sigma>))", "have \"?P pair'\""], ["proof (prove)\nusing this:\n  (pair', pair) \\<in> ecl_ord\n  \\<forall>y.\n     (y, pair) \\<in> ecl_ord \\<longrightarrow>\n     (\\<forall>C \\<sigma>.\n         fst y = C \\<longrightarrow>\n         \\<sigma> = snd y \\<longrightarrow>\n         C \\<in> S \\<longrightarrow>\n         ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n         all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n          (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n         validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n          (subst_cl (cl_ecl C) \\<sigma>))\n\ngoal (1 subgoal):\n 1. \\<forall>C \\<sigma>.\n       fst pair' = C \\<longrightarrow>\n       \\<sigma> = snd pair' \\<longrightarrow>\n       C \\<in> S \\<longrightarrow>\n       ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n       all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n        (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n       validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n        (subst_cl (cl_ecl C) \\<sigma>)", "by blast"], ["proof (state)\nthis:\n  \\<forall>C \\<sigma>.\n     fst pair' = C \\<longrightarrow>\n     \\<sigma> = snd pair' \\<longrightarrow>\n     C \\<in> S \\<longrightarrow>\n     ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n     all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n      (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n     validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n      (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from r ntr"], ["proof (chain)\npicking this:\n  R = Ecl Cl_R nt_R\n  nt_R =\n  dom_trms Cl_R\n   (subst_set (trms_ecl C \\<union> proper_subterms_of t) \\<sigma>)", "have \"trms_ecl R = (dom_trms (cl_ecl R) \n            (subst_set ((trms_ecl C) \\<union> (proper_subterms_of t)) \\<sigma>))\""], ["proof (prove)\nusing this:\n  R = Ecl Cl_R nt_R\n  nt_R =\n  dom_trms Cl_R\n   (subst_set (trms_ecl C \\<union> proper_subterms_of t) \\<sigma>)\n\ngoal (1 subgoal):\n 1. trms_ecl R =\n    dom_trms (cl_ecl R)\n     (subst_set (trms_ecl C \\<union> proper_subterms_of t) \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  trms_ecl R =\n  dom_trms (cl_ecl R)\n   (subst_set (trms_ecl C \\<union> proper_subterms_of t) \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  trms_ecl R =\n  dom_trms (cl_ecl R)\n   (subst_set (trms_ecl C \\<union> proper_subterms_of t) \\<sigma>)", "have \"trms_ecl R \\<subseteq> (subst_set ((trms_ecl C) \\<union> (proper_subterms_of t)) \\<sigma>)\""], ["proof (prove)\nusing this:\n  trms_ecl R =\n  dom_trms (cl_ecl R)\n   (subst_set (trms_ecl C \\<union> proper_subterms_of t) \\<sigma>)\n\ngoal (1 subgoal):\n 1. trms_ecl R\n    \\<subseteq> subst_set (trms_ecl C \\<union> proper_subterms_of t)\n                 \\<sigma>", "using dom_trms_subset"], ["proof (prove)\nusing this:\n  trms_ecl R =\n  dom_trms (cl_ecl R)\n   (subst_set (trms_ecl C \\<union> proper_subterms_of t) \\<sigma>)\n  dom_trms ?C ?E \\<subseteq> ?E\n\ngoal (1 subgoal):\n 1. trms_ecl R\n    \\<subseteq> subst_set (trms_ecl C \\<union> proper_subterms_of t)\n                 \\<sigma>", "by metis"], ["proof (state)\nthis:\n  trms_ecl R\n  \\<subseteq> subst_set (trms_ecl C \\<union> proper_subterms_of t) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from \\<open>pair' \\<in> S'\\<close> and all_normalized_term_included"], ["proof (chain)\npicking this:\n  pair' \\<in> S'\n  \\<forall>x\\<in>S'.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) (trms_ecl R)", "have \n          \"(subterms_inclusion (subst_set (trms_ecl (fst pair')) (snd pair')) \n             (trms_ecl R))\""], ["proof (prove)\nusing this:\n  pair' \\<in> S'\n  \\<forall>x\\<in>S'.\n     subterms_inclusion (subst_set (trms_ecl (fst x)) (snd x)) (trms_ecl R)\n\ngoal (1 subgoal):\n 1. subterms_inclusion (subst_set (trms_ecl (fst pair')) (snd pair'))\n     (trms_ecl R)", "by auto"], ["proof (state)\nthis:\n  subterms_inclusion (subst_set (trms_ecl (fst pair')) (snd pair'))\n   (trms_ecl R)\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "have i: \"(all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair')) \n                  (\\<lambda>t. (trm_rep t S)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair'))\n     (\\<lambda>t. trm_rep t S)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "assume \"\\<not>(all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair')) \n                  (\\<lambda>t. (trm_rep t S)))\""], ["proof (state)\nthis:\n  \\<not> all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair'))\n          (\\<lambda>t. trm_rep t S)\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair'))\n          (\\<lambda>t. trm_rep t S)", "obtain t' t'' where \"t' \\<in> (subst_set (trms_ecl (fst pair')) (snd pair'))\" \n            \"occurs_in t'' t'\" and \"trm_rep t'' S \\<noteq> t''\""], ["proof (prove)\nusing this:\n  \\<not> all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair'))\n          (\\<lambda>t. trm_rep t S)\n\ngoal (1 subgoal):\n 1. (\\<And>t' t''.\n        \\<lbrakk>t' \\<in> subst_set (trms_ecl (fst pair')) (snd pair');\n         occurs_in t'' t'; trm_rep t'' S \\<noteq> t''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding all_trms_irreducible_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x y.\n             x \\<in> subst_set (trms_ecl (fst pair'))\n                      (snd pair') \\<longrightarrow>\n             occurs_in y x \\<longrightarrow> trm_rep y S = y)\n\ngoal (1 subgoal):\n 1. (\\<And>t' t''.\n        \\<lbrakk>t' \\<in> subst_set (trms_ecl (fst pair')) (snd pair');\n         occurs_in t'' t'; trm_rep t'' S \\<noteq> t''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  t' \\<in> subst_set (trms_ecl (fst pair')) (snd pair')\n  occurs_in t'' t'\n  trm_rep t'' S \\<noteq> t''\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from \\<open>t' \\<in> (subst_set (trms_ecl (fst pair')) (snd pair'))\\<close> \n            and \\<open>(subterms_inclusion (subst_set (trms_ecl (fst pair')) (snd pair')) (trms_ecl R))\\<close>"], ["proof (chain)\npicking this:\n  t' \\<in> subst_set (trms_ecl (fst pair')) (snd pair')\n  subterms_inclusion (subst_set (trms_ecl (fst pair')) (snd pair'))\n   (trms_ecl R)", "obtain s' where \"s' \\<in> (trms_ecl R)\" and \"occurs_in t' s'\""], ["proof (prove)\nusing this:\n  t' \\<in> subst_set (trms_ecl (fst pair')) (snd pair')\n  subterms_inclusion (subst_set (trms_ecl (fst pair')) (snd pair'))\n   (trms_ecl R)\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>s' \\<in> trms_ecl R; occurs_in t' s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding subterms_inclusion_def"], ["proof (prove)\nusing this:\n  t' \\<in> subst_set (trms_ecl (fst pair')) (snd pair')\n  \\<forall>x1\\<in>subst_set (trms_ecl (fst pair')) (snd pair').\n     Bex (trms_ecl R) (occurs_in x1)\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>s' \\<in> trms_ecl R; occurs_in t' s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s' \\<in> trms_ecl R\n  occurs_in t' s'\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from \\<open>s' \\<in> (trms_ecl R)\\<close> and \\<open>trms_ecl R \\<subseteq> (subst_set ((trms_ecl C) \\<union> (proper_subterms_of t)) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  s' \\<in> trms_ecl R\n  trms_ecl R\n  \\<subseteq> subst_set (trms_ecl C \\<union> proper_subterms_of t) \\<sigma>", "have \"s' \\<in>(subst_set ((trms_ecl C) \\<union> (proper_subterms_of t)) \\<sigma>)\""], ["proof (prove)\nusing this:\n  s' \\<in> trms_ecl R\n  trms_ecl R\n  \\<subseteq> subst_set (trms_ecl C \\<union> proper_subterms_of t) \\<sigma>\n\ngoal (1 subgoal):\n 1. s' \\<in> subst_set (trms_ecl C \\<union> proper_subterms_of t) \\<sigma>", "by auto"], ["proof (state)\nthis:\n  s' \\<in> subst_set (trms_ecl C \\<union> proper_subterms_of t) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  s' \\<in> subst_set (trms_ecl C \\<union> proper_subterms_of t) \\<sigma>", "obtain s''\n            where \"s' = subst s'' \\<sigma>\" and \"s'' \\<in> ((trms_ecl C) \\<union> (proper_subterms_of t))\""], ["proof (prove)\nusing this:\n  s' \\<in> subst_set (trms_ecl C \\<union> proper_subterms_of t) \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>s''.\n        \\<lbrakk>s' = s'' \\<lhd> \\<sigma>;\n         s'' \\<in> trms_ecl C \\<union> proper_subterms_of t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s' = s'' \\<lhd> \\<sigma>\n  s'' \\<in> trms_ecl C \\<union> proper_subterms_of t\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "from \\<open>s'' \\<in> ((trms_ecl C) \\<union> (proper_subterms_of t))\\<close>"], ["proof (chain)\npicking this:\n  s'' \\<in> trms_ecl C \\<union> proper_subterms_of t", "have \"s'' \\<in> trms_ecl C \n            \\<or> s'' \\<in> (proper_subterms_of t)\""], ["proof (prove)\nusing this:\n  s'' \\<in> trms_ecl C \\<union> proper_subterms_of t\n\ngoal (1 subgoal):\n 1. s'' \\<in> trms_ecl C \\<or> s'' \\<in> proper_subterms_of t", "by auto"], ["proof (state)\nthis:\n  s'' \\<in> trms_ecl C \\<or> s'' \\<in> proper_subterms_of t\n\ngoal (1 subgoal):\n 1. \\<not> all_trms_irreducible\n            (subst_set (trms_ecl (fst pair')) (snd pair'))\n            (\\<lambda>t. trm_rep t S) \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  s'' \\<in> trms_ecl C \\<or> s'' \\<in> proper_subterms_of t\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. s'' \\<in> trms_ecl C \\<Longrightarrow> False\n 2. s'' \\<in> proper_subterms_of t \\<Longrightarrow> False", "assume \"s'' \\<in> trms_ecl C\""], ["proof (state)\nthis:\n  s'' \\<in> trms_ecl C\n\ngoal (2 subgoals):\n 1. s'' \\<in> trms_ecl C \\<Longrightarrow> False\n 2. s'' \\<in> proper_subterms_of t \\<Longrightarrow> False", "from this and \\<open>s' = subst s'' \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  s'' \\<in> trms_ecl C\n  s' = s'' \\<lhd> \\<sigma>", "have \"s' \\<in> (subst_set (trms_ecl C) \\<sigma>)\""], ["proof (prove)\nusing this:\n  s'' \\<in> trms_ecl C\n  s' = s'' \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. s' \\<in> subst_set (trms_ecl C) \\<sigma>", "by auto"], ["proof (state)\nthis:\n  s' \\<in> subst_set (trms_ecl C) \\<sigma>\n\ngoal (2 subgoals):\n 1. s'' \\<in> trms_ecl C \\<Longrightarrow> False\n 2. s'' \\<in> proper_subterms_of t \\<Longrightarrow> False", "from this and \\<open>(all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>) \n                  (\\<lambda>t. (trm_rep t S)))\\<close> and \\<open>occurs_in t' s'\\<close>"], ["proof (chain)\npicking this:\n  s' \\<in> subst_set (trms_ecl C) \\<sigma>\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n  occurs_in t' s'", "have \"trm_rep t' S = t'\""], ["proof (prove)\nusing this:\n  s' \\<in> subst_set (trms_ecl C) \\<sigma>\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n  occurs_in t' s'\n\ngoal (1 subgoal):\n 1. trm_rep t' S = t'", "unfolding all_trms_irreducible_def"], ["proof (prove)\nusing this:\n  s' \\<in> subst_set (trms_ecl C) \\<sigma>\n  \\<forall>x y.\n     x \\<in> subst_set (trms_ecl C) \\<sigma> \\<longrightarrow>\n     occurs_in y x \\<longrightarrow> trm_rep y S = y\n  occurs_in t' s'\n\ngoal (1 subgoal):\n 1. trm_rep t' S = t'", "by blast"], ["proof (state)\nthis:\n  trm_rep t' S = t'\n\ngoal (2 subgoals):\n 1. s'' \\<in> trms_ecl C \\<Longrightarrow> False\n 2. s'' \\<in> proper_subterms_of t \\<Longrightarrow> False", "from this and \\<open>occurs_in t'' t'\\<close> and \\<open>trm_rep t'' S \\<noteq> t''\\<close>"], ["proof (chain)\npicking this:\n  trm_rep t' S = t'\n  occurs_in t'' t'\n  trm_rep t'' S \\<noteq> t''", "show False"], ["proof (prove)\nusing this:\n  trm_rep t' S = t'\n  occurs_in t'' t'\n  trm_rep t'' S \\<noteq> t''\n\ngoal (1 subgoal):\n 1. False", "using occurs_in_def subts_of_irred_trms_are_irred"], ["proof (prove)\nusing this:\n  trm_rep t' S = t'\n  occurs_in t'' t'\n  trm_rep t'' S \\<noteq> t''\n  occurs_in ?t ?s = (\\<exists>p. subterm ?s p ?t)\n  trm_rep ?y ?S \\<noteq> ?y \\<Longrightarrow>\n  subterm ?x ?p ?y \\<longrightarrow> trm_rep ?x ?S \\<noteq> ?x\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. s'' \\<in> proper_subterms_of t \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s'' \\<in> proper_subterms_of t \\<Longrightarrow> False", "assume \" s'' \\<in> (proper_subterms_of t)\""], ["proof (state)\nthis:\n  s'' \\<in> proper_subterms_of t\n\ngoal (1 subgoal):\n 1. s'' \\<in> proper_subterms_of t \\<Longrightarrow> False", "from \\<open>occurs_in t' s'\\<close> \\<open>occurs_in t'' t'\\<close> \\<open>s' = s'' \\<lhd> \\<sigma>\\<close> \\<open>trm_rep t'' S \\<noteq> t''\\<close>"], ["proof (chain)\npicking this:\n  occurs_in t' s'\n  occurs_in t'' t'\n  s' = s'' \\<lhd> \\<sigma>\n  trm_rep t'' S \\<noteq> t''", "have \"trm_rep (subst s'' \\<sigma>) S \\<noteq>  (subst s'' \\<sigma>)\""], ["proof (prove)\nusing this:\n  occurs_in t' s'\n  occurs_in t'' t'\n  s' = s'' \\<lhd> \\<sigma>\n  trm_rep t'' S \\<noteq> t''\n\ngoal (1 subgoal):\n 1. trm_rep (s'' \\<lhd> \\<sigma>) S \\<noteq> s'' \\<lhd> \\<sigma>", "using occurs_in_def subts_of_irred_trms_are_irred"], ["proof (prove)\nusing this:\n  occurs_in t' s'\n  occurs_in t'' t'\n  s' = s'' \\<lhd> \\<sigma>\n  trm_rep t'' S \\<noteq> t''\n  occurs_in ?t ?s = (\\<exists>p. subterm ?s p ?t)\n  trm_rep ?y ?S \\<noteq> ?y \\<Longrightarrow>\n  subterm ?x ?p ?y \\<longrightarrow> trm_rep ?x ?S \\<noteq> ?x\n\ngoal (1 subgoal):\n 1. trm_rep (s'' \\<lhd> \\<sigma>) S \\<noteq> s'' \\<lhd> \\<sigma>", "by blast"], ["proof (state)\nthis:\n  trm_rep (s'' \\<lhd> \\<sigma>) S \\<noteq> s'' \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. s'' \\<in> proper_subterms_of t \\<Longrightarrow> False", "from this and \\<open>s'' \\<in> (proper_subterms_of t)\\<close> and \\<open>\\<not> (proper_subterm_red t S \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  trm_rep (s'' \\<lhd> \\<sigma>) S \\<noteq> s'' \\<lhd> \\<sigma>\n  s'' \\<in> proper_subterms_of t\n  \\<not> proper_subterm_red t S \\<sigma>", "show False"], ["proof (prove)\nusing this:\n  trm_rep (s'' \\<lhd> \\<sigma>) S \\<noteq> s'' \\<lhd> \\<sigma>\n  s'' \\<in> proper_subterms_of t\n  \\<not> proper_subterm_red t S \\<sigma>\n\ngoal (1 subgoal):\n 1. False", "using proper_subterm_red_def \"proper_subterms_of.simps\""], ["proof (prove)\nusing this:\n  trm_rep (s'' \\<lhd> \\<sigma>) S \\<noteq> s'' \\<lhd> \\<sigma>\n  s'' \\<in> proper_subterms_of t\n  \\<not> proper_subterm_red t S \\<sigma>\n  proper_subterm_red ?t ?S ?\\<sigma> =\n  (\\<exists>p s.\n      subterm ?t p s \\<and>\n      p \\<noteq> [] \\<and>\n      trm_rep (s \\<lhd> ?\\<sigma>) ?S \\<noteq> s \\<lhd> ?\\<sigma>)\n  proper_subterms_of ?t =\n  {s. \\<exists>p. p \\<noteq> [] \\<and> subterm ?t p s}\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair'))\n   (\\<lambda>t. trm_rep t S)\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from \\<open>S' \\<subseteq> (instances S)\\<close> and \\<open>pair' \\<in> S'\\<close>"], ["proof (chain)\npicking this:\n  S' \\<subseteq> instances S\n  pair' \\<in> S'", "have \n          ii: \"ground_clause (subst_cl (cl_ecl (fst pair')) (snd pair'))\""], ["proof (prove)\nusing this:\n  S' \\<subseteq> instances S\n  pair' \\<in> S'\n\ngoal (1 subgoal):\n 1. ground_clause (subst_cl (cl_ecl (fst pair')) (snd pair'))", "unfolding instances_def [of S]"], ["proof (prove)\nusing this:\n  S' \\<subseteq> {x. \\<exists>C \\<sigma>.\n                        C \\<in> S \\<and>\n                        ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<and>\n                        x = (C, \\<sigma>)}\n  pair' \\<in> S'\n\ngoal (1 subgoal):\n 1. ground_clause (subst_cl (cl_ecl (fst pair')) (snd pair'))", "by fastforce"], ["proof (state)\nthis:\n  ground_clause (subst_cl (cl_ecl (fst pair')) (snd pair'))\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from \\<open>S' \\<subseteq> (instances S)\\<close> and \\<open>pair' \\<in> S'\\<close>"], ["proof (chain)\npicking this:\n  S' \\<subseteq> instances S\n  pair' \\<in> S'", "have \n          iii: \"(fst pair') \\<in> S\""], ["proof (prove)\nusing this:\n  S' \\<subseteq> instances S\n  pair' \\<in> S'\n\ngoal (1 subgoal):\n 1. fst pair' \\<in> S", "unfolding instances_def [of S]"], ["proof (prove)\nusing this:\n  S' \\<subseteq> {x. \\<exists>C \\<sigma>.\n                        C \\<in> S \\<and>\n                        ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<and>\n                        x = (C, \\<sigma>)}\n  pair' \\<in> S'\n\ngoal (1 subgoal):\n 1. fst pair' \\<in> S", "by fastforce"], ["proof (state)\nthis:\n  fst pair' \\<in> S\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from \\<open>?P pair'\\<close> and i ii iii"], ["proof (chain)\npicking this:\n  \\<forall>C \\<sigma>.\n     fst pair' = C \\<longrightarrow>\n     \\<sigma> = snd pair' \\<longrightarrow>\n     C \\<in> S \\<longrightarrow>\n     ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n     all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n      (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n     validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n      (subst_cl (cl_ecl C) \\<sigma>)\n  all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair'))\n   (\\<lambda>t. trm_rep t S)\n  ground_clause (subst_cl (cl_ecl (fst pair')) (snd pair'))\n  fst pair' \\<in> S", "have \"validate_ground_clause ?I \n          (subst_cl (cl_ecl (fst pair')) (snd pair'))\""], ["proof (prove)\nusing this:\n  \\<forall>C \\<sigma>.\n     fst pair' = C \\<longrightarrow>\n     \\<sigma> = snd pair' \\<longrightarrow>\n     C \\<in> S \\<longrightarrow>\n     ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n     all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n      (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n     validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n      (subst_cl (cl_ecl C) \\<sigma>)\n  all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair'))\n   (\\<lambda>t. trm_rep t S)\n  ground_clause (subst_cl (cl_ecl (fst pair')) (snd pair'))\n  fst pair' \\<in> S\n\ngoal (1 subgoal):\n 1. validate_ground_clause (int_clset S)\n     (subst_cl (cl_ecl (fst pair')) (snd pair'))", "unfolding int_clset_def"], ["proof (prove)\nusing this:\n  \\<forall>C \\<sigma>.\n     fst pair' = C \\<longrightarrow>\n     \\<sigma> = snd pair' \\<longrightarrow>\n     C \\<in> S \\<longrightarrow>\n     ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n     all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n      (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n     validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n      (subst_cl (cl_ecl C) \\<sigma>)\n  all_trms_irreducible (subst_set (trms_ecl (fst pair')) (snd pair'))\n   (\\<lambda>t. trm_rep t S)\n  ground_clause (subst_cl (cl_ecl (fst pair')) (snd pair'))\n  fst pair' \\<in> S\n\ngoal (1 subgoal):\n 1. validate_ground_clause (same_values (\\<lambda>x. trm_rep x S))\n     (subst_cl (cl_ecl (fst pair')) (snd pair'))", "by blast"], ["proof (state)\nthis:\n  validate_ground_clause (int_clset S)\n   (subst_cl (cl_ecl (fst pair')) (snd pair'))\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set (int_clset S)\n            (clset_instances S') \\<Longrightarrow>\n    False", "from this and \\<open>x = (subst_cl (cl_ecl (fst pair')) (snd pair'))\\<close> \n          and \\<open>\\<not>validate_clause ?I x\\<close>"], ["proof (chain)\npicking this:\n  validate_ground_clause (int_clset S)\n   (subst_cl (cl_ecl (fst pair')) (snd pair'))\n  x = subst_cl (cl_ecl (fst pair')) (snd pair')\n  \\<not> validate_clause (int_clset S) x", "show False"], ["proof (prove)\nusing this:\n  validate_ground_clause (int_clset S)\n   (subst_cl (cl_ecl (fst pair')) (snd pair'))\n  x = subst_cl (cl_ecl (fst pair')) (snd pair')\n  \\<not> validate_clause (int_clset S) x\n\ngoal (1 subgoal):\n 1. False", "by (metis ii substs_preserve_ground_clause validate_clause.simps)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  validate_clause_set (int_clset S) (clset_instances S')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "from this and \\<open>fo_interpretation ?I\\<close> and \n        \\<open>(set_entails_clause (clset_instances S') (cl_ecl R))\\<close>"], ["proof (chain)\npicking this:\n  validate_clause_set (int_clset S) (clset_instances S')\n  fo_interpretation (int_clset S)\n  set_entails_clause (clset_instances S') (cl_ecl R)", "have \"validate_clause ?I (cl_ecl R)\""], ["proof (prove)\nusing this:\n  validate_clause_set (int_clset S) (clset_instances S')\n  fo_interpretation (int_clset S)\n  set_entails_clause (clset_instances S') (cl_ecl R)\n\ngoal (1 subgoal):\n 1. validate_clause (int_clset S) (cl_ecl R)", "unfolding set_entails_clause_def"], ["proof (prove)\nusing this:\n  validate_clause_set (int_clset S) (clset_instances S')\n  fo_interpretation (int_clset S)\n  \\<forall>I.\n     fo_interpretation I \\<longrightarrow>\n     validate_clause_set I (clset_instances S') \\<longrightarrow>\n     validate_clause I (cl_ecl R)\n\ngoal (1 subgoal):\n 1. validate_clause (int_clset S) (cl_ecl R)", "by blast"], ["proof (state)\nthis:\n  validate_clause (int_clset S) (cl_ecl R)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  validate_clause (int_clset S) (cl_ecl R)", "have \"validate_ground_clause ?I (cl_ecl R)\""], ["proof (prove)\nusing this:\n  validate_clause (int_clset S) (cl_ecl R)\n\ngoal (1 subgoal):\n 1. validate_ground_clause (int_clset S) (cl_ecl R)", "by (metis \\<open>R = Ecl Cl_R nt_R\\<close> \\<open>ground_clause Cl_R\\<close> \n            cl_ecl.simps substs_preserve_ground_clause validate_clause.simps)"], ["proof (state)\nthis:\n  validate_ground_clause (int_clset S) (cl_ecl R)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  validate_ground_clause (int_clset S) (cl_ecl R)", "obtain L'' where \"L'' \\<in> (cl_ecl R)\" and \"validate_ground_lit ?I L''\""], ["proof (prove)\nusing this:\n  validate_ground_clause (int_clset S) (cl_ecl R)\n\ngoal (1 subgoal):\n 1. (\\<And>L''.\n        \\<lbrakk>L'' \\<in> cl_ecl R;\n         validate_ground_lit (int_clset S) L''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using validate_ground_clause.simps"], ["proof (prove)\nusing this:\n  validate_ground_clause (int_clset S) (cl_ecl R)\n  validate_ground_clause ?I ?C =\n  (\\<exists>L. L \\<in> ?C \\<and> validate_ground_lit ?I L)\n\ngoal (1 subgoal):\n 1. (\\<And>L''.\n        \\<lbrakk>L'' \\<in> cl_ecl R;\n         validate_ground_lit (int_clset S) L''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  L'' \\<in> cl_ecl R\n  validate_ground_lit (int_clset S) L''\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "from \\<open>L'' \\<in> (cl_ecl R)\\<close> and \\<open>R = Ecl Cl_R nt_R\\<close> and\n          \\<open>Cl_R = (subst_cl ( ((cl_ecl C) - { L2 }) \\<union> { L' } ) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  L'' \\<in> cl_ecl R\n  R = Ecl Cl_R nt_R\n  Cl_R = subst_cl (cl_ecl C - {L2} \\<union> {L'}) \\<sigma>", "obtain M where m: \"M \\<in> ( ((cl_ecl C) - { L2, L1 }) \\<union> { L', L1 } )\" \n          and \"L'' = subst_lit M \\<sigma>\""], ["proof (prove)\nusing this:\n  L'' \\<in> cl_ecl R\n  R = Ecl Cl_R nt_R\n  Cl_R = subst_cl (cl_ecl C - {L2} \\<union> {L'}) \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>M \\<in> cl_ecl C - {L2, L1} \\<union> {L', L1};\n         L'' = subst_lit M \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M \\<in> cl_ecl C - {L2, L1} \\<union> {L', L1}\n  L'' = subst_lit M \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "have \"M \\<in> cl_ecl C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<in> cl_ecl C", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. M \\<notin> cl_ecl C \\<Longrightarrow> False", "assume \"M \\<notin> cl_ecl C\""], ["proof (state)\nthis:\n  M \\<notin> cl_ecl C\n\ngoal (1 subgoal):\n 1. M \\<notin> cl_ecl C \\<Longrightarrow> False", "from this and m and l1"], ["proof (chain)\npicking this:\n  M \\<notin> cl_ecl C\n  M \\<in> cl_ecl C - {L2, L1} \\<union> {L', L1}\n  L1 \\<in> cl_ecl C", "have \"M = L'\""], ["proof (prove)\nusing this:\n  M \\<notin> cl_ecl C\n  M \\<in> cl_ecl C - {L2, L1} \\<union> {L', L1}\n  L1 \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. M = L'", "by auto"], ["proof (state)\nthis:\n  M = L'\n\ngoal (1 subgoal):\n 1. M \\<notin> cl_ecl C \\<Longrightarrow> False", "from this and \\<open>L'' = subst_lit M \\<sigma>\\<close> and \\<open>L' = (Neg (Eq s v))\\<close>"], ["proof (chain)\npicking this:\n  M = L'\n  L'' = subst_lit M \\<sigma>\n  L' = Neg (Eq s v)", "have \"L'' = (Neg (Eq (subst s \\<sigma>)  (subst v \\<sigma>)))\""], ["proof (prove)\nusing this:\n  M = L'\n  L'' = subst_lit M \\<sigma>\n  L' = Neg (Eq s v)\n\ngoal (1 subgoal):\n 1. L'' = Neg (Eq (s \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>))", "by auto"], ["proof (state)\nthis:\n  L'' = Neg (Eq (s \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>))\n\ngoal (1 subgoal):\n 1. M \\<notin> cl_ecl C \\<Longrightarrow> False", "from this and \\<open>validate_ground_lit ?I L''\\<close>"], ["proof (chain)\npicking this:\n  L'' = Neg (Eq (s \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>))\n  validate_ground_lit (int_clset S) L''", "have \"\\<not>(?I (subst s \\<sigma>) (subst v \\<sigma>))\""], ["proof (prove)\nusing this:\n  L'' = Neg (Eq (s \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>))\n  validate_ground_lit (int_clset S) L''\n\ngoal (1 subgoal):\n 1. \\<not> int_clset S (s \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "using validate_ground_lit.simps(2) validate_ground_eq.simps"], ["proof (prove)\nusing this:\n  L'' = Neg (Eq (s \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>))\n  validate_ground_lit (int_clset S) L''\n  validate_ground_lit ?I (Neg ?E) = (\\<not> validate_ground_eq ?I ?E)\n  validate_ground_eq ?I (Eq ?t ?s) = ?I ?t ?s\n\ngoal (1 subgoal):\n 1. \\<not> int_clset S (s \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)", "by metis"], ["proof (state)\nthis:\n  \\<not> int_clset S (s \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. M \\<notin> cl_ecl C \\<Longrightarrow> False", "from this and i"], ["proof (chain)\npicking this:\n  \\<not> int_clset S (s \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n  trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S", "show False"], ["proof (prove)\nusing this:\n  \\<not> int_clset S (s \\<lhd> \\<sigma>) (v \\<lhd> \\<sigma>)\n  trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. False", "unfolding same_values_def int_clset_def"], ["proof (prove)\nusing this:\n  trm_rep (s \\<lhd> \\<sigma>) S \\<noteq> trm_rep (v \\<lhd> \\<sigma>) S\n  trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  M \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "from \\<open>M \\<in> cl_ecl C\\<close> and \\<open>L'' = subst_lit M \\<sigma>\\<close>and \\<open>validate_ground_lit ?I L''\\<close>"], ["proof (chain)\npicking this:\n  M \\<in> cl_ecl C\n  L'' = subst_lit M \\<sigma>\n  validate_ground_lit (int_clset S) L''", "have \"validate_ground_clause ?I (subst_cl (cl_ecl C) \\<sigma>)\""], ["proof (prove)\nusing this:\n  M \\<in> cl_ecl C\n  L'' = subst_lit M \\<sigma>\n  validate_ground_lit (int_clset S) L''\n\ngoal (1 subgoal):\n 1. validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)", "by (metis (mono_tags, lifting) subst_cl.simps mem_Collect_eq \n              validate_ground_clause.simps)"], ["proof (state)\nthis:\n  validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>L1 L2 t s u v.\n               L1 \\<in> cl_ecl C \\<longrightarrow>\n               eligible_literal L1 C \\<sigma> \\<longrightarrow>\n               L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n               orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n               orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n               t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n               \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n               trm_rep (s \\<lhd> \\<sigma>) S \\<noteq>\n               trm_rep (v \\<lhd> \\<sigma>) S) \\<Longrightarrow>\n    False", "from this and cm"], ["proof (chain)\npicking this:\n  validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)", "show False"], ["proof (prove)\nusing this:\n  validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>L1 L2 t s u v.\n     L1 \\<in> cl_ecl C \\<longrightarrow>\n     eligible_literal L1 C \\<sigma> \\<longrightarrow>\n     L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n     orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n     orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n     t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n     \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n     trm_rep (s \\<lhd> \\<sigma>) S \\<noteq> trm_rep (v \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "text \\<open>Now, it remains to prove that the considered clause yields a rule which can be used to \nreduce the left-hand side of the maximal equation, which (since no reduction is possible)\nentails that the left-hand side must be equivalent to the right-hand side \n(thus contradicting the fact that the clause is false).\\<close>"], ["proof (state)\nthis:\n  \\<forall>L1 L2 t s u v.\n     L1 \\<in> cl_ecl C \\<longrightarrow>\n     eligible_literal L1 C \\<sigma> \\<longrightarrow>\n     L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n     orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n     orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n     t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n     \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n     trm_rep (s \\<lhd> \\<sigma>) S \\<noteq> trm_rep (v \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "have \"(finite (cl_ecl C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (cl_ecl C)", "by (simp add: \\<open>C \\<in> S\\<close> all_finite)"], ["proof (state)\nthis:\n  finite (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "have \"(cl_ecl C) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cl_ecl C \\<noteq> {}", "by (simp add: \\<open>C \\<in> S\\<close> all_non_empty)"], ["proof (state)\nthis:\n  cl_ecl C \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "from \\<open>finite (cl_ecl C)\\<close> \\<open>(cl_ecl C) \\<noteq> {}\\<close> \\<open>ground_clause (subst_cl (cl_ecl C) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  finite (cl_ecl C)\n  cl_ecl C \\<noteq> {}\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)", "obtain L where \"L \\<in> (cl_ecl C)\" \"eligible_literal L C \\<sigma>\""], ["proof (prove)\nusing this:\n  finite (cl_ecl C)\n  cl_ecl C \\<noteq> {}\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>L \\<in> cl_ecl C; eligible_literal L C \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using eligible_lit_exists"], ["proof (prove)\nusing this:\n  finite (cl_ecl C)\n  cl_ecl C \\<noteq> {}\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n  \\<lbrakk>finite (cl_ecl ?C); cl_ecl ?C \\<noteq> {};\n   ground_clause (subst_cl (cl_ecl ?C) ?\\<sigma>)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>L.\n                       eligible_literal L ?C ?\\<sigma> \\<and>\n                       L \\<in> cl_ecl ?C\n\ngoal (1 subgoal):\n 1. (\\<And>L.\n        \\<lbrakk>L \\<in> cl_ecl C; eligible_literal L C \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  L \\<in> cl_ecl C\n  eligible_literal L C \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "obtain t s p where \"orient_lit_inst L t s p \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t s p.\n        orient_lit_inst L t s p \\<sigma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using literal.exhaust equation.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x1. ?y = Pos x1 \\<Longrightarrow> ?P;\n   \\<And>x2. ?y = Neg x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  (\\<And>x1 x2. ?y = Eq x1 x2 \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>t s p.\n        orient_lit_inst L t s p \\<sigma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using trm_ord_irrefl trm_ord_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x1. ?y = Pos x1 \\<Longrightarrow> ?P;\n   \\<And>x2. ?y = Neg x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  (\\<And>x1 x2. ?y = Eq x1 x2 \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n  irrefl trm_ord\n  trans trm_ord\n\ngoal (1 subgoal):\n 1. (\\<And>t s p.\n        orient_lit_inst L t s p \\<sigma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding orient_lit_inst_def irrefl_def trans_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x1. ?y = Pos x1 \\<Longrightarrow> ?P;\n   \\<And>x2. ?y = Neg x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  (\\<And>x1 x2. ?y = Eq x1 x2 \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n  \\<forall>a. (a, a) \\<notin> trm_ord\n  \\<forall>x y z.\n     (x, y) \\<in> trm_ord \\<longrightarrow>\n     (y, z) \\<in> trm_ord \\<longrightarrow> (x, z) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (\\<And>t s p.\n        (L = Pos (Eq t s) \\<or> L = Pos (Eq s t)) \\<and>\n        (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n        p = pos \\<or>\n        (L = Neg (Eq t s) \\<or> L = Neg (Eq s t)) \\<and>\n        (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n        p = neg \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  orient_lit_inst L t s p \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "text \\<open>We first show that the terms occurring inside variables are irreducible. To this aim, \nwe need to consider the normal form of the substitution @{term \"\\<sigma>\"}, obtained by replacing the \nimage of each variable by its normal form.\\<close>"], ["proof (state)\nthis:\n  orient_lit_inst L t s p \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "have \"\\<forall>x y. \n        ((x \\<in> vars_of_cl (cl_ecl C)) \\<longrightarrow> occurs_in y (subst (Var x) \\<sigma>) \\<longrightarrow> trm_rep y S = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n       occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow> trm_rep y S = y", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x y.\n               x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n               occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow>\n               trm_rep y S = y) \\<Longrightarrow>\n    False", "assume \"\\<not>(\\<forall>x y. (x \\<in> vars_of_cl (cl_ecl C)) \\<longrightarrow> occurs_in y (subst (Var x) \\<sigma>) \\<longrightarrow> trm_rep y S = y)\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>x y.\n             x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n             occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow>\n             trm_rep y S = y)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x y.\n               x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n               occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow>\n               trm_rep y S = y) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>x y.\n             x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n             occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow>\n             trm_rep y S = y)", "obtain x y where \"(x \\<in> vars_of_cl (cl_ecl C))\" and\n          \"occurs_in y (subst (Var x) \\<sigma>)\" and \"trm_rep y S \\<noteq> y\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x y.\n             x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n             occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow>\n             trm_rep y S = y)\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<in> vars_of_cl (cl_ecl C);\n         occurs_in y (Var x \\<lhd> \\<sigma>);\n         trm_rep y S \\<noteq> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> vars_of_cl (cl_ecl C)\n  occurs_in y (Var x \\<lhd> \\<sigma>)\n  trm_rep y S \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x y.\n               x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n               occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow>\n               trm_rep y S = y) \\<Longrightarrow>\n    False", "from \\<open>occurs_in y (subst (Var x) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  occurs_in y (Var x \\<lhd> \\<sigma>)", "obtain p where \"subterm (subst (Var x) \\<sigma>) p y\""], ["proof (prove)\nusing this:\n  occurs_in y (Var x \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        subterm (Var x \\<lhd> \\<sigma>) p y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding occurs_in_def"], ["proof (prove)\nusing this:\n  \\<exists>p. subterm (Var x \\<lhd> \\<sigma>) p y\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        subterm (Var x \\<lhd> \\<sigma>) p y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  subterm (Var x \\<lhd> \\<sigma>) p y\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x y.\n               x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n               occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow>\n               trm_rep y S = y) \\<Longrightarrow>\n    False", "from \\<open>subterm (subst (Var x) \\<sigma>) p y\\<close> and \\<open>trm_rep y S \\<noteq> y\\<close>"], ["proof (chain)\npicking this:\n  subterm (Var x \\<lhd> \\<sigma>) p y\n  trm_rep y S \\<noteq> y", "have \"trm_rep (subst (Var x) \\<sigma>) S \\<noteq> (subst (Var x) \\<sigma>)\""], ["proof (prove)\nusing this:\n  subterm (Var x \\<lhd> \\<sigma>) p y\n  trm_rep y S \\<noteq> y\n\ngoal (1 subgoal):\n 1. trm_rep (Var x \\<lhd> \\<sigma>) S \\<noteq> Var x \\<lhd> \\<sigma>", "using subts_of_irred_trms_are_irred"], ["proof (prove)\nusing this:\n  subterm (Var x \\<lhd> \\<sigma>) p y\n  trm_rep y S \\<noteq> y\n  trm_rep ?y ?S \\<noteq> ?y \\<Longrightarrow>\n  subterm ?x ?p ?y \\<longrightarrow> trm_rep ?x ?S \\<noteq> ?x\n\ngoal (1 subgoal):\n 1. trm_rep (Var x \\<lhd> \\<sigma>) S \\<noteq> Var x \\<lhd> \\<sigma>", "by blast"], ["proof (state)\nthis:\n  trm_rep (Var x \\<lhd> \\<sigma>) S \\<noteq> Var x \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x y.\n               x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n               occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow>\n               trm_rep y S = y) \\<Longrightarrow>\n    False", "let ?\\<theta> = \"map_subst (\\<lambda>x. (trm_rep x S)) \\<sigma>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x y.\n               x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n               occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow>\n               trm_rep y S = y) \\<Longrightarrow>\n    False", "have \"equivalent_on \\<sigma> ?\\<theta> (vars_of_cl (cl_ecl C)) ?I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalent_on \\<sigma> (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\n     (vars_of_cl (cl_ecl C)) (int_clset S)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> equivalent_on \\<sigma>\n            (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\n            (vars_of_cl (cl_ecl C)) (int_clset S) \\<Longrightarrow>\n    False", "assume \"\\<not>equivalent_on \\<sigma> ?\\<theta> (vars_of_cl (cl_ecl C)) ?I\""], ["proof (state)\nthis:\n  \\<not> equivalent_on \\<sigma>\n          (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\n          (vars_of_cl (cl_ecl C)) (int_clset S)\n\ngoal (1 subgoal):\n 1. \\<not> equivalent_on \\<sigma>\n            (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\n            (vars_of_cl (cl_ecl C)) (int_clset S) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> equivalent_on \\<sigma>\n          (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\n          (vars_of_cl (cl_ecl C)) (int_clset S)", "obtain z where \"z \\<in> vars_of_cl (cl_ecl C)\" \n            and \"\\<not> (?I (subst (Var z) \\<sigma>)  (subst (Var z) ?\\<theta>))\""], ["proof (prove)\nusing this:\n  \\<not> equivalent_on \\<sigma>\n          (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\n          (vars_of_cl (cl_ecl C)) (int_clset S)\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> vars_of_cl (cl_ecl C);\n         \\<not> int_clset S (Var z \\<lhd> \\<sigma>)\n                 (Var z \\<lhd>\n                  map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding equivalent_on_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x\\<in>vars_of_cl (cl_ecl C).\n             int_clset S (Var x \\<lhd> \\<sigma>)\n              (Var x \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>))\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> vars_of_cl (cl_ecl C);\n         \\<not> int_clset S (Var z \\<lhd> \\<sigma>)\n                 (Var z \\<lhd>\n                  map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  z \\<in> vars_of_cl (cl_ecl C)\n  \\<not> int_clset S (Var z \\<lhd> \\<sigma>)\n          (Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> equivalent_on \\<sigma>\n            (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\n            (vars_of_cl (cl_ecl C)) (int_clset S) \\<Longrightarrow>\n    False", "from \\<open>\\<not> (?I (subst (Var z) \\<sigma>)  (subst (Var z) ?\\<theta>))\\<close>"], ["proof (chain)\npicking this:\n  \\<not> int_clset S (Var z \\<lhd> \\<sigma>)\n          (Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)", "have \"trm_rep (subst (Var z) \\<sigma>) S \\<noteq> trm_rep (subst (Var z) ?\\<theta>) S\""], ["proof (prove)\nusing this:\n  \\<not> int_clset S (Var z \\<lhd> \\<sigma>)\n          (Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\n\ngoal (1 subgoal):\n 1. trm_rep (Var z \\<lhd> \\<sigma>) S \\<noteq>\n    trm_rep (Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) S", "unfolding same_values_def int_clset_def"], ["proof (prove)\nusing this:\n  trm_rep (Var z \\<lhd> \\<sigma>) S \\<noteq>\n  trm_rep (Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) S\n\ngoal (1 subgoal):\n 1. trm_rep (Var z \\<lhd> \\<sigma>) S \\<noteq>\n    trm_rep (Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) S", "by blast"], ["proof (state)\nthis:\n  trm_rep (Var z \\<lhd> \\<sigma>) S \\<noteq>\n  trm_rep (Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) S\n\ngoal (1 subgoal):\n 1. \\<not> equivalent_on \\<sigma>\n            (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\n            (vars_of_cl (cl_ecl C)) (int_clset S) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  trm_rep (Var z \\<lhd> \\<sigma>) S \\<noteq>\n  trm_rep (Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) S", "have \"trm_rep (trm_rep (subst (Var z) \\<sigma>) S) S \\<noteq> trm_rep (subst (Var z) ?\\<theta>) S\""], ["proof (prove)\nusing this:\n  trm_rep (Var z \\<lhd> \\<sigma>) S \\<noteq>\n  trm_rep (Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) S\n\ngoal (1 subgoal):\n 1. trm_rep (trm_rep (Var z \\<lhd> \\<sigma>) S) S \\<noteq>\n    trm_rep (Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) S", "using trm_rep_involutive"], ["proof (prove)\nusing this:\n  trm_rep (Var z \\<lhd> \\<sigma>) S \\<noteq>\n  trm_rep (Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) S\n  trm_rep (trm_rep ?t ?S) ?S = trm_rep ?t ?S\n\ngoal (1 subgoal):\n 1. trm_rep (trm_rep (Var z \\<lhd> \\<sigma>) S) S \\<noteq>\n    trm_rep (Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) S", "by metis"], ["proof (state)\nthis:\n  trm_rep (trm_rep (Var z \\<lhd> \\<sigma>) S) S \\<noteq>\n  trm_rep (Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) S\n\ngoal (1 subgoal):\n 1. \\<not> equivalent_on \\<sigma>\n            (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\n            (vars_of_cl (cl_ecl C)) (int_clset S) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  trm_rep (trm_rep (Var z \\<lhd> \\<sigma>) S) S \\<noteq>\n  trm_rep (Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) S", "have \"(subst (Var z) \\<sigma>) = (subst (Var z) ?\\<theta>)\""], ["proof (prove)\nusing this:\n  trm_rep (trm_rep (Var z \\<lhd> \\<sigma>) S) S \\<noteq>\n  trm_rep (Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) S\n\ngoal (1 subgoal):\n 1. Var z \\<lhd> \\<sigma> =\n    Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>", "using map_subst_lemma [of z \\<sigma> \"\\<lambda>x. (trm_rep x S)\"]"], ["proof (prove)\nusing this:\n  trm_rep (trm_rep (Var z \\<lhd> \\<sigma>) S) S \\<noteq>\n  trm_rep (Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) S\n  Var z \\<lhd> \\<sigma> \\<noteq> Var z \\<or>\n  Var z \\<lhd> \\<sigma> \\<noteq>\n  Var z \\<lhd>\n  map_subst (\\<lambda>x. trm_rep x S) \\<sigma> \\<longrightarrow>\n  Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma> =\n  trm_rep (Var z \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. Var z \\<lhd> \\<sigma> =\n    Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>", "by metis"], ["proof (state)\nthis:\n  Var z \\<lhd> \\<sigma> =\n  Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> equivalent_on \\<sigma>\n            (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\n            (vars_of_cl (cl_ecl C)) (int_clset S) \\<Longrightarrow>\n    False", "from this and \\<open>\\<not> (?I (subst (Var z) \\<sigma>)  (subst (Var z) ?\\<theta>))\\<close>"], ["proof (chain)\npicking this:\n  Var z \\<lhd> \\<sigma> =\n  Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>\n  \\<not> int_clset S (Var z \\<lhd> \\<sigma>)\n          (Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)", "show False"], ["proof (prove)\nusing this:\n  Var z \\<lhd> \\<sigma> =\n  Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>\n  \\<not> int_clset S (Var z \\<lhd> \\<sigma>)\n          (Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\n\ngoal (1 subgoal):\n 1. False", "using \\<open>fo_interpretation ?I\\<close>"], ["proof (prove)\nusing this:\n  Var z \\<lhd> \\<sigma> =\n  Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>\n  \\<not> int_clset S (Var z \\<lhd> \\<sigma>)\n          (Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\n  fo_interpretation (int_clset S)\n\ngoal (1 subgoal):\n 1. False", "unfolding fo_interpretation_def congruence_def equivalence_relation_def reflexive_def"], ["proof (prove)\nusing this:\n  Var z \\<lhd> \\<sigma> =\n  Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>\n  \\<not> int_clset S (Var z \\<lhd> \\<sigma>)\n          (Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\n  ((\\<forall>y. int_clset S y y) \\<and>\n   symmetric (int_clset S) \\<and> transitive (int_clset S)) \\<and>\n  compatible_with_structure (int_clset S)\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  equivalent_on \\<sigma> (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\n   (vars_of_cl (cl_ecl C)) (int_clset S)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x y.\n               x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n               occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow>\n               trm_rep y S = y) \\<Longrightarrow>\n    False", "from this and \\<open>\\<not> validate_ground_clause ?I (subst_cl (cl_ecl C) \\<sigma>)\\<close>\n          \\<open>fo_interpretation ?I\\<close>"], ["proof (chain)\npicking this:\n  equivalent_on \\<sigma> (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\n   (vars_of_cl (cl_ecl C)) (int_clset S)\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n  fo_interpretation (int_clset S)", "have \"\\<not> validate_ground_clause ?I (subst_cl (cl_ecl C) ?\\<theta>)\""], ["proof (prove)\nusing this:\n  equivalent_on \\<sigma> (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\n   (vars_of_cl (cl_ecl C)) (int_clset S)\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n  fo_interpretation (int_clset S)\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_clause (int_clset S)\n            (subst_cl (cl_ecl C)\n              (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>))", "using equivalent_on_cl"], ["proof (prove)\nusing this:\n  equivalent_on \\<sigma> (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\n   (vars_of_cl (cl_ecl C)) (int_clset S)\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n  fo_interpretation (int_clset S)\n  \\<lbrakk>equivalent_on ?\\<sigma> ?\\<eta> (vars_of_cl ?C) ?I;\n   fo_interpretation ?I\\<rbrakk>\n  \\<Longrightarrow> validate_ground_clause ?I (subst_cl ?C ?\\<sigma>) =\n                    validate_ground_clause ?I (subst_cl ?C ?\\<eta>)\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_clause (int_clset S)\n            (subst_cl (cl_ecl C)\n              (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>))", "by metis"], ["proof (state)\nthis:\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl C)\n            (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x y.\n               x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n               occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow>\n               trm_rep y S = y) \\<Longrightarrow>\n    False", "have \"lower_on ?\\<theta> \\<sigma> (vars_of_cl (cl_ecl C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lower_on (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) \\<sigma>\n     (vars_of_cl (cl_ecl C))", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> lower_on (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) \\<sigma>\n            (vars_of_cl (cl_ecl C)) \\<Longrightarrow>\n    False", "assume \"\\<not>lower_on ?\\<theta> \\<sigma> (vars_of_cl (cl_ecl C))\""], ["proof (state)\nthis:\n  \\<not> lower_on (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) \\<sigma>\n          (vars_of_cl (cl_ecl C))\n\ngoal (1 subgoal):\n 1. \\<not> lower_on (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) \\<sigma>\n            (vars_of_cl (cl_ecl C)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> lower_on (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) \\<sigma>\n          (vars_of_cl (cl_ecl C))", "obtain z where \"z \\<in> vars_of_cl (cl_ecl C)\" \n            and \"(subst (Var z) \\<sigma>) \\<noteq> (subst (Var z) ?\\<theta>)\"\n            and \"((subst (Var z) ?\\<theta>),(subst (Var z) \\<sigma>)) \\<notin> trm_ord\""], ["proof (prove)\nusing this:\n  \\<not> lower_on (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) \\<sigma>\n          (vars_of_cl (cl_ecl C))\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> vars_of_cl (cl_ecl C);\n         Var z \\<lhd> \\<sigma> \\<noteq>\n         Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>;\n         (Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>,\n          Var z \\<lhd> \\<sigma>)\n         \\<notin> trm_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding lower_on_def lower_or_eq_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x\\<in>vars_of_cl (cl_ecl C).\n             Var x \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma> =\n             Var x \\<lhd> \\<sigma> \\<or>\n             (Var x \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>,\n              Var x \\<lhd> \\<sigma>)\n             \\<in> trm_ord)\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> vars_of_cl (cl_ecl C);\n         Var z \\<lhd> \\<sigma> \\<noteq>\n         Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>;\n         (Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>,\n          Var z \\<lhd> \\<sigma>)\n         \\<notin> trm_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  z \\<in> vars_of_cl (cl_ecl C)\n  Var z \\<lhd> \\<sigma> \\<noteq>\n  Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>\n  (Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>,\n   Var z \\<lhd> \\<sigma>)\n  \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> lower_on (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) \\<sigma>\n            (vars_of_cl (cl_ecl C)) \\<Longrightarrow>\n    False", "from \\<open>(subst (Var z) \\<sigma>) \\<noteq> (subst (Var z) ?\\<theta>)\\<close>"], ["proof (chain)\npicking this:\n  Var z \\<lhd> \\<sigma> \\<noteq>\n  Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>", "have \n            \"(trm_rep (subst (Var z) \\<sigma>) S) = (subst (Var z) ?\\<theta>)\""], ["proof (prove)\nusing this:\n  Var z \\<lhd> \\<sigma> \\<noteq>\n  Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>\n\ngoal (1 subgoal):\n 1. trm_rep (Var z \\<lhd> \\<sigma>) S =\n    Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>", "using map_subst_lemma [of z \\<sigma> \"\\<lambda>x. (trm_rep x S)\"]"], ["proof (prove)\nusing this:\n  Var z \\<lhd> \\<sigma> \\<noteq>\n  Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>\n  Var z \\<lhd> \\<sigma> \\<noteq> Var z \\<or>\n  Var z \\<lhd> \\<sigma> \\<noteq>\n  Var z \\<lhd>\n  map_subst (\\<lambda>x. trm_rep x S) \\<sigma> \\<longrightarrow>\n  Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma> =\n  trm_rep (Var z \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. trm_rep (Var z \\<lhd> \\<sigma>) S =\n    Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>", "by metis"], ["proof (state)\nthis:\n  trm_rep (Var z \\<lhd> \\<sigma>) S =\n  Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> lower_on (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) \\<sigma>\n            (vars_of_cl (cl_ecl C)) \\<Longrightarrow>\n    False", "from this and \\<open>(subst (Var z) \\<sigma>) \\<noteq> (subst (Var z) ?\\<theta>)\\<close> \n            and \\<open>((subst (Var z) ?\\<theta>),(subst (Var z) \\<sigma>)) \\<notin> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  trm_rep (Var z \\<lhd> \\<sigma>) S =\n  Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>\n  Var z \\<lhd> \\<sigma> \\<noteq>\n  Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>\n  (Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>,\n   Var z \\<lhd> \\<sigma>)\n  \\<notin> trm_ord", "show False"], ["proof (prove)\nusing this:\n  trm_rep (Var z \\<lhd> \\<sigma>) S =\n  Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>\n  Var z \\<lhd> \\<sigma> \\<noteq>\n  Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>\n  (Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>,\n   Var z \\<lhd> \\<sigma>)\n  \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. False", "using trm_rep_is_lower"], ["proof (prove)\nusing this:\n  trm_rep (Var z \\<lhd> \\<sigma>) S =\n  Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>\n  Var z \\<lhd> \\<sigma> \\<noteq>\n  Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>\n  (Var z \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>,\n   Var z \\<lhd> \\<sigma>)\n  \\<notin> trm_ord\n  ?t \\<noteq> trm_rep ?t ?S \\<longrightarrow>\n  (trm_rep ?t ?S, ?t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lower_on (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) \\<sigma>\n   (vars_of_cl (cl_ecl C))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x y.\n               x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n               occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow>\n               trm_rep y S = y) \\<Longrightarrow>\n    False", "have \"subst (Var x) \\<sigma> \\<noteq> (Var x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Var x \\<lhd> \\<sigma> \\<noteq> Var x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Var x \\<lhd> \\<sigma> = Var x \\<Longrightarrow> False", "assume \"subst (Var x) \\<sigma> = (Var x)\""], ["proof (state)\nthis:\n  Var x \\<lhd> \\<sigma> = Var x\n\ngoal (1 subgoal):\n 1. Var x \\<lhd> \\<sigma> = Var x \\<Longrightarrow> False", "from this and \\<open>x \\<in> vars_of_cl (cl_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  Var x \\<lhd> \\<sigma> = Var x\n  x \\<in> vars_of_cl (cl_ecl C)", "have \"\\<not> (ground_on (vars_of_cl (cl_ecl C)) \\<sigma>)\""], ["proof (prove)\nusing this:\n  Var x \\<lhd> \\<sigma> = Var x\n  x \\<in> vars_of_cl (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<not> ground_on (vars_of_cl (cl_ecl C)) \\<sigma>", "unfolding ground_on_def ground_term_def"], ["proof (prove)\nusing this:\n  Var x \\<lhd> \\<sigma> = Var x\n  x \\<in> vars_of_cl (cl_ecl C)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>vars_of_cl (cl_ecl C).\n               vars_of (Var x \\<lhd> \\<sigma>) = {})", "by auto"], ["proof (state)\nthis:\n  \\<not> ground_on (vars_of_cl (cl_ecl C)) \\<sigma>\n\ngoal (1 subgoal):\n 1. Var x \\<lhd> \\<sigma> = Var x \\<Longrightarrow> False", "from this and \\<open>ground_clause (subst_cl (cl_ecl C) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> ground_on (vars_of_cl (cl_ecl C)) \\<sigma>\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)", "show False"], ["proof (prove)\nusing this:\n  \\<not> ground_on (vars_of_cl (cl_ecl C)) \\<sigma>\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. False", "using ground_clauses_and_ground_substs"], ["proof (prove)\nusing this:\n  \\<not> ground_on (vars_of_cl (cl_ecl C)) \\<sigma>\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n  ground_clause (subst_cl ?C ?\\<sigma>) \\<Longrightarrow>\n  ground_on (vars_of_cl ?C) ?\\<sigma>\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Var x \\<lhd> \\<sigma> \\<noteq> Var x\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x y.\n               x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n               occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow>\n               trm_rep y S = y) \\<Longrightarrow>\n    False", "from \\<open>subst (Var x) \\<sigma> \\<noteq> (Var x)\\<close>"], ["proof (chain)\npicking this:\n  Var x \\<lhd> \\<sigma> \\<noteq> Var x", "have \"(trm_rep (subst (Var x) \\<sigma>) S) = (subst (Var x) ?\\<theta>)\""], ["proof (prove)\nusing this:\n  Var x \\<lhd> \\<sigma> \\<noteq> Var x\n\ngoal (1 subgoal):\n 1. trm_rep (Var x \\<lhd> \\<sigma>) S =\n    Var x \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>", "using map_subst_lemma [of x \\<sigma> \"\\<lambda>x. (trm_rep x S)\"]"], ["proof (prove)\nusing this:\n  Var x \\<lhd> \\<sigma> \\<noteq> Var x\n  Var x \\<lhd> \\<sigma> \\<noteq> Var x \\<or>\n  Var x \\<lhd> \\<sigma> \\<noteq>\n  Var x \\<lhd>\n  map_subst (\\<lambda>x. trm_rep x S) \\<sigma> \\<longrightarrow>\n  Var x \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma> =\n  trm_rep (Var x \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. trm_rep (Var x \\<lhd> \\<sigma>) S =\n    Var x \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>", "by metis"], ["proof (state)\nthis:\n  trm_rep (Var x \\<lhd> \\<sigma>) S =\n  Var x \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x y.\n               x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n               occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow>\n               trm_rep y S = y) \\<Longrightarrow>\n    False", "from this and \\<open>trm_rep (subst (Var x) \\<sigma>) S \\<noteq> (subst (Var x) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  trm_rep (Var x \\<lhd> \\<sigma>) S =\n  Var x \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>\n  trm_rep (Var x \\<lhd> \\<sigma>) S \\<noteq> Var x \\<lhd> \\<sigma>", "have \"((subst (Var x) ?\\<theta>),(subst (Var x) \\<sigma>)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  trm_rep (Var x \\<lhd> \\<sigma>) S =\n  Var x \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>\n  trm_rep (Var x \\<lhd> \\<sigma>) S \\<noteq> Var x \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. (Var x \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>,\n     Var x \\<lhd> \\<sigma>)\n    \\<in> trm_ord", "using trm_rep_is_lower"], ["proof (prove)\nusing this:\n  trm_rep (Var x \\<lhd> \\<sigma>) S =\n  Var x \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>\n  trm_rep (Var x \\<lhd> \\<sigma>) S \\<noteq> Var x \\<lhd> \\<sigma>\n  ?t \\<noteq> trm_rep ?t ?S \\<longrightarrow>\n  (trm_rep ?t ?S, ?t) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (Var x \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>,\n     Var x \\<lhd> \\<sigma>)\n    \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (Var x \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>,\n   Var x \\<lhd> \\<sigma>)\n  \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x y.\n               x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n               occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow>\n               trm_rep y S = y) \\<Longrightarrow>\n    False", "from \\<open>lower_on ?\\<theta> \\<sigma> (vars_of_cl (cl_ecl C))\\<close> and \\<open>x \\<in> vars_of_cl (cl_ecl C)\\<close> \n          \\<open>finite (cl_ecl C)\\<close> \n          and \\<open>((subst (Var x) ?\\<theta>),(subst (Var x) \\<sigma>)) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  lower_on (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) \\<sigma>\n   (vars_of_cl (cl_ecl C))\n  x \\<in> vars_of_cl (cl_ecl C)\n  finite (cl_ecl C)\n  (Var x \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>,\n   Var x \\<lhd> \\<sigma>)\n  \\<in> trm_ord", "have \"((C,?\\<theta>), (C, \\<sigma>)) \\<in> ecl_ord\""], ["proof (prove)\nusing this:\n  lower_on (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) \\<sigma>\n   (vars_of_cl (cl_ecl C))\n  x \\<in> vars_of_cl (cl_ecl C)\n  finite (cl_ecl C)\n  (Var x \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>,\n   Var x \\<lhd> \\<sigma>)\n  \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. ((C, map_subst (\\<lambda>x. trm_rep x S) \\<sigma>), C, \\<sigma>)\n    \\<in> ecl_ord", "using lower_on_cl"], ["proof (prove)\nusing this:\n  lower_on (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) \\<sigma>\n   (vars_of_cl (cl_ecl C))\n  x \\<in> vars_of_cl (cl_ecl C)\n  finite (cl_ecl C)\n  (Var x \\<lhd> map_subst (\\<lambda>x. trm_rep x S) \\<sigma>,\n   Var x \\<lhd> \\<sigma>)\n  \\<in> trm_ord\n  \\<lbrakk>lower_on ?\\<sigma> ?\\<eta> (vars_of_cl (cl_ecl ?C));\n   (Var ?x \\<lhd> ?\\<sigma>, Var ?x \\<lhd> ?\\<eta>) \\<in> trm_ord;\n   ?x \\<in> vars_of_cl (cl_ecl ?C); finite (cl_ecl ?C)\\<rbrakk>\n  \\<Longrightarrow> ((?C, ?\\<sigma>), ?C, ?\\<eta>) \\<in> ecl_ord\n\ngoal (1 subgoal):\n 1. ((C, map_subst (\\<lambda>x. trm_rep x S) \\<sigma>), C, \\<sigma>)\n    \\<in> ecl_ord", "by blast"], ["proof (state)\nthis:\n  ((C, map_subst (\\<lambda>x. trm_rep x S) \\<sigma>), C, \\<sigma>)\n  \\<in> ecl_ord\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x y.\n               x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n               occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow>\n               trm_rep y S = y) \\<Longrightarrow>\n    False", "from \\<open>C = fst pair\\<close> \\<open>\\<sigma> = snd pair\\<close>"], ["proof (chain)\npicking this:\n  C = fst pair\n  \\<sigma> = snd pair", "have \"pair = (C,\\<sigma>)\""], ["proof (prove)\nusing this:\n  C = fst pair\n  \\<sigma> = snd pair\n\ngoal (1 subgoal):\n 1. pair = (C, \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  pair = (C, \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x y.\n               x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n               occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow>\n               trm_rep y S = y) \\<Longrightarrow>\n    False", "from this  and \\<open>((C,?\\<theta>), (C, \\<sigma>)) \\<in> ecl_ord\\<close>"], ["proof (chain)\npicking this:\n  pair = (C, \\<sigma>)\n  ((C, map_subst (\\<lambda>x. trm_rep x S) \\<sigma>), C, \\<sigma>)\n  \\<in> ecl_ord", "have \n          \"((C,?\\<theta>),pair) \\<in> ecl_ord\""], ["proof (prove)\nusing this:\n  pair = (C, \\<sigma>)\n  ((C, map_subst (\\<lambda>x. trm_rep x S) \\<sigma>), C, \\<sigma>)\n  \\<in> ecl_ord\n\ngoal (1 subgoal):\n 1. ((C, map_subst (\\<lambda>x. trm_rep x S) \\<sigma>), pair) \\<in> ecl_ord", "by metis"], ["proof (state)\nthis:\n  ((C, map_subst (\\<lambda>x. trm_rep x S) \\<sigma>), pair) \\<in> ecl_ord\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x y.\n               x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n               occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow>\n               trm_rep y S = y) \\<Longrightarrow>\n    False", "from this and hyp_ind"], ["proof (chain)\npicking this:\n  ((C, map_subst (\\<lambda>x. trm_rep x S) \\<sigma>), pair) \\<in> ecl_ord\n  \\<forall>y.\n     (y, pair) \\<in> ecl_ord \\<longrightarrow>\n     (\\<forall>C \\<sigma>.\n         fst y = C \\<longrightarrow>\n         \\<sigma> = snd y \\<longrightarrow>\n         C \\<in> S \\<longrightarrow>\n         ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n         all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n          (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n         validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n          (subst_cl (cl_ecl C) \\<sigma>))", "have \"?P (C,?\\<theta>)\""], ["proof (prove)\nusing this:\n  ((C, map_subst (\\<lambda>x. trm_rep x S) \\<sigma>), pair) \\<in> ecl_ord\n  \\<forall>y.\n     (y, pair) \\<in> ecl_ord \\<longrightarrow>\n     (\\<forall>C \\<sigma>.\n         fst y = C \\<longrightarrow>\n         \\<sigma> = snd y \\<longrightarrow>\n         C \\<in> S \\<longrightarrow>\n         ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n         all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n          (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n         validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n          (subst_cl (cl_ecl C) \\<sigma>))\n\ngoal (1 subgoal):\n 1. \\<forall>Ca \\<sigma>'.\n       fst (C, map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) =\n       Ca \\<longrightarrow>\n       \\<sigma>' =\n       snd (C, map_subst (\\<lambda>x. trm_rep x S)\n                \\<sigma>) \\<longrightarrow>\n       Ca \\<in> S \\<longrightarrow>\n       ground_clause (subst_cl (cl_ecl Ca) \\<sigma>') \\<longrightarrow>\n       all_trms_irreducible (subst_set (trms_ecl Ca) \\<sigma>')\n        (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n       validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n        (subst_cl (cl_ecl Ca) \\<sigma>')", "by blast"], ["proof (state)\nthis:\n  \\<forall>Ca \\<sigma>'.\n     fst (C, map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) =\n     Ca \\<longrightarrow>\n     \\<sigma>' =\n     snd (C, map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) \\<longrightarrow>\n     Ca \\<in> S \\<longrightarrow>\n     ground_clause (subst_cl (cl_ecl Ca) \\<sigma>') \\<longrightarrow>\n     all_trms_irreducible (subst_set (trms_ecl Ca) \\<sigma>')\n      (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n     validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n      (subst_cl (cl_ecl Ca) \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x y.\n               x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n               occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow>\n               trm_rep y S = y) \\<Longrightarrow>\n    False", "from \\<open>(all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>) \n                  (\\<lambda>t. (trm_rep t S)))\\<close>\n              \\<open>lower_on ?\\<theta> \\<sigma> (vars_of_cl (cl_ecl C))\\<close> \\<open>C \\<in> S\\<close> \\<open>fo_interpretation ?I\\<close>\n              \\<open>equivalent_on \\<sigma> ?\\<theta> (vars_of_cl (cl_ecl C)) ?I\\<close> assms(3)"], ["proof (chain)\npicking this:\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n  lower_on (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) \\<sigma>\n   (vars_of_cl (cl_ecl C))\n  C \\<in> S\n  fo_interpretation (int_clset S)\n  equivalent_on \\<sigma> (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\n   (vars_of_cl (cl_ecl C)) (int_clset S)\n  Ball S well_constrained", "have \"(all_trms_irreducible (subst_set (trms_ecl C) ?\\<theta>) \n                  (\\<lambda>t. (trm_rep t S)))\""], ["proof (prove)\nusing this:\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n  lower_on (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) \\<sigma>\n   (vars_of_cl (cl_ecl C))\n  C \\<in> S\n  fo_interpretation (int_clset S)\n  equivalent_on \\<sigma> (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\n   (vars_of_cl (cl_ecl C)) (int_clset S)\n  Ball S well_constrained\n\ngoal (1 subgoal):\n 1. all_trms_irreducible\n     (subst_set (trms_ecl C) (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>))\n     (\\<lambda>t. trm_rep t S)", "using irred_terms_and_reduced_subst"], ["proof (prove)\nusing this:\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n  lower_on (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) \\<sigma>\n   (vars_of_cl (cl_ecl C))\n  C \\<in> S\n  fo_interpretation (int_clset S)\n  equivalent_on \\<sigma> (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\n   (vars_of_cl (cl_ecl C)) (int_clset S)\n  Ball S well_constrained\n  \\<lbrakk>?f = (\\<lambda>t. trm_rep t ?S);\n   ?\\<eta> = map_subst ?f ?\\<sigma>;\n   all_trms_irreducible (subst_set ?E ?\\<sigma>) ?f; ?I = int_clset ?S;\n   equivalent_on ?\\<sigma> ?\\<eta> (vars_of_cl (cl_ecl ?C)) ?I;\n   lower_on ?\\<eta> ?\\<sigma> (vars_of_cl (cl_ecl ?C)); ?E = trms_ecl ?C;\n   \\<forall>x\\<in>?S.\n      \\<forall>y. y \\<in> trms_ecl x \\<longrightarrow> dom_trm y (cl_ecl x);\n   ?C \\<in> ?S; fo_interpretation ?I\\<rbrakk>\n  \\<Longrightarrow> all_trms_irreducible (subst_set ?E ?\\<eta>) ?f\n\ngoal (1 subgoal):\n 1. all_trms_irreducible\n     (subst_set (trms_ecl C) (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>))\n     (\\<lambda>t. trm_rep t S)", "unfolding Ball_def well_constrained_def"], ["proof (prove)\nusing this:\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n  lower_on (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) \\<sigma>\n   (vars_of_cl (cl_ecl C))\n  C \\<in> S\n  fo_interpretation (int_clset S)\n  equivalent_on \\<sigma> (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\n   (vars_of_cl (cl_ecl C)) (int_clset S)\n  \\<forall>x.\n     x \\<in> S \\<longrightarrow>\n     (\\<forall>y. y \\<in> trms_ecl x \\<longrightarrow> dom_trm y (cl_ecl x))\n  \\<lbrakk>?f = (\\<lambda>t. trm_rep t ?S);\n   ?\\<eta> = map_subst ?f ?\\<sigma>;\n   all_trms_irreducible (subst_set ?E ?\\<sigma>) ?f; ?I = int_clset ?S;\n   equivalent_on ?\\<sigma> ?\\<eta> (vars_of_cl (cl_ecl ?C)) ?I;\n   lower_on ?\\<eta> ?\\<sigma> (vars_of_cl (cl_ecl ?C)); ?E = trms_ecl ?C;\n   \\<forall>x.\n      x \\<in> ?S \\<longrightarrow>\n      (\\<forall>y.\n          y \\<in> trms_ecl x \\<longrightarrow> dom_trm y (cl_ecl x));\n   ?C \\<in> ?S; fo_interpretation ?I\\<rbrakk>\n  \\<Longrightarrow> all_trms_irreducible (subst_set ?E ?\\<eta>) ?f\n\ngoal (1 subgoal):\n 1. all_trms_irreducible\n     (subst_set (trms_ecl C) (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>))\n     (\\<lambda>t. trm_rep t S)", "by metis"], ["proof (state)\nthis:\n  all_trms_irreducible\n   (subst_set (trms_ecl C) (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>))\n   (\\<lambda>t. trm_rep t S)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x y.\n               x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n               occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow>\n               trm_rep y S = y) \\<Longrightarrow>\n    False", "have \"ground_clause (subst_cl (cl_ecl C) ?\\<theta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ground_clause\n     (subst_cl (cl_ecl C) (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ground_clause\n     (subst_cl (cl_ecl C) (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>))", "from \\<open>ground_clause (subst_cl (cl_ecl C) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)", "have \"ground_on (vars_of_cl (cl_ecl C)) \\<sigma>\""], ["proof (prove)\nusing this:\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. ground_on (vars_of_cl (cl_ecl C)) \\<sigma>", "using ground_clauses_and_ground_substs"], ["proof (prove)\nusing this:\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n  ground_clause (subst_cl ?C ?\\<sigma>) \\<Longrightarrow>\n  ground_on (vars_of_cl ?C) ?\\<sigma>\n\ngoal (1 subgoal):\n 1. ground_on (vars_of_cl (cl_ecl C)) \\<sigma>", "by auto"], ["proof (state)\nthis:\n  ground_on (vars_of_cl (cl_ecl C)) \\<sigma>\n\ngoal (1 subgoal):\n 1. ground_clause\n     (subst_cl (cl_ecl C) (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>))", "from this and \\<open>lower_on ?\\<theta> \\<sigma> (vars_of_cl (cl_ecl C))\\<close>"], ["proof (chain)\npicking this:\n  ground_on (vars_of_cl (cl_ecl C)) \\<sigma>\n  lower_on (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) \\<sigma>\n   (vars_of_cl (cl_ecl C))", "have \"ground_on (vars_of_cl (cl_ecl C)) ?\\<theta>\""], ["proof (prove)\nusing this:\n  ground_on (vars_of_cl (cl_ecl C)) \\<sigma>\n  lower_on (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) \\<sigma>\n   (vars_of_cl (cl_ecl C))\n\ngoal (1 subgoal):\n 1. ground_on (vars_of_cl (cl_ecl C))\n     (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)", "using lower_on_ground"], ["proof (prove)\nusing this:\n  ground_on (vars_of_cl (cl_ecl C)) \\<sigma>\n  lower_on (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) \\<sigma>\n   (vars_of_cl (cl_ecl C))\n  \\<lbrakk>lower_on ?\\<sigma> ?\\<eta> ?V; ground_on ?V ?\\<eta>\\<rbrakk>\n  \\<Longrightarrow> ground_on ?V ?\\<sigma>\n\ngoal (1 subgoal):\n 1. ground_on (vars_of_cl (cl_ecl C))\n     (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)", "by meson"], ["proof (state)\nthis:\n  ground_on (vars_of_cl (cl_ecl C))\n   (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\n\ngoal (1 subgoal):\n 1. ground_clause\n     (subst_cl (cl_ecl C) (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>))", "from this"], ["proof (chain)\npicking this:\n  ground_on (vars_of_cl (cl_ecl C))\n   (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)", "show ?thesis"], ["proof (prove)\nusing this:\n  ground_on (vars_of_cl (cl_ecl C))\n   (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\n\ngoal (1 subgoal):\n 1. ground_clause\n     (subst_cl (cl_ecl C) (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>))", "using ground_substs_yield_ground_clause"], ["proof (prove)\nusing this:\n  ground_on (vars_of_cl (cl_ecl C))\n   (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>)\n  ground_on (vars_of_cl ?C) ?\\<sigma> \\<Longrightarrow>\n  ground_clause (subst_cl ?C ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. ground_clause\n     (subst_cl (cl_ecl C) (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>))", "by metis"], ["proof (state)\nthis:\n  ground_clause\n   (subst_cl (cl_ecl C) (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ground_clause\n   (subst_cl (cl_ecl C) (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x y.\n               x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n               occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow>\n               trm_rep y S = y) \\<Longrightarrow>\n    False", "from this \n          \\<open>(all_trms_irreducible (subst_set (trms_ecl C) ?\\<theta>) (\\<lambda>t. (trm_rep t S)))\\<close> \n          \\<open>?P (C,?\\<theta>)\\<close> \\<open>\\<not> validate_ground_clause ?I (subst_cl (cl_ecl C) ?\\<theta>)\\<close> \n          \\<open>C \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  ground_clause\n   (subst_cl (cl_ecl C) (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>))\n  all_trms_irreducible\n   (subst_set (trms_ecl C) (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>))\n   (\\<lambda>t. trm_rep t S)\n  \\<forall>Ca \\<sigma>'.\n     fst (C, map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) =\n     Ca \\<longrightarrow>\n     \\<sigma>' =\n     snd (C, map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) \\<longrightarrow>\n     Ca \\<in> S \\<longrightarrow>\n     ground_clause (subst_cl (cl_ecl Ca) \\<sigma>') \\<longrightarrow>\n     all_trms_irreducible (subst_set (trms_ecl Ca) \\<sigma>')\n      (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n     validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n      (subst_cl (cl_ecl Ca) \\<sigma>')\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl C)\n            (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>))\n  C \\<in> S", "show False"], ["proof (prove)\nusing this:\n  ground_clause\n   (subst_cl (cl_ecl C) (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>))\n  all_trms_irreducible\n   (subst_set (trms_ecl C) (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>))\n   (\\<lambda>t. trm_rep t S)\n  \\<forall>Ca \\<sigma>'.\n     fst (C, map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) =\n     Ca \\<longrightarrow>\n     \\<sigma>' =\n     snd (C, map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) \\<longrightarrow>\n     Ca \\<in> S \\<longrightarrow>\n     ground_clause (subst_cl (cl_ecl Ca) \\<sigma>') \\<longrightarrow>\n     all_trms_irreducible (subst_set (trms_ecl Ca) \\<sigma>')\n      (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n     validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n      (subst_cl (cl_ecl Ca) \\<sigma>')\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl C)\n            (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>))\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. False", "unfolding int_clset_def"], ["proof (prove)\nusing this:\n  ground_clause\n   (subst_cl (cl_ecl C) (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>))\n  all_trms_irreducible\n   (subst_set (trms_ecl C) (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>))\n   (\\<lambda>t. trm_rep t S)\n  \\<forall>Ca \\<sigma>'.\n     fst (C, map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) =\n     Ca \\<longrightarrow>\n     \\<sigma>' =\n     snd (C, map_subst (\\<lambda>x. trm_rep x S) \\<sigma>) \\<longrightarrow>\n     Ca \\<in> S \\<longrightarrow>\n     ground_clause (subst_cl (cl_ecl Ca) \\<sigma>') \\<longrightarrow>\n     all_trms_irreducible (subst_set (trms_ecl Ca) \\<sigma>')\n      (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n     validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n      (subst_cl (cl_ecl Ca) \\<sigma>')\n  \\<not> validate_ground_clause (same_values (\\<lambda>x. trm_rep x S))\n          (subst_cl (cl_ecl C)\n            (map_subst (\\<lambda>x. trm_rep x S) \\<sigma>))\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. False", "by (metis fst_conv snd_conv)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x y.\n     x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n     occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow> trm_rep y S = y\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "text \\<open>Next, we show that the eligible term @{term \"t\"} is in normal form. \nWe first need to establish the result for proper subterms of @{term \"t\"} before considering \nthe general case.\\<close>"], ["proof (state)\nthis:\n  \\<forall>x y.\n     x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n     occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow> trm_rep y S = y\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "have \"\\<not>(proper_subterm_red t S \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> proper_subterm_red t S \\<sigma>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. proper_subterm_red t S \\<sigma> \\<Longrightarrow> False", "assume \"(proper_subterm_red t S \\<sigma>)\""], ["proof (state)\nthis:\n  proper_subterm_red t S \\<sigma>\n\ngoal (1 subgoal):\n 1. proper_subterm_red t S \\<sigma> \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  proper_subterm_red t S \\<sigma>", "have \"trm_rep (subst t \\<sigma>) S \\<noteq> subst t \\<sigma>\""], ["proof (prove)\nusing this:\n  proper_subterm_red t S \\<sigma>\n\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> t \\<lhd> \\<sigma>", "using proper_subterm_red_def substs_preserve_subterms subts_of_irred_trms_are_irred"], ["proof (prove)\nusing this:\n  proper_subterm_red t S \\<sigma>\n  proper_subterm_red ?t ?S ?\\<sigma> =\n  (\\<exists>p s.\n      subterm ?t p s \\<and>\n      p \\<noteq> [] \\<and>\n      trm_rep (s \\<lhd> ?\\<sigma>) ?S \\<noteq> s \\<lhd> ?\\<sigma>)\n  subterm ?t ?p ?s \\<Longrightarrow>\n  subterm (?t \\<lhd> ?\\<sigma>) ?p (?s \\<lhd> ?\\<sigma>)\n  trm_rep ?y ?S \\<noteq> ?y \\<Longrightarrow>\n  subterm ?x ?p ?y \\<longrightarrow> trm_rep ?x ?S \\<noteq> ?x\n\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> t \\<lhd> \\<sigma>", "by blast"], ["proof (state)\nthis:\n  trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> t \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. proper_subterm_red t S \\<sigma> \\<Longrightarrow> False", "from \\<open>(proper_subterm_red t S \\<sigma>)\\<close>\n          \\<open>\\<forall>x y. \n        ((x \\<in> vars_of_cl (cl_ecl C)) \\<longrightarrow> occurs_in y (subst (Var x) \\<sigma>) \\<longrightarrow> trm_rep y S = y)\\<close> \n        \\<open>eligible_literal L C \\<sigma>\\<close>\n        \\<open>trm_rep (subst t \\<sigma>) S \\<noteq> subst t \\<sigma>\\<close> \\<open>L \\<in> cl_ecl C\\<close> \n        \\<open>orient_lit_inst L t s p \\<sigma>\\<close> \\<open>\\<forall>x\\<in>S. finite (cl_ecl x)\\<close> \n        \\<open>ground_clause (subst_cl (cl_ecl C) \\<sigma>)\\<close>\n        \\<open>fo_interpretation (int_clset S)\\<close> \n        \\<open>Ball S well_constrained\\<close> \\<open>C \\<in> S\\<close>\n        \\<open>all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>) (\\<lambda>t. trm_rep t S)\\<close>\n        \\<open>\\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\\<close>\n        \\<open>closed_under_renaming S\\<close>"], ["proof (chain)\npicking this:\n  proper_subterm_red t S \\<sigma>\n  \\<forall>x y.\n     x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n     occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow> trm_rep y S = y\n  eligible_literal L C \\<sigma>\n  trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> t \\<lhd> \\<sigma>\n  L \\<in> cl_ecl C\n  orient_lit_inst L t s p \\<sigma>\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n  fo_interpretation (int_clset S)\n  Ball S well_constrained\n  C \\<in> S\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n  closed_under_renaming S", "have \"\n            \\<exists>\\<sigma>'' u u' pa v D L2. (reduction L C \\<sigma>'' t s p L2 u u' pa v D \n              (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and> variable_disjoint C D)\""], ["proof (prove)\nusing this:\n  proper_subterm_red t S \\<sigma>\n  \\<forall>x y.\n     x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n     occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow> trm_rep y S = y\n  eligible_literal L C \\<sigma>\n  trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> t \\<lhd> \\<sigma>\n  L \\<in> cl_ecl C\n  orient_lit_inst L t s p \\<sigma>\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n  fo_interpretation (int_clset S)\n  Ball S well_constrained\n  C \\<in> S\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n  closed_under_renaming S\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>'' u u' pa v D L2.\n       reduction L C \\<sigma>'' t s p L2 u u' pa v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "using reduction_exists [of p t s C S \\<sigma> L]"], ["proof (prove)\nusing this:\n  proper_subterm_red t S \\<sigma>\n  \\<forall>x y.\n     x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n     occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow> trm_rep y S = y\n  eligible_literal L C \\<sigma>\n  trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> t \\<lhd> \\<sigma>\n  L \\<in> cl_ecl C\n  orient_lit_inst L t s p \\<sigma>\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n  fo_interpretation (int_clset S)\n  Ball S well_constrained\n  C \\<in> S\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n  closed_under_renaming S\n  \\<lbrakk>p = neg \\<or>\n           \\<not> equivalent_eq_exists t s (cl_ecl C) (int_clset S) \\<sigma>\n                   L \\<or>\n           proper_subterm_red t S \\<sigma>;\n   \\<forall>x y.\n      x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n      occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow> trm_rep y S = y;\n   eligible_literal L C \\<sigma>;\n   trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> t \\<lhd> \\<sigma>;\n   L \\<in> cl_ecl C; orient_lit_inst L t s p \\<sigma>;\n   \\<forall>x\\<in>S. finite (cl_ecl x);\n   ground_clause (subst_cl (cl_ecl C) \\<sigma>);\n   fo_interpretation (same_values (\\<lambda>t. trm_rep t S)); C \\<in> S;\n   Ball S well_constrained;\n   all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n    (\\<lambda>t. trm_rep t S);\n   \\<not> validate_ground_clause (int_clset S)\n           (subst_cl (cl_ecl C) \\<sigma>);\n   closed_under_renaming S\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<sigma>' u u' pa v D L2.\n                       reduction L C \\<sigma>' t s p L2 u u' pa v D\n                        (same_values (\\<lambda>t. trm_rep t S)) S\n                        \\<sigma> \\<and>\n                       variable_disjoint C D\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>'' u u' pa v D L2.\n       reduction L C \\<sigma>'' t s p L2 u u' pa v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "unfolding int_clset_def"], ["proof (prove)\nusing this:\n  proper_subterm_red t S \\<sigma>\n  \\<forall>x y.\n     x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n     occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow> trm_rep y S = y\n  eligible_literal L C \\<sigma>\n  trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> t \\<lhd> \\<sigma>\n  L \\<in> cl_ecl C\n  orient_lit_inst L t s p \\<sigma>\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n  fo_interpretation (same_values (\\<lambda>x. trm_rep x S))\n  Ball S well_constrained\n  C \\<in> S\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n  \\<not> validate_ground_clause (same_values (\\<lambda>x. trm_rep x S))\n          (subst_cl (cl_ecl C) \\<sigma>)\n  closed_under_renaming S\n  \\<lbrakk>p = neg \\<or>\n           \\<not> equivalent_eq_exists t s (cl_ecl C)\n                   (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L \\<or>\n           proper_subterm_red t S \\<sigma>;\n   \\<forall>x y.\n      x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n      occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow> trm_rep y S = y;\n   eligible_literal L C \\<sigma>;\n   trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> t \\<lhd> \\<sigma>;\n   L \\<in> cl_ecl C; orient_lit_inst L t s p \\<sigma>;\n   \\<forall>x\\<in>S. finite (cl_ecl x);\n   ground_clause (subst_cl (cl_ecl C) \\<sigma>);\n   fo_interpretation (same_values (\\<lambda>t. trm_rep t S)); C \\<in> S;\n   Ball S well_constrained;\n   all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n    (\\<lambda>t. trm_rep t S);\n   \\<not> validate_ground_clause (same_values (\\<lambda>x. trm_rep x S))\n           (subst_cl (cl_ecl C) \\<sigma>);\n   closed_under_renaming S\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<sigma>' u u' pa v D L2.\n                       reduction L C \\<sigma>' t s p L2 u u' pa v D\n                        (same_values (\\<lambda>t. trm_rep t S)) S\n                        \\<sigma> \\<and>\n                       variable_disjoint C D\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>'' u u' pa v D L2.\n       reduction L C \\<sigma>'' t s p L2 u u' pa v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>'' u u' pa v D L2.\n     reduction L C \\<sigma>'' t s p L2 u u' pa v D\n      (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n     variable_disjoint C D\n\ngoal (1 subgoal):\n 1. proper_subterm_red t S \\<sigma> \\<Longrightarrow> False", "from this and \\<open>?nored\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>\\<sigma>'' u u' pa v D L2.\n     reduction L C \\<sigma>'' t s p L2 u u' pa v D\n      (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n     variable_disjoint C D\n  \\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n     \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n              (int_clset S) S \\<sigma> \\<and>\n             variable_disjoint C D)", "show False"], ["proof (prove)\nusing this:\n  \\<exists>\\<sigma>'' u u' pa v D L2.\n     reduction L C \\<sigma>'' t s p L2 u u' pa v D\n      (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n     variable_disjoint C D\n  \\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n     \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n              (int_clset S) S \\<sigma> \\<and>\n             variable_disjoint C D)\n\ngoal (1 subgoal):\n 1. False", "unfolding int_clset_def"], ["proof (prove)\nusing this:\n  \\<exists>\\<sigma>'' u u' pa v D L2.\n     reduction L C \\<sigma>'' t s p L2 u u' pa v D\n      (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n     variable_disjoint C D\n  \\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n     \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n              (same_values (\\<lambda>x. trm_rep x S)) S \\<sigma> \\<and>\n             variable_disjoint C D)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> proper_subterm_red t S \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "have \"p = neg \\<or> \\<not> equivalent_eq_exists t s (cl_ecl C) (same_values (\\<lambda>x. trm_rep x S)) \\<sigma>\n        L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = neg \\<or>\n    \\<not> equivalent_eq_exists t s (cl_ecl C)\n            (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (p = neg \\<or>\n            \\<not> equivalent_eq_exists t s (cl_ecl C)\n                    (same_values (\\<lambda>x. trm_rep x S)) \\<sigma>\n                    L) \\<Longrightarrow>\n    False", "assume neg: \"\\<not> (p = neg \\<or> \\<not> equivalent_eq_exists t s (cl_ecl C) \n            (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L)\""], ["proof (state)\nthis:\n  \\<not> (p = neg \\<or>\n          \\<not> equivalent_eq_exists t s (cl_ecl C)\n                  (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L)\n\ngoal (1 subgoal):\n 1. \\<not> (p = neg \\<or>\n            \\<not> equivalent_eq_exists t s (cl_ecl C)\n                    (same_values (\\<lambda>x. trm_rep x S)) \\<sigma>\n                    L) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (p = neg \\<or>\n          \\<not> equivalent_eq_exists t s (cl_ecl C)\n                  (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L)", "have \"p \\<noteq> neg\""], ["proof (prove)\nusing this:\n  \\<not> (p = neg \\<or>\n          \\<not> equivalent_eq_exists t s (cl_ecl C)\n                  (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L)\n\ngoal (1 subgoal):\n 1. p \\<noteq> neg", "by metis"], ["proof (state)\nthis:\n  p \\<noteq> neg\n\ngoal (1 subgoal):\n 1. \\<not> (p = neg \\<or>\n            \\<not> equivalent_eq_exists t s (cl_ecl C)\n                    (same_values (\\<lambda>x. trm_rep x S)) \\<sigma>\n                    L) \\<Longrightarrow>\n    False", "from neg"], ["proof (chain)\npicking this:\n  \\<not> (p = neg \\<or>\n          \\<not> equivalent_eq_exists t s (cl_ecl C)\n                  (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L)", "have \"equivalent_eq_exists t s (cl_ecl C) (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L\""], ["proof (prove)\nusing this:\n  \\<not> (p = neg \\<or>\n          \\<not> equivalent_eq_exists t s (cl_ecl C)\n                  (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L)\n\ngoal (1 subgoal):\n 1. equivalent_eq_exists t s (cl_ecl C)\n     (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L", "by metis"], ["proof (state)\nthis:\n  equivalent_eq_exists t s (cl_ecl C)\n   (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L\n\ngoal (1 subgoal):\n 1. \\<not> (p = neg \\<or>\n            \\<not> equivalent_eq_exists t s (cl_ecl C)\n                    (same_values (\\<lambda>x. trm_rep x S)) \\<sigma>\n                    L) \\<Longrightarrow>\n    False", "from \\<open>p \\<noteq> neg\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> neg", "have \"p = pos\""], ["proof (prove)\nusing this:\n  p \\<noteq> neg\n\ngoal (1 subgoal):\n 1. p = pos", "using sign.exhaust"], ["proof (prove)\nusing this:\n  p \\<noteq> neg\n  \\<lbrakk>?y = pos \\<Longrightarrow> ?P;\n   ?y = neg \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. p = pos", "by auto"], ["proof (state)\nthis:\n  p = pos\n\ngoal (1 subgoal):\n 1. \\<not> (p = neg \\<or>\n            \\<not> equivalent_eq_exists t s (cl_ecl C)\n                    (same_values (\\<lambda>x. trm_rep x S)) \\<sigma>\n                    L) \\<Longrightarrow>\n    False", "from \\<open>equivalent_eq_exists t s (cl_ecl C) (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L\\<close>"], ["proof (chain)\npicking this:\n  equivalent_eq_exists t s (cl_ecl C)\n   (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L", "obtain L2 where \"L2 \\<in> (cl_ecl C) - { L }\" and f:\"\\<exists>u v. orient_lit_inst L2 u v pos \\<sigma> \\<and>\n                subst t \\<sigma> = subst u \\<sigma> \\<and> trm_rep (subst s \\<sigma>) S = trm_rep (subst v \\<sigma>) S\""], ["proof (prove)\nusing this:\n  equivalent_eq_exists t s (cl_ecl C)\n   (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L\n\ngoal (1 subgoal):\n 1. (\\<And>L2.\n        \\<lbrakk>L2 \\<in> cl_ecl C - {L};\n         \\<exists>u v.\n            orient_lit_inst L2 u v pos \\<sigma> \\<and>\n            t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<and>\n            trm_rep (s \\<lhd> \\<sigma>) S =\n            trm_rep (v \\<lhd> \\<sigma>) S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding equivalent_eq_exists_def"], ["proof (prove)\nusing this:\n  \\<exists>L\\<in>cl_ecl C - {L}.\n     \\<exists>u v.\n        orient_lit_inst L u v pos \\<sigma> \\<and>\n        t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<and>\n        same_values (\\<lambda>x. trm_rep x S) (s \\<lhd> \\<sigma>)\n         (v \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>L2.\n        \\<lbrakk>L2 \\<in> cl_ecl C - {L};\n         \\<exists>u v.\n            orient_lit_inst L2 u v pos \\<sigma> \\<and>\n            t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<and>\n            trm_rep (s \\<lhd> \\<sigma>) S =\n            trm_rep (v \\<lhd> \\<sigma>) S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding same_values_def"], ["proof (prove)\nusing this:\n  \\<exists>L\\<in>cl_ecl C - {L}.\n     \\<exists>u v.\n        orient_lit_inst L u v pos \\<sigma> \\<and>\n        t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<and>\n        trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. (\\<And>L2.\n        \\<lbrakk>L2 \\<in> cl_ecl C - {L};\n         \\<exists>u v.\n            orient_lit_inst L2 u v pos \\<sigma> \\<and>\n            t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<and>\n            trm_rep (s \\<lhd> \\<sigma>) S =\n            trm_rep (v \\<lhd> \\<sigma>) S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  L2 \\<in> cl_ecl C - {L}\n  \\<exists>u v.\n     orient_lit_inst L2 u v pos \\<sigma> \\<and>\n     t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<and>\n     trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. \\<not> (p = neg \\<or>\n            \\<not> equivalent_eq_exists t s (cl_ecl C)\n                    (same_values (\\<lambda>x. trm_rep x S)) \\<sigma>\n                    L) \\<Longrightarrow>\n    False", "from f"], ["proof (chain)\npicking this:\n  \\<exists>u v.\n     orient_lit_inst L2 u v pos \\<sigma> \\<and>\n     t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<and>\n     trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S", "obtain u v where f': \"orient_lit_inst L2 u v pos \\<sigma> \\<and> subst t \\<sigma> = subst u \\<sigma> \n            \\<and> trm_rep (subst s \\<sigma>) S = trm_rep (subst v \\<sigma>) S\""], ["proof (prove)\nusing this:\n  \\<exists>u v.\n     orient_lit_inst L2 u v pos \\<sigma> \\<and>\n     t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<and>\n     trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        orient_lit_inst L2 u v pos \\<sigma> \\<and>\n        t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<and>\n        trm_rep (s \\<lhd> \\<sigma>) S =\n        trm_rep (v \\<lhd> \\<sigma>) S \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  orient_lit_inst L2 u v pos \\<sigma> \\<and>\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<and>\n  trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. \\<not> (p = neg \\<or>\n            \\<not> equivalent_eq_exists t s (cl_ecl C)\n                    (same_values (\\<lambda>x. trm_rep x S)) \\<sigma>\n                    L) \\<Longrightarrow>\n    False", "from f'"], ["proof (chain)\npicking this:\n  orient_lit_inst L2 u v pos \\<sigma> \\<and>\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<and>\n  trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S", "have \"orient_lit_inst L2 u v pos \\<sigma>\""], ["proof (prove)\nusing this:\n  orient_lit_inst L2 u v pos \\<sigma> \\<and>\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<and>\n  trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. orient_lit_inst L2 u v pos \\<sigma>", "by metis"], ["proof (state)\nthis:\n  orient_lit_inst L2 u v pos \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (p = neg \\<or>\n            \\<not> equivalent_eq_exists t s (cl_ecl C)\n                    (same_values (\\<lambda>x. trm_rep x S)) \\<sigma>\n                    L) \\<Longrightarrow>\n    False", "from f'"], ["proof (chain)\npicking this:\n  orient_lit_inst L2 u v pos \\<sigma> \\<and>\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<and>\n  trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S", "have \"subst t \\<sigma> = subst u \\<sigma>\""], ["proof (prove)\nusing this:\n  orient_lit_inst L2 u v pos \\<sigma> \\<and>\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<and>\n  trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>", "by metis"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (p = neg \\<or>\n            \\<not> equivalent_eq_exists t s (cl_ecl C)\n                    (same_values (\\<lambda>x. trm_rep x S)) \\<sigma>\n                    L) \\<Longrightarrow>\n    False", "from f'"], ["proof (chain)\npicking this:\n  orient_lit_inst L2 u v pos \\<sigma> \\<and>\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<and>\n  trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S", "have \"trm_rep (subst s \\<sigma>) S = trm_rep (subst v \\<sigma>) S\""], ["proof (prove)\nusing this:\n  orient_lit_inst L2 u v pos \\<sigma> \\<and>\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<and>\n  trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S", "by metis"], ["proof (state)\nthis:\n  trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. \\<not> (p = neg \\<or>\n            \\<not> equivalent_eq_exists t s (cl_ecl C)\n                    (same_values (\\<lambda>x. trm_rep x S)) \\<sigma>\n                    L) \\<Longrightarrow>\n    False", "from \\<open>orient_lit_inst L2 u v pos \\<sigma>\\<close> \\<open>subst t \\<sigma> = subst u \\<sigma>\\<close>  \n            \\<open>trm_rep (subst s \\<sigma>) S = trm_rep (subst v \\<sigma>) S\\<close> \n            \\<open>orient_lit_inst L t s p \\<sigma>\\<close> \\<open>p = pos\\<close> \\<open>L \\<in> (cl_ecl C)\\<close> \\<open>L2 \\<in> (cl_ecl C) - { L }\\<close>\n            \\<open>eligible_literal L C \\<sigma>\\<close>\n           \\<open>\\<not>(proper_subterm_red t S \\<sigma>)\\<close>\n            and \\<open>?no_fact\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L2 u v pos \\<sigma>\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n  trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S\n  orient_lit_inst L t s p \\<sigma>\n  p = pos\n  L \\<in> cl_ecl C\n  L2 \\<in> cl_ecl C - {L}\n  eligible_literal L C \\<sigma>\n  \\<not> proper_subterm_red t S \\<sigma>\n  \\<forall>L1 L2 t s u v.\n     L1 \\<in> cl_ecl C \\<longrightarrow>\n     eligible_literal L1 C \\<sigma> \\<longrightarrow>\n     L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n     orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n     orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n     t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n     \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n     trm_rep (s \\<lhd> \\<sigma>) S \\<noteq> trm_rep (v \\<lhd> \\<sigma>) S", "show False"], ["proof (prove)\nusing this:\n  orient_lit_inst L2 u v pos \\<sigma>\n  t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma>\n  trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (v \\<lhd> \\<sigma>) S\n  orient_lit_inst L t s p \\<sigma>\n  p = pos\n  L \\<in> cl_ecl C\n  L2 \\<in> cl_ecl C - {L}\n  eligible_literal L C \\<sigma>\n  \\<not> proper_subterm_red t S \\<sigma>\n  \\<forall>L1 L2 t s u v.\n     L1 \\<in> cl_ecl C \\<longrightarrow>\n     eligible_literal L1 C \\<sigma> \\<longrightarrow>\n     L2 \\<in> cl_ecl C - {L1} \\<longrightarrow>\n     orient_lit_inst L1 t s pos \\<sigma> \\<longrightarrow>\n     orient_lit_inst L2 u v pos \\<sigma> \\<longrightarrow>\n     t \\<lhd> \\<sigma> = u \\<lhd> \\<sigma> \\<longrightarrow>\n     \\<not> proper_subterm_red t S \\<sigma> \\<longrightarrow>\n     trm_rep (s \\<lhd> \\<sigma>) S \\<noteq> trm_rep (v \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p = neg \\<or>\n  \\<not> equivalent_eq_exists t s (cl_ecl C)\n          (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "have \"(trm_rep (subst t \\<sigma>) S) = (subst t \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S = t \\<lhd> \\<sigma>", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S \\<noteq>\n    t \\<lhd> \\<sigma> \\<Longrightarrow>\n    False", "assume \"(trm_rep (subst t \\<sigma>) S) \\<noteq>  (subst t \\<sigma>)\""], ["proof (state)\nthis:\n  trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> t \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S \\<noteq>\n    t \\<lhd> \\<sigma> \\<Longrightarrow>\n    False", "from \\<open>p = neg \\<or> \\<not> equivalent_eq_exists t s (cl_ecl C) (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L\\<close> \n          \\<open>\\<forall>x y. \n        ((x \\<in> vars_of_cl (cl_ecl C)) \\<longrightarrow> occurs_in y (subst (Var x) \\<sigma>) \\<longrightarrow> trm_rep y S = y)\\<close> \n        \\<open>eligible_literal L C \\<sigma>\\<close>\n        \\<open>trm_rep (subst t \\<sigma>) S \\<noteq> subst t \\<sigma>\\<close> \\<open>L \\<in> cl_ecl C\\<close> \n        \\<open>orient_lit_inst L t s p \\<sigma>\\<close> \\<open>\\<forall>x\\<in>S. finite (cl_ecl x)\\<close> \n        \\<open>ground_clause (subst_cl (cl_ecl C) \\<sigma>)\\<close>\n        \\<open>fo_interpretation (int_clset S)\\<close> \n        \\<open>Ball S well_constrained\\<close> \\<open>C \\<in> S\\<close>\n        \\<open>all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>) (\\<lambda>t. trm_rep t S)\\<close>\n        \\<open>\\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\\<close>\n        \\<open>closed_under_renaming S\\<close>"], ["proof (chain)\npicking this:\n  p = neg \\<or>\n  \\<not> equivalent_eq_exists t s (cl_ecl C)\n          (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L\n  \\<forall>x y.\n     x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n     occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow> trm_rep y S = y\n  eligible_literal L C \\<sigma>\n  trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> t \\<lhd> \\<sigma>\n  L \\<in> cl_ecl C\n  orient_lit_inst L t s p \\<sigma>\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n  fo_interpretation (int_clset S)\n  Ball S well_constrained\n  C \\<in> S\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n  closed_under_renaming S", "have \"\n            \\<exists>\\<sigma>'' u u' pa v D L2. (reduction L C \\<sigma>'' t s p L2 u u' pa v D \n              (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and> variable_disjoint C D)\""], ["proof (prove)\nusing this:\n  p = neg \\<or>\n  \\<not> equivalent_eq_exists t s (cl_ecl C)\n          (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L\n  \\<forall>x y.\n     x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n     occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow> trm_rep y S = y\n  eligible_literal L C \\<sigma>\n  trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> t \\<lhd> \\<sigma>\n  L \\<in> cl_ecl C\n  orient_lit_inst L t s p \\<sigma>\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n  fo_interpretation (int_clset S)\n  Ball S well_constrained\n  C \\<in> S\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n  closed_under_renaming S\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>'' u u' pa v D L2.\n       reduction L C \\<sigma>'' t s p L2 u u' pa v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "using reduction_exists [of p t s C S \\<sigma> L]"], ["proof (prove)\nusing this:\n  p = neg \\<or>\n  \\<not> equivalent_eq_exists t s (cl_ecl C)\n          (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L\n  \\<forall>x y.\n     x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n     occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow> trm_rep y S = y\n  eligible_literal L C \\<sigma>\n  trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> t \\<lhd> \\<sigma>\n  L \\<in> cl_ecl C\n  orient_lit_inst L t s p \\<sigma>\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n  fo_interpretation (int_clset S)\n  Ball S well_constrained\n  C \\<in> S\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n  closed_under_renaming S\n  \\<lbrakk>p = neg \\<or>\n           \\<not> equivalent_eq_exists t s (cl_ecl C) (int_clset S) \\<sigma>\n                   L \\<or>\n           proper_subterm_red t S \\<sigma>;\n   \\<forall>x y.\n      x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n      occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow> trm_rep y S = y;\n   eligible_literal L C \\<sigma>;\n   trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> t \\<lhd> \\<sigma>;\n   L \\<in> cl_ecl C; orient_lit_inst L t s p \\<sigma>;\n   \\<forall>x\\<in>S. finite (cl_ecl x);\n   ground_clause (subst_cl (cl_ecl C) \\<sigma>);\n   fo_interpretation (same_values (\\<lambda>t. trm_rep t S)); C \\<in> S;\n   Ball S well_constrained;\n   all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n    (\\<lambda>t. trm_rep t S);\n   \\<not> validate_ground_clause (int_clset S)\n           (subst_cl (cl_ecl C) \\<sigma>);\n   closed_under_renaming S\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<sigma>' u u' pa v D L2.\n                       reduction L C \\<sigma>' t s p L2 u u' pa v D\n                        (same_values (\\<lambda>t. trm_rep t S)) S\n                        \\<sigma> \\<and>\n                       variable_disjoint C D\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>'' u u' pa v D L2.\n       reduction L C \\<sigma>'' t s p L2 u u' pa v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "unfolding int_clset_def"], ["proof (prove)\nusing this:\n  p = neg \\<or>\n  \\<not> equivalent_eq_exists t s (cl_ecl C)\n          (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L\n  \\<forall>x y.\n     x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n     occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow> trm_rep y S = y\n  eligible_literal L C \\<sigma>\n  trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> t \\<lhd> \\<sigma>\n  L \\<in> cl_ecl C\n  orient_lit_inst L t s p \\<sigma>\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n  fo_interpretation (same_values (\\<lambda>x. trm_rep x S))\n  Ball S well_constrained\n  C \\<in> S\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n  \\<not> validate_ground_clause (same_values (\\<lambda>x. trm_rep x S))\n          (subst_cl (cl_ecl C) \\<sigma>)\n  closed_under_renaming S\n  \\<lbrakk>p = neg \\<or>\n           \\<not> equivalent_eq_exists t s (cl_ecl C)\n                   (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L \\<or>\n           proper_subterm_red t S \\<sigma>;\n   \\<forall>x y.\n      x \\<in> vars_of_cl (cl_ecl C) \\<longrightarrow>\n      occurs_in y (Var x \\<lhd> \\<sigma>) \\<longrightarrow> trm_rep y S = y;\n   eligible_literal L C \\<sigma>;\n   trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> t \\<lhd> \\<sigma>;\n   L \\<in> cl_ecl C; orient_lit_inst L t s p \\<sigma>;\n   \\<forall>x\\<in>S. finite (cl_ecl x);\n   ground_clause (subst_cl (cl_ecl C) \\<sigma>);\n   fo_interpretation (same_values (\\<lambda>t. trm_rep t S)); C \\<in> S;\n   Ball S well_constrained;\n   all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n    (\\<lambda>t. trm_rep t S);\n   \\<not> validate_ground_clause (same_values (\\<lambda>x. trm_rep x S))\n           (subst_cl (cl_ecl C) \\<sigma>);\n   closed_under_renaming S\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<sigma>' u u' pa v D L2.\n                       reduction L C \\<sigma>' t s p L2 u u' pa v D\n                        (same_values (\\<lambda>t. trm_rep t S)) S\n                        \\<sigma> \\<and>\n                       variable_disjoint C D\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>'' u u' pa v D L2.\n       reduction L C \\<sigma>'' t s p L2 u u' pa v D\n        (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n       variable_disjoint C D", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>'' u u' pa v D L2.\n     reduction L C \\<sigma>'' t s p L2 u u' pa v D\n      (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n     variable_disjoint C D\n\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S \\<noteq>\n    t \\<lhd> \\<sigma> \\<Longrightarrow>\n    False", "from this and \\<open>?nored\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>\\<sigma>'' u u' pa v D L2.\n     reduction L C \\<sigma>'' t s p L2 u u' pa v D\n      (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n     variable_disjoint C D\n  \\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n     \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n              (int_clset S) S \\<sigma> \\<and>\n             variable_disjoint C D)", "show False"], ["proof (prove)\nusing this:\n  \\<exists>\\<sigma>'' u u' pa v D L2.\n     reduction L C \\<sigma>'' t s p L2 u u' pa v D\n      (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n     variable_disjoint C D\n  \\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n     \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n              (int_clset S) S \\<sigma> \\<and>\n             variable_disjoint C D)\n\ngoal (1 subgoal):\n 1. False", "unfolding int_clset_def"], ["proof (prove)\nusing this:\n  \\<exists>\\<sigma>'' u u' pa v D L2.\n     reduction L C \\<sigma>'' t s p L2 u u' pa v D\n      (same_values (\\<lambda>t. trm_rep t S)) S \\<sigma> \\<and>\n     variable_disjoint C D\n  \\<forall>L1 L2 D t s u' u v p polarity \\<sigma>'.\n     \\<not> (reduction L1 C \\<sigma>' t s polarity L2 u u' p v D\n              (same_values (\\<lambda>x. trm_rep x S)) S \\<sigma> \\<and>\n             variable_disjoint C D)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  trm_rep (t \\<lhd> \\<sigma>) S = t \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "from \\<open>orient_lit_inst L t s p \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L t s p \\<sigma>", "have \"((subst t \\<sigma>),(subst s \\<sigma>)) \\<notin> trm_ord\""], ["proof (prove)\nusing this:\n  orient_lit_inst L t s p \\<sigma>\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  (L = Pos (Eq t s) \\<or> L = Pos (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  p = pos \\<or>\n  (L = Neg (Eq t s) \\<or> L = Neg (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and> p = neg\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord", "by auto"], ["proof (state)\nthis:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "from \\<open>ground_clause (subst_cl (cl_ecl C) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)", "have \"vars_of_cl (subst_cl (cl_ecl C) \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. vars_of_cl (subst_cl (cl_ecl C) \\<sigma>) = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_cl (subst_cl (cl_ecl C) \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "from this and \\<open>L \\<in> (cl_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  vars_of_cl (subst_cl (cl_ecl C) \\<sigma>) = {}\n  L \\<in> cl_ecl C", "have \"vars_of_lit (subst_lit L \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  vars_of_cl (subst_cl (cl_ecl C) \\<sigma>) = {}\n  L \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. vars_of_lit (subst_lit L \\<sigma>) = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "from \\<open>orient_lit_inst L t s p \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L t s p \\<sigma>", "have \"orient_lit (subst_lit L \\<sigma>) (subst t \\<sigma>) (subst s \\<sigma>) p\""], ["proof (prove)\nusing this:\n  orient_lit_inst L t s p \\<sigma>\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>)\n     (s \\<lhd> \\<sigma>) p", "using lift_orient_lit"], ["proof (prove)\nusing this:\n  orient_lit_inst L t s p \\<sigma>\n  orient_lit_inst ?L ?t ?s ?p ?\\<sigma> \\<Longrightarrow>\n  orient_lit (subst_lit ?L ?\\<sigma>) (?t \\<lhd> ?\\<sigma>)\n   (?s \\<lhd> ?\\<sigma>) ?p\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>)\n     (s \\<lhd> \\<sigma>) p", "by auto"], ["proof (state)\nthis:\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   p\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "from  \\<open>orient_lit (subst_lit L \\<sigma>) (subst t \\<sigma>) (subst s \\<sigma>) p\\<close>"], ["proof (chain)\npicking this:\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   p", "have \"vars_of (subst t \\<sigma>) \\<subseteq> vars_of_lit  (subst_lit L \\<sigma>)\""], ["proof (prove)\nusing this:\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   p\n\ngoal (1 subgoal):\n 1. vars_of (t \\<lhd> \\<sigma>)\n    \\<subseteq> vars_of_lit (subst_lit L \\<sigma>)", "using  orient_lit_vars"], ["proof (prove)\nusing this:\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   p\n  orient_lit ?L ?t ?s ?p \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of (t \\<lhd> \\<sigma>)\n    \\<subseteq> vars_of_lit (subst_lit L \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  vars_of (t \\<lhd> \\<sigma>) \\<subseteq> vars_of_lit (subst_lit L \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "from this and \\<open>vars_of_lit (subst_lit L \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  vars_of (t \\<lhd> \\<sigma>) \\<subseteq> vars_of_lit (subst_lit L \\<sigma>)\n  vars_of_lit (subst_lit L \\<sigma>) = {}", "have \"vars_of (subst t \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  vars_of (t \\<lhd> \\<sigma>) \\<subseteq> vars_of_lit (subst_lit L \\<sigma>)\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. vars_of (t \\<lhd> \\<sigma>) = {}", "by auto"], ["proof (state)\nthis:\n  vars_of (t \\<lhd> \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "from  \\<open>orient_lit (subst_lit L \\<sigma>) (subst t \\<sigma>) (subst s \\<sigma>) p\\<close>"], ["proof (chain)\npicking this:\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   p", "have \"vars_of (subst s \\<sigma>) \\<subseteq> vars_of_lit  (subst_lit L \\<sigma>)\""], ["proof (prove)\nusing this:\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   p\n\ngoal (1 subgoal):\n 1. vars_of (s \\<lhd> \\<sigma>)\n    \\<subseteq> vars_of_lit (subst_lit L \\<sigma>)", "using  orient_lit_vars"], ["proof (prove)\nusing this:\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   p\n  orient_lit ?L ?t ?s ?p \\<Longrightarrow>\n  vars_of ?t \\<subseteq> vars_of_lit ?L \\<and>\n  vars_of ?s \\<subseteq> vars_of_lit ?L\n\ngoal (1 subgoal):\n 1. vars_of (s \\<lhd> \\<sigma>)\n    \\<subseteq> vars_of_lit (subst_lit L \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  vars_of (s \\<lhd> \\<sigma>) \\<subseteq> vars_of_lit (subst_lit L \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "from this and \\<open>vars_of_lit (subst_lit L \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  vars_of (s \\<lhd> \\<sigma>) \\<subseteq> vars_of_lit (subst_lit L \\<sigma>)\n  vars_of_lit (subst_lit L \\<sigma>) = {}", "have \"vars_of (subst s \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  vars_of (s \\<lhd> \\<sigma>) \\<subseteq> vars_of_lit (subst_lit L \\<sigma>)\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. vars_of (s \\<lhd> \\<sigma>) = {}", "by auto"], ["proof (state)\nthis:\n  vars_of (s \\<lhd> \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "from\n          \\<open>((subst t \\<sigma>),(subst s \\<sigma>)) \\<notin> trm_ord\\<close>\n          \\<open>vars_of (subst t \\<sigma>) = {}\\<close> \\<open>vars_of (subst s \\<sigma>) = {}\\<close>"], ["proof (chain)\npicking this:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (t \\<lhd> \\<sigma>) = {}\n  vars_of (s \\<lhd> \\<sigma>) = {}", "have \"(subst t \\<sigma>) = (subst s \\<sigma>) \\<or> ((subst s \\<sigma>),(subst t \\<sigma>)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (t \\<lhd> \\<sigma>) = {}\n  vars_of (s \\<lhd> \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<or>\n    (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "using trm_ord_ground_total"], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (t \\<lhd> \\<sigma>) = {}\n  vars_of (s \\<lhd> \\<sigma>) = {}\n  \\<forall>x y.\n     ground_term x \\<longrightarrow>\n     ground_term y \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<or>\n    (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "unfolding ground_term_def"], ["proof (prove)\nusing this:\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord\n  vars_of (t \\<lhd> \\<sigma>) = {}\n  vars_of (s \\<lhd> \\<sigma>) = {}\n  \\<forall>x y.\n     vars_of x = {} \\<longrightarrow>\n     vars_of y = {} \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<or>\n    (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "by blast"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<or>\n  (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "from  \\<open>L \\<in> (cl_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  L \\<in> cl_ecl C", "have \"(subst_lit L \\<sigma>) \\<in> (subst_cl (cl_ecl C) \\<sigma>)\""], ["proof (prove)\nusing this:\n  L \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. subst_lit L \\<sigma> \\<in> subst_cl (cl_ecl C) \\<sigma>", "by auto"], ["proof (state)\nthis:\n  subst_lit L \\<sigma> \\<in> subst_cl (cl_ecl C) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "text \\<open>Using the fact that the eligible term is in normal form and that the eligible literal\nis false in the considered interpretation but is not a contradiction, we deduce that this literal \nmust be positive.\\<close>"], ["proof (state)\nthis:\n  subst_lit L \\<sigma> \\<in> subst_cl (cl_ecl C) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "have \"p = pos\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = pos", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> pos \\<Longrightarrow> False", "assume \"p \\<noteq> pos\""], ["proof (state)\nthis:\n  p \\<noteq> pos\n\ngoal (1 subgoal):\n 1. p \\<noteq> pos \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  p \\<noteq> pos", "have \"p = neg\""], ["proof (prove)\nusing this:\n  p \\<noteq> pos\n\ngoal (1 subgoal):\n 1. p = neg", "using sign.exhaust"], ["proof (prove)\nusing this:\n  p \\<noteq> pos\n  \\<lbrakk>?y = pos \\<Longrightarrow> ?P;\n   ?y = neg \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. p = neg", "by auto"], ["proof (state)\nthis:\n  p = neg\n\ngoal (1 subgoal):\n 1. p \\<noteq> pos \\<Longrightarrow> False", "from \\<open>trm_rep (subst t \\<sigma>) S =  (subst t \\<sigma>)\\<close> \\<open>L \\<in> (cl_ecl C)\\<close> \\<open>eligible_literal L C \\<sigma>\\<close> \n          and \\<open>orient_lit_inst L t s p \\<sigma>\\<close> \\<open>p = neg\\<close> \\<open>?no_cont\\<close>"], ["proof (chain)\npicking this:\n  trm_rep (t \\<lhd> \\<sigma>) S = t \\<lhd> \\<sigma>\n  L \\<in> cl_ecl C\n  eligible_literal L C \\<sigma>\n  orient_lit_inst L t s p \\<sigma>\n  p = neg\n  \\<forall>L t s.\n     L \\<in> cl_ecl C \\<longrightarrow>\n     eligible_literal L C \\<sigma> \\<longrightarrow>\n     orient_lit_inst L t s neg \\<sigma> \\<longrightarrow>\n     trm_rep (t \\<lhd> \\<sigma>) S = t \\<lhd> \\<sigma> \\<longrightarrow>\n     t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>", "have \"(subst t \\<sigma>) \\<noteq> (subst s \\<sigma>)\""], ["proof (prove)\nusing this:\n  trm_rep (t \\<lhd> \\<sigma>) S = t \\<lhd> \\<sigma>\n  L \\<in> cl_ecl C\n  eligible_literal L C \\<sigma>\n  orient_lit_inst L t s p \\<sigma>\n  p = neg\n  \\<forall>L t s.\n     L \\<in> cl_ecl C \\<longrightarrow>\n     eligible_literal L C \\<sigma> \\<longrightarrow>\n     orient_lit_inst L t s neg \\<sigma> \\<longrightarrow>\n     trm_rep (t \\<lhd> \\<sigma>) S = t \\<lhd> \\<sigma> \\<longrightarrow>\n     t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>", "by blast"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. p \\<noteq> pos \\<Longrightarrow> False", "from this and\n           \\<open>(subst t \\<sigma>) = (subst s \\<sigma>) \\<or> ((subst s \\<sigma>),(subst t \\<sigma>)) \\<in> trm_ord\\<close>\n          and \\<open>trm_rep (subst t \\<sigma>) S = subst t \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n  t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<or>\n  (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  trm_rep (t \\<lhd> \\<sigma>) S = t \\<lhd> \\<sigma>", "have \"((trm_rep (subst s \\<sigma>) S),(trm_rep (subst t \\<sigma>) S)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n  t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<or>\n  (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  trm_rep (t \\<lhd> \\<sigma>) S = t \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. (trm_rep (s \\<lhd> \\<sigma>) S, trm_rep (t \\<lhd> \\<sigma>) S)\n    \\<in> trm_ord", "using trm_rep_is_lower [of \" (subst s \\<sigma>)\" S ] trm_ord_trans"], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n  t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<or>\n  (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  trm_rep (t \\<lhd> \\<sigma>) S = t \\<lhd> \\<sigma>\n  s \\<lhd> \\<sigma> \\<noteq> trm_rep (s \\<lhd> \\<sigma>) S \\<longrightarrow>\n  (trm_rep (s \\<lhd> \\<sigma>) S, s \\<lhd> \\<sigma>) \\<in> trm_ord\n  trans trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep (s \\<lhd> \\<sigma>) S, trm_rep (t \\<lhd> \\<sigma>) S)\n    \\<in> trm_ord", "unfolding trans_def"], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n  t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<or>\n  (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  trm_rep (t \\<lhd> \\<sigma>) S = t \\<lhd> \\<sigma>\n  s \\<lhd> \\<sigma> \\<noteq> trm_rep (s \\<lhd> \\<sigma>) S \\<longrightarrow>\n  (trm_rep (s \\<lhd> \\<sigma>) S, s \\<lhd> \\<sigma>) \\<in> trm_ord\n  \\<forall>x y z.\n     (x, y) \\<in> trm_ord \\<longrightarrow>\n     (y, z) \\<in> trm_ord \\<longrightarrow> (x, z) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep (s \\<lhd> \\<sigma>) S, trm_rep (t \\<lhd> \\<sigma>) S)\n    \\<in> trm_ord", "by metis"], ["proof (state)\nthis:\n  (trm_rep (s \\<lhd> \\<sigma>) S, trm_rep (t \\<lhd> \\<sigma>) S)\n  \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. p \\<noteq> pos \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  (trm_rep (s \\<lhd> \\<sigma>) S, trm_rep (t \\<lhd> \\<sigma>) S)\n  \\<in> trm_ord", "have \"(trm_rep (subst s \\<sigma>) S) \\<noteq> (trm_rep (subst t \\<sigma>) S)\""], ["proof (prove)\nusing this:\n  (trm_rep (s \\<lhd> \\<sigma>) S, trm_rep (t \\<lhd> \\<sigma>) S)\n  \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. trm_rep (s \\<lhd> \\<sigma>) S \\<noteq> trm_rep (t \\<lhd> \\<sigma>) S", "using trm_ord_irrefl irrefl_def"], ["proof (prove)\nusing this:\n  (trm_rep (s \\<lhd> \\<sigma>) S, trm_rep (t \\<lhd> \\<sigma>) S)\n  \\<in> trm_ord\n  irrefl trm_ord\n  irrefl ?r = (\\<forall>a. (a, a) \\<notin> ?r)\n\ngoal (1 subgoal):\n 1. trm_rep (s \\<lhd> \\<sigma>) S \\<noteq> trm_rep (t \\<lhd> \\<sigma>) S", "by metis"], ["proof (state)\nthis:\n  trm_rep (s \\<lhd> \\<sigma>) S \\<noteq> trm_rep (t \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. p \\<noteq> pos \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  trm_rep (s \\<lhd> \\<sigma>) S \\<noteq> trm_rep (t \\<lhd> \\<sigma>) S", "have \"\\<not>validate_ground_eq ?I (Eq (subst t \\<sigma>) (subst s \\<sigma>))\""], ["proof (prove)\nusing this:\n  trm_rep (s \\<lhd> \\<sigma>) S \\<noteq> trm_rep (t \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_eq (int_clset S)\n            (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))", "unfolding same_values_def int_clset_def"], ["proof (prove)\nusing this:\n  trm_rep (s \\<lhd> \\<sigma>) S \\<noteq> trm_rep (t \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_eq (\\<lambda>x y. trm_rep x S = trm_rep y S)\n            (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))", "using validate_ground_eq.simps"], ["proof (prove)\nusing this:\n  trm_rep (s \\<lhd> \\<sigma>) S \\<noteq> trm_rep (t \\<lhd> \\<sigma>) S\n  validate_ground_eq ?I (Eq ?t ?s) = ?I ?t ?s\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_eq (\\<lambda>x y. trm_rep x S = trm_rep y S)\n            (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))", "by (metis (mono_tags, lifting))"], ["proof (state)\nthis:\n  \\<not> validate_ground_eq (int_clset S)\n          (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))\n\ngoal (1 subgoal):\n 1. p \\<noteq> pos \\<Longrightarrow> False", "from \\<open>(trm_rep (subst s \\<sigma>) S) \\<noteq> (trm_rep (subst t \\<sigma>) S)\\<close>"], ["proof (chain)\npicking this:\n  trm_rep (s \\<lhd> \\<sigma>) S \\<noteq> trm_rep (t \\<lhd> \\<sigma>) S", "have \"\\<not>validate_ground_eq ?I (Eq (subst s \\<sigma>) (subst t \\<sigma>))\""], ["proof (prove)\nusing this:\n  trm_rep (s \\<lhd> \\<sigma>) S \\<noteq> trm_rep (t \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_eq (int_clset S)\n            (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))", "unfolding same_values_def  int_clset_def"], ["proof (prove)\nusing this:\n  trm_rep (s \\<lhd> \\<sigma>) S \\<noteq> trm_rep (t \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_eq (\\<lambda>x y. trm_rep x S = trm_rep y S)\n            (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))", "using validate_ground_eq.simps"], ["proof (prove)\nusing this:\n  trm_rep (s \\<lhd> \\<sigma>) S \\<noteq> trm_rep (t \\<lhd> \\<sigma>) S\n  validate_ground_eq ?I (Eq ?t ?s) = ?I ?t ?s\n\ngoal (1 subgoal):\n 1. \\<not> validate_ground_eq (\\<lambda>x y. trm_rep x S = trm_rep y S)\n            (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))", "by (metis (mono_tags, lifting))"], ["proof (state)\nthis:\n  \\<not> validate_ground_eq (int_clset S)\n          (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))\n\ngoal (1 subgoal):\n 1. p \\<noteq> pos \\<Longrightarrow> False", "from \\<open>orient_lit_inst L t s p \\<sigma>\\<close> and \\<open>p=neg\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L t s p \\<sigma>\n  p = neg", "have \"L = (Neg (Eq t s)) \\<or> L = (Neg (Eq s t))\""], ["proof (prove)\nusing this:\n  orient_lit_inst L t s p \\<sigma>\n  p = neg\n\ngoal (1 subgoal):\n 1. L = Neg (Eq t s) \\<or> L = Neg (Eq s t)", "unfolding orient_lit_inst_def"], ["proof (prove)\nusing this:\n  (L = Pos (Eq t s) \\<or> L = Pos (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  p = pos \\<or>\n  (L = Neg (Eq t s) \\<or> L = Neg (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and> p = neg\n  p = neg\n\ngoal (1 subgoal):\n 1. L = Neg (Eq t s) \\<or> L = Neg (Eq s t)", "by auto"], ["proof (state)\nthis:\n  L = Neg (Eq t s) \\<or> L = Neg (Eq s t)\n\ngoal (1 subgoal):\n 1. p \\<noteq> pos \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  L = Neg (Eq t s) \\<or> L = Neg (Eq s t)", "have \"subst_lit L \\<sigma> = (Neg (Eq (subst t \\<sigma>)  (subst s \\<sigma>))) \n          \\<or> subst_lit L \\<sigma> = (Neg (Eq (subst s \\<sigma>)  (subst t \\<sigma>)))\""], ["proof (prove)\nusing this:\n  L = Neg (Eq t s) \\<or> L = Neg (Eq s t)\n\ngoal (1 subgoal):\n 1. subst_lit L \\<sigma> =\n    Neg (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)) \\<or>\n    subst_lit L \\<sigma> = Neg (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))", "by auto"], ["proof (state)\nthis:\n  subst_lit L \\<sigma> =\n  Neg (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)) \\<or>\n  subst_lit L \\<sigma> = Neg (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))\n\ngoal (1 subgoal):\n 1. p \\<noteq> pos \\<Longrightarrow> False", "from this and \\<open>\\<not>validate_ground_eq ?I (Eq (subst s \\<sigma>) (subst t \\<sigma>))\\<close> \n          and \\<open>\\<not>validate_ground_eq ?I (Eq (subst t \\<sigma>) (subst s \\<sigma>))\\<close>"], ["proof (chain)\npicking this:\n  subst_lit L \\<sigma> =\n  Neg (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)) \\<or>\n  subst_lit L \\<sigma> = Neg (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))\n  \\<not> validate_ground_eq (int_clset S)\n          (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))\n  \\<not> validate_ground_eq (int_clset S)\n          (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))", "have \"validate_ground_lit ?I (subst_lit L \\<sigma>)\""], ["proof (prove)\nusing this:\n  subst_lit L \\<sigma> =\n  Neg (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)) \\<or>\n  subst_lit L \\<sigma> = Neg (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))\n  \\<not> validate_ground_eq (int_clset S)\n          (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))\n  \\<not> validate_ground_eq (int_clset S)\n          (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))\n\ngoal (1 subgoal):\n 1. validate_ground_lit (int_clset S) (subst_lit L \\<sigma>)", "using validate_ground_lit.simps(2)"], ["proof (prove)\nusing this:\n  subst_lit L \\<sigma> =\n  Neg (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)) \\<or>\n  subst_lit L \\<sigma> = Neg (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))\n  \\<not> validate_ground_eq (int_clset S)\n          (Eq (s \\<lhd> \\<sigma>) (t \\<lhd> \\<sigma>))\n  \\<not> validate_ground_eq (int_clset S)\n          (Eq (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>))\n  validate_ground_lit ?I (Neg ?E) = (\\<not> validate_ground_eq ?I ?E)\n\ngoal (1 subgoal):\n 1. validate_ground_lit (int_clset S) (subst_lit L \\<sigma>)", "by metis"], ["proof (state)\nthis:\n  validate_ground_lit (int_clset S) (subst_lit L \\<sigma>)\n\ngoal (1 subgoal):\n 1. p \\<noteq> pos \\<Longrightarrow> False", "from \\<open>(subst_lit L \\<sigma>) \\<in> (subst_cl (cl_ecl C) \\<sigma>)\\<close> \n          and \\<open>validate_ground_lit ?I (subst_lit L \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  subst_lit L \\<sigma> \\<in> subst_cl (cl_ecl C) \\<sigma>\n  validate_ground_lit (int_clset S) (subst_lit L \\<sigma>)", "have \"validate_ground_clause ?I (subst_cl (cl_ecl C) \\<sigma>)\""], ["proof (prove)\nusing this:\n  subst_lit L \\<sigma> \\<in> subst_cl (cl_ecl C) \\<sigma>\n  validate_ground_lit (int_clset S) (subst_lit L \\<sigma>)\n\ngoal (1 subgoal):\n 1. validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)", "using validate_ground_clause.elims(3)"], ["proof (prove)\nusing this:\n  subst_lit L \\<sigma> \\<in> subst_cl (cl_ecl C) \\<sigma>\n  validate_ground_lit (int_clset S) (subst_lit L \\<sigma>)\n  \\<lbrakk>\\<not> validate_ground_clause ?x ?xa;\n   \\<And>I C.\n      \\<lbrakk>?x = I; ?xa = C;\n       \\<nexists>L. L \\<in> C \\<and> validate_ground_lit I L\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)", "by blast"], ["proof (state)\nthis:\n  validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. p \\<noteq> pos \\<Longrightarrow> False", "from this and \\<open>\\<not> validate_ground_clause ?I (subst_cl (cl_ecl C) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)", "show False"], ["proof (prove)\nusing this:\n  validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p = pos\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "text \\<open>This entails that the right-hand side of the eligible literal occurs in the set of \npossible values for the left-hand side @{term \"t\"}, which is impossible since this term is \nirreducible.\\<close>"], ["proof (state)\nthis:\n  p = pos\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "from \\<open>L \\<in> (cl_ecl C)\\<close> \\<open>orient_lit_inst L t s p \\<sigma>\\<close> \\<open>p = pos\\<close> \n      \\<open>\\<not> validate_ground_clause ?I (subst_cl (cl_ecl C) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  L \\<in> cl_ecl C\n  orient_lit_inst L t s p \\<sigma>\n  p = pos\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)", "have \"trm_rep (subst t \\<sigma>) S \\<noteq> trm_rep (subst s \\<sigma>) S\""], ["proof (prove)\nusing this:\n  L \\<in> cl_ecl C\n  orient_lit_inst L t s p \\<sigma>\n  p = pos\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> trm_rep (s \\<lhd> \\<sigma>) S", "using no_valid_literal"], ["proof (prove)\nusing this:\n  L \\<in> cl_ecl C\n  orient_lit_inst L t s p \\<sigma>\n  p = pos\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n  \\<lbrakk>?L \\<in> ?C; orient_lit_inst ?L ?t ?s pos ?\\<sigma>;\n   \\<not> validate_ground_clause (int_clset ?S)\n           (subst_cl ?C ?\\<sigma>)\\<rbrakk>\n  \\<Longrightarrow> trm_rep (?t \\<lhd> ?\\<sigma>) ?S \\<noteq>\n                    trm_rep (?s \\<lhd> ?\\<sigma>) ?S\n\ngoal (1 subgoal):\n 1. trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> trm_rep (s \\<lhd> \\<sigma>) S", "by metis"], ["proof (state)\nthis:\n  trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> trm_rep (s \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> trm_rep (s \\<lhd> \\<sigma>) S", "have \"(subst t \\<sigma>) \\<noteq> (subst s \\<sigma>)\""], ["proof (prove)\nusing this:\n  trm_rep (t \\<lhd> \\<sigma>) S \\<noteq> trm_rep (s \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>", "by metis"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "from this and \\<open>(subst t \\<sigma>) = (subst s \\<sigma>) \\<or> ((subst s \\<sigma>),(subst t \\<sigma>)) \\<in> trm_ord\\<close>"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n  t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<or>\n  (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "have \"((subst s \\<sigma>),(subst t \\<sigma>)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n  t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<or>\n  (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "using trm_ord_ground_total"], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n  t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<or>\n  (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  \\<forall>x y.\n     ground_term x \\<longrightarrow>\n     ground_term y \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "unfolding ground_term_def"], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> \\<noteq> s \\<lhd> \\<sigma>\n  t \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<or>\n  (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  \\<forall>x y.\n     vars_of x = {} \\<longrightarrow>\n     vars_of y = {} \\<longrightarrow>\n     x \\<noteq> y \\<longrightarrow>\n     (x, y) \\<in> trm_ord \\<or> (y, x) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord", "by blast"], ["proof (state)\nthis:\n  (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "from \\<open>p=pos\\<close> and \\<open>orient_lit_inst L t s p \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  p = pos\n  orient_lit_inst L t s p \\<sigma>", "have \"\\<not>negative_literal L\""], ["proof (prove)\nusing this:\n  p = pos\n  orient_lit_inst L t s p \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> negative_literal L", "unfolding  orient_lit_inst_def"], ["proof (prove)\nusing this:\n  p = pos\n  (L = Pos (Eq t s) \\<or> L = Pos (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  p = pos \\<or>\n  (L = Neg (Eq t s) \\<or> L = Neg (Eq s t)) \\<and>\n  (t \\<lhd> \\<sigma>, s \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and> p = neg\n\ngoal (1 subgoal):\n 1. \\<not> negative_literal L", "by auto"], ["proof (state)\nthis:\n  \\<not> negative_literal L\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "from this and \\<open>eligible_literal L C \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  \\<not> negative_literal L\n  eligible_literal L C \\<sigma>", "have \"sel(cl_ecl C) = {}\" and \"maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\""], ["proof (prove)\nusing this:\n  \\<not> negative_literal L\n  eligible_literal L C \\<sigma>\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C) = {} &&&\n    maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)", "using sel_neg"], ["proof (prove)\nusing this:\n  \\<not> negative_literal L\n  eligible_literal L C \\<sigma>\n  \\<forall>x.\n     sel (cl_ecl x) \\<subseteq> cl_ecl x \\<and>\n     (\\<forall>y\\<in>sel (cl_ecl x). negative_literal y)\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C) = {} &&&\n    maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)", "unfolding eligible_literal_def"], ["proof (prove)\nusing this:\n  \\<not> negative_literal L\n  L \\<in> sel (cl_ecl C) \\<or>\n  sel (cl_ecl C) = {} \\<and>\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n  \\<forall>x.\n     sel (cl_ecl x) \\<subseteq> cl_ecl x \\<and>\n     (\\<forall>y\\<in>sel (cl_ecl x). negative_literal y)\n\ngoal (1 subgoal):\n 1. sel (cl_ecl C) = {} &&&\n    maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  sel (cl_ecl C) = {}\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "from \\<open>\\<not> validate_ground_clause ?I (subst_cl (cl_ecl C) \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)", "have \"smaller_lits_are_false (subst t \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>) S\""], ["proof (prove)\nusing this:\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. smaller_lits_are_false (t \\<lhd> \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) S", "using smaller_lits_are_false_if_cl_not_valid [of S \"(subst_cl (cl_ecl C) \\<sigma>)\" ]"], ["proof (prove)\nusing this:\n  \\<not> validate_ground_clause (int_clset S) (subst_cl (cl_ecl C) \\<sigma>)\n  \\<not> validate_ground_clause (int_clset S)\n          (subst_cl (cl_ecl C) \\<sigma>) \\<Longrightarrow>\n  smaller_lits_are_false ?t (subst_cl (cl_ecl C) \\<sigma>) S\n\ngoal (1 subgoal):\n 1. smaller_lits_are_false (t \\<lhd> \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) S", "by blast"], ["proof (state)\nthis:\n  smaller_lits_are_false (t \\<lhd> \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n   S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "from \\<open>p = pos\\<close> and \\<open>p = neg \\<or> \\<not> equivalent_eq_exists t s (cl_ecl C) \n                          (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L\\<close>"], ["proof (chain)\npicking this:\n  p = pos\n  p = neg \\<or>\n  \\<not> equivalent_eq_exists t s (cl_ecl C)\n          (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L", "have \"\\<not> equivalent_eq_exists t s (cl_ecl C) (int_clset S) \\<sigma> L\""], ["proof (prove)\nusing this:\n  p = pos\n  p = neg \\<or>\n  \\<not> equivalent_eq_exists t s (cl_ecl C)\n          (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L\n\ngoal (1 subgoal):\n 1. \\<not> equivalent_eq_exists t s (cl_ecl C) (int_clset S) \\<sigma> L", "unfolding int_clset_def"], ["proof (prove)\nusing this:\n  p = pos\n  p = neg \\<or>\n  \\<not> equivalent_eq_exists t s (cl_ecl C)\n          (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L\n\ngoal (1 subgoal):\n 1. \\<not> equivalent_eq_exists t s (cl_ecl C)\n            (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L", "using sign.distinct"], ["proof (prove)\nusing this:\n  p = pos\n  p = neg \\<or>\n  \\<not> equivalent_eq_exists t s (cl_ecl C)\n          (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L\n  pos \\<noteq> neg\n  neg \\<noteq> pos\n\ngoal (1 subgoal):\n 1. \\<not> equivalent_eq_exists t s (cl_ecl C)\n            (same_values (\\<lambda>x. trm_rep x S)) \\<sigma> L", "by metis"], ["proof (state)\nthis:\n  \\<not> equivalent_eq_exists t s (cl_ecl C) (int_clset S) \\<sigma> L\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "from this \\<open>p=pos\\<close>"], ["proof (chain)\npicking this:\n  \\<not> equivalent_eq_exists t s (cl_ecl C) (int_clset S) \\<sigma> L\n  p = pos", "have \"maximal_literal_is_unique (subst t \\<sigma>) (subst s \\<sigma>) (cl_ecl C) L S \\<sigma>\""], ["proof (prove)\nusing this:\n  \\<not> equivalent_eq_exists t s (cl_ecl C) (int_clset S) \\<sigma> L\n  p = pos\n\ngoal (1 subgoal):\n 1. maximal_literal_is_unique (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n     (cl_ecl C) L S \\<sigma>", "using maximal_literal_is_unique_lemma [of t s \"(cl_ecl C)\" S \\<sigma> L]"], ["proof (prove)\nusing this:\n  \\<not> equivalent_eq_exists t s (cl_ecl C) (int_clset S) \\<sigma> L\n  p = pos\n  \\<not> equivalent_eq_exists t s (cl_ecl C) (int_clset S) \\<sigma>\n          L \\<Longrightarrow>\n  maximal_literal_is_unique (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   (cl_ecl C) L S \\<sigma>\n\ngoal (1 subgoal):\n 1. maximal_literal_is_unique (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n     (cl_ecl C) L S \\<sigma>", "by blast"], ["proof (state)\nthis:\n  maximal_literal_is_unique (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   (cl_ecl C) L S \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "from \\<open>all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>) (\\<lambda>t. trm_rep t S)\\<close>"], ["proof (chain)\npicking this:\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)", "have \"trms_irreducible C \\<sigma> S (subst t \\<sigma>)\""], ["proof (prove)\nusing this:\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n\ngoal (1 subgoal):\n 1. trms_irreducible C \\<sigma> S (t \\<lhd> \\<sigma>)", "using trms_irreducible_lemma"], ["proof (prove)\nusing this:\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t S)\n  all_trms_irreducible (subst_set (trms_ecl ?C) ?\\<sigma>)\n   (\\<lambda>t. trm_rep t ?S) \\<Longrightarrow>\n  trms_irreducible ?C ?\\<sigma> ?S ?t\n\ngoal (1 subgoal):\n 1. trms_irreducible C \\<sigma> S (t \\<lhd> \\<sigma>)", "by blast"], ["proof (state)\nthis:\n  trms_irreducible C \\<sigma> S (t \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "have \"(subst t \\<sigma>) \\<notin> subst_set (trms_ecl C) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma> \\<notin> subst_set (trms_ecl C) \\<sigma>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma>\n    \\<in> subst_set (trms_ecl C) \\<sigma> \\<Longrightarrow>\n    False", "assume \"(subst t \\<sigma>) \\<in> subst_set (trms_ecl C) \\<sigma>\""], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> \\<in> subst_set (trms_ecl C) \\<sigma>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma>\n    \\<in> subst_set (trms_ecl C) \\<sigma> \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  t \\<lhd> \\<sigma> \\<in> subst_set (trms_ecl C) \\<sigma>", "obtain t' where \"t' \\<in> trms_ecl C\" and \"(subst t' \\<sigma>) = (subst t \\<sigma>)\""], ["proof (prove)\nusing this:\n  t \\<lhd> \\<sigma> \\<in> subst_set (trms_ecl C) \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>t' \\<in> trms_ecl C;\n         t' \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t' \\<in> trms_ecl C\n  t' \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma>\n    \\<in> subst_set (trms_ecl C) \\<sigma> \\<Longrightarrow>\n    False", "from \\<open>t' \\<in> trms_ecl C\\<close> and assms(3) and \\<open>C \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  t' \\<in> trms_ecl C\n  Ball S well_constrained\n  C \\<in> S", "have \"dom_trm t' (cl_ecl C)\""], ["proof (prove)\nusing this:\n  t' \\<in> trms_ecl C\n  Ball S well_constrained\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. dom_trm t' (cl_ecl C)", "unfolding Ball_def well_constrained_def"], ["proof (prove)\nusing this:\n  t' \\<in> trms_ecl C\n  \\<forall>x.\n     x \\<in> S \\<longrightarrow>\n     (\\<forall>y. y \\<in> trms_ecl x \\<longrightarrow> dom_trm y (cl_ecl x))\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. dom_trm t' (cl_ecl C)", "by auto"], ["proof (state)\nthis:\n  dom_trm t' (cl_ecl C)\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma>\n    \\<in> subst_set (trms_ecl C) \\<sigma> \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  dom_trm t' (cl_ecl C)", "obtain M u v q where \"M \\<in> (cl_ecl C)\" \"decompose_literal M u v q\" and \n        \"q = neg \\<and> (u = t') \\<or> ( (t',u) \\<in> trm_ord)\""], ["proof (prove)\nusing this:\n  dom_trm t' (cl_ecl C)\n\ngoal (1 subgoal):\n 1. (\\<And>M u v q.\n        \\<lbrakk>M \\<in> cl_ecl C; decompose_literal M u v q;\n         q = neg \\<and> u = t' \\<or> (t', u) \\<in> trm_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dom_trm_def"], ["proof (prove)\nusing this:\n  \\<exists>L u v p.\n     L \\<in> cl_ecl C \\<and>\n     decompose_literal L u v p \\<and>\n     (p = neg \\<and> t' = u \\<or> (t', u) \\<in> trm_ord)\n\ngoal (1 subgoal):\n 1. (\\<And>M u v q.\n        \\<lbrakk>M \\<in> cl_ecl C; decompose_literal M u v q;\n         q = neg \\<and> u = t' \\<or> (t', u) \\<in> trm_ord\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  M \\<in> cl_ecl C\n  decompose_literal M u v q\n  q = neg \\<and> u = t' \\<or> (t', u) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma>\n    \\<in> subst_set (trms_ecl C) \\<sigma> \\<Longrightarrow>\n    False", "obtain u' v' q' where \"orient_lit_inst M u' v' q' \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u' v' q'.\n        orient_lit_inst M u' v' q' \\<sigma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using literal.exhaust equation.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x1. ?y = Pos x1 \\<Longrightarrow> ?P;\n   \\<And>x2. ?y = Neg x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  (\\<And>x1 x2. ?y = Eq x1 x2 \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>u' v' q'.\n        orient_lit_inst M u' v' q' \\<sigma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using trm_ord_irrefl trm_ord_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x1. ?y = Pos x1 \\<Longrightarrow> ?P;\n   \\<And>x2. ?y = Neg x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  (\\<And>x1 x2. ?y = Eq x1 x2 \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n  irrefl trm_ord\n  trans trm_ord\n\ngoal (1 subgoal):\n 1. (\\<And>u' v' q'.\n        orient_lit_inst M u' v' q' \\<sigma> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding orient_lit_inst_def irrefl_def trans_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x1. ?y = Pos x1 \\<Longrightarrow> ?P;\n   \\<And>x2. ?y = Neg x2 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  (\\<And>x1 x2. ?y = Eq x1 x2 \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n  \\<forall>a. (a, a) \\<notin> trm_ord\n  \\<forall>x y z.\n     (x, y) \\<in> trm_ord \\<longrightarrow>\n     (y, z) \\<in> trm_ord \\<longrightarrow> (x, z) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (\\<And>u' v' q'.\n        (M = Pos (Eq u' v') \\<or> M = Pos (Eq v' u')) \\<and>\n        (u' \\<lhd> \\<sigma>, v' \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n        q' = pos \\<or>\n        (M = Neg (Eq u' v') \\<or> M = Neg (Eq v' u')) \\<and>\n        (u' \\<lhd> \\<sigma>, v' \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n        q' = neg \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  orient_lit_inst M u' v' q' \\<sigma>\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma>\n    \\<in> subst_set (trms_ecl C) \\<sigma> \\<Longrightarrow>\n    False", "from \\<open>decompose_literal M u v q\\<close> and \\<open>orient_lit_inst M u' v' q' \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  decompose_literal M u v q\n  orient_lit_inst M u' v' q' \\<sigma>", "have \"u = u' \\<or> u = v'\""], ["proof (prove)\nusing this:\n  decompose_literal M u v q\n  orient_lit_inst M u' v' q' \\<sigma>\n\ngoal (1 subgoal):\n 1. u = u' \\<or> u = v'", "unfolding decompose_literal_def orient_lit_inst_def"], ["proof (prove)\nusing this:\n  \\<exists>e.\n     q = pos \\<and> M = Pos e \\<and> decompose_equation e u v \\<or>\n     q = neg \\<and> M = Neg e \\<and> decompose_equation e u v\n  (M = Pos (Eq u' v') \\<or> M = Pos (Eq v' u')) \\<and>\n  (u' \\<lhd> \\<sigma>, v' \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  q' = pos \\<or>\n  (M = Neg (Eq u' v') \\<or> M = Neg (Eq v' u')) \\<and>\n  (u' \\<lhd> \\<sigma>, v' \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and> q' = neg\n\ngoal (1 subgoal):\n 1. u = u' \\<or> u = v'", "by (metis atom.simps(2) decompose_equation_def equation.inject literal.distinct(1) \n              literal.inject(1))"], ["proof (state)\nthis:\n  u = u' \\<or> u = v'\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma>\n    \\<in> subst_set (trms_ecl C) \\<sigma> \\<Longrightarrow>\n    False", "from \\<open>decompose_literal M u v q\\<close> and \\<open>orient_lit_inst M u' v' q' \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  decompose_literal M u v q\n  orient_lit_inst M u' v' q' \\<sigma>", "have \"q = q'\""], ["proof (prove)\nusing this:\n  decompose_literal M u v q\n  orient_lit_inst M u' v' q' \\<sigma>\n\ngoal (1 subgoal):\n 1. q = q'", "unfolding decompose_literal_def orient_lit_inst_def"], ["proof (prove)\nusing this:\n  \\<exists>e.\n     q = pos \\<and> M = Pos e \\<and> decompose_equation e u v \\<or>\n     q = neg \\<and> M = Neg e \\<and> decompose_equation e u v\n  (M = Pos (Eq u' v') \\<or> M = Pos (Eq v' u')) \\<and>\n  (u' \\<lhd> \\<sigma>, v' \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and>\n  q' = pos \\<or>\n  (M = Neg (Eq u' v') \\<or> M = Neg (Eq v' u')) \\<and>\n  (u' \\<lhd> \\<sigma>, v' \\<lhd> \\<sigma>) \\<notin> trm_ord \\<and> q' = neg\n\ngoal (1 subgoal):\n 1. q = q'", "by auto"], ["proof (state)\nthis:\n  q = q'\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma>\n    \\<in> subst_set (trms_ecl C) \\<sigma> \\<Longrightarrow>\n    False", "from \\<open>vars_of_cl (subst_cl (cl_ecl C) \\<sigma>) = {}\\<close> and \\<open>M \\<in> (cl_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  vars_of_cl (subst_cl (cl_ecl C) \\<sigma>) = {}\n  M \\<in> cl_ecl C", "have \"vars_of_lit (subst_lit M \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  vars_of_cl (subst_cl (cl_ecl C) \\<sigma>) = {}\n  M \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. vars_of_lit (subst_lit M \\<sigma>) = {}", "by auto"], ["proof (state)\nthis:\n  vars_of_lit (subst_lit M \\<sigma>) = {}\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma>\n    \\<in> subst_set (trms_ecl C) \\<sigma> \\<Longrightarrow>\n    False", "from \\<open>orient_lit_inst M u' v' q' \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst M u' v' q' \\<sigma>", "have \n          \"orient_lit (subst_lit M \\<sigma>) (subst u' \\<sigma>) (subst v' \\<sigma>) q'\""], ["proof (prove)\nusing this:\n  orient_lit_inst M u' v' q' \\<sigma>\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit M \\<sigma>) (u' \\<lhd> \\<sigma>)\n     (v' \\<lhd> \\<sigma>) q'", "using lift_orient_lit"], ["proof (prove)\nusing this:\n  orient_lit_inst M u' v' q' \\<sigma>\n  orient_lit_inst ?L ?t ?s ?p ?\\<sigma> \\<Longrightarrow>\n  orient_lit (subst_lit ?L ?\\<sigma>) (?t \\<lhd> ?\\<sigma>)\n   (?s \\<lhd> ?\\<sigma>) ?p\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit M \\<sigma>) (u' \\<lhd> \\<sigma>)\n     (v' \\<lhd> \\<sigma>) q'", "by auto"], ["proof (state)\nthis:\n  orient_lit (subst_lit M \\<sigma>) (u' \\<lhd> \\<sigma>)\n   (v' \\<lhd> \\<sigma>) q'\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma>\n    \\<in> subst_set (trms_ecl C) \\<sigma> \\<Longrightarrow>\n    False", "from \\<open>orient_lit_inst L t s p \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  orient_lit_inst L t s p \\<sigma>", "have \n          \"orient_lit (subst_lit L \\<sigma>) (subst t \\<sigma>) (subst s \\<sigma>) p\""], ["proof (prove)\nusing this:\n  orient_lit_inst L t s p \\<sigma>\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>)\n     (s \\<lhd> \\<sigma>) p", "using lift_orient_lit"], ["proof (prove)\nusing this:\n  orient_lit_inst L t s p \\<sigma>\n  orient_lit_inst ?L ?t ?s ?p ?\\<sigma> \\<Longrightarrow>\n  orient_lit (subst_lit ?L ?\\<sigma>) (?t \\<lhd> ?\\<sigma>)\n   (?s \\<lhd> ?\\<sigma>) ?p\n\ngoal (1 subgoal):\n 1. orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>)\n     (s \\<lhd> \\<sigma>) p", "by auto"], ["proof (state)\nthis:\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   p\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma>\n    \\<in> subst_set (trms_ecl C) \\<sigma> \\<Longrightarrow>\n    False", "have \"(t',u) \\<notin> trm_ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t', u) \\<notin> trm_ord", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (t', u) \\<in> trm_ord \\<Longrightarrow> False", "assume \"(t',u) \\<in> trm_ord\""], ["proof (state)\nthis:\n  (t', u) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (t', u) \\<in> trm_ord \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (t', u) \\<in> trm_ord", "have \"((subst t' \\<sigma>),(subst u \\<sigma>)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (t', u) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (t' \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord", "using trm_ord_subst"], ["proof (prove)\nusing this:\n  (t', u) \\<in> trm_ord\n  \\<forall>s x y.\n     (x, y) \\<in> trm_ord \\<longrightarrow>\n     (x \\<lhd> s, y \\<lhd> s) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (t' \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (t' \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (t', u) \\<in> trm_ord \\<Longrightarrow> False", "from this and \\<open>(subst t' \\<sigma>) = (subst t \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  (t' \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n  t' \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>", "have \n          \"((subst t \\<sigma>),(subst u \\<sigma>)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  (t' \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n  t' \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord", "by auto"], ["proof (state)\nthis:\n  (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (t', u) \\<in> trm_ord \\<Longrightarrow> False", "from \\<open>orient_lit (subst_lit M \\<sigma>) (subst u' \\<sigma>) (subst v' \\<sigma>) q'\\<close>\n          and \\<open>orient_lit (subst_lit L \\<sigma>) (subst t \\<sigma>) (subst s \\<sigma>) p\\<close> \n          and \\<open>((subst t \\<sigma>),(subst u \\<sigma>)) \\<in> trm_ord\\<close>\n          and \\<open>vars_of_lit (subst_lit M \\<sigma>) = {}\\<close>\n          and \\<open>vars_of_lit (subst_lit L \\<sigma>) = {}\\<close>\n          and \\<open>u = u' \\<or> u = v'\\<close>"], ["proof (chain)\npicking this:\n  orient_lit (subst_lit M \\<sigma>) (u' \\<lhd> \\<sigma>)\n   (v' \\<lhd> \\<sigma>) q'\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   p\n  (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n  vars_of_lit (subst_lit M \\<sigma>) = {}\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  u = u' \\<or> u = v'", "have \"((subst_lit L \\<sigma>),(subst_lit M \\<sigma>)) \\<in> lit_ord\""], ["proof (prove)\nusing this:\n  orient_lit (subst_lit M \\<sigma>) (u' \\<lhd> \\<sigma>)\n   (v' \\<lhd> \\<sigma>) q'\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   p\n  (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n  vars_of_lit (subst_lit M \\<sigma>) = {}\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  u = u' \\<or> u = v'\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord", "using lit_ord_dominating_term"], ["proof (prove)\nusing this:\n  orient_lit (subst_lit M \\<sigma>) (u' \\<lhd> \\<sigma>)\n   (v' \\<lhd> \\<sigma>) q'\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   p\n  (t \\<lhd> \\<sigma>, u \\<lhd> \\<sigma>) \\<in> trm_ord\n  vars_of_lit (subst_lit M \\<sigma>) = {}\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  u = u' \\<or> u = v'\n  \\<lbrakk>(?s1.0, ?s2.0) \\<in> trm_ord \\<or> (?s1.0, ?t2.0) \\<in> trm_ord;\n   orient_lit ?x1.0 ?s1.0 ?t1.0 ?p1.0; orient_lit ?x2.0 ?s2.0 ?t2.0 ?p2.0;\n   vars_of_lit ?x1.0 = {}; vars_of_lit ?x2.0 = {}\\<rbrakk>\n  \\<Longrightarrow> (?x1.0, ?x2.0) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord", "by metis"], ["proof (state)\nthis:\n  (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (t', u) \\<in> trm_ord \\<Longrightarrow> False", "from this and \\<open>maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\\<close>\n          and \\<open>M \\<in> (cl_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n  M \\<in> cl_ecl C", "show False"], ["proof (prove)\nusing this:\n  (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n  M \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. False", "using maximal_literal_def"], ["proof (prove)\nusing this:\n  (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n  M \\<in> cl_ecl C\n  maximal_literal ?L ?C =\n  (\\<forall>x. x \\<in> ?C \\<longrightarrow> (?L, x) \\<notin> lit_ord)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (t', u) \\<notin> trm_ord\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma>\n    \\<in> subst_set (trms_ecl C) \\<sigma> \\<Longrightarrow>\n    False", "have \"\\<not> (q = neg \\<and> (u = t'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (q = neg \\<and> u = t')", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. q = neg \\<and> u = t' \\<Longrightarrow> False", "assume \"q = neg \\<and> (u = t')\""], ["proof (state)\nthis:\n  q = neg \\<and> u = t'\n\ngoal (1 subgoal):\n 1. q = neg \\<and> u = t' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  q = neg \\<and> u = t'", "have \"q = neg\" and \"u = t'\""], ["proof (prove)\nusing this:\n  q = neg \\<and> u = t'\n\ngoal (1 subgoal):\n 1. q = neg &&& u = t'", "by auto"], ["proof (state)\nthis:\n  q = neg\n  u = t'\n\ngoal (1 subgoal):\n 1. q = neg \\<and> u = t' \\<Longrightarrow> False", "from \\<open>orient_lit (subst_lit M \\<sigma>) (subst u' \\<sigma>) (subst v' \\<sigma>) q'\\<close>\n          and \\<open>orient_lit (subst_lit L \\<sigma>) (subst t \\<sigma>) (subst s \\<sigma>) p\\<close> \n          and \\<open>u = t'\\<close>\n          and \\<open>(subst t' \\<sigma>) = (subst t \\<sigma>)\\<close>\n          and \\<open>q = neg\\<close> and \\<open>q = q'\\<close>\n          and \\<open>p = pos\\<close>\n          and \\<open>vars_of_lit (subst_lit M \\<sigma>) = {}\\<close>\n          and \\<open>vars_of_lit (subst_lit L \\<sigma>) = {}\\<close>\n          and \\<open>u = u' \\<or> u = v'\\<close>"], ["proof (chain)\npicking this:\n  orient_lit (subst_lit M \\<sigma>) (u' \\<lhd> \\<sigma>)\n   (v' \\<lhd> \\<sigma>) q'\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   p\n  u = t'\n  t' \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>\n  q = neg\n  q = q'\n  p = pos\n  vars_of_lit (subst_lit M \\<sigma>) = {}\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  u = u' \\<or> u = v'", "have \"((subst_lit L \\<sigma>),(subst_lit M \\<sigma>)) \\<in> lit_ord\""], ["proof (prove)\nusing this:\n  orient_lit (subst_lit M \\<sigma>) (u' \\<lhd> \\<sigma>)\n   (v' \\<lhd> \\<sigma>) q'\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   p\n  u = t'\n  t' \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>\n  q = neg\n  q = q'\n  p = pos\n  vars_of_lit (subst_lit M \\<sigma>) = {}\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  u = u' \\<or> u = v'\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord", "using lit_ord_neg_lit_lhs lit_ord_neg_lit_rhs"], ["proof (prove)\nusing this:\n  orient_lit (subst_lit M \\<sigma>) (u' \\<lhd> \\<sigma>)\n   (v' \\<lhd> \\<sigma>) q'\n  orient_lit (subst_lit L \\<sigma>) (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   p\n  u = t'\n  t' \\<lhd> \\<sigma> = t \\<lhd> \\<sigma>\n  q = neg\n  q = q'\n  p = pos\n  vars_of_lit (subst_lit M \\<sigma>) = {}\n  vars_of_lit (subst_lit L \\<sigma>) = {}\n  u = u' \\<or> u = v'\n  \\<lbrakk>orient_lit ?x1.0 ?s ?t1.0 pos; orient_lit ?x2.0 ?s ?t2.0 neg;\n   vars_of_lit ?x1.0 = {}; vars_of_lit ?x2.0 = {}\\<rbrakk>\n  \\<Longrightarrow> (?x1.0, ?x2.0) \\<in> lit_ord\n  \\<lbrakk>orient_lit ?x1.0 ?s ?t1.0 pos; orient_lit ?x2.0 ?t2.0 ?s neg;\n   vars_of_lit ?x1.0 = {}; vars_of_lit ?x2.0 = {}\\<rbrakk>\n  \\<Longrightarrow> (?x1.0, ?x2.0) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord", "by metis"], ["proof (state)\nthis:\n  (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord\n\ngoal (1 subgoal):\n 1. q = neg \\<and> u = t' \\<Longrightarrow> False", "from this and \\<open>maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\\<close>\n          and \\<open>M \\<in> (cl_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n  M \\<in> cl_ecl C", "show False"], ["proof (prove)\nusing this:\n  (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n  M \\<in> cl_ecl C\n\ngoal (1 subgoal):\n 1. False", "using maximal_literal_def"], ["proof (prove)\nusing this:\n  (subst_lit L \\<sigma>, subst_lit M \\<sigma>) \\<in> lit_ord\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n  M \\<in> cl_ecl C\n  maximal_literal ?L ?C =\n  (\\<forall>x. x \\<in> ?C \\<longrightarrow> (?L, x) \\<notin> lit_ord)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (q = neg \\<and> u = t')\n\ngoal (1 subgoal):\n 1. t \\<lhd> \\<sigma>\n    \\<in> subst_set (trms_ecl C) \\<sigma> \\<Longrightarrow>\n    False", "from this and \\<open>(t',u) \\<notin> trm_ord\\<close> and \\<open>q = neg \\<and> (u = t') \\<or> ( (t',u) \\<in> trm_ord)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> (q = neg \\<and> u = t')\n  (t', u) \\<notin> trm_ord\n  q = neg \\<and> u = t' \\<or> (t', u) \\<in> trm_ord", "show False"], ["proof (prove)\nusing this:\n  \\<not> (q = neg \\<and> u = t')\n  (t', u) \\<notin> trm_ord\n  q = neg \\<and> u = t' \\<or> (t', u) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<lhd> \\<sigma> \\<notin> subst_set (trms_ecl C) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "from \\<open>C \\<in> S\\<close> \\<open>(subst s \\<sigma>, subst t \\<sigma>) \\<in> trm_ord\\<close> \n          and \\<open>p=pos\\<close> \\<open>orient_lit_inst L t s p \\<sigma>\\<close> and \\<open>sel (cl_ecl C) = {}\\<close> \n          and \\<open>L \\<in> cl_ecl C\\<close> \n          and \\<open>maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\\<close>\n          and \\<open>ground_clause (subst_cl (cl_ecl C) \\<sigma>)\\<close>  \n          and \\<open>finite (cl_ecl C)\\<close> \n          and \\<open>smaller_lits_are_false (subst t \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>) S\\<close> \n          and \\<open>maximal_literal_is_unique  (subst t \\<sigma>) (subst s \\<sigma>) (cl_ecl C) L S \\<sigma>\\<close>\n          and \\<open>trms_irreducible C \\<sigma> S  (subst t \\<sigma>)\\<close>\n          and \\<open>(subst t \\<sigma>) \\<notin> subst_set (trms_ecl C) \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  C \\<in> S\n  (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  p = pos\n  orient_lit_inst L t s p \\<sigma>\n  sel (cl_ecl C) = {}\n  L \\<in> cl_ecl C\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n  finite (cl_ecl C)\n  smaller_lits_are_false (t \\<lhd> \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n   S\n  maximal_literal_is_unique (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   (cl_ecl C) L S \\<sigma>\n  trms_irreducible C \\<sigma> S (t \\<lhd> \\<sigma>)\n  t \\<lhd> \\<sigma> \\<notin> subst_set (trms_ecl C) \\<sigma>", "have cv: \"(candidate_values (trm_rep (subst s \\<sigma>) S) C (cl_ecl C) \n          (subst_cl (cl_ecl C) \\<sigma>) (subst s \\<sigma>) (subst_lit L \\<sigma>) L \\<sigma> t s (subst t \\<sigma>) S)\""], ["proof (prove)\nusing this:\n  C \\<in> S\n  (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  p = pos\n  orient_lit_inst L t s p \\<sigma>\n  sel (cl_ecl C) = {}\n  L \\<in> cl_ecl C\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n  finite (cl_ecl C)\n  smaller_lits_are_false (t \\<lhd> \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n   S\n  maximal_literal_is_unique (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   (cl_ecl C) L S \\<sigma>\n  trms_irreducible C \\<sigma> S (t \\<lhd> \\<sigma>)\n  t \\<lhd> \\<sigma> \\<notin> subst_set (trms_ecl C) \\<sigma>\n\ngoal (1 subgoal):\n 1. candidate_values (trm_rep (s \\<lhd> \\<sigma>) S) C (cl_ecl C)\n     (subst_cl (cl_ecl C) \\<sigma>) (s \\<lhd> \\<sigma>)\n     (subst_lit L \\<sigma>) L \\<sigma> t s (t \\<lhd> \\<sigma>) S", "unfolding candidate_values_def"], ["proof (prove)\nusing this:\n  C \\<in> S\n  (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  p = pos\n  orient_lit_inst L t s p \\<sigma>\n  sel (cl_ecl C) = {}\n  L \\<in> cl_ecl C\n  maximal_literal (subst_lit L \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n  ground_clause (subst_cl (cl_ecl C) \\<sigma>)\n  finite (cl_ecl C)\n  smaller_lits_are_false (t \\<lhd> \\<sigma>) (subst_cl (cl_ecl C) \\<sigma>)\n   S\n  maximal_literal_is_unique (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n   (cl_ecl C) L S \\<sigma>\n  trms_irreducible C \\<sigma> S (t \\<lhd> \\<sigma>)\n  t \\<lhd> \\<sigma> \\<notin> subst_set (trms_ecl C) \\<sigma>\n\ngoal (1 subgoal):\n 1. C \\<in> S \\<and>\n    t \\<lhd> \\<sigma> \\<notin> subst_set (trms_ecl C) \\<sigma> \\<and>\n    trms_irreducible C \\<sigma> S (t \\<lhd> \\<sigma>) \\<and>\n    cl_ecl C = cl_ecl C \\<and>\n    (s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord \\<and>\n    ((s \\<lhd> \\<sigma>, t \\<lhd> \\<sigma>) \\<in> trm_ord \\<longrightarrow>\n     trm_rep (s \\<lhd> \\<sigma>) S = trm_rep (s \\<lhd> \\<sigma>) S) \\<and>\n    orient_lit_inst L t s pos \\<sigma> \\<and>\n    sel (cl_ecl C) = {} \\<and>\n    L \\<in> cl_ecl C \\<and>\n    maximal_literal (subst_lit L \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) \\<and>\n    subst_lit L \\<sigma> = subst_lit L \\<sigma> \\<and>\n    subst_cl (cl_ecl C) \\<sigma> = subst_cl (cl_ecl C) \\<sigma> \\<and>\n    ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<and>\n    t \\<lhd> \\<sigma> = t \\<lhd> \\<sigma> \\<and>\n    s \\<lhd> \\<sigma> = s \\<lhd> \\<sigma> \\<and>\n    finite (cl_ecl C) \\<and>\n    smaller_lits_are_false (t \\<lhd> \\<sigma>)\n     (subst_cl (cl_ecl C) \\<sigma>) S \\<and>\n    maximal_literal_is_unique (t \\<lhd> \\<sigma>) (s \\<lhd> \\<sigma>)\n     (cl_ecl C) L S \\<sigma>", "by blast"], ["proof (state)\nthis:\n  candidate_values (trm_rep (s \\<lhd> \\<sigma>) S) C (cl_ecl C)\n   (subst_cl (cl_ecl C) \\<sigma>) (s \\<lhd> \\<sigma>) (subst_lit L \\<sigma>)\n   L \\<sigma> t s (t \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "from cv"], ["proof (chain)\npicking this:\n  candidate_values (trm_rep (s \\<lhd> \\<sigma>) S) C (cl_ecl C)\n   (subst_cl (cl_ecl C) \\<sigma>) (s \\<lhd> \\<sigma>) (subst_lit L \\<sigma>)\n   L \\<sigma> t s (t \\<lhd> \\<sigma>) S", "have \"(trm_rep (subst s \\<sigma>) S,(subst s \\<sigma>)) \\<in> set_of_candidate_values S (subst t \\<sigma>)\""], ["proof (prove)\nusing this:\n  candidate_values (trm_rep (s \\<lhd> \\<sigma>) S) C (cl_ecl C)\n   (subst_cl (cl_ecl C) \\<sigma>) (s \\<lhd> \\<sigma>) (subst_lit L \\<sigma>)\n   L \\<sigma> t s (t \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. (trm_rep (s \\<lhd> \\<sigma>) S, s \\<lhd> \\<sigma>)\n    \\<in> set_of_candidate_values S (t \\<lhd> \\<sigma>)", "unfolding set_of_candidate_values_def"], ["proof (prove)\nusing this:\n  candidate_values (trm_rep (s \\<lhd> \\<sigma>) S) C (cl_ecl C)\n   (subst_cl (cl_ecl C) \\<sigma>) (s \\<lhd> \\<sigma>) (subst_lit L \\<sigma>)\n   L \\<sigma> t s (t \\<lhd> \\<sigma>) S\n\ngoal (1 subgoal):\n 1. (trm_rep (s \\<lhd> \\<sigma>) S, s \\<lhd> \\<sigma>)\n    \\<in> {pair.\n           \\<exists>z CC C' C s L L' \\<sigma>' t' s'.\n              pair = (z, s) \\<and>\n              candidate_values z CC C' C s L L' \\<sigma>' t' s'\n               (t \\<lhd> \\<sigma>) S}", "by blast"], ["proof (state)\nthis:\n  (trm_rep (s \\<lhd> \\<sigma>) S, s \\<lhd> \\<sigma>)\n  \\<in> set_of_candidate_values S (t \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "from \\<open>trm_rep (subst t \\<sigma>) S = (subst t \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  trm_rep (t \\<lhd> \\<sigma>) S = t \\<lhd> \\<sigma>", "have \"\\<not>(subterm_reduction_applicable S (subst t \\<sigma>))\""], ["proof (prove)\nusing this:\n  trm_rep (t \\<lhd> \\<sigma>) S = t \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> subterm_reduction_applicable S (t \\<lhd> \\<sigma>)", "using trm_rep_is_lower_subt_red trm_ord_irrefl irrefl_def"], ["proof (prove)\nusing this:\n  trm_rep (t \\<lhd> \\<sigma>) S = t \\<lhd> \\<sigma>\n  subterm_reduction_applicable ?S ?x \\<Longrightarrow>\n  (trm_rep ?x ?S, ?x) \\<in> trm_ord\n  irrefl trm_ord\n  irrefl ?r = (\\<forall>a. (a, a) \\<notin> ?r)\n\ngoal (1 subgoal):\n 1. \\<not> subterm_reduction_applicable S (t \\<lhd> \\<sigma>)", "by metis"], ["proof (state)\nthis:\n  \\<not> subterm_reduction_applicable S (t \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "from \\<open>(trm_rep (subst s \\<sigma>) S, subst s \\<sigma>) \n              \\<in> set_of_candidate_values S (subst t \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  (trm_rep (s \\<lhd> \\<sigma>) S, s \\<lhd> \\<sigma>)\n  \\<in> set_of_candidate_values S (t \\<lhd> \\<sigma>)", "have \"set_of_candidate_values S (subst t \\<sigma>) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  (trm_rep (s \\<lhd> \\<sigma>) S, s \\<lhd> \\<sigma>)\n  \\<in> set_of_candidate_values S (t \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. set_of_candidate_values S (t \\<lhd> \\<sigma>) \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  set_of_candidate_values S (t \\<lhd> \\<sigma>) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "from \\<open>(trm_rep (subst s \\<sigma>) S, subst s \\<sigma>) \n              \\<in> set_of_candidate_values S (subst t \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  (trm_rep (s \\<lhd> \\<sigma>) S, s \\<lhd> \\<sigma>)\n  \\<in> set_of_candidate_values S (t \\<lhd> \\<sigma>)", "have \"min_trms (set_of_candidate_values S (subst t \\<sigma>)) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  (trm_rep (s \\<lhd> \\<sigma>) S, s \\<lhd> \\<sigma>)\n  \\<in> set_of_candidate_values S (t \\<lhd> \\<sigma>)\n\ngoal (1 subgoal):\n 1. min_trms (set_of_candidate_values S (t \\<lhd> \\<sigma>)) \\<noteq> {}", "using min_trms_not_empty"], ["proof (prove)\nusing this:\n  (trm_rep (s \\<lhd> \\<sigma>) S, s \\<lhd> \\<sigma>)\n  \\<in> set_of_candidate_values S (t \\<lhd> \\<sigma>)\n  ?E \\<noteq> {} \\<Longrightarrow> min_trms ?E \\<noteq> {}\n\ngoal (1 subgoal):\n 1. min_trms (set_of_candidate_values S (t \\<lhd> \\<sigma>)) \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  min_trms (set_of_candidate_values S (t \\<lhd> \\<sigma>)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "from \\<open>\\<not>(subterm_reduction_applicable S (subst t \\<sigma>))\\<close>\n        \\<open>min_trms (set_of_candidate_values S (subst t \\<sigma>)) \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  \\<not> subterm_reduction_applicable S (t \\<lhd> \\<sigma>)\n  min_trms (set_of_candidate_values S (t \\<lhd> \\<sigma>)) \\<noteq> {}", "have \"(trm_rep (subst t \\<sigma>) S,(subst t \\<sigma>)) \\<in> trm_ord\""], ["proof (prove)\nusing this:\n  \\<not> subterm_reduction_applicable S (t \\<lhd> \\<sigma>)\n  min_trms (set_of_candidate_values S (t \\<lhd> \\<sigma>)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (trm_rep (t \\<lhd> \\<sigma>) S, t \\<lhd> \\<sigma>) \\<in> trm_ord", "using trm_rep_is_lower_root_red [of S \"subst t \\<sigma>\"]"], ["proof (prove)\nusing this:\n  \\<not> subterm_reduction_applicable S (t \\<lhd> \\<sigma>)\n  min_trms (set_of_candidate_values S (t \\<lhd> \\<sigma>)) \\<noteq> {}\n  \\<lbrakk>\\<not> subterm_reduction_applicable S (t \\<lhd> \\<sigma>);\n   min_trms (set_of_candidate_values S (t \\<lhd> \\<sigma>)) \\<noteq>\n   {}\\<rbrakk>\n  \\<Longrightarrow> (trm_rep (t \\<lhd> \\<sigma>) S, t \\<lhd> \\<sigma>)\n                    \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. (trm_rep (t \\<lhd> \\<sigma>) S, t \\<lhd> \\<sigma>) \\<in> trm_ord", "by blast"], ["proof (state)\nthis:\n  (trm_rep (t \\<lhd> \\<sigma>) S, t \\<lhd> \\<sigma>) \\<in> trm_ord\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>C \\<sigma>.\n               fst pair = C \\<longrightarrow>\n               \\<sigma> = snd pair \\<longrightarrow>\n               C \\<in> S \\<longrightarrow>\n               ground_clause\n                (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n               all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n                (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n               validate_ground_clause\n                (same_values (\\<lambda>t. trm_rep t S))\n                (subst_cl (cl_ecl C) \\<sigma>)) \\<Longrightarrow>\n    False", "from this and \\<open>(trm_rep (subst t \\<sigma>) S) = (subst t \\<sigma>)\\<close>"], ["proof (chain)\npicking this:\n  (trm_rep (t \\<lhd> \\<sigma>) S, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  trm_rep (t \\<lhd> \\<sigma>) S = t \\<lhd> \\<sigma>", "show False"], ["proof (prove)\nusing this:\n  (trm_rep (t \\<lhd> \\<sigma>) S, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  trm_rep (t \\<lhd> \\<sigma>) S = t \\<lhd> \\<sigma>\n\ngoal (1 subgoal):\n 1. False", "using trm_ord_irrefl irrefl_def"], ["proof (prove)\nusing this:\n  (trm_rep (t \\<lhd> \\<sigma>) S, t \\<lhd> \\<sigma>) \\<in> trm_ord\n  trm_rep (t \\<lhd> \\<sigma>) S = t \\<lhd> \\<sigma>\n  irrefl trm_ord\n  irrefl ?r = (\\<forall>a. (a, a) \\<notin> ?r)\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>C \\<sigma>.\n     fst pair = C \\<longrightarrow>\n     \\<sigma> = snd pair \\<longrightarrow>\n     C \\<in> S \\<longrightarrow>\n     ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n     all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n      (\\<lambda>t. trm_rep t S) \\<longrightarrow>\n     validate_ground_clause (same_values (\\<lambda>t. trm_rep t S))\n      (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>As an immediate consequence of the previous lemma, we show that the set of clauses that \nare derivable from an unsatisfiable clause set must contain an empty clause (since this set is\ntrivially saturated).\\<close>"], ["", "lemma COMPLETENESS:\n  assumes \"\\<forall>x. (x \\<in> S \\<longrightarrow> (trms_ecl x = {}))\"\n  assumes \"(\\<forall>x\\<in>S. finite (cl_ecl x))\"\n  assumes \"\\<not> (satisfiable_clause_set (cl_ecl ` S))\"\n  shows \"\\<exists>x. (derivable_ecl x S) \\<and> cl_ecl x = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. derivable_ecl x S \\<and> cl_ecl x = {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>x. derivable_ecl x S \\<and> cl_ecl x = {} \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<exists>x. (derivable_ecl x S) \\<and> cl_ecl x = {})\""], ["proof (state)\nthis:\n  \\<nexists>x. derivable_ecl x S \\<and> cl_ecl x = {}\n\ngoal (1 subgoal):\n 1. \\<nexists>x. derivable_ecl x S \\<and> cl_ecl x = {} \\<Longrightarrow>\n    False", "let ?S = \"{ y. (derivable_ecl y S) }\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>x. derivable_ecl x S \\<and> cl_ecl x = {} \\<Longrightarrow>\n    False", "let ?I = \"same_values (\\<lambda>x. (trm_rep x ?S))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>x. derivable_ecl x S \\<and> cl_ecl x = {} \\<Longrightarrow>\n    False", "have \"fo_interpretation ?I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fo_interpretation\n     (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))", "using trm_rep_compatible_with_structure same_values_fo_int"], ["proof (prove)\nusing this:\n  value_is_compatible_with_structure (\\<lambda>x. trm_rep x ?S)\n  value_is_compatible_with_structure ?f \\<Longrightarrow>\n  fo_interpretation (same_values ?f)\n\ngoal (1 subgoal):\n 1. fo_interpretation\n     (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))", "by metis"], ["proof (state)\nthis:\n  fo_interpretation\n   (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n\ngoal (1 subgoal):\n 1. \\<nexists>x. derivable_ecl x S \\<and> cl_ecl x = {} \\<Longrightarrow>\n    False", "have \"\\<forall>x \\<in> ?S. (cl_ecl x) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{y. derivable_ecl y S}. cl_ecl x \\<noteq> {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>{y. derivable_ecl y S}.\n               cl_ecl x \\<noteq> {}) \\<Longrightarrow>\n    False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>x\\<in>{y. derivable_ecl y S}. cl_ecl x \\<noteq> {})\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>{y. derivable_ecl y S}.\n               cl_ecl x \\<noteq> {}) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>x\\<in>{y. derivable_ecl y S}. cl_ecl x \\<noteq> {})", "obtain x where \"x \\<in> ?S\" and \"cl_ecl x = {}\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x\\<in>{y. derivable_ecl y S}. cl_ecl x \\<noteq> {})\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> {y. derivable_ecl y S}; cl_ecl x = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> {y. derivable_ecl y S}\n  cl_ecl x = {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>{y. derivable_ecl y S}.\n               cl_ecl x \\<noteq> {}) \\<Longrightarrow>\n    False", "from \\<open>x \\<in> ?S\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> {y. derivable_ecl y S}", "have \"derivable_ecl x S\""], ["proof (prove)\nusing this:\n  x \\<in> {y. derivable_ecl y S}\n\ngoal (1 subgoal):\n 1. derivable_ecl x S", "by (meson CollectD)"], ["proof (state)\nthis:\n  derivable_ecl x S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>{y. derivable_ecl y S}.\n               cl_ecl x \\<noteq> {}) \\<Longrightarrow>\n    False", "from this  \\<open>cl_ecl x = {}\\<close> \\<open>\\<not> (\\<exists>x. (derivable_ecl x S) \\<and> cl_ecl x = {})\\<close>"], ["proof (chain)\npicking this:\n  derivable_ecl x S\n  cl_ecl x = {}\n  \\<nexists>x. derivable_ecl x S \\<and> cl_ecl x = {}", "show False"], ["proof (prove)\nusing this:\n  derivable_ecl x S\n  cl_ecl x = {}\n  \\<nexists>x. derivable_ecl x S \\<and> cl_ecl x = {}\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{y. derivable_ecl y S}. cl_ecl x \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<nexists>x. derivable_ecl x S \\<and> cl_ecl x = {} \\<Longrightarrow>\n    False", "have all_finite: \"\\<forall>x \\<in> ?S. (finite (cl_ecl x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{y. derivable_ecl y S}. finite (cl_ecl x)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>{y. derivable_ecl y S}.\n               finite (cl_ecl x)) \\<Longrightarrow>\n    False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>x\\<in>{y. derivable_ecl y S}. finite (cl_ecl x))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>{y. derivable_ecl y S}.\n               finite (cl_ecl x)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>x\\<in>{y. derivable_ecl y S}. finite (cl_ecl x))", "obtain x where \"x \\<in> ?S\" and \"\\<not> finite (cl_ecl x)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x\\<in>{y. derivable_ecl y S}. finite (cl_ecl x))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> {y. derivable_ecl y S};\n         infinite (cl_ecl x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> {y. derivable_ecl y S}\n  infinite (cl_ecl x)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>{y. derivable_ecl y S}.\n               finite (cl_ecl x)) \\<Longrightarrow>\n    False", "from \\<open>x \\<in> ?S\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> {y. derivable_ecl y S}", "have \"derivable_ecl x S\""], ["proof (prove)\nusing this:\n  x \\<in> {y. derivable_ecl y S}\n\ngoal (1 subgoal):\n 1. derivable_ecl x S", "by (meson CollectD)"], ["proof (state)\nthis:\n  derivable_ecl x S\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x\\<in>{y. derivable_ecl y S}.\n               finite (cl_ecl x)) \\<Longrightarrow>\n    False", "from this assms(2) \\<open>\\<not> finite (cl_ecl x)\\<close>"], ["proof (chain)\npicking this:\n  derivable_ecl x S\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  infinite (cl_ecl x)", "show False"], ["proof (prove)\nusing this:\n  derivable_ecl x S\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  infinite (cl_ecl x)\n\ngoal (1 subgoal):\n 1. False", "using all_derived_clauses_are_finite"], ["proof (prove)\nusing this:\n  derivable_ecl x S\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  infinite (cl_ecl x)\n  \\<lbrakk>derivable_ecl ?C ?S;\n   \\<forall>x\\<in>?S. finite (cl_ecl x)\\<rbrakk>\n  \\<Longrightarrow> finite (cl_ecl ?C)\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{y. derivable_ecl y S}. finite (cl_ecl x)\n\ngoal (1 subgoal):\n 1. \\<nexists>x. derivable_ecl x S \\<and> cl_ecl x = {} \\<Longrightarrow>\n    False", "have \"Ball S well_constrained\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball S well_constrained", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> well_constrained x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> well_constrained x", "assume \"x \\<in> S\""], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> well_constrained x", "from this assms(1)"], ["proof (chain)\npicking this:\n  x \\<in> S\n  \\<forall>x. x \\<in> S \\<longrightarrow> trms_ecl x = {}", "have \"trms_ecl x = {}\""], ["proof (prove)\nusing this:\n  x \\<in> S\n  \\<forall>x. x \\<in> S \\<longrightarrow> trms_ecl x = {}\n\ngoal (1 subgoal):\n 1. trms_ecl x = {}", "by auto"], ["proof (state)\nthis:\n  trms_ecl x = {}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> well_constrained x", "from this"], ["proof (chain)\npicking this:\n  trms_ecl x = {}", "show \"well_constrained x\""], ["proof (prove)\nusing this:\n  trms_ecl x = {}\n\ngoal (1 subgoal):\n 1. well_constrained x", "unfolding well_constrained_def"], ["proof (prove)\nusing this:\n  trms_ecl x = {}\n\ngoal (1 subgoal):\n 1. \\<forall>y. y \\<in> trms_ecl x \\<longrightarrow> dom_trm y (cl_ecl x)", "by blast"], ["proof (state)\nthis:\n  well_constrained x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Ball S well_constrained\n\ngoal (1 subgoal):\n 1. \\<nexists>x. derivable_ecl x S \\<and> cl_ecl x = {} \\<Longrightarrow>\n    False", "have \"Ball ?S well_constrained\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball {y. derivable_ecl y S} well_constrained", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {y. derivable_ecl y S} \\<Longrightarrow> well_constrained x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {y. derivable_ecl y S} \\<Longrightarrow> well_constrained x", "assume \"x \\<in> ?S\""], ["proof (state)\nthis:\n  x \\<in> {y. derivable_ecl y S}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {y. derivable_ecl y S} \\<Longrightarrow> well_constrained x", "from this"], ["proof (chain)\npicking this:\n  x \\<in> {y. derivable_ecl y S}", "have \"derivable_ecl x S\""], ["proof (prove)\nusing this:\n  x \\<in> {y. derivable_ecl y S}\n\ngoal (1 subgoal):\n 1. derivable_ecl x S", "by (meson CollectD)"], ["proof (state)\nthis:\n  derivable_ecl x S\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {y. derivable_ecl y S} \\<Longrightarrow> well_constrained x", "from this assms(2) \\<open>Ball S well_constrained\\<close>"], ["proof (chain)\npicking this:\n  derivable_ecl x S\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  Ball S well_constrained", "show \"well_constrained x\""], ["proof (prove)\nusing this:\n  derivable_ecl x S\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  Ball S well_constrained\n\ngoal (1 subgoal):\n 1. well_constrained x", "using all_derived_clauses_are_wellconstrained"], ["proof (prove)\nusing this:\n  derivable_ecl x S\n  \\<forall>x\\<in>S. finite (cl_ecl x)\n  Ball S well_constrained\n  \\<lbrakk>derivable_ecl ?C ?S; Ball ?S well_constrained\\<rbrakk>\n  \\<Longrightarrow> well_constrained ?C\n\ngoal (1 subgoal):\n 1. well_constrained x", "by metis"], ["proof (state)\nthis:\n  well_constrained x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Ball {y. derivable_ecl y S} well_constrained\n\ngoal (1 subgoal):\n 1. \\<nexists>x. derivable_ecl x S \\<and> cl_ecl x = {} \\<Longrightarrow>\n    False", "have \"closed_under_renaming ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_under_renaming {y. derivable_ecl y S}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> closed_under_renaming {y. derivable_ecl y S} \\<Longrightarrow>\n    False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> closed_under_renaming {y. derivable_ecl y S}\n\ngoal (1 subgoal):\n 1. \\<not> closed_under_renaming {y. derivable_ecl y S} \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> closed_under_renaming {y. derivable_ecl y S}", "obtain C D  where \"C \\<in> ?S\" \"renaming_cl C D\" \"D \\<notin> ?S\""], ["proof (prove)\nusing this:\n  \\<not> closed_under_renaming {y. derivable_ecl y S}\n\ngoal (1 subgoal):\n 1. (\\<And>C D.\n        \\<lbrakk>C \\<in> {y. derivable_ecl y S}; renaming_cl C D;\n         D \\<notin> {y. derivable_ecl y S}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding closed_under_renaming_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>C D.\n             C \\<in> {y. derivable_ecl y S} \\<longrightarrow>\n             renaming_cl C D \\<longrightarrow>\n             D \\<in> {y. derivable_ecl y S})\n\ngoal (1 subgoal):\n 1. (\\<And>C D.\n        \\<lbrakk>C \\<in> {y. derivable_ecl y S}; renaming_cl C D;\n         D \\<notin> {y. derivable_ecl y S}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  C \\<in> {y. derivable_ecl y S}\n  renaming_cl C D\n  D \\<notin> {y. derivable_ecl y S}\n\ngoal (1 subgoal):\n 1. \\<not> closed_under_renaming {y. derivable_ecl y S} \\<Longrightarrow>\n    False", "from \\<open>C \\<in> ?S\\<close>"], ["proof (chain)\npicking this:\n  C \\<in> {y. derivable_ecl y S}", "have \"derivable_ecl C S\""], ["proof (prove)\nusing this:\n  C \\<in> {y. derivable_ecl y S}\n\ngoal (1 subgoal):\n 1. derivable_ecl C S", "by (meson CollectD)"], ["proof (state)\nthis:\n  derivable_ecl C S\n\ngoal (1 subgoal):\n 1. \\<not> closed_under_renaming {y. derivable_ecl y S} \\<Longrightarrow>\n    False", "from \\<open>derivable_ecl C S\\<close> \\<open>renaming_cl C D\\<close>"], ["proof (chain)\npicking this:\n  derivable_ecl C S\n  renaming_cl C D", "have \"(derivable_ecl D S)\""], ["proof (prove)\nusing this:\n  derivable_ecl C S\n  renaming_cl C D\n\ngoal (1 subgoal):\n 1. derivable_ecl D S", "using derivable_ecl.intros(2)"], ["proof (prove)\nusing this:\n  derivable_ecl C S\n  renaming_cl C D\n  \\<lbrakk>derivable_ecl ?C ?S; renaming_cl ?C ?D\\<rbrakk>\n  \\<Longrightarrow> derivable_ecl ?D ?S\n\ngoal (1 subgoal):\n 1. derivable_ecl D S", "by metis"], ["proof (state)\nthis:\n  derivable_ecl D S\n\ngoal (1 subgoal):\n 1. \\<not> closed_under_renaming {y. derivable_ecl y S} \\<Longrightarrow>\n    False", "from this and \\<open>D \\<notin> ?S\\<close>"], ["proof (chain)\npicking this:\n  derivable_ecl D S\n  D \\<notin> {y. derivable_ecl y S}", "show False"], ["proof (prove)\nusing this:\n  derivable_ecl D S\n  D \\<notin> {y. derivable_ecl y S}\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  closed_under_renaming {y. derivable_ecl y S}\n\ngoal (1 subgoal):\n 1. \\<nexists>x. derivable_ecl x S \\<and> cl_ecl x = {} \\<Longrightarrow>\n    False", "have \"inference_closed ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inference_closed {y. derivable_ecl y S}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> inference_closed {y. derivable_ecl y S} \\<Longrightarrow> False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> inference_closed {y. derivable_ecl y S}\n\ngoal (1 subgoal):\n 1. \\<not> inference_closed {y. derivable_ecl y S} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> inference_closed {y. derivable_ecl y S}", "obtain D P \\<theta> C' where \"(derivable D P ?S \\<theta> FirstOrder C')\" \"D \\<notin> ?S\""], ["proof (prove)\nusing this:\n  \\<not> inference_closed {y. derivable_ecl y S}\n\ngoal (1 subgoal):\n 1. (\\<And>D P \\<theta> C'.\n        \\<lbrakk>derivable D P {y. derivable_ecl y S} \\<theta> FirstOrder\n                  C';\n         D \\<notin> {y. derivable_ecl y S}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding inference_closed_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>P C' D \\<theta>.\n             derivable D P {y. derivable_ecl y S} \\<theta> FirstOrder\n              C' \\<longrightarrow>\n             D \\<in> {y. derivable_ecl y S})\n\ngoal (1 subgoal):\n 1. (\\<And>D P \\<theta> C'.\n        \\<lbrakk>derivable D P {y. derivable_ecl y S} \\<theta> FirstOrder\n                  C';\n         D \\<notin> {y. derivable_ecl y S}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  derivable D P {y. derivable_ecl y S} \\<theta> FirstOrder C'\n  D \\<notin> {y. derivable_ecl y S}\n\ngoal (1 subgoal):\n 1. \\<not> inference_closed {y. derivable_ecl y S} \\<Longrightarrow> False", "from \\<open>derivable D P ?S \\<theta> FirstOrder C'\\<close>"], ["proof (chain)\npicking this:\n  derivable D P {y. derivable_ecl y S} \\<theta> FirstOrder C'", "have \"P \\<subseteq> ?S\""], ["proof (prove)\nusing this:\n  derivable D P {y. derivable_ecl y S} \\<theta> FirstOrder C'\n\ngoal (1 subgoal):\n 1. P \\<subseteq> {y. derivable_ecl y S}", "using derivable_premisses"], ["proof (prove)\nusing this:\n  derivable D P {y. derivable_ecl y S} \\<theta> FirstOrder C'\n  derivable ?C ?P ?S ?\\<sigma> ?k ?C' \\<Longrightarrow> ?P \\<subseteq> ?S\n\ngoal (1 subgoal):\n 1. P \\<subseteq> {y. derivable_ecl y S}", "by metis"], ["proof (state)\nthis:\n  P \\<subseteq> {y. derivable_ecl y S}\n\ngoal (1 subgoal):\n 1. \\<not> inference_closed {y. derivable_ecl y S} \\<Longrightarrow> False", "have \"\\<forall>x. x \\<in> P \\<longrightarrow> derivable_ecl x S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. x \\<in> P \\<longrightarrow> derivable_ecl x S", "proof ((rule allI),(rule impI))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> derivable_ecl x S", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> derivable_ecl x S", "assume \"x \\<in> P\""], ["proof (state)\nthis:\n  x \\<in> P\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> derivable_ecl x S", "from this and \\<open>P \\<subseteq> ?S\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> P\n  P \\<subseteq> {y. derivable_ecl y S}", "have \"x \\<in> ?S\""], ["proof (prove)\nusing this:\n  x \\<in> P\n  P \\<subseteq> {y. derivable_ecl y S}\n\ngoal (1 subgoal):\n 1. x \\<in> {y. derivable_ecl y S}", "by (meson rev_subsetD)"], ["proof (state)\nthis:\n  x \\<in> {y. derivable_ecl y S}\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> P \\<Longrightarrow> derivable_ecl x S", "from this"], ["proof (chain)\npicking this:\n  x \\<in> {y. derivable_ecl y S}", "show \"derivable_ecl x S\""], ["proof (prove)\nusing this:\n  x \\<in> {y. derivable_ecl y S}\n\ngoal (1 subgoal):\n 1. derivable_ecl x S", "by (meson CollectD)"], ["proof (state)\nthis:\n  derivable_ecl x S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x. x \\<in> P \\<longrightarrow> derivable_ecl x S\n\ngoal (1 subgoal):\n 1. \\<not> inference_closed {y. derivable_ecl y S} \\<Longrightarrow> False", "from this and \\<open>(derivable D P ?S \\<theta> FirstOrder C')\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>x. x \\<in> P \\<longrightarrow> derivable_ecl x S\n  derivable D P {y. derivable_ecl y S} \\<theta> FirstOrder C'", "have \"derivable_ecl D S\""], ["proof (prove)\nusing this:\n  \\<forall>x. x \\<in> P \\<longrightarrow> derivable_ecl x S\n  derivable D P {y. derivable_ecl y S} \\<theta> FirstOrder C'\n\ngoal (1 subgoal):\n 1. derivable_ecl D S", "using derivable_ecl.intros(3) [of P S D ?S \\<theta> C']"], ["proof (prove)\nusing this:\n  \\<forall>x. x \\<in> P \\<longrightarrow> derivable_ecl x S\n  derivable D P {y. derivable_ecl y S} \\<theta> FirstOrder C'\n  \\<lbrakk>\\<forall>x. x \\<in> P \\<longrightarrow> derivable_ecl x S;\n   derivable D P {y. derivable_ecl y S} \\<theta> FirstOrder C'\\<rbrakk>\n  \\<Longrightarrow> derivable_ecl D S\n\ngoal (1 subgoal):\n 1. derivable_ecl D S", "by meson"], ["proof (state)\nthis:\n  derivable_ecl D S\n\ngoal (1 subgoal):\n 1. \\<not> inference_closed {y. derivable_ecl y S} \\<Longrightarrow> False", "from this and \\<open>D \\<notin> ?S\\<close>"], ["proof (chain)\npicking this:\n  derivable_ecl D S\n  D \\<notin> {y. derivable_ecl y S}", "show False"], ["proof (prove)\nusing this:\n  derivable_ecl D S\n  D \\<notin> {y. derivable_ecl y S}\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inference_closed {y. derivable_ecl y S}\n\ngoal (1 subgoal):\n 1. \\<nexists>x. derivable_ecl x S \\<and> cl_ecl x = {} \\<Longrightarrow>\n    False", "from this all_finite"], ["proof (chain)\npicking this:\n  inference_closed {y. derivable_ecl y S}\n  \\<forall>x\\<in>{y. derivable_ecl y S}. finite (cl_ecl x)", "have \"clause_saturated ?S\""], ["proof (prove)\nusing this:\n  inference_closed {y. derivable_ecl y S}\n  \\<forall>x\\<in>{y. derivable_ecl y S}. finite (cl_ecl x)\n\ngoal (1 subgoal):\n 1. clause_saturated {y. derivable_ecl y S}", "using inference_closed_sets_are_saturated"], ["proof (prove)\nusing this:\n  inference_closed {y. derivable_ecl y S}\n  \\<forall>x\\<in>{y. derivable_ecl y S}. finite (cl_ecl x)\n  \\<lbrakk>inference_closed ?S;\n   \\<forall>x\\<in>?S. finite (cl_ecl x)\\<rbrakk>\n  \\<Longrightarrow> clause_saturated ?S\n\ngoal (1 subgoal):\n 1. clause_saturated {y. derivable_ecl y S}", "by meson"], ["proof (state)\nthis:\n  clause_saturated {y. derivable_ecl y S}\n\ngoal (1 subgoal):\n 1. \\<nexists>x. derivable_ecl x S \\<and> cl_ecl x = {} \\<Longrightarrow>\n    False", "from this all_finite"], ["proof (chain)\npicking this:\n  clause_saturated {y. derivable_ecl y S}\n  \\<forall>x\\<in>{y. derivable_ecl y S}. finite (cl_ecl x)", "have \"inference_saturated ?S\""], ["proof (prove)\nusing this:\n  clause_saturated {y. derivable_ecl y S}\n  \\<forall>x\\<in>{y. derivable_ecl y S}. finite (cl_ecl x)\n\ngoal (1 subgoal):\n 1. inference_saturated {y. derivable_ecl y S}", "using clause_saturated_and_inference_saturated"], ["proof (prove)\nusing this:\n  clause_saturated {y. derivable_ecl y S}\n  \\<forall>x\\<in>{y. derivable_ecl y S}. finite (cl_ecl x)\n  \\<lbrakk>clause_saturated ?S;\n   \\<forall>x\\<in>?S. finite (cl_ecl x)\\<rbrakk>\n  \\<Longrightarrow> inference_saturated ?S\n\ngoal (1 subgoal):\n 1. inference_saturated {y. derivable_ecl y S}", "by meson"], ["proof (state)\nthis:\n  inference_saturated {y. derivable_ecl y S}\n\ngoal (1 subgoal):\n 1. \\<nexists>x. derivable_ecl x S \\<and> cl_ecl x = {} \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  inference_saturated {y. derivable_ecl y S}", "have \"ground_inference_saturated ?S\""], ["proof (prove)\nusing this:\n  inference_saturated {y. derivable_ecl y S}\n\ngoal (1 subgoal):\n 1. ground_inference_saturated {y. derivable_ecl y S}", "using lift_inference"], ["proof (prove)\nusing this:\n  inference_saturated {y. derivable_ecl y S}\n  inference_saturated ?S \\<Longrightarrow> ground_inference_saturated ?S\n\ngoal (1 subgoal):\n 1. ground_inference_saturated {y. derivable_ecl y S}", "by metis"], ["proof (state)\nthis:\n  ground_inference_saturated {y. derivable_ecl y S}\n\ngoal (1 subgoal):\n 1. \\<nexists>x. derivable_ecl x S \\<and> cl_ecl x = {} \\<Longrightarrow>\n    False", "have \"validate_clause_set ?I (cl_ecl ` S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. validate_clause_set\n     (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n     (cl_ecl ` S)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set\n            (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n            (cl_ecl ` S) \\<Longrightarrow>\n    False", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  \\<not> validate_clause_set\n          (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n          (cl_ecl ` S)\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set\n            (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n            (cl_ecl ` S) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  \\<not> validate_clause_set\n          (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n          (cl_ecl ` S)", "obtain Cl_C where clc: \"Cl_C \\<in> (cl_ecl ` S)\" and \"\\<not> (validate_clause ?I Cl_C)\""], ["proof (prove)\nusing this:\n  \\<not> validate_clause_set\n          (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n          (cl_ecl ` S)\n\ngoal (1 subgoal):\n 1. (\\<And>Cl_C.\n        \\<lbrakk>Cl_C \\<in> cl_ecl ` S;\n         \\<not> validate_clause\n                 (same_values\n                   (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n                 Cl_C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using validate_clause_set.simps"], ["proof (prove)\nusing this:\n  \\<not> validate_clause_set\n          (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n          (cl_ecl ` S)\n  validate_clause_set ?I ?S =\n  (\\<forall>C. C \\<in> ?S \\<longrightarrow> validate_clause ?I C)\n\ngoal (1 subgoal):\n 1. (\\<And>Cl_C.\n        \\<lbrakk>Cl_C \\<in> cl_ecl ` S;\n         \\<not> validate_clause\n                 (same_values\n                   (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n                 Cl_C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  Cl_C \\<in> cl_ecl ` S\n  \\<not> validate_clause\n          (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S})) Cl_C\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set\n            (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n            (cl_ecl ` S) \\<Longrightarrow>\n    False", "from clc"], ["proof (chain)\npicking this:\n  Cl_C \\<in> cl_ecl ` S", "obtain C where \"C \\<in> S\" and \"Cl_C = (cl_ecl C)\""], ["proof (prove)\nusing this:\n  Cl_C \\<in> cl_ecl ` S\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>C \\<in> S; Cl_C = cl_ecl C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  C \\<in> S\n  Cl_C = cl_ecl C\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set\n            (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n            (cl_ecl ` S) \\<Longrightarrow>\n    False", "from \\<open>C \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  C \\<in> S", "have \"derivable_ecl C S\""], ["proof (prove)\nusing this:\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. derivable_ecl C S", "using derivable_ecl.intros(1)"], ["proof (prove)\nusing this:\n  C \\<in> S\n  ?C \\<in> ?S \\<Longrightarrow> derivable_ecl ?C ?S\n\ngoal (1 subgoal):\n 1. derivable_ecl C S", "by metis"], ["proof (state)\nthis:\n  derivable_ecl C S\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set\n            (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n            (cl_ecl ` S) \\<Longrightarrow>\n    False", "from this"], ["proof (chain)\npicking this:\n  derivable_ecl C S", "have \"C \\<in> ?S\""], ["proof (prove)\nusing this:\n  derivable_ecl C S\n\ngoal (1 subgoal):\n 1. C \\<in> {y. derivable_ecl y S}", "by blast"], ["proof (state)\nthis:\n  C \\<in> {y. derivable_ecl y S}\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set\n            (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n            (cl_ecl ` S) \\<Longrightarrow>\n    False", "from \\<open>\\<not> (validate_clause ?I Cl_C)\\<close>"], ["proof (chain)\npicking this:\n  \\<not> validate_clause\n          (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S})) Cl_C", "obtain \\<sigma>\n      where \"\\<not> (validate_ground_clause ?I (subst_cl Cl_C \\<sigma>))\"\n        and \"ground_clause (subst_cl Cl_C \\<sigma>)\""], ["proof (prove)\nusing this:\n  \\<not> validate_clause\n          (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S})) Cl_C\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        \\<lbrakk>\\<not> validate_ground_clause\n                         (same_values\n                           (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n                         (subst_cl Cl_C \\<sigma>);\n         ground_clause (subst_cl Cl_C \\<sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using validate_clause.simps"], ["proof (prove)\nusing this:\n  \\<not> validate_clause\n          (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S})) Cl_C\n  validate_clause ?I ?C =\n  (\\<forall>s.\n      ground_clause (subst_cl ?C s) \\<longrightarrow>\n      validate_ground_clause ?I (subst_cl ?C s))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        \\<lbrakk>\\<not> validate_ground_clause\n                         (same_values\n                           (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n                         (subst_cl Cl_C \\<sigma>);\n         ground_clause (subst_cl Cl_C \\<sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  \\<not> validate_ground_clause\n          (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n          (subst_cl Cl_C \\<sigma>)\n  ground_clause (subst_cl Cl_C \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set\n            (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n            (cl_ecl ` S) \\<Longrightarrow>\n    False", "let ?pair = \"(C,\\<sigma>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set\n            (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n            (cl_ecl ` S) \\<Longrightarrow>\n    False", "have \"fst ?pair = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (C, \\<sigma>) = C", "by auto"], ["proof (state)\nthis:\n  fst (C, \\<sigma>) = C\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set\n            (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n            (cl_ecl ` S) \\<Longrightarrow>\n    False", "have \"snd ?pair = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (C, \\<sigma>) = \\<sigma>", "by auto"], ["proof (state)\nthis:\n  snd (C, \\<sigma>) = \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set\n            (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n            (cl_ecl ` S) \\<Longrightarrow>\n    False", "from \\<open>C \\<in> S\\<close> assms(1)"], ["proof (chain)\npicking this:\n  C \\<in> S\n  \\<forall>x. x \\<in> S \\<longrightarrow> trms_ecl x = {}", "have \"trms_ecl C = {}\""], ["proof (prove)\nusing this:\n  C \\<in> S\n  \\<forall>x. x \\<in> S \\<longrightarrow> trms_ecl x = {}\n\ngoal (1 subgoal):\n 1. trms_ecl C = {}", "by auto"], ["proof (state)\nthis:\n  trms_ecl C = {}\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set\n            (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n            (cl_ecl ` S) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  trms_ecl C = {}", "have \"(subst_set (trms_ecl C) \\<sigma>) = {}\""], ["proof (prove)\nusing this:\n  trms_ecl C = {}\n\ngoal (1 subgoal):\n 1. subst_set (trms_ecl C) \\<sigma> = {}", "by auto"], ["proof (state)\nthis:\n  subst_set (trms_ecl C) \\<sigma> = {}\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set\n            (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n            (cl_ecl ` S) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  subst_set (trms_ecl C) \\<sigma> = {}", "have n: \"all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>) \n                  (\\<lambda>t. trm_rep t {y. derivable_ecl y S})\""], ["proof (prove)\nusing this:\n  subst_set (trms_ecl C) \\<sigma> = {}\n\ngoal (1 subgoal):\n 1. all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n     (\\<lambda>t. trm_rep t {y. derivable_ecl y S})", "unfolding all_trms_irreducible_def"], ["proof (prove)\nusing this:\n  subst_set (trms_ecl C) \\<sigma> = {}\n\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       x \\<in> subst_set (trms_ecl C) \\<sigma> \\<longrightarrow>\n       occurs_in y x \\<longrightarrow> trm_rep y {y. derivable_ecl y S} = y", "by blast"], ["proof (state)\nthis:\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t {y. derivable_ecl y S})\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set\n            (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n            (cl_ecl ` S) \\<Longrightarrow>\n    False", "from \\<open>ground_inference_saturated ?S\\<close> all_finite \\<open>Ball ?S well_constrained\\<close> \n      \\<open>closed_under_renaming ?S\\<close> \\<open>\\<forall>x \\<in> ?S. (cl_ecl x) \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  ground_inference_saturated {y. derivable_ecl y S}\n  \\<forall>x\\<in>{y. derivable_ecl y S}. finite (cl_ecl x)\n  Ball {y. derivable_ecl y S} well_constrained\n  closed_under_renaming {y. derivable_ecl y S}\n  \\<forall>x\\<in>{y. derivable_ecl y S}. cl_ecl x \\<noteq> {}", "have \"\\<forall>C \\<sigma>. fst ?pair = C \\<longrightarrow>\n           \\<sigma> = snd ?pair \\<longrightarrow>\n           C \\<in> {y. derivable_ecl y S} \\<longrightarrow>\n           ground_clause (subst_cl (cl_ecl C) \\<sigma>) \\<longrightarrow>\n           all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>) (\\<lambda>t. trm_rep t {y. derivable_ecl y S}) \n           \\<longrightarrow> validate_ground_clause ?I  (subst_cl (cl_ecl C) \\<sigma>)\""], ["proof (prove)\nusing this:\n  ground_inference_saturated {y. derivable_ecl y S}\n  \\<forall>x\\<in>{y. derivable_ecl y S}. finite (cl_ecl x)\n  Ball {y. derivable_ecl y S} well_constrained\n  closed_under_renaming {y. derivable_ecl y S}\n  \\<forall>x\\<in>{y. derivable_ecl y S}. cl_ecl x \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>Ca \\<sigma>'.\n       fst (C, \\<sigma>) = Ca \\<longrightarrow>\n       \\<sigma>' = snd (C, \\<sigma>) \\<longrightarrow>\n       Ca \\<in> {y. derivable_ecl y S} \\<longrightarrow>\n       ground_clause (subst_cl (cl_ecl Ca) \\<sigma>') \\<longrightarrow>\n       all_trms_irreducible (subst_set (trms_ecl Ca) \\<sigma>')\n        (\\<lambda>t. trm_rep t {y. derivable_ecl y S}) \\<longrightarrow>\n       validate_ground_clause\n        (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n        (subst_cl (cl_ecl Ca) \\<sigma>')", "using int_clset_is_a_model [of ?S ?pair]"], ["proof (prove)\nusing this:\n  ground_inference_saturated {y. derivable_ecl y S}\n  \\<forall>x\\<in>{y. derivable_ecl y S}. finite (cl_ecl x)\n  Ball {y. derivable_ecl y S} well_constrained\n  closed_under_renaming {y. derivable_ecl y S}\n  \\<forall>x\\<in>{y. derivable_ecl y S}. cl_ecl x \\<noteq> {}\n  \\<lbrakk>ground_inference_saturated {y. derivable_ecl y S};\n   \\<forall>x\\<in>{y. derivable_ecl y S}. finite (cl_ecl x);\n   Ball {y. derivable_ecl y S} well_constrained;\n   \\<forall>x\\<in>{y. derivable_ecl y S}. cl_ecl x \\<noteq> {};\n   closed_under_renaming {y. derivable_ecl y S}\\<rbrakk>\n  \\<Longrightarrow> \\<forall>Ca \\<sigma>'.\n                       fst (C, \\<sigma>) = Ca \\<longrightarrow>\n                       \\<sigma>' = snd (C, \\<sigma>) \\<longrightarrow>\n                       Ca \\<in> {y. derivable_ecl y S} \\<longrightarrow>\n                       ground_clause\n                        (subst_cl (cl_ecl Ca) \\<sigma>') \\<longrightarrow>\n                       all_trms_irreducible\n                        (subst_set (trms_ecl Ca) \\<sigma>')\n                        (\\<lambda>t.\n                            trm_rep t\n                             {y. derivable_ecl y S}) \\<longrightarrow>\n                       validate_ground_clause\n                        (same_values\n                          (\\<lambda>t. trm_rep t {y. derivable_ecl y S}))\n                        (subst_cl (cl_ecl Ca) \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<forall>Ca \\<sigma>'.\n       fst (C, \\<sigma>) = Ca \\<longrightarrow>\n       \\<sigma>' = snd (C, \\<sigma>) \\<longrightarrow>\n       Ca \\<in> {y. derivable_ecl y S} \\<longrightarrow>\n       ground_clause (subst_cl (cl_ecl Ca) \\<sigma>') \\<longrightarrow>\n       all_trms_irreducible (subst_set (trms_ecl Ca) \\<sigma>')\n        (\\<lambda>t. trm_rep t {y. derivable_ecl y S}) \\<longrightarrow>\n       validate_ground_clause\n        (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n        (subst_cl (cl_ecl Ca) \\<sigma>')", "by blast"], ["proof (state)\nthis:\n  \\<forall>Ca \\<sigma>'.\n     fst (C, \\<sigma>) = Ca \\<longrightarrow>\n     \\<sigma>' = snd (C, \\<sigma>) \\<longrightarrow>\n     Ca \\<in> {y. derivable_ecl y S} \\<longrightarrow>\n     ground_clause (subst_cl (cl_ecl Ca) \\<sigma>') \\<longrightarrow>\n     all_trms_irreducible (subst_set (trms_ecl Ca) \\<sigma>')\n      (\\<lambda>t. trm_rep t {y. derivable_ecl y S}) \\<longrightarrow>\n     validate_ground_clause\n      (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n      (subst_cl (cl_ecl Ca) \\<sigma>')\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set\n            (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n            (cl_ecl ` S) \\<Longrightarrow>\n    False", "from this \\<open>fst ?pair = C\\<close> \\<open>C \\<in> ?S\\<close> \\<open>snd ?pair = \\<sigma>\\<close> \\<open>Cl_C = (cl_ecl C)\\<close> \n        \\<open>ground_clause (subst_cl Cl_C \\<sigma>)\\<close> n"], ["proof (chain)\npicking this:\n  \\<forall>Ca \\<sigma>'.\n     fst (C, \\<sigma>) = Ca \\<longrightarrow>\n     \\<sigma>' = snd (C, \\<sigma>) \\<longrightarrow>\n     Ca \\<in> {y. derivable_ecl y S} \\<longrightarrow>\n     ground_clause (subst_cl (cl_ecl Ca) \\<sigma>') \\<longrightarrow>\n     all_trms_irreducible (subst_set (trms_ecl Ca) \\<sigma>')\n      (\\<lambda>t. trm_rep t {y. derivable_ecl y S}) \\<longrightarrow>\n     validate_ground_clause\n      (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n      (subst_cl (cl_ecl Ca) \\<sigma>')\n  fst (C, \\<sigma>) = C\n  C \\<in> {y. derivable_ecl y S}\n  snd (C, \\<sigma>) = \\<sigma>\n  Cl_C = cl_ecl C\n  ground_clause (subst_cl Cl_C \\<sigma>)\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t {y. derivable_ecl y S})", "have \"validate_ground_clause ?I  (subst_cl (cl_ecl C) \\<sigma>)\""], ["proof (prove)\nusing this:\n  \\<forall>Ca \\<sigma>'.\n     fst (C, \\<sigma>) = Ca \\<longrightarrow>\n     \\<sigma>' = snd (C, \\<sigma>) \\<longrightarrow>\n     Ca \\<in> {y. derivable_ecl y S} \\<longrightarrow>\n     ground_clause (subst_cl (cl_ecl Ca) \\<sigma>') \\<longrightarrow>\n     all_trms_irreducible (subst_set (trms_ecl Ca) \\<sigma>')\n      (\\<lambda>t. trm_rep t {y. derivable_ecl y S}) \\<longrightarrow>\n     validate_ground_clause\n      (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n      (subst_cl (cl_ecl Ca) \\<sigma>')\n  fst (C, \\<sigma>) = C\n  C \\<in> {y. derivable_ecl y S}\n  snd (C, \\<sigma>) = \\<sigma>\n  Cl_C = cl_ecl C\n  ground_clause (subst_cl Cl_C \\<sigma>)\n  all_trms_irreducible (subst_set (trms_ecl C) \\<sigma>)\n   (\\<lambda>t. trm_rep t {y. derivable_ecl y S})\n\ngoal (1 subgoal):\n 1. validate_ground_clause\n     (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n     (subst_cl (cl_ecl C) \\<sigma>)", "by metis"], ["proof (state)\nthis:\n  validate_ground_clause\n   (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n   (subst_cl (cl_ecl C) \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<not> validate_clause_set\n            (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n            (cl_ecl ` S) \\<Longrightarrow>\n    False", "from this and \\<open>\\<not> (validate_ground_clause ?I (subst_cl Cl_C \\<sigma>))\\<close> \\<open>Cl_C = (cl_ecl C)\\<close>"], ["proof (chain)\npicking this:\n  validate_ground_clause\n   (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n   (subst_cl (cl_ecl C) \\<sigma>)\n  \\<not> validate_ground_clause\n          (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n          (subst_cl Cl_C \\<sigma>)\n  Cl_C = cl_ecl C", "show False"], ["proof (prove)\nusing this:\n  validate_ground_clause\n   (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n   (subst_cl (cl_ecl C) \\<sigma>)\n  \\<not> validate_ground_clause\n          (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n          (subst_cl Cl_C \\<sigma>)\n  Cl_C = cl_ecl C\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  validate_clause_set\n   (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S})) (cl_ecl ` S)\n\ngoal (1 subgoal):\n 1. \\<nexists>x. derivable_ecl x S \\<and> cl_ecl x = {} \\<Longrightarrow>\n    False", "from this and assms(3) \\<open>fo_interpretation ?I\\<close>"], ["proof (chain)\npicking this:\n  validate_clause_set\n   (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S})) (cl_ecl ` S)\n  \\<not> satisfiable_clause_set (cl_ecl ` S)\n  fo_interpretation\n   (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))", "show False"], ["proof (prove)\nusing this:\n  validate_clause_set\n   (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S})) (cl_ecl ` S)\n  \\<not> satisfiable_clause_set (cl_ecl ` S)\n  fo_interpretation\n   (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n\ngoal (1 subgoal):\n 1. False", "using satisfiable_clause_set_def"], ["proof (prove)\nusing this:\n  validate_clause_set\n   (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S})) (cl_ecl ` S)\n  \\<not> satisfiable_clause_set (cl_ecl ` S)\n  fo_interpretation\n   (same_values (\\<lambda>x. trm_rep x {y. derivable_ecl y S}))\n  satisfiable_clause_set ?S =\n  (\\<exists>I. fo_interpretation I \\<and> validate_clause_set I ?S)\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}