{"file_name": "/home/qj213/afp-2021-10-22/thys/Probabilistic_System_Zoo/Finitely_Bounded_Set_Counterexample.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Probabilistic_System_Zoo", "problem_names": ["lemma card_option_finite[simp]:\n  assumes \"finite (UNIV :: 'k set)\"\n  shows \"card (UNIV :: 'k option set) = Suc (card (UNIV :: 'k set))\"\n  (is \"card ?L = Suc (card ?R)\")", "lemma UNIV_x[simp]:\n  \"(UNIV :: ('a :: enum) x set) = {A, C} \\<union> Bs\"\n  (is \"_ = ?R\")", "lemma Collect_split_in_rel: \"{(x, y). in_rel R x y} = R\"", "lemma False"], "translations": [["", "lemma card_option_finite[simp]:\n  assumes \"finite (UNIV :: 'k set)\"\n  shows \"card (UNIV :: 'k option set) = Suc (card (UNIV :: 'k set))\"\n  (is \"card ?L = Suc (card ?R)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. card UNIV = Suc (card UNIV)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card UNIV = Suc (card UNIV)", "have \"card ?L = Suc (card (?L - {None}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card UNIV = Suc (card (UNIV - {None}))", "by (rule card.remove) (auto simp: assms)"], ["proof (state)\nthis:\n  card UNIV = Suc (card (UNIV - {None}))\n\ngoal (1 subgoal):\n 1. card UNIV = Suc (card UNIV)", "also"], ["proof (state)\nthis:\n  card UNIV = Suc (card (UNIV - {None}))\n\ngoal (1 subgoal):\n 1. card UNIV = Suc (card UNIV)", "have \"card (?L - {None}) = card ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (UNIV - {None}) = card UNIV", "by (rule bij_betw_same_card[of the])\n      (auto simp: bij_betw_def inj_on_def image_iff intro!: bexI[of _ \"Some x\" for x])"], ["proof (state)\nthis:\n  card (UNIV - {None}) = card UNIV\n\ngoal (1 subgoal):\n 1. card UNIV = Suc (card UNIV)", "finally"], ["proof (chain)\npicking this:\n  card UNIV = Suc (card UNIV)", "show ?thesis"], ["proof (prove)\nusing this:\n  card UNIV = Suc (card UNIV)\n\ngoal (1 subgoal):\n 1. card UNIV = Suc (card UNIV)", "."], ["proof (state)\nthis:\n  card UNIV = Suc (card UNIV)\n\ngoal:\nNo subgoals!", "qed"], ["", "datatype ('a :: enum) x = A | B \"'a option\" | C"], ["", "abbreviation \"Bs \\<equiv> B ` (insert None (Some ` set Enum.enum))\""], ["", "lemma UNIV_x[simp]:\n  \"(UNIV :: ('a :: enum) x set) = {A, C} \\<union> Bs\"\n  (is \"_ = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = {A, C} \\<union> Bs", "proof (intro set_eqI iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> x \\<in> {A, C} \\<union> Bs\n 2. \\<And>x. x \\<in> {A, C} \\<union> Bs \\<Longrightarrow> x \\<in> UNIV", "fix x :: \"'a x\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> x \\<in> {A, C} \\<union> Bs\n 2. \\<And>x. x \\<in> {A, C} \\<union> Bs \\<Longrightarrow> x \\<in> UNIV", "show \"x \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> {A, C} \\<union> Bs", "by (cases x) (auto simp add: enum_UNIV)"], ["proof (state)\nthis:\n  x \\<in> {A, C} \\<union> Bs\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> {A, C} \\<union> Bs \\<Longrightarrow> x \\<in> UNIV", "qed simp"], ["", "lemma Collect_split_in_rel: \"{(x, y). in_rel R x y} = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). in_rel R x y} = R", "by auto"], ["", "lift_definition X :: \"('a :: enum x, 'a x) bset\" is \"insert A Bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |insert A Bs| <o |UNIV|", "by (subst finite_card_of_iff_card3) (auto simp: card.insert_remove card_Diff_singleton_if)"], ["", "lift_definition Y :: \"('a :: enum x, 'a x) bset\" is \"insert C Bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |insert C Bs| <o |UNIV|", "by (subst finite_card_of_iff_card3) (auto simp: card.insert_remove card_Diff_singleton_if)"], ["", "lift_definition Z :: \"('a :: enum x, 'a x) bset\" is \"{A, C}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |{A, C}| <o |UNIV|", "by (subst finite_card_of_iff_card3) (auto simp: card.insert_remove card_Diff_singleton_if)"], ["", "lift_definition R :: \"('a x \\<times> 'a x, 'a :: enum x) bset\" is \"insert (A, A) ((\\<lambda>B. (B, C)) ` Bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |insert (A, A) ((\\<lambda>B. (B, C)) ` Bs)| <o |UNIV|", "by (subst finite_card_of_iff_card3)\n    (auto simp: card.insert_remove card_Diff_singleton_if image_iff card_image inj_on_def)"], ["", "lift_definition S :: \"('a x \\<times> 'a x, 'a :: enum x) bset\" is \"insert (C, C) ((\\<lambda>B. (A, B)) ` Bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |insert (C, C) (Pair A ` Bs)| <o |UNIV|", "by (subst finite_card_of_iff_card3)\n    (auto simp: card.insert_remove card_Diff_singleton_if image_iff card_image inj_on_def)"], ["", "lift_definition in_brel :: \"('a \\<times> 'b, 'k) bset \\<Rightarrow> 'a \\<Rightarrow> 'b \\<Rightarrow> bool\" is in_rel"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"rel_bset (in_brel R) X Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_bset (in_brel R) X Z", "unfolding bset.in_rel mem_Collect_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z.\n       set_bset z \\<subseteq> {(x, y). in_brel R x y} \\<and>\n       map_bset fst z = X \\<and> map_bset snd z = Z", "apply (intro exI[of _ R])"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bset R \\<subseteq> {(x, y). in_brel R x y} \\<and>\n    map_bset fst R = X \\<and> map_bset snd R = Z", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (A, A) ((\\<lambda>B. (B, C)) ` Bs)\n    \\<subseteq> {(x, y).\n                 in_rel (insert (A, A) ((\\<lambda>B. (B, C)) ` Bs)) x\n                  y} \\<and>\n    fst ` insert (A, A) ((\\<lambda>B. (B, C)) ` Bs) = insert A Bs \\<and>\n    snd ` insert (A, A) ((\\<lambda>B. (B, C)) ` Bs) = {A, C}", "apply (auto simp: image_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_bset (in_brel R) X Z\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  rel_bset (in_brel R) X Z\n\ngoal (1 subgoal):\n 1. False", "have \"rel_bset (in_brel S) Z Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_bset (in_brel S) Z Y", "unfolding bset.in_rel mem_Collect_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z.\n       set_bset z \\<subseteq> {(x, y). in_brel S x y} \\<and>\n       map_bset fst z = Z \\<and> map_bset snd z = Y", "apply (intro exI[of _ S])"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bset S \\<subseteq> {(x, y). in_brel S x y} \\<and>\n    map_bset fst S = Z \\<and> map_bset snd S = Y", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (C, C) (Pair A ` Bs)\n    \\<subseteq> {(x, y). in_rel (insert (C, C) (Pair A ` Bs)) x y} \\<and>\n    fst ` insert (C, C) (Pair A ` Bs) = {A, C} \\<and>\n    snd ` insert (C, C) (Pair A ` Bs) = insert C Bs", "apply (auto simp: image_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rel_bset (in_brel S) Z Y\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  rel_bset (in_brel R) X Z\n  rel_bset (in_brel S) Z Y", "have \"rel_bset (in_brel R OO in_brel S) X Y\""], ["proof (prove)\nusing this:\n  rel_bset (in_brel R) X Z\n  rel_bset (in_brel S) Z Y\n\ngoal (1 subgoal):\n 1. rel_bset (in_brel R OO in_brel S) X Y", "unfolding bset.rel_compp"], ["proof (prove)\nusing this:\n  rel_bset (in_brel R) X Z\n  rel_bset (in_brel S) Z Y\n\ngoal (1 subgoal):\n 1. (rel_bset (in_brel R) OO rel_bset (in_brel S)) X Y", "by blast"], ["proof (state)\nthis:\n  rel_bset (in_brel R OO in_brel S) X Y\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  rel_bset (in_brel R OO in_brel S) X Y\n\ngoal (1 subgoal):\n 1. False", "have *: \"insert (A, A) ((\\<lambda>B. (B, C)) ` Bs) O insert (C, C) ((\\<lambda>B. (A, B)) ` Bs) =\n    ((\\<lambda>B. (B, C)) ` Bs) \\<union> ((\\<lambda>B. (A, B)) ` Bs)\" (is \"_ = ?RS\" )"], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (A, A) ((\\<lambda>B. (B, C)) ` Bs) O\n    insert (C, C) (Pair A ` Bs) =\n    (\\<lambda>B. (B, C)) ` Bs \\<union> Pair A ` Bs", "by auto"], ["proof (state)\nthis:\n  insert (A, A) ((\\<lambda>B. (B, C)) ` Bs) O insert (C, C) (Pair A ` Bs) =\n  (\\<lambda>B. (B, C)) ` Bs \\<union> Pair A ` Bs\n\ngoal (1 subgoal):\n 1. False", "have \"\\<not> rel_bset (in_brel R OO in_brel S) X Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> rel_bset (in_brel R OO in_brel S) X Y", "unfolding bset.in_rel mem_Collect_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>z.\n       set_bset z \\<subseteq> {(x, y). (in_brel R OO in_brel S) x y} \\<and>\n       map_bset fst z = X \\<and> map_bset snd z = Y", "proof (transfer, safe, unfold relcompp_in_rel * Collect_split_in_rel)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>|z| <o |UNIV|;\n        z \\<subseteq> (\\<lambda>B. (B, C)) ` Bs \\<union> Pair A ` Bs;\n        fst ` z = insert A Bs; snd ` z = insert C Bs\\<rbrakk>\n       \\<Longrightarrow> False", "fix Z :: \"('a :: enum x \\<times> 'a x) set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>|z| <o |UNIV|;\n        z \\<subseteq> (\\<lambda>B. (B, C)) ` Bs \\<union> Pair A ` Bs;\n        fst ` z = insert A Bs; snd ` z = insert C Bs\\<rbrakk>\n       \\<Longrightarrow> False", "note enum_UNIV[simp] UNIV_option_conv[symmetric, simp]"], ["proof (state)\nthis:\n  set enum_class.enum = UNIV\n  insert None (range Some) = UNIV\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>|z| <o |UNIV|;\n        z \\<subseteq> (\\<lambda>B. (B, C)) ` Bs \\<union> Pair A ` Bs;\n        fst ` z = insert A Bs; snd ` z = insert C Bs\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"Z \\<subseteq> ?RS\" \"fst ` Z = insert A Bs\" \"snd ` Z = insert C Bs\""], ["proof (state)\nthis:\n  Z \\<subseteq> (\\<lambda>B. (B, C)) ` Bs \\<union> Pair A ` Bs\n  fst ` Z = insert A Bs\n  snd ` Z = insert C Bs\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>|z| <o |UNIV|;\n        z \\<subseteq> (\\<lambda>B. (B, C)) ` Bs \\<union> Pair A ` Bs;\n        fst ` z = insert A Bs; snd ` z = insert C Bs\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Z \\<subseteq> (\\<lambda>B. (B, C)) ` Bs \\<union> Pair A ` Bs\n  fst ` Z = insert A Bs\n  snd ` Z = insert C Bs", "have \"Z = ?RS\""], ["proof (prove)\nusing this:\n  Z \\<subseteq> (\\<lambda>B. (B, C)) ` Bs \\<union> Pair A ` Bs\n  fst ` Z = insert A Bs\n  snd ` Z = insert C Bs\n\ngoal (1 subgoal):\n 1. Z = (\\<lambda>B. (B, C)) ` Bs \\<union> Pair A ` Bs", "unfolding fst_eq_Domain snd_eq_Range"], ["proof (prove)\nusing this:\n  Z \\<subseteq> (\\<lambda>B. (B, C)) ` Bs \\<union> Pair A ` Bs\n  Domain Z = insert A Bs\n  Range Z = insert C Bs\n\ngoal (1 subgoal):\n 1. Z = (\\<lambda>B. (B, C)) ` Bs \\<union> Pair A ` Bs", "by auto"], ["proof (state)\nthis:\n  Z = (\\<lambda>B. (B, C)) ` Bs \\<union> Pair A ` Bs\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>|z| <o |UNIV|;\n        z \\<subseteq> (\\<lambda>B. (B, C)) ` Bs \\<union> Pair A ` Bs;\n        fst ` z = insert A Bs; snd ` z = insert C Bs\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Z = (\\<lambda>B. (B, C)) ` Bs \\<union> Pair A ` Bs\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>|z| <o |UNIV|;\n        z \\<subseteq> (\\<lambda>B. (B, C)) ` Bs \\<union> Pair A ` Bs;\n        fst ` z = insert A Bs; snd ` z = insert C Bs\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"|Z| <o |UNIV :: 'a x set|\""], ["proof (state)\nthis:\n  |Z| <o |UNIV|\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>|z| <o |UNIV|;\n        z \\<subseteq> (\\<lambda>B. (B, C)) ` Bs \\<union> Pair A ` Bs;\n        fst ` z = insert A Bs; snd ` z = insert C Bs\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  Z = (\\<lambda>B. (B, C)) ` Bs \\<union> Pair A ` Bs\n  |Z| <o |UNIV|", "show False"], ["proof (prove)\nusing this:\n  Z = (\\<lambda>B. (B, C)) ` Bs \\<union> Pair A ` Bs\n  |Z| <o |UNIV|\n\ngoal (1 subgoal):\n 1. False", "unfolding \\<open>Z = ?RS\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>B. (B, C)) ` Bs \\<union> Pair A ` Bs =\n  (\\<lambda>B. (B, C)) ` Bs \\<union> Pair A ` Bs\n  |(\\<lambda>B. (B, C)) ` Bs \\<union> Pair A ` Bs| <o |UNIV|\n\ngoal (1 subgoal):\n 1. False", "by (subst (asm) finite_card_of_iff_card3, simp, simp, subst (asm) card_Un_disjoint)\n        (auto simp: card.insert_remove card_Diff_singleton_if card_image inj_on_def split: if_splits)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> rel_bset (in_brel R OO in_brel S) X Y\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  rel_bset (in_brel R OO in_brel S) X Y\n  \\<not> rel_bset (in_brel R OO in_brel S) X Y", "show False"], ["proof (prove)\nusing this:\n  rel_bset (in_brel R OO in_brel S) X Y\n  \\<not> rel_bset (in_brel R OO in_brel S) X Y\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}