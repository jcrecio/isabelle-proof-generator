{"file_name": "/home/qj213/afp-2021-10-22/thys/Probabilistic_System_Zoo/Probabilistic_Hierarchy.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Probabilistic_System_Zoo", "problem_names": ["lemma mc_rel_eq[unfolded vimage2p_def]:\n  \"BNF_Def.vimage2p un_MC un_MC (rel_pmf (=)) = (=)\"", "lemma dlts_rel_eq[unfolded vimage2p_def]:\n  \"BNF_Def.vimage2p un_DLTS un_DLTS (rel_fun (=) (rel_option (=))) = (=)\"", "lemma react_rel_eq[unfolded vimage2p_def]:\n  \"BNF_Def.vimage2p un_React un_React (rel_fun (=) (rel_option (rel_pmf (=)))) = (=)\"", "lemma all_neq_Inl_ex_eq_Inr[dest]: \"(\\<forall>l. x \\<noteq> Inl l) \\<Longrightarrow> (\\<exists>r. x = Inr r)\"", "lemma all_neq_Inr_ex_eq_Inl[dest]: \"(\\<forall>r. x \\<noteq> Inr r) \\<Longrightarrow> (\\<exists>l. x = Inl l)\"", "lemma all2_neq_Inl_ex_eq_Inr[dest]: \"(\\<forall>a b. x \\<noteq> Inl (a, b)) \\<Longrightarrow> (\\<exists>r. x = Inr r)\"", "lemma all2_neq_Inr_ex_eq_Inl[dest]: \"(\\<forall>a b. x \\<noteq> Inr (a, b)) \\<Longrightarrow> (\\<exists>l. x = Inl l)\"", "lemma rel_prod_simp_asym[simp]:\n  \"\\<And>x y. rel_prod R S (x, y) = (\\<lambda>z. case z of (x', y') \\<Rightarrow> R x x' \\<and> S y y')\"\n  \"\\<And>x y z. rel_prod R S x (y, z) = (case x of (y', z') \\<Rightarrow> R y' y \\<and> S z' z)\"", "lemma map_prod_eq_Pair_iff[simp]:\n  \"map_prod f g x = (y, z) \\<longleftrightarrow> (f (fst x) = y \\<and> g (snd x) = z)\"", "lemmas [abs_def, simp] =\n  sum.rel_map prod.rel_map option.rel_map pmf.rel_map bset.rel_map fun.rel_map nebset.rel_map", "lemmas [simp] =\n  lts.rel_eq lmc.rel_eq lmdp.rel_eq gen.rel_eq str.rel_eq alt.rel_eq sseg.rel_eq seg.rel_eq\n  bun.rel_eq pz.rel_eq mg.rel_eq\n  rel_pmf_return_pmf1 rel_pmf_return_pmf2 set_pmf_not_empty rel_pmf_rel_prod\n  bset.set_map nebset.set_map", "lemmas [simp del] =\n  split_paired_Ex", "lemma bisimilar_eqI:\n  assumes \"\\<And>R. \\<lbrakk>R x y; \\<And>x y. R x y \\<Longrightarrow> Q R (s1 x) (s2 y)\\<rbrakk> \\<Longrightarrow>  P x y\"\n  and \"P x y \\<Longrightarrow> \\<forall>x y. P x y \\<longrightarrow> Q P (s1 x) (s2 y)\"\n  shows \"bisimilar Q s1 s2 x y = P x y\"", "lemma bisimilar_alt:\n  \"\\<And>s1 s2. bisimilar_mc s1 s2 x y = (unfold_mc s1 x = unfold_mc s2 y)\"\n  \"\\<And>s1 s2. bisimilar_dlts s1 s2 x y = (unfold_dlts s1 x = unfold_dlts s2 y)\"\n  \"\\<And>s1 s2. bisimilar_lts s1 s2 x y = (unfold_lts s1 x = unfold_lts s2 y)\"\n  \"\\<And>s1 s2. bisimilar_react s1 s2 x y = (unfold_react s1 x = unfold_react s2 y)\"\n  \"\\<And>s1 s2. bisimilar_lmc s1 s2 x y = (unfold_lmc s1 x = unfold_lmc s2 y)\"\n  \"\\<And>s1 s2. bisimilar_lmdp s1 s2 x y = (unfold_lmdp s1 x = unfold_lmdp s2 y)\"\n  \"\\<And>s1 s2. bisimilar_gen s1 s2 x y = (unfold_gen s1 x = unfold_gen s2 y)\"\n  \"\\<And>s1 s2. bisimilar_str s1 s2 x y = (unfold_str s1 x = unfold_str s2 y)\"\n  \"\\<And>s1 s2. bisimilar_alt s1 s2 x y = (unfold_alt s1 x = unfold_alt s2 y)\"\n  \"\\<And>s1 s2. bisimilar_sseg s1 s2 x y = (unfold_sseg s1 x = unfold_sseg s2 y)\"\n  \"\\<And>s1 s2. bisimilar_seg s1 s2 x y = (unfold_seg s1 x = unfold_seg s2 y)\"\n  \"\\<And>s1 s2. bisimilar_bun s1 s2 x y = (unfold_bun s1 x = unfold_bun s2 y)\"\n  \"\\<And>s1 s2. bisimilar_pz s1 s2 x y = (unfold_pz s1 x = unfold_pz s2 y)\"\n  \"\\<And>s1 s2. bisimilar_mg s1 s2 x y = (unfold_mg s1 x = unfold_mg s2 y)\"", "lemma emb_commute:\n  \"\\<And>s. unfold_lts (lts_of_dlts_emb o s) = lts_of_dlts o unfold_dlts s\"\n  \"\\<And>s. unfold_gen (gen_of_lmc_emb o s) = gen_of_lmc o unfold_lmc s\"\n  \"\\<And>s. unfold_lmdp (lmdp_of_lmc_emb o s) = lmdp_of_lmc o unfold_lmc s\"\n  \"\\<And>s. unfold_react (react_of_dlts_emb o s) = react_of_dlts o unfold_dlts s\"\n  \"\\<And>s. unfold_sseg (sseg_of_lmdp_emb o s) = sseg_of_lmdp o unfold_lmdp s\"\n  \"\\<And>s. unfold_sseg (sseg_of_lts_emb o s) = sseg_of_lts o unfold_lts s\"\n  \"\\<And>s. unfold_sseg (ssegopt_of_alt_emb o s) = ssegopt_of_alt o unfold_alt s\"\n  \"\\<And>s. unfold_sseg (sseg_of_react_emb o s) = sseg_of_react o unfold_react s\"\n  \"\\<And>s. unfold_seg (seg_of_sseg_emb o s) = seg_of_sseg o unfold_sseg s\"\n  \"\\<And>s. unfold_seg (seg_of_gen_emb o s) = seg_of_gen o unfold_gen s\"\n  \"\\<And>s. unfold_bun (bun_of_lts_emb o s) = bun_of_lts o unfold_lts s\"\n  \"\\<And>s. unfold_bun (bunopt_of_alt_emb o s) = bunopt_of_alt o unfold_alt s\"\n  \"\\<And>s. unfold_bun (bun_of_gen_emb o s) = bun_of_gen o unfold_gen s\"\n  \"\\<And>s. unfold_pz (pz_of_seg_emb o s) = pz_of_seg o unfold_seg s\"\n  \"\\<And>s. unfold_pz (pz_of_bun_emb o s) = pz_of_bun o unfold_bun s\"\n  \"\\<And>s. unfold_str (str_of_mc_emb o s) = str_of_mc o unfold_mc s\"\n  \"\\<And>s. unfold_alt (alt_of_str_emb o s) = alt_of_str o unfold_str s\"\n  \"\\<And>s. unfold_sseg (ssegopt_of_sseg_emb o s) = ssegopt_of_sseg o unfold_sseg s\"\n  \"\\<And>s. unfold_seg (segopt_of_seg_emb o s) = segopt_of_seg o unfold_seg s\"\n  \"\\<And>s. unfold_bun (bunopt_of_bun_emb o s) = bunopt_of_bun o unfold_bun s\"\n  \"\\<And>s. unfold_pz (pzopt_of_pz_emb o s) = pzopt_of_pz o unfold_pz s\"\n  \"\\<And>s. unfold_pz (pzopt_of_mg_emb o s) = pzopt_of_mg o unfold_mg s\"\n  \"\\<And>s. unfold_mg (mg_of_pzopt_emb o s) = mg_of_pzopt o unfold_pz s\"\n\n  \"\\<And>s. unfold_mg (mg_of_pz_emb o s) = mg_of_pz o unfold_pz s\"\n  \"\\<And>s. unfold_mg (mg_of_alt1_emb o s) = mg_of_alt1 o unfold_alt s\"\n  \"\\<And>s. unfold_mg (mg_of_alt2_emb o s) = mg_of_alt2 o unfold_alt s\"\n  \"\\<And>s. unfold_pz (pz_of_alt1_emb o s) = pz_of_alt1 o unfold_alt s\"\n  \"\\<And>s. unfold_pz (pz_of_alt2_emb o s) = pz_of_alt2 o unfold_alt s\"", "lemma inj:\n  \"inj lts_of_dlts\"\n  \"inj react_of_dlts\"\n  \"inj gen_of_lmc\"\n  \"inj lmdp_of_lmc\"\n  \"inj sseg_of_lmdp\"\n  \"inj sseg_of_react\"\n  \"inj sseg_of_lts\"\n  \"inj ssegopt_of_alt\"\n  \"inj seg_of_gen\"\n  \"inj seg_of_sseg\"\n  \"inj bun_of_lts\"\n  \"inj bunopt_of_alt\"\n  \"inj bun_of_gen\"\n  \"inj pz_of_seg\"\n  \"inj pz_of_bun\"\n  \"inj str_of_mc\"\n  \"inj alt_of_str\"\n  \"inj ssegopt_of_sseg\"\n  \"inj segopt_of_seg\"\n  \"inj bunopt_of_bun\"\n  \"inj pzopt_of_pz\"\n  \"inj pzopt_of_mg\"\n  \"inj mg_of_pzopt\"\n\n  \"inj mg_of_pz\"\n  \"inj mg_of_alt1\"\n  \"inj mg_of_alt2\"\n  \"inj pz_of_alt1\"\n  \"inj pz_of_alt2\"", "lemma hierarchy:\n  \"\\<And>s1 s2. bisimilar_dlts s1 s2 x y \\<longleftrightarrow> bisimilar_lts (lts_of_dlts_emb o s1) (lts_of_dlts_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_lmc s1 s2 x y \\<longleftrightarrow> bisimilar_gen (gen_of_lmc_emb o s1) (gen_of_lmc_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_lmc s1 s2 x y \\<longleftrightarrow> bisimilar_lmdp (lmdp_of_lmc_emb o s1) (lmdp_of_lmc_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_dlts s1 s2 x y \\<longleftrightarrow> bisimilar_react (react_of_dlts_emb o s1) (react_of_dlts_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_lmdp s1 s2 x y \\<longleftrightarrow> bisimilar_sseg (sseg_of_lmdp_emb o s1) (sseg_of_lmdp_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_lts s1 s2 x y \\<longleftrightarrow> bisimilar_sseg (sseg_of_lts_emb o s1) (sseg_of_lts_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_alt s1 s2 x y \\<longleftrightarrow> bisimilar_sseg (ssegopt_of_alt_emb o s1) (ssegopt_of_alt_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_react s1 s2 x y \\<longleftrightarrow> bisimilar_sseg (sseg_of_react_emb o s1) (sseg_of_react_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_sseg s1 s2 x y \\<longleftrightarrow> bisimilar_seg (seg_of_sseg_emb o s1) (seg_of_sseg_emb o s2) x y\"\n  \"\\<And>(s1 :: _ \\<Rightarrow> ('a option \\<times> _ pmf) set[_]) s2.\n     bisimilar_sseg s1 s2 x y \\<longleftrightarrow> bisimilar_seg (seg_of_sseg_emb o s1) (seg_of_sseg_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_gen s1 s2 x y \\<longleftrightarrow> bisimilar_seg (seg_of_gen_emb o s1) (seg_of_gen_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_lts s1 s2 x y \\<longleftrightarrow> bisimilar_bun (bun_of_lts_emb o s1) (bun_of_lts_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_alt s1 s2 x y \\<longleftrightarrow> bisimilar_bun (bunopt_of_alt_emb o s1) (bunopt_of_alt_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_gen s1 s2 x y \\<longleftrightarrow> bisimilar_bun (bun_of_gen_emb o s1) (bun_of_gen_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_seg s1 s2 x y \\<longleftrightarrow> bisimilar_pz (pz_of_seg_emb o s1) (pz_of_seg_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_bun s1 s2 x y \\<longleftrightarrow> bisimilar_pz (pz_of_bun_emb o s1) (pz_of_bun_emb o s2) x y\"\n  \"\\<And>(s1 :: _ \\<Rightarrow> ('a option \\<times> _) pmf set[_]) s2.\n     bisimilar_seg s1 s2 x y \\<longleftrightarrow> bisimilar_pz (pz_of_seg_emb o s1) (pz_of_seg_emb o s2) x y\"\n  \"\\<And>(s1 :: _ \\<Rightarrow> (('a option \\<times> _) set[_]) pmf) s2.\n     bisimilar_bun s1 s2 x y \\<longleftrightarrow> bisimilar_pz (pz_of_bun_emb o s1) (pz_of_bun_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_mc s1 s2 x y \\<longleftrightarrow> bisimilar_str (str_of_mc_emb o s1) (str_of_mc_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_sseg s1 s2 x y \\<longleftrightarrow> bisimilar_sseg (ssegopt_of_sseg_emb o s1) (ssegopt_of_sseg_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_seg s1 s2 x y \\<longleftrightarrow> bisimilar_seg (segopt_of_seg_emb o s1) (segopt_of_seg_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_bun s1 s2 x y \\<longleftrightarrow> bisimilar_bun (bunopt_of_bun_emb o s1) (bunopt_of_bun_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_pz s1 s2 x y \\<longleftrightarrow> bisimilar_pz (pzopt_of_pz_emb o s1) (pzopt_of_pz_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_str s1 s2 x y \\<longleftrightarrow> bisimilar_alt (alt_of_str_emb o s1) (alt_of_str_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_mg s1 s2 x y \\<longleftrightarrow> bisimilar_pz (pzopt_of_mg_emb o s1) (pzopt_of_mg_emb o s2) x y\"", "lemma\n  \"\\<And>s1 s2. bisimilar_pz s1 s2 x y \\<longleftrightarrow> bisimilar_mg (mg_of_pz_emb o s1) (mg_of_pz_emb o s2) x y\"", "lemma\n  \"\\<And>s1 s2. bisimilar_pz s1 s2 x y \\<longleftrightarrow> bisimilar_mg (mg_of_pzopt_emb o s1) (mg_of_pzopt_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_alt s1 s2 x y \\<longleftrightarrow> bisimilar_mg (mg_of_alt1_emb o s1) (mg_of_alt1_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_alt s1 s2 x y \\<longleftrightarrow> bisimilar_mg (mg_of_alt2_emb o s1) (mg_of_alt2_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_alt s1 s2 x y \\<longleftrightarrow> bisimilar_pz (pz_of_alt1_emb o s1) (pz_of_alt1_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_alt s1 s2 x y \\<longleftrightarrow> bisimilar_pz (pz_of_alt2_emb o s1) (pz_of_alt2_emb o s2) x y\"", "lemma \"\\<exists>f::(('a \\<times> 's) set \\<Rightarrow> 'a \\<Rightarrow> 's set). bij f\"", "lemma \"\\<exists>f::(('a \\<times> 's) set[('a \\<times> 's) set] \\<Rightarrow> 'a \\<Rightarrow> 's set['s set]). bij f\"", "lemma mc_unit:\n  fixes x y :: mc\n  shows \"x = y\"", "lemma \"bisimilar_mc s1 s2 x y\""], "translations": [["", "lemma mc_rel_eq[unfolded vimage2p_def]:\n  \"BNF_Def.vimage2p un_MC un_MC (rel_pmf (=)) = (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BNF_Def.vimage2p un_MC un_MC (rel_pmf (=)) = (=)", "by (auto simp add: vimage2p_def pmf.rel_eq option.rel_eq fun.rel_eq fun_eq_iff mc.expand)"], ["", "lemma dlts_rel_eq[unfolded vimage2p_def]:\n  \"BNF_Def.vimage2p un_DLTS un_DLTS (rel_fun (=) (rel_option (=))) = (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BNF_Def.vimage2p un_DLTS un_DLTS (rel_map (=)) = (=)", "by (auto simp add: vimage2p_def pmf.rel_eq option.rel_eq fun.rel_eq fun_eq_iff dlts.expand)"], ["", "lemma react_rel_eq[unfolded vimage2p_def]:\n  \"BNF_Def.vimage2p un_React un_React (rel_fun (=) (rel_option (rel_pmf (=)))) = (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BNF_Def.vimage2p un_React un_React (rel_map (rel_pmf (=))) = (=)", "by (auto simp add: vimage2p_def pmf.rel_eq option.rel_eq fun.rel_eq fun_eq_iff react.expand)"], ["", "lemma all_neq_Inl_ex_eq_Inr[dest]: \"(\\<forall>l. x \\<noteq> Inl l) \\<Longrightarrow> (\\<exists>r. x = Inr r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l. x \\<noteq> Inl l \\<Longrightarrow> \\<exists>r. x = Inr r", "by (cases x) auto"], ["", "lemma all_neq_Inr_ex_eq_Inl[dest]: \"(\\<forall>r. x \\<noteq> Inr r) \\<Longrightarrow> (\\<exists>l. x = Inl l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r. x \\<noteq> Inr r \\<Longrightarrow> \\<exists>l. x = Inl l", "by (cases x) auto"], ["", "lemma all2_neq_Inl_ex_eq_Inr[dest]: \"(\\<forall>a b. x \\<noteq> Inl (a, b)) \\<Longrightarrow> (\\<exists>r. x = Inr r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b. x \\<noteq> Inl (a, b) \\<Longrightarrow>\n    \\<exists>r. x = Inr r", "by (cases x) auto"], ["", "lemma all2_neq_Inr_ex_eq_Inl[dest]: \"(\\<forall>a b. x \\<noteq> Inr (a, b)) \\<Longrightarrow> (\\<exists>l. x = Inl l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b. x \\<noteq> Inr (a, b) \\<Longrightarrow>\n    \\<exists>l. x = Inl l", "by (cases x) auto"], ["", "lemma rel_prod_simp_asym[simp]:\n  \"\\<And>x y. rel_prod R S (x, y) = (\\<lambda>z. case z of (x', y') \\<Rightarrow> R x x' \\<and> S y y')\"\n  \"\\<And>x y z. rel_prod R S x (y, z) = (case x of (y', z') \\<Rightarrow> R y' y \\<and> S z' z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        rel_prod R S (x, y) =\n        (\\<lambda>z.\n            case z of (x', y') \\<Rightarrow> R x x' \\<and> S y y')) &&&\n    (\\<And>x y z.\n        rel_prod R S x (y, z) =\n        (case x of (y', z') \\<Rightarrow> R y' y \\<and> S z' z))", "by auto"], ["", "lemma map_prod_eq_Pair_iff[simp]:\n  \"map_prod f g x = (y, z) \\<longleftrightarrow> (f (fst x) = y \\<and> g (snd x) = z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_prod f g x = (y, z)) = (f (fst x) = y \\<and> g (snd x) = z)", "by (cases x) auto"], ["", "lemmas [abs_def, simp] =\n  sum.rel_map prod.rel_map option.rel_map pmf.rel_map bset.rel_map fun.rel_map nebset.rel_map"], ["", "lemmas [simp] =\n  lts.rel_eq lmc.rel_eq lmdp.rel_eq gen.rel_eq str.rel_eq alt.rel_eq sseg.rel_eq seg.rel_eq\n  bun.rel_eq pz.rel_eq mg.rel_eq\n  rel_pmf_return_pmf1 rel_pmf_return_pmf2 set_pmf_not_empty rel_pmf_rel_prod\n  bset.set_map nebset.set_map"], ["", "lemmas [simp del] =\n  split_paired_Ex"], ["", "lemma bisimilar_eqI:\n  assumes \"\\<And>R. \\<lbrakk>R x y; \\<And>x y. R x y \\<Longrightarrow> Q R (s1 x) (s2 y)\\<rbrakk> \\<Longrightarrow>  P x y\"\n  and \"P x y \\<Longrightarrow> \\<forall>x y. P x y \\<longrightarrow> Q P (s1 x) (s2 y)\"\n  shows \"bisimilar Q s1 s2 x y = P x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisimilar Q s1 s2 x y = P x y", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?R x y;\n   \\<And>x y. ?R x y \\<Longrightarrow> Q ?R (s1 x) (s2 y)\\<rbrakk>\n  \\<Longrightarrow> P x y\n  P x y \\<Longrightarrow>\n  \\<forall>x y. P x y \\<longrightarrow> Q P (s1 x) (s2 y)\n\ngoal (1 subgoal):\n 1. bisimilar Q s1 s2 x y = P x y", "unfolding bisimilar_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?R x y;\n   \\<And>x y. ?R x y \\<Longrightarrow> Q ?R (s1 x) (s2 y)\\<rbrakk>\n  \\<Longrightarrow> P x y\n  P x y \\<Longrightarrow>\n  \\<forall>x y. P x y \\<longrightarrow> Q P (s1 x) (s2 y)\n\ngoal (1 subgoal):\n 1. (\\<exists>R.\n        R x y \\<and>\n        (\\<forall>x y. R x y \\<longrightarrow> Q R (s1 x) (s2 y))) =\n    P x y", "by auto"], ["", "bundle probabilistic_hierarchy =\n  rel_fun_def[simp]\n  sum.splits[split]\n  prod.splits[split]\n  option.splits[split]\n\n  predicate2_eqD[THEN iffD2, OF mc_rel_eq, dest]\n  predicate2_eqD[THEN iffD2, OF dlts_rel_eq, dest]\n  predicate2_eqD[THEN iffD2, OF lts.rel_eq, dest]\n  predicate2_eqD[THEN iffD2, OF react_rel_eq, dest]\n  predicate2_eqD[THEN iffD2, OF lmc.rel_eq, dest]\n  predicate2_eqD[THEN iffD2, OF lmdp.rel_eq, dest]\n  predicate2_eqD[THEN iffD2, OF gen.rel_eq, dest]\n  predicate2_eqD[THEN iffD2, OF str.rel_eq, dest]\n  predicate2_eqD[THEN iffD2, OF alt.rel_eq, dest]\n  predicate2_eqD[THEN iffD2, OF sseg.rel_eq, dest]\n  predicate2_eqD[THEN iffD2, OF seg.rel_eq, dest]\n  predicate2_eqD[THEN iffD2, OF bun.rel_eq, dest]\n  predicate2_eqD[THEN iffD2, OF pz.rel_eq, dest]\n  predicate2_eqD[THEN iffD2, OF mg.rel_eq, dest]\n\n  iffD1[OF lts.rel_sel, dest!]\n  iffD1[OF lmc.rel_sel, dest!]\n  iffD1[OF lmdp.rel_sel, dest!]\n  iffD1[OF gen.rel_sel, dest!]\n  iffD1[OF str.rel_sel, dest!]\n  iffD1[OF alt.rel_sel, dest!]\n  iffD1[OF sseg.rel_sel, dest!]\n  iffD1[OF seg.rel_sel, dest!]\n  iffD1[OF bun.rel_sel, dest!]\n  iffD1[OF pz.rel_sel, dest!]\n  iffD1[OF mg.rel_sel, dest!]\n\n  pmf.rel_refl[intro]\n  bset.rel_refl[intro]\n  nebset.rel_refl[intro]\n  prod.rel_refl[intro]\n  sum.rel_refl[intro]\n  option.rel_refl[intro]\n\n  pmf.rel_mono_strong[intro]\n  bset.rel_mono_strong[intro]\n  nebset.rel_mono_strong[intro]\n  prod.rel_mono_strong[intro]\n  sum.rel_mono_strong[intro]\n  option.rel_mono_strong[intro]"], ["", "section \\<open>Proofs\\<close>"], ["", "context\nincludes probabilistic_hierarchy\nbegin"], ["", "method bisimilar_alt =\n  rule bisimilar_eqI,\n  match conclusion in \"u1 s1 x = u2 s2 y\" for u1 u2 s1 s2 x y \\<Rightarrow>\n    \\<open>coinduction arbitrary: x y, fastforce\\<close>,\n  fastforce"], ["", "lemma bisimilar_alt:\n  \"\\<And>s1 s2. bisimilar_mc s1 s2 x y = (unfold_mc s1 x = unfold_mc s2 y)\"\n  \"\\<And>s1 s2. bisimilar_dlts s1 s2 x y = (unfold_dlts s1 x = unfold_dlts s2 y)\"\n  \"\\<And>s1 s2. bisimilar_lts s1 s2 x y = (unfold_lts s1 x = unfold_lts s2 y)\"\n  \"\\<And>s1 s2. bisimilar_react s1 s2 x y = (unfold_react s1 x = unfold_react s2 y)\"\n  \"\\<And>s1 s2. bisimilar_lmc s1 s2 x y = (unfold_lmc s1 x = unfold_lmc s2 y)\"\n  \"\\<And>s1 s2. bisimilar_lmdp s1 s2 x y = (unfold_lmdp s1 x = unfold_lmdp s2 y)\"\n  \"\\<And>s1 s2. bisimilar_gen s1 s2 x y = (unfold_gen s1 x = unfold_gen s2 y)\"\n  \"\\<And>s1 s2. bisimilar_str s1 s2 x y = (unfold_str s1 x = unfold_str s2 y)\"\n  \"\\<And>s1 s2. bisimilar_alt s1 s2 x y = (unfold_alt s1 x = unfold_alt s2 y)\"\n  \"\\<And>s1 s2. bisimilar_sseg s1 s2 x y = (unfold_sseg s1 x = unfold_sseg s2 y)\"\n  \"\\<And>s1 s2. bisimilar_seg s1 s2 x y = (unfold_seg s1 x = unfold_seg s2 y)\"\n  \"\\<And>s1 s2. bisimilar_bun s1 s2 x y = (unfold_bun s1 x = unfold_bun s2 y)\"\n  \"\\<And>s1 s2. bisimilar_pz s1 s2 x y = (unfold_pz s1 x = unfold_pz s2 y)\"\n  \"\\<And>s1 s2. bisimilar_mg s1 s2 x y = (unfold_mg s1 x = unfold_mg s2 y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((\\<And>s1 s2.\n          bisimilar_mc s1 s2 x y = (unfold_mc s1 x = unfold_mc s2 y)) &&&\n      (\\<And>s1 s2.\n          bisimilar_dlts s1 s2 x y =\n          (unfold_dlts s1 x = unfold_dlts s2 y)) &&&\n      (\\<And>s1 s2.\n          bisimilar_lts s1 s2 x y =\n          (unfold_lts s1 x = unfold_lts s2 y))) &&&\n     ((\\<And>s1 s2.\n          bisimilar_react s1 s2 x y =\n          (unfold_react s1 x = unfold_react s2 y)) &&&\n      (\\<And>s1 s2.\n          bisimilar_lmc s1 s2 x y =\n          (unfold_lmc s1 x = unfold_lmc s2 y))) &&&\n     (\\<And>s1 s2.\n         bisimilar_lmdp s1 s2 x y =\n         (unfold_lmdp s1 x = unfold_lmdp s2 y)) &&&\n     (\\<And>s1 s2.\n         bisimilar_gen s1 s2 x y = (unfold_gen s1 x = unfold_gen s2 y))) &&&\n    ((\\<And>s1 s2.\n         bisimilar_str s1 s2 x y = (unfold_str s1 x = unfold_str s2 y)) &&&\n     (\\<And>s1 s2.\n         bisimilar_alt s1 s2 x y = (unfold_alt s1 x = unfold_alt s2 y)) &&&\n     (\\<And>s1 s2.\n         bisimilar_sseg s1 s2 x y =\n         (unfold_sseg s1 x = unfold_sseg s2 y))) &&&\n    ((\\<And>s1 s2.\n         bisimilar_seg s1 s2 x y = (unfold_seg s1 x = unfold_seg s2 y)) &&&\n     (\\<And>s1 s2.\n         bisimilar_bun s1 s2 x y = (unfold_bun s1 x = unfold_bun s2 y))) &&&\n    (\\<And>s1 s2.\n        bisimilar_pz s1 s2 x y = (unfold_pz s1 x = unfold_pz s2 y)) &&&\n    (\\<And>s1 s2.\n        bisimilar_mg s1 s2 x y = (unfold_mg s1 x = unfold_mg s2 y))", "by bisimilar_alt+"], ["", "method commute_prover =\n  intro ext,\n  match conclusion in \"u1 s1 x = (emb o u2 s2) x\" for emb u1 u2 s1 s2 x \\<Rightarrow>\n     \\<open>coinduction arbitrary: x, fastforce\\<close>"], ["", "lemma emb_commute:\n  \"\\<And>s. unfold_lts (lts_of_dlts_emb o s) = lts_of_dlts o unfold_dlts s\"\n  \"\\<And>s. unfold_gen (gen_of_lmc_emb o s) = gen_of_lmc o unfold_lmc s\"\n  \"\\<And>s. unfold_lmdp (lmdp_of_lmc_emb o s) = lmdp_of_lmc o unfold_lmc s\"\n  \"\\<And>s. unfold_react (react_of_dlts_emb o s) = react_of_dlts o unfold_dlts s\"\n  \"\\<And>s. unfold_sseg (sseg_of_lmdp_emb o s) = sseg_of_lmdp o unfold_lmdp s\"\n  \"\\<And>s. unfold_sseg (sseg_of_lts_emb o s) = sseg_of_lts o unfold_lts s\"\n  \"\\<And>s. unfold_sseg (ssegopt_of_alt_emb o s) = ssegopt_of_alt o unfold_alt s\"\n  \"\\<And>s. unfold_sseg (sseg_of_react_emb o s) = sseg_of_react o unfold_react s\"\n  \"\\<And>s. unfold_seg (seg_of_sseg_emb o s) = seg_of_sseg o unfold_sseg s\"\n  \"\\<And>s. unfold_seg (seg_of_gen_emb o s) = seg_of_gen o unfold_gen s\"\n  \"\\<And>s. unfold_bun (bun_of_lts_emb o s) = bun_of_lts o unfold_lts s\"\n  \"\\<And>s. unfold_bun (bunopt_of_alt_emb o s) = bunopt_of_alt o unfold_alt s\"\n  \"\\<And>s. unfold_bun (bun_of_gen_emb o s) = bun_of_gen o unfold_gen s\"\n  \"\\<And>s. unfold_pz (pz_of_seg_emb o s) = pz_of_seg o unfold_seg s\"\n  \"\\<And>s. unfold_pz (pz_of_bun_emb o s) = pz_of_bun o unfold_bun s\"\n  \"\\<And>s. unfold_str (str_of_mc_emb o s) = str_of_mc o unfold_mc s\"\n  \"\\<And>s. unfold_alt (alt_of_str_emb o s) = alt_of_str o unfold_str s\"\n  \"\\<And>s. unfold_sseg (ssegopt_of_sseg_emb o s) = ssegopt_of_sseg o unfold_sseg s\"\n  \"\\<And>s. unfold_seg (segopt_of_seg_emb o s) = segopt_of_seg o unfold_seg s\"\n  \"\\<And>s. unfold_bun (bunopt_of_bun_emb o s) = bunopt_of_bun o unfold_bun s\"\n  \"\\<And>s. unfold_pz (pzopt_of_pz_emb o s) = pzopt_of_pz o unfold_pz s\"\n  \"\\<And>s. unfold_pz (pzopt_of_mg_emb o s) = pzopt_of_mg o unfold_mg s\"\n  \"\\<And>s. unfold_mg (mg_of_pzopt_emb o s) = mg_of_pzopt o unfold_pz s\"\n\n  \"\\<And>s. unfold_mg (mg_of_pz_emb o s) = mg_of_pz o unfold_pz s\"\n  \"\\<And>s. unfold_mg (mg_of_alt1_emb o s) = mg_of_alt1 o unfold_alt s\"\n  \"\\<And>s. unfold_mg (mg_of_alt2_emb o s) = mg_of_alt2 o unfold_alt s\"\n  \"\\<And>s. unfold_pz (pz_of_alt1_emb o s) = pz_of_alt1 o unfold_alt s\"\n  \"\\<And>s. unfold_pz (pz_of_alt2_emb o s) = pz_of_alt2 o unfold_alt s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((((\\<And>s.\n           unfold_lts (bgraph \\<circ> s) =\n           lts_of_dlts \\<circ> unfold_dlts s) &&&\n       (\\<And>s.\n           unfold_gen\n            (Some \\<circ>\n             (\\<lambda>(x, y). (map_pmf \\<circ> Pair) x y) \\<circ>\n             s) =\n           gen_of_lmc \\<circ> unfold_lmc s) &&&\n       (\\<And>s.\n           unfold_lmdp (map_prod id nebsingleton \\<circ> s) =\n           lmdp_of_lmc \\<circ> unfold_lmc s)) &&&\n      ((\\<And>s.\n           unfold_react ((\\<circ>) (map_option return_pmf) \\<circ> s) =\n           react_of_dlts \\<circ> unfold_dlts s) &&&\n       (\\<And>s.\n           unfold_sseg\n            ((\\<lambda>(a, X). map_bset (Pair a) (bset_of_nebset X)) \\<circ>\n             s) =\n           sseg_of_lmdp \\<circ> unfold_lmdp s)) &&&\n      (\\<And>s.\n          unfold_sseg (map_bset (map_prod id return_pmf) \\<circ> s) =\n          sseg_of_lts \\<circ> unfold_lts s) &&&\n      (\\<And>s.\n          unfold_sseg\n           (case_sum (map_bset (Pair None) \\<circ> bsingleton)\n             (map_bset (map_prod Some return_pmf)) \\<circ>\n            s) =\n          ssegopt_of_alt \\<circ> unfold_alt s)) &&&\n     ((\\<And>s.\n          unfold_sseg (bgraph \\<circ> s) =\n          sseg_of_react \\<circ> unfold_react s) &&&\n      (\\<And>s.\n          unfold_seg\n           (map_bset (\\<lambda>(x, y). (map_pmf \\<circ> Pair) x y) \\<circ>\n            s) =\n          seg_of_sseg \\<circ> unfold_sseg s) &&&\n      (\\<And>s.\n          unfold_seg (bset_of_option \\<circ> s) =\n          seg_of_gen \\<circ> unfold_gen s)) &&&\n     ((\\<And>s.\n          unfold_bun (return_pmf \\<circ> s) =\n          bun_of_lts \\<circ> unfold_lts s) &&&\n      (\\<And>s.\n          unfold_bun\n           (case_sum (map_pmf (bsingleton \\<circ> Pair None))\n             (map_pmf (map_bset (map_prod Some id)) \\<circ>\n              return_pmf) \\<circ>\n            s) =\n          bunopt_of_alt \\<circ> unfold_alt s)) &&&\n     (\\<And>s.\n         unfold_bun\n          (case_option (return_pmf bempty) (map_pmf bsingleton) \\<circ> s) =\n         bun_of_gen \\<circ> unfold_gen s) &&&\n     (\\<And>s.\n         unfold_pz (map_bset (map_pmf bsingleton) \\<circ> s) =\n         pz_of_seg \\<circ> unfold_seg s)) &&&\n    (((\\<And>s.\n          unfold_pz (bsingleton \\<circ> s) =\n          pz_of_bun \\<circ> unfold_bun s) &&&\n      (\\<And>s.\n          unfold_str (Inl \\<circ> s) = str_of_mc \\<circ> unfold_mc s) &&&\n      (\\<And>s.\n          unfold_alt (map_sum id bset_of_option \\<circ> s) =\n          alt_of_str \\<circ> unfold_str s)) &&&\n     ((\\<And>s.\n          unfold_sseg (map_bset (map_prod Some id) \\<circ> s) =\n          ssegopt_of_sseg \\<circ> unfold_sseg s) &&&\n      (\\<And>s.\n          unfold_seg (map_bset (map_pmf (map_prod Some id)) \\<circ> s) =\n          segopt_of_seg \\<circ> unfold_seg s)) &&&\n     (\\<And>s.\n         unfold_bun (map_pmf (map_bset (map_prod Some id)) \\<circ> s) =\n         bunopt_of_bun \\<circ> unfold_bun s) &&&\n     (\\<And>s.\n         unfold_pz\n          (map_bset (map_pmf (map_bset (map_prod Some id))) \\<circ> s) =\n         pzopt_of_pz \\<circ> unfold_pz s)) &&&\n    ((\\<And>s.\n         unfold_pz\n          (map_bset\n            (map_pmf\n              (map_bset (case_sum (map_prod Some id) (Pair None)))) \\<circ>\n           s) =\n         pzopt_of_mg \\<circ> unfold_mg s) &&&\n     (\\<And>s.\n         unfold_mg\n          (map_bset\n            (map_pmf\n              (map_bset\n                (\\<lambda>(a, s).\n                    case a of None \\<Rightarrow> Inr s\n                    | Some a \\<Rightarrow> Inl (a, s)))) \\<circ>\n           s) =\n         mg_of_pzopt \\<circ> unfold_pz s) &&&\n     (\\<And>s.\n         unfold_mg (map_bset (map_pmf (map_bset Inl)) \\<circ> s) =\n         mg_of_pz \\<circ> unfold_pz s)) &&&\n    ((\\<And>s.\n         unfold_mg\n          (case_sum\n            (map_bset (map_pmf (map_bset Inr \\<circ> bsingleton)) \\<circ>\n             bsingleton)\n            (map_bset\n              (map_pmf (map_bset Inl \\<circ> bsingleton) \\<circ>\n               return_pmf)) \\<circ>\n           s) =\n         mg_of_alt1 \\<circ> unfold_alt s) &&&\n     (\\<And>s.\n         unfold_mg\n          (case_sum\n            (map_bset (map_pmf (map_bset Inr \\<circ> bsingleton)) \\<circ>\n             bsingleton)\n            (map_bset (map_pmf (map_bset Inl) \\<circ> return_pmf) \\<circ>\n             bsingleton) \\<circ>\n           s) =\n         mg_of_alt2 \\<circ> unfold_alt s)) &&&\n    (\\<And>s.\n        unfold_pz\n         (case_sum\n           (map_bset\n             (map_pmf (map_bset (Pair None) \\<circ> bsingleton)) \\<circ>\n            bsingleton)\n           (map_bset\n             (map_pmf\n               (map_bset (map_prod Some id) \\<circ> bsingleton) \\<circ>\n              return_pmf)) \\<circ>\n          s) =\n        pz_of_alt1 \\<circ> unfold_alt s) &&&\n    (\\<And>s.\n        unfold_pz\n         (case_sum\n           (map_bset\n             (map_pmf (map_bset (Pair None) \\<circ> bsingleton)) \\<circ>\n            bsingleton)\n           (map_bset\n             (map_pmf (map_bset (map_prod Some id)) \\<circ>\n              return_pmf) \\<circ>\n            bsingleton) \\<circ>\n          s) =\n        pz_of_alt2 \\<circ> unfold_alt s)", "by commute_prover+"], ["", "method inj_prover =\n  intro injI,\n  match conclusion in \"x = y\" for x y \\<Rightarrow> \\<open>coinduction arbitrary: x y, fastforce\\<close>"], ["", "lemma inj:\n  \"inj lts_of_dlts\"\n  \"inj react_of_dlts\"\n  \"inj gen_of_lmc\"\n  \"inj lmdp_of_lmc\"\n  \"inj sseg_of_lmdp\"\n  \"inj sseg_of_react\"\n  \"inj sseg_of_lts\"\n  \"inj ssegopt_of_alt\"\n  \"inj seg_of_gen\"\n  \"inj seg_of_sseg\"\n  \"inj bun_of_lts\"\n  \"inj bunopt_of_alt\"\n  \"inj bun_of_gen\"\n  \"inj pz_of_seg\"\n  \"inj pz_of_bun\"\n  \"inj str_of_mc\"\n  \"inj alt_of_str\"\n  \"inj ssegopt_of_sseg\"\n  \"inj segopt_of_seg\"\n  \"inj bunopt_of_bun\"\n  \"inj pzopt_of_pz\"\n  \"inj pzopt_of_mg\"\n  \"inj mg_of_pzopt\"\n\n  \"inj mg_of_pz\"\n  \"inj mg_of_alt1\"\n  \"inj mg_of_alt2\"\n  \"inj pz_of_alt1\"\n  \"inj pz_of_alt2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((inj lts_of_dlts &&& inj react_of_dlts &&& inj gen_of_lmc) &&&\n      (inj lmdp_of_lmc &&& inj sseg_of_lmdp) &&&\n      inj sseg_of_react &&& inj sseg_of_lts) &&&\n     (inj ssegopt_of_alt &&& inj seg_of_gen &&& inj seg_of_sseg) &&&\n     (inj bun_of_lts &&& inj bunopt_of_alt) &&&\n     inj bun_of_gen &&& inj pz_of_seg) &&&\n    ((inj pz_of_bun &&& inj str_of_mc &&& inj alt_of_str) &&&\n     (inj ssegopt_of_sseg &&& inj segopt_of_seg) &&&\n     inj bunopt_of_bun &&& inj pzopt_of_pz) &&&\n    (inj pzopt_of_mg &&& inj mg_of_pzopt &&& inj mg_of_pz) &&&\n    (inj mg_of_alt1 &&& inj mg_of_alt2) &&&\n    inj pz_of_alt1 &&& inj pz_of_alt2", "by inj_prover+"], ["", "end"], ["", "lemma hierarchy:\n  \"\\<And>s1 s2. bisimilar_dlts s1 s2 x y \\<longleftrightarrow> bisimilar_lts (lts_of_dlts_emb o s1) (lts_of_dlts_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_lmc s1 s2 x y \\<longleftrightarrow> bisimilar_gen (gen_of_lmc_emb o s1) (gen_of_lmc_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_lmc s1 s2 x y \\<longleftrightarrow> bisimilar_lmdp (lmdp_of_lmc_emb o s1) (lmdp_of_lmc_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_dlts s1 s2 x y \\<longleftrightarrow> bisimilar_react (react_of_dlts_emb o s1) (react_of_dlts_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_lmdp s1 s2 x y \\<longleftrightarrow> bisimilar_sseg (sseg_of_lmdp_emb o s1) (sseg_of_lmdp_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_lts s1 s2 x y \\<longleftrightarrow> bisimilar_sseg (sseg_of_lts_emb o s1) (sseg_of_lts_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_alt s1 s2 x y \\<longleftrightarrow> bisimilar_sseg (ssegopt_of_alt_emb o s1) (ssegopt_of_alt_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_react s1 s2 x y \\<longleftrightarrow> bisimilar_sseg (sseg_of_react_emb o s1) (sseg_of_react_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_sseg s1 s2 x y \\<longleftrightarrow> bisimilar_seg (seg_of_sseg_emb o s1) (seg_of_sseg_emb o s2) x y\"\n  \"\\<And>(s1 :: _ \\<Rightarrow> ('a option \\<times> _ pmf) set[_]) s2.\n     bisimilar_sseg s1 s2 x y \\<longleftrightarrow> bisimilar_seg (seg_of_sseg_emb o s1) (seg_of_sseg_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_gen s1 s2 x y \\<longleftrightarrow> bisimilar_seg (seg_of_gen_emb o s1) (seg_of_gen_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_lts s1 s2 x y \\<longleftrightarrow> bisimilar_bun (bun_of_lts_emb o s1) (bun_of_lts_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_alt s1 s2 x y \\<longleftrightarrow> bisimilar_bun (bunopt_of_alt_emb o s1) (bunopt_of_alt_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_gen s1 s2 x y \\<longleftrightarrow> bisimilar_bun (bun_of_gen_emb o s1) (bun_of_gen_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_seg s1 s2 x y \\<longleftrightarrow> bisimilar_pz (pz_of_seg_emb o s1) (pz_of_seg_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_bun s1 s2 x y \\<longleftrightarrow> bisimilar_pz (pz_of_bun_emb o s1) (pz_of_bun_emb o s2) x y\"\n  \"\\<And>(s1 :: _ \\<Rightarrow> ('a option \\<times> _) pmf set[_]) s2.\n     bisimilar_seg s1 s2 x y \\<longleftrightarrow> bisimilar_pz (pz_of_seg_emb o s1) (pz_of_seg_emb o s2) x y\"\n  \"\\<And>(s1 :: _ \\<Rightarrow> (('a option \\<times> _) set[_]) pmf) s2.\n     bisimilar_bun s1 s2 x y \\<longleftrightarrow> bisimilar_pz (pz_of_bun_emb o s1) (pz_of_bun_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_mc s1 s2 x y \\<longleftrightarrow> bisimilar_str (str_of_mc_emb o s1) (str_of_mc_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_sseg s1 s2 x y \\<longleftrightarrow> bisimilar_sseg (ssegopt_of_sseg_emb o s1) (ssegopt_of_sseg_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_seg s1 s2 x y \\<longleftrightarrow> bisimilar_seg (segopt_of_seg_emb o s1) (segopt_of_seg_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_bun s1 s2 x y \\<longleftrightarrow> bisimilar_bun (bunopt_of_bun_emb o s1) (bunopt_of_bun_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_pz s1 s2 x y \\<longleftrightarrow> bisimilar_pz (pzopt_of_pz_emb o s1) (pzopt_of_pz_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_str s1 s2 x y \\<longleftrightarrow> bisimilar_alt (alt_of_str_emb o s1) (alt_of_str_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_mg s1 s2 x y \\<longleftrightarrow> bisimilar_pz (pzopt_of_mg_emb o s1) (pzopt_of_mg_emb o s2) x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((((\\<And>s1 s2.\n           bisimilar_dlts s1 s2 x y =\n           bisimilar_lts (bgraph \\<circ> s1) (bgraph \\<circ> s2) x y) &&&\n       (\\<And>s1 s2.\n           bisimilar_lmc s1 s2 x y =\n           bisimilar_gen\n            (Some \\<circ>\n             (\\<lambda>(x, y). (map_pmf \\<circ> Pair) x y) \\<circ>\n             s1)\n            (Some \\<circ>\n             (\\<lambda>(x, y). (map_pmf \\<circ> Pair) x y) \\<circ>\n             s2)\n            x y) &&&\n       (\\<And>s1 s2.\n           bisimilar_lmc s1 s2 x y =\n           bisimilar_lmdp (map_prod id nebsingleton \\<circ> s1)\n            (map_prod id nebsingleton \\<circ> s2) x y)) &&&\n      (\\<And>s1 s2.\n          bisimilar_dlts s1 s2 x y =\n          bisimilar_react ((\\<circ>) (map_option return_pmf) \\<circ> s1)\n           ((\\<circ>) (map_option return_pmf) \\<circ> s2) x y) &&&\n      (\\<And>s1 s2.\n          bisimilar_lmdp s1 s2 x y =\n          bisimilar_sseg\n           ((\\<lambda>(a, X). map_bset (Pair a) (bset_of_nebset X)) \\<circ>\n            s1)\n           ((\\<lambda>(a, X). map_bset (Pair a) (bset_of_nebset X)) \\<circ>\n            s2)\n           x y) &&&\n      (\\<And>s1 s2.\n          bisimilar_lts s1 s2 x y =\n          bisimilar_sseg (map_bset (map_prod id return_pmf) \\<circ> s1)\n           (map_bset (map_prod id return_pmf) \\<circ> s2) x y)) &&&\n     ((\\<And>s1 s2.\n          bisimilar_alt s1 s2 x y =\n          bisimilar_sseg\n           (case_sum (map_bset (Pair None) \\<circ> bsingleton)\n             (map_bset (map_prod Some return_pmf)) \\<circ>\n            s1)\n           (case_sum (map_bset (Pair None) \\<circ> bsingleton)\n             (map_bset (map_prod Some return_pmf)) \\<circ>\n            s2)\n           x y) &&&\n      (\\<And>s1 s2.\n          bisimilar_react s1 s2 x y =\n          bisimilar_sseg (bgraph \\<circ> s1) (bgraph \\<circ> s2) x y) &&&\n      (\\<And>s1 s2.\n          bisimilar_sseg s1 s2 x y =\n          bisimilar_seg\n           (map_bset (\\<lambda>(x, y). (map_pmf \\<circ> Pair) x y) \\<circ>\n            s1)\n           (map_bset (\\<lambda>(x, y). (map_pmf \\<circ> Pair) x y) \\<circ>\n            s2)\n           x y)) &&&\n     (\\<And>s1 s2.\n         bisimilar_sseg s1 s2 x y =\n         bisimilar_seg\n          (map_bset (\\<lambda>(x, y). (map_pmf \\<circ> Pair) x y) \\<circ>\n           s1)\n          (map_bset (\\<lambda>(x, y). (map_pmf \\<circ> Pair) x y) \\<circ>\n           s2)\n          x y) &&&\n     (\\<And>s1 s2.\n         bisimilar_gen s1 s2 x y =\n         bisimilar_seg (bset_of_option \\<circ> s1)\n          (bset_of_option \\<circ> s2) x y) &&&\n     (\\<And>s1 s2.\n         bisimilar_lts s1 s2 x y =\n         bisimilar_bun (return_pmf \\<circ> s1) (return_pmf \\<circ> s2) x\n          y)) &&&\n    (((\\<And>s1 s2.\n          bisimilar_alt s1 s2 x y =\n          bisimilar_bun\n           (case_sum (map_pmf (bsingleton \\<circ> Pair None))\n             (map_pmf (map_bset (map_prod Some id)) \\<circ>\n              return_pmf) \\<circ>\n            s1)\n           (case_sum (map_pmf (bsingleton \\<circ> Pair None))\n             (map_pmf (map_bset (map_prod Some id)) \\<circ>\n              return_pmf) \\<circ>\n            s2)\n           x y) &&&\n      (\\<And>s1 s2.\n          bisimilar_gen s1 s2 x y =\n          bisimilar_bun\n           (case_option (return_pmf bempty) (map_pmf bsingleton) \\<circ> s1)\n           (case_option (return_pmf bempty) (map_pmf bsingleton) \\<circ> s2)\n           x y) &&&\n      (\\<And>s1 s2.\n          bisimilar_seg s1 s2 x y =\n          bisimilar_pz (map_bset (map_pmf bsingleton) \\<circ> s1)\n           (map_bset (map_pmf bsingleton) \\<circ> s2) x y)) &&&\n     (\\<And>s1 s2.\n         bisimilar_bun s1 s2 x y =\n         bisimilar_pz (bsingleton \\<circ> s1) (bsingleton \\<circ> s2) x\n          y) &&&\n     (\\<And>s1 s2.\n         bisimilar_seg s1 s2 x y =\n         bisimilar_pz (map_bset (map_pmf bsingleton) \\<circ> s1)\n          (map_bset (map_pmf bsingleton) \\<circ> s2) x y) &&&\n     (\\<And>s1 s2.\n         bisimilar_bun s1 s2 x y =\n         bisimilar_pz (bsingleton \\<circ> s1) (bsingleton \\<circ> s2) x\n          y)) &&&\n    ((\\<And>s1 s2.\n         bisimilar_mc s1 s2 x y =\n         bisimilar_str (Inl \\<circ> s1) (Inl \\<circ> s2) x y) &&&\n     (\\<And>s1 s2.\n         bisimilar_sseg s1 s2 x y =\n         bisimilar_sseg (map_bset (map_prod Some id) \\<circ> s1)\n          (map_bset (map_prod Some id) \\<circ> s2) x y) &&&\n     (\\<And>s1 s2.\n         bisimilar_seg s1 s2 x y =\n         bisimilar_seg (map_bset (map_pmf (map_prod Some id)) \\<circ> s1)\n          (map_bset (map_pmf (map_prod Some id)) \\<circ> s2) x y)) &&&\n    ((\\<And>s1 s2.\n         bisimilar_bun s1 s2 x y =\n         bisimilar_bun (map_pmf (map_bset (map_prod Some id)) \\<circ> s1)\n          (map_pmf (map_bset (map_prod Some id)) \\<circ> s2) x y) &&&\n     (\\<And>s1 s2.\n         bisimilar_pz s1 s2 x y =\n         bisimilar_pz\n          (map_bset (map_pmf (map_bset (map_prod Some id))) \\<circ> s1)\n          (map_bset (map_pmf (map_bset (map_prod Some id))) \\<circ> s2) x\n          y)) &&&\n    (\\<And>s1 s2.\n        bisimilar_str s1 s2 x y =\n        bisimilar_alt (map_sum id bset_of_option \\<circ> s1)\n         (map_sum id bset_of_option \\<circ> s2) x y) &&&\n    (\\<And>s1 s2.\n        bisimilar_mg s1 s2 x y =\n        bisimilar_pz\n         (map_bset\n           (map_pmf\n             (map_bset (case_sum (map_prod Some id) (Pair None)))) \\<circ>\n          s1)\n         (map_bset\n           (map_pmf\n             (map_bset (case_sum (map_prod Some id) (Pair None)))) \\<circ>\n          s2)\n         x y)", "unfolding inj[THEN inj_eq] bisimilar_alt emb_commute o_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((((\\<And>s1 s2.\n           (unfold_dlts s1 x = unfold_dlts s2 y) =\n           (unfold_dlts s1 x = unfold_dlts s2 y)) &&&\n       (\\<And>s1 s2.\n           (unfold_lmc s1 x = unfold_lmc s2 y) =\n           (unfold_lmc s1 x = unfold_lmc s2 y)) &&&\n       (\\<And>s1 s2.\n           (unfold_lmc s1 x = unfold_lmc s2 y) =\n           (unfold_lmc s1 x = unfold_lmc s2 y))) &&&\n      (\\<And>s1 s2.\n          (unfold_dlts s1 x = unfold_dlts s2 y) =\n          (unfold_dlts s1 x = unfold_dlts s2 y)) &&&\n      (\\<And>s1 s2.\n          (unfold_lmdp s1 x = unfold_lmdp s2 y) =\n          (unfold_lmdp s1 x = unfold_lmdp s2 y)) &&&\n      (\\<And>s1 s2.\n          (unfold_lts s1 x = unfold_lts s2 y) =\n          (unfold_lts s1 x = unfold_lts s2 y))) &&&\n     ((\\<And>s1 s2.\n          (unfold_alt s1 x = unfold_alt s2 y) =\n          (unfold_alt s1 x = unfold_alt s2 y)) &&&\n      (\\<And>s1 s2.\n          (unfold_react s1 x = unfold_react s2 y) =\n          (unfold_react s1 x = unfold_react s2 y)) &&&\n      (\\<And>s1 s2.\n          (unfold_sseg s1 x = unfold_sseg s2 y) =\n          (unfold_sseg s1 x = unfold_sseg s2 y))) &&&\n     (\\<And>s1 s2.\n         (unfold_sseg s1 x = unfold_sseg s2 y) =\n         (unfold_sseg s1 x = unfold_sseg s2 y)) &&&\n     (\\<And>s1 s2.\n         (unfold_gen s1 x = unfold_gen s2 y) =\n         (unfold_gen s1 x = unfold_gen s2 y)) &&&\n     (\\<And>s1 s2.\n         (unfold_lts s1 x = unfold_lts s2 y) =\n         (unfold_lts s1 x = unfold_lts s2 y))) &&&\n    (((\\<And>s1 s2.\n          (unfold_alt s1 x = unfold_alt s2 y) =\n          (unfold_alt s1 x = unfold_alt s2 y)) &&&\n      (\\<And>s1 s2.\n          (unfold_gen s1 x = unfold_gen s2 y) =\n          (unfold_gen s1 x = unfold_gen s2 y)) &&&\n      (\\<And>s1 s2.\n          (unfold_seg s1 x = unfold_seg s2 y) =\n          (unfold_seg s1 x = unfold_seg s2 y))) &&&\n     (\\<And>s1 s2.\n         (unfold_bun s1 x = unfold_bun s2 y) =\n         (unfold_bun s1 x = unfold_bun s2 y)) &&&\n     (\\<And>s1 s2.\n         (unfold_seg s1 x = unfold_seg s2 y) =\n         (unfold_seg s1 x = unfold_seg s2 y)) &&&\n     (\\<And>s1 s2.\n         (unfold_bun s1 x = unfold_bun s2 y) =\n         (unfold_bun s1 x = unfold_bun s2 y))) &&&\n    ((\\<And>s1 s2.\n         (unfold_mc s1 x = unfold_mc s2 y) =\n         (unfold_mc s1 x = unfold_mc s2 y)) &&&\n     (\\<And>s1 s2.\n         (unfold_sseg s1 x = unfold_sseg s2 y) =\n         (unfold_sseg s1 x = unfold_sseg s2 y)) &&&\n     (\\<And>s1 s2.\n         (unfold_seg s1 x = unfold_seg s2 y) =\n         (unfold_seg s1 x = unfold_seg s2 y))) &&&\n    ((\\<And>s1 s2.\n         (unfold_bun s1 x = unfold_bun s2 y) =\n         (unfold_bun s1 x = unfold_bun s2 y)) &&&\n     (\\<And>s1 s2.\n         (unfold_pz s1 x = unfold_pz s2 y) =\n         (unfold_pz s1 x = unfold_pz s2 y))) &&&\n    (\\<And>s1 s2.\n        (unfold_str s1 x = unfold_str s2 y) =\n        (unfold_str s1 x = unfold_str s2 y)) &&&\n    (\\<And>s1 s2.\n        (unfold_mg s1 x = unfold_mg s2 y) =\n        (unfold_mg s1 x = unfold_mg s2 y))", "by (rule refl)+"], ["", "text \\<open>An edge that would make the graph cyclic\\<close>"], ["", "lemma\n  \"\\<And>s1 s2. bisimilar_pz s1 s2 x y \\<longleftrightarrow> bisimilar_mg (mg_of_pz_emb o s1) (mg_of_pz_emb o s2) x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       bisimilar_pz s1 s2 x y =\n       bisimilar_mg (map_bset (map_pmf (map_bset Inl)) \\<circ> s1)\n        (map_bset (map_pmf (map_bset Inl)) \\<circ> s2) x y", "unfolding inj[THEN inj_eq] bisimilar_alt emb_commute o_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       (unfold_pz s1 x = unfold_pz s2 y) = (unfold_pz s1 x = unfold_pz s2 y)", "by (rule refl)+"], ["", "text \\<open>Some redundant (historic) transitive edges\\<close>"], ["", "lemma\n  \"\\<And>s1 s2. bisimilar_pz s1 s2 x y \\<longleftrightarrow> bisimilar_mg (mg_of_pzopt_emb o s1) (mg_of_pzopt_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_alt s1 s2 x y \\<longleftrightarrow> bisimilar_mg (mg_of_alt1_emb o s1) (mg_of_alt1_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_alt s1 s2 x y \\<longleftrightarrow> bisimilar_mg (mg_of_alt2_emb o s1) (mg_of_alt2_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_alt s1 s2 x y \\<longleftrightarrow> bisimilar_pz (pz_of_alt1_emb o s1) (pz_of_alt1_emb o s2) x y\"\n  \"\\<And>s1 s2. bisimilar_alt s1 s2 x y \\<longleftrightarrow> bisimilar_pz (pz_of_alt2_emb o s1) (pz_of_alt2_emb o s2) x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>s1 s2.\n         bisimilar_pz s1 s2 x y =\n         bisimilar_mg\n          (map_bset\n            (map_pmf\n              (map_bset\n                (\\<lambda>(a, s).\n                    case a of None \\<Rightarrow> Inr s\n                    | Some a \\<Rightarrow> Inl (a, s)))) \\<circ>\n           s1)\n          (map_bset\n            (map_pmf\n              (map_bset\n                (\\<lambda>(a, s).\n                    case a of None \\<Rightarrow> Inr s\n                    | Some a \\<Rightarrow> Inl (a, s)))) \\<circ>\n           s2)\n          x y) &&&\n     (\\<And>s1 s2.\n         bisimilar_alt s1 s2 x y =\n         bisimilar_mg\n          (case_sum\n            (map_bset (map_pmf (map_bset Inr \\<circ> bsingleton)) \\<circ>\n             bsingleton)\n            (map_bset\n              (map_pmf (map_bset Inl \\<circ> bsingleton) \\<circ>\n               return_pmf)) \\<circ>\n           s1)\n          (case_sum\n            (map_bset (map_pmf (map_bset Inr \\<circ> bsingleton)) \\<circ>\n             bsingleton)\n            (map_bset\n              (map_pmf (map_bset Inl \\<circ> bsingleton) \\<circ>\n               return_pmf)) \\<circ>\n           s2)\n          x y)) &&&\n    (\\<And>s1 s2.\n        bisimilar_alt s1 s2 x y =\n        bisimilar_mg\n         (case_sum\n           (map_bset (map_pmf (map_bset Inr \\<circ> bsingleton)) \\<circ>\n            bsingleton)\n           (map_bset (map_pmf (map_bset Inl) \\<circ> return_pmf) \\<circ>\n            bsingleton) \\<circ>\n          s1)\n         (case_sum\n           (map_bset (map_pmf (map_bset Inr \\<circ> bsingleton)) \\<circ>\n            bsingleton)\n           (map_bset (map_pmf (map_bset Inl) \\<circ> return_pmf) \\<circ>\n            bsingleton) \\<circ>\n          s2)\n         x y) &&&\n    (\\<And>s1 s2.\n        bisimilar_alt s1 s2 x y =\n        bisimilar_pz\n         (case_sum\n           (map_bset\n             (map_pmf (map_bset (Pair None) \\<circ> bsingleton)) \\<circ>\n            bsingleton)\n           (map_bset\n             (map_pmf\n               (map_bset (map_prod Some id) \\<circ> bsingleton) \\<circ>\n              return_pmf)) \\<circ>\n          s1)\n         (case_sum\n           (map_bset\n             (map_pmf (map_bset (Pair None) \\<circ> bsingleton)) \\<circ>\n            bsingleton)\n           (map_bset\n             (map_pmf\n               (map_bset (map_prod Some id) \\<circ> bsingleton) \\<circ>\n              return_pmf)) \\<circ>\n          s2)\n         x y) &&&\n    (\\<And>s1 s2.\n        bisimilar_alt s1 s2 x y =\n        bisimilar_pz\n         (case_sum\n           (map_bset\n             (map_pmf (map_bset (Pair None) \\<circ> bsingleton)) \\<circ>\n            bsingleton)\n           (map_bset\n             (map_pmf (map_bset (map_prod Some id)) \\<circ>\n              return_pmf) \\<circ>\n            bsingleton) \\<circ>\n          s1)\n         (case_sum\n           (map_bset\n             (map_pmf (map_bset (Pair None) \\<circ> bsingleton)) \\<circ>\n            bsingleton)\n           (map_bset\n             (map_pmf (map_bset (map_prod Some id)) \\<circ>\n              return_pmf) \\<circ>\n            bsingleton) \\<circ>\n          s2)\n         x y)", "unfolding inj[THEN inj_eq] bisimilar_alt emb_commute o_apply"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>s1 s2.\n         (unfold_pz s1 x = unfold_pz s2 y) =\n         (unfold_pz s1 x = unfold_pz s2 y)) &&&\n     (\\<And>s1 s2.\n         (unfold_alt s1 x = unfold_alt s2 y) =\n         (unfold_alt s1 x = unfold_alt s2 y))) &&&\n    (\\<And>s1 s2.\n        (unfold_alt s1 x = unfold_alt s2 y) =\n        (unfold_alt s1 x = unfold_alt s2 y)) &&&\n    (\\<And>s1 s2.\n        (unfold_alt s1 x = unfold_alt s2 y) =\n        (unfold_alt s1 x = unfold_alt s2 y)) &&&\n    (\\<And>s1 s2.\n        (unfold_alt s1 x = unfold_alt s2 y) =\n        (unfold_alt s1 x = unfold_alt s2 y))", "by (rule refl)+"], ["", "section \\<open>Some special proofs\\<close>"], ["", "text \\<open>Two views on LTS\\<close>"], ["", "lemma \"\\<exists>f::(('a \\<times> 's) set \\<Rightarrow> 'a \\<Rightarrow> 's set). bij f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. bij f", "by (fastforce simp: bij_def inj_on_def fun_eq_iff image_iff\n    intro: exI[of _ \"\\<lambda>S a. {s. (a, s) \\<in> S}\"] exI[of _ \"{(a, b). b \\<in> f a}\" for f])"], ["", "lemma \"\\<exists>f::(('a \\<times> 's) set[('a \\<times> 's) set] \\<Rightarrow> 'a \\<Rightarrow> 's set['s set]). bij f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. bij f", "by (auto simp: bij_def inj_on_def fun_eq_iff image_iff bset_eq_iff\n    intro!: exI[of _ \"\\<lambda>S a. bCollect (\\<lambda>s. bmember (a, s) S)\"]\n            exI[of _ \"bCollect (\\<lambda>(a, b). bmember b (f a))\" for f])"], ["", "text \\<open>mc is trivial\\<close>"], ["", "lemma mc_unit:\n  fixes x y :: mc\n  shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "by (coinduction arbitrary: x y)\n    (auto simp: pmf.in_rel map_fst_pair_pmf map_snd_pair_pmf intro: exI[of _ \"pair_pmf x y\" for x y])"], ["", "lemma \"bisimilar_mc s1 s2 x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bisimilar_mc s1 s2 x y", "unfolding bisimilar_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. unfold_mc s1 x = unfold_mc s2 y", "by (rule mc_unit)"], ["", "section \\<open>Printing the Hierarchy Graph\\<close>"], ["", "ML \\<open>\nlocal\n\nval trim = filter (fn s => s <> \"\" andalso s <> \"set\");\n\nfun str_of_T (Type (c, Ts)) =\n    space_implode \" \" (trim [commas (trim (map str_of_T Ts)), Long_Name.base_name c])\n  | str_of_T _ = \"\";\n\nfun get_edge thm = thm\n  |> Thm.concl_of\n  |> HOLogic.dest_Trueprop\n  |> HOLogic.dest_eq |> fst\n  |> dest_comb |> fst\n  |> fastype_of\n  |> dest_funT\n  |> apply2 str_of_T;\n\nval edges = map get_edge @{thms hierarchy[unfolded bisimilar_alt emb_commute o_apply, THEN iffD1]};\n\nval nodes = distinct (op =) (maps (fn (x, y) => [x, y]) edges);\n\nval node_graph = map (fn s => ((s, Graph_Display.content_node s []), [] : string list)) nodes;\n\nval graph = fold (fn (x, y) => fn g =>\n  AList.map_entry (fn (x, (y, _)) => x = y) x (cons y) g) edges node_graph\n\nin\n\nval _ = Graph_Display.display_graph graph\n\nend\n\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}