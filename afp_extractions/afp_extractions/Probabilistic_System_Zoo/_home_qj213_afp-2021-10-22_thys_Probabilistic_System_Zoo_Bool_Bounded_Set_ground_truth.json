{"file_name": "/home/qj213/afp-2021-10-22/thys/Probabilistic_System_Zoo/Bool_Bounded_Set.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Probabilistic_System_Zoo", "problem_names": ["lemma map_bset_bempty[simp]: \"map_bset f bempty = bempty\"", "lemma map_bset_eq_bempty[simp]:\n  \"map_bset f x = bempty \\<longleftrightarrow> x = bempty\"\n  \"bempty = map_bset f x \\<longleftrightarrow> x = bempty\"", "lemma map_bset_bsingleton[simp]: \"map_bset f (bsingleton x) = bsingleton (f x)\"", "lemma map_bset_bdoubleton[simp]: \"map_bset f (bdoubleton x y) = bdoubleton (f x) (f y)\"", "lemma bdoubleton_same[simp]: \"bdoubleton x x = bsingleton x\"", "lemma bempty_neq_bsingleton[simp]:\n  \"bempty \\<noteq> bsingleton x\"\n  \"bsingleton x \\<noteq> bempty\"", "lemma bempty_neq_bdoubleton[simp]:\n  \"bempty \\<noteq> bdoubleton x y\"\n  \"bdoubleton x y \\<noteq> bempty\"", "lemma bsinleton_eq_bdoubleton[simp]:\n  \"bsingleton x = bdoubleton y z \\<longleftrightarrow> (x = y \\<and> y = z)\"\n  \"bdoubleton y z = bsingleton x \\<longleftrightarrow> (x = y \\<and> y = z)\"", "lemma bsinleton_inj[simp]:\n  \"bsingleton x = bsingleton y \\<longleftrightarrow> (x = y)\"", "lemma bdoubleton_eq_iff[simp]:\n  \"bdoubleton x y = bdoubleton z w \\<longleftrightarrow> (x = z \\<and> y = w \\<or> x = w \\<and> y = z)\"", "lemmas [simp] = bempty.rep_eq bsingleton.rep_eq bdoubleton.rep_eq", "lemma bset_cases:\n  \"\\<lbrakk>X = bempty \\<Longrightarrow> P; \\<And>x. X = bsingleton x \\<Longrightarrow> P; \\<And>x y. \\<lbrakk>x \\<noteq> y; X = bdoubleton x y\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], "translations": [["", "lemma map_bset_bempty[simp]: \"map_bset f bempty = bempty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_bset f bempty = bempty", "by transfer simp"], ["", "lemma map_bset_eq_bempty[simp]:\n  \"map_bset f x = bempty \\<longleftrightarrow> x = bempty\"\n  \"bempty = map_bset f x \\<longleftrightarrow> x = bempty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_bset f x = bempty) = (x = bempty) &&&\n    (bempty = map_bset f x) = (x = bempty)", "by (transfer, simp)+"], ["", "lemma map_bset_bsingleton[simp]: \"map_bset f (bsingleton x) = bsingleton (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_bset f (bsingleton x) = bsingleton (f x)", "by transfer simp"], ["", "lemma map_bset_bdoubleton[simp]: \"map_bset f (bdoubleton x y) = bdoubleton (f x) (f y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_bset f (bdoubleton x y) = bdoubleton (f x) (f y)", "by transfer simp"], ["", "lemma bdoubleton_same[simp]: \"bdoubleton x x = bsingleton x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bdoubleton x x = bsingleton x", "by transfer simp"], ["", "lemma bempty_neq_bsingleton[simp]:\n  \"bempty \\<noteq> bsingleton x\"\n  \"bsingleton x \\<noteq> bempty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bempty \\<noteq> bsingleton x &&& bsingleton x \\<noteq> bempty", "by (transfer, simp)+"], ["", "lemma bempty_neq_bdoubleton[simp]:\n  \"bempty \\<noteq> bdoubleton x y\"\n  \"bdoubleton x y \\<noteq> bempty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bempty \\<noteq> bdoubleton x y &&& bdoubleton x y \\<noteq> bempty", "by (transfer, simp)+"], ["", "lemma bsinleton_eq_bdoubleton[simp]:\n  \"bsingleton x = bdoubleton y z \\<longleftrightarrow> (x = y \\<and> y = z)\"\n  \"bdoubleton y z = bsingleton x \\<longleftrightarrow> (x = y \\<and> y = z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bsingleton x = bdoubleton y z) = (x = y \\<and> y = z) &&&\n    (bdoubleton y z = bsingleton x) = (x = y \\<and> y = z)", "by (transfer, auto)+"], ["", "lemma bsinleton_inj[simp]:\n  \"bsingleton x = bsingleton y \\<longleftrightarrow> (x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bsingleton x = bsingleton y) = (x = y)", "by (transfer, simp)"], ["", "lemma bdoubleton_eq_iff[simp]:\n  \"bdoubleton x y = bdoubleton z w \\<longleftrightarrow> (x = z \\<and> y = w \\<or> x = w \\<and> y = z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bdoubleton x y = bdoubleton z w) =\n    (x = z \\<and> y = w \\<or> x = w \\<and> y = z)", "by transfer (simp add: doubleton_eq_iff)"], ["", "lemmas [simp] = bempty.rep_eq bsingleton.rep_eq bdoubleton.rep_eq"], ["", "lemma bset_cases:\n  \"\\<lbrakk>X = bempty \\<Longrightarrow> P; \\<And>x. X = bsingleton x \\<Longrightarrow> P; \\<And>x y. \\<lbrakk>x \\<noteq> y; X = bdoubleton x y\\<rbrakk> \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X = bempty \\<Longrightarrow> P;\n     \\<And>x. X = bsingleton x \\<Longrightarrow> P;\n     \\<And>x y.\n        \\<lbrakk>x \\<noteq> y; X = bdoubleton x y\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "proof (transfer fixing: P)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>|X| \\<le>o ctwo; X = {} \\<Longrightarrow> P;\n        \\<And>x. X = {x} \\<Longrightarrow> P;\n        \\<And>x y.\n           \\<lbrakk>x \\<noteq> y; X = {x, y}\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "fix Z :: \"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>|X| \\<le>o ctwo; X = {} \\<Longrightarrow> P;\n        \\<And>x. X = {x} \\<Longrightarrow> P;\n        \\<And>x y.\n           \\<lbrakk>x \\<noteq> y; X = {x, y}\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "assume \"|Z| \\<le>o ctwo\""], ["proof (state)\nthis:\n  |Z| \\<le>o ctwo\n\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>|X| \\<le>o ctwo; X = {} \\<Longrightarrow> P;\n        \\<And>x. X = {x} \\<Longrightarrow> P;\n        \\<And>x y.\n           \\<lbrakk>x \\<noteq> y; X = {x, y}\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "moreover"], ["proof (state)\nthis:\n  |Z| \\<le>o ctwo\n\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>|X| \\<le>o ctwo; X = {} \\<Longrightarrow> P;\n        \\<And>x. X = {x} \\<Longrightarrow> P;\n        \\<And>x y.\n           \\<lbrakk>x \\<noteq> y; X = {x, y}\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "then"], ["proof (chain)\npicking this:\n  |Z| \\<le>o ctwo", "have \"finite Z\""], ["proof (prove)\nusing this:\n  |Z| \\<le>o ctwo\n\ngoal (1 subgoal):\n 1. finite Z", "by (metis card_of_ordLeq_infinite ctwo_def finite_code)"], ["proof (state)\nthis:\n  finite Z\n\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>|X| \\<le>o ctwo; X = {} \\<Longrightarrow> P;\n        \\<And>x. X = {x} \\<Longrightarrow> P;\n        \\<And>x y.\n           \\<lbrakk>x \\<noteq> y; X = {x, y}\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "ultimately"], ["proof (chain)\npicking this:\n  |Z| \\<le>o ctwo\n  finite Z", "have \"card Z \\<le> 2\""], ["proof (prove)\nusing this:\n  |Z| \\<le>o ctwo\n  finite Z\n\ngoal (1 subgoal):\n 1. card Z \\<le> 2", "unfolding ctwo_def"], ["proof (prove)\nusing this:\n  |Z| \\<le>o |UNIV|\n  finite Z\n\ngoal (1 subgoal):\n 1. card Z \\<le> 2", "by (subst (asm) finite_card_of_iff_card2) auto"], ["proof (state)\nthis:\n  card Z \\<le> 2\n\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>|X| \\<le>o ctwo; X = {} \\<Longrightarrow> P;\n        \\<And>x. X = {x} \\<Longrightarrow> P;\n        \\<And>x y.\n           \\<lbrakk>x \\<noteq> y; X = {x, y}\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "moreover"], ["proof (state)\nthis:\n  card Z \\<le> 2\n\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>|X| \\<le>o ctwo; X = {} \\<Longrightarrow> P;\n        \\<And>x. X = {x} \\<Longrightarrow> P;\n        \\<And>x y.\n           \\<lbrakk>x \\<noteq> y; X = {x, y}\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "assume \"Z = {} \\<Longrightarrow> P\" \"\\<And>x. Z = {x} \\<Longrightarrow> P\" \"\\<And>x y. \\<lbrakk>x \\<noteq> y; Z = {x, y}\\<rbrakk> \\<Longrightarrow> P\""], ["proof (state)\nthis:\n  Z = {} \\<Longrightarrow> P\n  Z = {?x} \\<Longrightarrow> P\n  \\<lbrakk>?x \\<noteq> ?y; Z = {?x, ?y}\\<rbrakk> \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. \\<And>X.\n       \\<lbrakk>|X| \\<le>o ctwo; X = {} \\<Longrightarrow> P;\n        \\<And>x. X = {x} \\<Longrightarrow> P;\n        \\<And>x y.\n           \\<lbrakk>x \\<noteq> y; X = {x, y}\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "ultimately"], ["proof (chain)\npicking this:\n  card Z \\<le> 2\n  Z = {} \\<Longrightarrow> P\n  Z = {?x} \\<Longrightarrow> P\n  \\<lbrakk>?x \\<noteq> ?y; Z = {?x, ?y}\\<rbrakk> \\<Longrightarrow> P", "show P"], ["proof (prove)\nusing this:\n  card Z \\<le> 2\n  Z = {} \\<Longrightarrow> P\n  Z = {?x} \\<Longrightarrow> P\n  \\<lbrakk>?x \\<noteq> ?y; Z = {?x, ?y}\\<rbrakk> \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "using \\<open>finite Z\\<close>"], ["proof (prove)\nusing this:\n  card Z \\<le> 2\n  Z = {} \\<Longrightarrow> P\n  Z = {?x} \\<Longrightarrow> P\n  \\<lbrakk>?x \\<noteq> ?y; Z = {?x, ?y}\\<rbrakk> \\<Longrightarrow> P\n  finite Z\n\ngoal (1 subgoal):\n 1. P", "proof (induct \"card Z\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 = card Z; card Z \\<le> 2; Z = {} \\<Longrightarrow> P;\n     \\<And>x. Z = {x} \\<Longrightarrow> P;\n     \\<And>x y.\n        \\<lbrakk>x \\<noteq> y; Z = {x, y}\\<rbrakk> \\<Longrightarrow> P;\n     finite Z\\<rbrakk>\n    \\<Longrightarrow> P\n 2. \\<And>x.\n       \\<lbrakk>\\<lbrakk>x = card Z; card Z \\<le> 2;\n                 Z = {} \\<Longrightarrow> P;\n                 \\<And>x. Z = {x} \\<Longrightarrow> P;\n                 \\<And>x y.\n                    \\<lbrakk>x \\<noteq> y; Z = {x, y}\\<rbrakk>\n                    \\<Longrightarrow> P;\n                 finite Z\\<rbrakk>\n                \\<Longrightarrow> P;\n        Suc x = card Z; card Z \\<le> 2; Z = {} \\<Longrightarrow> P;\n        \\<And>x. Z = {x} \\<Longrightarrow> P;\n        \\<And>x y.\n           \\<lbrakk>x \\<noteq> y; Z = {x, y}\\<rbrakk> \\<Longrightarrow> P;\n        finite Z\\<rbrakk>\n       \\<Longrightarrow> P", "case (Suc m)"], ["proof (state)\nthis:\n  \\<lbrakk>m = card Z; card Z \\<le> 2; Z = {} \\<Longrightarrow> P;\n   \\<And>x. Z = {x} \\<Longrightarrow> P;\n   \\<And>x y.\n      \\<lbrakk>x \\<noteq> y; Z = {x, y}\\<rbrakk> \\<Longrightarrow> P;\n   finite Z\\<rbrakk>\n  \\<Longrightarrow> P\n  Suc m = card Z\n  card Z \\<le> 2\n  Z = {} \\<Longrightarrow> P\n  Z = {?x} \\<Longrightarrow> P\n  \\<lbrakk>?x \\<noteq> ?y; Z = {?x, ?y}\\<rbrakk> \\<Longrightarrow> P\n  finite Z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 = card Z; card Z \\<le> 2; Z = {} \\<Longrightarrow> P;\n     \\<And>x. Z = {x} \\<Longrightarrow> P;\n     \\<And>x y.\n        \\<lbrakk>x \\<noteq> y; Z = {x, y}\\<rbrakk> \\<Longrightarrow> P;\n     finite Z\\<rbrakk>\n    \\<Longrightarrow> P\n 2. \\<And>x.\n       \\<lbrakk>\\<lbrakk>x = card Z; card Z \\<le> 2;\n                 Z = {} \\<Longrightarrow> P;\n                 \\<And>x. Z = {x} \\<Longrightarrow> P;\n                 \\<And>x y.\n                    \\<lbrakk>x \\<noteq> y; Z = {x, y}\\<rbrakk>\n                    \\<Longrightarrow> P;\n                 finite Z\\<rbrakk>\n                \\<Longrightarrow> P;\n        Suc x = card Z; card Z \\<le> 2; Z = {} \\<Longrightarrow> P;\n        \\<And>x. Z = {x} \\<Longrightarrow> P;\n        \\<And>x y.\n           \\<lbrakk>x \\<noteq> y; Z = {x, y}\\<rbrakk> \\<Longrightarrow> P;\n        finite Z\\<rbrakk>\n       \\<Longrightarrow> P", "from Suc(2)[symmetric] Suc(2-7)"], ["proof (chain)\npicking this:\n  card Z = Suc m\n  Suc m = card Z\n  card Z \\<le> 2\n  Z = {} \\<Longrightarrow> P\n  Z = {?x} \\<Longrightarrow> P\n  \\<lbrakk>?x \\<noteq> ?y; Z = {?x, ?y}\\<rbrakk> \\<Longrightarrow> P\n  finite Z", "show P"], ["proof (prove)\nusing this:\n  card Z = Suc m\n  Suc m = card Z\n  card Z \\<le> 2\n  Z = {} \\<Longrightarrow> P\n  Z = {?x} \\<Longrightarrow> P\n  \\<lbrakk>?x \\<noteq> ?y; Z = {?x, ?y}\\<rbrakk> \\<Longrightarrow> P\n  finite Z\n\ngoal (1 subgoal):\n 1. P", "by (cases m) (auto simp: card_Suc_eq)"], ["proof (state)\nthis:\n  P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 = card Z; card Z \\<le> 2; Z = {} \\<Longrightarrow> P;\n     \\<And>x. Z = {x} \\<Longrightarrow> P;\n     \\<And>x y.\n        \\<lbrakk>x \\<noteq> y; Z = {x, y}\\<rbrakk> \\<Longrightarrow> P;\n     finite Z\\<rbrakk>\n    \\<Longrightarrow> P", "qed simp"], ["proof (state)\nthis:\n  P\n\ngoal:\nNo subgoals!", "qed"], ["", "bnf \"'k bset\"\n  map: map_bset\n  sets: set_bset\n  bd: natLeq\n  rel: rel_bset"], ["proof (prove)\ngoal (9 subgoals):\n 1. map_bset id = id\n 2. \\<And>f g. map_bset (g \\<circ> f) = map_bset g \\<circ> map_bset f\n 3. \\<And>x f g.\n       (\\<And>z.\n           z \\<in> set_bset x \\<Longrightarrow> f z = g z) \\<Longrightarrow>\n       map_bset f x = map_bset g x\n 4. \\<And>f. set_bset \\<circ> map_bset f = (`) f \\<circ> set_bset\n 5. card_order natLeq\n 6. cinfinite natLeq\n 7. \\<And>x. |set_bset x| \\<le>o natLeq\n 8. \\<And>R S. rel_bset R OO rel_bset S \\<le> rel_bset (R OO S)\n 9. \\<And>R.\n       rel_bset R =\n       (\\<lambda>x y.\n           \\<exists>z.\n              set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n              map_bset fst z = x \\<and> map_bset snd z = y)", "proof (standard, goal_cases)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>x. map_bset id x = id x\n 2. \\<And>f g. map_bset (g \\<circ> f) = map_bset g \\<circ> map_bset f\n 3. \\<And>x f g.\n       (\\<And>z.\n           z \\<in> set_bset x \\<Longrightarrow> f z = g z) \\<Longrightarrow>\n       map_bset f x = map_bset g x\n 4. \\<And>f. set_bset \\<circ> map_bset f = (`) f \\<circ> set_bset\n 5. card_order natLeq\n 6. cinfinite natLeq\n 7. \\<And>x. |set_bset x| \\<le>o natLeq\n 8. \\<And>R S. rel_bset R OO rel_bset S \\<le> rel_bset (R OO S)\n 9. \\<And>R.\n       rel_bset R =\n       (\\<lambda>x y.\n           \\<exists>z.\n              set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n              map_bset fst z = x \\<and> map_bset snd z = y)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (9 subgoals):\n 1. \\<And>x. map_bset id x = id x\n 2. \\<And>f g. map_bset (g \\<circ> f) = map_bset g \\<circ> map_bset f\n 3. \\<And>x f g.\n       (\\<And>z.\n           z \\<in> set_bset x \\<Longrightarrow> f z = g z) \\<Longrightarrow>\n       map_bset f x = map_bset g x\n 4. \\<And>f. set_bset \\<circ> map_bset f = (`) f \\<circ> set_bset\n 5. card_order natLeq\n 6. cinfinite natLeq\n 7. \\<And>x. |set_bset x| \\<le>o natLeq\n 8. \\<And>R S. rel_bset R OO rel_bset S \\<le> rel_bset (R OO S)\n 9. \\<And>R.\n       rel_bset R =\n       (\\<lambda>x y.\n           \\<exists>z.\n              set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n              map_bset fst z = x \\<and> map_bset snd z = y)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_bset id x_ = id x_", "by transfer simp"], ["proof (state)\nthis:\n  map_bset id x_ = id x_\n\ngoal (8 subgoals):\n 1. \\<And>f g. map_bset (g \\<circ> f) = map_bset g \\<circ> map_bset f\n 2. \\<And>x f g.\n       (\\<And>z.\n           z \\<in> set_bset x \\<Longrightarrow> f z = g z) \\<Longrightarrow>\n       map_bset f x = map_bset g x\n 3. \\<And>f. set_bset \\<circ> map_bset f = (`) f \\<circ> set_bset\n 4. card_order natLeq\n 5. cinfinite natLeq\n 6. \\<And>x. |set_bset x| \\<le>o natLeq\n 7. \\<And>R S. rel_bset R OO rel_bset S \\<le> rel_bset (R OO S)\n 8. \\<And>R.\n       rel_bset R =\n       (\\<lambda>x y.\n           \\<exists>z.\n              set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n              map_bset fst z = x \\<and> map_bset snd z = y)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>f g. map_bset (g \\<circ> f) = map_bset g \\<circ> map_bset f\n 2. \\<And>x f g.\n       (\\<And>z.\n           z \\<in> set_bset x \\<Longrightarrow> f z = g z) \\<Longrightarrow>\n       map_bset f x = map_bset g x\n 3. \\<And>f. set_bset \\<circ> map_bset f = (`) f \\<circ> set_bset\n 4. card_order natLeq\n 5. cinfinite natLeq\n 6. \\<And>x. |set_bset x| \\<le>o natLeq\n 7. \\<And>R S. rel_bset R OO rel_bset S \\<le> rel_bset (R OO S)\n 8. \\<And>R.\n       rel_bset R =\n       (\\<lambda>x y.\n           \\<exists>z.\n              set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n              map_bset fst z = x \\<and> map_bset snd z = y)", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (8 subgoals):\n 1. \\<And>f g. map_bset (g \\<circ> f) = map_bset g \\<circ> map_bset f\n 2. \\<And>x f g.\n       (\\<And>z.\n           z \\<in> set_bset x \\<Longrightarrow> f z = g z) \\<Longrightarrow>\n       map_bset f x = map_bset g x\n 3. \\<And>f. set_bset \\<circ> map_bset f = (`) f \\<circ> set_bset\n 4. card_order natLeq\n 5. cinfinite natLeq\n 6. \\<And>x. |set_bset x| \\<le>o natLeq\n 7. \\<And>R S. rel_bset R OO rel_bset S \\<le> rel_bset (R OO S)\n 8. \\<And>R.\n       rel_bset R =\n       (\\<lambda>x y.\n           \\<exists>z.\n              set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n              map_bset fst z = x \\<and> map_bset snd z = y)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_bset (g_ \\<circ> f_) = map_bset g_ \\<circ> map_bset f_", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       map_bset (g_ \\<circ> f_) x = (map_bset g_ \\<circ> map_bset f_) x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x g f.\n       |x| \\<le>o ctwo \\<Longrightarrow>\n       (g \\<circ> f) ` x = ((`) g \\<circ> (`) f) x", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_bset (g_ \\<circ> f_) = map_bset g_ \\<circ> map_bset f_\n\ngoal (7 subgoals):\n 1. \\<And>x f g.\n       (\\<And>z.\n           z \\<in> set_bset x \\<Longrightarrow> f z = g z) \\<Longrightarrow>\n       map_bset f x = map_bset g x\n 2. \\<And>f. set_bset \\<circ> map_bset f = (`) f \\<circ> set_bset\n 3. card_order natLeq\n 4. cinfinite natLeq\n 5. \\<And>x. |set_bset x| \\<le>o natLeq\n 6. \\<And>R S. rel_bset R OO rel_bset S \\<le> rel_bset (R OO S)\n 7. \\<And>R.\n       rel_bset R =\n       (\\<lambda>x y.\n           \\<exists>z.\n              set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n              map_bset fst z = x \\<and> map_bset snd z = y)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x f g.\n       (\\<And>z.\n           z \\<in> set_bset x \\<Longrightarrow> f z = g z) \\<Longrightarrow>\n       map_bset f x = map_bset g x\n 2. \\<And>f. set_bset \\<circ> map_bset f = (`) f \\<circ> set_bset\n 3. card_order natLeq\n 4. cinfinite natLeq\n 5. \\<And>x. |set_bset x| \\<le>o natLeq\n 6. \\<And>R S. rel_bset R OO rel_bset S \\<le> rel_bset (R OO S)\n 7. \\<And>R.\n       rel_bset R =\n       (\\<lambda>x y.\n           \\<exists>z.\n              set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n              map_bset fst z = x \\<and> map_bset snd z = y)", "case 3"], ["proof (state)\nthis:\n  ?z \\<in> set_bset x_ \\<Longrightarrow> f_ ?z = g_ ?z\n\ngoal (7 subgoals):\n 1. \\<And>x f g.\n       (\\<And>z.\n           z \\<in> set_bset x \\<Longrightarrow> f z = g z) \\<Longrightarrow>\n       map_bset f x = map_bset g x\n 2. \\<And>f. set_bset \\<circ> map_bset f = (`) f \\<circ> set_bset\n 3. card_order natLeq\n 4. cinfinite natLeq\n 5. \\<And>x. |set_bset x| \\<le>o natLeq\n 6. \\<And>R S. rel_bset R OO rel_bset S \\<le> rel_bset (R OO S)\n 7. \\<And>R.\n       rel_bset R =\n       (\\<lambda>x y.\n           \\<exists>z.\n              set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n              map_bset fst z = x \\<and> map_bset snd z = y)", "then"], ["proof (chain)\npicking this:\n  ?z \\<in> set_bset x_ \\<Longrightarrow> f_ ?z = g_ ?z", "show ?case"], ["proof (prove)\nusing this:\n  ?z \\<in> set_bset x_ \\<Longrightarrow> f_ ?z = g_ ?z\n\ngoal (1 subgoal):\n 1. map_bset f_ x_ = map_bset g_ x_", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x f g.\n       \\<lbrakk>|x| \\<le>o ctwo;\n        \\<And>z. z \\<in> x \\<Longrightarrow> f z = g z\\<rbrakk>\n       \\<Longrightarrow> f ` x = g ` x", "apply (auto simp: image_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_bset f_ x_ = map_bset g_ x_\n\ngoal (6 subgoals):\n 1. \\<And>f. set_bset \\<circ> map_bset f = (`) f \\<circ> set_bset\n 2. card_order natLeq\n 3. cinfinite natLeq\n 4. \\<And>x. |set_bset x| \\<le>o natLeq\n 5. \\<And>R S. rel_bset R OO rel_bset S \\<le> rel_bset (R OO S)\n 6. \\<And>R.\n       rel_bset R =\n       (\\<lambda>x y.\n           \\<exists>z.\n              set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n              map_bset fst z = x \\<and> map_bset snd z = y)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>f. set_bset \\<circ> map_bset f = (`) f \\<circ> set_bset\n 2. card_order natLeq\n 3. cinfinite natLeq\n 4. \\<And>x. |set_bset x| \\<le>o natLeq\n 5. \\<And>R S. rel_bset R OO rel_bset S \\<le> rel_bset (R OO S)\n 6. \\<And>R.\n       rel_bset R =\n       (\\<lambda>x y.\n           \\<exists>z.\n              set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n              map_bset fst z = x \\<and> map_bset snd z = y)", "case 4"], ["proof (state)\nthis:\n  \n\ngoal (6 subgoals):\n 1. \\<And>f. set_bset \\<circ> map_bset f = (`) f \\<circ> set_bset\n 2. card_order natLeq\n 3. cinfinite natLeq\n 4. \\<And>x. |set_bset x| \\<le>o natLeq\n 5. \\<And>R S. rel_bset R OO rel_bset S \\<le> rel_bset (R OO S)\n 6. \\<And>R.\n       rel_bset R =\n       (\\<lambda>x y.\n           \\<exists>z.\n              set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n              map_bset fst z = x \\<and> map_bset snd z = y)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bset \\<circ> map_bset f_ = (`) f_ \\<circ> set_bset", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (set_bset \\<circ> map_bset f_) x = ((`) f_ \\<circ> set_bset) x", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x f.\n       |x| \\<le>o ctwo \\<Longrightarrow>\n       ((\\<lambda>x. x) \\<circ> (`) f) x = ((`) f \\<circ> (\\<lambda>x. x)) x", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set_bset \\<circ> map_bset f_ = (`) f_ \\<circ> set_bset\n\ngoal (5 subgoals):\n 1. card_order natLeq\n 2. cinfinite natLeq\n 3. \\<And>x. |set_bset x| \\<le>o natLeq\n 4. \\<And>R S. rel_bset R OO rel_bset S \\<le> rel_bset (R OO S)\n 5. \\<And>R.\n       rel_bset R =\n       (\\<lambda>x y.\n           \\<exists>z.\n              set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n              map_bset fst z = x \\<and> map_bset snd z = y)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. card_order natLeq\n 2. cinfinite natLeq\n 3. \\<And>x. |set_bset x| \\<le>o natLeq\n 4. \\<And>R S. rel_bset R OO rel_bset S \\<le> rel_bset (R OO S)\n 5. \\<And>R.\n       rel_bset R =\n       (\\<lambda>x y.\n           \\<exists>z.\n              set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n              map_bset fst z = x \\<and> map_bset snd z = y)", "case 5"], ["proof (state)\nthis:\n  \n\ngoal (5 subgoals):\n 1. card_order natLeq\n 2. cinfinite natLeq\n 3. \\<And>x. |set_bset x| \\<le>o natLeq\n 4. \\<And>R S. rel_bset R OO rel_bset S \\<le> rel_bset (R OO S)\n 5. \\<And>R.\n       rel_bset R =\n       (\\<lambda>x y.\n           \\<exists>z.\n              set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n              map_bset fst z = x \\<and> map_bset snd z = y)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. card_order natLeq", "by (simp add: card_order_csum natLeq_card_order)"], ["proof (state)\nthis:\n  card_order natLeq\n\ngoal (4 subgoals):\n 1. cinfinite natLeq\n 2. \\<And>x. |set_bset x| \\<le>o natLeq\n 3. \\<And>R S. rel_bset R OO rel_bset S \\<le> rel_bset (R OO S)\n 4. \\<And>R.\n       rel_bset R =\n       (\\<lambda>x y.\n           \\<exists>z.\n              set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n              map_bset fst z = x \\<and> map_bset snd z = y)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. cinfinite natLeq\n 2. \\<And>x. |set_bset x| \\<le>o natLeq\n 3. \\<And>R S. rel_bset R OO rel_bset S \\<le> rel_bset (R OO S)\n 4. \\<And>R.\n       rel_bset R =\n       (\\<lambda>x y.\n           \\<exists>z.\n              set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n              map_bset fst z = x \\<and> map_bset snd z = y)", "case 6"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. cinfinite natLeq\n 2. \\<And>x. |set_bset x| \\<le>o natLeq\n 3. \\<And>R S. rel_bset R OO rel_bset S \\<le> rel_bset (R OO S)\n 4. \\<And>R.\n       rel_bset R =\n       (\\<lambda>x y.\n           \\<exists>z.\n              set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n              map_bset fst z = x \\<and> map_bset snd z = y)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. cinfinite natLeq", "by (simp add: cinfinite_csum natLeq_cinfinite)"], ["proof (state)\nthis:\n  cinfinite natLeq\n\ngoal (3 subgoals):\n 1. \\<And>x. |set_bset x| \\<le>o natLeq\n 2. \\<And>R S. rel_bset R OO rel_bset S \\<le> rel_bset (R OO S)\n 3. \\<And>R.\n       rel_bset R =\n       (\\<lambda>x y.\n           \\<exists>z.\n              set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n              map_bset fst z = x \\<and> map_bset snd z = y)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. |set_bset x| \\<le>o natLeq\n 2. \\<And>R S. rel_bset R OO rel_bset S \\<le> rel_bset (R OO S)\n 3. \\<And>R.\n       rel_bset R =\n       (\\<lambda>x y.\n           \\<exists>z.\n              set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n              map_bset fst z = x \\<and> map_bset snd z = y)", "case 7"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>x. |set_bset x| \\<le>o natLeq\n 2. \\<And>R S. rel_bset R OO rel_bset S \\<le> rel_bset (R OO S)\n 3. \\<And>R.\n       rel_bset R =\n       (\\<lambda>x y.\n           \\<exists>z.\n              set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n              map_bset fst z = x \\<and> map_bset snd z = y)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. |set_bset x_| \\<le>o natLeq", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. |x| \\<le>o ctwo \\<Longrightarrow> |x| \\<le>o natLeq", "apply (erule ordLeq_transitive[OF _ ordLess_imp_ordLeq[OF ctwo_ordLess_natLeq]])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  |set_bset x_| \\<le>o natLeq\n\ngoal (2 subgoals):\n 1. \\<And>R S. rel_bset R OO rel_bset S \\<le> rel_bset (R OO S)\n 2. \\<And>R.\n       rel_bset R =\n       (\\<lambda>x y.\n           \\<exists>z.\n              set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n              map_bset fst z = x \\<and> map_bset snd z = y)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>R S. rel_bset R OO rel_bset S \\<le> rel_bset (R OO S)\n 2. \\<And>R.\n       rel_bset R =\n       (\\<lambda>x y.\n           \\<exists>z.\n              set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n              map_bset fst z = x \\<and> map_bset snd z = y)", "case (8 R S)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>R S. rel_bset R OO rel_bset S \\<le> rel_bset (R OO S)\n 2. \\<And>R.\n       rel_bset R =\n       (\\<lambda>x y.\n           \\<exists>z.\n              set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n              map_bset fst z = x \\<and> map_bset snd z = y)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_bset R OO rel_bset S \\<le> rel_bset (R OO S)", "proof (safe elim!: rel_bset.cases, unfold rel_bset.simps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y b xa xb.\n       \\<lbrakk>set_bset xa \\<subseteq> {(x, y). R x y};\n        map_bset snd xa = map_bset fst xb;\n        set_bset xb \\<subseteq> {(x, y). S x y}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            map_bset fst xa = map_bset fst x \\<and>\n                            map_bset snd xb = map_bset snd x \\<and>\n                            set_bset x \\<subseteq> {(x, y). (R OO S) x y}", "fix z1 z2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y b xa xb.\n       \\<lbrakk>set_bset xa \\<subseteq> {(x, y). R x y};\n        map_bset snd xa = map_bset fst xb;\n        set_bset xb \\<subseteq> {(x, y). S x y}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            map_bset fst xa = map_bset fst x \\<and>\n                            map_bset snd xb = map_bset snd x \\<and>\n                            set_bset x \\<subseteq> {(x, y). (R OO S) x y}", "assume \"set_bset z1 \\<subseteq> {(x, y). R x y}\" \"set_bset z2 \\<subseteq> {(x, y). S x y}\" \"map_bset snd z1 = map_bset fst z2\""], ["proof (state)\nthis:\n  set_bset z1 \\<subseteq> {(x, y). R x y}\n  set_bset z2 \\<subseteq> {(x, y). S x y}\n  map_bset snd z1 = map_bset fst z2\n\ngoal (1 subgoal):\n 1. \\<And>x y b xa xb.\n       \\<lbrakk>set_bset xa \\<subseteq> {(x, y). R x y};\n        map_bset snd xa = map_bset fst xb;\n        set_bset xb \\<subseteq> {(x, y). S x y}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            map_bset fst xa = map_bset fst x \\<and>\n                            map_bset snd xb = map_bset snd x \\<and>\n                            set_bset x \\<subseteq> {(x, y). (R OO S) x y}", "then"], ["proof (chain)\npicking this:\n  set_bset z1 \\<subseteq> {(x, y). R x y}\n  set_bset z2 \\<subseteq> {(x, y). S x y}\n  map_bset snd z1 = map_bset fst z2", "show \"\\<exists>x. map_bset fst z1 = map_bset fst x \\<and> map_bset snd z2 = map_bset snd x \\<and>\n      set_bset x \\<subseteq> {(x, y). (R OO S) x y}\""], ["proof (prove)\nusing this:\n  set_bset z1 \\<subseteq> {(x, y). R x y}\n  set_bset z2 \\<subseteq> {(x, y). S x y}\n  map_bset snd z1 = map_bset fst z2\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       map_bset fst z1 = map_bset fst x \\<and>\n       map_bset snd z2 = map_bset snd x \\<and>\n       set_bset x \\<subseteq> {(x, y). (R OO S) x y}", "by (cases z1 z2 rule: bset_cases[case_product bset_cases])\n        (fastforce intro: exI[of _ \"bsingleton (a, b)\" for a b]\n        dest: spec[of _ \"bdoubleton (a, b) (c, d)\" for a b c d])+"], ["proof (state)\nthis:\n  \\<exists>x.\n     map_bset fst z1 = map_bset fst x \\<and>\n     map_bset snd z2 = map_bset snd x \\<and>\n     set_bset x \\<subseteq> {(x, y). (R OO S) x y}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rel_bset R OO rel_bset S \\<le> rel_bset (R OO S)\n\ngoal (1 subgoal):\n 1. \\<And>R.\n       rel_bset R =\n       (\\<lambda>x y.\n           \\<exists>z.\n              set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n              map_bset fst z = x \\<and> map_bset snd z = y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>R.\n       rel_bset R =\n       (\\<lambda>x y.\n           \\<exists>z.\n              set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n              map_bset fst z = x \\<and> map_bset snd z = y)", "case (9 R)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>R.\n       rel_bset R =\n       (\\<lambda>x y.\n           \\<exists>z.\n              set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n              map_bset fst z = x \\<and> map_bset snd z = y)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_bset R =\n    (\\<lambda>x y.\n        \\<exists>z.\n           set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n           map_bset fst z = x \\<and> map_bset snd z = y)", "by (auto simp: fun_eq_iff intro: rel_bset.intros elim: rel_bset.cases)"], ["proof (state)\nthis:\n  rel_bset R =\n  (\\<lambda>x y.\n      \\<exists>z.\n         set_bset z \\<subseteq> {(x, y). R x y} \\<and>\n         map_bset fst z = x \\<and> map_bset snd z = y)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}