{"file_name": "/home/qj213/afp-2021-10-22/thys/Propositional_Proof_Systems/CNF_Formulas.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Propositional_Proof_Systems", "problem_names": ["lemma \"nnf ((Atom (k::nat)) \\<^bold>\\<rightarrow> (Not ((Atom l) \\<^bold>\\<or> (Not (Atom m))))) = \\<^bold>\\<not> (Atom k) \\<^bold>\\<or> (\\<^bold>\\<not> (Atom l) \\<^bold>\\<and> Atom m)\"", "lemma is_nnf_nnf: \"is_nnf (nnf F)\"", "lemma nnf_no_imp: \"A \\<^bold>\\<rightarrow> B \\<notin> set (subformulae (nnf F))\"", "lemma subformulae_nnf: \"is_nnf F \\<Longrightarrow> G \\<in> set (subformulae F) \\<Longrightarrow> is_nnf G\"", "lemma is_nnf_NotD: \"is_nnf (\\<^bold>\\<not> F) \\<Longrightarrow> (\\<exists>k. F = Atom k) \\<or> F = \\<bottom>\"", "lemma cnf_fin:\nassumes \"is_nnf F\"\nshows \"finite (cnf F)\" \"C \\<in> cnf F \\<Longrightarrow> finite C\"", "lemmas cnf_form_of_defs = cnf_form_of_def form_of_cnf_def disj_of_clause_def", "lemma disj_of_clause_simps[simp]:\n  \"disj_of_clause [] = \\<bottom>\"\n  \"disj_of_clause (F#FF) = form_of_lit F \\<^bold>\\<or> disj_of_clause FF\"", "lemma is_cnf_BigAnd: \"is_cnf (\\<^bold>\\<And>ls) \\<longleftrightarrow> (\\<forall>l \\<in> set ls. is_cnf l)\"", "lemma BigOr_is_not_cnf'': \"is_cnf (\\<^bold>\\<Or>ls) \\<Longrightarrow> (\\<forall>l \\<in> set ls. is_lit_plus l)\"", "lemma BigOr_is_not_cnf': \"(\\<forall>l \\<in> set ls. is_lit_plus l) \\<Longrightarrow> is_cnf (\\<^bold>\\<Or>ls)\"", "lemma BigOr_is_not_cnf: \"is_cnf (\\<^bold>\\<Or>ls) \\<longleftrightarrow> (\\<forall>l \\<in> set ls. is_lit_plus l)\"", "lemma is_nnf_BigAnd[simp]: \"is_nnf (\\<^bold>\\<And>ls) \\<longleftrightarrow> (\\<forall>l \\<in> set ls. is_nnf l)\"", "lemma is_nnf_BigOr[simp]: \"is_nnf (\\<^bold>\\<Or>ls) \\<longleftrightarrow> (\\<forall>l \\<in> set ls. is_nnf l)\"", "lemma form_of_lit_is_nnf[simp,intro!]: \"is_nnf (form_of_lit x)\"", "lemma form_of_lit_is_lit[simp,intro!]: \"is_lit_plus (form_of_lit x)\"", "lemma disj_of_clause_is_nnf[simp,intro!]: \"is_nnf (disj_of_clause F)\"", "lemma cnf_form_of_is: \"is_nnf F \\<Longrightarrow> is_cnf (cnf_form_of F)\"", "lemma nnf_cnf_form: \"is_nnf F \\<Longrightarrow> is_nnf (cnf_form_of F)\"", "lemma cnf_BigAnd: \"cnf (\\<^bold>\\<And>ls) = (\\<Union>x \\<in> set ls. cnf x)\"", "lemma cnf_BigOr: \"cnf (\\<^bold>\\<Or> (x @ y)) =  {f \\<union> g |f g. f \\<in> cnf (\\<^bold>\\<Or>x) \\<and> g \\<in> cnf (\\<^bold>\\<Or>y)}\"", "lemma cnf_cnf: \"is_nnf F \\<Longrightarrow> cnf (cnf_form_of F) = cnf F\"", "lemma is_nnf_nnf_id: \"is_nnf F \\<Longrightarrow> nnf F = F\"", "lemma disj_of_clause_is: \"is_disj (disj_of_clause R)\"", "lemma form_of_cnf_is_nnf: \"is_nnf (form_of_cnf R)\"", "lemma cnf_disj: \"cnf (disj_of_clause R) = {set R}\"", "lemma cnf_disj_ex: \"is_disj F \\<Longrightarrow> \\<exists>R. cnf F = {R} \\<or> cnf F = {}\"", "lemma cnf_form_of_cnf: \"cnf (form_of_cnf S) = set (map set S)\"", "lemma disj_is_nnf: \"is_disj F \\<Longrightarrow> is_nnf F\"", "lemma nnf_BigAnd: \"nnf (\\<^bold>\\<And>F) = \\<^bold>\\<And>(map nnf F)\""], "translations": [["", "lemma \"nnf ((Atom (k::nat)) \\<^bold>\\<rightarrow> (Not ((Atom l) \\<^bold>\\<or> (Not (Atom m))))) = \\<^bold>\\<not> (Atom k) \\<^bold>\\<or> (\\<^bold>\\<not> (Atom l) \\<^bold>\\<and> Atom m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nnf (Atom k \\<^bold>\\<rightarrow>\n         \\<^bold>\\<not> (Atom l \\<^bold>\\<or> \\<^bold>\\<not> (Atom m))) =\n    \\<^bold>\\<not> (Atom k) \\<^bold>\\<or>\n    (\\<^bold>\\<not> (Atom l) \\<^bold>\\<and> Atom m)", "by code_simp"], ["", "fun is_lit_plus where\n\"is_lit_plus \\<bottom> = True\" |\n\"is_lit_plus (Not \\<bottom>) = True\" |\n\"is_lit_plus (Atom _) = True\" |\n\"is_lit_plus (Not (Atom _)) = True\" |\n\"is_lit_plus _ = False\""], ["", "case_of_simps is_lit_plus_cases: is_lit_plus.simps"], ["", "fun is_disj where\n(* It is crucial for this to be a (right) deep tree for the proof of LSC \\<Longrightarrow> Res\n  At some point, we obtain a subset A where A is in a disjunction from (A \\<or> B). \n  Now, resolution is at a loss because you can't say anything about the subset.\n  If, however, that subset is sandwiched between a literal and the empty clause,\n  you can just cover all the cases. *)\n\"is_disj (Or F G) = (is_lit_plus F \\<and> is_disj G)\" |\n\"is_disj F = is_lit_plus F\""], ["", "fun is_cnf where\n(* here, we do want to allow arbitrary trees of \\<and>.\n  If we do not do that, the proofs in LSC_Resolution won't work,\n  since it relies on the \\<and> case being just\n  a simple split in LSC and union in Resolution.\n  It is possible that that is fixable, but at what cost? *)\n\"is_cnf (And F G) = (is_cnf F \\<and> is_cnf G)\" |\n\"is_cnf H = is_disj H\""], ["", "fun is_nnf where\n\"is_nnf (Imp F G) = False\" |\n\"is_nnf (And F G) = (is_nnf F \\<and> is_nnf G)\" |\n\"is_nnf (Or F G) = (is_nnf F \\<and> is_nnf G)\" |\n\"is_nnf F = is_lit_plus F\""], ["", "lemma is_nnf_nnf: \"is_nnf (nnf F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nnf (nnf F)", "by(induction F rule: nnf.induct; simp)"], ["", "lemma nnf_no_imp: \"A \\<^bold>\\<rightarrow> B \\<notin> set (subformulae (nnf F))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<^bold>\\<rightarrow> B \\<notin> set (subformulae (nnf F))", "by(induction F rule: nnf.induct; simp)"], ["", "lemma subformulae_nnf: \"is_nnf F \\<Longrightarrow> G \\<in> set (subformulae F) \\<Longrightarrow> is_nnf G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_nnf F; G \\<in> set (subformulae F)\\<rbrakk>\n    \\<Longrightarrow> is_nnf G", "(* fun fact *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_nnf F; G \\<in> set (subformulae F)\\<rbrakk>\n    \\<Longrightarrow> is_nnf G", "by(induction F rule: is_nnf.induct; simp add: is_lit_plus_cases split: formula.splits; elim disjE conjE; simp)"], ["", "lemma is_nnf_NotD: \"is_nnf (\\<^bold>\\<not> F) \\<Longrightarrow> (\\<exists>k. F = Atom k) \\<or> F = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nnf (\\<^bold>\\<not> F) \\<Longrightarrow>\n    (\\<exists>k. F = Atom k) \\<or> F = \\<bottom>", "by(cases F; simp)"], ["", "fun cnf :: \"'a formula \\<Rightarrow> 'a clause set\" where\n\"cnf (Atom k) = {{ k\\<^sup>+ }}\" |\n\"cnf (Not (Atom k)) = {{ k\\<inverse> }}\" |\n\"cnf \\<bottom> = {\\<box>}\" |\n\"cnf (Not \\<bottom>) = {}\"  |\n\"cnf (And F G) = cnf F \\<union> cnf G\"  |\n\"cnf (Or F G) = {C \\<union> D| C D. C \\<in> (cnf F) \\<and> D \\<in> (cnf G)}\""], ["", "lemma cnf_fin:\nassumes \"is_nnf F\"\nshows \"finite (cnf F)\" \"C \\<in> cnf F \\<Longrightarrow> finite C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (cnf F) &&& (C \\<in> cnf F \\<Longrightarrow> finite C)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (cnf F)\n 2. C \\<in> cnf F \\<Longrightarrow> finite C", "have \"finite (cnf F) \\<and> (C \\<in> cnf F \\<longrightarrow> finite C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (cnf F) \\<and> (C \\<in> cnf F \\<longrightarrow> finite C)", "using assms"], ["proof (prove)\nusing this:\n  is_nnf F\n\ngoal (1 subgoal):\n 1. finite (cnf F) \\<and> (C \\<in> cnf F \\<longrightarrow> finite C)", "by(induction F arbitrary: C rule: cnf.induct;  clarsimp simp add: finite_image_set2)"], ["proof (state)\nthis:\n  finite (cnf F) \\<and> (C \\<in> cnf F \\<longrightarrow> finite C)\n\ngoal (2 subgoals):\n 1. finite (cnf F)\n 2. C \\<in> cnf F \\<Longrightarrow> finite C", "thus \"finite (cnf F)\" \"C \\<in> cnf F \\<Longrightarrow> finite C\""], ["proof (prove)\nusing this:\n  finite (cnf F) \\<and> (C \\<in> cnf F \\<longrightarrow> finite C)\n\ngoal (1 subgoal):\n 1. finite (cnf F) &&& (C \\<in> cnf F \\<Longrightarrow> finite C)", "by simp+"], ["proof (state)\nthis:\n  finite (cnf F)\n  C \\<in> cnf F \\<Longrightarrow> finite C\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Sets, as produced by @{const cnf} can be hard to handle.\n   Less because of their infinity, more because of their lack of explicit order. *)"], ["", "fun cnf_lists :: \"'a formula \\<Rightarrow> 'a literal list list\" where\n\"cnf_lists (Atom k) = [[ k\\<^sup>+ ]]\" |\n\"cnf_lists (Not (Atom k)) = [[ k\\<inverse> ]]\" |\n\"cnf_lists \\<bottom> = [[]]\" |\n\"cnf_lists (Not \\<bottom>) = []\"  |\n\"cnf_lists (And F G) = cnf_lists F @ cnf_lists G\"  |\n\"cnf_lists (Or F G) = [f @ g. f \\<leftarrow> (cnf_lists F), g \\<leftarrow> (cnf_lists G)]\""], ["", "primrec form_of_lit where\n\"form_of_lit (Pos k) = Atom k\" |\n\"form_of_lit (Neg k) = \\<^bold>\\<not>(Atom k)\""], ["", "case_of_simps form_of_lit_cases: form_of_lit.simps"], ["", "definition \"disj_of_clause c \\<equiv> \\<^bold>\\<Or>[form_of_lit l. l \\<leftarrow> c]\""], ["", "definition \"form_of_cnf F \\<equiv> \\<^bold>\\<And>[disj_of_clause c. c \\<leftarrow> F]\""], ["", "definition \"cnf_form_of \\<equiv> form_of_cnf \\<circ> cnf_lists\""], ["", "lemmas cnf_form_of_defs = cnf_form_of_def form_of_cnf_def disj_of_clause_def"], ["", "lemma disj_of_clause_simps[simp]:\n  \"disj_of_clause [] = \\<bottom>\"\n  \"disj_of_clause (F#FF) = form_of_lit F \\<^bold>\\<or> disj_of_clause FF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. disj_of_clause [] = \\<bottom> &&&\n    disj_of_clause (F # FF) = form_of_lit F \\<^bold>\\<or> disj_of_clause FF", "by(simp_all add: disj_of_clause_def)"], ["", "lemma is_cnf_BigAnd: \"is_cnf (\\<^bold>\\<And>ls) \\<longleftrightarrow> (\\<forall>l \\<in> set ls. is_cnf l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf \\<^bold>\\<And>ls = (\\<forall>l\\<in>set ls. is_cnf l)", "by(induction ls; simp)"], ["", "private"], ["", "lemma BigOr_is_not_cnf'': \"is_cnf (\\<^bold>\\<Or>ls) \\<Longrightarrow> (\\<forall>l \\<in> set ls. is_lit_plus l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf \\<^bold>\\<Or>ls \\<Longrightarrow>\n    \\<forall>l\\<in>set ls. is_lit_plus l", "proof(induction ls)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_cnf \\<^bold>\\<Or>[] \\<Longrightarrow> Ball (set []) is_lit_plus\n 2. \\<And>a ls.\n       \\<lbrakk>is_cnf \\<^bold>\\<Or>ls \\<Longrightarrow>\n                Ball (set ls) is_lit_plus;\n        is_cnf \\<^bold>\\<Or>a # ls\\<rbrakk>\n       \\<Longrightarrow> Ball (set (a # ls)) is_lit_plus", "case (Cons l ls)"], ["proof (state)\nthis:\n  is_cnf \\<^bold>\\<Or>ls \\<Longrightarrow>\n  \\<forall>a\\<in>set ls. is_lit_plus a\n  is_cnf \\<^bold>\\<Or>l # ls\n\ngoal (2 subgoals):\n 1. is_cnf \\<^bold>\\<Or>[] \\<Longrightarrow> Ball (set []) is_lit_plus\n 2. \\<And>a ls.\n       \\<lbrakk>is_cnf \\<^bold>\\<Or>ls \\<Longrightarrow>\n                Ball (set ls) is_lit_plus;\n        is_cnf \\<^bold>\\<Or>a # ls\\<rbrakk>\n       \\<Longrightarrow> Ball (set (a # ls)) is_lit_plus", "from Cons.prems"], ["proof (chain)\npicking this:\n  is_cnf \\<^bold>\\<Or>l # ls", "have \"is_cnf (\\<^bold>\\<Or> ls)\""], ["proof (prove)\nusing this:\n  is_cnf \\<^bold>\\<Or>l # ls\n\ngoal (1 subgoal):\n 1. is_cnf \\<^bold>\\<Or>ls", "by (metis BigOr.simps is_cnf.simps(3,5) is_disj.simps(1) list.exhaust)"], ["proof (state)\nthis:\n  is_cnf \\<^bold>\\<Or>ls\n\ngoal (2 subgoals):\n 1. is_cnf \\<^bold>\\<Or>[] \\<Longrightarrow> Ball (set []) is_lit_plus\n 2. \\<And>a ls.\n       \\<lbrakk>is_cnf \\<^bold>\\<Or>ls \\<Longrightarrow>\n                Ball (set ls) is_lit_plus;\n        is_cnf \\<^bold>\\<Or>a # ls\\<rbrakk>\n       \\<Longrightarrow> Ball (set (a # ls)) is_lit_plus", "thus ?case"], ["proof (prove)\nusing this:\n  is_cnf \\<^bold>\\<Or>ls\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set (l # ls). is_lit_plus a", "using Cons"], ["proof (prove)\nusing this:\n  is_cnf \\<^bold>\\<Or>ls\n  is_cnf \\<^bold>\\<Or>ls \\<Longrightarrow>\n  \\<forall>a\\<in>set ls. is_lit_plus a\n  is_cnf \\<^bold>\\<Or>l # ls\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set (l # ls). is_lit_plus a", "by simp"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set (l # ls). is_lit_plus a\n\ngoal (1 subgoal):\n 1. is_cnf \\<^bold>\\<Or>[] \\<Longrightarrow> Ball (set []) is_lit_plus", "qed simp"], ["", "private"], ["", "lemma BigOr_is_not_cnf': \"(\\<forall>l \\<in> set ls. is_lit_plus l) \\<Longrightarrow> is_cnf (\\<^bold>\\<Or>ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l\\<in>set ls. is_lit_plus l \\<Longrightarrow>\n    is_cnf \\<^bold>\\<Or>ls", "by(induction ls; simp) (metis BigOr.simps(1, 2) formula.distinct(25) is_cnf.elims(2) is_cnf.simps(3) list.exhaust)"], ["", "(* ugh *)"], ["", "lemma BigOr_is_not_cnf: \"is_cnf (\\<^bold>\\<Or>ls) \\<longleftrightarrow> (\\<forall>l \\<in> set ls. is_lit_plus l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cnf \\<^bold>\\<Or>ls = (\\<forall>l\\<in>set ls. is_lit_plus l)", "using BigOr_is_not_cnf' BigOr_is_not_cnf''"], ["proof (prove)\nusing this:\n  \\<forall>l\\<in>set ?ls. is_lit_plus l \\<Longrightarrow>\n  is_cnf \\<^bold>\\<Or>?ls\n  is_cnf \\<^bold>\\<Or>?ls \\<Longrightarrow>\n  \\<forall>l\\<in>set ?ls. is_lit_plus l\n\ngoal (1 subgoal):\n 1. is_cnf \\<^bold>\\<Or>ls = (\\<forall>l\\<in>set ls. is_lit_plus l)", "by blast"], ["", "lemma is_nnf_BigAnd[simp]: \"is_nnf (\\<^bold>\\<And>ls) \\<longleftrightarrow> (\\<forall>l \\<in> set ls. is_nnf l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nnf \\<^bold>\\<And>ls = (\\<forall>l\\<in>set ls. is_nnf l)", "by(induction ls; simp)"], ["", "lemma is_nnf_BigOr[simp]: \"is_nnf (\\<^bold>\\<Or>ls) \\<longleftrightarrow> (\\<forall>l \\<in> set ls. is_nnf l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nnf \\<^bold>\\<Or>ls = (\\<forall>l\\<in>set ls. is_nnf l)", "by(induction ls; simp)"], ["", "lemma form_of_lit_is_nnf[simp,intro!]: \"is_nnf (form_of_lit x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nnf (form_of_lit x)", "by(cases x; simp)"], ["", "lemma form_of_lit_is_lit[simp,intro!]: \"is_lit_plus (form_of_lit x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_lit_plus (form_of_lit x)", "by(cases x; simp)"], ["", "lemma disj_of_clause_is_nnf[simp,intro!]: \"is_nnf (disj_of_clause F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nnf (disj_of_clause F)", "unfolding disj_of_clause_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nnf \\<^bold>\\<Or>map form_of_lit F", "by simp"], ["", "lemma cnf_form_of_is: \"is_nnf F \\<Longrightarrow> is_cnf (cnf_form_of F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nnf F \\<Longrightarrow> is_cnf (cnf_form_of F)", "by(cases F) (auto simp: cnf_form_of_defs is_cnf_BigAnd BigOr_is_not_cnf)"], ["", "lemma nnf_cnf_form: \"is_nnf F \\<Longrightarrow> is_nnf (cnf_form_of F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nnf F \\<Longrightarrow> is_nnf (cnf_form_of F)", "by(cases F) (auto simp add: cnf_form_of_defs)"], ["", "lemma cnf_BigAnd: \"cnf (\\<^bold>\\<And>ls) = (\\<Union>x \\<in> set ls. cnf x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf \\<^bold>\\<And>ls = \\<Union> (cnf ` set ls)", "by(induction ls; simp)"], ["", "lemma cnf_BigOr: \"cnf (\\<^bold>\\<Or> (x @ y)) =  {f \\<union> g |f g. f \\<in> cnf (\\<^bold>\\<Or>x) \\<and> g \\<in> cnf (\\<^bold>\\<Or>y)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf \\<^bold>\\<Or>x @ y =\n    {f \\<union> g |f g.\n     f \\<in> cnf \\<^bold>\\<Or>x \\<and> g \\<in> cnf \\<^bold>\\<Or>y}", "by(induction x arbitrary: y; simp) (metis (no_types, hide_lams) sup.assoc)"], ["", "lemma cnf_cnf: \"is_nnf F \\<Longrightarrow> cnf (cnf_form_of F) = cnf F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nnf F \\<Longrightarrow> cnf (cnf_form_of F) = cnf F", "by(induction F rule: cnf.induct; \n     fastforce simp add: cnf_form_of_defs cnf_BigAnd cnf_BigOr)"], ["", "(* this is not an idempotency (is that a word?) lemma, since cnf_form_of is not idempotent. *)"], ["", "lemma is_nnf_nnf_id: \"is_nnf F \\<Longrightarrow> nnf F = F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nnf F \\<Longrightarrow> nnf F = F", "proof(induction rule: is_nnf.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>F G.\n       is_nnf (F \\<^bold>\\<rightarrow> G) \\<Longrightarrow>\n       nnf (F \\<^bold>\\<rightarrow> G) = F \\<^bold>\\<rightarrow> G\n 2. \\<And>F G.\n       \\<lbrakk>is_nnf F \\<Longrightarrow> nnf F = F;\n        is_nnf G \\<Longrightarrow> nnf G = G;\n        is_nnf (F \\<^bold>\\<and> G)\\<rbrakk>\n       \\<Longrightarrow> nnf (F \\<^bold>\\<and> G) = F \\<^bold>\\<and> G\n 3. \\<And>F G.\n       \\<lbrakk>is_nnf F \\<Longrightarrow> nnf F = F;\n        is_nnf G \\<Longrightarrow> nnf G = G;\n        is_nnf (F \\<^bold>\\<or> G)\\<rbrakk>\n       \\<Longrightarrow> nnf (F \\<^bold>\\<or> G) = F \\<^bold>\\<or> G\n 4. \\<And>v. is_nnf (Atom v) \\<Longrightarrow> nnf (Atom v) = Atom v\n 5. is_nnf \\<bottom> \\<Longrightarrow> nnf \\<bottom> = \\<bottom>\n 6. \\<And>v.\n       is_nnf (\\<^bold>\\<not> v) \\<Longrightarrow>\n       nnf (\\<^bold>\\<not> v) = \\<^bold>\\<not> v", "fix v"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>F G.\n       is_nnf (F \\<^bold>\\<rightarrow> G) \\<Longrightarrow>\n       nnf (F \\<^bold>\\<rightarrow> G) = F \\<^bold>\\<rightarrow> G\n 2. \\<And>F G.\n       \\<lbrakk>is_nnf F \\<Longrightarrow> nnf F = F;\n        is_nnf G \\<Longrightarrow> nnf G = G;\n        is_nnf (F \\<^bold>\\<and> G)\\<rbrakk>\n       \\<Longrightarrow> nnf (F \\<^bold>\\<and> G) = F \\<^bold>\\<and> G\n 3. \\<And>F G.\n       \\<lbrakk>is_nnf F \\<Longrightarrow> nnf F = F;\n        is_nnf G \\<Longrightarrow> nnf G = G;\n        is_nnf (F \\<^bold>\\<or> G)\\<rbrakk>\n       \\<Longrightarrow> nnf (F \\<^bold>\\<or> G) = F \\<^bold>\\<or> G\n 4. \\<And>v. is_nnf (Atom v) \\<Longrightarrow> nnf (Atom v) = Atom v\n 5. is_nnf \\<bottom> \\<Longrightarrow> nnf \\<bottom> = \\<bottom>\n 6. \\<And>v.\n       is_nnf (\\<^bold>\\<not> v) \\<Longrightarrow>\n       nnf (\\<^bold>\\<not> v) = \\<^bold>\\<not> v", "assume \"is_nnf (\\<^bold>\\<not> v)\""], ["proof (state)\nthis:\n  is_nnf (\\<^bold>\\<not> v)\n\ngoal (6 subgoals):\n 1. \\<And>F G.\n       is_nnf (F \\<^bold>\\<rightarrow> G) \\<Longrightarrow>\n       nnf (F \\<^bold>\\<rightarrow> G) = F \\<^bold>\\<rightarrow> G\n 2. \\<And>F G.\n       \\<lbrakk>is_nnf F \\<Longrightarrow> nnf F = F;\n        is_nnf G \\<Longrightarrow> nnf G = G;\n        is_nnf (F \\<^bold>\\<and> G)\\<rbrakk>\n       \\<Longrightarrow> nnf (F \\<^bold>\\<and> G) = F \\<^bold>\\<and> G\n 3. \\<And>F G.\n       \\<lbrakk>is_nnf F \\<Longrightarrow> nnf F = F;\n        is_nnf G \\<Longrightarrow> nnf G = G;\n        is_nnf (F \\<^bold>\\<or> G)\\<rbrakk>\n       \\<Longrightarrow> nnf (F \\<^bold>\\<or> G) = F \\<^bold>\\<or> G\n 4. \\<And>v. is_nnf (Atom v) \\<Longrightarrow> nnf (Atom v) = Atom v\n 5. is_nnf \\<bottom> \\<Longrightarrow> nnf \\<bottom> = \\<bottom>\n 6. \\<And>v.\n       is_nnf (\\<^bold>\\<not> v) \\<Longrightarrow>\n       nnf (\\<^bold>\\<not> v) = \\<^bold>\\<not> v", "thus \"nnf (\\<^bold>\\<not> v) = \\<^bold>\\<not> v\""], ["proof (prove)\nusing this:\n  is_nnf (\\<^bold>\\<not> v)\n\ngoal (1 subgoal):\n 1. nnf (\\<^bold>\\<not> v) = \\<^bold>\\<not> v", "by(cases v rule: is_lit_plus.cases; simp)"], ["proof (state)\nthis:\n  nnf (\\<^bold>\\<not> v) = \\<^bold>\\<not> v\n\ngoal (5 subgoals):\n 1. \\<And>F G.\n       is_nnf (F \\<^bold>\\<rightarrow> G) \\<Longrightarrow>\n       nnf (F \\<^bold>\\<rightarrow> G) = F \\<^bold>\\<rightarrow> G\n 2. \\<And>F G.\n       \\<lbrakk>is_nnf F \\<Longrightarrow> nnf F = F;\n        is_nnf G \\<Longrightarrow> nnf G = G;\n        is_nnf (F \\<^bold>\\<and> G)\\<rbrakk>\n       \\<Longrightarrow> nnf (F \\<^bold>\\<and> G) = F \\<^bold>\\<and> G\n 3. \\<And>F G.\n       \\<lbrakk>is_nnf F \\<Longrightarrow> nnf F = F;\n        is_nnf G \\<Longrightarrow> nnf G = G;\n        is_nnf (F \\<^bold>\\<or> G)\\<rbrakk>\n       \\<Longrightarrow> nnf (F \\<^bold>\\<or> G) = F \\<^bold>\\<or> G\n 4. \\<And>v. is_nnf (Atom v) \\<Longrightarrow> nnf (Atom v) = Atom v\n 5. is_nnf \\<bottom> \\<Longrightarrow> nnf \\<bottom> = \\<bottom>", "qed simp_all"], ["", "lemma disj_of_clause_is: \"is_disj (disj_of_clause R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_disj (disj_of_clause R)", "by(induction R; simp)"], ["", "lemma form_of_cnf_is_nnf: \"is_nnf (form_of_cnf R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nnf (form_of_cnf R)", "unfolding form_of_cnf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nnf \\<^bold>\\<And>map disj_of_clause R", "by simp"], ["", "lemma cnf_disj: \"cnf (disj_of_clause R) = {set R}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (disj_of_clause R) = {set R}", "by(induction R; simp add: form_of_lit_cases split: literal.splits)"], ["", "lemma cnf_disj_ex: \"is_disj F \\<Longrightarrow> \\<exists>R. cnf F = {R} \\<or> cnf F = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_disj F \\<Longrightarrow> \\<exists>R. cnf F = {R} \\<or> cnf F = {}", "by(induction F rule: is_disj.induct; clarsimp simp: is_lit_plus_cases split: formula.splits)"], ["", "lemma cnf_form_of_cnf: \"cnf (form_of_cnf S) = set (map set S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf (form_of_cnf S) = set (map set S)", "unfolding form_of_cnf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cnf \\<^bold>\\<And>map disj_of_clause S = set (map set S)", "by (simp add: cnf_BigAnd cnf_disj) blast"], ["", "lemma disj_is_nnf: \"is_disj F \\<Longrightarrow> is_nnf F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_disj F \\<Longrightarrow> is_nnf F", "by(induction F rule: is_disj.induct; simp add: is_lit_plus_cases split: formula.splits)"], ["", "lemma nnf_BigAnd: \"nnf (\\<^bold>\\<And>F) = \\<^bold>\\<And>(map nnf F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nnf \\<^bold>\\<And>F = \\<^bold>\\<And>map nnf F", "by(induction F; simp)"], ["", "end"], ["", "end"]]}