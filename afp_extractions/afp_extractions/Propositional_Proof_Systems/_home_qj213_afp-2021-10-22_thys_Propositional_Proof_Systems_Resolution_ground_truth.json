{"file_name": "/home/qj213/afp-2021-10-22/thys/Propositional_Proof_Systems/Resolution.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Propositional_Proof_Systems", "problem_names": ["lemma Resolution_weaken: \"S \\<turnstile> D \\<Longrightarrow> T \\<union> S \\<turnstile> D\"", "lemma Resolution_unnecessary:\n  assumes sd: \"\\<forall>C \\<in> T. S \\<turnstile> C\"\n  shows \"T \\<union> S \\<turnstile> D \\<longleftrightarrow> S \\<turnstile> D\" (is \"?l \\<longleftrightarrow> ?r\")", "lemma Resolution_taint_assumptions: \"S \\<union> T \\<turnstile> C \\<Longrightarrow> \\<exists>R \\<subseteq> D. ((\\<union>) D ` S) \\<union> T \\<turnstile> R \\<union> C\"", "lemma Resolution_useless_infinite:\nassumes R: \"S \\<turnstile> R\"\nassumes \"finite R\"\nshows \"\\<exists>S' \\<subseteq> S. Ball S' finite \\<and> finite S' \\<and> (S' \\<turnstile> R)\"", "lemma \"\\<box> \\<in> the (Rwhile ex1)\"", "lemma Rwhile_sound: assumes \"Rwhile S = Some S'\"\n  shows \"\\<forall>C \\<in> S'. Resolution S C\"", "lemma s_sub_all_clauses: \"S \\<subseteq> all_clauses S\"", "lemma atoms_res: \"atoms_of_cnf (res S) \\<subseteq>  atoms_of_cnf S\"", "lemma exlitE: \"(\\<And>x. xe = Pos x \\<Longrightarrow> P x) \\<Longrightarrow> (\\<And>x. xe = Neg x \\<Longrightarrow> False) \\<Longrightarrow> \\<exists>x. xe = Pos x \\<and> P x\"", "lemma res_in_all_clauses: \"res S \\<subseteq> all_clauses S\"", "lemma Res_in_all_clauses: \"res S \\<union> S \\<subseteq> all_clauses S\"", "lemma all_clauses_Res_inv: \"all_clauses (res S \\<union> S) = all_clauses S\"", "lemma all_clauses_finite: \"finite S \\<and> (\\<forall>C \\<in> S. finite C) \\<Longrightarrow> finite (all_clauses S)\"", "lemma finite_res: \"\\<forall>C \\<in> S. finite C \\<Longrightarrow> \\<forall>C \\<in> res S. finite C\"", "lemma \"finite T \\<Longrightarrow> S \\<subseteq> T \\<Longrightarrow> card S < Suc (card T)\"", "lemma \"finite S \\<and> (\\<forall>C \\<in> S. finite C) \\<Longrightarrow> \\<exists>T. Rwhile S = Some T\"", "lemma \"\\<box> \\<in> the (Res ex1)\"", "lemma res: \"C \\<in> res S \\<Longrightarrow> S \\<turnstile> C\"", "lemma Res_sound: \"Res S = Some S' \\<Longrightarrow> (\\<forall>C \\<in> S'. S \\<turnstile> C)\"", "lemma Res_terminates: \"finite S \\<Longrightarrow> \\<forall>C \\<in> S. finite C \\<Longrightarrow> \\<exists>T. Res S = Some T\""], "translations": [["", "lemma Resolution_weaken: \"S \\<turnstile> D \\<Longrightarrow> T \\<union> S \\<turnstile> D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<turnstile> D \\<Longrightarrow> T \\<union> S \\<turnstile> D", "by(induction rule: Resolution.induct; auto intro: Resolution.intros)"], ["", "lemma Resolution_unnecessary:\n  assumes sd: \"\\<forall>C \\<in> T. S \\<turnstile> C\"\n  shows \"T \\<union> S \\<turnstile> D \\<longleftrightarrow> S \\<turnstile> D\" (is \"?l \\<longleftrightarrow> ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (T \\<union> S \\<turnstile> D) = (S \\<turnstile> D)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. T \\<union> S \\<turnstile> D \\<Longrightarrow> S \\<turnstile> D\n 2. S \\<turnstile> D \\<Longrightarrow> T \\<union> S \\<turnstile> D", "assume ?l"], ["proof (state)\nthis:\n  T \\<union> S \\<turnstile> D\n\ngoal (2 subgoals):\n 1. T \\<union> S \\<turnstile> D \\<Longrightarrow> S \\<turnstile> D\n 2. S \\<turnstile> D \\<Longrightarrow> T \\<union> S \\<turnstile> D", "from \\<open>?l\\<close> sd"], ["proof (chain)\npicking this:\n  T \\<union> S \\<turnstile> D\n  \\<forall>C\\<in>T. S \\<turnstile> C", "show  ?r"], ["proof (prove)\nusing this:\n  T \\<union> S \\<turnstile> D\n  \\<forall>C\\<in>T. S \\<turnstile> C\n\ngoal (1 subgoal):\n 1. S \\<turnstile> D", "proof(induction \"T \\<union> S\" D rule: Resolution.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>C \\<in> T \\<union> S; Ball T (Resolution S)\\<rbrakk>\n       \\<Longrightarrow> S \\<turnstile> C\n 2. \\<And>C D k.\n       \\<lbrakk>T \\<union> S \\<turnstile> C;\n        Ball T (Resolution S) \\<Longrightarrow> S \\<turnstile> C;\n        T \\<union> S \\<turnstile> D;\n        Ball T (Resolution S) \\<Longrightarrow> S \\<turnstile> D;\n        k\\<^sup>+ \\<in> C; k\\<inverse> \\<in> D;\n        Ball T (Resolution S)\\<rbrakk>\n       \\<Longrightarrow> S \\<turnstile> C - {k\\<^sup>+} \\<union>\n  (D - {k\\<inverse>})", "case (Ass D)"], ["proof (state)\nthis:\n  D \\<in> T \\<union> S\n  Ball T (Resolution S)\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>C \\<in> T \\<union> S; Ball T (Resolution S)\\<rbrakk>\n       \\<Longrightarrow> S \\<turnstile> C\n 2. \\<And>C D k.\n       \\<lbrakk>T \\<union> S \\<turnstile> C;\n        Ball T (Resolution S) \\<Longrightarrow> S \\<turnstile> C;\n        T \\<union> S \\<turnstile> D;\n        Ball T (Resolution S) \\<Longrightarrow> S \\<turnstile> D;\n        k\\<^sup>+ \\<in> C; k\\<inverse> \\<in> D;\n        Ball T (Resolution S)\\<rbrakk>\n       \\<Longrightarrow> S \\<turnstile> C - {k\\<^sup>+} \\<union>\n  (D - {k\\<inverse>})", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<turnstile> D", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> S \\<turnstile> D\n 2. \\<not> ?P \\<Longrightarrow> S \\<turnstile> D", "assume \"D \\<in> S\""], ["proof (state)\nthis:\n  D \\<in> S\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> S \\<turnstile> D\n 2. \\<not> ?P \\<Longrightarrow> S \\<turnstile> D", "with Resolution.Ass"], ["proof (chain)\npicking this:\n  ?C \\<in> ?S \\<Longrightarrow> ?S \\<turnstile> ?C\n  D \\<in> S", "show ?thesis"], ["proof (prove)\nusing this:\n  ?C \\<in> ?S \\<Longrightarrow> ?S \\<turnstile> ?C\n  D \\<in> S\n\ngoal (1 subgoal):\n 1. S \\<turnstile> D", "."], ["proof (state)\nthis:\n  S \\<turnstile> D\n\ngoal (1 subgoal):\n 1. D \\<notin> S \\<Longrightarrow> S \\<turnstile> D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. D \\<notin> S \\<Longrightarrow> S \\<turnstile> D", "assume \"D \\<notin> S\""], ["proof (state)\nthis:\n  D \\<notin> S\n\ngoal (1 subgoal):\n 1. D \\<notin> S \\<Longrightarrow> S \\<turnstile> D", "with Ass.hyps"], ["proof (chain)\npicking this:\n  D \\<in> T \\<union> S\n  D \\<notin> S", "have \"D \\<in> T\""], ["proof (prove)\nusing this:\n  D \\<in> T \\<union> S\n  D \\<notin> S\n\ngoal (1 subgoal):\n 1. D \\<in> T", "by simp"], ["proof (state)\nthis:\n  D \\<in> T\n\ngoal (1 subgoal):\n 1. D \\<notin> S \\<Longrightarrow> S \\<turnstile> D", "with Ass.prems"], ["proof (chain)\npicking this:\n  Ball T (Resolution S)\n  D \\<in> T", "show ?thesis"], ["proof (prove)\nusing this:\n  Ball T (Resolution S)\n  D \\<in> T\n\ngoal (1 subgoal):\n 1. S \\<turnstile> D", "by blast"], ["proof (state)\nthis:\n  S \\<turnstile> D\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S \\<turnstile> D\n\ngoal (1 subgoal):\n 1. \\<And>C D k.\n       \\<lbrakk>T \\<union> S \\<turnstile> C;\n        Ball T (Resolution S) \\<Longrightarrow> S \\<turnstile> C;\n        T \\<union> S \\<turnstile> D;\n        Ball T (Resolution S) \\<Longrightarrow> S \\<turnstile> D;\n        k\\<^sup>+ \\<in> C; k\\<inverse> \\<in> D;\n        Ball T (Resolution S)\\<rbrakk>\n       \\<Longrightarrow> S \\<turnstile> C - {k\\<^sup>+} \\<union>\n  (D - {k\\<inverse>})", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C D k.\n       \\<lbrakk>T \\<union> S \\<turnstile> C;\n        Ball T (Resolution S) \\<Longrightarrow> S \\<turnstile> C;\n        T \\<union> S \\<turnstile> D;\n        Ball T (Resolution S) \\<Longrightarrow> S \\<turnstile> D;\n        k\\<^sup>+ \\<in> C; k\\<inverse> \\<in> D;\n        Ball T (Resolution S)\\<rbrakk>\n       \\<Longrightarrow> S \\<turnstile> C - {k\\<^sup>+} \\<union>\n  (D - {k\\<inverse>})", "case (R D H k)"], ["proof (state)\nthis:\n  T \\<union> S \\<turnstile> D\n  Ball T (Resolution S) \\<Longrightarrow> S \\<turnstile> D\n  T \\<union> S \\<turnstile> H\n  Ball T (Resolution S) \\<Longrightarrow> S \\<turnstile> H\n  k\\<^sup>+ \\<in> D\n  k\\<inverse> \\<in> H\n  Ball T (Resolution S)\n\ngoal (1 subgoal):\n 1. \\<And>C D k.\n       \\<lbrakk>T \\<union> S \\<turnstile> C;\n        Ball T (Resolution S) \\<Longrightarrow> S \\<turnstile> C;\n        T \\<union> S \\<turnstile> D;\n        Ball T (Resolution S) \\<Longrightarrow> S \\<turnstile> D;\n        k\\<^sup>+ \\<in> C; k\\<inverse> \\<in> D;\n        Ball T (Resolution S)\\<rbrakk>\n       \\<Longrightarrow> S \\<turnstile> C - {k\\<^sup>+} \\<union>\n  (D - {k\\<inverse>})", "thus ?case"], ["proof (prove)\nusing this:\n  T \\<union> S \\<turnstile> D\n  Ball T (Resolution S) \\<Longrightarrow> S \\<turnstile> D\n  T \\<union> S \\<turnstile> H\n  Ball T (Resolution S) \\<Longrightarrow> S \\<turnstile> H\n  k\\<^sup>+ \\<in> D\n  k\\<inverse> \\<in> H\n  Ball T (Resolution S)\n\ngoal (1 subgoal):\n 1. S \\<turnstile> D - {k\\<^sup>+} \\<union> (H - {k\\<inverse>})", "by (simp add: Resolution.R)"], ["proof (state)\nthis:\n  S \\<turnstile> D - {k\\<^sup>+} \\<union> (H - {k\\<inverse>})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S \\<turnstile> D\n\ngoal (1 subgoal):\n 1. S \\<turnstile> D \\<Longrightarrow> T \\<union> S \\<turnstile> D", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. S \\<turnstile> D \\<Longrightarrow> T \\<union> S \\<turnstile> D", "assume ?r"], ["proof (state)\nthis:\n  S \\<turnstile> D\n\ngoal (1 subgoal):\n 1. S \\<turnstile> D \\<Longrightarrow> T \\<union> S \\<turnstile> D", "with Resolution_weaken"], ["proof (chain)\npicking this:\n  ?S \\<turnstile> ?D \\<Longrightarrow> ?T \\<union> ?S \\<turnstile> ?D\n  S \\<turnstile> D", "show ?l"], ["proof (prove)\nusing this:\n  ?S \\<turnstile> ?D \\<Longrightarrow> ?T \\<union> ?S \\<turnstile> ?D\n  S \\<turnstile> D\n\ngoal (1 subgoal):\n 1. T \\<union> S \\<turnstile> D", "by blast"], ["proof (state)\nthis:\n  T \\<union> S \\<turnstile> D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Resolution_taint_assumptions: \"S \\<union> T \\<turnstile> C \\<Longrightarrow> \\<exists>R \\<subseteq> D. ((\\<union>) D ` S) \\<union> T \\<turnstile> R \\<union> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> T \\<turnstile> C \\<Longrightarrow>\n    \\<exists>R\\<subseteq>D.\n       (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C", "(* No, we don't need to show this for an arbitrary clause D, but the proof doesn't get any more readable if you only allow a single atom. *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> T \\<turnstile> C \\<Longrightarrow>\n    \\<exists>R\\<subseteq>D.\n       (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C", "proof(induction \"S \\<union> T\" \"C\" rule: Resolution.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C.\n       C \\<in> S \\<union> T \\<Longrightarrow>\n       \\<exists>R\\<subseteq>D.\n          (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C\n 2. \\<And>C Da k.\n       \\<lbrakk>S \\<union> T \\<turnstile> C;\n        \\<exists>R\\<subseteq>D.\n           (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C;\n        S \\<union> T \\<turnstile> Da;\n        \\<exists>R\\<subseteq>D.\n           (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> Da;\n        k\\<^sup>+ \\<in> C; k\\<inverse> \\<in> Da\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R\\<subseteq>D.\n                            (\\<union>) D ` S \\<union>\n                            T \\<turnstile> R \\<union>\n     (C - {k\\<^sup>+} \\<union> (Da - {k\\<inverse>}))", "case (Ass C)"], ["proof (state)\nthis:\n  C \\<in> S \\<union> T\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       C \\<in> S \\<union> T \\<Longrightarrow>\n       \\<exists>R\\<subseteq>D.\n          (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C\n 2. \\<And>C Da k.\n       \\<lbrakk>S \\<union> T \\<turnstile> C;\n        \\<exists>R\\<subseteq>D.\n           (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C;\n        S \\<union> T \\<turnstile> Da;\n        \\<exists>R\\<subseteq>D.\n           (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> Da;\n        k\\<^sup>+ \\<in> C; k\\<inverse> \\<in> Da\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R\\<subseteq>D.\n                            (\\<union>) D ` S \\<union>\n                            T \\<turnstile> R \\<union>\n     (C - {k\\<^sup>+} \\<union> (Da - {k\\<inverse>}))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>R\\<subseteq>D.\n       (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C", "proof(cases \"C \\<in> S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. C \\<in> S \\<Longrightarrow>\n    \\<exists>R\\<subseteq>D.\n       (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C\n 2. C \\<notin> S \\<Longrightarrow>\n    \\<exists>R\\<subseteq>D.\n       (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C", "case True"], ["proof (state)\nthis:\n  C \\<in> S\n\ngoal (2 subgoals):\n 1. C \\<in> S \\<Longrightarrow>\n    \\<exists>R\\<subseteq>D.\n       (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C\n 2. C \\<notin> S \\<Longrightarrow>\n    \\<exists>R\\<subseteq>D.\n       (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C", "hence \"D \\<union> C \\<in> (\\<union>) D ` S \\<union> T\""], ["proof (prove)\nusing this:\n  C \\<in> S\n\ngoal (1 subgoal):\n 1. D \\<union> C \\<in> (\\<union>) D ` S \\<union> T", "by simp"], ["proof (state)\nthis:\n  D \\<union> C \\<in> (\\<union>) D ` S \\<union> T\n\ngoal (2 subgoals):\n 1. C \\<in> S \\<Longrightarrow>\n    \\<exists>R\\<subseteq>D.\n       (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C\n 2. C \\<notin> S \\<Longrightarrow>\n    \\<exists>R\\<subseteq>D.\n       (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C", "with Resolution.Ass"], ["proof (chain)\npicking this:\n  ?C \\<in> ?S \\<Longrightarrow> ?S \\<turnstile> ?C\n  D \\<union> C \\<in> (\\<union>) D ` S \\<union> T", "have \"((\\<union>) D ` S) \\<union> T \\<turnstile> D \\<union> C\""], ["proof (prove)\nusing this:\n  ?C \\<in> ?S \\<Longrightarrow> ?S \\<turnstile> ?C\n  D \\<union> C \\<in> (\\<union>) D ` S \\<union> T\n\ngoal (1 subgoal):\n 1. (\\<union>) D ` S \\<union> T \\<turnstile> D \\<union> C", "."], ["proof (state)\nthis:\n  (\\<union>) D ` S \\<union> T \\<turnstile> D \\<union> C\n\ngoal (2 subgoals):\n 1. C \\<in> S \\<Longrightarrow>\n    \\<exists>R\\<subseteq>D.\n       (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C\n 2. C \\<notin> S \\<Longrightarrow>\n    \\<exists>R\\<subseteq>D.\n       (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<union>) D ` S \\<union> T \\<turnstile> D \\<union> C\n\ngoal (1 subgoal):\n 1. \\<exists>R\\<subseteq>D.\n       (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C", "by blast"], ["proof (state)\nthis:\n  \\<exists>R\\<subseteq>D.\n     (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C\n\ngoal (1 subgoal):\n 1. C \\<notin> S \\<Longrightarrow>\n    \\<exists>R\\<subseteq>D.\n       (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. C \\<notin> S \\<Longrightarrow>\n    \\<exists>R\\<subseteq>D.\n       (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C", "case False"], ["proof (state)\nthis:\n  C \\<notin> S\n\ngoal (1 subgoal):\n 1. C \\<notin> S \\<Longrightarrow>\n    \\<exists>R\\<subseteq>D.\n       (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C", "with Ass"], ["proof (chain)\npicking this:\n  C \\<in> S \\<union> T\n  C \\<notin> S", "have \"C \\<in> T\""], ["proof (prove)\nusing this:\n  C \\<in> S \\<union> T\n  C \\<notin> S\n\ngoal (1 subgoal):\n 1. C \\<in> T", "by simp"], ["proof (state)\nthis:\n  C \\<in> T\n\ngoal (1 subgoal):\n 1. C \\<notin> S \\<Longrightarrow>\n    \\<exists>R\\<subseteq>D.\n       (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C", "hence \"((\\<union>) D ` S) \\<union> T \\<turnstile> C\""], ["proof (prove)\nusing this:\n  C \\<in> T\n\ngoal (1 subgoal):\n 1. (\\<union>) D ` S \\<union> T \\<turnstile> C", "by(simp add: Resolution.Ass)"], ["proof (state)\nthis:\n  (\\<union>) D ` S \\<union> T \\<turnstile> C\n\ngoal (1 subgoal):\n 1. C \\<notin> S \\<Longrightarrow>\n    \\<exists>R\\<subseteq>D.\n       (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<union>) D ` S \\<union> T \\<turnstile> C\n\ngoal (1 subgoal):\n 1. \\<exists>R\\<subseteq>D.\n       (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C", "by(intro exI[where x=\"{}\"]) simp"], ["proof (state)\nthis:\n  \\<exists>R\\<subseteq>D.\n     (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>R\\<subseteq>D.\n     (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C\n\ngoal (1 subgoal):\n 1. \\<And>C Da k.\n       \\<lbrakk>S \\<union> T \\<turnstile> C;\n        \\<exists>R\\<subseteq>D.\n           (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C;\n        S \\<union> T \\<turnstile> Da;\n        \\<exists>R\\<subseteq>D.\n           (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> Da;\n        k\\<^sup>+ \\<in> C; k\\<inverse> \\<in> Da\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R\\<subseteq>D.\n                            (\\<union>) D ` S \\<union>\n                            T \\<turnstile> R \\<union>\n     (C - {k\\<^sup>+} \\<union> (Da - {k\\<inverse>}))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C Da k.\n       \\<lbrakk>S \\<union> T \\<turnstile> C;\n        \\<exists>R\\<subseteq>D.\n           (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C;\n        S \\<union> T \\<turnstile> Da;\n        \\<exists>R\\<subseteq>D.\n           (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> Da;\n        k\\<^sup>+ \\<in> C; k\\<inverse> \\<in> Da\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R\\<subseteq>D.\n                            (\\<union>) D ` S \\<union>\n                            T \\<turnstile> R \\<union>\n     (C - {k\\<^sup>+} \\<union> (Da - {k\\<inverse>}))", "case (R C1 C2 k)"], ["proof (state)\nthis:\n  S \\<union> T \\<turnstile> C1\n  \\<exists>R\\<subseteq>D.\n     (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C1\n  S \\<union> T \\<turnstile> C2\n  \\<exists>R\\<subseteq>D.\n     (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C2\n  k\\<^sup>+ \\<in> C1\n  k\\<inverse> \\<in> C2\n\ngoal (1 subgoal):\n 1. \\<And>C Da k.\n       \\<lbrakk>S \\<union> T \\<turnstile> C;\n        \\<exists>R\\<subseteq>D.\n           (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C;\n        S \\<union> T \\<turnstile> Da;\n        \\<exists>R\\<subseteq>D.\n           (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> Da;\n        k\\<^sup>+ \\<in> C; k\\<inverse> \\<in> Da\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R\\<subseteq>D.\n                            (\\<union>) D ` S \\<union>\n                            T \\<turnstile> R \\<union>\n     (C - {k\\<^sup>+} \\<union> (Da - {k\\<inverse>}))", "let ?m = \"((\\<union>) D ` S) \\<union> T\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C Da k.\n       \\<lbrakk>S \\<union> T \\<turnstile> C;\n        \\<exists>R\\<subseteq>D.\n           (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C;\n        S \\<union> T \\<turnstile> Da;\n        \\<exists>R\\<subseteq>D.\n           (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> Da;\n        k\\<^sup>+ \\<in> C; k\\<inverse> \\<in> Da\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R\\<subseteq>D.\n                            (\\<union>) D ` S \\<union>\n                            T \\<turnstile> R \\<union>\n     (C - {k\\<^sup>+} \\<union> (Da - {k\\<inverse>}))", "from R"], ["proof (chain)\npicking this:\n  S \\<union> T \\<turnstile> C1\n  \\<exists>R\\<subseteq>D.\n     (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C1\n  S \\<union> T \\<turnstile> C2\n  \\<exists>R\\<subseteq>D.\n     (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C2\n  k\\<^sup>+ \\<in> C1\n  k\\<inverse> \\<in> C2", "obtain R1 where IH1: \"R1 \\<subseteq> D\" \"?m \\<turnstile> R1 \\<union> C1\""], ["proof (prove)\nusing this:\n  S \\<union> T \\<turnstile> C1\n  \\<exists>R\\<subseteq>D.\n     (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C1\n  S \\<union> T \\<turnstile> C2\n  \\<exists>R\\<subseteq>D.\n     (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C2\n  k\\<^sup>+ \\<in> C1\n  k\\<inverse> \\<in> C2\n\ngoal (1 subgoal):\n 1. (\\<And>R1.\n        \\<lbrakk>R1 \\<subseteq> D;\n         (\\<union>) D ` S \\<union> T \\<turnstile> R1 \\<union> C1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  R1 \\<subseteq> D\n  (\\<union>) D ` S \\<union> T \\<turnstile> R1 \\<union> C1\n\ngoal (1 subgoal):\n 1. \\<And>C Da k.\n       \\<lbrakk>S \\<union> T \\<turnstile> C;\n        \\<exists>R\\<subseteq>D.\n           (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C;\n        S \\<union> T \\<turnstile> Da;\n        \\<exists>R\\<subseteq>D.\n           (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> Da;\n        k\\<^sup>+ \\<in> C; k\\<inverse> \\<in> Da\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R\\<subseteq>D.\n                            (\\<union>) D ` S \\<union>\n                            T \\<turnstile> R \\<union>\n     (C - {k\\<^sup>+} \\<union> (Da - {k\\<inverse>}))", "from R"], ["proof (chain)\npicking this:\n  S \\<union> T \\<turnstile> C1\n  \\<exists>R\\<subseteq>D.\n     (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C1\n  S \\<union> T \\<turnstile> C2\n  \\<exists>R\\<subseteq>D.\n     (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C2\n  k\\<^sup>+ \\<in> C1\n  k\\<inverse> \\<in> C2", "obtain R2 where IH2: \"R2 \\<subseteq> D\" \"?m \\<turnstile> R2 \\<union> C2\""], ["proof (prove)\nusing this:\n  S \\<union> T \\<turnstile> C1\n  \\<exists>R\\<subseteq>D.\n     (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C1\n  S \\<union> T \\<turnstile> C2\n  \\<exists>R\\<subseteq>D.\n     (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C2\n  k\\<^sup>+ \\<in> C1\n  k\\<inverse> \\<in> C2\n\ngoal (1 subgoal):\n 1. (\\<And>R2.\n        \\<lbrakk>R2 \\<subseteq> D;\n         (\\<union>) D ` S \\<union> T \\<turnstile> R2 \\<union> C2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  R2 \\<subseteq> D\n  (\\<union>) D ` S \\<union> T \\<turnstile> R2 \\<union> C2\n\ngoal (1 subgoal):\n 1. \\<And>C Da k.\n       \\<lbrakk>S \\<union> T \\<turnstile> C;\n        \\<exists>R\\<subseteq>D.\n           (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C;\n        S \\<union> T \\<turnstile> Da;\n        \\<exists>R\\<subseteq>D.\n           (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> Da;\n        k\\<^sup>+ \\<in> C; k\\<inverse> \\<in> Da\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R\\<subseteq>D.\n                            (\\<union>) D ` S \\<union>\n                            T \\<turnstile> R \\<union>\n     (C - {k\\<^sup>+} \\<union> (Da - {k\\<inverse>}))", "from R"], ["proof (chain)\npicking this:\n  S \\<union> T \\<turnstile> C1\n  \\<exists>R\\<subseteq>D.\n     (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C1\n  S \\<union> T \\<turnstile> C2\n  \\<exists>R\\<subseteq>D.\n     (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C2\n  k\\<^sup>+ \\<in> C1\n  k\\<inverse> \\<in> C2", "have \"k\\<^sup>+ \\<in> R1 \\<union> C1\" \"k\\<inverse> \\<in> R2 \\<union> C2\""], ["proof (prove)\nusing this:\n  S \\<union> T \\<turnstile> C1\n  \\<exists>R\\<subseteq>D.\n     (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C1\n  S \\<union> T \\<turnstile> C2\n  \\<exists>R\\<subseteq>D.\n     (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C2\n  k\\<^sup>+ \\<in> C1\n  k\\<inverse> \\<in> C2\n\ngoal (1 subgoal):\n 1. k\\<^sup>+ \\<in> R1 \\<union> C1 &&& k\\<inverse> \\<in> R2 \\<union> C2", "by simp_all"], ["proof (state)\nthis:\n  k\\<^sup>+ \\<in> R1 \\<union> C1\n  k\\<inverse> \\<in> R2 \\<union> C2\n\ngoal (1 subgoal):\n 1. \\<And>C Da k.\n       \\<lbrakk>S \\<union> T \\<turnstile> C;\n        \\<exists>R\\<subseteq>D.\n           (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C;\n        S \\<union> T \\<turnstile> Da;\n        \\<exists>R\\<subseteq>D.\n           (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> Da;\n        k\\<^sup>+ \\<in> C; k\\<inverse> \\<in> Da\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R\\<subseteq>D.\n                            (\\<union>) D ` S \\<union>\n                            T \\<turnstile> R \\<union>\n     (C - {k\\<^sup>+} \\<union> (Da - {k\\<inverse>}))", "note Resolution.R[OF IH1(2) IH2(2) this]"], ["proof (state)\nthis:\n  (\\<union>) D ` S \\<union>\n  T \\<turnstile> R1 \\<union> C1 - {k\\<^sup>+} \\<union>\n                 (R2 \\<union> C2 - {k\\<inverse>})\n\ngoal (1 subgoal):\n 1. \\<And>C Da k.\n       \\<lbrakk>S \\<union> T \\<turnstile> C;\n        \\<exists>R\\<subseteq>D.\n           (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C;\n        S \\<union> T \\<turnstile> Da;\n        \\<exists>R\\<subseteq>D.\n           (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> Da;\n        k\\<^sup>+ \\<in> C; k\\<inverse> \\<in> Da\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R\\<subseteq>D.\n                            (\\<union>) D ` S \\<union>\n                            T \\<turnstile> R \\<union>\n     (C - {k\\<^sup>+} \\<union> (Da - {k\\<inverse>}))", "hence \"?m \\<turnstile> (R1 - {k\\<^sup>+}) \\<union> (R2 - {k\\<inverse>}) \\<union> (C1 - {k\\<^sup>+} \\<union> (C2 - {k\\<inverse>}))\""], ["proof (prove)\nusing this:\n  (\\<union>) D ` S \\<union>\n  T \\<turnstile> R1 \\<union> C1 - {k\\<^sup>+} \\<union>\n                 (R2 \\<union> C2 - {k\\<inverse>})\n\ngoal (1 subgoal):\n 1. (\\<union>) D ` S \\<union>\n    T \\<turnstile> R1 - {k\\<^sup>+} \\<union> (R2 - {k\\<inverse>}) \\<union>\n                   (C1 - {k\\<^sup>+} \\<union> (C2 - {k\\<inverse>}))", "by (simp add: Un_Diff Un_left_commute sup.assoc)"], ["proof (state)\nthis:\n  (\\<union>) D ` S \\<union>\n  T \\<turnstile> R1 - {k\\<^sup>+} \\<union> (R2 - {k\\<inverse>}) \\<union>\n                 (C1 - {k\\<^sup>+} \\<union> (C2 - {k\\<inverse>}))\n\ngoal (1 subgoal):\n 1. \\<And>C Da k.\n       \\<lbrakk>S \\<union> T \\<turnstile> C;\n        \\<exists>R\\<subseteq>D.\n           (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C;\n        S \\<union> T \\<turnstile> Da;\n        \\<exists>R\\<subseteq>D.\n           (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> Da;\n        k\\<^sup>+ \\<in> C; k\\<inverse> \\<in> Da\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R\\<subseteq>D.\n                            (\\<union>) D ` S \\<union>\n                            T \\<turnstile> R \\<union>\n     (C - {k\\<^sup>+} \\<union> (Da - {k\\<inverse>}))", "moreover"], ["proof (state)\nthis:\n  (\\<union>) D ` S \\<union>\n  T \\<turnstile> R1 - {k\\<^sup>+} \\<union> (R2 - {k\\<inverse>}) \\<union>\n                 (C1 - {k\\<^sup>+} \\<union> (C2 - {k\\<inverse>}))\n\ngoal (1 subgoal):\n 1. \\<And>C Da k.\n       \\<lbrakk>S \\<union> T \\<turnstile> C;\n        \\<exists>R\\<subseteq>D.\n           (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C;\n        S \\<union> T \\<turnstile> Da;\n        \\<exists>R\\<subseteq>D.\n           (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> Da;\n        k\\<^sup>+ \\<in> C; k\\<inverse> \\<in> Da\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R\\<subseteq>D.\n                            (\\<union>) D ` S \\<union>\n                            T \\<turnstile> R \\<union>\n     (C - {k\\<^sup>+} \\<union> (Da - {k\\<inverse>}))", "have \"(R1 - {k\\<^sup>+}) \\<union> (R2 - {k\\<inverse>}) \\<subseteq> D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R1 - {k\\<^sup>+} \\<union> (R2 - {k\\<inverse>}) \\<subseteq> D", "(* hah\\<triangleright> gotcha. This is the reason that I should be doing this on sets\\<triangleright> not multisets. - neh, actually, there are others. how is the rule even supposed to look? *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. R1 - {k\\<^sup>+} \\<union> (R2 - {k\\<inverse>}) \\<subseteq> D", "using IH1(1) IH2(1)"], ["proof (prove)\nusing this:\n  R1 \\<subseteq> D\n  R2 \\<subseteq> D\n\ngoal (1 subgoal):\n 1. R1 - {k\\<^sup>+} \\<union> (R2 - {k\\<inverse>}) \\<subseteq> D", "by blast"], ["proof (state)\nthis:\n  R1 - {k\\<^sup>+} \\<union> (R2 - {k\\<inverse>}) \\<subseteq> D\n\ngoal (1 subgoal):\n 1. \\<And>C Da k.\n       \\<lbrakk>S \\<union> T \\<turnstile> C;\n        \\<exists>R\\<subseteq>D.\n           (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> C;\n        S \\<union> T \\<turnstile> Da;\n        \\<exists>R\\<subseteq>D.\n           (\\<union>) D ` S \\<union> T \\<turnstile> R \\<union> Da;\n        k\\<^sup>+ \\<in> C; k\\<inverse> \\<in> Da\\<rbrakk>\n       \\<Longrightarrow> \\<exists>R\\<subseteq>D.\n                            (\\<union>) D ` S \\<union>\n                            T \\<turnstile> R \\<union>\n     (C - {k\\<^sup>+} \\<union> (Da - {k\\<inverse>}))", "ultimately"], ["proof (chain)\npicking this:\n  (\\<union>) D ` S \\<union>\n  T \\<turnstile> R1 - {k\\<^sup>+} \\<union> (R2 - {k\\<inverse>}) \\<union>\n                 (C1 - {k\\<^sup>+} \\<union> (C2 - {k\\<inverse>}))\n  R1 - {k\\<^sup>+} \\<union> (R2 - {k\\<inverse>}) \\<subseteq> D", "show ?case"], ["proof (prove)\nusing this:\n  (\\<union>) D ` S \\<union>\n  T \\<turnstile> R1 - {k\\<^sup>+} \\<union> (R2 - {k\\<inverse>}) \\<union>\n                 (C1 - {k\\<^sup>+} \\<union> (C2 - {k\\<inverse>}))\n  R1 - {k\\<^sup>+} \\<union> (R2 - {k\\<inverse>}) \\<subseteq> D\n\ngoal (1 subgoal):\n 1. \\<exists>R\\<subseteq>D.\n       (\\<union>) D ` S \\<union>\n       T \\<turnstile> R \\<union>\n                      (C1 - {k\\<^sup>+} \\<union> (C2 - {k\\<inverse>}))", "by blast"], ["proof (state)\nthis:\n  \\<exists>R\\<subseteq>D.\n     (\\<union>) D ` S \\<union>\n     T \\<turnstile> R \\<union>\n                    (C1 - {k\\<^sup>+} \\<union> (C2 - {k\\<inverse>}))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Resolution is ``strange'':\nGiven a set of clauses that is presumed to be satisfiable,\nit derives new clauses that can be added while preserving the satisfiability of the set of clauses.\nHowever, not every clause that could be added while keeping satisfiability can actually be added by resolution.\nEspecially, the above lemma \\<open>Resolution_taint_assumptions\\<close> gives us the derivability of a clause\n@{term \"R \\<union> C\"}, where @{term \"R \\<subseteq> D\"}. What we might actually want is the derivability of \n@{term \"D \\<union> C\"}. Any model that satisfies @{term \"R \\<union> C\"} obviously satisfies @{term \"D \\<union> C\"} \n(since they are disjunctions), but Resolution only allows to derive the former.\n\\<close>"], ["", "text\\<open>Nevertheless, \\<open>Resolution_taint_assumptions\\<close>, can still be a quite useful lemma:\npicking @{term D} to be a singleton set only leaves two possibilities for @{term R}.\\<close>"], ["", "lemma Resolution_useless_infinite:\nassumes R: \"S \\<turnstile> R\"\nassumes \"finite R\"\nshows \"\\<exists>S' \\<subseteq> S. Ball S' finite \\<and> finite S' \\<and> (S' \\<turnstile> R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>S'\\<subseteq>S.\n       Ball S' finite \\<and> finite S' \\<and> (S' \\<turnstile> R)", "using assms"], ["proof (prove)\nusing this:\n  S \\<turnstile> R\n  finite R\n\ngoal (1 subgoal):\n 1. \\<exists>S'\\<subseteq>S.\n       Ball S' finite \\<and> finite S' \\<and> (S' \\<turnstile> R)", "proof(induction rule: Resolution.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C S.\n       \\<lbrakk>C \\<in> S; finite C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S'\\<subseteq>S.\n                            Ball S' finite \\<and>\n                            finite S' \\<and> (S' \\<turnstile> C)\n 2. \\<And>S C D k.\n       \\<lbrakk>S \\<turnstile> C;\n        finite C \\<Longrightarrow>\n        \\<exists>S'\\<subseteq>S.\n           Ball S' finite \\<and> finite S' \\<and> (S' \\<turnstile> C);\n        S \\<turnstile> D;\n        finite D \\<Longrightarrow>\n        \\<exists>S'\\<subseteq>S.\n           Ball S' finite \\<and> finite S' \\<and> (S' \\<turnstile> D);\n        k\\<^sup>+ \\<in> C; k\\<inverse> \\<in> D;\n        finite (C - {k\\<^sup>+} \\<union> (D - {k\\<inverse>}))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S'\\<subseteq>S.\n                            Ball S' finite \\<and>\n                            finite S' \\<and>\n                            (S' \\<turnstile> C - {k\\<^sup>+} \\<union>\n       (D - {k\\<inverse>}))", "case (Ass C S)"], ["proof (state)\nthis:\n  C \\<in> S\n  finite C\n\ngoal (2 subgoals):\n 1. \\<And>C S.\n       \\<lbrakk>C \\<in> S; finite C\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S'\\<subseteq>S.\n                            Ball S' finite \\<and>\n                            finite S' \\<and> (S' \\<turnstile> C)\n 2. \\<And>S C D k.\n       \\<lbrakk>S \\<turnstile> C;\n        finite C \\<Longrightarrow>\n        \\<exists>S'\\<subseteq>S.\n           Ball S' finite \\<and> finite S' \\<and> (S' \\<turnstile> C);\n        S \\<turnstile> D;\n        finite D \\<Longrightarrow>\n        \\<exists>S'\\<subseteq>S.\n           Ball S' finite \\<and> finite S' \\<and> (S' \\<turnstile> D);\n        k\\<^sup>+ \\<in> C; k\\<inverse> \\<in> D;\n        finite (C - {k\\<^sup>+} \\<union> (D - {k\\<inverse>}))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S'\\<subseteq>S.\n                            Ball S' finite \\<and>\n                            finite S' \\<and>\n                            (S' \\<turnstile> C - {k\\<^sup>+} \\<union>\n       (D - {k\\<inverse>}))", "thus ?case"], ["proof (prove)\nusing this:\n  C \\<in> S\n  finite C\n\ngoal (1 subgoal):\n 1. \\<exists>S'\\<subseteq>S.\n       (\\<forall>a\\<in>S'. finite a) \\<and>\n       finite S' \\<and> (S' \\<turnstile> C)", "using Resolution.Ass"], ["proof (prove)\nusing this:\n  C \\<in> S\n  finite C\n  ?C \\<in> ?S \\<Longrightarrow> ?S \\<turnstile> ?C\n\ngoal (1 subgoal):\n 1. \\<exists>S'\\<subseteq>S.\n       (\\<forall>a\\<in>S'. finite a) \\<and>\n       finite S' \\<and> (S' \\<turnstile> C)", "by(intro exI[where x=\"{C}\"]) auto"], ["proof (state)\nthis:\n  \\<exists>S'\\<subseteq>S.\n     (\\<forall>a\\<in>S'. finite a) \\<and>\n     finite S' \\<and> (S' \\<turnstile> C)\n\ngoal (1 subgoal):\n 1. \\<And>S C D k.\n       \\<lbrakk>S \\<turnstile> C;\n        finite C \\<Longrightarrow>\n        \\<exists>S'\\<subseteq>S.\n           Ball S' finite \\<and> finite S' \\<and> (S' \\<turnstile> C);\n        S \\<turnstile> D;\n        finite D \\<Longrightarrow>\n        \\<exists>S'\\<subseteq>S.\n           Ball S' finite \\<and> finite S' \\<and> (S' \\<turnstile> D);\n        k\\<^sup>+ \\<in> C; k\\<inverse> \\<in> D;\n        finite (C - {k\\<^sup>+} \\<union> (D - {k\\<inverse>}))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S'\\<subseteq>S.\n                            Ball S' finite \\<and>\n                            finite S' \\<and>\n                            (S' \\<turnstile> C - {k\\<^sup>+} \\<union>\n       (D - {k\\<inverse>}))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S C D k.\n       \\<lbrakk>S \\<turnstile> C;\n        finite C \\<Longrightarrow>\n        \\<exists>S'\\<subseteq>S.\n           Ball S' finite \\<and> finite S' \\<and> (S' \\<turnstile> C);\n        S \\<turnstile> D;\n        finite D \\<Longrightarrow>\n        \\<exists>S'\\<subseteq>S.\n           Ball S' finite \\<and> finite S' \\<and> (S' \\<turnstile> D);\n        k\\<^sup>+ \\<in> C; k\\<inverse> \\<in> D;\n        finite (C - {k\\<^sup>+} \\<union> (D - {k\\<inverse>}))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S'\\<subseteq>S.\n                            Ball S' finite \\<and>\n                            finite S' \\<and>\n                            (S' \\<turnstile> C - {k\\<^sup>+} \\<union>\n       (D - {k\\<inverse>}))", "case (R S C D k)"], ["proof (state)\nthis:\n  S \\<turnstile> C\n  S \\<turnstile> D\n  k\\<^sup>+ \\<in> C\n  k\\<inverse> \\<in> D\n  finite C \\<Longrightarrow>\n  \\<exists>S'\\<subseteq>S.\n     (\\<forall>a\\<in>S'. finite a) \\<and>\n     finite S' \\<and> (S' \\<turnstile> C)\n  finite D \\<Longrightarrow>\n  \\<exists>S'\\<subseteq>S.\n     (\\<forall>a\\<in>S'. finite a) \\<and>\n     finite S' \\<and> (S' \\<turnstile> D)\n  finite (C - {k\\<^sup>+} \\<union> (D - {k\\<inverse>}))\n\ngoal (1 subgoal):\n 1. \\<And>S C D k.\n       \\<lbrakk>S \\<turnstile> C;\n        finite C \\<Longrightarrow>\n        \\<exists>S'\\<subseteq>S.\n           Ball S' finite \\<and> finite S' \\<and> (S' \\<turnstile> C);\n        S \\<turnstile> D;\n        finite D \\<Longrightarrow>\n        \\<exists>S'\\<subseteq>S.\n           Ball S' finite \\<and> finite S' \\<and> (S' \\<turnstile> D);\n        k\\<^sup>+ \\<in> C; k\\<inverse> \\<in> D;\n        finite (C - {k\\<^sup>+} \\<union> (D - {k\\<inverse>}))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S'\\<subseteq>S.\n                            Ball S' finite \\<and>\n                            finite S' \\<and>\n                            (S' \\<turnstile> C - {k\\<^sup>+} \\<union>\n       (D - {k\\<inverse>}))", "from R.prems"], ["proof (chain)\npicking this:\n  finite (C - {k\\<^sup>+} \\<union> (D - {k\\<inverse>}))", "have \"finite C\" \"finite D\""], ["proof (prove)\nusing this:\n  finite (C - {k\\<^sup>+} \\<union> (D - {k\\<inverse>}))\n\ngoal (1 subgoal):\n 1. finite C &&& finite D", "by simp_all"], ["proof (state)\nthis:\n  finite C\n  finite D\n\ngoal (1 subgoal):\n 1. \\<And>S C D k.\n       \\<lbrakk>S \\<turnstile> C;\n        finite C \\<Longrightarrow>\n        \\<exists>S'\\<subseteq>S.\n           Ball S' finite \\<and> finite S' \\<and> (S' \\<turnstile> C);\n        S \\<turnstile> D;\n        finite D \\<Longrightarrow>\n        \\<exists>S'\\<subseteq>S.\n           Ball S' finite \\<and> finite S' \\<and> (S' \\<turnstile> D);\n        k\\<^sup>+ \\<in> C; k\\<inverse> \\<in> D;\n        finite (C - {k\\<^sup>+} \\<union> (D - {k\\<inverse>}))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S'\\<subseteq>S.\n                            Ball S' finite \\<and>\n                            finite S' \\<and>\n                            (S' \\<turnstile> C - {k\\<^sup>+} \\<union>\n       (D - {k\\<inverse>}))", "with R.IH"], ["proof (chain)\npicking this:\n  finite C \\<Longrightarrow>\n  \\<exists>S'\\<subseteq>S.\n     (\\<forall>a\\<in>S'. finite a) \\<and>\n     finite S' \\<and> (S' \\<turnstile> C)\n  finite D \\<Longrightarrow>\n  \\<exists>S'\\<subseteq>S.\n     (\\<forall>a\\<in>S'. finite a) \\<and>\n     finite S' \\<and> (S' \\<turnstile> D)\n  finite C\n  finite D", "obtain SC SD where IH:\n    \"SC\\<subseteq>S\" \"(\\<forall>C\\<in>SC. finite C)\" \"finite SC\" \"SC \\<turnstile> C\"\n    \"SD\\<subseteq>S\" \"(\\<forall>D\\<in>SD. finite D)\" \"finite SD\" \"SD \\<turnstile> D\""], ["proof (prove)\nusing this:\n  finite C \\<Longrightarrow>\n  \\<exists>S'\\<subseteq>S.\n     (\\<forall>a\\<in>S'. finite a) \\<and>\n     finite S' \\<and> (S' \\<turnstile> C)\n  finite D \\<Longrightarrow>\n  \\<exists>S'\\<subseteq>S.\n     (\\<forall>a\\<in>S'. finite a) \\<and>\n     finite S' \\<and> (S' \\<turnstile> D)\n  finite C\n  finite D\n\ngoal (1 subgoal):\n 1. (\\<And>SC SD.\n        \\<lbrakk>SC \\<subseteq> S; \\<forall>C\\<in>SC. finite C; finite SC;\n         SC \\<turnstile> C; SD \\<subseteq> S; \\<forall>D\\<in>SD. finite D;\n         finite SD; SD \\<turnstile> D\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  SC \\<subseteq> S\n  \\<forall>C\\<in>SC. finite C\n  finite SC\n  SC \\<turnstile> C\n  SD \\<subseteq> S\n  \\<forall>D\\<in>SD. finite D\n  finite SD\n  SD \\<turnstile> D\n\ngoal (1 subgoal):\n 1. \\<And>S C D k.\n       \\<lbrakk>S \\<turnstile> C;\n        finite C \\<Longrightarrow>\n        \\<exists>S'\\<subseteq>S.\n           Ball S' finite \\<and> finite S' \\<and> (S' \\<turnstile> C);\n        S \\<turnstile> D;\n        finite D \\<Longrightarrow>\n        \\<exists>S'\\<subseteq>S.\n           Ball S' finite \\<and> finite S' \\<and> (S' \\<turnstile> D);\n        k\\<^sup>+ \\<in> C; k\\<inverse> \\<in> D;\n        finite (C - {k\\<^sup>+} \\<union> (D - {k\\<inverse>}))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S'\\<subseteq>S.\n                            Ball S' finite \\<and>\n                            finite S' \\<and>\n                            (S' \\<turnstile> C - {k\\<^sup>+} \\<union>\n       (D - {k\\<inverse>}))", "hence IHw: \"SC \\<union> SD \\<turnstile> C\" \"SC \\<union> SD \\<turnstile> D\""], ["proof (prove)\nusing this:\n  SC \\<subseteq> S\n  \\<forall>C\\<in>SC. finite C\n  finite SC\n  SC \\<turnstile> C\n  SD \\<subseteq> S\n  \\<forall>D\\<in>SD. finite D\n  finite SD\n  SD \\<turnstile> D\n\ngoal (1 subgoal):\n 1. SC \\<union> SD \\<turnstile> C &&& SC \\<union> SD \\<turnstile> D", "using Resolution_weaken"], ["proof (prove)\nusing this:\n  SC \\<subseteq> S\n  \\<forall>C\\<in>SC. finite C\n  finite SC\n  SC \\<turnstile> C\n  SD \\<subseteq> S\n  \\<forall>D\\<in>SD. finite D\n  finite SD\n  SD \\<turnstile> D\n  ?S \\<turnstile> ?D \\<Longrightarrow> ?T \\<union> ?S \\<turnstile> ?D\n\ngoal (1 subgoal):\n 1. SC \\<union> SD \\<turnstile> C &&& SC \\<union> SD \\<turnstile> D", "by(simp_all add: sup_commute Resolution_weaken (* yes, using and simp set. whatever. *))"], ["proof (state)\nthis:\n  SC \\<union> SD \\<turnstile> C\n  SC \\<union> SD \\<turnstile> D\n\ngoal (1 subgoal):\n 1. \\<And>S C D k.\n       \\<lbrakk>S \\<turnstile> C;\n        finite C \\<Longrightarrow>\n        \\<exists>S'\\<subseteq>S.\n           Ball S' finite \\<and> finite S' \\<and> (S' \\<turnstile> C);\n        S \\<turnstile> D;\n        finite D \\<Longrightarrow>\n        \\<exists>S'\\<subseteq>S.\n           Ball S' finite \\<and> finite S' \\<and> (S' \\<turnstile> D);\n        k\\<^sup>+ \\<in> C; k\\<inverse> \\<in> D;\n        finite (C - {k\\<^sup>+} \\<union> (D - {k\\<inverse>}))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S'\\<subseteq>S.\n                            Ball S' finite \\<and>\n                            finite S' \\<and>\n                            (S' \\<turnstile> C - {k\\<^sup>+} \\<union>\n       (D - {k\\<inverse>}))", "with IH(1-3,5-7)"], ["proof (chain)\npicking this:\n  SC \\<subseteq> S\n  \\<forall>C\\<in>SC. finite C\n  finite SC\n  SD \\<subseteq> S\n  \\<forall>D\\<in>SD. finite D\n  finite SD\n  SC \\<union> SD \\<turnstile> C\n  SC \\<union> SD \\<turnstile> D", "show ?case"], ["proof (prove)\nusing this:\n  SC \\<subseteq> S\n  \\<forall>C\\<in>SC. finite C\n  finite SC\n  SD \\<subseteq> S\n  \\<forall>D\\<in>SD. finite D\n  finite SD\n  SC \\<union> SD \\<turnstile> C\n  SC \\<union> SD \\<turnstile> D\n\ngoal (1 subgoal):\n 1. \\<exists>S'\\<subseteq>S.\n       (\\<forall>a\\<in>S'. finite a) \\<and>\n       finite S' \\<and>\n       (S' \\<turnstile> C - {k\\<^sup>+} \\<union> (D - {k\\<inverse>}))", "by(blast intro!: exI[where x=\"SC \\<union> SD\"] Resolution.R[OF _ _ \\<open>k\\<^sup>+ \\<in> C\\<close> \\<open>k\\<inverse> \\<in> D\\<close>])"], ["proof (state)\nthis:\n  \\<exists>S'\\<subseteq>S.\n     (\\<forall>a\\<in>S'. finite a) \\<and>\n     finite S' \\<and>\n     (S' \\<turnstile> C - {k\\<^sup>+} \\<union> (D - {k\\<inverse>}))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* situation would be different if we allowed to resolve an infinite amount of literals in one step instead of just one.\n   And I think that's exactly the reason why one doesn't do that.\n *)"], ["", "text\\<open>Now we define and verify a toy resolution prover.\nFunction \\<open>res\\<close> computes the set of resolvents of a clause set:\\<close>"], ["", "context begin"], ["", "definition res :: \"'a clause set \\<Rightarrow> 'a clause set\" where\n\"res S =\n (\\<Union>C1 \\<in> S. \\<Union>C2 \\<in> S. \\<Union>L1 \\<in> C1. \\<Union>L2 \\<in> C2.\n (case (L1,L2) of (Pos i,Neg j) \\<Rightarrow> if i=j then {(C1 - {Pos i}) \\<union> (C2 - {Neg j})} else {}\n  | _ \\<Rightarrow> {}))\""], ["", "private"], ["", "definition \"ex1 \\<equiv> {{Neg (0::int)}, {Pos 0, Pos 1, Neg 2}, {Pos 0, Pos 1, Pos 2}, {Pos 0, Neg 1}}\""], ["", "value \"res ex1\""], ["", "(* now we want to iterate res. We've got two options. Either use the while combinator,\n   which is not so beautiful to present but easy to understand, or use partial_function magic,\n  which looks beautiful, but\\<dots> magic. The ML kind. *)"], ["", "definition Rwhile ::\" 'a clause set \\<Rightarrow> 'a clause set option\" where\n\"Rwhile = while_option (\\<lambda>S. \\<box> \\<notin> S \\<and> \\<not> res S \\<subseteq> S) (\\<lambda>S. res S \\<union> S)\""], ["", "value [code] \"Rwhile ex1\""], ["", "lemma \"\\<box> \\<in> the (Rwhile ex1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<box> \\<in> the (Rwhile ex1)", "by eval"], ["", "lemma Rwhile_sound: assumes \"Rwhile S = Some S'\"\n  shows \"\\<forall>C \\<in> S'. Resolution S C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>S'. S \\<turnstile> C", "apply(rule while_option_rule[OF _ assms[unfolded Rwhile_def]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>\\<forall>C\\<in>s. S \\<turnstile> C;\n        \\<box> \\<notin> s \\<and> \\<not> res s \\<subseteq> s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>C\\<in>res s \\<union> s. S \\<turnstile> C\n 2. \\<forall>C\\<in>S. S \\<turnstile> C", "apply (auto simp: Ass R res_def split: if_splits literal.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"all_clauses S = {s. s \\<subseteq> {Pos k|k. k \\<in> atoms_of_cnf S} \\<union> {Neg k|k. k \\<in> atoms_of_cnf S}}\""], ["", "lemma s_sub_all_clauses: \"S \\<subseteq> all_clauses S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> all_clauses S", "unfolding all_clauses_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> {s. s \\<subseteq> {k\\<^sup>+ |k.\n                                     k \\<in> atoms_of_cnf S} \\<union>\n                                    {k\\<inverse> |k.\n                                     k \\<in> atoms_of_cnf S}}", "apply(rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> S \\<Longrightarrow>\n       x \\<in> {s. s \\<subseteq> {k\\<^sup>+ |k.\n                                  k \\<in> atoms_of_cnf S} \\<union>\n                                 {k\\<inverse> |k. k \\<in> atoms_of_cnf S}}", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> S \\<Longrightarrow>\n       x \\<subseteq> {k\\<^sup>+ |k. k \\<in> atoms_of_cnf S} \\<union>\n                     {k\\<inverse> |k. k \\<in> atoms_of_cnf S}", "apply(rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> S; xa \\<in> x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {k\\<^sup>+ |k.\n                                   k \\<in> atoms_of_cnf S} \\<union>\n                                  {k\\<inverse> |k. k \\<in> atoms_of_cnf S}", "apply(simp add: atoms_of_cnf_alt lit_atoms_cases[abs_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> S; xa \\<in> x\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>k.\n                             xa = k\\<^sup>+ \\<and>\n                             (\\<exists>x\\<in>S.\n                                 k \\<in> (\\<lambda>x.\n       case x of xda\\<^sup>+ \\<Rightarrow> xda\n       | xea\\<inverse> \\<Rightarrow> xea) `\n   x)) \\<or>\n                         (\\<exists>k.\n                             xa = k\\<inverse> \\<and>\n                             (\\<exists>x\\<in>S.\n                                 k \\<in> (\\<lambda>x.\n       case x of xda\\<^sup>+ \\<Rightarrow> xda\n       | xea\\<inverse> \\<Rightarrow> xea) `\n   x))", "by (metis imageI literal.exhaust literal.simps(5) literal.simps(6))"], ["", "lemma atoms_res: \"atoms_of_cnf (res S) \\<subseteq>  atoms_of_cnf S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atoms_of_cnf (res S) \\<subseteq> atoms_of_cnf S", "unfolding res_def atoms_of_cnf_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     ((`) atoms_of_lit `\n      (\\<Union>C1\\<in>S.\n          \\<Union>C2\\<in>S.\n             \\<Union>L1\\<in>C1.\n                \\<Union>L2\\<in>C2.\n                   case (L1, L2) of (i\\<^sup>+, a\\<^sup>+) \\<Rightarrow> {}\n                   | (i\\<^sup>+, j\\<inverse>) \\<Rightarrow>\n                       if i = j\n                       then {C1 - {i\\<^sup>+} \\<union> (C2 - {j\\<inverse>})}\n                       else {}\n                   | (aa\\<inverse>, b) \\<Rightarrow> {}))\n    \\<subseteq> \\<Union> ((`) atoms_of_lit ` S)", "apply (clarsimp simp: lit_atoms_cases [abs_def] split: literal.splits if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb xf x2.\n       \\<lbrakk>xf \\<in> xa \\<and> xf \\<noteq> x2\\<^sup>+ \\<or>\n                xf \\<in> xb \\<and> xf \\<noteq> x2\\<inverse>;\n        xa \\<in> S; xb \\<in> S; x2\\<^sup>+ \\<in> xa;\n        x2\\<inverse> \\<in> xb\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x1.\n                             xf = x1\\<^sup>+ \\<longrightarrow>\n                             (\\<exists>x\\<in>S.\n                                 x1 \\<in> (\\<lambda>x.\n        case x of xda\\<^sup>+ \\<Rightarrow> xda\n        | xea\\<inverse> \\<Rightarrow> xea) `\n    x)) \\<and>\n                         (\\<forall>x2.\n                             xf = x2\\<inverse> \\<longrightarrow>\n                             (\\<exists>x\\<in>S.\n                                 x2 \\<in> (\\<lambda>x.\n        case x of xda\\<^sup>+ \\<Rightarrow> xda\n        | xea\\<inverse> \\<Rightarrow> xea) `\n    x))", "apply (clarsimp simp add: image_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb xf x2.\n       \\<lbrakk>xf \\<in> xa \\<and> xf \\<noteq> x2\\<^sup>+ \\<or>\n                xf \\<in> xb \\<and> xf \\<noteq> x2\\<inverse>;\n        xa \\<in> S; xb \\<in> S; x2\\<^sup>+ \\<in> xa;\n        x2\\<inverse> \\<in> xb\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x1.\n                             xf = x1\\<^sup>+ \\<longrightarrow>\n                             (\\<exists>x\\<in>S.\n                                 \\<exists>x\\<in>x.\n                                    x1 =\n                                    (case x of xda\\<^sup>+ \\<Rightarrow> xda\n                                     | xea\\<inverse> \\<Rightarrow>\n   xea))) \\<and>\n                         (\\<forall>x2.\n                             xf = x2\\<inverse> \\<longrightarrow>\n                             (\\<exists>x\\<in>S.\n                                 \\<exists>x\\<in>x.\n                                    x2 =\n                                    (case x of xda\\<^sup>+ \\<Rightarrow> xda\n                                     | xea\\<inverse> \\<Rightarrow> xea)))", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma exlitE: \"(\\<And>x. xe = Pos x \\<Longrightarrow> P x) \\<Longrightarrow> (\\<And>x. xe = Neg x \\<Longrightarrow> False) \\<Longrightarrow> \\<exists>x. xe = Pos x \\<and> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. xe = x\\<^sup>+ \\<Longrightarrow> P x;\n     \\<And>x. xe = x\\<inverse> \\<Longrightarrow> False\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. xe = x\\<^sup>+ \\<and> P x", "by(cases xe) auto"], ["", "lemma res_in_all_clauses: \"res S \\<subseteq> all_clauses S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. res S \\<subseteq> all_clauses S", "apply (clarsimp simp: res_def all_clauses_def atoms_of_cnf_alt lit_atoms_cases\n    split: literal.splits if_splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb xe x2.\n       \\<lbrakk>\\<forall>k.\n                   xe = k\\<inverse> \\<longrightarrow>\n                   (\\<forall>x\\<in>S.\n                       k \\<notin> (\\<lambda>x.\ncase x of xda\\<^sup>+ \\<Rightarrow> xda | xea\\<inverse> \\<Rightarrow> xea) `\n                                  x);\n        xa \\<in> S; xb \\<in> S; x2\\<^sup>+ \\<in> xa; x2\\<inverse> \\<in> xb;\n        xe \\<in> xa \\<and> xe \\<noteq> x2\\<^sup>+ \\<or>\n        xe \\<in> xb \\<and> xe \\<noteq> x2\\<inverse>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k.\n                            xe = k\\<^sup>+ \\<and>\n                            (\\<exists>x\\<in>S.\n                                k \\<in> (\\<lambda>x.\n      case x of xda\\<^sup>+ \\<Rightarrow> xda\n      | xea\\<inverse> \\<Rightarrow> xea) `\n  x)", "apply (clarsimp simp add: image_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa xb xe x2.\n       \\<lbrakk>\\<forall>k.\n                   xe = k\\<inverse> \\<longrightarrow>\n                   (\\<forall>x\\<in>S.\n                       \\<forall>x\\<in>x.\n                          k \\<noteq>\n                          (case x of xda\\<^sup>+ \\<Rightarrow> xda\n                           | xea\\<inverse> \\<Rightarrow> xea));\n        xa \\<in> S; xb \\<in> S; x2\\<^sup>+ \\<in> xa; x2\\<inverse> \\<in> xb;\n        xe \\<in> xa \\<and> xe \\<noteq> x2\\<^sup>+ \\<or>\n        xe \\<in> xb \\<and> xe \\<noteq> x2\\<inverse>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k.\n                            xe = k\\<^sup>+ \\<and>\n                            (\\<exists>x\\<in>S.\n                                \\<exists>x\\<in>x.\n                                   k =\n                                   (case x of xda\\<^sup>+ \\<Rightarrow> xda\n                                    | xea\\<inverse> \\<Rightarrow> xea))", "apply (metis atoms_of_lit.simps(1) atoms_of_lit.simps(2) lit_atoms_cases literal.exhaust)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Res_in_all_clauses: \"res S \\<union> S \\<subseteq> all_clauses S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. res S \\<union> S \\<subseteq> all_clauses S", "by (simp add: res_in_all_clauses s_sub_all_clauses)"], ["", "lemma all_clauses_Res_inv: \"all_clauses (res S \\<union> S) = all_clauses S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_clauses (res S \\<union> S) = all_clauses S", "unfolding all_clauses_def atoms_of_cnf_Un"], ["proof (prove)\ngoal (1 subgoal):\n 1. {s. s \\<subseteq> {k\\<^sup>+ |k.\n                       k \\<in> atoms_of_cnf (res S) \\<union>\n                               atoms_of_cnf S} \\<union>\n                      {k\\<inverse> |k.\n                       k \\<in> atoms_of_cnf (res S) \\<union>\n                               atoms_of_cnf S}} =\n    {s. s \\<subseteq> {k\\<^sup>+ |k. k \\<in> atoms_of_cnf S} \\<union>\n                      {k\\<inverse> |k. k \\<in> atoms_of_cnf S}}", "using atoms_res"], ["proof (prove)\nusing this:\n  atoms_of_cnf (res ?S) \\<subseteq> atoms_of_cnf ?S\n\ngoal (1 subgoal):\n 1. {s. s \\<subseteq> {k\\<^sup>+ |k.\n                       k \\<in> atoms_of_cnf (res S) \\<union>\n                               atoms_of_cnf S} \\<union>\n                      {k\\<inverse> |k.\n                       k \\<in> atoms_of_cnf (res S) \\<union>\n                               atoms_of_cnf S}} =\n    {s. s \\<subseteq> {k\\<^sup>+ |k. k \\<in> atoms_of_cnf S} \\<union>\n                      {k\\<inverse> |k. k \\<in> atoms_of_cnf S}}", "by fast"], ["", "lemma all_clauses_finite: \"finite S \\<and> (\\<forall>C \\<in> S. finite C) \\<Longrightarrow> finite (all_clauses S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S \\<and> (\\<forall>C\\<in>S. finite C) \\<Longrightarrow>\n    finite (all_clauses S)", "unfolding all_clauses_def atoms_of_cnf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S \\<and> (\\<forall>C\\<in>S. finite C) \\<Longrightarrow>\n    finite\n     {s. s \\<subseteq> {k\\<^sup>+ |k.\n                        k \\<in> atoms_of_lit ` \\<Union> S} \\<union>\n                       {k\\<inverse> |k. k \\<in> atoms_of_lit ` \\<Union> S}}", "by simp"], ["", "lemma finite_res: \"\\<forall>C \\<in> S. finite C \\<Longrightarrow> \\<forall>C \\<in> res S. finite C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>S. finite C \\<Longrightarrow>\n    \\<forall>C\\<in>res S. finite C", "unfolding res_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>S. finite C \\<Longrightarrow>\n    \\<forall>C\\<in>\\<Union>C1\\<in>S.\n                      \\<Union>C2\\<in>S.\n                         \\<Union>L1\\<in>C1.\n                            \\<Union>L2\\<in>C2.\n                               case (L1, L2) of\n                               (i\\<^sup>+, a\\<^sup>+) \\<Rightarrow> {}\n                               | (i\\<^sup>+, j\\<inverse>) \\<Rightarrow>\n                                   if i = j\n                                   then {C1 - {i\\<^sup>+} \\<union>\n   (C2 - {j\\<inverse>})}\n                                   else {}\n                               | (aa\\<inverse>, b) \\<Rightarrow> {}.\n       finite C", "by(clarsimp split: literal.splits)"], ["", "lemma \"finite T \\<Longrightarrow> S \\<subseteq> T \\<Longrightarrow> card S < Suc (card T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite T; S \\<subseteq> T\\<rbrakk>\n    \\<Longrightarrow> card S < Suc (card T)", "by (simp add: card_mono le_imp_less_Suc)"], ["", "lemma \"finite S \\<and> (\\<forall>C \\<in> S. finite C) \\<Longrightarrow> \\<exists>T. Rwhile S = Some T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S \\<and> (\\<forall>C\\<in>S. finite C) \\<Longrightarrow>\n    \\<exists>T. Rwhile S = Some T", "apply(unfold Rwhile_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S \\<and> (\\<forall>C\\<in>S. finite C) \\<Longrightarrow>\n    \\<exists>T.\n       while_option\n        (\\<lambda>S. \\<box> \\<notin> S \\<and> \\<not> res S \\<subseteq> S)\n        (\\<lambda>S. res S \\<union> S) S =\n       Some T", "apply(rule measure_while_option_Some[rotated, where f=\"\\<lambda>T. Suc (card (all_clauses S)) - card T\"\n        and P=\"\\<lambda>T. finite T \\<and> (\\<forall>C \\<in> T. finite C) \\<and> all_clauses T = all_clauses S\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite S \\<and> (\\<forall>C\\<in>S. finite C) \\<Longrightarrow>\n    finite S \\<and>\n    (\\<forall>C\\<in>S. finite C) \\<and> all_clauses S = all_clauses S\n 2. \\<And>s.\n       \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n        finite s \\<and>\n        (\\<forall>C\\<in>s. finite C) \\<and> all_clauses s = all_clauses S;\n        \\<box> \\<notin> s \\<and> \\<not> res s \\<subseteq> s\\<rbrakk>\n       \\<Longrightarrow> (finite (res s \\<union> s) \\<and>\n                          (\\<forall>C\\<in>res s \\<union> s. finite C) \\<and>\n                          all_clauses (res s \\<union> s) =\n                          all_clauses S) \\<and>\n                         Suc (card (all_clauses S)) -\n                         card (res s \\<union> s)\n                         < Suc (card (all_clauses S)) - card s", "apply(simp;fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n        finite s \\<and>\n        (\\<forall>C\\<in>s. finite C) \\<and> all_clauses s = all_clauses S;\n        \\<box> \\<notin> s \\<and> \\<not> res s \\<subseteq> s\\<rbrakk>\n       \\<Longrightarrow> (finite (res s \\<union> s) \\<and>\n                          (\\<forall>C\\<in>res s \\<union> s. finite C) \\<and>\n                          all_clauses (res s \\<union> s) =\n                          all_clauses S) \\<and>\n                         Suc (card (all_clauses S)) -\n                         card (res s \\<union> s)\n                         < Suc (card (all_clauses S)) - card s", "apply(intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n        finite s \\<and>\n        (\\<forall>C\\<in>s. finite C) \\<and> all_clauses s = all_clauses S;\n        \\<box> \\<notin> s \\<and> \\<not> res s \\<subseteq> s\\<rbrakk>\n       \\<Longrightarrow> finite (res s \\<union> s)\n 2. \\<And>s.\n       \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n        finite s \\<and>\n        (\\<forall>C\\<in>s. finite C) \\<and> all_clauses s = all_clauses S;\n        \\<box> \\<notin> s \\<and> \\<not> res s \\<subseteq> s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>C\\<in>res s \\<union> s. finite C\n 3. \\<And>s.\n       \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n        finite s \\<and>\n        (\\<forall>C\\<in>s. finite C) \\<and> all_clauses s = all_clauses S;\n        \\<box> \\<notin> s \\<and> \\<not> res s \\<subseteq> s\\<rbrakk>\n       \\<Longrightarrow> all_clauses (res s \\<union> s) = all_clauses S\n 4. \\<And>s.\n       \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n        finite s \\<and>\n        (\\<forall>C\\<in>s. finite C) \\<and> all_clauses s = all_clauses S;\n        \\<box> \\<notin> s \\<and> \\<not> res s \\<subseteq> s\\<rbrakk>\n       \\<Longrightarrow> Suc (card (all_clauses S)) -\n                         card (res s \\<union> s)\n                         < Suc (card (all_clauses S)) - card s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n     finite s_ \\<and>\n     (\\<forall>C\\<in>s_. finite C) \\<and> all_clauses s_ = all_clauses S;\n     \\<box> \\<notin> s_ \\<and> \\<not> res s_ \\<subseteq> s_\\<rbrakk>\n    \\<Longrightarrow> finite (res s_ \\<union> s_)", "by (meson all_clauses_finite finite_UnI finite_subset res_in_all_clauses)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n        finite s \\<and>\n        (\\<forall>C\\<in>s. finite C) \\<and> all_clauses s = all_clauses S;\n        \\<box> \\<notin> s \\<and> \\<not> res s \\<subseteq> s\\<rbrakk>\n       \\<Longrightarrow> \\<forall>C\\<in>res s \\<union> s. finite C\n 2. \\<And>s.\n       \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n        finite s \\<and>\n        (\\<forall>C\\<in>s. finite C) \\<and> all_clauses s = all_clauses S;\n        \\<box> \\<notin> s \\<and> \\<not> res s \\<subseteq> s\\<rbrakk>\n       \\<Longrightarrow> all_clauses (res s \\<union> s) = all_clauses S\n 3. \\<And>s.\n       \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n        finite s \\<and>\n        (\\<forall>C\\<in>s. finite C) \\<and> all_clauses s = all_clauses S;\n        \\<box> \\<notin> s \\<and> \\<not> res s \\<subseteq> s\\<rbrakk>\n       \\<Longrightarrow> Suc (card (all_clauses S)) -\n                         card (res s \\<union> s)\n                         < Suc (card (all_clauses S)) - card s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n     finite s_ \\<and>\n     (\\<forall>C\\<in>s_. finite C) \\<and> all_clauses s_ = all_clauses S;\n     \\<box> \\<notin> s_ \\<and> \\<not> res s_ \\<subseteq> s_\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>res s_ \\<union> s_. finite C", "using finite_res"], ["proof (prove)\nusing this:\n  \\<forall>C\\<in>?S. finite C \\<Longrightarrow>\n  \\<forall>C\\<in>res ?S. finite C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n     finite s_ \\<and>\n     (\\<forall>C\\<in>s_. finite C) \\<and> all_clauses s_ = all_clauses S;\n     \\<box> \\<notin> s_ \\<and> \\<not> res s_ \\<subseteq> s_\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>res s_ \\<union> s_. finite C", "by blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n        finite s \\<and>\n        (\\<forall>C\\<in>s. finite C) \\<and> all_clauses s = all_clauses S;\n        \\<box> \\<notin> s \\<and> \\<not> res s \\<subseteq> s\\<rbrakk>\n       \\<Longrightarrow> all_clauses (res s \\<union> s) = all_clauses S\n 2. \\<And>s.\n       \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n        finite s \\<and>\n        (\\<forall>C\\<in>s. finite C) \\<and> all_clauses s = all_clauses S;\n        \\<box> \\<notin> s \\<and> \\<not> res s \\<subseteq> s\\<rbrakk>\n       \\<Longrightarrow> Suc (card (all_clauses S)) -\n                         card (res s \\<union> s)\n                         < Suc (card (all_clauses S)) - card s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n     finite s_ \\<and>\n     (\\<forall>C\\<in>s_. finite C) \\<and> all_clauses s_ = all_clauses S;\n     \\<box> \\<notin> s_ \\<and> \\<not> res s_ \\<subseteq> s_\\<rbrakk>\n    \\<Longrightarrow> all_clauses (res s_ \\<union> s_) = all_clauses S", "using all_clauses_Res_inv"], ["proof (prove)\nusing this:\n  all_clauses (res ?S \\<union> ?S) = all_clauses ?S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n     finite s_ \\<and>\n     (\\<forall>C\\<in>s_. finite C) \\<and> all_clauses s_ = all_clauses S;\n     \\<box> \\<notin> s_ \\<and> \\<not> res s_ \\<subseteq> s_\\<rbrakk>\n    \\<Longrightarrow> all_clauses (res s_ \\<union> s_) = all_clauses S", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n        finite s \\<and>\n        (\\<forall>C\\<in>s. finite C) \\<and> all_clauses s = all_clauses S;\n        \\<box> \\<notin> s \\<and> \\<not> res s \\<subseteq> s\\<rbrakk>\n       \\<Longrightarrow> Suc (card (all_clauses S)) -\n                         card (res s \\<union> s)\n                         < Suc (card (all_clauses S)) - card s", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n     finite s_ \\<and>\n     (\\<forall>C\\<in>s_. finite C) \\<and> all_clauses s_ = all_clauses S;\n     \\<box> \\<notin> s_ \\<and> \\<not> res s_ \\<subseteq> s_\\<rbrakk>\n    \\<Longrightarrow> Suc (card (all_clauses S)) - card (res s_ \\<union> s_)\n                      < Suc (card (all_clauses S)) - card s_", "apply(rule diff_less_mono2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n     finite s_ \\<and>\n     (\\<forall>C\\<in>s_. finite C) \\<and> all_clauses s_ = all_clauses S;\n     \\<box> \\<notin> s_ \\<and> \\<not> res s_ \\<subseteq> s_\\<rbrakk>\n    \\<Longrightarrow> card s_ < card (res s_ \\<union> s_)\n 2. \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n     finite s_ \\<and>\n     (\\<forall>C\\<in>s_. finite C) \\<and> all_clauses s_ = all_clauses S;\n     \\<box> \\<notin> s_ \\<and> \\<not> res s_ \\<subseteq> s_\\<rbrakk>\n    \\<Longrightarrow> card s_ < Suc (card (all_clauses S))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n     finite s_ \\<and>\n     (\\<forall>C\\<in>s_. finite C) \\<and> all_clauses s_ = all_clauses S;\n     \\<box> \\<notin> s_ \\<and> \\<not> res s_ \\<subseteq> s_\\<rbrakk>\n    \\<Longrightarrow> card s_ < card (res s_ \\<union> s_)", "by (metis Res_in_all_clauses all_clauses_finite card_seteq finite_subset not_le sup_commute sup_ge2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n     finite s_ \\<and>\n     (\\<forall>C\\<in>s_. finite C) \\<and> all_clauses s_ = all_clauses S;\n     \\<box> \\<notin> s_ \\<and> \\<not> res s_ \\<subseteq> s_\\<rbrakk>\n    \\<Longrightarrow> card s_ < Suc (card (all_clauses S))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n     finite s_ \\<and>\n     (\\<forall>C\\<in>s_. finite C) \\<and> all_clauses s_ = all_clauses S;\n     \\<box> \\<notin> s_ \\<and> \\<not> res s_ \\<subseteq> s_\\<rbrakk>\n    \\<Longrightarrow> card s_ < Suc (card (all_clauses S))", "apply(intro card_mono le_imp_less_Suc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n     finite s_ \\<and>\n     (\\<forall>C\\<in>s_. finite C) \\<and> all_clauses s_ = all_clauses S;\n     \\<box> \\<notin> s_ \\<and> \\<not> res s_ \\<subseteq> s_\\<rbrakk>\n    \\<Longrightarrow> finite (all_clauses S)\n 2. \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n     finite s_ \\<and>\n     (\\<forall>C\\<in>s_. finite C) \\<and> all_clauses s_ = all_clauses S;\n     \\<box> \\<notin> s_ \\<and> \\<not> res s_ \\<subseteq> s_\\<rbrakk>\n    \\<Longrightarrow> s_ \\<subseteq> all_clauses S", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n     finite s_ \\<and>\n     (\\<forall>C\\<in>s_. finite C) \\<and> all_clauses s_ = all_clauses S;\n     \\<box> \\<notin> s_ \\<and> \\<not> res s_ \\<subseteq> s_\\<rbrakk>\n    \\<Longrightarrow> finite (all_clauses S)", "using all_clauses_finite"], ["proof (prove)\nusing this:\n  finite ?S \\<and> (\\<forall>C\\<in>?S. finite C) \\<Longrightarrow>\n  finite (all_clauses ?S)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n     finite s_ \\<and>\n     (\\<forall>C\\<in>s_. finite C) \\<and> all_clauses s_ = all_clauses S;\n     \\<box> \\<notin> s_ \\<and> \\<not> res s_ \\<subseteq> s_\\<rbrakk>\n    \\<Longrightarrow> finite (all_clauses S)", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n     finite s_ \\<and>\n     (\\<forall>C\\<in>s_. finite C) \\<and> all_clauses s_ = all_clauses S;\n     \\<box> \\<notin> s_ \\<and> \\<not> res s_ \\<subseteq> s_\\<rbrakk>\n    \\<Longrightarrow> s_ \\<subseteq> all_clauses S", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n     finite s_ \\<and>\n     (\\<forall>C\\<in>s_. finite C) \\<and> all_clauses s_ = all_clauses S;\n     \\<box> \\<notin> s_ \\<and> \\<not> res s_ \\<subseteq> s_\\<rbrakk>\n    \\<Longrightarrow> s_ \\<subseteq> all_clauses S", "using s_sub_all_clauses"], ["proof (prove)\nusing this:\n  ?S \\<subseteq> all_clauses ?S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S \\<and> (\\<forall>C\\<in>S. finite C);\n     finite s_ \\<and>\n     (\\<forall>C\\<in>s_. finite C) \\<and> all_clauses s_ = all_clauses S;\n     \\<box> \\<notin> s_ \\<and> \\<not> res s_ \\<subseteq> s_\\<rbrakk>\n    \\<Longrightarrow> s_ \\<subseteq> all_clauses S", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "partial_function(option) Res where\n\"Res S = (let R = res S \\<union> S in if R = S then Some S else Res R)\""], ["", "declare Res.simps[code]"], ["", "value [code] \"Res ex1\""], ["", "lemma \"\\<box> \\<in> the (Res ex1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<box> \\<in> the (Res ex1)", "by code_simp"], ["", "lemma res: \"C \\<in> res S \\<Longrightarrow> S \\<turnstile> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<in> res S \\<Longrightarrow> S \\<turnstile> C", "unfolding res_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<in> (\\<Union>C1\\<in>S.\n                \\<Union>C2\\<in>S.\n                   \\<Union>L1\\<in>C1.\n                      \\<Union>L2\\<in>C2.\n                         case (L1, L2) of\n                         (i\\<^sup>+, a\\<^sup>+) \\<Rightarrow> {}\n                         | (i\\<^sup>+, j\\<inverse>) \\<Rightarrow>\n                             if i = j\n                             then {C1 - {i\\<^sup>+} \\<union>\n                                   (C2 - {j\\<inverse>})}\n                             else {}\n                         | (aa\\<inverse>, b) \\<Rightarrow>\n                             {}) \\<Longrightarrow>\n    S \\<turnstile> C", "by(auto split: literal.splits if_splits) (metis Resolution.simps literal.exhaust)"], ["", "lemma Res_sound: \"Res S = Some S' \\<Longrightarrow> (\\<forall>C \\<in> S'. S \\<turnstile> C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Res S = Some S' \\<Longrightarrow> \\<forall>C\\<in>S'. S \\<turnstile> C", "proof (induction arbitrary: S S' rule: Res.fixp_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. option.admissible\n     (\\<lambda>Res.\n         \\<forall>x xa.\n            Res x = Some xa \\<longrightarrow> Ball xa (Resolution x))\n 2. \\<And>S S'. None = Some S' \\<Longrightarrow> Ball S' (Resolution S)\n 3. \\<And>S Sa S'.\n       \\<lbrakk>\\<And>Sa S'.\n                   S Sa = Some S' \\<Longrightarrow> Ball S' (Resolution Sa);\n        (let R = res Sa \\<union> Sa in if R = Sa then Some Sa else S R) =\n        Some S'\\<rbrakk>\n       \\<Longrightarrow> Ball S' (Resolution Sa)", "fix X S S'"], ["proof (state)\ngoal (3 subgoals):\n 1. option.admissible\n     (\\<lambda>Res.\n         \\<forall>x xa.\n            Res x = Some xa \\<longrightarrow> Ball xa (Resolution x))\n 2. \\<And>S S'. None = Some S' \\<Longrightarrow> Ball S' (Resolution S)\n 3. \\<And>S Sa S'.\n       \\<lbrakk>\\<And>Sa S'.\n                   S Sa = Some S' \\<Longrightarrow> Ball S' (Resolution Sa);\n        (let R = res Sa \\<union> Sa in if R = Sa then Some Sa else S R) =\n        Some S'\\<rbrakk>\n       \\<Longrightarrow> Ball S' (Resolution Sa)", "assume IH: \"\\<And>S S'. X S = Some S' \\<Longrightarrow> (\\<forall>C\\<in>S'. S \\<turnstile> C)\""], ["proof (state)\nthis:\n  X ?S = Some ?S' \\<Longrightarrow> \\<forall>C\\<in>?S'. ?S \\<turnstile> C\n\ngoal (3 subgoals):\n 1. option.admissible\n     (\\<lambda>Res.\n         \\<forall>x xa.\n            Res x = Some xa \\<longrightarrow> Ball xa (Resolution x))\n 2. \\<And>S S'. None = Some S' \\<Longrightarrow> Ball S' (Resolution S)\n 3. \\<And>S Sa S'.\n       \\<lbrakk>\\<And>Sa S'.\n                   S Sa = Some S' \\<Longrightarrow> Ball S' (Resolution Sa);\n        (let R = res Sa \\<union> Sa in if R = Sa then Some Sa else S R) =\n        Some S'\\<rbrakk>\n       \\<Longrightarrow> Ball S' (Resolution Sa)", "assume prem: \"(let R = res S \\<union> S in if R = S then Some S else X R) = Some S'\""], ["proof (state)\nthis:\n  (let R = res S \\<union> S in if R = S then Some S else X R) = Some S'\n\ngoal (3 subgoals):\n 1. option.admissible\n     (\\<lambda>Res.\n         \\<forall>x xa.\n            Res x = Some xa \\<longrightarrow> Ball xa (Resolution x))\n 2. \\<And>S S'. None = Some S' \\<Longrightarrow> Ball S' (Resolution S)\n 3. \\<And>S Sa S'.\n       \\<lbrakk>\\<And>Sa S'.\n                   S Sa = Some S' \\<Longrightarrow> Ball S' (Resolution Sa);\n        (let R = res Sa \\<union> Sa in if R = Sa then Some Sa else S R) =\n        Some S'\\<rbrakk>\n       \\<Longrightarrow> Ball S' (Resolution Sa)", "thus \"(\\<forall>C\\<in>S'. S \\<turnstile> C)\""], ["proof (prove)\nusing this:\n  (let R = res S \\<union> S in if R = S then Some S else X R) = Some S'\n\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>S'. S \\<turnstile> C", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(let R = res S \\<union> S in if R = S then Some S else X R) =\n             Some S';\n     ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>S'. S \\<turnstile> C\n 2. \\<lbrakk>(let R = res S \\<union> S in if R = S then Some S else X R) =\n             Some S';\n     \\<not> ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>S'. S \\<turnstile> C", "assume \"res S \\<union> S = S\""], ["proof (state)\nthis:\n  res S \\<union> S = S\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(let R = res S \\<union> S in if R = S then Some S else X R) =\n             Some S';\n     ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>S'. S \\<turnstile> C\n 2. \\<lbrakk>(let R = res S \\<union> S in if R = S then Some S else X R) =\n             Some S';\n     \\<not> ?P1\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>S'. S \\<turnstile> C", "with prem"], ["proof (chain)\npicking this:\n  (let R = res S \\<union> S in if R = S then Some S else X R) = Some S'\n  res S \\<union> S = S", "show ?thesis"], ["proof (prove)\nusing this:\n  (let R = res S \\<union> S in if R = S then Some S else X R) = Some S'\n  res S \\<union> S = S\n\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>S'. S \\<turnstile> C", "by (simp add: Resolution.Ass)"], ["proof (state)\nthis:\n  \\<forall>C\\<in>S'. S \\<turnstile> C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(let R = res S \\<union> S in if R = S then Some S else X R) =\n             Some S';\n     res S \\<union> S \\<noteq> S\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>S'. S \\<turnstile> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(let R = res S \\<union> S in if R = S then Some S else X R) =\n             Some S';\n     res S \\<union> S \\<noteq> S\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>S'. S \\<turnstile> C", "assume 1: \"res S \\<union> S \\<noteq> S\""], ["proof (state)\nthis:\n  res S \\<union> S \\<noteq> S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(let R = res S \\<union> S in if R = S then Some S else X R) =\n             Some S';\n     res S \\<union> S \\<noteq> S\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>S'. S \\<turnstile> C", "with prem"], ["proof (chain)\npicking this:\n  (let R = res S \\<union> S in if R = S then Some S else X R) = Some S'\n  res S \\<union> S \\<noteq> S", "have \"X (res S \\<union> S) = Some S'\""], ["proof (prove)\nusing this:\n  (let R = res S \\<union> S in if R = S then Some S else X R) = Some S'\n  res S \\<union> S \\<noteq> S\n\ngoal (1 subgoal):\n 1. X (res S \\<union> S) = Some S'", "by simp"], ["proof (state)\nthis:\n  X (res S \\<union> S) = Some S'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(let R = res S \\<union> S in if R = S then Some S else X R) =\n             Some S';\n     res S \\<union> S \\<noteq> S\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>S'. S \\<turnstile> C", "with IH"], ["proof (chain)\npicking this:\n  X ?S = Some ?S' \\<Longrightarrow> \\<forall>C\\<in>?S'. ?S \\<turnstile> C\n  X (res S \\<union> S) = Some S'", "have \"\\<forall>C\\<in>S'. res S \\<union> S \\<turnstile> C\""], ["proof (prove)\nusing this:\n  X ?S = Some ?S' \\<Longrightarrow> \\<forall>C\\<in>?S'. ?S \\<turnstile> C\n  X (res S \\<union> S) = Some S'\n\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>S'. res S \\<union> S \\<turnstile> C", "by blast"], ["proof (state)\nthis:\n  \\<forall>C\\<in>S'. res S \\<union> S \\<turnstile> C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(let R = res S \\<union> S in if R = S then Some S else X R) =\n             Some S';\n     res S \\<union> S \\<noteq> S\\<rbrakk>\n    \\<Longrightarrow> \\<forall>C\\<in>S'. S \\<turnstile> C", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>C\\<in>S'. res S \\<union> S \\<turnstile> C\n\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>S'. S \\<turnstile> C", "using Resolution_unnecessary res"], ["proof (prove)\nusing this:\n  \\<forall>C\\<in>S'. res S \\<union> S \\<turnstile> C\n  \\<forall>C\\<in>?T. ?S \\<turnstile> C \\<Longrightarrow>\n  (?T \\<union> ?S \\<turnstile> ?D) = (?S \\<turnstile> ?D)\n  ?C \\<in> res ?S \\<Longrightarrow> ?S \\<turnstile> ?C\n\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>S'. S \\<turnstile> C", "by blast"], ["proof (state)\nthis:\n  \\<forall>C\\<in>S'. S \\<turnstile> C\n\ngoal:\nNo subgoals!", "(* this needs the generalized Resolution_unnecessary lemma. And I don't get why the option-variant didn't. *)"], ["proof (state)\nthis:\n  \\<forall>C\\<in>S'. S \\<turnstile> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>C\\<in>S'. S \\<turnstile> C\n\ngoal (2 subgoals):\n 1. option.admissible\n     (\\<lambda>Res.\n         \\<forall>x xa.\n            Res x = Some xa \\<longrightarrow> Ball xa (Resolution x))\n 2. \\<And>S S'. None = Some S' \\<Longrightarrow> Ball S' (Resolution S)", "qed (fast intro!: option_admissible)+"], ["", "lemma Res_terminates: \"finite S \\<Longrightarrow> \\<forall>C \\<in> S. finite C \\<Longrightarrow> \\<exists>T. Res S = Some T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite S; \\<forall>C\\<in>S. finite C\\<rbrakk>\n    \\<Longrightarrow> \\<exists>T. Res S = Some T", "proof(induction \"card (all_clauses S) - card S\" arbitrary: S rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>\\<And>Sa.\n                   \\<lbrakk>card (all_clauses Sa) - card Sa\n                            < card (all_clauses S) - card S;\n                    finite Sa; Ball Sa finite\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>T. Res Sa = Some T;\n        finite S; Ball S finite\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T. Res S = Some T", "(* can be done by induction on \"card (all_clauses S - S)\", but I found that to be more annoying. *)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>\\<And>Sa.\n                   \\<lbrakk>card (all_clauses Sa) - card Sa\n                            < card (all_clauses S) - card S;\n                    finite Sa; Ball Sa finite\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>T. Res Sa = Some T;\n        finite S; Ball S finite\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T. Res S = Some T", "case less"], ["proof (state)\nthis:\n  \\<lbrakk>card (all_clauses ?S) - card ?S < card (all_clauses S) - card S;\n   finite ?S; Ball ?S finite\\<rbrakk>\n  \\<Longrightarrow> \\<exists>T. Res ?S = Some T\n  finite S\n  Ball S finite\n\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>\\<And>Sa.\n                   \\<lbrakk>card (all_clauses Sa) - card Sa\n                            < card (all_clauses S) - card S;\n                    finite Sa; Ball Sa finite\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>T. Res Sa = Some T;\n        finite S; Ball S finite\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T. Res S = Some T", "let ?r = \"res S \\<union> S\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>\\<And>Sa.\n                   \\<lbrakk>card (all_clauses Sa) - card Sa\n                            < card (all_clauses S) - card S;\n                    finite Sa; Ball Sa finite\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>T. Res Sa = Some T;\n        finite S; Ball S finite\\<rbrakk>\n       \\<Longrightarrow> \\<exists>T. Res S = Some T", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T. Res S = Some T", "proof(cases \"?r = S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. res S \\<union> S = S \\<Longrightarrow> \\<exists>T. Res S = Some T\n 2. res S \\<union> S \\<noteq> S \\<Longrightarrow> \\<exists>T. Res S = Some T", "case False"], ["proof (state)\nthis:\n  res S \\<union> S \\<noteq> S\n\ngoal (2 subgoals):\n 1. res S \\<union> S = S \\<Longrightarrow> \\<exists>T. Res S = Some T\n 2. res S \\<union> S \\<noteq> S \\<Longrightarrow> \\<exists>T. Res S = Some T", "have b: \"finite (res S \\<union> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (res S \\<union> S)", "by (meson less Res_in_all_clauses all_clauses_finite infinite_super)"], ["proof (state)\nthis:\n  finite (res S \\<union> S)\n\ngoal (2 subgoals):\n 1. res S \\<union> S = S \\<Longrightarrow> \\<exists>T. Res S = Some T\n 2. res S \\<union> S \\<noteq> S \\<Longrightarrow> \\<exists>T. Res S = Some T", "have c: \"Ball (res S \\<union> S) finite\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (res S \\<union> S) finite", "using less.prems(2) finite_res"], ["proof (prove)\nusing this:\n  Ball S finite\n  \\<forall>C\\<in>?S. finite C \\<Longrightarrow>\n  \\<forall>C\\<in>res ?S. finite C\n\ngoal (1 subgoal):\n 1. Ball (res S \\<union> S) finite", "by auto"], ["proof (state)\nthis:\n  Ball (res S \\<union> S) finite\n\ngoal (2 subgoals):\n 1. res S \\<union> S = S \\<Longrightarrow> \\<exists>T. Res S = Some T\n 2. res S \\<union> S \\<noteq> S \\<Longrightarrow> \\<exists>T. Res S = Some T", "have \"card S < card ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card S < card (res S \\<union> S)", "by (metis False b psubsetI psubset_card_mono sup_ge2)"], ["proof (state)\nthis:\n  card S < card (res S \\<union> S)\n\ngoal (2 subgoals):\n 1. res S \\<union> S = S \\<Longrightarrow> \\<exists>T. Res S = Some T\n 2. res S \\<union> S \\<noteq> S \\<Longrightarrow> \\<exists>T. Res S = Some T", "moreover"], ["proof (state)\nthis:\n  card S < card (res S \\<union> S)\n\ngoal (2 subgoals):\n 1. res S \\<union> S = S \\<Longrightarrow> \\<exists>T. Res S = Some T\n 2. res S \\<union> S \\<noteq> S \\<Longrightarrow> \\<exists>T. Res S = Some T", "have \"card ?r \\<le> (card (all_clauses S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (res S \\<union> S) \\<le> card (all_clauses S)", "by (meson less Res_in_all_clauses all_clauses_finite card_mono le_imp_less_Suc)"], ["proof (state)\nthis:\n  card (res S \\<union> S) \\<le> card (all_clauses S)\n\ngoal (2 subgoals):\n 1. res S \\<union> S = S \\<Longrightarrow> \\<exists>T. Res S = Some T\n 2. res S \\<union> S \\<noteq> S \\<Longrightarrow> \\<exists>T. Res S = Some T", "ultimately"], ["proof (chain)\npicking this:\n  card S < card (res S \\<union> S)\n  card (res S \\<union> S) \\<le> card (all_clauses S)", "have a: \"(card (all_clauses ?r)) - card ?r < (card (all_clauses S)) - card S\""], ["proof (prove)\nusing this:\n  card S < card (res S \\<union> S)\n  card (res S \\<union> S) \\<le> card (all_clauses S)\n\ngoal (1 subgoal):\n 1. card (all_clauses (res S \\<union> S)) - card (res S \\<union> S)\n    < card (all_clauses S) - card S", "using all_clauses_Res_inv[of S]"], ["proof (prove)\nusing this:\n  card S < card (res S \\<union> S)\n  card (res S \\<union> S) \\<le> card (all_clauses S)\n  all_clauses (res S \\<union> S) = all_clauses S\n\ngoal (1 subgoal):\n 1. card (all_clauses (res S \\<union> S)) - card (res S \\<union> S)\n    < card (all_clauses S) - card S", "by simp"], ["proof (state)\nthis:\n  card (all_clauses (res S \\<union> S)) - card (res S \\<union> S)\n  < card (all_clauses S) - card S\n\ngoal (2 subgoals):\n 1. res S \\<union> S = S \\<Longrightarrow> \\<exists>T. Res S = Some T\n 2. res S \\<union> S \\<noteq> S \\<Longrightarrow> \\<exists>T. Res S = Some T", "from less(1)[OF a b c]"], ["proof (chain)\npicking this:\n  \\<exists>T. Res (res S \\<union> S) = Some T", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>T. Res (res S \\<union> S) = Some T\n\ngoal (1 subgoal):\n 1. \\<exists>T. Res S = Some T", "by (subst Res.simps) (simp add: Let_def)"], ["proof (state)\nthis:\n  \\<exists>T. Res S = Some T\n\ngoal (1 subgoal):\n 1. res S \\<union> S = S \\<Longrightarrow> \\<exists>T. Res S = Some T", "qed (simp add: Res.simps)"], ["proof (state)\nthis:\n  \\<exists>T. Res S = Some T\n\ngoal:\nNo subgoals!", "qed"], ["", "(* just to demonstrate, this would not work: *)"], ["", "code_pred (*(modes: i \\<Rightarrow> i \\<Rightarrow> bool)*) Resolution"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "(* can't infer any modes. *)"], ["", "print_theorems"], ["", "(* doesn't generate any theorems either. *)"], ["", "end"], ["", "end"]]}