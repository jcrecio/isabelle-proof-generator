{"file_name": "/home/qj213/afp-2021-10-22/thys/Propositional_Proof_Systems/SC_Depth_Limit.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Propositional_Proof_Systems", "problem_names": ["lemma SC_completeness: \"\\<Turnstile> \\<Gamma> \\<Rightarrow> \\<Delta> \\<Longrightarrow> \\<Gamma> \\<Rightarrow> \\<Delta> \\<down> sequent_cost \\<Gamma> \\<Delta>\"", "lemma sc_sim_depth:\n  assumes \"sc \\<Gamma> A \\<Delta> B = {}\"\n  shows \"image_mset Atom (mset A) + mset \\<Gamma> \\<Rightarrow> image_mset Atom (mset B) + mset \\<Delta> \\<down> sum_list (map size (\\<Gamma>@\\<Delta>)) + (if set A \\<inter> set B = {} then 0 else 1)\""], "translations": [["", "lemma SC_completeness: \"\\<Turnstile> \\<Gamma> \\<Rightarrow> \\<Delta> \\<Longrightarrow> \\<Gamma> \\<Rightarrow> \\<Delta> \\<down> sequent_cost \\<Gamma> \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Turnstile> \\<Gamma> \\<Rightarrow> \\<Delta> \\<Longrightarrow>\n    \\<Gamma> \\<Rightarrow> \\<Delta> \\<down> sequent_cost \\<Gamma> \\<Delta>", "proof(induction \"sequent_cost \\<Gamma> \\<Delta>\" arbitrary: \\<Gamma> \\<Delta>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> \\<Delta>.\n       \\<lbrakk>0 = sequent_cost \\<Gamma> \\<Delta>;\n        \\<Turnstile> \\<Gamma> \\<Rightarrow> \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<Rightarrow>\n                         \\<Delta> \\<down> sequent_cost \\<Gamma> \\<Delta>\n 2. \\<And>x \\<Gamma> \\<Delta>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Delta>.\n                   \\<lbrakk>x = sequent_cost \\<Gamma> \\<Delta>;\n                    \\<Turnstile> \\<Gamma> \\<Rightarrow> \\<Delta>\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<Rightarrow>\n                                     \\<Delta> \\<down> sequent_cost \\<Gamma>\n                 \\<Delta>;\n        Suc x = sequent_cost \\<Gamma> \\<Delta>;\n        \\<Turnstile> \\<Gamma> \\<Rightarrow> \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<Rightarrow>\n                         \\<Delta> \\<down> sequent_cost \\<Gamma> \\<Delta>", "case 0"], ["proof (state)\nthis:\n  0 = sequent_cost \\<Gamma> \\<Delta>\n  \\<Turnstile> \\<Gamma> \\<Rightarrow> \\<Delta>\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> \\<Delta>.\n       \\<lbrakk>0 = sequent_cost \\<Gamma> \\<Delta>;\n        \\<Turnstile> \\<Gamma> \\<Rightarrow> \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<Rightarrow>\n                         \\<Delta> \\<down> sequent_cost \\<Gamma> \\<Delta>\n 2. \\<And>x \\<Gamma> \\<Delta>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Delta>.\n                   \\<lbrakk>x = sequent_cost \\<Gamma> \\<Delta>;\n                    \\<Turnstile> \\<Gamma> \\<Rightarrow> \\<Delta>\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<Rightarrow>\n                                     \\<Delta> \\<down> sequent_cost \\<Gamma>\n                 \\<Delta>;\n        Suc x = sequent_cost \\<Gamma> \\<Delta>;\n        \\<Turnstile> \\<Gamma> \\<Rightarrow> \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<Rightarrow>\n                         \\<Delta> \\<down> sequent_cost \\<Gamma> \\<Delta>", "hence False"], ["proof (prove)\nusing this:\n  0 = sequent_cost \\<Gamma> \\<Delta>\n  \\<Turnstile> \\<Gamma> \\<Rightarrow> \\<Delta>\n\ngoal (1 subgoal):\n 1. False", "by(simp add: sequent_cost_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma> \\<Delta>.\n       \\<lbrakk>0 = sequent_cost \\<Gamma> \\<Delta>;\n        \\<Turnstile> \\<Gamma> \\<Rightarrow> \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<Rightarrow>\n                         \\<Delta> \\<down> sequent_cost \\<Gamma> \\<Delta>\n 2. \\<And>x \\<Gamma> \\<Delta>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Delta>.\n                   \\<lbrakk>x = sequent_cost \\<Gamma> \\<Delta>;\n                    \\<Turnstile> \\<Gamma> \\<Rightarrow> \\<Delta>\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<Rightarrow>\n                                     \\<Delta> \\<down> sequent_cost \\<Gamma>\n                 \\<Delta>;\n        Suc x = sequent_cost \\<Gamma> \\<Delta>;\n        \\<Turnstile> \\<Gamma> \\<Rightarrow> \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<Rightarrow>\n                         \\<Delta> \\<down> sequent_cost \\<Gamma> \\<Delta>", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<Gamma> \\<Rightarrow> \\<Delta> \\<down> sequent_cost \\<Gamma> \\<Delta>", "by clarify"], ["proof (state)\nthis:\n  \\<Gamma> \\<Rightarrow> \\<Delta> \\<down> sequent_cost \\<Gamma> \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<And>x \\<Gamma> \\<Delta>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Delta>.\n                   \\<lbrakk>x = sequent_cost \\<Gamma> \\<Delta>;\n                    \\<Turnstile> \\<Gamma> \\<Rightarrow> \\<Delta>\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<Rightarrow>\n                                     \\<Delta> \\<down> sequent_cost \\<Gamma>\n                 \\<Delta>;\n        Suc x = sequent_cost \\<Gamma> \\<Delta>;\n        \\<Turnstile> \\<Gamma> \\<Rightarrow> \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<Rightarrow>\n                         \\<Delta> \\<down> sequent_cost \\<Gamma> \\<Delta>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x \\<Gamma> \\<Delta>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Delta>.\n                   \\<lbrakk>x = sequent_cost \\<Gamma> \\<Delta>;\n                    \\<Turnstile> \\<Gamma> \\<Rightarrow> \\<Delta>\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<Rightarrow>\n                                     \\<Delta> \\<down> sequent_cost \\<Gamma>\n                 \\<Delta>;\n        Suc x = sequent_cost \\<Gamma> \\<Delta>;\n        \\<Turnstile> \\<Gamma> \\<Rightarrow> \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<Rightarrow>\n                         \\<Delta> \\<down> sequent_cost \\<Gamma> \\<Delta>", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>n = sequent_cost ?\\<Gamma> ?\\<Delta>;\n   \\<Turnstile> ?\\<Gamma> \\<Rightarrow> ?\\<Delta>\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma> \\<Rightarrow>\n                    ?\\<Delta> \\<down> sequent_cost ?\\<Gamma> ?\\<Delta>\n  Suc n = sequent_cost \\<Gamma> \\<Delta>\n  \\<Turnstile> \\<Gamma> \\<Rightarrow> \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<And>x \\<Gamma> \\<Delta>.\n       \\<lbrakk>\\<And>\\<Gamma> \\<Delta>.\n                   \\<lbrakk>x = sequent_cost \\<Gamma> \\<Delta>;\n                    \\<Turnstile> \\<Gamma> \\<Rightarrow> \\<Delta>\\<rbrakk>\n                   \\<Longrightarrow> \\<Gamma> \\<Rightarrow>\n                                     \\<Delta> \\<down> sequent_cost \\<Gamma>\n                 \\<Delta>;\n        Suc x = sequent_cost \\<Gamma> \\<Delta>;\n        \\<Turnstile> \\<Gamma> \\<Rightarrow> \\<Delta>\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma> \\<Rightarrow>\n                         \\<Delta> \\<down> sequent_cost \\<Gamma> \\<Delta>", "from Suc(3)"], ["proof (chain)\npicking this:\n  \\<Turnstile> \\<Gamma> \\<Rightarrow> \\<Delta>", "show ?case"], ["proof (prove)\nusing this:\n  \\<Turnstile> \\<Gamma> \\<Rightarrow> \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<Gamma> \\<Rightarrow> \\<Delta> \\<down> sequent_cost \\<Gamma> \\<Delta>", "using SCc.cases[OF Suc.hyps(1)]"], ["proof (prove)\nusing this:\n  \\<Turnstile> \\<Gamma> \\<Rightarrow> \\<Delta>\n  \\<lbrakk>n = sequent_cost ?a1.0 ?a2.0;\n   \\<Turnstile> ?a1.0 \\<Rightarrow> ?a2.0;\n   \\<And>\\<Gamma> \\<Delta> n.\n      \\<lbrakk>?a1.0 = \\<Gamma>; ?a2.0 = \\<Delta>;\n       sequent_cost ?a1.0 ?a2.0 = Suc n; \\<bottom> \\<in># \\<Gamma>\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>k \\<Gamma> \\<Delta> n.\n      \\<lbrakk>?a1.0 = \\<Gamma>; ?a2.0 = \\<Delta>;\n       sequent_cost ?a1.0 ?a2.0 = Suc n; Atom k \\<in># \\<Gamma>;\n       Atom k \\<in># \\<Delta>\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>\\<Gamma> F \\<Delta> n.\n      \\<lbrakk>?a1.0 = \\<^bold>\\<not> F, \\<Gamma>; ?a2.0 = \\<Delta>;\n       sequent_cost ?a1.0 ?a2.0 = Suc n;\n       \\<Gamma> \\<Rightarrow> F, \\<Delta> \\<down> n\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>F \\<Gamma> \\<Delta> n.\n      \\<lbrakk>?a1.0 = \\<Gamma>; ?a2.0 = \\<^bold>\\<not> F, \\<Delta>;\n       sequent_cost ?a1.0 ?a2.0 = Suc n;\n       F, \\<Gamma> \\<Rightarrow> \\<Delta> \\<down> n\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>F G \\<Gamma> \\<Delta> n.\n      \\<lbrakk>?a1.0 = F \\<^bold>\\<and> G, \\<Gamma>; ?a2.0 = \\<Delta>;\n       sequent_cost ?a1.0 ?a2.0 = Suc n;\n       F, G, \\<Gamma> \\<Rightarrow> \\<Delta> \\<down> n\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>\\<Gamma> F \\<Delta> n G.\n      \\<lbrakk>?a1.0 = \\<Gamma>; ?a2.0 = F \\<^bold>\\<and> G, \\<Delta>;\n       sequent_cost ?a1.0 ?a2.0 = Suc n;\n       \\<Gamma> \\<Rightarrow> F, \\<Delta> \\<down> n;\n       \\<Gamma> \\<Rightarrow> G, \\<Delta> \\<down> n\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>F \\<Gamma> \\<Delta> n G.\n      \\<lbrakk>?a1.0 = F \\<^bold>\\<or> G, \\<Gamma>; ?a2.0 = \\<Delta>;\n       sequent_cost ?a1.0 ?a2.0 = Suc n;\n       F, \\<Gamma> \\<Rightarrow> \\<Delta> \\<down> n;\n       G, \\<Gamma> \\<Rightarrow> \\<Delta> \\<down> n\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>\\<Gamma> F G \\<Delta> n.\n      \\<lbrakk>?a1.0 = \\<Gamma>; ?a2.0 = F \\<^bold>\\<or> G, \\<Delta>;\n       sequent_cost ?a1.0 ?a2.0 = Suc n;\n       \\<Gamma> \\<Rightarrow> F, G, \\<Delta> \\<down> n\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>\\<Gamma> F \\<Delta> n G.\n      \\<lbrakk>?a1.0 = F \\<^bold>\\<rightarrow> G, \\<Gamma>;\n       ?a2.0 = \\<Delta>; sequent_cost ?a1.0 ?a2.0 = Suc n;\n       \\<Gamma> \\<Rightarrow> F, \\<Delta> \\<down> n;\n       G, \\<Gamma> \\<Rightarrow> \\<Delta> \\<down> n\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>F \\<Gamma> G \\<Delta> n.\n      \\<lbrakk>?a1.0 = \\<Gamma>;\n       ?a2.0 = F \\<^bold>\\<rightarrow> G, \\<Delta>;\n       sequent_cost ?a1.0 ?a2.0 = Suc n;\n       F, \\<Gamma> \\<Rightarrow> G, \\<Delta> \\<down> n\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<Gamma> \\<Rightarrow> \\<Delta> \\<down> sequent_cost \\<Gamma> \\<Delta>", "oops"], ["", "text\\<open>Making this proof of completeness go through should be possible,\n  but finding the right way to split the cases could get verbose.\nThe variant with the search procedure is a lot more elegant.\\<close>"], ["", "lemma sc_sim_depth:\n  assumes \"sc \\<Gamma> A \\<Delta> B = {}\"\n  shows \"image_mset Atom (mset A) + mset \\<Gamma> \\<Rightarrow> image_mset Atom (mset B) + mset \\<Delta> \\<down> sum_list (map size (\\<Gamma>@\\<Delta>)) + (if set A \\<inter> set B = {} then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset Atom (mset A) + mset \\<Gamma> \\<Rightarrow>\n    image_mset Atom (mset B) +\n    mset\n     \\<Delta> \\<down> sum_list (map size (\\<Gamma> @ \\<Delta>)) +\n                      (if set A \\<inter> set B = {} then 0 else 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. image_mset Atom (mset A) + mset \\<Gamma> \\<Rightarrow>\n    image_mset Atom (mset B) +\n    mset\n     \\<Delta> \\<down> sum_list (map size (\\<Gamma> @ \\<Delta>)) +\n                      (if set A \\<inter> set B = {} then 0 else 1)", "have [simp]: \"image_mset Atom (mset A) \\<Rightarrow> image_mset Atom (mset B) \\<down> Suc 0\" (is ?k) if \"set A \\<inter> set B \\<noteq> {}\" for A B"], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset Atom (mset A) \\<Rightarrow>\n    image_mset Atom (mset B) \\<down> Suc 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. image_mset Atom (mset A) \\<Rightarrow>\n    image_mset Atom (mset B) \\<down> Suc 0", "from that"], ["proof (chain)\npicking this:\n  set A \\<inter> set B \\<noteq> {}", "obtain a where \"a \\<in> set A\" \"a \\<in> set B\""], ["proof (prove)\nusing this:\n  set A \\<inter> set B \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> set A; a \\<in> set B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a \\<in> set A\n  a \\<in> set B\n\ngoal (1 subgoal):\n 1. image_mset Atom (mset A) \\<Rightarrow>\n    image_mset Atom (mset B) \\<down> Suc 0", "thus ?k"], ["proof (prove)\nusing this:\n  a \\<in> set A\n  a \\<in> set B\n\ngoal (1 subgoal):\n 1. image_mset Atom (mset A) \\<Rightarrow>\n    image_mset Atom (mset B) \\<down> Suc 0", "by(force simp: in_image_mset intro: SCc.Ax[where k=a])"], ["proof (state)\nthis:\n  image_mset Atom (mset A) \\<Rightarrow>\n  image_mset Atom (mset B) \\<down> Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set ?A1 \\<inter> set ?B1 \\<noteq> {} \\<Longrightarrow>\n  image_mset Atom (mset ?A1) \\<Rightarrow>\n  image_mset Atom (mset ?B1) \\<down> Suc 0\n\ngoal (1 subgoal):\n 1. image_mset Atom (mset A) + mset \\<Gamma> \\<Rightarrow>\n    image_mset Atom (mset B) +\n    mset\n     \\<Delta> \\<down> sum_list (map size (\\<Gamma> @ \\<Delta>)) +\n                      (if set A \\<inter> set B = {} then 0 else 1)", "note SCc.intros(3-)[intro]"], ["proof (state)\nthis:\n  ?\\<Gamma> \\<Rightarrow> ?F, ?\\<Delta> \\<down> ?n \\<Longrightarrow>\n  \\<^bold>\\<not> ?F, ?\\<Gamma> \\<Rightarrow> ?\\<Delta> \\<down> Suc ?n\n  ?F, ?\\<Gamma> \\<Rightarrow> ?\\<Delta> \\<down> ?n \\<Longrightarrow>\n  ?\\<Gamma> \\<Rightarrow> \\<^bold>\\<not> ?F, ?\\<Delta> \\<down> Suc ?n\n  ?F, ?G, ?\\<Gamma> \\<Rightarrow> ?\\<Delta> \\<down> ?n \\<Longrightarrow>\n  ?F \\<^bold>\\<and> ?G, ?\\<Gamma> \\<Rightarrow> ?\\<Delta> \\<down> Suc ?n\n  \\<lbrakk>?\\<Gamma> \\<Rightarrow> ?F, ?\\<Delta> \\<down> ?n;\n   ?\\<Gamma> \\<Rightarrow> ?G, ?\\<Delta> \\<down> ?n\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma> \\<Rightarrow>\n                    ?F \\<^bold>\\<and> ?G, ?\\<Delta> \\<down> Suc ?n\n  \\<lbrakk>?F, ?\\<Gamma> \\<Rightarrow> ?\\<Delta> \\<down> ?n;\n   ?G, ?\\<Gamma> \\<Rightarrow> ?\\<Delta> \\<down> ?n\\<rbrakk>\n  \\<Longrightarrow> ?F \\<^bold>\\<or> ?G, ?\\<Gamma> \\<Rightarrow>\n                    ?\\<Delta> \\<down> Suc ?n\n  ?\\<Gamma> \\<Rightarrow> ?F, ?G, ?\\<Delta> \\<down> ?n \\<Longrightarrow>\n  ?\\<Gamma> \\<Rightarrow> ?F \\<^bold>\\<or> ?G, ?\\<Delta> \\<down> Suc ?n\n  \\<lbrakk>?\\<Gamma> \\<Rightarrow> ?F, ?\\<Delta> \\<down> ?n;\n   ?G, ?\\<Gamma> \\<Rightarrow> ?\\<Delta> \\<down> ?n\\<rbrakk>\n  \\<Longrightarrow> ?F \\<^bold>\\<rightarrow> ?G, ?\\<Gamma> \\<Rightarrow>\n                    ?\\<Delta> \\<down> Suc ?n\n  ?F, ?\\<Gamma> \\<Rightarrow> ?G, ?\\<Delta> \\<down> ?n \\<Longrightarrow>\n  ?\\<Gamma> \\<Rightarrow>\n  ?F \\<^bold>\\<rightarrow> ?G, ?\\<Delta> \\<down> Suc ?n\n\ngoal (1 subgoal):\n 1. image_mset Atom (mset A) + mset \\<Gamma> \\<Rightarrow>\n    image_mset Atom (mset B) +\n    mset\n     \\<Delta> \\<down> sum_list (map size (\\<Gamma> @ \\<Delta>)) +\n                      (if set A \\<inter> set B = {} then 0 else 1)", "have [elim!]: \"\\<Gamma> \\<Rightarrow> \\<Delta> \\<down> n \\<Longrightarrow> n \\<le> m \\<Longrightarrow> \\<Gamma> \\<Rightarrow> \\<Delta> \\<down> m\" for \\<Gamma> \\<Delta> n m"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> \\<Rightarrow> \\<Delta> \\<down> n; n \\<le> m\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<Rightarrow> \\<Delta> \\<down> m", "using dec_induct"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<le> ?j; ?P ?i;\n   \\<And>n.\n      \\<lbrakk>?i \\<le> n; n < ?j; ?P n\\<rbrakk>\n      \\<Longrightarrow> ?P (Suc n)\\<rbrakk>\n  \\<Longrightarrow> ?P ?j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> \\<Rightarrow> \\<Delta> \\<down> n; n \\<le> m\\<rbrakk>\n    \\<Longrightarrow> \\<Gamma> \\<Rightarrow> \\<Delta> \\<down> m", "by(fastforce elim!: deeper_suc)"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<Gamma>2 \\<Rightarrow> ?\\<Delta>2 \\<down> ?n2;\n   ?n2 \\<le> ?m2\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma>2 \\<Rightarrow> ?\\<Delta>2 \\<down> ?m2\n\ngoal (1 subgoal):\n 1. image_mset Atom (mset A) + mset \\<Gamma> \\<Rightarrow>\n    image_mset Atom (mset B) +\n    mset\n     \\<Delta> \\<down> sum_list (map size (\\<Gamma> @ \\<Delta>)) +\n                      (if set A \\<inter> set B = {} then 0 else 1)", "(* sledgehammer is flippin' using induction. *)"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<Gamma>2 \\<Rightarrow> ?\\<Delta>2 \\<down> ?n2;\n   ?n2 \\<le> ?m2\\<rbrakk>\n  \\<Longrightarrow> ?\\<Gamma>2 \\<Rightarrow> ?\\<Delta>2 \\<down> ?m2\n\ngoal (1 subgoal):\n 1. image_mset Atom (mset A) + mset \\<Gamma> \\<Rightarrow>\n    image_mset Atom (mset B) +\n    mset\n     \\<Delta> \\<down> sum_list (map size (\\<Gamma> @ \\<Delta>)) +\n                      (if set A \\<inter> set B = {} then 0 else 1)", "from assms"], ["proof (chain)\npicking this:\n  sc \\<Gamma> A \\<Delta> B = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  sc \\<Gamma> A \\<Delta> B = {}\n\ngoal (1 subgoal):\n 1. image_mset Atom (mset A) + mset \\<Gamma> \\<Rightarrow>\n    image_mset Atom (mset B) +\n    mset\n     \\<Delta> \\<down> sum_list (map size (\\<Gamma> @ \\<Delta>)) +\n                      (if set A \\<inter> set B = {} then 0 else 1)", "by(induction \\<Gamma> A \\<Delta> B rule: sc.induct)\n      (auto\n      simp add: list_sequent_cost_def add.assoc deeper_suc weakenR'\n      split: if_splits option.splits)"], ["proof (state)\nthis:\n  image_mset Atom (mset A) + mset \\<Gamma> \\<Rightarrow>\n  image_mset Atom (mset B) +\n  mset\n   \\<Delta> \\<down> sum_list (map size (\\<Gamma> @ \\<Delta>)) +\n                    (if set A \\<inter> set B = {} then 0 else 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary sc_depth_complete:\n  assumes s: \"\\<Turnstile> \\<Gamma> \\<Rightarrow> \\<Delta>\"\n  shows \"\\<Gamma> \\<Rightarrow> \\<Delta> \\<down> sum_mset (image_mset size (\\<Gamma>+\\<Delta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<Rightarrow>\n    \\<Delta> \\<down> \\<Sum>\\<^sub># (image_mset size (\\<Gamma> + \\<Delta>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<Rightarrow>\n    \\<Delta> \\<down> \\<Sum>\\<^sub># (image_mset size (\\<Gamma> + \\<Delta>))", "obtain \\<Gamma>' \\<Delta>' where p: \"\\<Gamma> = mset \\<Gamma>'\" \"\\<Delta> = mset \\<Delta>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' \\<Delta>'.\n        \\<lbrakk>\\<Gamma> = mset \\<Gamma>';\n         \\<Delta> = mset \\<Delta>'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis ex_mset)"], ["proof (state)\nthis:\n  \\<Gamma> = mset \\<Gamma>'\n  \\<Delta> = mset \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<Gamma> \\<Rightarrow>\n    \\<Delta> \\<down> \\<Sum>\\<^sub># (image_mset size (\\<Gamma> + \\<Delta>))", "with s"], ["proof (chain)\npicking this:\n  \\<Turnstile> \\<Gamma> \\<Rightarrow> \\<Delta>\n  \\<Gamma> = mset \\<Gamma>'\n  \\<Delta> = mset \\<Delta>'", "have sl: \"\\<Turnstile> mset \\<Gamma>' \\<Rightarrow> mset \\<Delta>'\""], ["proof (prove)\nusing this:\n  \\<Turnstile> \\<Gamma> \\<Rightarrow> \\<Delta>\n  \\<Gamma> = mset \\<Gamma>'\n  \\<Delta> = mset \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<Turnstile> mset \\<Gamma>' \\<Rightarrow> mset \\<Delta>'", "by simp"], ["proof (state)\nthis:\n  \\<Turnstile> mset \\<Gamma>' \\<Rightarrow> mset \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<Gamma> \\<Rightarrow>\n    \\<Delta> \\<down> \\<Sum>\\<^sub># (image_mset size (\\<Gamma> + \\<Delta>))", "let ?d = \"sum_mset (image_mset size (\\<Gamma>+\\<Delta>))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma> \\<Rightarrow>\n    \\<Delta> \\<down> \\<Sum>\\<^sub># (image_mset size (\\<Gamma> + \\<Delta>))", "have d: \"?d = sum_list (map size (\\<Gamma>'@\\<Delta>'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset size (\\<Gamma> + \\<Delta>)) =\n    sum_list (map size (\\<Gamma>' @ \\<Delta>'))", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset size (mset \\<Gamma>' + mset \\<Delta>')) =\n    sum_list (map size (\\<Gamma>' @ \\<Delta>'))", "by (metis mset_append mset_map sum_mset_sum_list)"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (image_mset size (\\<Gamma> + \\<Delta>)) =\n  sum_list (map size (\\<Gamma>' @ \\<Delta>'))\n\ngoal (1 subgoal):\n 1. \\<Gamma> \\<Rightarrow>\n    \\<Delta> \\<down> \\<Sum>\\<^sub># (image_mset size (\\<Gamma> + \\<Delta>))", "have \"mset \\<Gamma>' \\<Rightarrow> mset \\<Delta>' \\<down> ?d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset \\<Gamma>' \\<Rightarrow>\n    mset\n     \\<Delta>' \\<down> \\<Sum>\\<^sub>#\n                        (image_mset size (\\<Gamma> + \\<Delta>))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    mset \\<Gamma>' \\<Rightarrow>\n    mset\n     \\<Delta>' \\<down> \\<Sum>\\<^sub>#\n                        (image_mset size (\\<Gamma> + \\<Delta>))\n 2. \\<not> ?P \\<Longrightarrow>\n    mset \\<Gamma>' \\<Rightarrow>\n    mset\n     \\<Delta>' \\<down> \\<Sum>\\<^sub>#\n                        (image_mset size (\\<Gamma> + \\<Delta>))", "assume \"sc \\<Gamma>' [] \\<Delta>' [] = {}\""], ["proof (state)\nthis:\n  sc \\<Gamma>' [] \\<Delta>' [] = {}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    mset \\<Gamma>' \\<Rightarrow>\n    mset\n     \\<Delta>' \\<down> \\<Sum>\\<^sub>#\n                        (image_mset size (\\<Gamma> + \\<Delta>))\n 2. \\<not> ?P \\<Longrightarrow>\n    mset \\<Gamma>' \\<Rightarrow>\n    mset\n     \\<Delta>' \\<down> \\<Sum>\\<^sub>#\n                        (image_mset size (\\<Gamma> + \\<Delta>))", "from sc_sim_depth[OF this]"], ["proof (chain)\npicking this:\n  image_mset Atom (mset []) + mset \\<Gamma>' \\<Rightarrow>\n  image_mset Atom (mset []) +\n  mset\n   \\<Delta>' \\<down> sum_list (map size (\\<Gamma>' @ \\<Delta>')) +\n                     (if set [] \\<inter> set [] = {} then 0 else 1)", "show \"mset \\<Gamma>' \\<Rightarrow> mset \\<Delta>' \\<down> ?d\""], ["proof (prove)\nusing this:\n  image_mset Atom (mset []) + mset \\<Gamma>' \\<Rightarrow>\n  image_mset Atom (mset []) +\n  mset\n   \\<Delta>' \\<down> sum_list (map size (\\<Gamma>' @ \\<Delta>')) +\n                     (if set [] \\<inter> set [] = {} then 0 else 1)\n\ngoal (1 subgoal):\n 1. mset \\<Gamma>' \\<Rightarrow>\n    mset\n     \\<Delta>' \\<down> \\<Sum>\\<^sub>#\n                        (image_mset size (\\<Gamma> + \\<Delta>))", "unfolding d"], ["proof (prove)\nusing this:\n  image_mset Atom (mset []) + mset \\<Gamma>' \\<Rightarrow>\n  image_mset Atom (mset []) +\n  mset\n   \\<Delta>' \\<down> sum_list (map size (\\<Gamma>' @ \\<Delta>')) +\n                     (if set [] \\<inter> set [] = {} then 0 else 1)\n\ngoal (1 subgoal):\n 1. mset \\<Gamma>' \\<Rightarrow>\n    mset \\<Delta>' \\<down> sum_list (map size (\\<Gamma>' @ \\<Delta>'))", "by auto"], ["proof (state)\nthis:\n  mset \\<Gamma>' \\<Rightarrow>\n  mset\n   \\<Delta>' \\<down> \\<Sum>\\<^sub># (image_mset size (\\<Gamma> + \\<Delta>))\n\ngoal (1 subgoal):\n 1. sc \\<Gamma>' [] \\<Delta>' [] \\<noteq> {} \\<Longrightarrow>\n    mset \\<Gamma>' \\<Rightarrow>\n    mset\n     \\<Delta>' \\<down> \\<Sum>\\<^sub>#\n                        (image_mset size (\\<Gamma> + \\<Delta>))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sc \\<Gamma>' [] \\<Delta>' [] \\<noteq> {} \\<Longrightarrow>\n    mset \\<Gamma>' \\<Rightarrow>\n    mset\n     \\<Delta>' \\<down> \\<Sum>\\<^sub>#\n                        (image_mset size (\\<Gamma> + \\<Delta>))", "assume \"sc \\<Gamma>' [] \\<Delta>' [] \\<noteq> {}\""], ["proof (state)\nthis:\n  sc \\<Gamma>' [] \\<Delta>' [] \\<noteq> {}\n\ngoal (1 subgoal):\n 1. sc \\<Gamma>' [] \\<Delta>' [] \\<noteq> {} \\<Longrightarrow>\n    mset \\<Gamma>' \\<Rightarrow>\n    mset\n     \\<Delta>' \\<down> \\<Sum>\\<^sub>#\n                        (image_mset size (\\<Gamma> + \\<Delta>))", "with SC_counterexample"], ["proof (chain)\npicking this:\n  (?C, ?D) \\<in> sc ?\\<Gamma> ?A ?\\<Delta> ?B \\<Longrightarrow>\n  (\\<lambda>a.\n      a \\<in> set ?C) \\<not>\\<Turnstile> image_mset Atom (mset ?A) +\n   mset ?\\<Gamma> \\<Rightarrow>\n   image_mset Atom (mset ?B) + mset ?\\<Delta>\n  sc \\<Gamma>' [] \\<Delta>' [] \\<noteq> {}", "have \"\\<not> \\<Turnstile> mset \\<Gamma>' \\<Rightarrow> mset \\<Delta>'\""], ["proof (prove)\nusing this:\n  (?C, ?D) \\<in> sc ?\\<Gamma> ?A ?\\<Delta> ?B \\<Longrightarrow>\n  (\\<lambda>a.\n      a \\<in> set ?C) \\<not>\\<Turnstile> image_mset Atom (mset ?A) +\n   mset ?\\<Gamma> \\<Rightarrow>\n   image_mset Atom (mset ?B) + mset ?\\<Delta>\n  sc \\<Gamma>' [] \\<Delta>' [] \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> \\<Turnstile> mset \\<Gamma>' \\<Rightarrow> mset \\<Delta>'", "by fastforce"], ["proof (state)\nthis:\n  \\<not> \\<Turnstile> mset \\<Gamma>' \\<Rightarrow> mset \\<Delta>'\n\ngoal (1 subgoal):\n 1. sc \\<Gamma>' [] \\<Delta>' [] \\<noteq> {} \\<Longrightarrow>\n    mset \\<Gamma>' \\<Rightarrow>\n    mset\n     \\<Delta>' \\<down> \\<Sum>\\<^sub>#\n                        (image_mset size (\\<Gamma> + \\<Delta>))", "moreover"], ["proof (state)\nthis:\n  \\<not> \\<Turnstile> mset \\<Gamma>' \\<Rightarrow> mset \\<Delta>'\n\ngoal (1 subgoal):\n 1. sc \\<Gamma>' [] \\<Delta>' [] \\<noteq> {} \\<Longrightarrow>\n    mset \\<Gamma>' \\<Rightarrow>\n    mset\n     \\<Delta>' \\<down> \\<Sum>\\<^sub>#\n                        (image_mset size (\\<Gamma> + \\<Delta>))", "note s[unfolded p]"], ["proof (state)\nthis:\n  \\<Turnstile> mset \\<Gamma>' \\<Rightarrow> mset \\<Delta>'\n\ngoal (1 subgoal):\n 1. sc \\<Gamma>' [] \\<Delta>' [] \\<noteq> {} \\<Longrightarrow>\n    mset \\<Gamma>' \\<Rightarrow>\n    mset\n     \\<Delta>' \\<down> \\<Sum>\\<^sub>#\n                        (image_mset size (\\<Gamma> + \\<Delta>))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> \\<Turnstile> mset \\<Gamma>' \\<Rightarrow> mset \\<Delta>'\n  \\<Turnstile> mset \\<Gamma>' \\<Rightarrow> mset \\<Delta>'", "have False"], ["proof (prove)\nusing this:\n  \\<not> \\<Turnstile> mset \\<Gamma>' \\<Rightarrow> mset \\<Delta>'\n  \\<Turnstile> mset \\<Gamma>' \\<Rightarrow> mset \\<Delta>'\n\ngoal (1 subgoal):\n 1. False", ".."], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. sc \\<Gamma>' [] \\<Delta>' [] \\<noteq> {} \\<Longrightarrow>\n    mset \\<Gamma>' \\<Rightarrow>\n    mset\n     \\<Delta>' \\<down> \\<Sum>\\<^sub>#\n                        (image_mset size (\\<Gamma> + \\<Delta>))", "thus \"mset \\<Gamma>' \\<Rightarrow> mset \\<Delta>' \\<down> ?d\""], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. mset \\<Gamma>' \\<Rightarrow>\n    mset\n     \\<Delta>' \\<down> \\<Sum>\\<^sub>#\n                        (image_mset size (\\<Gamma> + \\<Delta>))", ".."], ["proof (state)\nthis:\n  mset \\<Gamma>' \\<Rightarrow>\n  mset\n   \\<Delta>' \\<down> \\<Sum>\\<^sub># (image_mset size (\\<Gamma> + \\<Delta>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mset \\<Gamma>' \\<Rightarrow>\n  mset\n   \\<Delta>' \\<down> \\<Sum>\\<^sub># (image_mset size (\\<Gamma> + \\<Delta>))\n\ngoal (1 subgoal):\n 1. \\<Gamma> \\<Rightarrow>\n    \\<Delta> \\<down> \\<Sum>\\<^sub># (image_mset size (\\<Gamma> + \\<Delta>))", "thus ?thesis"], ["proof (prove)\nusing this:\n  mset \\<Gamma>' \\<Rightarrow>\n  mset\n   \\<Delta>' \\<down> \\<Sum>\\<^sub># (image_mset size (\\<Gamma> + \\<Delta>))\n\ngoal (1 subgoal):\n 1. \\<Gamma> \\<Rightarrow>\n    \\<Delta> \\<down> \\<Sum>\\<^sub># (image_mset size (\\<Gamma> + \\<Delta>))", "unfolding p"], ["proof (prove)\nusing this:\n  mset \\<Gamma>' \\<Rightarrow>\n  mset\n   \\<Delta>' \\<down> \\<Sum>\\<^sub>#\n                      (image_mset size (mset \\<Gamma>' + mset \\<Delta>'))\n\ngoal (1 subgoal):\n 1. mset \\<Gamma>' \\<Rightarrow>\n    mset\n     \\<Delta>' \\<down> \\<Sum>\\<^sub>#\n                        (image_mset size (mset \\<Gamma>' + mset \\<Delta>'))", "."], ["proof (state)\nthis:\n  \\<Gamma> \\<Rightarrow>\n  \\<Delta> \\<down> \\<Sum>\\<^sub># (image_mset size (\\<Gamma> + \\<Delta>))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}