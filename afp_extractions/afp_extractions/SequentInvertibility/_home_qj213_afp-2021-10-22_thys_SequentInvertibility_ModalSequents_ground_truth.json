{"file_name": "/home/qj213/afp-2021-10-22/thys/SequentInvertibility/ModalSequents.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/SequentInvertibility", "problem_names": ["lemma nonEmpty_contain:\nassumes \"\\<Gamma> \\<noteq> \\<Empt>\"\nshows \"\\<exists> a. a \\<in># \\<Gamma>\"", "lemma nonEmpty_neq:\nassumes \"\\<Gamma> \\<noteq> \\<Empt>\"\nshows \"\\<Gamma> + C \\<noteq> C\"", "lemma nonEmpty_image:\nassumes \"\\<Gamma> \\<noteq> \\<Empt>\"\nshows \"f \\<cdot>\\<cdot> \\<Gamma> \\<noteq> \\<Empt>\"", "lemma single_plus_obtain:\nassumes \"A \\<in># \\<Gamma>\"\nshows \"\\<exists> \\<Delta>. \\<Gamma> = \\<Delta> \\<oplus> A\"", "lemma singleton_add_means_equal:\nassumes \"\\<LM>A\\<RM> = \\<Gamma> \\<oplus> B\"\nshows \"A = B\"", "lemma singleton_add_means_empty:\nassumes \"\\<LM>A\\<RM> = \\<Gamma> \\<oplus> B\"\nshows \"\\<Gamma> = \\<Empt>\"", "lemma single_multiset_eq_non_empty:\nassumes \"\\<LM>A\\<RM> = \\<Delta> + \\<Delta>'\"\nand     \"\\<Delta> \\<noteq> \\<Empt>\"\nshows \"\\<Delta>' = \\<Empt> \\<and> \\<Delta> = \\<LM>A\\<RM>\"", "lemma two_neq_one_aux:\nassumes \"(\\<LM>A\\<RM>) \\<oplus> B = \\<LM>C\\<RM>\"\nshows \"False\"", "lemma two_neq_one:\nassumes \"((\\<LM>A\\<RM>) \\<oplus> B) + \\<Gamma> = \\<LM>C\\<RM>\"\nshows \"False\"", "lemma add_equal_means_equal:\nassumes \"\\<Gamma> \\<oplus> A = \\<Delta> \\<oplus> A\"\nshows \"\\<Gamma> = \\<Delta>\"", "lemma characteriseSeq:\nshows \"\\<exists> A B. (C :: ('a,'b) sequent) = (A \\<Rightarrow>* B)\"", "lemma extend1_to_2:\nshows \"extendRule2 S S r = extendRule S r\"", "lemma nonEmptySet:\nshows \"A \\<noteq> [] \\<longrightarrow> (\\<exists> a. a \\<in> set A)\"", "lemma extendID:\nassumes \"extend S (\\<LM> At i \\<RM> \\<Rightarrow>* \\<LM> At i \\<RM>) = (\\<Gamma> \\<Rightarrow>* \\<Delta>)\"\nshows \"At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>\"", "lemma extendFalsum:\nassumes \"extend S (\\<LM> ff \\<RM> \\<Rightarrow>* \\<Empt>) = (\\<Gamma> \\<Rightarrow>* \\<Delta>)\"\nshows \"ff \\<in># \\<Gamma>\"", "lemma containID:\nassumes a:\"At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>\"\n    and b:\"Ax \\<subseteq> R\"\nshows \"(\\<Gamma> \\<Rightarrow>* \\<Delta>,0) \\<in> derivable (ext R R' M N)\"", "lemma containFalsum:\nassumes a: \"ff \\<in># \\<Gamma>\"\n   and  b: \"Ax \\<subseteq> R\"\nshows \"(\\<Gamma> \\<Rightarrow>* \\<Delta>,0) \\<in> derivable (ext R R' M N)\"", "lemma characteriseAx:\nshows \"r \\<in> Ax \\<Longrightarrow> r = ([],\\<LM> ff \\<RM> \\<Rightarrow>* \\<Empt>) \\<or> (\\<exists> i. r = ([], \\<LM> At i \\<RM> \\<Rightarrow>* \\<LM> At i \\<RM>))\"", "lemma characteriseLast:\nassumes \"(C,m+1) \\<in> derivable R\"\nshows \"\\<exists> Ps. Ps \\<noteq> [] \\<and>\n             (Ps,C) \\<in> R \\<and> \n             (\\<forall> p \\<in> set Ps. \\<exists> n\\<le>m. (p,n) \\<in> derivable R)\"", "lemma succ_upRule:\nassumes \"(Ps,\\<Phi> \\<Rightarrow>* \\<Psi>) \\<in> upRules\"\nshows \"\\<Psi> = \\<Empt> \\<or> (\\<exists> A. \\<Psi> = \\<LM>A\\<RM>)\"", "lemma antec_upRule:\nassumes \"(Ps,\\<Phi> \\<Rightarrow>* \\<Psi>) \\<in> upRules\"\nshows \"\\<Phi> = \\<Empt> \\<or> (\\<exists> A. \\<Phi> = \\<LM>A\\<RM>)\"", "lemma upRule_Size:\nassumes \"r \\<in> upRules\"\nshows \"seq_size (snd r) = 1\"", "lemma upRuleCharacterise:\nassumes \"(Ps,C) \\<in> upRules\"\nshows \"\\<exists> F Fs. C = (\\<Empt> \\<Rightarrow>* \\<LM>Compound F Fs\\<RM>) \\<or> C = (\\<LM>Compound F Fs\\<RM> \\<Rightarrow>* \\<Empt>)\"", "lemma modRule2Characterise:\nassumes \"(Ps,C) \\<in> modRules2\"\nshows \"Ps \\<noteq> [] \\<and> (\\<exists> F Fs. C = (\\<Empt> \\<Rightarrow>* \\<LM>Modal F Fs\\<RM>) \\<or> C = (\\<LM>Modal F Fs\\<RM> \\<Rightarrow>* \\<Empt>))\"", "lemma modRule1Characterise:\nassumes \"(Ps,C) \\<in> p_e R M N\" and \"R \\<subseteq> modRules2\"\nshows \"\\<exists> F Fs \\<Gamma> \\<Delta> ps r. (Ps,C) = extendRule (M\\<cdot>\\<Gamma>\\<Rightarrow>*N\\<cdot>\\<Delta>) r \\<and> r \\<in> R \\<and> \n                    (r = (ps,\\<Empt> \\<Rightarrow>* \\<LM>Modal F Fs\\<RM>) \\<or> \n                     r = (ps,\\<LM>Modal F Fs\\<RM> \\<Rightarrow>* \\<Empt>))\"", "lemma extendEmpty:\nshows \"extend (\\<Empt> \\<Rightarrow>* \\<Empt>) C = C\"", "lemma mapExtendEmpty:\nshows \"map (extend (\\<Empt> \\<Rightarrow>* \\<Empt>)) ps = ps\"", "lemma extendRuleEmpty:\nshows \"extendRule (\\<Empt> \\<Rightarrow>* \\<Empt>) r = r\"", "lemma extendNonEmpty:\nassumes \"\\<not> (\\<Gamma> = \\<Empt> \\<and> \\<Delta> = \\<Empt>)\"\nshows \"extend (\\<Gamma> \\<Rightarrow>* \\<Delta>) C \\<noteq> C\"", "lemma extendRuleNonEmpty:\nassumes \"\\<not> (\\<Gamma> = \\<Empt> \\<and> \\<Delta> = \\<Empt>)\"\nshows \"extendRule (\\<Gamma> \\<Rightarrow>* \\<Delta>) r \\<noteq> r\"", "lemma extendRuleEmptyRev:\nassumes \"extendRule S r = r\"\nshows \"S = (\\<Empt> \\<Rightarrow>* \\<Empt>)\"", "lemma modaliseEmpty:\nshows \"a \\<cdot> (\\<Empt>) = \\<Empt>\"", "lemma modaliseNonEmpty:\nassumes \"\\<Gamma> \\<noteq> \\<Empt>\"\nshows \"a \\<cdot> \\<Gamma> \\<noteq> \\<Empt>\"", "lemma mset_extend:\nshows \"mset (extend S c) = mset S + mset c\"", "lemma mset_extend_size:\nassumes \"\\<not> (\\<Gamma> = \\<Empt> \\<and> \\<Delta> = \\<Empt>)\"\nshows \"size (mset ((extend (\\<Gamma> \\<Rightarrow>* \\<Delta>) c))) > size (mset c)\"", "lemma extendContain:\nassumes \"r = (ps,c)\"\n    and \"(Ps,C) = extendRule S r\"\n    and \"p \\<in> set ps\"\nshows \"extend S p \\<in> set Ps\"", "lemma extendCommute:\nshows \"(extend S) (extend R c) = (extend R) (extend S c)\"", "lemma mapCommute:\nshows \"map (extend S) (map (extend R) c) = map (extend R) (map (extend S) c)\"", "lemma extendAssoc:\nshows \"(extend S) (extend R c) = extend (extend S R) c\"", "lemma mapAssoc:\nshows \"map (extend S) (map (extend R) c) = map (extend (extend S R)) c\"", "lemma disjoint_Aux:\nassumes \"mset c = \\<LM>A\\<RM>\"\nshows \"A \\<in># mset (extend S c)\"", "lemma disjoint_Aux2:\nassumes \"mset c = \\<LM>A\\<RM>\"\n    and \"A \\<noteq> B\"\n    and \"mset (extend S c) = \\<LM>B\\<RM>\"\nshows \"False\"", "lemma disjoint_Ax_up:\nshows \"Ax \\<inter> upRules = {}\"", "lemma disjoint_Ax_mod2:\nshows \"Ax \\<inter> modRules2 = {}\"", "lemma disjoint_Ax_mod1:\nshows \"Ax \\<inter> p_e modRules2 M N = {}\"", "lemma disjoint_up_mod2:\nshows \"upRules \\<inter> modRules2 = {}\"", "lemma disjoint_up_mod1:\nshows \"upRules \\<inter> p_e modRules2 M N = {}\"", "lemmas disjoint = disjoint_Ax_up disjoint_Ax_mod1 disjoint_Ax_mod2 \n                  disjoint_up_mod2 disjoint_up_mod1", "lemma Ax_subset_false_aux:\nassumes \"A \\<subseteq> B\" and \"A \\<inter> B = {}\" and \"A \\<noteq> {}\"\nshows \"False\"", "lemma Ax_subset_false:\nassumes \"Ax \\<subseteq> modRules2\"\nshows \"False\"", "lemma modal_not_contain:\nassumes \"M \\<noteq> N\"\nshows \"\\<not> (Modal M A \\<in># N\\<cdot>\\<Gamma>)\"", "lemma nonPrincipalID:\nfixes A :: \"('a,'b) form\"\nassumes \"r \\<in> Ax\"\nshows \"\\<not> rightPrincipal r A R \\<and> \\<not> leftPrincipal r A R\"", "lemma compound_not_in_modal_multi:\nshows \"\\<not> (Compound M Ms \\<in># N\\<cdot>\\<Gamma>)\"", "lemma not_principal_aux:\nassumes \"mset c = \\<LM>Modal T Ts\\<RM>\"\n    and \"M\\<cdot>\\<Gamma> + succ c = N\\<cdot>\\<Delta> \\<oplus> Compound F Fs\"\nshows \"False\"", "lemma not_principal_aux2:\nassumes \"mset c = \\<LM>Modal T Ts\\<RM>\"\n    and \"M\\<cdot>\\<Gamma> + antec c = N\\<cdot>\\<Delta> \\<oplus> Compound F Fs\"\nshows \"False\"", "lemma modRules_not_right_principal_for_compound:\nassumes \"r \\<in> p_e modRules2 S T\"\nshows \"\\<not> rightPrincipal r (Compound M Ms) R\"", "lemma modRules_not_left_principal_for_compound:\nassumes \"r \\<in> p_e modRules2 T S\"\nshows \"\\<not> leftPrincipal r (Compound M Ms) R\"", "lemma modRules2_not_left_principal_for_compound:\nassumes \"r \\<in> modRules2\"\nshows \"\\<not> leftPrincipal r (Compound M Ms) R\"", "lemma modRules2_not_right_principal_for_compound:\nassumes \"r \\<in> modRules2\"\nshows \"\\<not> rightPrincipal r (Compound M Ms) R\"", "lemma upRules_not_right_principal_for_modal:\nassumes \"r \\<in> upRules\"\n  shows \"\\<not> rightPrincipal r (Modal M Ms) R\"", "lemma upRules_not_left_principal_for_modal:\nassumes \"r \\<in> upRules\"\nshows \"\\<not> leftPrincipal r (Modal M Ms) R\"", "lemmas nonPrincipalRight = upRules_not_right_principal_for_modal\n                           modRules_not_right_principal_for_compound\n                           modRules2_not_right_principal_for_compound", "lemmas nonPrincipalLeft = upRules_not_left_principal_for_modal\n                          modRules_not_left_principal_for_compound\n                          modRules2_not_left_principal_for_compound", "lemma modalise_characterise:\nfixes A :: \"('a,'b) form\"\nand   M :: \"'b\"\nand  \\<Delta>  :: \"('a,'b) form multiset\"\nassumes \"A \\<in># M\\<cdot>\\<Delta>\"\nshows \"\\<exists> B. A = Modal M [B]\"", "lemma non_contain:\nfixes \\<Delta> \\<Delta>' :: \"('a,'b) form multiset\"\nassumes \"\\<Delta> \\<noteq> \\<Empt>\" and \"\\<Delta>' \\<noteq> \\<Empt>\" and \"M \\<noteq> N\"\nshows \"set_mset (M\\<cdot>\\<Delta>) \\<inter> set_mset (N\\<cdot>\\<Delta>') = {}\"", "lemma modal_neq:\nfixes A :: \"('a,'b) form\" and ps :: \"('a,'b) form list\"\nshows \"A \\<noteq> Modal M [A]\" and \"ps \\<noteq> [Modal M ps]\"", "lemma p_e_non_empty: \n \"r \\<in> p_e R M N \\<Longrightarrow> fst r \\<noteq> []\"", "lemma dpWeak:\nassumes a:\"(\\<Gamma> \\<Rightarrow>* \\<Delta>,n) \\<in> derivable (ext R R2 M N)\"\n   and  b: \"R1 \\<subseteq> upRules\"\n   and  c: \"R2 \\<subseteq> modRules2\"\n   and  d: \"R3 \\<subseteq> modRules2\"\n   and  e: \"R = Ax \\<union> R1 \\<union> (p_e R2 M N) \\<union> R3\" \nshows \"(\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',n) \\<in> derivable (ext R R2 M N)\"", "lemma nonPrincipalInvertRight:\nassumes \"R1 \\<subseteq> upRules\" and \"R2 \\<subseteq> modRules2\" and \"R3 \\<subseteq> modRules2\"\n    and \"R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3\" and \"r \\<in> R\" and \"r = (ps,c)\"\n    and \"R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\"\n    and IH: \"\\<forall>m<n. \\<forall>\\<Gamma> \\<Delta>. ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, m) \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n              (\\<forall>r' \\<in> R'. rightPrincipal r' (Modal M Ms) R' \\<longrightarrow> ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')) \\<longrightarrow>              \n              (\\<exists>m'\\<le>m. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m') \\<in> derivable (ext R R2 M1 M2))\"\n    and a': \"(\\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms,n) \\<in> derivable (ext R R2 M1 M2)\" \n    and b': \"\\<forall> r' \\<in> R'. rightPrincipal r' (Modal M Ms) R' \\<longrightarrow> (\\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\"\n    and np: \"\\<not> rightPrincipal r (Modal M Ms) R'\"\n    and ext: \"(r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and> extendRule S r = (Ps, \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\"\n    and num: \"n = n' + 1\"\n    and all: \"\\<forall> p \\<in> set Ps. \\<exists> n\\<le>n'. (p,n) \\<in> derivable (ext R R2 M1 M2)\"\n    and nonempty: \"Ps \\<noteq> []\"  \nshows \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\"", "lemma nonPrincipalInvertLeft:\nassumes \"R1 \\<subseteq> upRules\" and \"R2 \\<subseteq> modRules2\" and \"R3 \\<subseteq> modRules2\"\n    and \"R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3\" and \"r \\<in> R\" and \"r = (ps,c)\" and \"R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\"\n    and IH: \"\\<forall>m<n. \\<forall>\\<Gamma> \\<Delta>. ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, m) \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n              (\\<forall>r' \\<in> R'. leftPrincipal r' (Modal M Ms) R' \\<longrightarrow> ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')) \\<longrightarrow>\n              (\\<exists>m'\\<le>m. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m') \\<in> derivable (ext R R2 M1 M2) )\"\n    and a': \"(\\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>,n) \\<in> derivable (ext R R2 M1 M2)\" \n    and b': \"\\<forall> r' \\<in> R'. leftPrincipal r' (Modal M Ms) R' \\<longrightarrow> (\\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\"\n    and np: \"\\<not> leftPrincipal r (Modal M Ms) R'\"\n    and ext: \"((r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and> extendRule S r = (Ps, \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>))\"\n    and num: \"n = n' + 1\"\n    and all: \"\\<forall> p \\<in> set Ps. \\<exists> n\\<le>n'. (p,n) \\<in> derivable (ext R R2 M1 M2)\"\n    and nonempty: \"Ps \\<noteq> []\"  \nshows \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\"", "lemma rightInvert:\nfixes \\<Gamma> \\<Delta> :: \"('a,'b) form multiset\"\nassumes rules: \"R1 \\<subseteq> upRules \\<and> R2 \\<subseteq> modRules2 \\<and> R3 \\<subseteq> modRules2 \\<and> \n                R = Ax \\<union> R1 \\<union> (p_e R2 M1 M2) \\<union> R3 \\<and>\n                R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\"\n    and   a: \"(\\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms,n) \\<in> derivable (ext R R2 M1 M2)\"\n    and   b: \"\\<forall> r' \\<in> R'. rightPrincipal r' (Modal M Ms) R' \\<longrightarrow> \n                         (\\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\"\n    and  neq: \"M2 \\<noteq> M\"\nshows \"\\<exists> m\\<le>n. (\\<Gamma> +\\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\"", "lemma leftInvert:\nfixes \\<Gamma> \\<Delta> :: \"('a,'b) form multiset\"\nassumes rules: \"R1 \\<subseteq> upRules \\<and> R2 \\<subseteq> modRules2 \\<and> R3 \\<subseteq> modRules2 \\<and> R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and> R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\"\n    and   a: \"(\\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>,n) \\<in> derivable (ext R R2 M1 M2)\"\n    and   b: \"\\<forall> r' \\<in> R'. leftPrincipal r' (Modal M Ms) R' \\<longrightarrow> (\\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\"\n    and neq: \"M1 \\<noteq> M\"\nshows \"\\<exists> m\\<le>n. (\\<Gamma> +\\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\"", "lemma g3up_upRules:\nshows \"g3up \\<subseteq> upRules\"", "lemma g3mod2_modRules2:\nshows \"g3mod2 \\<subseteq> modRules2\"", "lemma g3mod1_modRules2:\nshows \"g3mod1 \\<subseteq> modRules2\"", "lemmas g3 = g3up_upRules g3mod1_modRules2 g3mod2_modRules2", "lemma principal_Ax:\nshows \"\\<lbrakk> r \\<in> Ax ; rightPrincipal r (\\<box> A) R \\<rbrakk> \\<Longrightarrow> (\\<Empt> \\<Rightarrow>* \\<LM>A\\<RM>) \\<in> set (fst r)\"", "lemma principal_g3up:\nshows \"\\<lbrakk> r \\<in> g3up ; rightPrincipal r (\\<box> A) R \\<rbrakk> \\<Longrightarrow> (\\<Empt> \\<Rightarrow>* \\<LM>A\\<RM>) \\<in> set (fst r)\"", "lemma principal_g3mod2:\nassumes \"r \\<in> g3mod2\"\nand \"R = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2\"\nand \"rightPrincipal r (\\<box> A) R\"\nshows \"(\\<Empt> \\<Rightarrow>* \\<LM>A\\<RM>) \\<in> set (fst r)\"", "lemma principal_g3mod1:\nassumes \"r \\<in> g3mod1\"\nand \"R = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2\"\nand \"rightPrincipal r (\\<box> A) R\"\nshows \"(\\<Empt> \\<Rightarrow>* \\<LM>A\\<RM>) \\<in> set (fst r)\"", "lemma principal:\nassumes \"R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2\"\nshows \"\\<forall> r \\<in> R'. rightPrincipal r (\\<box> A) R' \\<longrightarrow> (\\<Empt> \\<Rightarrow>* \\<LM>A\\<RM>) \\<in> set (fst r)\"", "lemma invertBoxR:\nassumes \"R = Ax \\<union> g3up \\<union> (p_e g3mod1 \\<box> \\<diamond>) \\<union> g3mod2\"\nand     \"(\\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> (\\<box> A),n) \\<in> derivable (ext R g3mod1 \\<box> \\<diamond>)\"\nshows   \"\\<exists> m\\<le>n. (\\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> A,m) \\<in> derivable (ext R g3mod1 \\<box> \\<diamond>)\""], "translations": [["", "lemma nonEmpty_contain:\nassumes \"\\<Gamma> \\<noteq> \\<Empt>\"\nshows \"\\<exists> a. a \\<in># \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. a \\<in># \\<Gamma>", "using assms"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<noteq> \\<Empt>\n\ngoal (1 subgoal):\n 1. \\<exists>a. a \\<in># \\<Gamma>", "by (induct \\<Gamma>) auto"], ["", "lemma nonEmpty_neq:\nassumes \"\\<Gamma> \\<noteq> \\<Empt>\"\nshows \"\\<Gamma> + C \\<noteq> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> + C \\<noteq> C", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma> + C \\<noteq> C", "from assms and nonEmpty_contain"], ["proof (chain)\npicking this:\n  \\<Gamma> \\<noteq> \\<Empt>\n  ?\\<Gamma> \\<noteq> \\<Empt> \\<Longrightarrow>\n  \\<exists>a. a \\<in># ?\\<Gamma>", "obtain a where \"a \\<in># \\<Gamma>\""], ["proof (prove)\nusing this:\n  \\<Gamma> \\<noteq> \\<Empt>\n  ?\\<Gamma> \\<noteq> \\<Empt> \\<Longrightarrow>\n  \\<exists>a. a \\<in># ?\\<Gamma>\n\ngoal (1 subgoal):\n 1. (\\<And>a. a \\<in># \\<Gamma> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a \\<in># \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<Gamma> + C \\<noteq> C", "then"], ["proof (chain)\npicking this:\n  a \\<in># \\<Gamma>", "have \"count \\<Gamma> a \\<ge> 1\""], ["proof (prove)\nusing this:\n  a \\<in># \\<Gamma>\n\ngoal (1 subgoal):\n 1. 1 \\<le> count \\<Gamma> a", "by (simp add: Suc_le_eq)"], ["proof (state)\nthis:\n  1 \\<le> count \\<Gamma> a\n\ngoal (1 subgoal):\n 1. \\<Gamma> + C \\<noteq> C", "then"], ["proof (chain)\npicking this:\n  1 \\<le> count \\<Gamma> a", "have \"count (\\<Gamma> + C) a \\<noteq> count C a\""], ["proof (prove)\nusing this:\n  1 \\<le> count \\<Gamma> a\n\ngoal (1 subgoal):\n 1. count (\\<Gamma> + C) a \\<noteq> count C a", "by auto"], ["proof (state)\nthis:\n  count (\\<Gamma> + C) a \\<noteq> count C a\n\ngoal (1 subgoal):\n 1. \\<Gamma> + C \\<noteq> C", "then"], ["proof (chain)\npicking this:\n  count (\\<Gamma> + C) a \\<noteq> count C a", "show \"\\<Gamma> + C \\<noteq> C\""], ["proof (prove)\nusing this:\n  count (\\<Gamma> + C) a \\<noteq> count C a\n\ngoal (1 subgoal):\n 1. \\<Gamma> + C \\<noteq> C", "by (auto simp add:multiset_eq_iff)"], ["proof (state)\nthis:\n  \\<Gamma> + C \\<noteq> C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nonEmpty_image:\nassumes \"\\<Gamma> \\<noteq> \\<Empt>\"\nshows \"f \\<cdot>\\<cdot> \\<Gamma> \\<noteq> \\<Empt>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<cdot>\\<cdot> \\<Gamma> \\<noteq> \\<Empt>", "using image_mset_is_empty_iff assms"], ["proof (prove)\nusing this:\n  (image_mset ?f ?M = \\<Empt>) = (?M = \\<Empt>)\n  \\<Gamma> \\<noteq> \\<Empt>\n\ngoal (1 subgoal):\n 1. f \\<cdot>\\<cdot> \\<Gamma> \\<noteq> \\<Empt>", "by auto"], ["", "lemma single_plus_obtain:\nassumes \"A \\<in># \\<Gamma>\"\nshows \"\\<exists> \\<Delta>. \\<Gamma> = \\<Delta> \\<oplus> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<Delta>. \\<Gamma> = \\<Delta> \\<oplus> A", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<Delta>. \\<Gamma> = \\<Delta> \\<oplus> A", "from assms"], ["proof (chain)\npicking this:\n  A \\<in># \\<Gamma>", "have \"\\<Gamma> = \\<Gamma> \\<ominus> A \\<oplus> A\""], ["proof (prove)\nusing this:\n  A \\<in># \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<Gamma> = \\<Gamma> \\<ominus> A \\<oplus> A", "by (auto simp add:multiset_eq_iff)"], ["proof (state)\nthis:\n  \\<Gamma> = \\<Gamma> \\<ominus> A \\<oplus> A\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Delta>. \\<Gamma> = \\<Delta> \\<oplus> A", "then"], ["proof (chain)\npicking this:\n  \\<Gamma> = \\<Gamma> \\<ominus> A \\<oplus> A", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Gamma> = \\<Gamma> \\<ominus> A \\<oplus> A\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Delta>. \\<Gamma> = \\<Delta> \\<oplus> A", "by (rule_tac x=\"\\<Gamma>\\<ominus>A\" in exI) simp"], ["proof (state)\nthis:\n  \\<exists>\\<Delta>. \\<Gamma> = \\<Delta> \\<oplus> A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma singleton_add_means_equal:\nassumes \"\\<LM>A\\<RM> = \\<Gamma> \\<oplus> B\"\nshows \"A = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = B", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. A = B", "from assms"], ["proof (chain)\npicking this:\n  \\<LM> A  \\<RM> = \\<Gamma> \\<oplus> B", "have \"size (\\<LM>A\\<RM>) = size (\\<Gamma> \\<oplus> B)\""], ["proof (prove)\nusing this:\n  \\<LM> A  \\<RM> = \\<Gamma> \\<oplus> B\n\ngoal (1 subgoal):\n 1. size (\\<LM> A  \\<RM>) = size (\\<Gamma> \\<oplus> B)", "by auto"], ["proof (state)\nthis:\n  size (\\<LM> A  \\<RM>) = size (\\<Gamma> \\<oplus> B)\n\ngoal (1 subgoal):\n 1. A = B", "then"], ["proof (chain)\npicking this:\n  size (\\<LM> A  \\<RM>) = size (\\<Gamma> \\<oplus> B)", "have \"size (\\<LM>A\\<RM>) = size \\<Gamma> + size (\\<LM>B\\<RM>)\""], ["proof (prove)\nusing this:\n  size (\\<LM> A  \\<RM>) = size (\\<Gamma> \\<oplus> B)\n\ngoal (1 subgoal):\n 1. size (\\<LM> A  \\<RM>) = size \\<Gamma> + size (\\<LM> B  \\<RM>)", "by auto"], ["proof (state)\nthis:\n  size (\\<LM> A  \\<RM>) = size \\<Gamma> + size (\\<LM> B  \\<RM>)\n\ngoal (1 subgoal):\n 1. A = B", "then"], ["proof (chain)\npicking this:\n  size (\\<LM> A  \\<RM>) = size \\<Gamma> + size (\\<LM> B  \\<RM>)", "have \"\\<Gamma> = \\<Empt>\""], ["proof (prove)\nusing this:\n  size (\\<LM> A  \\<RM>) = size \\<Gamma> + size (\\<LM> B  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<Gamma> = \\<Empt>", "by auto"], ["proof (state)\nthis:\n  \\<Gamma> = \\<Empt>\n\ngoal (1 subgoal):\n 1. A = B", "with assms"], ["proof (chain)\npicking this:\n  \\<LM> A  \\<RM> = \\<Gamma> \\<oplus> B\n  \\<Gamma> = \\<Empt>", "have \"\\<LM>A\\<RM> = \\<LM>B\\<RM>\""], ["proof (prove)\nusing this:\n  \\<LM> A  \\<RM> = \\<Gamma> \\<oplus> B\n  \\<Gamma> = \\<Empt>\n\ngoal (1 subgoal):\n 1. \\<LM> A  \\<RM> = \\<LM> B  \\<RM>", "by auto"], ["proof (state)\nthis:\n  \\<LM> A  \\<RM> = \\<LM> B  \\<RM>\n\ngoal (1 subgoal):\n 1. A = B", "then"], ["proof (chain)\npicking this:\n  \\<LM> A  \\<RM> = \\<LM> B  \\<RM>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<LM> A  \\<RM> = \\<LM> B  \\<RM>\n\ngoal (1 subgoal):\n 1. A = B", "by auto"], ["proof (state)\nthis:\n  A = B\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma singleton_add_means_empty:\nassumes \"\\<LM>A\\<RM> = \\<Gamma> \\<oplus> B\"\nshows \"\\<Gamma> = \\<Empt>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> = \\<Empt>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma> = \\<Empt>", "from assms"], ["proof (chain)\npicking this:\n  \\<LM> A  \\<RM> = \\<Gamma> \\<oplus> B", "have \"size (\\<LM>A\\<RM>) = size (\\<Gamma> \\<oplus> B)\""], ["proof (prove)\nusing this:\n  \\<LM> A  \\<RM> = \\<Gamma> \\<oplus> B\n\ngoal (1 subgoal):\n 1. size (\\<LM> A  \\<RM>) = size (\\<Gamma> \\<oplus> B)", "by auto"], ["proof (state)\nthis:\n  size (\\<LM> A  \\<RM>) = size (\\<Gamma> \\<oplus> B)\n\ngoal (1 subgoal):\n 1. \\<Gamma> = \\<Empt>", "then"], ["proof (chain)\npicking this:\n  size (\\<LM> A  \\<RM>) = size (\\<Gamma> \\<oplus> B)", "have \"size (\\<LM>A\\<RM>) = size \\<Gamma> + size (\\<LM>B\\<RM>)\""], ["proof (prove)\nusing this:\n  size (\\<LM> A  \\<RM>) = size (\\<Gamma> \\<oplus> B)\n\ngoal (1 subgoal):\n 1. size (\\<LM> A  \\<RM>) = size \\<Gamma> + size (\\<LM> B  \\<RM>)", "by auto"], ["proof (state)\nthis:\n  size (\\<LM> A  \\<RM>) = size \\<Gamma> + size (\\<LM> B  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<Gamma> = \\<Empt>", "then"], ["proof (chain)\npicking this:\n  size (\\<LM> A  \\<RM>) = size \\<Gamma> + size (\\<LM> B  \\<RM>)", "show \"\\<Gamma> = \\<Empt>\""], ["proof (prove)\nusing this:\n  size (\\<LM> A  \\<RM>) = size \\<Gamma> + size (\\<LM> B  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<Gamma> = \\<Empt>", "by auto"], ["proof (state)\nthis:\n  \\<Gamma> = \\<Empt>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma single_multiset_eq_non_empty:\nassumes \"\\<LM>A\\<RM> = \\<Delta> + \\<Delta>'\"\nand     \"\\<Delta> \\<noteq> \\<Empt>\"\nshows \"\\<Delta>' = \\<Empt> \\<and> \\<Delta> = \\<LM>A\\<RM>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Delta>' = \\<Empt> \\<and> \\<Delta> = \\<LM> A  \\<RM>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Delta>' = \\<Empt> \\<and> \\<Delta> = \\<LM> A  \\<RM>", "from assms"], ["proof (chain)\npicking this:\n  \\<LM> A  \\<RM> = \\<Delta> + \\<Delta>'\n  \\<Delta> \\<noteq> \\<Empt>", "have \"size (\\<LM>A\\<RM>) = size \\<Delta> + size \\<Delta>'\""], ["proof (prove)\nusing this:\n  \\<LM> A  \\<RM> = \\<Delta> + \\<Delta>'\n  \\<Delta> \\<noteq> \\<Empt>\n\ngoal (1 subgoal):\n 1. size (\\<LM> A  \\<RM>) = size \\<Delta> + size \\<Delta>'", "by auto"], ["proof (state)\nthis:\n  size (\\<LM> A  \\<RM>) = size \\<Delta> + size \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<Delta>' = \\<Empt> \\<and> \\<Delta> = \\<LM> A  \\<RM>", "then"], ["proof (chain)\npicking this:\n  size (\\<LM> A  \\<RM>) = size \\<Delta> + size \\<Delta>'", "have \"1 = size \\<Delta> + size \\<Delta>'\""], ["proof (prove)\nusing this:\n  size (\\<LM> A  \\<RM>) = size \\<Delta> + size \\<Delta>'\n\ngoal (1 subgoal):\n 1. 1 = size \\<Delta> + size \\<Delta>'", "by auto"], ["proof (state)\nthis:\n  1 = size \\<Delta> + size \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<Delta>' = \\<Empt> \\<and> \\<Delta> = \\<LM> A  \\<RM>", "moreover"], ["proof (state)\nthis:\n  1 = size \\<Delta> + size \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<Delta>' = \\<Empt> \\<and> \\<Delta> = \\<LM> A  \\<RM>", "from \\<open>\\<Delta> \\<noteq> \\<Empt>\\<close>"], ["proof (chain)\npicking this:\n  \\<Delta> \\<noteq> \\<Empt>", "have \"0 \\<noteq> size \\<Delta>\""], ["proof (prove)\nusing this:\n  \\<Delta> \\<noteq> \\<Empt>\n\ngoal (1 subgoal):\n 1. 0 \\<noteq> size \\<Delta>", "by auto"], ["proof (state)\nthis:\n  0 \\<noteq> size \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<Delta>' = \\<Empt> \\<and> \\<Delta> = \\<LM> A  \\<RM>", "ultimately"], ["proof (chain)\npicking this:\n  1 = size \\<Delta> + size \\<Delta>'\n  0 \\<noteq> size \\<Delta>", "have \"size \\<Delta> = 1 \\<and> size \\<Delta>' = 0\""], ["proof (prove)\nusing this:\n  1 = size \\<Delta> + size \\<Delta>'\n  0 \\<noteq> size \\<Delta>\n\ngoal (1 subgoal):\n 1. size \\<Delta> = 1 \\<and> size \\<Delta>' = 0", "by arith"], ["proof (state)\nthis:\n  size \\<Delta> = 1 \\<and> size \\<Delta>' = 0\n\ngoal (1 subgoal):\n 1. \\<Delta>' = \\<Empt> \\<and> \\<Delta> = \\<LM> A  \\<RM>", "then"], ["proof (chain)\npicking this:\n  size \\<Delta> = 1 \\<and> size \\<Delta>' = 0", "have a: \"\\<Delta>' = \\<Empt>\""], ["proof (prove)\nusing this:\n  size \\<Delta> = 1 \\<and> size \\<Delta>' = 0\n\ngoal (1 subgoal):\n 1. \\<Delta>' = \\<Empt>", "by auto"], ["proof (state)\nthis:\n  \\<Delta>' = \\<Empt>\n\ngoal (1 subgoal):\n 1. \\<Delta>' = \\<Empt> \\<and> \\<Delta> = \\<LM> A  \\<RM>", "with \\<open>\\<LM>A\\<RM> = \\<Delta> + \\<Delta>'\\<close>"], ["proof (chain)\npicking this:\n  \\<LM> A  \\<RM> = \\<Delta> + \\<Delta>'\n  \\<Delta>' = \\<Empt>", "have b: \"\\<Delta> = \\<LM>A\\<RM>\""], ["proof (prove)\nusing this:\n  \\<LM> A  \\<RM> = \\<Delta> + \\<Delta>'\n  \\<Delta>' = \\<Empt>\n\ngoal (1 subgoal):\n 1. \\<Delta> = \\<LM> A  \\<RM>", "by auto"], ["proof (state)\nthis:\n  \\<Delta> = \\<LM> A  \\<RM>\n\ngoal (1 subgoal):\n 1. \\<Delta>' = \\<Empt> \\<and> \\<Delta> = \\<LM> A  \\<RM>", "from a b"], ["proof (chain)\npicking this:\n  \\<Delta>' = \\<Empt>\n  \\<Delta> = \\<LM> A  \\<RM>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Delta>' = \\<Empt>\n  \\<Delta> = \\<LM> A  \\<RM>\n\ngoal (1 subgoal):\n 1. \\<Delta>' = \\<Empt> \\<and> \\<Delta> = \\<LM> A  \\<RM>", "by auto"], ["proof (state)\nthis:\n  \\<Delta>' = \\<Empt> \\<and> \\<Delta> = \\<LM> A  \\<RM>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma two_neq_one_aux:\nassumes \"(\\<LM>A\\<RM>) \\<oplus> B = \\<LM>C\\<RM>\"\nshows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from assms"], ["proof (chain)\npicking this:\n  (\\<LM> A  \\<RM>) \\<oplus> B = \\<LM> C  \\<RM>", "have \"size ((\\<LM>A\\<RM>) \\<oplus> B) = size (\\<LM>C\\<RM>)\""], ["proof (prove)\nusing this:\n  (\\<LM> A  \\<RM>) \\<oplus> B = \\<LM> C  \\<RM>\n\ngoal (1 subgoal):\n 1. size ((\\<LM> A  \\<RM>) \\<oplus> B) = size (\\<LM> C  \\<RM>)", "by auto"], ["proof (state)\nthis:\n  size ((\\<LM> A  \\<RM>) \\<oplus> B) = size (\\<LM> C  \\<RM>)\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  size ((\\<LM> A  \\<RM>) \\<oplus> B) = size (\\<LM> C  \\<RM>)", "have \"size (\\<LM>A\\<RM>) + size (\\<LM>B\\<RM>) = size (\\<LM>C\\<RM>)\""], ["proof (prove)\nusing this:\n  size ((\\<LM> A  \\<RM>) \\<oplus> B) = size (\\<LM> C  \\<RM>)\n\ngoal (1 subgoal):\n 1. size (\\<LM> A  \\<RM>) + size (\\<LM> B  \\<RM>) = size (\\<LM> C  \\<RM>)", "by auto"], ["proof (state)\nthis:\n  size (\\<LM> A  \\<RM>) + size (\\<LM> B  \\<RM>) = size (\\<LM> C  \\<RM>)\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  size (\\<LM> A  \\<RM>) + size (\\<LM> B  \\<RM>) = size (\\<LM> C  \\<RM>)", "show ?thesis"], ["proof (prove)\nusing this:\n  size (\\<LM> A  \\<RM>) + size (\\<LM> B  \\<RM>) = size (\\<LM> C  \\<RM>)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma two_neq_one:\nassumes \"((\\<LM>A\\<RM>) \\<oplus> B) + \\<Gamma> = \\<LM>C\\<RM>\"\nshows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from assms"], ["proof (chain)\npicking this:\n  (\\<LM> A  \\<RM>) \\<oplus> B + \\<Gamma> = \\<LM> C  \\<RM>", "have \"size (((\\<LM>A\\<RM>)\\<oplus> B) + \\<Gamma>) = size (\\<LM>C\\<RM>)\""], ["proof (prove)\nusing this:\n  (\\<LM> A  \\<RM>) \\<oplus> B + \\<Gamma> = \\<LM> C  \\<RM>\n\ngoal (1 subgoal):\n 1. size ((\\<LM> A  \\<RM>) \\<oplus> B + \\<Gamma>) = size (\\<LM> C  \\<RM>)", "by auto"], ["proof (state)\nthis:\n  size ((\\<LM> A  \\<RM>) \\<oplus> B + \\<Gamma>) = size (\\<LM> C  \\<RM>)\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  size ((\\<LM> A  \\<RM>) \\<oplus> B + \\<Gamma>) = size (\\<LM> C  \\<RM>)", "have \"size (\\<LM>A\\<RM>) + size (\\<LM>B\\<RM>) + size \\<Gamma> = 1\""], ["proof (prove)\nusing this:\n  size ((\\<LM> A  \\<RM>) \\<oplus> B + \\<Gamma>) = size (\\<LM> C  \\<RM>)\n\ngoal (1 subgoal):\n 1. size (\\<LM> A  \\<RM>) + size (\\<LM> B  \\<RM>) + size \\<Gamma> = 1", "by auto"], ["proof (state)\nthis:\n  size (\\<LM> A  \\<RM>) + size (\\<LM> B  \\<RM>) + size \\<Gamma> = 1\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  size (\\<LM> A  \\<RM>) + size (\\<LM> B  \\<RM>) + size \\<Gamma> = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  size (\\<LM> A  \\<RM>) + size (\\<LM> B  \\<RM>) + size \\<Gamma> = 1\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_equal_means_equal:\nassumes \"\\<Gamma> \\<oplus> A = \\<Delta> \\<oplus> A\"\nshows \"\\<Gamma> = \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> = \\<Delta>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma> = \\<Delta>", "from assms and add_eq_conv_diff[where M=\\<Gamma> and N=\\<Delta> and a=A and b=A]"], ["proof (chain)\npicking this:\n  \\<Gamma> \\<oplus> A = \\<Delta> \\<oplus> A\n  (add_mset A \\<Gamma> = add_mset A \\<Delta>) =\n  (\\<Gamma> = \\<Delta> \\<and> A = A \\<or>\n   \\<Gamma> = add_mset A (\\<Delta> \\<ominus> A) \\<and>\n   \\<Delta> = add_mset A (\\<Gamma> \\<ominus> A))", "show \"\\<Gamma> = \\<Delta>\""], ["proof (prove)\nusing this:\n  \\<Gamma> \\<oplus> A = \\<Delta> \\<oplus> A\n  (add_mset A \\<Gamma> = add_mset A \\<Delta>) =\n  (\\<Gamma> = \\<Delta> \\<and> A = A \\<or>\n   \\<Gamma> = add_mset A (\\<Delta> \\<ominus> A) \\<and>\n   \\<Delta> = add_mset A (\\<Gamma> \\<ominus> A))\n\ngoal (1 subgoal):\n 1. \\<Gamma> = \\<Delta>", "by auto"], ["proof (state)\nthis:\n  \\<Gamma> = \\<Delta>\n\ngoal:\nNo subgoals!", "qed"], ["", "(* -------------------------------\n   -------------------------------\n        SequentRulesModal2.thy\n   -------------------------------\n   ------------------------------- *)\n\n(*>*)"], ["", "text\\<open>\n\\section{Modal Calculi \\label{isamodal}}\nSome new techniques are needed when formalising results about modal calculi.  A set of modal operators must index formulae (and sequents and rules), there must be a method for modalising a multiset of formulae and we need to be able to handle implicit weakening rules.\n\nThe first of these is easy; instead of indexing formulae by a single type variable, we index on a pair of type variables, one which contains the propositional connectives, and one which contains the modal operators:\n\\<close>"], ["", "datatype ('a, 'b) form = At \"nat\"\n                                 | Compound \"'a\" \"('a, 'b) form list\"\n                                 | Modal \"'b\" \"('a, 'b) form list\"\n                                 | ff"], ["", "datatype_compat form"], ["", "(*<*)"], ["", "datatype ('a,'b) sequent = Sequent \"(('a,'b) form) multiset\" \"(('a,'b) form) multiset\" (\" (_) \\<Rightarrow>* (_)\" [6,6] 5)"], ["", "type_synonym ('a,'b) rule = \"('a,'b) sequent list * ('a,'b) sequent\""], ["", "type_synonym ('a,'b) deriv = \"('a,'b) sequent * nat\""], ["", "consts\n  (* extend a sequent by adding another one.  A form of weakening.  *)\n  extend :: \"('a,'b) sequent \\<Rightarrow> ('a,'b) sequent \\<Rightarrow> ('a,'b) sequent\"\n  extendRule :: \"('a,'b) sequent \\<Rightarrow> ('a,'b) rule \\<Rightarrow> ('a,'b) rule\"\n  extendRule2 :: \"('a,'b) sequent \\<Rightarrow> ('a,'b) sequent \\<Rightarrow> ('a,'b) rule \\<Rightarrow> ('a,'b) rule\"\n  extendConc :: \"('a,'b) sequent \\<Rightarrow> ('a,'b) rule \\<Rightarrow> ('a,'b) rule\"\n\n  (* Unique conclusion Property *)\n  uniqueConclusion :: \"('a,'b) rule set \\<Rightarrow> bool\"\n\n  (* Transform a multiset using a modal operator.  \"Boxing\" a context, effectively *)\n  modaliseMultiset :: \"'b \\<Rightarrow> ('a,'b) form multiset \\<Rightarrow> ('a,'b) form multiset\" (infixl \"\\<cdot>\" 200)"], ["", "(* functions to get at components of sequents *)"], ["", "primrec antec :: \"('a,'b) sequent \\<Rightarrow> ('a,'b) form multiset\" where\n  \"antec (Sequent ant suc) = ant\""], ["", "primrec succ :: \"('a,'b) sequent \\<Rightarrow> ('a,'b) form multiset\" where\n  \"succ (Sequent ant suc) = suc\""], ["", "primrec mset :: \"('a,'b) sequent \\<Rightarrow> ('a,'b) form multiset\" where\n  \"mset (Sequent ant suc) = ant + suc\""], ["", "primrec seq_size :: \"('a,'b) sequent \\<Rightarrow> nat\" where\n  \"seq_size (Sequent ant suc) = size ant + size suc\""], ["", "(* Extend a sequent, and then a rule by adding seq to all premisses and the conclusion *)"], ["", "overloading\n  extend \\<equiv> extend\n  extendRule \\<equiv> extendRule\n  extendRule2 \\<equiv> extendRule2\nbegin"], ["", "definition extend\n  where \"extend forms seq \\<equiv> (antec forms + antec seq) \\<Rightarrow>* (succ forms + succ seq)\""], ["", "definition extendRule\n  where \"extendRule forms R \\<equiv> (map (extend forms) (fst R), extend forms (snd R))\""], ["", "definition extendRule2 :: \"('a,'b) sequent \\<Rightarrow> ('a,'b) sequent \\<Rightarrow> ('a,'b) rule \\<Rightarrow> ('a,'b) rule\"\n  where \"extendRule2 S1 S2 r \\<equiv> (map (extend S1) (fst r), extend S2 (snd r))\""], ["", "end"], ["", "(*>*)\n\n(* The unique conclusion property.  A set of rules has unique conclusion property if for any pair of rules,\n   the conclusions being the same means the rules are the same*)"], ["", "overloading\n  uniqueConclusion \\<equiv> uniqueConclusion\n  modaliseMultiset \\<equiv> modaliseMultiset\nbegin"], ["", "definition uniqueConclusion :: \"('a,'b) rule set \\<Rightarrow> bool\"\n  where \"uniqueConclusion R \\<equiv> \\<forall> r1 \\<in> R. \\<forall> r2 \\<in> R. (snd r1 = snd r2) \\<longrightarrow> (r1 =r2)\""], ["", "text\\<open>\n\\noindent Modalising multisets is relatively straightforward.  We use the notation $!\\cdot \\Gamma$, where $!$ is a modal operator and $\\Gamma$ is a multiset of formulae:\n\\<close>"], ["", "definition modaliseMultiset :: \"'b \\<Rightarrow> ('a,'b) form multiset \\<Rightarrow> ('a,'b) form multiset\"\n  where \"modaliseMultiset a \\<Gamma> \\<equiv> {# Modal a [p]. p \\<in># \\<Gamma> #}\""], ["", "end"], ["", "(*<*) \n(* The formulation of various rule sets *)\n\n(* Ax is the set containing all identity RULES and LBot *)"], ["", "inductive_set \"Ax\" where\n   id[intro]: \"([], \\<LM> At i \\<RM> \\<Rightarrow>* \\<LM> At i \\<RM>) \\<in> Ax\"\n|  Lbot[intro]: \"([], \\<LM> ff \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax\""], ["", "(* upRules is the set of all rules which have a single conclusion.  This is akin to each rule having a \n   single principal formula.  We don't want rules to have no premisses, hence the restriction\n   that ps \\<noteq> [] *)"], ["", "inductive_set \"upRules\" where\n   I[intro]: \"\\<lbrakk> mset c = \\<LM> Compound R Fs \\<RM> ; ps \\<noteq> [] \\<rbrakk> \\<Longrightarrow> (ps,c) \\<in> upRules\""], ["", "(*>*)"], ["", "text\\<open>\n\\noindent Similarly to \\S\\ref{isafirstorder}, two new rule sets are created.  The first are the normal modal rules:\n\\<close>"], ["", "inductive_set \"modRules2\" where\n   (*<*)I[intro]:(*>*) \"\\<lbrakk> ps \\<noteq> [] ; mset c = \\<LM> Modal M Ms \\<RM> \\<rbrakk> \\<Longrightarrow> (ps,c) \\<in> modRules2\""], ["", "text\\<open>\n\\noindent The second are the \\textit{modalised context rules}.  Taking a subset of the normal modal rules, we extend using a pair of modalised multisets for context.  We create a new inductive rule set called \\texttt{p-e}, for ``prime extend'', which takes a set of modal active parts and a pair of modal operators (say $!$ and $\\bullet$), and returns the set of active parts extended with $!\\cdot \\Gamma \\Rightarrow \\bullet\\cdot\\Delta$:\n\\<close>"], ["", "inductive_set p_e :: \"('a,'b) rule set \\<Rightarrow> 'b \\<Rightarrow> 'b \\<Rightarrow> ('a,'b) rule set\" \n  for R :: \"('a,'b) rule set\" and M N :: \"'b\" \n  where\n  (*<*)I[intro]:(*>*) \"\\<lbrakk> (Ps, c) \\<in> R ; R \\<subseteq> modRules2 \\<rbrakk> \\<Longrightarrow> extendRule (M\\<cdot>\\<Gamma> \\<Rightarrow>* N\\<cdot>\\<Delta>) (Ps, c) \\<in> p_e R M N\""], ["", "text\\<open>\n\\noindent We need a method for extending the conclusion of a rule without extending the premisses.  Again, this is simple:\\<close>"], ["", "overloading extendConc \\<equiv> extendConc\nbegin"], ["", "definition extendConc :: \"('a,'b) sequent \\<Rightarrow> ('a,'b) rule \\<Rightarrow> ('a,'b) rule\"\n  where \"extendConc S r \\<equiv> (fst r, extend S (snd r))\""], ["", "end"], ["", "text\\<open>\\noindent  The extension of a rule set is now more complicated; the inductive definition has four clauses, depending on the type of rule:\n\\<close>"], ["", "inductive_set ext :: \"('a,'b) rule set \\<Rightarrow> ('a,'b) rule set \\<Rightarrow> 'b \\<Rightarrow> 'b \\<Rightarrow> ('a,'b) rule set\" \n  for R R' :: \"('a,'b) rule set\" and M N :: \"'b\"\n  where\n   ax(*<*)[intro](*>*):    \"\\<lbrakk> r \\<in> R ; r \\<in> Ax \\<rbrakk> \\<Longrightarrow> extendRule seq r \\<in> ext R R' M N\"\n|  up(*<*)[intro](*>*):    \"\\<lbrakk> r \\<in> R ; r \\<in> upRules\\<rbrakk> \\<Longrightarrow> extendRule seq r \\<in> ext R R' M N\"\n| mod1(*<*)[intro](*>*): \"\\<lbrakk> r \\<in> p_e R' M N ; r \\<in> R \\<rbrakk> \\<Longrightarrow> extendConc seq r \\<in> ext R R' M N\"\n| mod2(*<*)[intro](*>*): \"\\<lbrakk> r \\<in> R ; r \\<in> modRules2 \\<rbrakk> \\<Longrightarrow> extendRule seq r \\<in> ext R R' M N\""], ["", "text\\<open>\n\\noindent Note the new rule set carries information about which set contains the modalised context rules and which modal operators which extend those prime parts.\n\\<close>"], ["", "(*<*)\n(* A formulation of what it means to be a principal formula for a rule.   *)"], ["", "inductive leftPrincipal :: \"('a,'b) rule \\<Rightarrow> ('a,'b) form \\<Rightarrow> ('a,'b) rule set \\<Rightarrow> bool\"\n  where\n  up[intro]: \"\\<lbrakk> C = (\\<LM> A \\<RM> \\<Rightarrow>* \\<Empt>) ; A \\<noteq> ff ; (Ps,C) \\<in> R \\<rbrakk>  \\<Longrightarrow> \n                   leftPrincipal (Ps,C) A R\""], ["", "inductive rightPrincipal :: \"('a,'b) rule \\<Rightarrow> ('a,'b) form \\<Rightarrow> ('a,'b) rule set \\<Rightarrow> bool\"\n  where\n  up[intro]: \"\\<lbrakk> C = (\\<Empt> \\<Rightarrow>* \\<LM>A\\<RM>) ; (Ps,C) \\<in> R \\<rbrakk>\\<Longrightarrow> rightPrincipal (Ps,C) A R\""], ["", "(* What it means to be a derivable sequent.  Can have this as a predicate or as a set.\n   The two formation rules say that the supplied premisses are derivable, and the second says\n   that if all the premisses of some rule are derivable, then so is the conclusion. *)"], ["", "inductive_set derivable :: \"('a,'b) rule set \\<Rightarrow> ('a,'b) deriv set\"\n  for R :: \"('a,'b) rule set\"\n  where\n   base[intro]: \"\\<lbrakk>([],C) \\<in> R\\<rbrakk> \\<Longrightarrow> (C,0) \\<in> derivable R\"\n|  step[intro]: \"\\<lbrakk> r \\<in> R ; (fst r)\\<noteq>[] ; \\<forall> p \\<in> set (fst r). \\<exists> n \\<le> m. (p,n) \\<in> derivable R \\<rbrakk> \n                       \\<Longrightarrow> (snd r,m + 1) \\<in> derivable R\""], ["", "(* Characterisation of a sequent *)"], ["", "lemma characteriseSeq:\nshows \"\\<exists> A B. (C :: ('a,'b) sequent) = (A \\<Rightarrow>* B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>A B. C = ( A \\<Rightarrow>* B)", "apply (rule_tac x=\"antec C\" in exI, rule_tac x=\"succ C\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. C = ( antec C \\<Rightarrow>* succ C)", "by (cases C) (auto)"], ["", "(* Obvious connection *)"], ["", "lemma extend1_to_2:\nshows \"extendRule2 S S r = extendRule S r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extendRule2 S S r = extendRule S r", "by (auto simp add:extendRule_def extendRule2_def)"], ["", "(* Helper function for later *)"], ["", "lemma nonEmptySet:\nshows \"A \\<noteq> [] \\<longrightarrow> (\\<exists> a. a \\<in> set A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> [] \\<longrightarrow> (\\<exists>a. a \\<in> set A)", "by (auto simp add:neq_Nil_conv)"], ["", "(* Lemma which says that if we have extended an identity rule, then the propositional variable is\n   contained in the extended multisets *)"], ["", "lemma extendID:\nassumes \"extend S (\\<LM> At i \\<RM> \\<Rightarrow>* \\<LM> At i \\<RM>) = (\\<Gamma> \\<Rightarrow>* \\<Delta>)\"\nshows \"At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>", "using assms"], ["proof (prove)\nusing this:\n  extend S ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. extend S ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n    ( \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<Longrightarrow>\n    At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>", "from assms"], ["proof (chain)\npicking this:\n  extend S ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>)", "have \"\\<exists> \\<Gamma>' \\<Delta>'. \\<Gamma> = \\<Gamma>' \\<oplus> At i \\<and> \\<Delta> = \\<Delta>' \\<oplus> At i\""], ["proof (prove)\nusing this:\n  extend S ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>' \\<Delta>'.\n       \\<Gamma> = \\<Gamma>' \\<oplus> At i \\<and>\n       \\<Delta> = \\<Delta>' \\<oplus> At i", "using extend_def[where forms=S and seq=\"\\<LM> At i \\<RM> \\<Rightarrow>* \\<LM> At i \\<RM>\"]"], ["proof (prove)\nusing this:\n  extend S ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  extend S ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<equiv>\n   antec S +\n   antec\n    ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At\n        i  \\<RM>) \\<Rightarrow>* succ S +\n                                 succ\n                                  ( \\<LM> At\n     i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>' \\<Delta>'.\n       \\<Gamma> = \\<Gamma>' \\<oplus> At i \\<and>\n       \\<Delta> = \\<Delta>' \\<oplus> At i", "by (rule_tac x=\"antec S\" in exI,rule_tac x=\"succ S\" in exI) auto"], ["proof (state)\nthis:\n  \\<exists>\\<Gamma>' \\<Delta>'.\n     \\<Gamma> = \\<Gamma>' \\<oplus> At i \\<and>\n     \\<Delta> = \\<Delta>' \\<oplus> At i\n\ngoal (1 subgoal):\n 1. extend S ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n    ( \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<Longrightarrow>\n    At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<Gamma>' \\<Delta>'.\n     \\<Gamma> = \\<Gamma>' \\<oplus> At i \\<and>\n     \\<Delta> = \\<Delta>' \\<oplus> At i", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>\\<Gamma>' \\<Delta>'.\n     \\<Gamma> = \\<Gamma>' \\<oplus> At i \\<and>\n     \\<Delta> = \\<Delta>' \\<oplus> At i\n\ngoal (1 subgoal):\n 1. At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>", "by auto"], ["proof (state)\nthis:\n  At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extendFalsum:\nassumes \"extend S (\\<LM> ff \\<RM> \\<Rightarrow>* \\<Empt>) = (\\<Gamma> \\<Rightarrow>* \\<Delta>)\"\nshows \"ff \\<in># \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ff \\<in># \\<Gamma>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ff \\<in># \\<Gamma>", "from assms"], ["proof (chain)\npicking this:\n  extend S ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>)", "have \"\\<exists> \\<Gamma>'. \\<Gamma> = \\<Gamma>' \\<oplus> ff\""], ["proof (prove)\nusing this:\n  extend S ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>'. \\<Gamma> = \\<Gamma>' \\<oplus> ff", "using extend_def[where forms=S and seq=\"\\<LM>ff \\<RM> \\<Rightarrow>* \\<Empt>\"]"], ["proof (prove)\nusing this:\n  extend S ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  extend S ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<equiv>\n   antec S +\n   antec\n    ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Rightarrow>* succ S +\n                       succ ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>'. \\<Gamma> = \\<Gamma>' \\<oplus> ff", "by (rule_tac x=\"antec S\" in exI) auto"], ["proof (state)\nthis:\n  \\<exists>\\<Gamma>'. \\<Gamma> = \\<Gamma>' \\<oplus> ff\n\ngoal (1 subgoal):\n 1. ff \\<in># \\<Gamma>", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<Gamma>'. \\<Gamma> = \\<Gamma>' \\<oplus> ff", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>\\<Gamma>'. \\<Gamma> = \\<Gamma>' \\<oplus> ff\n\ngoal (1 subgoal):\n 1. ff \\<in># \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  ff \\<in># \\<Gamma>\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Lemma that says if a propositional variable is in both the antecedent and succedent of a sequent,\n   then it is derivable from idupRules *)"], ["", "lemma containID:\nassumes a:\"At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>\"\n    and b:\"Ax \\<subseteq> R\"\nshows \"(\\<Gamma> \\<Rightarrow>* \\<Delta>,0) \\<in> derivable (ext R R' M N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<Rightarrow>* \\<Delta>, 0) \\<in> derivable (ext R R' M N)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<Rightarrow>* \\<Delta>, 0) \\<in> derivable (ext R R' M N)", "from a"], ["proof (chain)\npicking this:\n  At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>", "have \"\\<Gamma> = \\<Gamma> \\<ominus> At i \\<oplus> At i \\<and> \\<Delta> = \\<Delta> \\<ominus> At i \\<oplus> At i\""], ["proof (prove)\nusing this:\n  At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<Gamma> = \\<Gamma> \\<ominus> At i \\<oplus> At i \\<and>\n    \\<Delta> = \\<Delta> \\<ominus> At i \\<oplus> At i", "by auto"], ["proof (state)\nthis:\n  \\<Gamma> = \\<Gamma> \\<ominus> At i \\<oplus> At i \\<and>\n  \\<Delta> = \\<Delta> \\<ominus> At i \\<oplus> At i\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<Rightarrow>* \\<Delta>, 0) \\<in> derivable (ext R R' M N)", "then"], ["proof (chain)\npicking this:\n  \\<Gamma> = \\<Gamma> \\<ominus> At i \\<oplus> At i \\<and>\n  \\<Delta> = \\<Delta> \\<ominus> At i \\<oplus> At i", "have \"extend ((\\<Gamma> \\<ominus> At i) \\<Rightarrow>* (\\<Delta> \\<ominus> At i)) (\\<LM> At i \\<RM> \\<Rightarrow>* \\<LM> At i \\<RM>) = (\\<Gamma> \\<Rightarrow>* \\<Delta>)\""], ["proof (prove)\nusing this:\n  \\<Gamma> = \\<Gamma> \\<ominus> At i \\<oplus> At i \\<and>\n  \\<Delta> = \\<Delta> \\<ominus> At i \\<oplus> At i\n\ngoal (1 subgoal):\n 1. extend ( \\<Gamma> \\<ominus> At i \\<Rightarrow>* \\<Delta> \\<ominus> At i)\n     ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n    ( \\<Gamma> \\<Rightarrow>* \\<Delta>)", "using extend_def[where forms=\"\\<Gamma> \\<ominus> At i \\<Rightarrow>* \\<Delta> \\<ominus> At i\" and seq=\"\\<LM>At i\\<RM> \\<Rightarrow>* \\<LM>At i\\<RM>\"]"], ["proof (prove)\nusing this:\n  \\<Gamma> = \\<Gamma> \\<ominus> At i \\<oplus> At i \\<and>\n  \\<Delta> = \\<Delta> \\<ominus> At i \\<oplus> At i\n  extend ( \\<Gamma> \\<ominus> At i \\<Rightarrow>* \\<Delta> \\<ominus> At i)\n   ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<equiv>\n   antec ( \\<Gamma> \\<ominus> At i \\<Rightarrow>* \\<Delta> \\<ominus> At i) +\n   antec\n    ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At\n        i  \\<RM>) \\<Rightarrow>* succ\n                                  ( \\<Gamma> \\<ominus>\n                                    At i \\<Rightarrow>* \\<Delta> \\<ominus>\n                  At i) +\n                                 succ\n                                  ( \\<LM> At\n     i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n\ngoal (1 subgoal):\n 1. extend ( \\<Gamma> \\<ominus> At i \\<Rightarrow>* \\<Delta> \\<ominus> At i)\n     ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n    ( \\<Gamma> \\<Rightarrow>* \\<Delta>)", "by auto"], ["proof (state)\nthis:\n  extend ( \\<Gamma> \\<ominus> At i \\<Rightarrow>* \\<Delta> \\<ominus> At i)\n   ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<Rightarrow>* \\<Delta>, 0) \\<in> derivable (ext R R' M N)", "moreover"], ["proof (state)\nthis:\n  extend ( \\<Gamma> \\<ominus> At i \\<Rightarrow>* \\<Delta> \\<ominus> At i)\n   ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<Rightarrow>* \\<Delta>, 0) \\<in> derivable (ext R R' M N)", "have \"([],\\<LM> At i \\<RM> \\<Rightarrow>* \\<LM> At i \\<RM>) \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<in> R", "using b"], ["proof (prove)\nusing this:\n  Ax \\<subseteq> R\n\ngoal (1 subgoal):\n 1. ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<in> R", "by auto"], ["proof (state)\nthis:\n  ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<in> R\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<Rightarrow>* \\<Delta>, 0) \\<in> derivable (ext R R' M N)", "ultimately"], ["proof (chain)\npicking this:\n  extend ( \\<Gamma> \\<ominus> At i \\<Rightarrow>* \\<Delta> \\<ominus> At i)\n   ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<in> R", "have \"([],\\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> ext R R' M N\""], ["proof (prove)\nusing this:\n  extend ( \\<Gamma> \\<ominus> At i \\<Rightarrow>* \\<Delta> \\<ominus> At i)\n   ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<in> R\n\ngoal (1 subgoal):\n 1. ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> ext R R' M N", "using ext.ax[where R=R and r=\"([],  \\<LM>At i\\<RM> \\<Rightarrow>* \\<LM>At i\\<RM>)\" and seq=\"\\<Gamma> \\<ominus> At i \\<Rightarrow>* \\<Delta> \\<ominus> At i\"] \n       and extendRule_def[where forms=\"\\<Gamma> \\<ominus> At i \\<Rightarrow>* \\<Delta> \\<ominus> At i\" and R=\"([],  \\<LM>At i\\<RM> \\<Rightarrow>* \\<LM>At i\\<RM>)\"]"], ["proof (prove)\nusing this:\n  extend ( \\<Gamma> \\<ominus> At i \\<Rightarrow>* \\<Delta> \\<ominus> At i)\n   ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<in> R\n  \\<lbrakk>([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n           \\<in> R;\n   case ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) of\n   (x, xa) \\<Rightarrow> (x, xa) \\<in> Ax\\<rbrakk>\n  \\<Longrightarrow> extendRule\n                     ( \\<Gamma> \\<ominus>\n                       At i \\<Rightarrow>* \\<Delta> \\<ominus> At i)\n                     ([],\n                       \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n                    \\<in> ext R ?R' ?M ?N\n  extendRule\n   ( \\<Gamma> \\<ominus> At i \\<Rightarrow>* \\<Delta> \\<ominus> At i)\n   ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<equiv>\n  (map (extend\n         ( \\<Gamma> \\<ominus> At i \\<Rightarrow>* \\<Delta> \\<ominus> At i))\n    (fst ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)),\n   extend ( \\<Gamma> \\<ominus> At i \\<Rightarrow>* \\<Delta> \\<ominus> At i)\n    (snd ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)))\n\ngoal (1 subgoal):\n 1. ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> ext R R' M N", "by auto"], ["proof (state)\nthis:\n  ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> ext R R' M N\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<Rightarrow>* \\<Delta>, 0) \\<in> derivable (ext R R' M N)", "then"], ["proof (chain)\npicking this:\n  ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> ext R R' M N", "show ?thesis"], ["proof (prove)\nusing this:\n  ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> ext R R' M N\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<Rightarrow>* \\<Delta>, 0) \\<in> derivable (ext R R' M N)", "using derivable.base[where R=\"ext R R' M N\" and C=\"\\<Gamma> \\<Rightarrow>* \\<Delta>\"]"], ["proof (prove)\nusing this:\n  ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> ext R R' M N\n  ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  \\<in> ext R R' M N \\<Longrightarrow>\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>, 0) \\<in> derivable (ext R R' M N)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<Rightarrow>* \\<Delta>, 0) \\<in> derivable (ext R R' M N)", "by auto"], ["proof (state)\nthis:\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>, 0) \\<in> derivable (ext R R' M N)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma containFalsum:\nassumes a: \"ff \\<in># \\<Gamma>\"\n   and  b: \"Ax \\<subseteq> R\"\nshows \"(\\<Gamma> \\<Rightarrow>* \\<Delta>,0) \\<in> derivable (ext R R' M N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<Rightarrow>* \\<Delta>, 0) \\<in> derivable (ext R R' M N)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<Rightarrow>* \\<Delta>, 0) \\<in> derivable (ext R R' M N)", "from a"], ["proof (chain)\npicking this:\n  ff \\<in># \\<Gamma>", "have \"\\<Gamma> = \\<Gamma> \\<ominus> ff \\<oplus> ff\""], ["proof (prove)\nusing this:\n  ff \\<in># \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<Gamma> = \\<Gamma> \\<ominus> ff \\<oplus> ff", "by auto"], ["proof (state)\nthis:\n  \\<Gamma> = \\<Gamma> \\<ominus> ff \\<oplus> ff\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<Rightarrow>* \\<Delta>, 0) \\<in> derivable (ext R R' M N)", "then"], ["proof (chain)\npicking this:\n  \\<Gamma> = \\<Gamma> \\<ominus> ff \\<oplus> ff", "have \"extend (\\<Gamma> \\<ominus> ff \\<Rightarrow>* \\<Delta>) (\\<LM>ff\\<RM> \\<Rightarrow>* \\<Empt>) = (\\<Gamma> \\<Rightarrow>* \\<Delta>)\""], ["proof (prove)\nusing this:\n  \\<Gamma> = \\<Gamma> \\<ominus> ff \\<oplus> ff\n\ngoal (1 subgoal):\n 1. extend ( \\<Gamma> \\<ominus> ff \\<Rightarrow>* \\<Delta>)\n     ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n    ( \\<Gamma> \\<Rightarrow>* \\<Delta>)", "using extend_def[where forms=\"\\<Gamma> \\<ominus> ff \\<Rightarrow>* \\<Delta>\" and seq=\"\\<LM>ff\\<RM> \\<Rightarrow>* \\<Empt>\"]"], ["proof (prove)\nusing this:\n  \\<Gamma> = \\<Gamma> \\<ominus> ff \\<oplus> ff\n  extend ( \\<Gamma> \\<ominus> ff \\<Rightarrow>* \\<Delta>)\n   ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<equiv>\n   antec ( \\<Gamma> \\<ominus> ff \\<Rightarrow>* \\<Delta>) +\n   antec\n    ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Rightarrow>* succ\n                        ( \\<Gamma> \\<ominus> ff \\<Rightarrow>* \\<Delta>) +\n                       succ ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. extend ( \\<Gamma> \\<ominus> ff \\<Rightarrow>* \\<Delta>)\n     ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n    ( \\<Gamma> \\<Rightarrow>* \\<Delta>)", "by auto"], ["proof (state)\nthis:\n  extend ( \\<Gamma> \\<ominus> ff \\<Rightarrow>* \\<Delta>)\n   ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<Rightarrow>* \\<Delta>, 0) \\<in> derivable (ext R R' M N)", "moreover"], ["proof (state)\nthis:\n  extend ( \\<Gamma> \\<ominus> ff \\<Rightarrow>* \\<Delta>)\n   ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<Rightarrow>* \\<Delta>, 0) \\<in> derivable (ext R R' M N)", "have \"([],\\<LM>ff\\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R", "using b"], ["proof (prove)\nusing this:\n  Ax \\<subseteq> R\n\ngoal (1 subgoal):\n 1. ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R", "by auto"], ["proof (state)\nthis:\n  ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<Rightarrow>* \\<Delta>, 0) \\<in> derivable (ext R R' M N)", "ultimately"], ["proof (chain)\npicking this:\n  extend ( \\<Gamma> \\<ominus> ff \\<Rightarrow>* \\<Delta>)\n   ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R", "have \"([],\\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> ext R R' M N\""], ["proof (prove)\nusing this:\n  extend ( \\<Gamma> \\<ominus> ff \\<Rightarrow>* \\<Delta>)\n   ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R\n\ngoal (1 subgoal):\n 1. ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> ext R R' M N", "using ext.ax[where R=R and r=\"([],  \\<LM>ff\\<RM> \\<Rightarrow>* \\<Empt>)\" and seq=\"\\<Gamma> \\<ominus> ff \\<Rightarrow>* \\<Delta>\"] \n       and extendRule_def[where forms=\"\\<Gamma> \\<ominus> ff \\<Rightarrow>* \\<Delta>\" and R=\"([],  \\<LM>ff\\<RM> \\<Rightarrow>* \\<Empt>)\"]"], ["proof (prove)\nusing this:\n  extend ( \\<Gamma> \\<ominus> ff \\<Rightarrow>* \\<Delta>)\n   ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R\n  \\<lbrakk>([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R;\n   case ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) of\n   (x, xa) \\<Rightarrow> (x, xa) \\<in> Ax\\<rbrakk>\n  \\<Longrightarrow> extendRule\n                     ( \\<Gamma> \\<ominus> ff \\<Rightarrow>* \\<Delta>)\n                     ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n                    \\<in> ext R ?R' ?M ?N\n  extendRule ( \\<Gamma> \\<ominus> ff \\<Rightarrow>* \\<Delta>)\n   ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<equiv>\n  (map (extend ( \\<Gamma> \\<ominus> ff \\<Rightarrow>* \\<Delta>))\n    (fst ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)),\n   extend ( \\<Gamma> \\<ominus> ff \\<Rightarrow>* \\<Delta>)\n    (snd ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)))\n\ngoal (1 subgoal):\n 1. ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> ext R R' M N", "by auto"], ["proof (state)\nthis:\n  ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> ext R R' M N\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<Rightarrow>* \\<Delta>, 0) \\<in> derivable (ext R R' M N)", "then"], ["proof (chain)\npicking this:\n  ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> ext R R' M N", "show ?thesis"], ["proof (prove)\nusing this:\n  ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> ext R R' M N\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<Rightarrow>* \\<Delta>, 0) \\<in> derivable (ext R R' M N)", "using derivable.base[where R=\"ext R R' M N\" and C=\"\\<Gamma> \\<Rightarrow>* \\<Delta>\"]"], ["proof (prove)\nusing this:\n  ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> ext R R' M N\n  ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  \\<in> ext R R' M N \\<Longrightarrow>\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>, 0) \\<in> derivable (ext R R' M N)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<Rightarrow>* \\<Delta>, 0) \\<in> derivable (ext R R' M N)", "by auto"], ["proof (state)\nthis:\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>, 0) \\<in> derivable (ext R R' M N)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Lemma which says that if r is an identity rule, then r is of the form\n   ([], P \\<Rightarrow>* P) *)"], ["", "lemma characteriseAx:\nshows \"r \\<in> Ax \\<Longrightarrow> r = ([],\\<LM> ff \\<RM> \\<Rightarrow>* \\<Empt>) \\<or> (\\<exists> i. r = ([], \\<LM> At i \\<RM> \\<Rightarrow>* \\<LM> At i \\<RM>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> Ax \\<Longrightarrow>\n    r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n    (\\<exists>i.\n        r = ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>))", "apply (cases r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>r \\<in> Ax; r = (a, b)\\<rbrakk>\n       \\<Longrightarrow> r =\n                         ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n                         (\\<exists>i.\n                             r =\n                             ([],\n                               \\<LM> At\ni  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>))", "by (rule Ax.cases) auto"], ["", "(* A lemma about the last rule used in a derivation, i.e. that one exists *)"], ["", "lemma characteriseLast:\nassumes \"(C,m+1) \\<in> derivable R\"\nshows \"\\<exists> Ps. Ps \\<noteq> [] \\<and>\n             (Ps,C) \\<in> R \\<and> \n             (\\<forall> p \\<in> set Ps. \\<exists> n\\<le>m. (p,n) \\<in> derivable R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Ps.\n       Ps \\<noteq> [] \\<and>\n       (Ps, C) \\<in> R \\<and>\n       (\\<forall>p\\<in>set Ps. \\<exists>n\\<le>m. (p, n) \\<in> derivable R)", "using assms"], ["proof (prove)\nusing this:\n  (C, m + 1) \\<in> derivable R\n\ngoal (1 subgoal):\n 1. \\<exists>Ps.\n       Ps \\<noteq> [] \\<and>\n       (Ps, C) \\<in> R \\<and>\n       (\\<forall>p\\<in>set Ps. \\<exists>n\\<le>m. (p, n) \\<in> derivable R)", "by (cases) auto"], ["", "(* Lemma which says that if rule is an upRule, then the succedent is either empty, or a single formula *)"], ["", "lemma succ_upRule:\nassumes \"(Ps,\\<Phi> \\<Rightarrow>* \\<Psi>) \\<in> upRules\"\nshows \"\\<Psi> = \\<Empt> \\<or> (\\<exists> A. \\<Psi> = \\<LM>A\\<RM>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> = \\<Empt> \\<or> (\\<exists>A. \\<Psi> = \\<LM> A  \\<RM>)", "using assms"], ["proof (prove)\nusing this:\n  (Ps,  \\<Phi> \\<Rightarrow>* \\<Psi>) \\<in> upRules\n\ngoal (1 subgoal):\n 1. \\<Psi> = \\<Empt> \\<or> (\\<exists>A. \\<Psi> = \\<LM> A  \\<RM>)", "proof (cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>R Fs.\n       \\<lbrakk>ModalSequents.mset ( \\<Phi> \\<Rightarrow>* \\<Psi>) =\n                \\<LM> Compound R Fs  \\<RM>;\n        Ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> = \\<Empt> \\<or>\n                         (\\<exists>A. \\<Psi> = \\<LM> A  \\<RM>)", "case (I R Rs)"], ["proof (state)\nthis:\n  ModalSequents.mset ( \\<Phi> \\<Rightarrow>* \\<Psi>) =\n  \\<LM> Compound R Rs  \\<RM>\n  Ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>R Fs.\n       \\<lbrakk>ModalSequents.mset ( \\<Phi> \\<Rightarrow>* \\<Psi>) =\n                \\<LM> Compound R Fs  \\<RM>;\n        Ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<Psi> = \\<Empt> \\<or>\n                         (\\<exists>A. \\<Psi> = \\<LM> A  \\<RM>)", "then"], ["proof (chain)\npicking this:\n  ModalSequents.mset ( \\<Phi> \\<Rightarrow>* \\<Psi>) =\n  \\<LM> Compound R Rs  \\<RM>\n  Ps \\<noteq> []", "show \"\\<Psi> = \\<Empt> \\<or> (\\<exists> A. \\<Psi> = \\<LM>A\\<RM>)\""], ["proof (prove)\nusing this:\n  ModalSequents.mset ( \\<Phi> \\<Rightarrow>* \\<Psi>) =\n  \\<LM> Compound R Rs  \\<RM>\n  Ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<Psi> = \\<Empt> \\<or> (\\<exists>A. \\<Psi> = \\<LM> A  \\<RM>)", "using mset.simps [where ant=\\<Phi> and suc=\\<Psi>] \n         and union_is_single[where M=\\<Phi> and N=\\<Psi> and a=\"Compound R Rs\"]"], ["proof (prove)\nusing this:\n  ModalSequents.mset ( \\<Phi> \\<Rightarrow>* \\<Psi>) =\n  \\<LM> Compound R Rs  \\<RM>\n  Ps \\<noteq> []\n  ModalSequents.mset ( \\<Phi> \\<Rightarrow>* \\<Psi>) = \\<Phi> + \\<Psi>\n  (\\<Phi> + \\<Psi> = \\<LM> Compound R Rs  \\<RM>) =\n  (\\<Phi> = \\<LM> Compound R Rs  \\<RM> \\<and> \\<Psi> = \\<Empt> \\<or>\n   \\<Phi> = \\<Empt> \\<and> \\<Psi> = \\<LM> Compound R Rs  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<Psi> = \\<Empt> \\<or> (\\<exists>A. \\<Psi> = \\<LM> A  \\<RM>)", "by (simp,elim disjE) (auto)"], ["proof (state)\nthis:\n  \\<Psi> = \\<Empt> \\<or> (\\<exists>A. \\<Psi> = \\<LM> A  \\<RM>)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Equivalent, but the antecedent *)"], ["", "lemma antec_upRule:\nassumes \"(Ps,\\<Phi> \\<Rightarrow>* \\<Psi>) \\<in> upRules\"\nshows \"\\<Phi> = \\<Empt> \\<or> (\\<exists> A. \\<Phi> = \\<LM>A\\<RM>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> = \\<Empt> \\<or> (\\<exists>A. \\<Phi> = \\<LM> A  \\<RM>)", "using assms"], ["proof (prove)\nusing this:\n  (Ps,  \\<Phi> \\<Rightarrow>* \\<Psi>) \\<in> upRules\n\ngoal (1 subgoal):\n 1. \\<Phi> = \\<Empt> \\<or> (\\<exists>A. \\<Phi> = \\<LM> A  \\<RM>)", "proof (cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>R Fs.\n       \\<lbrakk>ModalSequents.mset ( \\<Phi> \\<Rightarrow>* \\<Psi>) =\n                \\<LM> Compound R Fs  \\<RM>;\n        Ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> = \\<Empt> \\<or>\n                         (\\<exists>A. \\<Phi> = \\<LM> A  \\<RM>)", "case (I R Rs)"], ["proof (state)\nthis:\n  ModalSequents.mset ( \\<Phi> \\<Rightarrow>* \\<Psi>) =\n  \\<LM> Compound R Rs  \\<RM>\n  Ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>R Fs.\n       \\<lbrakk>ModalSequents.mset ( \\<Phi> \\<Rightarrow>* \\<Psi>) =\n                \\<LM> Compound R Fs  \\<RM>;\n        Ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> = \\<Empt> \\<or>\n                         (\\<exists>A. \\<Phi> = \\<LM> A  \\<RM>)", "then"], ["proof (chain)\npicking this:\n  ModalSequents.mset ( \\<Phi> \\<Rightarrow>* \\<Psi>) =\n  \\<LM> Compound R Rs  \\<RM>\n  Ps \\<noteq> []", "show \"\\<Phi> = \\<Empt> \\<or> (\\<exists> A. \\<Phi> = \\<LM>A\\<RM>)\""], ["proof (prove)\nusing this:\n  ModalSequents.mset ( \\<Phi> \\<Rightarrow>* \\<Psi>) =\n  \\<LM> Compound R Rs  \\<RM>\n  Ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<Phi> = \\<Empt> \\<or> (\\<exists>A. \\<Phi> = \\<LM> A  \\<RM>)", "using mset.simps[where ant=\\<Phi> and suc=\\<Psi>] \n         and union_is_single[where M=\\<Phi> and N=\\<Psi> and a=\"Compound R Rs\"]"], ["proof (prove)\nusing this:\n  ModalSequents.mset ( \\<Phi> \\<Rightarrow>* \\<Psi>) =\n  \\<LM> Compound R Rs  \\<RM>\n  Ps \\<noteq> []\n  ModalSequents.mset ( \\<Phi> \\<Rightarrow>* \\<Psi>) = \\<Phi> + \\<Psi>\n  (\\<Phi> + \\<Psi> = \\<LM> Compound R Rs  \\<RM>) =\n  (\\<Phi> = \\<LM> Compound R Rs  \\<RM> \\<and> \\<Psi> = \\<Empt> \\<or>\n   \\<Phi> = \\<Empt> \\<and> \\<Psi> = \\<LM> Compound R Rs  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<Phi> = \\<Empt> \\<or> (\\<exists>A. \\<Phi> = \\<LM> A  \\<RM>)", "by (simp,elim disjE) (auto)"], ["proof (state)\nthis:\n  \\<Phi> = \\<Empt> \\<or> (\\<exists>A. \\<Phi> = \\<LM> A  \\<RM>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upRule_Size:\nassumes \"r \\<in> upRules\"\nshows \"seq_size (snd r) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq_size (snd r) = 1", "using assms"], ["proof (prove)\nusing this:\n  r \\<in> upRules\n\ngoal (1 subgoal):\n 1. seq_size (snd r) = 1", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<in> upRules \\<Longrightarrow> seq_size (snd r) = 1", "obtain Ps C where \"r = (Ps,C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Ps C. r = (Ps, C) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases r)"], ["proof (state)\nthis:\n  r = (Ps, C)\n\ngoal (1 subgoal):\n 1. r \\<in> upRules \\<Longrightarrow> seq_size (snd r) = 1", "then"], ["proof (chain)\npicking this:\n  r = (Ps, C)", "have \"(Ps,C) \\<in> upRules\""], ["proof (prove)\nusing this:\n  r = (Ps, C)\n\ngoal (1 subgoal):\n 1. (Ps, C) \\<in> upRules", "using assms"], ["proof (prove)\nusing this:\n  r = (Ps, C)\n  r \\<in> upRules\n\ngoal (1 subgoal):\n 1. (Ps, C) \\<in> upRules", "by simp"], ["proof (state)\nthis:\n  (Ps, C) \\<in> upRules\n\ngoal (1 subgoal):\n 1. r \\<in> upRules \\<Longrightarrow> seq_size (snd r) = 1", "then"], ["proof (chain)\npicking this:\n  (Ps, C) \\<in> upRules", "show ?thesis"], ["proof (prove)\nusing this:\n  (Ps, C) \\<in> upRules\n\ngoal (1 subgoal):\n 1. seq_size (snd r) = 1", "proof (cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>R Fs.\n       \\<lbrakk>ModalSequents.mset C = \\<LM> Compound R Fs  \\<RM>;\n        Ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> seq_size (snd r) = 1", "case (I R Rs)"], ["proof (state)\nthis:\n  ModalSequents.mset C = \\<LM> Compound R Rs  \\<RM>\n  Ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>R Fs.\n       \\<lbrakk>ModalSequents.mset C = \\<LM> Compound R Fs  \\<RM>;\n        Ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> seq_size (snd r) = 1", "obtain G H where \"C = (G \\<Rightarrow>* H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>G H.\n        C = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases C) (auto)"], ["proof (state)\nthis:\n  C = ( G \\<Rightarrow>* H)\n\ngoal (1 subgoal):\n 1. \\<And>R Fs.\n       \\<lbrakk>ModalSequents.mset C = \\<LM> Compound R Fs  \\<RM>;\n        Ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> seq_size (snd r) = 1", "then"], ["proof (chain)\npicking this:\n  C = ( G \\<Rightarrow>* H)", "have \"G + H = \\<LM>Compound R Rs\\<RM>\""], ["proof (prove)\nusing this:\n  C = ( G \\<Rightarrow>* H)\n\ngoal (1 subgoal):\n 1. G + H = \\<LM> Compound R Rs  \\<RM>", "using mset.simps and \\<open>mset C = \\<LM>Compound R Rs\\<RM>\\<close>"], ["proof (prove)\nusing this:\n  C = ( G \\<Rightarrow>* H)\n  ModalSequents.mset ( ?ant \\<Rightarrow>* ?suc) = ?ant + ?suc\n  ModalSequents.mset C = \\<LM> Compound R Rs  \\<RM>\n\ngoal (1 subgoal):\n 1. G + H = \\<LM> Compound R Rs  \\<RM>", "by auto"], ["proof (state)\nthis:\n  G + H = \\<LM> Compound R Rs  \\<RM>\n\ngoal (1 subgoal):\n 1. \\<And>R Fs.\n       \\<lbrakk>ModalSequents.mset C = \\<LM> Compound R Fs  \\<RM>;\n        Ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> seq_size (snd r) = 1", "then"], ["proof (chain)\npicking this:\n  G + H = \\<LM> Compound R Rs  \\<RM>", "have \"size (G+H) = 1\""], ["proof (prove)\nusing this:\n  G + H = \\<LM> Compound R Rs  \\<RM>\n\ngoal (1 subgoal):\n 1. size (G + H) = 1", "by auto"], ["proof (state)\nthis:\n  size (G + H) = 1\n\ngoal (1 subgoal):\n 1. \\<And>R Fs.\n       \\<lbrakk>ModalSequents.mset C = \\<LM> Compound R Fs  \\<RM>;\n        Ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> seq_size (snd r) = 1", "then"], ["proof (chain)\npicking this:\n  size (G + H) = 1", "have \"size G + size H = 1\""], ["proof (prove)\nusing this:\n  size (G + H) = 1\n\ngoal (1 subgoal):\n 1. size G + size H = 1", "by auto"], ["proof (state)\nthis:\n  size G + size H = 1\n\ngoal (1 subgoal):\n 1. \\<And>R Fs.\n       \\<lbrakk>ModalSequents.mset C = \\<LM> Compound R Fs  \\<RM>;\n        Ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> seq_size (snd r) = 1", "then"], ["proof (chain)\npicking this:\n  size G + size H = 1", "have \"seq_size C = 1\""], ["proof (prove)\nusing this:\n  size G + size H = 1\n\ngoal (1 subgoal):\n 1. seq_size C = 1", "using seq_size.simps[where ant=G and suc=H] and \\<open>C = (G \\<Rightarrow>* H)\\<close>"], ["proof (prove)\nusing this:\n  size G + size H = 1\n  seq_size ( G \\<Rightarrow>* H) = size G + size H\n  C = ( G \\<Rightarrow>* H)\n\ngoal (1 subgoal):\n 1. seq_size C = 1", "by auto"], ["proof (state)\nthis:\n  seq_size C = 1\n\ngoal (1 subgoal):\n 1. \\<And>R Fs.\n       \\<lbrakk>ModalSequents.mset C = \\<LM> Compound R Fs  \\<RM>;\n        Ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> seq_size (snd r) = 1", "moreover"], ["proof (state)\nthis:\n  seq_size C = 1\n\ngoal (1 subgoal):\n 1. \\<And>R Fs.\n       \\<lbrakk>ModalSequents.mset C = \\<LM> Compound R Fs  \\<RM>;\n        Ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> seq_size (snd r) = 1", "have \"snd r = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd r = C", "using \\<open>r = (Ps,C)\\<close>"], ["proof (prove)\nusing this:\n  r = (Ps, C)\n\ngoal (1 subgoal):\n 1. snd r = C", "by simp"], ["proof (state)\nthis:\n  snd r = C\n\ngoal (1 subgoal):\n 1. \\<And>R Fs.\n       \\<lbrakk>ModalSequents.mset C = \\<LM> Compound R Fs  \\<RM>;\n        Ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> seq_size (snd r) = 1", "ultimately"], ["proof (chain)\npicking this:\n  seq_size C = 1\n  snd r = C", "show \"seq_size (snd r) = 1\""], ["proof (prove)\nusing this:\n  seq_size C = 1\n  snd r = C\n\ngoal (1 subgoal):\n 1. seq_size (snd r) = 1", "by simp"], ["proof (state)\nthis:\n  seq_size (snd r) = 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  seq_size (snd r) = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upRuleCharacterise:\nassumes \"(Ps,C) \\<in> upRules\"\nshows \"\\<exists> F Fs. C = (\\<Empt> \\<Rightarrow>* \\<LM>Compound F Fs\\<RM>) \\<or> C = (\\<LM>Compound F Fs\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>F Fs.\n       C = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F Fs  \\<RM>) \\<or>\n       C = ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)", "using assms"], ["proof (prove)\nusing this:\n  (Ps, C) \\<in> upRules\n\ngoal (1 subgoal):\n 1. \\<exists>F Fs.\n       C = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F Fs  \\<RM>) \\<or>\n       C = ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)", "proof (cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>R Fs.\n       \\<lbrakk>ModalSequents.mset C = \\<LM> Compound R Fs  \\<RM>;\n        Ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F Fs.\n                            C =\n                            ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F\n                      Fs  \\<RM>) \\<or>\n                            C =\n                            ( \\<LM> Compound F\n                                     Fs  \\<RM> \\<Rightarrow>* \\<Empt>)", "case (I F Fs)"], ["proof (state)\nthis:\n  ModalSequents.mset C = \\<LM> Compound F Fs  \\<RM>\n  Ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>R Fs.\n       \\<lbrakk>ModalSequents.mset C = \\<LM> Compound R Fs  \\<RM>;\n        Ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F Fs.\n                            C =\n                            ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F\n                      Fs  \\<RM>) \\<or>\n                            C =\n                            ( \\<LM> Compound F\n                                     Fs  \\<RM> \\<Rightarrow>* \\<Empt>)", "then"], ["proof (chain)\npicking this:\n  ModalSequents.mset C = \\<LM> Compound F Fs  \\<RM>\n  Ps \\<noteq> []", "obtain \\<Gamma> \\<Delta> where \"C = (\\<Gamma> \\<Rightarrow>* \\<Delta>)\""], ["proof (prove)\nusing this:\n  ModalSequents.mset C = \\<LM> Compound F Fs  \\<RM>\n  Ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma> \\<Delta>.\n        C = ( \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using characteriseSeq[where C=C]"], ["proof (prove)\nusing this:\n  ModalSequents.mset C = \\<LM> Compound F Fs  \\<RM>\n  Ps \\<noteq> []\n  \\<exists>A B. C = ( A \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma> \\<Delta>.\n        C = ( \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C = ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>R Fs.\n       \\<lbrakk>ModalSequents.mset C = \\<LM> Compound R Fs  \\<RM>;\n        Ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F Fs.\n                            C =\n                            ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F\n                      Fs  \\<RM>) \\<or>\n                            C =\n                            ( \\<LM> Compound F\n                                     Fs  \\<RM> \\<Rightarrow>* \\<Empt>)", "then"], ["proof (chain)\npicking this:\n  C = ( \\<Gamma> \\<Rightarrow>* \\<Delta>)", "have \"(Ps,\\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> upRules\""], ["proof (prove)\nusing this:\n  C = ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> upRules", "using assms"], ["proof (prove)\nusing this:\n  C = ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  (Ps, C) \\<in> upRules\n\ngoal (1 subgoal):\n 1. (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> upRules", "by simp"], ["proof (state)\nthis:\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> upRules\n\ngoal (1 subgoal):\n 1. \\<And>R Fs.\n       \\<lbrakk>ModalSequents.mset C = \\<LM> Compound R Fs  \\<RM>;\n        Ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F Fs.\n                            C =\n                            ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F\n                      Fs  \\<RM>) \\<or>\n                            C =\n                            ( \\<LM> Compound F\n                                     Fs  \\<RM> \\<Rightarrow>* \\<Empt>)", "then"], ["proof (chain)\npicking this:\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> upRules", "show \"\\<exists> F Fs. C = (\\<Empt> \\<Rightarrow>* \\<LM>Compound F Fs\\<RM>) \\<or> C = (\\<LM>Compound F Fs\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> upRules\n\ngoal (1 subgoal):\n 1. \\<exists>F Fs.\n       C = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F Fs  \\<RM>) \\<or>\n       C = ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)", "using \\<open>mset C = \\<LM>Compound F Fs\\<RM>\\<close> and \\<open>C = (\\<Gamma> \\<Rightarrow>* \\<Delta>)\\<close>\n      and mset.simps [where ant=\\<Gamma> and suc=\\<Delta>] and union_is_single[where M=\\<Gamma> and N=\\<Delta> and a=\"Compound F Fs\"]"], ["proof (prove)\nusing this:\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> upRules\n  ModalSequents.mset C = \\<LM> Compound F Fs  \\<RM>\n  C = ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  ModalSequents.mset ( \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n  \\<Gamma> + \\<Delta>\n  (\\<Gamma> + \\<Delta> = \\<LM> Compound F Fs  \\<RM>) =\n  (\\<Gamma> = \\<LM> Compound F Fs  \\<RM> \\<and> \\<Delta> = \\<Empt> \\<or>\n   \\<Gamma> = \\<Empt> \\<and> \\<Delta> = \\<LM> Compound F Fs  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<exists>F Fs.\n       C = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F Fs  \\<RM>) \\<or>\n       C = ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>F Fs.\n     C = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F Fs  \\<RM>) \\<or>\n     C = ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma modRule2Characterise:\nassumes \"(Ps,C) \\<in> modRules2\"\nshows \"Ps \\<noteq> [] \\<and> (\\<exists> F Fs. C = (\\<Empt> \\<Rightarrow>* \\<LM>Modal F Fs\\<RM>) \\<or> C = (\\<LM>Modal F Fs\\<RM> \\<Rightarrow>* \\<Empt>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ps \\<noteq> [] \\<and>\n    (\\<exists>F Fs.\n        C = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n        C = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))", "using assms"], ["proof (prove)\nusing this:\n  (Ps, C) \\<in> modRules2\n\ngoal (1 subgoal):\n 1. Ps \\<noteq> [] \\<and>\n    (\\<exists>F Fs.\n        C = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n        C = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))", "proof (cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M Ms.\n       \\<lbrakk>Ps \\<noteq> [];\n        ModalSequents.mset C = \\<LM> Modal M Ms  \\<RM>\\<rbrakk>\n       \\<Longrightarrow> Ps \\<noteq> [] \\<and>\n                         (\\<exists>F Fs.\n                             C =\n                             ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F\n                       Fs  \\<RM>) \\<or>\n                             C =\n                             ( \\<LM> Modal F\nFs  \\<RM> \\<Rightarrow>* \\<Empt>))", "case (I F Fs)"], ["proof (state)\nthis:\n  Ps \\<noteq> []\n  ModalSequents.mset C = \\<LM> Modal F Fs  \\<RM>\n\ngoal (1 subgoal):\n 1. \\<And>M Ms.\n       \\<lbrakk>Ps \\<noteq> [];\n        ModalSequents.mset C = \\<LM> Modal M Ms  \\<RM>\\<rbrakk>\n       \\<Longrightarrow> Ps \\<noteq> [] \\<and>\n                         (\\<exists>F Fs.\n                             C =\n                             ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F\n                       Fs  \\<RM>) \\<or>\n                             C =\n                             ( \\<LM> Modal F\nFs  \\<RM> \\<Rightarrow>* \\<Empt>))", "then"], ["proof (chain)\npicking this:\n  Ps \\<noteq> []\n  ModalSequents.mset C = \\<LM> Modal F Fs  \\<RM>", "have \"Ps \\<noteq> []\""], ["proof (prove)\nusing this:\n  Ps \\<noteq> []\n  ModalSequents.mset C = \\<LM> Modal F Fs  \\<RM>\n\ngoal (1 subgoal):\n 1. Ps \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  Ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>M Ms.\n       \\<lbrakk>Ps \\<noteq> [];\n        ModalSequents.mset C = \\<LM> Modal M Ms  \\<RM>\\<rbrakk>\n       \\<Longrightarrow> Ps \\<noteq> [] \\<and>\n                         (\\<exists>F Fs.\n                             C =\n                             ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F\n                       Fs  \\<RM>) \\<or>\n                             C =\n                             ( \\<LM> Modal F\nFs  \\<RM> \\<Rightarrow>* \\<Empt>))", "obtain \\<Gamma> \\<Delta> where \"C = (\\<Gamma> \\<Rightarrow>* \\<Delta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma> \\<Delta>.\n        C = ( \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using characteriseSeq[where C=C]"], ["proof (prove)\nusing this:\n  \\<exists>A B. C = ( A \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma> \\<Delta>.\n        C = ( \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  C = ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>M Ms.\n       \\<lbrakk>Ps \\<noteq> [];\n        ModalSequents.mset C = \\<LM> Modal M Ms  \\<RM>\\<rbrakk>\n       \\<Longrightarrow> Ps \\<noteq> [] \\<and>\n                         (\\<exists>F Fs.\n                             C =\n                             ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F\n                       Fs  \\<RM>) \\<or>\n                             C =\n                             ( \\<LM> Modal F\nFs  \\<RM> \\<Rightarrow>* \\<Empt>))", "then"], ["proof (chain)\npicking this:\n  C = ( \\<Gamma> \\<Rightarrow>* \\<Delta>)", "have \"(Ps,\\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> modRules2\""], ["proof (prove)\nusing this:\n  C = ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> modRules2", "using assms"], ["proof (prove)\nusing this:\n  C = ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  (Ps, C) \\<in> modRules2\n\ngoal (1 subgoal):\n 1. (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> modRules2", "by simp"], ["proof (state)\nthis:\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> modRules2\n\ngoal (1 subgoal):\n 1. \\<And>M Ms.\n       \\<lbrakk>Ps \\<noteq> [];\n        ModalSequents.mset C = \\<LM> Modal M Ms  \\<RM>\\<rbrakk>\n       \\<Longrightarrow> Ps \\<noteq> [] \\<and>\n                         (\\<exists>F Fs.\n                             C =\n                             ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F\n                       Fs  \\<RM>) \\<or>\n                             C =\n                             ( \\<LM> Modal F\nFs  \\<RM> \\<Rightarrow>* \\<Empt>))", "then"], ["proof (chain)\npicking this:\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> modRules2", "have \"\\<exists> F Fs. C = (\\<Empt> \\<Rightarrow>* \\<LM>Modal F Fs\\<RM>) \\<or> C = (\\<LM>Modal F Fs\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> modRules2\n\ngoal (1 subgoal):\n 1. \\<exists>F Fs.\n       C = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n       C = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)", "using \\<open>mset C = \\<LM>Modal F Fs\\<RM>\\<close> and \\<open>C = (\\<Gamma> \\<Rightarrow>* \\<Delta>)\\<close>\n      and mset.simps[where ant=\\<Gamma> and suc=\\<Delta>] and union_is_single[where M=\\<Gamma> and N=\\<Delta> and a=\"Modal F Fs\"]"], ["proof (prove)\nusing this:\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> modRules2\n  ModalSequents.mset C = \\<LM> Modal F Fs  \\<RM>\n  C = ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  ModalSequents.mset ( \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n  \\<Gamma> + \\<Delta>\n  (\\<Gamma> + \\<Delta> = \\<LM> Modal F Fs  \\<RM>) =\n  (\\<Gamma> = \\<LM> Modal F Fs  \\<RM> \\<and> \\<Delta> = \\<Empt> \\<or>\n   \\<Gamma> = \\<Empt> \\<and> \\<Delta> = \\<LM> Modal F Fs  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<exists>F Fs.\n       C = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n       C = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>F Fs.\n     C = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n     C = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<And>M Ms.\n       \\<lbrakk>Ps \\<noteq> [];\n        ModalSequents.mset C = \\<LM> Modal M Ms  \\<RM>\\<rbrakk>\n       \\<Longrightarrow> Ps \\<noteq> [] \\<and>\n                         (\\<exists>F Fs.\n                             C =\n                             ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F\n                       Fs  \\<RM>) \\<or>\n                             C =\n                             ( \\<LM> Modal F\nFs  \\<RM> \\<Rightarrow>* \\<Empt>))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>F Fs.\n     C = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n     C = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. Ps \\<noteq> [] \\<and>\n    (\\<exists>F Fs.\n        C = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n        C = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))", "using \\<open>Ps \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>F Fs.\n     C = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n     C = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n  Ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. Ps \\<noteq> [] \\<and>\n    (\\<exists>F Fs.\n        C = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n        C = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))", "by auto"], ["proof (state)\nthis:\n  Ps \\<noteq> [] \\<and>\n  (\\<exists>F Fs.\n      C = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n      C = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma modRule1Characterise:\nassumes \"(Ps,C) \\<in> p_e R M N\" and \"R \\<subseteq> modRules2\"\nshows \"\\<exists> F Fs \\<Gamma> \\<Delta> ps r. (Ps,C) = extendRule (M\\<cdot>\\<Gamma>\\<Rightarrow>*N\\<cdot>\\<Delta>) r \\<and> r \\<in> R \\<and> \n                    (r = (ps,\\<Empt> \\<Rightarrow>* \\<LM>Modal F Fs\\<RM>) \\<or> \n                     r = (ps,\\<LM>Modal F Fs\\<RM> \\<Rightarrow>* \\<Empt>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>F Fs \\<Gamma> \\<Delta> ps r.\n       (Ps, C) =\n       extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n        r \\<and>\n       r \\<in> R \\<and>\n       (r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n        r = (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))", "using assms"], ["proof (prove)\nusing this:\n  (Ps, C) \\<in> p_e R M N\n  R \\<subseteq> modRules2\n\ngoal (1 subgoal):\n 1. \\<exists>F Fs \\<Gamma> \\<Delta> ps r.\n       (Ps, C) =\n       extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n        r \\<and>\n       r \\<in> R \\<and>\n       (r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n        r = (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))", "proof (cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Psa c \\<Gamma> \\<Delta>.\n       \\<lbrakk>R \\<subseteq> modRules2;\n        (Ps, C) =\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Psa, c);\n        (Psa, c) \\<in> R; R \\<subseteq> modRules2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F Fs \\<Gamma> \\<Delta> ps r.\n                            (Ps, C) =\n                            extendRule\n                             ( M \\<cdot>\n                               \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n                             r \\<and>\n                            r \\<in> R \\<and>\n                            (r =\n                             (ps,\n                               \\<Empt> \\<Rightarrow>* \\<LM> Modal F\n                       Fs  \\<RM>) \\<or>\n                             r =\n                             (ps,\n                               \\<LM> Modal F\nFs  \\<RM> \\<Rightarrow>* \\<Empt>))", "case (I ps c \\<Gamma> \\<Delta>)"], ["proof (state)\nthis:\n  (Ps, C) =\n  extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>) (ps, c)\n  (ps, c) \\<in> R\n  R \\<subseteq> modRules2\n\ngoal (1 subgoal):\n 1. \\<And>Psa c \\<Gamma> \\<Delta>.\n       \\<lbrakk>R \\<subseteq> modRules2;\n        (Ps, C) =\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Psa, c);\n        (Psa, c) \\<in> R; R \\<subseteq> modRules2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F Fs \\<Gamma> \\<Delta> ps r.\n                            (Ps, C) =\n                            extendRule\n                             ( M \\<cdot>\n                               \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n                             r \\<and>\n                            r \\<in> R \\<and>\n                            (r =\n                             (ps,\n                               \\<Empt> \\<Rightarrow>* \\<LM> Modal F\n                       Fs  \\<RM>) \\<or>\n                             r =\n                             (ps,\n                               \\<LM> Modal F\nFs  \\<RM> \\<Rightarrow>* \\<Empt>))", "then"], ["proof (chain)\npicking this:\n  (Ps, C) =\n  extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>) (ps, c)\n  (ps, c) \\<in> R\n  R \\<subseteq> modRules2", "have \"(ps, c) \\<in> modRules2\""], ["proof (prove)\nusing this:\n  (Ps, C) =\n  extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>) (ps, c)\n  (ps, c) \\<in> R\n  R \\<subseteq> modRules2\n\ngoal (1 subgoal):\n 1. (ps, c) \\<in> modRules2", "by auto"], ["proof (state)\nthis:\n  (ps, c) \\<in> modRules2\n\ngoal (1 subgoal):\n 1. \\<And>Psa c \\<Gamma> \\<Delta>.\n       \\<lbrakk>R \\<subseteq> modRules2;\n        (Ps, C) =\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Psa, c);\n        (Psa, c) \\<in> R; R \\<subseteq> modRules2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F Fs \\<Gamma> \\<Delta> ps r.\n                            (Ps, C) =\n                            extendRule\n                             ( M \\<cdot>\n                               \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n                             r \\<and>\n                            r \\<in> R \\<and>\n                            (r =\n                             (ps,\n                               \\<Empt> \\<Rightarrow>* \\<LM> Modal F\n                       Fs  \\<RM>) \\<or>\n                             r =\n                             (ps,\n                               \\<LM> Modal F\nFs  \\<RM> \\<Rightarrow>* \\<Empt>))", "with \\<open>(ps, c) \\<in> modRules2\\<close>"], ["proof (chain)\npicking this:\n  (ps, c) \\<in> modRules2\n  (ps, c) \\<in> modRules2", "obtain F Fs where \"c = (\\<Empt> \\<Rightarrow>* \\<LM>Modal F Fs\\<RM>) \\<or> c = (\\<LM>Modal F Fs\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  (ps, c) \\<in> modRules2\n  (ps, c) \\<in> modRules2\n\ngoal (1 subgoal):\n 1. (\\<And>F Fs.\n        c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n        c =\n        ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using modRule2Characterise[where C=c and Ps=ps]"], ["proof (prove)\nusing this:\n  (ps, c) \\<in> modRules2\n  (ps, c) \\<in> modRules2\n  (ps, c) \\<in> modRules2 \\<Longrightarrow>\n  ps \\<noteq> [] \\<and>\n  (\\<exists>F Fs.\n      c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n      c = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))\n\ngoal (1 subgoal):\n 1. (\\<And>F Fs.\n        c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n        c =\n        ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n  c = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<And>Psa c \\<Gamma> \\<Delta>.\n       \\<lbrakk>R \\<subseteq> modRules2;\n        (Ps, C) =\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Psa, c);\n        (Psa, c) \\<in> R; R \\<subseteq> modRules2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>F Fs \\<Gamma> \\<Delta> ps r.\n                            (Ps, C) =\n                            extendRule\n                             ( M \\<cdot>\n                               \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n                             r \\<and>\n                            r \\<in> R \\<and>\n                            (r =\n                             (ps,\n                               \\<Empt> \\<Rightarrow>* \\<LM> Modal F\n                       Fs  \\<RM>) \\<or>\n                             r =\n                             (ps,\n                               \\<LM> Modal F\nFs  \\<RM> \\<Rightarrow>* \\<Empt>))", "with I"], ["proof (chain)\npicking this:\n  (Ps, C) =\n  extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>) (ps, c)\n  (ps, c) \\<in> R\n  R \\<subseteq> modRules2\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n  c = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)", "show ?thesis"], ["proof (prove)\nusing this:\n  (Ps, C) =\n  extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>) (ps, c)\n  (ps, c) \\<in> R\n  R \\<subseteq> modRules2\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n  c = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<exists>F Fs \\<Gamma> \\<Delta> ps r.\n       (Ps, C) =\n       extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n        r \\<and>\n       r \\<in> R \\<and>\n       (r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n        r = (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Ps, C) =\n             extendRule\n              ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n              (ps, c);\n     (ps, c) \\<in> R; R \\<subseteq> modRules2;\n     c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n     c = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>F Fs \\<Gamma> \\<Delta> ps r.\n                         (Ps, C) =\n                         extendRule\n                          ( M \\<cdot>\n                            \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n                          r \\<and>\n                         r \\<in> R \\<and>\n                         (r =\n                          (ps,\n                            \\<Empt> \\<Rightarrow>* \\<LM> Modal F\n                    Fs  \\<RM>) \\<or>\n                          r =\n                          (ps,\n                            \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))", "apply (rule_tac x=F in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Ps, C) =\n             extendRule\n              ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n              (ps, c);\n     (ps, c) \\<in> R; R \\<subseteq> modRules2;\n     c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n     c = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Fs \\<Gamma> \\<Delta> ps r.\n                         (Ps, C) =\n                         extendRule\n                          ( M \\<cdot>\n                            \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n                          r \\<and>\n                         r \\<in> R \\<and>\n                         (r =\n                          (ps,\n                            \\<Empt> \\<Rightarrow>* \\<LM> Modal F\n                    Fs  \\<RM>) \\<or>\n                          r =\n                          (ps,\n                            \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))", "apply (rule_tac x=Fs in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Ps, C) =\n             extendRule\n              ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n              (ps, c);\n     (ps, c) \\<in> R; R \\<subseteq> modRules2;\n     c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n     c = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<Gamma> \\<Delta> ps r.\n                         (Ps, C) =\n                         extendRule\n                          ( M \\<cdot>\n                            \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n                          r \\<and>\n                         r \\<in> R \\<and>\n                         (r =\n                          (ps,\n                            \\<Empt> \\<Rightarrow>* \\<LM> Modal F\n                    Fs  \\<RM>) \\<or>\n                          r =\n                          (ps,\n                            \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))", "apply (rule_tac x=\\<Gamma> in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Ps, C) =\n             extendRule\n              ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n              (ps, c);\n     (ps, c) \\<in> R; R \\<subseteq> modRules2;\n     c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n     c = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<Delta> ps r.\n                         (Ps, C) =\n                         extendRule\n                          ( M \\<cdot>\n                            \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n                          r \\<and>\n                         r \\<in> R \\<and>\n                         (r =\n                          (ps,\n                            \\<Empt> \\<Rightarrow>* \\<LM> Modal F\n                    Fs  \\<RM>) \\<or>\n                          r =\n                          (ps,\n                            \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))", "apply (rule_tac x=\\<Delta> in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(Ps, C) =\n             extendRule\n              ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n              (ps, c);\n     (ps, c) \\<in> R; R \\<subseteq> modRules2;\n     c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n     c = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>ps r.\n                         (Ps, C) =\n                         extendRule\n                          ( M \\<cdot>\n                            \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n                          r \\<and>\n                         r \\<in> R \\<and>\n                         (r =\n                          (ps,\n                            \\<Empt> \\<Rightarrow>* \\<LM> Modal F\n                    Fs  \\<RM>) \\<or>\n                          r =\n                          (ps,\n                            \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>F Fs \\<Gamma> \\<Delta> ps r.\n     (Ps, C) =\n     extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n      r \\<and>\n     r \\<in> R \\<and>\n     (r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n      r = (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extendEmpty:\nshows \"extend (\\<Empt> \\<Rightarrow>* \\<Empt>) C = C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extend ( \\<Empt> \\<Rightarrow>* \\<Empt>) C = C", "apply (auto simp add:extend_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ( antec C \\<Rightarrow>* succ C) = C", "by (cases C) auto"], ["", "lemma mapExtendEmpty:\nshows \"map (extend (\\<Empt> \\<Rightarrow>* \\<Empt>)) ps = ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (extend ( \\<Empt> \\<Rightarrow>* \\<Empt>)) ps = ps", "using extendEmpty"], ["proof (prove)\nusing this:\n  extend ( \\<Empt> \\<Rightarrow>* \\<Empt>) ?C = ?C\n\ngoal (1 subgoal):\n 1. map (extend ( \\<Empt> \\<Rightarrow>* \\<Empt>)) ps = ps", "by (induct ps) auto"], ["", "lemma extendRuleEmpty:\nshows \"extendRule (\\<Empt> \\<Rightarrow>* \\<Empt>) r = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extendRule ( \\<Empt> \\<Rightarrow>* \\<Empt>) r = r", "by (auto simp add:extendRule_def extendEmpty mapExtendEmpty)"], ["", "lemma extendNonEmpty:\nassumes \"\\<not> (\\<Gamma> = \\<Empt> \\<and> \\<Delta> = \\<Empt>)\"\nshows \"extend (\\<Gamma> \\<Rightarrow>* \\<Delta>) C \\<noteq> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extend ( \\<Gamma> \\<Rightarrow>* \\<Delta>) C \\<noteq> C", "using assms"], ["proof (prove)\nusing this:\n  \\<not> (\\<Gamma> = \\<Empt> \\<and> \\<Delta> = \\<Empt>)\n\ngoal (1 subgoal):\n 1. extend ( \\<Gamma> \\<Rightarrow>* \\<Delta>) C \\<noteq> C", "by (cases C) (auto simp add:extend_def nonEmpty_neq)"], ["", "lemma extendRuleNonEmpty:\nassumes \"\\<not> (\\<Gamma> = \\<Empt> \\<and> \\<Delta> = \\<Empt>)\"\nshows \"extendRule (\\<Gamma> \\<Rightarrow>* \\<Delta>) r \\<noteq> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extendRule ( \\<Gamma> \\<Rightarrow>* \\<Delta>) r \\<noteq> r", "using assms"], ["proof (prove)\nusing this:\n  \\<not> (\\<Gamma> = \\<Empt> \\<and> \\<Delta> = \\<Empt>)\n\ngoal (1 subgoal):\n 1. extendRule ( \\<Gamma> \\<Rightarrow>* \\<Delta>) r \\<noteq> r", "by (cases r) (auto simp add:extendRule_def extendNonEmpty)"], ["", "lemma extendRuleEmptyRev:\nassumes \"extendRule S r = r\"\nshows \"S = (\\<Empt> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S = ( \\<Empt> \\<Rightarrow>* \\<Empt>)", "using assms extendRuleNonEmpty"], ["proof (prove)\nusing this:\n  extendRule S r = r\n  \\<not> (?\\<Gamma> = \\<Empt> \\<and> ?\\<Delta> = \\<Empt>) \\<Longrightarrow>\n  extendRule ( ?\\<Gamma> \\<Rightarrow>* ?\\<Delta>) ?r \\<noteq> ?r\n\ngoal (1 subgoal):\n 1. S = ( \\<Empt> \\<Rightarrow>* \\<Empt>)", "apply (cases r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>extendRule S r = r;\n        \\<And>\\<Gamma> \\<Delta> r.\n           \\<not> (\\<Gamma> = \\<Empt> \\<and>\n                   \\<Delta> = \\<Empt>) \\<Longrightarrow>\n           extendRule ( \\<Gamma> \\<Rightarrow>* \\<Delta>) r \\<noteq> r;\n        r = (a, b)\\<rbrakk>\n       \\<Longrightarrow> S = ( \\<Empt> \\<Rightarrow>* \\<Empt>)", "by (cases S) (auto)"], ["", "lemma modaliseEmpty:\nshows \"a \\<cdot> (\\<Empt>) = \\<Empt>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<cdot> (\\<Empt>) = \\<Empt>", "using modaliseMultiset_def[where a=a and \\<Gamma>=\"\\<Empt>\"]"], ["proof (prove)\nusing this:\n  a \\<cdot> (\\<Empt>) \\<equiv>\n  (\\<lambda>p. Modal a [p]) \\<cdot>\\<cdot> (\\<Empt>)\n\ngoal (1 subgoal):\n 1. a \\<cdot> (\\<Empt>) = \\<Empt>", "by auto"], ["", "lemma modaliseNonEmpty:\nassumes \"\\<Gamma> \\<noteq> \\<Empt>\"\nshows \"a \\<cdot> \\<Gamma> \\<noteq> \\<Empt>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<cdot> \\<Gamma> \\<noteq> \\<Empt>", "using assms nonEmpty_image[where \\<Gamma>=\\<Gamma>] modaliseMultiset_def[where \\<Gamma>=\\<Gamma> and a=a]"], ["proof (prove)\nusing this:\n  \\<Gamma> \\<noteq> \\<Empt>\n  \\<Gamma> \\<noteq> \\<Empt> \\<Longrightarrow>\n  ?f \\<cdot>\\<cdot> \\<Gamma> \\<noteq> \\<Empt>\n  a \\<cdot> \\<Gamma> \\<equiv>\n  (\\<lambda>p. Modal a [p]) \\<cdot>\\<cdot> \\<Gamma>\n\ngoal (1 subgoal):\n 1. a \\<cdot> \\<Gamma> \\<noteq> \\<Empt>", "by auto"], ["", "lemma mset_extend:\nshows \"mset (extend S c) = mset S + mset c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ModalSequents.mset (extend S c) =\n    ModalSequents.mset S + ModalSequents.mset c", "using mset.simps extend_def"], ["proof (prove)\nusing this:\n  ModalSequents.mset ( ?ant \\<Rightarrow>* ?suc) = ?ant + ?suc\n  extend ?forms ?seq \\<equiv>\n   antec ?forms + antec ?seq \\<Rightarrow>* succ ?forms + succ ?seq\n\ngoal (1 subgoal):\n 1. ModalSequents.mset (extend S c) =\n    ModalSequents.mset S + ModalSequents.mset c", "apply (cases S)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>ant suc.\n                   ModalSequents.mset ( ant \\<Rightarrow>* suc) = ant + suc;\n        \\<And>forms seq.\n           extend forms seq \\<equiv>\n            antec forms + antec seq \\<Rightarrow>* succ forms + succ seq;\n        S = ( x1 \\<Rightarrow>* x2)\\<rbrakk>\n       \\<Longrightarrow> ModalSequents.mset (extend S c) =\n                         ModalSequents.mset S + ModalSequents.mset c", "apply (cases c)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>\\<And>ant suc.\n                   ModalSequents.mset ( ant \\<Rightarrow>* suc) = ant + suc;\n        \\<And>forms seq.\n           extend forms seq \\<equiv>\n            antec forms + antec seq \\<Rightarrow>* succ forms + succ seq;\n        S = ( x1 \\<Rightarrow>* x2); c = ( x1a \\<Rightarrow>* x2a)\\<rbrakk>\n       \\<Longrightarrow> ModalSequents.mset (extend S c) =\n                         ModalSequents.mset S + ModalSequents.mset c", "by (auto simp add: union_ac extend_def)"], ["", "lemma mset_extend_size:\nassumes \"\\<not> (\\<Gamma> = \\<Empt> \\<and> \\<Delta> = \\<Empt>)\"\nshows \"size (mset ((extend (\\<Gamma> \\<Rightarrow>* \\<Delta>) c))) > size (mset c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (ModalSequents.mset c)\n    < size\n       (ModalSequents.mset (extend ( \\<Gamma> \\<Rightarrow>* \\<Delta>) c))", "using assms"], ["proof (prove)\nusing this:\n  \\<not> (\\<Gamma> = \\<Empt> \\<and> \\<Delta> = \\<Empt>)\n\ngoal (1 subgoal):\n 1. size (ModalSequents.mset c)\n    < size\n       (ModalSequents.mset (extend ( \\<Gamma> \\<Rightarrow>* \\<Delta>) c))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<Gamma> = \\<Empt> \\<and> \\<Delta> = \\<Empt>) \\<Longrightarrow>\n    size (ModalSequents.mset c)\n    < size\n       (ModalSequents.mset (extend ( \\<Gamma> \\<Rightarrow>* \\<Delta>) c))", "from assms"], ["proof (chain)\npicking this:\n  \\<not> (\\<Gamma> = \\<Empt> \\<and> \\<Delta> = \\<Empt>)", "have \"mset (\\<Gamma> \\<Rightarrow>* \\<Delta>) \\<noteq> \\<Empt>\""], ["proof (prove)\nusing this:\n  \\<not> (\\<Gamma> = \\<Empt> \\<and> \\<Delta> = \\<Empt>)\n\ngoal (1 subgoal):\n 1. ModalSequents.mset ( \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<noteq> \\<Empt>", "by auto"], ["proof (state)\nthis:\n  ModalSequents.mset ( \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<noteq> \\<Empt>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<Gamma> = \\<Empt> \\<and> \\<Delta> = \\<Empt>) \\<Longrightarrow>\n    size (ModalSequents.mset c)\n    < size\n       (ModalSequents.mset (extend ( \\<Gamma> \\<Rightarrow>* \\<Delta>) c))", "then"], ["proof (chain)\npicking this:\n  ModalSequents.mset ( \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<noteq> \\<Empt>", "have \"size (mset (\\<Gamma> \\<Rightarrow>* \\<Delta>)) > 0\""], ["proof (prove)\nusing this:\n  ModalSequents.mset ( \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<noteq> \\<Empt>\n\ngoal (1 subgoal):\n 1. 0 < size (ModalSequents.mset ( \\<Gamma> \\<Rightarrow>* \\<Delta>))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Delta> = \\<Empt>; \\<Gamma> \\<noteq> \\<Empt>\\<rbrakk>\n    \\<Longrightarrow> 0 < size \\<Gamma>", "by (induct \\<Gamma>) auto"], ["proof (state)\nthis:\n  0 < size (ModalSequents.mset ( \\<Gamma> \\<Rightarrow>* \\<Delta>))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<Gamma> = \\<Empt> \\<and> \\<Delta> = \\<Empt>) \\<Longrightarrow>\n    size (ModalSequents.mset c)\n    < size\n       (ModalSequents.mset (extend ( \\<Gamma> \\<Rightarrow>* \\<Delta>) c))", "moreover"], ["proof (state)\nthis:\n  0 < size (ModalSequents.mset ( \\<Gamma> \\<Rightarrow>* \\<Delta>))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<Gamma> = \\<Empt> \\<and> \\<Delta> = \\<Empt>) \\<Longrightarrow>\n    size (ModalSequents.mset c)\n    < size\n       (ModalSequents.mset (extend ( \\<Gamma> \\<Rightarrow>* \\<Delta>) c))", "have \"mset (extend (\\<Gamma> \\<Rightarrow>* \\<Delta>) c) = mset (\\<Gamma>\\<Rightarrow>*\\<Delta>) + mset c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ModalSequents.mset (extend ( \\<Gamma> \\<Rightarrow>* \\<Delta>) c) =\n    ModalSequents.mset ( \\<Gamma> \\<Rightarrow>* \\<Delta>) +\n    ModalSequents.mset c", "using mset_extend[where S=\"\\<Gamma> \\<Rightarrow>* \\<Delta>\" and c=c]"], ["proof (prove)\nusing this:\n  ModalSequents.mset (extend ( \\<Gamma> \\<Rightarrow>* \\<Delta>) c) =\n  ModalSequents.mset ( \\<Gamma> \\<Rightarrow>* \\<Delta>) +\n  ModalSequents.mset c\n\ngoal (1 subgoal):\n 1. ModalSequents.mset (extend ( \\<Gamma> \\<Rightarrow>* \\<Delta>) c) =\n    ModalSequents.mset ( \\<Gamma> \\<Rightarrow>* \\<Delta>) +\n    ModalSequents.mset c", "by auto"], ["proof (state)\nthis:\n  ModalSequents.mset (extend ( \\<Gamma> \\<Rightarrow>* \\<Delta>) c) =\n  ModalSequents.mset ( \\<Gamma> \\<Rightarrow>* \\<Delta>) +\n  ModalSequents.mset c\n\ngoal (1 subgoal):\n 1. \\<not> (\\<Gamma> = \\<Empt> \\<and> \\<Delta> = \\<Empt>) \\<Longrightarrow>\n    size (ModalSequents.mset c)\n    < size\n       (ModalSequents.mset (extend ( \\<Gamma> \\<Rightarrow>* \\<Delta>) c))", "then"], ["proof (chain)\npicking this:\n  ModalSequents.mset (extend ( \\<Gamma> \\<Rightarrow>* \\<Delta>) c) =\n  ModalSequents.mset ( \\<Gamma> \\<Rightarrow>* \\<Delta>) +\n  ModalSequents.mset c", "have \"size (mset (extend (\\<Gamma> \\<Rightarrow>* \\<Delta>) c)) = size (mset (\\<Gamma> \\<Rightarrow>* \\<Delta>)) + size (mset c)\""], ["proof (prove)\nusing this:\n  ModalSequents.mset (extend ( \\<Gamma> \\<Rightarrow>* \\<Delta>) c) =\n  ModalSequents.mset ( \\<Gamma> \\<Rightarrow>* \\<Delta>) +\n  ModalSequents.mset c\n\ngoal (1 subgoal):\n 1. size\n     (ModalSequents.mset (extend ( \\<Gamma> \\<Rightarrow>* \\<Delta>) c)) =\n    size (ModalSequents.mset ( \\<Gamma> \\<Rightarrow>* \\<Delta>)) +\n    size (ModalSequents.mset c)", "by simp"], ["proof (state)\nthis:\n  size (ModalSequents.mset (extend ( \\<Gamma> \\<Rightarrow>* \\<Delta>) c)) =\n  size (ModalSequents.mset ( \\<Gamma> \\<Rightarrow>* \\<Delta>)) +\n  size (ModalSequents.mset c)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<Gamma> = \\<Empt> \\<and> \\<Delta> = \\<Empt>) \\<Longrightarrow>\n    size (ModalSequents.mset c)\n    < size\n       (ModalSequents.mset (extend ( \\<Gamma> \\<Rightarrow>* \\<Delta>) c))", "ultimately"], ["proof (chain)\npicking this:\n  0 < size (ModalSequents.mset ( \\<Gamma> \\<Rightarrow>* \\<Delta>))\n  size (ModalSequents.mset (extend ( \\<Gamma> \\<Rightarrow>* \\<Delta>) c)) =\n  size (ModalSequents.mset ( \\<Gamma> \\<Rightarrow>* \\<Delta>)) +\n  size (ModalSequents.mset c)", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < size (ModalSequents.mset ( \\<Gamma> \\<Rightarrow>* \\<Delta>))\n  size (ModalSequents.mset (extend ( \\<Gamma> \\<Rightarrow>* \\<Delta>) c)) =\n  size (ModalSequents.mset ( \\<Gamma> \\<Rightarrow>* \\<Delta>)) +\n  size (ModalSequents.mset c)\n\ngoal (1 subgoal):\n 1. size (ModalSequents.mset c)\n    < size\n       (ModalSequents.mset (extend ( \\<Gamma> \\<Rightarrow>* \\<Delta>) c))", "by arith"], ["proof (state)\nthis:\n  size (ModalSequents.mset c)\n  < size (ModalSequents.mset (extend ( \\<Gamma> \\<Rightarrow>* \\<Delta>) c))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extendContain:\nassumes \"r = (ps,c)\"\n    and \"(Ps,C) = extendRule S r\"\n    and \"p \\<in> set ps\"\nshows \"extend S p \\<in> set Ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extend S p \\<in> set Ps", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. extend S p \\<in> set Ps", "from \\<open>p \\<in> set ps\\<close>"], ["proof (chain)\npicking this:\n  p \\<in> set ps", "have \"extend S p \\<in> set (map (extend S) ps)\""], ["proof (prove)\nusing this:\n  p \\<in> set ps\n\ngoal (1 subgoal):\n 1. extend S p \\<in> set (map (extend S) ps)", "by auto"], ["proof (state)\nthis:\n  extend S p \\<in> set (map (extend S) ps)\n\ngoal (1 subgoal):\n 1. extend S p \\<in> set Ps", "moreover"], ["proof (state)\nthis:\n  extend S p \\<in> set (map (extend S) ps)\n\ngoal (1 subgoal):\n 1. extend S p \\<in> set Ps", "from \\<open>(Ps,C) = extendRule S r\\<close> and \\<open>r = (ps,c)\\<close>"], ["proof (chain)\npicking this:\n  (Ps, C) = extendRule S r\n  r = (ps, c)", "have \"map (extend S) ps = Ps\""], ["proof (prove)\nusing this:\n  (Ps, C) = extendRule S r\n  r = (ps, c)\n\ngoal (1 subgoal):\n 1. map (extend S) ps = Ps", "by (simp add:extendRule_def)"], ["proof (state)\nthis:\n  map (extend S) ps = Ps\n\ngoal (1 subgoal):\n 1. extend S p \\<in> set Ps", "ultimately"], ["proof (chain)\npicking this:\n  extend S p \\<in> set (map (extend S) ps)\n  map (extend S) ps = Ps", "show ?thesis"], ["proof (prove)\nusing this:\n  extend S p \\<in> set (map (extend S) ps)\n  map (extend S) ps = Ps\n\ngoal (1 subgoal):\n 1. extend S p \\<in> set Ps", "by auto"], ["proof (state)\nthis:\n  extend S p \\<in> set Ps\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extendCommute:\nshows \"(extend S) (extend R c) = (extend R) (extend S c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extend S (extend R c) = extend R (extend S c)", "by (auto simp add:extend_def union_ac)"], ["", "lemma mapCommute:\nshows \"map (extend S) (map (extend R) c) = map (extend R) (map (extend S) c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (extend S) (map (extend R) c) = map (extend R) (map (extend S) c)", "by (induct_tac c) (auto simp add:extendCommute)"], ["", "lemma extendAssoc:\nshows \"(extend S) (extend R c) = extend (extend S R) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extend S (extend R c) = extend (extend S R) c", "by (auto simp add:extend_def union_ac)"], ["", "lemma mapAssoc:\nshows \"map (extend S) (map (extend R) c) = map (extend (extend S R)) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (extend S) (map (extend R) c) = map (extend (extend S R)) c", "by (induct_tac c) (auto simp add:extendAssoc)"], ["", "(* Disjointness of the various rule sets *)"], ["", "lemma disjoint_Aux:\nassumes \"mset c = \\<LM>A\\<RM>\"\nshows \"A \\<in># mset (extend S c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<in># ModalSequents.mset (extend S c)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<in># ModalSequents.mset (extend S c)", "from assms"], ["proof (chain)\npicking this:\n  ModalSequents.mset c = \\<LM> A  \\<RM>", "have \"c = (\\<Empt> \\<Rightarrow>* \\<LM>A\\<RM>) \\<or> c = (\\<LM>A\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  ModalSequents.mset c = \\<LM> A  \\<RM>\n\ngoal (1 subgoal):\n 1. c = ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<or>\n    c = ( \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>)", "by (cases c) (auto simp add:mset.simps union_is_single)"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<or>\n  c = ( \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. A \\<in># ModalSequents.mset (extend S c)", "then"], ["proof (chain)\npicking this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<or>\n  c = ( \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>)", "show ?thesis"], ["proof (prove)\nusing this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<or>\n  c = ( \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. A \\<in># ModalSequents.mset (extend S c)", "by (auto simp add:extend_def mset.simps)"], ["proof (state)\nthis:\n  A \\<in># ModalSequents.mset (extend S c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma disjoint_Aux2:\nassumes \"mset c = \\<LM>A\\<RM>\"\n    and \"A \\<noteq> B\"\n    and \"mset (extend S c) = \\<LM>B\\<RM>\"\nshows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from assms"], ["proof (chain)\npicking this:\n  ModalSequents.mset c = \\<LM> A  \\<RM>\n  A \\<noteq> B\n  ModalSequents.mset (extend S c) = \\<LM> B  \\<RM>", "have \"A \\<in># \\<LM>B\\<RM>\""], ["proof (prove)\nusing this:\n  ModalSequents.mset c = \\<LM> A  \\<RM>\n  A \\<noteq> B\n  ModalSequents.mset (extend S c) = \\<LM> B  \\<RM>\n\ngoal (1 subgoal):\n 1. A \\<in># \\<LM> B  \\<RM>", "using disjoint_Aux[where c=c and A=A and S=S]"], ["proof (prove)\nusing this:\n  ModalSequents.mset c = \\<LM> A  \\<RM>\n  A \\<noteq> B\n  ModalSequents.mset (extend S c) = \\<LM> B  \\<RM>\n  ModalSequents.mset c = \\<LM> A  \\<RM> \\<Longrightarrow>\n  A \\<in># ModalSequents.mset (extend S c)\n\ngoal (1 subgoal):\n 1. A \\<in># \\<LM> B  \\<RM>", "by auto"], ["proof (state)\nthis:\n  A \\<in># \\<LM> B  \\<RM>\n\ngoal (1 subgoal):\n 1. False", "with \\<open>A \\<noteq> B\\<close>"], ["proof (chain)\npicking this:\n  A \\<noteq> B\n  A \\<in># \\<LM> B  \\<RM>", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<noteq> B\n  A \\<in># \\<LM> B  \\<RM>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma disjoint_Ax_up:\nshows \"Ax \\<inter> upRules = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ax \\<inter> upRules = {}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Ax; (a, b) \\<in> upRules\\<rbrakk>\n       \\<Longrightarrow> False", "apply (rule Ax.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Ax; (a, b) \\<in> upRules\\<rbrakk>\n       \\<Longrightarrow> (?a1.4 a b, ?a2.4 a b) \\<in> Ax\n 2. \\<And>a b i.\n       \\<lbrakk>(a, b) \\<in> Ax; (a, b) \\<in> upRules; ?a1.4 a b = [];\n        ?a2.4 a b =\n        ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Ax; (a, b) \\<in> upRules; ?a1.4 a b = [];\n        ?a2.4 a b = ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n                \\<in> Ax;\n        ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n        \\<in> upRules\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax;\n     ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> upRules\\<rbrakk>\n    \\<Longrightarrow> False", "by (rotate_tac 1,rule upRules.cases,auto)+"], ["", "lemma disjoint_Ax_mod2:\nshows \"Ax \\<inter> modRules2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ax \\<inter> modRules2 = {}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Ax; (a, b) \\<in> modRules2\\<rbrakk>\n       \\<Longrightarrow> False", "apply (rule Ax.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Ax; (a, b) \\<in> modRules2\\<rbrakk>\n       \\<Longrightarrow> (?a1.4 a b, ?a2.4 a b) \\<in> Ax\n 2. \\<And>a b i.\n       \\<lbrakk>(a, b) \\<in> Ax; (a, b) \\<in> modRules2; ?a1.4 a b = [];\n        ?a2.4 a b =\n        ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Ax; (a, b) \\<in> modRules2; ?a1.4 a b = [];\n        ?a2.4 a b = ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n                \\<in> Ax;\n        ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n        \\<in> modRules2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax;\n     ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> modRules2\\<rbrakk>\n    \\<Longrightarrow> False", "by (rotate_tac 1,rule modRules2.cases,auto)+"], ["", "lemma disjoint_Ax_mod1:\nshows \"Ax \\<inter> p_e modRules2 M N = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ax \\<inter> p_e modRules2 M N = {}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Ax; (a, b) \\<in> p_e modRules2 M N\\<rbrakk>\n       \\<Longrightarrow> False", "apply (rule Ax.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Ax; (a, b) \\<in> p_e modRules2 M N\\<rbrakk>\n       \\<Longrightarrow> (?a1.4 a b, ?a2.4 a b) \\<in> Ax\n 2. \\<And>a b i.\n       \\<lbrakk>(a, b) \\<in> Ax; (a, b) \\<in> p_e modRules2 M N;\n        ?a1.4 a b = [];\n        ?a2.4 a b =\n        ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> Ax; (a, b) \\<in> p_e modRules2 M N;\n        ?a1.4 a b = [];\n        ?a2.4 a b = ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n                \\<in> Ax;\n        ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n        \\<in> p_e modRules2 M N\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax;\n     ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n     \\<in> p_e modRules2 M N\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule p_e.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n                \\<in> Ax;\n        ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n        \\<in> p_e modRules2 M N\\<rbrakk>\n       \\<Longrightarrow> ?a12 i \\<in> p_e (?R12 i) (?M12 i) (?N12 i)\n 2. \\<And>i Ps c \\<Gamma> \\<Delta>.\n       \\<lbrakk>([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n                \\<in> Ax;\n        ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n        \\<in> p_e modRules2 M N;\n        ?a12 i =\n        extendRule\n         ( ?M12 i \\<cdot> \\<Gamma> \\<Rightarrow>* ?N12 i \\<cdot> \\<Delta>)\n         (Ps, c);\n        (Ps, c) \\<in> ?R12 i; ?R12 i \\<subseteq> modRules2\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<lbrakk>([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax;\n     ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n     \\<in> p_e modRules2 M N\\<rbrakk>\n    \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i Ps c \\<Gamma> \\<Delta>.\n       \\<lbrakk>extendRule\n                 ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n                 (Ps, c)\n                \\<in> Ax;\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Ps, c)\n        \\<in> p_e modRules2 M N;\n        ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Ps, c);\n        (Ps, c) \\<in> modRules2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax;\n     ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n     \\<in> p_e modRules2 M N\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule modRules2.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i Ps c \\<Gamma> \\<Delta>.\n       \\<lbrakk>extendRule\n                 ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n                 (Ps, c)\n                \\<in> Ax;\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Ps, c)\n        \\<in> p_e modRules2 M N;\n        ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Ps, c);\n        (Ps, c) \\<in> modRules2\\<rbrakk>\n       \\<Longrightarrow> (?a1.15 i Ps c \\<Gamma> \\<Delta>,\n                          ?a2.15 i Ps c \\<Gamma> \\<Delta>)\n                         \\<in> modRules2\n 2. \\<And>i Ps c \\<Gamma> \\<Delta> ps ca Ma Ms.\n       \\<lbrakk>extendRule\n                 ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n                 (Ps, c)\n                \\<in> Ax;\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Ps, c)\n        \\<in> p_e modRules2 M N;\n        ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Ps, c);\n        (Ps, c) \\<in> modRules2; ?a1.15 i Ps c \\<Gamma> \\<Delta> = ps;\n        ?a2.15 i Ps c \\<Gamma> \\<Delta> = ca; ps \\<noteq> [];\n        ModalSequents.mset ca = \\<LM> Modal Ma Ms  \\<RM>\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<lbrakk>([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax;\n     ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n     \\<in> p_e modRules2 M N\\<rbrakk>\n    \\<Longrightarrow> False", "apply (auto simp add:extendRule_def extend_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax;\n     ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n     \\<in> p_e modRules2 M N\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule p_e.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax;\n     ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n     \\<in> p_e modRules2 M N\\<rbrakk>\n    \\<Longrightarrow> ?a22 \\<in> p_e ?R22 ?M22 ?N22\n 2. \\<And>Ps c \\<Gamma> \\<Delta>.\n       \\<lbrakk>([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax;\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n        \\<in> p_e modRules2 M N;\n        ?a22 =\n        extendRule\n         ( ?M22 \\<cdot> \\<Gamma> \\<Rightarrow>* ?N22 \\<cdot> \\<Delta>)\n         (Ps, c);\n        (Ps, c) \\<in> ?R22; ?R22 \\<subseteq> modRules2\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps c \\<Gamma> \\<Delta>.\n       \\<lbrakk>extendRule\n                 ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n                 (Ps, c)\n                \\<in> Ax;\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Ps, c)\n        \\<in> p_e modRules2 M N;\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Ps, c);\n        (Ps, c) \\<in> modRules2\\<rbrakk>\n       \\<Longrightarrow> False", "apply (rule modRules2.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Ps c \\<Gamma> \\<Delta>.\n       \\<lbrakk>extendRule\n                 ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n                 (Ps, c)\n                \\<in> Ax;\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Ps, c)\n        \\<in> p_e modRules2 M N;\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Ps, c);\n        (Ps, c) \\<in> modRules2\\<rbrakk>\n       \\<Longrightarrow> (?a1.25 Ps c \\<Gamma> \\<Delta>,\n                          ?a2.25 Ps c \\<Gamma> \\<Delta>)\n                         \\<in> modRules2\n 2. \\<And>Ps c \\<Gamma> \\<Delta> ps ca Ma Ms.\n       \\<lbrakk>extendRule\n                 ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n                 (Ps, c)\n                \\<in> Ax;\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Ps, c)\n        \\<in> p_e modRules2 M N;\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Ps, c);\n        (Ps, c) \\<in> modRules2; ?a1.25 Ps c \\<Gamma> \\<Delta> = ps;\n        ?a2.25 Ps c \\<Gamma> \\<Delta> = ca; ps \\<noteq> [];\n        ModalSequents.mset ca = \\<LM> Modal Ma Ms  \\<RM>\\<rbrakk>\n       \\<Longrightarrow> False", "by (auto simp add:extendRule_def extend_def)"], ["", "lemma disjoint_up_mod2:\nshows \"upRules \\<inter> modRules2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upRules \\<inter> modRules2 = {}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> upRules; (a, b) \\<in> modRules2\\<rbrakk>\n       \\<Longrightarrow> False", "apply (rule upRules.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> upRules; (a, b) \\<in> modRules2\\<rbrakk>\n       \\<Longrightarrow> (?a1.4 a b, ?a2.4 a b) \\<in> upRules\n 2. \\<And>a b c R Fs ps.\n       \\<lbrakk>(a, b) \\<in> upRules; (a, b) \\<in> modRules2;\n        ?a1.4 a b = ps; ?a2.4 a b = c;\n        ModalSequents.mset c = \\<LM> Compound R Fs  \\<RM>;\n        ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c R Fs ps.\n       \\<lbrakk>(ps, c) \\<in> upRules; (ps, c) \\<in> modRules2;\n        ModalSequents.mset c = \\<LM> Compound R Fs  \\<RM>;\n        ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False", "by (rotate_tac 1,rule modRules2.cases,auto)"], ["", "lemma disjoint_up_mod1:\nshows \"upRules \\<inter> p_e modRules2 M N = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upRules \\<inter> p_e modRules2 M N = {}", "using disjoint_Aux2"], ["proof (prove)\nusing this:\n  \\<lbrakk>ModalSequents.mset ?c = \\<LM> ?A  \\<RM>; ?A \\<noteq> ?B;\n   ModalSequents.mset (extend ?S ?c) = \\<LM> ?B  \\<RM>\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. upRules \\<inter> p_e modRules2 M N = {}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>c A B S.\n                   \\<lbrakk>ModalSequents.mset c = \\<LM> A  \\<RM>;\n                    A \\<noteq> B;\n                    ModalSequents.mset (extend S c) =\n                    \\<LM> B  \\<RM>\\<rbrakk>\n                   \\<Longrightarrow> False;\n        (a, b) \\<in> upRules; (a, b) \\<in> p_e modRules2 M N\\<rbrakk>\n       \\<Longrightarrow> False", "apply (rule upRules.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>c A B S.\n                   \\<lbrakk>ModalSequents.mset c = \\<LM> A  \\<RM>;\n                    A \\<noteq> B;\n                    ModalSequents.mset (extend S c) =\n                    \\<LM> B  \\<RM>\\<rbrakk>\n                   \\<Longrightarrow> False;\n        (a, b) \\<in> upRules; (a, b) \\<in> p_e modRules2 M N\\<rbrakk>\n       \\<Longrightarrow> (?a1.6 a b, ?a2.6 a b) \\<in> upRules\n 2. \\<And>a b c R Fs ps.\n       \\<lbrakk>\\<And>c A B S.\n                   \\<lbrakk>ModalSequents.mset c = \\<LM> A  \\<RM>;\n                    A \\<noteq> B;\n                    ModalSequents.mset (extend S c) =\n                    \\<LM> B  \\<RM>\\<rbrakk>\n                   \\<Longrightarrow> False;\n        (a, b) \\<in> upRules; (a, b) \\<in> p_e modRules2 M N;\n        ?a1.6 a b = ps; ?a2.6 a b = c;\n        ModalSequents.mset c = \\<LM> Compound R Fs  \\<RM>;\n        ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c R Fs ps.\n       \\<lbrakk>\\<And>c A B S.\n                   \\<lbrakk>ModalSequents.mset c = \\<LM> A  \\<RM>;\n                    A \\<noteq> B;\n                    ModalSequents.mset (extend S c) =\n                    \\<LM> B  \\<RM>\\<rbrakk>\n                   \\<Longrightarrow> False;\n        (ps, c) \\<in> upRules; (ps, c) \\<in> p_e modRules2 M N;\n        ModalSequents.mset c = \\<LM> Compound R Fs  \\<RM>;\n        ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> False", "apply (rule p_e.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c R Fs ps.\n       \\<lbrakk>\\<And>c A B S.\n                   \\<lbrakk>ModalSequents.mset c = \\<LM> A  \\<RM>;\n                    A \\<noteq> B;\n                    ModalSequents.mset (extend S c) =\n                    \\<LM> B  \\<RM>\\<rbrakk>\n                   \\<Longrightarrow> False;\n        (ps, c) \\<in> upRules; (ps, c) \\<in> p_e modRules2 M N;\n        ModalSequents.mset c = \\<LM> Compound R Fs  \\<RM>;\n        ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ?a11 c R Fs ps\n                         \\<in> p_e (?R11 c R Fs ps) (?M11 c R Fs ps)\n                                (?N11 c R Fs ps)\n 2. \\<And>c R Fs ps Ps ca \\<Gamma> \\<Delta>.\n       \\<lbrakk>\\<And>c A B S.\n                   \\<lbrakk>ModalSequents.mset c = \\<LM> A  \\<RM>;\n                    A \\<noteq> B;\n                    ModalSequents.mset (extend S c) =\n                    \\<LM> B  \\<RM>\\<rbrakk>\n                   \\<Longrightarrow> False;\n        (ps, c) \\<in> upRules; (ps, c) \\<in> p_e modRules2 M N;\n        ModalSequents.mset c = \\<LM> Compound R Fs  \\<RM>; ps \\<noteq> [];\n        ?a11 c R Fs ps =\n        extendRule\n         ( ?M11 c R Fs ps \\<cdot>\n           \\<Gamma> \\<Rightarrow>* ?N11 c R Fs ps \\<cdot> \\<Delta>)\n         (Ps, ca);\n        (Ps, ca) \\<in> ?R11 c R Fs ps;\n        ?R11 c R Fs ps \\<subseteq> modRules2\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c R Fs ps Ps ca \\<Gamma> \\<Delta>.\n       \\<lbrakk>\\<And>c A B S.\n                   \\<lbrakk>ModalSequents.mset c = \\<LM> A  \\<RM>;\n                    A \\<noteq> B;\n                    ModalSequents.mset (extend S c) =\n                    \\<LM> B  \\<RM>\\<rbrakk>\n                   \\<Longrightarrow> False;\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Ps, ca)\n        \\<in> upRules;\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Ps, ca)\n        \\<in> p_e modRules2 M N;\n        ModalSequents.mset c = \\<LM> Compound R Fs  \\<RM>; ps \\<noteq> [];\n        (ps, c) =\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Ps, ca);\n        (Ps, ca) \\<in> modRules2\\<rbrakk>\n       \\<Longrightarrow> False", "apply (rule modRules2.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c R Fs ps Ps ca \\<Gamma> \\<Delta>.\n       \\<lbrakk>\\<And>c A B S.\n                   \\<lbrakk>ModalSequents.mset c = \\<LM> A  \\<RM>;\n                    A \\<noteq> B;\n                    ModalSequents.mset (extend S c) =\n                    \\<LM> B  \\<RM>\\<rbrakk>\n                   \\<Longrightarrow> False;\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Ps, ca)\n        \\<in> upRules;\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Ps, ca)\n        \\<in> p_e modRules2 M N;\n        ModalSequents.mset c = \\<LM> Compound R Fs  \\<RM>; ps \\<noteq> [];\n        (ps, c) =\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Ps, ca);\n        (Ps, ca) \\<in> modRules2\\<rbrakk>\n       \\<Longrightarrow> (?a1.14 c R Fs ps Ps ca \\<Gamma> \\<Delta>,\n                          ?a2.14 c R Fs ps Ps ca \\<Gamma> \\<Delta>)\n                         \\<in> modRules2\n 2. \\<And>c R Fs ps Ps ca \\<Gamma> \\<Delta> psa cb Ma Ms.\n       \\<lbrakk>\\<And>c A B S.\n                   \\<lbrakk>ModalSequents.mset c = \\<LM> A  \\<RM>;\n                    A \\<noteq> B;\n                    ModalSequents.mset (extend S c) =\n                    \\<LM> B  \\<RM>\\<rbrakk>\n                   \\<Longrightarrow> False;\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Ps, ca)\n        \\<in> upRules;\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Ps, ca)\n        \\<in> p_e modRules2 M N;\n        ModalSequents.mset c = \\<LM> Compound R Fs  \\<RM>; ps \\<noteq> [];\n        (ps, c) =\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Ps, ca);\n        (Ps, ca) \\<in> modRules2;\n        ?a1.14 c R Fs ps Ps ca \\<Gamma> \\<Delta> = psa;\n        ?a2.14 c R Fs ps Ps ca \\<Gamma> \\<Delta> = cb; psa \\<noteq> [];\n        ModalSequents.mset cb = \\<LM> Modal Ma Ms  \\<RM>\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto simp add:extendRule_def extend_def union_ac)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>R Fs \\<Gamma> \\<Delta> psa cb Ma Ms.\n       \\<lbrakk>\\<And>c A B S.\n                   \\<lbrakk>ModalSequents.mset c = \\<LM> A  \\<RM>;\n                    A \\<noteq> B;\n                    antec c + (antec S + (succ c + succ S)) =\n                    \\<LM> B  \\<RM>\\<rbrakk>\n                   \\<Longrightarrow> False;\n        (map (extend\n               ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>))\n          psa,\n          antec cb +\n          M \\<cdot> \\<Gamma> \\<Rightarrow>* succ cb + N \\<cdot> \\<Delta>)\n        \\<in> upRules;\n        (map (extend\n               ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>))\n          psa,\n          antec cb +\n          M \\<cdot> \\<Gamma> \\<Rightarrow>* succ cb + N \\<cdot> \\<Delta>)\n        \\<in> p_e modRules2 M N;\n        antec cb + (succ cb + (M \\<cdot> \\<Gamma> + N \\<cdot> \\<Delta>)) =\n        \\<LM> Compound R Fs  \\<RM>;\n        (psa, cb) \\<in> modRules2; psa \\<noteq> [];\n        ModalSequents.mset cb = \\<LM> Modal Ma Ms  \\<RM>\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule_tac x=cb in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>R Fs \\<Gamma> \\<Delta> psa cb Ma Ms.\n       \\<lbrakk>(map (extend\n                       ( M \\<cdot>\n                         \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>))\n                  psa,\n                  antec cb +\n                  M \\<cdot>\n                  \\<Gamma> \\<Rightarrow>* succ cb + N \\<cdot> \\<Delta>)\n                \\<in> upRules;\n        (map (extend\n               ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>))\n          psa,\n          antec cb +\n          M \\<cdot> \\<Gamma> \\<Rightarrow>* succ cb + N \\<cdot> \\<Delta>)\n        \\<in> p_e modRules2 M N;\n        antec cb + (succ cb + (M \\<cdot> \\<Gamma> + N \\<cdot> \\<Delta>)) =\n        \\<LM> Compound R Fs  \\<RM>;\n        (psa, cb) \\<in> modRules2; psa \\<noteq> [];\n        ModalSequents.mset cb = \\<LM> Modal Ma Ms  \\<RM>;\n        \\<And>A B S.\n           \\<lbrakk>ModalSequents.mset cb = \\<LM> A  \\<RM>; A \\<noteq> B;\n            antec cb + (antec S + (succ cb + succ S)) =\n            \\<LM> B  \\<RM>\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule_tac x=\"Modal Ma Ms\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>R Fs \\<Gamma> \\<Delta> psa cb Ma Ms.\n       \\<lbrakk>(map (extend\n                       ( M \\<cdot>\n                         \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>))\n                  psa,\n                  antec cb +\n                  M \\<cdot>\n                  \\<Gamma> \\<Rightarrow>* succ cb + N \\<cdot> \\<Delta>)\n                \\<in> upRules;\n        (map (extend\n               ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>))\n          psa,\n          antec cb +\n          M \\<cdot> \\<Gamma> \\<Rightarrow>* succ cb + N \\<cdot> \\<Delta>)\n        \\<in> p_e modRules2 M N;\n        antec cb + (succ cb + (M \\<cdot> \\<Gamma> + N \\<cdot> \\<Delta>)) =\n        \\<LM> Compound R Fs  \\<RM>;\n        (psa, cb) \\<in> modRules2; psa \\<noteq> [];\n        ModalSequents.mset cb = \\<LM> Modal Ma Ms  \\<RM>;\n        \\<And>B S.\n           \\<lbrakk>ModalSequents.mset cb = \\<LM> Modal Ma Ms  \\<RM>;\n            Modal Ma Ms \\<noteq> B;\n            antec cb + (antec S + (succ cb + succ S)) =\n            \\<LM> B  \\<RM>\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule_tac x=\"Compound R Fs\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>R Fs \\<Gamma> \\<Delta> psa cb Ma Ms.\n       \\<lbrakk>(map (extend\n                       ( M \\<cdot>\n                         \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>))\n                  psa,\n                  antec cb +\n                  M \\<cdot>\n                  \\<Gamma> \\<Rightarrow>* succ cb + N \\<cdot> \\<Delta>)\n                \\<in> upRules;\n        (map (extend\n               ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>))\n          psa,\n          antec cb +\n          M \\<cdot> \\<Gamma> \\<Rightarrow>* succ cb + N \\<cdot> \\<Delta>)\n        \\<in> p_e modRules2 M N;\n        antec cb + (succ cb + (M \\<cdot> \\<Gamma> + N \\<cdot> \\<Delta>)) =\n        \\<LM> Compound R Fs  \\<RM>;\n        (psa, cb) \\<in> modRules2; psa \\<noteq> [];\n        ModalSequents.mset cb = \\<LM> Modal Ma Ms  \\<RM>;\n        \\<And>S.\n           \\<lbrakk>ModalSequents.mset cb = \\<LM> Modal Ma Ms  \\<RM>;\n            Modal Ma Ms \\<noteq> Compound R Fs;\n            antec cb + (antec S + (succ cb + succ S)) =\n            \\<LM> Compound R Fs  \\<RM>\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule_tac x=\"M\\<cdot>\\<Gamma> \\<Rightarrow>* N\\<cdot>\\<Delta>\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>R Fs \\<Gamma> \\<Delta> psa cb Ma Ms.\n       \\<lbrakk>(map (extend\n                       ( M \\<cdot>\n                         \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>))\n                  psa,\n                  antec cb +\n                  M \\<cdot>\n                  \\<Gamma> \\<Rightarrow>* succ cb + N \\<cdot> \\<Delta>)\n                \\<in> upRules;\n        (map (extend\n               ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>))\n          psa,\n          antec cb +\n          M \\<cdot> \\<Gamma> \\<Rightarrow>* succ cb + N \\<cdot> \\<Delta>)\n        \\<in> p_e modRules2 M N;\n        antec cb + (succ cb + (M \\<cdot> \\<Gamma> + N \\<cdot> \\<Delta>)) =\n        \\<LM> Compound R Fs  \\<RM>;\n        (psa, cb) \\<in> modRules2; psa \\<noteq> [];\n        ModalSequents.mset cb = \\<LM> Modal Ma Ms  \\<RM>;\n        \\<lbrakk>ModalSequents.mset cb = \\<LM> Modal Ma Ms  \\<RM>;\n         Modal Ma Ms \\<noteq> Compound R Fs;\n         antec cb +\n         (antec ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>) +\n          (succ cb +\n           succ ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>))) =\n         \\<LM> Compound R Fs  \\<RM>\\<rbrakk>\n        \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> False", "by (auto simp:union_ac)"], ["", "lemmas disjoint = disjoint_Ax_up disjoint_Ax_mod1 disjoint_Ax_mod2 \n                  disjoint_up_mod2 disjoint_up_mod1"], ["", "lemma Ax_subset_false_aux:\nassumes \"A \\<subseteq> B\" and \"A \\<inter> B = {}\" and \"A \\<noteq> {}\"\nshows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from \\<open>A \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  A \\<noteq> {}", "have \"\\<exists> a. a \\<in> A\""], ["proof (prove)\nusing this:\n  A \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>a. a \\<in> A", "by auto"], ["proof (state)\nthis:\n  \\<exists>a. a \\<in> A\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  \\<exists>a. a \\<in> A", "obtain a where a: \"a \\<in> A\""], ["proof (prove)\nusing this:\n  \\<exists>a. a \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<And>a. a \\<in> A \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. False", "with \\<open>A \\<subseteq> B\\<close>"], ["proof (chain)\npicking this:\n  A \\<subseteq> B\n  a \\<in> A", "have \"a \\<in> B\""], ["proof (prove)\nusing this:\n  A \\<subseteq> B\n  a \\<in> A\n\ngoal (1 subgoal):\n 1. a \\<in> B", "by auto"], ["proof (state)\nthis:\n  a \\<in> B\n\ngoal (1 subgoal):\n 1. False", "with a"], ["proof (chain)\npicking this:\n  a \\<in> A\n  a \\<in> B", "have \"a \\<in> A \\<inter> B\""], ["proof (prove)\nusing this:\n  a \\<in> A\n  a \\<in> B\n\ngoal (1 subgoal):\n 1. a \\<in> A \\<inter> B", "by simp"], ["proof (state)\nthis:\n  a \\<in> A \\<inter> B\n\ngoal (1 subgoal):\n 1. False", "with \\<open>A \\<inter> B = {}\\<close>"], ["proof (chain)\npicking this:\n  A \\<inter> B = {}\n  a \\<in> A \\<inter> B", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<inter> B = {}\n  a \\<in> A \\<inter> B\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Ax_subset_false:\nassumes \"Ax \\<subseteq> modRules2\"\nshows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have a: \"([],\\<LM>ff\\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax", "by auto"], ["proof (state)\nthis:\n  ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax", "have \"Ax \\<noteq> {}\""], ["proof (prove)\nusing this:\n  ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax\n\ngoal (1 subgoal):\n 1. Ax \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  Ax \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "with disjoint_Ax_mod2 and assms"], ["proof (chain)\npicking this:\n  Ax \\<inter> modRules2 = {}\n  Ax \\<subseteq> modRules2\n  Ax \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  Ax \\<inter> modRules2 = {}\n  Ax \\<subseteq> modRules2\n  Ax \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "using Ax_subset_false_aux[where A=Ax and B=\"modRules2\"]"], ["proof (prove)\nusing this:\n  Ax \\<inter> modRules2 = {}\n  Ax \\<subseteq> modRules2\n  Ax \\<noteq> {}\n  \\<lbrakk>Ax \\<subseteq> modRules2; Ax \\<inter> modRules2 = {};\n   Ax \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma modal_not_contain:\nassumes \"M \\<noteq> N\"\nshows \"\\<not> (Modal M A \\<in># N\\<cdot>\\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Modal M A \\<notin># N \\<cdot> \\<Gamma>", "using assms"], ["proof (prove)\nusing this:\n  M \\<noteq> N\n\ngoal (1 subgoal):\n 1. Modal M A \\<notin># N \\<cdot> \\<Gamma>", "by (induct \\<Gamma>) (auto simp add:modaliseMultiset_def)"], ["", "lemma nonPrincipalID:\nfixes A :: \"('a,'b) form\"\nassumes \"r \\<in> Ax\"\nshows \"\\<not> rightPrincipal r A R \\<and> \\<not> leftPrincipal r A R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r A R \\<and> \\<not> leftPrincipal r A R", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r A R \\<and> \\<not> leftPrincipal r A R", "from assms"], ["proof (chain)\npicking this:\n  r \\<in> Ax", "obtain i where r1:\"r = ([], \\<LM> ff \\<RM> \\<Rightarrow>* \\<Empt>) \\<or> r = ([], \\<LM> At i \\<RM> \\<Rightarrow>* \\<LM> At i\\<RM>)\""], ["proof (prove)\nusing this:\n  r \\<in> Ax\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n        r =\n        ([],\n          \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At\n            i  \\<RM>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using characteriseAx[where r=r]"], ["proof (prove)\nusing this:\n  r \\<in> Ax\n  r \\<in> Ax \\<Longrightarrow>\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n  (\\<exists>i.\n      r = ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n        r =\n        ([],\n          \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At\n            i  \\<RM>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n  r = ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r A R \\<and> \\<not> leftPrincipal r A R", "{"], ["proof (state)\nthis:\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n  r = ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r A R \\<and> \\<not> leftPrincipal r A R", "assume \"rightPrincipal r A R\""], ["proof (state)\nthis:\n  rightPrincipal r A R\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r A R \\<and> \\<not> leftPrincipal r A R", "then"], ["proof (chain)\npicking this:\n  rightPrincipal r A R", "obtain Ps where r2:\"r = (Ps, \\<Empt> \\<Rightarrow>* \\<LM> A \\<RM>)\""], ["proof (prove)\nusing this:\n  rightPrincipal r A R\n\ngoal (1 subgoal):\n 1. (\\<And>Ps.\n        r = (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases r) auto"], ["proof (state)\nthis:\n  r = (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r A R \\<and> \\<not> leftPrincipal r A R", "with r1 and disjoint and \\<open>r \\<in> Ax\\<close>"], ["proof (chain)\npicking this:\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n  r = ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n  Ax \\<inter> upRules = {}\n  Ax \\<inter> p_e modRules2 ?M ?N = {}\n  Ax \\<inter> modRules2 = {}\n  upRules \\<inter> modRules2 = {}\n  upRules \\<inter> p_e modRules2 ?M ?N = {}\n  r \\<in> Ax\n  r = (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)", "have \"False\""], ["proof (prove)\nusing this:\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n  r = ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n  Ax \\<inter> upRules = {}\n  Ax \\<inter> p_e modRules2 ?M ?N = {}\n  Ax \\<inter> modRules2 = {}\n  upRules \\<inter> modRules2 = {}\n  upRules \\<inter> p_e modRules2 ?M ?N = {}\n  r \\<in> Ax\n  r = (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r A R \\<and> \\<not> leftPrincipal r A R", "}"], ["proof (state)\nthis:\n  rightPrincipal r A R \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r A R \\<and> \\<not> leftPrincipal r A R", "then"], ["proof (chain)\npicking this:\n  rightPrincipal r A R \\<Longrightarrow> False", "have \"\\<not> rightPrincipal r A R\""], ["proof (prove)\nusing this:\n  rightPrincipal r A R \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r A R", "by auto"], ["proof (state)\nthis:\n  \\<not> rightPrincipal r A R\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r A R \\<and> \\<not> leftPrincipal r A R", "moreover"], ["proof (state)\nthis:\n  \\<not> rightPrincipal r A R\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r A R \\<and> \\<not> leftPrincipal r A R", "{"], ["proof (state)\nthis:\n  \\<not> rightPrincipal r A R\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r A R \\<and> \\<not> leftPrincipal r A R", "assume \"leftPrincipal r A R\""], ["proof (state)\nthis:\n  leftPrincipal r A R\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r A R \\<and> \\<not> leftPrincipal r A R", "then"], ["proof (chain)\npicking this:\n  leftPrincipal r A R", "obtain Ps' \n          where r3:\"r = (Ps', \\<LM>A\\<RM> \\<Rightarrow>* \\<Empt>) \\<and> A \\<noteq> ff\""], ["proof (prove)\nusing this:\n  leftPrincipal r A R\n\ngoal (1 subgoal):\n 1. (\\<And>Ps'.\n        r = (Ps',  \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>) \\<and>\n        A \\<noteq> ff \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases r) auto"], ["proof (state)\nthis:\n  r = (Ps',  \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>) \\<and> A \\<noteq> ff\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r A R \\<and> \\<not> leftPrincipal r A R", "with r1 and disjoint and \\<open>r \\<in> Ax\\<close>"], ["proof (chain)\npicking this:\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n  r = ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n  Ax \\<inter> upRules = {}\n  Ax \\<inter> p_e modRules2 ?M ?N = {}\n  Ax \\<inter> modRules2 = {}\n  upRules \\<inter> modRules2 = {}\n  upRules \\<inter> p_e modRules2 ?M ?N = {}\n  r \\<in> Ax\n  r = (Ps',  \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>) \\<and> A \\<noteq> ff", "have \"False\""], ["proof (prove)\nusing this:\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n  r = ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n  Ax \\<inter> upRules = {}\n  Ax \\<inter> p_e modRules2 ?M ?N = {}\n  Ax \\<inter> modRules2 = {}\n  upRules \\<inter> modRules2 = {}\n  upRules \\<inter> p_e modRules2 ?M ?N = {}\n  r \\<in> Ax\n  r = (Ps',  \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>) \\<and> A \\<noteq> ff\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r A R \\<and> \\<not> leftPrincipal r A R", "}"], ["proof (state)\nthis:\n  leftPrincipal r A R \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r A R \\<and> \\<not> leftPrincipal r A R", "then"], ["proof (chain)\npicking this:\n  leftPrincipal r A R \\<Longrightarrow> False", "have \"\\<not> leftPrincipal r A R\""], ["proof (prove)\nusing this:\n  leftPrincipal r A R \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> leftPrincipal r A R", "by auto"], ["proof (state)\nthis:\n  \\<not> leftPrincipal r A R\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r A R \\<and> \\<not> leftPrincipal r A R", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> rightPrincipal r A R\n  \\<not> leftPrincipal r A R", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> rightPrincipal r A R\n  \\<not> leftPrincipal r A R\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r A R \\<and> \\<not> leftPrincipal r A R", "by simp"], ["proof (state)\nthis:\n  \\<not> rightPrincipal r A R \\<and> \\<not> leftPrincipal r A R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compound_not_in_modal_multi:\nshows \"\\<not> (Compound M Ms \\<in># N\\<cdot>\\<Gamma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Compound M Ms \\<notin># N \\<cdot> \\<Gamma>", "by (induct \\<Gamma>) (auto simp add:modaliseMultiset_def)"], ["", "lemma not_principal_aux:\nassumes \"mset c = \\<LM>Modal T Ts\\<RM>\"\n    and \"M\\<cdot>\\<Gamma> + succ c = N\\<cdot>\\<Delta> \\<oplus> Compound F Fs\"\nshows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from assms and single_is_union"], ["proof (chain)\npicking this:\n  ModalSequents.mset c = \\<LM> Modal T Ts  \\<RM>\n  M \\<cdot> \\<Gamma> + succ c = N \\<cdot> \\<Delta> \\<oplus> Compound F Fs\n  (\\<LM> ?a  \\<RM> = ?M + ?N) =\n  (\\<LM> ?a  \\<RM> = ?M \\<and> ?N = \\<Empt> \\<or>\n   ?M = \\<Empt> \\<and> \\<LM> ?a  \\<RM> = ?N)", "have \"c = (\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<or> c = (\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  ModalSequents.mset c = \\<LM> Modal T Ts  \\<RM>\n  M \\<cdot> \\<Gamma> + succ c = N \\<cdot> \\<Delta> \\<oplus> Compound F Fs\n  (\\<LM> ?a  \\<RM> = ?M + ?N) =\n  (\\<LM> ?a  \\<RM> = ?M \\<and> ?N = \\<Empt> \\<or>\n   ?M = \\<Empt> \\<and> \\<LM> ?a  \\<RM> = ?N)\n\ngoal (1 subgoal):\n 1. c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n    c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)", "apply (cases c)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>ModalSequents.mset c = \\<LM> Modal T Ts  \\<RM>;\n        M \\<cdot> \\<Gamma> + succ c =\n        N \\<cdot> \\<Delta> \\<oplus> Compound F Fs;\n        \\<And>a M N.\n           (\\<LM> a  \\<RM> = M + N) =\n           (\\<LM> a  \\<RM> = M \\<and> N = \\<Empt> \\<or>\n            M = \\<Empt> \\<and> \\<LM> a  \\<RM> = N);\n        c = ( x1 \\<Rightarrow>* x2)\\<rbrakk>\n       \\<Longrightarrow> c =\n                         ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T\n                   Ts  \\<RM>) \\<or>\n                         c =\n                         ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)", "apply (rename_tac multiset1 multiset2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>multiset1 multiset2.\n       \\<lbrakk>ModalSequents.mset c = \\<LM> Modal T Ts  \\<RM>;\n        M \\<cdot> \\<Gamma> + succ c =\n        N \\<cdot> \\<Delta> \\<oplus> Compound F Fs;\n        \\<And>a M N.\n           (\\<LM> a  \\<RM> = M + N) =\n           (\\<LM> a  \\<RM> = M \\<and> N = \\<Empt> \\<or>\n            M = \\<Empt> \\<and> \\<LM> a  \\<RM> = N);\n        c = ( multiset1 \\<Rightarrow>* multiset2)\\<rbrakk>\n       \\<Longrightarrow> c =\n                         ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T\n                   Ts  \\<RM>) \\<or>\n                         c =\n                         ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>multiset1 multiset2.\n       \\<lbrakk>multiset1 + multiset2 = \\<LM> Modal T Ts  \\<RM>;\n        M \\<cdot> \\<Gamma> + multiset2 =\n        add_mset (Compound F Fs) (N \\<cdot> \\<Delta>);\n        \\<And>a M N.\n           (\\<LM> a  \\<RM> = M + N) =\n           (\\<LM> a  \\<RM> = M \\<and> N = \\<Empt> \\<or>\n            M = \\<Empt> \\<and> \\<LM> a  \\<RM> = N);\n        c = ( multiset1 \\<Rightarrow>* multiset2);\n        multiset1 \\<noteq> \\<LM> Modal T Ts  \\<RM>\\<rbrakk>\n       \\<Longrightarrow> multiset1 = \\<Empt>\n 2. \\<And>multiset1 multiset2.\n       \\<lbrakk>multiset1 + multiset2 = \\<LM> Modal T Ts  \\<RM>;\n        M \\<cdot> \\<Gamma> + multiset2 =\n        add_mset (Compound F Fs) (N \\<cdot> \\<Delta>);\n        \\<And>a M N.\n           (\\<LM> a  \\<RM> = M + N) =\n           (\\<LM> a  \\<RM> = M \\<and> N = \\<Empt> \\<or>\n            M = \\<Empt> \\<and> \\<LM> a  \\<RM> = N);\n        c = ( multiset1 \\<Rightarrow>* multiset2);\n        multiset1 \\<noteq> \\<LM> Modal T Ts  \\<RM>\\<rbrakk>\n       \\<Longrightarrow> multiset2 = \\<LM> Modal T Ts  \\<RM>\n 3. \\<And>multiset1 multiset2.\n       \\<lbrakk>multiset1 + multiset2 = \\<LM> Modal T Ts  \\<RM>;\n        M \\<cdot> \\<Gamma> + multiset2 =\n        add_mset (Compound F Fs) (N \\<cdot> \\<Delta>);\n        \\<And>a M N.\n           (\\<LM> a  \\<RM> = M + N) =\n           (\\<LM> a  \\<RM> = M \\<and> N = \\<Empt> \\<or>\n            M = \\<Empt> \\<and> \\<LM> a  \\<RM> = N);\n        c = ( multiset1 \\<Rightarrow>* multiset2);\n        multiset2 \\<noteq> \\<Empt>\\<rbrakk>\n       \\<Longrightarrow> multiset1 = \\<Empt>\n 4. \\<And>multiset1 multiset2.\n       \\<lbrakk>multiset1 + multiset2 = \\<LM> Modal T Ts  \\<RM>;\n        M \\<cdot> \\<Gamma> + multiset2 =\n        add_mset (Compound F Fs) (N \\<cdot> \\<Delta>);\n        \\<And>a M N.\n           (\\<LM> a  \\<RM> = M + N) =\n           (\\<LM> a  \\<RM> = M \\<and> N = \\<Empt> \\<or>\n            M = \\<Empt> \\<and> \\<LM> a  \\<RM> = N);\n        c = ( multiset1 \\<Rightarrow>* multiset2);\n        multiset2 \\<noteq> \\<Empt>\\<rbrakk>\n       \\<Longrightarrow> multiset2 = \\<LM> Modal T Ts  \\<RM>", "by (drule_tac x=\"Modal T Ts\" in meta_spec,drule_tac x=\"multiset1\" in meta_spec,\n         drule_tac x=\"multiset2\" in meta_spec,simp)+"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. False", "{"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. False", "assume \"c = (\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>)\""], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n\ngoal (1 subgoal):\n 1. False", "with assms"], ["proof (chain)\npicking this:\n  ModalSequents.mset c = \\<LM> Modal T Ts  \\<RM>\n  M \\<cdot> \\<Gamma> + succ c = N \\<cdot> \\<Delta> \\<oplus> Compound F Fs\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)", "have \"M\\<cdot>\\<Gamma> \\<oplus> Modal T Ts = N\\<cdot>\\<Delta> \\<oplus> Compound F Fs\""], ["proof (prove)\nusing this:\n  ModalSequents.mset c = \\<LM> Modal T Ts  \\<RM>\n  M \\<cdot> \\<Gamma> + succ c = N \\<cdot> \\<Delta> \\<oplus> Compound F Fs\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n\ngoal (1 subgoal):\n 1. M \\<cdot> \\<Gamma> \\<oplus> Modal T Ts =\n    N \\<cdot> \\<Delta> \\<oplus> Compound F Fs", "by auto"], ["proof (state)\nthis:\n  M \\<cdot> \\<Gamma> \\<oplus> Modal T Ts =\n  N \\<cdot> \\<Delta> \\<oplus> Compound F Fs\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  M \\<cdot> \\<Gamma> \\<oplus> Modal T Ts =\n  N \\<cdot> \\<Delta> \\<oplus> Compound F Fs", "have \"Compound F Fs \\<in># M\\<cdot>\\<Gamma> \\<oplus> Modal T Ts\""], ["proof (prove)\nusing this:\n  M \\<cdot> \\<Gamma> \\<oplus> Modal T Ts =\n  N \\<cdot> \\<Delta> \\<oplus> Compound F Fs\n\ngoal (1 subgoal):\n 1. Compound F Fs \\<in># M \\<cdot> \\<Gamma> \\<oplus> Modal T Ts", "by auto"], ["proof (state)\nthis:\n  Compound F Fs \\<in># M \\<cdot> \\<Gamma> \\<oplus> Modal T Ts\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  Compound F Fs \\<in># M \\<cdot> \\<Gamma> \\<oplus> Modal T Ts", "have \"Compound F Fs \\<in># M\\<cdot>\\<Gamma>\""], ["proof (prove)\nusing this:\n  Compound F Fs \\<in># M \\<cdot> \\<Gamma> \\<oplus> Modal T Ts\n\ngoal (1 subgoal):\n 1. Compound F Fs \\<in># M \\<cdot> \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  Compound F Fs \\<in># M \\<cdot> \\<Gamma>\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  Compound F Fs \\<in># M \\<cdot> \\<Gamma>", "have \"False\""], ["proof (prove)\nusing this:\n  Compound F Fs \\<in># M \\<cdot> \\<Gamma>\n\ngoal (1 subgoal):\n 1. False", "using compound_not_in_modal_multi[where M=F and Ms=Fs and N=M and \\<Gamma>=\\<Gamma>]"], ["proof (prove)\nusing this:\n  Compound F Fs \\<in># M \\<cdot> \\<Gamma>\n  Compound F Fs \\<notin># M \\<cdot> \\<Gamma>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. False", "}"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. False", "{"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. False", "assume \"c = (\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (state)\nthis:\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. False", "with assms"], ["proof (chain)\npicking this:\n  ModalSequents.mset c = \\<LM> Modal T Ts  \\<RM>\n  M \\<cdot> \\<Gamma> + succ c = N \\<cdot> \\<Delta> \\<oplus> Compound F Fs\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"Compound F Fs \\<in># M\\<cdot>\\<Gamma>\""], ["proof (prove)\nusing this:\n  ModalSequents.mset c = \\<LM> Modal T Ts  \\<RM>\n  M \\<cdot> \\<Gamma> + succ c = N \\<cdot> \\<Delta> \\<oplus> Compound F Fs\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. Compound F Fs \\<in># M \\<cdot> \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  Compound F Fs \\<in># M \\<cdot> \\<Gamma>\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  Compound F Fs \\<in># M \\<cdot> \\<Gamma>", "have \"False\""], ["proof (prove)\nusing this:\n  Compound F Fs \\<in># M \\<cdot> \\<Gamma>\n\ngoal (1 subgoal):\n 1. False", "using compound_not_in_modal_multi[where M=F and Ms=Fs and N=M and \\<Gamma>=\\<Gamma>]"], ["proof (prove)\nusing this:\n  Compound F Fs \\<in># M \\<cdot> \\<Gamma>\n  Compound F Fs \\<notin># M \\<cdot> \\<Gamma>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. False", "}"], ["proof (state)\nthis:\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  False\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  False\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_principal_aux2:\nassumes \"mset c = \\<LM>Modal T Ts\\<RM>\"\n    and \"M\\<cdot>\\<Gamma> + antec c = N\\<cdot>\\<Delta> \\<oplus> Compound F Fs\"\nshows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from assms and single_is_union"], ["proof (chain)\npicking this:\n  ModalSequents.mset c = \\<LM> Modal T Ts  \\<RM>\n  M \\<cdot> \\<Gamma> + antec c = N \\<cdot> \\<Delta> \\<oplus> Compound F Fs\n  (\\<LM> ?a  \\<RM> = ?M + ?N) =\n  (\\<LM> ?a  \\<RM> = ?M \\<and> ?N = \\<Empt> \\<or>\n   ?M = \\<Empt> \\<and> \\<LM> ?a  \\<RM> = ?N)", "have \"c = (\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<or> c = (\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  ModalSequents.mset c = \\<LM> Modal T Ts  \\<RM>\n  M \\<cdot> \\<Gamma> + antec c = N \\<cdot> \\<Delta> \\<oplus> Compound F Fs\n  (\\<LM> ?a  \\<RM> = ?M + ?N) =\n  (\\<LM> ?a  \\<RM> = ?M \\<and> ?N = \\<Empt> \\<or>\n   ?M = \\<Empt> \\<and> \\<LM> ?a  \\<RM> = ?N)\n\ngoal (1 subgoal):\n 1. c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n    c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)", "apply (cases c)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>ModalSequents.mset c = \\<LM> Modal T Ts  \\<RM>;\n        M \\<cdot> \\<Gamma> + antec c =\n        N \\<cdot> \\<Delta> \\<oplus> Compound F Fs;\n        \\<And>a M N.\n           (\\<LM> a  \\<RM> = M + N) =\n           (\\<LM> a  \\<RM> = M \\<and> N = \\<Empt> \\<or>\n            M = \\<Empt> \\<and> \\<LM> a  \\<RM> = N);\n        c = ( x1 \\<Rightarrow>* x2)\\<rbrakk>\n       \\<Longrightarrow> c =\n                         ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T\n                   Ts  \\<RM>) \\<or>\n                         c =\n                         ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)", "apply (rename_tac multiset1 multiset2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>multiset1 multiset2.\n       \\<lbrakk>ModalSequents.mset c = \\<LM> Modal T Ts  \\<RM>;\n        M \\<cdot> \\<Gamma> + antec c =\n        N \\<cdot> \\<Delta> \\<oplus> Compound F Fs;\n        \\<And>a M N.\n           (\\<LM> a  \\<RM> = M + N) =\n           (\\<LM> a  \\<RM> = M \\<and> N = \\<Empt> \\<or>\n            M = \\<Empt> \\<and> \\<LM> a  \\<RM> = N);\n        c = ( multiset1 \\<Rightarrow>* multiset2)\\<rbrakk>\n       \\<Longrightarrow> c =\n                         ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T\n                   Ts  \\<RM>) \\<or>\n                         c =\n                         ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)", "apply (auto simp add:mset.simps)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>multiset1 multiset2.\n       \\<lbrakk>multiset1 + multiset2 = \\<LM> Modal T Ts  \\<RM>;\n        M \\<cdot> \\<Gamma> + multiset1 =\n        add_mset (Compound F Fs) (N \\<cdot> \\<Delta>);\n        \\<And>a M N.\n           (\\<LM> a  \\<RM> = M + N) =\n           (\\<LM> a  \\<RM> = M \\<and> N = \\<Empt> \\<or>\n            M = \\<Empt> \\<and> \\<LM> a  \\<RM> = N);\n        c = ( multiset1 \\<Rightarrow>* multiset2);\n        multiset1 \\<noteq> \\<LM> Modal T Ts  \\<RM>\\<rbrakk>\n       \\<Longrightarrow> multiset1 = \\<Empt>\n 2. \\<And>multiset1 multiset2.\n       \\<lbrakk>multiset1 + multiset2 = \\<LM> Modal T Ts  \\<RM>;\n        M \\<cdot> \\<Gamma> + multiset1 =\n        add_mset (Compound F Fs) (N \\<cdot> \\<Delta>);\n        \\<And>a M N.\n           (\\<LM> a  \\<RM> = M + N) =\n           (\\<LM> a  \\<RM> = M \\<and> N = \\<Empt> \\<or>\n            M = \\<Empt> \\<and> \\<LM> a  \\<RM> = N);\n        c = ( multiset1 \\<Rightarrow>* multiset2);\n        multiset1 \\<noteq> \\<LM> Modal T Ts  \\<RM>\\<rbrakk>\n       \\<Longrightarrow> multiset2 = \\<LM> Modal T Ts  \\<RM>\n 3. \\<And>multiset1 multiset2.\n       \\<lbrakk>multiset1 + multiset2 = \\<LM> Modal T Ts  \\<RM>;\n        M \\<cdot> \\<Gamma> + multiset1 =\n        add_mset (Compound F Fs) (N \\<cdot> \\<Delta>);\n        \\<And>a M N.\n           (\\<LM> a  \\<RM> = M + N) =\n           (\\<LM> a  \\<RM> = M \\<and> N = \\<Empt> \\<or>\n            M = \\<Empt> \\<and> \\<LM> a  \\<RM> = N);\n        c = ( multiset1 \\<Rightarrow>* multiset2);\n        multiset2 \\<noteq> \\<Empt>\\<rbrakk>\n       \\<Longrightarrow> multiset1 = \\<Empt>\n 4. \\<And>multiset1 multiset2.\n       \\<lbrakk>multiset1 + multiset2 = \\<LM> Modal T Ts  \\<RM>;\n        M \\<cdot> \\<Gamma> + multiset1 =\n        add_mset (Compound F Fs) (N \\<cdot> \\<Delta>);\n        \\<And>a M N.\n           (\\<LM> a  \\<RM> = M + N) =\n           (\\<LM> a  \\<RM> = M \\<and> N = \\<Empt> \\<or>\n            M = \\<Empt> \\<and> \\<LM> a  \\<RM> = N);\n        c = ( multiset1 \\<Rightarrow>* multiset2);\n        multiset2 \\<noteq> \\<Empt>\\<rbrakk>\n       \\<Longrightarrow> multiset2 = \\<LM> Modal T Ts  \\<RM>", "by (drule_tac x=\"Modal T Ts\" in meta_spec,drule_tac x=\"multiset1\" in meta_spec,\n         drule_tac x=\"multiset2\" in meta_spec,simp)+"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. False", "{"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. False", "assume \"c = (\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>)\""], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n\ngoal (1 subgoal):\n 1. False", "with assms"], ["proof (chain)\npicking this:\n  ModalSequents.mset c = \\<LM> Modal T Ts  \\<RM>\n  M \\<cdot> \\<Gamma> + antec c = N \\<cdot> \\<Delta> \\<oplus> Compound F Fs\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)", "have \"Compound F Fs \\<in># M\\<cdot>\\<Gamma>\""], ["proof (prove)\nusing this:\n  ModalSequents.mset c = \\<LM> Modal T Ts  \\<RM>\n  M \\<cdot> \\<Gamma> + antec c = N \\<cdot> \\<Delta> \\<oplus> Compound F Fs\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n\ngoal (1 subgoal):\n 1. Compound F Fs \\<in># M \\<cdot> \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  Compound F Fs \\<in># M \\<cdot> \\<Gamma>\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  Compound F Fs \\<in># M \\<cdot> \\<Gamma>", "have \"False\""], ["proof (prove)\nusing this:\n  Compound F Fs \\<in># M \\<cdot> \\<Gamma>\n\ngoal (1 subgoal):\n 1. False", "using compound_not_in_modal_multi[where M=F and Ms=Fs and N=M and \\<Gamma>=\\<Gamma>]"], ["proof (prove)\nusing this:\n  Compound F Fs \\<in># M \\<cdot> \\<Gamma>\n  Compound F Fs \\<notin># M \\<cdot> \\<Gamma>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. False", "}"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. False", "moreover"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. False", "{"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. False", "assume \"c = (\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (state)\nthis:\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. False", "with assms"], ["proof (chain)\npicking this:\n  ModalSequents.mset c = \\<LM> Modal T Ts  \\<RM>\n  M \\<cdot> \\<Gamma> + antec c = N \\<cdot> \\<Delta> \\<oplus> Compound F Fs\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"M\\<cdot>\\<Gamma> \\<oplus> Modal T Ts = N\\<cdot>\\<Delta> \\<oplus> Compound F Fs\""], ["proof (prove)\nusing this:\n  ModalSequents.mset c = \\<LM> Modal T Ts  \\<RM>\n  M \\<cdot> \\<Gamma> + antec c = N \\<cdot> \\<Delta> \\<oplus> Compound F Fs\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. M \\<cdot> \\<Gamma> \\<oplus> Modal T Ts =\n    N \\<cdot> \\<Delta> \\<oplus> Compound F Fs", "by auto"], ["proof (state)\nthis:\n  M \\<cdot> \\<Gamma> \\<oplus> Modal T Ts =\n  N \\<cdot> \\<Delta> \\<oplus> Compound F Fs\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  M \\<cdot> \\<Gamma> \\<oplus> Modal T Ts =\n  N \\<cdot> \\<Delta> \\<oplus> Compound F Fs", "have \"Compound F Fs \\<in># M\\<cdot>\\<Gamma> \\<oplus> Modal T Ts\""], ["proof (prove)\nusing this:\n  M \\<cdot> \\<Gamma> \\<oplus> Modal T Ts =\n  N \\<cdot> \\<Delta> \\<oplus> Compound F Fs\n\ngoal (1 subgoal):\n 1. Compound F Fs \\<in># M \\<cdot> \\<Gamma> \\<oplus> Modal T Ts", "by auto"], ["proof (state)\nthis:\n  Compound F Fs \\<in># M \\<cdot> \\<Gamma> \\<oplus> Modal T Ts\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  Compound F Fs \\<in># M \\<cdot> \\<Gamma> \\<oplus> Modal T Ts", "have \"Compound F Fs \\<in># M\\<cdot>\\<Gamma>\""], ["proof (prove)\nusing this:\n  Compound F Fs \\<in># M \\<cdot> \\<Gamma> \\<oplus> Modal T Ts\n\ngoal (1 subgoal):\n 1. Compound F Fs \\<in># M \\<cdot> \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  Compound F Fs \\<in># M \\<cdot> \\<Gamma>\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  Compound F Fs \\<in># M \\<cdot> \\<Gamma>", "have \"False\""], ["proof (prove)\nusing this:\n  Compound F Fs \\<in># M \\<cdot> \\<Gamma>\n\ngoal (1 subgoal):\n 1. False", "using compound_not_in_modal_multi[where M=F and Ms=Fs and N=M and \\<Gamma>=\\<Gamma>]"], ["proof (prove)\nusing this:\n  Compound F Fs \\<in># M \\<cdot> \\<Gamma>\n  Compound F Fs \\<notin># M \\<cdot> \\<Gamma>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. False", "}"], ["proof (state)\nthis:\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. False", "ultimately"], ["proof (chain)\npicking this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  False\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  False\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma modRules_not_right_principal_for_compound:\nassumes \"r \\<in> p_e modRules2 S T\"\nshows \"\\<not> rightPrincipal r (Compound M Ms) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (Compound M Ms) R", "using assms"], ["proof (prove)\nusing this:\n  r \\<in> p_e modRules2 S T\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (Compound M Ms) R", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<in> p_e modRules2 S T \\<Longrightarrow>\n    \\<not> rightPrincipal r (Compound M Ms) R", "from assms"], ["proof (chain)\npicking this:\n  r \\<in> p_e modRules2 S T", "have \"fst r \\<noteq> []\""], ["proof (prove)\nusing this:\n  r \\<in> p_e modRules2 S T\n\ngoal (1 subgoal):\n 1. fst r \\<noteq> []", "apply (rule p_e.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps c \\<Gamma> \\<Delta>.\n       \\<lbrakk>r =\n                extendRule\n                 ( S \\<cdot> \\<Gamma> \\<Rightarrow>* T \\<cdot> \\<Delta>)\n                 (Ps, c);\n        (Ps, c) \\<in> modRules2; modRules2 \\<subseteq> modRules2\\<rbrakk>\n       \\<Longrightarrow> fst r \\<noteq> []", "apply (insert modRule2Characterise)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps c \\<Gamma> \\<Delta>.\n       \\<lbrakk>r =\n                extendRule\n                 ( S \\<cdot> \\<Gamma> \\<Rightarrow>* T \\<cdot> \\<Delta>)\n                 (Ps, c);\n        (Ps, c) \\<in> modRules2; modRules2 \\<subseteq> modRules2;\n        \\<And>Ps C.\n           (Ps, C) \\<in> modRules2 \\<Longrightarrow>\n           Ps \\<noteq> [] \\<and>\n           (\\<exists>F Fs.\n               C = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n               C =\n               ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))\\<rbrakk>\n       \\<Longrightarrow> fst r \\<noteq> []", "apply (drule_tac x=Ps in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps c \\<Gamma> \\<Delta>.\n       \\<lbrakk>r =\n                extendRule\n                 ( S \\<cdot> \\<Gamma> \\<Rightarrow>* T \\<cdot> \\<Delta>)\n                 (Ps, c);\n        (Ps, c) \\<in> modRules2; modRules2 \\<subseteq> modRules2;\n        \\<And>C.\n           (Ps, C) \\<in> modRules2 \\<Longrightarrow>\n           Ps \\<noteq> [] \\<and>\n           (\\<exists>F Fs.\n               C = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n               C =\n               ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))\\<rbrakk>\n       \\<Longrightarrow> fst r \\<noteq> []", "apply (drule_tac x=c in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps c \\<Gamma> \\<Delta>.\n       \\<lbrakk>r =\n                extendRule\n                 ( S \\<cdot> \\<Gamma> \\<Rightarrow>* T \\<cdot> \\<Delta>)\n                 (Ps, c);\n        (Ps, c) \\<in> modRules2; modRules2 \\<subseteq> modRules2;\n        (Ps, c) \\<in> modRules2 \\<Longrightarrow>\n        Ps \\<noteq> [] \\<and>\n        (\\<exists>F Fs.\n            c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n            c = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))\\<rbrakk>\n       \\<Longrightarrow> fst r \\<noteq> []", "by (auto simp add:extendRule_def)"], ["proof (state)\nthis:\n  fst r \\<noteq> []\n\ngoal (1 subgoal):\n 1. r \\<in> p_e modRules2 S T \\<Longrightarrow>\n    \\<not> rightPrincipal r (Compound M Ms) R", "{"], ["proof (state)\nthis:\n  fst r \\<noteq> []\n\ngoal (1 subgoal):\n 1. r \\<in> p_e modRules2 S T \\<Longrightarrow>\n    \\<not> rightPrincipal r (Compound M Ms) R", "assume \"rightPrincipal r (Compound M Ms) R\""], ["proof (state)\nthis:\n  rightPrincipal r (Compound M Ms) R\n\ngoal (1 subgoal):\n 1. r \\<in> p_e modRules2 S T \\<Longrightarrow>\n    \\<not> rightPrincipal r (Compound M Ms) R", "with assms"], ["proof (chain)\npicking this:\n  r \\<in> p_e modRules2 S T\n  rightPrincipal r (Compound M Ms) R", "obtain ps c where \"r = (ps,c)\" and \"c = (\\<Empt> \\<Rightarrow>* \\<LM>Compound M Ms\\<RM>)\""], ["proof (prove)\nusing this:\n  r \\<in> p_e modRules2 S T\n  rightPrincipal r (Compound M Ms) R\n\ngoal (1 subgoal):\n 1. (\\<And>ps c.\n        \\<lbrakk>r = (ps, c);\n         c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound M Ms  \\<RM>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using not_principal_aux"], ["proof (prove)\nusing this:\n  r \\<in> p_e modRules2 S T\n  rightPrincipal r (Compound M Ms) R\n  \\<lbrakk>ModalSequents.mset ?c = \\<LM> Modal ?T ?Ts  \\<RM>;\n   ?M \\<cdot> ?\\<Gamma> + succ ?c =\n   ?N \\<cdot> ?\\<Delta> \\<oplus> Compound ?F ?Fs\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (\\<And>ps c.\n        \\<lbrakk>r = (ps, c);\n         c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound M Ms  \\<RM>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (cases r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps c \\<Gamma> \\<Delta>.\n       \\<lbrakk>\\<And>ps c.\n                   \\<lbrakk>r = (ps, c);\n                    c =\n                    ( \\<Empt> \\<Rightarrow>* \\<LM> Compound M\n              Ms  \\<RM>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        rightPrincipal r (Compound M Ms) R;\n        \\<And>c T Ts M \\<Gamma> N \\<Delta> F Fs.\n           \\<lbrakk>ModalSequents.mset c = \\<LM> Modal T Ts  \\<RM>;\n            M \\<cdot> \\<Gamma> + succ c =\n            N \\<cdot> \\<Delta> \\<oplus> Compound F Fs\\<rbrakk>\n           \\<Longrightarrow> False;\n        r =\n        extendRule ( S \\<cdot> \\<Gamma> \\<Rightarrow>* T \\<cdot> \\<Delta>)\n         (Ps, c);\n        (Ps, c) \\<in> modRules2; modRules2 \\<subseteq> modRules2\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (rule rightPrincipal.cases) auto"], ["proof (state)\nthis:\n  r = (ps, c)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound M Ms  \\<RM>)\n\ngoal (1 subgoal):\n 1. r \\<in> p_e modRules2 S T \\<Longrightarrow>\n    \\<not> rightPrincipal r (Compound M Ms) R", "then"], ["proof (chain)\npicking this:\n  r = (ps, c)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound M Ms  \\<RM>)", "have \"r \\<in> upRules\""], ["proof (prove)\nusing this:\n  r = (ps, c)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound M Ms  \\<RM>)\n\ngoal (1 subgoal):\n 1. r \\<in> upRules", "using \\<open>fst r \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  r = (ps, c)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound M Ms  \\<RM>)\n  fst r \\<noteq> []\n\ngoal (1 subgoal):\n 1. r \\<in> upRules", "by auto"], ["proof (state)\nthis:\n  r \\<in> upRules\n\ngoal (1 subgoal):\n 1. r \\<in> p_e modRules2 S T \\<Longrightarrow>\n    \\<not> rightPrincipal r (Compound M Ms) R", "with assms"], ["proof (chain)\npicking this:\n  r \\<in> p_e modRules2 S T\n  r \\<in> upRules", "have \"False\""], ["proof (prove)\nusing this:\n  r \\<in> p_e modRules2 S T\n  r \\<in> upRules\n\ngoal (1 subgoal):\n 1. False", "using disjoint_up_mod1[where M=S and N=T]"], ["proof (prove)\nusing this:\n  r \\<in> p_e modRules2 S T\n  r \\<in> upRules\n  upRules \\<inter> p_e modRules2 S T = {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. r \\<in> p_e modRules2 S T \\<Longrightarrow>\n    \\<not> rightPrincipal r (Compound M Ms) R", "}"], ["proof (state)\nthis:\n  rightPrincipal r (Compound M Ms) R \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. r \\<in> p_e modRules2 S T \\<Longrightarrow>\n    \\<not> rightPrincipal r (Compound M Ms) R", "thus ?thesis"], ["proof (prove)\nusing this:\n  rightPrincipal r (Compound M Ms) R \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (Compound M Ms) R", "by auto"], ["proof (state)\nthis:\n  \\<not> rightPrincipal r (Compound M Ms) R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma modRules_not_left_principal_for_compound:\nassumes \"r \\<in> p_e modRules2 T S\"\nshows \"\\<not> leftPrincipal r (Compound M Ms) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> leftPrincipal r (Compound M Ms) R", "using assms"], ["proof (prove)\nusing this:\n  r \\<in> p_e modRules2 T S\n\ngoal (1 subgoal):\n 1. \\<not> leftPrincipal r (Compound M Ms) R", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<in> p_e modRules2 T S \\<Longrightarrow>\n    \\<not> leftPrincipal r (Compound M Ms) R", "from assms"], ["proof (chain)\npicking this:\n  r \\<in> p_e modRules2 T S", "have \"fst r \\<noteq> []\""], ["proof (prove)\nusing this:\n  r \\<in> p_e modRules2 T S\n\ngoal (1 subgoal):\n 1. fst r \\<noteq> []", "apply (rule p_e.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps c \\<Gamma> \\<Delta>.\n       \\<lbrakk>r =\n                extendRule\n                 ( T \\<cdot> \\<Gamma> \\<Rightarrow>* S \\<cdot> \\<Delta>)\n                 (Ps, c);\n        (Ps, c) \\<in> modRules2; modRules2 \\<subseteq> modRules2\\<rbrakk>\n       \\<Longrightarrow> fst r \\<noteq> []", "apply (insert modRule2Characterise)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps c \\<Gamma> \\<Delta>.\n       \\<lbrakk>r =\n                extendRule\n                 ( T \\<cdot> \\<Gamma> \\<Rightarrow>* S \\<cdot> \\<Delta>)\n                 (Ps, c);\n        (Ps, c) \\<in> modRules2; modRules2 \\<subseteq> modRules2;\n        \\<And>Ps C.\n           (Ps, C) \\<in> modRules2 \\<Longrightarrow>\n           Ps \\<noteq> [] \\<and>\n           (\\<exists>F Fs.\n               C = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n               C =\n               ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))\\<rbrakk>\n       \\<Longrightarrow> fst r \\<noteq> []", "apply (drule_tac x=Ps in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps c \\<Gamma> \\<Delta>.\n       \\<lbrakk>r =\n                extendRule\n                 ( T \\<cdot> \\<Gamma> \\<Rightarrow>* S \\<cdot> \\<Delta>)\n                 (Ps, c);\n        (Ps, c) \\<in> modRules2; modRules2 \\<subseteq> modRules2;\n        \\<And>C.\n           (Ps, C) \\<in> modRules2 \\<Longrightarrow>\n           Ps \\<noteq> [] \\<and>\n           (\\<exists>F Fs.\n               C = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n               C =\n               ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))\\<rbrakk>\n       \\<Longrightarrow> fst r \\<noteq> []", "apply (drule_tac x=c in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps c \\<Gamma> \\<Delta>.\n       \\<lbrakk>r =\n                extendRule\n                 ( T \\<cdot> \\<Gamma> \\<Rightarrow>* S \\<cdot> \\<Delta>)\n                 (Ps, c);\n        (Ps, c) \\<in> modRules2; modRules2 \\<subseteq> modRules2;\n        (Ps, c) \\<in> modRules2 \\<Longrightarrow>\n        Ps \\<noteq> [] \\<and>\n        (\\<exists>F Fs.\n            c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n            c = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))\\<rbrakk>\n       \\<Longrightarrow> fst r \\<noteq> []", "by (auto simp add:extendRule_def)"], ["proof (state)\nthis:\n  fst r \\<noteq> []\n\ngoal (1 subgoal):\n 1. r \\<in> p_e modRules2 T S \\<Longrightarrow>\n    \\<not> leftPrincipal r (Compound M Ms) R", "{"], ["proof (state)\nthis:\n  fst r \\<noteq> []\n\ngoal (1 subgoal):\n 1. r \\<in> p_e modRules2 T S \\<Longrightarrow>\n    \\<not> leftPrincipal r (Compound M Ms) R", "assume \"leftPrincipal r (Compound M Ms) R\""], ["proof (state)\nthis:\n  leftPrincipal r (Compound M Ms) R\n\ngoal (1 subgoal):\n 1. r \\<in> p_e modRules2 T S \\<Longrightarrow>\n    \\<not> leftPrincipal r (Compound M Ms) R", "with assms"], ["proof (chain)\npicking this:\n  r \\<in> p_e modRules2 T S\n  leftPrincipal r (Compound M Ms) R", "obtain ps c where \"r = (ps,c)\" and \"c = (\\<LM>Compound M Ms\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  r \\<in> p_e modRules2 T S\n  leftPrincipal r (Compound M Ms) R\n\ngoal (1 subgoal):\n 1. (\\<And>ps c.\n        \\<lbrakk>r = (ps, c);\n         c = ( \\<LM> Compound M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using not_principal_aux2"], ["proof (prove)\nusing this:\n  r \\<in> p_e modRules2 T S\n  leftPrincipal r (Compound M Ms) R\n  \\<lbrakk>ModalSequents.mset ?c = \\<LM> Modal ?T ?Ts  \\<RM>;\n   ?M \\<cdot> ?\\<Gamma> + antec ?c =\n   ?N \\<cdot> ?\\<Delta> \\<oplus> Compound ?F ?Fs\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (\\<And>ps c.\n        \\<lbrakk>r = (ps, c);\n         c = ( \\<LM> Compound M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (cases r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps c \\<Gamma> \\<Delta>.\n       \\<lbrakk>\\<And>ps c.\n                   \\<lbrakk>r = (ps, c);\n                    c =\n                    ( \\<LM> Compound M\n                             Ms  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        leftPrincipal r (Compound M Ms) R;\n        \\<And>c T Ts M \\<Gamma> N \\<Delta> F Fs.\n           \\<lbrakk>ModalSequents.mset c = \\<LM> Modal T Ts  \\<RM>;\n            M \\<cdot> \\<Gamma> + antec c =\n            N \\<cdot> \\<Delta> \\<oplus> Compound F Fs\\<rbrakk>\n           \\<Longrightarrow> False;\n        r =\n        extendRule ( T \\<cdot> \\<Gamma> \\<Rightarrow>* S \\<cdot> \\<Delta>)\n         (Ps, c);\n        (Ps, c) \\<in> modRules2; modRules2 \\<subseteq> modRules2\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (rule leftPrincipal.cases) auto"], ["proof (state)\nthis:\n  r = (ps, c)\n  c = ( \\<LM> Compound M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. r \\<in> p_e modRules2 T S \\<Longrightarrow>\n    \\<not> leftPrincipal r (Compound M Ms) R", "then"], ["proof (chain)\npicking this:\n  r = (ps, c)\n  c = ( \\<LM> Compound M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"r \\<in> upRules\""], ["proof (prove)\nusing this:\n  r = (ps, c)\n  c = ( \\<LM> Compound M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. r \\<in> upRules", "using \\<open>fst r \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  r = (ps, c)\n  c = ( \\<LM> Compound M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)\n  fst r \\<noteq> []\n\ngoal (1 subgoal):\n 1. r \\<in> upRules", "by auto"], ["proof (state)\nthis:\n  r \\<in> upRules\n\ngoal (1 subgoal):\n 1. r \\<in> p_e modRules2 T S \\<Longrightarrow>\n    \\<not> leftPrincipal r (Compound M Ms) R", "with assms"], ["proof (chain)\npicking this:\n  r \\<in> p_e modRules2 T S\n  r \\<in> upRules", "have \"False\""], ["proof (prove)\nusing this:\n  r \\<in> p_e modRules2 T S\n  r \\<in> upRules\n\ngoal (1 subgoal):\n 1. False", "using disjoint_up_mod1[where M=T and N=S]"], ["proof (prove)\nusing this:\n  r \\<in> p_e modRules2 T S\n  r \\<in> upRules\n  upRules \\<inter> p_e modRules2 T S = {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. r \\<in> p_e modRules2 T S \\<Longrightarrow>\n    \\<not> leftPrincipal r (Compound M Ms) R", "}"], ["proof (state)\nthis:\n  leftPrincipal r (Compound M Ms) R \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. r \\<in> p_e modRules2 T S \\<Longrightarrow>\n    \\<not> leftPrincipal r (Compound M Ms) R", "thus ?thesis"], ["proof (prove)\nusing this:\n  leftPrincipal r (Compound M Ms) R \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> leftPrincipal r (Compound M Ms) R", "by auto"], ["proof (state)\nthis:\n  \\<not> leftPrincipal r (Compound M Ms) R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma modRules2_not_left_principal_for_compound:\nassumes \"r \\<in> modRules2\"\nshows \"\\<not> leftPrincipal r (Compound M Ms) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> leftPrincipal r (Compound M Ms) R", "using assms"], ["proof (prove)\nusing this:\n  r \\<in> modRules2\n\ngoal (1 subgoal):\n 1. \\<not> leftPrincipal r (Compound M Ms) R", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<in> modRules2 \\<Longrightarrow>\n    \\<not> leftPrincipal r (Compound M Ms) R", "from assms"], ["proof (chain)\npicking this:\n  r \\<in> modRules2", "obtain ps T Ts where \"r = (ps,\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<or> r = (ps,\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  r \\<in> modRules2\n\ngoal (1 subgoal):\n 1. (\\<And>ps T Ts.\n        r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n        r =\n        (ps,\n          \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using modRule2Characterise"], ["proof (prove)\nusing this:\n  r \\<in> modRules2\n  (?Ps, ?C) \\<in> modRules2 \\<Longrightarrow>\n  ?Ps \\<noteq> [] \\<and>\n  (\\<exists>F Fs.\n      ?C = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n      ?C = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))\n\ngoal (1 subgoal):\n 1. (\\<And>ps T Ts.\n        r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n        r =\n        (ps,\n          \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply (cases r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>ps T Ts.\n                   r =\n                   (ps,\n                     \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n                   r =\n                   (ps,\n                     \\<LM> Modal T\n                            Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n                   thesis;\n        r \\<in> modRules2;\n        \\<And>Ps C.\n           (Ps, C) \\<in> modRules2 \\<Longrightarrow>\n           Ps \\<noteq> [] \\<and>\n           (\\<exists>F Fs.\n               C = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n               C = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>));\n        r = (a, b)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>ps T Ts.\n                   a = ps \\<and>\n                   b =\n                   ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n                   a = ps \\<and>\n                   b =\n                   ( \\<LM> Modal T\n                            Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n                   thesis;\n        (a, b) \\<in> modRules2;\n        \\<And>Ps C.\n           (Ps, C) \\<in> modRules2 \\<Longrightarrow>\n           Ps \\<noteq> [] \\<and>\n           (\\<exists>F Fs.\n               C = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n               C = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>));\n        r = (a, b)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (rotate_tac 2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>Ps C.\n                   (Ps, C) \\<in> modRules2 \\<Longrightarrow>\n                   Ps \\<noteq> [] \\<and>\n                   (\\<exists>F Fs.\n                       C =\n                       ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F\n                 Fs  \\<RM>) \\<or>\n                       C =\n                       ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>));\n        r = (a, b);\n        \\<And>ps T Ts.\n           a = ps \\<and>\n           b = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n           a = ps \\<and>\n           b =\n           ( \\<LM> Modal T\n                    Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n           thesis;\n        (a, b) \\<in> modRules2\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (drule_tac x=a in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>r = (a, b);\n        \\<And>ps T Ts.\n           a = ps \\<and>\n           b = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n           a = ps \\<and>\n           b =\n           ( \\<LM> Modal T\n                    Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n           thesis;\n        (a, b) \\<in> modRules2;\n        \\<And>C.\n           (a, C) \\<in> modRules2 \\<Longrightarrow>\n           a \\<noteq> [] \\<and>\n           (\\<exists>F Fs.\n               C = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n               C =\n               ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (rotate_tac 2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> modRules2;\n        \\<And>C.\n           (a, C) \\<in> modRules2 \\<Longrightarrow>\n           a \\<noteq> [] \\<and>\n           (\\<exists>F Fs.\n               C = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n               C = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>));\n        r = (a, b);\n        \\<And>ps T Ts.\n           a = ps \\<and>\n           b = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n           a = ps \\<and>\n           b =\n           ( \\<LM> Modal T\n                    Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (drule_tac x=b in meta_spec) auto"], ["proof (state)\nthis:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  r = (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. r \\<in> modRules2 \\<Longrightarrow>\n    \\<not> leftPrincipal r (Compound M Ms) R", "moreover"], ["proof (state)\nthis:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  r = (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. r \\<in> modRules2 \\<Longrightarrow>\n    \\<not> leftPrincipal r (Compound M Ms) R", "{"], ["proof (state)\nthis:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  r = (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. r \\<in> modRules2 \\<Longrightarrow>\n    \\<not> leftPrincipal r (Compound M Ms) R", "assume \"r = (ps,\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>)\""], ["proof (state)\nthis:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n\ngoal (1 subgoal):\n 1. r \\<in> modRules2 \\<Longrightarrow>\n    \\<not> leftPrincipal r (Compound M Ms) R", "then"], ["proof (chain)\npicking this:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)", "have \"\\<not> leftPrincipal r (Compound M Ms) R\""], ["proof (prove)\nusing this:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<not> leftPrincipal r (Compound M Ms) R", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     leftPrincipal (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n      (Compound M Ms) R\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule leftPrincipal.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     leftPrincipal (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n      (Compound M Ms) R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal ?a1.2 ?a2.2 ?a3.2\n 2. \\<And>C A Ps Ra.\n       \\<lbrakk>r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n        leftPrincipal (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n         (Compound M Ms) R;\n        ?a1.2 = (Ps, C); ?a2.2 = A; ?a3.2 = Ra;\n        C = ( \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>); A \\<noteq> ff;\n        (Ps, C) \\<in> Ra\\<rbrakk>\n       \\<Longrightarrow> False", "by (auto simp add:extendRule_def extend_def)"], ["proof (state)\nthis:\n  \\<not> leftPrincipal r (Compound M Ms) R\n\ngoal (1 subgoal):\n 1. r \\<in> modRules2 \\<Longrightarrow>\n    \\<not> leftPrincipal r (Compound M Ms) R", "}"], ["proof (state)\nthis:\n  r =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  \\<not> leftPrincipal r (Compound M Ms) R\n\ngoal (1 subgoal):\n 1. r \\<in> modRules2 \\<Longrightarrow>\n    \\<not> leftPrincipal r (Compound M Ms) R", "moreover"], ["proof (state)\nthis:\n  r =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  \\<not> leftPrincipal r (Compound M Ms) R\n\ngoal (1 subgoal):\n 1. r \\<in> modRules2 \\<Longrightarrow>\n    \\<not> leftPrincipal r (Compound M Ms) R", "{"], ["proof (state)\nthis:\n  r =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  \\<not> leftPrincipal r (Compound M Ms) R\n\ngoal (1 subgoal):\n 1. r \\<in> modRules2 \\<Longrightarrow>\n    \\<not> leftPrincipal r (Compound M Ms) R", "assume \"r = (ps,\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (state)\nthis:\n  r = (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. r \\<in> modRules2 \\<Longrightarrow>\n    \\<not> leftPrincipal r (Compound M Ms) R", "then"], ["proof (chain)\npicking this:\n  r = (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"\\<not> leftPrincipal r (Compound M Ms) R\""], ["proof (prove)\nusing this:\n  r = (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<not> leftPrincipal r (Compound M Ms) R", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     leftPrincipal (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n      (Compound M Ms) R\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule leftPrincipal.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r = (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     leftPrincipal (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n      (Compound M Ms) R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal ?a1.2 ?a2.2 ?a3.2\n 2. \\<And>C A Ps Ra.\n       \\<lbrakk>r = (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n        leftPrincipal (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n         (Compound M Ms) R;\n        ?a1.2 = (Ps, C); ?a2.2 = A; ?a3.2 = Ra;\n        C = ( \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>); A \\<noteq> ff;\n        (Ps, C) \\<in> Ra\\<rbrakk>\n       \\<Longrightarrow> False", "by (auto simp add:extendRule_def extend_def)"], ["proof (state)\nthis:\n  \\<not> leftPrincipal r (Compound M Ms) R\n\ngoal (1 subgoal):\n 1. r \\<in> modRules2 \\<Longrightarrow>\n    \\<not> leftPrincipal r (Compound M Ms) R", "}"], ["proof (state)\nthis:\n  r =\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<not> leftPrincipal r (Compound M Ms) R\n\ngoal (1 subgoal):\n 1. r \\<in> modRules2 \\<Longrightarrow>\n    \\<not> leftPrincipal r (Compound M Ms) R", "ultimately"], ["proof (chain)\npicking this:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  r = (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  r =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  \\<not> leftPrincipal r (Compound M Ms) R\n  r =\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<not> leftPrincipal r (Compound M Ms) R", "show \"\\<not> leftPrincipal r (Compound M Ms) R\""], ["proof (prove)\nusing this:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  r = (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  r =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  \\<not> leftPrincipal r (Compound M Ms) R\n  r =\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<not> leftPrincipal r (Compound M Ms) R\n\ngoal (1 subgoal):\n 1. \\<not> leftPrincipal r (Compound M Ms) R", "by blast"], ["proof (state)\nthis:\n  \\<not> leftPrincipal r (Compound M Ms) R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma modRules2_not_right_principal_for_compound:\nassumes \"r \\<in> modRules2\"\nshows \"\\<not> rightPrincipal r (Compound M Ms) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (Compound M Ms) R", "using assms"], ["proof (prove)\nusing this:\n  r \\<in> modRules2\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (Compound M Ms) R", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<in> modRules2 \\<Longrightarrow>\n    \\<not> rightPrincipal r (Compound M Ms) R", "from assms"], ["proof (chain)\npicking this:\n  r \\<in> modRules2", "obtain ps T Ts where \"r = (ps,\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<or> r = (ps,\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  r \\<in> modRules2\n\ngoal (1 subgoal):\n 1. (\\<And>ps T Ts.\n        r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n        r =\n        (ps,\n          \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using modRule2Characterise"], ["proof (prove)\nusing this:\n  r \\<in> modRules2\n  (?Ps, ?C) \\<in> modRules2 \\<Longrightarrow>\n  ?Ps \\<noteq> [] \\<and>\n  (\\<exists>F Fs.\n      ?C = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n      ?C = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))\n\ngoal (1 subgoal):\n 1. (\\<And>ps T Ts.\n        r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n        r =\n        (ps,\n          \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply (cases r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>ps T Ts.\n                   r =\n                   (ps,\n                     \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n                   r =\n                   (ps,\n                     \\<LM> Modal T\n                            Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n                   thesis;\n        r \\<in> modRules2;\n        \\<And>Ps C.\n           (Ps, C) \\<in> modRules2 \\<Longrightarrow>\n           Ps \\<noteq> [] \\<and>\n           (\\<exists>F Fs.\n               C = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n               C = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>));\n        r = (a, b)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>ps T Ts.\n                   a = ps \\<and>\n                   b =\n                   ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n                   a = ps \\<and>\n                   b =\n                   ( \\<LM> Modal T\n                            Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n                   thesis;\n        (a, b) \\<in> modRules2;\n        \\<And>Ps C.\n           (Ps, C) \\<in> modRules2 \\<Longrightarrow>\n           Ps \\<noteq> [] \\<and>\n           (\\<exists>F Fs.\n               C = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n               C = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>));\n        r = (a, b)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (rotate_tac 2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>Ps C.\n                   (Ps, C) \\<in> modRules2 \\<Longrightarrow>\n                   Ps \\<noteq> [] \\<and>\n                   (\\<exists>F Fs.\n                       C =\n                       ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F\n                 Fs  \\<RM>) \\<or>\n                       C =\n                       ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>));\n        r = (a, b);\n        \\<And>ps T Ts.\n           a = ps \\<and>\n           b = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n           a = ps \\<and>\n           b =\n           ( \\<LM> Modal T\n                    Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n           thesis;\n        (a, b) \\<in> modRules2\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (drule_tac x=a in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>r = (a, b);\n        \\<And>ps T Ts.\n           a = ps \\<and>\n           b = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n           a = ps \\<and>\n           b =\n           ( \\<LM> Modal T\n                    Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n           thesis;\n        (a, b) \\<in> modRules2;\n        \\<And>C.\n           (a, C) \\<in> modRules2 \\<Longrightarrow>\n           a \\<noteq> [] \\<and>\n           (\\<exists>F Fs.\n               C = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n               C =\n               ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (rotate_tac 2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> modRules2;\n        \\<And>C.\n           (a, C) \\<in> modRules2 \\<Longrightarrow>\n           a \\<noteq> [] \\<and>\n           (\\<exists>F Fs.\n               C = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n               C = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>));\n        r = (a, b);\n        \\<And>ps T Ts.\n           a = ps \\<and>\n           b = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n           a = ps \\<and>\n           b =\n           ( \\<LM> Modal T\n                    Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (drule_tac x=b in meta_spec) auto"], ["proof (state)\nthis:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  r = (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. r \\<in> modRules2 \\<Longrightarrow>\n    \\<not> rightPrincipal r (Compound M Ms) R", "moreover"], ["proof (state)\nthis:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  r = (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. r \\<in> modRules2 \\<Longrightarrow>\n    \\<not> rightPrincipal r (Compound M Ms) R", "{"], ["proof (state)\nthis:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  r = (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. r \\<in> modRules2 \\<Longrightarrow>\n    \\<not> rightPrincipal r (Compound M Ms) R", "assume \"r = (ps,\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>)\""], ["proof (state)\nthis:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n\ngoal (1 subgoal):\n 1. r \\<in> modRules2 \\<Longrightarrow>\n    \\<not> rightPrincipal r (Compound M Ms) R", "then"], ["proof (chain)\npicking this:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)", "have \"\\<not> rightPrincipal r (Compound M Ms) R\""], ["proof (prove)\nusing this:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (Compound M Ms) R", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     rightPrincipal (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n      (Compound M Ms) R\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule rightPrincipal.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     rightPrincipal (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n      (Compound M Ms) R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal ?a1.2 ?a2.2 ?a3.2\n 2. \\<And>C A Ps Ra.\n       \\<lbrakk>r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n        rightPrincipal (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n         (Compound M Ms) R;\n        ?a1.2 = (Ps, C); ?a2.2 = A; ?a3.2 = Ra;\n        C = ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>);\n        (Ps, C) \\<in> Ra\\<rbrakk>\n       \\<Longrightarrow> False", "by (auto simp add:extendRule_def extend_def)"], ["proof (state)\nthis:\n  \\<not> rightPrincipal r (Compound M Ms) R\n\ngoal (1 subgoal):\n 1. r \\<in> modRules2 \\<Longrightarrow>\n    \\<not> rightPrincipal r (Compound M Ms) R", "}"], ["proof (state)\nthis:\n  r =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  \\<not> rightPrincipal r (Compound M Ms) R\n\ngoal (1 subgoal):\n 1. r \\<in> modRules2 \\<Longrightarrow>\n    \\<not> rightPrincipal r (Compound M Ms) R", "moreover"], ["proof (state)\nthis:\n  r =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  \\<not> rightPrincipal r (Compound M Ms) R\n\ngoal (1 subgoal):\n 1. r \\<in> modRules2 \\<Longrightarrow>\n    \\<not> rightPrincipal r (Compound M Ms) R", "{"], ["proof (state)\nthis:\n  r =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  \\<not> rightPrincipal r (Compound M Ms) R\n\ngoal (1 subgoal):\n 1. r \\<in> modRules2 \\<Longrightarrow>\n    \\<not> rightPrincipal r (Compound M Ms) R", "assume \"r = (ps,\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (state)\nthis:\n  r = (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. r \\<in> modRules2 \\<Longrightarrow>\n    \\<not> rightPrincipal r (Compound M Ms) R", "then"], ["proof (chain)\npicking this:\n  r = (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"\\<not> rightPrincipal r (Compound M Ms) R\""], ["proof (prove)\nusing this:\n  r = (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (Compound M Ms) R", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     rightPrincipal (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n      (Compound M Ms) R\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule rightPrincipal.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r = (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     rightPrincipal (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n      (Compound M Ms) R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal ?a1.2 ?a2.2 ?a3.2\n 2. \\<And>C A Ps Ra.\n       \\<lbrakk>r = (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n        rightPrincipal (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n         (Compound M Ms) R;\n        ?a1.2 = (Ps, C); ?a2.2 = A; ?a3.2 = Ra;\n        C = ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>);\n        (Ps, C) \\<in> Ra\\<rbrakk>\n       \\<Longrightarrow> False", "by (auto simp add:extendRule_def extend_def)"], ["proof (state)\nthis:\n  \\<not> rightPrincipal r (Compound M Ms) R\n\ngoal (1 subgoal):\n 1. r \\<in> modRules2 \\<Longrightarrow>\n    \\<not> rightPrincipal r (Compound M Ms) R", "}"], ["proof (state)\nthis:\n  r =\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<not> rightPrincipal r (Compound M Ms) R\n\ngoal (1 subgoal):\n 1. r \\<in> modRules2 \\<Longrightarrow>\n    \\<not> rightPrincipal r (Compound M Ms) R", "ultimately"], ["proof (chain)\npicking this:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  r = (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  r =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  \\<not> rightPrincipal r (Compound M Ms) R\n  r =\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<not> rightPrincipal r (Compound M Ms) R", "show \"\\<not> rightPrincipal r (Compound M Ms) R\""], ["proof (prove)\nusing this:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  r = (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  r =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  \\<not> rightPrincipal r (Compound M Ms) R\n  r =\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<not> rightPrincipal r (Compound M Ms) R\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (Compound M Ms) R", "by blast"], ["proof (state)\nthis:\n  \\<not> rightPrincipal r (Compound M Ms) R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upRules_not_right_principal_for_modal:\nassumes \"r \\<in> upRules\"\n  shows \"\\<not> rightPrincipal r (Modal M Ms) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (Modal M Ms) R", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (Modal M Ms) R", "from assms"], ["proof (chain)\npicking this:\n  r \\<in> upRules", "obtain ps T Ts where \"r = (ps,\\<Empt> \\<Rightarrow>* \\<LM>Compound T Ts\\<RM>) \\<or> r = (ps,\\<LM>Compound T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  r \\<in> upRules\n\ngoal (1 subgoal):\n 1. (\\<And>ps T Ts.\n        r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n        r =\n        (ps,\n          \\<LM> Compound T\n                 Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using upRuleCharacterise"], ["proof (prove)\nusing this:\n  r \\<in> upRules\n  (?Ps, ?C) \\<in> upRules \\<Longrightarrow>\n  \\<exists>F Fs.\n     ?C = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F Fs  \\<RM>) \\<or>\n     ?C = ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. (\\<And>ps T Ts.\n        r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n        r =\n        (ps,\n          \\<LM> Compound T\n                 Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply (cases r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>ps T Ts.\n                   r =\n                   (ps,\n                     \\<Empt> \\<Rightarrow>* \\<LM> Compound T\n             Ts  \\<RM>) \\<or>\n                   r =\n                   (ps,\n                     \\<LM> Compound T\n                            Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n                   thesis;\n        r \\<in> upRules;\n        \\<And>Ps C.\n           (Ps, C) \\<in> upRules \\<Longrightarrow>\n           \\<exists>F Fs.\n              C = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F Fs  \\<RM>) \\<or>\n              C = ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>);\n        r = (a, b)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>ps T Ts.\n                   a = ps \\<and>\n                   b =\n                   ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T\n             Ts  \\<RM>) \\<or>\n                   a = ps \\<and>\n                   b =\n                   ( \\<LM> Compound T\n                            Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n                   thesis;\n        (a, b) \\<in> upRules;\n        \\<And>Ps C.\n           (Ps, C) \\<in> upRules \\<Longrightarrow>\n           \\<exists>F Fs.\n              C = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F Fs  \\<RM>) \\<or>\n              C = ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>);\n        r = (a, b)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (rotate_tac 2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>Ps C.\n                   (Ps, C) \\<in> upRules \\<Longrightarrow>\n                   \\<exists>F Fs.\n                      C =\n                      ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F\n                Fs  \\<RM>) \\<or>\n                      C =\n                      ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>);\n        r = (a, b);\n        \\<And>ps T Ts.\n           a = ps \\<and>\n           b = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n           a = ps \\<and>\n           b =\n           ( \\<LM> Compound T\n                    Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n           thesis;\n        (a, b) \\<in> upRules\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (drule_tac x=a in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>r = (a, b);\n        \\<And>ps T Ts.\n           a = ps \\<and>\n           b = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n           a = ps \\<and>\n           b =\n           ( \\<LM> Compound T\n                    Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n           thesis;\n        (a, b) \\<in> upRules;\n        \\<And>C.\n           (a, C) \\<in> upRules \\<Longrightarrow>\n           \\<exists>F Fs.\n              C = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F Fs  \\<RM>) \\<or>\n              C =\n              ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (rotate_tac 2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> upRules;\n        \\<And>C.\n           (a, C) \\<in> upRules \\<Longrightarrow>\n           \\<exists>F Fs.\n              C = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F Fs  \\<RM>) \\<or>\n              C = ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>);\n        r = (a, b);\n        \\<And>ps T Ts.\n           a = ps \\<and>\n           b = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n           a = ps \\<and>\n           b =\n           ( \\<LM> Compound T\n                    Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (drule_tac x=b in meta_spec) auto"], ["proof (state)\nthis:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n  r = (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (Modal M Ms) R", "moreover"], ["proof (state)\nthis:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n  r = (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (Modal M Ms) R", "{"], ["proof (state)\nthis:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n  r = (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (Modal M Ms) R", "assume \"r = (ps,\\<Empt> \\<Rightarrow>* \\<LM>Compound T Ts\\<RM>)\""], ["proof (state)\nthis:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (Modal M Ms) R", "then"], ["proof (chain)\npicking this:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>)", "have \"\\<not> rightPrincipal r (Modal M Ms) R\""], ["proof (prove)\nusing this:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (Modal M Ms) R", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>);\n     rightPrincipal (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>)\n      (Modal M Ms) R\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule rightPrincipal.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>);\n     rightPrincipal (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>)\n      (Modal M Ms) R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal ?a1.2 ?a2.2 ?a3.2\n 2. \\<And>C A Ps Ra.\n       \\<lbrakk>r =\n                (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>);\n        rightPrincipal\n         (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>)\n         (Modal M Ms) R;\n        ?a1.2 = (Ps, C); ?a2.2 = A; ?a3.2 = Ra;\n        C = ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>);\n        (Ps, C) \\<in> Ra\\<rbrakk>\n       \\<Longrightarrow> False", "by (auto simp add:extendRule_def extend_def)"], ["proof (state)\nthis:\n  \\<not> rightPrincipal r (Modal M Ms) R\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (Modal M Ms) R", "}"], ["proof (state)\nthis:\n  r =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<Longrightarrow>\n  \\<not> rightPrincipal r (Modal M Ms) R\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (Modal M Ms) R", "moreover"], ["proof (state)\nthis:\n  r =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<Longrightarrow>\n  \\<not> rightPrincipal r (Modal M Ms) R\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (Modal M Ms) R", "{"], ["proof (state)\nthis:\n  r =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<Longrightarrow>\n  \\<not> rightPrincipal r (Modal M Ms) R\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (Modal M Ms) R", "assume \"r = (ps,\\<LM>Compound T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (state)\nthis:\n  r = (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (Modal M Ms) R", "then"], ["proof (chain)\npicking this:\n  r = (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"\\<not> rightPrincipal r (Modal M Ms) R\""], ["proof (prove)\nusing this:\n  r = (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (Modal M Ms) R", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     rightPrincipal (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n      (Modal M Ms) R\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule rightPrincipal.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r = (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     rightPrincipal (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n      (Modal M Ms) R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal ?a1.2 ?a2.2 ?a3.2\n 2. \\<And>C A Ps Ra.\n       \\<lbrakk>r =\n                (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n        rightPrincipal\n         (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n         (Modal M Ms) R;\n        ?a1.2 = (Ps, C); ?a2.2 = A; ?a3.2 = Ra;\n        C = ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>);\n        (Ps, C) \\<in> Ra\\<rbrakk>\n       \\<Longrightarrow> False", "by (auto simp add:extendRule_def extend_def)"], ["proof (state)\nthis:\n  \\<not> rightPrincipal r (Modal M Ms) R\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (Modal M Ms) R", "}"], ["proof (state)\nthis:\n  r =\n  (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<not> rightPrincipal r (Modal M Ms) R\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (Modal M Ms) R", "ultimately"], ["proof (chain)\npicking this:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n  r = (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  r =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<Longrightarrow>\n  \\<not> rightPrincipal r (Modal M Ms) R\n  r =\n  (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<not> rightPrincipal r (Modal M Ms) R", "show \"\\<not> rightPrincipal r (Modal M Ms) R\""], ["proof (prove)\nusing this:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n  r = (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  r =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<Longrightarrow>\n  \\<not> rightPrincipal r (Modal M Ms) R\n  r =\n  (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<not> rightPrincipal r (Modal M Ms) R\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (Modal M Ms) R", "by blast"], ["proof (state)\nthis:\n  \\<not> rightPrincipal r (Modal M Ms) R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upRules_not_left_principal_for_modal:\nassumes \"r \\<in> upRules\"\nshows \"\\<not> leftPrincipal r (Modal M Ms) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> leftPrincipal r (Modal M Ms) R", "using assms"], ["proof (prove)\nusing this:\n  r \\<in> upRules\n\ngoal (1 subgoal):\n 1. \\<not> leftPrincipal r (Modal M Ms) R", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<in> upRules \\<Longrightarrow> \\<not> leftPrincipal r (Modal M Ms) R", "from assms"], ["proof (chain)\npicking this:\n  r \\<in> upRules", "obtain ps T Ts where \"r = (ps,\\<Empt> \\<Rightarrow>* \\<LM>Compound T Ts\\<RM>) \\<or> r = (ps,\\<LM>Compound T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  r \\<in> upRules\n\ngoal (1 subgoal):\n 1. (\\<And>ps T Ts.\n        r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n        r =\n        (ps,\n          \\<LM> Compound T\n                 Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using upRuleCharacterise"], ["proof (prove)\nusing this:\n  r \\<in> upRules\n  (?Ps, ?C) \\<in> upRules \\<Longrightarrow>\n  \\<exists>F Fs.\n     ?C = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F Fs  \\<RM>) \\<or>\n     ?C = ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. (\\<And>ps T Ts.\n        r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n        r =\n        (ps,\n          \\<LM> Compound T\n                 Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply (cases r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>ps T Ts.\n                   r =\n                   (ps,\n                     \\<Empt> \\<Rightarrow>* \\<LM> Compound T\n             Ts  \\<RM>) \\<or>\n                   r =\n                   (ps,\n                     \\<LM> Compound T\n                            Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n                   thesis;\n        r \\<in> upRules;\n        \\<And>Ps C.\n           (Ps, C) \\<in> upRules \\<Longrightarrow>\n           \\<exists>F Fs.\n              C = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F Fs  \\<RM>) \\<or>\n              C = ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>);\n        r = (a, b)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>ps T Ts.\n                   a = ps \\<and>\n                   b =\n                   ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T\n             Ts  \\<RM>) \\<or>\n                   a = ps \\<and>\n                   b =\n                   ( \\<LM> Compound T\n                            Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n                   thesis;\n        (a, b) \\<in> upRules;\n        \\<And>Ps C.\n           (Ps, C) \\<in> upRules \\<Longrightarrow>\n           \\<exists>F Fs.\n              C = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F Fs  \\<RM>) \\<or>\n              C = ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>);\n        r = (a, b)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (rotate_tac 2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>Ps C.\n                   (Ps, C) \\<in> upRules \\<Longrightarrow>\n                   \\<exists>F Fs.\n                      C =\n                      ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F\n                Fs  \\<RM>) \\<or>\n                      C =\n                      ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>);\n        r = (a, b);\n        \\<And>ps T Ts.\n           a = ps \\<and>\n           b = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n           a = ps \\<and>\n           b =\n           ( \\<LM> Compound T\n                    Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n           thesis;\n        (a, b) \\<in> upRules\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (drule_tac x=a in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>r = (a, b);\n        \\<And>ps T Ts.\n           a = ps \\<and>\n           b = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n           a = ps \\<and>\n           b =\n           ( \\<LM> Compound T\n                    Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n           thesis;\n        (a, b) \\<in> upRules;\n        \\<And>C.\n           (a, C) \\<in> upRules \\<Longrightarrow>\n           \\<exists>F Fs.\n              C = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F Fs  \\<RM>) \\<or>\n              C =\n              ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (rotate_tac 2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> upRules;\n        \\<And>C.\n           (a, C) \\<in> upRules \\<Longrightarrow>\n           \\<exists>F Fs.\n              C = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F Fs  \\<RM>) \\<or>\n              C = ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>);\n        r = (a, b);\n        \\<And>ps T Ts.\n           a = ps \\<and>\n           b = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n           a = ps \\<and>\n           b =\n           ( \\<LM> Compound T\n                    Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n           thesis\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (drule_tac x=b in meta_spec) auto"], ["proof (state)\nthis:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n  r = (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. r \\<in> upRules \\<Longrightarrow> \\<not> leftPrincipal r (Modal M Ms) R", "moreover"], ["proof (state)\nthis:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n  r = (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. r \\<in> upRules \\<Longrightarrow> \\<not> leftPrincipal r (Modal M Ms) R", "{"], ["proof (state)\nthis:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n  r = (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. r \\<in> upRules \\<Longrightarrow> \\<not> leftPrincipal r (Modal M Ms) R", "assume \"r = (ps,\\<Empt> \\<Rightarrow>* \\<LM>Compound T Ts\\<RM>)\""], ["proof (state)\nthis:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>)\n\ngoal (1 subgoal):\n 1. r \\<in> upRules \\<Longrightarrow> \\<not> leftPrincipal r (Modal M Ms) R", "then"], ["proof (chain)\npicking this:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>)", "have \"\\<not> leftPrincipal r (Modal M Ms) R\""], ["proof (prove)\nusing this:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<not> leftPrincipal r (Modal M Ms) R", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>);\n     leftPrincipal (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>)\n      (Modal M Ms) R\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule leftPrincipal.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>);\n     leftPrincipal (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>)\n      (Modal M Ms) R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal ?a1.2 ?a2.2 ?a3.2\n 2. \\<And>C A Ps Ra.\n       \\<lbrakk>r =\n                (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>);\n        leftPrincipal\n         (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>)\n         (Modal M Ms) R;\n        ?a1.2 = (Ps, C); ?a2.2 = A; ?a3.2 = Ra;\n        C = ( \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>); A \\<noteq> ff;\n        (Ps, C) \\<in> Ra\\<rbrakk>\n       \\<Longrightarrow> False", "by (auto simp add:extendRule_def extend_def)"], ["proof (state)\nthis:\n  \\<not> leftPrincipal r (Modal M Ms) R\n\ngoal (1 subgoal):\n 1. r \\<in> upRules \\<Longrightarrow> \\<not> leftPrincipal r (Modal M Ms) R", "}"], ["proof (state)\nthis:\n  r =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<Longrightarrow>\n  \\<not> leftPrincipal r (Modal M Ms) R\n\ngoal (1 subgoal):\n 1. r \\<in> upRules \\<Longrightarrow> \\<not> leftPrincipal r (Modal M Ms) R", "moreover"], ["proof (state)\nthis:\n  r =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<Longrightarrow>\n  \\<not> leftPrincipal r (Modal M Ms) R\n\ngoal (1 subgoal):\n 1. r \\<in> upRules \\<Longrightarrow> \\<not> leftPrincipal r (Modal M Ms) R", "{"], ["proof (state)\nthis:\n  r =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<Longrightarrow>\n  \\<not> leftPrincipal r (Modal M Ms) R\n\ngoal (1 subgoal):\n 1. r \\<in> upRules \\<Longrightarrow> \\<not> leftPrincipal r (Modal M Ms) R", "assume \"r = (ps,\\<LM>Compound T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (state)\nthis:\n  r = (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. r \\<in> upRules \\<Longrightarrow> \\<not> leftPrincipal r (Modal M Ms) R", "then"], ["proof (chain)\npicking this:\n  r = (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"\\<not> leftPrincipal r (Modal M Ms) R\""], ["proof (prove)\nusing this:\n  r = (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<not> leftPrincipal r (Modal M Ms) R", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     leftPrincipal (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n      (Modal M Ms) R\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule leftPrincipal.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r = (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     leftPrincipal (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n      (Modal M Ms) R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal ?a1.2 ?a2.2 ?a3.2\n 2. \\<And>C A Ps Ra.\n       \\<lbrakk>r =\n                (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n        leftPrincipal\n         (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n         (Modal M Ms) R;\n        ?a1.2 = (Ps, C); ?a2.2 = A; ?a3.2 = Ra;\n        C = ( \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>); A \\<noteq> ff;\n        (Ps, C) \\<in> Ra\\<rbrakk>\n       \\<Longrightarrow> False", "by (auto simp add:extendRule_def extend_def)"], ["proof (state)\nthis:\n  \\<not> leftPrincipal r (Modal M Ms) R\n\ngoal (1 subgoal):\n 1. r \\<in> upRules \\<Longrightarrow> \\<not> leftPrincipal r (Modal M Ms) R", "}"], ["proof (state)\nthis:\n  r =\n  (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<not> leftPrincipal r (Modal M Ms) R\n\ngoal (1 subgoal):\n 1. r \\<in> upRules \\<Longrightarrow> \\<not> leftPrincipal r (Modal M Ms) R", "ultimately"], ["proof (chain)\npicking this:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n  r = (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  r =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<Longrightarrow>\n  \\<not> leftPrincipal r (Modal M Ms) R\n  r =\n  (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<not> leftPrincipal r (Modal M Ms) R", "show \"\\<not> leftPrincipal r (Modal M Ms) R\""], ["proof (prove)\nusing this:\n  r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n  r = (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  r =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<Longrightarrow>\n  \\<not> leftPrincipal r (Modal M Ms) R\n  r =\n  (ps,  \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<not> leftPrincipal r (Modal M Ms) R\n\ngoal (1 subgoal):\n 1. \\<not> leftPrincipal r (Modal M Ms) R", "by blast"], ["proof (state)\nthis:\n  \\<not> leftPrincipal r (Modal M Ms) R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas nonPrincipalRight = upRules_not_right_principal_for_modal\n                           modRules_not_right_principal_for_compound\n                           modRules2_not_right_principal_for_compound"], ["", "lemmas nonPrincipalLeft = upRules_not_left_principal_for_modal\n                          modRules_not_left_principal_for_compound\n                          modRules2_not_left_principal_for_compound"], ["", "(* Bunch of results about modalising multisets *)"], ["", "lemma modalise_characterise:\nfixes A :: \"('a,'b) form\"\nand   M :: \"'b\"\nand  \\<Delta>  :: \"('a,'b) form multiset\"\nassumes \"A \\<in># M\\<cdot>\\<Delta>\"\nshows \"\\<exists> B. A = Modal M [B]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B. A = Modal M [B]", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>B. A = Modal M [B]", "from assms"], ["proof (chain)\npicking this:\n  A \\<in># M \\<cdot> \\<Delta>", "have \"\\<Delta> \\<noteq> \\<Empt>\""], ["proof (prove)\nusing this:\n  A \\<in># M \\<cdot> \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<Delta> \\<noteq> \\<Empt>", "by (auto simp add:modaliseEmpty)"], ["proof (state)\nthis:\n  \\<Delta> \\<noteq> \\<Empt>\n\ngoal (1 subgoal):\n 1. \\<exists>B. A = Modal M [B]", "with \\<open>A \\<in># M\\<cdot>\\<Delta>\\<close>"], ["proof (chain)\npicking this:\n  A \\<in># M \\<cdot> \\<Delta>\n  \\<Delta> \\<noteq> \\<Empt>", "show \"\\<exists> B. A = Modal M [B]\""], ["proof (prove)\nusing this:\n  A \\<in># M \\<cdot> \\<Delta>\n  \\<Delta> \\<noteq> \\<Empt>\n\ngoal (1 subgoal):\n 1. \\<exists>B. A = Modal M [B]", "proof (induct \\<Delta>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<in># M \\<cdot> (\\<Empt>); \\<Empt> \\<noteq> \\<Empt>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>B. A = Modal M [B]\n 2. \\<And>x \\<Delta>.\n       \\<lbrakk>\\<lbrakk>A \\<in># M \\<cdot> \\<Delta>;\n                 \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n                \\<Longrightarrow> \\<exists>B. A = Modal M [B];\n        A \\<in># M \\<cdot> add_mset x \\<Delta>;\n        add_mset x \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. A = Modal M [B]", "case empty"], ["proof (state)\nthis:\n  A \\<in># M \\<cdot> (\\<Empt>)\n  \\<Empt> \\<noteq> \\<Empt>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>A \\<in># M \\<cdot> (\\<Empt>); \\<Empt> \\<noteq> \\<Empt>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>B. A = Modal M [B]\n 2. \\<And>x \\<Delta>.\n       \\<lbrakk>\\<lbrakk>A \\<in># M \\<cdot> \\<Delta>;\n                 \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n                \\<Longrightarrow> \\<exists>B. A = Modal M [B];\n        A \\<in># M \\<cdot> add_mset x \\<Delta>;\n        add_mset x \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. A = Modal M [B]", "then"], ["proof (chain)\npicking this:\n  A \\<in># M \\<cdot> (\\<Empt>)\n  \\<Empt> \\<noteq> \\<Empt>", "show ?case"], ["proof (prove)\nusing this:\n  A \\<in># M \\<cdot> (\\<Empt>)\n  \\<Empt> \\<noteq> \\<Empt>\n\ngoal (1 subgoal):\n 1. \\<exists>B. A = Modal M [B]", "by simp"], ["proof (state)\nthis:\n  \\<exists>B. A = Modal M [B]\n\ngoal (1 subgoal):\n 1. \\<And>x \\<Delta>.\n       \\<lbrakk>\\<lbrakk>A \\<in># M \\<cdot> \\<Delta>;\n                 \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n                \\<Longrightarrow> \\<exists>B. A = Modal M [B];\n        A \\<in># M \\<cdot> add_mset x \\<Delta>;\n        add_mset x \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. A = Modal M [B]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x \\<Delta>.\n       \\<lbrakk>\\<lbrakk>A \\<in># M \\<cdot> \\<Delta>;\n                 \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n                \\<Longrightarrow> \\<exists>B. A = Modal M [B];\n        A \\<in># M \\<cdot> add_mset x \\<Delta>;\n        add_mset x \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. A = Modal M [B]", "case (add x \\<Delta>')"], ["proof (state)\nthis:\n  \\<lbrakk>A \\<in># M \\<cdot> \\<Delta>'; \\<Delta>' \\<noteq> \\<Empt>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>B. A = Modal M [B]\n  A \\<in># M \\<cdot> add_mset x \\<Delta>'\n  add_mset x \\<Delta>' \\<noteq> \\<Empt>\n\ngoal (1 subgoal):\n 1. \\<And>x \\<Delta>.\n       \\<lbrakk>\\<lbrakk>A \\<in># M \\<cdot> \\<Delta>;\n                 \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n                \\<Longrightarrow> \\<exists>B. A = Modal M [B];\n        A \\<in># M \\<cdot> add_mset x \\<Delta>;\n        add_mset x \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. A = Modal M [B]", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>A \\<in># M \\<cdot> \\<Delta>'; \\<Delta>' \\<noteq> \\<Empt>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>B. A = Modal M [B]\n  A \\<in># M \\<cdot> add_mset x \\<Delta>'\n  add_mset x \\<Delta>' \\<noteq> \\<Empt>", "have IH: \"\\<lbrakk> A \\<in># M\\<cdot>\\<Delta>' ; \\<Delta>' \\<noteq> \\<Empt> \\<rbrakk> \\<Longrightarrow> \\<exists> B. A = Modal M [B]\"\n            and b: \"A \\<in># M \\<cdot> (\\<Delta>' \\<oplus> x)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>A \\<in># M \\<cdot> \\<Delta>'; \\<Delta>' \\<noteq> \\<Empt>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>B. A = Modal M [B]\n  A \\<in># M \\<cdot> add_mset x \\<Delta>'\n  add_mset x \\<Delta>' \\<noteq> \\<Empt>\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>A \\<in># M \\<cdot> \\<Delta>';\n      \\<Delta>' \\<noteq> \\<Empt>\\<rbrakk>\n     \\<Longrightarrow> \\<exists>B. A = Modal M [B]) &&&\n    A \\<in># M \\<cdot> (\\<Delta>' \\<oplus> x)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>A \\<in># M \\<cdot> \\<Delta>'; \\<Delta>' \\<noteq> \\<Empt>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>B. A = Modal M [B]\n  A \\<in># M \\<cdot> (\\<Delta>' \\<oplus> x)\n\ngoal (1 subgoal):\n 1. \\<And>x \\<Delta>.\n       \\<lbrakk>\\<lbrakk>A \\<in># M \\<cdot> \\<Delta>;\n                 \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n                \\<Longrightarrow> \\<exists>B. A = Modal M [B];\n        A \\<in># M \\<cdot> add_mset x \\<Delta>;\n        add_mset x \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. A = Modal M [B]", "from b"], ["proof (chain)\npicking this:\n  A \\<in># M \\<cdot> (\\<Delta>' \\<oplus> x)", "have \"A \\<in># M\\<cdot>\\<Delta>' \\<or> A \\<in># M\\<cdot>(\\<LM>x\\<RM>)\""], ["proof (prove)\nusing this:\n  A \\<in># M \\<cdot> (\\<Delta>' \\<oplus> x)\n\ngoal (1 subgoal):\n 1. A \\<in># M \\<cdot> \\<Delta>' \\<or> A \\<in># M \\<cdot> (\\<LM> x  \\<RM>)", "by (auto simp add:modaliseMultiset_def)"], ["proof (state)\nthis:\n  A \\<in># M \\<cdot> \\<Delta>' \\<or> A \\<in># M \\<cdot> (\\<LM> x  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<And>x \\<Delta>.\n       \\<lbrakk>\\<lbrakk>A \\<in># M \\<cdot> \\<Delta>;\n                 \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n                \\<Longrightarrow> \\<exists>B. A = Modal M [B];\n        A \\<in># M \\<cdot> add_mset x \\<Delta>;\n        add_mset x \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. A = Modal M [B]", "moreover"], ["proof (state)\nthis:\n  A \\<in># M \\<cdot> \\<Delta>' \\<or> A \\<in># M \\<cdot> (\\<LM> x  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<And>x \\<Delta>.\n       \\<lbrakk>\\<lbrakk>A \\<in># M \\<cdot> \\<Delta>;\n                 \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n                \\<Longrightarrow> \\<exists>B. A = Modal M [B];\n        A \\<in># M \\<cdot> add_mset x \\<Delta>;\n        add_mset x \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. A = Modal M [B]", "{"], ["proof (state)\nthis:\n  A \\<in># M \\<cdot> \\<Delta>' \\<or> A \\<in># M \\<cdot> (\\<LM> x  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<And>x \\<Delta>.\n       \\<lbrakk>\\<lbrakk>A \\<in># M \\<cdot> \\<Delta>;\n                 \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n                \\<Longrightarrow> \\<exists>B. A = Modal M [B];\n        A \\<in># M \\<cdot> add_mset x \\<Delta>;\n        add_mset x \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. A = Modal M [B]", "assume \"A \\<in># M\\<cdot>\\<Delta>'\""], ["proof (state)\nthis:\n  A \\<in># M \\<cdot> \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<And>x \\<Delta>.\n       \\<lbrakk>\\<lbrakk>A \\<in># M \\<cdot> \\<Delta>;\n                 \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n                \\<Longrightarrow> \\<exists>B. A = Modal M [B];\n        A \\<in># M \\<cdot> add_mset x \\<Delta>;\n        add_mset x \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. A = Modal M [B]", "then"], ["proof (chain)\npicking this:\n  A \\<in># M \\<cdot> \\<Delta>'", "have \"\\<Delta>' \\<noteq> \\<Empt>\""], ["proof (prove)\nusing this:\n  A \\<in># M \\<cdot> \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<Delta>' \\<noteq> \\<Empt>", "by (auto simp add:modaliseEmpty)"], ["proof (state)\nthis:\n  \\<Delta>' \\<noteq> \\<Empt>\n\ngoal (1 subgoal):\n 1. \\<And>x \\<Delta>.\n       \\<lbrakk>\\<lbrakk>A \\<in># M \\<cdot> \\<Delta>;\n                 \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n                \\<Longrightarrow> \\<exists>B. A = Modal M [B];\n        A \\<in># M \\<cdot> add_mset x \\<Delta>;\n        add_mset x \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. A = Modal M [B]", "with \\<open>A \\<in># M\\<cdot>\\<Delta>'\\<close>"], ["proof (chain)\npicking this:\n  A \\<in># M \\<cdot> \\<Delta>'\n  \\<Delta>' \\<noteq> \\<Empt>", "have \"\\<exists> B. A = Modal M [B]\""], ["proof (prove)\nusing this:\n  A \\<in># M \\<cdot> \\<Delta>'\n  \\<Delta>' \\<noteq> \\<Empt>\n\ngoal (1 subgoal):\n 1. \\<exists>B. A = Modal M [B]", "using IH"], ["proof (prove)\nusing this:\n  A \\<in># M \\<cdot> \\<Delta>'\n  \\<Delta>' \\<noteq> \\<Empt>\n  \\<lbrakk>A \\<in># M \\<cdot> \\<Delta>'; \\<Delta>' \\<noteq> \\<Empt>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>B. A = Modal M [B]\n\ngoal (1 subgoal):\n 1. \\<exists>B. A = Modal M [B]", "by simp"], ["proof (state)\nthis:\n  \\<exists>B. A = Modal M [B]\n\ngoal (1 subgoal):\n 1. \\<And>x \\<Delta>.\n       \\<lbrakk>\\<lbrakk>A \\<in># M \\<cdot> \\<Delta>;\n                 \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n                \\<Longrightarrow> \\<exists>B. A = Modal M [B];\n        A \\<in># M \\<cdot> add_mset x \\<Delta>;\n        add_mset x \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. A = Modal M [B]", "}"], ["proof (state)\nthis:\n  A \\<in># M \\<cdot> \\<Delta>' \\<Longrightarrow> \\<exists>B. A = Modal M [B]\n\ngoal (1 subgoal):\n 1. \\<And>x \\<Delta>.\n       \\<lbrakk>\\<lbrakk>A \\<in># M \\<cdot> \\<Delta>;\n                 \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n                \\<Longrightarrow> \\<exists>B. A = Modal M [B];\n        A \\<in># M \\<cdot> add_mset x \\<Delta>;\n        add_mset x \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. A = Modal M [B]", "moreover"], ["proof (state)\nthis:\n  A \\<in># M \\<cdot> \\<Delta>' \\<Longrightarrow> \\<exists>B. A = Modal M [B]\n\ngoal (1 subgoal):\n 1. \\<And>x \\<Delta>.\n       \\<lbrakk>\\<lbrakk>A \\<in># M \\<cdot> \\<Delta>;\n                 \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n                \\<Longrightarrow> \\<exists>B. A = Modal M [B];\n        A \\<in># M \\<cdot> add_mset x \\<Delta>;\n        add_mset x \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. A = Modal M [B]", "{"], ["proof (state)\nthis:\n  A \\<in># M \\<cdot> \\<Delta>' \\<Longrightarrow> \\<exists>B. A = Modal M [B]\n\ngoal (1 subgoal):\n 1. \\<And>x \\<Delta>.\n       \\<lbrakk>\\<lbrakk>A \\<in># M \\<cdot> \\<Delta>;\n                 \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n                \\<Longrightarrow> \\<exists>B. A = Modal M [B];\n        A \\<in># M \\<cdot> add_mset x \\<Delta>;\n        add_mset x \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. A = Modal M [B]", "assume \"A \\<in># M\\<cdot>(\\<LM>x\\<RM>)\""], ["proof (state)\nthis:\n  A \\<in># M \\<cdot> (\\<LM> x  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<And>x \\<Delta>.\n       \\<lbrakk>\\<lbrakk>A \\<in># M \\<cdot> \\<Delta>;\n                 \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n                \\<Longrightarrow> \\<exists>B. A = Modal M [B];\n        A \\<in># M \\<cdot> add_mset x \\<Delta>;\n        add_mset x \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. A = Modal M [B]", "then"], ["proof (chain)\npicking this:\n  A \\<in># M \\<cdot> (\\<LM> x  \\<RM>)", "have \"A \\<in># \\<LM> Modal M [x] \\<RM>\""], ["proof (prove)\nusing this:\n  A \\<in># M \\<cdot> (\\<LM> x  \\<RM>)\n\ngoal (1 subgoal):\n 1. A \\<in># \\<LM> Modal M [x]  \\<RM>", "by (auto simp add:modaliseMultiset_def)"], ["proof (state)\nthis:\n  A \\<in># \\<LM> Modal M [x]  \\<RM>\n\ngoal (1 subgoal):\n 1. \\<And>x \\<Delta>.\n       \\<lbrakk>\\<lbrakk>A \\<in># M \\<cdot> \\<Delta>;\n                 \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n                \\<Longrightarrow> \\<exists>B. A = Modal M [B];\n        A \\<in># M \\<cdot> add_mset x \\<Delta>;\n        add_mset x \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. A = Modal M [B]", "then"], ["proof (chain)\npicking this:\n  A \\<in># \\<LM> Modal M [x]  \\<RM>", "have \"A \\<in> set_mset (\\<LM>Modal M [x]\\<RM>)\""], ["proof (prove)\nusing this:\n  A \\<in># \\<LM> Modal M [x]  \\<RM>\n\ngoal (1 subgoal):\n 1. A \\<in># \\<LM> Modal M [x]  \\<RM>", "by (auto simp only:set_mset_def)"], ["proof (state)\nthis:\n  A \\<in># \\<LM> Modal M [x]  \\<RM>\n\ngoal (1 subgoal):\n 1. \\<And>x \\<Delta>.\n       \\<lbrakk>\\<lbrakk>A \\<in># M \\<cdot> \\<Delta>;\n                 \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n                \\<Longrightarrow> \\<exists>B. A = Modal M [B];\n        A \\<in># M \\<cdot> add_mset x \\<Delta>;\n        add_mset x \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. A = Modal M [B]", "then"], ["proof (chain)\npicking this:\n  A \\<in># \\<LM> Modal M [x]  \\<RM>", "have \"A \\<in> {Modal M [x]}\""], ["proof (prove)\nusing this:\n  A \\<in># \\<LM> Modal M [x]  \\<RM>\n\ngoal (1 subgoal):\n 1. A \\<in> {Modal M [x]}", "by auto"], ["proof (state)\nthis:\n  A \\<in> {Modal M [x]}\n\ngoal (1 subgoal):\n 1. \\<And>x \\<Delta>.\n       \\<lbrakk>\\<lbrakk>A \\<in># M \\<cdot> \\<Delta>;\n                 \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n                \\<Longrightarrow> \\<exists>B. A = Modal M [B];\n        A \\<in># M \\<cdot> add_mset x \\<Delta>;\n        add_mset x \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. A = Modal M [B]", "then"], ["proof (chain)\npicking this:\n  A \\<in> {Modal M [x]}", "have \"A = Modal M [x]\""], ["proof (prove)\nusing this:\n  A \\<in> {Modal M [x]}\n\ngoal (1 subgoal):\n 1. A = Modal M [x]", "by auto"], ["proof (state)\nthis:\n  A = Modal M [x]\n\ngoal (1 subgoal):\n 1. \\<And>x \\<Delta>.\n       \\<lbrakk>\\<lbrakk>A \\<in># M \\<cdot> \\<Delta>;\n                 \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n                \\<Longrightarrow> \\<exists>B. A = Modal M [B];\n        A \\<in># M \\<cdot> add_mset x \\<Delta>;\n        add_mset x \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. A = Modal M [B]", "then"], ["proof (chain)\npicking this:\n  A = Modal M [x]", "have \"\\<exists> B. A = Modal M [B]\""], ["proof (prove)\nusing this:\n  A = Modal M [x]\n\ngoal (1 subgoal):\n 1. \\<exists>B. A = Modal M [B]", "by blast"], ["proof (state)\nthis:\n  \\<exists>B. A = Modal M [B]\n\ngoal (1 subgoal):\n 1. \\<And>x \\<Delta>.\n       \\<lbrakk>\\<lbrakk>A \\<in># M \\<cdot> \\<Delta>;\n                 \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n                \\<Longrightarrow> \\<exists>B. A = Modal M [B];\n        A \\<in># M \\<cdot> add_mset x \\<Delta>;\n        add_mset x \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. A = Modal M [B]", "}"], ["proof (state)\nthis:\n  A \\<in># M \\<cdot> (\\<LM> x  \\<RM>) \\<Longrightarrow>\n  \\<exists>B. A = Modal M [B]\n\ngoal (1 subgoal):\n 1. \\<And>x \\<Delta>.\n       \\<lbrakk>\\<lbrakk>A \\<in># M \\<cdot> \\<Delta>;\n                 \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n                \\<Longrightarrow> \\<exists>B. A = Modal M [B];\n        A \\<in># M \\<cdot> add_mset x \\<Delta>;\n        add_mset x \\<Delta> \\<noteq> \\<Empt>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B. A = Modal M [B]", "ultimately"], ["proof (chain)\npicking this:\n  A \\<in># M \\<cdot> \\<Delta>' \\<or> A \\<in># M \\<cdot> (\\<LM> x  \\<RM>)\n  A \\<in># M \\<cdot> \\<Delta>' \\<Longrightarrow> \\<exists>B. A = Modal M [B]\n  A \\<in># M \\<cdot> (\\<LM> x  \\<RM>) \\<Longrightarrow>\n  \\<exists>B. A = Modal M [B]", "show ?case"], ["proof (prove)\nusing this:\n  A \\<in># M \\<cdot> \\<Delta>' \\<or> A \\<in># M \\<cdot> (\\<LM> x  \\<RM>)\n  A \\<in># M \\<cdot> \\<Delta>' \\<Longrightarrow> \\<exists>B. A = Modal M [B]\n  A \\<in># M \\<cdot> (\\<LM> x  \\<RM>) \\<Longrightarrow>\n  \\<exists>B. A = Modal M [B]\n\ngoal (1 subgoal):\n 1. \\<exists>B. A = Modal M [B]", "by blast"], ["proof (state)\nthis:\n  \\<exists>B. A = Modal M [B]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>B. A = Modal M [B]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma non_contain:\nfixes \\<Delta> \\<Delta>' :: \"('a,'b) form multiset\"\nassumes \"\\<Delta> \\<noteq> \\<Empt>\" and \"\\<Delta>' \\<noteq> \\<Empt>\" and \"M \\<noteq> N\"\nshows \"set_mset (M\\<cdot>\\<Delta>) \\<inter> set_mset (N\\<cdot>\\<Delta>') = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mset (M \\<cdot> \\<Delta>) \\<inter> set_mset (N \\<cdot> \\<Delta>') =\n    {}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. set_mset (M \\<cdot> \\<Delta>) \\<inter> set_mset (N \\<cdot> \\<Delta>') =\n    {}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. set_mset (M \\<cdot> \\<Delta>) \\<inter> set_mset (N \\<cdot> \\<Delta>') =\n    {}", "assume \"set_mset (M\\<cdot>\\<Delta>) \\<inter> set_mset (N\\<cdot>\\<Delta>') \\<noteq> {}\""], ["proof (state)\nthis:\n  set_mset (M \\<cdot> \\<Delta>) \\<inter>\n  set_mset (N \\<cdot> \\<Delta>') \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. set_mset (M \\<cdot> \\<Delta>) \\<inter> set_mset (N \\<cdot> \\<Delta>') =\n    {}", "then"], ["proof (chain)\npicking this:\n  set_mset (M \\<cdot> \\<Delta>) \\<inter>\n  set_mset (N \\<cdot> \\<Delta>') \\<noteq>\n  {}", "have \"\\<exists> A. A \\<in> set_mset (M\\<cdot>\\<Delta>) \\<inter> set_mset (N\\<cdot>\\<Delta>')\""], ["proof (prove)\nusing this:\n  set_mset (M \\<cdot> \\<Delta>) \\<inter>\n  set_mset (N \\<cdot> \\<Delta>') \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       A \\<in> set_mset (M \\<cdot> \\<Delta>) \\<inter>\n               set_mset (N \\<cdot> \\<Delta>')", "by auto"], ["proof (state)\nthis:\n  \\<exists>A.\n     A \\<in> set_mset (M \\<cdot> \\<Delta>) \\<inter>\n             set_mset (N \\<cdot> \\<Delta>')\n\ngoal (1 subgoal):\n 1. set_mset (M \\<cdot> \\<Delta>) \\<inter> set_mset (N \\<cdot> \\<Delta>') =\n    {}", "then"], ["proof (chain)\npicking this:\n  \\<exists>A.\n     A \\<in> set_mset (M \\<cdot> \\<Delta>) \\<inter>\n             set_mset (N \\<cdot> \\<Delta>')", "obtain A where a: \"A \\<in> set_mset (M\\<cdot>\\<Delta>) \\<inter> set_mset (N\\<cdot>\\<Delta>')\""], ["proof (prove)\nusing this:\n  \\<exists>A.\n     A \\<in> set_mset (M \\<cdot> \\<Delta>) \\<inter>\n             set_mset (N \\<cdot> \\<Delta>')\n\ngoal (1 subgoal):\n 1. (\\<And>A.\n        A \\<in> set_mset (M \\<cdot> \\<Delta>) \\<inter>\n                set_mset (N \\<cdot> \\<Delta>') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  A \\<in> set_mset (M \\<cdot> \\<Delta>) \\<inter>\n          set_mset (N \\<cdot> \\<Delta>')\n\ngoal (1 subgoal):\n 1. set_mset (M \\<cdot> \\<Delta>) \\<inter> set_mset (N \\<cdot> \\<Delta>') =\n    {}", "then"], ["proof (chain)\npicking this:\n  A \\<in> set_mset (M \\<cdot> \\<Delta>) \\<inter>\n          set_mset (N \\<cdot> \\<Delta>')", "have \"False\""], ["proof (prove)\nusing this:\n  A \\<in> set_mset (M \\<cdot> \\<Delta>) \\<inter>\n          set_mset (N \\<cdot> \\<Delta>')\n\ngoal (1 subgoal):\n 1. False", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. A \\<in> set_mset (M \\<cdot> \\<Delta>) \\<inter>\n            set_mset (N \\<cdot> \\<Delta>') \\<Longrightarrow>\n    False", "from a"], ["proof (chain)\npicking this:\n  A \\<in> set_mset (M \\<cdot> \\<Delta>) \\<inter>\n          set_mset (N \\<cdot> \\<Delta>')", "have box: \"A \\<in> set_mset (M\\<cdot>\\<Delta>)\" and dia: \"A \\<in> set_mset (N\\<cdot>\\<Delta>')\""], ["proof (prove)\nusing this:\n  A \\<in> set_mset (M \\<cdot> \\<Delta>) \\<inter>\n          set_mset (N \\<cdot> \\<Delta>')\n\ngoal (1 subgoal):\n 1. A \\<in># M \\<cdot> \\<Delta> &&& A \\<in># N \\<cdot> \\<Delta>'", "by auto"], ["proof (state)\nthis:\n  A \\<in># M \\<cdot> \\<Delta>\n  A \\<in># N \\<cdot> \\<Delta>'\n\ngoal (1 subgoal):\n 1. A \\<in> set_mset (M \\<cdot> \\<Delta>) \\<inter>\n            set_mset (N \\<cdot> \\<Delta>') \\<Longrightarrow>\n    False", "from box"], ["proof (chain)\npicking this:\n  A \\<in># M \\<cdot> \\<Delta>", "have \"A \\<in># M\\<cdot>\\<Delta>\""], ["proof (prove)\nusing this:\n  A \\<in># M \\<cdot> \\<Delta>\n\ngoal (1 subgoal):\n 1. A \\<in># M \\<cdot> \\<Delta>", "by auto"], ["proof (state)\nthis:\n  A \\<in># M \\<cdot> \\<Delta>\n\ngoal (1 subgoal):\n 1. A \\<in> set_mset (M \\<cdot> \\<Delta>) \\<inter>\n            set_mset (N \\<cdot> \\<Delta>') \\<Longrightarrow>\n    False", "with \\<open>\\<Delta> \\<noteq> \\<Empt>\\<close>"], ["proof (chain)\npicking this:\n  \\<Delta> \\<noteq> \\<Empt>\n  A \\<in># M \\<cdot> \\<Delta>", "have \"\\<exists> B. A = Modal M [B]\""], ["proof (prove)\nusing this:\n  \\<Delta> \\<noteq> \\<Empt>\n  A \\<in># M \\<cdot> \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<exists>B. A = Modal M [B]", "using modalise_characterise[where M=M]"], ["proof (prove)\nusing this:\n  \\<Delta> \\<noteq> \\<Empt>\n  A \\<in># M \\<cdot> \\<Delta>\n  ?A \\<in># M \\<cdot> ?\\<Delta> \\<Longrightarrow>\n  \\<exists>B. ?A = Modal M [B]\n\ngoal (1 subgoal):\n 1. \\<exists>B. A = Modal M [B]", "by (auto)"], ["proof (state)\nthis:\n  \\<exists>B. A = Modal M [B]\n\ngoal (1 subgoal):\n 1. A \\<in> set_mset (M \\<cdot> \\<Delta>) \\<inter>\n            set_mset (N \\<cdot> \\<Delta>') \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>B. A = Modal M [B]", "obtain B where \"A = Modal M [B]\""], ["proof (prove)\nusing this:\n  \\<exists>B. A = Modal M [B]\n\ngoal (1 subgoal):\n 1. (\\<And>B. A = Modal M [B] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  A = Modal M [B]\n\ngoal (1 subgoal):\n 1. A \\<in> set_mset (M \\<cdot> \\<Delta>) \\<inter>\n            set_mset (N \\<cdot> \\<Delta>') \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  A = Modal M [B]\n\ngoal (1 subgoal):\n 1. A \\<in> set_mset (M \\<cdot> \\<Delta>) \\<inter>\n            set_mset (N \\<cdot> \\<Delta>') \\<Longrightarrow>\n    False", "from dia"], ["proof (chain)\npicking this:\n  A \\<in># N \\<cdot> \\<Delta>'", "have \"A \\<in># N\\<cdot>\\<Delta>'\""], ["proof (prove)\nusing this:\n  A \\<in># N \\<cdot> \\<Delta>'\n\ngoal (1 subgoal):\n 1. A \\<in># N \\<cdot> \\<Delta>'", "by auto"], ["proof (state)\nthis:\n  A \\<in># N \\<cdot> \\<Delta>'\n\ngoal (1 subgoal):\n 1. A \\<in> set_mset (M \\<cdot> \\<Delta>) \\<inter>\n            set_mset (N \\<cdot> \\<Delta>') \\<Longrightarrow>\n    False", "with \\<open>\\<Delta>' \\<noteq> \\<Empt>\\<close>"], ["proof (chain)\npicking this:\n  \\<Delta>' \\<noteq> \\<Empt>\n  A \\<in># N \\<cdot> \\<Delta>'", "have \"\\<exists> C. A = Modal N [C]\""], ["proof (prove)\nusing this:\n  \\<Delta>' \\<noteq> \\<Empt>\n  A \\<in># N \\<cdot> \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<exists>C. A = Modal N [C]", "using modalise_characterise[where M=N]"], ["proof (prove)\nusing this:\n  \\<Delta>' \\<noteq> \\<Empt>\n  A \\<in># N \\<cdot> \\<Delta>'\n  ?A \\<in># N \\<cdot> ?\\<Delta> \\<Longrightarrow>\n  \\<exists>B. ?A = Modal N [B]\n\ngoal (1 subgoal):\n 1. \\<exists>C. A = Modal N [C]", "by auto"], ["proof (state)\nthis:\n  \\<exists>C. A = Modal N [C]\n\ngoal (1 subgoal):\n 1. A \\<in> set_mset (M \\<cdot> \\<Delta>) \\<inter>\n            set_mset (N \\<cdot> \\<Delta>') \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>C. A = Modal N [C]", "obtain C where \"A = Modal N [C]\""], ["proof (prove)\nusing this:\n  \\<exists>C. A = Modal N [C]\n\ngoal (1 subgoal):\n 1. (\\<And>C. A = Modal N [C] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  A = Modal N [C]\n\ngoal (1 subgoal):\n 1. A \\<in> set_mset (M \\<cdot> \\<Delta>) \\<inter>\n            set_mset (N \\<cdot> \\<Delta>') \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  A = Modal M [B]\n  A = Modal N [C]", "show \"False\""], ["proof (prove)\nusing this:\n  A = Modal M [B]\n  A = Modal N [C]\n\ngoal (1 subgoal):\n 1. False", "using \\<open>M\\<noteq>N\\<close>"], ["proof (prove)\nusing this:\n  A = Modal M [B]\n  A = Modal N [C]\n  M \\<noteq> N\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. set_mset (M \\<cdot> \\<Delta>) \\<inter> set_mset (N \\<cdot> \\<Delta>') =\n    {}", "}"], ["proof (state)\nthis:\n  set_mset (M \\<cdot> \\<Delta>) \\<inter>\n  set_mset (N \\<cdot> \\<Delta>') \\<noteq>\n  {} \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. set_mset (M \\<cdot> \\<Delta>) \\<inter> set_mset (N \\<cdot> \\<Delta>') =\n    {}", "then"], ["proof (chain)\npicking this:\n  set_mset (M \\<cdot> \\<Delta>) \\<inter>\n  set_mset (N \\<cdot> \\<Delta>') \\<noteq>\n  {} \\<Longrightarrow>\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  set_mset (M \\<cdot> \\<Delta>) \\<inter>\n  set_mset (N \\<cdot> \\<Delta>') \\<noteq>\n  {} \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. set_mset (M \\<cdot> \\<Delta>) \\<inter> set_mset (N \\<cdot> \\<Delta>') =\n    {}", "by auto"], ["proof (state)\nthis:\n  set_mset (M \\<cdot> \\<Delta>) \\<inter> set_mset (N \\<cdot> \\<Delta>') = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma modal_neq:\nfixes A :: \"('a,'b) form\" and ps :: \"('a,'b) form list\"\nshows \"A \\<noteq> Modal M [A]\" and \"ps \\<noteq> [Modal M ps]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> Modal M [A] &&& ps \\<noteq> [Modal M ps]", "by (induct A and ps rule: compat_form.induct compat_form_list.induct) auto"], ["", "lemma p_e_non_empty: \n \"r \\<in> p_e R M N \\<Longrightarrow> fst r \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<in> p_e R M N \\<Longrightarrow> fst r \\<noteq> []", "apply (rule p_e.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. r \\<in> p_e R M N \\<Longrightarrow> ?a \\<in> p_e ?R ?M ?N\n 2. \\<And>Ps c \\<Gamma> \\<Delta>.\n       \\<lbrakk>r \\<in> p_e R M N;\n        ?a =\n        extendRule ( ?M \\<cdot> \\<Gamma> \\<Rightarrow>* ?N \\<cdot> \\<Delta>)\n         (Ps, c);\n        (Ps, c) \\<in> ?R; ?R \\<subseteq> modRules2\\<rbrakk>\n       \\<Longrightarrow> fst r \\<noteq> []", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps c \\<Gamma> \\<Delta>.\n       \\<lbrakk>extendRule\n                 ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n                 (Ps, c)\n                \\<in> p_e R M N;\n        (Ps, c) \\<in> R; R \\<subseteq> modRules2;\n        r =\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Ps, c);\n        fst (extendRule\n              ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n              (Ps, c)) =\n        []\\<rbrakk>\n       \\<Longrightarrow> False", "apply (subgoal_tac \"(Ps, c) \\<in> modRules2\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Ps c \\<Gamma> \\<Delta>.\n       \\<lbrakk>extendRule\n                 ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n                 (Ps, c)\n                \\<in> p_e R M N;\n        (Ps, c) \\<in> R; R \\<subseteq> modRules2;\n        r =\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Ps, c);\n        fst (extendRule\n              ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n              (Ps, c)) =\n        [];\n        (Ps, c) \\<in> modRules2\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Ps c \\<Gamma> \\<Delta>.\n       \\<lbrakk>extendRule\n                 ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n                 (Ps, c)\n                \\<in> p_e R M N;\n        (Ps, c) \\<in> R; R \\<subseteq> modRules2;\n        r =\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Ps, c);\n        fst (extendRule\n              ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n              (Ps, c)) =\n        []\\<rbrakk>\n       \\<Longrightarrow> (Ps, c) \\<in> modRules2", "apply (rule modRules2.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Ps c \\<Gamma> \\<Delta>.\n       \\<lbrakk>extendRule\n                 ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n                 (Ps, c)\n                \\<in> p_e R M N;\n        (Ps, c) \\<in> R; R \\<subseteq> modRules2;\n        r =\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Ps, c);\n        fst (extendRule\n              ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n              (Ps, c)) =\n        [];\n        (Ps, c) \\<in> modRules2\\<rbrakk>\n       \\<Longrightarrow> (?a1.7 Ps c \\<Gamma> \\<Delta>,\n                          ?a2.7 Ps c \\<Gamma> \\<Delta>)\n                         \\<in> modRules2\n 2. \\<And>Ps c \\<Gamma> \\<Delta> ps ca Ma Ms.\n       \\<lbrakk>extendRule\n                 ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n                 (Ps, c)\n                \\<in> p_e R M N;\n        (Ps, c) \\<in> R; R \\<subseteq> modRules2;\n        r =\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Ps, c);\n        fst (extendRule\n              ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n              (Ps, c)) =\n        [];\n        (Ps, c) \\<in> modRules2; ?a1.7 Ps c \\<Gamma> \\<Delta> = ps;\n        ?a2.7 Ps c \\<Gamma> \\<Delta> = ca; ps \\<noteq> [];\n        ModalSequents.mset ca = \\<LM> Modal Ma Ms  \\<RM>\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>Ps c \\<Gamma> \\<Delta>.\n       \\<lbrakk>extendRule\n                 ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n                 (Ps, c)\n                \\<in> p_e R M N;\n        (Ps, c) \\<in> R; R \\<subseteq> modRules2;\n        r =\n        extendRule ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         (Ps, c);\n        fst (extendRule\n              ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n              (Ps, c)) =\n        []\\<rbrakk>\n       \\<Longrightarrow> (Ps, c) \\<in> modRules2", "by (auto simp add:extendRule_def)"], ["", "(* -------------------------------\n   -------------------------------\n        ModalWeakening2.thy\n   -------------------------------\n   ------------------------------- *)"], ["", "lemma dpWeak:\nassumes a:\"(\\<Gamma> \\<Rightarrow>* \\<Delta>,n) \\<in> derivable (ext R R2 M N)\"\n   and  b: \"R1 \\<subseteq> upRules\"\n   and  c: \"R2 \\<subseteq> modRules2\"\n   and  d: \"R3 \\<subseteq> modRules2\"\n   and  e: \"R = Ax \\<union> R1 \\<union> (p_e R2 M N) \\<union> R3\" \nshows \"(\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',n) \\<in> derivable (ext R R2 M N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)", "using a"], ["proof (prove)\nusing this:\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>, n) \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)", "proof (induct n arbitrary: \\<Gamma> \\<Delta> rule:nat_less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n \\<Gamma> \\<Delta>.\n       \\<lbrakk>\\<forall>m<n.\n                   \\<forall>x xa.\n                      ( x \\<Rightarrow>* xa, m)\n                      \\<in> derivable (ext R R2 M N) \\<longrightarrow>\n                      ( x + \\<Gamma>' \\<Rightarrow>* xa + \\<Delta>', m)\n                      \\<in> derivable (ext R R2 M N);\n        ( \\<Gamma> \\<Rightarrow>* \\<Delta>, n)\n        \\<in> derivable (ext R R2 M N)\\<rbrakk>\n       \\<Longrightarrow> ( \\<Gamma> +\n                           \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                          n)\n                         \\<in> derivable (ext R R2 M N)", "case (1 n \\<Gamma> \\<Delta>)"], ["proof (state)\nthis:\n  \\<forall>m<n.\n     \\<forall>x xa.\n        ( x \\<Rightarrow>* xa, m)\n        \\<in> derivable (ext R R2 M N) \\<longrightarrow>\n        ( x + \\<Gamma>' \\<Rightarrow>* xa + \\<Delta>', m)\n        \\<in> derivable (ext R R2 M N)\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>, n) \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. \\<And>n \\<Gamma> \\<Delta>.\n       \\<lbrakk>\\<forall>m<n.\n                   \\<forall>x xa.\n                      ( x \\<Rightarrow>* xa, m)\n                      \\<in> derivable (ext R R2 M N) \\<longrightarrow>\n                      ( x + \\<Gamma>' \\<Rightarrow>* xa + \\<Delta>', m)\n                      \\<in> derivable (ext R R2 M N);\n        ( \\<Gamma> \\<Rightarrow>* \\<Delta>, n)\n        \\<in> derivable (ext R R2 M N)\\<rbrakk>\n       \\<Longrightarrow> ( \\<Gamma> +\n                           \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                          n)\n                         \\<in> derivable (ext R R2 M N)", "then"], ["proof (chain)\npicking this:\n  \\<forall>m<n.\n     \\<forall>x xa.\n        ( x \\<Rightarrow>* xa, m)\n        \\<in> derivable (ext R R2 M N) \\<longrightarrow>\n        ( x + \\<Gamma>' \\<Rightarrow>* xa + \\<Delta>', m)\n        \\<in> derivable (ext R R2 M N)\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>, n) \\<in> derivable (ext R R2 M N)", "have IH: \"\\<forall>m<n. \\<forall> \\<Gamma> \\<Delta>. ( \\<Gamma> \\<Rightarrow>* \\<Delta>, m) \\<in> derivable (ext R R2 M N) \\<longrightarrow> ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m) \\<in> derivable (ext R R2 M N)\" \n      and a': \"( \\<Gamma> \\<Rightarrow>* \\<Delta>, n) \\<in> derivable (ext R R2 M N)\""], ["proof (prove)\nusing this:\n  \\<forall>m<n.\n     \\<forall>x xa.\n        ( x \\<Rightarrow>* xa, m)\n        \\<in> derivable (ext R R2 M N) \\<longrightarrow>\n        ( x + \\<Gamma>' \\<Rightarrow>* xa + \\<Delta>', m)\n        \\<in> derivable (ext R R2 M N)\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>, n) \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. \\<forall>m<n.\n       \\<forall>\\<Gamma> \\<Delta>.\n          ( \\<Gamma> \\<Rightarrow>* \\<Delta>, m)\n          \\<in> derivable (ext R R2 M N) \\<longrightarrow>\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M N) &&&\n    ( \\<Gamma> \\<Rightarrow>* \\<Delta>, n) \\<in> derivable (ext R R2 M N)", "by auto"], ["proof (state)\nthis:\n  \\<forall>m<n.\n     \\<forall>\\<Gamma> \\<Delta>.\n        ( \\<Gamma> \\<Rightarrow>* \\<Delta>, m)\n        \\<in> derivable (ext R R2 M N) \\<longrightarrow>\n        ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n        \\<in> derivable (ext R R2 M N)\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>, n) \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. \\<And>n \\<Gamma> \\<Delta>.\n       \\<lbrakk>\\<forall>m<n.\n                   \\<forall>x xa.\n                      ( x \\<Rightarrow>* xa, m)\n                      \\<in> derivable (ext R R2 M N) \\<longrightarrow>\n                      ( x + \\<Gamma>' \\<Rightarrow>* xa + \\<Delta>', m)\n                      \\<in> derivable (ext R R2 M N);\n        ( \\<Gamma> \\<Rightarrow>* \\<Delta>, n)\n        \\<in> derivable (ext R R2 M N)\\<rbrakk>\n       \\<Longrightarrow> ( \\<Gamma> +\n                           \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                          n)\n                         \\<in> derivable (ext R R2 M N)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "then"], ["proof (chain)\npicking this:\n  n = 0", "have \"(\\<Gamma> \\<Rightarrow>* \\<Delta>,0) \\<in> derivable (ext R R2 M N)\""], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<Rightarrow>* \\<Delta>, 0) \\<in> derivable (ext R R2 M N)", "using a'"], ["proof (prove)\nusing this:\n  n = 0\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>, n) \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<Rightarrow>* \\<Delta>, 0) \\<in> derivable (ext R R2 M N)", "by simp"], ["proof (state)\nthis:\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>, 0) \\<in> derivable (ext R R2 M N)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "then"], ["proof (chain)\npicking this:\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>, 0) \\<in> derivable (ext R R2 M N)", "have \"([], \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> (ext R R2 M N)\""], ["proof (prove)\nusing this:\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>, 0) \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> ext R R2 M N", "by (cases) auto"], ["proof (state)\nthis:\n  ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> ext R R2 M N\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "then"], ["proof (chain)\npicking this:\n  ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> ext R R2 M N", "obtain  r S where \"r \\<in> R\" and split:\"(extendRule S r = ([],\\<Gamma> \\<Rightarrow>* \\<Delta>) \\<or> extendConc S r = ([],\\<Gamma> \\<Rightarrow>* \\<Delta>))\""], ["proof (prove)\nusing this:\n  ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> ext R R2 M N\n\ngoal (1 subgoal):\n 1. (\\<And>r S.\n        \\<lbrakk>r \\<in> R;\n         extendRule S r = ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<or>\n         extendConc S r = ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (rule ext.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>r seq.\n       \\<lbrakk>\\<And>r S.\n                   \\<lbrakk>r \\<in> R;\n                    extendRule S r =\n                    ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<or>\n                    extendConc S r =\n                    ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) = extendRule seq r;\n        r \\<in> R; case r of (x, xa) \\<Rightarrow> (x, xa) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>r seq.\n       \\<lbrakk>\\<And>r S.\n                   \\<lbrakk>r \\<in> R;\n                    extendRule S r =\n                    ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<or>\n                    extendConc S r =\n                    ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) = extendRule seq r;\n        r \\<in> R;\n        case r of (x, xa) \\<Rightarrow> (x, xa) \\<in> upRules\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>r seq.\n       \\<lbrakk>\\<And>r S.\n                   \\<lbrakk>r \\<in> R;\n                    extendRule S r =\n                    ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<or>\n                    extendConc S r =\n                    ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) = extendConc seq r;\n        r \\<in> p_e R2 M N; r \\<in> R\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>r seq.\n       \\<lbrakk>\\<And>r S.\n                   \\<lbrakk>r \\<in> R;\n                    extendRule S r =\n                    ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<or>\n                    extendConc S r =\n                    ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) = extendRule seq r;\n        r \\<in> R;\n        case r of (x, xa) \\<Rightarrow> (x, xa) \\<in> modRules2\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (auto simp add:extendRule_def extend_def extendConc_def)"], ["proof (state)\nthis:\n  r \\<in> R\n  extendRule S r = ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<or>\n  extendConc S r = ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "then"], ["proof (chain)\npicking this:\n  r \\<in> R\n  extendRule S r = ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<or>\n  extendConc S r = ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>)", "obtain c where \"r = ([],c)\""], ["proof (prove)\nusing this:\n  r \\<in> R\n  extendRule S r = ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<or>\n  extendConc S r = ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. (\\<And>c. r = ([], c) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases r) (auto simp add:extendRule_def extendConc_def)"], ["proof (state)\nthis:\n  r = ([], c)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "with \\<open>r \\<in> R\\<close>"], ["proof (chain)\npicking this:\n  r \\<in> R\n  r = ([], c)", "have \"r \\<in> Ax \\<or> (r \\<in> upRules \\<union> (p_e R2 M N) \\<union> modRules2)\""], ["proof (prove)\nusing this:\n  r \\<in> R\n  r = ([], c)\n\ngoal (1 subgoal):\n 1. r \\<in> Ax \\<or> r \\<in> upRules \\<union> p_e R2 M N \\<union> modRules2", "using b c d e"], ["proof (prove)\nusing this:\n  r \\<in> R\n  r = ([], c)\n  R1 \\<subseteq> upRules\n  R2 \\<subseteq> modRules2\n  R3 \\<subseteq> modRules2\n  R = Ax \\<union> R1 \\<union> p_e R2 M N \\<union> R3\n\ngoal (1 subgoal):\n 1. r \\<in> Ax \\<or> r \\<in> upRules \\<union> p_e R2 M N \\<union> modRules2", "by auto"], ["proof (state)\nthis:\n  r \\<in> Ax \\<or> r \\<in> upRules \\<union> p_e R2 M N \\<union> modRules2\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "with \\<open>r = ([],c)\\<close>"], ["proof (chain)\npicking this:\n  r = ([], c)\n  r \\<in> Ax \\<or> r \\<in> upRules \\<union> p_e R2 M N \\<union> modRules2", "have \"r \\<in> Ax\""], ["proof (prove)\nusing this:\n  r = ([], c)\n  r \\<in> Ax \\<or> r \\<in> upRules \\<union> p_e R2 M N \\<union> modRules2\n\ngoal (1 subgoal):\n 1. r \\<in> Ax", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>r = ([], c); ([], c) \\<in> upRules\\<rbrakk>\n    \\<Longrightarrow> ([], c) \\<in> Ax\n 2. \\<lbrakk>r = ([], c); ([], c) \\<in> p_e R2 M N\\<rbrakk>\n    \\<Longrightarrow> ([], c) \\<in> Ax\n 3. \\<lbrakk>r = ([], c); ([], c) \\<in> modRules2\\<rbrakk>\n    \\<Longrightarrow> ([], c) \\<in> Ax", "apply (rule upRules.cases,auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r = ([], c); ([], c) \\<in> p_e R2 M N\\<rbrakk>\n    \\<Longrightarrow> ([], c) \\<in> Ax\n 2. \\<lbrakk>r = ([], c); ([], c) \\<in> modRules2\\<rbrakk>\n    \\<Longrightarrow> ([], c) \\<in> Ax", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r = ([], c); ([], c) \\<in> modRules2\\<rbrakk>\n    \\<Longrightarrow> ([], c) \\<in> Ax\n 2. \\<lbrakk>r = ([], c); ([], c) \\<in> p_e R2 M N\\<rbrakk>\n    \\<Longrightarrow> ([], c) \\<in> Ax", "apply (rule modRules2.cases, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = ([], c); ([], c) \\<in> p_e R2 M N\\<rbrakk>\n    \\<Longrightarrow> ([], c) \\<in> Ax", "apply (rule p_e.cases,auto simp add:extendRule_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ca \\<Gamma> \\<Delta>.\n       \\<lbrakk>r =\n                ([],\n                 extend\n                  ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n                  ca);\n        ([],\n         extend ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>) ca)\n        \\<in> p_e R2 M N;\n        ([], ca) \\<in> R2; R2 \\<subseteq> modRules2;\n        c =\n        extend ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n         ca\\<rbrakk>\n       \\<Longrightarrow> ([],\n                          extend\n                           ( M \\<cdot>\n                             \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n                           ca)\n                         \\<in> Ax", "apply hypsubst_thin"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c \\<Gamma> \\<Delta>.\n       \\<lbrakk>([],\n                 extend\n                  ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>) c)\n                \\<in> p_e R2 M N;\n        ([], c) \\<in> R2; R2 \\<subseteq> modRules2\\<rbrakk>\n       \\<Longrightarrow> ([],\n                          extend\n                           ( M \\<cdot>\n                             \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n                           c)\n                         \\<in> Ax", "apply (insert p_e_non_empty[where R=R2 and M=M and N=N])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c \\<Gamma> \\<Delta>.\n       \\<lbrakk>([],\n                 extend\n                  ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>) c)\n                \\<in> p_e R2 M N;\n        ([], c) \\<in> R2; R2 \\<subseteq> modRules2;\n        \\<And>r.\n           r \\<in> p_e R2 M N \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ([],\n                          extend\n                           ( M \\<cdot>\n                             \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n                           c)\n                         \\<in> Ax", "apply (drule_tac x=\"([], extend ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>) c)\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c \\<Gamma> \\<Delta>.\n       \\<lbrakk>([],\n                 extend\n                  ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>) c)\n                \\<in> p_e R2 M N;\n        ([], c) \\<in> R2; R2 \\<subseteq> modRules2;\n        ([],\n         extend ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>) c)\n        \\<in> p_e R2 M N \\<Longrightarrow>\n        fst ([],\n             extend ( M \\<cdot> \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n              c) \\<noteq>\n        []\\<rbrakk>\n       \\<Longrightarrow> ([],\n                          extend\n                           ( M \\<cdot>\n                             \\<Gamma> \\<Rightarrow>* N \\<cdot> \\<Delta>)\n                           c)\n                         \\<in> Ax", "by auto"], ["proof (state)\nthis:\n  r \\<in> Ax\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "with \\<open>r = ([],c)\\<close>"], ["proof (chain)\npicking this:\n  r = ([], c)\n  r \\<in> Ax", "obtain i where \"c = (\\<LM>At i\\<RM> \\<Rightarrow>* \\<LM>At i\\<RM>) \\<or> c = (\\<LM>ff\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  r = ([], c)\n  r \\<in> Ax\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        c = ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<or>\n        c = ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using characteriseAx[where r=r]"], ["proof (prove)\nusing this:\n  r = ([], c)\n  r \\<in> Ax\n  r \\<in> Ax \\<Longrightarrow>\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n  (\\<exists>i.\n      r = ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        c = ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<or>\n        c = ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c = ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<or>\n  c = ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "moreover"], ["proof (state)\nthis:\n  c = ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<or>\n  c = ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "{"], ["proof (state)\nthis:\n  c = ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<or>\n  c = ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "assume \"c = (\\<LM>At i\\<RM> \\<Rightarrow>* \\<LM>At i\\<RM>)\""], ["proof (state)\nthis:\n  c = ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "then"], ["proof (chain)\npicking this:\n  c = ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)", "have \"extend S (\\<LM>At i\\<RM> \\<Rightarrow>*\\<LM>At i\\<RM>) = (\\<Gamma> \\<Rightarrow>* \\<Delta>)\""], ["proof (prove)\nusing this:\n  c = ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n\ngoal (1 subgoal):\n 1. extend S ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n    ( \\<Gamma> \\<Rightarrow>* \\<Delta>)", "using split and \\<open>r = ([],c)\\<close>"], ["proof (prove)\nusing this:\n  c = ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n  extendRule S r = ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<or>\n  extendConc S r = ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  r = ([], c)\n\ngoal (1 subgoal):\n 1. extend S ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n    ( \\<Gamma> \\<Rightarrow>* \\<Delta>)", "by (auto simp add:extendRule_def extendConc_def)"], ["proof (state)\nthis:\n  extend S ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "then"], ["proof (chain)\npicking this:\n  extend S ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>)", "have \"At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>\""], ["proof (prove)\nusing this:\n  extend S ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>", "using extendID"], ["proof (prove)\nusing this:\n  extend S ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  extend ?S ( \\<LM> At ?i  \\<RM> \\<Rightarrow>* \\<LM> At ?i  \\<RM>) =\n  ( ?\\<Gamma> \\<Rightarrow>* ?\\<Delta>) \\<Longrightarrow>\n  At ?i \\<in># ?\\<Gamma> \\<and> At ?i \\<in># ?\\<Delta>\n\ngoal (1 subgoal):\n 1. At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>", "by auto"], ["proof (state)\nthis:\n  At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "then"], ["proof (chain)\npicking this:\n  At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>", "have \"At i \\<in># \\<Gamma> + \\<Gamma>' \\<and> At i \\<in># \\<Delta> + \\<Delta>'\""], ["proof (prove)\nusing this:\n  At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>\n\ngoal (1 subgoal):\n 1. At i \\<in># \\<Gamma> + \\<Gamma>' \\<and> At i \\<in># \\<Delta> + \\<Delta>'", "by auto"], ["proof (state)\nthis:\n  At i \\<in># \\<Gamma> + \\<Gamma>' \\<and> At i \\<in># \\<Delta> + \\<Delta>'\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "then"], ["proof (chain)\npicking this:\n  At i \\<in># \\<Gamma> + \\<Gamma>' \\<and> At i \\<in># \\<Delta> + \\<Delta>'", "have \"(\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',0) \\<in> derivable (ext R R2 M N)\""], ["proof (prove)\nusing this:\n  At i \\<in># \\<Gamma> + \\<Gamma>' \\<and> At i \\<in># \\<Delta> + \\<Delta>'\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n    \\<in> derivable (ext R R2 M N)", "using e and containID[where \\<Gamma>=\"\\<Gamma>+\\<Gamma>'\" and \\<Delta>=\"\\<Delta>+\\<Delta>'\" and R=R and i=i]"], ["proof (prove)\nusing this:\n  At i \\<in># \\<Gamma> + \\<Gamma>' \\<and> At i \\<in># \\<Delta> + \\<Delta>'\n  R = Ax \\<union> R1 \\<union> p_e R2 M N \\<union> R3\n  \\<lbrakk>At i \\<in># \\<Gamma> + \\<Gamma>' \\<and>\n           At i \\<in># \\<Delta> + \\<Delta>';\n   Ax \\<subseteq> R\\<rbrakk>\n  \\<Longrightarrow> ( \\<Gamma> +\n                      \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                     0)\n                    \\<in> derivable (ext R ?R' ?M ?N)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n    \\<in> derivable (ext R R2 M N)", "by auto"], ["proof (state)\nthis:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M N)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "}"], ["proof (state)\nthis:\n  c =\n  ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M N)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "moreover"], ["proof (state)\nthis:\n  c =\n  ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M N)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "{"], ["proof (state)\nthis:\n  c =\n  ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M N)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "assume \"c = (\\<LM>ff\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (state)\nthis:\n  c = ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "then"], ["proof (chain)\npicking this:\n  c = ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"extend S (\\<LM>ff\\<RM> \\<Rightarrow>*\\<Empt>) = (\\<Gamma> \\<Rightarrow>* \\<Delta>)\""], ["proof (prove)\nusing this:\n  c = ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. extend S ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n    ( \\<Gamma> \\<Rightarrow>* \\<Delta>)", "using split and \\<open>r = ([],c)\\<close>"], ["proof (prove)\nusing this:\n  c = ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n  extendRule S r = ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<or>\n  extendConc S r = ([],  \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  r = ([], c)\n\ngoal (1 subgoal):\n 1. extend S ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n    ( \\<Gamma> \\<Rightarrow>* \\<Delta>)", "by (auto simp add:extendRule_def extendConc_def)"], ["proof (state)\nthis:\n  extend S ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "then"], ["proof (chain)\npicking this:\n  extend S ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>)", "have \"ff \\<in># \\<Gamma>\""], ["proof (prove)\nusing this:\n  extend S ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. ff \\<in># \\<Gamma>", "using extendFalsum"], ["proof (prove)\nusing this:\n  extend S ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  extend ?S ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( ?\\<Gamma> \\<Rightarrow>* ?\\<Delta>) \\<Longrightarrow>\n  ff \\<in># ?\\<Gamma>\n\ngoal (1 subgoal):\n 1. ff \\<in># \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  ff \\<in># \\<Gamma>\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "then"], ["proof (chain)\npicking this:\n  ff \\<in># \\<Gamma>", "have \"ff \\<in># \\<Gamma> + \\<Gamma>'\""], ["proof (prove)\nusing this:\n  ff \\<in># \\<Gamma>\n\ngoal (1 subgoal):\n 1. ff \\<in># \\<Gamma> + \\<Gamma>'", "by auto"], ["proof (state)\nthis:\n  ff \\<in># \\<Gamma> + \\<Gamma>'\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "then"], ["proof (chain)\npicking this:\n  ff \\<in># \\<Gamma> + \\<Gamma>'", "have \"(\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',0) \\<in> derivable (ext R R2 M N)\""], ["proof (prove)\nusing this:\n  ff \\<in># \\<Gamma> + \\<Gamma>'\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n    \\<in> derivable (ext R R2 M N)", "using e and containFalsum[where \\<Gamma>=\"\\<Gamma>+\\<Gamma>'\" and \\<Delta>=\"\\<Delta>+\\<Delta>'\" and R=R]"], ["proof (prove)\nusing this:\n  ff \\<in># \\<Gamma> + \\<Gamma>'\n  R = Ax \\<union> R1 \\<union> p_e R2 M N \\<union> R3\n  \\<lbrakk>ff \\<in># \\<Gamma> + \\<Gamma>'; Ax \\<subseteq> R\\<rbrakk>\n  \\<Longrightarrow> ( \\<Gamma> +\n                      \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                     0)\n                    \\<in> derivable (ext R ?R' ?M ?N)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n    \\<in> derivable (ext R R2 M N)", "by auto"], ["proof (state)\nthis:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M N)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "}"], ["proof (state)\nthis:\n  c = ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M N)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "ultimately"], ["proof (chain)\npicking this:\n  c = ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<or>\n  c = ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n  c =\n  ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M N)\n  c = ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M N)", "show \"(\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',n) \\<in> derivable (ext R R2 M N)\""], ["proof (prove)\nusing this:\n  c = ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<or>\n  c = ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n  c =\n  ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M N)\n  c = ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)", "using \\<open>n=0\\<close>"], ["proof (prove)\nusing this:\n  c = ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<or>\n  c = ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n  c =\n  ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M N)\n  c = ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M N)\n  n = 0\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)", "by auto"], ["proof (state)\nthis:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n  \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "case (Suc n')"], ["proof (state)\nthis:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "then"], ["proof (chain)\npicking this:\n  n = Suc n'", "have \"(\\<Gamma> \\<Rightarrow>* \\<Delta>, n'+1) \\<in> derivable (ext R R2 M N)\""], ["proof (prove)\nusing this:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<Rightarrow>* \\<Delta>, n' + 1)\n    \\<in> derivable (ext R R2 M N)", "using a'"], ["proof (prove)\nusing this:\n  n = Suc n'\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>, n) \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<Rightarrow>* \\<Delta>, n' + 1)\n    \\<in> derivable (ext R R2 M N)", "by simp"], ["proof (state)\nthis:\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>, n' + 1) \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "then"], ["proof (chain)\npicking this:\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>, n' + 1) \\<in> derivable (ext R R2 M N)", "obtain Ps where f:\"Ps \\<noteq> []\"\n                  and g:\"(Ps, \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> (ext R R2 M N)\" \n                  and h:\"\\<forall> p \\<in> set Ps. \\<exists> m\\<le>n'. (p,m) \\<in> derivable (ext R R2 M N)\""], ["proof (prove)\nusing this:\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>, n' + 1) \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. (\\<And>Ps.\n        \\<lbrakk>Ps \\<noteq> [];\n         (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> ext R R2 M N;\n         \\<forall>p\\<in>set Ps.\n            \\<exists>m\\<le>n'.\n               (p, m) \\<in> derivable (ext R R2 M N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using characteriseLast[where C=\"\\<Gamma> \\<Rightarrow>* \\<Delta>\" and m=n' and R=\"ext R R2 M N\"]"], ["proof (prove)\nusing this:\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>, n' + 1) \\<in> derivable (ext R R2 M N)\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta>, n' + 1)\n  \\<in> derivable (ext R R2 M N) \\<Longrightarrow>\n  \\<exists>Ps.\n     Ps \\<noteq> [] \\<and>\n     (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> ext R R2 M N \\<and>\n     (\\<forall>p\\<in>set Ps.\n         \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M N))\n\ngoal (1 subgoal):\n 1. (\\<And>Ps.\n        \\<lbrakk>Ps \\<noteq> [];\n         (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> ext R R2 M N;\n         \\<forall>p\\<in>set Ps.\n            \\<exists>m\\<le>n'.\n               (p, m) \\<in> derivable (ext R R2 M N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Ps \\<noteq> []\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> ext R R2 M N\n  \\<forall>p\\<in>set Ps.\n     \\<exists>m\\<le>n'. (p, m) \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "from g c"], ["proof (chain)\npicking this:\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> ext R R2 M N\n  R2 \\<subseteq> modRules2", "obtain S r where \"r \\<in> R\" and \"((r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and> extendRule S r = (Ps, \\<Gamma> \\<Rightarrow>* \\<Delta>)) \\<or>\n                                  (r \\<in> p_e R2 M N \\<and> extendConc S r = (Ps, \\<Gamma> \\<Rightarrow>* \\<Delta>))\""], ["proof (prove)\nusing this:\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> ext R R2 M N\n  R2 \\<subseteq> modRules2\n\ngoal (1 subgoal):\n 1. (\\<And>r S.\n        \\<lbrakk>r \\<in> R;\n         (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n         extendRule S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<or>\n         r \\<in> p_e R2 M N \\<and>\n         extendConc S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases) auto"], ["proof (state)\nthis:\n  r \\<in> R\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<or>\n  r \\<in> p_e R2 M N \\<and>\n  extendConc S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "moreover"], ["proof (state)\nthis:\n  r \\<in> R\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<or>\n  r \\<in> p_e R2 M N \\<and>\n  extendConc S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "{"], ["proof (state)\nthis:\n  r \\<in> R\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<or>\n  r \\<in> p_e R2 M N \\<and>\n  extendConc S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "assume as:\"(r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and> extendRule S r = (Ps, \\<Gamma> \\<Rightarrow>* \\<Delta>)\""], ["proof (state)\nthis:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "then"], ["proof (chain)\npicking this:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>)", "have eq:\"map (extend (\\<Gamma>' \\<Rightarrow>* \\<Delta>')) Ps = fst (extendRule (extend S (\\<Gamma>' \\<Rightarrow>* \\<Delta>')) r)\""], ["proof (prove)\nusing this:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) Ps =\n    fst (extendRule (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r)", "using mapCommute[where S=\"\\<Gamma>'\\<Rightarrow>*\\<Delta>'\" and R=S and c=\"fst r\"]"], ["proof (prove)\nusing this:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n   (map (extend S) (fst r)) =\n  map (extend S)\n   (map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) (fst r))\n\ngoal (1 subgoal):\n 1. map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) Ps =\n    fst (extendRule (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r)", "by (auto simp add:extendRule_def extend_def mapAssoc simp del: map_map)"], ["proof (state)\nthis:\n  map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) Ps =\n  fst (extendRule (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "from as"], ["proof (chain)\npicking this:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>)", "have eq2: \"(\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') = snd (extendRule (extend S (\\<Gamma>' \\<Rightarrow>* \\<Delta>')) r)\""], ["proof (prove)\nusing this:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') =\n    snd (extendRule (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r)", "by (auto simp add:extendRule_def extend_def union_ac)"], ["proof (state)\nthis:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') =\n  snd (extendRule (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "from as f"], ["proof (chain)\npicking this:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  Ps \\<noteq> []", "have \"fst r \\<noteq> []\""], ["proof (prove)\nusing this:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  Ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. fst r \\<noteq> []", "by (auto simp add:extendRule_def map_is_Nil_conv)"], ["proof (state)\nthis:\n  fst r \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "with as"], ["proof (chain)\npicking this:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  fst r \\<noteq> []", "have \"r \\<in> upRules \\<or> r \\<in> modRules2\""], ["proof (prove)\nusing this:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  fst r \\<noteq> []\n\ngoal (1 subgoal):\n 1. r \\<in> upRules \\<or> r \\<in> modRules2", "apply (cases r,auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<noteq> []; r = (a, b);\n        extendRule S (a, b) = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>);\n        (a, b) \\<notin> modRules2; (a, b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> upRules", "by (rule Ax.cases) auto"], ["proof (state)\nthis:\n  r \\<in> upRules \\<or> r \\<in> modRules2\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "have \"\\<forall> p' \\<in> set (map (extend (\\<Gamma>' \\<Rightarrow>* \\<Delta>')) Ps). \\<exists> m\\<le>n'. (p',m) \\<in> derivable (ext R R2 M N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p'\\<in>set (map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                          Ps).\n       \\<exists>m\\<le>n'. (p', m) \\<in> derivable (ext R R2 M N)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>p'\\<in>set (map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                          Ps).\n       \\<exists>m\\<le>n'. (p', m) \\<in> derivable (ext R R2 M N)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>p'\\<in>set (map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                          Ps).\n       \\<exists>m\\<le>n'. (p', m) \\<in> derivable (ext R R2 M N)", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>p'\\<in>set (map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                          Ps).\n       \\<exists>m\\<le>n'. (p', m) \\<in> derivable (ext R R2 M N)", "assume \"p \\<in> set (map (extend (\\<Gamma>' \\<Rightarrow>* \\<Delta>')) Ps)\""], ["proof (state)\nthis:\n  p \\<in> set (map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) Ps)\n\ngoal (1 subgoal):\n 1. \\<forall>p'\\<in>set (map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                          Ps).\n       \\<exists>m\\<le>n'. (p', m) \\<in> derivable (ext R R2 M N)", "then"], ["proof (chain)\npicking this:\n  p \\<in> set (map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) Ps)", "obtain p' where t:\"p' \\<in> set Ps \\<and> p = extend (\\<Gamma>' \\<Rightarrow>* \\<Delta>') p'\""], ["proof (prove)\nusing this:\n  p \\<in> set (map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) Ps)\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        p' \\<in> set Ps \\<and>\n        p =\n        extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') p' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p' \\<in> set Ps \\<and> p = extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') p'\n\ngoal (1 subgoal):\n 1. \\<forall>p'\\<in>set (map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                          Ps).\n       \\<exists>m\\<le>n'. (p', m) \\<in> derivable (ext R R2 M N)", "with h"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set Ps.\n     \\<exists>m\\<le>n'. (p, m) \\<in> derivable (ext R R2 M N)\n  p' \\<in> set Ps \\<and> p = extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') p'", "obtain m where \"m\\<le>n'\" and \"(p',m) \\<in> derivable (ext R R2 M N)\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps.\n     \\<exists>m\\<le>n'. (p, m) \\<in> derivable (ext R R2 M N)\n  p' \\<in> set Ps \\<and> p = extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') p'\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>m \\<le> n'; (p', m) \\<in> derivable (ext R R2 M N)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  m \\<le> n'\n  (p', m) \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. \\<forall>p'\\<in>set (map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                          Ps).\n       \\<exists>m\\<le>n'. (p', m) \\<in> derivable (ext R R2 M N)", "moreover"], ["proof (state)\nthis:\n  m \\<le> n'\n  (p', m) \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. \\<forall>p'\\<in>set (map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                          Ps).\n       \\<exists>m\\<le>n'. (p', m) \\<in> derivable (ext R R2 M N)", "obtain \\<Phi> \\<Psi> where eq:\"p' = (\\<Phi> \\<Rightarrow>* \\<Psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Phi> \\<Psi>.\n        p' = ( \\<Phi> \\<Rightarrow>* \\<Psi>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases p') auto"], ["proof (state)\nthis:\n  p' = ( \\<Phi> \\<Rightarrow>* \\<Psi>)\n\ngoal (1 subgoal):\n 1. \\<forall>p'\\<in>set (map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                          Ps).\n       \\<exists>m\\<le>n'. (p', m) \\<in> derivable (ext R R2 M N)", "then"], ["proof (chain)\npicking this:\n  p' = ( \\<Phi> \\<Rightarrow>* \\<Psi>)", "have \"p = (\\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\""], ["proof (prove)\nusing this:\n  p' = ( \\<Phi> \\<Rightarrow>* \\<Psi>)\n\ngoal (1 subgoal):\n 1. p = ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')", "using t"], ["proof (prove)\nusing this:\n  p' = ( \\<Phi> \\<Rightarrow>* \\<Psi>)\n  p' \\<in> set Ps \\<and> p = extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') p'\n\ngoal (1 subgoal):\n 1. p = ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')", "by (auto simp add:extend_def union_ac)"], ["proof (state)\nthis:\n  p = ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<forall>p'\\<in>set (map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                          Ps).\n       \\<exists>m\\<le>n'. (p', m) \\<in> derivable (ext R R2 M N)", "ultimately"], ["proof (chain)\npicking this:\n  m \\<le> n'\n  (p', m) \\<in> derivable (ext R R2 M N)\n  p = ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')", "have \"(p,m) \\<in> derivable (ext R R2 M N)\""], ["proof (prove)\nusing this:\n  m \\<le> n'\n  (p', m) \\<in> derivable (ext R R2 M N)\n  p = ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n\ngoal (1 subgoal):\n 1. (p, m) \\<in> derivable (ext R R2 M N)", "using IH and \\<open>n = Suc n'\\<close> and eq"], ["proof (prove)\nusing this:\n  m \\<le> n'\n  (p', m) \\<in> derivable (ext R R2 M N)\n  p = ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n  \\<forall>m<n.\n     \\<forall>\\<Gamma> \\<Delta>.\n        ( \\<Gamma> \\<Rightarrow>* \\<Delta>, m)\n        \\<in> derivable (ext R R2 M N) \\<longrightarrow>\n        ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n        \\<in> derivable (ext R R2 M N)\n  n = Suc n'\n  p' = ( \\<Phi> \\<Rightarrow>* \\<Psi>)\n\ngoal (1 subgoal):\n 1. (p, m) \\<in> derivable (ext R R2 M N)", "apply-"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<le> n'; (p', m) \\<in> derivable (ext R R2 M N);\n     p = ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>');\n     \\<forall>m<n.\n        \\<forall>\\<Gamma> \\<Delta>.\n           ( \\<Gamma> \\<Rightarrow>* \\<Delta>, m)\n           \\<in> derivable (ext R R2 M N) \\<longrightarrow>\n           ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n           \\<in> derivable (ext R R2 M N);\n     n = Suc n'; p' = ( \\<Phi> \\<Rightarrow>* \\<Psi>)\\<rbrakk>\n    \\<Longrightarrow> (p, m) \\<in> derivable (ext R R2 M N)", "by (drule_tac x=m in spec) simp"], ["proof (state)\nthis:\n  (p, m) \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. \\<forall>p'\\<in>set (map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                          Ps).\n       \\<exists>m\\<le>n'. (p', m) \\<in> derivable (ext R R2 M N)", "then"], ["proof (chain)\npicking this:\n  (p, m) \\<in> derivable (ext R R2 M N)", "have \"\\<exists> m\\<le>n'. (p,m) \\<in> derivable (ext R R2 M N)\""], ["proof (prove)\nusing this:\n  (p, m) \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n'. (p, m) \\<in> derivable (ext R R2 M N)", "using \\<open>m\\<le>n'\\<close>"], ["proof (prove)\nusing this:\n  (p, m) \\<in> derivable (ext R R2 M N)\n  m \\<le> n'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n'. (p, m) \\<in> derivable (ext R R2 M N)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n'. (p, m) \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. \\<forall>p'\\<in>set (map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                          Ps).\n       \\<exists>m\\<le>n'. (p', m) \\<in> derivable (ext R R2 M N)", "}"], ["proof (state)\nthis:\n  ?p2\n  \\<in> set (map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n              Ps) \\<Longrightarrow>\n  \\<exists>m\\<le>n'. (?p2, m) \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. \\<forall>p'\\<in>set (map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                          Ps).\n       \\<exists>m\\<le>n'. (p', m) \\<in> derivable (ext R R2 M N)", "then"], ["proof (chain)\npicking this:\n  ?p2\n  \\<in> set (map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n              Ps) \\<Longrightarrow>\n  \\<exists>m\\<le>n'. (?p2, m) \\<in> derivable (ext R R2 M N)", "show ?thesis"], ["proof (prove)\nusing this:\n  ?p2\n  \\<in> set (map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n              Ps) \\<Longrightarrow>\n  \\<exists>m\\<le>n'. (?p2, m) \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. \\<forall>p'\\<in>set (map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                          Ps).\n       \\<exists>m\\<le>n'. (p', m) \\<in> derivable (ext R R2 M N)", "by auto"], ["proof (state)\nthis:\n  \\<forall>p'\\<in>set (map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                        Ps).\n     \\<exists>m\\<le>n'. (p', m) \\<in> derivable (ext R R2 M N)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p'\\<in>set (map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                        Ps).\n     \\<exists>m\\<le>n'. (p', m) \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "then"], ["proof (chain)\npicking this:\n  \\<forall>p'\\<in>set (map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                        Ps).\n     \\<exists>m\\<le>n'. (p', m) \\<in> derivable (ext R R2 M N)", "have \"\\<forall> p' \\<in> set (fst (extendRule (extend S (\\<Gamma>' \\<Rightarrow>* \\<Delta>')) r)).\n                \\<exists> m\\<le>n'. (p',m) \\<in> derivable (ext R R2 M N)\""], ["proof (prove)\nusing this:\n  \\<forall>p'\\<in>set (map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                        Ps).\n     \\<exists>m\\<le>n'. (p', m) \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. \\<forall>p'\\<in>set (fst (extendRule\n                               (extend S\n                                 ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                               r)).\n       \\<exists>m\\<le>n'. (p', m) \\<in> derivable (ext R R2 M N)", "using eq"], ["proof (prove)\nusing this:\n  \\<forall>p'\\<in>set (map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                        Ps).\n     \\<exists>m\\<le>n'. (p', m) \\<in> derivable (ext R R2 M N)\n  map (extend ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) Ps =\n  fst (extendRule (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r)\n\ngoal (1 subgoal):\n 1. \\<forall>p'\\<in>set (fst (extendRule\n                               (extend S\n                                 ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                               r)).\n       \\<exists>m\\<le>n'. (p', m) \\<in> derivable (ext R R2 M N)", "by auto"], ["proof (state)\nthis:\n  \\<forall>p'\\<in>set (fst (extendRule\n                             (extend S\n                               ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                             r)).\n     \\<exists>m\\<le>n'. (p', m) \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "moreover"], ["proof (state)\nthis:\n  \\<forall>p'\\<in>set (fst (extendRule\n                             (extend S\n                               ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                             r)).\n     \\<exists>m\\<le>n'. (p', m) \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "have \"extendRule (extend S (\\<Gamma>' \\<Rightarrow>* \\<Delta>')) r \\<in> (ext R R2 M N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extendRule (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r\n    \\<in> ext R R2 M N", "using \\<open>r \\<in> upRules \\<or> r \\<in> modRules2\\<close> and \\<open>r \\<in> R\\<close>"], ["proof (prove)\nusing this:\n  r \\<in> upRules \\<or> r \\<in> modRules2\n  r \\<in> R\n\ngoal (1 subgoal):\n 1. extendRule (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r\n    \\<in> ext R R2 M N", "by auto"], ["proof (state)\nthis:\n  extendRule (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r\n  \\<in> ext R R2 M N\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>p'\\<in>set (fst (extendRule\n                             (extend S\n                               ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                             r)).\n     \\<exists>m\\<le>n'. (p', m) \\<in> derivable (ext R R2 M N)\n  extendRule (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r\n  \\<in> ext R R2 M N", "have \"(\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',n'+1) \\<in> derivable (ext R R2 M N)\""], ["proof (prove)\nusing this:\n  \\<forall>p'\\<in>set (fst (extendRule\n                             (extend S\n                               ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                             r)).\n     \\<exists>m\\<le>n'. (p', m) \\<in> derivable (ext R R2 M N)\n  extendRule (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r\n  \\<in> ext R R2 M N\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n    \\<in> derivable (ext R R2 M N)", "using derivable.step[where r=\"extendRule (extend S (\\<Gamma>' \\<Rightarrow>* \\<Delta>')) r\" and R=\"ext R R2 M N\" and m=\"n'\"]\n              and \\<open>fst r \\<noteq> []\\<close> and eq2"], ["proof (prove)\nusing this:\n  \\<forall>p'\\<in>set (fst (extendRule\n                             (extend S\n                               ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                             r)).\n     \\<exists>m\\<le>n'. (p', m) \\<in> derivable (ext R R2 M N)\n  extendRule (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r\n  \\<in> ext R R2 M N\n  \\<lbrakk>extendRule (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r\n           \\<in> ext R R2 M N;\n   fst (extendRule (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n         r) \\<noteq>\n   [];\n   \\<forall>p\\<in>set (fst (extendRule\n                             (extend S\n                               ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                             r)).\n      \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M N)\\<rbrakk>\n  \\<Longrightarrow> (snd (extendRule\n                           (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                           r),\n                     n' + 1)\n                    \\<in> derivable (ext R R2 M N)\n  fst r \\<noteq> []\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') =\n  snd (extendRule (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n    \\<in> derivable (ext R R2 M N)", "by (cases r) (auto simp add:map_is_Nil_conv extendRule_def)"], ["proof (state)\nthis:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "}"], ["proof (state)\nthis:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "moreover"], ["proof (state)\nthis:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "{"], ["proof (state)\nthis:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "assume as:\"r \\<in> p_e R2 M N \\<and> extendConc S r = (Ps, \\<Gamma> \\<Rightarrow>* \\<Delta>)\""], ["proof (state)\nthis:\n  r \\<in> p_e R2 M N \\<and>\n  extendConc S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "then"], ["proof (chain)\npicking this:\n  r \\<in> p_e R2 M N \\<and>\n  extendConc S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>)", "have \"(\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') = snd (extendConc (extend S (\\<Gamma>' \\<Rightarrow>* \\<Delta>')) r)\""], ["proof (prove)\nusing this:\n  r \\<in> p_e R2 M N \\<and>\n  extendConc S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') =\n    snd (extendConc (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r)", "by (auto simp add:extendConc_def extend_def union_ac)"], ["proof (state)\nthis:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') =\n  snd (extendConc (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "moreover"], ["proof (state)\nthis:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') =\n  snd (extendConc (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "from as"], ["proof (chain)\npicking this:\n  r \\<in> p_e R2 M N \\<and>\n  extendConc S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>)", "have \"Ps = fst (extendConc (extend S (\\<Gamma>' \\<Rightarrow>* \\<Delta>')) r)\""], ["proof (prove)\nusing this:\n  r \\<in> p_e R2 M N \\<and>\n  extendConc S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. Ps = fst (extendConc (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r)", "by (auto simp add:extendConc_def)"], ["proof (state)\nthis:\n  Ps = fst (extendConc (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "moreover"], ["proof (state)\nthis:\n  Ps = fst (extendConc (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "have \"extendConc S r \\<in> ext R R2 M N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extendConc S r \\<in> ext R R2 M N", "using as and g"], ["proof (prove)\nusing this:\n  r \\<in> p_e R2 M N \\<and>\n  extendConc S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<in> ext R R2 M N\n\ngoal (1 subgoal):\n 1. extendConc S r \\<in> ext R R2 M N", "by auto"], ["proof (state)\nthis:\n  extendConc S r \\<in> ext R R2 M N\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "moreover"], ["proof (state)\nthis:\n  extendConc S r \\<in> ext R R2 M N\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "have \"extendConc (extend S (\\<Gamma>' \\<Rightarrow>* \\<Delta>')) r \\<in> ext R R2 M N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extendConc (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r\n    \\<in> ext R R2 M N", "using as and \\<open>r \\<in> R\\<close> and c\n            and ext.mod1[where r=r and R'=R2 and M=M and N=N and R=R and seq=\"extend S (\\<Gamma>' \\<Rightarrow>* \\<Delta>')\"]"], ["proof (prove)\nusing this:\n  r \\<in> p_e R2 M N \\<and>\n  extendConc S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  r \\<in> R\n  R2 \\<subseteq> modRules2\n  \\<lbrakk>r \\<in> p_e R2 M N; r \\<in> R\\<rbrakk>\n  \\<Longrightarrow> extendConc\n                     (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r\n                    \\<in> ext R R2 M N\n\ngoal (1 subgoal):\n 1. extendConc (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r\n    \\<in> ext R R2 M N", "by auto"], ["proof (state)\nthis:\n  extendConc (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r\n  \\<in> ext R R2 M N\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "ultimately"], ["proof (chain)\npicking this:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') =\n  snd (extendConc (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r)\n  Ps = fst (extendConc (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r)\n  extendConc S r \\<in> ext R R2 M N\n  extendConc (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r\n  \\<in> ext R R2 M N", "have \"(\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',n'+1) \\<in> derivable (ext R R2 M N)\""], ["proof (prove)\nusing this:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') =\n  snd (extendConc (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r)\n  Ps = fst (extendConc (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r)\n  extendConc S r \\<in> ext R R2 M N\n  extendConc (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r\n  \\<in> ext R R2 M N\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n    \\<in> derivable (ext R R2 M N)", "using h f and \n           derivable.step[where r=\"extendConc (extend S (\\<Gamma>' \\<Rightarrow>* \\<Delta>')) r\" and R=\"ext R R2 M N\" and m=\"n'\"]"], ["proof (prove)\nusing this:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') =\n  snd (extendConc (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r)\n  Ps = fst (extendConc (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r)\n  extendConc S r \\<in> ext R R2 M N\n  extendConc (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r\n  \\<in> ext R R2 M N\n  \\<forall>p\\<in>set Ps.\n     \\<exists>m\\<le>n'. (p, m) \\<in> derivable (ext R R2 M N)\n  Ps \\<noteq> []\n  \\<lbrakk>extendConc (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')) r\n           \\<in> ext R R2 M N;\n   fst (extendConc (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n         r) \\<noteq>\n   [];\n   \\<forall>p\\<in>set (fst (extendConc\n                             (extend S\n                               ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                             r)).\n      \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M N)\\<rbrakk>\n  \\<Longrightarrow> (snd (extendConc\n                           (extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>'))\n                           r),\n                     n' + 1)\n                    \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n    \\<in> derivable (ext R R2 M N)", "by auto"], ["proof (state)\nthis:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "}"], ["proof (state)\nthis:\n  r \\<in> p_e R2 M N \\<and>\n  extendConc S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M N)", "ultimately"], ["proof (chain)\npicking this:\n  r \\<in> R\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<or>\n  r \\<in> p_e R2 M N \\<and>\n  extendConc S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M N)\n  r \\<in> p_e R2 M N \\<and>\n  extendConc S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M N)", "show \"( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n) \\<in> derivable (ext R R2 M N)\""], ["proof (prove)\nusing this:\n  r \\<in> R\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<or>\n  r \\<in> p_e R2 M N \\<and>\n  extendConc S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M N)\n  r \\<in> p_e R2 M N \\<and>\n  extendConc S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M N)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)", "using \\<open>n = Suc n'\\<close>"], ["proof (prove)\nusing this:\n  r \\<in> R\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<or>\n  r \\<in> p_e R2 M N \\<and>\n  extendConc S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M N)\n  r \\<in> p_e R2 M N \\<and>\n  extendConc S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M N)\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n    \\<in> derivable (ext R R2 M N)", "by auto"], ["proof (state)\nthis:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n  \\<in> derivable (ext R R2 M N)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n  \\<in> derivable (ext R R2 M N)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* -------------------------------\n   -------------------------------\n        ModalInvertibility.thy\n   -------------------------------\n   ------------------------------- *)"], ["", "lemma nonPrincipalInvertRight:\nassumes \"R1 \\<subseteq> upRules\" and \"R2 \\<subseteq> modRules2\" and \"R3 \\<subseteq> modRules2\"\n    and \"R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3\" and \"r \\<in> R\" and \"r = (ps,c)\"\n    and \"R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\"\n    and IH: \"\\<forall>m<n. \\<forall>\\<Gamma> \\<Delta>. ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, m) \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n              (\\<forall>r' \\<in> R'. rightPrincipal r' (Modal M Ms) R' \\<longrightarrow> ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')) \\<longrightarrow>              \n              (\\<exists>m'\\<le>m. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m') \\<in> derivable (ext R R2 M1 M2))\"\n    and a': \"(\\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms,n) \\<in> derivable (ext R R2 M1 M2)\" \n    and b': \"\\<forall> r' \\<in> R'. rightPrincipal r' (Modal M Ms) R' \\<longrightarrow> (\\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\"\n    and np: \"\\<not> rightPrincipal r (Modal M Ms) R'\"\n    and ext: \"(r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and> extendRule S r = (Ps, \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\"\n    and num: \"n = n' + 1\"\n    and all: \"\\<forall> p \\<in> set Ps. \\<exists> n\\<le>n'. (p,n) \\<in> derivable (ext R R2 M1 M2)\"\n    and nonempty: \"Ps \\<noteq> []\"  \nshows \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "from ext nonempty"], ["proof (chain)\npicking this:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  Ps \\<noteq> []", "have \"r \\<in> upRules \\<or> r \\<in> modRules2\""], ["proof (prove)\nusing this:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  Ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. r \\<in> upRules \\<or> r \\<in> modRules2", "apply (auto simp add:extendRule_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>extend S (snd r) =\n             ( \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>);\n     Ps = map (extend S) (fst r); fst r \\<noteq> []; r \\<notin> modRules2;\n     r \\<in> Ax\\<rbrakk>\n    \\<Longrightarrow> r \\<in> upRules", "apply (cases r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>extend S (snd r) =\n                ( \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>);\n        Ps = map (extend S) (fst r); fst r \\<noteq> [];\n        r \\<notin> modRules2; r \\<in> Ax; r = (a, b)\\<rbrakk>\n       \\<Longrightarrow> r \\<in> upRules", "apply (rotate_tac 3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>r \\<notin> modRules2; r \\<in> Ax; r = (a, b);\n        extend S (snd r) =\n        ( \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>);\n        Ps = map (extend S) (fst r); fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> r \\<in> upRules", "by (rule Ax.cases) auto"], ["proof (state)\nthis:\n  r \\<in> upRules \\<or> r \\<in> modRules2\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "obtain \\<Phi> \\<Psi> where \"S = (\\<Phi> \\<Rightarrow>* \\<Psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Phi> \\<Psi>.\n        S = ( \\<Phi> \\<Rightarrow>* \\<Psi>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases S) (auto)"], ["proof (state)\nthis:\n  S = ( \\<Phi> \\<Rightarrow>* \\<Psi>)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "from \\<open>r = (ps,c)\\<close>"], ["proof (chain)\npicking this:\n  r = (ps, c)", "obtain G H where \"c = (G \\<Rightarrow>* H)\""], ["proof (prove)\nusing this:\n  r = (ps, c)\n\ngoal (1 subgoal):\n 1. (\\<And>G H.\n        c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases c) (auto)"], ["proof (state)\nthis:\n  c = ( G \\<Rightarrow>* H)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  c = ( G \\<Rightarrow>* H)", "have \"\\<LM> Modal M Ms \\<RM> \\<noteq> H\""], ["proof (prove)\nusing this:\n  c = ( G \\<Rightarrow>* H)\n\ngoal (1 subgoal):\n 1. \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "assume \"r \\<in> upRules\""], ["proof (state)\nthis:\n  r \\<in> upRules\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "with \\<open>r = (ps,c)\\<close>"], ["proof (chain)\npicking this:\n  r = (ps, c)\n  r \\<in> upRules", "obtain T Ts where \"c = (\\<Empt> \\<Rightarrow>* \\<LM>Compound T Ts\\<RM>) \\<or> c = (\\<LM>Compound T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  r = (ps, c)\n  r \\<in> upRules\n\ngoal (1 subgoal):\n 1. (\\<And>T Ts.\n        c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n        c =\n        ( \\<LM> Compound T\n                 Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using upRuleCharacterise[where Ps=ps and C=c]"], ["proof (prove)\nusing this:\n  r = (ps, c)\n  r \\<in> upRules\n  (ps, c) \\<in> upRules \\<Longrightarrow>\n  \\<exists>F Fs.\n     c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F Fs  \\<RM>) \\<or>\n     c = ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. (\\<And>T Ts.\n        c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n        c =\n        ( \\<LM> Compound T\n                 Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "moreover"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "{"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "assume \"c = (\\<Empt> \\<Rightarrow>* \\<LM>Compound T Ts\\<RM>)\""], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>)\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "with \\<open>c = (G \\<Rightarrow>* H)\\<close>"], ["proof (chain)\npicking this:\n  c = ( G \\<Rightarrow>* H)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>)", "have \"\\<LM> Modal M Ms \\<RM> \\<noteq> H\""], ["proof (prove)\nusing this:\n  c = ( G \\<Rightarrow>* H)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "by auto"], ["proof (state)\nthis:\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "}"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "moreover"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "{"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "assume \"c = (\\<LM>Compound T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (state)\nthis:\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "then"], ["proof (chain)\npicking this:\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"\\<LM>Modal M Ms \\<RM> \\<noteq> H\""], ["proof (prove)\nusing this:\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "using \\<open>c = (G \\<Rightarrow>* H)\\<close>"], ["proof (prove)\nusing this:\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  c = ( G \\<Rightarrow>* H)\n\ngoal (1 subgoal):\n 1. \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "by auto"], ["proof (state)\nthis:\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "}"], ["proof (state)\nthis:\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "ultimately"], ["proof (chain)\npicking this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "have \"\\<LM> Modal M Ms \\<RM> \\<noteq> H\""], ["proof (prove)\nusing this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "by blast"], ["proof (state)\nthis:\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "}"], ["proof (state)\nthis:\n  r \\<in> upRules \\<Longrightarrow> \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "moreover"], ["proof (state)\nthis:\n  r \\<in> upRules \\<Longrightarrow> \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "{"], ["proof (state)\nthis:\n  r \\<in> upRules \\<Longrightarrow> \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "assume \"r \\<in> modRules2\""], ["proof (state)\nthis:\n  r \\<in> modRules2\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "with \\<open>r = (ps,c)\\<close>"], ["proof (chain)\npicking this:\n  r = (ps, c)\n  r \\<in> modRules2", "obtain T Ts where \"c = (\\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts \\<RM>) \\<or> c = (\\<LM> Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  r = (ps, c)\n  r \\<in> modRules2\n\ngoal (1 subgoal):\n 1. (\\<And>T Ts.\n        c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n        c =\n        ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using modRule2Characterise[where Ps=ps and C=c]"], ["proof (prove)\nusing this:\n  r = (ps, c)\n  r \\<in> modRules2\n  (ps, c) \\<in> modRules2 \\<Longrightarrow>\n  ps \\<noteq> [] \\<and>\n  (\\<exists>F Fs.\n      c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n      c = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))\n\ngoal (1 subgoal):\n 1. (\\<And>T Ts.\n        c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n        c =\n        ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "moreover"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "{"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "assume \"c = (\\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts \\<RM>)\""], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "then"], ["proof (chain)\npicking this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)", "have \"rightPrincipal r (Modal T Ts) R'\""], ["proof (prove)\nusing this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n\ngoal (1 subgoal):\n 1. rightPrincipal r (Modal T Ts) R'", "using \\<open>r = (ps,c)\\<close> and \\<open>r \\<in> R\\<close>"], ["proof (prove)\nusing this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  r = (ps, c)\n  r \\<in> R\n\ngoal (1 subgoal):\n 1. rightPrincipal r (Modal T Ts) R'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "from \\<open>c = (\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>)\\<close> and \\<open>r = (ps,c)\\<close> and \\<open>r \\<in> R\\<close> and \\<open>r \\<in> modRules2\\<close>"], ["proof (chain)\npicking this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  r = (ps, c)\n  r \\<in> R\n  r \\<in> modRules2", "have \"(ps,\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<in> R\""], ["proof (prove)\nusing this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  r = (ps, c)\n  r \\<in> R\n  r \\<in> modRules2\n\ngoal (1 subgoal):\n 1. (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "with \\<open>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3\\<close>"], ["proof (chain)\npicking this:\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R", "have \"(ps,  \\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<in> p_e R2 M1 M2 \\<or>\n                          (ps,  \\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<in> R3\""], ["proof (prove)\nusing this:\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R\n\ngoal (1 subgoal):\n 1. (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n    \\<in> p_e R2 M1 M2 \\<or>\n    (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R3", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> Ax\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                      \\<in> p_e R2 M1 M2\n 2. \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R1\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                      \\<in> p_e R2 M1 M2", "apply (rule Ax.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> Ax\\<rbrakk>\n    \\<Longrightarrow> (?a1.7, ?a2.7) \\<in> Ax\n 2. \\<And>i.\n       \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n        (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> Ax;\n        ?a1.7 = [];\n        ?a2.7 =\n        ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\\<rbrakk>\n       \\<Longrightarrow> (ps,\n                           \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                         \\<in> p_e R2 M1 M2\n 3. \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> Ax;\n     ?a1.7 = []; ?a2.7 = ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                      \\<in> p_e R2 M1 M2\n 4. \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R1\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                      \\<in> p_e R2 M1 M2", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R1\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                      \\<in> p_e R2 M1 M2", "apply (subgoal_tac \"(ps,\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<in> upRules\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R1;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n     \\<in> upRules\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                      \\<in> p_e R2 M1 M2\n 2. \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R1\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                      \\<in> upRules", "apply (insert \\<open>R1 \\<subseteq> upRules\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R1;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> upRules;\n     R1 \\<subseteq> upRules\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                      \\<in> p_e R2 M1 M2\n 2. \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R1;\n     R1 \\<subseteq> upRules\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                      \\<in> upRules", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R1;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> upRules;\n     R1 \\<subseteq> upRules\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                      \\<in> p_e R2 M1 M2", "apply (rule upRules.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R1;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> upRules;\n     R1 \\<subseteq> upRules\\<rbrakk>\n    \\<Longrightarrow> (?a1.76, ?a2.76) \\<in> upRules\n 2. \\<And>c Ra Fs psa.\n       \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n        (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R1;\n        (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> upRules;\n        R1 \\<subseteq> upRules; ?a1.76 = psa; ?a2.76 = c;\n        ModalSequents.mset c = \\<LM> Compound Ra Fs  \\<RM>;\n        psa \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (ps,\n                           \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                         \\<in> p_e R2 M1 M2", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  \\<in> p_e R2 M1 M2 \\<or>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "moreover"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  \\<in> p_e R2 M1 M2 \\<or>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "{"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  \\<in> p_e R2 M1 M2 \\<or>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "assume \"(ps, \\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<in> R3\""], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R3", "have \"(ps, \\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<in> R'\""], ["proof (prove)\nusing this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R3\n\ngoal (1 subgoal):\n 1. (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'", "using \\<open>R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\\<close>"], ["proof (prove)\nusing this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R3\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n\ngoal (1 subgoal):\n 1. (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "}"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  \\<in> R3 \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "moreover"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  \\<in> R3 \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "{"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  \\<in> R3 \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "assume \"(ps,\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<in> p_e R2 M1 M2\""], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> p_e R2 M1 M2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> p_e R2 M1 M2", "obtain \\<Gamma>' \\<Delta>' r' where aa: \"(ps, \\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) = extendRule (M1\\<cdot>\\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>') r' \\<and> r' \\<in> R2\""], ["proof (prove)\nusing this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> p_e R2 M1 M2\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' \\<Delta>' r'.\n        (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n        extendRule\n         ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n         r' \\<and>\n        r' \\<in> R2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply (rule p_e.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps c \\<Gamma> \\<Delta>.\n       \\<lbrakk>\\<And>\\<Gamma>' \\<Delta>' r'.\n                   (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n                   extendRule\n                    ( M1 \\<cdot>\n                      \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n                    r' \\<and>\n                   r' \\<in> R2 \\<Longrightarrow>\n                   thesis;\n        (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n        extendRule ( M1 \\<cdot> \\<Gamma> \\<Rightarrow>* M2 \\<cdot> \\<Delta>)\n         (Ps, c);\n        (Ps, c) \\<in> R2; R2 \\<subseteq> modRules2\\<rbrakk>\n       \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2", "have \"r' \\<in> modRules2\""], ["proof (prove)\nusing this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n\ngoal (1 subgoal):\n 1. r' \\<in> modRules2", "using \\<open>R2 \\<subseteq> modRules2\\<close>"], ["proof (prove)\nusing this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n  R2 \\<subseteq> modRules2\n\ngoal (1 subgoal):\n 1. r' \\<in> modRules2", "by auto"], ["proof (state)\nthis:\n  r' \\<in> modRules2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  r' \\<in> modRules2", "obtain F Fs where \n                        \"snd r' = (\\<Empt> \\<Rightarrow>* \\<LM>Modal F Fs\\<RM>) \\<or> snd r' = (\\<LM>Modal F Fs\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  r' \\<in> modRules2\n\ngoal (1 subgoal):\n 1. (\\<And>F Fs.\n        snd r' = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n        snd r' =\n        ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using modRule2Characterise[where Ps=\"fst r'\" and C=\"snd r'\"]"], ["proof (prove)\nusing this:\n  r' \\<in> modRules2\n  (fst r', snd r') \\<in> modRules2 \\<Longrightarrow>\n  fst r' \\<noteq> [] \\<and>\n  (\\<exists>F Fs.\n      snd r' = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n      snd r' = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))\n\ngoal (1 subgoal):\n 1. (\\<And>F Fs.\n        snd r' = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n        snd r' =\n        ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  snd r' = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n  snd r' = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "with aa"], ["proof (chain)\npicking this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n  snd r' = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n  snd r' = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"(\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) = (M1\\<cdot>\\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>' \\<oplus> Modal F Fs) \\<or>\n                                 (\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) = (M1\\<cdot>\\<Gamma>' \\<oplus> Modal F Fs \\<Rightarrow>* M2\\<cdot>\\<Delta>')\""], ["proof (prove)\nusing this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n  snd r' = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n  snd r' = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n    ( M1 \\<cdot>\n      \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus>\n                               Modal F Fs) \\<or>\n    ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n    ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n      Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')", "by (auto simp add:extendRule_def extend_def)"], ["proof (state)\nthis:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs) \\<or>\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "moreover"], ["proof (state)\nthis:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs) \\<or>\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "{"], ["proof (state)\nthis:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs) \\<or>\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "assume \"(\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) = (M1\\<cdot>\\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>' \\<oplus> Modal F Fs)\""], ["proof (state)\nthis:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs)", "have \"M1\\<cdot>\\<Gamma>' = \\<Empt>\" and \"\\<LM>Modal T Ts\\<RM> = M2\\<cdot>\\<Delta>' \\<oplus> Modal F Fs\""], ["proof (prove)\nusing this:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs)\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>' = \\<Empt> &&&\n    \\<LM> Modal T Ts  \\<RM> = M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs", "by auto"], ["proof (state)\nthis:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  \\<LM> Modal T Ts  \\<RM> = M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  \\<LM> Modal T Ts  \\<RM> = M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs", "have \"M1\\<cdot>\\<Gamma>' = \\<Empt>\" and \"Modal T Ts = Modal F Fs\" and \"M2\\<cdot>\\<Delta>' = \\<Empt>\""], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  \\<LM> Modal T Ts  \\<RM> = M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>' = \\<Empt> &&&\n    Modal T Ts = Modal F Fs &&& M2 \\<cdot> \\<Delta>' = \\<Empt>", "using \n                            singleton_add_means_equal[where A=\"Modal T Ts\" and \\<Gamma>=\"M2\\<cdot>\\<Delta>'\" and B=\"Modal F Fs\"]\n                            and singleton_add_means_empty[where A=\"Modal T Ts\" and \\<Gamma>=\"M2\\<cdot>\\<Delta>'\" and B=\"Modal F Fs\"]"], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  \\<LM> Modal T Ts  \\<RM> = M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs\n  \\<LM> Modal T Ts  \\<RM> =\n  M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs \\<Longrightarrow>\n  Modal T Ts = Modal F Fs\n  \\<LM> Modal T Ts  \\<RM> =\n  M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs \\<Longrightarrow>\n  M2 \\<cdot> \\<Delta>' = \\<Empt>\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>' = \\<Empt> &&&\n    Modal T Ts = Modal F Fs &&& M2 \\<cdot> \\<Delta>' = \\<Empt>", "by (auto simp add:modaliseMultiset_def)"], ["proof (state)\nthis:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  Modal T Ts = Modal F Fs\n  M2 \\<cdot> \\<Delta>' = \\<Empt>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  Modal T Ts = Modal F Fs\n  M2 \\<cdot> \\<Delta>' = \\<Empt>", "have \"extendRule (M1\\<cdot>\\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>') r' = r'\""], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  Modal T Ts = Modal F Fs\n  M2 \\<cdot> \\<Delta>' = \\<Empt>\n\ngoal (1 subgoal):\n 1. extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n     r' =\n    r'", "using extendRuleEmpty[where r=r']"], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  Modal T Ts = Modal F Fs\n  M2 \\<cdot> \\<Delta>' = \\<Empt>\n  extendRule ( \\<Empt> \\<Rightarrow>* \\<Empt>) r' = r'\n\ngoal (1 subgoal):\n 1. extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n     r' =\n    r'", "by auto"], ["proof (state)\nthis:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' =\n  r'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' =\n  r'", "have \"extendRule (M1\\<cdot>\\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>') r' \\<in> R2\""], ["proof (prove)\nusing this:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' =\n  r'\n\ngoal (1 subgoal):\n 1. extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n     r'\n    \\<in> R2", "using aa"], ["proof (prove)\nusing this:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' =\n  r'\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n\ngoal (1 subgoal):\n 1. extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n     r'\n    \\<in> R2", "by auto"], ["proof (state)\nthis:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>') r'\n  \\<in> R2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>') r'\n  \\<in> R2", "have \"(ps,\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<in> R2\""], ["proof (prove)\nusing this:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>') r'\n  \\<in> R2\n\ngoal (1 subgoal):\n 1. (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R2", "using aa"], ["proof (prove)\nusing this:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>') r'\n  \\<in> R2\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n\ngoal (1 subgoal):\n 1. (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R2", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R2", "have \"(ps,\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<in> R'\""], ["proof (prove)\nusing this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R2\n\ngoal (1 subgoal):\n 1. (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'", "using \\<open>R' = Ax\\<union>R1 \\<union>R2 \\<union> R3 \\<close>"], ["proof (prove)\nusing this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R2\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n\ngoal (1 subgoal):\n 1. (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'", "by simp"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "}"], ["proof (state)\nthis:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus>\n                             Modal F Fs) \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "moreover"], ["proof (state)\nthis:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus>\n                             Modal F Fs) \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "{"], ["proof (state)\nthis:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus>\n                             Modal F Fs) \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "assume \"(\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) = (M1\\<cdot>\\<Gamma>' \\<oplus> Modal F Fs \\<Rightarrow>* M2\\<cdot>\\<Delta>')\""], ["proof (state)\nthis:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')", "have \"\\<Empt> = M1\\<cdot>\\<Gamma>' \\<oplus> Modal F Fs\""], ["proof (prove)\nusing this:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<Empt> = M1 \\<cdot> \\<Gamma>' \\<oplus> Modal F Fs", "by auto"], ["proof (state)\nthis:\n  \\<Empt> = M1 \\<cdot> \\<Gamma>' \\<oplus> Modal F Fs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  \\<Empt> = M1 \\<cdot> \\<Gamma>' \\<oplus> Modal F Fs", "have \"(ps, \\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<in> R'\""], ["proof (prove)\nusing this:\n  \\<Empt> = M1 \\<cdot> \\<Gamma>' \\<oplus> Modal F Fs\n\ngoal (1 subgoal):\n 1. (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "}"], ["proof (state)\nthis:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>') \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "ultimately"], ["proof (chain)\npicking this:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs) \\<or>\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus>\n                             Modal F Fs) \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>') \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'", "have \"(ps,\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<in> R'\""], ["proof (prove)\nusing this:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs) \\<or>\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus>\n                             Modal F Fs) \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>') \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'", "by blast"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "}"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "ultimately"], ["proof (chain)\npicking this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  \\<in> p_e R2 M1 M2 \\<or>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R3\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  \\<in> R3 \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'", "have \"(ps,\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<in> R'\""], ["proof (prove)\nusing this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  \\<in> p_e R2 M1 M2 \\<or>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R3\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  \\<in> R3 \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'", "show ?thesis"], ["proof (prove)\nusing this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. rightPrincipal r (Modal T Ts) R'", "using \\<open>r = (ps,c)\\<close> and \\<open>c = (\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>)\\<close>"], ["proof (prove)\nusing this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n  r = (ps, c)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n\ngoal (1 subgoal):\n 1. rightPrincipal r (Modal T Ts) R'", "by auto"], ["proof (state)\nthis:\n  rightPrincipal r (Modal T Ts) R'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rightPrincipal r (Modal T Ts) R'\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "with \\<open>\\<not> rightPrincipal r (Modal M Ms) R'\\<close>"], ["proof (chain)\npicking this:\n  \\<not> rightPrincipal r (Modal M Ms) R'\n  rightPrincipal r (Modal T Ts) R'", "have \"Modal T Ts \\<noteq> Modal M Ms\""], ["proof (prove)\nusing this:\n  \\<not> rightPrincipal r (Modal M Ms) R'\n  rightPrincipal r (Modal T Ts) R'\n\ngoal (1 subgoal):\n 1. Modal T Ts \\<noteq> Modal M Ms", "by auto"], ["proof (state)\nthis:\n  Modal T Ts \\<noteq> Modal M Ms\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "with \\<open>c = (G \\<Rightarrow>* H)\\<close>"], ["proof (chain)\npicking this:\n  c = ( G \\<Rightarrow>* H)\n  Modal T Ts \\<noteq> Modal M Ms", "have \"\\<LM> Modal M Ms \\<RM> \\<noteq> H\""], ["proof (prove)\nusing this:\n  c = ( G \\<Rightarrow>* H)\n  Modal T Ts \\<noteq> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "using \\<open>c = (\\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts \\<RM>)\\<close>"], ["proof (prove)\nusing this:\n  c = ( G \\<Rightarrow>* H)\n  Modal T Ts \\<noteq> Modal M Ms\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "by auto"], ["proof (state)\nthis:\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "}"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "moreover"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "{"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "assume \"c = (\\<LM>Modal T Ts \\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (state)\nthis:\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "then"], ["proof (chain)\npicking this:\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"\\<LM>Modal M Ms \\<RM> \\<noteq> H\""], ["proof (prove)\nusing this:\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "using \\<open>c = (G \\<Rightarrow>* H)\\<close>"], ["proof (prove)\nusing this:\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  c = ( G \\<Rightarrow>* H)\n\ngoal (1 subgoal):\n 1. \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "by auto"], ["proof (state)\nthis:\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "}"], ["proof (state)\nthis:\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "ultimately"], ["proof (chain)\npicking this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "have \"\\<LM> Modal M Ms \\<RM> \\<noteq> H\""], ["proof (prove)\nusing this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "by blast"], ["proof (state)\nthis:\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "}"], ["proof (state)\nthis:\n  r \\<in> modRules2 \\<Longrightarrow> \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( G \\<Rightarrow>* H) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "ultimately"], ["proof (chain)\npicking this:\n  r \\<in> upRules \\<Longrightarrow> \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n  r \\<in> modRules2 \\<Longrightarrow> \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "show ?thesis"], ["proof (prove)\nusing this:\n  r \\<in> upRules \\<Longrightarrow> \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n  r \\<in> modRules2 \\<Longrightarrow> \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "using \\<open>r \\<in> upRules \\<or> r \\<in> modRules2\\<close>"], ["proof (prove)\nusing this:\n  r \\<in> upRules \\<Longrightarrow> \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n  r \\<in> modRules2 \\<Longrightarrow> \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n  r \\<in> upRules \\<or> r \\<in> modRules2\n\ngoal (1 subgoal):\n 1. \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "by blast"], ["proof (state)\nthis:\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "have \"succ S + succ (snd r) = (\\<Delta> \\<oplus> Modal M Ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. succ S + succ (snd r) = \\<Delta> \\<oplus> Modal M Ms", "using ext and extendRule_def[where forms=S and R=r]\n                    and extend_def[where forms=S and seq=\"snd r\"]"], ["proof (prove)\nusing this:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  extendRule S r \\<equiv> (map (extend S) (fst r), extend S (snd r))\n  extend S (snd r) \\<equiv>\n   antec S + antec (snd r) \\<Rightarrow>* succ S + succ (snd r)\n\ngoal (1 subgoal):\n 1. succ S + succ (snd r) = \\<Delta> \\<oplus> Modal M Ms", "by auto"], ["proof (state)\nthis:\n  succ S + succ (snd r) = \\<Delta> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  succ S + succ (snd r) = \\<Delta> \\<oplus> Modal M Ms", "have \"\\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms\""], ["proof (prove)\nusing this:\n  succ S + succ (snd r) = \\<Delta> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms", "using \\<open>S = (\\<Phi> \\<Rightarrow>* \\<Psi>)\\<close> and \\<open>r = (ps,c)\\<close> and \\<open>c = (G \\<Rightarrow>* H)\\<close>"], ["proof (prove)\nusing this:\n  succ S + succ (snd r) = \\<Delta> \\<oplus> Modal M Ms\n  S = ( \\<Phi> \\<Rightarrow>* \\<Psi>)\n  r = (ps, c)\n  c = ( G \\<Rightarrow>* H)\n\ngoal (1 subgoal):\n 1. \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms", "by auto"], ["proof (state)\nthis:\n  \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "from \\<open>r = (ps,c)\\<close> and \\<open>r \\<in> upRules \\<or> r \\<in> modRules2\\<close>"], ["proof (chain)\npicking this:\n  r = (ps, c)\n  r \\<in> upRules \\<or> r \\<in> modRules2", "have \"(ps,c) \\<in> upRules \\<or> (ps,c) \\<in> modRules2\""], ["proof (prove)\nusing this:\n  r = (ps, c)\n  r \\<in> upRules \\<or> r \\<in> modRules2\n\ngoal (1 subgoal):\n 1. (ps, c) \\<in> upRules \\<or> (ps, c) \\<in> modRules2", "by auto"], ["proof (state)\nthis:\n  (ps, c) \\<in> upRules \\<or> (ps, c) \\<in> modRules2\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  (ps, c) \\<in> upRules \\<or> (ps, c) \\<in> modRules2", "have \"\\<exists> A. c = (\\<Empt> \\<Rightarrow>* \\<LM>A\\<RM>) \\<or> c = (\\<LM>A\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  (ps, c) \\<in> upRules \\<or> (ps, c) \\<in> modRules2\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       c = ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<or>\n       c = ( \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>)", "using upRuleCharacterise[where Ps=ps and C=c]\n        and modRule2Characterise[where Ps=ps and C=c]"], ["proof (prove)\nusing this:\n  (ps, c) \\<in> upRules \\<or> (ps, c) \\<in> modRules2\n  (ps, c) \\<in> upRules \\<Longrightarrow>\n  \\<exists>F Fs.\n     c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F Fs  \\<RM>) \\<or>\n     c = ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n  (ps, c) \\<in> modRules2 \\<Longrightarrow>\n  ps \\<noteq> [] \\<and>\n  (\\<exists>F Fs.\n      c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n      c = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       c = ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<or>\n       c = ( \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>A.\n     c = ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<or>\n     c = ( \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<exists>A.\n     c = ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<or>\n     c = ( \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"H = \\<Empt> \\<or> (\\<exists> A. H = \\<LM>A\\<RM>)\""], ["proof (prove)\nusing this:\n  \\<exists>A.\n     c = ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<or>\n     c = ( \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)", "using \\<open>c = (G \\<Rightarrow>* H)\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>A.\n     c = ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<or>\n     c = ( \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>)\n  c = ( G \\<Rightarrow>* H)\n\ngoal (1 subgoal):\n 1. H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)", "by auto"], ["proof (state)\nthis:\n  H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n  \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms\n  H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)", "have \"Modal M Ms \\<in># \\<Psi>\""], ["proof (prove)\nusing this:\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n  \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms\n  H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\n\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># \\<Psi>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>", "have \"H = \\<Empt> \\<or> (\\<exists> A. H = \\<LM>A\\<RM>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)", "by fact"], ["proof (state)\nthis:\n  H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>", "moreover"], ["proof (state)\nthis:\n  H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>", "{"], ["proof (state)\nthis:\n  H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>", "assume \"H = \\<Empt>\""], ["proof (state)\nthis:\n  H = \\<Empt>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>", "then"], ["proof (chain)\npicking this:\n  H = \\<Empt>", "have \"\\<Psi> = \\<Delta> \\<oplus> Modal M Ms\""], ["proof (prove)\nusing this:\n  H = \\<Empt>\n\ngoal (1 subgoal):\n 1. \\<Psi> = \\<Delta> \\<oplus> Modal M Ms", "using \\<open>\\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms\\<close>"], ["proof (prove)\nusing this:\n  H = \\<Empt>\n  \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<Psi> = \\<Delta> \\<oplus> Modal M Ms", "by auto"], ["proof (state)\nthis:\n  \\<Psi> = \\<Delta> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>", "then"], ["proof (chain)\npicking this:\n  \\<Psi> = \\<Delta> \\<oplus> Modal M Ms", "have \"Modal M Ms \\<in># \\<Psi>\""], ["proof (prove)\nusing this:\n  \\<Psi> = \\<Delta> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># \\<Psi>", "by auto"], ["proof (state)\nthis:\n  Modal M Ms \\<in># \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>", "}"], ["proof (state)\nthis:\n  H = \\<Empt> \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>", "moreover"], ["proof (state)\nthis:\n  H = \\<Empt> \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>", "{"], ["proof (state)\nthis:\n  H = \\<Empt> \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>", "assume \"\\<exists> A. H = \\<LM>A\\<RM>\""], ["proof (state)\nthis:\n  \\<exists>A. H = \\<LM> A  \\<RM>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>", "then"], ["proof (chain)\npicking this:\n  \\<exists>A. H = \\<LM> A  \\<RM>", "obtain T where \"H = \\<LM>T\\<RM>\""], ["proof (prove)\nusing this:\n  \\<exists>A. H = \\<LM> A  \\<RM>\n\ngoal (1 subgoal):\n 1. (\\<And>T. H = \\<LM> T  \\<RM> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  H = \\<LM> T  \\<RM>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>", "then"], ["proof (chain)\npicking this:\n  H = \\<LM> T  \\<RM>", "have \"\\<Psi> \\<oplus> T = \\<Delta> \\<oplus> Modal M Ms\""], ["proof (prove)\nusing this:\n  H = \\<LM> T  \\<RM>\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<oplus> T = \\<Delta> \\<oplus> Modal M Ms", "using \\<open>\\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms\\<close>"], ["proof (prove)\nusing this:\n  H = \\<LM> T  \\<RM>\n  \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<Psi> \\<oplus> T = \\<Delta> \\<oplus> Modal M Ms", "by auto"], ["proof (state)\nthis:\n  \\<Psi> \\<oplus> T = \\<Delta> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>", "then"], ["proof (chain)\npicking this:\n  \\<Psi> \\<oplus> T = \\<Delta> \\<oplus> Modal M Ms", "have \"set_mset (\\<Psi> \\<oplus> T) = set_mset (\\<Delta> \\<oplus> Modal M Ms)\""], ["proof (prove)\nusing this:\n  \\<Psi> \\<oplus> T = \\<Delta> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. set_mset (\\<Psi> \\<oplus> T) = set_mset (\\<Delta> \\<oplus> Modal M Ms)", "by auto"], ["proof (state)\nthis:\n  set_mset (\\<Psi> \\<oplus> T) = set_mset (\\<Delta> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>", "then"], ["proof (chain)\npicking this:\n  set_mset (\\<Psi> \\<oplus> T) = set_mset (\\<Delta> \\<oplus> Modal M Ms)", "have \"set_mset \\<Psi> \\<union> {T} = set_mset \\<Delta> \\<union> {Modal M Ms}\""], ["proof (prove)\nusing this:\n  set_mset (\\<Psi> \\<oplus> T) = set_mset (\\<Delta> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. set_mset \\<Psi> \\<union> {T} = set_mset \\<Delta> \\<union> {Modal M Ms}", "by auto"], ["proof (state)\nthis:\n  set_mset \\<Psi> \\<union> {T} = set_mset \\<Delta> \\<union> {Modal M Ms}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>", "moreover"], ["proof (state)\nthis:\n  set_mset \\<Psi> \\<union> {T} = set_mset \\<Delta> \\<union> {Modal M Ms}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>", "from \\<open>H = \\<LM>T\\<RM>\\<close> and \\<open>\\<LM>Modal M Ms\\<RM> \\<noteq> H\\<close>"], ["proof (chain)\npicking this:\n  H = \\<LM> T  \\<RM>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "have \"Modal M Ms \\<noteq> T\""], ["proof (prove)\nusing this:\n  H = \\<LM> T  \\<RM>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. Modal M Ms \\<noteq> T", "by auto"], ["proof (state)\nthis:\n  Modal M Ms \\<noteq> T\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>", "ultimately"], ["proof (chain)\npicking this:\n  set_mset \\<Psi> \\<union> {T} = set_mset \\<Delta> \\<union> {Modal M Ms}\n  Modal M Ms \\<noteq> T", "have \"Modal M Ms \\<in> set_mset \\<Psi>\""], ["proof (prove)\nusing this:\n  set_mset \\<Psi> \\<union> {T} = set_mset \\<Delta> \\<union> {Modal M Ms}\n  Modal M Ms \\<noteq> T\n\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># \\<Psi>", "by auto"], ["proof (state)\nthis:\n  Modal M Ms \\<in># \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>", "then"], ["proof (chain)\npicking this:\n  Modal M Ms \\<in># \\<Psi>", "have \"Modal M Ms \\<in># \\<Psi>\""], ["proof (prove)\nusing this:\n  Modal M Ms \\<in># \\<Psi>\n\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># \\<Psi>", "by auto"], ["proof (state)\nthis:\n  Modal M Ms \\<in># \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>", "}"], ["proof (state)\nthis:\n  \\<exists>A. H = \\<LM> A  \\<RM> \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Psi> + H = \\<Delta> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>", "ultimately"], ["proof (chain)\npicking this:\n  H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\n  H = \\<Empt> \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>\n  \\<exists>A. H = \\<LM> A  \\<RM> \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>", "show \"Modal M Ms \\<in># \\<Psi>\""], ["proof (prove)\nusing this:\n  H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\n  H = \\<Empt> \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>\n  \\<exists>A. H = \\<LM> A  \\<RM> \\<Longrightarrow> Modal M Ms \\<in># \\<Psi>\n\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># \\<Psi>", "by blast"], ["proof (state)\nthis:\n  Modal M Ms \\<in># \\<Psi>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Modal M Ms \\<in># \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  Modal M Ms \\<in># \\<Psi>", "have \"\\<exists> \\<Psi>1. \\<Psi> = \\<Psi>1 \\<oplus> Modal M Ms\""], ["proof (prove)\nusing this:\n  Modal M Ms \\<in># \\<Psi>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Psi>1. \\<Psi> = \\<Psi>1 \\<oplus> Modal M Ms", "by (rule_tac x=\"\\<Psi> \\<ominus> Modal M Ms\" in exI) (auto simp add:multiset_eq_iff)"], ["proof (state)\nthis:\n  \\<exists>\\<Psi>1. \\<Psi> = \\<Psi>1 \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<Psi>1. \\<Psi> = \\<Psi>1 \\<oplus> Modal M Ms", "obtain \\<Psi>1 where \"S = (\\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\""], ["proof (prove)\nusing this:\n  \\<exists>\\<Psi>1. \\<Psi> = \\<Psi>1 \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Psi>1.\n        S =\n        ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus>\n                                Modal M Ms) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>S = (\\<Phi> \\<Rightarrow>* \\<Psi>)\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>\\<Psi>1. \\<Psi> = \\<Psi>1 \\<oplus> Modal M Ms\n  S = ( \\<Phi> \\<Rightarrow>* \\<Psi>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Psi>1.\n        S =\n        ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus>\n                                Modal M Ms) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  S = ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "have \"Ps = map (extend S) ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ps = map (extend S) ps", "using ext and extendRule_def[where forms=S and R=r] and \\<open>r = (ps,c)\\<close>"], ["proof (prove)\nusing this:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  extendRule S r \\<equiv> (map (extend S) (fst r), extend S (snd r))\n  r = (ps, c)\n\ngoal (1 subgoal):\n 1. Ps = map (extend S) ps", "by auto"], ["proof (state)\nthis:\n  Ps = map (extend S) ps\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  Ps = map (extend S) ps", "have \"\\<forall> p \\<in> set Ps. (\\<exists> p'. p = extend S p')\""], ["proof (prove)\nusing this:\n  Ps = map (extend S) ps\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps. \\<exists>p'. p = extend S p'", "using ex_map_conv[where ys=Ps and f=\"extend S\"]"], ["proof (prove)\nusing this:\n  Ps = map (extend S) ps\n  (\\<exists>xs. Ps = map (extend S) xs) =\n  (\\<forall>y\\<in>set Ps. \\<exists>x. y = extend S x)\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps. \\<exists>p'. p = extend S p'", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set Ps. \\<exists>p'. p = extend S p'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set Ps. \\<exists>p'. p = extend S p'", "have \"\\<forall> p \\<in> set Ps. (Modal M Ms \\<in># succ p)\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps. \\<exists>p'. p = extend S p'\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps. Modal M Ms \\<in># succ p", "using \\<open>Modal M Ms \\<in># \\<Psi>\\<close> and \\<open>S = (\\<Phi> \\<Rightarrow>* \\<Psi>)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps. \\<exists>p'. p = extend S p'\n  Modal M Ms \\<in># \\<Psi>\n  S = ( \\<Phi> \\<Rightarrow>* \\<Psi>)\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps. Modal M Ms \\<in># succ p", "apply (auto simp add:Ball_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> set Ps \\<longrightarrow>\n                   (\\<exists>p'.\n                       x = extend ( \\<Phi> \\<Rightarrow>* \\<Psi>) p');\n        Modal M Ms \\<in># \\<Psi>; S = ( \\<Phi> \\<Rightarrow>* \\<Psi>);\n        x \\<in> set Ps\\<rbrakk>\n       \\<Longrightarrow> Modal M Ms \\<in># succ x", "by (drule_tac x=x in spec) (auto simp add:extend_def)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set Ps. Modal M Ms \\<in># succ p\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set Ps. Modal M Ms \\<in># succ p", "have a1:\"\\<forall> p \\<in> set Ps. \\<exists> \\<Phi>' \\<Psi>'. p = (\\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps. Modal M Ms \\<in># succ p\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps.\n       \\<exists>\\<Phi>' \\<Psi>'.\n          p = ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)", "using characteriseSeq"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps. Modal M Ms \\<in># succ p\n  \\<exists>A B. ?C = ( A \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps.\n       \\<exists>\\<Phi>' \\<Psi>'.\n          p = ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)", "apply (auto simp add:Ball_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> set Ps \\<longrightarrow>\n                   Modal M Ms \\<in># succ x;\n        \\<And>C. \\<exists>A B. C = ( A \\<Rightarrow>* B);\n        x \\<in> set Ps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>' \\<Psi>'.\n                            x =\n                            ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms)\n                \\<Psi>')", "apply (drule_tac x=x in spec,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>C. \\<exists>A B. C = ( A \\<Rightarrow>* B);\n        x \\<in> set Ps; Modal M Ms \\<in># succ x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>' \\<Psi>'.\n                            x =\n                            ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms)\n                \\<Psi>')", "apply (rule_tac x=\"antec x\" in exI,rule_tac x=\"succ x \\<ominus> Modal M Ms\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>C. \\<exists>A B. C = ( A \\<Rightarrow>* B);\n        x \\<in> set Ps; Modal M Ms \\<in># succ x\\<rbrakk>\n       \\<Longrightarrow> x =\n                         ( antec\n                            x \\<Rightarrow>* add_mset (Modal M Ms)\n        (succ x \\<ominus> Modal M Ms))", "by (drule_tac x=x in meta_spec) (auto simp add:multiset_eq_iff)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set Ps.\n     \\<exists>\\<Phi>' \\<Psi>'.\n        p = ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "with all"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set Ps.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n  \\<forall>p\\<in>set Ps.\n     \\<exists>\\<Phi>' \\<Psi>'.\n        p = ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)", "have \"\\<forall> p \\<in> set Ps. \\<exists> \\<Phi>' \\<Psi>' n. n\\<le>n' \\<and> \n                             (\\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms,n) \\<in> derivable (ext R R2 M1 M2) \\<and> \n                              p = (\\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus>Modal M Ms)\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n  \\<forall>p\\<in>set Ps.\n     \\<exists>\\<Phi>' \\<Psi>'.\n        p = ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps.\n       \\<exists>\\<Phi>' \\<Psi>' n.\n          n \\<le> n' \\<and>\n          ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms, n)\n          \\<in> derivable (ext R R2 M1 M2) \\<and>\n          p = ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)", "by (auto simp add:Ball_def)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set Ps.\n     \\<exists>\\<Phi>' \\<Psi>' n.\n        n \\<le> n' \\<and>\n        ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms, n)\n        \\<in> derivable (ext R R2 M1 M2) \\<and>\n        p = ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set Ps.\n     \\<exists>\\<Phi>' \\<Psi>' n.\n        n \\<le> n' \\<and>\n        ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms, n)\n        \\<in> derivable (ext R R2 M1 M2) \\<and>\n        p = ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)", "have a2: \"\\<forall> p \\<in> set Ps. \\<exists> \\<Phi>' \\<Psi>' m. m\\<le>n' \\<and> \n                              (\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2) \\<and> \n                              p = (\\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps.\n     \\<exists>\\<Phi>' \\<Psi>' n.\n        n \\<le> n' \\<and>\n        ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms, n)\n        \\<in> derivable (ext R R2 M1 M2) \\<and>\n        p = ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps.\n       \\<exists>\\<Phi>' \\<Psi>' m.\n          m \\<le> n' \\<and>\n          ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2) \\<and>\n          p = ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)", "using num and b' and IH"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps.\n     \\<exists>\\<Phi>' \\<Psi>' n.\n        n \\<le> n' \\<and>\n        ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms, n)\n        \\<in> derivable (ext R R2 M1 M2) \\<and>\n        p = ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n  n = n' + 1\n  \\<forall>r'\\<in>R'.\n     rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\n  \\<forall>m<n.\n     \\<forall>\\<Gamma> \\<Delta>.\n        ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, m)\n        \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n        (\\<forall>r'\\<in>R'.\n            rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n            ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n            \\<in> set (fst r')) \\<longrightarrow>\n        (\\<exists>m'\\<le>m.\n            ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m')\n            \\<in> derivable (ext R R2 M1 M2))\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps.\n       \\<exists>\\<Phi>' \\<Psi>' m.\n          m \\<le> n' \\<and>\n          ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2) \\<and>\n          p = ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)", "apply (auto simp add:Ball_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> set Ps \\<longrightarrow>\n                   (\\<exists>\\<Phi>' \\<Psi>' n.\n                       n \\<le> n' \\<and>\n                       ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms)\n           \\<Psi>',\n                        n)\n                       \\<in> derivable (ext R R2 M1 M2) \\<and>\n                       x =\n                       ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms)\n           \\<Psi>'));\n        n = Suc n';\n        \\<forall>a b.\n           (a, b) \\<in> R' \\<longrightarrow>\n           rightPrincipal (a, b) (Modal M Ms) R' \\<longrightarrow>\n           ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set a;\n        \\<forall>m<Suc n'.\n           \\<forall>\\<Gamma> \\<Delta>.\n              ( \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>, m)\n              \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n              (\\<exists>m'\\<le>m.\n                  ( \\<Gamma> +\n                    \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                   m')\n                  \\<in> derivable (ext R R2 M1 M2));\n        x \\<in> set Ps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>' \\<Psi>' m.\n                            m \\<le> n' \\<and>\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2) \\<and>\n                            x =\n                            ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms)\n                \\<Psi>')", "apply (drule_tac x=x in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>n = Suc n';\n        \\<forall>a b.\n           (a, b) \\<in> R' \\<longrightarrow>\n           rightPrincipal (a, b) (Modal M Ms) R' \\<longrightarrow>\n           ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set a;\n        \\<forall>m<Suc n'.\n           \\<forall>\\<Gamma> \\<Delta>.\n              ( \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>, m)\n              \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n              (\\<exists>m'\\<le>m.\n                  ( \\<Gamma> +\n                    \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                   m')\n                  \\<in> derivable (ext R R2 M1 M2));\n        x \\<in> set Ps;\n        x \\<in> set Ps \\<longrightarrow>\n        (\\<exists>\\<Phi>' \\<Psi>' n.\n            n \\<le> n' \\<and>\n            ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>', n)\n            \\<in> derivable (ext R R2 M1 M2) \\<and>\n            x =\n            ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms)\n\\<Psi>'))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>' \\<Psi>' m.\n                            m \\<le> n' \\<and>\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2) \\<and>\n                            x =\n                            ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms)\n                \\<Psi>')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>n = Suc n';\n        \\<forall>a b.\n           (a, b) \\<in> R' \\<longrightarrow>\n           rightPrincipal (a, b) (Modal M Ms) R' \\<longrightarrow>\n           ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set a;\n        \\<forall>m<Suc n'.\n           \\<forall>\\<Gamma> \\<Delta>.\n              ( \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>, m)\n              \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n              (\\<exists>m'\\<le>m.\n                  ( \\<Gamma> +\n                    \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                   m')\n                  \\<in> derivable (ext R R2 M1 M2));\n        x \\<in> set Ps;\n        \\<exists>\\<Phi>' \\<Psi>' n.\n           n \\<le> n' \\<and>\n           ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>', n)\n           \\<in> derivable (ext R R2 M1 M2) \\<and>\n           x =\n           ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>' \\<Psi>' m.\n                            m \\<le> n' \\<and>\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2) \\<and>\n                            x =\n                            ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms)\n                \\<Psi>')", "apply hypsubst_thin"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>a b.\n                   (a, b) \\<in> R' \\<longrightarrow>\n                   rightPrincipal (a, b) (Modal M Ms) R' \\<longrightarrow>\n                   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set a;\n        \\<forall>m<Suc n'.\n           \\<forall>\\<Gamma> \\<Delta>.\n              ( \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>, m)\n              \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n              (\\<exists>m'\\<le>m.\n                  ( \\<Gamma> +\n                    \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                   m')\n                  \\<in> derivable (ext R R2 M1 M2));\n        x \\<in> set Ps;\n        \\<exists>\\<Phi>' \\<Psi>' n.\n           n \\<le> n' \\<and>\n           ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>', n)\n           \\<in> derivable (ext R R2 M1 M2) \\<and>\n           x =\n           ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>' \\<Psi>' m.\n                            m \\<le> n' \\<and>\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2) \\<and>\n                            x =\n                            ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms)\n                \\<Psi>')", "apply (elim exE conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<Phi>' \\<Psi>' n.\n       \\<lbrakk>\\<forall>a b.\n                   (a, b) \\<in> R' \\<longrightarrow>\n                   rightPrincipal (a, b) (Modal M Ms) R' \\<longrightarrow>\n                   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set a;\n        \\<forall>m<Suc n'.\n           \\<forall>\\<Gamma> \\<Delta>.\n              ( \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>, m)\n              \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n              (\\<exists>m'\\<le>m.\n                  ( \\<Gamma> +\n                    \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                   m')\n                  \\<in> derivable (ext R R2 M1 M2));\n        x \\<in> set Ps; n \\<le> n';\n        ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>', n)\n        \\<in> derivable (ext R R2 M1 M2);\n        x = ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>' \\<Psi>' m.\n                            m \\<le> n' \\<and>\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2) \\<and>\n                            x =\n                            ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms)\n                \\<Psi>')", "apply (drule_tac x=n in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<Phi>' \\<Psi>' n.\n       \\<lbrakk>\\<forall>a b.\n                   (a, b) \\<in> R' \\<longrightarrow>\n                   rightPrincipal (a, b) (Modal M Ms) R' \\<longrightarrow>\n                   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set a;\n        x \\<in> set Ps; n \\<le> n';\n        ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>', n)\n        \\<in> derivable (ext R R2 M1 M2);\n        x = ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>');\n        n < Suc n' \\<longrightarrow>\n        (\\<forall>\\<Gamma> \\<Delta>.\n            ( \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>, n)\n            \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n            (\\<exists>m'\\<le>n.\n                ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                 m')\n                \\<in> derivable (ext R R2 M1 M2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>' \\<Psi>' m.\n                            m \\<le> n' \\<and>\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2) \\<and>\n                            x =\n                            ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms)\n                \\<Psi>')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<Phi>' \\<Psi>' n.\n       \\<lbrakk>\\<forall>a b.\n                   (a, b) \\<in> R' \\<longrightarrow>\n                   rightPrincipal (a, b) (Modal M Ms) R' \\<longrightarrow>\n                   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set a;\n        ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>')\n        \\<in> set Ps;\n        n \\<le> n';\n        ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>', n)\n        \\<in> derivable (ext R R2 M1 M2);\n        x = ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>');\n        \\<forall>\\<Gamma> \\<Delta>.\n           ( \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>, n)\n           \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n           (\\<exists>m'\\<le>n.\n               ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                m')\n               \\<in> derivable (ext R R2 M1 M2))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<le>n'.\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2)", "apply (drule_tac x=\\<Phi>' in spec,drule_tac x=\\<Psi>' in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<Phi>' \\<Psi>' n.\n       \\<lbrakk>\\<forall>a b.\n                   (a, b) \\<in> R' \\<longrightarrow>\n                   rightPrincipal (a, b) (Modal M Ms) R' \\<longrightarrow>\n                   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set a;\n        ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>')\n        \\<in> set Ps;\n        n \\<le> n';\n        ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>', n)\n        \\<in> derivable (ext R R2 M1 M2);\n        x = ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>');\n        ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>', n)\n        \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n        (\\<exists>m'\\<le>n.\n            ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', m')\n            \\<in> derivable (ext R R2 M1 M2))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<le>n'.\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2)", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<Phi>' \\<Psi>' n.\n       \\<lbrakk>\\<forall>a b.\n                   (a, b) \\<in> R' \\<longrightarrow>\n                   rightPrincipal (a, b) (Modal M Ms) R' \\<longrightarrow>\n                   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set a;\n        ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>')\n        \\<in> set Ps;\n        n \\<le> n';\n        ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>', n)\n        \\<in> derivable (ext R R2 M1 M2);\n        x = ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>');\n        \\<exists>m'\\<le>n.\n           ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', m')\n           \\<in> derivable (ext R R2 M1 M2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<le>n'.\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2)", "apply (elim exE conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<Phi>' \\<Psi>' n m'.\n       \\<lbrakk>\\<forall>a b.\n                   (a, b) \\<in> R' \\<longrightarrow>\n                   rightPrincipal (a, b) (Modal M Ms) R' \\<longrightarrow>\n                   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set a;\n        ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>')\n        \\<in> set Ps;\n        n \\<le> n';\n        ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>', n)\n        \\<in> derivable (ext R R2 M1 M2);\n        x = ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>');\n        m' \\<le> n;\n        ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', m')\n        \\<in> derivable (ext R R2 M1 M2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<le>n'.\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2)", "by (rule_tac x=m' in exI) arith"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set Ps.\n     \\<exists>\\<Phi>' \\<Psi>' m.\n        m \\<le> n' \\<and>\n        ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', m)\n        \\<in> derivable (ext R R2 M1 M2) \\<and>\n        p = ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "obtain Ps' where eq: \"Ps' = map (extend (\\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')) ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Ps'.\n        Ps' =\n        map (extend\n              ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>'))\n         ps \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Ps' =\n  map (extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')) ps\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "have \"length Ps = length Ps'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length Ps = length Ps'", "using \\<open>Ps' = map (extend (\\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')) ps\\<close>\n                               and \\<open>Ps = map (extend S) ps\\<close>"], ["proof (prove)\nusing this:\n  Ps' =\n  map (extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')) ps\n  Ps = map (extend S) ps\n\ngoal (1 subgoal):\n 1. length Ps = length Ps'", "by auto"], ["proof (state)\nthis:\n  length Ps = length Ps'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  length Ps = length Ps'", "have \"Ps' \\<noteq> []\""], ["proof (prove)\nusing this:\n  length Ps = length Ps'\n\ngoal (1 subgoal):\n 1. Ps' \\<noteq> []", "using nonempty"], ["proof (prove)\nusing this:\n  length Ps = length Ps'\n  Ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. Ps' \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  Ps' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "from \\<open>r \\<in> upRules \\<or> r \\<in> modRules2\\<close> and \\<open>r \\<in> R\\<close>"], ["proof (chain)\npicking this:\n  r \\<in> upRules \\<or> r \\<in> modRules2\n  r \\<in> R", "have \"extendRule (\\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') r \\<in> (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  r \\<in> upRules \\<or> r \\<in> modRules2\n  r \\<in> R\n\ngoal (1 subgoal):\n 1. extendRule ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') r\n    \\<in> ext R R2 M1 M2", "by auto"], ["proof (state)\nthis:\n  extendRule ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  extendRule ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "have \"extendRule (\\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') r = (Ps',\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extendRule ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') r =\n    (Ps',  \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>')", "using \\<open>S = (\\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\\<close> and ext and \\<open>r = (ps,c)\\<close> and eq"], ["proof (prove)\nusing this:\n  S = ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r = (ps, c)\n  Ps' =\n  map (extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')) ps\n\ngoal (1 subgoal):\n 1. extendRule ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') r =\n    (Ps',  \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>')", "by (auto simp add:extendRule_def extend_def)"], ["proof (state)\nthis:\n  extendRule ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') r =\n  (Ps',  \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  extendRule ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n  extendRule ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') r =\n  (Ps',  \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>')", "have \"(Ps',\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') \\<in> (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  extendRule ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n  extendRule ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') r =\n  (Ps',  \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>')\n\ngoal (1 subgoal):\n 1. (Ps',  \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>')\n    \\<in> ext R R2 M1 M2", "by simp"], ["proof (state)\nthis:\n  (Ps',  \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>')\n  \\<in> ext R R2 M1 M2\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "have c1:\"\\<forall> p \\<in> set ps. extend S p \\<in> set Ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set ps. extend S p \\<in> set Ps", "using \\<open>Ps = map (extend S) ps\\<close>"], ["proof (prove)\nusing this:\n  Ps = map (extend S) ps\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set ps. extend S p \\<in> set Ps", "by (simp add:Ball_def)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set ps. extend S p \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "have c2:\"\\<forall> p \\<in> set ps. extend (\\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p \\<in> set Ps'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set ps.\n       extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p\n       \\<in> set Ps'", "using eq"], ["proof (prove)\nusing this:\n  Ps' =\n  map (extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')) ps\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set ps.\n       extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p\n       \\<in> set Ps'", "by (simp add:Ball_def)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set ps.\n     extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p\n     \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set ps.\n     extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p\n     \\<in> set Ps'", "have eq2:\"\\<forall> p \\<in> set Ps'. \\<exists> \\<Phi>' \\<Psi>'. p = (\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set ps.\n     extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p\n     \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps'.\n       \\<exists>\\<Phi>' \\<Psi>'.\n          p = ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "using eq"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set ps.\n     extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p\n     \\<in> set Ps'\n  Ps' =\n  map (extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')) ps\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps'.\n       \\<exists>\\<Phi>' \\<Psi>'.\n          p = ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "by (auto simp add: extend_def)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>\\<Phi>' \\<Psi>'.\n        p = ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "have d1:\"\\<forall> p \\<in> set Ps. \\<exists> p' \\<in> set ps. p = extend S p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps. \\<exists>p'\\<in>set ps. p = extend S p'", "using \\<open>Ps = map (extend S) ps\\<close>"], ["proof (prove)\nusing this:\n  Ps = map (extend S) ps\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps. \\<exists>p'\\<in>set ps. p = extend S p'", "by (auto simp add:Ball_def Bex_def)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set Ps. \\<exists>p'\\<in>set ps. p = extend S p'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set Ps. \\<exists>p'\\<in>set ps. p = extend S p'", "have \"\\<forall> p \\<in> set Ps. \\<exists> p'. p' \\<in> set Ps'\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps. \\<exists>p'\\<in>set ps. p = extend S p'\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps. \\<exists>p'. p' \\<in> set Ps'", "using c2"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps. \\<exists>p'\\<in>set ps. p = extend S p'\n  \\<forall>p\\<in>set ps.\n     extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p\n     \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps. \\<exists>p'. p' \\<in> set Ps'", "by (auto simp add:Ball_def Bex_def)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set Ps. \\<exists>p'. p' \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set Ps. \\<exists>p'. p' \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "have d2: \"\\<forall> p \\<in> set Ps'. \\<exists> p' \\<in> set ps. p = extend (\\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps'.\n       \\<exists>p'\\<in>set ps.\n          p =\n          extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p'", "using eq"], ["proof (prove)\nusing this:\n  Ps' =\n  map (extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')) ps\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps'.\n       \\<exists>p'\\<in>set ps.\n          p =\n          extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p'", "by (auto simp add:Ball_def Bex_def)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>p'\\<in>set ps.\n        p =\n        extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>p'\\<in>set ps.\n        p =\n        extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p'", "have \"\\<forall> p \\<in> set Ps'. \\<exists> p'. p' \\<in> set Ps\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>p'\\<in>set ps.\n        p =\n        extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p'\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps'. \\<exists>p'. p' \\<in> set Ps", "using c1"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>p'\\<in>set ps.\n        p =\n        extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p'\n  \\<forall>p\\<in>set ps. extend S p \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps'. \\<exists>p'. p' \\<in> set Ps", "by (auto simp add:Ball_def Bex_def)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set Ps'. \\<exists>p'. p' \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "have \"\\<forall> \\<Phi>' \\<Psi>'. (\\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps \\<longrightarrow> (\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "fix \\<Phi>' \\<Psi>'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "assume \"(\\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps\""], ["proof (state)\nthis:\n  ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "then"], ["proof (chain)\npicking this:\n  ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps", "have \"\\<exists> p \\<in> set ps. extend (\\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms) p = (\\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\""], ["proof (prove)\nusing this:\n  ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set ps.\n       extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms) p =\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)", "using \\<open>Ps = map (extend S) ps\\<close> and \\<open>S = (\\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\\<close> and a1 and d1"], ["proof (prove)\nusing this:\n  ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps\n  Ps = map (extend S) ps\n  S = ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\n  \\<forall>p\\<in>set Ps.\n     \\<exists>\\<Phi>' \\<Psi>'.\n        p = ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n  \\<forall>p\\<in>set Ps. \\<exists>p'\\<in>set ps. p = extend S p'\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set ps.\n       extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms) p =\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)", "apply (simp only:Ball_def Bex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n             \\<in> set (map (extend\n                              ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus>\n                Modal M Ms))\n                         ps);\n     Ps =\n     map (extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)) ps;\n     S = ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms);\n     \\<forall>x.\n        x \\<in> set (map (extend\n                           ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus>\n             Modal M Ms))\n                      ps) \\<longrightarrow>\n        (\\<exists>\\<Phi>' \\<Psi>'.\n            x = ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms));\n     \\<forall>x.\n        x \\<in> set (map (extend\n                           ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus>\n             Modal M Ms))\n                      ps) \\<longrightarrow>\n        (\\<exists>xa.\n            xa \\<in> set ps \\<and>\n            x =\n            extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\n             xa)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         x \\<in> set ps \\<and>\n                         extend\n                          ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus>\n            Modal M Ms)\n                          x =\n                         ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus>\n            Modal M Ms)", "apply (drule_tac x=\" \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n             \\<in> set (map (extend\n                              ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus>\n                Modal M Ms))\n                         ps);\n     Ps =\n     map (extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)) ps;\n     S = ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms);\n     \\<forall>x.\n        x \\<in> set (map (extend\n                           ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus>\n             Modal M Ms))\n                      ps) \\<longrightarrow>\n        (\\<exists>xa.\n            xa \\<in> set ps \\<and>\n            x =\n            extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms) xa);\n     ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n     \\<in> set (map (extend\n                      ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms))\n                 ps) \\<longrightarrow>\n     (\\<exists>\\<Phi>'' \\<Psi>''.\n         ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) =\n         ( \\<Phi>'' \\<Rightarrow>* \\<Psi>'' \\<oplus> Modal M Ms))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         x \\<in> set ps \\<and>\n                         extend\n                          ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus>\n            Modal M Ms)\n                          x =\n                         ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus>\n            Modal M Ms)", "by (drule_tac x=\"\\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms\" in spec) (auto)"], ["proof (state)\nthis:\n  \\<exists>p\\<in>set ps.\n     extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms) p =\n     ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "then"], ["proof (chain)\npicking this:\n  \\<exists>p\\<in>set ps.\n     extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms) p =\n     ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)", "obtain p where t:\"p \\<in> set ps \\<and> (\\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) = extend (\\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms) p\""], ["proof (prove)\nusing this:\n  \\<exists>p\\<in>set ps.\n     extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms) p =\n     ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        p \\<in> set ps \\<and>\n        ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) =\n        extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\n         p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>p.\n                   p \\<in> set ps \\<and>\n                   ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>') =\n                   extend\n                    ( \\<Phi> \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>1)\n                    p \\<Longrightarrow>\n                   thesis;\n        p \\<in> set ps;\n        extend ( \\<Phi> \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>1) p =\n        ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>')\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (drule_tac x=p in meta_spec) (simp)"], ["proof (state)\nthis:\n  p \\<in> set ps \\<and>\n  ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) =\n  extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms) p\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "then"], ["proof (chain)\npicking this:\n  p \\<in> set ps \\<and>\n  ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) =\n  extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms) p", "obtain D B where \"p = (D \\<Rightarrow>* B)\""], ["proof (prove)\nusing this:\n  p \\<in> set ps \\<and>\n  ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) =\n  extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms) p\n\ngoal (1 subgoal):\n 1. (\\<And>D B.\n        p = ( D \\<Rightarrow>* B) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases p)"], ["proof (state)\nthis:\n  p = ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "then"], ["proof (chain)\npicking this:\n  p = ( D \\<Rightarrow>* B)", "have \"(D \\<Rightarrow>* B) \\<in> set ps \\<and> (\\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) = extend (\\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms) (D \\<Rightarrow>* B)\""], ["proof (prove)\nusing this:\n  p = ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. ( D \\<Rightarrow>* B) \\<in> set ps \\<and>\n    ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) =\n    extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\n     ( D \\<Rightarrow>* B)", "using t"], ["proof (prove)\nusing this:\n  p = ( D \\<Rightarrow>* B)\n  p \\<in> set ps \\<and>\n  ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) =\n  extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms) p\n\ngoal (1 subgoal):\n 1. ( D \\<Rightarrow>* B) \\<in> set ps \\<and>\n    ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) =\n    extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\n     ( D \\<Rightarrow>* B)", "by auto"], ["proof (state)\nthis:\n  ( D \\<Rightarrow>* B) \\<in> set ps \\<and>\n  ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) =\n  extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\n   ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "then"], ["proof (chain)\npicking this:\n  ( D \\<Rightarrow>* B) \\<in> set ps \\<and>\n  ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) =\n  extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\n   ( D \\<Rightarrow>* B)", "have ant: \"\\<Phi>' = \\<Phi> + D\" and suc: \"\\<Psi>' \\<oplus> Modal M Ms = \\<Psi>1 \\<oplus> Modal M Ms + B\""], ["proof (prove)\nusing this:\n  ( D \\<Rightarrow>* B) \\<in> set ps \\<and>\n  ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) =\n  extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\n   ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. \\<Phi>' = \\<Phi> + D &&&\n    \\<Psi>' \\<oplus> Modal M Ms = \\<Psi>1 \\<oplus> Modal M Ms + B", "using extend_def[where forms=\"\\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms\" and seq=\"D \\<Rightarrow>* B\"]"], ["proof (prove)\nusing this:\n  ( D \\<Rightarrow>* B) \\<in> set ps \\<and>\n  ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) =\n  extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\n   ( D \\<Rightarrow>* B)\n  extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\n   ( D \\<Rightarrow>* B) \\<equiv>\n   antec ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms) +\n   antec\n    ( D \\<Rightarrow>* B) \\<Rightarrow>* succ\n    ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms) +\n   succ ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. \\<Phi>' = \\<Phi> + D &&&\n    \\<Psi>' \\<oplus> Modal M Ms = \\<Psi>1 \\<oplus> Modal M Ms + B", "by auto"], ["proof (state)\nthis:\n  \\<Phi>' = \\<Phi> + D\n  \\<Psi>' \\<oplus> Modal M Ms = \\<Psi>1 \\<oplus> Modal M Ms + B\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "from ant"], ["proof (chain)\npicking this:\n  \\<Phi>' = \\<Phi> + D", "have \"\\<Phi>' + \\<Gamma>' = (\\<Phi> + \\<Gamma>') + D\""], ["proof (prove)\nusing this:\n  \\<Phi>' = \\<Phi> + D\n\ngoal (1 subgoal):\n 1. \\<Phi>' + \\<Gamma>' = \\<Phi> + \\<Gamma>' + D", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  \\<Phi>' + \\<Gamma>' = \\<Phi> + \\<Gamma>' + D\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "moreover"], ["proof (state)\nthis:\n  \\<Phi>' + \\<Gamma>' = \\<Phi> + \\<Gamma>' + D\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "from suc"], ["proof (chain)\npicking this:\n  \\<Psi>' \\<oplus> Modal M Ms = \\<Psi>1 \\<oplus> Modal M Ms + B", "have \"\\<Psi>' = \\<Psi>1 + B\""], ["proof (prove)\nusing this:\n  \\<Psi>' \\<oplus> Modal M Ms = \\<Psi>1 \\<oplus> Modal M Ms + B\n\ngoal (1 subgoal):\n 1. \\<Psi>' = \\<Psi>1 + B", "by auto"], ["proof (state)\nthis:\n  \\<Psi>' = \\<Psi>1 + B\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "then"], ["proof (chain)\npicking this:\n  \\<Psi>' = \\<Psi>1 + B", "have \"\\<Psi>' + \\<Delta>' = (\\<Psi>1 + \\<Delta>') + B\""], ["proof (prove)\nusing this:\n  \\<Psi>' = \\<Psi>1 + B\n\ngoal (1 subgoal):\n 1. \\<Psi>' + \\<Delta>' = \\<Psi>1 + \\<Delta>' + B", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  \\<Psi>' + \\<Delta>' = \\<Psi>1 + \\<Delta>' + B\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "ultimately"], ["proof (chain)\npicking this:\n  \\<Phi>' + \\<Gamma>' = \\<Phi> + \\<Gamma>' + D\n  \\<Psi>' + \\<Delta>' = \\<Psi>1 + \\<Delta>' + B", "have \"(\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') = extend (\\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') (D \\<Rightarrow>* B)\""], ["proof (prove)\nusing this:\n  \\<Phi>' + \\<Gamma>' = \\<Phi> + \\<Gamma>' + D\n  \\<Psi>' + \\<Delta>' = \\<Psi>1 + \\<Delta>' + B\n\ngoal (1 subgoal):\n 1. ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n    extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')\n     ( D \\<Rightarrow>* B)", "using extend_def[where forms=\"\\<Phi>+\\<Gamma>'\\<Rightarrow>*\\<Psi>1+\\<Delta>'\" and seq=\"D\\<Rightarrow>*B\"]"], ["proof (prove)\nusing this:\n  \\<Phi>' + \\<Gamma>' = \\<Phi> + \\<Gamma>' + D\n  \\<Psi>' + \\<Delta>' = \\<Psi>1 + \\<Delta>' + B\n  extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')\n   ( D \\<Rightarrow>* B) \\<equiv>\n   antec ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') +\n   antec\n    ( D \\<Rightarrow>* B) \\<Rightarrow>* succ\n    ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') +\n   succ ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n    extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')\n     ( D \\<Rightarrow>* B)", "by auto"], ["proof (state)\nthis:\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n  extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')\n   ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "moreover"], ["proof (state)\nthis:\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n  extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')\n   ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "have \"extend (\\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') (D \\<Rightarrow>* B) \\<in> set Ps'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')\n     ( D \\<Rightarrow>* B)\n    \\<in> set Ps'", "using \\<open>p = (D \\<Rightarrow>* B)\\<close> and t and c2"], ["proof (prove)\nusing this:\n  p = ( D \\<Rightarrow>* B)\n  p \\<in> set ps \\<and>\n  ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) =\n  extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms) p\n  \\<forall>p\\<in>set ps.\n     extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p\n     \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')\n     ( D \\<Rightarrow>* B)\n    \\<in> set Ps'", "by auto"], ["proof (state)\nthis:\n  extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')\n   ( D \\<Rightarrow>* B)\n  \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "ultimately"], ["proof (chain)\npicking this:\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n  extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')\n   ( D \\<Rightarrow>* B)\n  extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')\n   ( D \\<Rightarrow>* B)\n  \\<in> set Ps'", "have \"(\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'\""], ["proof (prove)\nusing this:\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n  extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')\n   ( D \\<Rightarrow>* B)\n  extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')\n   ( D \\<Rightarrow>* B)\n  \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'", "by simp"], ["proof (state)\nthis:\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "}"], ["proof (state)\nthis:\n  ( ?\\<Phi>'2 \\<Rightarrow>* ?\\<Psi>'2 \\<oplus> Modal M Ms)\n  \\<in> set Ps \\<Longrightarrow>\n  ( ?\\<Phi>'2 + \\<Gamma>' \\<Rightarrow>* ?\\<Psi>'2 + \\<Delta>')\n  \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "thus ?thesis"], ["proof (prove)\nusing this:\n  ( ?\\<Phi>'2 \\<Rightarrow>* ?\\<Psi>'2 \\<oplus> Modal M Ms)\n  \\<in> set Ps \\<Longrightarrow>\n  ( ?\\<Phi>'2 + \\<Gamma>' \\<Rightarrow>* ?\\<Psi>'2 + \\<Delta>')\n  \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "by blast"], ["proof (state)\nthis:\n  \\<forall>\\<Phi>' \\<Psi>'.\n     ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n     \\<in> set Ps \\<longrightarrow>\n     ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<Phi>' \\<Psi>'.\n     ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n     \\<in> set Ps \\<longrightarrow>\n     ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<Phi>' \\<Psi>'.\n     ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n     \\<in> set Ps \\<longrightarrow>\n     ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "have \"\\<forall> \\<Phi>' \\<Psi>'. (\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps' \\<longrightarrow> (\\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps", "fix \\<Phi>' \\<Psi>'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps", "assume \"(\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'\""], ["proof (state)\nthis:\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps", "then"], ["proof (chain)\npicking this:\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'", "have \"\\<exists> p \\<in> set ps. extend (\\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p = (\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\""], ["proof (prove)\nusing this:\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set ps.\n       extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p =\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "using eq and eq2 and d2"], ["proof (prove)\nusing this:\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'\n  Ps' =\n  map (extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')) ps\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>\\<Phi>' \\<Psi>'.\n        p = ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>p'\\<in>set ps.\n        p =\n        extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p'\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set ps.\n       extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p =\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "apply (simp only:Ball_def Bex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n             \\<in> set (map (extend\n                              ( \\<Phi> +\n                                \\<Gamma>' \\<Rightarrow>* \\<Psi>1 +\n                   \\<Delta>'))\n                         ps);\n     Ps' =\n     map (extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>'))\n      ps;\n     \\<forall>x.\n        x \\<in> set (map (extend\n                           ( \\<Phi> +\n                             \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>'))\n                      ps) \\<longrightarrow>\n        (\\<exists>\\<Phi>' \\<Psi>'.\n            x = ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>'));\n     \\<forall>x.\n        x \\<in> set (map (extend\n                           ( \\<Phi> +\n                             \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>'))\n                      ps) \\<longrightarrow>\n        (\\<exists>xa.\n            xa \\<in> set ps \\<and>\n            x =\n            extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')\n             xa)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         x \\<in> set ps \\<and>\n                         extend\n                          ( \\<Phi> +\n                            \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')\n                          x =\n                         ( \\<Phi>' +\n                           \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "apply (drule_tac x=\"\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>'\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n             \\<in> set (map (extend\n                              ( \\<Phi> +\n                                \\<Gamma>' \\<Rightarrow>* \\<Psi>1 +\n                   \\<Delta>'))\n                         ps);\n     Ps' =\n     map (extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>'))\n      ps;\n     \\<forall>x.\n        x \\<in> set (map (extend\n                           ( \\<Phi> +\n                             \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>'))\n                      ps) \\<longrightarrow>\n        (\\<exists>xa.\n            xa \\<in> set ps \\<and>\n            x =\n            extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')\n             xa);\n     ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n     \\<in> set (map (extend\n                      ( \\<Phi> +\n                        \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>'))\n                 ps) \\<longrightarrow>\n     (\\<exists>\\<Phi>'' \\<Psi>''.\n         ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n         ( \\<Phi>'' +\n           \\<Gamma>' \\<Rightarrow>* \\<Psi>'' + \\<Delta>'))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         x \\<in> set ps \\<and>\n                         extend\n                          ( \\<Phi> +\n                            \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')\n                          x =\n                         ( \\<Phi>' +\n                           \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "by (drule_tac x=\"\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>'\" in spec) (auto)"], ["proof (state)\nthis:\n  \\<exists>p\\<in>set ps.\n     extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p =\n     ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps", "then"], ["proof (chain)\npicking this:\n  \\<exists>p\\<in>set ps.\n     extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p =\n     ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "obtain p where t:\"p \\<in> set ps \\<and> (\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') = extend (\\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p\""], ["proof (prove)\nusing this:\n  \\<exists>p\\<in>set ps.\n     extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p =\n     ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        p \\<in> set ps \\<and>\n        ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n        extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')\n         p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>p.\n                   p \\<in> set ps \\<and>\n                   ( \\<Phi>' +\n                     \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n                   extend\n                    ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')\n                    p \\<Longrightarrow>\n                   thesis;\n        p \\<in> set ps;\n        extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p =\n        ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (drule_tac x=p in meta_spec) (simp)"], ["proof (state)\nthis:\n  p \\<in> set ps \\<and>\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n  extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps", "then"], ["proof (chain)\npicking this:\n  p \\<in> set ps \\<and>\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n  extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p", "obtain D B where \"p = (D \\<Rightarrow>* B)\""], ["proof (prove)\nusing this:\n  p \\<in> set ps \\<and>\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n  extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p\n\ngoal (1 subgoal):\n 1. (\\<And>D B.\n        p = ( D \\<Rightarrow>* B) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases p)"], ["proof (state)\nthis:\n  p = ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps", "then"], ["proof (chain)\npicking this:\n  p = ( D \\<Rightarrow>* B)", "have \"(D \\<Rightarrow>* B) \\<in> set ps \\<and> (\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') = extend (\\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') (D \\<Rightarrow>* B)\""], ["proof (prove)\nusing this:\n  p = ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. ( D \\<Rightarrow>* B) \\<in> set ps \\<and>\n    ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n    extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')\n     ( D \\<Rightarrow>* B)", "using t"], ["proof (prove)\nusing this:\n  p = ( D \\<Rightarrow>* B)\n  p \\<in> set ps \\<and>\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n  extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p\n\ngoal (1 subgoal):\n 1. ( D \\<Rightarrow>* B) \\<in> set ps \\<and>\n    ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n    extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')\n     ( D \\<Rightarrow>* B)", "by auto"], ["proof (state)\nthis:\n  ( D \\<Rightarrow>* B) \\<in> set ps \\<and>\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n  extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')\n   ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps", "then"], ["proof (chain)\npicking this:\n  ( D \\<Rightarrow>* B) \\<in> set ps \\<and>\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n  extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')\n   ( D \\<Rightarrow>* B)", "have ant: \"\\<Phi>' + \\<Gamma>' = \\<Phi> + \\<Gamma>' + D\" and suc: \"\\<Psi>' + \\<Delta>' = \\<Psi>1 + \\<Delta>' + B\""], ["proof (prove)\nusing this:\n  ( D \\<Rightarrow>* B) \\<in> set ps \\<and>\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n  extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')\n   ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. \\<Phi>' + \\<Gamma>' = \\<Phi> + \\<Gamma>' + D &&&\n    \\<Psi>' + \\<Delta>' = \\<Psi>1 + \\<Delta>' + B", "using extend_def[where forms=\"\\<Phi>+\\<Gamma>'\\<Rightarrow>*\\<Psi>1+\\<Delta>'\" and seq=\"D\\<Rightarrow>*B\"]"], ["proof (prove)\nusing this:\n  ( D \\<Rightarrow>* B) \\<in> set ps \\<and>\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n  extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')\n   ( D \\<Rightarrow>* B)\n  extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>')\n   ( D \\<Rightarrow>* B) \\<equiv>\n   antec ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') +\n   antec\n    ( D \\<Rightarrow>* B) \\<Rightarrow>* succ\n    ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') +\n   succ ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. \\<Phi>' + \\<Gamma>' = \\<Phi> + \\<Gamma>' + D &&&\n    \\<Psi>' + \\<Delta>' = \\<Psi>1 + \\<Delta>' + B", "by auto"], ["proof (state)\nthis:\n  \\<Phi>' + \\<Gamma>' = \\<Phi> + \\<Gamma>' + D\n  \\<Psi>' + \\<Delta>' = \\<Psi>1 + \\<Delta>' + B\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps", "from ant"], ["proof (chain)\npicking this:\n  \\<Phi>' + \\<Gamma>' = \\<Phi> + \\<Gamma>' + D", "have \"\\<Phi>' + \\<Gamma>' = (\\<Phi> + D) + \\<Gamma>'\""], ["proof (prove)\nusing this:\n  \\<Phi>' + \\<Gamma>' = \\<Phi> + \\<Gamma>' + D\n\ngoal (1 subgoal):\n 1. \\<Phi>' + \\<Gamma>' = \\<Phi> + D + \\<Gamma>'", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  \\<Phi>' + \\<Gamma>' = \\<Phi> + D + \\<Gamma>'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps", "then"], ["proof (chain)\npicking this:\n  \\<Phi>' + \\<Gamma>' = \\<Phi> + D + \\<Gamma>'", "have \"\\<Phi>' = \\<Phi> + D\""], ["proof (prove)\nusing this:\n  \\<Phi>' + \\<Gamma>' = \\<Phi> + D + \\<Gamma>'\n\ngoal (1 subgoal):\n 1. \\<Phi>' = \\<Phi> + D", "by simp"], ["proof (state)\nthis:\n  \\<Phi>' = \\<Phi> + D\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps", "moreover"], ["proof (state)\nthis:\n  \\<Phi>' = \\<Phi> + D\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps", "from suc"], ["proof (chain)\npicking this:\n  \\<Psi>' + \\<Delta>' = \\<Psi>1 + \\<Delta>' + B", "have \"\\<Psi>' + \\<Delta>' = (\\<Psi>1 + B) + \\<Delta>'\""], ["proof (prove)\nusing this:\n  \\<Psi>' + \\<Delta>' = \\<Psi>1 + \\<Delta>' + B\n\ngoal (1 subgoal):\n 1. \\<Psi>' + \\<Delta>' = \\<Psi>1 + B + \\<Delta>'", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  \\<Psi>' + \\<Delta>' = \\<Psi>1 + B + \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps", "then"], ["proof (chain)\npicking this:\n  \\<Psi>' + \\<Delta>' = \\<Psi>1 + B + \\<Delta>'", "have \"\\<Psi>' = \\<Psi>1 + B\""], ["proof (prove)\nusing this:\n  \\<Psi>' + \\<Delta>' = \\<Psi>1 + B + \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<Psi>' = \\<Psi>1 + B", "by simp"], ["proof (state)\nthis:\n  \\<Psi>' = \\<Psi>1 + B\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps", "then"], ["proof (chain)\npicking this:\n  \\<Psi>' = \\<Psi>1 + B", "have \"\\<Psi>' \\<oplus> Modal M Ms = (\\<Psi>1 \\<oplus> Modal M Ms) + B\""], ["proof (prove)\nusing this:\n  \\<Psi>' = \\<Psi>1 + B\n\ngoal (1 subgoal):\n 1. \\<Psi>' \\<oplus> Modal M Ms = \\<Psi>1 \\<oplus> Modal M Ms + B", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  \\<Psi>' \\<oplus> Modal M Ms = \\<Psi>1 \\<oplus> Modal M Ms + B\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps", "ultimately"], ["proof (chain)\npicking this:\n  \\<Phi>' = \\<Phi> + D\n  \\<Psi>' \\<oplus> Modal M Ms = \\<Psi>1 \\<oplus> Modal M Ms + B", "have \"(\\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) = extend (\\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms) (D \\<Rightarrow>* B)\""], ["proof (prove)\nusing this:\n  \\<Phi>' = \\<Phi> + D\n  \\<Psi>' \\<oplus> Modal M Ms = \\<Psi>1 \\<oplus> Modal M Ms + B\n\ngoal (1 subgoal):\n 1. ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) =\n    extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\n     ( D \\<Rightarrow>* B)", "using extend_def[where forms=\"\\<Phi>\\<Rightarrow>*\\<Psi>1\\<oplus>Modal M Ms\" and seq=\"D\\<Rightarrow>*B\"]"], ["proof (prove)\nusing this:\n  \\<Phi>' = \\<Phi> + D\n  \\<Psi>' \\<oplus> Modal M Ms = \\<Psi>1 \\<oplus> Modal M Ms + B\n  extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\n   ( D \\<Rightarrow>* B) \\<equiv>\n   antec ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms) +\n   antec\n    ( D \\<Rightarrow>* B) \\<Rightarrow>* succ\n    ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms) +\n   succ ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) =\n    extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\n     ( D \\<Rightarrow>* B)", "by auto"], ["proof (state)\nthis:\n  ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) =\n  extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\n   ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps", "moreover"], ["proof (state)\nthis:\n  ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) =\n  extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\n   ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps", "have \"extend (\\<Phi>  \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms) (D \\<Rightarrow>* B) \\<in> set Ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\n     ( D \\<Rightarrow>* B)\n    \\<in> set Ps", "using \\<open>p = (D \\<Rightarrow>* B)\\<close> and t and c1\n                       and \\<open>S = (\\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\\<close>"], ["proof (prove)\nusing this:\n  p = ( D \\<Rightarrow>* B)\n  p \\<in> set ps \\<and>\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n  extend ( \\<Phi> + \\<Gamma>' \\<Rightarrow>* \\<Psi>1 + \\<Delta>') p\n  \\<forall>p\\<in>set ps. extend S p \\<in> set Ps\n  S = ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\n     ( D \\<Rightarrow>* B)\n    \\<in> set Ps", "by auto"], ["proof (state)\nthis:\n  extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\n   ( D \\<Rightarrow>* B)\n  \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps", "ultimately"], ["proof (chain)\npicking this:\n  ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) =\n  extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\n   ( D \\<Rightarrow>* B)\n  extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\n   ( D \\<Rightarrow>* B)\n  \\<in> set Ps", "have \"(\\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps\""], ["proof (prove)\nusing this:\n  ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) =\n  extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\n   ( D \\<Rightarrow>* B)\n  extend ( \\<Phi> \\<Rightarrow>* \\<Psi>1 \\<oplus> Modal M Ms)\n   ( D \\<Rightarrow>* B)\n  \\<in> set Ps\n\ngoal (1 subgoal):\n 1. ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps", "by simp"], ["proof (state)\nthis:\n  ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps", "}"], ["proof (state)\nthis:\n  ( ?\\<Phi>'2 + \\<Gamma>' \\<Rightarrow>* ?\\<Psi>'2 + \\<Delta>')\n  \\<in> set Ps' \\<Longrightarrow>\n  ( ?\\<Phi>'2 \\<Rightarrow>* ?\\<Psi>'2 \\<oplus> Modal M Ms) \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps", "thus ?thesis"], ["proof (prove)\nusing this:\n  ( ?\\<Phi>'2 + \\<Gamma>' \\<Rightarrow>* ?\\<Psi>'2 + \\<Delta>')\n  \\<in> set Ps' \\<Longrightarrow>\n  ( ?\\<Phi>'2 \\<Rightarrow>* ?\\<Psi>'2 \\<oplus> Modal M Ms) \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps", "by blast"], ["proof (state)\nthis:\n  \\<forall>\\<Phi>' \\<Psi>'.\n     ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n     \\<in> set Ps' \\<longrightarrow>\n     ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<Phi>' \\<Psi>'.\n     ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n     \\<in> set Ps' \\<longrightarrow>\n     ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set Ps. \\<exists>p'. p' \\<in> set Ps'\n  \\<forall>\\<Phi>' \\<Psi>'.\n     ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n     \\<in> set Ps \\<longrightarrow>\n     ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'\n  \\<forall>\\<Phi>' \\<Psi>'.\n     ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n     \\<in> set Ps' \\<longrightarrow>\n     ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps", "have \"\\<forall> \\<Phi>' \\<Psi>'. ((\\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps) = ((\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps')\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps. \\<exists>p'. p' \\<in> set Ps'\n  \\<forall>\\<Phi>' \\<Psi>'.\n     ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n     \\<in> set Ps \\<longrightarrow>\n     ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'\n  \\<forall>\\<Phi>' \\<Psi>'.\n     ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n     \\<in> set Ps' \\<longrightarrow>\n     ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       (( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n        \\<in> set Ps) =\n       (( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n        \\<in> set Ps')", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<Phi>' \\<Psi>'.\n     (( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps) =\n     (( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n      \\<in> set Ps')\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<Phi>' \\<Psi>'.\n     (( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps) =\n     (( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n      \\<in> set Ps')", "have \"\\<forall> p \\<in> set Ps'. \\<exists> \\<Phi>' \\<Psi>' n. n\\<le>n' \\<and> (\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',n) \\<in> derivable (ext R R2 M1 M2)\n                 \\<and> p = (\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\""], ["proof (prove)\nusing this:\n  \\<forall>\\<Phi>' \\<Psi>'.\n     (( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps) =\n     (( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n      \\<in> set Ps')\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps'.\n       \\<exists>\\<Phi>' \\<Psi>' n.\n          n \\<le> n' \\<and>\n          ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', n)\n          \\<in> derivable (ext R R2 M1 M2) \\<and>\n          p = ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "using eq2 and a2"], ["proof (prove)\nusing this:\n  \\<forall>\\<Phi>' \\<Psi>'.\n     (( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms) \\<in> set Ps) =\n     (( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n      \\<in> set Ps')\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>\\<Phi>' \\<Psi>'.\n        p = ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n  \\<forall>p\\<in>set Ps.\n     \\<exists>\\<Phi>' \\<Psi>' m.\n        m \\<le> n' \\<and>\n        ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', m)\n        \\<in> derivable (ext R R2 M1 M2) \\<and>\n        p = ( \\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps'.\n       \\<exists>\\<Phi>' \\<Psi>' n.\n          n \\<le> n' \\<and>\n          ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', n)\n          \\<in> derivable (ext R R2 M1 M2) \\<and>\n          p = ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "apply (simp add:Ball_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<Phi>' \\<Psi>'.\n                (( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>')\n                 \\<in> set Ps) =\n                (( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n                 \\<in> set Ps');\n     \\<forall>x.\n        x \\<in> set Ps' \\<longrightarrow>\n        (\\<exists>\\<Phi>' \\<Psi>'.\n            x = ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>'));\n     \\<forall>x.\n        x \\<in> set Ps \\<longrightarrow>\n        (\\<exists>\\<Phi>' \\<Psi>' m.\n            m \\<le> n' \\<and>\n            ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', m)\n            \\<in> derivable (ext R R2 M1 M2) \\<and>\n            x =\n            ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms)\n\\<Psi>'))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         x \\<in> set Ps' \\<longrightarrow>\n                         (\\<exists>\\<Phi>' \\<Psi>' n.\n                             n \\<le> n' \\<and>\n                             ( \\<Phi>' +\n                               \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                              n)\n                             \\<in> derivable (ext R R2 M1 M2) \\<and>\n                             x =\n                             ( \\<Phi>' +\n                               \\<Gamma>' \\<Rightarrow>* \\<Psi>' +\n                  \\<Delta>'))", "apply (intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<Phi>' \\<Psi>'.\n                   (( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>')\n                    \\<in> set Ps) =\n                   (( \\<Phi>' +\n                      \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n                    \\<in> set Ps');\n        \\<forall>x.\n           x \\<in> set Ps' \\<longrightarrow>\n           (\\<exists>\\<Phi>' \\<Psi>'.\n               x =\n               ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>'));\n        \\<forall>x.\n           x \\<in> set Ps \\<longrightarrow>\n           (\\<exists>\\<Phi>' \\<Psi>' m.\n               m \\<le> n' \\<and>\n               ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', m)\n               \\<in> derivable (ext R R2 M1 M2) \\<and>\n               x = ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>'));\n        x \\<in> set Ps'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>' \\<Psi>' n.\n                            n \\<le> n' \\<and>\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             n)\n                            \\<in> derivable (ext R R2 M1 M2) \\<and>\n                            x =\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "apply (drule_tac x=x in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<Phi>' \\<Psi>'.\n                   (( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>')\n                    \\<in> set Ps) =\n                   (( \\<Phi>' +\n                      \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n                    \\<in> set Ps');\n        \\<forall>x.\n           x \\<in> set Ps \\<longrightarrow>\n           (\\<exists>\\<Phi>' \\<Psi>' m.\n               m \\<le> n' \\<and>\n               ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', m)\n               \\<in> derivable (ext R R2 M1 M2) \\<and>\n               x = ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>'));\n        x \\<in> set Ps';\n        x \\<in> set Ps' \\<longrightarrow>\n        (\\<exists>\\<Phi>' \\<Psi>'.\n            x =\n            ( \\<Phi>' +\n              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>'))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>' \\<Psi>' n.\n                            n \\<le> n' \\<and>\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             n)\n                            \\<in> derivable (ext R R2 M1 M2) \\<and>\n                            x =\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<Phi>' \\<Psi>'.\n                   (( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>')\n                    \\<in> set Ps) =\n                   (( \\<Phi>' +\n                      \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n                    \\<in> set Ps');\n        \\<forall>x.\n           x \\<in> set Ps \\<longrightarrow>\n           (\\<exists>\\<Phi>' \\<Psi>' m.\n               m \\<le> n' \\<and>\n               ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', m)\n               \\<in> derivable (ext R R2 M1 M2) \\<and>\n               x = ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>'));\n        x \\<in> set Ps';\n        \\<exists>\\<Phi>' \\<Psi>'.\n           x =\n           ( \\<Phi>' +\n             \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>' \\<Psi>' n.\n                            n \\<le> n' \\<and>\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             n)\n                            \\<in> derivable (ext R R2 M1 M2) \\<and>\n                            x =\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "apply (elim exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<Phi>' \\<Psi>'.\n       \\<lbrakk>\\<forall>\\<Phi>' \\<Psi>'.\n                   (( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>')\n                    \\<in> set Ps) =\n                   (( \\<Phi>' +\n                      \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n                    \\<in> set Ps');\n        \\<forall>x.\n           x \\<in> set Ps \\<longrightarrow>\n           (\\<exists>\\<Phi>' \\<Psi>' m.\n               m \\<le> n' \\<and>\n               ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', m)\n               \\<in> derivable (ext R R2 M1 M2) \\<and>\n               x = ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>'));\n        x \\<in> set Ps';\n        x =\n        ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>' \\<Psi>' n.\n                            n \\<le> n' \\<and>\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             n)\n                            \\<in> derivable (ext R R2 M1 M2) \\<and>\n                            x =\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "apply (drule_tac x=\\<Phi>' in spec,drule_tac x=\\<Psi>' in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<Phi>' \\<Psi>'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> set Ps \\<longrightarrow>\n                   (\\<exists>\\<Phi>' \\<Psi>' m.\n                       m \\<le> n' \\<and>\n                       ( \\<Phi>' +\n                         \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                        m)\n                       \\<in> derivable (ext R R2 M1 M2) \\<and>\n                       x =\n                       ( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms)\n           \\<Psi>'));\n        x \\<in> set Ps';\n        x = ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>');\n        (( \\<Phi>' \\<Rightarrow>* add_mset (Modal M Ms) \\<Psi>')\n         \\<in> set Ps) =\n        (( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n         \\<in> set Ps')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>' \\<Psi>' n.\n                            n \\<le> n' \\<and>\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             n)\n                            \\<in> derivable (ext R R2 M1 M2) \\<and>\n                            x =\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "by (drule_tac x=\"\\<Phi>' \\<Rightarrow>* \\<Psi>' \\<oplus> Modal M Ms\" in spec) (simp)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>\\<Phi>' \\<Psi>' n.\n        n \\<le> n' \\<and>\n        ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', n)\n        \\<in> derivable (ext R R2 M1 M2) \\<and>\n        p = ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>\\<Phi>' \\<Psi>' n.\n        n \\<le> n' \\<and>\n        ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', n)\n        \\<in> derivable (ext R R2 M1 M2) \\<and>\n        p = ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "have all:\"\\<forall> p \\<in> set Ps'. \\<exists> n\\<le>n'. (p,n) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>\\<Phi>' \\<Psi>' n.\n        n \\<le> n' \\<and>\n        ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', n)\n        \\<in> derivable (ext R R2 M1 M2) \\<and>\n        p = ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps'.\n       \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)", "show \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "using num\n      and \\<open>(Ps',\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') \\<in> (ext R R2 M1 M2)\\<close> and \\<open>Ps' \\<noteq> []\\<close>\n      and derivable.step[where r=\"(Ps',\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>')\" and R=\"ext R R2 M1 M2\"]"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n  n = n' + 1\n  (Ps',  \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>')\n  \\<in> ext R R2 M1 M2\n  Ps' \\<noteq> []\n  \\<lbrakk>(Ps',  \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>')\n           \\<in> ext R R2 M1 M2;\n   fst (Ps',\n         \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') \\<noteq>\n   [];\n   \\<forall>p\\<in>set (fst (Ps',\n                             \\<Gamma> +\n                             \\<Gamma>' \\<Rightarrow>* \\<Delta> +\n                \\<Delta>')).\n      \\<exists>n\\<le>?m. (p, n) \\<in> derivable (ext R R2 M1 M2)\\<rbrakk>\n  \\<Longrightarrow> (snd (Ps',\n                           \\<Gamma> +\n                           \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>'),\n                     ?m + 1)\n                    \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by (auto simp add:Ball_def Bex_def)"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Check this later. *)"], ["", "lemma nonPrincipalInvertLeft:\nassumes \"R1 \\<subseteq> upRules\" and \"R2 \\<subseteq> modRules2\" and \"R3 \\<subseteq> modRules2\"\n    and \"R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3\" and \"r \\<in> R\" and \"r = (ps,c)\" and \"R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\"\n    and IH: \"\\<forall>m<n. \\<forall>\\<Gamma> \\<Delta>. ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, m) \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n              (\\<forall>r' \\<in> R'. leftPrincipal r' (Modal M Ms) R' \\<longrightarrow> ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')) \\<longrightarrow>\n              (\\<exists>m'\\<le>m. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m') \\<in> derivable (ext R R2 M1 M2) )\"\n    and a': \"(\\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>,n) \\<in> derivable (ext R R2 M1 M2)\" \n    and b': \"\\<forall> r' \\<in> R'. leftPrincipal r' (Modal M Ms) R' \\<longrightarrow> (\\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\"\n    and np: \"\\<not> leftPrincipal r (Modal M Ms) R'\"\n    and ext: \"((r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and> extendRule S r = (Ps, \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>))\"\n    and num: \"n = n' + 1\"\n    and all: \"\\<forall> p \\<in> set Ps. \\<exists> n\\<le>n'. (p,n) \\<in> derivable (ext R R2 M1 M2)\"\n    and nonempty: \"Ps \\<noteq> []\"  \nshows \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "from ext nonempty"], ["proof (chain)\npicking this:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  Ps \\<noteq> []", "have \"r \\<in> upRules \\<or> r \\<in> modRules2\""], ["proof (prove)\nusing this:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  Ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. r \\<in> upRules \\<or> r \\<in> modRules2", "apply (auto simp add:extendRule_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>extend S (snd r) =\n             ( add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>);\n     Ps = map (extend S) (fst r); fst r \\<noteq> []; r \\<notin> modRules2;\n     r \\<in> Ax\\<rbrakk>\n    \\<Longrightarrow> r \\<in> upRules", "apply (cases r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>extend S (snd r) =\n                ( add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>);\n        Ps = map (extend S) (fst r); fst r \\<noteq> [];\n        r \\<notin> modRules2; r \\<in> Ax; r = (a, b)\\<rbrakk>\n       \\<Longrightarrow> r \\<in> upRules", "apply (rotate_tac 3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>r \\<notin> modRules2; r \\<in> Ax; r = (a, b);\n        extend S (snd r) =\n        ( add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>);\n        Ps = map (extend S) (fst r); fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> r \\<in> upRules", "by (rule Ax.cases) auto"], ["proof (state)\nthis:\n  r \\<in> upRules \\<or> r \\<in> modRules2\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "obtain \\<Phi> \\<Psi> where \"S = (\\<Phi> \\<Rightarrow>* \\<Psi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Phi> \\<Psi>.\n        S = ( \\<Phi> \\<Rightarrow>* \\<Psi>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases S) (auto)"], ["proof (state)\nthis:\n  S = ( \\<Phi> \\<Rightarrow>* \\<Psi>)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "from \\<open>r = (ps,c)\\<close>"], ["proof (chain)\npicking this:\n  r = (ps, c)", "obtain G H where \"c = (H \\<Rightarrow>* G)\""], ["proof (prove)\nusing this:\n  r = (ps, c)\n\ngoal (1 subgoal):\n 1. (\\<And>H G.\n        c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases c) (auto)"], ["proof (state)\nthis:\n  c = ( H \\<Rightarrow>* G)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  c = ( H \\<Rightarrow>* G)", "have \"\\<LM> Modal M Ms \\<RM> \\<noteq> H\""], ["proof (prove)\nusing this:\n  c = ( H \\<Rightarrow>* G)\n\ngoal (1 subgoal):\n 1. \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "assume \"r \\<in> upRules\""], ["proof (state)\nthis:\n  r \\<in> upRules\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "with \\<open>r = (ps,c)\\<close>"], ["proof (chain)\npicking this:\n  r = (ps, c)\n  r \\<in> upRules", "obtain T Ts where \"c = (\\<Empt> \\<Rightarrow>* \\<LM>Compound T Ts\\<RM>) \\<or> c = (\\<LM>Compound T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  r = (ps, c)\n  r \\<in> upRules\n\ngoal (1 subgoal):\n 1. (\\<And>T Ts.\n        c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n        c =\n        ( \\<LM> Compound T\n                 Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using upRuleCharacterise[where Ps=ps and C=c]"], ["proof (prove)\nusing this:\n  r = (ps, c)\n  r \\<in> upRules\n  (ps, c) \\<in> upRules \\<Longrightarrow>\n  \\<exists>F Fs.\n     c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F Fs  \\<RM>) \\<or>\n     c = ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. (\\<And>T Ts.\n        c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n        c =\n        ( \\<LM> Compound T\n                 Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "moreover"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "{"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "assume \"c = (\\<Empt> \\<Rightarrow>* \\<LM>Compound T Ts\\<RM>)\""], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>)\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "with \\<open>c = (H \\<Rightarrow>* G)\\<close>"], ["proof (chain)\npicking this:\n  c = ( H \\<Rightarrow>* G)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>)", "have \"\\<LM> Modal M Ms \\<RM> \\<noteq> H\""], ["proof (prove)\nusing this:\n  c = ( H \\<Rightarrow>* G)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "by auto"], ["proof (state)\nthis:\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "}"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "moreover"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "{"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "assume \"c = (\\<LM>Compound T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (state)\nthis:\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "then"], ["proof (chain)\npicking this:\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"\\<LM>Modal M Ms \\<RM> \\<noteq> H\""], ["proof (prove)\nusing this:\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "using \\<open>c = (H \\<Rightarrow>* G)\\<close>"], ["proof (prove)\nusing this:\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  c = ( H \\<Rightarrow>* G)\n\ngoal (1 subgoal):\n 1. \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "by auto"], ["proof (state)\nthis:\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "}"], ["proof (state)\nthis:\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "ultimately"], ["proof (chain)\npicking this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "have \"\\<LM> Modal M Ms \\<RM> \\<noteq> H\""], ["proof (prove)\nusing this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "by blast"], ["proof (state)\nthis:\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "}"], ["proof (state)\nthis:\n  r \\<in> upRules \\<Longrightarrow> \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "moreover"], ["proof (state)\nthis:\n  r \\<in> upRules \\<Longrightarrow> \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "{"], ["proof (state)\nthis:\n  r \\<in> upRules \\<Longrightarrow> \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "assume \"r \\<in> modRules2\""], ["proof (state)\nthis:\n  r \\<in> modRules2\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "with \\<open>r = (ps,c)\\<close>"], ["proof (chain)\npicking this:\n  r = (ps, c)\n  r \\<in> modRules2", "obtain T Ts where \"c = (\\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts \\<RM>) \\<or> c = (\\<LM> Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  r = (ps, c)\n  r \\<in> modRules2\n\ngoal (1 subgoal):\n 1. (\\<And>T Ts.\n        c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n        c =\n        ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using modRule2Characterise[where Ps=ps and C=c]"], ["proof (prove)\nusing this:\n  r = (ps, c)\n  r \\<in> modRules2\n  (ps, c) \\<in> modRules2 \\<Longrightarrow>\n  ps \\<noteq> [] \\<and>\n  (\\<exists>F Fs.\n      c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n      c = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))\n\ngoal (1 subgoal):\n 1. (\\<And>T Ts.\n        c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n        c =\n        ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "moreover"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "{"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "assume \"c = (\\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts \\<RM>)\""], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "then"], ["proof (chain)\npicking this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)", "have \"\\<LM>Modal M Ms \\<RM> \\<noteq> H\""], ["proof (prove)\nusing this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "using \\<open>c = (H \\<Rightarrow>* G)\\<close>"], ["proof (prove)\nusing this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  c = ( H \\<Rightarrow>* G)\n\ngoal (1 subgoal):\n 1. \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "by auto"], ["proof (state)\nthis:\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "}"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "moreover"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "{"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "assume \"c = (\\<LM>Modal T Ts \\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (state)\nthis:\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "then"], ["proof (chain)\npicking this:\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"leftPrincipal r (Modal T Ts) R'\""], ["proof (prove)\nusing this:\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. leftPrincipal r (Modal T Ts) R'", "using \\<open>r = (ps,c)\\<close> and \\<open>r \\<in> R\\<close>"], ["proof (prove)\nusing this:\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  r = (ps, c)\n  r \\<in> R\n\ngoal (1 subgoal):\n 1. leftPrincipal r (Modal T Ts) R'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "from \\<open>c = (\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\\<close> and \\<open>r = (ps,c)\\<close> and \\<open>r \\<in> R\\<close> and \\<open>r \\<in> modRules2\\<close>"], ["proof (chain)\npicking this:\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  r = (ps, c)\n  r \\<in> R\n  r \\<in> modRules2", "have \"(ps,\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R\""], ["proof (prove)\nusing this:\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  r = (ps, c)\n  r \\<in> R\n  r \\<in> modRules2\n\ngoal (1 subgoal):\n 1. (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "with \\<open>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3\\<close>"], ["proof (chain)\npicking this:\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R", "have \"(ps,  \\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) \\<in> p_e R2 M1 M2 \\<or>\n                          (ps,  \\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R3\""], ["proof (prove)\nusing this:\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R\n\ngoal (1 subgoal):\n 1. (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n    \\<in> p_e R2 M1 M2 \\<or>\n    (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R3", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<notin> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                      \\<in> p_e R2 M1 M2\n 2. \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<notin> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R1\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                      \\<in> p_e R2 M1 M2", "apply (rule Ax.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<notin> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax\\<rbrakk>\n    \\<Longrightarrow> (?a1.7, ?a2.7) \\<in> Ax\n 2. \\<And>i.\n       \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<notin> R3;\n        (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax;\n        ?a1.7 = [];\n        ?a2.7 =\n        ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\\<rbrakk>\n       \\<Longrightarrow> (ps,\n                           \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                         \\<in> p_e R2 M1 M2\n 3. \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<notin> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax;\n     ?a1.7 = []; ?a2.7 = ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                      \\<in> p_e R2 M1 M2\n 4. \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<notin> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R1\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                      \\<in> p_e R2 M1 M2", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<notin> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R1\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                      \\<in> p_e R2 M1 M2", "apply (subgoal_tac \"(ps,\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) \\<in> upRules\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<notin> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R1;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n     \\<in> upRules\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                      \\<in> p_e R2 M1 M2\n 2. \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<notin> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R1\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                      \\<in> upRules", "apply (insert \\<open>R1 \\<subseteq> upRules\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<notin> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R1;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> upRules;\n     R1 \\<subseteq> upRules\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                      \\<in> p_e R2 M1 M2\n 2. \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<notin> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R1;\n     R1 \\<subseteq> upRules\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                      \\<in> upRules", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<notin> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R1;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> upRules;\n     R1 \\<subseteq> upRules\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                      \\<in> p_e R2 M1 M2", "apply (rule upRules.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<notin> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R1;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> upRules;\n     R1 \\<subseteq> upRules\\<rbrakk>\n    \\<Longrightarrow> (?a1.78, ?a2.78) \\<in> upRules\n 2. \\<And>c Ra Fs psa.\n       \\<lbrakk>R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<notin> R3;\n        (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R1;\n        (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> upRules;\n        R1 \\<subseteq> upRules; ?a1.78 = psa; ?a2.78 = c;\n        ModalSequents.mset c = \\<LM> Compound Ra Fs  \\<RM>;\n        psa \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (ps,\n                           \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                         \\<in> p_e R2 M1 M2", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  \\<in> p_e R2 M1 M2 \\<or>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "moreover"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  \\<in> p_e R2 M1 M2 \\<or>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "{"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  \\<in> p_e R2 M1 M2 \\<or>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "assume \"(ps, \\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R3\""], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R3", "have \"(ps, \\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\""], ["proof (prove)\nusing this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R3\n\ngoal (1 subgoal):\n 1. (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'", "using \\<open>R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\\<close>"], ["proof (prove)\nusing this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R3\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n\ngoal (1 subgoal):\n 1. (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "}"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  \\<in> R3 \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "moreover"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  \\<in> R3 \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "{"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  \\<in> R3 \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "assume \"(ps,\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) \\<in> p_e R2 M1 M2\""], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> p_e R2 M1 M2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> p_e R2 M1 M2", "obtain \\<Gamma>' \\<Delta>' r' where aa: \"(ps, \\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) = extendRule (M1\\<cdot>\\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>') r' \\<and> r' \\<in> R2\""], ["proof (prove)\nusing this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> p_e R2 M1 M2\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' \\<Delta>' r'.\n        (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n        extendRule\n         ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n         r' \\<and>\n        r' \\<in> R2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply (rule p_e.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps c \\<Gamma> \\<Delta>.\n       \\<lbrakk>\\<And>\\<Gamma>' \\<Delta>' r'.\n                   (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n                   extendRule\n                    ( M1 \\<cdot>\n                      \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n                    r' \\<and>\n                   r' \\<in> R2 \\<Longrightarrow>\n                   thesis;\n        (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n        extendRule ( M1 \\<cdot> \\<Gamma> \\<Rightarrow>* M2 \\<cdot> \\<Delta>)\n         (Ps, c);\n        (Ps, c) \\<in> R2; R2 \\<subseteq> modRules2\\<rbrakk>\n       \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2", "have \"r' \\<in> modRules2\""], ["proof (prove)\nusing this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n\ngoal (1 subgoal):\n 1. r' \\<in> modRules2", "using \\<open>R2 \\<subseteq> modRules2\\<close>"], ["proof (prove)\nusing this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n  R2 \\<subseteq> modRules2\n\ngoal (1 subgoal):\n 1. r' \\<in> modRules2", "by auto"], ["proof (state)\nthis:\n  r' \\<in> modRules2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  r' \\<in> modRules2", "obtain F Fs where \n                        \"snd r' = (\\<Empt> \\<Rightarrow>* \\<LM>Modal F Fs\\<RM>) \\<or> snd r' = (\\<LM>Modal F Fs\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  r' \\<in> modRules2\n\ngoal (1 subgoal):\n 1. (\\<And>F Fs.\n        snd r' = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n        snd r' =\n        ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using modRule2Characterise[where Ps=\"fst r'\" and C=\"snd r'\"]"], ["proof (prove)\nusing this:\n  r' \\<in> modRules2\n  (fst r', snd r') \\<in> modRules2 \\<Longrightarrow>\n  fst r' \\<noteq> [] \\<and>\n  (\\<exists>F Fs.\n      snd r' = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n      snd r' = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))\n\ngoal (1 subgoal):\n 1. (\\<And>F Fs.\n        snd r' = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n        snd r' =\n        ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  snd r' = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n  snd r' = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "with aa"], ["proof (chain)\npicking this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n  snd r' = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n  snd r' = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"(\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) = (M1\\<cdot>\\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>' \\<oplus> Modal F Fs) \\<or>\n                                 (\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) = (M1\\<cdot>\\<Gamma>' \\<oplus> Modal F Fs \\<Rightarrow>* M2\\<cdot>\\<Delta>')\""], ["proof (prove)\nusing this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n  snd r' = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n  snd r' = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n    ( M1 \\<cdot>\n      \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus>\n                               Modal F Fs) \\<or>\n    ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n    ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n      Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')", "by (auto simp add:extendRule_def extend_def)"], ["proof (state)\nthis:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs) \\<or>\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "moreover"], ["proof (state)\nthis:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs) \\<or>\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "{"], ["proof (state)\nthis:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs) \\<or>\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "assume \"(\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) = (M1\\<cdot>\\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>' \\<oplus> Modal F Fs)\""], ["proof (state)\nthis:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs)", "have \"\\<Empt> = M2\\<cdot>\\<Delta>' \\<oplus> Modal F Fs\""], ["proof (prove)\nusing this:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs)\n\ngoal (1 subgoal):\n 1. \\<Empt> = M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs", "by auto"], ["proof (state)\nthis:\n  \\<Empt> = M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  \\<Empt> = M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs", "have \"(ps, \\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\""], ["proof (prove)\nusing this:\n  \\<Empt> = M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs\n\ngoal (1 subgoal):\n 1. (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "}"], ["proof (state)\nthis:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus>\n                             Modal F Fs) \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "moreover"], ["proof (state)\nthis:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus>\n                             Modal F Fs) \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "{"], ["proof (state)\nthis:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus>\n                             Modal F Fs) \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "assume \"(\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) = (M1\\<cdot>\\<Gamma>' \\<oplus> Modal F Fs \\<Rightarrow>* M2\\<cdot>\\<Delta>')\""], ["proof (state)\nthis:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')", "have \"M1\\<cdot>\\<Gamma>' \\<oplus> Modal F Fs = \\<LM>Modal T Ts\\<RM>\" and \"\\<Empt> = M2\\<cdot>\\<Delta>'\""], ["proof (prove)\nusing this:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>' \\<oplus> Modal F Fs = \\<LM> Modal T Ts  \\<RM> &&&\n    \\<Empt> = M2 \\<cdot> \\<Delta>'", "by auto"], ["proof (state)\nthis:\n  M1 \\<cdot> \\<Gamma>' \\<oplus> Modal F Fs = \\<LM> Modal T Ts  \\<RM>\n  \\<Empt> = M2 \\<cdot> \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  M1 \\<cdot> \\<Gamma>' \\<oplus> Modal F Fs = \\<LM> Modal T Ts  \\<RM>\n  \\<Empt> = M2 \\<cdot> \\<Delta>'", "have \"M1\\<cdot>\\<Gamma>' = \\<Empt>\" and \"Modal T Ts = Modal F Fs\" and \"M2\\<cdot>\\<Delta>' = \\<Empt>\""], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>' \\<oplus> Modal F Fs = \\<LM> Modal T Ts  \\<RM>\n  \\<Empt> = M2 \\<cdot> \\<Delta>'\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>' = \\<Empt> &&&\n    Modal T Ts = Modal F Fs &&& M2 \\<cdot> \\<Delta>' = \\<Empt>", "using \n                            singleton_add_means_equal[where A=\"Modal T Ts\" and \\<Gamma>=\"M1\\<cdot>\\<Gamma>'\" and B=\"Modal F Fs\"]\n                            and singleton_add_means_empty[where A=\"Modal T Ts\" and \\<Gamma>=\"M1\\<cdot>\\<Gamma>'\" and B=\"Modal F Fs\"]"], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>' \\<oplus> Modal F Fs = \\<LM> Modal T Ts  \\<RM>\n  \\<Empt> = M2 \\<cdot> \\<Delta>'\n  \\<LM> Modal T Ts  \\<RM> =\n  M1 \\<cdot> \\<Gamma>' \\<oplus> Modal F Fs \\<Longrightarrow>\n  Modal T Ts = Modal F Fs\n  \\<LM> Modal T Ts  \\<RM> =\n  M1 \\<cdot> \\<Gamma>' \\<oplus> Modal F Fs \\<Longrightarrow>\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>' = \\<Empt> &&&\n    Modal T Ts = Modal F Fs &&& M2 \\<cdot> \\<Delta>' = \\<Empt>", "by (auto simp add:modaliseMultiset_def)"], ["proof (state)\nthis:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  Modal T Ts = Modal F Fs\n  M2 \\<cdot> \\<Delta>' = \\<Empt>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  Modal T Ts = Modal F Fs\n  M2 \\<cdot> \\<Delta>' = \\<Empt>", "have \"extendRule (M1\\<cdot>\\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>') r' = r'\""], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  Modal T Ts = Modal F Fs\n  M2 \\<cdot> \\<Delta>' = \\<Empt>\n\ngoal (1 subgoal):\n 1. extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n     r' =\n    r'", "using extendRuleEmpty[where r=r']"], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  Modal T Ts = Modal F Fs\n  M2 \\<cdot> \\<Delta>' = \\<Empt>\n  extendRule ( \\<Empt> \\<Rightarrow>* \\<Empt>) r' = r'\n\ngoal (1 subgoal):\n 1. extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n     r' =\n    r'", "by auto"], ["proof (state)\nthis:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' =\n  r'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' =\n  r'", "have \"extendRule (M1\\<cdot>\\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>') r' \\<in> R2\""], ["proof (prove)\nusing this:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' =\n  r'\n\ngoal (1 subgoal):\n 1. extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n     r'\n    \\<in> R2", "using aa"], ["proof (prove)\nusing this:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' =\n  r'\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n\ngoal (1 subgoal):\n 1. extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n     r'\n    \\<in> R2", "by auto"], ["proof (state)\nthis:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>') r'\n  \\<in> R2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>') r'\n  \\<in> R2", "have \"(ps,\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R2\""], ["proof (prove)\nusing this:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>') r'\n  \\<in> R2\n\ngoal (1 subgoal):\n 1. (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R2", "using aa"], ["proof (prove)\nusing this:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>') r'\n  \\<in> R2\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n\ngoal (1 subgoal):\n 1. (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R2", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R2", "have \"(ps,\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\""], ["proof (prove)\nusing this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R2\n\ngoal (1 subgoal):\n 1. (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'", "using \\<open>R' = Ax\\<union>R1 \\<union>R2 \\<union> R3 \\<close>"], ["proof (prove)\nusing this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R2\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n\ngoal (1 subgoal):\n 1. (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'", "by simp"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "}"], ["proof (state)\nthis:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>') \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "ultimately"], ["proof (chain)\npicking this:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs) \\<or>\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus>\n                             Modal F Fs) \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>') \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'", "have \"(ps,\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\""], ["proof (prove)\nusing this:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs) \\<or>\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus>\n                             Modal F Fs) \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>') \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'", "by blast"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "}"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "ultimately"], ["proof (chain)\npicking this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  \\<in> p_e R2 M1 M2 \\<or>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R3\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  \\<in> R3 \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'", "have \"(ps,\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\""], ["proof (prove)\nusing this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  \\<in> p_e R2 M1 M2 \\<or>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R3\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  \\<in> R3 \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'", "show ?thesis"], ["proof (prove)\nusing this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. leftPrincipal r (Modal T Ts) R'", "using \\<open>r = (ps,c)\\<close> and \\<open>c = (\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\\<close>"], ["proof (prove)\nusing this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n  r = (ps, c)\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. leftPrincipal r (Modal T Ts) R'", "by auto"], ["proof (state)\nthis:\n  leftPrincipal r (Modal T Ts) R'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  leftPrincipal r (Modal T Ts) R'\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "then"], ["proof (chain)\npicking this:\n  leftPrincipal r (Modal T Ts) R'", "have \"leftPrincipal r (Modal T Ts) R'\""], ["proof (prove)\nusing this:\n  leftPrincipal r (Modal T Ts) R'\n\ngoal (1 subgoal):\n 1. leftPrincipal r (Modal T Ts) R'", "using \\<open>r = (ps,c)\\<close>"], ["proof (prove)\nusing this:\n  leftPrincipal r (Modal T Ts) R'\n  r = (ps, c)\n\ngoal (1 subgoal):\n 1. leftPrincipal r (Modal T Ts) R'", "by auto"], ["proof (state)\nthis:\n  leftPrincipal r (Modal T Ts) R'\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "with \\<open>\\<not> leftPrincipal r (Modal M Ms) R'\\<close>"], ["proof (chain)\npicking this:\n  \\<not> leftPrincipal r (Modal M Ms) R'\n  leftPrincipal r (Modal T Ts) R'", "have \"Modal T Ts \\<noteq> Modal M Ms\""], ["proof (prove)\nusing this:\n  \\<not> leftPrincipal r (Modal M Ms) R'\n  leftPrincipal r (Modal T Ts) R'\n\ngoal (1 subgoal):\n 1. Modal T Ts \\<noteq> Modal M Ms", "by auto"], ["proof (state)\nthis:\n  Modal T Ts \\<noteq> Modal M Ms\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "with \\<open>c = (H \\<Rightarrow>* G)\\<close>"], ["proof (chain)\npicking this:\n  c = ( H \\<Rightarrow>* G)\n  Modal T Ts \\<noteq> Modal M Ms", "have \"\\<LM> Modal M Ms \\<RM> \\<noteq> H\""], ["proof (prove)\nusing this:\n  c = ( H \\<Rightarrow>* G)\n  Modal T Ts \\<noteq> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "using \\<open>c = (\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\\<close>"], ["proof (prove)\nusing this:\n  c = ( H \\<Rightarrow>* G)\n  Modal T Ts \\<noteq> Modal M Ms\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "by auto"], ["proof (state)\nthis:\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "}"], ["proof (state)\nthis:\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "ultimately"], ["proof (chain)\npicking this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "have \"\\<LM> Modal M Ms \\<RM> \\<noteq> H\""], ["proof (prove)\nusing this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "by blast"], ["proof (state)\nthis:\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "}"], ["proof (state)\nthis:\n  r \\<in> modRules2 \\<Longrightarrow> \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. c = ( H \\<Rightarrow>* G) \\<Longrightarrow>\n    \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "ultimately"], ["proof (chain)\npicking this:\n  r \\<in> upRules \\<Longrightarrow> \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n  r \\<in> modRules2 \\<Longrightarrow> \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "show ?thesis"], ["proof (prove)\nusing this:\n  r \\<in> upRules \\<Longrightarrow> \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n  r \\<in> modRules2 \\<Longrightarrow> \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "using \\<open>r \\<in> upRules \\<or> r \\<in> modRules2\\<close>"], ["proof (prove)\nusing this:\n  r \\<in> upRules \\<Longrightarrow> \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n  r \\<in> modRules2 \\<Longrightarrow> \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n  r \\<in> upRules \\<or> r \\<in> modRules2\n\ngoal (1 subgoal):\n 1. \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "by blast"], ["proof (state)\nthis:\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "have \"antec S + antec (snd r) = (\\<Gamma> \\<oplus> Modal M Ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antec S + antec (snd r) = \\<Gamma> \\<oplus> Modal M Ms", "using ext and extendRule_def[where forms=S and R=r]\n                    and extend_def[where forms=S and seq=\"snd r\"]"], ["proof (prove)\nusing this:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  extendRule S r \\<equiv> (map (extend S) (fst r), extend S (snd r))\n  extend S (snd r) \\<equiv>\n   antec S + antec (snd r) \\<Rightarrow>* succ S + succ (snd r)\n\ngoal (1 subgoal):\n 1. antec S + antec (snd r) = \\<Gamma> \\<oplus> Modal M Ms", "by auto"], ["proof (state)\nthis:\n  antec S + antec (snd r) = \\<Gamma> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  antec S + antec (snd r) = \\<Gamma> \\<oplus> Modal M Ms", "have \"\\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms\""], ["proof (prove)\nusing this:\n  antec S + antec (snd r) = \\<Gamma> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms", "using \\<open>S = (\\<Phi> \\<Rightarrow>* \\<Psi>)\\<close> and \\<open>r = (ps,c)\\<close> and \\<open>c = (H \\<Rightarrow>* G)\\<close>"], ["proof (prove)\nusing this:\n  antec S + antec (snd r) = \\<Gamma> \\<oplus> Modal M Ms\n  S = ( \\<Phi> \\<Rightarrow>* \\<Psi>)\n  r = (ps, c)\n  c = ( H \\<Rightarrow>* G)\n\ngoal (1 subgoal):\n 1. \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms", "by auto"], ["proof (state)\nthis:\n  \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "from \\<open>r = (ps,c)\\<close> and \\<open>r \\<in> upRules \\<or> r \\<in> modRules2\\<close>"], ["proof (chain)\npicking this:\n  r = (ps, c)\n  r \\<in> upRules \\<or> r \\<in> modRules2", "have \"(ps,c) \\<in> upRules \\<or> (ps,c) \\<in> modRules2\""], ["proof (prove)\nusing this:\n  r = (ps, c)\n  r \\<in> upRules \\<or> r \\<in> modRules2\n\ngoal (1 subgoal):\n 1. (ps, c) \\<in> upRules \\<or> (ps, c) \\<in> modRules2", "by auto"], ["proof (state)\nthis:\n  (ps, c) \\<in> upRules \\<or> (ps, c) \\<in> modRules2\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  (ps, c) \\<in> upRules \\<or> (ps, c) \\<in> modRules2", "have \"\\<exists> A. c = (\\<Empt> \\<Rightarrow>* \\<LM>A\\<RM>) \\<or> c = (\\<LM>A\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  (ps, c) \\<in> upRules \\<or> (ps, c) \\<in> modRules2\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       c = ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<or>\n       c = ( \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>)", "using upRuleCharacterise[where Ps=ps and C=c]\n        and modRule2Characterise[where Ps=ps and C=c]"], ["proof (prove)\nusing this:\n  (ps, c) \\<in> upRules \\<or> (ps, c) \\<in> modRules2\n  (ps, c) \\<in> upRules \\<Longrightarrow>\n  \\<exists>F Fs.\n     c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F Fs  \\<RM>) \\<or>\n     c = ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n  (ps, c) \\<in> modRules2 \\<Longrightarrow>\n  ps \\<noteq> [] \\<and>\n  (\\<exists>F Fs.\n      c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n      c = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       c = ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<or>\n       c = ( \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>A.\n     c = ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<or>\n     c = ( \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<exists>A.\n     c = ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<or>\n     c = ( \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"H = \\<Empt> \\<or> (\\<exists> A. H = \\<LM>A\\<RM>)\""], ["proof (prove)\nusing this:\n  \\<exists>A.\n     c = ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<or>\n     c = ( \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)", "using \\<open>c = (H \\<Rightarrow>* G)\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>A.\n     c = ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<or>\n     c = ( \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>)\n  c = ( H \\<Rightarrow>* G)\n\ngoal (1 subgoal):\n 1. H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)", "by auto"], ["proof (state)\nthis:\n  H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n  \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms\n  H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)", "have \"Modal M Ms \\<in># \\<Phi>\""], ["proof (prove)\nusing this:\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n  \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms\n  H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\n\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># \\<Phi>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>", "have \"H = \\<Empt> \\<or> (\\<exists> A. H = \\<LM>A\\<RM>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)", "by fact"], ["proof (state)\nthis:\n  H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>", "moreover"], ["proof (state)\nthis:\n  H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>", "{"], ["proof (state)\nthis:\n  H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>", "assume \"H = \\<Empt>\""], ["proof (state)\nthis:\n  H = \\<Empt>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>", "then"], ["proof (chain)\npicking this:\n  H = \\<Empt>", "have \"\\<Phi> = \\<Gamma> \\<oplus> Modal M Ms\""], ["proof (prove)\nusing this:\n  H = \\<Empt>\n\ngoal (1 subgoal):\n 1. \\<Phi> = \\<Gamma> \\<oplus> Modal M Ms", "using \\<open>\\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms\\<close>"], ["proof (prove)\nusing this:\n  H = \\<Empt>\n  \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<Phi> = \\<Gamma> \\<oplus> Modal M Ms", "by auto"], ["proof (state)\nthis:\n  \\<Phi> = \\<Gamma> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>", "then"], ["proof (chain)\npicking this:\n  \\<Phi> = \\<Gamma> \\<oplus> Modal M Ms", "have \"Modal M Ms \\<in># \\<Phi>\""], ["proof (prove)\nusing this:\n  \\<Phi> = \\<Gamma> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># \\<Phi>", "by auto"], ["proof (state)\nthis:\n  Modal M Ms \\<in># \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>", "}"], ["proof (state)\nthis:\n  H = \\<Empt> \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>", "moreover"], ["proof (state)\nthis:\n  H = \\<Empt> \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>", "{"], ["proof (state)\nthis:\n  H = \\<Empt> \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>", "assume \"\\<exists> A. H = \\<LM>A\\<RM>\""], ["proof (state)\nthis:\n  \\<exists>A. H = \\<LM> A  \\<RM>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>", "then"], ["proof (chain)\npicking this:\n  \\<exists>A. H = \\<LM> A  \\<RM>", "obtain T where \"H = \\<LM>T\\<RM>\""], ["proof (prove)\nusing this:\n  \\<exists>A. H = \\<LM> A  \\<RM>\n\ngoal (1 subgoal):\n 1. (\\<And>T. H = \\<LM> T  \\<RM> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  H = \\<LM> T  \\<RM>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>", "then"], ["proof (chain)\npicking this:\n  H = \\<LM> T  \\<RM>", "have \"\\<Phi> \\<oplus> T = \\<Gamma> \\<oplus> Modal M Ms\""], ["proof (prove)\nusing this:\n  H = \\<LM> T  \\<RM>\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<oplus> T = \\<Gamma> \\<oplus> Modal M Ms", "using \\<open>\\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms\\<close>"], ["proof (prove)\nusing this:\n  H = \\<LM> T  \\<RM>\n  \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<Phi> \\<oplus> T = \\<Gamma> \\<oplus> Modal M Ms", "by auto"], ["proof (state)\nthis:\n  \\<Phi> \\<oplus> T = \\<Gamma> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>", "then"], ["proof (chain)\npicking this:\n  \\<Phi> \\<oplus> T = \\<Gamma> \\<oplus> Modal M Ms", "have \"set_mset (\\<Phi> \\<oplus> T) = set_mset (\\<Gamma> \\<oplus> Modal M Ms)\""], ["proof (prove)\nusing this:\n  \\<Phi> \\<oplus> T = \\<Gamma> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. set_mset (\\<Phi> \\<oplus> T) = set_mset (\\<Gamma> \\<oplus> Modal M Ms)", "by auto"], ["proof (state)\nthis:\n  set_mset (\\<Phi> \\<oplus> T) = set_mset (\\<Gamma> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>", "then"], ["proof (chain)\npicking this:\n  set_mset (\\<Phi> \\<oplus> T) = set_mset (\\<Gamma> \\<oplus> Modal M Ms)", "have \"set_mset \\<Phi> \\<union> {T} = set_mset \\<Gamma> \\<union> {Modal M Ms}\""], ["proof (prove)\nusing this:\n  set_mset (\\<Phi> \\<oplus> T) = set_mset (\\<Gamma> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. set_mset \\<Phi> \\<union> {T} = set_mset \\<Gamma> \\<union> {Modal M Ms}", "by auto"], ["proof (state)\nthis:\n  set_mset \\<Phi> \\<union> {T} = set_mset \\<Gamma> \\<union> {Modal M Ms}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>", "moreover"], ["proof (state)\nthis:\n  set_mset \\<Phi> \\<union> {T} = set_mset \\<Gamma> \\<union> {Modal M Ms}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>", "from \\<open>H = \\<LM>T\\<RM>\\<close> and \\<open>\\<LM>Modal M Ms\\<RM> \\<noteq> H\\<close>"], ["proof (chain)\npicking this:\n  H = \\<LM> T  \\<RM>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H", "have \"Modal M Ms \\<noteq> T\""], ["proof (prove)\nusing this:\n  H = \\<LM> T  \\<RM>\n  \\<LM> Modal M Ms  \\<RM> \\<noteq> H\n\ngoal (1 subgoal):\n 1. Modal M Ms \\<noteq> T", "by auto"], ["proof (state)\nthis:\n  Modal M Ms \\<noteq> T\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>", "ultimately"], ["proof (chain)\npicking this:\n  set_mset \\<Phi> \\<union> {T} = set_mset \\<Gamma> \\<union> {Modal M Ms}\n  Modal M Ms \\<noteq> T", "have \"Modal M Ms \\<in> set_mset \\<Phi>\""], ["proof (prove)\nusing this:\n  set_mset \\<Phi> \\<union> {T} = set_mset \\<Gamma> \\<union> {Modal M Ms}\n  Modal M Ms \\<noteq> T\n\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># \\<Phi>", "by auto"], ["proof (state)\nthis:\n  Modal M Ms \\<in># \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>", "then"], ["proof (chain)\npicking this:\n  Modal M Ms \\<in># \\<Phi>", "have \"Modal M Ms \\<in># \\<Phi>\""], ["proof (prove)\nusing this:\n  Modal M Ms \\<in># \\<Phi>\n\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># \\<Phi>", "by auto"], ["proof (state)\nthis:\n  Modal M Ms \\<in># \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>", "}"], ["proof (state)\nthis:\n  \\<exists>A. H = \\<LM> A  \\<RM> \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<LM> Modal M Ms  \\<RM> \\<noteq> H;\n     \\<Phi> + H = \\<Gamma> \\<oplus> Modal M Ms;\n     H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>", "ultimately"], ["proof (chain)\npicking this:\n  H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\n  H = \\<Empt> \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>\n  \\<exists>A. H = \\<LM> A  \\<RM> \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>", "show \"Modal M Ms \\<in># \\<Phi>\""], ["proof (prove)\nusing this:\n  H = \\<Empt> \\<or> (\\<exists>A. H = \\<LM> A  \\<RM>)\n  H = \\<Empt> \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>\n  \\<exists>A. H = \\<LM> A  \\<RM> \\<Longrightarrow> Modal M Ms \\<in># \\<Phi>\n\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># \\<Phi>", "by blast"], ["proof (state)\nthis:\n  Modal M Ms \\<in># \\<Phi>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Modal M Ms \\<in># \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  Modal M Ms \\<in># \\<Phi>", "have \"\\<exists> \\<Phi>1. \\<Phi> = \\<Phi>1 \\<oplus> Modal M Ms\""], ["proof (prove)\nusing this:\n  Modal M Ms \\<in># \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>1. \\<Phi> = \\<Phi>1 \\<oplus> Modal M Ms", "by (rule_tac x=\"\\<Phi> \\<ominus> Modal M Ms\" in exI) (auto simp add:multiset_eq_iff)"], ["proof (state)\nthis:\n  \\<exists>\\<Phi>1. \\<Phi> = \\<Phi>1 \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<Phi>1. \\<Phi> = \\<Phi>1 \\<oplus> Modal M Ms", "obtain \\<Phi>1 where \"S = (\\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\""], ["proof (prove)\nusing this:\n  \\<exists>\\<Phi>1. \\<Phi> = \\<Phi>1 \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Phi>1.\n        S =\n        ( \\<Phi>1 \\<oplus>\n          Modal M Ms \\<Rightarrow>* \\<Psi>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>S = (\\<Phi> \\<Rightarrow>* \\<Psi>)\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>\\<Phi>1. \\<Phi> = \\<Phi>1 \\<oplus> Modal M Ms\n  S = ( \\<Phi> \\<Rightarrow>* \\<Psi>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Phi>1.\n        S =\n        ( \\<Phi>1 \\<oplus>\n          Modal M Ms \\<Rightarrow>* \\<Psi>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  S = ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "have \"Ps = map (extend S) ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ps = map (extend S) ps", "using ext and extendRule_def[where forms=S and R=r] and \\<open>r = (ps,c)\\<close>"], ["proof (prove)\nusing this:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  extendRule S r \\<equiv> (map (extend S) (fst r), extend S (snd r))\n  r = (ps, c)\n\ngoal (1 subgoal):\n 1. Ps = map (extend S) ps", "by auto"], ["proof (state)\nthis:\n  Ps = map (extend S) ps\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  Ps = map (extend S) ps", "have \"\\<forall> p \\<in> set Ps. (\\<exists> p'. p = extend S p')\""], ["proof (prove)\nusing this:\n  Ps = map (extend S) ps\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps. \\<exists>p'. p = extend S p'", "using ex_map_conv[where ys=Ps and f=\"extend S\"]"], ["proof (prove)\nusing this:\n  Ps = map (extend S) ps\n  (\\<exists>xs. Ps = map (extend S) xs) =\n  (\\<forall>y\\<in>set Ps. \\<exists>x. y = extend S x)\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps. \\<exists>p'. p = extend S p'", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set Ps. \\<exists>p'. p = extend S p'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set Ps. \\<exists>p'. p = extend S p'", "have \"\\<forall> p \\<in> set Ps. (Modal M Ms \\<in># antec p)\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps. \\<exists>p'. p = extend S p'\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps. Modal M Ms \\<in># antec p", "using \\<open>Modal M Ms \\<in># \\<Phi>\\<close> and \\<open>S = (\\<Phi> \\<Rightarrow>* \\<Psi>)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps. \\<exists>p'. p = extend S p'\n  Modal M Ms \\<in># \\<Phi>\n  S = ( \\<Phi> \\<Rightarrow>* \\<Psi>)\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps. Modal M Ms \\<in># antec p", "apply (auto simp add:Ball_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> set Ps \\<longrightarrow>\n                   (\\<exists>p'.\n                       x = extend ( \\<Phi> \\<Rightarrow>* \\<Psi>) p');\n        Modal M Ms \\<in># \\<Phi>; S = ( \\<Phi> \\<Rightarrow>* \\<Psi>);\n        x \\<in> set Ps\\<rbrakk>\n       \\<Longrightarrow> Modal M Ms \\<in># antec x", "by (drule_tac x=x in spec) (auto simp add:extend_def)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set Ps. Modal M Ms \\<in># antec p\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set Ps. Modal M Ms \\<in># antec p", "have a1:\"\\<forall> p \\<in> set Ps. \\<exists> \\<Phi>' \\<Psi>'. p = (\\<Phi>'\\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps. Modal M Ms \\<in># antec p\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps.\n       \\<exists>\\<Phi>' \\<Psi>'.\n          p = ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')", "using characteriseSeq"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps. Modal M Ms \\<in># antec p\n  \\<exists>A B. ?C = ( A \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps.\n       \\<exists>\\<Phi>' \\<Psi>'.\n          p = ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')", "apply (auto simp add:Ball_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> set Ps \\<longrightarrow>\n                   Modal M Ms \\<in># antec x;\n        \\<And>C. \\<exists>A B. C = ( A \\<Rightarrow>* B);\n        x \\<in> set Ps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>' \\<Psi>'.\n                            x =\n                            ( add_mset (Modal M Ms)\n                               \\<Phi>' \\<Rightarrow>* \\<Psi>')", "apply (drule_tac x=x in spec,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>C. \\<exists>A B. C = ( A \\<Rightarrow>* B);\n        x \\<in> set Ps; Modal M Ms \\<in># antec x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>' \\<Psi>'.\n                            x =\n                            ( add_mset (Modal M Ms)\n                               \\<Phi>' \\<Rightarrow>* \\<Psi>')", "apply (rule_tac x=\"antec x \\<ominus> Modal M Ms\" in exI,rule_tac x=\"succ x\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>C. \\<exists>A B. C = ( A \\<Rightarrow>* B);\n        x \\<in> set Ps; Modal M Ms \\<in># antec x\\<rbrakk>\n       \\<Longrightarrow> x =\n                         ( add_mset (Modal M Ms)\n                            (antec x \\<ominus>\n                             Modal M Ms) \\<Rightarrow>* succ x)", "by (drule_tac x=x in meta_spec) (auto simp add:multiset_eq_iff)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set Ps.\n     \\<exists>\\<Phi>' \\<Psi>'.\n        p = ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "with all"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set Ps.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n  \\<forall>p\\<in>set Ps.\n     \\<exists>\\<Phi>' \\<Psi>'.\n        p = ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')", "have \"\\<forall> p \\<in> set Ps. \\<exists> \\<Phi>' \\<Psi>' n. n\\<le>n' \\<and> (\\<Phi>'\\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>',n) \\<in> derivable (ext R R2 M1 M2) \\<and> \n                              p = (\\<Phi>'\\<oplus>Modal M Ms \\<Rightarrow>* \\<Psi>')\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n  \\<forall>p\\<in>set Ps.\n     \\<exists>\\<Phi>' \\<Psi>'.\n        p = ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps.\n       \\<exists>\\<Phi>' \\<Psi>' n.\n          n \\<le> n' \\<and>\n          ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>', n)\n          \\<in> derivable (ext R R2 M1 M2) \\<and>\n          p = ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')", "by (auto simp add:Ball_def)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set Ps.\n     \\<exists>\\<Phi>' \\<Psi>' n.\n        n \\<le> n' \\<and>\n        ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>', n)\n        \\<in> derivable (ext R R2 M1 M2) \\<and>\n        p = ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set Ps.\n     \\<exists>\\<Phi>' \\<Psi>' n.\n        n \\<le> n' \\<and>\n        ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>', n)\n        \\<in> derivable (ext R R2 M1 M2) \\<and>\n        p = ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')", "have a2: \"\\<forall> p \\<in> set Ps. \\<exists> \\<Phi>' \\<Psi>' m. m\\<le>n' \\<and> (\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2) \\<and> \n                  p = (\\<Phi>'\\<oplus>Modal M Ms \\<Rightarrow>* \\<Psi>')\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps.\n     \\<exists>\\<Phi>' \\<Psi>' n.\n        n \\<le> n' \\<and>\n        ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>', n)\n        \\<in> derivable (ext R R2 M1 M2) \\<and>\n        p = ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps.\n       \\<exists>\\<Phi>' \\<Psi>' m.\n          m \\<le> n' \\<and>\n          ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2) \\<and>\n          p = ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')", "using num and b' and IH"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps.\n     \\<exists>\\<Phi>' \\<Psi>' n.\n        n \\<le> n' \\<and>\n        ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>', n)\n        \\<in> derivable (ext R R2 M1 M2) \\<and>\n        p = ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n  n = n' + 1\n  \\<forall>r'\\<in>R'.\n     leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\n  \\<forall>m<n.\n     \\<forall>\\<Gamma> \\<Delta>.\n        ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, m)\n        \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n        (\\<forall>r'\\<in>R'.\n            leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n            ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n            \\<in> set (fst r')) \\<longrightarrow>\n        (\\<exists>m'\\<le>m.\n            ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m')\n            \\<in> derivable (ext R R2 M1 M2))\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps.\n       \\<exists>\\<Phi>' \\<Psi>' m.\n          m \\<le> n' \\<and>\n          ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2) \\<and>\n          p = ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')", "apply (auto simp add:Ball_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> set Ps \\<longrightarrow>\n                   (\\<exists>\\<Phi>' \\<Psi>' n.\n                       n \\<le> n' \\<and>\n                       ( add_mset (Modal M Ms)\n                          \\<Phi>' \\<Rightarrow>* \\<Psi>',\n                        n)\n                       \\<in> derivable (ext R R2 M1 M2) \\<and>\n                       x =\n                       ( add_mset (Modal M Ms)\n                          \\<Phi>' \\<Rightarrow>* \\<Psi>'));\n        n = Suc n';\n        \\<forall>a b.\n           (a, b) \\<in> R' \\<longrightarrow>\n           leftPrincipal (a, b) (Modal M Ms) R' \\<longrightarrow>\n           ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set a;\n        \\<forall>m<Suc n'.\n           \\<forall>\\<Gamma> \\<Delta>.\n              ( add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>, m)\n              \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n              (\\<exists>m'\\<le>m.\n                  ( \\<Gamma> +\n                    \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                   m')\n                  \\<in> derivable (ext R R2 M1 M2));\n        x \\<in> set Ps\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>' \\<Psi>' m.\n                            m \\<le> n' \\<and>\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2) \\<and>\n                            x =\n                            ( add_mset (Modal M Ms)\n                               \\<Phi>' \\<Rightarrow>* \\<Psi>')", "apply (drule_tac x=x in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>n = Suc n';\n        \\<forall>a b.\n           (a, b) \\<in> R' \\<longrightarrow>\n           leftPrincipal (a, b) (Modal M Ms) R' \\<longrightarrow>\n           ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set a;\n        \\<forall>m<Suc n'.\n           \\<forall>\\<Gamma> \\<Delta>.\n              ( add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>, m)\n              \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n              (\\<exists>m'\\<le>m.\n                  ( \\<Gamma> +\n                    \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                   m')\n                  \\<in> derivable (ext R R2 M1 M2));\n        x \\<in> set Ps;\n        x \\<in> set Ps \\<longrightarrow>\n        (\\<exists>\\<Phi>' \\<Psi>' n.\n            n \\<le> n' \\<and>\n            ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>', n)\n            \\<in> derivable (ext R R2 M1 M2) \\<and>\n            x =\n            ( add_mset (Modal M Ms)\n               \\<Phi>' \\<Rightarrow>* \\<Psi>'))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>' \\<Psi>' m.\n                            m \\<le> n' \\<and>\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2) \\<and>\n                            x =\n                            ( add_mset (Modal M Ms)\n                               \\<Phi>' \\<Rightarrow>* \\<Psi>')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>n = Suc n';\n        \\<forall>a b.\n           (a, b) \\<in> R' \\<longrightarrow>\n           leftPrincipal (a, b) (Modal M Ms) R' \\<longrightarrow>\n           ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set a;\n        \\<forall>m<Suc n'.\n           \\<forall>\\<Gamma> \\<Delta>.\n              ( add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>, m)\n              \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n              (\\<exists>m'\\<le>m.\n                  ( \\<Gamma> +\n                    \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                   m')\n                  \\<in> derivable (ext R R2 M1 M2));\n        x \\<in> set Ps;\n        \\<exists>\\<Phi>' \\<Psi>' n.\n           n \\<le> n' \\<and>\n           ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>', n)\n           \\<in> derivable (ext R R2 M1 M2) \\<and>\n           x =\n           ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>' \\<Psi>' m.\n                            m \\<le> n' \\<and>\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2) \\<and>\n                            x =\n                            ( add_mset (Modal M Ms)\n                               \\<Phi>' \\<Rightarrow>* \\<Psi>')", "apply hypsubst_thin"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>a b.\n                   (a, b) \\<in> R' \\<longrightarrow>\n                   leftPrincipal (a, b) (Modal M Ms) R' \\<longrightarrow>\n                   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set a;\n        \\<forall>m<Suc n'.\n           \\<forall>\\<Gamma> \\<Delta>.\n              ( add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>, m)\n              \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n              (\\<exists>m'\\<le>m.\n                  ( \\<Gamma> +\n                    \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                   m')\n                  \\<in> derivable (ext R R2 M1 M2));\n        x \\<in> set Ps;\n        \\<exists>\\<Phi>' \\<Psi>' n.\n           n \\<le> n' \\<and>\n           ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>', n)\n           \\<in> derivable (ext R R2 M1 M2) \\<and>\n           x =\n           ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>' \\<Psi>' m.\n                            m \\<le> n' \\<and>\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2) \\<and>\n                            x =\n                            ( add_mset (Modal M Ms)\n                               \\<Phi>' \\<Rightarrow>* \\<Psi>')", "apply (elim exE conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<Phi>' \\<Psi>' n.\n       \\<lbrakk>\\<forall>a b.\n                   (a, b) \\<in> R' \\<longrightarrow>\n                   leftPrincipal (a, b) (Modal M Ms) R' \\<longrightarrow>\n                   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set a;\n        \\<forall>m<Suc n'.\n           \\<forall>\\<Gamma> \\<Delta>.\n              ( add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>, m)\n              \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n              (\\<exists>m'\\<le>m.\n                  ( \\<Gamma> +\n                    \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                   m')\n                  \\<in> derivable (ext R R2 M1 M2));\n        x \\<in> set Ps; n \\<le> n';\n        ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>', n)\n        \\<in> derivable (ext R R2 M1 M2);\n        x = ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>' \\<Psi>' m.\n                            m \\<le> n' \\<and>\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2) \\<and>\n                            x =\n                            ( add_mset (Modal M Ms)\n                               \\<Phi>' \\<Rightarrow>* \\<Psi>')", "apply (drule_tac x=n in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<Phi>' \\<Psi>' n.\n       \\<lbrakk>\\<forall>a b.\n                   (a, b) \\<in> R' \\<longrightarrow>\n                   leftPrincipal (a, b) (Modal M Ms) R' \\<longrightarrow>\n                   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set a;\n        x \\<in> set Ps; n \\<le> n';\n        ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>', n)\n        \\<in> derivable (ext R R2 M1 M2);\n        x = ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>');\n        n < Suc n' \\<longrightarrow>\n        (\\<forall>\\<Gamma> \\<Delta>.\n            ( add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>, n)\n            \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n            (\\<exists>m'\\<le>n.\n                ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                 m')\n                \\<in> derivable (ext R R2 M1 M2)))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>' \\<Psi>' m.\n                            m \\<le> n' \\<and>\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2) \\<and>\n                            x =\n                            ( add_mset (Modal M Ms)\n                               \\<Phi>' \\<Rightarrow>* \\<Psi>')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<Phi>' \\<Psi>' n.\n       \\<lbrakk>\\<forall>a b.\n                   (a, b) \\<in> R' \\<longrightarrow>\n                   leftPrincipal (a, b) (Modal M Ms) R' \\<longrightarrow>\n                   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set a;\n        ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>')\n        \\<in> set Ps;\n        n \\<le> n';\n        ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>', n)\n        \\<in> derivable (ext R R2 M1 M2);\n        x = ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>');\n        \\<forall>\\<Gamma> \\<Delta>.\n           ( add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>, n)\n           \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n           (\\<exists>m'\\<le>n.\n               ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                m')\n               \\<in> derivable (ext R R2 M1 M2))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<le>n'.\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2)", "apply (drule_tac x=\\<Phi>' in spec,drule_tac x=\\<Psi>' in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<Phi>' \\<Psi>' n.\n       \\<lbrakk>\\<forall>a b.\n                   (a, b) \\<in> R' \\<longrightarrow>\n                   leftPrincipal (a, b) (Modal M Ms) R' \\<longrightarrow>\n                   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set a;\n        ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>')\n        \\<in> set Ps;\n        n \\<le> n';\n        ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>', n)\n        \\<in> derivable (ext R R2 M1 M2);\n        x = ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>');\n        ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>', n)\n        \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n        (\\<exists>m'\\<le>n.\n            ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', m')\n            \\<in> derivable (ext R R2 M1 M2))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<le>n'.\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2)", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<Phi>' \\<Psi>' n.\n       \\<lbrakk>\\<forall>a b.\n                   (a, b) \\<in> R' \\<longrightarrow>\n                   leftPrincipal (a, b) (Modal M Ms) R' \\<longrightarrow>\n                   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set a;\n        ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>')\n        \\<in> set Ps;\n        n \\<le> n';\n        ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>', n)\n        \\<in> derivable (ext R R2 M1 M2);\n        x = ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>');\n        \\<exists>m'\\<le>n.\n           ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', m')\n           \\<in> derivable (ext R R2 M1 M2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<le>n'.\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2)", "apply (elim exE conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<Phi>' \\<Psi>' n m'.\n       \\<lbrakk>\\<forall>a b.\n                   (a, b) \\<in> R' \\<longrightarrow>\n                   leftPrincipal (a, b) (Modal M Ms) R' \\<longrightarrow>\n                   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set a;\n        ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>')\n        \\<in> set Ps;\n        n \\<le> n';\n        ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>', n)\n        \\<in> derivable (ext R R2 M1 M2);\n        x = ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>');\n        m' \\<le> n;\n        ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', m')\n        \\<in> derivable (ext R R2 M1 M2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<le>n'.\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2)", "by (rule_tac x=m' in exI) (arith)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set Ps.\n     \\<exists>\\<Phi>' \\<Psi>' m.\n        m \\<le> n' \\<and>\n        ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', m)\n        \\<in> derivable (ext R R2 M1 M2) \\<and>\n        p = ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "obtain Ps' where eq: \"Ps' = map (extend (\\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')) ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Ps'.\n        Ps' =\n        map (extend\n              ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>'))\n         ps \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Ps' =\n  map (extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')) ps\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "have \"length Ps = length Ps'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length Ps = length Ps'", "using \\<open>Ps' = map (extend (\\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')) ps\\<close>\n                               and \\<open>Ps = map (extend S) ps\\<close>"], ["proof (prove)\nusing this:\n  Ps' =\n  map (extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')) ps\n  Ps = map (extend S) ps\n\ngoal (1 subgoal):\n 1. length Ps = length Ps'", "by auto"], ["proof (state)\nthis:\n  length Ps = length Ps'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  length Ps = length Ps'", "have \"Ps' \\<noteq> []\""], ["proof (prove)\nusing this:\n  length Ps = length Ps'\n\ngoal (1 subgoal):\n 1. Ps' \\<noteq> []", "using nonempty"], ["proof (prove)\nusing this:\n  length Ps = length Ps'\n  Ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. Ps' \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  Ps' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "from \\<open>r \\<in> upRules \\<or> r \\<in> modRules2\\<close> and \\<open>r \\<in> R\\<close>"], ["proof (chain)\npicking this:\n  r \\<in> upRules \\<or> r \\<in> modRules2\n  r \\<in> R", "have \"extendRule (\\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') r \\<in> (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  r \\<in> upRules \\<or> r \\<in> modRules2\n  r \\<in> R\n\ngoal (1 subgoal):\n 1. extendRule ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') r\n    \\<in> ext R R2 M1 M2", "by auto"], ["proof (state)\nthis:\n  extendRule ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  extendRule ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "have \"extendRule (\\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') r = (Ps',\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extendRule ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') r =\n    (Ps',  \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>')", "using \\<open>S = (\\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\\<close> and ext and \\<open>r = (ps,c)\\<close> and eq"], ["proof (prove)\nusing this:\n  S = ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r = (ps, c)\n  Ps' =\n  map (extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')) ps\n\ngoal (1 subgoal):\n 1. extendRule ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') r =\n    (Ps',  \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>')", "by (auto simp add:extendRule_def extend_def)"], ["proof (state)\nthis:\n  extendRule ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') r =\n  (Ps',  \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  extendRule ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n  extendRule ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') r =\n  (Ps',  \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>')", "have \"(Ps',\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') \\<in> (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  extendRule ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n  extendRule ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') r =\n  (Ps',  \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>')\n\ngoal (1 subgoal):\n 1. (Ps',  \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>')\n    \\<in> ext R R2 M1 M2", "by simp"], ["proof (state)\nthis:\n  (Ps',  \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>')\n  \\<in> ext R R2 M1 M2\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "have c1:\"\\<forall> p \\<in> set ps. extend S p \\<in> set Ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set ps. extend S p \\<in> set Ps", "using \\<open>Ps = map (extend S) ps\\<close>"], ["proof (prove)\nusing this:\n  Ps = map (extend S) ps\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set ps. extend S p \\<in> set Ps", "by (simp add:Ball_def)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set ps. extend S p \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "have c2:\"\\<forall> p \\<in> set ps. extend (\\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p \\<in> set Ps'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set ps.\n       extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p\n       \\<in> set Ps'", "using eq"], ["proof (prove)\nusing this:\n  Ps' =\n  map (extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')) ps\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set ps.\n       extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p\n       \\<in> set Ps'", "by (simp add:Ball_def)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set ps.\n     extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p\n     \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set ps.\n     extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p\n     \\<in> set Ps'", "have eq2:\"\\<forall> p \\<in> set Ps'. \\<exists> \\<Phi>' \\<Psi>'. p = (\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set ps.\n     extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p\n     \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps'.\n       \\<exists>\\<Phi>' \\<Psi>'.\n          p = ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "using eq"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set ps.\n     extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p\n     \\<in> set Ps'\n  Ps' =\n  map (extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')) ps\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps'.\n       \\<exists>\\<Phi>' \\<Psi>'.\n          p = ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "by (auto simp add: extend_def)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>\\<Phi>' \\<Psi>'.\n        p = ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "have d1:\"\\<forall> p \\<in> set Ps. \\<exists> p' \\<in> set ps. p = extend S p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps. \\<exists>p'\\<in>set ps. p = extend S p'", "using \\<open>Ps = map (extend S) ps\\<close>"], ["proof (prove)\nusing this:\n  Ps = map (extend S) ps\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps. \\<exists>p'\\<in>set ps. p = extend S p'", "by (auto simp add:Ball_def Bex_def)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set Ps. \\<exists>p'\\<in>set ps. p = extend S p'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set Ps. \\<exists>p'\\<in>set ps. p = extend S p'", "have \"\\<forall> p \\<in> set Ps. \\<exists> p'. p' \\<in> set Ps'\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps. \\<exists>p'\\<in>set ps. p = extend S p'\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps. \\<exists>p'. p' \\<in> set Ps'", "using c2"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps. \\<exists>p'\\<in>set ps. p = extend S p'\n  \\<forall>p\\<in>set ps.\n     extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p\n     \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps. \\<exists>p'. p' \\<in> set Ps'", "by (auto simp add:Ball_def Bex_def)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set Ps. \\<exists>p'. p' \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set Ps. \\<exists>p'. p' \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "have d2: \"\\<forall> p \\<in> set Ps'. \\<exists> p' \\<in> set ps. p = extend (\\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps'.\n       \\<exists>p'\\<in>set ps.\n          p =\n          extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p'", "using eq"], ["proof (prove)\nusing this:\n  Ps' =\n  map (extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')) ps\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps'.\n       \\<exists>p'\\<in>set ps.\n          p =\n          extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p'", "by (auto simp add:Ball_def Bex_def)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>p'\\<in>set ps.\n        p =\n        extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>p'\\<in>set ps.\n        p =\n        extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p'", "have \"\\<forall> p \\<in> set Ps'. \\<exists> p'. p' \\<in> set Ps\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>p'\\<in>set ps.\n        p =\n        extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p'\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps'. \\<exists>p'. p' \\<in> set Ps", "using c1"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>p'\\<in>set ps.\n        p =\n        extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p'\n  \\<forall>p\\<in>set ps. extend S p \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps'. \\<exists>p'. p' \\<in> set Ps", "by (auto simp add:Ball_def Bex_def)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set Ps'. \\<exists>p'. p' \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "have \"\\<forall> \\<Phi>' \\<Psi>'. (\\<Phi>'\\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps \\<longrightarrow> (\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "fix \\<Phi>' \\<Psi>'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "assume \"(\\<Phi>' \\<oplus> Modal M Ms\\<Rightarrow>* \\<Psi>') \\<in> set Ps\""], ["proof (state)\nthis:\n  ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "then"], ["proof (chain)\npicking this:\n  ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps", "have \"\\<exists> p \\<in> set ps. extend (\\<Phi>1\\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>) p = (\\<Phi>'\\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\""], ["proof (prove)\nusing this:\n  ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set ps.\n       extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>) p =\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')", "using \\<open>Ps = map (extend S) ps\\<close> and \\<open>S = (\\<Phi>1\\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\\<close> and a1 and d1"], ["proof (prove)\nusing this:\n  ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps\n  Ps = map (extend S) ps\n  S = ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\n  \\<forall>p\\<in>set Ps.\n     \\<exists>\\<Phi>' \\<Psi>'.\n        p = ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n  \\<forall>p\\<in>set Ps. \\<exists>p'\\<in>set ps. p = extend S p'\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set ps.\n       extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>) p =\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')", "apply (simp only:Ball_def Bex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n             \\<in> set (map (extend\n                              ( \\<Phi>1 \\<oplus>\n                                Modal M Ms \\<Rightarrow>* \\<Psi>))\n                         ps);\n     Ps =\n     map (extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)) ps;\n     S = ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>);\n     \\<forall>x.\n        x \\<in> set (map (extend\n                           ( \\<Phi>1 \\<oplus>\n                             Modal M Ms \\<Rightarrow>* \\<Psi>))\n                      ps) \\<longrightarrow>\n        (\\<exists>\\<Phi>' \\<Psi>'.\n            x = ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>'));\n     \\<forall>x.\n        x \\<in> set (map (extend\n                           ( \\<Phi>1 \\<oplus>\n                             Modal M Ms \\<Rightarrow>* \\<Psi>))\n                      ps) \\<longrightarrow>\n        (\\<exists>xa.\n            xa \\<in> set ps \\<and>\n            x =\n            extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\n             xa)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         x \\<in> set ps \\<and>\n                         extend\n                          ( \\<Phi>1 \\<oplus>\n                            Modal M Ms \\<Rightarrow>* \\<Psi>)\n                          x =\n                         ( \\<Phi>' \\<oplus>\n                           Modal M Ms \\<Rightarrow>* \\<Psi>')", "apply (drule_tac x=\" \\<Phi>'\\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>'\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n             \\<in> set (map (extend\n                              ( \\<Phi>1 \\<oplus>\n                                Modal M Ms \\<Rightarrow>* \\<Psi>))\n                         ps);\n     Ps =\n     map (extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)) ps;\n     S = ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>);\n     \\<forall>x.\n        x \\<in> set (map (extend\n                           ( \\<Phi>1 \\<oplus>\n                             Modal M Ms \\<Rightarrow>* \\<Psi>))\n                      ps) \\<longrightarrow>\n        (\\<exists>xa.\n            xa \\<in> set ps \\<and>\n            x =\n            extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>) xa);\n     ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n     \\<in> set (map (extend\n                      ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>))\n                 ps) \\<longrightarrow>\n     (\\<exists>\\<Phi>'' \\<Psi>''.\n         ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') =\n         ( \\<Phi>'' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>''))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         x \\<in> set ps \\<and>\n                         extend\n                          ( \\<Phi>1 \\<oplus>\n                            Modal M Ms \\<Rightarrow>* \\<Psi>)\n                          x =\n                         ( \\<Phi>' \\<oplus>\n                           Modal M Ms \\<Rightarrow>* \\<Psi>')", "by (drule_tac x=\"\\<Phi>'\\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>'\" in spec) (auto)"], ["proof (state)\nthis:\n  \\<exists>p\\<in>set ps.\n     extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>) p =\n     ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "then"], ["proof (chain)\npicking this:\n  \\<exists>p\\<in>set ps.\n     extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>) p =\n     ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')", "obtain p where t:\"p \\<in> set ps \\<and> (\\<Phi>'\\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') = extend (\\<Phi>1\\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>) p\""], ["proof (prove)\nusing this:\n  \\<exists>p\\<in>set ps.\n     extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>) p =\n     ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        p \\<in> set ps \\<and>\n        ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') =\n        extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\n         p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>p.\n                   p \\<in> set ps \\<and>\n                   ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>') =\n                   extend\n                    ( add_mset (Modal M Ms) \\<Phi>1 \\<Rightarrow>* \\<Psi>)\n                    p \\<Longrightarrow>\n                   thesis;\n        p \\<in> set ps;\n        extend ( add_mset (Modal M Ms) \\<Phi>1 \\<Rightarrow>* \\<Psi>) p =\n        ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>')\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (drule_tac x=p in meta_spec) (simp)"], ["proof (state)\nthis:\n  p \\<in> set ps \\<and>\n  ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') =\n  extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>) p\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "then"], ["proof (chain)\npicking this:\n  p \\<in> set ps \\<and>\n  ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') =\n  extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>) p", "obtain D B where \"p = (D \\<Rightarrow>* B)\""], ["proof (prove)\nusing this:\n  p \\<in> set ps \\<and>\n  ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') =\n  extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>) p\n\ngoal (1 subgoal):\n 1. (\\<And>D B.\n        p = ( D \\<Rightarrow>* B) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases p)"], ["proof (state)\nthis:\n  p = ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "then"], ["proof (chain)\npicking this:\n  p = ( D \\<Rightarrow>* B)", "have \"(D \\<Rightarrow>* B) \\<in> set ps \\<and> (\\<Phi>'\\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') = extend (\\<Phi>1\\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>) (D \\<Rightarrow>* B)\""], ["proof (prove)\nusing this:\n  p = ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. ( D \\<Rightarrow>* B) \\<in> set ps \\<and>\n    ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') =\n    extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\n     ( D \\<Rightarrow>* B)", "using t"], ["proof (prove)\nusing this:\n  p = ( D \\<Rightarrow>* B)\n  p \\<in> set ps \\<and>\n  ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') =\n  extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>) p\n\ngoal (1 subgoal):\n 1. ( D \\<Rightarrow>* B) \\<in> set ps \\<and>\n    ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') =\n    extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\n     ( D \\<Rightarrow>* B)", "by auto"], ["proof (state)\nthis:\n  ( D \\<Rightarrow>* B) \\<in> set ps \\<and>\n  ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') =\n  extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\n   ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "then"], ["proof (chain)\npicking this:\n  ( D \\<Rightarrow>* B) \\<in> set ps \\<and>\n  ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') =\n  extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\n   ( D \\<Rightarrow>* B)", "have ant: \"\\<Phi>'\\<oplus> Modal M Ms = \\<Phi>1\\<oplus> Modal M Ms + D\" and suc: \"\\<Psi>' = \\<Psi> + B\""], ["proof (prove)\nusing this:\n  ( D \\<Rightarrow>* B) \\<in> set ps \\<and>\n  ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') =\n  extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\n   ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. \\<Phi>' \\<oplus> Modal M Ms = \\<Phi>1 \\<oplus> Modal M Ms + D &&&\n    \\<Psi>' = \\<Psi> + B", "using extend_def[where forms=\"\\<Phi>1\\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>\" and seq=\"D \\<Rightarrow>* B\"]"], ["proof (prove)\nusing this:\n  ( D \\<Rightarrow>* B) \\<in> set ps \\<and>\n  ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') =\n  extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\n   ( D \\<Rightarrow>* B)\n  extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\n   ( D \\<Rightarrow>* B) \\<equiv>\n   antec ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>) +\n   antec\n    ( D \\<Rightarrow>* B) \\<Rightarrow>* succ\n    ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>) +\n   succ ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. \\<Phi>' \\<oplus> Modal M Ms = \\<Phi>1 \\<oplus> Modal M Ms + D &&&\n    \\<Psi>' = \\<Psi> + B", "by auto"], ["proof (state)\nthis:\n  \\<Phi>' \\<oplus> Modal M Ms = \\<Phi>1 \\<oplus> Modal M Ms + D\n  \\<Psi>' = \\<Psi> + B\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "from suc"], ["proof (chain)\npicking this:\n  \\<Psi>' = \\<Psi> + B", "have \"\\<Psi>' + \\<Delta>' = (\\<Psi> + \\<Delta>') + B\""], ["proof (prove)\nusing this:\n  \\<Psi>' = \\<Psi> + B\n\ngoal (1 subgoal):\n 1. \\<Psi>' + \\<Delta>' = \\<Psi> + \\<Delta>' + B", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  \\<Psi>' + \\<Delta>' = \\<Psi> + \\<Delta>' + B\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "moreover"], ["proof (state)\nthis:\n  \\<Psi>' + \\<Delta>' = \\<Psi> + \\<Delta>' + B\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "from ant"], ["proof (chain)\npicking this:\n  \\<Phi>' \\<oplus> Modal M Ms = \\<Phi>1 \\<oplus> Modal M Ms + D", "have \"\\<Phi>' = \\<Phi>1 + D\""], ["proof (prove)\nusing this:\n  \\<Phi>' \\<oplus> Modal M Ms = \\<Phi>1 \\<oplus> Modal M Ms + D\n\ngoal (1 subgoal):\n 1. \\<Phi>' = \\<Phi>1 + D", "by auto"], ["proof (state)\nthis:\n  \\<Phi>' = \\<Phi>1 + D\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "then"], ["proof (chain)\npicking this:\n  \\<Phi>' = \\<Phi>1 + D", "have \"\\<Phi>' + \\<Gamma>' = (\\<Phi>1 + \\<Gamma>') + D\""], ["proof (prove)\nusing this:\n  \\<Phi>' = \\<Phi>1 + D\n\ngoal (1 subgoal):\n 1. \\<Phi>' + \\<Gamma>' = \\<Phi>1 + \\<Gamma>' + D", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  \\<Phi>' + \\<Gamma>' = \\<Phi>1 + \\<Gamma>' + D\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "ultimately"], ["proof (chain)\npicking this:\n  \\<Psi>' + \\<Delta>' = \\<Psi> + \\<Delta>' + B\n  \\<Phi>' + \\<Gamma>' = \\<Phi>1 + \\<Gamma>' + D", "have \"(\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') = extend (\\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') (D \\<Rightarrow>* B)\""], ["proof (prove)\nusing this:\n  \\<Psi>' + \\<Delta>' = \\<Psi> + \\<Delta>' + B\n  \\<Phi>' + \\<Gamma>' = \\<Phi>1 + \\<Gamma>' + D\n\ngoal (1 subgoal):\n 1. ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n    extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n     ( D \\<Rightarrow>* B)", "using extend_def[where forms=\"\\<Phi>1+\\<Gamma>'\\<Rightarrow>*\\<Psi>+\\<Delta>'\" and seq=\"D\\<Rightarrow>*B\"]"], ["proof (prove)\nusing this:\n  \\<Psi>' + \\<Delta>' = \\<Psi> + \\<Delta>' + B\n  \\<Phi>' + \\<Gamma>' = \\<Phi>1 + \\<Gamma>' + D\n  extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n   ( D \\<Rightarrow>* B) \\<equiv>\n   antec ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') +\n   antec\n    ( D \\<Rightarrow>* B) \\<Rightarrow>* succ\n    ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') +\n   succ ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n    extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n     ( D \\<Rightarrow>* B)", "by auto"], ["proof (state)\nthis:\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n  extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n   ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "moreover"], ["proof (state)\nthis:\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n  extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n   ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "have \"extend (\\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') (D \\<Rightarrow>* B) \\<in> set Ps'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n     ( D \\<Rightarrow>* B)\n    \\<in> set Ps'", "using \\<open>p = (D \\<Rightarrow>* B)\\<close> and t and c2"], ["proof (prove)\nusing this:\n  p = ( D \\<Rightarrow>* B)\n  p \\<in> set ps \\<and>\n  ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') =\n  extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>) p\n  \\<forall>p\\<in>set ps.\n     extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p\n     \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n     ( D \\<Rightarrow>* B)\n    \\<in> set Ps'", "by auto"], ["proof (state)\nthis:\n  extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n   ( D \\<Rightarrow>* B)\n  \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "ultimately"], ["proof (chain)\npicking this:\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n  extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n   ( D \\<Rightarrow>* B)\n  extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n   ( D \\<Rightarrow>* B)\n  \\<in> set Ps'", "have \"(\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'\""], ["proof (prove)\nusing this:\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n  extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n   ( D \\<Rightarrow>* B)\n  extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n   ( D \\<Rightarrow>* B)\n  \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'", "by simp"], ["proof (state)\nthis:\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "}"], ["proof (state)\nthis:\n  ( ?\\<Phi>'2 \\<oplus> Modal M Ms \\<Rightarrow>* ?\\<Psi>'2)\n  \\<in> set Ps \\<Longrightarrow>\n  ( ?\\<Phi>'2 + \\<Gamma>' \\<Rightarrow>* ?\\<Psi>'2 + \\<Delta>')\n  \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "thus ?thesis"], ["proof (prove)\nusing this:\n  ( ?\\<Phi>'2 \\<oplus> Modal M Ms \\<Rightarrow>* ?\\<Psi>'2)\n  \\<in> set Ps \\<Longrightarrow>\n  ( ?\\<Phi>'2 + \\<Gamma>' \\<Rightarrow>* ?\\<Psi>'2 + \\<Delta>')\n  \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n       \\<in> set Ps \\<longrightarrow>\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps'", "by blast"], ["proof (state)\nthis:\n  \\<forall>\\<Phi>' \\<Psi>'.\n     ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n     \\<in> set Ps \\<longrightarrow>\n     ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<Phi>' \\<Psi>'.\n     ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n     \\<in> set Ps \\<longrightarrow>\n     ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  \\<forall>\\<Phi>' \\<Psi>'.\n     ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n     \\<in> set Ps \\<longrightarrow>\n     ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "have \"\\<forall> \\<Phi>' \\<Psi>'. (\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps' \\<longrightarrow> (\\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps", "fix \\<Phi>' \\<Psi>'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps", "assume \"(\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'\""], ["proof (state)\nthis:\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps", "then"], ["proof (chain)\npicking this:\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'", "have \"\\<exists> p \\<in> set ps. extend (\\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p = (\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\""], ["proof (prove)\nusing this:\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set ps.\n       extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p =\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "using eq and eq2 and d2"], ["proof (prove)\nusing this:\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'\n  Ps' =\n  map (extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')) ps\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>\\<Phi>' \\<Psi>'.\n        p = ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>p'\\<in>set ps.\n        p =\n        extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p'\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>set ps.\n       extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p =\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "apply (simp only:Ball_def Bex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n             \\<in> set (map (extend\n                              ( \\<Phi>1 +\n                                \\<Gamma>' \\<Rightarrow>* \\<Psi> +\n                   \\<Delta>'))\n                         ps);\n     Ps' =\n     map (extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>'))\n      ps;\n     \\<forall>x.\n        x \\<in> set (map (extend\n                           ( \\<Phi>1 +\n                             \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>'))\n                      ps) \\<longrightarrow>\n        (\\<exists>\\<Phi>' \\<Psi>'.\n            x = ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>'));\n     \\<forall>x.\n        x \\<in> set (map (extend\n                           ( \\<Phi>1 +\n                             \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>'))\n                      ps) \\<longrightarrow>\n        (\\<exists>xa.\n            xa \\<in> set ps \\<and>\n            x =\n            extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n             xa)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         x \\<in> set ps \\<and>\n                         extend\n                          ( \\<Phi>1 +\n                            \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n                          x =\n                         ( \\<Phi>' +\n                           \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "apply (drule_tac x=\"\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>'\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n             \\<in> set (map (extend\n                              ( \\<Phi>1 +\n                                \\<Gamma>' \\<Rightarrow>* \\<Psi> +\n                   \\<Delta>'))\n                         ps);\n     Ps' =\n     map (extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>'))\n      ps;\n     \\<forall>x.\n        x \\<in> set (map (extend\n                           ( \\<Phi>1 +\n                             \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>'))\n                      ps) \\<longrightarrow>\n        (\\<exists>xa.\n            xa \\<in> set ps \\<and>\n            x =\n            extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n             xa);\n     ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n     \\<in> set (map (extend\n                      ( \\<Phi>1 +\n                        \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>'))\n                 ps) \\<longrightarrow>\n     (\\<exists>\\<Phi>'' \\<Psi>''.\n         ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n         ( \\<Phi>'' +\n           \\<Gamma>' \\<Rightarrow>* \\<Psi>'' + \\<Delta>'))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         x \\<in> set ps \\<and>\n                         extend\n                          ( \\<Phi>1 +\n                            \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n                          x =\n                         ( \\<Phi>' +\n                           \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "by (drule_tac x=\"\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>'\" in spec) (auto)"], ["proof (state)\nthis:\n  \\<exists>p\\<in>set ps.\n     extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p =\n     ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps", "then"], ["proof (chain)\npicking this:\n  \\<exists>p\\<in>set ps.\n     extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p =\n     ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "obtain p where t:\"p \\<in> set ps \\<and> (\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') = extend (\\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p\""], ["proof (prove)\nusing this:\n  \\<exists>p\\<in>set ps.\n     extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p =\n     ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        p \\<in> set ps \\<and>\n        ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n        extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n         p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>p.\n                   p \\<in> set ps \\<and>\n                   ( \\<Phi>' +\n                     \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n                   extend\n                    ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n                    p \\<Longrightarrow>\n                   thesis;\n        p \\<in> set ps;\n        extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p =\n        ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (drule_tac x=p in meta_spec) (simp)"], ["proof (state)\nthis:\n  p \\<in> set ps \\<and>\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n  extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps", "then"], ["proof (chain)\npicking this:\n  p \\<in> set ps \\<and>\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n  extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p", "obtain D B where \"p = (D \\<Rightarrow>* B)\""], ["proof (prove)\nusing this:\n  p \\<in> set ps \\<and>\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n  extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p\n\ngoal (1 subgoal):\n 1. (\\<And>D B.\n        p = ( D \\<Rightarrow>* B) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases p)"], ["proof (state)\nthis:\n  p = ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps", "then"], ["proof (chain)\npicking this:\n  p = ( D \\<Rightarrow>* B)", "have \"(D \\<Rightarrow>* B) \\<in> set ps \\<and> (\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') = extend (\\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') (D \\<Rightarrow>* B)\""], ["proof (prove)\nusing this:\n  p = ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. ( D \\<Rightarrow>* B) \\<in> set ps \\<and>\n    ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n    extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n     ( D \\<Rightarrow>* B)", "using t"], ["proof (prove)\nusing this:\n  p = ( D \\<Rightarrow>* B)\n  p \\<in> set ps \\<and>\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n  extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p\n\ngoal (1 subgoal):\n 1. ( D \\<Rightarrow>* B) \\<in> set ps \\<and>\n    ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n    extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n     ( D \\<Rightarrow>* B)", "by auto"], ["proof (state)\nthis:\n  ( D \\<Rightarrow>* B) \\<in> set ps \\<and>\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n  extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n   ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps", "then"], ["proof (chain)\npicking this:\n  ( D \\<Rightarrow>* B) \\<in> set ps \\<and>\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n  extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n   ( D \\<Rightarrow>* B)", "have ant: \"\\<Phi>' + \\<Gamma>' = \\<Phi>1 + \\<Gamma>' + D\" and suc: \"\\<Psi>' + \\<Delta>' = \\<Psi> + \\<Delta>' + B\""], ["proof (prove)\nusing this:\n  ( D \\<Rightarrow>* B) \\<in> set ps \\<and>\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n  extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n   ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. \\<Phi>' + \\<Gamma>' = \\<Phi>1 + \\<Gamma>' + D &&&\n    \\<Psi>' + \\<Delta>' = \\<Psi> + \\<Delta>' + B", "using extend_def[where forms=\"\\<Phi>1+\\<Gamma>'\\<Rightarrow>*\\<Psi>+\\<Delta>'\" and seq=\"D\\<Rightarrow>*B\"]"], ["proof (prove)\nusing this:\n  ( D \\<Rightarrow>* B) \\<in> set ps \\<and>\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n  extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n   ( D \\<Rightarrow>* B)\n  extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>')\n   ( D \\<Rightarrow>* B) \\<equiv>\n   antec ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') +\n   antec\n    ( D \\<Rightarrow>* B) \\<Rightarrow>* succ\n    ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') +\n   succ ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. \\<Phi>' + \\<Gamma>' = \\<Phi>1 + \\<Gamma>' + D &&&\n    \\<Psi>' + \\<Delta>' = \\<Psi> + \\<Delta>' + B", "by auto"], ["proof (state)\nthis:\n  \\<Phi>' + \\<Gamma>' = \\<Phi>1 + \\<Gamma>' + D\n  \\<Psi>' + \\<Delta>' = \\<Psi> + \\<Delta>' + B\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps", "from suc"], ["proof (chain)\npicking this:\n  \\<Psi>' + \\<Delta>' = \\<Psi> + \\<Delta>' + B", "have \"\\<Psi>' + \\<Delta>' = (\\<Psi> + B) + \\<Delta>'\""], ["proof (prove)\nusing this:\n  \\<Psi>' + \\<Delta>' = \\<Psi> + \\<Delta>' + B\n\ngoal (1 subgoal):\n 1. \\<Psi>' + \\<Delta>' = \\<Psi> + B + \\<Delta>'", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  \\<Psi>' + \\<Delta>' = \\<Psi> + B + \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps", "then"], ["proof (chain)\npicking this:\n  \\<Psi>' + \\<Delta>' = \\<Psi> + B + \\<Delta>'", "have \"\\<Psi>' = \\<Psi> + B\""], ["proof (prove)\nusing this:\n  \\<Psi>' + \\<Delta>' = \\<Psi> + B + \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<Psi>' = \\<Psi> + B", "by simp"], ["proof (state)\nthis:\n  \\<Psi>' = \\<Psi> + B\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps", "moreover"], ["proof (state)\nthis:\n  \\<Psi>' = \\<Psi> + B\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps", "from ant"], ["proof (chain)\npicking this:\n  \\<Phi>' + \\<Gamma>' = \\<Phi>1 + \\<Gamma>' + D", "have \"\\<Phi>' + \\<Gamma>' = (\\<Phi>1 + D) + \\<Gamma>'\""], ["proof (prove)\nusing this:\n  \\<Phi>' + \\<Gamma>' = \\<Phi>1 + \\<Gamma>' + D\n\ngoal (1 subgoal):\n 1. \\<Phi>' + \\<Gamma>' = \\<Phi>1 + D + \\<Gamma>'", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  \\<Phi>' + \\<Gamma>' = \\<Phi>1 + D + \\<Gamma>'\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps", "then"], ["proof (chain)\npicking this:\n  \\<Phi>' + \\<Gamma>' = \\<Phi>1 + D + \\<Gamma>'", "have \"\\<Phi>' = \\<Phi>1 + D\""], ["proof (prove)\nusing this:\n  \\<Phi>' + \\<Gamma>' = \\<Phi>1 + D + \\<Gamma>'\n\ngoal (1 subgoal):\n 1. \\<Phi>' = \\<Phi>1 + D", "by simp"], ["proof (state)\nthis:\n  \\<Phi>' = \\<Phi>1 + D\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps", "then"], ["proof (chain)\npicking this:\n  \\<Phi>' = \\<Phi>1 + D", "have \"\\<Phi>' \\<oplus> Modal M Ms = (\\<Phi>1 \\<oplus> Modal M Ms) + D\""], ["proof (prove)\nusing this:\n  \\<Phi>' = \\<Phi>1 + D\n\ngoal (1 subgoal):\n 1. \\<Phi>' \\<oplus> Modal M Ms = \\<Phi>1 \\<oplus> Modal M Ms + D", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  \\<Phi>' \\<oplus> Modal M Ms = \\<Phi>1 \\<oplus> Modal M Ms + D\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps", "ultimately"], ["proof (chain)\npicking this:\n  \\<Psi>' = \\<Psi> + B\n  \\<Phi>' \\<oplus> Modal M Ms = \\<Phi>1 \\<oplus> Modal M Ms + D", "have \"(\\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>' ) = extend (\\<Phi>1\\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>) (D \\<Rightarrow>* B)\""], ["proof (prove)\nusing this:\n  \\<Psi>' = \\<Psi> + B\n  \\<Phi>' \\<oplus> Modal M Ms = \\<Phi>1 \\<oplus> Modal M Ms + D\n\ngoal (1 subgoal):\n 1. ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') =\n    extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\n     ( D \\<Rightarrow>* B)", "using extend_def[where forms=\"\\<Phi>1 \\<oplus> Modal M Ms\\<Rightarrow>*\\<Psi>\" and seq=\"D\\<Rightarrow>*B\"]"], ["proof (prove)\nusing this:\n  \\<Psi>' = \\<Psi> + B\n  \\<Phi>' \\<oplus> Modal M Ms = \\<Phi>1 \\<oplus> Modal M Ms + D\n  extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\n   ( D \\<Rightarrow>* B) \\<equiv>\n   antec ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>) +\n   antec\n    ( D \\<Rightarrow>* B) \\<Rightarrow>* succ\n    ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>) +\n   succ ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') =\n    extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\n     ( D \\<Rightarrow>* B)", "by auto"], ["proof (state)\nthis:\n  ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') =\n  extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\n   ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps", "moreover"], ["proof (state)\nthis:\n  ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') =\n  extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\n   ( D \\<Rightarrow>* B)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps", "have \"extend (\\<Phi>1\\<oplus>Modal M Ms  \\<Rightarrow>* \\<Psi>) (D \\<Rightarrow>* B) \\<in> set Ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\n     ( D \\<Rightarrow>* B)\n    \\<in> set Ps", "using \\<open>p = (D \\<Rightarrow>* B)\\<close> and t and c1\n                       and \\<open>S = (\\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\\<close>"], ["proof (prove)\nusing this:\n  p = ( D \\<Rightarrow>* B)\n  p \\<in> set ps \\<and>\n  ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') =\n  extend ( \\<Phi>1 + \\<Gamma>' \\<Rightarrow>* \\<Psi> + \\<Delta>') p\n  \\<forall>p\\<in>set ps. extend S p \\<in> set Ps\n  S = ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\n\ngoal (1 subgoal):\n 1. extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\n     ( D \\<Rightarrow>* B)\n    \\<in> set Ps", "by auto"], ["proof (state)\nthis:\n  extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\n   ( D \\<Rightarrow>* B)\n  \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps", "ultimately"], ["proof (chain)\npicking this:\n  ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') =\n  extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\n   ( D \\<Rightarrow>* B)\n  extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\n   ( D \\<Rightarrow>* B)\n  \\<in> set Ps", "have \"(\\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>' ) \\<in> set Ps\""], ["proof (prove)\nusing this:\n  ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') =\n  extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\n   ( D \\<Rightarrow>* B)\n  extend ( \\<Phi>1 \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>)\n   ( D \\<Rightarrow>* B)\n  \\<in> set Ps\n\ngoal (1 subgoal):\n 1. ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps", "by simp"], ["proof (state)\nthis:\n  ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps", "}"], ["proof (state)\nthis:\n  ( ?\\<Phi>'2 + \\<Gamma>' \\<Rightarrow>* ?\\<Psi>'2 + \\<Delta>')\n  \\<in> set Ps' \\<Longrightarrow>\n  ( ?\\<Phi>'2 \\<oplus> Modal M Ms \\<Rightarrow>* ?\\<Psi>'2) \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps", "thus ?thesis"], ["proof (prove)\nusing this:\n  ( ?\\<Phi>'2 + \\<Gamma>' \\<Rightarrow>* ?\\<Psi>'2 + \\<Delta>')\n  \\<in> set Ps' \\<Longrightarrow>\n  ( ?\\<Phi>'2 \\<oplus> Modal M Ms \\<Rightarrow>* ?\\<Psi>'2) \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n       \\<in> set Ps' \\<longrightarrow>\n       ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps", "by blast"], ["proof (state)\nthis:\n  \\<forall>\\<Phi>' \\<Psi>'.\n     ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n     \\<in> set Ps' \\<longrightarrow>\n     ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<Phi>' \\<Psi>'.\n     ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n     \\<in> set Ps' \\<longrightarrow>\n     ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set Ps. \\<exists>p'. p' \\<in> set Ps'\n  \\<forall>\\<Phi>' \\<Psi>'.\n     ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n     \\<in> set Ps \\<longrightarrow>\n     ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'\n  \\<forall>\\<Phi>' \\<Psi>'.\n     ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n     \\<in> set Ps' \\<longrightarrow>\n     ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps", "have \"\\<forall> \\<Phi>' \\<Psi>'. ((\\<Phi>'\\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>' ) \\<in> set Ps) = ((\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps')\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps. \\<exists>p'. p' \\<in> set Ps'\n  \\<forall>\\<Phi>' \\<Psi>'.\n     ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n     \\<in> set Ps \\<longrightarrow>\n     ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>') \\<in> set Ps'\n  \\<forall>\\<Phi>' \\<Psi>'.\n     ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n     \\<in> set Ps' \\<longrightarrow>\n     ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<forall>\\<Phi>' \\<Psi>'.\n       (( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n        \\<in> set Ps) =\n       (( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n        \\<in> set Ps')", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<Phi>' \\<Psi>'.\n     (( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps) =\n     (( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n      \\<in> set Ps')\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<forall>\\<Phi>' \\<Psi>'.\n     (( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps) =\n     (( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n      \\<in> set Ps')", "have \"\\<forall> p \\<in> set Ps'. \\<exists> \\<Phi>' \\<Psi>' n. n\\<le>n' \\<and> (\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',n) \\<in> derivable (ext R R2 M1 M2)\n                 \\<and> p = (\\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\""], ["proof (prove)\nusing this:\n  \\<forall>\\<Phi>' \\<Psi>'.\n     (( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps) =\n     (( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n      \\<in> set Ps')\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps'.\n       \\<exists>\\<Phi>' \\<Psi>' n.\n          n \\<le> n' \\<and>\n          ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', n)\n          \\<in> derivable (ext R R2 M1 M2) \\<and>\n          p = ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "using eq2 and a2"], ["proof (prove)\nusing this:\n  \\<forall>\\<Phi>' \\<Psi>'.\n     (( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>') \\<in> set Ps) =\n     (( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n      \\<in> set Ps')\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>\\<Phi>' \\<Psi>'.\n        p = ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n  \\<forall>p\\<in>set Ps.\n     \\<exists>\\<Phi>' \\<Psi>' m.\n        m \\<le> n' \\<and>\n        ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', m)\n        \\<in> derivable (ext R R2 M1 M2) \\<and>\n        p = ( \\<Phi>' \\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>')\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps'.\n       \\<exists>\\<Phi>' \\<Psi>' n.\n          n \\<le> n' \\<and>\n          ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', n)\n          \\<in> derivable (ext R R2 M1 M2) \\<and>\n          p = ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "apply (simp add:Ball_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<Phi>' \\<Psi>'.\n                (( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>')\n                 \\<in> set Ps) =\n                (( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n                 \\<in> set Ps');\n     \\<forall>x.\n        x \\<in> set Ps' \\<longrightarrow>\n        (\\<exists>\\<Phi>' \\<Psi>'.\n            x = ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>'));\n     \\<forall>x.\n        x \\<in> set Ps \\<longrightarrow>\n        (\\<exists>\\<Phi>' \\<Psi>' m.\n            m \\<le> n' \\<and>\n            ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', m)\n            \\<in> derivable (ext R R2 M1 M2) \\<and>\n            x =\n            ( add_mset (Modal M Ms)\n               \\<Phi>' \\<Rightarrow>* \\<Psi>'))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         x \\<in> set Ps' \\<longrightarrow>\n                         (\\<exists>\\<Phi>' \\<Psi>' n.\n                             n \\<le> n' \\<and>\n                             ( \\<Phi>' +\n                               \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                              n)\n                             \\<in> derivable (ext R R2 M1 M2) \\<and>\n                             x =\n                             ( \\<Phi>' +\n                               \\<Gamma>' \\<Rightarrow>* \\<Psi>' +\n                  \\<Delta>'))", "apply (intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<Phi>' \\<Psi>'.\n                   (( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>')\n                    \\<in> set Ps) =\n                   (( \\<Phi>' +\n                      \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n                    \\<in> set Ps');\n        \\<forall>x.\n           x \\<in> set Ps' \\<longrightarrow>\n           (\\<exists>\\<Phi>' \\<Psi>'.\n               x =\n               ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>'));\n        \\<forall>x.\n           x \\<in> set Ps \\<longrightarrow>\n           (\\<exists>\\<Phi>' \\<Psi>' m.\n               m \\<le> n' \\<and>\n               ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', m)\n               \\<in> derivable (ext R R2 M1 M2) \\<and>\n               x = ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>'));\n        x \\<in> set Ps'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>' \\<Psi>' n.\n                            n \\<le> n' \\<and>\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             n)\n                            \\<in> derivable (ext R R2 M1 M2) \\<and>\n                            x =\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "apply (drule_tac x=x in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<Phi>' \\<Psi>'.\n                   (( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>')\n                    \\<in> set Ps) =\n                   (( \\<Phi>' +\n                      \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n                    \\<in> set Ps');\n        \\<forall>x.\n           x \\<in> set Ps \\<longrightarrow>\n           (\\<exists>\\<Phi>' \\<Psi>' m.\n               m \\<le> n' \\<and>\n               ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', m)\n               \\<in> derivable (ext R R2 M1 M2) \\<and>\n               x = ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>'));\n        x \\<in> set Ps';\n        x \\<in> set Ps' \\<longrightarrow>\n        (\\<exists>\\<Phi>' \\<Psi>'.\n            x =\n            ( \\<Phi>' +\n              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>'))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>' \\<Psi>' n.\n                            n \\<le> n' \\<and>\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             n)\n                            \\<in> derivable (ext R R2 M1 M2) \\<and>\n                            x =\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>\\<Phi>' \\<Psi>'.\n                   (( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>')\n                    \\<in> set Ps) =\n                   (( \\<Phi>' +\n                      \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n                    \\<in> set Ps');\n        \\<forall>x.\n           x \\<in> set Ps \\<longrightarrow>\n           (\\<exists>\\<Phi>' \\<Psi>' m.\n               m \\<le> n' \\<and>\n               ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', m)\n               \\<in> derivable (ext R R2 M1 M2) \\<and>\n               x = ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>'));\n        x \\<in> set Ps';\n        \\<exists>\\<Phi>' \\<Psi>'.\n           x =\n           ( \\<Phi>' +\n             \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>' \\<Psi>' n.\n                            n \\<le> n' \\<and>\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             n)\n                            \\<in> derivable (ext R R2 M1 M2) \\<and>\n                            x =\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "apply (elim exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<Phi>' \\<Psi>'.\n       \\<lbrakk>\\<forall>\\<Phi>' \\<Psi>'.\n                   (( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>')\n                    \\<in> set Ps) =\n                   (( \\<Phi>' +\n                      \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n                    \\<in> set Ps');\n        \\<forall>x.\n           x \\<in> set Ps \\<longrightarrow>\n           (\\<exists>\\<Phi>' \\<Psi>' m.\n               m \\<le> n' \\<and>\n               ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', m)\n               \\<in> derivable (ext R R2 M1 M2) \\<and>\n               x = ( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>'));\n        x \\<in> set Ps';\n        x =\n        ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>' \\<Psi>' n.\n                            n \\<le> n' \\<and>\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             n)\n                            \\<in> derivable (ext R R2 M1 M2) \\<and>\n                            x =\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "apply (drule_tac x=\\<Phi>' in spec,drule_tac x=\\<Psi>' in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<Phi>' \\<Psi>'.\n       \\<lbrakk>\\<forall>x.\n                   x \\<in> set Ps \\<longrightarrow>\n                   (\\<exists>\\<Phi>' \\<Psi>' m.\n                       m \\<le> n' \\<and>\n                       ( \\<Phi>' +\n                         \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                        m)\n                       \\<in> derivable (ext R R2 M1 M2) \\<and>\n                       x =\n                       ( add_mset (Modal M Ms)\n                          \\<Phi>' \\<Rightarrow>* \\<Psi>'));\n        x \\<in> set Ps';\n        x = ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>');\n        (( add_mset (Modal M Ms) \\<Phi>' \\<Rightarrow>* \\<Psi>')\n         \\<in> set Ps) =\n        (( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n         \\<in> set Ps')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<Phi>' \\<Psi>' n.\n                            n \\<le> n' \\<and>\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>',\n                             n)\n                            \\<in> derivable (ext R R2 M1 M2) \\<and>\n                            x =\n                            ( \\<Phi>' +\n                              \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "by (drule_tac x=\"\\<Phi>'\\<oplus> Modal M Ms \\<Rightarrow>* \\<Psi>' \" in spec) (simp)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>\\<Phi>' \\<Psi>' n.\n        n \\<le> n' \\<and>\n        ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', n)\n        \\<in> derivable (ext R R2 M1 M2) \\<and>\n        p = ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>\\<Phi>' \\<Psi>' n.\n        n \\<le> n' \\<and>\n        ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', n)\n        \\<in> derivable (ext R R2 M1 M2) \\<and>\n        p = ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')", "have all:\"\\<forall> p \\<in> set Ps'. \\<exists> n\\<le>n'. (p,n) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>\\<Phi>' \\<Psi>' n.\n        n \\<le> n' \\<and>\n        ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>', n)\n        \\<in> derivable (ext R R2 M1 M2) \\<and>\n        p = ( \\<Phi>' + \\<Gamma>' \\<Rightarrow>* \\<Psi>' + \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set Ps'.\n       \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)", "show \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "using num\n      and \\<open>(Ps',\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') \\<in> (ext R R2 M1 M2)\\<close> and \\<open>Ps' \\<noteq> []\\<close>\n      and derivable.step[where r=\"(Ps',\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>')\" and R=\"(ext R R2 M1 M2)\"]"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps'.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n  n = n' + 1\n  (Ps',  \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>')\n  \\<in> ext R R2 M1 M2\n  Ps' \\<noteq> []\n  \\<lbrakk>(Ps',  \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>')\n           \\<in> ext R R2 M1 M2;\n   fst (Ps',\n         \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') \\<noteq>\n   [];\n   \\<forall>p\\<in>set (fst (Ps',\n                             \\<Gamma> +\n                             \\<Gamma>' \\<Rightarrow>* \\<Delta> +\n                \\<Delta>')).\n      \\<exists>n\\<le>?m. (p, n) \\<in> derivable (ext R R2 M1 M2)\\<rbrakk>\n  \\<Longrightarrow> (snd (Ps',\n                           \\<Gamma> +\n                           \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>'),\n                     ?m + 1)\n                    \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by (auto simp add:Ball_def Bex_def)"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*>*)"], ["", "text\\<open>\nWe have two different inversion lemmata, depending on whether the rule was a modalised context rule, or some other kind of rule.  We only show the former, since the latter is much the same as earlier proofs.  The interesting cases are picked out:\n\\<close>"], ["", "lemma rightInvert:\nfixes \\<Gamma> \\<Delta> :: \"('a,'b) form multiset\"\nassumes rules: \"R1 \\<subseteq> upRules \\<and> R2 \\<subseteq> modRules2 \\<and> R3 \\<subseteq> modRules2 \\<and> \n                R = Ax \\<union> R1 \\<union> (p_e R2 M1 M2) \\<union> R3 \\<and>\n                R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\"\n    and   a: \"(\\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms,n) \\<in> derivable (ext R R2 M1 M2)\"\n    and   b: \"\\<forall> r' \\<in> R'. rightPrincipal r' (Modal M Ms) R' \\<longrightarrow> \n                         (\\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\"\n    and  neq: \"M2 \\<noteq> M\"\nshows \"\\<exists> m\\<le>n. (\\<Gamma> +\\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "(*<*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "using assms"], ["proof (prove)\nusing this:\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, n)\n  \\<in> derivable (ext R R2 M1 M2)\n  \\<forall>r'\\<in>R'.\n     rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\n  M2 \\<noteq> M\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "proof (induct n arbitrary: \\<Gamma> \\<Delta> rule:nat_less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n \\<Gamma> \\<Delta>.\n       \\<lbrakk>\\<forall>m<n.\n                   R1 \\<subseteq> upRules \\<and>\n                   R2 \\<subseteq> modRules2 \\<and>\n                   R3 \\<subseteq> modRules2 \\<and>\n                   R =\n                   Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n                   R' =\n                   Ax \\<union> R1 \\<union> R2 \\<union> R3 \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ( x \\<Rightarrow>* xa \\<oplus> Modal M Ms, m)\n                       \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n                       (\\<forall>r'\\<in>R'.\n                           rightPrincipal r' (Modal M Ms)\n                            R' \\<longrightarrow>\n                           ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n                           \\<in> set (fst r')) \\<longrightarrow>\n                       M2 \\<noteq> M \\<longrightarrow>\n                       (\\<exists>ma\\<le>m.\n                           ( x + \\<Gamma>' \\<Rightarrow>* xa + \\<Delta>',\n                            ma)\n                           \\<in> derivable (ext R R2 M1 M2)));\n        R1 \\<subseteq> upRules \\<and>\n        R2 \\<subseteq> modRules2 \\<and>\n        R3 \\<subseteq> modRules2 \\<and>\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, n)\n        \\<in> derivable (ext R R2 M1 M2);\n        \\<forall>r'\\<in>R'.\n           rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n           ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r');\n        M2 \\<noteq> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<le>n.\n                            ( \\<Gamma> +\n                              \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2)", "case (1 n \\<Gamma> \\<Delta>)"], ["proof (state)\nthis:\n  \\<forall>m<n.\n     R1 \\<subseteq> upRules \\<and>\n     R2 \\<subseteq> modRules2 \\<and>\n     R3 \\<subseteq> modRules2 \\<and>\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3 \\<longrightarrow>\n     (\\<forall>x xa.\n         ( x \\<Rightarrow>* xa \\<oplus> Modal M Ms, m)\n         \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n         (\\<forall>r'\\<in>R'.\n             rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n             ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n             \\<in> set (fst r')) \\<longrightarrow>\n         M2 \\<noteq> M \\<longrightarrow>\n         (\\<exists>ma\\<le>m.\n             ( x + \\<Gamma>' \\<Rightarrow>* xa + \\<Delta>', ma)\n             \\<in> derivable (ext R R2 M1 M2)))\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, n)\n  \\<in> derivable (ext R R2 M1 M2)\n  \\<forall>r'\\<in>R'.\n     rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\n  M2 \\<noteq> M\n\ngoal (1 subgoal):\n 1. \\<And>n \\<Gamma> \\<Delta>.\n       \\<lbrakk>\\<forall>m<n.\n                   R1 \\<subseteq> upRules \\<and>\n                   R2 \\<subseteq> modRules2 \\<and>\n                   R3 \\<subseteq> modRules2 \\<and>\n                   R =\n                   Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n                   R' =\n                   Ax \\<union> R1 \\<union> R2 \\<union> R3 \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ( x \\<Rightarrow>* xa \\<oplus> Modal M Ms, m)\n                       \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n                       (\\<forall>r'\\<in>R'.\n                           rightPrincipal r' (Modal M Ms)\n                            R' \\<longrightarrow>\n                           ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n                           \\<in> set (fst r')) \\<longrightarrow>\n                       M2 \\<noteq> M \\<longrightarrow>\n                       (\\<exists>ma\\<le>m.\n                           ( x + \\<Gamma>' \\<Rightarrow>* xa + \\<Delta>',\n                            ma)\n                           \\<in> derivable (ext R R2 M1 M2)));\n        R1 \\<subseteq> upRules \\<and>\n        R2 \\<subseteq> modRules2 \\<and>\n        R3 \\<subseteq> modRules2 \\<and>\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, n)\n        \\<in> derivable (ext R R2 M1 M2);\n        \\<forall>r'\\<in>R'.\n           rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n           ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r');\n        M2 \\<noteq> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<le>n.\n                            ( \\<Gamma> +\n                              \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<forall>m<n.\n     R1 \\<subseteq> upRules \\<and>\n     R2 \\<subseteq> modRules2 \\<and>\n     R3 \\<subseteq> modRules2 \\<and>\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3 \\<longrightarrow>\n     (\\<forall>x xa.\n         ( x \\<Rightarrow>* xa \\<oplus> Modal M Ms, m)\n         \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n         (\\<forall>r'\\<in>R'.\n             rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n             ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n             \\<in> set (fst r')) \\<longrightarrow>\n         M2 \\<noteq> M \\<longrightarrow>\n         (\\<exists>ma\\<le>m.\n             ( x + \\<Gamma>' \\<Rightarrow>* xa + \\<Delta>', ma)\n             \\<in> derivable (ext R R2 M1 M2)))\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, n)\n  \\<in> derivable (ext R R2 M1 M2)\n  \\<forall>r'\\<in>R'.\n     rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\n  M2 \\<noteq> M", "have IH:\"\\<forall>m<n. \\<forall>\\<Gamma> \\<Delta>. ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, m) \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n              (\\<forall>r' \\<in> R'. rightPrincipal r' (Modal M Ms) R' \\<longrightarrow> ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')) \\<longrightarrow>\n              (\\<exists>m'\\<le>m. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m') \\<in> derivable (ext R R2 M1 M2))\" \n     and a': \"(\\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms,n) \\<in> derivable (ext R R2 M1 M2)\" \n     and b': \"\\<forall> r' \\<in> R'. rightPrincipal r' (Modal M Ms) R' \\<longrightarrow> (\\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\""], ["proof (prove)\nusing this:\n  \\<forall>m<n.\n     R1 \\<subseteq> upRules \\<and>\n     R2 \\<subseteq> modRules2 \\<and>\n     R3 \\<subseteq> modRules2 \\<and>\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3 \\<longrightarrow>\n     (\\<forall>x xa.\n         ( x \\<Rightarrow>* xa \\<oplus> Modal M Ms, m)\n         \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n         (\\<forall>r'\\<in>R'.\n             rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n             ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n             \\<in> set (fst r')) \\<longrightarrow>\n         M2 \\<noteq> M \\<longrightarrow>\n         (\\<exists>ma\\<le>m.\n             ( x + \\<Gamma>' \\<Rightarrow>* xa + \\<Delta>', ma)\n             \\<in> derivable (ext R R2 M1 M2)))\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, n)\n  \\<in> derivable (ext R R2 M1 M2)\n  \\<forall>r'\\<in>R'.\n     rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\n  M2 \\<noteq> M\n\ngoal (1 subgoal):\n 1. \\<forall>m<n.\n       \\<forall>\\<Gamma> \\<Delta>.\n          ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, m)\n          \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n          (\\<forall>r'\\<in>R'.\n              rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n              ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n              \\<in> set (fst r')) \\<longrightarrow>\n          (\\<exists>m'\\<le>m.\n              ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n               m')\n              \\<in> derivable (ext R R2 M1 M2)) &&&\n    ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, n)\n    \\<in> derivable (ext R R2 M1 M2) &&&\n    \\<forall>r'\\<in>R'.\n       rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n       ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')", "by auto"], ["proof (state)\nthis:\n  \\<forall>m<n.\n     \\<forall>\\<Gamma> \\<Delta>.\n        ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, m)\n        \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n        (\\<forall>r'\\<in>R'.\n            rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n            ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n            \\<in> set (fst r')) \\<longrightarrow>\n        (\\<exists>m'\\<le>m.\n            ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m')\n            \\<in> derivable (ext R R2 M1 M2))\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, n)\n  \\<in> derivable (ext R R2 M1 M2)\n  \\<forall>r'\\<in>R'.\n     rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\n\ngoal (1 subgoal):\n 1. \\<And>n \\<Gamma> \\<Delta>.\n       \\<lbrakk>\\<forall>m<n.\n                   R1 \\<subseteq> upRules \\<and>\n                   R2 \\<subseteq> modRules2 \\<and>\n                   R3 \\<subseteq> modRules2 \\<and>\n                   R =\n                   Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n                   R' =\n                   Ax \\<union> R1 \\<union> R2 \\<union> R3 \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ( x \\<Rightarrow>* xa \\<oplus> Modal M Ms, m)\n                       \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n                       (\\<forall>r'\\<in>R'.\n                           rightPrincipal r' (Modal M Ms)\n                            R' \\<longrightarrow>\n                           ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n                           \\<in> set (fst r')) \\<longrightarrow>\n                       M2 \\<noteq> M \\<longrightarrow>\n                       (\\<exists>ma\\<le>m.\n                           ( x + \\<Gamma>' \\<Rightarrow>* xa + \\<Delta>',\n                            ma)\n                           \\<in> derivable (ext R R2 M1 M2)));\n        R1 \\<subseteq> upRules \\<and>\n        R2 \\<subseteq> modRules2 \\<and>\n        R3 \\<subseteq> modRules2 \\<and>\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, n)\n        \\<in> derivable (ext R R2 M1 M2);\n        \\<forall>r'\\<in>R'.\n           rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n           ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r');\n        M2 \\<noteq> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<le>n.\n                            ( \\<Gamma> +\n                              \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  n = 0", "have \"(\\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms,0) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, 0)\n    \\<in> derivable (ext R R2 M1 M2)", "using a'"], ["proof (prove)\nusing this:\n  n = 0\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, n)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, 0)\n    \\<in> derivable (ext R R2 M1 M2)", "by simp"], ["proof (state)\nthis:\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, 0)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, 0)\n  \\<in> derivable (ext R R2 M1 M2)", "have \"([],\\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<in> ext R R2 M1 M2\""], ["proof (prove)\nusing this:\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, 0)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. ([],  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n    \\<in> ext R R2 M1 M2", "by (cases) (auto)"], ["proof (state)\nthis:\n  ([],  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  \\<in> ext R R2 M1 M2\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  ([],  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  \\<in> ext R R2 M1 M2", "have \"\\<exists> r S. extendRule S r = ([],\\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<and> (r \\<in> Ax)\""], ["proof (prove)\nusing this:\n  ([],  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  \\<in> ext R R2 M1 M2\n\ngoal (1 subgoal):\n 1. \\<exists>r S.\n       extendRule S r =\n       ([],  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<and>\n       r \\<in> Ax", "using rules"], ["proof (prove)\nusing this:\n  ([],  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  \\<in> ext R R2 M1 M2\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n\ngoal (1 subgoal):\n 1. \\<exists>r S.\n       extendRule S r =\n       ([],  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<and>\n       r \\<in> Ax", "apply-"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>([],  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n             \\<in> ext R R2 M1 M2;\n     R1 \\<subseteq> upRules \\<and>\n     R2 \\<subseteq> modRules2 \\<and>\n     R3 \\<subseteq> modRules2 \\<and>\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r S.\n                         extendRule S r =\n                         ([],\n                           \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus>\n             Modal M Ms) \\<and>\n                         r \\<in> Ax", "apply (rule ext.cases [where 'a = 'a and 'b = 'b])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>([],  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n             \\<in> ext R R2 M1 M2;\n     R1 \\<subseteq> upRules \\<and>\n     R2 \\<subseteq> modRules2 \\<and>\n     R3 \\<subseteq> modRules2 \\<and>\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\\<rbrakk>\n    \\<Longrightarrow> ?a2 \\<in> ext ?R2 ?R'2 ?M2 ?N2\n 2. \\<And>r seq.\n       \\<lbrakk>([],  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n                \\<in> ext R R2 M1 M2;\n        R1 \\<subseteq> upRules \\<and>\n        R2 \\<subseteq> modRules2 \\<and>\n        R3 \\<subseteq> modRules2 \\<and>\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ?a2 = extendRule seq r; r \\<in> ?R2;\n        case r of (x, xa) \\<Rightarrow> (x, xa) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r S.\n                            extendRule S r =\n                            ([],\n                              \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus>\n                Modal M Ms) \\<and>\n                            r \\<in> Ax\n 3. \\<And>r seq.\n       \\<lbrakk>([],  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n                \\<in> ext R R2 M1 M2;\n        R1 \\<subseteq> upRules \\<and>\n        R2 \\<subseteq> modRules2 \\<and>\n        R3 \\<subseteq> modRules2 \\<and>\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ?a2 = extendRule seq r; r \\<in> ?R2;\n        case r of (x, xa) \\<Rightarrow> (x, xa) \\<in> upRules\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r S.\n                            extendRule S r =\n                            ([],\n                              \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus>\n                Modal M Ms) \\<and>\n                            r \\<in> Ax\n 4. \\<And>r seq.\n       \\<lbrakk>([],  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n                \\<in> ext R R2 M1 M2;\n        R1 \\<subseteq> upRules \\<and>\n        R2 \\<subseteq> modRules2 \\<and>\n        R3 \\<subseteq> modRules2 \\<and>\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ?a2 = extendConc seq r; r \\<in> p_e ?R'2 ?M2 ?N2;\n        r \\<in> ?R2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r S.\n                            extendRule S r =\n                            ([],\n                              \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus>\n                Modal M Ms) \\<and>\n                            r \\<in> Ax\n 5. \\<And>r seq.\n       \\<lbrakk>([],  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n                \\<in> ext R R2 M1 M2;\n        R1 \\<subseteq> upRules \\<and>\n        R2 \\<subseteq> modRules2 \\<and>\n        R3 \\<subseteq> modRules2 \\<and>\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ?a2 = extendRule seq r; r \\<in> ?R2;\n        case r of (x, xa) \\<Rightarrow> (x, xa) \\<in> modRules2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r S.\n                            extendRule S r =\n                            ([],\n                              \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus>\n                Modal M Ms) \\<and>\n                            r \\<in> Ax", "apply (auto simp add:extendRule_def extend_def)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 2. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> Ax; R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 3. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> Ax; R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 4. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> Ax; R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 8. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 9. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 10. \\<And>a b seq.\n        \\<lbrakk>extendConc seq (a, b)\n                 \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union>\n                            R3)\n                        R2 M1 M2;\n         ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n         extendConc seq (a, b);\n         (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n         R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n         R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n         R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n         (a, b) \\<in> R1\\<rbrakk>\n        \\<Longrightarrow> \\<exists>b S.\n                             antec S + antec b = \\<Gamma> \\<and>\n                             succ S + succ b =\n                             add_mset (Modal M Ms) \\<Delta> \\<and>\n                             ([], b) \\<in> Ax\nA total of 16 subgoals...", "apply (rule_tac x=b in exI)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S.\n                            antec S + antec b = antec seq + antec b \\<and>\n                            succ S + succ b = succ seq + succ b \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> Ax; R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 3. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> Ax; R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 4. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> Ax; R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 8. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 9. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 10. \\<And>a b seq.\n        \\<lbrakk>extendConc seq (a, b)\n                 \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union>\n                            R3)\n                        R2 M1 M2;\n         ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n         extendConc seq (a, b);\n         (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n         R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n         R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n         R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n         (a, b) \\<in> R1\\<rbrakk>\n        \\<Longrightarrow> \\<exists>b S.\n                             antec S + antec b = \\<Gamma> \\<and>\n                             succ S + succ b =\n                             add_mset (Modal M Ms) \\<Delta> \\<and>\n                             ([], b) \\<in> Ax\nA total of 16 subgoals...", "apply (rule_tac x=seq in exI)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> antec seq + antec b = antec seq + antec b \\<and>\n                         succ seq + succ b = succ seq + succ b \\<and>\n                         ([], b) \\<in> Ax\n 2. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> Ax; R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 3. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> Ax; R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 4. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> Ax; R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 8. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 9. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 10. \\<And>a b seq.\n        \\<lbrakk>extendConc seq (a, b)\n                 \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union>\n                            R3)\n                        R2 M1 M2;\n         ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n         extendConc seq (a, b);\n         (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n         R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n         R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n         R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n         (a, b) \\<in> R1\\<rbrakk>\n        \\<Longrightarrow> \\<exists>b S.\n                             antec S + antec b = \\<Gamma> \\<and>\n                             succ S + succ b =\n                             add_mset (Modal M Ms) \\<Delta> \\<and>\n                             ([], b) \\<in> Ax\nA total of 16 subgoals...", "apply auto"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 2. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 3. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 6. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 7. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 8. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 9. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 10. \\<And>b seq.\n        \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                 \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union>\n                            R3)\n                        R2 M1 M2;\n         ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n         R2 \\<subseteq> modRules2;\n         add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n         \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n         R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n         R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n         ([], b) \\<in> R3\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ba S.\n                             antec S + antec ba = antec seq + antec b \\<and>\n                             succ S + succ ba = succ seq + succ b \\<and>\n                             ([], ba) \\<in> Ax", "apply (rule upRules.cases)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> (?a1.406 b seq, ?a2.406 b seq) \\<in> upRules\n 2. \\<And>b seq c Ra Fs ps.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        ?a1.406 b seq = ps; ?a2.406 b seq = c;\n        ModalSequents.mset c = \\<LM> Compound Ra Fs  \\<RM>;\n        ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 3. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 4. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 5. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 6. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 7. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 8. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 9. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 10. \\<And>b seq.\n        \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                 \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union>\n                            R3)\n                        R2 M1 M2;\n         ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n         R2 \\<subseteq> modRules2;\n         add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n         \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n         R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n         R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n         ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ba S.\n                             antec S + antec ba = antec seq + antec b \\<and>\n                             succ S + succ ba = succ seq + succ b \\<and>\n                             ([], ba) \\<in> Ax\nA total of 11 subgoals...", "apply auto"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 2. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 6. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 8. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 9. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (rule upRules.cases)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> (?a1.413 b seq, ?a2.413 b seq) \\<in> upRules\n 2. \\<And>b seq c Ra Fs ps.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2; ?a1.413 b seq = ps; ?a2.413 b seq = c;\n        ModalSequents.mset c = \\<LM> Compound Ra Fs  \\<RM>;\n        ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 3. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 6. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 7. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 8. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 9. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 10. \\<And>b seq.\n        \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                 \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union>\n                            R3)\n                        R2 M1 M2;\n         ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n         R2 \\<subseteq> modRules2;\n         add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n         \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n         R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n         R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n         ([], b) \\<in> R3\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ba S.\n                             antec S + antec ba = antec seq + antec b \\<and>\n                             succ S + succ ba = succ seq + succ b \\<and>\n                             ([], ba) \\<in> Ax", "apply auto"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 2. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 8. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (rule upRules.cases)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> (?a1.420 b seq, ?a2.420 b seq) \\<in> upRules\n 2. \\<And>b seq c Ra Fs ps.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        ?a1.420 b seq = ps; ?a2.420 b seq = c;\n        ModalSequents.mset c = \\<LM> Compound Ra Fs  \\<RM>;\n        ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 6. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 8. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 9. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply auto"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (insert p_e_non_empty[where R=R2 and M=M1 and N=M2])"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> Ax;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R1;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R3;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (rule Ax.cases)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> Ax;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (?a1.441 a b seq, ?a2.441 a b seq) \\<in> Ax\n 2. \\<And>a b seq i.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> Ax;\n        \\<And>r. r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> [];\n        ?a1.441 a b seq = [];\n        ?a2.441 a b seq =\n        ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> Ax;\n        \\<And>r. r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> [];\n        ?a1.441 a b seq = [];\n        ?a2.441 a b seq = ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R1;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 6. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R3;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 8. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 9. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply auto"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>seq i.\n       \\<lbrakk>extendConc seq\n                 ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq\n         ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>);\n        ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n        \\<in> p_e R2 M1 M2;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<in> Ax;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>seq.\n       \\<lbrakk>extendConc seq ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>);\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> p_e R2 M1 M2;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 8. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (drule_tac x=\"[]\" in meta_spec)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>seq i.\n       \\<lbrakk>extendConc seq\n                 ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq\n         ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>);\n        ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n        \\<in> p_e R2 M1 M2;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<in> Ax;\n        \\<And>b.\n           ([], b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>seq.\n       \\<lbrakk>extendConc seq ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>);\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> p_e R2 M1 M2;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 8. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (drule_tac x=\"\\<LM>At i\\<RM> \\<Rightarrow>* \\<LM>At i\\<RM>\" in meta_spec)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>seq i.\n       \\<lbrakk>extendConc seq\n                 ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq\n         ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>);\n        ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n        \\<in> p_e R2 M1 M2;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<in> Ax;\n        ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n        \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n        [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>seq.\n       \\<lbrakk>extendConc seq ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>);\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> p_e R2 M1 M2;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 8. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply auto"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>seq.\n       \\<lbrakk>extendConc seq ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>);\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> p_e R2 M1 M2;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (drule_tac x=\"[]\" in meta_spec)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>seq.\n       \\<lbrakk>extendConc seq ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>);\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> p_e R2 M1 M2;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax;\n        \\<And>b.\n           ([], b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (drule_tac x=\"\\<LM>ff\\<RM> \\<Rightarrow>* \\<Empt>\" in meta_spec)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>seq.\n       \\<lbrakk>extendConc seq ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>);\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> p_e R2 M1 M2;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax;\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n        \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n        [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply auto"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (drule_tac x=a in meta_spec)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R1;\n        \\<And>b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (drule_tac x=b in meta_spec)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R1;\n        (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow> a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (auto simp add:extendConc_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([], extend seq b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ( \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extend seq b;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>b seq.\n       \\<lbrakk>([], extend seq b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ( \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extend seq b;\n        ([], b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 4. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (drule_tac x=\"[]\" in meta_spec)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([], extend seq b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ( \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extend seq b;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>b.\n           ([], b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>b seq.\n       \\<lbrakk>([], extend seq b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ( \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extend seq b;\n        ([], b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 4. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (drule_tac x=b in meta_spec)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([], extend seq b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ( \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extend seq b;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        ([], b) \\<in> p_e R2 M1 M2 \\<Longrightarrow> [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>b seq.\n       \\<lbrakk>([], extend seq b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ( \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extend seq b;\n        ([], b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 4. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([], extend seq b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ( \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extend seq b;\n        ([], b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 3. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 4. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (subgoal_tac \"([],b) \\<in> modRules2\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([], extend seq b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ( \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extend seq b;\n        ([], b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow> a \\<noteq> [];\n        ([], b) \\<in> modRules2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b = \\<Gamma> \\<and>\n                            succ S + succ b =\n                            add_mset (Modal M Ms) \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>b seq.\n       \\<lbrakk>([], extend seq b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ( \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>) =\n        extend seq b;\n        ([], b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ([], b) \\<in> modRules2\n 3. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 4. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Delta> = succ seq + succ b;\n        \\<Gamma> = antec seq + antec b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "by (rule modRules2.cases,auto)+"], ["proof (state)\nthis:\n  \\<exists>r S.\n     extendRule S r =\n     ([],  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<and>\n     r \\<in> Ax\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<exists>r S.\n     extendRule S r =\n     ([],  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<and>\n     r \\<in> Ax", "obtain r S where \"extendRule S r = ([],\\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\" and \"r \\<in> Ax\""], ["proof (prove)\nusing this:\n  \\<exists>r S.\n     extendRule S r =\n     ([],  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<and>\n     r \\<in> Ax\n\ngoal (1 subgoal):\n 1. (\\<And>S r.\n        \\<lbrakk>extendRule S r =\n                 ([],\n                   \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms);\n         r \\<in> Ax\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  extendRule S r =\n  ([],  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r \\<in> Ax\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  extendRule S r =\n  ([],  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r \\<in> Ax", "obtain i xs where \"([], \\<LM> At i \\<RM> \\<Rightarrow>* \\<LM> At i \\<RM>) = r \\<or> r = ([],\\<LM>ff\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  extendRule S r =\n  ([],  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r \\<in> Ax\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) = r \\<or>\n        r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using characteriseAx[where r=r]"], ["proof (prove)\nusing this:\n  extendRule S r =\n  ([],  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r \\<in> Ax\n  r \\<in> Ax \\<Longrightarrow>\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n  (\\<exists>i.\n      r = ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) = r \\<or>\n        r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) = r \\<or>\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) = r \\<or>\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) = r \\<or>\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"r = ([],\\<LM>At i\\<RM> \\<Rightarrow>* \\<LM>At i\\<RM>)\""], ["proof (state)\nthis:\n  r = ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with \\<open>extendRule S r = ([],\\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\\<close>"], ["proof (chain)\npicking this:\n  extendRule S r =\n  ([],  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r = ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)", "have \"extend S (\\<LM> At i \\<RM> \\<Rightarrow>* \\<LM> At i \\<RM>) = (\\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\""], ["proof (prove)\nusing this:\n  extendRule S r =\n  ([],  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r = ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n\ngoal (1 subgoal):\n 1. extend S ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n    ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)", "using extendRule_def[where R=\"([],\\<LM>At i\\<RM> \\<Rightarrow>* \\<LM>At i\\<RM>)\" and forms=S]"], ["proof (prove)\nusing this:\n  extendRule S r =\n  ([],  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r = ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n  extendRule S\n   ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<equiv>\n  (map (extend S)\n    (fst ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)),\n   extend S (snd ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)))\n\ngoal (1 subgoal):\n 1. extend S ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n    ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)", "by auto"], ["proof (state)\nthis:\n  extend S ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  extend S ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)", "have \"At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>\""], ["proof (prove)\nusing this:\n  extend S ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>", "using extendID[where S=S and i=i and \\<Gamma>=\\<Gamma> and \\<Delta>=\"\\<Delta> \\<oplus> Modal M Ms\"]"], ["proof (prove)\nusing this:\n  extend S ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  extend S ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<Longrightarrow>\n  At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>", "by auto"], ["proof (state)\nthis:\n  At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>", "have \"At i \\<in># \\<Gamma> + \\<Gamma>' \\<and> At i \\<in># \\<Delta> + \\<Delta>'\""], ["proof (prove)\nusing this:\n  At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>\n\ngoal (1 subgoal):\n 1. At i \\<in># \\<Gamma> + \\<Gamma>' \\<and> At i \\<in># \\<Delta> + \\<Delta>'", "by auto"], ["proof (state)\nthis:\n  At i \\<in># \\<Gamma> + \\<Gamma>' \\<and> At i \\<in># \\<Delta> + \\<Delta>'\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  At i \\<in># \\<Gamma> + \\<Gamma>' \\<and> At i \\<in># \\<Delta> + \\<Delta>'", "have \"(\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',0) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  At i \\<in># \\<Gamma> + \\<Gamma>' \\<and> At i \\<in># \\<Delta> + \\<Delta>'\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n    \\<in> derivable (ext R R2 M1 M2)", "using rules\n               and containID[where \\<Gamma>=\"\\<Gamma> + \\<Gamma>'\" and i=i and \\<Delta>=\"\\<Delta> + \\<Delta>'\" and R=R]"], ["proof (prove)\nusing this:\n  At i \\<in># \\<Gamma> + \\<Gamma>' \\<and> At i \\<in># \\<Delta> + \\<Delta>'\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  \\<lbrakk>At i \\<in># \\<Gamma> + \\<Gamma>' \\<and>\n           At i \\<in># \\<Delta> + \\<Delta>';\n   Ax \\<subseteq> R\\<rbrakk>\n  \\<Longrightarrow> ( \\<Gamma> +\n                      \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                     0)\n                    \\<in> derivable (ext R ?R' ?M ?N)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n    \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  r =\n  ([],\n    \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  r =\n  ([],\n    \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  r =\n  ([],\n    \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"r = ([],\\<LM>ff\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (state)\nthis:\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with \\<open>extendRule S r = ([],\\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\\<close>"], ["proof (chain)\npicking this:\n  extendRule S r =\n  ([],  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"extend S (\\<LM> ff \\<RM> \\<Rightarrow>* \\<Empt>) = (\\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\""], ["proof (prove)\nusing this:\n  extendRule S r =\n  ([],  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. extend S ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n    ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)", "using extendRule_def[where R=\"([],\\<LM>ff\\<RM> \\<Rightarrow>* \\<Empt>)\" and forms=S]"], ["proof (prove)\nusing this:\n  extendRule S r =\n  ([],  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n  extendRule S ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<equiv>\n  (map (extend S) (fst ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)),\n   extend S (snd ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)))\n\ngoal (1 subgoal):\n 1. extend S ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n    ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)", "by auto"], ["proof (state)\nthis:\n  extend S ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  extend S ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)", "have \"ff \\<in># \\<Gamma>\""], ["proof (prove)\nusing this:\n  extend S ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. ff \\<in># \\<Gamma>", "using extendFalsum[where S=S and \\<Gamma>=\\<Gamma> and \\<Delta>=\"\\<Delta> \\<oplus> Modal M Ms\"]"], ["proof (prove)\nusing this:\n  extend S ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  extend S ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<Longrightarrow>\n  ff \\<in># \\<Gamma>\n\ngoal (1 subgoal):\n 1. ff \\<in># \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  ff \\<in># \\<Gamma>\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  ff \\<in># \\<Gamma>", "have \"ff \\<in># \\<Gamma> + \\<Gamma>'\""], ["proof (prove)\nusing this:\n  ff \\<in># \\<Gamma>\n\ngoal (1 subgoal):\n 1. ff \\<in># \\<Gamma> + \\<Gamma>'", "by auto"], ["proof (state)\nthis:\n  ff \\<in># \\<Gamma> + \\<Gamma>'\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  ff \\<in># \\<Gamma> + \\<Gamma>'", "have \"(\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',0) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  ff \\<in># \\<Gamma> + \\<Gamma>'\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n    \\<in> derivable (ext R R2 M1 M2)", "using rules\n               and containFalsum[where \\<Gamma>=\"\\<Gamma> + \\<Gamma>'\" and \\<Delta>=\"\\<Delta> + \\<Delta>'\" and R=R]"], ["proof (prove)\nusing this:\n  ff \\<in># \\<Gamma> + \\<Gamma>'\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  \\<lbrakk>ff \\<in># \\<Gamma> + \\<Gamma>'; Ax \\<subseteq> R\\<rbrakk>\n  \\<Longrightarrow> ( \\<Gamma> +\n                      \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                     0)\n                    \\<in> derivable (ext R ?R' ?M ?N)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n    \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) = r \\<or>\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n  r =\n  ([],\n    \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)", "have \"(\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',0) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) = r \\<or>\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n  r =\n  ([],\n    \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n    \\<in> derivable (ext R R2 M1 M2)", "by blast"], ["proof (state)\nthis:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)", "show \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "using \\<open>n=0\\<close>"], ["proof (prove)\nusing this:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)\n  n = 0\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "case (Suc n')"], ["proof (state)\nthis:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  n = Suc n'", "have \"(\\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms,n'+1) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, n' + 1)\n    \\<in> derivable (ext R R2 M1 M2)", "using a'"], ["proof (prove)\nusing this:\n  n = Suc n'\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, n)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, n' + 1)\n    \\<in> derivable (ext R R2 M1 M2)", "by simp"], ["proof (state)\nthis:\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)", "obtain Ps where \"(Ps, \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<in> (ext R R2 M1 M2)\" and \n                          \"Ps \\<noteq> []\" and \n                       d':\"\\<forall> p \\<in> set Ps. \\<exists> n\\<le>n'. (p,n) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. (\\<And>Ps.\n        \\<lbrakk>(Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n                 \\<in> ext R R2 M1 M2;\n         Ps \\<noteq> [];\n         \\<forall>p\\<in>set Ps.\n            \\<exists>n\\<le>n'.\n               (p, n) \\<in> derivable (ext R R2 M1 M2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using characteriseLast[where C=\"\\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms\" and m=n' and R=\"ext R R2 M1 M2\"]"], ["proof (prove)\nusing this:\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, n' + 1)\n  \\<in> derivable (ext R R2 M1 M2) \\<Longrightarrow>\n  \\<exists>Ps.\n     Ps \\<noteq> [] \\<and>\n     (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n     \\<in> ext R R2 M1 M2 \\<and>\n     (\\<forall>p\\<in>set Ps.\n         \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2))\n\ngoal (1 subgoal):\n 1. (\\<And>Ps.\n        \\<lbrakk>(Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n                 \\<in> ext R R2 M1 M2;\n         Ps \\<noteq> [];\n         \\<forall>p\\<in>set Ps.\n            \\<exists>n\\<le>n'.\n               (p, n) \\<in> derivable (ext R R2 M1 M2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  \\<in> ext R R2 M1 M2\n  Ps \\<noteq> []\n  \\<forall>p\\<in>set Ps.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  \\<in> ext R R2 M1 M2\n  Ps \\<noteq> []\n  \\<forall>p\\<in>set Ps.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)", "have \"\\<exists> r S. (((r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and> extendRule S r = (Ps, \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)) \\<or>\n                       (r \\<in> p_e R2 M1 M2 \\<and> extendConc S r = (Ps,\\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms))) \\<and> r\\<in>R\""], ["proof (prove)\nusing this:\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  \\<in> ext R R2 M1 M2\n  Ps \\<noteq> []\n  \\<forall>p\\<in>set Ps.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>r S.\n       ((r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n        extendRule S r =\n        (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<or>\n        r \\<in> p_e R2 M1 M2 \\<and>\n        extendConc S r =\n        (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)) \\<and>\n       r \\<in> R", "by (cases) auto"], ["proof (state)\nthis:\n  \\<exists>r S.\n     ((r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n      extendRule S r =\n      (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<or>\n      r \\<in> p_e R2 M1 M2 \\<and>\n      extendConc S r =\n      (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)) \\<and>\n     r \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<exists>r S.\n     ((r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n      extendRule S r =\n      (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<or>\n      r \\<in> p_e R2 M1 M2 \\<and>\n      extendConc S r =\n      (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)) \\<and>\n     r \\<in> R", "obtain r S where ext: \"((r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and> extendRule S r = (Ps, \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms))\n                                \\<or> (r \\<in> p_e R2 M1 M2 \\<and> extendConc S r = (Ps,\\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms))\" and \"r \\<in> R\""], ["proof (prove)\nusing this:\n  \\<exists>r S.\n     ((r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n      extendRule S r =\n      (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<or>\n      r \\<in> p_e R2 M1 M2 \\<and>\n      extendConc S r =\n      (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)) \\<and>\n     r \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<And>r S.\n        \\<lbrakk>(r \\<in> Ax \\<or>\n                  r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n                 extendRule S r =\n                 (Ps,\n                   \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus>\n     Modal M Ms) \\<or>\n                 r \\<in> p_e R2 M1 M2 \\<and>\n                 extendConc S r =\n                 (Ps,\n                   \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms);\n         r \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<or>\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<or>\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<or>\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume ext1: \"(r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and> extendRule S r = (Ps, \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\""], ["proof (state)\nthis:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with \\<open>Ps \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  Ps \\<noteq> []\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)", "have \"r \\<in> upRules \\<or> r \\<in> modRules2\" and \"extendRule S r = (Ps,\\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\""], ["proof (prove)\nusing this:\n  Ps \\<noteq> []\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. r \\<in> upRules \\<or> r \\<in> modRules2 &&&\n    extendRule S r =\n    (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ps \\<noteq> [];\n     extendRule S r =\n     (Ps,  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>);\n     r \\<notin> modRules2; r \\<in> Ax\\<rbrakk>\n    \\<Longrightarrow> r \\<in> upRules", "apply (cases r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>Ps \\<noteq> [];\n        extendRule S r =\n        (Ps,  \\<Gamma> \\<Rightarrow>* add_mset (Modal M Ms) \\<Delta>);\n        r \\<notin> modRules2; r \\<in> Ax; r = (a, b)\\<rbrakk>\n       \\<Longrightarrow> r \\<in> upRules", "by (rule Ax.cases) (auto simp add:extendRule_def)"], ["proof (state)\nthis:\n  r \\<in> upRules \\<or> r \\<in> modRules2\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  r \\<in> upRules \\<or> r \\<in> modRules2\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  r \\<in> upRules \\<or> r \\<in> modRules2\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"r \\<in> upRules\""], ["proof (state)\nthis:\n  r \\<in> upRules\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with \\<open>r \\<in> R\\<close>"], ["proof (chain)\npicking this:\n  r \\<in> R\n  r \\<in> upRules", "have \"r \\<in> R1\""], ["proof (prove)\nusing this:\n  r \\<in> R\n  r \\<in> upRules\n\ngoal (1 subgoal):\n 1. r \\<in> R1", "using rules [[hypsubst_thin=true]]"], ["proof (prove)\nusing this:\n  r \\<in> R\n  r \\<in> upRules\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n\ngoal (1 subgoal):\n 1. r \\<in> R1", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>r \\<in> upRules; R1 \\<subseteq> upRules;\n     R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2; r \\<in> Ax\\<rbrakk>\n    \\<Longrightarrow> r \\<in> R1\n 2. \\<lbrakk>r \\<in> upRules; R1 \\<subseteq> upRules;\n     R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n     r \\<in> p_e R2 M1 M2\\<rbrakk>\n    \\<Longrightarrow> r \\<in> R1\n 3. \\<lbrakk>r \\<in> upRules; R1 \\<subseteq> upRules;\n     R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2; r \\<in> R3\\<rbrakk>\n    \\<Longrightarrow> r \\<in> R1", "apply (insert disjoint)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>r \\<in> upRules; R1 \\<subseteq> upRules;\n     R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2; r \\<in> Ax;\n     Ax \\<inter> upRules = {};\n     \\<And>M N. Ax \\<inter> p_e modRules2 M N = {};\n     Ax \\<inter> modRules2 = {}; upRules \\<inter> modRules2 = {};\n     \\<And>M N. upRules \\<inter> p_e modRules2 M N = {}\\<rbrakk>\n    \\<Longrightarrow> r \\<in> R1\n 2. \\<lbrakk>r \\<in> upRules; R1 \\<subseteq> upRules;\n     R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n     r \\<in> p_e R2 M1 M2; Ax \\<inter> upRules = {};\n     \\<And>M N. Ax \\<inter> p_e modRules2 M N = {};\n     Ax \\<inter> modRules2 = {}; upRules \\<inter> modRules2 = {};\n     \\<And>M N. upRules \\<inter> p_e modRules2 M N = {}\\<rbrakk>\n    \\<Longrightarrow> r \\<in> R1\n 3. \\<lbrakk>r \\<in> upRules; R1 \\<subseteq> upRules;\n     R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2; r \\<in> R3;\n     Ax \\<inter> upRules = {};\n     \\<And>M N. Ax \\<inter> p_e modRules2 M N = {};\n     Ax \\<inter> modRules2 = {}; upRules \\<inter> modRules2 = {};\n     \\<And>M N. upRules \\<inter> p_e modRules2 M N = {}\\<rbrakk>\n    \\<Longrightarrow> r \\<in> R1", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<in> upRules; R1 \\<subseteq> upRules;\n     R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n     r \\<in> p_e R2 M1 M2; Ax \\<inter> upRules = {};\n     \\<And>M N. Ax \\<inter> p_e modRules2 M N = {};\n     Ax \\<inter> modRules2 = {}; upRules \\<inter> modRules2 = {};\n     \\<And>M N. upRules \\<inter> p_e modRules2 M N = {}\\<rbrakk>\n    \\<Longrightarrow> r \\<in> R1", "apply (insert upRuleCharacterise)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<in> upRules; R1 \\<subseteq> upRules;\n     R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n     r \\<in> p_e R2 M1 M2; Ax \\<inter> upRules = {};\n     \\<And>M N. Ax \\<inter> p_e modRules2 M N = {};\n     Ax \\<inter> modRules2 = {}; upRules \\<inter> modRules2 = {};\n     \\<And>M N. upRules \\<inter> p_e modRules2 M N = {};\n     \\<And>Ps C.\n        (Ps, C) \\<in> upRules \\<Longrightarrow>\n        \\<exists>F Fs.\n           C = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F Fs  \\<RM>) \\<or>\n           C = ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n    \\<Longrightarrow> r \\<in> R1", "apply (rotate_tac 10)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>Ps C.\n                (Ps, C) \\<in> upRules \\<Longrightarrow>\n                \\<exists>F Fs.\n                   C =\n                   ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F\n             Fs  \\<RM>) \\<or>\n                   C = ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r \\<in> upRules; R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n     R3 \\<subseteq> modRules2; r \\<in> p_e R2 M1 M2;\n     Ax \\<inter> upRules = {};\n     \\<And>M N. Ax \\<inter> p_e modRules2 M N = {};\n     Ax \\<inter> modRules2 = {}; upRules \\<inter> modRules2 = {};\n     \\<And>M N. upRules \\<inter> p_e modRules2 M N = {}\\<rbrakk>\n    \\<Longrightarrow> r \\<in> R1", "apply (drule_tac x=\"fst r\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<in> upRules; R1 \\<subseteq> upRules;\n     R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n     r \\<in> p_e R2 M1 M2; Ax \\<inter> upRules = {};\n     \\<And>M N. Ax \\<inter> p_e modRules2 M N = {};\n     Ax \\<inter> modRules2 = {}; upRules \\<inter> modRules2 = {};\n     \\<And>M N. upRules \\<inter> p_e modRules2 M N = {};\n     \\<And>C.\n        (fst r, C) \\<in> upRules \\<Longrightarrow>\n        \\<exists>F Fs.\n           C = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F Fs  \\<RM>) \\<or>\n           C = ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n    \\<Longrightarrow> r \\<in> R1", "apply (rotate_tac 10)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>C.\n                (fst r, C) \\<in> upRules \\<Longrightarrow>\n                \\<exists>F Fs.\n                   C =\n                   ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F\n             Fs  \\<RM>) \\<or>\n                   C = ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r \\<in> upRules; R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n     R3 \\<subseteq> modRules2; r \\<in> p_e R2 M1 M2;\n     Ax \\<inter> upRules = {};\n     \\<And>M N. Ax \\<inter> p_e modRules2 M N = {};\n     Ax \\<inter> modRules2 = {}; upRules \\<inter> modRules2 = {};\n     \\<And>M N. upRules \\<inter> p_e modRules2 M N = {}\\<rbrakk>\n    \\<Longrightarrow> r \\<in> R1", "apply (drule_tac x=\"snd r\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<in> upRules; R1 \\<subseteq> upRules;\n     R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n     r \\<in> p_e R2 M1 M2; Ax \\<inter> upRules = {};\n     \\<And>M N. Ax \\<inter> p_e modRules2 M N = {};\n     Ax \\<inter> modRules2 = {}; upRules \\<inter> modRules2 = {};\n     \\<And>M N. upRules \\<inter> p_e modRules2 M N = {};\n     (fst r, snd r) \\<in> upRules \\<Longrightarrow>\n     \\<exists>F Fs.\n        snd r = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F Fs  \\<RM>) \\<or>\n        snd r =\n        ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n    \\<Longrightarrow> r \\<in> R1", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<in> upRules; R1 \\<subseteq> upRules;\n     R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n     r \\<in> p_e R2 M1 M2; Ax \\<inter> upRules = {};\n     \\<And>M N. Ax \\<inter> p_e modRules2 M N = {};\n     Ax \\<inter> modRules2 = {}; upRules \\<inter> modRules2 = {};\n     \\<And>M N. upRules \\<inter> p_e modRules2 M N = {};\n     \\<exists>F Fs.\n        snd r = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F Fs  \\<RM>) \\<or>\n        snd r =\n        ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n    \\<Longrightarrow> r \\<in> R1", "apply (elim exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F Fs.\n       \\<lbrakk>r \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        r \\<in> p_e R2 M1 M2; Ax \\<inter> upRules = {};\n        \\<And>M N. Ax \\<inter> p_e modRules2 M N = {};\n        Ax \\<inter> modRules2 = {}; upRules \\<inter> modRules2 = {};\n        \\<And>M N. upRules \\<inter> p_e modRules2 M N = {};\n        snd r = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F Fs  \\<RM>) \\<or>\n        snd r =\n        ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n       \\<Longrightarrow> r \\<in> R1", "apply (insert modRule1Characterise[where Ps=\"fst r\" and C=\"snd r\" and R=R2 and M=M1 and N=M2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>F Fs.\n       \\<lbrakk>r \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        r \\<in> p_e R2 M1 M2; Ax \\<inter> upRules = {};\n        \\<And>M N. Ax \\<inter> p_e modRules2 M N = {};\n        Ax \\<inter> modRules2 = {}; upRules \\<inter> modRules2 = {};\n        \\<And>M N. upRules \\<inter> p_e modRules2 M N = {};\n        snd r = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F Fs  \\<RM>) \\<or>\n        snd r = ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>);\n        \\<lbrakk>(fst r, snd r) \\<in> p_e R2 M1 M2;\n         R2 \\<subseteq> modRules2\\<rbrakk>\n        \\<Longrightarrow> \\<exists>F Fs \\<Gamma> \\<Delta> ps ra.\n                             (fst r, snd r) =\n                             extendRule\n                              ( M1 \\<cdot>\n                                \\<Gamma> \\<Rightarrow>* M2 \\<cdot> \\<Delta>)\n                              ra \\<and>\n                             ra \\<in> R2 \\<and>\n                             (ra =\n                              (ps,\n                                \\<Empt> \\<Rightarrow>* \\<LM> Modal F\n                        Fs  \\<RM>) \\<or>\n                              ra =\n                              (ps,\n                                \\<LM> Modal F\n Fs  \\<RM> \\<Rightarrow>* \\<Empt>))\\<rbrakk>\n       \\<Longrightarrow> r \\<in> R1", "by (auto simp add:extendRule_def extend_def)"], ["proof (state)\nthis:\n  r \\<in> R1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with rules"], ["proof (chain)\npicking this:\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  r \\<in> R1", "have \"r \\<in> R'\""], ["proof (prove)\nusing this:\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  r \\<in> R1\n\ngoal (1 subgoal):\n 1. r \\<in> R'", "by auto"], ["proof (state)\nthis:\n  r \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "obtain ps c where \"r = (ps,c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps c. r = (ps, c) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases r) auto"], ["proof (state)\nthis:\n  r = (ps, c)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with \\<open>r \\<in> upRules\\<close>"], ["proof (chain)\npicking this:\n  r \\<in> upRules\n  r = (ps, c)", "obtain T Ts where sw:\"c = (\\<Empt> \\<Rightarrow>* \\<LM>Compound T Ts\\<RM>) \\<or> \n                                                   c = (\\<LM>Compound T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  r \\<in> upRules\n  r = (ps, c)\n\ngoal (1 subgoal):\n 1. (\\<And>T Ts.\n        c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n        c =\n        ( \\<LM> Compound T\n                 Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using upRuleCharacterise[where Ps=ps and C=c]"], ["proof (prove)\nusing this:\n  r \\<in> upRules\n  r = (ps, c)\n  (ps, c) \\<in> upRules \\<Longrightarrow>\n  \\<exists>F Fs.\n     c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F Fs  \\<RM>) \\<or>\n     c = ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. (\\<And>T Ts.\n        c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n        c =\n        ( \\<LM> Compound T\n                 Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "have \"(rightPrincipal r (Modal M Ms) R') \\<or> \\<not>(rightPrincipal r (Modal M Ms) R')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rightPrincipal r (Modal M Ms) R' \\<or>\n    \\<not> rightPrincipal r (Modal M Ms) R'", "by blast"], ["proof (state)\nthis:\n  rightPrincipal r (Modal M Ms) R' \\<or>\n  \\<not> rightPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  rightPrincipal r (Modal M Ms) R' \\<or>\n  \\<not> rightPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  rightPrincipal r (Modal M Ms) R' \\<or>\n  \\<not> rightPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"rightPrincipal r (Modal M Ms) R'\""], ["proof (state)\nthis:\n  rightPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  rightPrincipal r (Modal M Ms) R'", "have \"c = (\\<Empt> \\<Rightarrow>* \\<LM>Modal M Ms\\<RM>)\""], ["proof (prove)\nusing this:\n  rightPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal M Ms  \\<RM>)", "using \\<open>r = (ps,c)\\<close>"], ["proof (prove)\nusing this:\n  rightPrincipal r (Modal M Ms) R'\n  r = (ps, c)\n\ngoal (1 subgoal):\n 1. c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal M Ms  \\<RM>)", "by (cases) auto"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal M Ms  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with sw and \\<open>r \\<in> R'\\<close>"], ["proof (chain)\npicking this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  r \\<in> R'\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal M Ms  \\<RM>)", "have \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  r \\<in> R'\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal M Ms  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  rightPrincipal r (Modal M Ms) R' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  rightPrincipal r (Modal M Ms) R' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  rightPrincipal r (Modal M Ms) R' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"\\<not> rightPrincipal r (Modal M Ms) R'\""], ["proof (state)\nthis:\n  \\<not> rightPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<not> rightPrincipal r (Modal M Ms) R'", "have \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  \\<not> rightPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "using IH and a' b' d' \\<open>Ps \\<noteq> []\\<close>\n                      and nonPrincipalInvertRight[where ?R1.0=R1 and ?R2.0=R2 and ?R3.0=R3 and R=R and n=n\n                                                  and \\<Gamma>=\\<Gamma> and \\<Delta>=\\<Delta> and M=M and Ms=Ms and r=r and S=S\n                                                  and \\<Gamma>'=\\<Gamma>' and \\<Delta>'=\\<Delta>' and n'=n' and Ps=Ps and ps=ps \n                                                  and c=c and R'=R' and ?M1.0=M1 and ?M2.0=M2]\n                      and \\<open>n = Suc n'\\<close> and ext1 and rules and \\<open>r = (ps,c)\\<close> and \\<open>r \\<in> R\\<close>"], ["proof (prove)\nusing this:\n  \\<not> rightPrincipal r (Modal M Ms) R'\n  \\<forall>m<n.\n     \\<forall>\\<Gamma> \\<Delta>.\n        ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, m)\n        \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n        (\\<forall>r'\\<in>R'.\n            rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n            ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n            \\<in> set (fst r')) \\<longrightarrow>\n        (\\<exists>m'\\<le>m.\n            ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m')\n            \\<in> derivable (ext R R2 M1 M2))\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, n)\n  \\<in> derivable (ext R R2 M1 M2)\n  \\<forall>r'\\<in>R'.\n     rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\n  \\<forall>p\\<in>set Ps.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n  Ps \\<noteq> []\n  \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n   R3 \\<subseteq> modRules2;\n   R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3; r \\<in> R;\n   r = (ps, c); R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n   \\<forall>m<n.\n      \\<forall>\\<Gamma> \\<Delta>.\n         ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, m)\n         \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n         (\\<forall>r'\\<in>R'.\n             rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n             ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n             \\<in> set (fst r')) \\<longrightarrow>\n         (\\<exists>m'\\<le>m.\n             ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m')\n             \\<in> derivable (ext R R2 M1 M2));\n   ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, n)\n   \\<in> derivable (ext R R2 M1 M2);\n   \\<forall>r'\\<in>R'.\n      rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n      ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r');\n   \\<not> rightPrincipal r (Modal M Ms) R';\n   (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n   extendRule S r =\n   (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms);\n   n = n' + 1;\n   \\<forall>p\\<in>set Ps.\n      \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2);\n   Ps \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m\\<le>n.\n                       ( \\<Gamma> +\n                         \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                        m)\n                       \\<in> derivable (ext R R2 M1 M2)\n  n = Suc n'\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  r = (ps, c)\n  r \\<in> R\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  \\<not> rightPrincipal r (Modal M Ms) R' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  rightPrincipal r (Modal M Ms) R' \\<or>\n  \\<not> rightPrincipal r (Modal M Ms) R'\n  rightPrincipal r (Modal M Ms) R' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  \\<not> rightPrincipal r (Modal M Ms) R' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)", "have \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  rightPrincipal r (Modal M Ms) R' \\<or>\n  \\<not> rightPrincipal r (Modal M Ms) R'\n  rightPrincipal r (Modal M Ms) R' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  \\<not> rightPrincipal r (Modal M Ms) R' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  r \\<in> upRules \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  r \\<in> upRules \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "(*>*)"], ["proof (state)\nthis:\n  r \\<in> upRules \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "txt\\<open>\\noindent This is the case where the last inference was a normal modal inference:\\<close>"], ["proof (state)\nthis:\n  r \\<in> upRules \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  r \\<in> upRules \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"r \\<in> modRules2\""], ["proof (state)\nthis:\n  r \\<in> modRules2\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "obtain ps c where \"r = (ps,c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ps c. r = (ps, c) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases r) auto"], ["proof (state)\nthis:\n  r = (ps, c)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with \\<open>r \\<in> modRules2\\<close>"], ["proof (chain)\npicking this:\n  r \\<in> modRules2\n  r = (ps, c)", "obtain T Ts where \"c = (\\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts \\<RM>) \\<or> \n            c = (\\<LM> Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  r \\<in> modRules2\n  r = (ps, c)\n\ngoal (1 subgoal):\n 1. (\\<And>T Ts.\n        c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n        c =\n        ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using modRule2Characterise[where Ps=ps and C=c]"], ["proof (prove)\nusing this:\n  r \\<in> modRules2\n  r = (ps, c)\n  (ps, c) \\<in> modRules2 \\<Longrightarrow>\n  ps \\<noteq> [] \\<and>\n  (\\<exists>F Fs.\n      c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n      c = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))\n\ngoal (1 subgoal):\n 1. (\\<And>T Ts.\n        c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n        c =\n        ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"c = (\\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts \\<RM>)\""], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)", "have bb: \"rightPrincipal r (Modal T Ts) R'\""], ["proof (prove)\nusing this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n\ngoal (1 subgoal):\n 1. rightPrincipal r (Modal T Ts) R'", "using \\<open>r = (ps,c)\\<close> and \\<open>r \\<in> R\\<close>"], ["proof (prove)\nusing this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  r = (ps, c)\n  r \\<in> R\n\ngoal (1 subgoal):\n 1. rightPrincipal r (Modal T Ts) R'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "txt\\<open>\\noindent We need to know $r \\in R$ so that we can extend the active part\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "from \\<open>c = (\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>)\\<close> and \n           \\<open>r = (ps,c)\\<close> and \n           \\<open>r \\<in> R\\<close> and \n           \\<open>r \\<in> modRules2\\<close>"], ["proof (chain)\npicking this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  r = (ps, c)\n  r \\<in> R\n  r \\<in> modRules2", "have \"(ps,\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<in> R\""], ["proof (prove)\nusing this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  r = (ps, c)\n  r \\<in> R\n  r \\<in> modRules2\n\ngoal (1 subgoal):\n 1. (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "with rules"], ["proof (chain)\npicking this:\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R", "have \"(ps,  \\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<in> p_e R2 M1 M2 \\<or>\n         (ps,  \\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<in> R3\""], ["proof (prove)\nusing this:\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R\n\ngoal (1 subgoal):\n 1. (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n    \\<in> p_e R2 M1 M2 \\<or>\n    (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R3", "(*<*)"], ["proof (prove)\nusing this:\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R\n\ngoal (1 subgoal):\n 1. (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n    \\<in> p_e R2 M1 M2 \\<or>\n    (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R3", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n     R3 \\<subseteq> modRules2;\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> Ax\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                      \\<in> p_e R2 M1 M2\n 2. \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n     R3 \\<subseteq> modRules2;\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R1\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                      \\<in> p_e R2 M1 M2", "apply (rule Ax.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n     R3 \\<subseteq> modRules2;\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> Ax\\<rbrakk>\n    \\<Longrightarrow> (?a1.14, ?a2.14) \\<in> Ax\n 2. \\<And>i.\n       \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n        (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> Ax;\n        ?a1.14 = [];\n        ?a2.14 =\n        ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\\<rbrakk>\n       \\<Longrightarrow> (ps,\n                           \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                         \\<in> p_e R2 M1 M2\n 3. \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n     R3 \\<subseteq> modRules2;\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> Ax;\n     ?a1.14 = [];\n     ?a2.14 = ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                      \\<in> p_e R2 M1 M2\n 4. \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n     R3 \\<subseteq> modRules2;\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R1\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                      \\<in> p_e R2 M1 M2", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n     R3 \\<subseteq> modRules2;\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R1\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                      \\<in> p_e R2 M1 M2", "apply (subgoal_tac \"(ps,\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<in> upRules\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n     R3 \\<subseteq> modRules2;\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R1;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n     \\<in> upRules\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                      \\<in> p_e R2 M1 M2\n 2. \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n     R3 \\<subseteq> modRules2;\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R1\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                      \\<in> upRules", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n     R3 \\<subseteq> modRules2;\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R1;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n     \\<in> upRules\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                      \\<in> p_e R2 M1 M2", "apply (rule upRules.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n     R3 \\<subseteq> modRules2;\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R1;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n     \\<in> upRules\\<rbrakk>\n    \\<Longrightarrow> (?a1.103, ?a2.103) \\<in> upRules\n 2. \\<And>c Ra Fs psa.\n       \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n        (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R1;\n        (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> upRules;\n        ?a1.103 = psa; ?a2.103 = c;\n        ModalSequents.mset c = \\<LM> Compound Ra Fs  \\<RM>;\n        psa \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (ps,\n                           \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                         \\<in> p_e R2 M1 M2", "(*>*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n     R3 \\<subseteq> modRules2;\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R1;\n     (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n     \\<in> upRules\\<rbrakk>\n    \\<Longrightarrow> (?a1.103, ?a2.103) \\<in> upRules\n 2. \\<And>c Ra Fs psa.\n       \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<notin> R3;\n        (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R1;\n        (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> upRules;\n        ?a1.103 = psa; ?a2.103 = c;\n        ModalSequents.mset c = \\<LM> Compound Ra Fs  \\<RM>;\n        psa \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (ps,\n                           \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                         \\<in> p_e R2 M1 M2", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  \\<in> p_e R2 M1 M2 \\<or>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "moreover"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  \\<in> p_e R2 M1 M2 \\<or>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "{"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  \\<in> p_e R2 M1 M2 \\<or>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "assume \"(ps, \\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<in> R3\""], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R3", "have \"(ps, \\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<in> R'\""], ["proof (prove)\nusing this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R3\n\ngoal (1 subgoal):\n 1. (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'", "using rules"], ["proof (prove)\nusing this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R3\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n\ngoal (1 subgoal):\n 1. (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "}"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  \\<in> R3 \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "moreover"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  \\<in> R3 \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "{"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  \\<in> R3 \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "assume \"(ps,\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<in> p_e R2 M1 M2\""], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> p_e R2 M1 M2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "txt\\<open>\\noindent In this case, we show that $\\Delta'$ and $\\Gamma'$ must be empty.  The details are generally suppressed:\\<close>"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> p_e R2 M1 M2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> p_e R2 M1 M2", "obtain \\<Gamma>' \\<Delta>' r' \n  where aa: \"(ps, \\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) = extendRule (M1\\<cdot>\\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>') r' \n            \\<and> r' \\<in> R2\""], ["proof (prove)\nusing this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> p_e R2 M1 M2\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' \\<Delta>' r'.\n        (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n        extendRule\n         ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n         r' \\<and>\n        r' \\<in> R2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "(*<*)"], ["proof (prove)\nusing this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> p_e R2 M1 M2\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' \\<Delta>' r'.\n        (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n        extendRule\n         ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n         r' \\<and>\n        r' \\<in> R2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply (rule p_e.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps c \\<Gamma> \\<Delta>.\n       \\<lbrakk>\\<And>\\<Gamma>' \\<Delta>' r'.\n                   (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n                   extendRule\n                    ( M1 \\<cdot>\n                      \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n                    r' \\<and>\n                   r' \\<in> R2 \\<Longrightarrow>\n                   thesis;\n        (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n        extendRule ( M1 \\<cdot> \\<Gamma> \\<Rightarrow>* M2 \\<cdot> \\<Delta>)\n         (Ps, c);\n        (Ps, c) \\<in> R2; R2 \\<subseteq> modRules2\\<rbrakk>\n       \\<Longrightarrow> thesis", "(*>*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps c \\<Gamma> \\<Delta>.\n       \\<lbrakk>\\<And>\\<Gamma>' \\<Delta>' r'.\n                   (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n                   extendRule\n                    ( M1 \\<cdot>\n                      \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n                    r' \\<and>\n                   r' \\<in> R2 \\<Longrightarrow>\n                   thesis;\n        (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n        extendRule ( M1 \\<cdot> \\<Gamma> \\<Rightarrow>* M2 \\<cdot> \\<Delta>)\n         (Ps, c);\n        (Ps, c) \\<in> R2; R2 \\<subseteq> modRules2\\<rbrakk>\n       \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "(*<*)"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2", "have \"r' \\<in> modRules2\""], ["proof (prove)\nusing this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n\ngoal (1 subgoal):\n 1. r' \\<in> modRules2", "using rules"], ["proof (prove)\nusing this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n\ngoal (1 subgoal):\n 1. r' \\<in> modRules2", "by auto"], ["proof (state)\nthis:\n  r' \\<in> modRules2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  r' \\<in> modRules2", "obtain F Fs where \n                                   \"snd r' = (\\<Empt> \\<Rightarrow>* \\<LM>Modal F Fs\\<RM>) \\<or> snd r' = (\\<LM>Modal F Fs\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  r' \\<in> modRules2\n\ngoal (1 subgoal):\n 1. (\\<And>F Fs.\n        snd r' = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n        snd r' =\n        ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using modRule2Characterise[where Ps=\"fst r'\" and C=\"snd r'\"]"], ["proof (prove)\nusing this:\n  r' \\<in> modRules2\n  (fst r', snd r') \\<in> modRules2 \\<Longrightarrow>\n  fst r' \\<noteq> [] \\<and>\n  (\\<exists>F Fs.\n      snd r' = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n      snd r' = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))\n\ngoal (1 subgoal):\n 1. (\\<And>F Fs.\n        snd r' = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n        snd r' =\n        ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  snd r' = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n  snd r' = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "with aa"], ["proof (chain)\npicking this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n  snd r' = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n  snd r' = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"(\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) = (M1\\<cdot>\\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>' \\<oplus> Modal F Fs) \\<or>\n                                            (\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) = (M1\\<cdot>\\<Gamma>' \\<oplus> Modal F Fs \\<Rightarrow>* M2\\<cdot>\\<Delta>')\""], ["proof (prove)\nusing this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n  snd r' = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n  snd r' = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n    ( M1 \\<cdot>\n      \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus>\n                               Modal F Fs) \\<or>\n    ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n    ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n      Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')", "by (auto simp add:extendRule_def extend_def)"], ["proof (state)\nthis:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs) \\<or>\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "moreover"], ["proof (state)\nthis:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs) \\<or>\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "{"], ["proof (state)\nthis:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs) \\<or>\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "assume \"(\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) = (M1\\<cdot>\\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>' \\<oplus> Modal F Fs)\""], ["proof (state)\nthis:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs)", "have \"M1\\<cdot>\\<Gamma>' = \\<Empt>\" and \"\\<LM>Modal T Ts\\<RM> = M2\\<cdot>\\<Delta>' \\<oplus> Modal F Fs\""], ["proof (prove)\nusing this:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs)\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>' = \\<Empt> &&&\n    \\<LM> Modal T Ts  \\<RM> = M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs", "by auto"], ["proof (state)\nthis:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  \\<LM> Modal T Ts  \\<RM> = M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "(*>*)"], ["proof (state)\nthis:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  \\<LM> Modal T Ts  \\<RM> = M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  \\<LM> Modal T Ts  \\<RM> = M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs", "have \"M1\\<cdot>\\<Gamma>' = \\<Empt>\" (*<*)and \"Modal T Ts = Modal F Fs\"(*>*) and \"M2\\<cdot>\\<Delta>' = \\<Empt>\""], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  \\<LM> Modal T Ts  \\<RM> = M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>' = \\<Empt> &&&\n    Modal T Ts = Modal F Fs &&& M2 \\<cdot> \\<Delta>' = \\<Empt>", "(*<*)"], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  \\<LM> Modal T Ts  \\<RM> = M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>' = \\<Empt> &&&\n    Modal T Ts = Modal F Fs &&& M2 \\<cdot> \\<Delta>' = \\<Empt>", "using \n                                       singleton_add_means_equal[where A=\"Modal T Ts\" and \\<Gamma>=\"M2\\<cdot>\\<Delta>'\" and B=\"Modal F Fs\"]\n                                       and singleton_add_means_empty[where A=\"Modal T Ts\" and \\<Gamma>=\"M2\\<cdot>\\<Delta>'\" and B=\"Modal F Fs\"]"], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  \\<LM> Modal T Ts  \\<RM> = M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs\n  \\<LM> Modal T Ts  \\<RM> =\n  M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs \\<Longrightarrow>\n  Modal T Ts = Modal F Fs\n  \\<LM> Modal T Ts  \\<RM> =\n  M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs \\<Longrightarrow>\n  M2 \\<cdot> \\<Delta>' = \\<Empt>\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>' = \\<Empt> &&&\n    Modal T Ts = Modal F Fs &&& M2 \\<cdot> \\<Delta>' = \\<Empt>", "(*>*)"], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  \\<LM> Modal T Ts  \\<RM> = M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs\n  \\<LM> Modal T Ts  \\<RM> =\n  M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs \\<Longrightarrow>\n  Modal T Ts = Modal F Fs\n  \\<LM> Modal T Ts  \\<RM> =\n  M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs \\<Longrightarrow>\n  M2 \\<cdot> \\<Delta>' = \\<Empt>\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>' = \\<Empt> &&&\n    Modal T Ts = Modal F Fs &&& M2 \\<cdot> \\<Delta>' = \\<Empt>", "by (auto simp add:modaliseMultiset_def)"], ["proof (state)\nthis:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  Modal T Ts = Modal F Fs\n  M2 \\<cdot> \\<Delta>' = \\<Empt>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "(*<*)"], ["proof (state)\nthis:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  Modal T Ts = Modal F Fs\n  M2 \\<cdot> \\<Delta>' = \\<Empt>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  Modal T Ts = Modal F Fs\n  M2 \\<cdot> \\<Delta>' = \\<Empt>", "have \"extendRule (M1\\<cdot>\\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>') r' = r'\""], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  Modal T Ts = Modal F Fs\n  M2 \\<cdot> \\<Delta>' = \\<Empt>\n\ngoal (1 subgoal):\n 1. extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n     r' =\n    r'", "using extendRuleEmpty[where r=r']"], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  Modal T Ts = Modal F Fs\n  M2 \\<cdot> \\<Delta>' = \\<Empt>\n  extendRule ( \\<Empt> \\<Rightarrow>* \\<Empt>) r' = r'\n\ngoal (1 subgoal):\n 1. extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n     r' =\n    r'", "by auto"], ["proof (state)\nthis:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' =\n  r'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' =\n  r'", "have \"extendRule (M1\\<cdot>\\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>') r' \\<in> R2\""], ["proof (prove)\nusing this:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' =\n  r'\n\ngoal (1 subgoal):\n 1. extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n     r'\n    \\<in> R2", "using aa"], ["proof (prove)\nusing this:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' =\n  r'\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n\ngoal (1 subgoal):\n 1. extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n     r'\n    \\<in> R2", "by auto"], ["proof (state)\nthis:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>') r'\n  \\<in> R2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>') r'\n  \\<in> R2", "have \"(ps,\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<in> R2\""], ["proof (prove)\nusing this:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>') r'\n  \\<in> R2\n\ngoal (1 subgoal):\n 1. (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R2", "using aa"], ["proof (prove)\nusing this:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>') r'\n  \\<in> R2\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n\ngoal (1 subgoal):\n 1. (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R2", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R2", "have \"(ps,\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<in> R'\""], ["proof (prove)\nusing this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R2\n\ngoal (1 subgoal):\n 1. (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'", "using rules"], ["proof (prove)\nusing this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R2\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n\ngoal (1 subgoal):\n 1. (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'", "by simp"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "}"], ["proof (state)\nthis:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus>\n                             Modal F Fs) \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "moreover"], ["proof (state)\nthis:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus>\n                             Modal F Fs) \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "{"], ["proof (state)\nthis:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus>\n                             Modal F Fs) \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "assume \"(\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) = (M1\\<cdot>\\<Gamma>' \\<oplus> Modal F Fs \\<Rightarrow>* M2\\<cdot>\\<Delta>')\""], ["proof (state)\nthis:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')", "have \"\\<Empt> = M1\\<cdot>\\<Gamma>' \\<oplus> Modal F Fs\""], ["proof (prove)\nusing this:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<Empt> = M1 \\<cdot> \\<Gamma>' \\<oplus> Modal F Fs", "by auto"], ["proof (state)\nthis:\n  \\<Empt> = M1 \\<cdot> \\<Gamma>' \\<oplus> Modal F Fs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  \\<Empt> = M1 \\<cdot> \\<Gamma>' \\<oplus> Modal F Fs", "have \"(ps, \\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<in> R'\""], ["proof (prove)\nusing this:\n  \\<Empt> = M1 \\<cdot> \\<Gamma>' \\<oplus> Modal F Fs\n\ngoal (1 subgoal):\n 1. (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "}"], ["proof (state)\nthis:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>') \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "ultimately"], ["proof (chain)\npicking this:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs) \\<or>\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus>\n                             Modal F Fs) \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>') \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'", "have \"(ps,\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<in> R'\""], ["proof (prove)\nusing this:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs) \\<or>\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus>\n                             Modal F Fs) \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n  ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>') \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'", "by blast"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "}"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "ultimately"], ["proof (chain)\npicking this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  \\<in> p_e R2 M1 M2 \\<or>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R3\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  \\<in> R3 \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'", "have \"(ps,\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>) \\<in> R'\""], ["proof (prove)\nusing this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  \\<in> p_e R2 M1 M2 \\<or>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R3\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  \\<in> R3 \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'", "show ?thesis"], ["proof (prove)\nusing this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n\ngoal (1 subgoal):\n 1. rightPrincipal r (Modal T Ts) R'", "using \\<open>r = (ps,c)\\<close> and \\<open>c = (\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>)\\<close>"], ["proof (prove)\nusing this:\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R'\n  r = (ps, c)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n\ngoal (1 subgoal):\n 1. rightPrincipal r (Modal T Ts) R'", "by auto"], ["proof (state)\nthis:\n  rightPrincipal r (Modal T Ts) R'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rightPrincipal r (Modal T Ts) R'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "have \"Modal T Ts = Modal M Ms \\<or> Modal T Ts \\<noteq> Modal M Ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Modal T Ts = Modal M Ms \\<or> Modal T Ts \\<noteq> Modal M Ms", "by blast"], ["proof (state)\nthis:\n  Modal T Ts = Modal M Ms \\<or> Modal T Ts \\<noteq> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  Modal T Ts = Modal M Ms \\<or> Modal T Ts \\<noteq> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  Modal T Ts = Modal M Ms \\<or> Modal T Ts \\<noteq> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"Modal T Ts = Modal M Ms\""], ["proof (state)\nthis:\n  Modal T Ts = Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with bb"], ["proof (chain)\npicking this:\n  rightPrincipal r (Modal T Ts) R'\n  Modal T Ts = Modal M Ms", "have \"rightPrincipal r (Modal M Ms) R'\""], ["proof (prove)\nusing this:\n  rightPrincipal r (Modal T Ts) R'\n  Modal T Ts = Modal M Ms\n\ngoal (1 subgoal):\n 1. rightPrincipal r (Modal M Ms) R'", "by auto"], ["proof (state)\nthis:\n  rightPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with b'"], ["proof (chain)\npicking this:\n  \\<forall>r'\\<in>R'.\n     rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\n  rightPrincipal r (Modal M Ms) R'", "have \"(\\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r)\""], ["proof (prove)\nusing this:\n  \\<forall>r'\\<in>R'.\n     rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\n  rightPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r)", "apply-"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>r'\\<in>R'.\n                rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n                ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r');\n     rightPrincipal r (Modal M Ms) R'\\<rbrakk>\n    \\<Longrightarrow> ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n                      \\<in> set (fst r)", "by (rule rightPrincipal.cases) auto"], ["proof (state)\nthis:\n  ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "from \\<open>r = (ps,c)\\<close> and \\<open>c = (\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>)\\<close> and \\<open>Modal T Ts = Modal M Ms\\<close>\n                                 and \\<open>extendRule S r = (Ps,\\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\\<close>"], ["proof (chain)\npicking this:\n  r = (ps, c)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  Modal T Ts = Modal M Ms\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)", "have \"S = (\\<Gamma> \\<Rightarrow>* \\<Delta>)\""], ["proof (prove)\nusing this:\n  r = (ps, c)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  Modal T Ts = Modal M Ms\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. S = ( \\<Gamma> \\<Rightarrow>* \\<Delta>)", "apply (auto simp add:extendRule_def extend_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal M Ms  \\<RM>);\n     c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal M Ms  \\<RM>); T = M; Ts = Ms;\n     Ps = map (extend S) ps; \\<Gamma> = antec S; \\<Delta> = succ S\\<rbrakk>\n    \\<Longrightarrow> S = ( antec S \\<Rightarrow>* succ S)", "by (cases S) auto"], ["proof (state)\nthis:\n  S = ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r)\n  S = ( \\<Gamma> \\<Rightarrow>* \\<Delta>)", "have \"(\\<Gamma>+\\<Gamma>' \\<Rightarrow>* \\<Delta>+\\<Delta>') \\<in> set Ps\""], ["proof (prove)\nusing this:\n  ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r)\n  S = ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') \\<in> set Ps", "using extendContain[where r=r and ps=ps and c=c and Ps=Ps \n                                               and C=\"\\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms\" and S=\"\\<Gamma> \\<Rightarrow>* \\<Delta>\" and p=\"\\<Gamma>'\\<Rightarrow>*\\<Delta>'\"]\n                             and \\<open>r = (ps,c)\\<close> and \\<open>extendRule S r = (Ps,\\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\\<close>"], ["proof (prove)\nusing this:\n  ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r)\n  S = ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n  \\<lbrakk>r = (ps, c);\n   (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) =\n   extendRule ( \\<Gamma> \\<Rightarrow>* \\<Delta>) r;\n   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set ps\\<rbrakk>\n  \\<Longrightarrow> extend ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n                     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n                    \\<in> set Ps\n  r = (ps, c)\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') \\<in> set Ps", "by (auto simp add:extend_def)"], ["proof (state)\nthis:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with d'"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set Ps.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') \\<in> set Ps", "have \"\\<exists> n\\<le>n'. (\\<Gamma>+\\<Gamma>' \\<Rightarrow>* \\<Delta>+\\<Delta>',n) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<le>n'.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n       \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>n\\<le>n'.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with \\<open>n = Suc n'\\<close>"], ["proof (chain)\npicking this:\n  n = Suc n'\n  \\<exists>n\\<le>n'.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n     \\<in> derivable (ext R R2 M1 M2)", "have \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  n = Suc n'\n  \\<exists>n\\<le>n'.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n = Suc n'; n \\<le> n';\n        ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n        \\<in> derivable (ext R R2 M1 M2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<le>Suc n'.\n                            ( \\<Gamma> +\n                              \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2)", "apply (rule_tac x=n in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n = Suc n'; n \\<le> n';\n        ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n)\n        \\<in> derivable (ext R R2 M1 M2)\\<rbrakk>\n       \\<Longrightarrow> n \\<le> Suc n' \\<and>\n                         ( \\<Gamma> +\n                           \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                          n)\n                         \\<in> derivable (ext R R2 M1 M2)", "by arith"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  Modal T Ts = Modal M Ms \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  Modal T Ts = Modal M Ms \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  Modal T Ts = Modal M Ms \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"Modal T Ts \\<noteq> Modal M Ms\""], ["proof (state)\nthis:\n  Modal T Ts \\<noteq> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with bb"], ["proof (chain)\npicking this:\n  rightPrincipal r (Modal T Ts) R'\n  Modal T Ts \\<noteq> Modal M Ms", "have \"\\<not> rightPrincipal r (Modal M Ms) R'\""], ["proof (prove)\nusing this:\n  rightPrincipal r (Modal T Ts) R'\n  Modal T Ts \\<noteq> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (Modal M Ms) R'", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rightPrincipal r (Modal T Ts) R';\n     rightPrincipal r (Modal M Ms) R'; T \\<noteq> M\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>rightPrincipal r (Modal T Ts) R';\n     rightPrincipal r (Modal M Ms) R'; Ts \\<noteq> Ms\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule rightPrincipal.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>rightPrincipal r (Modal T Ts) R';\n     rightPrincipal r (Modal M Ms) R'; T \\<noteq> M\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal ?a1.4 ?a2.4 ?a3.4\n 2. \\<And>C A Ps R.\n       \\<lbrakk>rightPrincipal r (Modal T Ts) R';\n        rightPrincipal r (Modal M Ms) R'; T \\<noteq> M; ?a1.4 = (Ps, C);\n        ?a2.4 = A; ?a3.4 = R; C = ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>);\n        (Ps, C) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<lbrakk>rightPrincipal r (Modal T Ts) R';\n     rightPrincipal r (Modal M Ms) R'; Ts \\<noteq> Ms\\<rbrakk>\n    \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Ps.\n       \\<lbrakk>rightPrincipal\n                 (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                 (Modal T Ts) R';\n        rightPrincipal (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n         (Modal M Ms) R';\n        T \\<noteq> M;\n        (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R';\n        r = (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>rightPrincipal r (Modal T Ts) R';\n     rightPrincipal r (Modal M Ms) R'; Ts \\<noteq> Ms\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rotate_tac 1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Ps.\n       \\<lbrakk>rightPrincipal\n                 (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                 (Modal M Ms) R';\n        T \\<noteq> M;\n        (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R';\n        r = (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n        rightPrincipal (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n         (Modal T Ts) R'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>rightPrincipal r (Modal T Ts) R';\n     rightPrincipal r (Modal M Ms) R'; Ts \\<noteq> Ms\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule rightPrincipal.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Ps.\n       \\<lbrakk>rightPrincipal\n                 (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                 (Modal M Ms) R';\n        T \\<noteq> M;\n        (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R';\n        r = (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n        rightPrincipal (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n         (Modal T Ts) R'\\<rbrakk>\n       \\<Longrightarrow> rightPrincipal (?a1.12 Ps) (?a2.12 Ps) (?a3.12 Ps)\n 2. \\<And>Ps C A Psa R.\n       \\<lbrakk>rightPrincipal\n                 (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                 (Modal M Ms) R';\n        T \\<noteq> M;\n        (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R';\n        r = (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n        rightPrincipal (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n         (Modal T Ts) R';\n        ?a1.12 Ps = (Psa, C); ?a2.12 Ps = A; ?a3.12 Ps = R;\n        C = ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>);\n        (Psa, C) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<lbrakk>rightPrincipal r (Modal T Ts) R';\n     rightPrincipal r (Modal M Ms) R'; Ts \\<noteq> Ms\\<rbrakk>\n    \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rightPrincipal r (Modal T Ts) R';\n     rightPrincipal r (Modal M Ms) R'; Ts \\<noteq> Ms\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule rightPrincipal.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rightPrincipal r (Modal T Ts) R';\n     rightPrincipal r (Modal M Ms) R'; Ts \\<noteq> Ms\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal ?a1.30 ?a2.30 ?a3.30\n 2. \\<And>C A Ps R.\n       \\<lbrakk>rightPrincipal r (Modal T Ts) R';\n        rightPrincipal r (Modal M Ms) R'; Ts \\<noteq> Ms; ?a1.30 = (Ps, C);\n        ?a2.30 = A; ?a3.30 = R;\n        C = ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>);\n        (Ps, C) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps.\n       \\<lbrakk>rightPrincipal\n                 (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                 (Modal T Ts) R';\n        rightPrincipal (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n         (Modal M Ms) R';\n        Ts \\<noteq> Ms;\n        (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R';\n        r = (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (rotate_tac 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps.\n       \\<lbrakk>rightPrincipal\n                 (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n                 (Modal M Ms) R';\n        Ts \\<noteq> Ms;\n        (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<in> R';\n        r = (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n        rightPrincipal (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n         (Modal T Ts) R'\\<rbrakk>\n       \\<Longrightarrow> False", "by (rule rightPrincipal.cases) auto"], ["proof (state)\nthis:\n  \\<not> rightPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<not> rightPrincipal r (Modal M Ms) R'", "have \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  \\<not> rightPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "using IH and a' b' d' \\<open>Ps \\<noteq> []\\<close>\n                             and nonPrincipalInvertRight[where ?R1.0=R1 and ?R2.0=R2 and ?R3.0=R3 and R=R and n=n\n                                                  and \\<Gamma>=\\<Gamma> and \\<Delta>=\\<Delta> and M=M and Ms=Ms and r=r and S=S\n                                                  and \\<Gamma>'=\\<Gamma>' and \\<Delta>'=\\<Delta>' and n'=n' and Ps=Ps and ps=ps \n                                                  and c=c and R'=R' and ?M1.0=M1 and ?M2.0=M2]\n                             and \\<open>n = Suc n'\\<close> and ext1 and rules and \\<open>r = (ps,c)\\<close> and \\<open>r \\<in> R\\<close>"], ["proof (prove)\nusing this:\n  \\<not> rightPrincipal r (Modal M Ms) R'\n  \\<forall>m<n.\n     \\<forall>\\<Gamma> \\<Delta>.\n        ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, m)\n        \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n        (\\<forall>r'\\<in>R'.\n            rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n            ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n            \\<in> set (fst r')) \\<longrightarrow>\n        (\\<exists>m'\\<le>m.\n            ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m')\n            \\<in> derivable (ext R R2 M1 M2))\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, n)\n  \\<in> derivable (ext R R2 M1 M2)\n  \\<forall>r'\\<in>R'.\n     rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\n  \\<forall>p\\<in>set Ps.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n  Ps \\<noteq> []\n  \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n   R3 \\<subseteq> modRules2;\n   R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3; r \\<in> R;\n   r = (ps, c); R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n   \\<forall>m<n.\n      \\<forall>\\<Gamma> \\<Delta>.\n         ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, m)\n         \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n         (\\<forall>r'\\<in>R'.\n             rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n             ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n             \\<in> set (fst r')) \\<longrightarrow>\n         (\\<exists>m'\\<le>m.\n             ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m')\n             \\<in> derivable (ext R R2 M1 M2));\n   ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, n)\n   \\<in> derivable (ext R R2 M1 M2);\n   \\<forall>r'\\<in>R'.\n      rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n      ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r');\n   \\<not> rightPrincipal r (Modal M Ms) R';\n   (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n   extendRule S r =\n   (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms);\n   n = n' + 1;\n   \\<forall>p\\<in>set Ps.\n      \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2);\n   Ps \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m\\<le>n.\n                       ( \\<Gamma> +\n                         \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                        m)\n                       \\<in> derivable (ext R R2 M1 M2)\n  n = Suc n'\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  r = (ps, c)\n  r \\<in> R\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  Modal T Ts \\<noteq> Modal M Ms \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  Modal T Ts = Modal M Ms \\<or> Modal T Ts \\<noteq> Modal M Ms\n  Modal T Ts = Modal M Ms \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  Modal T Ts \\<noteq> Modal M Ms \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)", "have \" \\<exists>m\\<le>n. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  Modal T Ts = Modal M Ms \\<or> Modal T Ts \\<noteq> Modal M Ms\n  Modal T Ts = Modal M Ms \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  Modal T Ts \\<noteq> Modal M Ms \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"c = (\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (state)\nthis:\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with \\<open>r = (ps,c)\\<close>"], ["proof (chain)\npicking this:\n  r = (ps, c)\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"\\<not> rightPrincipal r (Modal M Ms) R'\""], ["proof (prove)\nusing this:\n  r = (ps, c)\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (Modal M Ms) R'", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     rightPrincipal (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n      (Modal M Ms) R'\\<rbrakk>\n    \\<Longrightarrow> False", "by (rule rightPrincipal.cases) auto"], ["proof (state)\nthis:\n  \\<not> rightPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<not> rightPrincipal r (Modal M Ms) R'", "have \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  \\<not> rightPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "using IH and a' b' d' \\<open>Ps \\<noteq> []\\<close>\n                         and nonPrincipalInvertRight[where ?R1.0=R1 and ?R2.0=R2 and ?R3.0=R3 and R=R and n=n\n                                                  and \\<Gamma>=\\<Gamma> and \\<Delta>=\\<Delta> and M=M and Ms=Ms and r=r and S=S\n                                                  and \\<Gamma>'=\\<Gamma>' and \\<Delta>'=\\<Delta>' and n'=n' and Ps=Ps and ps=ps \n                                                  and c=c and R'=R' and ?M1.0=M1 and ?M2.0=M2]\n                         and \\<open>n = Suc n'\\<close> and ext1 and rules and \\<open>r = (ps,c)\\<close> and \\<open>r \\<in> R\\<close>"], ["proof (prove)\nusing this:\n  \\<not> rightPrincipal r (Modal M Ms) R'\n  \\<forall>m<n.\n     \\<forall>\\<Gamma> \\<Delta>.\n        ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, m)\n        \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n        (\\<forall>r'\\<in>R'.\n            rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n            ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n            \\<in> set (fst r')) \\<longrightarrow>\n        (\\<exists>m'\\<le>m.\n            ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m')\n            \\<in> derivable (ext R R2 M1 M2))\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, n)\n  \\<in> derivable (ext R R2 M1 M2)\n  \\<forall>r'\\<in>R'.\n     rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\n  \\<forall>p\\<in>set Ps.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n  Ps \\<noteq> []\n  \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n   R3 \\<subseteq> modRules2;\n   R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3; r \\<in> R;\n   r = (ps, c); R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n   \\<forall>m<n.\n      \\<forall>\\<Gamma> \\<Delta>.\n         ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, m)\n         \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n         (\\<forall>r'\\<in>R'.\n             rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n             ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n             \\<in> set (fst r')) \\<longrightarrow>\n         (\\<exists>m'\\<le>m.\n             ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m')\n             \\<in> derivable (ext R R2 M1 M2));\n   ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms, n)\n   \\<in> derivable (ext R R2 M1 M2);\n   \\<forall>r'\\<in>R'.\n      rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n      ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r');\n   \\<not> rightPrincipal r (Modal M Ms) R';\n   (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n   extendRule S r =\n   (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms);\n   n = n' + 1;\n   \\<forall>p\\<in>set Ps.\n      \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2);\n   Ps \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m\\<le>n.\n                       ( \\<Gamma> +\n                         \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                        m)\n                       \\<in> derivable (ext R R2 M1 M2)\n  n = Suc n'\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  r = (ps, c)\n  r \\<in> R\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)", "have \"\\<exists>m\\<le>n. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  r \\<in> modRules2 \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  r \\<in> upRules \\<or> r \\<in> modRules2\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r \\<in> upRules \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  r \\<in> modRules2 \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)", "have \"\\<exists>m\\<le>n. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  r \\<in> upRules \\<or> r \\<in> modRules2\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r \\<in> upRules \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  r \\<in> modRules2 \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,\n    \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,\n    \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "(*>*)"], ["proof (state)\nthis:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,\n    \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "txt\\<open>\\noindent  The other interesting case is where the last inference was a modalised context inference:\\<close>"], ["proof (state)\nthis:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,\n    \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,\n    \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume ba: \"r \\<in> p_e R2 M1 M2 \\<and> \n         extendConc S r = (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\""], ["proof (state)\nthis:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with rules"], ["proof (chain)\npicking this:\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)", "obtain F Fs \\<Gamma>'' \\<Delta>'' ps r' where\n       ca: \"r = extendRule (M1\\<cdot>\\<Gamma>'' \\<Rightarrow>* M2\\<cdot>\\<Delta>'') r'\" and \n       cb: \"r' \\<in> R2\" and\n     cc:  \"r' = (ps, \\<Empt> \\<Rightarrow>* \\<LM>Modal F Fs\\<RM>) \\<or> r' = (ps,\\<LM>Modal F Fs\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>'' \\<Delta>'' r' ps F Fs.\n        \\<lbrakk>r =\n                 extendRule\n                  ( M1 \\<cdot>\n                    \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n                  r';\n         r' \\<in> R2;\n         r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n         r' = (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "(*<*)"], ["proof (prove)\nusing this:\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>'' \\<Delta>'' r' ps F Fs.\n        \\<lbrakk>r =\n                 extendRule\n                  ( M1 \\<cdot>\n                    \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n                  r';\n         r' \\<in> R2;\n         r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n         r' = (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using modRule1Characterise[where Ps=\"fst r\" and C=\"snd r\" and M=M1 and N=M2 and R=R2]"], ["proof (prove)\nusing this:\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  \\<lbrakk>(fst r, snd r) \\<in> p_e R2 M1 M2;\n   R2 \\<subseteq> modRules2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>F Fs \\<Gamma> \\<Delta> ps ra.\n                       (fst r, snd r) =\n                       extendRule\n                        ( M1 \\<cdot>\n                          \\<Gamma> \\<Rightarrow>* M2 \\<cdot> \\<Delta>)\n                        ra \\<and>\n                       ra \\<in> R2 \\<and>\n                       (ra =\n                        (ps,\n                          \\<Empt> \\<Rightarrow>* \\<LM> Modal F\n                  Fs  \\<RM>) \\<or>\n                        ra =\n                        (ps,\n                          \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>'' \\<Delta>'' r' ps F Fs.\n        \\<lbrakk>r =\n                 extendRule\n                  ( M1 \\<cdot>\n                    \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n                  r';\n         r' \\<in> R2;\n         r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n         r' = (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'\n  r' \\<in> R2\n  r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n  r' = (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "obtain \\<Gamma>1 \\<Delta>1 where \"S = (\\<Gamma>1 \\<Rightarrow>* \\<Delta>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>1 \\<Delta>1.\n        S = ( \\<Gamma>1 \\<Rightarrow>* \\<Delta>1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases S) auto"], ["proof (state)\nthis:\n  S = ( \\<Gamma>1 \\<Rightarrow>* \\<Delta>1)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  S = ( \\<Gamma>1 \\<Rightarrow>* \\<Delta>1)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  S = ( \\<Gamma>1 \\<Rightarrow>* \\<Delta>1)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"r' = (ps, \\<Empt> \\<Rightarrow>* \\<LM>Modal F Fs\\<RM>)\""], ["proof (state)\nthis:\n  r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with ba ca \\<open>S = (\\<Gamma>1 \\<Rightarrow>* \\<Delta>1)\\<close>"], ["proof (chain)\npicking this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'\n  S = ( \\<Gamma>1 \\<Rightarrow>* \\<Delta>1)\n  r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>)", "have\n   eq1: \"(M1\\<cdot>\\<Gamma>'' + \\<Gamma>1 \\<Rightarrow>* M2\\<cdot>\\<Delta>'' + \\<Delta>1 \\<oplus> Modal F Fs) = (\\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\""], ["proof (prove)\nusing this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'\n  S = ( \\<Gamma>1 \\<Rightarrow>* \\<Delta>1)\n  r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>)\n\ngoal (1 subgoal):\n 1. ( M1 \\<cdot> \\<Gamma>'' +\n      \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' +\n                               \\<Delta>1 \\<oplus> Modal F Fs) =\n    ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)", "by (auto simp add:extendRule_def extend_def extendConc_def union_ac)"], ["proof (state)\nthis:\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' +\n                             \\<Delta>1 \\<oplus> Modal F Fs) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "(*<*)"], ["proof (state)\nthis:\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' +\n                             \\<Delta>1 \\<oplus> Modal F Fs) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' +\n                             \\<Delta>1 \\<oplus> Modal F Fs) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)", "have eq2: \"M2\\<cdot>\\<Delta>'' + \\<Delta>1 \\<oplus> Modal F Fs = \\<Delta> \\<oplus> Modal M Ms\""], ["proof (prove)\nusing this:\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' +\n                             \\<Delta>1 \\<oplus> Modal F Fs) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. M2 \\<cdot> \\<Delta>'' + \\<Delta>1 \\<oplus> Modal F Fs =\n    \\<Delta> \\<oplus> Modal M Ms", "by auto"], ["proof (state)\nthis:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 \\<oplus> Modal F Fs =\n  \\<Delta> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 \\<oplus> Modal F Fs =\n  \\<Delta> \\<oplus> Modal M Ms", "have \"set_mset (M2 \\<cdot> \\<Delta>'' + \\<Delta>1 \\<oplus> Modal F Fs) = set_mset (\\<Delta> \\<oplus> Modal M Ms)\""], ["proof (prove)\nusing this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 \\<oplus> Modal F Fs =\n  \\<Delta> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. set_mset (M2 \\<cdot> \\<Delta>'' + \\<Delta>1 \\<oplus> Modal F Fs) =\n    set_mset (\\<Delta> \\<oplus> Modal M Ms)", "by auto"], ["proof (state)\nthis:\n  set_mset (M2 \\<cdot> \\<Delta>'' + \\<Delta>1 \\<oplus> Modal F Fs) =\n  set_mset (\\<Delta> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  set_mset (M2 \\<cdot> \\<Delta>'' + \\<Delta>1 \\<oplus> Modal F Fs) =\n  set_mset (\\<Delta> \\<oplus> Modal M Ms)", "have \"set_mset (\\<LM>Modal M Ms\\<RM>) \\<subseteq> set_mset (M2 \\<cdot> \\<Delta>'') \\<union> set_mset \\<Delta>1 \\<union>  {Modal F Fs}\""], ["proof (prove)\nusing this:\n  set_mset (M2 \\<cdot> \\<Delta>'' + \\<Delta>1 \\<oplus> Modal F Fs) =\n  set_mset (\\<Delta> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. set_mset (\\<LM> Modal M Ms  \\<RM>)\n    \\<subseteq> set_mset (M2 \\<cdot> \\<Delta>'') \\<union>\n                set_mset \\<Delta>1 \\<union>\n                {Modal F Fs}", "by auto"], ["proof (state)\nthis:\n  set_mset (\\<LM> Modal M Ms  \\<RM>)\n  \\<subseteq> set_mset (M2 \\<cdot> \\<Delta>'') \\<union>\n              set_mset \\<Delta>1 \\<union>\n              {Modal F Fs}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "(*>*)"], ["proof (state)\nthis:\n  set_mset (\\<LM> Modal M Ms  \\<RM>)\n  \\<subseteq> set_mset (M2 \\<cdot> \\<Delta>'') \\<union>\n              set_mset \\<Delta>1 \\<union>\n              {Modal F Fs}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  set_mset (\\<LM> Modal M Ms  \\<RM>)\n  \\<subseteq> set_mset (M2 \\<cdot> \\<Delta>'') \\<union>\n              set_mset \\<Delta>1 \\<union>\n              {Modal F Fs}", "have \"Modal M Ms \\<in> set_mset (M2\\<cdot>\\<Delta>'') \\<or> \n             Modal M Ms \\<in> set_mset \\<Delta>1 \\<or> \n             Modal M Ms = Modal F Fs\""], ["proof (prove)\nusing this:\n  set_mset (\\<LM> Modal M Ms  \\<RM>)\n  \\<subseteq> set_mset (M2 \\<cdot> \\<Delta>'') \\<union>\n              set_mset \\<Delta>1 \\<union>\n              {Modal F Fs}\n\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># M2 \\<cdot> \\<Delta>'' \\<or>\n    Modal M Ms \\<in># \\<Delta>1 \\<or> Modal M Ms = Modal F Fs", "by auto"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>'' \\<or>\n  Modal M Ms \\<in># \\<Delta>1 \\<or> Modal M Ms = Modal F Fs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>'' \\<or>\n  Modal M Ms \\<in># \\<Delta>1 \\<or> Modal M Ms = Modal F Fs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>'' \\<or>\n  Modal M Ms \\<in># \\<Delta>1 \\<or> Modal M Ms = Modal F Fs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"Modal M Ms \\<in> set_mset (M2\\<cdot>\\<Delta>'')\" \\<comment> \\<open>Contradiction\\<close>"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>''\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>''", "have \"Modal M Ms \\<in># M2\\<cdot>\\<Delta>''\""], ["proof (prove)\nusing this:\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>''\n\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># M2 \\<cdot> \\<Delta>''", "by auto"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>''\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with (*<*)modal_not_contain[where M=M and N=M2 and A=Ms and \\<Gamma>=\\<Delta>''] and(*>*) neq"], ["proof (chain)\npicking this:\n  M \\<noteq> M2 \\<Longrightarrow> Modal M Ms \\<notin># M2 \\<cdot> \\<Delta>''\n  M2 \\<noteq> M\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>''", "have \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  M \\<noteq> M2 \\<Longrightarrow> Modal M Ms \\<notin># M2 \\<cdot> \\<Delta>''\n  M2 \\<noteq> M\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>''\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>'' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>'' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>'' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"Modal M Ms = Modal F Fs\" \\<comment> \\<open>The last inference is principal\\<close>"], ["proof (state)\nthis:\n  Modal M Ms = Modal F Fs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  Modal M Ms = Modal F Fs", "have \"r' = (ps, \\<Empt> \\<Rightarrow>* \\<LM>Modal M Ms\\<RM>)\""], ["proof (prove)\nusing this:\n  Modal M Ms = Modal F Fs\n\ngoal (1 subgoal):\n 1. r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal M Ms  \\<RM>)", "using \\<open>r' = (ps,\\<Empt> \\<Rightarrow>* \\<LM>Modal F Fs\\<RM>)\\<close>"], ["proof (prove)\nusing this:\n  Modal M Ms = Modal F Fs\n  r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>)\n\ngoal (1 subgoal):\n 1. r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal M Ms  \\<RM>)", "by simp"], ["proof (state)\nthis:\n  r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal M Ms  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with cb and rules"], ["proof (chain)\npicking this:\n  r' \\<in> R2\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal M Ms  \\<RM>)", "have \"rightPrincipal r' (Modal M Ms) R'\" \n        and \"r' \\<in> R'\""], ["proof (prove)\nusing this:\n  r' \\<in> R2\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal M Ms  \\<RM>)\n\ngoal (1 subgoal):\n 1. rightPrincipal r' (Modal M Ms) R' &&& r' \\<in> R'", "by auto"], ["proof (state)\nthis:\n  rightPrincipal r' (Modal M Ms) R'\n  r' \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with b"], ["proof (chain)\npicking this:\n  \\<forall>r'\\<in>R'.\n     rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\n  rightPrincipal r' (Modal M Ms) R'\n  r' \\<in> R'", "have \"(\\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set ps\""], ["proof (prove)\nusing this:\n  \\<forall>r'\\<in>R'.\n     rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\n  rightPrincipal r' (Modal M Ms) R'\n  r' \\<in> R'\n\ngoal (1 subgoal):\n 1. ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set ps", "using \\<open>r' = (ps, \\<Empt> \\<Rightarrow>* \\<LM>Modal M Ms\\<RM>)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>r'\\<in>R'.\n     rightPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\n  rightPrincipal r' (Modal M Ms) R'\n  r' \\<in> R'\n  r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal M Ms  \\<RM>)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set ps", "by (auto simp add:Ball_def)"], ["proof (state)\nthis:\n  ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set ps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "(*<*)"], ["proof (state)\nthis:\n  ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set ps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set ps", "have \"extend (M1\\<cdot>\\<Gamma>'' \\<Rightarrow>* M2\\<cdot>\\<Delta>'') (\\<Gamma>' \\<Rightarrow>* \\<Delta>') \n                               \\<in> set (map (extend (M1\\<cdot>\\<Gamma>'' \\<Rightarrow>* M2\\<cdot>\\<Delta>'')) ps)\""], ["proof (prove)\nusing this:\n  ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set ps\n\ngoal (1 subgoal):\n 1. extend ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n    \\<in> set (map (extend\n                     ( M1 \\<cdot>\n                       \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>''))\n                ps)", "by auto"], ["proof (state)\nthis:\n  extend ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n  \\<in> set (map (extend\n                   ( M1 \\<cdot>\n                     \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>''))\n              ps)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  extend ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n  \\<in> set (map (extend\n                   ( M1 \\<cdot>\n                     \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>''))\n              ps)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "from ba and \\<open>r' = (ps, \\<Empt> \\<Rightarrow>* \\<LM>Modal M Ms\\<RM>)\\<close> and ca"], ["proof (chain)\npicking this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal M Ms  \\<RM>)\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'", "have \"Ps = map (extend (M1\\<cdot>\\<Gamma>'' \\<Rightarrow>* M2\\<cdot>\\<Delta>'')) ps\""], ["proof (prove)\nusing this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal M Ms  \\<RM>)\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'\n\ngoal (1 subgoal):\n 1. Ps =\n    map (extend\n          ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>''))\n     ps", "by (auto simp add:extendRule_def extendConc_def)"], ["proof (state)\nthis:\n  Ps =\n  map (extend ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>''))\n   ps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  Ps =\n  map (extend ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>''))\n   ps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "have \"extend (M1\\<cdot>\\<Gamma>'' \\<Rightarrow>* M2\\<cdot>\\<Delta>'') (\\<Gamma>' \\<Rightarrow>* \\<Delta>') = (M1\\<cdot>\\<Gamma>'' + \\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>'' + \\<Delta>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extend ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') =\n    ( M1 \\<cdot> \\<Gamma>'' +\n      \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>')", "by (auto simp add:extend_def)"], ["proof (state)\nthis:\n  extend ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') =\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  extend ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n  \\<in> set (map (extend\n                   ( M1 \\<cdot>\n                     \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>''))\n              ps)\n  Ps =\n  map (extend ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>''))\n   ps\n  extend ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') =\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>')", "have \"(M1\\<cdot>\\<Gamma>'' + \\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>'' + \\<Delta>') \\<in> set Ps\""], ["proof (prove)\nusing this:\n  extend ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n  \\<in> set (map (extend\n                   ( M1 \\<cdot>\n                     \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>''))\n              ps)\n  Ps =\n  map (extend ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>''))\n   ps\n  extend ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') =\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>')\n\ngoal (1 subgoal):\n 1. ( M1 \\<cdot> \\<Gamma>'' +\n      \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>')\n    \\<in> set Ps", "by auto"], ["proof (state)\nthis:\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>')\n  \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with d'"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set Ps.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>')\n  \\<in> set Ps", "have \"\\<exists> m\\<le>n'. (M1\\<cdot>\\<Gamma>'' + \\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>'' + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>')\n  \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n'.\n       ( M1 \\<cdot> \\<Gamma>'' +\n         \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>',\n        m)\n       \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n'.\n     ( M1 \\<cdot> \\<Gamma>'' +\n       \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>',\n      m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<exists>m\\<le>n'.\n     ( M1 \\<cdot> \\<Gamma>'' +\n       \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>',\n      m)\n     \\<in> derivable (ext R R2 M1 M2)", "have \"\\<exists> m\\<le>n'. (M1\\<cdot>\\<Gamma>'' + \\<Gamma>' + \\<Gamma>1 \\<Rightarrow>* M2\\<cdot>\\<Delta>'' + \\<Delta>' + \\<Delta>1,m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  \\<exists>m\\<le>n'.\n     ( M1 \\<cdot> \\<Gamma>'' +\n       \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>',\n      m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n'.\n       ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' +\n         \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>' +\n                                  \\<Delta>1,\n        m)\n       \\<in> derivable (ext R R2 M1 M2)", "using dpWeak[where \\<Gamma>=\"M1\\<cdot>\\<Gamma>'' + \\<Gamma>'\" and \\<Delta>=\"M2\\<cdot>\\<Delta>'' + \\<Delta>'\" and R=R and ?R2.0=R2\n                                      and M=M1 and N=M2 and ?R1.0=R1 and ?R3.0=R3 and \\<Gamma>'=\\<Gamma>1 and \\<Delta>'=\\<Delta>1] \n                         and rules"], ["proof (prove)\nusing this:\n  \\<exists>m\\<le>n'.\n     ( M1 \\<cdot> \\<Gamma>'' +\n       \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>',\n      m)\n     \\<in> derivable (ext R R2 M1 M2)\n  \\<lbrakk>( M1 \\<cdot> \\<Gamma>'' +\n             \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>',\n            ?n)\n           \\<in> derivable (ext R R2 M1 M2);\n   R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n   R3 \\<subseteq> modRules2;\n   R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3\\<rbrakk>\n  \\<Longrightarrow> ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' +\n                      \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' +\n         \\<Delta>' +\n         \\<Delta>1,\n                     ?n)\n                    \\<in> derivable (ext R R2 M1 M2)\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n'.\n       ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' +\n         \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>' +\n                                  \\<Delta>1,\n        m)\n       \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n'.\n     ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' +\n       \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>' +\n                                \\<Delta>1,\n      m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with \\<open>n = Suc n'\\<close>"], ["proof (chain)\npicking this:\n  n = Suc n'\n  \\<exists>m\\<le>n'.\n     ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' +\n       \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>' +\n                                \\<Delta>1,\n      m)\n     \\<in> derivable (ext R R2 M1 M2)", "have ee: \"\\<exists> m\\<le>n. (M1\\<cdot>\\<Gamma>'' + \\<Gamma>' + \\<Gamma>1 \\<Rightarrow>* M2\\<cdot>\\<Delta>'' + \\<Delta>' + \\<Delta>1,m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  n = Suc n'\n  \\<exists>m\\<le>n'.\n     ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' +\n       \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>' +\n                                \\<Delta>1,\n      m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' +\n         \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>' +\n                                  \\<Delta>1,\n        m)\n       \\<in> derivable (ext R R2 M1 M2)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>n = Suc n'; m \\<le> n';\n        ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' +\n          \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>' +\n                                   \\<Delta>1,\n         m)\n        \\<in> derivable (ext R R2 M1 M2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<le>Suc n'.\n                            ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' +\n                              \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot>\n                 \\<Delta>'' +\n                 \\<Delta>' +\n                 \\<Delta>1,\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2)", "apply (rule_tac x=m in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>n = Suc n'; m \\<le> n';\n        ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' +\n          \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>' +\n                                   \\<Delta>1,\n         m)\n        \\<in> derivable (ext R R2 M1 M2)\\<rbrakk>\n       \\<Longrightarrow> m \\<le> Suc n' \\<and>\n                         ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' +\n                           \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' +\n              \\<Delta>' +\n              \\<Delta>1,\n                          m)\n                         \\<in> derivable (ext R R2 M1 M2)", "by arith"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' +\n       \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>' +\n                                \\<Delta>1,\n      m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "from eq1"], ["proof (chain)\npicking this:\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' +\n                             \\<Delta>1 \\<oplus> Modal F Fs) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)", "have \"M1\\<cdot>\\<Gamma>'' + \\<Gamma>1 = \\<Gamma>\""], ["proof (prove)\nusing this:\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' +\n                             \\<Delta>1 \\<oplus> Modal F Fs) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 = \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 = \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 = \\<Gamma>", "have \"M1\\<cdot>\\<Gamma>'' + \\<Gamma>' + \\<Gamma>1 = \\<Gamma> + \\<Gamma>'\""], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 = \\<Gamma>\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' + \\<Gamma>1 = \\<Gamma> + \\<Gamma>'", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' + \\<Gamma>1 = \\<Gamma> + \\<Gamma>'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' + \\<Gamma>1 = \\<Gamma> + \\<Gamma>'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "from eq2 and \\<open>Modal M Ms = Modal F Fs\\<close>"], ["proof (chain)\npicking this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 \\<oplus> Modal F Fs =\n  \\<Delta> \\<oplus> Modal M Ms\n  Modal M Ms = Modal F Fs", "have \"M2\\<cdot>\\<Delta>'' + \\<Delta>1 = \\<Delta>\""], ["proof (prove)\nusing this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 \\<oplus> Modal F Fs =\n  \\<Delta> \\<oplus> Modal M Ms\n  Modal M Ms = Modal F Fs\n\ngoal (1 subgoal):\n 1. M2 \\<cdot> \\<Delta>'' + \\<Delta>1 = \\<Delta>", "using add_equal_means_equal[where \\<Gamma>=\" M2 \\<cdot> \\<Delta>'' + \\<Delta>1\" and \\<Delta>=\\<Delta> and A=\"Modal F Fs\"]"], ["proof (prove)\nusing this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 \\<oplus> Modal F Fs =\n  \\<Delta> \\<oplus> Modal M Ms\n  Modal M Ms = Modal F Fs\n  (M2 \\<cdot> \\<Delta>'' + \\<Delta>1) \\<oplus> Modal F Fs =\n  \\<Delta> \\<oplus> Modal F Fs \\<Longrightarrow>\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 = \\<Delta>\n\ngoal (1 subgoal):\n 1. M2 \\<cdot> \\<Delta>'' + \\<Delta>1 = \\<Delta>", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 = \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 = \\<Delta>", "have \"M2\\<cdot>\\<Delta>'' + \\<Delta>' + \\<Delta>1 = \\<Delta> + \\<Delta>'\""], ["proof (prove)\nusing this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 = \\<Delta>\n\ngoal (1 subgoal):\n 1. M2 \\<cdot> \\<Delta>'' + \\<Delta>' + \\<Delta>1 = \\<Delta> + \\<Delta>'", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>' + \\<Delta>1 = \\<Delta> + \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "(*>*)"], ["proof (state)\nthis:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>' + \\<Delta>1 = \\<Delta> + \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' + \\<Gamma>1 = \\<Gamma> + \\<Gamma>'\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>' + \\<Delta>1 = \\<Delta> + \\<Delta>'", "have \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta>+\\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' + \\<Gamma>1 = \\<Gamma> + \\<Gamma>'\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>' + \\<Delta>1 = \\<Delta> + \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "(*<*)"], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' + \\<Gamma>1 = \\<Gamma> + \\<Gamma>'\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>' + \\<Delta>1 = \\<Delta> + \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "using ee"], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' + \\<Gamma>1 = \\<Gamma> + \\<Gamma>'\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>' + \\<Delta>1 = \\<Delta> + \\<Delta>'\n  \\<exists>m\\<le>n.\n     ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' +\n       \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>' +\n                                \\<Delta>1,\n      m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "(*>*)"], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' + \\<Gamma>1 = \\<Gamma> + \\<Gamma>'\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>' + \\<Delta>1 = \\<Delta> + \\<Delta>'\n  \\<exists>m\\<le>n.\n     ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' +\n       \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>' +\n                                \\<Delta>1,\n      m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by metis"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  Modal M Ms = Modal F Fs \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  Modal M Ms = Modal F Fs \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  Modal M Ms = Modal F Fs \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"Modal M Ms \\<in> set_mset \\<Delta>1\" \\<comment> \\<open>Formula is in the implicit weakening\\<close>"], ["proof (state)\nthis:\n  Modal M Ms \\<in># \\<Delta>1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "(*<*)"], ["proof (state)\nthis:\n  Modal M Ms \\<in># \\<Delta>1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  Modal M Ms \\<in># \\<Delta>1", "have \"Modal M Ms \\<in># \\<Delta>1\""], ["proof (prove)\nusing this:\n  Modal M Ms \\<in># \\<Delta>1\n\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># \\<Delta>1", "by auto"], ["proof (state)\nthis:\n  Modal M Ms \\<in># \\<Delta>1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  Modal M Ms \\<in># \\<Delta>1", "have \"\\<exists> \\<Delta>2. \\<Delta>1 = \\<Delta>2 \\<oplus> Modal M Ms\""], ["proof (prove)\nusing this:\n  Modal M Ms \\<in># \\<Delta>1\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Delta>2. \\<Delta>1 = \\<Delta>2 \\<oplus> Modal M Ms", "using insert_DiffM[where x=\"Modal M Ms\" and M=\"\\<Delta>1\"]"], ["proof (prove)\nusing this:\n  Modal M Ms \\<in># \\<Delta>1\n  Modal M Ms \\<in># \\<Delta>1 \\<Longrightarrow>\n  add_mset (Modal M Ms) (\\<Delta>1 \\<ominus> Modal M Ms) = \\<Delta>1\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Delta>2. \\<Delta>1 = \\<Delta>2 \\<oplus> Modal M Ms", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># \\<Delta>1 \\<Longrightarrow>\n    \\<exists>\\<Delta>2. \\<Delta>1 = add_mset (Modal M Ms) \\<Delta>2", "apply (rule_tac x=\"\\<Delta>1\\<ominus>Modal M Ms\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># \\<Delta>1 \\<Longrightarrow>\n    \\<Delta>1 = add_mset (Modal M Ms) (\\<Delta>1 \\<ominus> Modal M Ms)", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  \\<exists>\\<Delta>2. \\<Delta>1 = \\<Delta>2 \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "(*>*)"], ["proof (state)\nthis:\n  \\<exists>\\<Delta>2. \\<Delta>1 = \\<Delta>2 \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<Delta>2. \\<Delta>1 = \\<Delta>2 \\<oplus> Modal M Ms", "obtain \\<Delta>2 where \"\\<Delta>1 = \\<Delta>2 \\<oplus> Modal M Ms\""], ["proof (prove)\nusing this:\n  \\<exists>\\<Delta>2. \\<Delta>1 = \\<Delta>2 \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Delta>2.\n        \\<Delta>1 = \\<Delta>2 \\<oplus> Modal M Ms \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<Delta>1 = \\<Delta>2 \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "(*>*)"], ["proof (state)\nthis:\n  \\<Delta>1 = \\<Delta>2 \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "from ba and rules"], ["proof (chain)\npicking this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3", "have \"extendConc (\\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r \\<in> (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n\ngoal (1 subgoal):\n 1. extendConc ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>')\n     r\n    \\<in> ext R R2 M1 M2", "by auto"], ["proof (state)\nthis:\n  extendConc ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  extendConc ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "from ba and ca"], ["proof (chain)\npicking this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'", "have \"fst (extendConc (\\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r) = Ps\""], ["proof (prove)\nusing this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'\n\ngoal (1 subgoal):\n 1. fst (extendConc\n          ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r) =\n    Ps", "by (auto simp add:extendConc_def)"], ["proof (state)\nthis:\n  fst (extendConc\n        ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r) =\n  Ps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "(*<*)"], ["proof (state)\nthis:\n  fst (extendConc\n        ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r) =\n  Ps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  extendConc ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n  fst (extendConc\n        ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r) =\n  Ps", "have \"(snd (extendConc (\\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r),n'+1) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  extendConc ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n  fst (extendConc\n        ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r) =\n  Ps\n\ngoal (1 subgoal):\n 1. (snd (extendConc\n           ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r),\n     n' + 1)\n    \\<in> derivable (ext R R2 M1 M2)", "using d' and derivable.step[where r=\"extendConc (\\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r\"\n                                                     and R=\"ext R R2 M1 M2\" and m=n'] and \\<open>Ps \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  extendConc ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n  fst (extendConc\n        ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r) =\n  Ps\n  \\<forall>p\\<in>set Ps.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n  \\<lbrakk>extendConc\n            ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r\n           \\<in> ext R R2 M1 M2;\n   fst (extendConc\n         ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>')\n         r) \\<noteq>\n   [];\n   \\<forall>p\\<in>set (fst (extendConc\n                             ( \\<Gamma>1 +\n                               \\<Gamma>' \\<Rightarrow>* \\<Delta>2 +\n                  \\<Delta>')\n                             r)).\n      \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\\<rbrakk>\n  \\<Longrightarrow> (snd (extendConc\n                           ( \\<Gamma>1 +\n                             \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>')\n                           r),\n                     n' + 1)\n                    \\<in> derivable (ext R R2 M1 M2)\n  Ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. (snd (extendConc\n           ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r),\n     n' + 1)\n    \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  (snd (extendConc\n         ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r),\n   n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  (snd (extendConc\n         ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r),\n   n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "from ca and \\<open>r' = (ps,\\<Empt> \\<Rightarrow>* \\<LM>Modal F Fs \\<RM>)\\<close>"], ["proof (chain)\npicking this:\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'\n  r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>)", "have \"snd (extendConc (\\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r) = (M1\\<cdot>\\<Gamma>'' + (\\<Gamma>1 + \\<Gamma>') \\<Rightarrow>* (M2\\<cdot>\\<Delta>'' \\<oplus> Modal F Fs) + \\<Delta>2 + \\<Delta>')\""], ["proof (prove)\nusing this:\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'\n  r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>)\n\ngoal (1 subgoal):\n 1. snd (extendConc\n          ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r) =\n    ( M1 \\<cdot> \\<Gamma>'' +\n      (\\<Gamma>1 +\n       \\<Gamma>') \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' \\<oplus> Modal F Fs +\n                                 \\<Delta>2 +\n                                 \\<Delta>')", "by (auto simp add:extendRule_def extendConc_def extend_def union_ac)"], ["proof (state)\nthis:\n  snd (extendConc\n        ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r) =\n  ( M1 \\<cdot> \\<Gamma>'' +\n    (\\<Gamma>1 +\n     \\<Gamma>') \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' \\<oplus> Modal F Fs +\n                               \\<Delta>2 +\n                               \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  (snd (extendConc\n         ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r),\n   n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n  snd (extendConc\n        ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r) =\n  ( M1 \\<cdot> \\<Gamma>'' +\n    (\\<Gamma>1 +\n     \\<Gamma>') \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' \\<oplus> Modal F Fs +\n                               \\<Delta>2 +\n                               \\<Delta>')", "have gg: \"(M1\\<cdot>\\<Gamma>'' + \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>'' + \\<Delta>2 + \\<Delta>' \\<oplus> Modal F Fs,n'+1) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  (snd (extendConc\n         ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r),\n   n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n  snd (extendConc\n        ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r) =\n  ( M1 \\<cdot> \\<Gamma>'' +\n    (\\<Gamma>1 +\n     \\<Gamma>') \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' \\<oplus> Modal F Fs +\n                               \\<Delta>2 +\n                               \\<Delta>')\n\ngoal (1 subgoal):\n 1. ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 +\n      \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>2 +\n                               \\<Delta>' \\<oplus> Modal F Fs,\n     n' + 1)\n    \\<in> derivable (ext R R2 M1 M2)", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 +\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>2 +\n                             \\<Delta>' \\<oplus> Modal F Fs,\n   n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "from eq1"], ["proof (chain)\npicking this:\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' +\n                             \\<Delta>1 \\<oplus> Modal F Fs) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)", "have \"M1\\<cdot>\\<Gamma>'' + \\<Gamma>1 = \\<Gamma>\""], ["proof (prove)\nusing this:\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' +\n                             \\<Delta>1 \\<oplus> Modal F Fs) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 = \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 = \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 = \\<Gamma>", "have \"(M1\\<cdot>\\<Gamma>'' + \\<Gamma>1 + \\<Gamma>') = \\<Gamma> + \\<Gamma>'\""], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 = \\<Gamma>\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 + \\<Gamma>' = \\<Gamma> + \\<Gamma>'", "by auto"], ["proof (state)\nthis:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 + \\<Gamma>' = \\<Gamma> + \\<Gamma>'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 + \\<Gamma>' = \\<Gamma> + \\<Gamma>'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "from eq2 and \\<open>\\<Delta>1 = \\<Delta>2 \\<oplus> Modal M Ms\\<close>"], ["proof (chain)\npicking this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 \\<oplus> Modal F Fs =\n  \\<Delta> \\<oplus> Modal M Ms\n  \\<Delta>1 = \\<Delta>2 \\<oplus> Modal M Ms", "have \"M2\\<cdot>\\<Delta>'' + \\<Delta>2 \\<oplus> Modal F Fs \\<oplus> Modal M Ms = \\<Delta> \\<oplus> Modal M Ms\""], ["proof (prove)\nusing this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 \\<oplus> Modal F Fs =\n  \\<Delta> \\<oplus> Modal M Ms\n  \\<Delta>1 = \\<Delta>2 \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. M2 \\<cdot> \\<Delta>'' +\n    \\<Delta>2 \\<oplus> Modal F Fs \\<oplus> Modal M Ms =\n    \\<Delta> \\<oplus> Modal M Ms", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  M2 \\<cdot> \\<Delta>'' +\n  \\<Delta>2 \\<oplus> Modal F Fs \\<oplus> Modal M Ms =\n  \\<Delta> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  M2 \\<cdot> \\<Delta>'' +\n  \\<Delta>2 \\<oplus> Modal F Fs \\<oplus> Modal M Ms =\n  \\<Delta> \\<oplus> Modal M Ms", "have \"M2\\<cdot>\\<Delta>'' + \\<Delta>2 \\<oplus> Modal F Fs = \\<Delta>\""], ["proof (prove)\nusing this:\n  M2 \\<cdot> \\<Delta>'' +\n  \\<Delta>2 \\<oplus> Modal F Fs \\<oplus> Modal M Ms =\n  \\<Delta> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. M2 \\<cdot> \\<Delta>'' + \\<Delta>2 \\<oplus> Modal F Fs = \\<Delta>", "using add_equal_means_equal[where \\<Gamma>=\" M2 \\<cdot> \\<Delta>'' + \\<Delta>2 \\<oplus> Modal F Fs\" and \\<Delta>=\\<Delta> and A=\"Modal M Ms\"]"], ["proof (prove)\nusing this:\n  M2 \\<cdot> \\<Delta>'' +\n  \\<Delta>2 \\<oplus> Modal F Fs \\<oplus> Modal M Ms =\n  \\<Delta> \\<oplus> Modal M Ms\n  (M2 \\<cdot> \\<Delta>'' + \\<Delta>2 \\<oplus> Modal F Fs) \\<oplus>\n  Modal M Ms =\n  \\<Delta> \\<oplus> Modal M Ms \\<Longrightarrow>\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>2 \\<oplus> Modal F Fs = \\<Delta>\n\ngoal (1 subgoal):\n 1. M2 \\<cdot> \\<Delta>'' + \\<Delta>2 \\<oplus> Modal F Fs = \\<Delta>", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>2 \\<oplus> Modal F Fs = \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>2 \\<oplus> Modal F Fs = \\<Delta>", "have \"M2\\<cdot>\\<Delta>'' + \\<Delta>2 + \\<Delta>' \\<oplus> Modal F Fs = \\<Delta> + \\<Delta>'\""], ["proof (prove)\nusing this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>2 \\<oplus> Modal F Fs = \\<Delta>\n\ngoal (1 subgoal):\n 1. M2 \\<cdot> \\<Delta>'' + \\<Delta>2 + \\<Delta>' \\<oplus> Modal F Fs =\n    \\<Delta> + \\<Delta>'", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>2 + \\<Delta>' \\<oplus> Modal F Fs =\n  \\<Delta> + \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "(*>*)"], ["proof (state)\nthis:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>2 + \\<Delta>' \\<oplus> Modal F Fs =\n  \\<Delta> + \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 + \\<Gamma>' = \\<Gamma> + \\<Gamma>'\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>2 + \\<Delta>' \\<oplus> Modal F Fs =\n  \\<Delta> + \\<Delta>'", "have \"(\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',n'+1) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 + \\<Gamma>' = \\<Gamma> + \\<Gamma>'\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>2 + \\<Delta>' \\<oplus> Modal F Fs =\n  \\<Delta> + \\<Delta>'\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n    \\<in> derivable (ext R R2 M1 M2)", "(*<*)"], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 + \\<Gamma>' = \\<Gamma> + \\<Gamma>'\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>2 + \\<Delta>' \\<oplus> Modal F Fs =\n  \\<Delta> + \\<Delta>'\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n    \\<in> derivable (ext R R2 M1 M2)", "using gg"], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 + \\<Gamma>' = \\<Gamma> + \\<Gamma>'\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>2 + \\<Delta>' \\<oplus> Modal F Fs =\n  \\<Delta> + \\<Delta>'\n  ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 +\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>2 +\n                             \\<Delta>' \\<oplus> Modal F Fs,\n   n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n    \\<in> derivable (ext R R2 M1 M2)", "(*>*)"], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 + \\<Gamma>' = \\<Gamma> + \\<Gamma>'\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>2 + \\<Delta>' \\<oplus> Modal F Fs =\n  \\<Delta> + \\<Delta>'\n  ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 +\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>2 +\n                             \\<Delta>' \\<oplus> Modal F Fs,\n   n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n    \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)", "have \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "using \\<open>n = Suc n'\\<close>"], ["proof (prove)\nusing this:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  Modal M Ms \\<in># \\<Delta>1 \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>'' \\<or>\n  Modal M Ms \\<in># \\<Delta>1 \\<or> Modal M Ms = Modal F Fs\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>'' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  Modal M Ms = Modal F Fs \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  Modal M Ms \\<in># \\<Delta>1 \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)", "have \"\\<exists>m\\<le>n. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>'' \\<or>\n  Modal M Ms \\<in># \\<Delta>1 \\<or> Modal M Ms = Modal F Fs\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>'' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  Modal M Ms = Modal F Fs \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  Modal M Ms \\<in># \\<Delta>1 \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "(*<*)"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  r' =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "(*>*)"], ["proof (state)\nthis:\n  r' =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "txt\\<open>\\noindent The other case, where the last inference was a left inference, is more straightforward, and so is omitted.\\<close>"], ["proof (state)\nthis:\n  r' =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "(*<*)"], ["proof (state)\nthis:\n  r' =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  r' =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  r' =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"r' = (ps,\\<LM>Modal F Fs\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (state)\nthis:\n  r' = (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with ba ca \\<open>S = (\\<Gamma>1 \\<Rightarrow>* \\<Delta>1)\\<close>"], ["proof (chain)\npicking this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'\n  S = ( \\<Gamma>1 \\<Rightarrow>* \\<Delta>1)\n  r' = (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)", "have\n                     eq1: \"(M1\\<cdot>\\<Gamma>'' + \\<Gamma>1 \\<oplus> Modal F Fs \\<Rightarrow>* M2\\<cdot>\\<Delta>'' + \\<Delta>1) = (\\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\""], ["proof (prove)\nusing this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'\n  S = ( \\<Gamma>1 \\<Rightarrow>* \\<Delta>1)\n  r' = (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. ( M1 \\<cdot> \\<Gamma>'' +\n      \\<Gamma>1 \\<oplus>\n      Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>1) =\n    ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)", "by (auto simp add:extendRule_def extend_def extendConc_def union_ac)"], ["proof (state)\nthis:\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>1 \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>1) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>1 \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>1) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)", "have eq2: \"M2\\<cdot>\\<Delta>'' + \\<Delta>1 = \\<Delta> \\<oplus> Modal M Ms\""], ["proof (prove)\nusing this:\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>1 \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>1) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. M2 \\<cdot> \\<Delta>'' + \\<Delta>1 = \\<Delta> \\<oplus> Modal M Ms", "by auto"], ["proof (state)\nthis:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 = \\<Delta> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 = \\<Delta> \\<oplus> Modal M Ms", "have \"set_mset (M2 \\<cdot> \\<Delta>'' + \\<Delta>1) = set_mset (\\<Delta> \\<oplus> Modal M Ms)\""], ["proof (prove)\nusing this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 = \\<Delta> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. set_mset (M2 \\<cdot> \\<Delta>'' + \\<Delta>1) =\n    set_mset (\\<Delta> \\<oplus> Modal M Ms)", "by auto"], ["proof (state)\nthis:\n  set_mset (M2 \\<cdot> \\<Delta>'' + \\<Delta>1) =\n  set_mset (\\<Delta> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  set_mset (M2 \\<cdot> \\<Delta>'' + \\<Delta>1) =\n  set_mset (\\<Delta> \\<oplus> Modal M Ms)", "have \"set_mset (\\<LM>Modal M Ms\\<RM>) \\<subseteq> set_mset (M2 \\<cdot> \\<Delta>'') \\<union> set_mset \\<Delta>1\""], ["proof (prove)\nusing this:\n  set_mset (M2 \\<cdot> \\<Delta>'' + \\<Delta>1) =\n  set_mset (\\<Delta> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. set_mset (\\<LM> Modal M Ms  \\<RM>)\n    \\<subseteq> set_mset (M2 \\<cdot> \\<Delta>'') \\<union> set_mset \\<Delta>1", "by auto"], ["proof (state)\nthis:\n  set_mset (\\<LM> Modal M Ms  \\<RM>)\n  \\<subseteq> set_mset (M2 \\<cdot> \\<Delta>'') \\<union> set_mset \\<Delta>1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  set_mset (\\<LM> Modal M Ms  \\<RM>)\n  \\<subseteq> set_mset (M2 \\<cdot> \\<Delta>'') \\<union> set_mset \\<Delta>1", "have \"Modal M Ms \\<in> set_mset (M2\\<cdot>\\<Delta>'') \\<or> Modal M Ms \\<in> set_mset \\<Delta>1\""], ["proof (prove)\nusing this:\n  set_mset (\\<LM> Modal M Ms  \\<RM>)\n  \\<subseteq> set_mset (M2 \\<cdot> \\<Delta>'') \\<union> set_mset \\<Delta>1\n\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># M2 \\<cdot> \\<Delta>'' \\<or>\n    Modal M Ms \\<in># \\<Delta>1", "by auto"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>'' \\<or> Modal M Ms \\<in># \\<Delta>1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>'' \\<or> Modal M Ms \\<in># \\<Delta>1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>'' \\<or> Modal M Ms \\<in># \\<Delta>1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"Modal M Ms \\<in> set_mset (M2\\<cdot>\\<Delta>'')\""], ["proof (state)\nthis:\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>''\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>''", "have \"Modal M Ms \\<in># M2\\<cdot>\\<Delta>''\""], ["proof (prove)\nusing this:\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>''\n\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># M2 \\<cdot> \\<Delta>''", "by auto"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>''\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with modal_not_contain[where M=M and N=M2 and A=Ms and \\<Gamma>=\\<Delta>''] and neq"], ["proof (chain)\npicking this:\n  M \\<noteq> M2 \\<Longrightarrow> Modal M Ms \\<notin># M2 \\<cdot> \\<Delta>''\n  M2 \\<noteq> M\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>''", "have \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  M \\<noteq> M2 \\<Longrightarrow> Modal M Ms \\<notin># M2 \\<cdot> \\<Delta>''\n  M2 \\<noteq> M\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>''\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>'' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>'' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>'' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"Modal M Ms \\<in> set_mset \\<Delta>1\""], ["proof (state)\nthis:\n  Modal M Ms \\<in># \\<Delta>1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  Modal M Ms \\<in># \\<Delta>1", "have \"Modal M Ms \\<in># \\<Delta>1\""], ["proof (prove)\nusing this:\n  Modal M Ms \\<in># \\<Delta>1\n\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># \\<Delta>1", "by auto"], ["proof (state)\nthis:\n  Modal M Ms \\<in># \\<Delta>1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  Modal M Ms \\<in># \\<Delta>1", "have \"\\<exists> \\<Delta>2. \\<Delta>1 = \\<Delta>2 \\<oplus> Modal M Ms\""], ["proof (prove)\nusing this:\n  Modal M Ms \\<in># \\<Delta>1\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Delta>2. \\<Delta>1 = \\<Delta>2 \\<oplus> Modal M Ms", "using insert_DiffM[where x=\"Modal M Ms\" and M=\"\\<Delta>1\"]"], ["proof (prove)\nusing this:\n  Modal M Ms \\<in># \\<Delta>1\n  Modal M Ms \\<in># \\<Delta>1 \\<Longrightarrow>\n  add_mset (Modal M Ms) (\\<Delta>1 \\<ominus> Modal M Ms) = \\<Delta>1\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Delta>2. \\<Delta>1 = \\<Delta>2 \\<oplus> Modal M Ms", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># \\<Delta>1 \\<Longrightarrow>\n    \\<exists>\\<Delta>2. \\<Delta>1 = add_mset (Modal M Ms) \\<Delta>2", "apply (rule_tac x=\"\\<Delta>1\\<ominus>Modal M Ms\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># \\<Delta>1 \\<Longrightarrow>\n    \\<Delta>1 = add_mset (Modal M Ms) (\\<Delta>1 \\<ominus> Modal M Ms)", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  \\<exists>\\<Delta>2. \\<Delta>1 = \\<Delta>2 \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<Delta>2. \\<Delta>1 = \\<Delta>2 \\<oplus> Modal M Ms", "obtain \\<Delta>2 where \"\\<Delta>1 = \\<Delta>2 \\<oplus> Modal M Ms\""], ["proof (prove)\nusing this:\n  \\<exists>\\<Delta>2. \\<Delta>1 = \\<Delta>2 \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Delta>2.\n        \\<Delta>1 = \\<Delta>2 \\<oplus> Modal M Ms \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<Delta>1 = \\<Delta>2 \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "from ba and rules"], ["proof (chain)\npicking this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3", "have \"extendConc (\\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r \\<in> (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n\ngoal (1 subgoal):\n 1. extendConc ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>')\n     r\n    \\<in> ext R R2 M1 M2", "by auto"], ["proof (state)\nthis:\n  extendConc ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  extendConc ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "from ba and ca"], ["proof (chain)\npicking this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'", "have \"fst (extendConc (\\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r) = Ps\""], ["proof (prove)\nusing this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'\n\ngoal (1 subgoal):\n 1. fst (extendConc\n          ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r) =\n    Ps", "by (auto simp add:extendConc_def)"], ["proof (state)\nthis:\n  fst (extendConc\n        ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r) =\n  Ps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  extendConc ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n  fst (extendConc\n        ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r) =\n  Ps", "have \"(snd (extendConc (\\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r),n'+1) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  extendConc ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n  fst (extendConc\n        ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r) =\n  Ps\n\ngoal (1 subgoal):\n 1. (snd (extendConc\n           ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r),\n     n' + 1)\n    \\<in> derivable (ext R R2 M1 M2)", "using d' and derivable.step[where r=\"extendConc (\\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r\"\n                                                     and R=\"ext R R2 M1 M2\" and m=n'] and \\<open>Ps \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  extendConc ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n  fst (extendConc\n        ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r) =\n  Ps\n  \\<forall>p\\<in>set Ps.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n  \\<lbrakk>extendConc\n            ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r\n           \\<in> ext R R2 M1 M2;\n   fst (extendConc\n         ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>')\n         r) \\<noteq>\n   [];\n   \\<forall>p\\<in>set (fst (extendConc\n                             ( \\<Gamma>1 +\n                               \\<Gamma>' \\<Rightarrow>* \\<Delta>2 +\n                  \\<Delta>')\n                             r)).\n      \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\\<rbrakk>\n  \\<Longrightarrow> (snd (extendConc\n                           ( \\<Gamma>1 +\n                             \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>')\n                           r),\n                     n' + 1)\n                    \\<in> derivable (ext R R2 M1 M2)\n  Ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. (snd (extendConc\n           ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r),\n     n' + 1)\n    \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  (snd (extendConc\n         ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r),\n   n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  (snd (extendConc\n         ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r),\n   n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "from ca and \\<open>r' = (ps,\\<LM>Modal F Fs\\<RM> \\<Rightarrow>* \\<Empt>)\\<close>"], ["proof (chain)\npicking this:\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'\n  r' = (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"snd (extendConc (\\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r) = ((M1\\<cdot>\\<Gamma>'' \\<oplus> Modal F Fs)+ \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>'' + \\<Delta>2 + \\<Delta>')\""], ["proof (prove)\nusing this:\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'\n  r' = (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. snd (extendConc\n          ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r) =\n    ( M1 \\<cdot> \\<Gamma>'' \\<oplus> Modal F Fs + \\<Gamma>1 +\n      \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>2 +\n                               \\<Delta>')", "by (auto simp add:extendRule_def extendConc_def extend_def union_ac)"], ["proof (state)\nthis:\n  snd (extendConc\n        ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r) =\n  ( M1 \\<cdot> \\<Gamma>'' \\<oplus> Modal F Fs + \\<Gamma>1 +\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>2 + \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  (snd (extendConc\n         ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r),\n   n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n  snd (extendConc\n        ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r) =\n  ( M1 \\<cdot> \\<Gamma>'' \\<oplus> Modal F Fs + \\<Gamma>1 +\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>2 + \\<Delta>')", "have gg: \"(M1\\<cdot>\\<Gamma>'' + \\<Gamma>1 + \\<Gamma>' \\<oplus> Modal F Fs \\<Rightarrow>* M2\\<cdot>\\<Delta>'' + \\<Delta>2 + \\<Delta>',n'+1) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  (snd (extendConc\n         ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r),\n   n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n  snd (extendConc\n        ( \\<Gamma>1 + \\<Gamma>' \\<Rightarrow>* \\<Delta>2 + \\<Delta>') r) =\n  ( M1 \\<cdot> \\<Gamma>'' \\<oplus> Modal F Fs + \\<Gamma>1 +\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>2 + \\<Delta>')\n\ngoal (1 subgoal):\n 1. ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 +\n      \\<Gamma>' \\<oplus>\n      Modal F\n       Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>2 + \\<Delta>',\n     n' + 1)\n    \\<in> derivable (ext R R2 M1 M2)", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 +\n    \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>2 + \\<Delta>',\n   n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "from eq1"], ["proof (chain)\npicking this:\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>1 \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>1) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)", "have \"M1\\<cdot>\\<Gamma>'' + \\<Gamma>1 \\<oplus> Modal F Fs  = \\<Gamma>\""], ["proof (prove)\nusing this:\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>1 \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>1) =\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 \\<oplus> Modal F Fs = \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 \\<oplus> Modal F Fs = \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 \\<oplus> Modal F Fs = \\<Gamma>", "have \"(M1\\<cdot>\\<Gamma>'' + \\<Gamma>1 + \\<Gamma>') \\<oplus> Modal F Fs = \\<Gamma> + \\<Gamma>'\""], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 \\<oplus> Modal F Fs = \\<Gamma>\n\ngoal (1 subgoal):\n 1. (M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 + \\<Gamma>') \\<oplus> Modal F Fs =\n    \\<Gamma> + \\<Gamma>'", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  (M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 + \\<Gamma>') \\<oplus> Modal F Fs =\n  \\<Gamma> + \\<Gamma>'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  (M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 + \\<Gamma>') \\<oplus> Modal F Fs =\n  \\<Gamma> + \\<Gamma>'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "from eq2 and \\<open>\\<Delta>1 = \\<Delta>2 \\<oplus> Modal M Ms\\<close>"], ["proof (chain)\npicking this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 = \\<Delta> \\<oplus> Modal M Ms\n  \\<Delta>1 = \\<Delta>2 \\<oplus> Modal M Ms", "have \"M2\\<cdot>\\<Delta>'' + \\<Delta>2 \\<oplus> Modal M Ms = \\<Delta> \\<oplus> Modal M Ms\""], ["proof (prove)\nusing this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 = \\<Delta> \\<oplus> Modal M Ms\n  \\<Delta>1 = \\<Delta>2 \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. M2 \\<cdot> \\<Delta>'' + \\<Delta>2 \\<oplus> Modal M Ms =\n    \\<Delta> \\<oplus> Modal M Ms", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>2 \\<oplus> Modal M Ms =\n  \\<Delta> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>2 \\<oplus> Modal M Ms =\n  \\<Delta> \\<oplus> Modal M Ms", "have \"M2\\<cdot>\\<Delta>'' + \\<Delta>2 = \\<Delta>\""], ["proof (prove)\nusing this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>2 \\<oplus> Modal M Ms =\n  \\<Delta> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. M2 \\<cdot> \\<Delta>'' + \\<Delta>2 = \\<Delta>", "using add_equal_means_equal[where \\<Gamma>=\" M2 \\<cdot> \\<Delta>'' + \\<Delta>2\" and \\<Delta>=\\<Delta> and A=\"Modal M Ms\"]"], ["proof (prove)\nusing this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>2 \\<oplus> Modal M Ms =\n  \\<Delta> \\<oplus> Modal M Ms\n  (M2 \\<cdot> \\<Delta>'' + \\<Delta>2) \\<oplus> Modal M Ms =\n  \\<Delta> \\<oplus> Modal M Ms \\<Longrightarrow>\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>2 = \\<Delta>\n\ngoal (1 subgoal):\n 1. M2 \\<cdot> \\<Delta>'' + \\<Delta>2 = \\<Delta>", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>2 = \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>2 = \\<Delta>", "have \"M2\\<cdot>\\<Delta>'' + \\<Delta>2 + \\<Delta>'  = \\<Delta> + \\<Delta>'\""], ["proof (prove)\nusing this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>2 = \\<Delta>\n\ngoal (1 subgoal):\n 1. M2 \\<cdot> \\<Delta>'' + \\<Delta>2 + \\<Delta>' = \\<Delta> + \\<Delta>'", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>2 + \\<Delta>' = \\<Delta> + \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  (M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 + \\<Gamma>') \\<oplus> Modal F Fs =\n  \\<Gamma> + \\<Gamma>'\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>2 + \\<Delta>' = \\<Delta> + \\<Delta>'", "have \"(\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',n'+1) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  (M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 + \\<Gamma>') \\<oplus> Modal F Fs =\n  \\<Gamma> + \\<Gamma>'\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>2 + \\<Delta>' = \\<Delta> + \\<Delta>'\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n    \\<in> derivable (ext R R2 M1 M2)", "using gg"], ["proof (prove)\nusing this:\n  (M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 + \\<Gamma>') \\<oplus> Modal F Fs =\n  \\<Gamma> + \\<Gamma>'\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>2 + \\<Delta>' = \\<Delta> + \\<Delta>'\n  ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 +\n    \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>2 + \\<Delta>',\n   n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n    \\<in> derivable (ext R R2 M1 M2)", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)", "have \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "using \\<open>n = Suc n'\\<close>"], ["proof (prove)\nusing this:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  Modal M Ms \\<in># \\<Delta>1 \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>'' \\<or> Modal M Ms \\<in># \\<Delta>1\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>'' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  Modal M Ms \\<in># \\<Delta>1 \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)", "have \"\\<exists>m\\<le>n. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>'' \\<or> Modal M Ms \\<in># \\<Delta>1\n  Modal M Ms \\<in># M2 \\<cdot> \\<Delta>'' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  Modal M Ms \\<in># \\<Delta>1 \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  r' =\n  (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  S = ( \\<Gamma>1 \\<Rightarrow>* \\<Delta>1)\n  r' =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  r' =\n  (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)", "have \"\\<exists>m\\<le>n. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  S = ( \\<Gamma>1 \\<Rightarrow>* \\<Delta>1)\n  r' =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  r' =\n  (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "using cc"], ["proof (prove)\nusing this:\n  S = ( \\<Gamma>1 \\<Rightarrow>* \\<Delta>1)\n  r' =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  r' =\n  (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n  r' = (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,\n    \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<or>\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r \\<in> R\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,\n    \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,\n    \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)", "show \"\\<exists>m\\<le>n. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<or>\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms)\n  r \\<in> R\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,\n    \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,\n    \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> Modal M Ms) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma leftInvert:\nfixes \\<Gamma> \\<Delta> :: \"('a,'b) form multiset\"\nassumes rules: \"R1 \\<subseteq> upRules \\<and> R2 \\<subseteq> modRules2 \\<and> R3 \\<subseteq> modRules2 \\<and> R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and> R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\"\n    and   a: \"(\\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>,n) \\<in> derivable (ext R R2 M1 M2)\"\n    and   b: \"\\<forall> r' \\<in> R'. leftPrincipal r' (Modal M Ms) R' \\<longrightarrow> (\\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\"\n    and neq: \"M1 \\<noteq> M\"\nshows \"\\<exists> m\\<le>n. (\\<Gamma> +\\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "using assms"], ["proof (prove)\nusing this:\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, n)\n  \\<in> derivable (ext R R2 M1 M2)\n  \\<forall>r'\\<in>R'.\n     leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\n  M1 \\<noteq> M\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "proof (induct n arbitrary: \\<Gamma> \\<Delta> rule:nat_less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n \\<Gamma> \\<Delta>.\n       \\<lbrakk>\\<forall>m<n.\n                   R1 \\<subseteq> upRules \\<and>\n                   R2 \\<subseteq> modRules2 \\<and>\n                   R3 \\<subseteq> modRules2 \\<and>\n                   R =\n                   Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n                   R' =\n                   Ax \\<union> R1 \\<union> R2 \\<union> R3 \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ( x \\<oplus> Modal M Ms \\<Rightarrow>* xa, m)\n                       \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n                       (\\<forall>r'\\<in>R'.\n                           leftPrincipal r' (Modal M Ms)\n                            R' \\<longrightarrow>\n                           ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n                           \\<in> set (fst r')) \\<longrightarrow>\n                       M1 \\<noteq> M \\<longrightarrow>\n                       (\\<exists>ma\\<le>m.\n                           ( x + \\<Gamma>' \\<Rightarrow>* xa + \\<Delta>',\n                            ma)\n                           \\<in> derivable (ext R R2 M1 M2)));\n        R1 \\<subseteq> upRules \\<and>\n        R2 \\<subseteq> modRules2 \\<and>\n        R3 \\<subseteq> modRules2 \\<and>\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, n)\n        \\<in> derivable (ext R R2 M1 M2);\n        \\<forall>r'\\<in>R'.\n           leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n           ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r');\n        M1 \\<noteq> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<le>n.\n                            ( \\<Gamma> +\n                              \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2)", "case (1 n \\<Gamma> \\<Delta>)"], ["proof (state)\nthis:\n  \\<forall>m<n.\n     R1 \\<subseteq> upRules \\<and>\n     R2 \\<subseteq> modRules2 \\<and>\n     R3 \\<subseteq> modRules2 \\<and>\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3 \\<longrightarrow>\n     (\\<forall>x xa.\n         ( x \\<oplus> Modal M Ms \\<Rightarrow>* xa, m)\n         \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n         (\\<forall>r'\\<in>R'.\n             leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n             ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n             \\<in> set (fst r')) \\<longrightarrow>\n         M1 \\<noteq> M \\<longrightarrow>\n         (\\<exists>ma\\<le>m.\n             ( x + \\<Gamma>' \\<Rightarrow>* xa + \\<Delta>', ma)\n             \\<in> derivable (ext R R2 M1 M2)))\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, n)\n  \\<in> derivable (ext R R2 M1 M2)\n  \\<forall>r'\\<in>R'.\n     leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\n  M1 \\<noteq> M\n\ngoal (1 subgoal):\n 1. \\<And>n \\<Gamma> \\<Delta>.\n       \\<lbrakk>\\<forall>m<n.\n                   R1 \\<subseteq> upRules \\<and>\n                   R2 \\<subseteq> modRules2 \\<and>\n                   R3 \\<subseteq> modRules2 \\<and>\n                   R =\n                   Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n                   R' =\n                   Ax \\<union> R1 \\<union> R2 \\<union> R3 \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ( x \\<oplus> Modal M Ms \\<Rightarrow>* xa, m)\n                       \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n                       (\\<forall>r'\\<in>R'.\n                           leftPrincipal r' (Modal M Ms)\n                            R' \\<longrightarrow>\n                           ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n                           \\<in> set (fst r')) \\<longrightarrow>\n                       M1 \\<noteq> M \\<longrightarrow>\n                       (\\<exists>ma\\<le>m.\n                           ( x + \\<Gamma>' \\<Rightarrow>* xa + \\<Delta>',\n                            ma)\n                           \\<in> derivable (ext R R2 M1 M2)));\n        R1 \\<subseteq> upRules \\<and>\n        R2 \\<subseteq> modRules2 \\<and>\n        R3 \\<subseteq> modRules2 \\<and>\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, n)\n        \\<in> derivable (ext R R2 M1 M2);\n        \\<forall>r'\\<in>R'.\n           leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n           ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r');\n        M1 \\<noteq> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<le>n.\n                            ( \\<Gamma> +\n                              \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<forall>m<n.\n     R1 \\<subseteq> upRules \\<and>\n     R2 \\<subseteq> modRules2 \\<and>\n     R3 \\<subseteq> modRules2 \\<and>\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3 \\<longrightarrow>\n     (\\<forall>x xa.\n         ( x \\<oplus> Modal M Ms \\<Rightarrow>* xa, m)\n         \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n         (\\<forall>r'\\<in>R'.\n             leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n             ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n             \\<in> set (fst r')) \\<longrightarrow>\n         M1 \\<noteq> M \\<longrightarrow>\n         (\\<exists>ma\\<le>m.\n             ( x + \\<Gamma>' \\<Rightarrow>* xa + \\<Delta>', ma)\n             \\<in> derivable (ext R R2 M1 M2)))\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, n)\n  \\<in> derivable (ext R R2 M1 M2)\n  \\<forall>r'\\<in>R'.\n     leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\n  M1 \\<noteq> M", "have IH:\"\\<forall>m<n. \\<forall>\\<Gamma> \\<Delta>. ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, m) \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n              (\\<forall>r' \\<in> R'. leftPrincipal r' (Modal M Ms) R' \\<longrightarrow> ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')) \\<longrightarrow>\n              (\\<exists>m'\\<le>m. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m') \\<in> derivable (ext R R2 M1 M2))\" \n     and a': \"(\\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>,n) \\<in> derivable (ext R R2 M1 M2)\" \n     and b': \"\\<forall> r' \\<in> R'. leftPrincipal r' (Modal M Ms) R' \\<longrightarrow> (\\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\""], ["proof (prove)\nusing this:\n  \\<forall>m<n.\n     R1 \\<subseteq> upRules \\<and>\n     R2 \\<subseteq> modRules2 \\<and>\n     R3 \\<subseteq> modRules2 \\<and>\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3 \\<longrightarrow>\n     (\\<forall>x xa.\n         ( x \\<oplus> Modal M Ms \\<Rightarrow>* xa, m)\n         \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n         (\\<forall>r'\\<in>R'.\n             leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n             ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n             \\<in> set (fst r')) \\<longrightarrow>\n         M1 \\<noteq> M \\<longrightarrow>\n         (\\<exists>ma\\<le>m.\n             ( x + \\<Gamma>' \\<Rightarrow>* xa + \\<Delta>', ma)\n             \\<in> derivable (ext R R2 M1 M2)))\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, n)\n  \\<in> derivable (ext R R2 M1 M2)\n  \\<forall>r'\\<in>R'.\n     leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\n  M1 \\<noteq> M\n\ngoal (1 subgoal):\n 1. \\<forall>m<n.\n       \\<forall>\\<Gamma> \\<Delta>.\n          ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, m)\n          \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n          (\\<forall>r'\\<in>R'.\n              leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n              ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n              \\<in> set (fst r')) \\<longrightarrow>\n          (\\<exists>m'\\<le>m.\n              ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n               m')\n              \\<in> derivable (ext R R2 M1 M2)) &&&\n    ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, n)\n    \\<in> derivable (ext R R2 M1 M2) &&&\n    \\<forall>r'\\<in>R'.\n       leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n       ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')", "by auto"], ["proof (state)\nthis:\n  \\<forall>m<n.\n     \\<forall>\\<Gamma> \\<Delta>.\n        ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, m)\n        \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n        (\\<forall>r'\\<in>R'.\n            leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n            ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n            \\<in> set (fst r')) \\<longrightarrow>\n        (\\<exists>m'\\<le>m.\n            ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m')\n            \\<in> derivable (ext R R2 M1 M2))\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, n)\n  \\<in> derivable (ext R R2 M1 M2)\n  \\<forall>r'\\<in>R'.\n     leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\n\ngoal (1 subgoal):\n 1. \\<And>n \\<Gamma> \\<Delta>.\n       \\<lbrakk>\\<forall>m<n.\n                   R1 \\<subseteq> upRules \\<and>\n                   R2 \\<subseteq> modRules2 \\<and>\n                   R3 \\<subseteq> modRules2 \\<and>\n                   R =\n                   Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n                   R' =\n                   Ax \\<union> R1 \\<union> R2 \\<union> R3 \\<longrightarrow>\n                   (\\<forall>x xa.\n                       ( x \\<oplus> Modal M Ms \\<Rightarrow>* xa, m)\n                       \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n                       (\\<forall>r'\\<in>R'.\n                           leftPrincipal r' (Modal M Ms)\n                            R' \\<longrightarrow>\n                           ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n                           \\<in> set (fst r')) \\<longrightarrow>\n                       M1 \\<noteq> M \\<longrightarrow>\n                       (\\<exists>ma\\<le>m.\n                           ( x + \\<Gamma>' \\<Rightarrow>* xa + \\<Delta>',\n                            ma)\n                           \\<in> derivable (ext R R2 M1 M2)));\n        R1 \\<subseteq> upRules \\<and>\n        R2 \\<subseteq> modRules2 \\<and>\n        R3 \\<subseteq> modRules2 \\<and>\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, n)\n        \\<in> derivable (ext R R2 M1 M2);\n        \\<forall>r'\\<in>R'.\n           leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n           ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r');\n        M1 \\<noteq> M\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<le>n.\n                            ( \\<Gamma> +\n                              \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  n = 0", "have \"(\\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>,0) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, 0)\n    \\<in> derivable (ext R R2 M1 M2)", "using a'"], ["proof (prove)\nusing this:\n  n = 0\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, n)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, 0)\n    \\<in> derivable (ext R R2 M1 M2)", "by simp"], ["proof (state)\nthis:\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, 0)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, 0)\n  \\<in> derivable (ext R R2 M1 M2)", "have \"([],\\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>) \\<in> (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, 0)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. ([],  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n    \\<in> ext R R2 M1 M2", "by (cases) (auto)"], ["proof (state)\nthis:\n  ([],  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  \\<in> ext R R2 M1 M2\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  ([],  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  \\<in> ext R R2 M1 M2", "have \"\\<exists> r S. extendRule S r = ([],\\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>) \\<and> (r \\<in> Ax)\""], ["proof (prove)\nusing this:\n  ([],  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  \\<in> ext R R2 M1 M2\n\ngoal (1 subgoal):\n 1. \\<exists>r S.\n       extendRule S r =\n       ([],  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>) \\<and>\n       r \\<in> Ax", "using rules"], ["proof (prove)\nusing this:\n  ([],  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  \\<in> ext R R2 M1 M2\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n\ngoal (1 subgoal):\n 1. \\<exists>r S.\n       extendRule S r =\n       ([],  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>) \\<and>\n       r \\<in> Ax", "apply-"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>([],  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n             \\<in> ext R R2 M1 M2;\n     R1 \\<subseteq> upRules \\<and>\n     R2 \\<subseteq> modRules2 \\<and>\n     R3 \\<subseteq> modRules2 \\<and>\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>r S.\n                         extendRule S r =\n                         ([],\n                           \\<Gamma> \\<oplus>\n                           Modal M Ms \\<Rightarrow>* \\<Delta>) \\<and>\n                         r \\<in> Ax", "apply (rule ext.cases [where 'a = 'a and 'b = 'b])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>([],  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n             \\<in> ext R R2 M1 M2;\n     R1 \\<subseteq> upRules \\<and>\n     R2 \\<subseteq> modRules2 \\<and>\n     R3 \\<subseteq> modRules2 \\<and>\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\\<rbrakk>\n    \\<Longrightarrow> ?a2 \\<in> ext ?R2 ?R'2 ?M2 ?N2\n 2. \\<And>r seq.\n       \\<lbrakk>([],  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n                \\<in> ext R R2 M1 M2;\n        R1 \\<subseteq> upRules \\<and>\n        R2 \\<subseteq> modRules2 \\<and>\n        R3 \\<subseteq> modRules2 \\<and>\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ?a2 = extendRule seq r; r \\<in> ?R2;\n        case r of (x, xa) \\<Rightarrow> (x, xa) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r S.\n                            extendRule S r =\n                            ([],\n                              \\<Gamma> \\<oplus>\n                              Modal M Ms \\<Rightarrow>* \\<Delta>) \\<and>\n                            r \\<in> Ax\n 3. \\<And>r seq.\n       \\<lbrakk>([],  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n                \\<in> ext R R2 M1 M2;\n        R1 \\<subseteq> upRules \\<and>\n        R2 \\<subseteq> modRules2 \\<and>\n        R3 \\<subseteq> modRules2 \\<and>\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ?a2 = extendRule seq r; r \\<in> ?R2;\n        case r of (x, xa) \\<Rightarrow> (x, xa) \\<in> upRules\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r S.\n                            extendRule S r =\n                            ([],\n                              \\<Gamma> \\<oplus>\n                              Modal M Ms \\<Rightarrow>* \\<Delta>) \\<and>\n                            r \\<in> Ax\n 4. \\<And>r seq.\n       \\<lbrakk>([],  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n                \\<in> ext R R2 M1 M2;\n        R1 \\<subseteq> upRules \\<and>\n        R2 \\<subseteq> modRules2 \\<and>\n        R3 \\<subseteq> modRules2 \\<and>\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ?a2 = extendConc seq r; r \\<in> p_e ?R'2 ?M2 ?N2;\n        r \\<in> ?R2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r S.\n                            extendRule S r =\n                            ([],\n                              \\<Gamma> \\<oplus>\n                              Modal M Ms \\<Rightarrow>* \\<Delta>) \\<and>\n                            r \\<in> Ax\n 5. \\<And>r seq.\n       \\<lbrakk>([],  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n                \\<in> ext R R2 M1 M2;\n        R1 \\<subseteq> upRules \\<and>\n        R2 \\<subseteq> modRules2 \\<and>\n        R3 \\<subseteq> modRules2 \\<and>\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ?a2 = extendRule seq r; r \\<in> ?R2;\n        case r of (x, xa) \\<Rightarrow> (x, xa) \\<in> modRules2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r S.\n                            extendRule S r =\n                            ([],\n                              \\<Gamma> \\<oplus>\n                              Modal M Ms \\<Rightarrow>* \\<Delta>) \\<and>\n                            r \\<in> Ax", "apply (auto simp add:extendRule_def extend_def)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 2. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> Ax; R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 3. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> Ax; R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 4. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> Ax; R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 8. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 9. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 10. \\<And>a b seq.\n        \\<lbrakk>extendConc seq (a, b)\n                 \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union>\n                            R3)\n                        R2 M1 M2;\n         ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n         extendConc seq (a, b);\n         (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n         R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n         R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n         R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n         (a, b) \\<in> R1\\<rbrakk>\n        \\<Longrightarrow> \\<exists>b S.\n                             antec S + antec b =\n                             add_mset (Modal M Ms) \\<Gamma> \\<and>\n                             succ S + succ b = \\<Delta> \\<and>\n                             ([], b) \\<in> Ax\nA total of 16 subgoals...", "apply (rule_tac x=b in exI)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>S.\n                            antec S + antec b = antec seq + antec b \\<and>\n                            succ S + succ b = succ seq + succ b \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> Ax; R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 3. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> Ax; R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 4. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> Ax; R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 8. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 9. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 10. \\<And>a b seq.\n        \\<lbrakk>extendConc seq (a, b)\n                 \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union>\n                            R3)\n                        R2 M1 M2;\n         ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n         extendConc seq (a, b);\n         (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n         R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n         R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n         R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n         (a, b) \\<in> R1\\<rbrakk>\n        \\<Longrightarrow> \\<exists>b S.\n                             antec S + antec b =\n                             add_mset (Modal M Ms) \\<Gamma> \\<and>\n                             succ S + succ b = \\<Delta> \\<and>\n                             ([], b) \\<in> Ax\nA total of 16 subgoals...", "apply (rule_tac x=seq in exI)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> antec seq + antec b = antec seq + antec b \\<and>\n                         succ seq + succ b = succ seq + succ b \\<and>\n                         ([], b) \\<in> Ax\n 2. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> Ax; R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 3. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> Ax; R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 4. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> Ax; R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 8. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 9. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 10. \\<And>a b seq.\n        \\<lbrakk>extendConc seq (a, b)\n                 \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union>\n                            R3)\n                        R2 M1 M2;\n         ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n         extendConc seq (a, b);\n         (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n         R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n         R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n         R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n         (a, b) \\<in> R1\\<rbrakk>\n        \\<Longrightarrow> \\<exists>b S.\n                             antec S + antec b =\n                             add_mset (Modal M Ms) \\<Gamma> \\<and>\n                             succ S + succ b = \\<Delta> \\<and>\n                             ([], b) \\<in> Ax\nA total of 16 subgoals...", "apply auto"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 2. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 3. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 6. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 7. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 8. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 9. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 10. \\<And>b seq.\n        \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                 \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union>\n                            R3)\n                        R2 M1 M2;\n         ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n         R2 \\<subseteq> modRules2;\n         add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n         \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n         R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n         R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n         ([], b) \\<in> R3\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ba S.\n                             antec S + antec ba = antec seq + antec b \\<and>\n                             succ S + succ ba = succ seq + succ b \\<and>\n                             ([], ba) \\<in> Ax", "apply (rule upRules.cases)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> (?a1.406 b seq, ?a2.406 b seq) \\<in> upRules\n 2. \\<And>b seq c Ra Fs ps.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        ?a1.406 b seq = ps; ?a2.406 b seq = c;\n        ModalSequents.mset c = \\<LM> Compound Ra Fs  \\<RM>;\n        ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 3. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 4. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 5. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 6. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 7. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 8. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 9. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 10. \\<And>b seq.\n        \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                 \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union>\n                            R3)\n                        R2 M1 M2;\n         ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n         R2 \\<subseteq> modRules2;\n         add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n         \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n         R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n         R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n         ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ba S.\n                             antec S + antec ba = antec seq + antec b \\<and>\n                             succ S + succ ba = succ seq + succ b \\<and>\n                             ([], ba) \\<in> Ax\nA total of 11 subgoals...", "apply auto"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 2. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 6. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 8. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 9. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (rule upRules.cases)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> (?a1.413 b seq, ?a2.413 b seq) \\<in> upRules\n 2. \\<And>b seq c Ra Fs ps.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2; ?a1.413 b seq = ps; ?a2.413 b seq = c;\n        ModalSequents.mset c = \\<LM> Compound Ra Fs  \\<RM>;\n        ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 3. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 6. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 7. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 8. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 9. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 10. \\<And>b seq.\n        \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                 \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union>\n                            R3)\n                        R2 M1 M2;\n         ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n         R2 \\<subseteq> modRules2;\n         add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n         \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n         R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n         R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n         ([], b) \\<in> R3\\<rbrakk>\n        \\<Longrightarrow> \\<exists>ba S.\n                             antec S + antec ba = antec seq + antec b \\<and>\n                             succ S + succ ba = succ seq + succ b \\<and>\n                             ([], ba) \\<in> Ax", "apply auto"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 2. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 8. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (rule upRules.cases)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> (?a1.420 b seq, ?a2.420 b seq) \\<in> upRules\n 2. \\<And>b seq c Ra Fs ps.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> upRules; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        ?a1.420 b seq = ps; ?a2.420 b seq = c;\n        ModalSequents.mset c = \\<LM> Compound Ra Fs  \\<RM>;\n        ps \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 6. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 8. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 9. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply auto"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> R3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (insert p_e_non_empty[where R=R2 and M=M1 and N=M2])"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> Ax;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R1;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R3;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (rule Ax.cases)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> Ax;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (?a1.441 a b seq, ?a2.441 a b seq) \\<in> Ax\n 2. \\<And>a b seq i.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> Ax;\n        \\<And>r. r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> [];\n        ?a1.441 a b seq = [];\n        ?a2.441 a b seq =\n        ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> Ax;\n        \\<And>r. r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> [];\n        ?a1.441 a b seq = [];\n        ?a2.441 a b seq = ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R1;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 6. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R3;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 8. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 9. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>r.\n           r \\<in> p_e R2 M1 M2 \\<Longrightarrow> fst r \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply auto"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>seq i.\n       \\<lbrakk>extendConc seq\n                 ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq\n         ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>);\n        ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n        \\<in> p_e R2 M1 M2;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<in> Ax;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>seq.\n       \\<lbrakk>extendConc seq ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>);\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> p_e R2 M1 M2;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 8. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (drule_tac x=\"[]\" in meta_spec)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>seq i.\n       \\<lbrakk>extendConc seq\n                 ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq\n         ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>);\n        ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n        \\<in> p_e R2 M1 M2;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<in> Ax;\n        \\<And>b.\n           ([], b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>seq.\n       \\<lbrakk>extendConc seq ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>);\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> p_e R2 M1 M2;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 8. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (drule_tac x=\"\\<LM>At i\\<RM> \\<Rightarrow>* \\<LM>At i\\<RM>\" in meta_spec)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>seq i.\n       \\<lbrakk>extendConc seq\n                 ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq\n         ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>);\n        ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n        \\<in> p_e R2 M1 M2;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<in> Ax;\n        ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n        \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n        [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>seq.\n       \\<lbrakk>extendConc seq ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>);\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> p_e R2 M1 M2;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 8. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply auto"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>seq.\n       \\<lbrakk>extendConc seq ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>);\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> p_e R2 M1 M2;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (drule_tac x=\"[]\" in meta_spec)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>seq.\n       \\<lbrakk>extendConc seq ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>);\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> p_e R2 M1 M2;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax;\n        \\<And>b.\n           ([], b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (drule_tac x=\"\\<LM>ff\\<RM> \\<Rightarrow>* \\<Empt>\" in meta_spec)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>seq.\n       \\<lbrakk>extendConc seq ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>);\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> p_e R2 M1 M2;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax;\n        ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n        \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n        [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 7. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply auto"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (drule_tac x=a in meta_spec)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R1;\n        \\<And>b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (drule_tac x=b in meta_spec)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R1;\n        (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow> a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (a, b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>a b seq.\n       \\<lbrakk>extendConc seq (a, b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([],  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extendConc seq (a, b);\n        (a, b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; (a, b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 4. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 6. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (auto simp add:extendConc_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([], extend seq b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ( add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extend seq b;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>b seq.\n       \\<lbrakk>([], extend seq b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ( add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extend seq b;\n        ([], b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 4. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (drule_tac x=\"[]\" in meta_spec)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([], extend seq b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ( add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extend seq b;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>b.\n           ([], b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>b seq.\n       \\<lbrakk>([], extend seq b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ( add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extend seq b;\n        ([], b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 4. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (drule_tac x=b in meta_spec)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([], extend seq b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ( add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extend seq b;\n        R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        ([], b) \\<in> p_e R2 M1 M2 \\<Longrightarrow> [] \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>b seq.\n       \\<lbrakk>([], extend seq b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ( add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extend seq b;\n        ([], b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 3. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 4. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([], extend seq b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ( add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extend seq b;\n        ([], b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 3. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 4. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "apply (subgoal_tac \"([],b) \\<in> modRules2\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>b seq.\n       \\<lbrakk>([], extend seq b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ( add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extend seq b;\n        ([], b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow> a \\<noteq> [];\n        ([], b) \\<in> modRules2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b S.\n                            antec S + antec b =\n                            add_mset (Modal M Ms) \\<Gamma> \\<and>\n                            succ S + succ b = \\<Delta> \\<and>\n                            ([], b) \\<in> Ax\n 2. \\<And>b seq.\n       \\<lbrakk>([], extend seq b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ( add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>) =\n        extend seq b;\n        ([], b) \\<in> p_e R2 M1 M2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ([], b) \\<in> modRules2\n 3. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R1;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 4. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        ([], b) \\<in> p_e R2 M1 M2;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax\n 5. \\<And>b seq.\n       \\<lbrakk>([],  antec seq + antec b \\<Rightarrow>* succ seq + succ b)\n                \\<in> ext (Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3)\n                       R2 M1 M2;\n        ([], b) \\<in> modRules2; R1 \\<subseteq> upRules;\n        R2 \\<subseteq> modRules2;\n        add_mset (Modal M Ms) \\<Gamma> = antec seq + antec b;\n        \\<Delta> = succ seq + succ b; R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3; ([], b) \\<in> R3;\n        \\<And>a b.\n           (a, b) \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n           a \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba S.\n                            antec S + antec ba = antec seq + antec b \\<and>\n                            succ S + succ ba = succ seq + succ b \\<and>\n                            ([], ba) \\<in> Ax", "by (rule modRules2.cases,auto)+"], ["proof (state)\nthis:\n  \\<exists>r S.\n     extendRule S r =\n     ([],  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>) \\<and>\n     r \\<in> Ax\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<exists>r S.\n     extendRule S r =\n     ([],  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>) \\<and>\n     r \\<in> Ax", "obtain r S where \"extendRule S r = ([],\\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\" and \"r \\<in> Ax\""], ["proof (prove)\nusing this:\n  \\<exists>r S.\n     extendRule S r =\n     ([],  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>) \\<and>\n     r \\<in> Ax\n\ngoal (1 subgoal):\n 1. (\\<And>S r.\n        \\<lbrakk>extendRule S r =\n                 ([],\n                   \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>);\n         r \\<in> Ax\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  extendRule S r =\n  ([],  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r \\<in> Ax\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  extendRule S r =\n  ([],  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r \\<in> Ax", "obtain i xs where \"([], \\<LM> At i \\<RM> \\<Rightarrow>* \\<LM> At i \\<RM>) = r \\<or> r = ([],\\<LM>ff\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  extendRule S r =\n  ([],  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r \\<in> Ax\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) = r \\<or>\n        r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using characteriseAx[where r=r]"], ["proof (prove)\nusing this:\n  extendRule S r =\n  ([],  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r \\<in> Ax\n  r \\<in> Ax \\<Longrightarrow>\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n  (\\<exists>i.\n      r = ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) = r \\<or>\n        r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) = r \\<or>\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) = r \\<or>\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) = r \\<or>\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"r = ([],\\<LM>At i\\<RM> \\<Rightarrow>* \\<LM>At i\\<RM>)\""], ["proof (state)\nthis:\n  r = ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with \\<open>extendRule S r = ([],\\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\\<close>"], ["proof (chain)\npicking this:\n  extendRule S r =\n  ([],  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r = ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)", "have \"extend S (\\<LM> At i \\<RM> \\<Rightarrow>* \\<LM> At i \\<RM>) = (\\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\""], ["proof (prove)\nusing this:\n  extendRule S r =\n  ([],  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r = ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n\ngoal (1 subgoal):\n 1. extend S ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n    ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)", "using extendRule_def[where R=\"([],\\<LM>At i\\<RM> \\<Rightarrow>* \\<LM>At i\\<RM>)\" and forms=S]"], ["proof (prove)\nusing this:\n  extendRule S r =\n  ([],  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r = ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\n  extendRule S\n   ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<equiv>\n  (map (extend S)\n    (fst ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)),\n   extend S (snd ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)))\n\ngoal (1 subgoal):\n 1. extend S ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n    ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)", "by auto"], ["proof (state)\nthis:\n  extend S ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  extend S ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)", "have \"At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>\""], ["proof (prove)\nusing this:\n  extend S ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>", "using extendID[where S=S and i=i and \\<Gamma>=\"\\<Gamma>\\<oplus> Modal M Ms\" and \\<Delta>=\\<Delta>]"], ["proof (prove)\nusing this:\n  extend S ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  extend S ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) =\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>) \\<Longrightarrow>\n  At i \\<in># \\<Gamma> \\<oplus> Modal M Ms \\<and> At i \\<in># \\<Delta>\n\ngoal (1 subgoal):\n 1. At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>", "by auto"], ["proof (state)\nthis:\n  At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>", "have \"At i \\<in># \\<Gamma> + \\<Gamma>' \\<and> At i \\<in># \\<Delta> + \\<Delta>'\""], ["proof (prove)\nusing this:\n  At i \\<in># \\<Gamma> \\<and> At i \\<in># \\<Delta>\n\ngoal (1 subgoal):\n 1. At i \\<in># \\<Gamma> + \\<Gamma>' \\<and> At i \\<in># \\<Delta> + \\<Delta>'", "by auto"], ["proof (state)\nthis:\n  At i \\<in># \\<Gamma> + \\<Gamma>' \\<and> At i \\<in># \\<Delta> + \\<Delta>'\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  At i \\<in># \\<Gamma> + \\<Gamma>' \\<and> At i \\<in># \\<Delta> + \\<Delta>'", "have \"(\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',0) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  At i \\<in># \\<Gamma> + \\<Gamma>' \\<and> At i \\<in># \\<Delta> + \\<Delta>'\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n    \\<in> derivable (ext R R2 M1 M2)", "using rules\n               and containID[where \\<Gamma>=\"\\<Gamma> + \\<Gamma>'\" and i=i and \\<Delta>=\"\\<Delta> + \\<Delta>'\" and R=R]"], ["proof (prove)\nusing this:\n  At i \\<in># \\<Gamma> + \\<Gamma>' \\<and> At i \\<in># \\<Delta> + \\<Delta>'\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  \\<lbrakk>At i \\<in># \\<Gamma> + \\<Gamma>' \\<and>\n           At i \\<in># \\<Delta> + \\<Delta>';\n   Ax \\<subseteq> R\\<rbrakk>\n  \\<Longrightarrow> ( \\<Gamma> +\n                      \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                     0)\n                    \\<in> derivable (ext R ?R' ?M ?N)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n    \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  r =\n  ([],\n    \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  r =\n  ([],\n    \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  r =\n  ([],\n    \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"r = ([],\\<LM>ff\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (state)\nthis:\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with \\<open>extendRule S r = ([],\\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\\<close>"], ["proof (chain)\npicking this:\n  extendRule S r =\n  ([],  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"extend S (\\<LM> ff \\<RM> \\<Rightarrow>* \\<Empt>) = (\\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\""], ["proof (prove)\nusing this:\n  extendRule S r =\n  ([],  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. extend S ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n    ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)", "using extendRule_def[where R=\"([],\\<LM>ff\\<RM> \\<Rightarrow>* \\<Empt>)\" and forms=S]"], ["proof (prove)\nusing this:\n  extendRule S r =\n  ([],  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n  extendRule S ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<equiv>\n  (map (extend S) (fst ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)),\n   extend S (snd ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)))\n\ngoal (1 subgoal):\n 1. extend S ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n    ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)", "by auto"], ["proof (state)\nthis:\n  extend S ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  extend S ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)", "have \"ff \\<in># \\<Gamma>\""], ["proof (prove)\nusing this:\n  extend S ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. ff \\<in># \\<Gamma>", "using extendFalsum[where S=S and \\<Gamma>=\"\\<Gamma>\\<oplus>Modal M Ms\" and \\<Delta>=\\<Delta>]"], ["proof (prove)\nusing this:\n  extend S ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  extend S ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>) \\<Longrightarrow>\n  ff \\<in># \\<Gamma> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. ff \\<in># \\<Gamma>", "by auto"], ["proof (state)\nthis:\n  ff \\<in># \\<Gamma>\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  ff \\<in># \\<Gamma>", "have \"ff \\<in># \\<Gamma> + \\<Gamma>'\""], ["proof (prove)\nusing this:\n  ff \\<in># \\<Gamma>\n\ngoal (1 subgoal):\n 1. ff \\<in># \\<Gamma> + \\<Gamma>'", "by auto"], ["proof (state)\nthis:\n  ff \\<in># \\<Gamma> + \\<Gamma>'\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  ff \\<in># \\<Gamma> + \\<Gamma>'", "have \"(\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',0) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  ff \\<in># \\<Gamma> + \\<Gamma>'\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n    \\<in> derivable (ext R R2 M1 M2)", "using rules\n               and containFalsum[where \\<Gamma>=\"\\<Gamma> + \\<Gamma>'\" and \\<Delta>=\"\\<Delta> + \\<Delta>'\" and R=R]"], ["proof (prove)\nusing this:\n  ff \\<in># \\<Gamma> + \\<Gamma>'\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  \\<lbrakk>ff \\<in># \\<Gamma> + \\<Gamma>'; Ax \\<subseteq> R\\<rbrakk>\n  \\<Longrightarrow> ( \\<Gamma> +\n                      \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                     0)\n                    \\<in> derivable (ext R ?R' ?M ?N)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n    \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) = r \\<or>\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n  r =\n  ([],\n    \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)", "have \"(\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',0) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  ([],  \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) = r \\<or>\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\n  r =\n  ([],\n    \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)\n  r = ([],  \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n    \\<in> derivable (ext R R2 M1 M2)", "by blast"], ["proof (state)\nthis:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)", "show \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "using \\<open>n=0\\<close>"], ["proof (prove)\nusing this:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', 0)\n  \\<in> derivable (ext R R2 M1 M2)\n  n = 0\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "case (Suc n')"], ["proof (state)\nthis:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  n = Suc n'", "have \"(\\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>,n'+1) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, n' + 1)\n    \\<in> derivable (ext R R2 M1 M2)", "using a'"], ["proof (prove)\nusing this:\n  n = Suc n'\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, n)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, n' + 1)\n    \\<in> derivable (ext R R2 M1 M2)", "by simp"], ["proof (state)\nthis:\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)", "obtain Ps where \"(Ps, \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>) \\<in> (ext R R2 M1 M2)\" and \n                          \"Ps \\<noteq> []\" and \n                       d':\"\\<forall> p \\<in> set Ps. \\<exists> n\\<le>n'. (p,n) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. (\\<And>Ps.\n        \\<lbrakk>(Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n                 \\<in> ext R R2 M1 M2;\n         Ps \\<noteq> [];\n         \\<forall>p\\<in>set Ps.\n            \\<exists>n\\<le>n'.\n               (p, n) \\<in> derivable (ext R R2 M1 M2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using characteriseLast[where C=\"\\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>\" and m=n' and R=\"(ext R R2 M1 M2)\"]"], ["proof (prove)\nusing this:\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, n' + 1)\n  \\<in> derivable (ext R R2 M1 M2) \\<Longrightarrow>\n  \\<exists>Ps.\n     Ps \\<noteq> [] \\<and>\n     (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n     \\<in> ext R R2 M1 M2 \\<and>\n     (\\<forall>p\\<in>set Ps.\n         \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2))\n\ngoal (1 subgoal):\n 1. (\\<And>Ps.\n        \\<lbrakk>(Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n                 \\<in> ext R R2 M1 M2;\n         Ps \\<noteq> [];\n         \\<forall>p\\<in>set Ps.\n            \\<exists>n\\<le>n'.\n               (p, n) \\<in> derivable (ext R R2 M1 M2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  \\<in> ext R R2 M1 M2\n  Ps \\<noteq> []\n  \\<forall>p\\<in>set Ps.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  \\<in> ext R R2 M1 M2\n  Ps \\<noteq> []\n  \\<forall>p\\<in>set Ps.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)", "have \"\\<exists> r S. (((r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and> extendRule S r = (Ps, \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)) \\<or>\n                       (r \\<in> p_e R2 M1 M2 \\<and> extendConc S r = (Ps,\\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>))) \\<and> r\\<in>R\""], ["proof (prove)\nusing this:\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  \\<in> ext R R2 M1 M2\n  Ps \\<noteq> []\n  \\<forall>p\\<in>set Ps.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>r S.\n       ((r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n        extendRule S r =\n        (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>) \\<or>\n        r \\<in> p_e R2 M1 M2 \\<and>\n        extendConc S r =\n        (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)) \\<and>\n       r \\<in> R", "by (cases) auto"], ["proof (state)\nthis:\n  \\<exists>r S.\n     ((r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n      extendRule S r =\n      (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>) \\<or>\n      r \\<in> p_e R2 M1 M2 \\<and>\n      extendConc S r =\n      (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)) \\<and>\n     r \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<exists>r S.\n     ((r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n      extendRule S r =\n      (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>) \\<or>\n      r \\<in> p_e R2 M1 M2 \\<and>\n      extendConc S r =\n      (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)) \\<and>\n     r \\<in> R", "obtain r S where ext: \"((r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and> extendRule S r = (Ps, \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>))\n                                \\<or> (r \\<in> p_e R2 M1 M2 \\<and> extendConc S r = (Ps,\\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>))\" and \"r \\<in> R\""], ["proof (prove)\nusing this:\n  \\<exists>r S.\n     ((r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n      extendRule S r =\n      (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>) \\<or>\n      r \\<in> p_e R2 M1 M2 \\<and>\n      extendConc S r =\n      (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)) \\<and>\n     r \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<And>r S.\n        \\<lbrakk>(r \\<in> Ax \\<or>\n                  r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n                 extendRule S r =\n                 (Ps,\n                   \\<Gamma> \\<oplus>\n                   Modal M Ms \\<Rightarrow>* \\<Delta>) \\<or>\n                 r \\<in> p_e R2 M1 M2 \\<and>\n                 extendConc S r =\n                 (Ps,\n                   \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>);\n         r \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>) \\<or>\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>) \\<or>\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>) \\<or>\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume ext1: \"(r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and> extendRule S r = (Ps, \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\""], ["proof (state)\nthis:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with \\<open>Ps \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  Ps \\<noteq> []\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)", "have \"r \\<in> upRules \\<or> r \\<in> modRules2\" and \"extendRule S r = (Ps,\\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\""], ["proof (prove)\nusing this:\n  Ps \\<noteq> []\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. r \\<in> upRules \\<or> r \\<in> modRules2 &&&\n    extendRule S r =\n    (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ps \\<noteq> [];\n     extendRule S r =\n     (Ps,  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>);\n     r \\<notin> modRules2; r \\<in> Ax\\<rbrakk>\n    \\<Longrightarrow> r \\<in> upRules", "apply (cases r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>Ps \\<noteq> [];\n        extendRule S r =\n        (Ps,  add_mset (Modal M Ms) \\<Gamma> \\<Rightarrow>* \\<Delta>);\n        r \\<notin> modRules2; r \\<in> Ax; r = (a, b)\\<rbrakk>\n       \\<Longrightarrow> r \\<in> upRules", "by (rule Ax.cases) (auto simp add:extendRule_def)"], ["proof (state)\nthis:\n  r \\<in> upRules \\<or> r \\<in> modRules2\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  r \\<in> upRules \\<or> r \\<in> modRules2\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  r \\<in> upRules \\<or> r \\<in> modRules2\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"r \\<in> upRules\""], ["proof (state)\nthis:\n  r \\<in> upRules\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  r \\<in> upRules", "obtain ps c where \"r = (ps,c)\""], ["proof (prove)\nusing this:\n  r \\<in> upRules\n\ngoal (1 subgoal):\n 1. (\\<And>ps c. r = (ps, c) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases r) auto"], ["proof (state)\nthis:\n  r = (ps, c)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with \\<open>r \\<in> upRules\\<close>"], ["proof (chain)\npicking this:\n  r \\<in> upRules\n  r = (ps, c)", "obtain T Ts where sw:\"c = (\\<Empt> \\<Rightarrow>* \\<LM>Compound T Ts\\<RM>) \\<or> \n                                                   c = (\\<LM>Compound T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  r \\<in> upRules\n  r = (ps, c)\n\ngoal (1 subgoal):\n 1. (\\<And>T Ts.\n        c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n        c =\n        ( \\<LM> Compound T\n                 Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using upRuleCharacterise[where Ps=ps and C=c]"], ["proof (prove)\nusing this:\n  r \\<in> upRules\n  r = (ps, c)\n  (ps, c) \\<in> upRules \\<Longrightarrow>\n  \\<exists>F Fs.\n     c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound F Fs  \\<RM>) \\<or>\n     c = ( \\<LM> Compound F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. (\\<And>T Ts.\n        c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n        c =\n        ( \\<LM> Compound T\n                 Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "have \"(leftPrincipal r (Modal M Ms) R') \\<or> \\<not>(leftPrincipal r (Modal M Ms) R')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. leftPrincipal r (Modal M Ms) R' \\<or>\n    \\<not> leftPrincipal r (Modal M Ms) R'", "by blast"], ["proof (state)\nthis:\n  leftPrincipal r (Modal M Ms) R' \\<or>\n  \\<not> leftPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  leftPrincipal r (Modal M Ms) R' \\<or>\n  \\<not> leftPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  leftPrincipal r (Modal M Ms) R' \\<or>\n  \\<not> leftPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"leftPrincipal r (Modal M Ms) R'\""], ["proof (state)\nthis:\n  leftPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  leftPrincipal r (Modal M Ms) R'", "have \"c = (\\<LM>Modal M Ms\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  leftPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. c = ( \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)", "using \\<open>r = (ps,c)\\<close>"], ["proof (prove)\nusing this:\n  leftPrincipal r (Modal M Ms) R'\n  r = (ps, c)\n\ngoal (1 subgoal):\n 1. c = ( \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)", "by (cases) auto"], ["proof (state)\nthis:\n  c = ( \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with sw and \\<open>r \\<in> upRules\\<close> and disjoint"], ["proof (chain)\npicking this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  r \\<in> upRules\n  Ax \\<inter> upRules = {}\n  Ax \\<inter> p_e modRules2 ?M ?N = {}\n  Ax \\<inter> modRules2 = {}\n  upRules \\<inter> modRules2 = {}\n  upRules \\<inter> p_e modRules2 ?M ?N = {}\n  c = ( \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Compound T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Compound T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  r \\<in> upRules\n  Ax \\<inter> upRules = {}\n  Ax \\<inter> p_e modRules2 ?M ?N = {}\n  Ax \\<inter> modRules2 = {}\n  upRules \\<inter> modRules2 = {}\n  upRules \\<inter> p_e modRules2 ?M ?N = {}\n  c = ( \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  leftPrincipal r (Modal M Ms) R' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  leftPrincipal r (Modal M Ms) R' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  leftPrincipal r (Modal M Ms) R' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"\\<not> leftPrincipal r (Modal M Ms) R'\""], ["proof (state)\nthis:\n  \\<not> leftPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<not> leftPrincipal r (Modal M Ms) R'", "have \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  \\<not> leftPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "using IH and a' b' d' \\<open>Ps \\<noteq> []\\<close>\n                      and nonPrincipalInvertLeft[where ?R1.0=R1 and ?R2.0=R2 and ?R3.0=R3 and R=R and n=n\n                                                  and \\<Gamma>=\\<Gamma> and \\<Delta>=\\<Delta> and M=M and Ms=Ms and r=r and S=S\n                                                  and \\<Gamma>'=\\<Gamma>' and \\<Delta>'=\\<Delta>' and n'=n' and Ps=Ps and ps=ps \n                                                  and c=c and R'=R' and ?M1.0=M1 and ?M2.0=M2]\n                      and \\<open>n = Suc n'\\<close> and ext1 and rules and \\<open>r = (ps,c)\\<close> and \\<open>r \\<in> R\\<close>"], ["proof (prove)\nusing this:\n  \\<not> leftPrincipal r (Modal M Ms) R'\n  \\<forall>m<n.\n     \\<forall>\\<Gamma> \\<Delta>.\n        ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, m)\n        \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n        (\\<forall>r'\\<in>R'.\n            leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n            ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n            \\<in> set (fst r')) \\<longrightarrow>\n        (\\<exists>m'\\<le>m.\n            ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m')\n            \\<in> derivable (ext R R2 M1 M2))\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, n)\n  \\<in> derivable (ext R R2 M1 M2)\n  \\<forall>r'\\<in>R'.\n     leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\n  \\<forall>p\\<in>set Ps.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n  Ps \\<noteq> []\n  \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n   R3 \\<subseteq> modRules2;\n   R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3; r \\<in> R;\n   r = (ps, c); R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n   \\<forall>m<n.\n      \\<forall>\\<Gamma> \\<Delta>.\n         ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, m)\n         \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n         (\\<forall>r'\\<in>R'.\n             leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n             ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n             \\<in> set (fst r')) \\<longrightarrow>\n         (\\<exists>m'\\<le>m.\n             ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m')\n             \\<in> derivable (ext R R2 M1 M2));\n   ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, n)\n   \\<in> derivable (ext R R2 M1 M2);\n   \\<forall>r'\\<in>R'.\n      leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n      ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r');\n   \\<not> leftPrincipal r (Modal M Ms) R';\n   (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n   extendRule S r =\n   (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>);\n   n = n' + 1;\n   \\<forall>p\\<in>set Ps.\n      \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2);\n   Ps \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m\\<le>n.\n                       ( \\<Gamma> +\n                         \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                        m)\n                       \\<in> derivable (ext R R2 M1 M2)\n  n = Suc n'\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  r = (ps, c)\n  r \\<in> R\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  \\<not> leftPrincipal r (Modal M Ms) R' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  leftPrincipal r (Modal M Ms) R' \\<or>\n  \\<not> leftPrincipal r (Modal M Ms) R'\n  leftPrincipal r (Modal M Ms) R' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  \\<not> leftPrincipal r (Modal M Ms) R' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)", "have \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  leftPrincipal r (Modal M Ms) R' \\<or>\n  \\<not> leftPrincipal r (Modal M Ms) R'\n  leftPrincipal r (Modal M Ms) R' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  \\<not> leftPrincipal r (Modal M Ms) R' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  r \\<in> upRules \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  r \\<in> upRules \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  r \\<in> upRules \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"r \\<in> modRules2\""], ["proof (state)\nthis:\n  r \\<in> modRules2\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  r \\<in> modRules2", "obtain ps c where \"r = (ps,c)\""], ["proof (prove)\nusing this:\n  r \\<in> modRules2\n\ngoal (1 subgoal):\n 1. (\\<And>ps c. r = (ps, c) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases r) auto"], ["proof (state)\nthis:\n  r = (ps, c)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with \\<open>r \\<in> modRules2\\<close>"], ["proof (chain)\npicking this:\n  r \\<in> modRules2\n  r = (ps, c)", "obtain T Ts where sw: \"c = (\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>)\n                                                         \\<or> c = (\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  r \\<in> modRules2\n  r = (ps, c)\n\ngoal (1 subgoal):\n 1. (\\<And>T Ts.\n        c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n        c =\n        ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using modRule2Characterise[where Ps=ps and C=c]"], ["proof (prove)\nusing this:\n  r \\<in> modRules2\n  r = (ps, c)\n  (ps, c) \\<in> modRules2 \\<Longrightarrow>\n  ps \\<noteq> [] \\<and>\n  (\\<exists>F Fs.\n      c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n      c = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))\n\ngoal (1 subgoal):\n 1. (\\<And>T Ts.\n        c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n        c =\n        ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "have \"leftPrincipal r (Modal M Ms) R' \\<or> \\<not> leftPrincipal r (Modal M Ms) R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. leftPrincipal r (Modal M Ms) R' \\<or>\n    \\<not> leftPrincipal r (Modal M Ms) R'", "by blast"], ["proof (state)\nthis:\n  leftPrincipal r (Modal M Ms) R' \\<or>\n  \\<not> leftPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  leftPrincipal r (Modal M Ms) R' \\<or>\n  \\<not> leftPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  leftPrincipal r (Modal M Ms) R' \\<or>\n  \\<not> leftPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"leftPrincipal r (Modal M Ms) R'\""], ["proof (state)\nthis:\n  leftPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  leftPrincipal r (Modal M Ms) R'", "have \"(\\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set ps\""], ["proof (prove)\nusing this:\n  leftPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set ps", "using b' and \\<open>r = (ps,c)\\<close> and \\<open>r \\<in> R\\<close>"], ["proof (prove)\nusing this:\n  leftPrincipal r (Modal M Ms) R'\n  \\<forall>r'\\<in>R'.\n     leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\n  r = (ps, c)\n  r \\<in> R\n\ngoal (1 subgoal):\n 1. ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set ps", "apply-"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>leftPrincipal r (Modal M Ms) R';\n     \\<forall>r'\\<in>R'.\n        leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n        ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r');\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set ps", "apply (rule leftPrincipal.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>leftPrincipal r (Modal M Ms) R';\n     \\<forall>r'\\<in>R'.\n        leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n        ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r');\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal ?a1.4 ?a2.4 ?a3.4\n 2. \\<And>C A Ps Ra.\n       \\<lbrakk>leftPrincipal r (Modal M Ms) R';\n        \\<forall>r'\\<in>R'.\n           leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n           ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r');\n        r = (ps, c); r \\<in> R; ?a1.4 = (Ps, C); ?a2.4 = A; ?a3.4 = Ra;\n        C = ( \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>); A \\<noteq> ff;\n        (Ps, C) \\<in> Ra\\<rbrakk>\n       \\<Longrightarrow> ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set ps", "by auto"], ["proof (state)\nthis:\n  ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set ps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set ps", "have ex:\"extend S (\\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set Ps\""], ["proof (prove)\nusing this:\n  ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set ps\n\ngoal (1 subgoal):\n 1. extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set Ps", "using \\<open>extendRule S r = (Ps,\\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\\<close>\n                      and \\<open>r = (ps,c)\\<close>"], ["proof (prove)\nusing this:\n  ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set ps\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r = (ps, c)\n\ngoal (1 subgoal):\n 1. extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set Ps", "by (simp add:extendContain)"], ["proof (state)\nthis:\n  extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"c = (\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (state)\nthis:\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)", "have bb: \"leftPrincipal r (Modal T Ts) R'\""], ["proof (prove)\nusing this:\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. leftPrincipal r (Modal T Ts) R'", "using \\<open>r = (ps,c)\\<close> and \\<open>r \\<in> R\\<close>"], ["proof (prove)\nusing this:\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  r = (ps, c)\n  r \\<in> R\n\ngoal (1 subgoal):\n 1. leftPrincipal r (Modal T Ts) R'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "from \\<open>c = (\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\\<close> and \\<open>r = (ps,c)\\<close> and \\<open>r \\<in> R\\<close> and \\<open>r \\<in> modRules2\\<close>"], ["proof (chain)\npicking this:\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  r = (ps, c)\n  r \\<in> R\n  r \\<in> modRules2", "have \"(ps,\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R\""], ["proof (prove)\nusing this:\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  r = (ps, c)\n  r \\<in> R\n  r \\<in> modRules2\n\ngoal (1 subgoal):\n 1. (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "with rules"], ["proof (chain)\npicking this:\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R", "have \"(ps,  \\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) \\<in> p_e R2 M1 M2 \\<or>\n                                (ps,  \\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R3\""], ["proof (prove)\nusing this:\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R\n\ngoal (1 subgoal):\n 1. (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n    \\<in> p_e R2 M1 M2 \\<or>\n    (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R3", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n     R3 \\<subseteq> modRules2;\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<notin> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                      \\<in> p_e R2 M1 M2\n 2. \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n     R3 \\<subseteq> modRules2;\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<notin> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R1\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                      \\<in> p_e R2 M1 M2", "apply (rule Ax.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n     R3 \\<subseteq> modRules2;\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<notin> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax\\<rbrakk>\n    \\<Longrightarrow> (?a1.14, ?a2.14) \\<in> Ax\n 2. \\<And>i.\n       \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<notin> R3;\n        (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax;\n        ?a1.14 = [];\n        ?a2.14 =\n        ( \\<LM> At i  \\<RM> \\<Rightarrow>* \\<LM> At i  \\<RM>)\\<rbrakk>\n       \\<Longrightarrow> (ps,\n                           \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                         \\<in> p_e R2 M1 M2\n 3. \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n     R3 \\<subseteq> modRules2;\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<notin> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> Ax;\n     ?a1.14 = [];\n     ?a2.14 = ( \\<LM> ff  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                      \\<in> p_e R2 M1 M2\n 4. \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n     R3 \\<subseteq> modRules2;\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<notin> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R1\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                      \\<in> p_e R2 M1 M2", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n     R3 \\<subseteq> modRules2;\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<notin> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R1\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                      \\<in> p_e R2 M1 M2", "apply (subgoal_tac \"(ps,\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) \\<in> upRules\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n     R3 \\<subseteq> modRules2;\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<notin> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R1;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n     \\<in> upRules\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                      \\<in> p_e R2 M1 M2\n 2. \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n     R3 \\<subseteq> modRules2;\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<notin> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R1\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                      \\<in> upRules", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n     R3 \\<subseteq> modRules2;\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<notin> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R1;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n     \\<in> upRules\\<rbrakk>\n    \\<Longrightarrow> (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                      \\<in> p_e R2 M1 M2", "apply (rule upRules.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n     R3 \\<subseteq> modRules2;\n     R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n     R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<notin> R3;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R1;\n     (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n     \\<in> upRules\\<rbrakk>\n    \\<Longrightarrow> (?a1.105, ?a2.105) \\<in> upRules\n 2. \\<And>c Ra Fs psa.\n       \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n        R3 \\<subseteq> modRules2;\n        R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3;\n        R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n        (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<notin> R3;\n        (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R1;\n        (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> upRules;\n        ?a1.105 = psa; ?a2.105 = c;\n        ModalSequents.mset c = \\<LM> Compound Ra Fs  \\<RM>;\n        psa \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> (ps,\n                           \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                         \\<in> p_e R2 M1 M2", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  \\<in> p_e R2 M1 M2 \\<or>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "moreover"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  \\<in> p_e R2 M1 M2 \\<or>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "{"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  \\<in> p_e R2 M1 M2 \\<or>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "assume \"(ps, \\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R3\""], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R3", "have \"(ps, \\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\""], ["proof (prove)\nusing this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R3\n\ngoal (1 subgoal):\n 1. (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'", "using rules"], ["proof (prove)\nusing this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R3\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n\ngoal (1 subgoal):\n 1. (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "}"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  \\<in> R3 \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "moreover"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  \\<in> R3 \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "{"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  \\<in> R3 \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "assume \"(ps,\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) \\<in> p_e R2 M1 M2\""], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> p_e R2 M1 M2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> p_e R2 M1 M2", "obtain \\<Gamma>' \\<Delta>' r' \n                                   where aa: \"(ps, \\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) = extendRule (M1\\<cdot>\\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>') r' \\<and> r' \\<in> R2\""], ["proof (prove)\nusing this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> p_e R2 M1 M2\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>' \\<Delta>' r'.\n        (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n        extendRule\n         ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n         r' \\<and>\n        r' \\<in> R2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply (rule p_e.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps c \\<Gamma> \\<Delta>.\n       \\<lbrakk>\\<And>\\<Gamma>' \\<Delta>' r'.\n                   (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n                   extendRule\n                    ( M1 \\<cdot>\n                      \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n                    r' \\<and>\n                   r' \\<in> R2 \\<Longrightarrow>\n                   thesis;\n        (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n        extendRule ( M1 \\<cdot> \\<Gamma> \\<Rightarrow>* M2 \\<cdot> \\<Delta>)\n         (Ps, c);\n        (Ps, c) \\<in> R2; R2 \\<subseteq> modRules2\\<rbrakk>\n       \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2", "have \"r' \\<in> modRules2\""], ["proof (prove)\nusing this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n\ngoal (1 subgoal):\n 1. r' \\<in> modRules2", "using rules"], ["proof (prove)\nusing this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n\ngoal (1 subgoal):\n 1. r' \\<in> modRules2", "by auto"], ["proof (state)\nthis:\n  r' \\<in> modRules2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  r' \\<in> modRules2", "obtain F Fs where \n                                   \"snd r' = (\\<Empt> \\<Rightarrow>* \\<LM>Modal F Fs\\<RM>) \\<or> snd r' = (\\<LM>Modal F Fs\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  r' \\<in> modRules2\n\ngoal (1 subgoal):\n 1. (\\<And>F Fs.\n        snd r' = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n        snd r' =\n        ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using modRule2Characterise[where Ps=\"fst r'\" and C=\"snd r'\"]"], ["proof (prove)\nusing this:\n  r' \\<in> modRules2\n  (fst r', snd r') \\<in> modRules2 \\<Longrightarrow>\n  fst r' \\<noteq> [] \\<and>\n  (\\<exists>F Fs.\n      snd r' = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n      snd r' = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))\n\ngoal (1 subgoal):\n 1. (\\<And>F Fs.\n        snd r' = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n        snd r' =\n        ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  snd r' = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n  snd r' = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "with aa"], ["proof (chain)\npicking this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n  snd r' = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n  snd r' = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"(\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) = (M1\\<cdot>\\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>' \\<oplus> Modal F Fs) \\<or>\n                                            (\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) = (M1\\<cdot>\\<Gamma>' \\<oplus> Modal F Fs \\<Rightarrow>* M2\\<cdot>\\<Delta>')\""], ["proof (prove)\nusing this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n  snd r' = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n  snd r' = ( \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n    ( M1 \\<cdot>\n      \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus>\n                               Modal F Fs) \\<or>\n    ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n    ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n      Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')", "by (auto simp add:extendRule_def extend_def)"], ["proof (state)\nthis:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs) \\<or>\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "moreover"], ["proof (state)\nthis:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs) \\<or>\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "{"], ["proof (state)\nthis:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs) \\<or>\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "assume \"(\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) = (M1\\<cdot>\\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>' \\<oplus> Modal F Fs)\""], ["proof (state)\nthis:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs)", "have \"\\<Empt> = M2\\<cdot>\\<Delta>' \\<oplus> Modal F Fs\""], ["proof (prove)\nusing this:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs)\n\ngoal (1 subgoal):\n 1. \\<Empt> = M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs", "by auto"], ["proof (state)\nthis:\n  \\<Empt> = M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  \\<Empt> = M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs", "have \"(ps, \\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\""], ["proof (prove)\nusing this:\n  \\<Empt> = M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs\n\ngoal (1 subgoal):\n 1. (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "}"], ["proof (state)\nthis:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus>\n                             Modal F Fs) \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "moreover"], ["proof (state)\nthis:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus>\n                             Modal F Fs) \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "{"], ["proof (state)\nthis:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus>\n                             Modal F Fs) \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "assume \"(\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) = (M1\\<cdot>\\<Gamma>' \\<oplus> Modal F Fs \\<Rightarrow>* M2\\<cdot>\\<Delta>')\""], ["proof (state)\nthis:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')", "have \"M2\\<cdot>\\<Delta>' = \\<Empt>\" and \"\\<LM>Modal T Ts\\<RM> = M1\\<cdot>\\<Gamma>' \\<oplus> Modal F Fs\""], ["proof (prove)\nusing this:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n\ngoal (1 subgoal):\n 1. M2 \\<cdot> \\<Delta>' = \\<Empt> &&&\n    \\<LM> Modal T Ts  \\<RM> = M1 \\<cdot> \\<Gamma>' \\<oplus> Modal F Fs", "by auto"], ["proof (state)\nthis:\n  M2 \\<cdot> \\<Delta>' = \\<Empt>\n  \\<LM> Modal T Ts  \\<RM> = M1 \\<cdot> \\<Gamma>' \\<oplus> Modal F Fs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  M2 \\<cdot> \\<Delta>' = \\<Empt>\n  \\<LM> Modal T Ts  \\<RM> = M1 \\<cdot> \\<Gamma>' \\<oplus> Modal F Fs", "have \"M1\\<cdot>\\<Gamma>' = \\<Empt>\" and \"Modal T Ts = Modal F Fs\" and \"M2\\<cdot>\\<Delta>' = \\<Empt>\""], ["proof (prove)\nusing this:\n  M2 \\<cdot> \\<Delta>' = \\<Empt>\n  \\<LM> Modal T Ts  \\<RM> = M1 \\<cdot> \\<Gamma>' \\<oplus> Modal F Fs\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>' = \\<Empt> &&&\n    Modal T Ts = Modal F Fs &&& M2 \\<cdot> \\<Delta>' = \\<Empt>", "using \n                                       singleton_add_means_equal[where A=\"Modal T Ts\" and \\<Gamma>=\"M1\\<cdot>\\<Gamma>'\" and B=\"Modal F Fs\"]\n                                       and singleton_add_means_empty[where A=\"Modal T Ts\" and \\<Gamma>=\"M1\\<cdot>\\<Gamma>'\" and B=\"Modal F Fs\"]"], ["proof (prove)\nusing this:\n  M2 \\<cdot> \\<Delta>' = \\<Empt>\n  \\<LM> Modal T Ts  \\<RM> = M1 \\<cdot> \\<Gamma>' \\<oplus> Modal F Fs\n  \\<LM> Modal T Ts  \\<RM> =\n  M1 \\<cdot> \\<Gamma>' \\<oplus> Modal F Fs \\<Longrightarrow>\n  Modal T Ts = Modal F Fs\n  \\<LM> Modal T Ts  \\<RM> =\n  M1 \\<cdot> \\<Gamma>' \\<oplus> Modal F Fs \\<Longrightarrow>\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>' = \\<Empt> &&&\n    Modal T Ts = Modal F Fs &&& M2 \\<cdot> \\<Delta>' = \\<Empt>", "by (auto simp add:modaliseMultiset_def)"], ["proof (state)\nthis:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  Modal T Ts = Modal F Fs\n  M2 \\<cdot> \\<Delta>' = \\<Empt>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  Modal T Ts = Modal F Fs\n  M2 \\<cdot> \\<Delta>' = \\<Empt>", "have \"extendRule (M1\\<cdot>\\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>') r' = r'\""], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  Modal T Ts = Modal F Fs\n  M2 \\<cdot> \\<Delta>' = \\<Empt>\n\ngoal (1 subgoal):\n 1. extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n     r' =\n    r'", "using extendRuleEmpty[where r=r']"], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>' = \\<Empt>\n  Modal T Ts = Modal F Fs\n  M2 \\<cdot> \\<Delta>' = \\<Empt>\n  extendRule ( \\<Empt> \\<Rightarrow>* \\<Empt>) r' = r'\n\ngoal (1 subgoal):\n 1. extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n     r' =\n    r'", "by auto"], ["proof (state)\nthis:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' =\n  r'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' =\n  r'", "have \"extendRule (M1\\<cdot>\\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>') r' \\<in> R2\""], ["proof (prove)\nusing this:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' =\n  r'\n\ngoal (1 subgoal):\n 1. extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n     r'\n    \\<in> R2", "using aa"], ["proof (prove)\nusing this:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' =\n  r'\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n\ngoal (1 subgoal):\n 1. extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n     r'\n    \\<in> R2", "by auto"], ["proof (state)\nthis:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>') r'\n  \\<in> R2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>') r'\n  \\<in> R2", "have \"(ps,\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R2\""], ["proof (prove)\nusing this:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>') r'\n  \\<in> R2\n\ngoal (1 subgoal):\n 1. (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R2", "using aa"], ["proof (prove)\nusing this:\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>') r'\n  \\<in> R2\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  extendRule ( M1 \\<cdot> \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n   r' \\<and>\n  r' \\<in> R2\n\ngoal (1 subgoal):\n 1. (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R2", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R2", "have \"(ps,\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\""], ["proof (prove)\nusing this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R2\n\ngoal (1 subgoal):\n 1. (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'", "using rules"], ["proof (prove)\nusing this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R2\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n\ngoal (1 subgoal):\n 1. (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'", "by simp"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "}"], ["proof (state)\nthis:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>') \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "ultimately"], ["proof (chain)\npicking this:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs) \\<or>\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus>\n                             Modal F Fs) \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>') \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'", "have \"(ps,\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\""], ["proof (prove)\nusing this:\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus> Modal F Fs) \\<or>\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>')\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot>\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>' \\<oplus>\n                             Modal F Fs) \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n  ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) =\n  ( M1 \\<cdot> \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>') \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'", "by blast"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "}"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "ultimately"], ["proof (chain)\npicking this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  \\<in> p_e R2 M1 M2 \\<or>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R3\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  \\<in> R3 \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'", "have \"(ps,\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\""], ["proof (prove)\nusing this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  \\<in> p_e R2 M1 M2 \\<or>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R3\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  \\<in> R3 \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n  \\<in> p_e R2 M1 M2 \\<Longrightarrow>\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'", "by auto"], ["proof (state)\nthis:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps, c); r \\<in> R\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal r (Modal T Ts) R'", "then"], ["proof (chain)\npicking this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'", "show ?thesis"], ["proof (prove)\nusing this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n\ngoal (1 subgoal):\n 1. leftPrincipal r (Modal T Ts) R'", "using \\<open>r = (ps,c)\\<close> and \\<open>c = (\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\\<close>"], ["proof (prove)\nusing this:\n  (ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R'\n  r = (ps, c)\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. leftPrincipal r (Modal T Ts) R'", "by auto"], ["proof (state)\nthis:\n  leftPrincipal r (Modal T Ts) R'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  leftPrincipal r (Modal T Ts) R'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  leftPrincipal r (Modal T Ts) R'", "have \"Modal T Ts = Modal M Ms\""], ["proof (prove)\nusing this:\n  leftPrincipal r (Modal T Ts) R'\n\ngoal (1 subgoal):\n 1. Modal T Ts = Modal M Ms", "using \\<open>leftPrincipal r (Modal M Ms) R'\\<close>"], ["proof (prove)\nusing this:\n  leftPrincipal r (Modal T Ts) R'\n  leftPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. Modal T Ts = Modal M Ms", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>leftPrincipal r (Modal T Ts) R';\n     leftPrincipal r (Modal M Ms) R'\\<rbrakk>\n    \\<Longrightarrow> T = M\n 2. \\<lbrakk>leftPrincipal r (Modal T Ts) R';\n     leftPrincipal r (Modal M Ms) R'\\<rbrakk>\n    \\<Longrightarrow> Ts = Ms", "apply (rule leftPrincipal.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>leftPrincipal r (Modal T Ts) R';\n     leftPrincipal r (Modal M Ms) R'\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal ?a1.3 ?a2.3 ?a3.3\n 2. \\<And>C A Ps R.\n       \\<lbrakk>leftPrincipal r (Modal T Ts) R';\n        leftPrincipal r (Modal M Ms) R'; ?a1.3 = (Ps, C); ?a2.3 = A;\n        ?a3.3 = R; C = ( \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>);\n        A \\<noteq> ff; (Ps, C) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> T = M\n 3. \\<lbrakk>leftPrincipal r (Modal T Ts) R';\n     leftPrincipal r (Modal M Ms) R'\\<rbrakk>\n    \\<Longrightarrow> Ts = Ms", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Ps.\n       \\<lbrakk>leftPrincipal\n                 (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                 (Modal T Ts) R';\n        leftPrincipal (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n         (Modal M Ms) R';\n        (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R';\n        r = (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n       \\<Longrightarrow> T = M\n 2. \\<lbrakk>leftPrincipal r (Modal T Ts) R';\n     leftPrincipal r (Modal M Ms) R'\\<rbrakk>\n    \\<Longrightarrow> Ts = Ms", "apply (rotate_tac 1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Ps.\n       \\<lbrakk>leftPrincipal\n                 (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                 (Modal M Ms) R';\n        (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R';\n        r = (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n        leftPrincipal (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n         (Modal T Ts) R'\\<rbrakk>\n       \\<Longrightarrow> T = M\n 2. \\<lbrakk>leftPrincipal r (Modal T Ts) R';\n     leftPrincipal r (Modal M Ms) R'\\<rbrakk>\n    \\<Longrightarrow> Ts = Ms", "apply (rule leftPrincipal.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Ps.\n       \\<lbrakk>leftPrincipal\n                 (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                 (Modal M Ms) R';\n        (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R';\n        r = (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n        leftPrincipal (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n         (Modal T Ts) R'\\<rbrakk>\n       \\<Longrightarrow> leftPrincipal (?a1.11 Ps) (?a2.11 Ps) (?a3.11 Ps)\n 2. \\<And>Ps C A Psa R.\n       \\<lbrakk>leftPrincipal\n                 (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                 (Modal M Ms) R';\n        (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R';\n        r = (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n        leftPrincipal (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n         (Modal T Ts) R';\n        ?a1.11 Ps = (Psa, C); ?a2.11 Ps = A; ?a3.11 Ps = R;\n        C = ( \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>); A \\<noteq> ff;\n        (Psa, C) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> T = M\n 3. \\<lbrakk>leftPrincipal r (Modal T Ts) R';\n     leftPrincipal r (Modal M Ms) R'\\<rbrakk>\n    \\<Longrightarrow> Ts = Ms", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>leftPrincipal r (Modal T Ts) R';\n     leftPrincipal r (Modal M Ms) R'\\<rbrakk>\n    \\<Longrightarrow> Ts = Ms", "apply (rule leftPrincipal.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>leftPrincipal r (Modal T Ts) R';\n     leftPrincipal r (Modal M Ms) R'\\<rbrakk>\n    \\<Longrightarrow> leftPrincipal ?a1.28 ?a2.28 ?a3.28\n 2. \\<And>C A Ps R.\n       \\<lbrakk>leftPrincipal r (Modal T Ts) R';\n        leftPrincipal r (Modal M Ms) R'; ?a1.28 = (Ps, C); ?a2.28 = A;\n        ?a3.28 = R; C = ( \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>);\n        A \\<noteq> ff; (Ps, C) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> Ts = Ms", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps.\n       \\<lbrakk>leftPrincipal\n                 (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                 (Modal T Ts) R';\n        leftPrincipal (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n         (Modal M Ms) R';\n        (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R';\n        r = (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n       \\<Longrightarrow> Ts = Ms", "apply (rotate_tac 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps.\n       \\<lbrakk>leftPrincipal\n                 (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                 (Modal M Ms) R';\n        (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R';\n        r = (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n        leftPrincipal (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n         (Modal T Ts) R'\\<rbrakk>\n       \\<Longrightarrow> Ts = Ms", "apply (rule leftPrincipal.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Ps.\n       \\<lbrakk>leftPrincipal\n                 (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                 (Modal M Ms) R';\n        (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R';\n        r = (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n        leftPrincipal (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n         (Modal T Ts) R'\\<rbrakk>\n       \\<Longrightarrow> leftPrincipal (?a1.36 Ps) (?a2.36 Ps) (?a3.36 Ps)\n 2. \\<And>Ps C A Psa R.\n       \\<lbrakk>leftPrincipal\n                 (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n                 (Modal M Ms) R';\n        (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> R';\n        r = (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>);\n        leftPrincipal (Ps,  \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n         (Modal T Ts) R';\n        ?a1.36 Ps = (Psa, C); ?a2.36 Ps = A; ?a3.36 Ps = R;\n        C = ( \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>); A \\<noteq> ff;\n        (Psa, C) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> Ts = Ms", "by auto"], ["proof (state)\nthis:\n  Modal T Ts = Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  Modal T Ts = Modal M Ms", "have \"c = (\\<LM>Modal M Ms\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  Modal T Ts = Modal M Ms\n\ngoal (1 subgoal):\n 1. c = ( \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)", "using \\<open>c = (\\<LM>Modal T Ts\\<RM> \\<Rightarrow>* \\<Empt>)\\<close>"], ["proof (prove)\nusing this:\n  Modal T Ts = Modal M Ms\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. c = ( \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)", "by auto"], ["proof (state)\nthis:\n  c = ( \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  c = ( \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  c = ( \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  c = ( \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"c = (\\<Empt> \\<Rightarrow>* \\<LM>Modal T Ts\\<RM>)\""], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)", "have \"\\<not> leftPrincipal r (Modal M Ms) R'\""], ["proof (prove)\nusing this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<not> leftPrincipal r (Modal M Ms) R'", "using \\<open>r = (ps,c)\\<close>"], ["proof (prove)\nusing this:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n  r = (ps, c)\n\ngoal (1 subgoal):\n 1. \\<not> leftPrincipal r (Modal M Ms) R'", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     r = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>);\n     leftPrincipal (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>)\n      (Modal M Ms) R'\\<rbrakk>\n    \\<Longrightarrow> False", "by (rule leftPrincipal.cases) (auto simp add:extendRule_def extend_def)"], ["proof (state)\nthis:\n  \\<not> leftPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with \\<open>leftPrincipal r (Modal M Ms) R'\\<close>"], ["proof (chain)\npicking this:\n  leftPrincipal r (Modal M Ms) R'\n  \\<not> leftPrincipal r (Modal M Ms) R'", "have \"c = (\\<LM>Modal M Ms\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  leftPrincipal r (Modal M Ms) R'\n  \\<not> leftPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. c = ( \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)", "by simp"], ["proof (state)\nthis:\n  c = ( \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  c = ( \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set Ps\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  c = ( \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  c = ( \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"c = (\\<LM>Modal M Ms\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set Ps\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  c = ( \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  c = ( \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. c = ( \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)", "using sw"], ["proof (prove)\nusing this:\n  extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set Ps\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  c = ( \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<Longrightarrow>\n  c = ( \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)\n  c = ( \\<Empt> \\<Rightarrow>* \\<LM> Modal T Ts  \\<RM>) \\<or>\n  c = ( \\<LM> Modal T Ts  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. c = ( \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)", "by blast"], ["proof (state)\nthis:\n  c = ( \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with \\<open>extendRule S r = (Ps,\\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\\<close>"], ["proof (chain)\npicking this:\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  c = ( \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"S = (\\<Gamma> \\<Rightarrow>* \\<Delta>)\""], ["proof (prove)\nusing this:\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  c = ( \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. S = ( \\<Gamma> \\<Rightarrow>* \\<Delta>)", "using \\<open>r = (ps,c)\\<close>"], ["proof (prove)\nusing this:\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  c = ( \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)\n  r = (ps, c)\n\ngoal (1 subgoal):\n 1. S = ( \\<Gamma> \\<Rightarrow>* \\<Delta>)", "apply (auto simp add:extendRule_def extend_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c = ( \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>);\n     r = (ps,  \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>);\n     Ps = map (extend S) ps; \\<Gamma> = antec S; \\<Delta> = succ S\\<rbrakk>\n    \\<Longrightarrow> S = ( antec S \\<Rightarrow>* succ S)", "by (cases S) auto"], ["proof (state)\nthis:\n  S = ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with ex"], ["proof (chain)\npicking this:\n  extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set Ps\n  S = ( \\<Gamma> \\<Rightarrow>* \\<Delta>)", "have \"(\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') \\<in> set Ps\""], ["proof (prove)\nusing this:\n  extend S ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set Ps\n  S = ( \\<Gamma> \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') \\<in> set Ps", "by (simp add:extend_def)"], ["proof (state)\nthis:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') \\<in> set Ps", "have \"\\<exists> m\\<le>n'. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n'.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "using \\<open>\\<forall> p \\<in> set Ps. \\<exists> n\\<le>n'. (p,n) \\<in> derivable (ext R R2 M1 M2)\\<close>"], ["proof (prove)\nusing this:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>') \\<in> set Ps\n  \\<forall>p\\<in>set Ps.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n'.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n'.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<exists>m\\<le>n'.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)", "have \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  \\<exists>m\\<le>n'.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "using \\<open>n = Suc n'\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>m\\<le>n'.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by (auto,rule_tac x=m in exI) (simp)"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  leftPrincipal r (Modal M Ms) R' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  leftPrincipal r (Modal M Ms) R' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  leftPrincipal r (Modal M Ms) R' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"\\<not> leftPrincipal r (Modal M Ms) R'\""], ["proof (state)\nthis:\n  \\<not> leftPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<not> leftPrincipal r (Modal M Ms) R'", "have \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  \\<not> leftPrincipal r (Modal M Ms) R'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "using IH and a' b' d' \\<open>Ps \\<noteq> []\\<close>\n                      and nonPrincipalInvertLeft[where ?R1.0=R1 and ?R2.0=R2 and ?R3.0=R3 and R=R and n=n\n                                                  and \\<Gamma>=\\<Gamma> and \\<Delta>=\\<Delta> and M=M and Ms=Ms and r=r and S=S\n                                                  and \\<Gamma>'=\\<Gamma>' and \\<Delta>'=\\<Delta>' and n'=n' and Ps=Ps and ps=ps \n                                                  and c=c and R'=R' and ?M1.0=M1 and ?M2.0=M2]\n                      and \\<open>n = Suc n'\\<close> and ext1 and rules and \\<open>r = (ps,c)\\<close> and \\<open>r \\<in> R\\<close>"], ["proof (prove)\nusing this:\n  \\<not> leftPrincipal r (Modal M Ms) R'\n  \\<forall>m<n.\n     \\<forall>\\<Gamma> \\<Delta>.\n        ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, m)\n        \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n        (\\<forall>r'\\<in>R'.\n            leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n            ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n            \\<in> set (fst r')) \\<longrightarrow>\n        (\\<exists>m'\\<le>m.\n            ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m')\n            \\<in> derivable (ext R R2 M1 M2))\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, n)\n  \\<in> derivable (ext R R2 M1 M2)\n  \\<forall>r'\\<in>R'.\n     leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\n  \\<forall>p\\<in>set Ps.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n  Ps \\<noteq> []\n  \\<lbrakk>R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n   R3 \\<subseteq> modRules2;\n   R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3; r \\<in> R;\n   r = (ps, c); R' = Ax \\<union> R1 \\<union> R2 \\<union> R3;\n   \\<forall>m<n.\n      \\<forall>\\<Gamma> \\<Delta>.\n         ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, m)\n         \\<in> derivable (ext R R2 M1 M2) \\<longrightarrow>\n         (\\<forall>r'\\<in>R'.\n             leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n             ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n             \\<in> set (fst r')) \\<longrightarrow>\n         (\\<exists>m'\\<le>m.\n             ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m')\n             \\<in> derivable (ext R R2 M1 M2));\n   ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>, n)\n   \\<in> derivable (ext R R2 M1 M2);\n   \\<forall>r'\\<in>R'.\n      leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n      ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r');\n   \\<not> leftPrincipal r (Modal M Ms) R';\n   (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n   extendRule S r =\n   (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>);\n   n = n' + 1;\n   \\<forall>p\\<in>set Ps.\n      \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2);\n   Ps \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m\\<le>n.\n                       ( \\<Gamma> +\n                         \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',\n                        m)\n                       \\<in> derivable (ext R R2 M1 M2)\n  n = Suc n'\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  r = (ps, c)\n  r \\<in> R\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  \\<not> leftPrincipal r (Modal M Ms) R' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  leftPrincipal r (Modal M Ms) R' \\<or>\n  \\<not> leftPrincipal r (Modal M Ms) R'\n  leftPrincipal r (Modal M Ms) R' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  \\<not> leftPrincipal r (Modal M Ms) R' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)", "have \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  leftPrincipal r (Modal M Ms) R' \\<or>\n  \\<not> leftPrincipal r (Modal M Ms) R'\n  leftPrincipal r (Modal M Ms) R' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  \\<not> leftPrincipal r (Modal M Ms) R' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  r \\<in> modRules2 \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  r \\<in> upRules \\<or> r \\<in> modRules2\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r \\<in> upRules \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  r \\<in> modRules2 \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)", "have \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  r \\<in> upRules \\<or> r \\<in> modRules2\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r \\<in> upRules \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  r \\<in> modRules2 \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,\n    \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,\n    \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,\n    \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume ba: \"r \\<in> p_e R2 M1 M2 \\<and> extendConc S r = (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\""], ["proof (state)\nthis:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with rules"], ["proof (chain)\npicking this:\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)", "obtain F Fs \\<Gamma>'' \\<Delta>'' ps r' where\n                ca: \"r = extendRule (M1\\<cdot>\\<Gamma>'' \\<Rightarrow>* M2\\<cdot>\\<Delta>'') r'\" and \n                cb: \"r' \\<in> R2\" and\n                cc:  \"r' = (ps, \\<Empt> \\<Rightarrow>* \\<LM>Modal F Fs\\<RM>) \\<or> r' = (ps,\\<LM>Modal F Fs\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>'' \\<Delta>'' r' ps F Fs.\n        \\<lbrakk>r =\n                 extendRule\n                  ( M1 \\<cdot>\n                    \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n                  r';\n         r' \\<in> R2;\n         r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n         r' = (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using modRule1Characterise[where Ps=\"fst r\" and C=\"snd r\" and M=M1 and N=M2 and R=R2]"], ["proof (prove)\nusing this:\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  \\<lbrakk>(fst r, snd r) \\<in> p_e R2 M1 M2;\n   R2 \\<subseteq> modRules2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>F Fs \\<Gamma> \\<Delta> ps ra.\n                       (fst r, snd r) =\n                       extendRule\n                        ( M1 \\<cdot>\n                          \\<Gamma> \\<Rightarrow>* M2 \\<cdot> \\<Delta>)\n                        ra \\<and>\n                       ra \\<in> R2 \\<and>\n                       (ra =\n                        (ps,\n                          \\<Empt> \\<Rightarrow>* \\<LM> Modal F\n                  Fs  \\<RM>) \\<or>\n                        ra =\n                        (ps,\n                          \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>))\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>'' \\<Delta>'' r' ps F Fs.\n        \\<lbrakk>r =\n                 extendRule\n                  ( M1 \\<cdot>\n                    \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n                  r';\n         r' \\<in> R2;\n         r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n         r' = (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'\n  r' \\<in> R2\n  r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n  r' = (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "obtain \\<Gamma>1 \\<Delta>1 where \"S = (\\<Gamma>1 \\<Rightarrow>* \\<Delta>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>1 \\<Delta>1.\n        S = ( \\<Gamma>1 \\<Rightarrow>* \\<Delta>1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases S) auto"], ["proof (state)\nthis:\n  S = ( \\<Gamma>1 \\<Rightarrow>* \\<Delta>1)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  S = ( \\<Gamma>1 \\<Rightarrow>* \\<Delta>1)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  S = ( \\<Gamma>1 \\<Rightarrow>* \\<Delta>1)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"r' = (ps, \\<Empt> \\<Rightarrow>* \\<LM>Modal F Fs\\<RM>)\""], ["proof (state)\nthis:\n  r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with ba ca \\<open>S = (\\<Gamma>1 \\<Rightarrow>* \\<Delta>1)\\<close>"], ["proof (chain)\npicking this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'\n  S = ( \\<Gamma>1 \\<Rightarrow>* \\<Delta>1)\n  r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>)", "have\n                     eq1: \"(M1\\<cdot>\\<Gamma>'' + \\<Gamma>1  \\<Rightarrow>* M2\\<cdot>\\<Delta>'' + \\<Delta>1 \\<oplus> Modal F Fs) = (\\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\""], ["proof (prove)\nusing this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'\n  S = ( \\<Gamma>1 \\<Rightarrow>* \\<Delta>1)\n  r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>)\n\ngoal (1 subgoal):\n 1. ( M1 \\<cdot> \\<Gamma>'' +\n      \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' +\n                               \\<Delta>1 \\<oplus> Modal F Fs) =\n    ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)", "by (auto simp add:extendRule_def extend_def extendConc_def union_ac)"], ["proof (state)\nthis:\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' +\n                             \\<Delta>1 \\<oplus> Modal F Fs) =\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' +\n                             \\<Delta>1 \\<oplus> Modal F Fs) =\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)", "have eq2: \"M1\\<cdot>\\<Gamma>'' + \\<Gamma>1 = \\<Gamma> \\<oplus> Modal M Ms\""], ["proof (prove)\nusing this:\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' +\n                             \\<Delta>1 \\<oplus> Modal F Fs) =\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 = \\<Gamma> \\<oplus> Modal M Ms", "by auto"], ["proof (state)\nthis:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 = \\<Gamma> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 = \\<Gamma> \\<oplus> Modal M Ms", "have \"set_mset (M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1) = set_mset (\\<Gamma> \\<oplus> Modal M Ms)\""], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 = \\<Gamma> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. set_mset (M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1) =\n    set_mset (\\<Gamma> \\<oplus> Modal M Ms)", "by auto"], ["proof (state)\nthis:\n  set_mset (M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1) =\n  set_mset (\\<Gamma> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  set_mset (M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1) =\n  set_mset (\\<Gamma> \\<oplus> Modal M Ms)", "have \"set_mset (\\<LM>Modal M Ms\\<RM>) \\<subseteq> set_mset (M1 \\<cdot> \\<Gamma>'') \\<union> set_mset \\<Gamma>1\""], ["proof (prove)\nusing this:\n  set_mset (M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1) =\n  set_mset (\\<Gamma> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. set_mset (\\<LM> Modal M Ms  \\<RM>)\n    \\<subseteq> set_mset (M1 \\<cdot> \\<Gamma>'') \\<union> set_mset \\<Gamma>1", "by auto"], ["proof (state)\nthis:\n  set_mset (\\<LM> Modal M Ms  \\<RM>)\n  \\<subseteq> set_mset (M1 \\<cdot> \\<Gamma>'') \\<union> set_mset \\<Gamma>1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  set_mset (\\<LM> Modal M Ms  \\<RM>)\n  \\<subseteq> set_mset (M1 \\<cdot> \\<Gamma>'') \\<union> set_mset \\<Gamma>1", "have \"Modal M Ms \\<in> set_mset (M1\\<cdot>\\<Gamma>'') \\<or> Modal M Ms \\<in> set_mset \\<Gamma>1\""], ["proof (prove)\nusing this:\n  set_mset (\\<LM> Modal M Ms  \\<RM>)\n  \\<subseteq> set_mset (M1 \\<cdot> \\<Gamma>'') \\<union> set_mset \\<Gamma>1\n\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>'' \\<or>\n    Modal M Ms \\<in># \\<Gamma>1", "by auto"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>'' \\<or> Modal M Ms \\<in># \\<Gamma>1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>'' \\<or> Modal M Ms \\<in># \\<Gamma>1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>'' \\<or> Modal M Ms \\<in># \\<Gamma>1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"Modal M Ms \\<in> set_mset (M1\\<cdot>\\<Gamma>'')\""], ["proof (state)\nthis:\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>''\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>''", "have \"Modal M Ms \\<in># M1\\<cdot>\\<Gamma>''\""], ["proof (prove)\nusing this:\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>''\n\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>''", "by auto"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>''\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with modal_not_contain[where M=M and N=M1 and A=Ms and \\<Gamma>=\\<Gamma>''] and neq"], ["proof (chain)\npicking this:\n  M \\<noteq> M1 \\<Longrightarrow> Modal M Ms \\<notin># M1 \\<cdot> \\<Gamma>''\n  M1 \\<noteq> M\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>''", "have \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  M \\<noteq> M1 \\<Longrightarrow> Modal M Ms \\<notin># M1 \\<cdot> \\<Gamma>''\n  M1 \\<noteq> M\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>''\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>'' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>'' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>'' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"Modal M Ms \\<in> set_mset \\<Gamma>1\""], ["proof (state)\nthis:\n  Modal M Ms \\<in># \\<Gamma>1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  Modal M Ms \\<in># \\<Gamma>1", "have \"Modal M Ms \\<in># \\<Gamma>1\""], ["proof (prove)\nusing this:\n  Modal M Ms \\<in># \\<Gamma>1\n\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># \\<Gamma>1", "by auto"], ["proof (state)\nthis:\n  Modal M Ms \\<in># \\<Gamma>1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  Modal M Ms \\<in># \\<Gamma>1", "have \"\\<exists> \\<Gamma>2. \\<Gamma>1 = \\<Gamma>2 \\<oplus> Modal M Ms\""], ["proof (prove)\nusing this:\n  Modal M Ms \\<in># \\<Gamma>1\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>2. \\<Gamma>1 = \\<Gamma>2 \\<oplus> Modal M Ms", "using insert_DiffM[where x=\"Modal M Ms\" and M=\"\\<Gamma>1\"]"], ["proof (prove)\nusing this:\n  Modal M Ms \\<in># \\<Gamma>1\n  Modal M Ms \\<in># \\<Gamma>1 \\<Longrightarrow>\n  add_mset (Modal M Ms) (\\<Gamma>1 \\<ominus> Modal M Ms) = \\<Gamma>1\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>2. \\<Gamma>1 = \\<Gamma>2 \\<oplus> Modal M Ms", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># \\<Gamma>1 \\<Longrightarrow>\n    \\<exists>\\<Gamma>2. \\<Gamma>1 = add_mset (Modal M Ms) \\<Gamma>2", "apply (rule_tac x=\"\\<Gamma>1\\<ominus>Modal M Ms\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># \\<Gamma>1 \\<Longrightarrow>\n    \\<Gamma>1 = add_mset (Modal M Ms) (\\<Gamma>1 \\<ominus> Modal M Ms)", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  \\<exists>\\<Gamma>2. \\<Gamma>1 = \\<Gamma>2 \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<Gamma>2. \\<Gamma>1 = \\<Gamma>2 \\<oplus> Modal M Ms", "obtain \\<Gamma>2 where \"\\<Gamma>1 = \\<Gamma>2 \\<oplus> Modal M Ms\""], ["proof (prove)\nusing this:\n  \\<exists>\\<Gamma>2. \\<Gamma>1 = \\<Gamma>2 \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>2.\n        \\<Gamma>1 = \\<Gamma>2 \\<oplus> Modal M Ms \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<Gamma>1 = \\<Gamma>2 \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "from ba and rules"], ["proof (chain)\npicking this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3", "have \"extendConc (\\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r \\<in> (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n\ngoal (1 subgoal):\n 1. extendConc ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>')\n     r\n    \\<in> ext R R2 M1 M2", "by auto"], ["proof (state)\nthis:\n  extendConc ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  extendConc ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "from ba and ca"], ["proof (chain)\npicking this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'", "have \"fst (extendConc (\\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r) = Ps\""], ["proof (prove)\nusing this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'\n\ngoal (1 subgoal):\n 1. fst (extendConc\n          ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r) =\n    Ps", "by (auto simp add:extendConc_def)"], ["proof (state)\nthis:\n  fst (extendConc\n        ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r) =\n  Ps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  extendConc ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n  fst (extendConc\n        ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r) =\n  Ps", "have \"(snd (extendConc (\\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r),n'+1) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  extendConc ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n  fst (extendConc\n        ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r) =\n  Ps\n\ngoal (1 subgoal):\n 1. (snd (extendConc\n           ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r),\n     n' + 1)\n    \\<in> derivable (ext R R2 M1 M2)", "using d' and derivable.step[where r=\"extendConc (\\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r\"\n                                                     and R=\"ext R R2 M1 M2\" and m=n'] and \\<open>Ps \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  extendConc ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n  fst (extendConc\n        ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r) =\n  Ps\n  \\<forall>p\\<in>set Ps.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n  \\<lbrakk>extendConc\n            ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r\n           \\<in> ext R R2 M1 M2;\n   fst (extendConc\n         ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>')\n         r) \\<noteq>\n   [];\n   \\<forall>p\\<in>set (fst (extendConc\n                             ( \\<Gamma>2 +\n                               \\<Gamma>' \\<Rightarrow>* \\<Delta>1 +\n                  \\<Delta>')\n                             r)).\n      \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\\<rbrakk>\n  \\<Longrightarrow> (snd (extendConc\n                           ( \\<Gamma>2 +\n                             \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>')\n                           r),\n                     n' + 1)\n                    \\<in> derivable (ext R R2 M1 M2)\n  Ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. (snd (extendConc\n           ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r),\n     n' + 1)\n    \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  (snd (extendConc\n         ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r),\n   n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  (snd (extendConc\n         ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r),\n   n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "from ca and \\<open>r' = (ps,\\<Empt> \\<Rightarrow>* \\<LM>Modal F Fs\\<RM>)\\<close>"], ["proof (chain)\npicking this:\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'\n  r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>)", "have \"snd (extendConc (\\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r) = (M1\\<cdot>\\<Gamma>''+ \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* (M2\\<cdot>\\<Delta>'' \\<oplus> Modal F Fs)+ \\<Delta>1 + \\<Delta>')\""], ["proof (prove)\nusing this:\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'\n  r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>)\n\ngoal (1 subgoal):\n 1. snd (extendConc\n          ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r) =\n    ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 +\n      \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' \\<oplus> Modal F Fs +\n                               \\<Delta>1 +\n                               \\<Delta>')", "by (auto simp add:extendRule_def extendConc_def extend_def union_ac)"], ["proof (state)\nthis:\n  snd (extendConc\n        ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r) =\n  ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 +\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' \\<oplus> Modal F Fs +\n                             \\<Delta>1 +\n                             \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  (snd (extendConc\n         ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r),\n   n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n  snd (extendConc\n        ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r) =\n  ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 +\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' \\<oplus> Modal F Fs +\n                             \\<Delta>1 +\n                             \\<Delta>')", "have gg: \"(M1\\<cdot>\\<Gamma>'' + \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>'' + \\<Delta>1 + \\<Delta>' \\<oplus> Modal F Fs,n'+1) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  (snd (extendConc\n         ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r),\n   n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n  snd (extendConc\n        ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r) =\n  ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 +\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' \\<oplus> Modal F Fs +\n                             \\<Delta>1 +\n                             \\<Delta>')\n\ngoal (1 subgoal):\n 1. ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 +\n      \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>1 +\n                               \\<Delta>' \\<oplus> Modal F Fs,\n     n' + 1)\n    \\<in> derivable (ext R R2 M1 M2)", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 +\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>1 +\n                             \\<Delta>' \\<oplus> Modal F Fs,\n   n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "from eq1"], ["proof (chain)\npicking this:\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' +\n                             \\<Delta>1 \\<oplus> Modal F Fs) =\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)", "have \"M2\\<cdot>\\<Delta>'' + \\<Delta>1 \\<oplus> Modal F Fs  = \\<Delta>\""], ["proof (prove)\nusing this:\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' +\n                             \\<Delta>1 \\<oplus> Modal F Fs) =\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. M2 \\<cdot> \\<Delta>'' + \\<Delta>1 \\<oplus> Modal F Fs = \\<Delta>", "by auto"], ["proof (state)\nthis:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 \\<oplus> Modal F Fs = \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 \\<oplus> Modal F Fs = \\<Delta>", "have \"(M2\\<cdot>\\<Delta>'' + \\<Delta>1 + \\<Delta>') \\<oplus> Modal F Fs = \\<Delta> + \\<Delta>'\""], ["proof (prove)\nusing this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 \\<oplus> Modal F Fs = \\<Delta>\n\ngoal (1 subgoal):\n 1. (M2 \\<cdot> \\<Delta>'' + \\<Delta>1 + \\<Delta>') \\<oplus> Modal F Fs =\n    \\<Delta> + \\<Delta>'", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  (M2 \\<cdot> \\<Delta>'' + \\<Delta>1 + \\<Delta>') \\<oplus> Modal F Fs =\n  \\<Delta> + \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  (M2 \\<cdot> \\<Delta>'' + \\<Delta>1 + \\<Delta>') \\<oplus> Modal F Fs =\n  \\<Delta> + \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "from eq2 and \\<open>\\<Gamma>1 = \\<Gamma>2 \\<oplus> Modal M Ms\\<close>"], ["proof (chain)\npicking this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 = \\<Gamma> \\<oplus> Modal M Ms\n  \\<Gamma>1 = \\<Gamma>2 \\<oplus> Modal M Ms", "have \"M1\\<cdot>\\<Gamma>'' + \\<Gamma>2 \\<oplus> Modal M Ms = \\<Gamma> \\<oplus> Modal M Ms\""], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 = \\<Gamma> \\<oplus> Modal M Ms\n  \\<Gamma>1 = \\<Gamma>2 \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 \\<oplus> Modal M Ms =\n    \\<Gamma> \\<oplus> Modal M Ms", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 \\<oplus> Modal M Ms =\n  \\<Gamma> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 \\<oplus> Modal M Ms =\n  \\<Gamma> \\<oplus> Modal M Ms", "have \"M1\\<cdot>\\<Gamma>'' + \\<Gamma>2 = \\<Gamma>\""], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 \\<oplus> Modal M Ms =\n  \\<Gamma> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 = \\<Gamma>", "using add_equal_means_equal[where \\<Gamma>=\" M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2\" and \\<Delta>=\\<Gamma> and A=\"Modal M Ms\"]"], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 \\<oplus> Modal M Ms =\n  \\<Gamma> \\<oplus> Modal M Ms\n  (M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2) \\<oplus> Modal M Ms =\n  \\<Gamma> \\<oplus> Modal M Ms \\<Longrightarrow>\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 = \\<Gamma>\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 = \\<Gamma>", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 = \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 = \\<Gamma>", "have \"M1\\<cdot>\\<Gamma>'' + \\<Gamma>2 + \\<Gamma>'  = \\<Gamma> + \\<Gamma>'\""], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 = \\<Gamma>\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 + \\<Gamma>' = \\<Gamma> + \\<Gamma>'", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 + \\<Gamma>' = \\<Gamma> + \\<Gamma>'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  (M2 \\<cdot> \\<Delta>'' + \\<Delta>1 + \\<Delta>') \\<oplus> Modal F Fs =\n  \\<Delta> + \\<Delta>'\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 + \\<Gamma>' = \\<Gamma> + \\<Gamma>'", "have \"(\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',n'+1) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  (M2 \\<cdot> \\<Delta>'' + \\<Delta>1 + \\<Delta>') \\<oplus> Modal F Fs =\n  \\<Delta> + \\<Delta>'\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 + \\<Gamma>' = \\<Gamma> + \\<Gamma>'\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n    \\<in> derivable (ext R R2 M1 M2)", "using gg"], ["proof (prove)\nusing this:\n  (M2 \\<cdot> \\<Delta>'' + \\<Delta>1 + \\<Delta>') \\<oplus> Modal F Fs =\n  \\<Delta> + \\<Delta>'\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 + \\<Gamma>' = \\<Gamma> + \\<Gamma>'\n  ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 +\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>1 +\n                             \\<Delta>' \\<oplus> Modal F Fs,\n   n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n    \\<in> derivable (ext R R2 M1 M2)", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)", "have \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "using \\<open>n = Suc n'\\<close>"], ["proof (prove)\nusing this:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  Modal M Ms \\<in># \\<Gamma>1 \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>'' \\<or> Modal M Ms \\<in># \\<Gamma>1\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>'' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  Modal M Ms \\<in># \\<Gamma>1 \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)", "have \"\\<exists>m\\<le>n. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>'' \\<or> Modal M Ms \\<in># \\<Gamma>1\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>'' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  Modal M Ms \\<in># \\<Gamma>1 \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  r' =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  r' =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  r' =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"r' = (ps,\\<LM>Modal F Fs\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (state)\nthis:\n  r' = (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with ba ca \\<open>S = (\\<Gamma>1 \\<Rightarrow>* \\<Delta>1)\\<close>"], ["proof (chain)\npicking this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'\n  S = ( \\<Gamma>1 \\<Rightarrow>* \\<Delta>1)\n  r' = (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)", "have\n                     eq1: \"(M1\\<cdot>\\<Gamma>'' + \\<Gamma>1 \\<oplus> Modal F Fs \\<Rightarrow>* M2\\<cdot>\\<Delta>'' + \\<Delta>1) = (\\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\""], ["proof (prove)\nusing this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'\n  S = ( \\<Gamma>1 \\<Rightarrow>* \\<Delta>1)\n  r' = (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. ( M1 \\<cdot> \\<Gamma>'' +\n      \\<Gamma>1 \\<oplus>\n      Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>1) =\n    ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)", "by (auto simp add:extendRule_def extend_def extendConc_def union_ac)"], ["proof (state)\nthis:\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>1 \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>1) =\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>1 \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>1) =\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)", "have eq2: \"M1\\<cdot>\\<Gamma>'' + \\<Gamma>1 \\<oplus> Modal F Fs = \\<Gamma> \\<oplus> Modal M Ms\""], ["proof (prove)\nusing this:\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>1 \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>1) =\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 \\<oplus> Modal F Fs =\n    \\<Gamma> \\<oplus> Modal M Ms", "by auto"], ["proof (state)\nthis:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 \\<oplus> Modal F Fs =\n  \\<Gamma> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 \\<oplus> Modal F Fs =\n  \\<Gamma> \\<oplus> Modal M Ms", "have \"set_mset (M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 \\<oplus> Modal F Fs) = set_mset (\\<Gamma> \\<oplus> Modal M Ms)\""], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 \\<oplus> Modal F Fs =\n  \\<Gamma> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. set_mset (M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 \\<oplus> Modal F Fs) =\n    set_mset (\\<Gamma> \\<oplus> Modal M Ms)", "by auto"], ["proof (state)\nthis:\n  set_mset (M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 \\<oplus> Modal F Fs) =\n  set_mset (\\<Gamma> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  set_mset (M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 \\<oplus> Modal F Fs) =\n  set_mset (\\<Gamma> \\<oplus> Modal M Ms)", "have \"set_mset (\\<LM>Modal M Ms\\<RM>) \\<subseteq> set_mset (M1\\<cdot> \\<Gamma>'') \\<union> set_mset \\<Gamma>1 \\<union>  {Modal F Fs}\""], ["proof (prove)\nusing this:\n  set_mset (M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 \\<oplus> Modal F Fs) =\n  set_mset (\\<Gamma> \\<oplus> Modal M Ms)\n\ngoal (1 subgoal):\n 1. set_mset (\\<LM> Modal M Ms  \\<RM>)\n    \\<subseteq> set_mset (M1 \\<cdot> \\<Gamma>'') \\<union>\n                set_mset \\<Gamma>1 \\<union>\n                {Modal F Fs}", "by auto"], ["proof (state)\nthis:\n  set_mset (\\<LM> Modal M Ms  \\<RM>)\n  \\<subseteq> set_mset (M1 \\<cdot> \\<Gamma>'') \\<union>\n              set_mset \\<Gamma>1 \\<union>\n              {Modal F Fs}\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  set_mset (\\<LM> Modal M Ms  \\<RM>)\n  \\<subseteq> set_mset (M1 \\<cdot> \\<Gamma>'') \\<union>\n              set_mset \\<Gamma>1 \\<union>\n              {Modal F Fs}", "have \"Modal M Ms \\<in> set_mset (M1\\<cdot>\\<Gamma>'') \\<or> Modal M Ms \\<in> set_mset \\<Gamma>1 \\<or> Modal M Ms = Modal F Fs\""], ["proof (prove)\nusing this:\n  set_mset (\\<LM> Modal M Ms  \\<RM>)\n  \\<subseteq> set_mset (M1 \\<cdot> \\<Gamma>'') \\<union>\n              set_mset \\<Gamma>1 \\<union>\n              {Modal F Fs}\n\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>'' \\<or>\n    Modal M Ms \\<in># \\<Gamma>1 \\<or> Modal M Ms = Modal F Fs", "by auto"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>'' \\<or>\n  Modal M Ms \\<in># \\<Gamma>1 \\<or> Modal M Ms = Modal F Fs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>'' \\<or>\n  Modal M Ms \\<in># \\<Gamma>1 \\<or> Modal M Ms = Modal F Fs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>'' \\<or>\n  Modal M Ms \\<in># \\<Gamma>1 \\<or> Modal M Ms = Modal F Fs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"Modal M Ms \\<in> set_mset (M1\\<cdot>\\<Gamma>'')\""], ["proof (state)\nthis:\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>''\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>''", "have \"Modal M Ms \\<in># M1\\<cdot>\\<Gamma>''\""], ["proof (prove)\nusing this:\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>''\n\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>''", "by auto"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>''\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with modal_not_contain[where M=M and N=M1 and A=Ms and \\<Gamma>=\\<Gamma>''] and neq"], ["proof (chain)\npicking this:\n  M \\<noteq> M1 \\<Longrightarrow> Modal M Ms \\<notin># M1 \\<cdot> \\<Gamma>''\n  M1 \\<noteq> M\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>''", "have \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  M \\<noteq> M1 \\<Longrightarrow> Modal M Ms \\<notin># M1 \\<cdot> \\<Gamma>''\n  M1 \\<noteq> M\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>''\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>'' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>'' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>'' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"Modal M Ms = Modal F Fs\""], ["proof (state)\nthis:\n  Modal M Ms = Modal F Fs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  Modal M Ms = Modal F Fs", "have \"r' = (ps, \\<LM>Modal M Ms\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (prove)\nusing this:\n  Modal M Ms = Modal F Fs\n\ngoal (1 subgoal):\n 1. r' = (ps,  \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)", "using \\<open>r' = (ps,\\<LM>Modal F Fs\\<RM> \\<Rightarrow>* \\<Empt>)\\<close>"], ["proof (prove)\nusing this:\n  Modal M Ms = Modal F Fs\n  r' = (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. r' = (ps,  \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)", "by simp"], ["proof (state)\nthis:\n  r' = (ps,  \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with cb and rules"], ["proof (chain)\npicking this:\n  r' \\<in> R2\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  r' = (ps,  \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"leftPrincipal r' (Modal M Ms) R'\" and \"r' \\<in> R'\""], ["proof (prove)\nusing this:\n  r' \\<in> R2\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n  r' = (ps,  \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. leftPrincipal r' (Modal M Ms) R' &&& r' \\<in> R'", "by auto"], ["proof (state)\nthis:\n  leftPrincipal r' (Modal M Ms) R'\n  r' \\<in> R'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with b"], ["proof (chain)\npicking this:\n  \\<forall>r'\\<in>R'.\n     leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\n  leftPrincipal r' (Modal M Ms) R'\n  r' \\<in> R'", "have \"(\\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set ps\""], ["proof (prove)\nusing this:\n  \\<forall>r'\\<in>R'.\n     leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\n  leftPrincipal r' (Modal M Ms) R'\n  r' \\<in> R'\n\ngoal (1 subgoal):\n 1. ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set ps", "using \\<open>r' = (ps, \\<LM>Modal M Ms\\<RM> \\<Rightarrow>* \\<Empt>)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>r'\\<in>R'.\n     leftPrincipal r' (Modal M Ms) R' \\<longrightarrow>\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (fst r')\n  leftPrincipal r' (Modal M Ms) R'\n  r' \\<in> R'\n  r' = (ps,  \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set ps", "by (auto simp add:Ball_def)"], ["proof (state)\nthis:\n  ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set ps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set ps", "have \"extend (M1\\<cdot>\\<Gamma>'' \\<Rightarrow>* M2\\<cdot>\\<Delta>'') (\\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set (map (extend (M1\\<cdot>\\<Gamma>'' \\<Rightarrow>* M2\\<cdot>\\<Delta>'')) ps)\""], ["proof (prove)\nusing this:\n  ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') \\<in> set ps\n\ngoal (1 subgoal):\n 1. extend ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n    \\<in> set (map (extend\n                     ( M1 \\<cdot>\n                       \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>''))\n                ps)", "by auto"], ["proof (state)\nthis:\n  extend ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n  \\<in> set (map (extend\n                   ( M1 \\<cdot>\n                     \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>''))\n              ps)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  extend ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n  \\<in> set (map (extend\n                   ( M1 \\<cdot>\n                     \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>''))\n              ps)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "from ba and \\<open>r' = (ps, \\<LM>Modal M Ms\\<RM> \\<Rightarrow>* \\<Empt>)\\<close> and ca"], ["proof (chain)\npicking this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r' = (ps,  \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'", "have \"Ps = map (extend (M1\\<cdot>\\<Gamma>'' \\<Rightarrow>* M2\\<cdot>\\<Delta>'')) ps\""], ["proof (prove)\nusing this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r' = (ps,  \\<LM> Modal M Ms  \\<RM> \\<Rightarrow>* \\<Empt>)\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'\n\ngoal (1 subgoal):\n 1. Ps =\n    map (extend\n          ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>''))\n     ps", "by (auto simp add:extendRule_def extendConc_def)"], ["proof (state)\nthis:\n  Ps =\n  map (extend ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>''))\n   ps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  Ps =\n  map (extend ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>''))\n   ps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "have \"extend (M1\\<cdot>\\<Gamma>'' \\<Rightarrow>* M2\\<cdot>\\<Delta>'') (\\<Gamma>' \\<Rightarrow>* \\<Delta>') = (M1\\<cdot>\\<Gamma>'' + \\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>'' + \\<Delta>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extend ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n     ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') =\n    ( M1 \\<cdot> \\<Gamma>'' +\n      \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>')", "by (auto simp add:extend_def)"], ["proof (state)\nthis:\n  extend ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') =\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  extend ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n  \\<in> set (map (extend\n                   ( M1 \\<cdot>\n                     \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>''))\n              ps)\n  Ps =\n  map (extend ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>''))\n   ps\n  extend ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') =\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>')", "have \"(M1\\<cdot>\\<Gamma>'' + \\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>'' + \\<Delta>') \\<in> set Ps\""], ["proof (prove)\nusing this:\n  extend ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>')\n  \\<in> set (map (extend\n                   ( M1 \\<cdot>\n                     \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>''))\n              ps)\n  Ps =\n  map (extend ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>''))\n   ps\n  extend ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   ( \\<Gamma>' \\<Rightarrow>* \\<Delta>') =\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>')\n\ngoal (1 subgoal):\n 1. ( M1 \\<cdot> \\<Gamma>'' +\n      \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>')\n    \\<in> set Ps", "by auto"], ["proof (state)\nthis:\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>')\n  \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with d'"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set Ps.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>')\n  \\<in> set Ps", "have \"\\<exists> m\\<le>n'. (M1\\<cdot>\\<Gamma>'' + \\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>'' + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set Ps.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>')\n  \\<in> set Ps\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n'.\n       ( M1 \\<cdot> \\<Gamma>'' +\n         \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>',\n        m)\n       \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n'.\n     ( M1 \\<cdot> \\<Gamma>'' +\n       \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>',\n      m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<exists>m\\<le>n'.\n     ( M1 \\<cdot> \\<Gamma>'' +\n       \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>',\n      m)\n     \\<in> derivable (ext R R2 M1 M2)", "have \"\\<exists> m\\<le>n'. (M1\\<cdot>\\<Gamma>'' + \\<Gamma>' + \\<Gamma>1 \\<Rightarrow>* M2\\<cdot>\\<Delta>'' + \\<Delta>' + \\<Delta>1,m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  \\<exists>m\\<le>n'.\n     ( M1 \\<cdot> \\<Gamma>'' +\n       \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>',\n      m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n'.\n       ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' +\n         \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>' +\n                                  \\<Delta>1,\n        m)\n       \\<in> derivable (ext R R2 M1 M2)", "using dpWeak[where \\<Gamma>=\"M1\\<cdot>\\<Gamma>'' + \\<Gamma>'\" and \\<Delta>=\"M2\\<cdot>\\<Delta>'' + \\<Delta>'\" and R=R and ?R2.0=R2\n                                      and M=M1 and N=M2 and ?R1.0=R1 and ?R3.0=R3 and \\<Gamma>'=\\<Gamma>1 and \\<Delta>'=\\<Delta>1] \n                         and rules"], ["proof (prove)\nusing this:\n  \\<exists>m\\<le>n'.\n     ( M1 \\<cdot> \\<Gamma>'' +\n       \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>',\n      m)\n     \\<in> derivable (ext R R2 M1 M2)\n  \\<lbrakk>( M1 \\<cdot> \\<Gamma>'' +\n             \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>',\n            ?n)\n           \\<in> derivable (ext R R2 M1 M2);\n   R1 \\<subseteq> upRules; R2 \\<subseteq> modRules2;\n   R3 \\<subseteq> modRules2;\n   R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3\\<rbrakk>\n  \\<Longrightarrow> ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' +\n                      \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' +\n         \\<Delta>' +\n         \\<Delta>1,\n                     ?n)\n                    \\<in> derivable (ext R R2 M1 M2)\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n'.\n       ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' +\n         \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>' +\n                                  \\<Delta>1,\n        m)\n       \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n'.\n     ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' +\n       \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>' +\n                                \\<Delta>1,\n      m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "with \\<open>n = Suc n'\\<close>"], ["proof (chain)\npicking this:\n  n = Suc n'\n  \\<exists>m\\<le>n'.\n     ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' +\n       \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>' +\n                                \\<Delta>1,\n      m)\n     \\<in> derivable (ext R R2 M1 M2)", "have ee: \"\\<exists> m\\<le>n. (M1\\<cdot>\\<Gamma>'' + \\<Gamma>' + \\<Gamma>1 \\<Rightarrow>* M2\\<cdot>\\<Delta>'' + \\<Delta>' + \\<Delta>1,m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  n = Suc n'\n  \\<exists>m\\<le>n'.\n     ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' +\n       \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>' +\n                                \\<Delta>1,\n      m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' +\n         \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>' +\n                                  \\<Delta>1,\n        m)\n       \\<in> derivable (ext R R2 M1 M2)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>n = Suc n'; m \\<le> n';\n        ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' +\n          \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>' +\n                                   \\<Delta>1,\n         m)\n        \\<in> derivable (ext R R2 M1 M2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<le>Suc n'.\n                            ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' +\n                              \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot>\n                 \\<Delta>'' +\n                 \\<Delta>' +\n                 \\<Delta>1,\n                             m)\n                            \\<in> derivable (ext R R2 M1 M2)", "apply (rule_tac x=m in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>n = Suc n'; m \\<le> n';\n        ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' +\n          \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>' +\n                                   \\<Delta>1,\n         m)\n        \\<in> derivable (ext R R2 M1 M2)\\<rbrakk>\n       \\<Longrightarrow> m \\<le> Suc n' \\<and>\n                         ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' +\n                           \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' +\n              \\<Delta>' +\n              \\<Delta>1,\n                          m)\n                         \\<in> derivable (ext R R2 M1 M2)", "by arith"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' +\n       \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>' +\n                                \\<Delta>1,\n      m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "from eq1"], ["proof (chain)\npicking this:\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>1 \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>1) =\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)", "have \"M2\\<cdot>\\<Delta>'' + \\<Delta>1 = \\<Delta>\""], ["proof (prove)\nusing this:\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>1 \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>1) =\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. M2 \\<cdot> \\<Delta>'' + \\<Delta>1 = \\<Delta>", "by auto"], ["proof (state)\nthis:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 = \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 = \\<Delta>", "have \"M2\\<cdot>\\<Delta>'' + \\<Delta>' + \\<Delta>1 = \\<Delta> + \\<Delta>'\""], ["proof (prove)\nusing this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 = \\<Delta>\n\ngoal (1 subgoal):\n 1. M2 \\<cdot> \\<Delta>'' + \\<Delta>' + \\<Delta>1 = \\<Delta> + \\<Delta>'", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>' + \\<Delta>1 = \\<Delta> + \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>' + \\<Delta>1 = \\<Delta> + \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "from eq2 and \\<open>Modal M Ms = Modal F Fs\\<close>"], ["proof (chain)\npicking this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 \\<oplus> Modal F Fs =\n  \\<Gamma> \\<oplus> Modal M Ms\n  Modal M Ms = Modal F Fs", "have \"M1\\<cdot>\\<Gamma>'' + \\<Gamma>1 = \\<Gamma>\""], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 \\<oplus> Modal F Fs =\n  \\<Gamma> \\<oplus> Modal M Ms\n  Modal M Ms = Modal F Fs\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 = \\<Gamma>", "using add_equal_means_equal[where \\<Gamma>=\" M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1\" and \\<Delta>=\\<Gamma> and A=\"Modal F Fs\"]"], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 \\<oplus> Modal F Fs =\n  \\<Gamma> \\<oplus> Modal M Ms\n  Modal M Ms = Modal F Fs\n  (M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1) \\<oplus> Modal F Fs =\n  \\<Gamma> \\<oplus> Modal F Fs \\<Longrightarrow>\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 = \\<Gamma>\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 = \\<Gamma>", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 = \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 = \\<Gamma>", "have \"M1\\<cdot>\\<Gamma>'' + \\<Gamma>' + \\<Gamma>1 = \\<Gamma> + \\<Gamma>'\""], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 = \\<Gamma>\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' + \\<Gamma>1 = \\<Gamma> + \\<Gamma>'", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' + \\<Gamma>1 = \\<Gamma> + \\<Gamma>'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>' + \\<Delta>1 = \\<Delta> + \\<Delta>'\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' + \\<Gamma>1 = \\<Gamma> + \\<Gamma>'", "have \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta>+\\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>' + \\<Delta>1 = \\<Delta> + \\<Delta>'\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' + \\<Gamma>1 = \\<Gamma> + \\<Gamma>'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "using ee"], ["proof (prove)\nusing this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>' + \\<Delta>1 = \\<Delta> + \\<Delta>'\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' + \\<Gamma>1 = \\<Gamma> + \\<Gamma>'\n  \\<exists>m\\<le>n.\n     ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>' +\n       \\<Gamma>1 \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>' +\n                                \\<Delta>1,\n      m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by metis"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  Modal M Ms = Modal F Fs \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  Modal M Ms = Modal F Fs \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "{"], ["proof (state)\nthis:\n  Modal M Ms = Modal F Fs \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "assume \"Modal M Ms \\<in> set_mset \\<Gamma>1\""], ["proof (state)\nthis:\n  Modal M Ms \\<in># \\<Gamma>1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  Modal M Ms \\<in># \\<Gamma>1", "have \"Modal M Ms \\<in># \\<Gamma>1\""], ["proof (prove)\nusing this:\n  Modal M Ms \\<in># \\<Gamma>1\n\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># \\<Gamma>1", "by auto"], ["proof (state)\nthis:\n  Modal M Ms \\<in># \\<Gamma>1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  Modal M Ms \\<in># \\<Gamma>1", "have \"\\<exists> \\<Gamma>2. \\<Gamma>1 = \\<Gamma>2 \\<oplus> Modal M Ms\""], ["proof (prove)\nusing this:\n  Modal M Ms \\<in># \\<Gamma>1\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>2. \\<Gamma>1 = \\<Gamma>2 \\<oplus> Modal M Ms", "using insert_DiffM[where x=\"Modal M Ms\" and M=\"\\<Gamma>1\"]"], ["proof (prove)\nusing this:\n  Modal M Ms \\<in># \\<Gamma>1\n  Modal M Ms \\<in># \\<Gamma>1 \\<Longrightarrow>\n  add_mset (Modal M Ms) (\\<Gamma>1 \\<ominus> Modal M Ms) = \\<Gamma>1\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>2. \\<Gamma>1 = \\<Gamma>2 \\<oplus> Modal M Ms", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># \\<Gamma>1 \\<Longrightarrow>\n    \\<exists>\\<Gamma>2. \\<Gamma>1 = add_mset (Modal M Ms) \\<Gamma>2", "apply (rule_tac x=\"\\<Gamma>1\\<ominus>Modal M Ms\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Modal M Ms \\<in># \\<Gamma>1 \\<Longrightarrow>\n    \\<Gamma>1 = add_mset (Modal M Ms) (\\<Gamma>1 \\<ominus> Modal M Ms)", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  \\<exists>\\<Gamma>2. \\<Gamma>1 = \\<Gamma>2 \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  \\<exists>\\<Gamma>2. \\<Gamma>1 = \\<Gamma>2 \\<oplus> Modal M Ms", "obtain \\<Gamma>2 where \"\\<Gamma>1 = \\<Gamma>2 \\<oplus> Modal M Ms\""], ["proof (prove)\nusing this:\n  \\<exists>\\<Gamma>2. \\<Gamma>1 = \\<Gamma>2 \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Gamma>2.\n        \\<Gamma>1 = \\<Gamma>2 \\<oplus> Modal M Ms \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<Gamma>1 = \\<Gamma>2 \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "from ba and rules"], ["proof (chain)\npicking this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3", "have \"extendConc (\\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r \\<in> (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  R1 \\<subseteq> upRules \\<and>\n  R2 \\<subseteq> modRules2 \\<and>\n  R3 \\<subseteq> modRules2 \\<and>\n  R = Ax \\<union> R1 \\<union> p_e R2 M1 M2 \\<union> R3 \\<and>\n  R' = Ax \\<union> R1 \\<union> R2 \\<union> R3\n\ngoal (1 subgoal):\n 1. extendConc ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>')\n     r\n    \\<in> ext R R2 M1 M2", "by auto"], ["proof (state)\nthis:\n  extendConc ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  extendConc ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "from ba and ca"], ["proof (chain)\npicking this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'", "have \"fst (extendConc (\\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r) = Ps\""], ["proof (prove)\nusing this:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'\n\ngoal (1 subgoal):\n 1. fst (extendConc\n          ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r) =\n    Ps", "by (auto simp add:extendConc_def)"], ["proof (state)\nthis:\n  fst (extendConc\n        ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r) =\n  Ps\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  extendConc ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n  fst (extendConc\n        ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r) =\n  Ps", "have \"(snd (extendConc (\\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r),n'+1) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  extendConc ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n  fst (extendConc\n        ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r) =\n  Ps\n\ngoal (1 subgoal):\n 1. (snd (extendConc\n           ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r),\n     n' + 1)\n    \\<in> derivable (ext R R2 M1 M2)", "using d' and derivable.step[where r=\"extendConc (\\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r\"\n                                                     and R=\"ext R R2 M1 M2\" and m=n'] and \\<open>Ps \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  extendConc ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r\n  \\<in> ext R R2 M1 M2\n  fst (extendConc\n        ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r) =\n  Ps\n  \\<forall>p\\<in>set Ps.\n     \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\n  \\<lbrakk>extendConc\n            ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r\n           \\<in> ext R R2 M1 M2;\n   fst (extendConc\n         ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>')\n         r) \\<noteq>\n   [];\n   \\<forall>p\\<in>set (fst (extendConc\n                             ( \\<Gamma>2 +\n                               \\<Gamma>' \\<Rightarrow>* \\<Delta>1 +\n                  \\<Delta>')\n                             r)).\n      \\<exists>n\\<le>n'. (p, n) \\<in> derivable (ext R R2 M1 M2)\\<rbrakk>\n  \\<Longrightarrow> (snd (extendConc\n                           ( \\<Gamma>2 +\n                             \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>')\n                           r),\n                     n' + 1)\n                    \\<in> derivable (ext R R2 M1 M2)\n  Ps \\<noteq> []\n\ngoal (1 subgoal):\n 1. (snd (extendConc\n           ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r),\n     n' + 1)\n    \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  (snd (extendConc\n         ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r),\n   n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  (snd (extendConc\n         ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r),\n   n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "from ca and \\<open>r' = (ps,\\<LM>Modal F Fs\\<RM> \\<Rightarrow>* \\<Empt>)\\<close>"], ["proof (chain)\npicking this:\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'\n  r' = (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"snd (extendConc (\\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r) = ((M1\\<cdot>\\<Gamma>'' \\<oplus> Modal F Fs )+ \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* M2\\<cdot>\\<Delta>'' + \\<Delta>1 + \\<Delta>')\""], ["proof (prove)\nusing this:\n  r =\n  extendRule ( M1 \\<cdot> \\<Gamma>'' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'')\n   r'\n  r' = (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. snd (extendConc\n          ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r) =\n    ( M1 \\<cdot> \\<Gamma>'' \\<oplus> Modal F Fs + \\<Gamma>2 +\n      \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>1 +\n                               \\<Delta>')", "by (auto simp add:extendRule_def extendConc_def extend_def union_ac)"], ["proof (state)\nthis:\n  snd (extendConc\n        ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r) =\n  ( M1 \\<cdot> \\<Gamma>'' \\<oplus> Modal F Fs + \\<Gamma>2 +\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>1 + \\<Delta>')\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  (snd (extendConc\n         ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r),\n   n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n  snd (extendConc\n        ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r) =\n  ( M1 \\<cdot> \\<Gamma>'' \\<oplus> Modal F Fs + \\<Gamma>2 +\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>1 + \\<Delta>')", "have gg: \"(M1\\<cdot>\\<Gamma>'' + \\<Gamma>2 + \\<Gamma>' \\<oplus> Modal F Fs\\<Rightarrow>* M2\\<cdot>\\<Delta>'' + \\<Delta>1 + \\<Delta>',n'+1) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  (snd (extendConc\n         ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r),\n   n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n  snd (extendConc\n        ( \\<Gamma>2 + \\<Gamma>' \\<Rightarrow>* \\<Delta>1 + \\<Delta>') r) =\n  ( M1 \\<cdot> \\<Gamma>'' \\<oplus> Modal F Fs + \\<Gamma>2 +\n    \\<Gamma>' \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>1 + \\<Delta>')\n\ngoal (1 subgoal):\n 1. ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 +\n      \\<Gamma>' \\<oplus>\n      Modal F\n       Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>1 + \\<Delta>',\n     n' + 1)\n    \\<in> derivable (ext R R2 M1 M2)", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 +\n    \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>1 + \\<Delta>',\n   n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "from eq1"], ["proof (chain)\npicking this:\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>1 \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>1) =\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)", "have \"M2\\<cdot>\\<Delta>'' + \\<Delta>1 = \\<Delta>\""], ["proof (prove)\nusing this:\n  ( M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>1 \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>1) =\n  ( \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n\ngoal (1 subgoal):\n 1. M2 \\<cdot> \\<Delta>'' + \\<Delta>1 = \\<Delta>", "by auto"], ["proof (state)\nthis:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 = \\<Delta>\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 = \\<Delta>", "have \"(M2\\<cdot>\\<Delta>'' + \\<Delta>1 + \\<Delta>') = \\<Delta> + \\<Delta>'\""], ["proof (prove)\nusing this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 = \\<Delta>\n\ngoal (1 subgoal):\n 1. M2 \\<cdot> \\<Delta>'' + \\<Delta>1 + \\<Delta>' = \\<Delta> + \\<Delta>'", "by auto"], ["proof (state)\nthis:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 + \\<Delta>' = \\<Delta> + \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "moreover"], ["proof (state)\nthis:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 + \\<Delta>' = \\<Delta> + \\<Delta>'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "from eq2 and \\<open>\\<Gamma>1 = \\<Gamma>2 \\<oplus> Modal M Ms\\<close>"], ["proof (chain)\npicking this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 \\<oplus> Modal F Fs =\n  \\<Gamma> \\<oplus> Modal M Ms\n  \\<Gamma>1 = \\<Gamma>2 \\<oplus> Modal M Ms", "have \"M1\\<cdot>\\<Gamma>'' + \\<Gamma>2 \\<oplus> Modal F Fs \\<oplus> Modal M Ms = \\<Gamma> \\<oplus> Modal M Ms\""], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>1 \\<oplus> Modal F Fs =\n  \\<Gamma> \\<oplus> Modal M Ms\n  \\<Gamma>1 = \\<Gamma>2 \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>'' +\n    \\<Gamma>2 \\<oplus> Modal F Fs \\<oplus> Modal M Ms =\n    \\<Gamma> \\<oplus> Modal M Ms", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  M1 \\<cdot> \\<Gamma>'' +\n  \\<Gamma>2 \\<oplus> Modal F Fs \\<oplus> Modal M Ms =\n  \\<Gamma> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  M1 \\<cdot> \\<Gamma>'' +\n  \\<Gamma>2 \\<oplus> Modal F Fs \\<oplus> Modal M Ms =\n  \\<Gamma> \\<oplus> Modal M Ms", "have \"M1\\<cdot>\\<Gamma>'' + \\<Gamma>2 \\<oplus> Modal F Fs = \\<Gamma>\""], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>'' +\n  \\<Gamma>2 \\<oplus> Modal F Fs \\<oplus> Modal M Ms =\n  \\<Gamma> \\<oplus> Modal M Ms\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 \\<oplus> Modal F Fs = \\<Gamma>", "using add_equal_means_equal[where \\<Gamma>=\" M1\\<cdot>\\<Gamma>'' + \\<Gamma>2 \\<oplus> Modal F Fs\" and \\<Delta>=\\<Gamma> and A=\"Modal M Ms\"]"], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>'' +\n  \\<Gamma>2 \\<oplus> Modal F Fs \\<oplus> Modal M Ms =\n  \\<Gamma> \\<oplus> Modal M Ms\n  (M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 \\<oplus> Modal F Fs) \\<oplus>\n  Modal M Ms =\n  \\<Gamma> \\<oplus> Modal M Ms \\<Longrightarrow>\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 \\<oplus> Modal F Fs = \\<Gamma>\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 \\<oplus> Modal F Fs = \\<Gamma>", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 \\<oplus> Modal F Fs = \\<Gamma>\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 \\<oplus> Modal F Fs = \\<Gamma>", "have \"M1\\<cdot>\\<Gamma>'' + \\<Gamma>2 + \\<Gamma>' \\<oplus> Modal F Fs = \\<Gamma> + \\<Gamma>'\""], ["proof (prove)\nusing this:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 \\<oplus> Modal F Fs = \\<Gamma>\n\ngoal (1 subgoal):\n 1. M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 + \\<Gamma>' \\<oplus> Modal F Fs =\n    \\<Gamma> + \\<Gamma>'", "by (auto simp add:union_ac)"], ["proof (state)\nthis:\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 + \\<Gamma>' \\<oplus> Modal F Fs =\n  \\<Gamma> + \\<Gamma>'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 + \\<Delta>' = \\<Delta> + \\<Delta>'\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 + \\<Gamma>' \\<oplus> Modal F Fs =\n  \\<Gamma> + \\<Gamma>'", "have \"(\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',n'+1) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 + \\<Delta>' = \\<Delta> + \\<Delta>'\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 + \\<Gamma>' \\<oplus> Modal F Fs =\n  \\<Gamma> + \\<Gamma>'\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n    \\<in> derivable (ext R R2 M1 M2)", "using gg"], ["proof (prove)\nusing this:\n  M2 \\<cdot> \\<Delta>'' + \\<Delta>1 + \\<Delta>' = \\<Delta> + \\<Delta>'\n  M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 + \\<Gamma>' \\<oplus> Modal F Fs =\n  \\<Gamma> + \\<Gamma>'\n  ( M1 \\<cdot> \\<Gamma>'' + \\<Gamma>2 +\n    \\<Gamma>' \\<oplus>\n    Modal F Fs \\<Rightarrow>* M2 \\<cdot> \\<Delta>'' + \\<Delta>1 + \\<Delta>',\n   n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n    \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "then"], ["proof (chain)\npicking this:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)", "have \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "using \\<open>n = Suc n'\\<close>"], ["proof (prove)\nusing this:\n  ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', n' + 1)\n  \\<in> derivable (ext R R2 M1 M2)\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  Modal M Ms \\<in># \\<Gamma>1 \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>'' \\<or>\n  Modal M Ms \\<in># \\<Gamma>1 \\<or> Modal M Ms = Modal F Fs\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>'' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  Modal M Ms = Modal F Fs \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  Modal M Ms \\<in># \\<Gamma>1 \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)", "have \"\\<exists>m\\<le>n. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>'' \\<or>\n  Modal M Ms \\<in># \\<Gamma>1 \\<or> Modal M Ms = Modal F Fs\n  Modal M Ms \\<in># M1 \\<cdot> \\<Gamma>'' \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  Modal M Ms = Modal F Fs \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  Modal M Ms \\<in># \\<Gamma>1 \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  r' =\n  (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  S = ( \\<Gamma>1 \\<Rightarrow>* \\<Delta>1)\n  r' =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  r' =\n  (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)", "have \"\\<exists>m\\<le>n. ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  S = ( \\<Gamma>1 \\<Rightarrow>* \\<Delta>1)\n  r' =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  r' =\n  (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "using cc"], ["proof (prove)\nusing this:\n  S = ( \\<Gamma>1 \\<Rightarrow>* \\<Delta>1)\n  r' =\n  (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  r' =\n  (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  r' = (ps,  \\<Empt> \\<Rightarrow>* \\<LM> Modal F Fs  \\<RM>) \\<or>\n  r' = (ps,  \\<LM> Modal F Fs  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "}"], ["proof (state)\nthis:\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,\n    \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>m\\<le>n.\n          ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n          \\<in> derivable (ext R R2 M1 M2)", "ultimately"], ["proof (chain)\npicking this:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>) \\<or>\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r \\<in> R\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,\n    \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,\n    \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)", "show \"\\<exists> m\\<le>n. (\\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>',m) \\<in> derivable (ext R R2 M1 M2)\""], ["proof (prove)\nusing this:\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>) \\<or>\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,  \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>)\n  r \\<in> R\n  (r \\<in> Ax \\<or> r \\<in> upRules \\<or> r \\<in> modRules2) \\<and>\n  extendRule S r =\n  (Ps,\n    \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n  r \\<in> p_e R2 M1 M2 \\<and>\n  extendConc S r =\n  (Ps,\n    \\<Gamma> \\<oplus> Modal M Ms \\<Rightarrow>* \\<Delta>) \\<Longrightarrow>\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n       \\<in> derivable (ext R R2 M1 M2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> + \\<Gamma>' \\<Rightarrow>* \\<Delta> + \\<Delta>', m)\n     \\<in> derivable (ext R R2 M1 M2)\n\ngoal:\nNo subgoals!", "qed"], ["", "datatype C = con"], ["", "datatype BD = BOX (\"\\<box>\")| DIAMOND (\"\\<diamond>\")"], ["", "type_synonym CDBD_form = \"(C,BD) form\""], ["", "abbreviation con_form (infixl \"\\<and>*\" 80) where\n   \"p \\<and>* (q :: CDBD_form) \\<equiv> Compound con [p,q]\""], ["", "abbreviation BOX_form ( \"\\<box> _\" [80]80) where\n   \"\\<box> (p:: CDBD_form)  \\<equiv> Modal \\<box> [p]\""], ["", "abbreviation DIAMOND_form (\"\\<diamond> _\" [80]80) where\n   \"\\<diamond> (p :: CDBD_form) \\<equiv> Modal \\<diamond> [p]\""], ["", "inductive_set \"g3up\"\nwhere\n    conL[intro]: \"([\\<LM> A \\<RM> + \\<LM> B \\<RM> \\<Rightarrow>* \\<Empt>], \\<LM> A \\<and>* B \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> g3up\"\n|   conR[intro]: \"([\\<Empt> \\<Rightarrow>* \\<LM> A \\<RM>, \\<Empt> \\<Rightarrow>* \\<LM> B \\<RM>], \\<Empt> \\<Rightarrow>* \\<LM> A \\<and>* B \\<RM>) \\<in> g3up\""], ["", "(*>*)"], ["", "text\\<open>\n\nWe guarantee no other rule has the same modal operator in the succedent of a modalised context rule using the condition $M \\neq M_{2}$.  Note this lemma only allows one kind of modalised context rule.  In other words, it could not be applied to a calculus with the rules:\n\n\\[\n\\begin{array}{ccc}\n\\infer[R_{1}]{\\Gamma',!\\cdot\\Gamma \\Rightarrow \\bullet A,\\bullet\\cdot\\Delta,\\Delta'}{!\\cdot\\Gamma \\Rightarrow A,\\bullet\\cdot\\Delta} & \\ \\ \\ &\n\\infer[R_{2}]{\\Gamma',\\bullet\\cdot\\Gamma \\Rightarrow \\bullet A,!\\cdot\\Delta,\\Delta'}{\\bullet\\cdot\\Gamma \\Rightarrow A,!\\cdot\\Delta}\n\\end{array}\n\\]\nsince, if $([\\emptyset \\Rightarrow A],\\emptyset \\Rightarrow \\bullet A) \\in \\mathcal{R}$, then $R_{1} \\in \\textrm{p-e } \\mathcal{R}\\ !\\ \\bullet$, whereas $R_{2} \\in \\textrm{p-e } \\mathcal{R}\\ \\bullet\\ !$.  Similarly, we cannot have modalised context rules which have more than one modalised multiset in the antecedent or succedent of the active part.  For instance:\n\n\\[\n\\infer{\\Gamma',!\\cdot\\Gamma_{1},\\bullet\\cdot\\Gamma_{2} \\Rightarrow \\bullet A,!\\cdot\\Delta_{1},\\bullet\\cdot\\Delta_{2},\\Delta'}{!\\cdot\\Gamma_{1},\\bullet\\cdot\\Gamma_{2} \\Rightarrow A,!\\cdot\\Delta_{1},\\bullet\\cdot\\Delta_{2}}\n\\]\ncannot belong to any \\texttt{p-e} set.  It would be a simple matter to extend the definition of \\texttt{p-e} to take a \\textit{set} of modal operators, however this has not been done. \n\nAs an example, classical modal logic can be formalised.\nThe (modal) rules for this calculus are then given in two sets, the latter of which will be extended with $\\Box\\cdot\\Gamma \\Rightarrow \\Diamond\\cdot\\Delta$:\n\\<close>"], ["", "inductive_set \"g3mod2\" \nwhere\n    diaR(*<*)[intro](*>*): \"([\\<Empt> \\<Rightarrow>* \\<LM> A \\<RM>], \\<Empt> \\<Rightarrow>* \\<LM> \\<diamond> A \\<RM>) \\<in> g3mod2\"\n|   boxL(*<*)[intro](*>*): \"([\\<LM> A \\<RM> \\<Rightarrow>* \\<Empt>], \\<LM> \\<box> A \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> g3mod2\""], ["", "inductive_set \"g3mod1\"\nwhere\n    boxR(*<*)[intro](*>*): \"([\\<Empt> \\<Rightarrow>* \\<LM>A\\<RM>],\\<Empt> \\<Rightarrow>* \\<LM> \\<box> A \\<RM>) \\<in> g3mod1\"\n|   diaL(*<*)[intro](*>*): \"([\\<LM>A\\<RM> \\<Rightarrow>* \\<Empt>],\\<LM> \\<diamond> A \\<RM> \\<Rightarrow>* \\<Empt>) \\<in> g3mod1\""], ["", "(*<*)"], ["", "lemma g3up_upRules:\nshows \"g3up \\<subseteq> upRules\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g3up \\<subseteq> upRules", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. g3up \\<subseteq> upRules", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. g3up \\<subseteq> upRules", "fix ps c"], ["proof (state)\ngoal (1 subgoal):\n 1. g3up \\<subseteq> upRules", "assume \"(ps,c) \\<in> g3up\""], ["proof (state)\nthis:\n  (ps, c) \\<in> g3up\n\ngoal (1 subgoal):\n 1. g3up \\<subseteq> upRules", "then"], ["proof (chain)\npicking this:\n  (ps, c) \\<in> g3up", "have \"(ps,c) \\<in> upRules\""], ["proof (prove)\nusing this:\n  (ps, c) \\<in> g3up\n\ngoal (1 subgoal):\n 1. (ps, c) \\<in> upRules", "by (induct) auto"], ["proof (state)\nthis:\n  (ps, c) \\<in> upRules\n\ngoal (1 subgoal):\n 1. g3up \\<subseteq> upRules", "}"], ["proof (state)\nthis:\n  (?ps2, ?c2) \\<in> g3up \\<Longrightarrow> (?ps2, ?c2) \\<in> upRules\n\ngoal (1 subgoal):\n 1. g3up \\<subseteq> upRules", "thus \"g3up \\<subseteq> upRules\""], ["proof (prove)\nusing this:\n  (?ps2, ?c2) \\<in> g3up \\<Longrightarrow> (?ps2, ?c2) \\<in> upRules\n\ngoal (1 subgoal):\n 1. g3up \\<subseteq> upRules", "by auto"], ["proof (state)\nthis:\n  g3up \\<subseteq> upRules\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g3mod2_modRules2:\nshows \"g3mod2 \\<subseteq> modRules2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g3mod2 \\<subseteq> modRules2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. g3mod2 \\<subseteq> modRules2", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. g3mod2 \\<subseteq> modRules2", "fix ps c"], ["proof (state)\ngoal (1 subgoal):\n 1. g3mod2 \\<subseteq> modRules2", "assume \"(ps,c) \\<in> g3mod2\""], ["proof (state)\nthis:\n  (ps, c) \\<in> g3mod2\n\ngoal (1 subgoal):\n 1. g3mod2 \\<subseteq> modRules2", "then"], ["proof (chain)\npicking this:\n  (ps, c) \\<in> g3mod2", "have \"(ps,c) \\<in> modRules2\""], ["proof (prove)\nusing this:\n  (ps, c) \\<in> g3mod2\n\ngoal (1 subgoal):\n 1. (ps, c) \\<in> modRules2", "by (induct) auto"], ["proof (state)\nthis:\n  (ps, c) \\<in> modRules2\n\ngoal (1 subgoal):\n 1. g3mod2 \\<subseteq> modRules2", "}"], ["proof (state)\nthis:\n  (?ps2, ?c2) \\<in> g3mod2 \\<Longrightarrow> (?ps2, ?c2) \\<in> modRules2\n\ngoal (1 subgoal):\n 1. g3mod2 \\<subseteq> modRules2", "thus \"g3mod2 \\<subseteq> modRules2\""], ["proof (prove)\nusing this:\n  (?ps2, ?c2) \\<in> g3mod2 \\<Longrightarrow> (?ps2, ?c2) \\<in> modRules2\n\ngoal (1 subgoal):\n 1. g3mod2 \\<subseteq> modRules2", "by auto"], ["proof (state)\nthis:\n  g3mod2 \\<subseteq> modRules2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g3mod1_modRules2:\nshows \"g3mod1 \\<subseteq> modRules2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g3mod1 \\<subseteq> modRules2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. g3mod1 \\<subseteq> modRules2", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. g3mod1 \\<subseteq> modRules2", "fix ps c"], ["proof (state)\ngoal (1 subgoal):\n 1. g3mod1 \\<subseteq> modRules2", "assume \"(ps,c) \\<in> g3mod1\""], ["proof (state)\nthis:\n  (ps, c) \\<in> g3mod1\n\ngoal (1 subgoal):\n 1. g3mod1 \\<subseteq> modRules2", "then"], ["proof (chain)\npicking this:\n  (ps, c) \\<in> g3mod1", "have \"(ps,c) \\<in> modRules2\""], ["proof (prove)\nusing this:\n  (ps, c) \\<in> g3mod1\n\ngoal (1 subgoal):\n 1. (ps, c) \\<in> modRules2", "by (induct) auto"], ["proof (state)\nthis:\n  (ps, c) \\<in> modRules2\n\ngoal (1 subgoal):\n 1. g3mod1 \\<subseteq> modRules2", "}"], ["proof (state)\nthis:\n  (?ps2, ?c2) \\<in> g3mod1 \\<Longrightarrow> (?ps2, ?c2) \\<in> modRules2\n\ngoal (1 subgoal):\n 1. g3mod1 \\<subseteq> modRules2", "thus \"g3mod1 \\<subseteq> modRules2\""], ["proof (prove)\nusing this:\n  (?ps2, ?c2) \\<in> g3mod1 \\<Longrightarrow> (?ps2, ?c2) \\<in> modRules2\n\ngoal (1 subgoal):\n 1. g3mod1 \\<subseteq> modRules2", "by auto"], ["proof (state)\nthis:\n  g3mod1 \\<subseteq> modRules2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas g3 = g3up_upRules g3mod1_modRules2 g3mod2_modRules2"], ["", "lemma principal_Ax:\nshows \"\\<lbrakk> r \\<in> Ax ; rightPrincipal r (\\<box> A) R \\<rbrakk> \\<Longrightarrow> (\\<Empt> \\<Rightarrow>* \\<LM>A\\<RM>) \\<in> set (fst r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<in> Ax; rightPrincipal r (\\<box> A) R\\<rbrakk>\n    \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                      \\<in> set (fst r)", "by (auto simp add:nonPrincipalID)"], ["", "lemma principal_g3up:\nshows \"\\<lbrakk> r \\<in> g3up ; rightPrincipal r (\\<box> A) R \\<rbrakk> \\<Longrightarrow> (\\<Empt> \\<Rightarrow>* \\<LM>A\\<RM>) \\<in> set (fst r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<in> g3up; rightPrincipal r (\\<box> A) R\\<rbrakk>\n    \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                      \\<in> set (fst r)", "apply (subgoal_tac \"r \\<in> upRules\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r \\<in> g3up; rightPrincipal r (\\<box> A) R;\n     r \\<in> upRules\\<rbrakk>\n    \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                      \\<in> set (fst r)\n 2. \\<lbrakk>r \\<in> g3up; rightPrincipal r (\\<box> A) R\\<rbrakk>\n    \\<Longrightarrow> r \\<in> upRules", "apply (auto simp add:upRules_not_right_principal_for_modal)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<in> g3up; rightPrincipal r (\\<box> A) R\\<rbrakk>\n    \\<Longrightarrow> r \\<in> upRules", "apply (insert g3up_upRules)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r \\<in> g3up; rightPrincipal r (\\<box> A) R;\n     g3up \\<subseteq> upRules\\<rbrakk>\n    \\<Longrightarrow> r \\<in> upRules", "by auto"], ["", "lemma principal_g3mod2:\nassumes \"r \\<in> g3mod2\"\nand \"R = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2\"\nand \"rightPrincipal r (\\<box> A) R\"\nshows \"(\\<Empt> \\<Rightarrow>* \\<LM>A\\<RM>) \\<in> set (fst r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "from \\<open>r \\<in> g3mod2\\<close>"], ["proof (chain)\npicking this:\n  r \\<in> g3mod2", "have \"\\<exists> A. r = ([\\<LM>A\\<RM> \\<Rightarrow>* \\<Empt>], \\<LM>\\<box> A\\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n                              r = ([\\<Empt> \\<Rightarrow>* \\<LM>A\\<RM>], \\<Empt> \\<Rightarrow>* \\<LM>\\<diamond> A\\<RM>)\""], ["proof (prove)\nusing this:\n  r \\<in> g3mod2\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       r =\n       ([ \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>],\n         \\<LM> \\<box> A  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n       r =\n       ([ \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>],\n         \\<Empt> \\<Rightarrow>* \\<LM> \\<diamond> A  \\<RM>)", "apply (cases r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>r \\<in> g3mod2; r = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            r =\n                            ([ \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>],\n                              \\<LM> \\<box> A  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n                            r =\n                            ([ \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>],\n                              \\<Empt> \\<Rightarrow>* \\<LM> \\<diamond> A  \\<RM>)", "by (rule g3mod2.cases) auto"], ["proof (state)\nthis:\n  \\<exists>A.\n     r =\n     ([ \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>],\n       \\<LM> \\<box> A  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n     r =\n     ([ \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>],\n       \\<Empt> \\<Rightarrow>* \\<LM> \\<diamond> A  \\<RM>)\n\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "then"], ["proof (chain)\npicking this:\n  \\<exists>A.\n     r =\n     ([ \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>],\n       \\<LM> \\<box> A  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n     r =\n     ([ \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>],\n       \\<Empt> \\<Rightarrow>* \\<LM> \\<diamond> A  \\<RM>)", "obtain B where  \"r = ([\\<LM>B\\<RM> \\<Rightarrow>* \\<Empt>], \\<LM>\\<box> B\\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n                       r = ([\\<Empt> \\<Rightarrow>* \\<LM>B\\<RM>], \\<Empt> \\<Rightarrow>* \\<LM>\\<diamond> B\\<RM>)\""], ["proof (prove)\nusing this:\n  \\<exists>A.\n     r =\n     ([ \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>],\n       \\<LM> \\<box> A  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n     r =\n     ([ \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>],\n       \\<Empt> \\<Rightarrow>* \\<LM> \\<diamond> A  \\<RM>)\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        r =\n        ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n          \\<LM> \\<box> B  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n        r =\n        ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n          \\<Empt> \\<Rightarrow>* \\<LM> \\<diamond> B  \\<RM>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  r =\n  ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n    \\<LM> \\<box> B  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n  r =\n  ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n    \\<Empt> \\<Rightarrow>* \\<LM> \\<diamond> B  \\<RM>)\n\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "then"], ["proof (chain)\npicking this:\n  r =\n  ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n    \\<LM> \\<box> B  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n  r =\n  ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n    \\<Empt> \\<Rightarrow>* \\<LM> \\<diamond> B  \\<RM>)", "have \"\\<not> rightPrincipal r (\\<box> A) R\""], ["proof (prove)\nusing this:\n  r =\n  ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n    \\<LM> \\<box> B  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n  r =\n  ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n    \\<Empt> \\<Rightarrow>* \\<LM> \\<diamond> B  \\<RM>)\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (\\<box> A) R", "using \\<open>R = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2\\<close>"], ["proof (prove)\nusing this:\n  r =\n  ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n    \\<LM> \\<box> B  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n  r =\n  ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n    \\<Empt> \\<Rightarrow>* \\<LM> \\<diamond> B  \\<RM>)\n  R = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (\\<box> A) R", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>R = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n     rightPrincipal\n      ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n        \\<LM> \\<box> B  \\<RM> \\<Rightarrow>* \\<Empt>)\n      (\\<box> A) (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n     r =\n     ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n       \\<LM> \\<box> B  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>R = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n     rightPrincipal\n      ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n        \\<Empt> \\<Rightarrow>* \\<LM> \\<diamond> B  \\<RM>)\n      (\\<box> A) (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n     r =\n     ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n       \\<Empt> \\<Rightarrow>* \\<LM> \\<diamond> B  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule rightPrincipal.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>R = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n     rightPrincipal\n      ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n        \\<LM> \\<box> B  \\<RM> \\<Rightarrow>* \\<Empt>)\n      (\\<box> A) (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n     r =\n     ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n       \\<LM> \\<box> B  \\<RM> \\<Rightarrow>* \\<Empt>)\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal ?a1.8 ?a2.8 ?a3.8\n 2. \\<And>C Aa Ps Ra.\n       \\<lbrakk>R = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal\n         ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n           \\<LM> \\<box> B  \\<RM> \\<Rightarrow>* \\<Empt>)\n         (\\<box> A) (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        r =\n        ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n          \\<LM> \\<box> B  \\<RM> \\<Rightarrow>* \\<Empt>);\n        ?a1.8 = (Ps, C); ?a2.8 = Aa; ?a3.8 = Ra;\n        C = ( \\<Empt> \\<Rightarrow>* \\<LM> Aa  \\<RM>);\n        (Ps, C) \\<in> Ra\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<lbrakk>R = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n     rightPrincipal\n      ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n        \\<Empt> \\<Rightarrow>* \\<LM> \\<diamond> B  \\<RM>)\n      (\\<box> A) (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n     r =\n     ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n       \\<Empt> \\<Rightarrow>* \\<LM> \\<diamond> B  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (auto simp add:extendRule_def extend_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n     rightPrincipal\n      ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n        \\<Empt> \\<Rightarrow>* \\<LM> \\<diamond> B  \\<RM>)\n      (\\<box> A) (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n     r =\n     ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n       \\<Empt> \\<Rightarrow>* \\<LM> \\<diamond> B  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule rightPrincipal.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>R = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n     rightPrincipal\n      ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n        \\<Empt> \\<Rightarrow>* \\<LM> \\<diamond> B  \\<RM>)\n      (\\<box> A) (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n     r =\n     ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n       \\<Empt> \\<Rightarrow>* \\<LM> \\<diamond> B  \\<RM>)\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal ?a1.30 ?a2.30 ?a3.30\n 2. \\<And>C Aa Ps Ra.\n       \\<lbrakk>R = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal\n         ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n           \\<Empt> \\<Rightarrow>* \\<LM> \\<diamond> B  \\<RM>)\n         (\\<box> A) (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        r =\n        ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n          \\<Empt> \\<Rightarrow>* \\<LM> \\<diamond> B  \\<RM>);\n        ?a1.30 = (Ps, C); ?a2.30 = Aa; ?a3.30 = Ra;\n        C = ( \\<Empt> \\<Rightarrow>* \\<LM> Aa  \\<RM>);\n        (Ps, C) \\<in> Ra\\<rbrakk>\n       \\<Longrightarrow> False", "by (auto simp add:extendRule_def extend_def)"], ["proof (state)\nthis:\n  \\<not> rightPrincipal r (\\<box> A) R\n\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "with \\<open>rightPrincipal r (\\<box> A) R\\<close>"], ["proof (chain)\npicking this:\n  rightPrincipal r (\\<box> A) R\n  \\<not> rightPrincipal r (\\<box> A) R", "show ?thesis"], ["proof (prove)\nusing this:\n  rightPrincipal r (\\<box> A) R\n  \\<not> rightPrincipal r (\\<box> A) R\n\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "by auto"], ["proof (state)\nthis:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma principal_g3mod1:\nassumes \"r \\<in> g3mod1\"\nand \"R = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2\"\nand \"rightPrincipal r (\\<box> A) R\"\nshows \"(\\<Empt> \\<Rightarrow>* \\<LM>A\\<RM>) \\<in> set (fst r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "from \\<open>r \\<in> g3mod1\\<close>"], ["proof (chain)\npicking this:\n  r \\<in> g3mod1", "have \"\\<exists> A. r = ([\\<LM>A\\<RM> \\<Rightarrow>* \\<Empt>], \\<LM>\\<diamond> A\\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n                              r = ([\\<Empt> \\<Rightarrow>* \\<LM>A\\<RM>], \\<Empt> \\<Rightarrow>* \\<LM>\\<box> A\\<RM>)\""], ["proof (prove)\nusing this:\n  r \\<in> g3mod1\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       r =\n       ([ \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>],\n         \\<LM> \\<diamond> A  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n       r =\n       ([ \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>],\n         \\<Empt> \\<Rightarrow>* \\<LM> \\<box> A  \\<RM>)", "apply (cases r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>r \\<in> g3mod1; r = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A.\n                            r =\n                            ([ \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>],\n                              \\<LM> \\<diamond> A  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n                            r =\n                            ([ \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>],\n                              \\<Empt> \\<Rightarrow>* \\<LM> \\<box> A  \\<RM>)", "by (rule g3mod1.cases) auto"], ["proof (state)\nthis:\n  \\<exists>A.\n     r =\n     ([ \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>],\n       \\<LM> \\<diamond> A  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n     r =\n     ([ \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>],\n       \\<Empt> \\<Rightarrow>* \\<LM> \\<box> A  \\<RM>)\n\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "then"], ["proof (chain)\npicking this:\n  \\<exists>A.\n     r =\n     ([ \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>],\n       \\<LM> \\<diamond> A  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n     r =\n     ([ \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>],\n       \\<Empt> \\<Rightarrow>* \\<LM> \\<box> A  \\<RM>)", "obtain B where  \"r = ([\\<LM>B\\<RM> \\<Rightarrow>* \\<Empt>], \\<LM>\\<diamond> B\\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n                       r = ([\\<Empt> \\<Rightarrow>* \\<LM>B\\<RM>], \\<Empt> \\<Rightarrow>* \\<LM>\\<box> B\\<RM>)\""], ["proof (prove)\nusing this:\n  \\<exists>A.\n     r =\n     ([ \\<LM> A  \\<RM> \\<Rightarrow>* \\<Empt>],\n       \\<LM> \\<diamond> A  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n     r =\n     ([ \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>],\n       \\<Empt> \\<Rightarrow>* \\<LM> \\<box> A  \\<RM>)\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        r =\n        ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n          \\<LM> \\<diamond> B  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n        r =\n        ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n          \\<Empt> \\<Rightarrow>* \\<LM> \\<box> B  \\<RM>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  r =\n  ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n    \\<LM> \\<diamond> B  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n  r =\n  ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n    \\<Empt> \\<Rightarrow>* \\<LM> \\<box> B  \\<RM>)\n\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "moreover"], ["proof (state)\nthis:\n  r =\n  ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n    \\<LM> \\<diamond> B  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n  r =\n  ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n    \\<Empt> \\<Rightarrow>* \\<LM> \\<box> B  \\<RM>)\n\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "{"], ["proof (state)\nthis:\n  r =\n  ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n    \\<LM> \\<diamond> B  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n  r =\n  ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n    \\<Empt> \\<Rightarrow>* \\<LM> \\<box> B  \\<RM>)\n\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "assume \"r = ([\\<LM>B\\<RM> \\<Rightarrow>* \\<Empt>], \\<LM>\\<diamond> B\\<RM> \\<Rightarrow>* \\<Empt>)\""], ["proof (state)\nthis:\n  r =\n  ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n    \\<LM> \\<diamond> B  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "then"], ["proof (chain)\npicking this:\n  r =\n  ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n    \\<LM> \\<diamond> B  \\<RM> \\<Rightarrow>* \\<Empt>)", "have \"\\<not> rightPrincipal r (\\<box> A) R\""], ["proof (prove)\nusing this:\n  r =\n  ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n    \\<LM> \\<diamond> B  \\<RM> \\<Rightarrow>* \\<Empt>)\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (\\<box> A) R", "using \\<open>R = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2\\<close>"], ["proof (prove)\nusing this:\n  r =\n  ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n    \\<LM> \\<diamond> B  \\<RM> \\<Rightarrow>* \\<Empt>)\n  R = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2\n\ngoal (1 subgoal):\n 1. \\<not> rightPrincipal r (\\<box> A) R", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r =\n             ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n               \\<LM> \\<diamond> B  \\<RM> \\<Rightarrow>* \\<Empt>);\n     R = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n     rightPrincipal\n      ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n        \\<LM> \\<diamond> B  \\<RM> \\<Rightarrow>* \\<Empt>)\n      (\\<box> A) (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule rightPrincipal.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r =\n             ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n               \\<LM> \\<diamond> B  \\<RM> \\<Rightarrow>* \\<Empt>);\n     R = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n     rightPrincipal\n      ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n        \\<LM> \\<diamond> B  \\<RM> \\<Rightarrow>* \\<Empt>)\n      (\\<box> A) (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2)\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal ?a1.3 ?a2.3 ?a3.3\n 2. \\<And>C Aa Ps Ra.\n       \\<lbrakk>r =\n                ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n                  \\<LM> \\<diamond> B  \\<RM> \\<Rightarrow>* \\<Empt>);\n        R = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal\n         ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n           \\<LM> \\<diamond> B  \\<RM> \\<Rightarrow>* \\<Empt>)\n         (\\<box> A) (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        ?a1.3 = (Ps, C); ?a2.3 = Aa; ?a3.3 = Ra;\n        C = ( \\<Empt> \\<Rightarrow>* \\<LM> Aa  \\<RM>);\n        (Ps, C) \\<in> Ra\\<rbrakk>\n       \\<Longrightarrow> False", "by (auto simp add:extendRule_def extend_def)"], ["proof (state)\nthis:\n  \\<not> rightPrincipal r (\\<box> A) R\n\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "with \\<open>rightPrincipal r (\\<box> A) R\\<close>"], ["proof (chain)\npicking this:\n  rightPrincipal r (\\<box> A) R\n  \\<not> rightPrincipal r (\\<box> A) R", "have \"(\\<Empt> \\<Rightarrow>* \\<LM>A\\<RM>) \\<in> set (fst r)\""], ["proof (prove)\nusing this:\n  rightPrincipal r (\\<box> A) R\n  \\<not> rightPrincipal r (\\<box> A) R\n\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "by auto"], ["proof (state)\nthis:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)\n\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "}"], ["proof (state)\nthis:\n  r =\n  ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n    \\<LM> \\<diamond> B  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)\n\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "moreover"], ["proof (state)\nthis:\n  r =\n  ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n    \\<LM> \\<diamond> B  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)\n\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "{"], ["proof (state)\nthis:\n  r =\n  ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n    \\<LM> \\<diamond> B  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)\n\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "assume \"r = ([\\<Empt> \\<Rightarrow>* \\<LM>B\\<RM>], \\<Empt> \\<Rightarrow>* \\<LM>\\<box> B\\<RM>)\""], ["proof (state)\nthis:\n  r =\n  ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n    \\<Empt> \\<Rightarrow>* \\<LM> \\<box> B  \\<RM>)\n\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "then"], ["proof (chain)\npicking this:\n  r =\n  ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n    \\<Empt> \\<Rightarrow>* \\<LM> \\<box> B  \\<RM>)", "have \"rightPrincipal r (\\<box> B) R\""], ["proof (prove)\nusing this:\n  r =\n  ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n    \\<Empt> \\<Rightarrow>* \\<LM> \\<box> B  \\<RM>)\n\ngoal (1 subgoal):\n 1. rightPrincipal r (\\<box> B) R", "using \\<open>r \\<in> g3mod1\\<close> and \\<open>R = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2\\<close>"], ["proof (prove)\nusing this:\n  r =\n  ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n    \\<Empt> \\<Rightarrow>* \\<LM> \\<box> B  \\<RM>)\n  r \\<in> g3mod1\n  R = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2\n\ngoal (1 subgoal):\n 1. rightPrincipal r (\\<box> B) R", "by auto"], ["proof (state)\nthis:\n  rightPrincipal r (\\<box> B) R\n\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "with \\<open>rightPrincipal r (\\<box> A) R\\<close>"], ["proof (chain)\npicking this:\n  rightPrincipal r (\\<box> A) R\n  rightPrincipal r (\\<box> B) R", "have \"A = B\""], ["proof (prove)\nusing this:\n  rightPrincipal r (\\<box> A) R\n  rightPrincipal r (\\<box> B) R\n\ngoal (1 subgoal):\n 1. A = B", "apply-"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rightPrincipal r (\\<box> A) R;\n     rightPrincipal r (\\<box> B) R\\<rbrakk>\n    \\<Longrightarrow> A = B", "apply (rule rightPrincipal.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rightPrincipal r (\\<box> A) R;\n     rightPrincipal r (\\<box> B) R\\<rbrakk>\n    \\<Longrightarrow> rightPrincipal ?a1.2 ?a2.2 ?a3.2\n 2. \\<And>C Aa Ps Ra.\n       \\<lbrakk>rightPrincipal r (\\<box> A) R;\n        rightPrincipal r (\\<box> B) R; ?a1.2 = (Ps, C); ?a2.2 = Aa;\n        ?a3.2 = Ra; C = ( \\<Empt> \\<Rightarrow>* \\<LM> Aa  \\<RM>);\n        (Ps, C) \\<in> Ra\\<rbrakk>\n       \\<Longrightarrow> A = B", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps.\n       \\<lbrakk>rightPrincipal\n                 (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> \\<box> A  \\<RM>)\n                 (\\<box> A) R;\n        rightPrincipal (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> \\<box> A  \\<RM>)\n         (\\<box> B) R;\n        (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> \\<box> A  \\<RM>) \\<in> R;\n        r = (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> \\<box> A  \\<RM>)\\<rbrakk>\n       \\<Longrightarrow> A = B", "apply (rotate_tac 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps.\n       \\<lbrakk>rightPrincipal\n                 (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> \\<box> A  \\<RM>)\n                 (\\<box> B) R;\n        (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> \\<box> A  \\<RM>) \\<in> R;\n        r = (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> \\<box> A  \\<RM>);\n        rightPrincipal (Ps,  \\<Empt> \\<Rightarrow>* \\<LM> \\<box> A  \\<RM>)\n         (\\<box> A) R\\<rbrakk>\n       \\<Longrightarrow> A = B", "by (rule rightPrincipal.cases) auto"], ["proof (state)\nthis:\n  A = B\n\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "with \\<open>r = ([\\<Empt> \\<Rightarrow>* \\<LM>B\\<RM>], \\<Empt> \\<Rightarrow>* \\<LM>\\<box> B\\<RM>)\\<close>"], ["proof (chain)\npicking this:\n  r =\n  ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n    \\<Empt> \\<Rightarrow>* \\<LM> \\<box> B  \\<RM>)\n  A = B", "have \"(\\<Empt> \\<Rightarrow>* \\<LM>A\\<RM>) \\<in> set (fst r)\""], ["proof (prove)\nusing this:\n  r =\n  ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n    \\<Empt> \\<Rightarrow>* \\<LM> \\<box> B  \\<RM>)\n  A = B\n\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "by auto"], ["proof (state)\nthis:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)\n\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "}"], ["proof (state)\nthis:\n  r =\n  ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n    \\<Empt> \\<Rightarrow>* \\<LM> \\<box> B  \\<RM>) \\<Longrightarrow>\n  ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)\n\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "ultimately"], ["proof (chain)\npicking this:\n  r =\n  ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n    \\<LM> \\<diamond> B  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n  r =\n  ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n    \\<Empt> \\<Rightarrow>* \\<LM> \\<box> B  \\<RM>)\n  r =\n  ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n    \\<LM> \\<diamond> B  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)\n  r =\n  ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n    \\<Empt> \\<Rightarrow>* \\<LM> \\<box> B  \\<RM>) \\<Longrightarrow>\n  ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "show ?thesis"], ["proof (prove)\nusing this:\n  r =\n  ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n    \\<LM> \\<diamond> B  \\<RM> \\<Rightarrow>* \\<Empt>) \\<or>\n  r =\n  ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n    \\<Empt> \\<Rightarrow>* \\<LM> \\<box> B  \\<RM>)\n  r =\n  ([ \\<LM> B  \\<RM> \\<Rightarrow>* \\<Empt>],\n    \\<LM> \\<diamond> B  \\<RM> \\<Rightarrow>* \\<Empt>) \\<Longrightarrow>\n  ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)\n  r =\n  ([ \\<Empt> \\<Rightarrow>* \\<LM> B  \\<RM>],\n    \\<Empt> \\<Rightarrow>* \\<LM> \\<box> B  \\<RM>) \\<Longrightarrow>\n  ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)\n\ngoal (1 subgoal):\n 1. ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "by auto"], ["proof (state)\nthis:\n  ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma principal:\nassumes \"R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2\"\nshows \"\\<forall> r \\<in> R'. rightPrincipal r (\\<box> A) R' \\<longrightarrow> (\\<Empt> \\<Rightarrow>* \\<LM>A\\<RM>) \\<in> set (fst r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>R'.\n       rightPrincipal r (\\<box> A) R' \\<longrightarrow>\n       ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "using assms"], ["proof (prove)\nusing this:\n  R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>R'.\n       rightPrincipal r (\\<box> A) R' \\<longrightarrow>\n       ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)", "apply auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> Ax\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a\n 2. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> g3up\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a\n 3. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> g3mod1\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a\n 4. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> g3mod2\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a", "apply (insert principal_Ax)[1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> Ax;\n        \\<And>r A R.\n           \\<lbrakk>r \\<in> Ax; rightPrincipal r (\\<box> A) R\\<rbrakk>\n           \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                             \\<in> set (fst r)\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a\n 2. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> g3up\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a\n 3. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> g3mod1\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a\n 4. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> g3mod2\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a", "apply (drule_tac x=\"(a,b)\" in meta_spec)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> Ax;\n        \\<And>A R.\n           \\<lbrakk>(a, b) \\<in> Ax;\n            rightPrincipal (a, b) (\\<box> A) R\\<rbrakk>\n           \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                             \\<in> set (fst (a, b))\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a\n 2. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> g3up\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a\n 3. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> g3mod1\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a\n 4. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> g3mod2\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> g3up\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a\n 2. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> g3mod1\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a\n 3. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> g3mod2\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a", "apply (insert principal_g3up)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> g3up;\n        \\<And>r A R.\n           \\<lbrakk>r \\<in> g3up; rightPrincipal r (\\<box> A) R\\<rbrakk>\n           \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                             \\<in> set (fst r)\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a\n 2. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> g3mod1\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a\n 3. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> g3mod2\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a", "apply (drule_tac x=\"(a,b)\" in meta_spec)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> g3up;\n        \\<And>A R.\n           \\<lbrakk>(a, b) \\<in> g3up;\n            rightPrincipal (a, b) (\\<box> A) R\\<rbrakk>\n           \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                             \\<in> set (fst (a, b))\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a\n 2. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> g3mod1\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a\n 3. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> g3mod2\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> g3mod1\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a\n 2. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> g3mod2\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a", "apply (insert principal_g3mod1)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> g3mod1;\n        \\<And>r R A.\n           \\<lbrakk>r \\<in> g3mod1;\n            R = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n            rightPrincipal r (\\<box> A) R\\<rbrakk>\n           \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                             \\<in> set (fst r)\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a\n 2. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> g3mod2\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a", "apply (drule_tac x=\"(a,b)\" in meta_spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> g3mod1;\n        \\<And>R A.\n           \\<lbrakk>(a, b) \\<in> g3mod1;\n            R = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n            rightPrincipal (a, b) (\\<box> A) R\\<rbrakk>\n           \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                             \\<in> set (fst (a, b))\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a\n 2. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> g3mod2\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> g3mod2\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a", "apply (insert principal_g3mod2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> g3mod2;\n        \\<And>r R A.\n           \\<lbrakk>r \\<in> g3mod2;\n            R = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n            rightPrincipal r (\\<box> A) R\\<rbrakk>\n           \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                             \\<in> set (fst r)\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a", "apply (drule_tac x=\"(a,b)\" in meta_spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>R' = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n        rightPrincipal (a, b) (\\<box> A)\n         (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2);\n        (a, b) \\<in> g3mod2;\n        \\<And>R A.\n           \\<lbrakk>(a, b) \\<in> g3mod2;\n            R = Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n            rightPrincipal (a, b) (\\<box> A) R\\<rbrakk>\n           \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                             \\<in> set (fst (a, b))\\<rbrakk>\n       \\<Longrightarrow> ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>)\n                         \\<in> set a", "by auto"], ["", "(*>*)"], ["", "text\\<open>\n\\noindent We then show the strong admissibility of the rule:\n\n\\[\n\\infer{\\Gamma \\Rightarrow A,\\Delta}{\\Gamma \\Rightarrow \\Box A,\\Delta}\n\\]\n\n\\<close>"], ["", "lemma invertBoxR:\nassumes \"R = Ax \\<union> g3up \\<union> (p_e g3mod1 \\<box> \\<diamond>) \\<union> g3mod2\"\nand     \"(\\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> (\\<box> A),n) \\<in> derivable (ext R g3mod1 \\<box> \\<diamond>)\"\nshows   \"\\<exists> m\\<le>n. (\\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> A,m) \\<in> derivable (ext R g3mod1 \\<box> \\<diamond>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> A, m)\n       \\<in> derivable (ext R g3mod1 \\<box> \\<diamond>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> A, m)\n       \\<in> derivable (ext R g3mod1 \\<box> \\<diamond>)", "from assms"], ["proof (chain)\npicking this:\n  R = Ax \\<union> g3up \\<union> p_e g3mod1 \\<box> \\<diamond> \\<union> g3mod2\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> (\\<box> A), n)\n  \\<in> derivable (ext R g3mod1 \\<box> \\<diamond>)", "show ?thesis"], ["proof (prove)\nusing this:\n  R = Ax \\<union> g3up \\<union> p_e g3mod1 \\<box> \\<diamond> \\<union> g3mod2\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> (\\<box> A), n)\n  \\<in> derivable (ext R g3mod1 \\<box> \\<diamond>)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> A, m)\n       \\<in> derivable (ext R g3mod1 \\<box> \\<diamond>)", "using principal(*<*)[where R'=\"Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2\" and A=A] (*>*)\n and rightInvert(*<*)[where ?R1.0=\"g3up\" and ?R2.0=\"g3mod1\" and ?R3.0=\"g3mod2\" and R=R and ?M1.0=\\<box> and ?M2.0=\\<diamond>\n                       and M=\\<box> and Ms=\"[A]\" and n=n and \\<Gamma>=\\<Gamma> and \\<Delta>=\\<Delta> and \\<Gamma>'=\"\\<Empt>\" and \\<Delta>'=\"\\<LM>A\\<RM>\"\n                       and R'=\"Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2\"](*>*)\n and g3"], ["proof (prove)\nusing this:\n  R = Ax \\<union> g3up \\<union> p_e g3mod1 \\<box> \\<diamond> \\<union> g3mod2\n  ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> (\\<box> A), n)\n  \\<in> derivable (ext R g3mod1 \\<box> \\<diamond>)\n  Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2 =\n  Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2 \\<Longrightarrow>\n  \\<forall>r\\<in>Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2.\n     rightPrincipal r (\\<box> A)\n      (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2) \\<longrightarrow>\n     ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r)\n  \\<lbrakk>g3up \\<subseteq> upRules \\<and>\n           g3mod1 \\<subseteq> modRules2 \\<and>\n           g3mod2 \\<subseteq> modRules2 \\<and>\n           R =\n           Ax \\<union> g3up \\<union> p_e g3mod1 \\<box> \\<diamond> \\<union>\n           g3mod2 \\<and>\n           Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2 =\n           Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2;\n   ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> (\\<box> A), n)\n   \\<in> derivable (ext R g3mod1 \\<box> \\<diamond>);\n   \\<forall>r'\\<in>Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2.\n      rightPrincipal r' (\\<box> A)\n       (Ax \\<union> g3up \\<union> g3mod1 \\<union> g3mod2) \\<longrightarrow>\n      ( \\<Empt> \\<Rightarrow>* \\<LM> A  \\<RM>) \\<in> set (fst r');\n   \\<diamond> \\<noteq> \\<box>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m\\<le>n.\n                       ( \\<Gamma> +\n                         \\<Empt> \\<Rightarrow>* \\<Delta> \\<oplus> A,\n                        m)\n                       \\<in> derivable (ext R g3mod1 \\<box> \\<diamond>)\n  g3up \\<subseteq> upRules\n  g3mod1 \\<subseteq> modRules2\n  g3mod2 \\<subseteq> modRules2\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<le>n.\n       ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> A, m)\n       \\<in> derivable (ext R g3mod1 \\<box> \\<diamond>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<le>n.\n     ( \\<Gamma> \\<Rightarrow>* \\<Delta> \\<oplus> A, m)\n     \\<in> derivable (ext R g3mod1 \\<box> \\<diamond>)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\\noindent where \\textit{principal} is the result which fulfils the principal formula conditions given in the inversion lemma, and \\textit{g3} is a result about rule sets.\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}