{"file_name": "/home/qj213/afp-2021-10-22/thys/Combinatorics_Words_Lyndon/Lyndon.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Combinatorics_Words_Lyndon", "problem_names": ["lemma (in linorder) lexordp_mid_pref: \"ord_class.lexordp u v \\<Longrightarrow> ord_class.lexordp v (u\\<cdot>s) \\<Longrightarrow>\n   u \\<le>p v\"", "lemma (in linorder) lexordp_ext: \"ord_class.lexordp u v \\<Longrightarrow>  \\<not> u \\<le>p v \\<Longrightarrow> \n  ord_class.lexordp (u\\<cdot>w) (v\\<cdot>z)\"", "lemmas [code] = lexordp_simps", "lemma sorted_dual_rev_iff: \"dual_rlex.sorted ws \\<longleftrightarrow> rlex.sorted (rev ws)\"", "lemmas lexord_suf_linorder = lexord_sufE[of _ _ _ _ \"{(x, y). x < y}\", folded lexordp_conv_lexord]\n  and lexord_append_leftI_linorder = lexord_append_leftI[of  _ _  \"{(x, y). x < y}\" _, folded lexordp_conv_lexord]\n  and lexord_app_right_linorder = lexord_sufI[of  _ _  \"{(x, y). x < y}\" _, folded lexordp_conv_lexord]\n  and lexord_take_index_conv_linorder = lexord_take_index_conv[of  _ _  \"{(x, y). x < y}\", folded lexordp_conv_lexord]\n  and mismatch_lexord_linorder = mismatch_lexord[of  _ _  \"{(x, y). x < y}\", folded lexordp_conv_lexord]\n  and lexord_cancel_right_linorder = lexord_cancel_right[of _ _ _ _ \"{(a,b). a < b}\", folded lexordp_conv_lexord]", "lemma LyndonD: \"Lyndon w \\<Longrightarrow> 0 < n \\<Longrightarrow> n < \\<^bold>|w\\<^bold>| \\<Longrightarrow> w <lex rotate n w\"", "lemma LyndonD_nemp: \"Lyndon w \\<Longrightarrow> w \\<noteq> \\<epsilon>\"", "lemma LyndonI: \"w \\<noteq> \\<epsilon> \\<Longrightarrow> \\<forall> n. 0 < n \\<and> n < \\<^bold>|w\\<^bold>| \\<longrightarrow> w <lex rotate n w \\<Longrightarrow>  Lyndon w\"", "lemma Lyndon_sing: \"Lyndon [a]\"", "lemma Lyndon_prim: assumes \"Lyndon w\"\n  shows \"primitive w\"", "lemma Lyndon_conj_greater: \"Lyndon (u\\<cdot>v) \\<Longrightarrow> u \\<noteq> \\<epsilon> \\<Longrightarrow> v \\<noteq> \\<epsilon> \\<Longrightarrow> u\\<cdot>v <lex v\\<cdot>u\"", "lemma Lyndon_rec_all: assumes \"Lyndon_rec (a # w) (\\<^bold>|w\\<^bold>|)\"\n  shows \"n < \\<^bold>|a#w\\<^bold>| \\<Longrightarrow> 0 < n \\<Longrightarrow> Lyndon_rec (a#w) n\"", "lemma Lyndon_Lyndon_rec: assumes \"Lyndon w\"\n  shows \"0 < n \\<Longrightarrow> n < \\<^bold>|w\\<^bold>| \\<Longrightarrow> Lyndon_rec w n\"", "lemma Lyndon_code [code]:\n    \"Lyndon Nil = False\" \n    \"Lyndon (a # w) = Lyndon_rec (a # w) (\\<^bold>|w\\<^bold>|)\"", "theorem Lyndon_unbordered: assumes \"Lyndon w\" shows \"\\<not> bordered w\"", "lemma conjug_Lyndon_ex: assumes \"primitive w\"\n  obtains n where \"Lyndon (rotate n w)\"", "lemma conjug_Lyndon_ex': assumes \"primitive w\"\n  obtains v where \"w \\<sim> v\" and \"Lyndon v\"", "lemma Lyndon_suf_less: assumes \"Lyndon w\" \"s \\<le>ns w\" \"s \\<noteq> w\"\n  shows \"w <lex s\"", "lemma Lyndon_pref_suf_less:  assumes \"Lyndon w\" \"p \\<le>p w\" \"s \\<le>ns w\" \"s \\<noteq> w\"\n  shows \"p <lex s\"", "lemma suf_less_Lyndon: assumes \"w \\<noteq> \\<epsilon>\" and \"\\<forall>s. (s \\<le>ns w \\<longrightarrow> s \\<noteq> w \\<longrightarrow> w <lex s)\"\n  shows \"Lyndon w\"", "lemma Lyndon_suf_le: \"Lyndon w \\<Longrightarrow> s \\<le>ns w \\<Longrightarrow> w \\<le>lex s\"", "lemma unbordered_pref_Lyndon: \"Lyndon (u\\<cdot>v) \\<Longrightarrow> u \\<noteq> \\<epsilon> \\<Longrightarrow> \\<not> bordered u \\<Longrightarrow> Lyndon u\"", "theorem Lyndon_concat: assumes  \"Lyndon u\" and \"Lyndon v\" and \"u <lex v\"\n  shows \"Lyndon (u\\<cdot>v)\"", "lemma longest_Lyndon_suf_ext: \"\\<not> Lyndon (a # w) \\<Longrightarrow> LynSuf w = LynSuf (a # w)\"", "lemma longest_Lyndon_suf_suf: \"w \\<noteq> \\<epsilon> \\<Longrightarrow> LynSuf w \\<le>s w\"", "lemma longest_Lyndon_suf_max: \n  \"v \\<le>s w  \\<Longrightarrow> Lyndon v \\<Longrightarrow> v \\<le>s (LynSuf w)\"", "lemma longest_Lyndon_suf_Lyndon_id: assumes \"Lyndon w\" \n  shows \"LynSuf w = w\"", "lemma longest_Lyndon_suf_longest: \"w \\<noteq> \\<epsilon> \\<Longrightarrow> v' \\<le>s w \\<Longrightarrow> Lyndon v' \\<Longrightarrow> \\<^bold>|v'\\<^bold>| \\<le> \\<^bold>|(LynSuf w)\\<^bold>|\"", "lemma longest_Lyndon_suf_sing: \"LynSuf [a] = [a]\"", "lemma longest_Lyndon_suf_Lyndon: \"w \\<noteq> \\<epsilon> \\<Longrightarrow> Lyndon (LynSuf w)\"", "lemma longest_Lyndon_suf_nemp: \"w \\<noteq> \\<epsilon> \\<Longrightarrow> LynSuf w \\<noteq> \\<epsilon>\"", "lemma longest_Lyndon_sufI:\n  assumes \"q \\<le>s w\" and \"Lyndon q\" and all_s: \"(\\<forall> s. (s \\<le>s w \\<and> Lyndon s) \\<longrightarrow> s \\<le>s q)\" \n  shows \"LynSuf w = q\"", "lemma longest_Lyndon_suf_shorter: assumes \"w \\<noteq> \\<epsilon>\" \n  shows \"\\<^bold>|w\\<^sup><\\<inverse>(LynSuf w)\\<^bold>| < \\<^bold>|w\\<^bold>|\"", "lemma Lyndon_fac_simp: \"w \\<noteq> \\<epsilon> \\<Longrightarrow> Lyndon_fac w =  Lyndon_fac (w\\<^sup><\\<inverse>LynSuf w) \\<cdot> (LynSuf w # \\<epsilon>)\"", "lemma Lyndon_fac_emp: \"Lyndon_fac \\<epsilon> = \\<epsilon>\"", "lemma Lyndon_fac_longest_Lyndon_id: \"Lyndon w \\<Longrightarrow> Lyndon_fac w = [w]\"", "lemma Lyndon_fac_set: \"z \\<in> set (Lyndon_fac w) \\<Longrightarrow> Lyndon z\"", "lemma Lyndon_fac_longest_dec: \"concat (Lyndon_fac w) = w\"", "lemma Lyndon_fac_longest_pref: \"us \\<le>p Lyndon_fac w \\<Longrightarrow> Lyndon_fac (concat us) = us\"", "lemma Lyndon_mono_set: \"Lyndon_mono ws \\<Longrightarrow> u \\<in> set ws \\<Longrightarrow> Lyndon u\"", "lemma Lyndon_mono_sorted: \"Lyndon_mono ws \\<Longrightarrow> rlex.sorted (rev ws)\"", "lemma Lyndon_mono_nth: \"Lyndon_mono ws \\<Longrightarrow> i \\<le> j \\<Longrightarrow> j < \\<^bold>|ws\\<^bold>| \\<Longrightarrow> ws!j \\<le>lex ws!i\"", "lemma Lyndon_mono_empty[simp]: \"Lyndon_mono \\<epsilon>\"", "lemma Lyndon_mono_sing: \"Lyndon u \\<Longrightarrow> Lyndon_mono [u]\"", "lemma Lyndon_mono_fac_Lyndon_mono: \n  assumes \"ps \\<le>f ws\" and \"Lyndon_mono ws\" shows \"Lyndon_mono ps\"", "theorem fac_Lyndon_mono: \"Lyndon_mono (Lyndon_fac w)\"", "lemma Lyndon_mono_last_smallest: \"Lyndon_mono ws \\<Longrightarrow>s \\<le>ns (concat ws) \\<Longrightarrow> last ws \\<le>lex s\"", "lemma Lyndon_mono_last_longest: assumes \"ws \\<noteq> \\<epsilon>\" and \"Lyndon_mono ws\" \n  shows \"LynSuf (concat ws) = last ws\"", "lemma Lyndon_mono_fac:\n  \"Lyndon_mono ws \\<Longrightarrow> ws = Lyndon_fac (concat ws)\"", "lemma Lyndon_std: assumes \"Lyndon w\" \"1 < \\<^bold>|w\\<^bold>|\"\n  obtains l m where \"w = l\\<cdot>m\" and \"Lyndon l\" and \"Lyndon m\" and \"l <lex m\""], "translations": [["", "lemma (in linorder) lexordp_mid_pref: \"ord_class.lexordp u v \\<Longrightarrow> ord_class.lexordp v (u\\<cdot>s) \\<Longrightarrow>\n   u \\<le>p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ord_class.lexordp u v;\n     ord_class.lexordp v (u \\<cdot> s)\\<rbrakk>\n    \\<Longrightarrow> u \\<le>p v", "by (induct rule: lexordp_induct, simp_all)"], ["", "lemma (in linorder) lexordp_ext: \"ord_class.lexordp u v \\<Longrightarrow>  \\<not> u \\<le>p v \\<Longrightarrow> \n  ord_class.lexordp (u\\<cdot>w) (v\\<cdot>z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ord_class.lexordp u v; \\<not> u \\<le>p v\\<rbrakk>\n    \\<Longrightarrow> ord_class.lexordp (u \\<cdot> w) (v \\<cdot> z)", "by (induct rule: lexordp_induct, simp_all)"], ["", "lemmas [code] = lexordp_simps"], ["", "context linorder\nbegin"], ["", "abbreviation Lyndon_less :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> bool\" (infixl \"<lex\" 50)\n  where \"Lyndon_less xs ys \\<equiv> ord_class.lexordp xs ys\""], ["", "abbreviation Lyndon_le :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> bool\" (infixl \"\\<le>lex\" 50)\n  where \"Lyndon_le xs ys \\<equiv> ord_class.lexordp_eq xs ys\""], ["", "interpretation rlex: linorder \"(\\<le>lex)\" \"(<lex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linorder (\\<le>lex) (<lex)", "using lexordp_linorder"], ["proof (prove)\nusing this:\n  class.linorder lexordp_eq ord_class.lexordp\n\ngoal (1 subgoal):\n 1. class.linorder (\\<le>lex) (<lex)", "."], ["", "interpretation dual_rlex: linorder \"\\<lambda> x y. y \\<le>lex x\" \"\\<lambda> x y. y <lex x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linorder (\\<lambda>x y. y \\<le>lex x) (\\<lambda>x y. y <lex x)", "using rlex.dual_linorder"], ["proof (prove)\nusing this:\n  class.linorder (\\<lambda>x y. y \\<le>lex x) (\\<lambda>x y. y <lex x)\n\ngoal (1 subgoal):\n 1. class.linorder (\\<lambda>x y. y \\<le>lex x) (\\<lambda>x y. y <lex x)", "."], ["", "lemma sorted_dual_rev_iff: \"dual_rlex.sorted ws \\<longleftrightarrow> rlex.sorted (rev ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder.sorted (\\<lambda>x y. y \\<le>lex x) ws =\n    linorder.sorted (\\<le>lex) (rev ws)", "unfolding rlex.sorted_rev_iff_nth_mono dual_rlex.sorted_iff_nth_mono"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i j.\n        i \\<le> j \\<longrightarrow>\n        j < \\<^bold>|ws\\<^bold>| \\<longrightarrow> ws ! j \\<le>lex ws ! i) =\n    (\\<forall>i j.\n        i \\<le> j \\<longrightarrow>\n        j < \\<^bold>|ws\\<^bold>| \\<longrightarrow> ws ! j \\<le>lex ws ! i)", "by blast"], ["", "text \\<open>Several useful lemmas that are formulated for relations, interpreted for the default linear order.\\<close>"], ["", "lemmas lexord_suf_linorder = lexord_sufE[of _ _ _ _ \"{(x, y). x < y}\", folded lexordp_conv_lexord]\n  and lexord_append_leftI_linorder = lexord_append_leftI[of  _ _  \"{(x, y). x < y}\" _, folded lexordp_conv_lexord]\n  and lexord_app_right_linorder = lexord_sufI[of  _ _  \"{(x, y). x < y}\" _, folded lexordp_conv_lexord]\n  and lexord_take_index_conv_linorder = lexord_take_index_conv[of  _ _  \"{(x, y). x < y}\", folded lexordp_conv_lexord]\n  and mismatch_lexord_linorder = mismatch_lexord[of  _ _  \"{(x, y). x < y}\", folded lexordp_conv_lexord]\n  and lexord_cancel_right_linorder = lexord_cancel_right[of _ _ _ _ \"{(a,b). a < b}\", folded lexordp_conv_lexord]"], ["", "subsection \"Lyndon word definition\""], ["", "fun Lyndon :: \"'a list \\<Rightarrow> bool\"\n  where \"Lyndon w = (w \\<noteq> \\<epsilon> \\<and> (\\<forall>n. 0 < n \\<and> n < \\<^bold>|w\\<^bold>| \\<longrightarrow> w <lex rotate n w))\""], ["", "lemma LyndonD: \"Lyndon w \\<Longrightarrow> 0 < n \\<Longrightarrow> n < \\<^bold>|w\\<^bold>| \\<Longrightarrow> w <lex rotate n w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Lyndon w; 0 < n; n < \\<^bold>|w\\<^bold>|\\<rbrakk>\n    \\<Longrightarrow> w <lex rotate n w", "unfolding Lyndon.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> \\<epsilon> \\<and>\n             (\\<forall>n.\n                 0 < n \\<and> n < \\<^bold>|w\\<^bold>| \\<longrightarrow>\n                 w <lex rotate n w);\n     0 < n; n < \\<^bold>|w\\<^bold>|\\<rbrakk>\n    \\<Longrightarrow> w <lex rotate n w", "by blast"], ["", "lemma LyndonD_nemp: \"Lyndon w \\<Longrightarrow> w \\<noteq> \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon w \\<Longrightarrow> w \\<noteq> \\<epsilon>", "unfolding Lyndon.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<noteq> \\<epsilon> \\<and>\n    (\\<forall>n.\n        0 < n \\<and> n < \\<^bold>|w\\<^bold>| \\<longrightarrow>\n        w <lex rotate n w) \\<Longrightarrow>\n    w \\<noteq> \\<epsilon>", "by blast"], ["", "lemma LyndonI: \"w \\<noteq> \\<epsilon> \\<Longrightarrow> \\<forall> n. 0 < n \\<and> n < \\<^bold>|w\\<^bold>| \\<longrightarrow> w <lex rotate n w \\<Longrightarrow>  Lyndon w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> \\<epsilon>;\n     \\<forall>n.\n        0 < n \\<and> n < \\<^bold>|w\\<^bold>| \\<longrightarrow>\n        w <lex rotate n w\\<rbrakk>\n    \\<Longrightarrow> Lyndon w", "unfolding  Lyndon.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> \\<epsilon>;\n     \\<forall>n.\n        0 < n \\<and> n < \\<^bold>|w\\<^bold>| \\<longrightarrow>\n        w <lex rotate n w\\<rbrakk>\n    \\<Longrightarrow> w \\<noteq> \\<epsilon> \\<and>\n                      (\\<forall>n.\n                          0 < n \\<and>\n                          n < \\<^bold>|w\\<^bold>| \\<longrightarrow>\n                          w <lex rotate n w)", "by blast"], ["", "lemma Lyndon_sing: \"Lyndon [a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon [a]", "unfolding Lyndon.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. [a] \\<noteq> \\<epsilon> \\<and>\n    (\\<forall>n.\n        0 < n \\<and> n < \\<^bold>|[a]\\<^bold>| \\<longrightarrow>\n        [a] <lex rotate n [a])", "by auto"], ["", "lemma Lyndon_prim: assumes \"Lyndon w\"\n  shows \"primitive w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primitive w", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. primitive w", "have \"0 < n \\<Longrightarrow> n < \\<^bold>|w\\<^bold>| \\<Longrightarrow> rotate n w \\<noteq> w\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; n < \\<^bold>|w\\<^bold>|\\<rbrakk>\n    \\<Longrightarrow> rotate n w \\<noteq> w", "using LyndonD[OF \\<open>Lyndon w\\<close>, of n] rlex.less_irrefl[of w]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < n; n < \\<^bold>|w\\<^bold>|\\<rbrakk>\n  \\<Longrightarrow> w <lex rotate n w\n  \\<not> w <lex w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; n < \\<^bold>|w\\<^bold>|\\<rbrakk>\n    \\<Longrightarrow> rotate n w \\<noteq> w", "by argo"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?n1; ?n1 < \\<^bold>|w\\<^bold>|\\<rbrakk>\n  \\<Longrightarrow> rotate ?n1 w \\<noteq> w\n\ngoal (1 subgoal):\n 1. primitive w", "from no_rotate_prim[OF LyndonD_nemp[OF \\<open>Lyndon w\\<close>]] this"], ["proof (chain)\npicking this:\n  (\\<And>n.\n      \\<lbrakk>0 < n; n < \\<^bold>|w\\<^bold>|\\<rbrakk>\n      \\<Longrightarrow> rotate n w \\<noteq> w) \\<Longrightarrow>\n  primitive w\n  \\<lbrakk>0 < ?n1; ?n1 < \\<^bold>|w\\<^bold>|\\<rbrakk>\n  \\<Longrightarrow> rotate ?n1 w \\<noteq> w", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>n.\n      \\<lbrakk>0 < n; n < \\<^bold>|w\\<^bold>|\\<rbrakk>\n      \\<Longrightarrow> rotate n w \\<noteq> w) \\<Longrightarrow>\n  primitive w\n  \\<lbrakk>0 < ?n1; ?n1 < \\<^bold>|w\\<^bold>|\\<rbrakk>\n  \\<Longrightarrow> rotate ?n1 w \\<noteq> w\n\ngoal (1 subgoal):\n 1. primitive w", "by blast"], ["proof (state)\nthis:\n  primitive w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Lyndon_conj_greater: \"Lyndon (u\\<cdot>v) \\<Longrightarrow> u \\<noteq> \\<epsilon> \\<Longrightarrow> v \\<noteq> \\<epsilon> \\<Longrightarrow> u\\<cdot>v <lex v\\<cdot>u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Lyndon (u \\<cdot> v); u \\<noteq> \\<epsilon>;\n     v \\<noteq> \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> u \\<cdot> v <lex v \\<cdot> u", "using LyndonD[of \"u\\<cdot>v\" \"\\<^bold>|u\\<^bold>|\", unfolded rotate_append[of u v]]"], ["proof (prove)\nusing this:\n  \\<lbrakk>Lyndon (u \\<cdot> v); 0 < \\<^bold>|u\\<^bold>|;\n   \\<^bold>|u\\<^bold>| < \\<^bold>|u \\<cdot> v\\<^bold>|\\<rbrakk>\n  \\<Longrightarrow> u \\<cdot> v <lex v \\<cdot> u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Lyndon (u \\<cdot> v); u \\<noteq> \\<epsilon>;\n     v \\<noteq> \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> u \\<cdot> v <lex v \\<cdot> u", "by force"], ["", "subsection \"Code equations for Lyndon words\""], ["", "primrec Lyndon_rec :: \"'a list \\<Rightarrow> nat \\<Rightarrow> bool\" where\n    \"Lyndon_rec w 0 = True\" |\n    \"Lyndon_rec w (Suc n) = (if w <lex rotate (Suc n) w then Lyndon_rec w n else False)\""], ["", "lemma Lyndon_rec_all: assumes \"Lyndon_rec (a # w) (\\<^bold>|w\\<^bold>|)\"\n  shows \"n < \\<^bold>|a#w\\<^bold>| \\<Longrightarrow> 0 < n \\<Longrightarrow> Lyndon_rec (a#w) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < \\<^bold>|a # w\\<^bold>|; 0 < n\\<rbrakk>\n    \\<Longrightarrow> Lyndon_rec (a # w) n", "proof(induction n rule: strict_inc_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<^bold>|a # w\\<^bold>| = Suc i; 0 < i\\<rbrakk>\n       \\<Longrightarrow> Lyndon_rec (a # w) i\n 2. \\<And>i.\n       \\<lbrakk>i < \\<^bold>|a # w\\<^bold>|;\n        0 < Suc i \\<Longrightarrow> Lyndon_rec (a # w) (Suc i);\n        0 < i\\<rbrakk>\n       \\<Longrightarrow> Lyndon_rec (a # w) i", "case (base i)"], ["proof (state)\nthis:\n  \\<^bold>|a # w\\<^bold>| = Suc i\n  0 < i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<^bold>|a # w\\<^bold>| = Suc i; 0 < i\\<rbrakk>\n       \\<Longrightarrow> Lyndon_rec (a # w) i\n 2. \\<And>i.\n       \\<lbrakk>i < \\<^bold>|a # w\\<^bold>|;\n        0 < Suc i \\<Longrightarrow> Lyndon_rec (a # w) (Suc i);\n        0 < i\\<rbrakk>\n       \\<Longrightarrow> Lyndon_rec (a # w) i", "then"], ["proof (chain)\npicking this:\n  \\<^bold>|a # w\\<^bold>| = Suc i\n  0 < i", "show ?case"], ["proof (prove)\nusing this:\n  \\<^bold>|a # w\\<^bold>| = Suc i\n  0 < i\n\ngoal (1 subgoal):\n 1. Lyndon_rec (a # w) i", "using assms"], ["proof (prove)\nusing this:\n  \\<^bold>|a # w\\<^bold>| = Suc i\n  0 < i\n  Lyndon_rec (a # w) \\<^bold>|w\\<^bold>|\n\ngoal (1 subgoal):\n 1. Lyndon_rec (a # w) i", "by auto"], ["proof (state)\nthis:\n  Lyndon_rec (a # w) i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < \\<^bold>|a # w\\<^bold>|;\n        0 < Suc i \\<Longrightarrow> Lyndon_rec (a # w) (Suc i);\n        0 < i\\<rbrakk>\n       \\<Longrightarrow> Lyndon_rec (a # w) i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < \\<^bold>|a # w\\<^bold>|;\n        0 < Suc i \\<Longrightarrow> Lyndon_rec (a # w) (Suc i);\n        0 < i\\<rbrakk>\n       \\<Longrightarrow> Lyndon_rec (a # w) i", "case (step i)"], ["proof (state)\nthis:\n  i < \\<^bold>|a # w\\<^bold>|\n  0 < Suc i \\<Longrightarrow> Lyndon_rec (a # w) (Suc i)\n  0 < i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < \\<^bold>|a # w\\<^bold>|;\n        0 < Suc i \\<Longrightarrow> Lyndon_rec (a # w) (Suc i);\n        0 < i\\<rbrakk>\n       \\<Longrightarrow> Lyndon_rec (a # w) i", "then"], ["proof (chain)\npicking this:\n  i < \\<^bold>|a # w\\<^bold>|\n  0 < Suc i \\<Longrightarrow> Lyndon_rec (a # w) (Suc i)\n  0 < i", "show ?case"], ["proof (prove)\nusing this:\n  i < \\<^bold>|a # w\\<^bold>|\n  0 < Suc i \\<Longrightarrow> Lyndon_rec (a # w) (Suc i)\n  0 < i\n\ngoal (1 subgoal):\n 1. Lyndon_rec (a # w) i", "by (meson Lyndon_rec.simps(2) zero_less_Suc)"], ["proof (state)\nthis:\n  Lyndon_rec (a # w) i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Lyndon_Lyndon_rec: assumes \"Lyndon w\"\n  shows \"0 < n \\<Longrightarrow> n < \\<^bold>|w\\<^bold>| \\<Longrightarrow> Lyndon_rec w n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; n < \\<^bold>|w\\<^bold>|\\<rbrakk>\n    \\<Longrightarrow> Lyndon_rec w n", "proof(induction n, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>0 < n; n < \\<^bold>|w\\<^bold>|\\<rbrakk>\n                \\<Longrightarrow> Lyndon_rec w n;\n        0 < Suc n; Suc n < \\<^bold>|w\\<^bold>|\\<rbrakk>\n       \\<Longrightarrow> Lyndon_rec w (Suc n)", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>0 < n; n < \\<^bold>|w\\<^bold>|\\<rbrakk>\n  \\<Longrightarrow> Lyndon_rec w n\n  0 < Suc n\n  Suc n < \\<^bold>|w\\<^bold>|\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>0 < n; n < \\<^bold>|w\\<^bold>|\\<rbrakk>\n                \\<Longrightarrow> Lyndon_rec w n;\n        0 < Suc n; Suc n < \\<^bold>|w\\<^bold>|\\<rbrakk>\n       \\<Longrightarrow> Lyndon_rec w (Suc n)", "have \"w <lex rotate (Suc n) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w <lex rotate (Suc n) w", "using LyndonD Suc.prems(2) assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>Lyndon ?w; 0 < ?n; ?n < \\<^bold>|?w\\<^bold>|\\<rbrakk>\n  \\<Longrightarrow> ?w <lex rotate ?n ?w\n  Suc n < \\<^bold>|w\\<^bold>|\n  Lyndon w\n\ngoal (1 subgoal):\n 1. w <lex rotate (Suc n) w", "by blast"], ["proof (state)\nthis:\n  w <lex rotate (Suc n) w\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>0 < n; n < \\<^bold>|w\\<^bold>|\\<rbrakk>\n                \\<Longrightarrow> Lyndon_rec w n;\n        0 < Suc n; Suc n < \\<^bold>|w\\<^bold>|\\<rbrakk>\n       \\<Longrightarrow> Lyndon_rec w (Suc n)", "then"], ["proof (chain)\npicking this:\n  w <lex rotate (Suc n) w", "show ?case"], ["proof (prove)\nusing this:\n  w <lex rotate (Suc n) w\n\ngoal (1 subgoal):\n 1. Lyndon_rec w (Suc n)", "using Suc.IH[OF _ Suc_lessD[OF \\<open>Suc n < \\<^bold>|w\\<^bold>|\\<close>], folded neq0_conv] Lyndon_rec.simps(1)[of w]"], ["proof (prove)\nusing this:\n  w <lex rotate (Suc n) w\n  n \\<noteq> 0 \\<Longrightarrow> Lyndon_rec w n\n  Lyndon_rec w 0 = True\n\ngoal (1 subgoal):\n 1. Lyndon_rec w (Suc n)", "unfolding Lyndon_rec.simps(2)"], ["proof (prove)\nusing this:\n  w <lex rotate (Suc n) w\n  n \\<noteq> 0 \\<Longrightarrow> Lyndon_rec w n\n  Lyndon_rec w 0 = True\n\ngoal (1 subgoal):\n 1. if w <lex rotate (Suc n) w then Lyndon_rec w n else False", "by metis"], ["proof (state)\nthis:\n  Lyndon_rec w (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Lyndon_code [code]:\n    \"Lyndon Nil = False\" \n    \"Lyndon (a # w) = Lyndon_rec (a # w) (\\<^bold>|w\\<^bold>|)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon \\<epsilon> = False &&&\n    Lyndon (a # w) = Lyndon_rec (a # w) \\<^bold>|w\\<^bold>|", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. Lyndon \\<epsilon> = False\n 2. Lyndon (a # w) = Lyndon_rec (a # w) \\<^bold>|w\\<^bold>|", "show \"Lyndon Nil = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon \\<epsilon> = False", "by simp"], ["proof (state)\nthis:\n  Lyndon \\<epsilon> = False\n\ngoal (1 subgoal):\n 1. Lyndon (a # w) = Lyndon_rec (a # w) \\<^bold>|w\\<^bold>|", "have \"a # w \\<noteq> \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a # w \\<noteq> \\<epsilon>", "by simp"], ["proof (state)\nthis:\n  a # w \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. Lyndon (a # w) = Lyndon_rec (a # w) \\<^bold>|w\\<^bold>|", "have ax: \"0 < n \\<Longrightarrow> Lyndon_rec (a#w) n \\<Longrightarrow> (a#w) <lex rotate n (a#w)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; Lyndon_rec (a # w) n\\<rbrakk>\n    \\<Longrightarrow> a # w <lex rotate n (a # w)", "using Lyndon_rec.simps(2)[of \"a#w\"] gr0_implies_Suc[of n]"], ["proof (prove)\nusing this:\n  Lyndon_rec (a # w) (Suc ?n) =\n  (if a # w <lex rotate (Suc ?n) (a # w) then Lyndon_rec (a # w) ?n\n   else False)\n  0 < n \\<Longrightarrow> \\<exists>m. n = Suc m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; Lyndon_rec (a # w) n\\<rbrakk>\n    \\<Longrightarrow> a # w <lex rotate n (a # w)", "by metis"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?n1; Lyndon_rec (a # w) ?n1\\<rbrakk>\n  \\<Longrightarrow> a # w <lex rotate ?n1 (a # w)\n\ngoal (1 subgoal):\n 1. Lyndon (a # w) = Lyndon_rec (a # w) \\<^bold>|w\\<^bold>|", "have bx: \"Lyndon_rec (a # w) (\\<^bold>|w\\<^bold>|) = (\\<forall>n. n < \\<^bold>|a#w\\<^bold>| \\<and> 0 < n \\<longrightarrow> Lyndon_rec (a#w) n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon_rec (a # w) \\<^bold>|w\\<^bold>| =\n    (\\<forall>n.\n        n < \\<^bold>|a # w\\<^bold>| \\<and> 0 < n \\<longrightarrow>\n        Lyndon_rec (a # w) n)", "proof(cases \"w = \\<epsilon>\", simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> \\<epsilon> \\<Longrightarrow>\n    Lyndon_rec (a # w) \\<^bold>|w\\<^bold>| =\n    (\\<forall>n.\n        n < \\<^bold>|a # w\\<^bold>| \\<and> 0 < n \\<longrightarrow>\n        Lyndon_rec (a # w) n)", "assume \"w \\<noteq> \\<epsilon>\""], ["proof (state)\nthis:\n  w \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. w \\<noteq> \\<epsilon> \\<Longrightarrow>\n    Lyndon_rec (a # w) \\<^bold>|w\\<^bold>| =\n    (\\<forall>n.\n        n < \\<^bold>|a # w\\<^bold>| \\<and> 0 < n \\<longrightarrow>\n        Lyndon_rec (a # w) n)", "from this[folded length_greater_0_conv]"], ["proof (chain)\npicking this:\n  0 < \\<^bold>|w\\<^bold>|", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < \\<^bold>|w\\<^bold>|\n\ngoal (1 subgoal):\n 1. Lyndon_rec (a # w) \\<^bold>|w\\<^bold>| =\n    (\\<forall>n.\n        n < \\<^bold>|a # w\\<^bold>| \\<and> 0 < n \\<longrightarrow>\n        Lyndon_rec (a # w) n)", "using Lyndon_rec_all[of a w] length_Cons[of a w] lessI[of \"\\<^bold>|w\\<^bold>|\"]"], ["proof (prove)\nusing this:\n  0 < \\<^bold>|w\\<^bold>|\n  \\<lbrakk>Lyndon_rec (a # w) \\<^bold>|w\\<^bold>|;\n   ?n < \\<^bold>|a # w\\<^bold>|; 0 < ?n\\<rbrakk>\n  \\<Longrightarrow> Lyndon_rec (a # w) ?n\n  \\<^bold>|a # w\\<^bold>| = Suc \\<^bold>|w\\<^bold>|\n  \\<^bold>|w\\<^bold>| < Suc \\<^bold>|w\\<^bold>|\n\ngoal (1 subgoal):\n 1. Lyndon_rec (a # w) \\<^bold>|w\\<^bold>| =\n    (\\<forall>n.\n        n < \\<^bold>|a # w\\<^bold>| \\<and> 0 < n \\<longrightarrow>\n        Lyndon_rec (a # w) n)", "by fastforce"], ["proof (state)\nthis:\n  Lyndon_rec (a # w) \\<^bold>|w\\<^bold>| =\n  (\\<forall>n.\n      n < \\<^bold>|a # w\\<^bold>| \\<and> 0 < n \\<longrightarrow>\n      Lyndon_rec (a # w) n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Lyndon_rec (a # w) \\<^bold>|w\\<^bold>| =\n  (\\<forall>n.\n      n < \\<^bold>|a # w\\<^bold>| \\<and> 0 < n \\<longrightarrow>\n      Lyndon_rec (a # w) n)\n\ngoal (1 subgoal):\n 1. Lyndon (a # w) = Lyndon_rec (a # w) \\<^bold>|w\\<^bold>|", "show \"Lyndon (a # w) = Lyndon_rec (a # w) \\<^bold>|w\\<^bold>|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon (a # w) = Lyndon_rec (a # w) \\<^bold>|w\\<^bold>|", "unfolding bx Lyndon.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (a # w \\<noteq> \\<epsilon> \\<and>\n     (\\<forall>n.\n         0 < n \\<and> n < \\<^bold>|a # w\\<^bold>| \\<longrightarrow>\n         a # w <lex rotate n (a # w))) =\n    (\\<forall>n.\n        n < \\<^bold>|a # w\\<^bold>| \\<and> 0 < n \\<longrightarrow>\n        Lyndon_rec (a # w) n)", "using ax  LyndonI[OF \\<open>a # w \\<noteq> \\<epsilon>\\<close>]Lyndon_Lyndon_rec"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?n1; Lyndon_rec (a # w) ?n1\\<rbrakk>\n  \\<Longrightarrow> a # w <lex rotate ?n1 (a # w)\n  \\<forall>n.\n     0 < n \\<and> n < \\<^bold>|a # w\\<^bold>| \\<longrightarrow>\n     a # w <lex rotate n (a # w) \\<Longrightarrow>\n  Lyndon (a # w)\n  \\<lbrakk>Lyndon ?w; 0 < ?n; ?n < \\<^bold>|?w\\<^bold>|\\<rbrakk>\n  \\<Longrightarrow> Lyndon_rec ?w ?n\n\ngoal (1 subgoal):\n 1. (a # w \\<noteq> \\<epsilon> \\<and>\n     (\\<forall>n.\n         0 < n \\<and> n < \\<^bold>|a # w\\<^bold>| \\<longrightarrow>\n         a # w <lex rotate n (a # w))) =\n    (\\<forall>n.\n        n < \\<^bold>|a # w\\<^bold>| \\<and> 0 < n \\<longrightarrow>\n        Lyndon_rec (a # w) n)", "by blast"], ["proof (state)\nthis:\n  Lyndon (a # w) = Lyndon_rec (a # w) \\<^bold>|w\\<^bold>|\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Properties of Lyndon words\""], ["", "subsubsection \"Lyndon words are unbordered\""], ["", "theorem Lyndon_unbordered: assumes \"Lyndon w\" shows \"\\<not> bordered w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> bordered w", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. bordered w \\<Longrightarrow> False", "assume \"bordered w\""], ["proof (state)\nthis:\n  bordered w\n\ngoal (1 subgoal):\n 1. bordered w \\<Longrightarrow> False", "from bordered_dec[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>u v.\n      \\<lbrakk>u \\<cdot> v \\<cdot> u = w; u \\<noteq> \\<epsilon>\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain u v where \"u\\<cdot>v\\<cdot>u = w\" and \"u \\<noteq> \\<epsilon>\""], ["proof (prove)\nusing this:\n  (\\<And>u v.\n      \\<lbrakk>u \\<cdot> v \\<cdot> u = w; u \\<noteq> \\<epsilon>\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<cdot> v \\<cdot> u = w; u \\<noteq> \\<epsilon>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  u \\<cdot> v \\<cdot> u = w\n  u \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. bordered w \\<Longrightarrow> False", "hence \"v \\<cdot> u \\<noteq> \\<epsilon>\" and \"u \\<cdot> v \\<noteq> \\<epsilon>\""], ["proof (prove)\nusing this:\n  u \\<cdot> v \\<cdot> u = w\n  u \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. v \\<cdot> u \\<noteq> \\<epsilon> &&& u \\<cdot> v \\<noteq> \\<epsilon>", "by blast+"], ["proof (state)\nthis:\n  v \\<cdot> u \\<noteq> \\<epsilon>\n  u \\<cdot> v \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. bordered w \\<Longrightarrow> False", "note lyn = \\<open>Lyndon w\\<close>[folded  \\<open>u\\<cdot>v\\<cdot>u = w\\<close>]"], ["proof (state)\nthis:\n  Lyndon (u \\<cdot> v \\<cdot> u)\n\ngoal (1 subgoal):\n 1. bordered w \\<Longrightarrow> False", "have \"u\\<cdot>v\\<cdot>u <lex v\\<cdot>u\\<cdot>u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<cdot> v \\<cdot> u <lex v \\<cdot> u \\<cdot> u", "using Lyndon_conj_greater[of u \"v\\<cdot>u\", OF lyn \\<open>u \\<noteq> \\<epsilon>\\<close> \\<open>v \\<cdot> u \\<noteq> \\<epsilon>\\<close>, unfolded rassoc]"], ["proof (prove)\nusing this:\n  u \\<cdot> v \\<cdot> u <lex v \\<cdot> u \\<cdot> u\n\ngoal (1 subgoal):\n 1. u \\<cdot> v \\<cdot> u <lex v \\<cdot> u \\<cdot> u", "."], ["proof (state)\nthis:\n  u \\<cdot> v \\<cdot> u <lex v \\<cdot> u \\<cdot> u\n\ngoal (1 subgoal):\n 1. bordered w \\<Longrightarrow> False", "from this[unfolded lassoc]"], ["proof (chain)\npicking this:\n  (u \\<cdot> v) \\<cdot> u <lex (v \\<cdot> u) \\<cdot> u", "have \"u \\<cdot> v \\<noteq> v \\<cdot> u\""], ["proof (prove)\nusing this:\n  (u \\<cdot> v) \\<cdot> u <lex (v \\<cdot> u) \\<cdot> u\n\ngoal (1 subgoal):\n 1. u \\<cdot> v \\<noteq> v \\<cdot> u", "by force"], ["proof (state)\nthis:\n  u \\<cdot> v \\<noteq> v \\<cdot> u\n\ngoal (1 subgoal):\n 1. bordered w \\<Longrightarrow> False", "from lexord_suf_linorder[OF _ this, of u u]"], ["proof (chain)\npicking this:\n  \\<lbrakk>(u \\<cdot> v) \\<cdot> u <lex (v \\<cdot> u) \\<cdot> u;\n   \\<^bold>|u \\<cdot> v\\<^bold>| = \\<^bold>|v \\<cdot> u\\<^bold>|;\n   \\<^bold>|u\\<^bold>| = \\<^bold>|u\\<^bold>|\\<rbrakk>\n  \\<Longrightarrow> u \\<cdot> v <lex v \\<cdot> u", "have \"u\\<cdot>v <lex v\\<cdot>u\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(u \\<cdot> v) \\<cdot> u <lex (v \\<cdot> u) \\<cdot> u;\n   \\<^bold>|u \\<cdot> v\\<^bold>| = \\<^bold>|v \\<cdot> u\\<^bold>|;\n   \\<^bold>|u\\<^bold>| = \\<^bold>|u\\<^bold>|\\<rbrakk>\n  \\<Longrightarrow> u \\<cdot> v <lex v \\<cdot> u\n\ngoal (1 subgoal):\n 1. u \\<cdot> v <lex v \\<cdot> u", "using  \\<open>u\\<cdot>v\\<cdot>u <lex v\\<cdot>u\\<cdot>u\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>(u \\<cdot> v) \\<cdot> u <lex (v \\<cdot> u) \\<cdot> u;\n   \\<^bold>|u \\<cdot> v\\<^bold>| = \\<^bold>|v \\<cdot> u\\<^bold>|;\n   \\<^bold>|u\\<^bold>| = \\<^bold>|u\\<^bold>|\\<rbrakk>\n  \\<Longrightarrow> u \\<cdot> v <lex v \\<cdot> u\n  u \\<cdot> v \\<cdot> u <lex v \\<cdot> u \\<cdot> u\n\ngoal (1 subgoal):\n 1. u \\<cdot> v <lex v \\<cdot> u", "by simp"], ["proof (state)\nthis:\n  u \\<cdot> v <lex v \\<cdot> u\n\ngoal (1 subgoal):\n 1. bordered w \\<Longrightarrow> False", "from lexord_append_leftI_linorder[of  \"u\\<cdot>v\" \"v\\<cdot>u\", unfolded lassoc, OF this, unfolded rassoc]"], ["proof (chain)\npicking this:\n  ?x \\<cdot> u \\<cdot> v <lex ?x \\<cdot> v \\<cdot> u", "have \"u\\<cdot>u\\<cdot>v <lex u\\<cdot>v\\<cdot>u\""], ["proof (prove)\nusing this:\n  ?x \\<cdot> u \\<cdot> v <lex ?x \\<cdot> v \\<cdot> u\n\ngoal (1 subgoal):\n 1. u \\<cdot> u \\<cdot> v <lex u \\<cdot> v \\<cdot> u", "."], ["proof (state)\nthis:\n  u \\<cdot> u \\<cdot> v <lex u \\<cdot> v \\<cdot> u\n\ngoal (1 subgoal):\n 1. bordered w \\<Longrightarrow> False", "from this Lyndon_conj_greater[of \"u\\<cdot>v\" u, unfolded rassoc, OF lyn \\<open>u \\<cdot> v \\<noteq> \\<epsilon>\\<close>  \\<open>u \\<noteq> \\<epsilon>\\<close>]"], ["proof (chain)\npicking this:\n  u \\<cdot> u \\<cdot> v <lex u \\<cdot> v \\<cdot> u\n  u \\<cdot> v \\<cdot> u <lex u \\<cdot> u \\<cdot> v", "show False"], ["proof (prove)\nusing this:\n  u \\<cdot> u \\<cdot> v <lex u \\<cdot> v \\<cdot> u\n  u \\<cdot> v \\<cdot> u <lex u \\<cdot> u \\<cdot> v\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Each conjugacy class contains a Lyndon word\""], ["", "lemma conjug_Lyndon_ex: assumes \"primitive w\"\n  obtains n where \"Lyndon (rotate n w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        Lyndon (rotate n w) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        Lyndon (rotate n w) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"w \\<noteq> \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<noteq> \\<epsilon>", "using  prim_nemp[OF \\<open>primitive w\\<close>]"], ["proof (prove)\nusing this:\n  w \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. w \\<noteq> \\<epsilon>", "."], ["proof (state)\nthis:\n  w \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        Lyndon (rotate n w) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?ConClass = \"{rotate n w | n. 0 \\<le> n \\<and> n < \\<^bold>|w\\<^bold>|}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        Lyndon (rotate n w) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"?ConClass \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {rotate n w |n. 0 \\<le> n \\<and> n < \\<^bold>|w\\<^bold>|} \\<noteq> {}", "using \\<open>w \\<noteq> \\<epsilon>\\<close>"], ["proof (prove)\nusing this:\n  w \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. {rotate n w |n. 0 \\<le> n \\<and> n < \\<^bold>|w\\<^bold>|} \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  {rotate n w |n. 0 \\<le> n \\<and> n < \\<^bold>|w\\<^bold>|} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        Lyndon (rotate n w) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"w \\<in> ?ConClass\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> {rotate n w |n. 0 \\<le> n \\<and> n < \\<^bold>|w\\<^bold>|}", "using \\<open>w \\<noteq> \\<epsilon>\\<close> id_apply[of w, folded rotate0]"], ["proof (prove)\nusing this:\n  w \\<noteq> \\<epsilon>\n  rotate 0 w = w\n\ngoal (1 subgoal):\n 1. w \\<in> {rotate n w |n. 0 \\<le> n \\<and> n < \\<^bold>|w\\<^bold>|}", "by force"], ["proof (state)\nthis:\n  w \\<in> {rotate n w |n. 0 \\<le> n \\<and> n < \\<^bold>|w\\<^bold>|}\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        Lyndon (rotate n w) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"finite ?ConClass\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {rotate n w |n. 0 \\<le> n \\<and> n < \\<^bold>|w\\<^bold>|}", "by simp"], ["proof (state)\nthis:\n  finite {rotate n w |n. 0 \\<le> n \\<and> n < \\<^bold>|w\\<^bold>|}\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        Lyndon (rotate n w) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have all_rot: \"rotate m w \\<in> ?ConClass\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate m w\n    \\<in> {rotate n w |n. 0 \\<le> n \\<and> n < \\<^bold>|w\\<^bold>|}", "using rotate_conv_mod[of _ w] mod_less_divisor[of \"\\<^bold>|w\\<^bold>|\"] \\<open>w \\<noteq> \\<epsilon>\\<close>"], ["proof (prove)\nusing this:\n  rotate ?n w = rotate (?n mod \\<^bold>|w\\<^bold>|) w\n  0 < \\<^bold>|w\\<^bold>| \\<Longrightarrow>\n  ?m mod \\<^bold>|w\\<^bold>| < \\<^bold>|w\\<^bold>|\n  w \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. rotate m w\n    \\<in> {rotate n w |n. 0 \\<le> n \\<and> n < \\<^bold>|w\\<^bold>|}", "by blast"], ["proof (state)\nthis:\n  rotate ?m1 w\n  \\<in> {rotate n w |n. 0 \\<le> n \\<and> n < \\<^bold>|w\\<^bold>|}\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        Lyndon (rotate n w) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain w' n where \"w' \\<in> ?ConClass\" and all_b: \"\\<forall> b \\<in> ?ConClass. b \\<le>lex w' \\<longrightarrow> w' = b\" and w': \"w' = rotate n w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w' n.\n        \\<lbrakk>w' \\<in> {rotate n w |n.\n                           0 \\<le> n \\<and> n < \\<^bold>|w\\<^bold>|};\n         \\<forall>b\\<in>{rotate n w |n.\n                         0 \\<le> n \\<and> n < \\<^bold>|w\\<^bold>|}.\n            b \\<le>lex w' \\<longrightarrow> w' = b;\n         w' = rotate n w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rlex.finite_has_minimal[OF \\<open>finite ?ConClass\\<close> \\<open>?ConClass \\<noteq> {}\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>m\\<in>{rotate n w |n. 0 \\<le> n \\<and> n < \\<^bold>|w\\<^bold>|}.\n     \\<forall>b\\<in>{rotate n w |n.\n                     0 \\<le> n \\<and> n < \\<^bold>|w\\<^bold>|}.\n        b \\<le>lex m \\<longrightarrow> m = b\n\ngoal (1 subgoal):\n 1. (\\<And>w' n.\n        \\<lbrakk>w' \\<in> {rotate n w |n.\n                           0 \\<le> n \\<and> n < \\<^bold>|w\\<^bold>|};\n         \\<forall>b\\<in>{rotate n w |n.\n                         0 \\<le> n \\<and> n < \\<^bold>|w\\<^bold>|}.\n            b \\<le>lex w' \\<longrightarrow> w' = b;\n         w' = rotate n w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w' \\<in> {rotate n w |n. 0 \\<le> n \\<and> n < \\<^bold>|w\\<^bold>|}\n  \\<forall>b\\<in>{rotate n w |n. 0 \\<le> n \\<and> n < \\<^bold>|w\\<^bold>|}.\n     b \\<le>lex w' \\<longrightarrow> w' = b\n  w' = rotate n w\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        Lyndon (rotate n w) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"rotate n w <lex rotate na (rotate n w)\" if  \"0 < na\" and \"na < \\<^bold>|w\\<^bold>|\" for na"], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate n w <lex rotate na (rotate n w)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. rotate n w <lex rotate na (rotate n w)", "from prim_no_rotate[OF assms[unfolded prim_rotate_conv[of w n]], of na] \\<open>na < \\<^bold>|w\\<^bold>|\\<close> \\<open>0 < na\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < na; na < \\<^bold>|rotate n w\\<^bold>|\\<rbrakk>\n  \\<Longrightarrow> rotate na (rotate n w) \\<noteq> rotate n w\n  na < \\<^bold>|w\\<^bold>|\n  0 < na", "have \"rotate na (rotate n w) \\<noteq> rotate n w\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < na; na < \\<^bold>|rotate n w\\<^bold>|\\<rbrakk>\n  \\<Longrightarrow> rotate na (rotate n w) \\<noteq> rotate n w\n  na < \\<^bold>|w\\<^bold>|\n  0 < na\n\ngoal (1 subgoal):\n 1. rotate na (rotate n w) \\<noteq> rotate n w", "by force"], ["proof (state)\nthis:\n  rotate na (rotate n w) \\<noteq> rotate n w\n\ngoal (1 subgoal):\n 1. rotate n w <lex rotate na (rotate n w)", "hence \"\\<not> rotate na (rotate n w) \\<le>lex rotate n w\""], ["proof (prove)\nusing this:\n  rotate na (rotate n w) \\<noteq> rotate n w\n\ngoal (1 subgoal):\n 1. \\<not> rotate na (rotate n w) \\<le>lex rotate n w", "using all_b[rule_format, OF all_rot[of \"na + n\", folded rotate_rotate[of na n w]]]"], ["proof (prove)\nusing this:\n  rotate na (rotate n w) \\<noteq> rotate n w\n  rotate na (rotate n w) \\<le>lex w' \\<Longrightarrow>\n  w' = rotate na (rotate n w)\n\ngoal (1 subgoal):\n 1. \\<not> rotate na (rotate n w) \\<le>lex rotate n w", "unfolding w'"], ["proof (prove)\nusing this:\n  rotate na (rotate n w) \\<noteq> rotate n w\n  rotate na (rotate n w) \\<le>lex rotate n w \\<Longrightarrow>\n  rotate n w = rotate na (rotate n w)\n\ngoal (1 subgoal):\n 1. \\<not> rotate na (rotate n w) \\<le>lex rotate n w", "by auto"], ["proof (state)\nthis:\n  \\<not> rotate na (rotate n w) \\<le>lex rotate n w\n\ngoal (1 subgoal):\n 1. rotate n w <lex rotate na (rotate n w)", "from rlex.not_le_imp_less[OF this]"], ["proof (chain)\npicking this:\n  rotate n w <lex rotate na (rotate n w)", "show \"rotate n w <lex rotate na (rotate n w)\""], ["proof (prove)\nusing this:\n  rotate n w <lex rotate na (rotate n w)\n\ngoal (1 subgoal):\n 1. rotate n w <lex rotate na (rotate n w)", "."], ["proof (state)\nthis:\n  rotate n w <lex rotate na (rotate n w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?na1; ?na1 < \\<^bold>|w\\<^bold>|\\<rbrakk>\n  \\<Longrightarrow> rotate n w <lex rotate ?na1 (rotate n w)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        Lyndon (rotate n w) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"Lyndon (rotate n w)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?na1; ?na1 < \\<^bold>|w\\<^bold>|\\<rbrakk>\n  \\<Longrightarrow> rotate n w <lex rotate ?na1 (rotate n w)\n\ngoal (1 subgoal):\n 1. Lyndon (rotate n w)", "using \\<open>w \\<noteq> \\<epsilon>\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?na1; ?na1 < \\<^bold>|w\\<^bold>|\\<rbrakk>\n  \\<Longrightarrow> rotate n w <lex rotate ?na1 (rotate n w)\n  w \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. Lyndon (rotate n w)", "by auto"], ["proof (state)\nthis:\n  Lyndon (rotate n w)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        Lyndon (rotate n w) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from that[OF this]"], ["proof (chain)\npicking this:\n  thesis", "show thesis"], ["proof (prove)\nusing this:\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma conjug_Lyndon_ex': assumes \"primitive w\"\n  obtains v where \"w \\<sim> v\" and \"Lyndon v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>w \\<sim> v; Lyndon v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding conjug_rotate_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>\\<exists>n. v = rotate n w; Lyndon v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using conjug_Lyndon_ex[OF \\<open>primitive w\\<close>]"], ["proof (prove)\nusing this:\n  (\\<And>n. Lyndon (rotate n w) \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>\\<exists>n. v = rotate n w; Lyndon v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["", "section \"Characterization by suffixes\""], ["", "lemma Lyndon_suf_less: assumes \"Lyndon w\" \"s \\<le>ns w\" \"s \\<noteq> w\"\n  shows \"w <lex s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w <lex s", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. w <lex s", "define p where \"p = take \\<^bold>|s\\<^bold>| w\""], ["proof (state)\nthis:\n  p = take \\<^bold>|s\\<^bold>| w\n\ngoal (1 subgoal):\n 1. w <lex s", "have \"\\<^bold>|s\\<^bold>| \\<le> \\<^bold>|w\\<^bold>|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>|s\\<^bold>| \\<le> \\<^bold>|w\\<^bold>|", "using nsD[OF \\<open>s \\<le>ns w\\<close>]"], ["proof (prove)\nusing this:\n  s \\<le>s w\n\ngoal (1 subgoal):\n 1. \\<^bold>|s\\<^bold>| \\<le> \\<^bold>|w\\<^bold>|", "by force"], ["proof (state)\nthis:\n  \\<^bold>|s\\<^bold>| \\<le> \\<^bold>|w\\<^bold>|\n\ngoal (1 subgoal):\n 1. w <lex s", "have \"p \\<le>p w\" and \"\\<^bold>|p\\<^bold>|  = \\<^bold>|s\\<^bold>|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le>p w &&& \\<^bold>|p\\<^bold>| = \\<^bold>|s\\<^bold>|", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. take \\<^bold>|s\\<^bold>| w \\<le>p w &&&\n    \\<^bold>|take \\<^bold>|s\\<^bold>| w\\<^bold>| = \\<^bold>|s\\<^bold>|", "using take_is_prefix \\<open>\\<^bold>|s\\<^bold>| \\<le> \\<^bold>|w\\<^bold>|\\<close> take_len"], ["proof (prove)\nusing this:\n  take ?n ?xs \\<le>p ?xs\n  \\<^bold>|s\\<^bold>| \\<le> \\<^bold>|w\\<^bold>|\n  ?p \\<le> \\<^bold>|?w\\<^bold>| \\<Longrightarrow>\n  \\<^bold>|take ?p ?w\\<^bold>| = ?p\n\ngoal (1 subgoal):\n 1. take \\<^bold>|s\\<^bold>| w \\<le>p w &&&\n    \\<^bold>|take \\<^bold>|s\\<^bold>| w\\<^bold>| = \\<^bold>|s\\<^bold>|", "by blast+"], ["proof (state)\nthis:\n  p \\<le>p w\n  \\<^bold>|p\\<^bold>| = \\<^bold>|s\\<^bold>|\n\ngoal (1 subgoal):\n 1. w <lex s", "hence \"p \\<noteq> s\""], ["proof (prove)\nusing this:\n  p \\<le>p w\n  \\<^bold>|p\\<^bold>| = \\<^bold>|s\\<^bold>|\n\ngoal (1 subgoal):\n 1. p \\<noteq> s", "using Lyndon_unbordered[OF \\<open>Lyndon w\\<close>] \\<open>s \\<le>ns w\\<close> \\<open>s \\<noteq> w\\<close> assms"], ["proof (prove)\nusing this:\n  p \\<le>p w\n  \\<^bold>|p\\<^bold>| = \\<^bold>|s\\<^bold>|\n  \\<not> bordered w\n  s \\<le>ns w\n  s \\<noteq> w\n  Lyndon w\n  s \\<le>ns w\n  s \\<noteq> w\n\ngoal (1 subgoal):\n 1. p \\<noteq> s", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> s\n\ngoal (1 subgoal):\n 1. w <lex s", "define p' s' where \"p' = drop \\<^bold>|s\\<^bold>| w\" and \"s' = take \\<^bold>|p'\\<^bold>| w\""], ["proof (state)\nthis:\n  p' = drop \\<^bold>|s\\<^bold>| w\n  s' = take \\<^bold>|p'\\<^bold>| w\n\ngoal (1 subgoal):\n 1. w <lex s", "have \"p\\<cdot>p' = w\" and \"s'\\<cdot>s = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<cdot> p' = w &&& s' \\<cdot> s = w", "unfolding p'_def p_def s'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. take \\<^bold>|s\\<^bold>| w \\<cdot> drop \\<^bold>|s\\<^bold>| w = w &&&\n    take \\<^bold>|drop \\<^bold>|s\\<^bold>| w\\<^bold>| w \\<cdot> s = w", "using \\<open>s \\<le>ns w\\<close>"], ["proof (prove)\nusing this:\n  s \\<le>ns w\n\ngoal (1 subgoal):\n 1. take \\<^bold>|s\\<^bold>| w \\<cdot> drop \\<^bold>|s\\<^bold>| w = w &&&\n    take \\<^bold>|drop \\<^bold>|s\\<^bold>| w\\<^bold>| w \\<cdot> s = w", "by auto"], ["proof (state)\nthis:\n  p \\<cdot> p' = w\n  s' \\<cdot> s = w\n\ngoal (1 subgoal):\n 1. w <lex s", "have \"\\<^bold>|p'\\<^bold>| = \\<^bold>|s'\\<^bold>|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>|p'\\<^bold>| = \\<^bold>|s'\\<^bold>|", "using s'_def \\<open>p\\<cdot>p' = w\\<close>"], ["proof (prove)\nusing this:\n  s' = take \\<^bold>|p'\\<^bold>| w\n  p \\<cdot> p' = w\n\ngoal (1 subgoal):\n 1. \\<^bold>|p'\\<^bold>| = \\<^bold>|s'\\<^bold>|", "by auto"], ["proof (state)\nthis:\n  \\<^bold>|p'\\<^bold>| = \\<^bold>|s'\\<^bold>|\n\ngoal (1 subgoal):\n 1. w <lex s", "have \"w <lex s\\<cdot>s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w <lex s \\<cdot> s'", "using Lyndon_conj_greater[of s' s, unfolded \\<open>s' \\<cdot> s = w\\<close>, OF \\<open>Lyndon w\\<close>] \\<open>p \\<noteq> s\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>s' \\<noteq> \\<epsilon>; s \\<noteq> \\<epsilon>\\<rbrakk>\n  \\<Longrightarrow> w <lex s \\<cdot> s'\n  p \\<noteq> s\n\ngoal (1 subgoal):\n 1. w <lex s \\<cdot> s'", "unfolding \\<open>s' \\<cdot> s = w\\<close> p_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>s' \\<noteq> \\<epsilon>; s \\<noteq> \\<epsilon>\\<rbrakk>\n  \\<Longrightarrow> w <lex s \\<cdot> s'\n  take \\<^bold>|s\\<^bold>| w \\<noteq> s\n\ngoal (1 subgoal):\n 1. w <lex s \\<cdot> s'", "using \\<open>s' \\<cdot> s = w\\<close> assms(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>s' \\<noteq> \\<epsilon>; s \\<noteq> \\<epsilon>\\<rbrakk>\n  \\<Longrightarrow> w <lex s \\<cdot> s'\n  take \\<^bold>|s\\<^bold>| w \\<noteq> s\n  s' \\<cdot> s = w\n  s \\<noteq> w\n\ngoal (1 subgoal):\n 1. w <lex s \\<cdot> s'", "by fastforce"], ["proof (state)\nthis:\n  w <lex s \\<cdot> s'\n\ngoal (1 subgoal):\n 1. w <lex s", "from lexord_suf_linorder[OF _ \\<open>p \\<noteq> s\\<close> \\<open>\\<^bold>|p\\<^bold>| = \\<^bold>|s\\<^bold>|\\<close> \\<open>\\<^bold>|p'\\<^bold>| = \\<^bold>|s'\\<^bold>|\\<close>, OF this[folded \\<open>p \\<cdot> p' = w\\<close>]]"], ["proof (chain)\npicking this:\n  p <lex s", "have \"p <lex s\""], ["proof (prove)\nusing this:\n  p <lex s\n\ngoal (1 subgoal):\n 1. p <lex s", "."], ["proof (state)\nthis:\n  p <lex s\n\ngoal (1 subgoal):\n 1. w <lex s", "from lexord_app_right_linorder[OF this, of p' \\<epsilon>, unfolded \\<open>p \\<cdot> p' = w\\<close>]  \\<open>\\<^bold>|p\\<^bold>| = \\<^bold>|s\\<^bold>|\\<close>"], ["proof (chain)\npicking this:\n  \\<^bold>|s\\<^bold>| \\<le> \\<^bold>|p\\<^bold>| \\<Longrightarrow>\n  w <lex s \\<cdot> \\<epsilon>\n  \\<^bold>|p\\<^bold>| = \\<^bold>|s\\<^bold>|", "show \"w <lex s\""], ["proof (prove)\nusing this:\n  \\<^bold>|s\\<^bold>| \\<le> \\<^bold>|p\\<^bold>| \\<Longrightarrow>\n  w <lex s \\<cdot> \\<epsilon>\n  \\<^bold>|p\\<^bold>| = \\<^bold>|s\\<^bold>|\n\ngoal (1 subgoal):\n 1. w <lex s", "by simp"], ["proof (state)\nthis:\n  w <lex s\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO zkusit pouzit jinde *)"], ["", "lemma Lyndon_pref_suf_less:  assumes \"Lyndon w\" \"p \\<le>p w\" \"s \\<le>ns w\" \"s \\<noteq> w\"\n  shows \"p <lex s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p <lex s", "proof(cases \"p = w\", simp add: Lyndon_suf_less[OF assms(1) assms(3) assms(4)])"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> w \\<Longrightarrow> p <lex s", "assume \"p \\<noteq> w\""], ["proof (state)\nthis:\n  p \\<noteq> w\n\ngoal (1 subgoal):\n 1. p \\<noteq> w \\<Longrightarrow> p <lex s", "show \"p <lex s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p <lex s", "proof(rule rlex.less_trans)"], ["proof (state)\ngoal (2 subgoals):\n 1. p <lex ?y\n 2. ?y <lex s", "show \"p <lex w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p <lex w", "using \\<open>p \\<noteq> w\\<close> assms(2) lexordp_append_rightI"], ["proof (prove)\nusing this:\n  p \\<noteq> w\n  p \\<le>p w\n  ?ys \\<noteq> \\<epsilon> \\<Longrightarrow> ?xs <lex ?xs \\<cdot> ?ys\n\ngoal (1 subgoal):\n 1. p <lex w", "by fastforce"], ["proof (state)\nthis:\n  p <lex w\n\ngoal (1 subgoal):\n 1. w <lex s", "show \"w <lex s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w <lex s", "using Lyndon_suf_less assms(1) assms(3) assms(4)"], ["proof (prove)\nusing this:\n  \\<lbrakk>Lyndon ?w; ?s \\<le>ns ?w; ?s \\<noteq> ?w\\<rbrakk>\n  \\<Longrightarrow> ?w <lex ?s\n  Lyndon w\n  s \\<le>ns w\n  s \\<noteq> w\n\ngoal (1 subgoal):\n 1. w <lex s", "by blast"], ["proof (state)\nthis:\n  w <lex s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p <lex s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma suf_less_Lyndon: assumes \"w \\<noteq> \\<epsilon>\" and \"\\<forall>s. (s \\<le>ns w \\<longrightarrow> s \\<noteq> w \\<longrightarrow> w <lex s)\"\n  shows \"Lyndon w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon w", "proof (cases \"primitive w\")"], ["proof (state)\ngoal (2 subgoals):\n 1. primitive w \\<Longrightarrow> Lyndon w\n 2. \\<not> primitive w \\<Longrightarrow> Lyndon w", "assume \"\\<not> primitive w\""], ["proof (state)\nthis:\n  \\<not> primitive w\n\ngoal (2 subgoals):\n 1. primitive w \\<Longrightarrow> Lyndon w\n 2. \\<not> primitive w \\<Longrightarrow> Lyndon w", "obtain q k where \"q \\<noteq> \\<epsilon>\" \"1 < k\" \"q\\<^sup>@k=w\" \"w\\<noteq>q\" \\<comment> \\<open>the exact match of @{thm non_prim} fastens the proof considerably\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q k.\n        \\<lbrakk>q \\<noteq> \\<epsilon>; 1 < k; q \\<^sup>@ k = w;\n         w \\<noteq> q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using non_prim[OF \\<open>\\<not> primitive w\\<close> \\<open>w \\<noteq> \\<epsilon>\\<close>]"], ["proof (prove)\nusing this:\n  (\\<And>r k.\n      \\<lbrakk>r \\<noteq> \\<epsilon>; 1 < k; r \\<^sup>@ k = w;\n       w \\<noteq> r\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>q k.\n        \\<lbrakk>q \\<noteq> \\<epsilon>; 1 < k; q \\<^sup>@ k = w;\n         w \\<noteq> q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  q \\<noteq> \\<epsilon>\n  1 < k\n  q \\<^sup>@ k = w\n  w \\<noteq> q\n\ngoal (2 subgoals):\n 1. primitive w \\<Longrightarrow> Lyndon w\n 2. \\<not> primitive w \\<Longrightarrow> Lyndon w", "hence \"q \\<le>ns w\""], ["proof (prove)\nusing this:\n  q \\<noteq> \\<epsilon>\n  1 < k\n  q \\<^sup>@ k = w\n  w \\<noteq> q\n\ngoal (1 subgoal):\n 1. q \\<le>ns w", "unfolding nonempty_suffix_def pow_eq_if_list[of q k] pow_commutes_list[symmetric]"], ["proof (prove)\nusing this:\n  q \\<noteq> \\<epsilon>\n  1 < k\n  (if k = 0 then \\<epsilon> else q \\<^sup>@ (k - 1) \\<cdot> q) = w\n  w \\<noteq> q\n\ngoal (1 subgoal):\n 1. q \\<noteq> \\<epsilon> \\<and> q \\<le>s w", "using sufI[of \"q \\<^sup>@ (k - 1)\" q w]"], ["proof (prove)\nusing this:\n  q \\<noteq> \\<epsilon>\n  1 < k\n  (if k = 0 then \\<epsilon> else q \\<^sup>@ (k - 1) \\<cdot> q) = w\n  w \\<noteq> q\n  q \\<^sup>@ (k - 1) \\<cdot> q = w \\<Longrightarrow> q \\<le>s w\n\ngoal (1 subgoal):\n 1. q \\<noteq> \\<epsilon> \\<and> q \\<le>s w", "by presburger"], ["proof (state)\nthis:\n  q \\<le>ns w\n\ngoal (2 subgoals):\n 1. primitive w \\<Longrightarrow> Lyndon w\n 2. \\<not> primitive w \\<Longrightarrow> Lyndon w", "have \"q <p w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q <p w", "using \\<open>1 < k\\<close>  \\<open>q \\<^sup>@ k = w\\<close>"], ["proof (prove)\nusing this:\n  1 < k\n  q \\<^sup>@ k = w\n\ngoal (1 subgoal):\n 1. q <p w", "unfolding pow_eq_if_list[of q k] pow_eq_if_list[of q \"k-1\"]"], ["proof (prove)\nusing this:\n  1 < k\n  (if k = 0 then \\<epsilon>\n   else q \\<cdot>\n        (if k - 1 = 0 then \\<epsilon>\n         else q \\<cdot> q \\<^sup>@ (k - 1 - 1))) =\n  w\n\ngoal (1 subgoal):\n 1. q <p w", "using \\<open>w \\<noteq> \\<epsilon>\\<close>"], ["proof (prove)\nusing this:\n  1 < k\n  (if k = 0 then \\<epsilon>\n   else q \\<cdot>\n        (if k - 1 = 0 then \\<epsilon>\n         else q \\<cdot> q \\<^sup>@ (k - 1 - 1))) =\n  w\n  w \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. q <p w", "by auto"], ["proof (state)\nthis:\n  q <p w\n\ngoal (2 subgoals):\n 1. primitive w \\<Longrightarrow> Lyndon w\n 2. \\<not> primitive w \\<Longrightarrow> Lyndon w", "from lexordp_append_rightI[of \"q\\<inverse>\\<^sup>>w\" q, \n      unfolded lq_pref[OF sprefD1[OF this]], OF lq_spref[OF this]]"], ["proof (chain)\npicking this:\n  q <lex w", "have \"q <lex w\""], ["proof (prove)\nusing this:\n  q <lex w\n\ngoal (1 subgoal):\n 1. q <lex w", "."], ["proof (state)\nthis:\n  q <lex w\n\ngoal (2 subgoals):\n 1. primitive w \\<Longrightarrow> Lyndon w\n 2. \\<not> primitive w \\<Longrightarrow> Lyndon w", "thus  \"Lyndon w\""], ["proof (prove)\nusing this:\n  q <lex w\n\ngoal (1 subgoal):\n 1. Lyndon w", "unfolding Lyndon.simps"], ["proof (prove)\nusing this:\n  q <lex w\n\ngoal (1 subgoal):\n 1. w \\<noteq> \\<epsilon> \\<and>\n    (\\<forall>n.\n        0 < n \\<and> n < \\<^bold>|w\\<^bold>| \\<longrightarrow>\n        w <lex rotate n w)", "using \\<open>q \\<le>ns w\\<close> \\<open>w \\<noteq> \\<epsilon>\\<close> assms(2) rlex.order.strict_trans"], ["proof (prove)\nusing this:\n  q <lex w\n  q \\<le>ns w\n  w \\<noteq> \\<epsilon>\n  \\<forall>s.\n     s \\<le>ns w \\<longrightarrow> s \\<noteq> w \\<longrightarrow> w <lex s\n  \\<lbrakk>?a <lex ?b; ?b <lex ?c\\<rbrakk> \\<Longrightarrow> ?a <lex ?c\n\ngoal (1 subgoal):\n 1. w \\<noteq> \\<epsilon> \\<and>\n    (\\<forall>n.\n        0 < n \\<and> n < \\<^bold>|w\\<^bold>| \\<longrightarrow>\n        w <lex rotate n w)", "by blast"], ["proof (state)\nthis:\n  Lyndon w\n\ngoal (1 subgoal):\n 1. primitive w \\<Longrightarrow> Lyndon w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. primitive w \\<Longrightarrow> Lyndon w", "assume \"primitive w\""], ["proof (state)\nthis:\n  primitive w\n\ngoal (1 subgoal):\n 1. primitive w \\<Longrightarrow> Lyndon w", "have \"w <lex rotate l w\" if assms_l: \"0 < l\" \"l < \\<^bold>|w\\<^bold>|\" for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. w <lex rotate l w", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. w <lex rotate l w", "have \"take l w \\<le>np w\" and \"\\<^bold>|take l w\\<^bold>| = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take l w \\<le>np w &&& \\<^bold>|take l w\\<^bold>| = l", "using assms_l take_is_prefix  \\<open>l < \\<^bold>|w\\<^bold>|\\<close>"], ["proof (prove)\nusing this:\n  0 < l\n  l < \\<^bold>|w\\<^bold>|\n  take ?n ?xs \\<le>p ?xs\n  l < \\<^bold>|w\\<^bold>|\n\ngoal (1 subgoal):\n 1. take l w \\<le>np w &&& \\<^bold>|take l w\\<^bold>| = l", "by auto"], ["proof (state)\nthis:\n  take l w \\<le>np w\n  \\<^bold>|take l w\\<^bold>| = l\n\ngoal (1 subgoal):\n 1. w <lex rotate l w", "have \"drop l w \\<le>ns w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop l w \\<le>ns w", "using \\<open>l < \\<^bold>|w\\<^bold>|\\<close> suffix_drop"], ["proof (prove)\nusing this:\n  l < \\<^bold>|w\\<^bold>|\n  drop ?n ?as \\<le>s ?as\n\ngoal (1 subgoal):\n 1. drop l w \\<le>ns w", "by auto"], ["proof (state)\nthis:\n  drop l w \\<le>ns w\n\ngoal (1 subgoal):\n 1. w <lex rotate l w", "have \"drop l w \\<noteq> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop l w \\<noteq> w", "using append_take_drop_id[of l w] npD'[OF \\<open>take l w \\<le>np w\\<close>]"], ["proof (prove)\nusing this:\n  take l w \\<cdot> drop l w = w\n  take l w \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. drop l w \\<noteq> w", "by force"], ["proof (state)\nthis:\n  drop l w \\<noteq> w\n\ngoal (1 subgoal):\n 1. w <lex rotate l w", "have \"drop l w \\<cdot> take l w = rotate l w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. drop l w \\<cdot> take l w = rotate l w", "using rotate_append[of \"take l w\" \"drop l w\", symmetric, unfolded \\<open>\\<^bold>|take l w\\<^bold>| = l\\<close>, \n          unfolded append_take_drop_id]"], ["proof (prove)\nusing this:\n  drop l w \\<cdot> take l w = rotate l w\n\ngoal (1 subgoal):\n 1. drop l w \\<cdot> take l w = rotate l w", "."], ["proof (state)\nthis:\n  drop l w \\<cdot> take l w = rotate l w\n\ngoal (1 subgoal):\n 1. w <lex rotate l w", "have \"w <lex drop l w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w <lex drop l w", "using \\<open>drop l w \\<le>ns w\\<close> \\<open>drop l w \\<noteq> w\\<close> assms(2)"], ["proof (prove)\nusing this:\n  drop l w \\<le>ns w\n  drop l w \\<noteq> w\n  \\<forall>s.\n     s \\<le>ns w \\<longrightarrow> s \\<noteq> w \\<longrightarrow> w <lex s\n\ngoal (1 subgoal):\n 1. w <lex drop l w", "by blast"], ["proof (state)\nthis:\n  w <lex drop l w\n\ngoal (1 subgoal):\n 1. w <lex rotate l w", "from lexord_app_right_linorder[OF this suffix_length_le[OF conjunct2[OF \\<open>drop l w \\<le>ns w\\<close>[unfolded nonempty_suffix_def]]], of \\<epsilon> \"take l w\", unfolded  append.right_neutral]"], ["proof (chain)\npicking this:\n  w <lex drop l w \\<cdot> take l w", "have \"w <lex drop l w \\<cdot> take l w\""], ["proof (prove)\nusing this:\n  w <lex drop l w \\<cdot> take l w\n\ngoal (1 subgoal):\n 1. w <lex drop l w \\<cdot> take l w", "."], ["proof (state)\nthis:\n  w <lex drop l w \\<cdot> take l w\n\ngoal (1 subgoal):\n 1. w <lex rotate l w", "thus \"w <lex rotate l w\""], ["proof (prove)\nusing this:\n  w <lex drop l w \\<cdot> take l w\n\ngoal (1 subgoal):\n 1. w <lex rotate l w", "by (simp add: \\<open>drop l w \\<cdot> take l w = rotate l w\\<close>)"], ["proof (state)\nthis:\n  w <lex rotate l w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?l1; ?l1 < \\<^bold>|w\\<^bold>|\\<rbrakk>\n  \\<Longrightarrow> w <lex rotate ?l1 w\n\ngoal (1 subgoal):\n 1. primitive w \\<Longrightarrow> Lyndon w", "thus \"Lyndon w\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?l1; ?l1 < \\<^bold>|w\\<^bold>|\\<rbrakk>\n  \\<Longrightarrow> w <lex rotate ?l1 w\n\ngoal (1 subgoal):\n 1. Lyndon w", "by (simp add: \\<open>w \\<noteq> \\<epsilon>\\<close> local.LyndonI)"], ["proof (state)\nthis:\n  Lyndon w\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary Lyndon_suf_char: \"w \\<noteq> \\<epsilon> \\<Longrightarrow> Lyndon w \\<longleftrightarrow> (\\<forall>s. s \\<le>ns w \\<longrightarrow> s \\<noteq> w \\<longrightarrow> w <lex s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<noteq> \\<epsilon> \\<Longrightarrow>\n    Lyndon w =\n    (\\<forall>s.\n        s \\<le>ns w \\<longrightarrow>\n        s \\<noteq> w \\<longrightarrow> w <lex s)", "using Lyndon_suf_less suf_less_Lyndon"], ["proof (prove)\nusing this:\n  \\<lbrakk>Lyndon ?w; ?s \\<le>ns ?w; ?s \\<noteq> ?w\\<rbrakk>\n  \\<Longrightarrow> ?w <lex ?s\n  \\<lbrakk>?w \\<noteq> \\<epsilon>;\n   \\<forall>s.\n      s \\<le>ns ?w \\<longrightarrow>\n      s \\<noteq> ?w \\<longrightarrow> ?w <lex s\\<rbrakk>\n  \\<Longrightarrow> Lyndon ?w\n\ngoal (1 subgoal):\n 1. w \\<noteq> \\<epsilon> \\<Longrightarrow>\n    Lyndon w =\n    (\\<forall>s.\n        s \\<le>ns w \\<longrightarrow>\n        s \\<noteq> w \\<longrightarrow> w <lex s)", "by blast"], ["", "lemma Lyndon_suf_le: \"Lyndon w \\<Longrightarrow> s \\<le>ns w \\<Longrightarrow> w \\<le>lex s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Lyndon w; s \\<le>ns w\\<rbrakk> \\<Longrightarrow> w \\<le>lex s", "using Lyndon_suf_less rlex.not_less rlex.order.asym"], ["proof (prove)\nusing this:\n  \\<lbrakk>Lyndon ?w; ?s \\<le>ns ?w; ?s \\<noteq> ?w\\<rbrakk>\n  \\<Longrightarrow> ?w <lex ?s\n  (\\<not> ?x <lex ?y) = (?y \\<le>lex ?x)\n  \\<lbrakk>?a <lex ?b; ?b <lex ?a\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Lyndon w; s \\<le>ns w\\<rbrakk> \\<Longrightarrow> w \\<le>lex s", "by blast"], ["", "section \"Unbordered prefix of a Lyndon word is Lyndon\""], ["", "lemma unbordered_pref_Lyndon: \"Lyndon (u\\<cdot>v) \\<Longrightarrow> u \\<noteq> \\<epsilon> \\<Longrightarrow> \\<not> bordered u \\<Longrightarrow> Lyndon u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Lyndon (u \\<cdot> v); u \\<noteq> \\<epsilon>;\n     \\<not> bordered u\\<rbrakk>\n    \\<Longrightarrow> Lyndon u", "unfolding Lyndon_suf_char"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Lyndon (u \\<cdot> v); u \\<noteq> \\<epsilon>;\n     \\<not> bordered u\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s.\n                         s \\<le>ns u \\<longrightarrow>\n                         s \\<noteq> u \\<longrightarrow> u <lex s", "proof(standard+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>Lyndon (u \\<cdot> v); u \\<noteq> \\<epsilon>;\n        \\<not> bordered u; s \\<le>ns u; s \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> u <lex s", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>Lyndon (u \\<cdot> v); u \\<noteq> \\<epsilon>;\n        \\<not> bordered u; s \\<le>ns u; s \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> u <lex s", "assume \"Lyndon (u \\<cdot> v)\" and  \"u \\<noteq> \\<epsilon>\" and \"\\<not> bordered u\" and \"s \\<le>ns u\" and \"s \\<noteq> u\""], ["proof (state)\nthis:\n  Lyndon (u \\<cdot> v)\n  u \\<noteq> \\<epsilon>\n  \\<not> bordered u\n  s \\<le>ns u\n  s \\<noteq> u\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>Lyndon (u \\<cdot> v); u \\<noteq> \\<epsilon>;\n        \\<not> bordered u; s \\<le>ns u; s \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> u <lex s", "hence \"u \\<cdot> v <lex s \\<cdot> v\""], ["proof (prove)\nusing this:\n  Lyndon (u \\<cdot> v)\n  u \\<noteq> \\<epsilon>\n  \\<not> bordered u\n  s \\<le>ns u\n  s \\<noteq> u\n\ngoal (1 subgoal):\n 1. u \\<cdot> v <lex s \\<cdot> v", "using  Lyndon_suf_less[OF \\<open>Lyndon (u \\<cdot> v)\\<close>, of \"s \\<cdot> v\"]"], ["proof (prove)\nusing this:\n  Lyndon (u \\<cdot> v)\n  u \\<noteq> \\<epsilon>\n  \\<not> bordered u\n  s \\<le>ns u\n  s \\<noteq> u\n  \\<lbrakk>s \\<cdot> v \\<le>ns u \\<cdot> v;\n   s \\<cdot> v \\<noteq> u \\<cdot> v\\<rbrakk>\n  \\<Longrightarrow> u \\<cdot> v <lex s \\<cdot> v\n\ngoal (1 subgoal):\n 1. u \\<cdot> v <lex s \\<cdot> v", "by auto"], ["proof (state)\nthis:\n  u \\<cdot> v <lex s \\<cdot> v\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>Lyndon (u \\<cdot> v); u \\<noteq> \\<epsilon>;\n        \\<not> bordered u; s \\<le>ns u; s \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> u <lex s", "have \"\\<not> s \\<le>p u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> s \\<le>p u", "using \\<open>\\<not> bordered u\\<close> \\<open>s \\<le>ns u\\<close> \\<open>s \\<noteq> u\\<close>"], ["proof (prove)\nusing this:\n  \\<not> bordered u\n  s \\<le>ns u\n  s \\<noteq> u\n\ngoal (1 subgoal):\n 1. \\<not> s \\<le>p u", "by auto"], ["proof (state)\nthis:\n  \\<not> s \\<le>p u\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>Lyndon (u \\<cdot> v); u \\<noteq> \\<epsilon>;\n        \\<not> bordered u; s \\<le>ns u; s \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> u <lex s", "moreover"], ["proof (state)\nthis:\n  \\<not> s \\<le>p u\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>Lyndon (u \\<cdot> v); u \\<noteq> \\<epsilon>;\n        \\<not> bordered u; s \\<le>ns u; s \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> u <lex s", "have \"\\<not> u \\<le>p s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> u \\<le>p s", "using suf_pref_eq[OF nsD[OF\\<open>s \\<le>ns u\\<close>]] \\<open>s \\<noteq> u\\<close>"], ["proof (prove)\nusing this:\n  u \\<le>p s \\<Longrightarrow> u = s\n  s \\<noteq> u\n\ngoal (1 subgoal):\n 1. \\<not> u \\<le>p s", "by blast"], ["proof (state)\nthis:\n  \\<not> u \\<le>p s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>Lyndon (u \\<cdot> v); u \\<noteq> \\<epsilon>;\n        \\<not> bordered u; s \\<le>ns u; s \\<noteq> u\\<rbrakk>\n       \\<Longrightarrow> u <lex s", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> s \\<le>p u\n  \\<not> u \\<le>p s", "show \"u <lex s\""], ["proof (prove)\nusing this:\n  \\<not> s \\<le>p u\n  \\<not> u \\<le>p s\n\ngoal (1 subgoal):\n 1. u <lex s", "using lexord_cancel_right_linorder[OF \\<open>u \\<cdot> v <lex s \\<cdot> v\\<close>]"], ["proof (prove)\nusing this:\n  \\<not> s \\<le>p u\n  \\<not> u \\<le>p s\n  \\<not> u \\<bowtie> s \\<Longrightarrow> u <lex s\n\ngoal (1 subgoal):\n 1. u <lex s", "by blast"], ["proof (state)\nthis:\n  u <lex s\n\ngoal:\nNo subgoals!", "qed"], ["", "section \"Concatenation of Lyndon words\""], ["", "theorem Lyndon_concat: assumes  \"Lyndon u\" and \"Lyndon v\" and \"u <lex v\"\n  shows \"Lyndon (u\\<cdot>v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon (u \\<cdot> v)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Lyndon (u \\<cdot> v)", "have \"u\\<cdot>v <lex v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<cdot> v <lex v", "proof(cases \"u \\<le>p v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<le>p v \\<Longrightarrow> u \\<cdot> v <lex v\n 2. \\<not> u \\<le>p v \\<Longrightarrow> u \\<cdot> v <lex v", "assume \"u \\<le>p v\""], ["proof (state)\nthis:\n  u \\<le>p v\n\ngoal (2 subgoals):\n 1. u \\<le>p v \\<Longrightarrow> u \\<cdot> v <lex v\n 2. \\<not> u \\<le>p v \\<Longrightarrow> u \\<cdot> v <lex v", "then"], ["proof (chain)\npicking this:\n  u \\<le>p v", "obtain z where \"u\\<cdot>z = v\" and \"z \\<le>ns v\""], ["proof (prove)\nusing this:\n  u \\<le>p v\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>u \\<cdot> z = v; z \\<le>ns v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(3) dual_rlex.less_imp_neq"], ["proof (prove)\nusing this:\n  u \\<le>p v\n  u <lex v\n  ?y <lex ?x \\<Longrightarrow> ?x \\<noteq> ?y\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>u \\<cdot> z = v; z \\<le>ns v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u \\<cdot> z = v\n  z \\<le>ns v\n\ngoal (2 subgoals):\n 1. u \\<le>p v \\<Longrightarrow> u \\<cdot> v <lex v\n 2. \\<not> u \\<le>p v \\<Longrightarrow> u \\<cdot> v <lex v", "from Lyndon_suf_less[OF \\<open>Lyndon v\\<close> this(2), THEN lexord_append_leftI_linorder, of u]\n      LyndonD_nemp[OF \\<open>Lyndon u\\<close>] this(1)"], ["proof (chain)\npicking this:\n  z \\<noteq> v \\<Longrightarrow> u \\<cdot> v <lex u \\<cdot> z\n  u \\<noteq> \\<epsilon>\n  u \\<cdot> z = v", "show ?thesis"], ["proof (prove)\nusing this:\n  z \\<noteq> v \\<Longrightarrow> u \\<cdot> v <lex u \\<cdot> z\n  u \\<noteq> \\<epsilon>\n  u \\<cdot> z = v\n\ngoal (1 subgoal):\n 1. u \\<cdot> v <lex v", "by blast"], ["proof (state)\nthis:\n  u \\<cdot> v <lex v\n\ngoal (1 subgoal):\n 1. \\<not> u \\<le>p v \\<Longrightarrow> u \\<cdot> v <lex v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> u \\<le>p v \\<Longrightarrow> u \\<cdot> v <lex v", "assume \"\\<not> u \\<le>p v\""], ["proof (state)\nthis:\n  \\<not> u \\<le>p v\n\ngoal (1 subgoal):\n 1. \\<not> u \\<le>p v \\<Longrightarrow> u \\<cdot> v <lex v", "then"], ["proof (chain)\npicking this:\n  \\<not> u \\<le>p v", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> u \\<le>p v\n\ngoal (1 subgoal):\n 1. u \\<cdot> v <lex v", "using local.lexordp_linear[of v \"u\\<cdot>v\"] \n        local.lexordp_mid_pref[OF \\<open>u <lex v\\<close>,of v]\n        prefixI[of v u v]"], ["proof (prove)\nusing this:\n  \\<not> u \\<le>p v\n  v <lex u \\<cdot> v \\<or> v = u \\<cdot> v \\<or> u \\<cdot> v <lex v\n  v <lex u \\<cdot> v \\<Longrightarrow> u \\<le>p v\n  v = u \\<cdot> v \\<Longrightarrow> u \\<le>p v\n\ngoal (1 subgoal):\n 1. u \\<cdot> v <lex v", "by argo"], ["proof (state)\nthis:\n  u \\<cdot> v <lex v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u \\<cdot> v <lex v\n\ngoal (1 subgoal):\n 1. Lyndon (u \\<cdot> v)", "{"], ["proof (state)\nthis:\n  u \\<cdot> v <lex v\n\ngoal (1 subgoal):\n 1. Lyndon (u \\<cdot> v)", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. Lyndon (u \\<cdot> v)", "assume \"z \\<le>ns (u\\<cdot>v)\" \"z \\<noteq> u\\<cdot>v\""], ["proof (state)\nthis:\n  z \\<le>ns u \\<cdot> v\n  z \\<noteq> u \\<cdot> v\n\ngoal (1 subgoal):\n 1. Lyndon (u \\<cdot> v)", "have \"u\\<cdot>v <lex z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<cdot> v <lex z", "proof(cases \"z \\<le>ns v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. z \\<le>ns v \\<Longrightarrow> u \\<cdot> v <lex z\n 2. \\<not> z \\<le>ns v \\<Longrightarrow> u \\<cdot> v <lex z", "assume \"z \\<le>ns v\""], ["proof (state)\nthis:\n  z \\<le>ns v\n\ngoal (2 subgoals):\n 1. z \\<le>ns v \\<Longrightarrow> u \\<cdot> v <lex z\n 2. \\<not> z \\<le>ns v \\<Longrightarrow> u \\<cdot> v <lex z", "from Lyndon_suf_less[OF \\<open>Lyndon v\\<close> this]"], ["proof (chain)\npicking this:\n  z \\<noteq> v \\<Longrightarrow> v <lex z", "have \"z \\<noteq> v \\<Longrightarrow> v <lex z\""], ["proof (prove)\nusing this:\n  z \\<noteq> v \\<Longrightarrow> v <lex z\n\ngoal (1 subgoal):\n 1. z \\<noteq> v \\<Longrightarrow> v <lex z", "by blast"], ["proof (state)\nthis:\n  z \\<noteq> v \\<Longrightarrow> v <lex z\n\ngoal (2 subgoals):\n 1. z \\<le>ns v \\<Longrightarrow> u \\<cdot> v <lex z\n 2. \\<not> z \\<le>ns v \\<Longrightarrow> u \\<cdot> v <lex z", "thus \"u\\<cdot>v <lex z\""], ["proof (prove)\nusing this:\n  z \\<noteq> v \\<Longrightarrow> v <lex z\n\ngoal (1 subgoal):\n 1. u \\<cdot> v <lex z", "using \\<open>u \\<cdot> v <lex v\\<close> rlex.less_trans"], ["proof (prove)\nusing this:\n  z \\<noteq> v \\<Longrightarrow> v <lex z\n  u \\<cdot> v <lex v\n  \\<lbrakk>?x <lex ?y; ?y <lex ?z\\<rbrakk> \\<Longrightarrow> ?x <lex ?z\n\ngoal (1 subgoal):\n 1. u \\<cdot> v <lex z", "by fast"], ["proof (state)\nthis:\n  u \\<cdot> v <lex z\n\ngoal (1 subgoal):\n 1. \\<not> z \\<le>ns v \\<Longrightarrow> u \\<cdot> v <lex z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> z \\<le>ns v \\<Longrightarrow> u \\<cdot> v <lex z", "assume \"\\<not> z \\<le>ns v\""], ["proof (state)\nthis:\n  \\<not> z \\<le>ns v\n\ngoal (1 subgoal):\n 1. \\<not> z \\<le>ns v \\<Longrightarrow> u \\<cdot> v <lex z", "then"], ["proof (chain)\npicking this:\n  \\<not> z \\<le>ns v", "obtain z' where \"z' \\<le>ns u\" \"z' \\<noteq> u\" \"z'\\<cdot>v = z\""], ["proof (prove)\nusing this:\n  \\<not> z \\<le>ns v\n\ngoal (1 subgoal):\n 1. (\\<And>z'.\n        \\<lbrakk>z' \\<le>ns u; z' \\<noteq> u; z' \\<cdot> v = z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>z \\<le>ns u \\<cdot> v\\<close> \\<open>z \\<noteq> u \\<cdot> v\\<close> suffix_append[of z u v]"], ["proof (prove)\nusing this:\n  \\<not> z \\<le>ns v\n  z \\<le>ns u \\<cdot> v\n  z \\<noteq> u \\<cdot> v\n  z \\<le>s u \\<cdot> v =\n  (z \\<le>s v \\<or> (\\<exists>xs'. z = xs' \\<cdot> v \\<and> xs' \\<le>s u))\n\ngoal (1 subgoal):\n 1. (\\<And>z'.\n        \\<lbrakk>z' \\<le>ns u; z' \\<noteq> u; z' \\<cdot> v = z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding nonempty_suffix_def"], ["proof (prove)\nusing this:\n  \\<not> (z \\<noteq> \\<epsilon> \\<and> z \\<le>s v)\n  z \\<noteq> \\<epsilon> \\<and> z \\<le>s u \\<cdot> v\n  z \\<noteq> u \\<cdot> v\n  z \\<le>s u \\<cdot> v =\n  (z \\<le>s v \\<or> (\\<exists>xs'. z = xs' \\<cdot> v \\<and> xs' \\<le>s u))\n\ngoal (1 subgoal):\n 1. (\\<And>z'.\n        \\<lbrakk>z' \\<noteq> \\<epsilon> \\<and> z' \\<le>s u; z' \\<noteq> u;\n         z' \\<cdot> v = z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  z' \\<le>ns u\n  z' \\<noteq> u\n  z' \\<cdot> v = z\n\ngoal (1 subgoal):\n 1. \\<not> z \\<le>ns v \\<Longrightarrow> u \\<cdot> v <lex z", "from Lyndon_suf_less[OF \\<open>Lyndon u\\<close> this(1) this(2)]"], ["proof (chain)\npicking this:\n  u <lex z'", "have \"u <lex z'\""], ["proof (prove)\nusing this:\n  u <lex z'\n\ngoal (1 subgoal):\n 1. u <lex z'", "."], ["proof (state)\nthis:\n  u <lex z'\n\ngoal (1 subgoal):\n 1. \\<not> z \\<le>ns v \\<Longrightarrow> u \\<cdot> v <lex z", "thus \"u\\<cdot>v <lex z\""], ["proof (prove)\nusing this:\n  u <lex z'\n\ngoal (1 subgoal):\n 1. u \\<cdot> v <lex z", "using  \\<open>z' \\<le>ns u\\<close> lexord_app_right_linorder[of u z' v v] suffix_length_le[of z' u]"], ["proof (prove)\nusing this:\n  u <lex z'\n  z' \\<le>ns u\n  \\<lbrakk>u <lex z';\n   \\<^bold>|z'\\<^bold>| \\<le> \\<^bold>|u\\<^bold>|\\<rbrakk>\n  \\<Longrightarrow> u \\<cdot> v <lex z' \\<cdot> v\n  z' \\<le>s u \\<Longrightarrow>\n  \\<^bold>|z'\\<^bold>| \\<le> \\<^bold>|u\\<^bold>|\n\ngoal (1 subgoal):\n 1. u \\<cdot> v <lex z", "unfolding nonempty_suffix_def \\<open>z' \\<cdot> v = z\\<close>"], ["proof (prove)\nusing this:\n  u <lex z'\n  z' \\<noteq> \\<epsilon> \\<and> z' \\<le>s u\n  \\<lbrakk>u <lex z';\n   \\<^bold>|z'\\<^bold>| \\<le> \\<^bold>|u\\<^bold>|\\<rbrakk>\n  \\<Longrightarrow> u \\<cdot> v <lex z\n  z' \\<le>s u \\<Longrightarrow>\n  \\<^bold>|z'\\<^bold>| \\<le> \\<^bold>|u\\<^bold>|\n\ngoal (1 subgoal):\n 1. u \\<cdot> v <lex z", "by blast"], ["proof (state)\nthis:\n  u \\<cdot> v <lex z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u \\<cdot> v <lex z\n\ngoal (1 subgoal):\n 1. Lyndon (u \\<cdot> v)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?z3 \\<le>ns u \\<cdot> v; ?z3 \\<noteq> u \\<cdot> v\\<rbrakk>\n  \\<Longrightarrow> u \\<cdot> v <lex ?z3\n\ngoal (1 subgoal):\n 1. Lyndon (u \\<cdot> v)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?z3 \\<le>ns u \\<cdot> v; ?z3 \\<noteq> u \\<cdot> v\\<rbrakk>\n  \\<Longrightarrow> u \\<cdot> v <lex ?z3\n\ngoal (1 subgoal):\n 1. Lyndon (u \\<cdot> v)", "using suf_nemp[OF LyndonD_nemp[OF \\<open>Lyndon v\\<close>], of u, THEN suf_less_Lyndon]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?z3 \\<le>ns u \\<cdot> v; ?z3 \\<noteq> u \\<cdot> v\\<rbrakk>\n  \\<Longrightarrow> u \\<cdot> v <lex ?z3\n  \\<forall>s.\n     s \\<le>ns u \\<cdot> v \\<longrightarrow>\n     s \\<noteq> u \\<cdot> v \\<longrightarrow>\n     u \\<cdot> v <lex s \\<Longrightarrow>\n  Lyndon (u \\<cdot> v)\n\ngoal (1 subgoal):\n 1. Lyndon (u \\<cdot> v)", "by blast"], ["proof (state)\nthis:\n  Lyndon (u \\<cdot> v)\n\ngoal:\nNo subgoals!", "qed"], ["", "section \"Longest Lyndon suffix\""], ["", "fun longest_Lyndon_suffix:: \"'a list \\<Rightarrow> 'a list\" (\"LynSuf\") where\n  \"longest_Lyndon_suffix \\<epsilon> = \\<epsilon>\" |\n  \"longest_Lyndon_suffix (a#w) = (if Lyndon (a#w) then a#w else longest_Lyndon_suffix w)\""], ["", "lemma longest_Lyndon_suf_ext: \"\\<not> Lyndon (a # w) \\<Longrightarrow> LynSuf w = LynSuf (a # w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Lyndon (a # w) \\<Longrightarrow> LynSuf w = LynSuf (a # w)", "using longest_Lyndon_suffix.simps(2)"], ["proof (prove)\nusing this:\n  LynSuf (?a # ?w) = (if Lyndon (?a # ?w) then ?a # ?w else LynSuf ?w)\n\ngoal (1 subgoal):\n 1. \\<not> Lyndon (a # w) \\<Longrightarrow> LynSuf w = LynSuf (a # w)", "by presburger"], ["", "lemma longest_Lyndon_suf_suf: \"w \\<noteq> \\<epsilon> \\<Longrightarrow> LynSuf w \\<le>s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<noteq> \\<epsilon> \\<Longrightarrow> LynSuf w \\<le>s w", "proof(induction w rule: longest_Lyndon_suffix.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<epsilon> \\<noteq> \\<epsilon> \\<Longrightarrow>\n    LynSuf \\<epsilon> \\<le>s \\<epsilon>\n 2. \\<And>a w.\n       \\<lbrakk>\\<lbrakk>\\<not> Lyndon (a # w);\n                 w \\<noteq> \\<epsilon>\\<rbrakk>\n                \\<Longrightarrow> LynSuf w \\<le>s w;\n        a # w \\<noteq> \\<epsilon>\\<rbrakk>\n       \\<Longrightarrow> LynSuf (a # w) \\<le>s a # w", "case 1"], ["proof (state)\nthis:\n  \\<epsilon> \\<noteq> \\<epsilon>\n\ngoal (2 subgoals):\n 1. \\<epsilon> \\<noteq> \\<epsilon> \\<Longrightarrow>\n    LynSuf \\<epsilon> \\<le>s \\<epsilon>\n 2. \\<And>a w.\n       \\<lbrakk>\\<lbrakk>\\<not> Lyndon (a # w);\n                 w \\<noteq> \\<epsilon>\\<rbrakk>\n                \\<Longrightarrow> LynSuf w \\<le>s w;\n        a # w \\<noteq> \\<epsilon>\\<rbrakk>\n       \\<Longrightarrow> LynSuf (a # w) \\<le>s a # w", "then"], ["proof (chain)\npicking this:\n  \\<epsilon> \\<noteq> \\<epsilon>", "show ?case"], ["proof (prove)\nusing this:\n  \\<epsilon> \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. LynSuf \\<epsilon> \\<le>s \\<epsilon>", "by simp"], ["proof (state)\nthis:\n  LynSuf \\<epsilon> \\<le>s \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>a w.\n       \\<lbrakk>\\<lbrakk>\\<not> Lyndon (a # w);\n                 w \\<noteq> \\<epsilon>\\<rbrakk>\n                \\<Longrightarrow> LynSuf w \\<le>s w;\n        a # w \\<noteq> \\<epsilon>\\<rbrakk>\n       \\<Longrightarrow> LynSuf (a # w) \\<le>s a # w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a w.\n       \\<lbrakk>\\<lbrakk>\\<not> Lyndon (a # w);\n                 w \\<noteq> \\<epsilon>\\<rbrakk>\n                \\<Longrightarrow> LynSuf w \\<le>s w;\n        a # w \\<noteq> \\<epsilon>\\<rbrakk>\n       \\<Longrightarrow> LynSuf (a # w) \\<le>s a # w", "case (2 a w)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> Lyndon (a # w); w \\<noteq> \\<epsilon>\\<rbrakk>\n  \\<Longrightarrow> LynSuf w \\<le>s w\n  a # w \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>a w.\n       \\<lbrakk>\\<lbrakk>\\<not> Lyndon (a # w);\n                 w \\<noteq> \\<epsilon>\\<rbrakk>\n                \\<Longrightarrow> LynSuf w \\<le>s w;\n        a # w \\<noteq> \\<epsilon>\\<rbrakk>\n       \\<Longrightarrow> LynSuf (a # w) \\<le>s a # w", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. LynSuf (a # w) \\<le>s a # w", "proof(cases \"Lyndon (a#w)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Lyndon (a # w) \\<Longrightarrow> LynSuf (a # w) \\<le>s a # w\n 2. \\<not> Lyndon (a # w) \\<Longrightarrow> LynSuf (a # w) \\<le>s a # w", "case True"], ["proof (state)\nthis:\n  Lyndon (a # w)\n\ngoal (2 subgoals):\n 1. Lyndon (a # w) \\<Longrightarrow> LynSuf (a # w) \\<le>s a # w\n 2. \\<not> Lyndon (a # w) \\<Longrightarrow> LynSuf (a # w) \\<le>s a # w", "then"], ["proof (chain)\npicking this:\n  Lyndon (a # w)", "show ?thesis"], ["proof (prove)\nusing this:\n  Lyndon (a # w)\n\ngoal (1 subgoal):\n 1. LynSuf (a # w) \\<le>s a # w", "by auto"], ["proof (state)\nthis:\n  LynSuf (a # w) \\<le>s a # w\n\ngoal (1 subgoal):\n 1. \\<not> Lyndon (a # w) \\<Longrightarrow> LynSuf (a # w) \\<le>s a # w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Lyndon (a # w) \\<Longrightarrow> LynSuf (a # w) \\<le>s a # w", "case False"], ["proof (state)\nthis:\n  \\<not> Lyndon (a # w)\n\ngoal (1 subgoal):\n 1. \\<not> Lyndon (a # w) \\<Longrightarrow> LynSuf (a # w) \\<le>s a # w", "from \"2.IH\"[OF this, unfolded longest_Lyndon_suf_ext[OF this], THEN suffix_ConsI, of a]\n      Lyndon_sing False"], ["proof (chain)\npicking this:\n  w \\<noteq> \\<epsilon> \\<Longrightarrow> LynSuf (a # w) \\<le>s a # w\n  Lyndon [?a]\n  \\<not> Lyndon (a # w)", "show ?thesis"], ["proof (prove)\nusing this:\n  w \\<noteq> \\<epsilon> \\<Longrightarrow> LynSuf (a # w) \\<le>s a # w\n  Lyndon [?a]\n  \\<not> Lyndon (a # w)\n\ngoal (1 subgoal):\n 1. LynSuf (a # w) \\<le>s a # w", "by blast"], ["proof (state)\nthis:\n  LynSuf (a # w) \\<le>s a # w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LynSuf (a # w) \\<le>s a # w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma longest_Lyndon_suf_max: \n  \"v \\<le>s w  \\<Longrightarrow> Lyndon v \\<Longrightarrow> v \\<le>s (LynSuf w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<le>s w; Lyndon v\\<rbrakk>\n    \\<Longrightarrow> v \\<le>s LynSuf w", "proof(induction w arbitrary: v rule: longest_Lyndon_suffix.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>v \\<le>s \\<epsilon>; Lyndon v\\<rbrakk>\n       \\<Longrightarrow> v \\<le>s LynSuf \\<epsilon>\n 2. \\<And>a w v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<not> Lyndon (a # w); v \\<le>s w;\n                    Lyndon v\\<rbrakk>\n                   \\<Longrightarrow> v \\<le>s LynSuf w;\n        v \\<le>s a # w; Lyndon v\\<rbrakk>\n       \\<Longrightarrow> v \\<le>s LynSuf (a # w)", "case 1"], ["proof (state)\nthis:\n  v \\<le>s \\<epsilon>\n  Lyndon v\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>v \\<le>s \\<epsilon>; Lyndon v\\<rbrakk>\n       \\<Longrightarrow> v \\<le>s LynSuf \\<epsilon>\n 2. \\<And>a w v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<not> Lyndon (a # w); v \\<le>s w;\n                    Lyndon v\\<rbrakk>\n                   \\<Longrightarrow> v \\<le>s LynSuf w;\n        v \\<le>s a # w; Lyndon v\\<rbrakk>\n       \\<Longrightarrow> v \\<le>s LynSuf (a # w)", "then"], ["proof (chain)\npicking this:\n  v \\<le>s \\<epsilon>\n  Lyndon v", "show ?case"], ["proof (prove)\nusing this:\n  v \\<le>s \\<epsilon>\n  Lyndon v\n\ngoal (1 subgoal):\n 1. v \\<le>s LynSuf \\<epsilon>", "using longest_Lyndon_suffix.simps(1)"], ["proof (prove)\nusing this:\n  v \\<le>s \\<epsilon>\n  Lyndon v\n  LynSuf \\<epsilon> = \\<epsilon>\n\ngoal (1 subgoal):\n 1. v \\<le>s LynSuf \\<epsilon>", "by presburger"], ["proof (state)\nthis:\n  v \\<le>s LynSuf \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>a w v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<not> Lyndon (a # w); v \\<le>s w;\n                    Lyndon v\\<rbrakk>\n                   \\<Longrightarrow> v \\<le>s LynSuf w;\n        v \\<le>s a # w; Lyndon v\\<rbrakk>\n       \\<Longrightarrow> v \\<le>s LynSuf (a # w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a w v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<not> Lyndon (a # w); v \\<le>s w;\n                    Lyndon v\\<rbrakk>\n                   \\<Longrightarrow> v \\<le>s LynSuf w;\n        v \\<le>s a # w; Lyndon v\\<rbrakk>\n       \\<Longrightarrow> v \\<le>s LynSuf (a # w)", "case (2 a w)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> Lyndon (a # w); ?v1 \\<le>s w; Lyndon ?v1\\<rbrakk>\n  \\<Longrightarrow> ?v1 \\<le>s LynSuf w\n  v \\<le>s a # w\n  Lyndon v\n\ngoal (1 subgoal):\n 1. \\<And>a w v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>\\<not> Lyndon (a # w); v \\<le>s w;\n                    Lyndon v\\<rbrakk>\n                   \\<Longrightarrow> v \\<le>s LynSuf w;\n        v \\<le>s a # w; Lyndon v\\<rbrakk>\n       \\<Longrightarrow> v \\<le>s LynSuf (a # w)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<le>s LynSuf (a # w)", "proof(cases \"Lyndon (a#w)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Lyndon (a # w) \\<Longrightarrow> v \\<le>s LynSuf (a # w)\n 2. \\<not> Lyndon (a # w) \\<Longrightarrow> v \\<le>s LynSuf (a # w)", "case True"], ["proof (state)\nthis:\n  Lyndon (a # w)\n\ngoal (2 subgoals):\n 1. Lyndon (a # w) \\<Longrightarrow> v \\<le>s LynSuf (a # w)\n 2. \\<not> Lyndon (a # w) \\<Longrightarrow> v \\<le>s LynSuf (a # w)", "then"], ["proof (chain)\npicking this:\n  Lyndon (a # w)", "show ?thesis"], ["proof (prove)\nusing this:\n  Lyndon (a # w)\n\ngoal (1 subgoal):\n 1. v \\<le>s LynSuf (a # w)", "using \"2.prems\"(1) longest_Lyndon_suffix.simps(2)"], ["proof (prove)\nusing this:\n  Lyndon (a # w)\n  v \\<le>s a # w\n  LynSuf (?a # ?w) = (if Lyndon (?a # ?w) then ?a # ?w else LynSuf ?w)\n\ngoal (1 subgoal):\n 1. v \\<le>s LynSuf (a # w)", "by presburger"], ["proof (state)\nthis:\n  v \\<le>s LynSuf (a # w)\n\ngoal (1 subgoal):\n 1. \\<not> Lyndon (a # w) \\<Longrightarrow> v \\<le>s LynSuf (a # w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Lyndon (a # w) \\<Longrightarrow> v \\<le>s LynSuf (a # w)", "case False"], ["proof (state)\nthis:\n  \\<not> Lyndon (a # w)\n\ngoal (1 subgoal):\n 1. \\<not> Lyndon (a # w) \\<Longrightarrow> v \\<le>s LynSuf (a # w)", "have \"v \\<noteq> a # w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<noteq> a # w", "using \"2.prems\"(2) False"], ["proof (prove)\nusing this:\n  Lyndon v\n  \\<not> Lyndon (a # w)\n\ngoal (1 subgoal):\n 1. v \\<noteq> a # w", "by blast"], ["proof (state)\nthis:\n  v \\<noteq> a # w\n\ngoal (1 subgoal):\n 1. \\<not> Lyndon (a # w) \\<Longrightarrow> v \\<le>s LynSuf (a # w)", "from \"2.IH\"[OF False _ \"2.prems\"(2), unfolded longest_Lyndon_suf_ext[OF False]]\n       \"2.prems\"(1)[unfolded suffix_Cons] this"], ["proof (chain)\npicking this:\n  v \\<le>s w \\<Longrightarrow> v \\<le>s LynSuf (a # w)\n  v = a # w \\<or> v \\<le>s w\n  v \\<noteq> a # w", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<le>s w \\<Longrightarrow> v \\<le>s LynSuf (a # w)\n  v = a # w \\<or> v \\<le>s w\n  v \\<noteq> a # w\n\ngoal (1 subgoal):\n 1. v \\<le>s LynSuf (a # w)", "by fast"], ["proof (state)\nthis:\n  v \\<le>s LynSuf (a # w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v \\<le>s LynSuf (a # w)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma longest_Lyndon_suf_Lyndon_id: assumes \"Lyndon w\" \n  shows \"LynSuf w = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LynSuf w = w", "proof(cases \"w = \\<epsilon>\", simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> \\<epsilon> \\<Longrightarrow> LynSuf w = w", "case False"], ["proof (state)\nthis:\n  w \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. w \\<noteq> \\<epsilon> \\<Longrightarrow> LynSuf w = w", "from longest_Lyndon_suf_suf[OF this]\n    suffix_order.order_refl[THEN longest_Lyndon_suf_max[OF _ assms]]\n    suffix_order.order.antisym"], ["proof (chain)\npicking this:\n  LynSuf w \\<le>s w\n  w \\<le>s LynSuf w\n  \\<lbrakk>?a \\<le>s ?b; ?b \\<le>s ?a\\<rbrakk> \\<Longrightarrow> ?a = ?b", "show ?thesis"], ["proof (prove)\nusing this:\n  LynSuf w \\<le>s w\n  w \\<le>s LynSuf w\n  \\<lbrakk>?a \\<le>s ?b; ?b \\<le>s ?a\\<rbrakk> \\<Longrightarrow> ?a = ?b\n\ngoal (1 subgoal):\n 1. LynSuf w = w", "by blast"], ["proof (state)\nthis:\n  LynSuf w = w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma longest_Lyndon_suf_longest: \"w \\<noteq> \\<epsilon> \\<Longrightarrow> v' \\<le>s w \\<Longrightarrow> Lyndon v' \\<Longrightarrow> \\<^bold>|v'\\<^bold>| \\<le> \\<^bold>|(LynSuf w)\\<^bold>|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> \\<epsilon>; v' \\<le>s w; Lyndon v'\\<rbrakk>\n    \\<Longrightarrow> \\<^bold>|v'\\<^bold>| \\<le> \\<^bold>|LynSuf w\\<^bold>|", "using longest_Lyndon_suf_max suffix_length_le"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<le>s ?w; Lyndon ?v\\<rbrakk>\n  \\<Longrightarrow> ?v \\<le>s LynSuf ?w\n  ?xs \\<le>s ?ys \\<Longrightarrow>\n  \\<^bold>|?xs\\<^bold>| \\<le> \\<^bold>|?ys\\<^bold>|\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> \\<epsilon>; v' \\<le>s w; Lyndon v'\\<rbrakk>\n    \\<Longrightarrow> \\<^bold>|v'\\<^bold>| \\<le> \\<^bold>|LynSuf w\\<^bold>|", "by blast"], ["", "lemma longest_Lyndon_suf_sing: \"LynSuf [a] = [a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LynSuf [a] = [a]", "using Lyndon_sing longest_Lyndon_suf_Lyndon_id"], ["proof (prove)\nusing this:\n  Lyndon [?a]\n  Lyndon ?w \\<Longrightarrow> LynSuf ?w = ?w\n\ngoal (1 subgoal):\n 1. LynSuf [a] = [a]", "by blast"], ["", "lemma longest_Lyndon_suf_Lyndon: \"w \\<noteq> \\<epsilon> \\<Longrightarrow> Lyndon (LynSuf w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<noteq> \\<epsilon> \\<Longrightarrow> Lyndon (LynSuf w)", "proof(induction w rule: longest_Lyndon_suffix.induct, blast)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a w.\n       \\<lbrakk>\\<lbrakk>\\<not> Lyndon (a # w);\n                 w \\<noteq> \\<epsilon>\\<rbrakk>\n                \\<Longrightarrow> Lyndon (LynSuf w);\n        a # w \\<noteq> \\<epsilon>\\<rbrakk>\n       \\<Longrightarrow> Lyndon (LynSuf (a # w))", "case (2 a w)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> Lyndon (a # w); w \\<noteq> \\<epsilon>\\<rbrakk>\n  \\<Longrightarrow> Lyndon (LynSuf w)\n  a # w \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>a w.\n       \\<lbrakk>\\<lbrakk>\\<not> Lyndon (a # w);\n                 w \\<noteq> \\<epsilon>\\<rbrakk>\n                \\<Longrightarrow> Lyndon (LynSuf w);\n        a # w \\<noteq> \\<epsilon>\\<rbrakk>\n       \\<Longrightarrow> Lyndon (LynSuf (a # w))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon (LynSuf (a # w))", "proof(cases \"Lyndon (a#w)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Lyndon (a # w) \\<Longrightarrow> Lyndon (LynSuf (a # w))\n 2. \\<not> Lyndon (a # w) \\<Longrightarrow> Lyndon (LynSuf (a # w))", "case True"], ["proof (state)\nthis:\n  Lyndon (a # w)\n\ngoal (2 subgoals):\n 1. Lyndon (a # w) \\<Longrightarrow> Lyndon (LynSuf (a # w))\n 2. \\<not> Lyndon (a # w) \\<Longrightarrow> Lyndon (LynSuf (a # w))", "then"], ["proof (chain)\npicking this:\n  Lyndon (a # w)", "show ?thesis"], ["proof (prove)\nusing this:\n  Lyndon (a # w)\n\ngoal (1 subgoal):\n 1. Lyndon (LynSuf (a # w))", "using longest_Lyndon_suf_Lyndon_id"], ["proof (prove)\nusing this:\n  Lyndon (a # w)\n  Lyndon ?w \\<Longrightarrow> LynSuf ?w = ?w\n\ngoal (1 subgoal):\n 1. Lyndon (LynSuf (a # w))", "by presburger"], ["proof (state)\nthis:\n  Lyndon (LynSuf (a # w))\n\ngoal (1 subgoal):\n 1. \\<not> Lyndon (a # w) \\<Longrightarrow> Lyndon (LynSuf (a # w))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Lyndon (a # w) \\<Longrightarrow> Lyndon (LynSuf (a # w))", "case False"], ["proof (state)\nthis:\n  \\<not> Lyndon (a # w)\n\ngoal (1 subgoal):\n 1. \\<not> Lyndon (a # w) \\<Longrightarrow> Lyndon (LynSuf (a # w))", "from \"2.IH\"[OF this, unfolded longest_Lyndon_suf_ext[OF this]] Lyndon_sing"], ["proof (chain)\npicking this:\n  w \\<noteq> \\<epsilon> \\<Longrightarrow> Lyndon (LynSuf (a # w))\n  Lyndon [?a]", "show ?thesis"], ["proof (prove)\nusing this:\n  w \\<noteq> \\<epsilon> \\<Longrightarrow> Lyndon (LynSuf (a # w))\n  Lyndon [?a]\n\ngoal (1 subgoal):\n 1. Lyndon (LynSuf (a # w))", "by fastforce"], ["proof (state)\nthis:\n  Lyndon (LynSuf (a # w))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Lyndon (LynSuf (a # w))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma longest_Lyndon_suf_nemp: \"w \\<noteq> \\<epsilon> \\<Longrightarrow> LynSuf w \\<noteq> \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<noteq> \\<epsilon> \\<Longrightarrow> LynSuf w \\<noteq> \\<epsilon>", "using longest_Lyndon_suf_Lyndon[THEN LyndonD_nemp]"], ["proof (prove)\nusing this:\n  ?w1 \\<noteq> \\<epsilon> \\<Longrightarrow> LynSuf ?w1 \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. w \\<noteq> \\<epsilon> \\<Longrightarrow> LynSuf w \\<noteq> \\<epsilon>", "."], ["", "lemma longest_Lyndon_sufI:\n  assumes \"q \\<le>s w\" and \"Lyndon q\" and all_s: \"(\\<forall> s. (s \\<le>s w \\<and> Lyndon s) \\<longrightarrow> s \\<le>s q)\" \n  shows \"LynSuf w = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LynSuf w = q", "proof(cases \"w = \\<epsilon>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. w = \\<epsilon> \\<Longrightarrow> LynSuf w = q\n 2. w \\<noteq> \\<epsilon> \\<Longrightarrow> LynSuf w = q", "case True"], ["proof (state)\nthis:\n  w = \\<epsilon>\n\ngoal (2 subgoals):\n 1. w = \\<epsilon> \\<Longrightarrow> LynSuf w = q\n 2. w \\<noteq> \\<epsilon> \\<Longrightarrow> LynSuf w = q", "then"], ["proof (chain)\npicking this:\n  w = \\<epsilon>", "show ?thesis"], ["proof (prove)\nusing this:\n  w = \\<epsilon>\n\ngoal (1 subgoal):\n 1. LynSuf w = q", "using assms(1) longest_Lyndon_suffix.simps(1) suffix_bot.bot.extremum_uniqueI"], ["proof (prove)\nusing this:\n  w = \\<epsilon>\n  q \\<le>s w\n  LynSuf \\<epsilon> = \\<epsilon>\n  ?a \\<le>s \\<epsilon> \\<Longrightarrow> ?a = \\<epsilon>\n\ngoal (1 subgoal):\n 1. LynSuf w = q", "by blast"], ["proof (state)\nthis:\n  LynSuf w = q\n\ngoal (1 subgoal):\n 1. w \\<noteq> \\<epsilon> \\<Longrightarrow> LynSuf w = q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> \\<epsilon> \\<Longrightarrow> LynSuf w = q", "case False"], ["proof (state)\nthis:\n  w \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. w \\<noteq> \\<epsilon> \\<Longrightarrow> LynSuf w = q", "from all_s longest_Lyndon_suf_Lyndon[OF this] longest_Lyndon_suf_max[OF assms(1) assms(2)]\n    longest_Lyndon_suf_suf[OF this] suffix_order.eq_iff"], ["proof (chain)\npicking this:\n  \\<forall>s. s \\<le>s w \\<and> Lyndon s \\<longrightarrow> s \\<le>s q\n  Lyndon (LynSuf w)\n  q \\<le>s LynSuf w\n  LynSuf w \\<le>s w\n  (?x = ?y) = (?x \\<le>s ?y \\<and> ?y \\<le>s ?x)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>s. s \\<le>s w \\<and> Lyndon s \\<longrightarrow> s \\<le>s q\n  Lyndon (LynSuf w)\n  q \\<le>s LynSuf w\n  LynSuf w \\<le>s w\n  (?x = ?y) = (?x \\<le>s ?y \\<and> ?y \\<le>s ?x)\n\ngoal (1 subgoal):\n 1. LynSuf w = q", "by blast"], ["proof (state)\nthis:\n  LynSuf w = q\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary longest_Lyndon_sufI': \n  assumes \"q \\<le>s w\" and \"Lyndon q\" and all_s: \"\\<forall> s. (s \\<le>s w \\<and> Lyndon s) \\<longrightarrow> \\<^bold>|s\\<^bold>| \\<le> \\<^bold>|q\\<^bold>|\" \n  shows \"LynSuf w = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LynSuf w = q", "using longest_Lyndon_sufI[OF \\<open>q \\<le>s w\\<close> \\<open>Lyndon q\\<close>] suf_ruler_le all_s \\<open>q \\<le>s w\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>s.\n     s \\<le>s w \\<and> Lyndon s \\<longrightarrow>\n     s \\<le>s q \\<Longrightarrow>\n  LynSuf w = q\n  \\<lbrakk>?ps \\<le>s ?xs; ?qs \\<le>s ?xs;\n   \\<^bold>|?ps\\<^bold>| \\<le> \\<^bold>|?qs\\<^bold>|\\<rbrakk>\n  \\<Longrightarrow> ?ps \\<le>s ?qs\n  \\<forall>s.\n     s \\<le>s w \\<and> Lyndon s \\<longrightarrow>\n     \\<^bold>|s\\<^bold>| \\<le> \\<^bold>|q\\<^bold>|\n  q \\<le>s w\n\ngoal (1 subgoal):\n 1. LynSuf w = q", "by blast"], ["", "text\\<open>The next lemma is fabricated to suit the upcoming definition of longest Lyndon factorization.\\<close>"], ["", "lemma longest_Lyndon_suf_shorter: assumes \"w \\<noteq> \\<epsilon>\" \n  shows \"\\<^bold>|w\\<^sup><\\<inverse>(LynSuf w)\\<^bold>| < \\<^bold>|w\\<^bold>|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>|w\\<^sup><\\<inverse>LynSuf w \\<^bold>| < \\<^bold>|w\\<^bold>|", "using nemp_len[OF longest_Lyndon_suf_nemp[OF \\<open>w \\<noteq> \\<epsilon>\\<close>]] arg_cong[OF rq_suf[OF longest_Lyndon_suf_suf[OF \\<open>w \\<noteq> \\<epsilon>\\<close>]], of length]"], ["proof (prove)\nusing this:\n  \\<^bold>|LynSuf w\\<^bold>| \\<noteq> 0\n  \\<^bold>|w\\<^sup><\\<inverse>LynSuf w  \\<cdot> LynSuf w\\<^bold>| =\n  \\<^bold>|w\\<^bold>|\n\ngoal (1 subgoal):\n 1. \\<^bold>|w\\<^sup><\\<inverse>LynSuf w \\<^bold>| < \\<^bold>|w\\<^bold>|", "unfolding length_append"], ["proof (prove)\nusing this:\n  \\<^bold>|LynSuf w\\<^bold>| \\<noteq> 0\n  \\<^bold>|w\\<^sup><\\<inverse>LynSuf w \\<^bold>| +\n  \\<^bold>|LynSuf w\\<^bold>| =\n  \\<^bold>|w\\<^bold>|\n\ngoal (1 subgoal):\n 1. \\<^bold>|w\\<^sup><\\<inverse>LynSuf w \\<^bold>| < \\<^bold>|w\\<^bold>|", "by linarith"], ["", "section \"Lyndon factorizations\""], ["", "function Lyndon_fac::\"'a list  \\<Rightarrow> 'a list list\" (\"LynFac\")\n  where \"Lyndon_fac w  = (if w \\<noteq> \\<epsilon> then ((Lyndon_fac (w \\<^sup><\\<inverse>(LynSuf w) )) \\<cdot> [LynSuf w]) else \\<epsilon>)\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>w. x = w \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>w wa.\n       w = wa \\<Longrightarrow>\n       (if w \\<noteq> \\<epsilon>\n        then Lyndon_fac_sumC (w\\<^sup><\\<inverse>LynSuf w ) \\<cdot>\n             [LynSuf w]\n        else \\<epsilon>) =\n       (if wa \\<noteq> \\<epsilon>\n        then Lyndon_fac_sumC (wa\\<^sup><\\<inverse>LynSuf wa ) \\<cdot>\n             [LynSuf wa]\n        else \\<epsilon>)", "using longest_Lyndon_suffix.cases"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x = \\<epsilon> \\<Longrightarrow> ?P;\n   \\<And>a w. ?x = a # w \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>w. x = w \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>w wa.\n       w = wa \\<Longrightarrow>\n       (if w \\<noteq> \\<epsilon>\n        then Lyndon_fac_sumC (w\\<^sup><\\<inverse>LynSuf w ) \\<cdot>\n             [LynSuf w]\n        else \\<epsilon>) =\n       (if wa \\<noteq> \\<epsilon>\n        then Lyndon_fac_sumC (wa\\<^sup><\\<inverse>LynSuf wa ) \\<cdot>\n             [LynSuf wa]\n        else \\<epsilon>)", "by blast+"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. Lyndon_fac_dom x", "proof(relation \"measure length\", simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<noteq> \\<epsilon> \\<Longrightarrow>\n       (w\\<^sup><\\<inverse>LynSuf w , w) \\<in> measure length", "show \"\\<And>w. w \\<noteq> \\<epsilon> \\<Longrightarrow> (w\\<^sup><\\<inverse>LynSuf w, w) \\<in> measure length\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<noteq> \\<epsilon> \\<Longrightarrow>\n       (w\\<^sup><\\<inverse>LynSuf w , w) \\<in> measure length", "unfolding measure_def inv_image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<noteq> \\<epsilon> \\<Longrightarrow>\n       (w\\<^sup><\\<inverse>LynSuf w , w)\n       \\<in> {(x, y).\n              (\\<^bold>|x\\<^bold>|, \\<^bold>|y\\<^bold>|) \\<in> less_than}", "using longest_Lyndon_suf_shorter"], ["proof (prove)\nusing this:\n  ?w \\<noteq> \\<epsilon> \\<Longrightarrow>\n  \\<^bold>|?w\\<^sup><\\<inverse>LynSuf ?w \\<^bold>| < \\<^bold>|?w\\<^bold>|\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<noteq> \\<epsilon> \\<Longrightarrow>\n       (w\\<^sup><\\<inverse>LynSuf w , w)\n       \\<in> {(x, y).\n              (\\<^bold>|x\\<^bold>|, \\<^bold>|y\\<^bold>|) \\<in> less_than}", "by blast"], ["proof (state)\nthis:\n  ?w1 \\<noteq> \\<epsilon> \\<Longrightarrow>\n  (?w1\\<^sup><\\<inverse>LynSuf ?w1 , ?w1) \\<in> measure length\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The factorization @{term \"Lyndon_fac w\"} obtained by taking always the longest Lyndon suffix is well defined, \nand called ``Lyndon factorization (of $w$)''.\\<close>"], ["", "lemma Lyndon_fac_simp: \"w \\<noteq> \\<epsilon> \\<Longrightarrow> Lyndon_fac w =  Lyndon_fac (w\\<^sup><\\<inverse>LynSuf w) \\<cdot> (LynSuf w # \\<epsilon>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<noteq> \\<epsilon> \\<Longrightarrow>\n    LynFac w = LynFac (w\\<^sup><\\<inverse>LynSuf w ) \\<cdot> [LynSuf w]", "using Lyndon_fac.simps[of w]"], ["proof (prove)\nusing this:\n  LynFac w =\n  (if w \\<noteq> \\<epsilon>\n   then LynFac (w\\<^sup><\\<inverse>LynSuf w ) \\<cdot> [LynSuf w]\n   else \\<epsilon>)\n\ngoal (1 subgoal):\n 1. w \\<noteq> \\<epsilon> \\<Longrightarrow>\n    LynFac w = LynFac (w\\<^sup><\\<inverse>LynSuf w ) \\<cdot> [LynSuf w]", "by meson"], ["", "lemma Lyndon_fac_emp: \"Lyndon_fac \\<epsilon> = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LynFac \\<epsilon> = \\<epsilon>", "by simp"], ["", "text\\<open>Note that the Lyndon factorization of a Lyndon word is trivial.\\<close>"], ["", "lemma Lyndon_fac_longest_Lyndon_id: \"Lyndon w \\<Longrightarrow> Lyndon_fac w = [w]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon w \\<Longrightarrow> LynFac w = [w]", "by (simp add: longest_Lyndon_suf_Lyndon_id)"], ["", "text\\<open>Lyndon factorization is composed of Lyndon words ...\\<close>"], ["", "lemma Lyndon_fac_set: \"z \\<in> set (Lyndon_fac w) \\<Longrightarrow> Lyndon z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> set (LynFac w) \\<Longrightarrow> Lyndon z", "proof(induction w rule:  Lyndon_fac.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>\\<lbrakk>w \\<noteq> \\<epsilon>;\n                 z \\<in> set (LynFac\n                               (w\\<^sup><\\<inverse>LynSuf w ))\\<rbrakk>\n                \\<Longrightarrow> Lyndon z;\n        z \\<in> set (LynFac w)\\<rbrakk>\n       \\<Longrightarrow> Lyndon z", "case (1 w)"], ["proof (state)\nthis:\n  \\<lbrakk>w \\<noteq> \\<epsilon>;\n   z \\<in> set (LynFac (w\\<^sup><\\<inverse>LynSuf w ))\\<rbrakk>\n  \\<Longrightarrow> Lyndon z\n  z \\<in> set (LynFac w)\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>\\<lbrakk>w \\<noteq> \\<epsilon>;\n                 z \\<in> set (LynFac\n                               (w\\<^sup><\\<inverse>LynSuf w ))\\<rbrakk>\n                \\<Longrightarrow> Lyndon z;\n        z \\<in> set (LynFac w)\\<rbrakk>\n       \\<Longrightarrow> Lyndon z", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>w \\<noteq> \\<epsilon>;\n   z \\<in> set (LynFac (w\\<^sup><\\<inverse>LynSuf w ))\\<rbrakk>\n  \\<Longrightarrow> Lyndon z\n  z \\<in> set (LynFac w)", "show \"Lyndon z\""], ["proof (prove)\nusing this:\n  \\<lbrakk>w \\<noteq> \\<epsilon>;\n   z \\<in> set (LynFac (w\\<^sup><\\<inverse>LynSuf w ))\\<rbrakk>\n  \\<Longrightarrow> Lyndon z\n  z \\<in> set (LynFac w)\n\ngoal (1 subgoal):\n 1. Lyndon z", "proof (cases \"w = \\<epsilon>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>w \\<noteq> \\<epsilon>;\n              z \\<in> set (LynFac (w\\<^sup><\\<inverse>LynSuf w ))\\<rbrakk>\n             \\<Longrightarrow> Lyndon z;\n     z \\<in> set (LynFac w); w = \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> Lyndon z\n 2. \\<lbrakk>\\<lbrakk>w \\<noteq> \\<epsilon>;\n              z \\<in> set (LynFac (w\\<^sup><\\<inverse>LynSuf w ))\\<rbrakk>\n             \\<Longrightarrow> Lyndon z;\n     z \\<in> set (LynFac w); w \\<noteq> \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> Lyndon z", "assume \"w \\<noteq> \\<epsilon>\""], ["proof (state)\nthis:\n  w \\<noteq> \\<epsilon>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>w \\<noteq> \\<epsilon>;\n              z \\<in> set (LynFac (w\\<^sup><\\<inverse>LynSuf w ))\\<rbrakk>\n             \\<Longrightarrow> Lyndon z;\n     z \\<in> set (LynFac w); w = \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> Lyndon z\n 2. \\<lbrakk>\\<lbrakk>w \\<noteq> \\<epsilon>;\n              z \\<in> set (LynFac (w\\<^sup><\\<inverse>LynSuf w ))\\<rbrakk>\n             \\<Longrightarrow> Lyndon z;\n     z \\<in> set (LynFac w); w \\<noteq> \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> Lyndon z", "have \"Lyndon_fac w  = (Lyndon_fac (w \\<^sup><\\<inverse>(LynSuf w) )) \\<cdot> [LynSuf w]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LynFac w = LynFac (w\\<^sup><\\<inverse>LynSuf w ) \\<cdot> [LynSuf w]", "using Lyndon_fac_simp[OF \\<open>w \\<noteq> \\<epsilon>\\<close>]"], ["proof (prove)\nusing this:\n  LynFac w = LynFac (w\\<^sup><\\<inverse>LynSuf w ) \\<cdot> [LynSuf w]\n\ngoal (1 subgoal):\n 1. LynFac w = LynFac (w\\<^sup><\\<inverse>LynSuf w ) \\<cdot> [LynSuf w]", "."], ["proof (state)\nthis:\n  LynFac w = LynFac (w\\<^sup><\\<inverse>LynSuf w ) \\<cdot> [LynSuf w]\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>w \\<noteq> \\<epsilon>;\n              z \\<in> set (LynFac (w\\<^sup><\\<inverse>LynSuf w ))\\<rbrakk>\n             \\<Longrightarrow> Lyndon z;\n     z \\<in> set (LynFac w); w = \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> Lyndon z\n 2. \\<lbrakk>\\<lbrakk>w \\<noteq> \\<epsilon>;\n              z \\<in> set (LynFac (w\\<^sup><\\<inverse>LynSuf w ))\\<rbrakk>\n             \\<Longrightarrow> Lyndon z;\n     z \\<in> set (LynFac w); w \\<noteq> \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> Lyndon z", "from set_ConsD[OF \"1.prems\"(1)[unfolded rotate1.simps(2)[of \"LynSuf w\" \"Lyndon_fac (w \\<^sup><\\<inverse>(LynSuf w) )\", folded this, symmetric], unfolded set_rotate1]]"], ["proof (chain)\npicking this:\n  z = LynSuf w \\<or> z \\<in> set (LynFac (w\\<^sup><\\<inverse>LynSuf w ))", "have \"z = LynSuf w \\<or> z \\<in> set (Lyndon_fac (w \\<^sup><\\<inverse>(LynSuf w) ))\""], ["proof (prove)\nusing this:\n  z = LynSuf w \\<or> z \\<in> set (LynFac (w\\<^sup><\\<inverse>LynSuf w ))\n\ngoal (1 subgoal):\n 1. z = LynSuf w \\<or> z \\<in> set (LynFac (w\\<^sup><\\<inverse>LynSuf w ))", "."], ["proof (state)\nthis:\n  z = LynSuf w \\<or> z \\<in> set (LynFac (w\\<^sup><\\<inverse>LynSuf w ))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>w \\<noteq> \\<epsilon>;\n              z \\<in> set (LynFac (w\\<^sup><\\<inverse>LynSuf w ))\\<rbrakk>\n             \\<Longrightarrow> Lyndon z;\n     z \\<in> set (LynFac w); w = \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> Lyndon z\n 2. \\<lbrakk>\\<lbrakk>w \\<noteq> \\<epsilon>;\n              z \\<in> set (LynFac (w\\<^sup><\\<inverse>LynSuf w ))\\<rbrakk>\n             \\<Longrightarrow> Lyndon z;\n     z \\<in> set (LynFac w); w \\<noteq> \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> Lyndon z", "thus \"Lyndon z\""], ["proof (prove)\nusing this:\n  z = LynSuf w \\<or> z \\<in> set (LynFac (w\\<^sup><\\<inverse>LynSuf w ))\n\ngoal (1 subgoal):\n 1. Lyndon z", "using \"1.IH\"[OF \\<open>w \\<noteq> \\<epsilon>\\<close>] longest_Lyndon_suf_Lyndon[OF \\<open>w \\<noteq> \\<epsilon>\\<close>]"], ["proof (prove)\nusing this:\n  z = LynSuf w \\<or> z \\<in> set (LynFac (w\\<^sup><\\<inverse>LynSuf w ))\n  z \\<in> set (LynFac (w\\<^sup><\\<inverse>LynSuf w )) \\<Longrightarrow>\n  Lyndon z\n  Lyndon (LynSuf w)\n\ngoal (1 subgoal):\n 1. Lyndon z", "by blast"], ["proof (state)\nthis:\n  Lyndon z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>w \\<noteq> \\<epsilon>;\n              z \\<in> set (LynFac (w\\<^sup><\\<inverse>LynSuf w ))\\<rbrakk>\n             \\<Longrightarrow> Lyndon z;\n     z \\<in> set (LynFac w); w = \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> Lyndon z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>w \\<noteq> \\<epsilon>;\n              z \\<in> set (LynFac (w\\<^sup><\\<inverse>LynSuf w ))\\<rbrakk>\n             \\<Longrightarrow> Lyndon z;\n     z \\<in> set (LynFac w); w = \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> Lyndon z", "assume \"w = \\<epsilon>\""], ["proof (state)\nthis:\n  w = \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>w \\<noteq> \\<epsilon>;\n              z \\<in> set (LynFac (w\\<^sup><\\<inverse>LynSuf w ))\\<rbrakk>\n             \\<Longrightarrow> Lyndon z;\n     z \\<in> set (LynFac w); w = \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> Lyndon z", "thus \"Lyndon z\""], ["proof (prove)\nusing this:\n  w = \\<epsilon>\n\ngoal (1 subgoal):\n 1. Lyndon z", "using \"1.prems\""], ["proof (prove)\nusing this:\n  w = \\<epsilon>\n  z \\<in> set (LynFac w)\n\ngoal (1 subgoal):\n 1. Lyndon z", "unfolding Lyndon_fac_emp[folded \\<open>w = \\<epsilon>\\<close>] list.set(1) empty_iff"], ["proof (prove)\nusing this:\n  w = \\<epsilon>\n  False\n\ngoal (1 subgoal):\n 1. Lyndon z", "by blast"], ["proof (state)\nthis:\n  Lyndon z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Lyndon z\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>...and it indeed is a factorization of the argument.\\<close>"], ["", "lemma Lyndon_fac_longest_dec: \"concat (Lyndon_fac w) = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (LynFac w) = w", "proof(induction w rule: Lyndon_fac.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w.\n       (w \\<noteq> \\<epsilon> \\<Longrightarrow>\n        concat (LynFac (w\\<^sup><\\<inverse>LynSuf w )) =\n        w\\<^sup><\\<inverse>LynSuf w ) \\<Longrightarrow>\n       concat (LynFac w) = w", "case (1 w)"], ["proof (state)\nthis:\n  w \\<noteq> \\<epsilon> \\<Longrightarrow>\n  concat (LynFac (w\\<^sup><\\<inverse>LynSuf w )) =\n  w\\<^sup><\\<inverse>LynSuf w \n\ngoal (1 subgoal):\n 1. \\<And>w.\n       (w \\<noteq> \\<epsilon> \\<Longrightarrow>\n        concat (LynFac (w\\<^sup><\\<inverse>LynSuf w )) =\n        w\\<^sup><\\<inverse>LynSuf w ) \\<Longrightarrow>\n       concat (LynFac w) = w", "thus \"concat (LynFac w) = w\""], ["proof (prove)\nusing this:\n  w \\<noteq> \\<epsilon> \\<Longrightarrow>\n  concat (LynFac (w\\<^sup><\\<inverse>LynSuf w )) =\n  w\\<^sup><\\<inverse>LynSuf w \n\ngoal (1 subgoal):\n 1. concat (LynFac w) = w", "proof (cases \"w = \\<epsilon>\", simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> \\<epsilon> \\<Longrightarrow>\n             concat (LynFac (w\\<^sup><\\<inverse>LynSuf w )) =\n             w\\<^sup><\\<inverse>LynSuf w ;\n     w \\<noteq> \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> concat (LynFac w) = w", "assume \"w \\<noteq> \\<epsilon>\""], ["proof (state)\nthis:\n  w \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> \\<epsilon> \\<Longrightarrow>\n             concat (LynFac (w\\<^sup><\\<inverse>LynSuf w )) =\n             w\\<^sup><\\<inverse>LynSuf w ;\n     w \\<noteq> \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> concat (LynFac w) = w", "have eq: \"concat (Lyndon_fac w) = concat ( (Lyndon_fac (w \\<^sup><\\<inverse>(LynSuf w) )) ) \\<cdot> concat ([LynSuf w])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (LynFac w) =\n    concat (LynFac (w\\<^sup><\\<inverse>LynSuf w )) \\<cdot> concat [LynSuf w]", "unfolding Lyndon_fac_simp[OF \\<open>w \\<noteq> \\<epsilon>\\<close>] concat_morph"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (LynFac (w\\<^sup><\\<inverse>LynSuf w ) \\<cdot> [LynSuf w]) =\n    concat (LynFac (w\\<^sup><\\<inverse>LynSuf w ) \\<cdot> [LynSuf w])", ".."], ["proof (state)\nthis:\n  concat (LynFac w) =\n  concat (LynFac (w\\<^sup><\\<inverse>LynSuf w )) \\<cdot> concat [LynSuf w]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<noteq> \\<epsilon> \\<Longrightarrow>\n             concat (LynFac (w\\<^sup><\\<inverse>LynSuf w )) =\n             w\\<^sup><\\<inverse>LynSuf w ;\n     w \\<noteq> \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> concat (LynFac w) = w", "from this[unfolded \"1.IH\"[OF \\<open>w \\<noteq> \\<epsilon>\\<close>] concat_sing' rq_suf[OF longest_Lyndon_suf_suf[OF \\<open>w \\<noteq> \\<epsilon>\\<close>]]]"], ["proof (chain)\npicking this:\n  concat (LynFac w) = w", "show ?case"], ["proof (prove)\nusing this:\n  concat (LynFac w) = w\n\ngoal (1 subgoal):\n 1. concat (LynFac w) = w", "."], ["proof (state)\nthis:\n  concat (LynFac w) = w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  concat (LynFac w) = w\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>The following lemma makes explicit the inductive character of the definition of @{term Lyndon_fac}.\\<close>"], ["", "lemma Lyndon_fac_longest_pref: \"us \\<le>p Lyndon_fac w \\<Longrightarrow> Lyndon_fac (concat us) = us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. us \\<le>p LynFac w \\<Longrightarrow> LynFac (concat us) = us", "proof(induction w arbitrary: us rule:  Lyndon_fac.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w us.\n       \\<lbrakk>\\<And>us.\n                   \\<lbrakk>w \\<noteq> \\<epsilon>;\n                    us \\<le>p LynFac (w\\<^sup><\\<inverse>LynSuf w )\\<rbrakk>\n                   \\<Longrightarrow> LynFac (concat us) = us;\n        us \\<le>p LynFac w\\<rbrakk>\n       \\<Longrightarrow> LynFac (concat us) = us", "case (1 w)"], ["proof (state)\nthis:\n  \\<lbrakk>w \\<noteq> \\<epsilon>;\n   ?us1 \\<le>p LynFac (w\\<^sup><\\<inverse>LynSuf w )\\<rbrakk>\n  \\<Longrightarrow> LynFac (concat ?us1) = ?us1\n  us \\<le>p LynFac w\n\ngoal (1 subgoal):\n 1. \\<And>w us.\n       \\<lbrakk>\\<And>us.\n                   \\<lbrakk>w \\<noteq> \\<epsilon>;\n                    us \\<le>p LynFac (w\\<^sup><\\<inverse>LynSuf w )\\<rbrakk>\n                   \\<Longrightarrow> LynFac (concat us) = us;\n        us \\<le>p LynFac w\\<rbrakk>\n       \\<Longrightarrow> LynFac (concat us) = us", "thus \"LynFac (concat us) = us\""], ["proof (prove)\nusing this:\n  \\<lbrakk>w \\<noteq> \\<epsilon>;\n   ?us1 \\<le>p LynFac (w\\<^sup><\\<inverse>LynSuf w )\\<rbrakk>\n  \\<Longrightarrow> LynFac (concat ?us1) = ?us1\n  us \\<le>p LynFac w\n\ngoal (1 subgoal):\n 1. LynFac (concat us) = us", "proof (cases \"w = \\<epsilon>\", simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>us.\n                \\<lbrakk>w \\<noteq> \\<epsilon>;\n                 us \\<le>p LynFac (w\\<^sup><\\<inverse>LynSuf w )\\<rbrakk>\n                \\<Longrightarrow> LynFac (concat us) = us;\n     us \\<le>p LynFac w; w \\<noteq> \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> LynFac (concat us) = us", "assume \"w \\<noteq> \\<epsilon>\""], ["proof (state)\nthis:\n  w \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>us.\n                \\<lbrakk>w \\<noteq> \\<epsilon>;\n                 us \\<le>p LynFac (w\\<^sup><\\<inverse>LynSuf w )\\<rbrakk>\n                \\<Longrightarrow> LynFac (concat us) = us;\n     us \\<le>p LynFac w; w \\<noteq> \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> LynFac (concat us) = us", "have step: \"Lyndon_fac w = (Lyndon_fac (w \\<^sup><\\<inverse>(LynSuf w))) \\<cdot> [LynSuf w]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LynFac w = LynFac (w\\<^sup><\\<inverse>LynSuf w ) \\<cdot> [LynSuf w]", "using Lyndon_fac_simp[OF \\<open>w \\<noteq> \\<epsilon>\\<close>]"], ["proof (prove)\nusing this:\n  LynFac w = LynFac (w\\<^sup><\\<inverse>LynSuf w ) \\<cdot> [LynSuf w]\n\ngoal (1 subgoal):\n 1. LynFac w = LynFac (w\\<^sup><\\<inverse>LynSuf w ) \\<cdot> [LynSuf w]", "."], ["proof (state)\nthis:\n  LynFac w = LynFac (w\\<^sup><\\<inverse>LynSuf w ) \\<cdot> [LynSuf w]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>us.\n                \\<lbrakk>w \\<noteq> \\<epsilon>;\n                 us \\<le>p LynFac (w\\<^sup><\\<inverse>LynSuf w )\\<rbrakk>\n                \\<Longrightarrow> LynFac (concat us) = us;\n     us \\<le>p LynFac w; w \\<noteq> \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> LynFac (concat us) = us", "consider (neq) \"us \\<noteq> Lyndon_fac w\" | (eq) \"us = Lyndon_fac w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>us \\<noteq> LynFac w \\<Longrightarrow> thesis;\n     us = LynFac w \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using \"1.prems\" le_neq_implies_less"], ["proof (prove)\nusing this:\n  us \\<le>p LynFac w\n  \\<lbrakk>?m \\<le> ?n; ?m \\<noteq> ?n\\<rbrakk> \\<Longrightarrow> ?m < ?n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>us \\<noteq> LynFac w \\<Longrightarrow> thesis;\n     us = LynFac w \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>us \\<noteq> LynFac w \\<Longrightarrow> ?thesis1;\n   us = LynFac w \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>us.\n                \\<lbrakk>w \\<noteq> \\<epsilon>;\n                 us \\<le>p LynFac (w\\<^sup><\\<inverse>LynSuf w )\\<rbrakk>\n                \\<Longrightarrow> LynFac (concat us) = us;\n     us \\<le>p LynFac w; w \\<noteq> \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> LynFac (concat us) = us", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>us \\<noteq> LynFac w \\<Longrightarrow> ?thesis1;\n   us = LynFac w \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1", "show \"LynFac (concat us) = us\""], ["proof (prove)\nusing this:\n  \\<lbrakk>us \\<noteq> LynFac w \\<Longrightarrow> ?thesis1;\n   us = LynFac w \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. LynFac (concat us) = us", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. us \\<noteq> LynFac w \\<Longrightarrow> LynFac (concat us) = us\n 2. us = LynFac w \\<Longrightarrow> LynFac (concat us) = us", "case neq"], ["proof (state)\nthis:\n  us \\<noteq> LynFac w\n\ngoal (2 subgoals):\n 1. us \\<noteq> LynFac w \\<Longrightarrow> LynFac (concat us) = us\n 2. us = LynFac w \\<Longrightarrow> LynFac (concat us) = us", "hence \"us \\<le>p Lyndon_fac (w\\<^sup><\\<inverse>LynSuf w)\""], ["proof (prove)\nusing this:\n  us \\<noteq> LynFac w\n\ngoal (1 subgoal):\n 1. us \\<le>p LynFac (w\\<^sup><\\<inverse>LynSuf w )", "using \"1.prems\" last_no_split[of us \"Lyndon_fac (w\\<^sup><\\<inverse>LynSuf w)\" \"LynSuf w\"]"], ["proof (prove)\nusing this:\n  us \\<noteq> LynFac w\n  us \\<le>p LynFac w\n  (us \\<le>p LynFac (w\\<^sup><\\<inverse>LynSuf w ) \\<cdot> [LynSuf w]) =\n  (us = LynFac (w\\<^sup><\\<inverse>LynSuf w ) \\<cdot> [LynSuf w] \\<or>\n   us \\<le>p LynFac (w\\<^sup><\\<inverse>LynSuf w ))\n\ngoal (1 subgoal):\n 1. us \\<le>p LynFac (w\\<^sup><\\<inverse>LynSuf w )", "unfolding step[symmetric]"], ["proof (prove)\nusing this:\n  us \\<noteq> LynFac w\n  us \\<le>p LynFac w\n  (us \\<le>p LynFac w) =\n  (us = LynFac w \\<or> us \\<le>p LynFac (w\\<^sup><\\<inverse>LynSuf w ))\n\ngoal (1 subgoal):\n 1. us \\<le>p LynFac (w\\<^sup><\\<inverse>LynSuf w )", "by blast"], ["proof (state)\nthis:\n  us \\<le>p LynFac (w\\<^sup><\\<inverse>LynSuf w )\n\ngoal (2 subgoals):\n 1. us \\<noteq> LynFac w \\<Longrightarrow> LynFac (concat us) = us\n 2. us = LynFac w \\<Longrightarrow> LynFac (concat us) = us", "thus \"LynFac (concat us) = us\""], ["proof (prove)\nusing this:\n  us \\<le>p LynFac (w\\<^sup><\\<inverse>LynSuf w )\n\ngoal (1 subgoal):\n 1. LynFac (concat us) = us", "using \"1.IH\" \\<open>w \\<noteq> \\<epsilon>\\<close>"], ["proof (prove)\nusing this:\n  us \\<le>p LynFac (w\\<^sup><\\<inverse>LynSuf w )\n  \\<lbrakk>w \\<noteq> \\<epsilon>;\n   ?us1 \\<le>p LynFac (w\\<^sup><\\<inverse>LynSuf w )\\<rbrakk>\n  \\<Longrightarrow> LynFac (concat ?us1) = ?us1\n  w \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. LynFac (concat us) = us", "by blast"], ["proof (state)\nthis:\n  LynFac (concat us) = us\n\ngoal (1 subgoal):\n 1. us = LynFac w \\<Longrightarrow> LynFac (concat us) = us", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. us = LynFac w \\<Longrightarrow> LynFac (concat us) = us", "case eq"], ["proof (state)\nthis:\n  us = LynFac w\n\ngoal (1 subgoal):\n 1. us = LynFac w \\<Longrightarrow> LynFac (concat us) = us", "show \"LynFac (concat us) = us\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LynFac (concat us) = us", "using Lyndon_fac_longest_dec[of w, folded eq] eq"], ["proof (prove)\nusing this:\n  concat us = w\n  us = LynFac w\n\ngoal (1 subgoal):\n 1. LynFac (concat us) = us", "by simp"], ["proof (state)\nthis:\n  LynFac (concat us) = us\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LynFac (concat us) = us\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  LynFac (concat us) = us\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>We give name to an important predicate: monotone (nonincreasing) list of Lyndon words.\\<close>"], ["", "definition Lyndon_mono :: \"'a list list \\<Rightarrow>  bool\" where\n  \"Lyndon_mono ws \\<longleftrightarrow> (\\<forall> u \\<in> set ws. Lyndon u) \\<and> (rlex.sorted (rev ws))\""], ["", "lemma Lyndon_mono_set: \"Lyndon_mono ws \\<Longrightarrow> u \\<in> set ws \\<Longrightarrow> Lyndon u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Lyndon_mono ws; u \\<in> set ws\\<rbrakk>\n    \\<Longrightarrow> Lyndon u", "unfolding Lyndon_mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ball (set ws) Lyndon \\<and>\n             linorder.sorted lexordp_eq (rev ws);\n     u \\<in> set ws\\<rbrakk>\n    \\<Longrightarrow> Lyndon u", "by blast"], ["", "lemma Lyndon_mono_sorted: \"Lyndon_mono ws \\<Longrightarrow> rlex.sorted (rev ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon_mono ws \\<Longrightarrow> linorder.sorted (\\<le>lex) (rev ws)", "unfolding Lyndon_mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set ws) Lyndon \\<and>\n    linorder.sorted lexordp_eq (rev ws) \\<Longrightarrow>\n    linorder.sorted (\\<le>lex) (rev ws)", "by blast"], ["", "lemma Lyndon_mono_nth: \"Lyndon_mono ws \\<Longrightarrow> i \\<le> j \\<Longrightarrow> j < \\<^bold>|ws\\<^bold>| \\<Longrightarrow> ws!j \\<le>lex ws!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Lyndon_mono ws; i \\<le> j; j < \\<^bold>|ws\\<^bold>|\\<rbrakk>\n    \\<Longrightarrow> ws ! j \\<le>lex ws ! i", "unfolding Lyndon_mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Ball (set ws) Lyndon \\<and>\n             linorder.sorted lexordp_eq (rev ws);\n     i \\<le> j; j < \\<^bold>|ws\\<^bold>|\\<rbrakk>\n    \\<Longrightarrow> ws ! j \\<le>lex ws ! i", "using  rlex.sorted_rev_nth_mono"], ["proof (prove)\nusing this:\n  \\<lbrakk>linorder.sorted (\\<le>lex) (rev ?xs); ?i \\<le> ?j;\n   ?j < \\<^bold>|?xs\\<^bold>|\\<rbrakk>\n  \\<Longrightarrow> ?xs ! ?j \\<le>lex ?xs ! ?i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Ball (set ws) Lyndon \\<and>\n             linorder.sorted lexordp_eq (rev ws);\n     i \\<le> j; j < \\<^bold>|ws\\<^bold>|\\<rbrakk>\n    \\<Longrightarrow> ws ! j \\<le>lex ws ! i", "by blast"], ["", "lemma Lyndon_mono_empty[simp]: \"Lyndon_mono \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon_mono \\<epsilon>", "unfolding Lyndon_mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set \\<epsilon>) Lyndon \\<and>\n    linorder.sorted lexordp_eq (rev \\<epsilon>)", "by auto"], ["", "lemma Lyndon_mono_sing: \"Lyndon u \\<Longrightarrow> Lyndon_mono [u]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon u \\<Longrightarrow> Lyndon_mono [u]", "unfolding Lyndon_mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon u \\<Longrightarrow>\n    Ball (set [u]) Lyndon \\<and> linorder.sorted lexordp_eq (rev [u])", "by auto"], ["", "lemma Lyndon_mono_fac_Lyndon_mono: \n  assumes \"ps \\<le>f ws\" and \"Lyndon_mono ws\" shows \"Lyndon_mono ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon_mono ps", "unfolding Lyndon_mono_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set ps) Lyndon \\<and> linorder.sorted lexordp_eq (rev ps)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. Ball (set ps) Lyndon\n 2. linorder.sorted lexordp_eq (rev ps)", "show \"\\<forall>x \\<in> (set ps). Lyndon x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set ps. Lyndon x", "using \\<open>Lyndon_mono ws\\<close>[unfolded Lyndon_mono_def] set_mono_sublist[OF \\<open>ps \\<le>f ws\\<close>]"], ["proof (prove)\nusing this:\n  Ball (set ws) Lyndon \\<and> linorder.sorted lexordp_eq (rev ws)\n  set ps \\<subseteq> set ws\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set ps. Lyndon x", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set ps. Lyndon x\n\ngoal (1 subgoal):\n 1. linorder.sorted lexordp_eq (rev ps)", "show \"linorder.sorted (\\<le>lex) (rev ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder.sorted (\\<le>lex) (rev ps)", "using rlex.sorted_append \\<open>Lyndon_mono ws\\<close>[unfolded Lyndon_mono_def] \\<open>ps \\<le>f ws\\<close>[unfolded sublist_def]"], ["proof (prove)\nusing this:\n  linorder.sorted (\\<le>lex) (?xs \\<cdot> ?ys) =\n  (linorder.sorted (\\<le>lex) ?xs \\<and>\n   linorder.sorted (\\<le>lex) ?ys \\<and>\n   (\\<forall>x\\<in>set ?xs. \\<forall>y\\<in>set ?ys. x \\<le>lex y))\n  Ball (set ws) Lyndon \\<and> linorder.sorted lexordp_eq (rev ws)\n  \\<exists>psa ss. ws = psa \\<cdot> ps \\<cdot> ss\n\ngoal (1 subgoal):\n 1. linorder.sorted (\\<le>lex) (rev ps)", "by fastforce"], ["proof (state)\nthis:\n  linorder.sorted (\\<le>lex) (rev ps)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Lyndon factorization is monotone! \nAltogether, we have shown that the Lyndon factorization is a monotone factorization \ninto Lyndon words.\\<close>"], ["", "theorem fac_Lyndon_mono: \"Lyndon_mono (Lyndon_fac w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon_mono (LynFac w)", "proof (induct \"Lyndon_fac w\" arbitrary: w rule: rev_induct, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs w.\n       \\<lbrakk>\\<And>w.\n                   xs = LynFac w \\<Longrightarrow> Lyndon_mono (LynFac w);\n        xs \\<cdot> [x] = LynFac w\\<rbrakk>\n       \\<Longrightarrow> Lyndon_mono (LynFac w)", "case (snoc x xs)"], ["proof (state)\nthis:\n  xs = LynFac ?w1 \\<Longrightarrow> Lyndon_mono (LynFac ?w1)\n  xs \\<cdot> [x] = LynFac w\n\ngoal (1 subgoal):\n 1. \\<And>x xs w.\n       \\<lbrakk>\\<And>w.\n                   xs = LynFac w \\<Longrightarrow> Lyndon_mono (LynFac w);\n        xs \\<cdot> [x] = LynFac w\\<rbrakk>\n       \\<Longrightarrow> Lyndon_mono (LynFac w)", "have \"Lyndon x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon x", "using Lyndon_fac_set[of x, unfolded in_set_conv_decomp, of w, folded snoc.hyps(2)]"], ["proof (prove)\nusing this:\n  \\<exists>ys zs. xs \\<cdot> [x] = ys \\<cdot> x # zs \\<Longrightarrow>\n  Lyndon x\n\ngoal (1 subgoal):\n 1. Lyndon x", "by fast"], ["proof (state)\nthis:\n  Lyndon x\n\ngoal (1 subgoal):\n 1. \\<And>x xs w.\n       \\<lbrakk>\\<And>w.\n                   xs = LynFac w \\<Longrightarrow> Lyndon_mono (LynFac w);\n        xs \\<cdot> [x] = LynFac w\\<rbrakk>\n       \\<Longrightarrow> Lyndon_mono (LynFac w)", "have \"concat (xs \\<cdot> [x]) = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (xs \\<cdot> [x]) = w", "using Lyndon_fac_longest_dec[of w, folded snoc.hyps(2)]"], ["proof (prove)\nusing this:\n  concat (xs \\<cdot> [x]) = w\n\ngoal (1 subgoal):\n 1. concat (xs \\<cdot> [x]) = w", "by auto"], ["proof (state)\nthis:\n  concat (xs \\<cdot> [x]) = w\n\ngoal (1 subgoal):\n 1. \\<And>x xs w.\n       \\<lbrakk>\\<And>w.\n                   xs = LynFac w \\<Longrightarrow> Lyndon_mono (LynFac w);\n        xs \\<cdot> [x] = LynFac w\\<rbrakk>\n       \\<Longrightarrow> Lyndon_mono (LynFac w)", "then"], ["proof (chain)\npicking this:\n  concat (xs \\<cdot> [x]) = w", "show \"Lyndon_mono (LynFac w)\""], ["proof (prove)\nusing this:\n  concat (xs \\<cdot> [x]) = w\n\ngoal (1 subgoal):\n 1. Lyndon_mono (LynFac w)", "proof (cases \"xs = \\<epsilon>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>concat (xs \\<cdot> [x]) = w; xs = \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> Lyndon_mono (LynFac w)\n 2. \\<lbrakk>concat (xs \\<cdot> [x]) = w; xs \\<noteq> \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> Lyndon_mono (LynFac w)", "assume \"xs = \\<epsilon>\""], ["proof (state)\nthis:\n  xs = \\<epsilon>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>concat (xs \\<cdot> [x]) = w; xs = \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> Lyndon_mono (LynFac w)\n 2. \\<lbrakk>concat (xs \\<cdot> [x]) = w; xs \\<noteq> \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> Lyndon_mono (LynFac w)", "show \"Lyndon_mono (LynFac w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon_mono (LynFac w)", "unfolding Lyndon_mono_def \\<open>xs \\<cdot> [x] = LynFac w\\<close>[symmetric] \\<open>xs = \\<epsilon>\\<close> append.left_neutral \n                rlex.sorted1[of x]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set [x]) Lyndon \\<and> linorder.sorted lexordp_eq (rev [x])", "using \\<open>Lyndon x\\<close>"], ["proof (prove)\nusing this:\n  Lyndon x\n\ngoal (1 subgoal):\n 1. Ball (set [x]) Lyndon \\<and> linorder.sorted lexordp_eq (rev [x])", "by force"], ["proof (state)\nthis:\n  Lyndon_mono (LynFac w)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>concat (xs \\<cdot> [x]) = w; xs \\<noteq> \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> Lyndon_mono (LynFac w)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>concat (xs \\<cdot> [x]) = w; xs \\<noteq> \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> Lyndon_mono (LynFac w)", "assume \"xs \\<noteq> \\<epsilon>\""], ["proof (state)\nthis:\n  xs \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>concat (xs \\<cdot> [x]) = w; xs \\<noteq> \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> Lyndon_mono (LynFac w)", "have \"concat (xs \\<cdot> [x]) \\<noteq> \\<epsilon>\" and \"w \\<noteq> \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (xs \\<cdot> [x]) \\<noteq> \\<epsilon> &&& w \\<noteq> \\<epsilon>", "using Lyndon_fac_longest_dec snoc.hyps(2)"], ["proof (prove)\nusing this:\n  concat (LynFac ?w) = ?w\n  xs \\<cdot> [x] = LynFac w\n\ngoal (1 subgoal):\n 1. concat (xs \\<cdot> [x]) \\<noteq> \\<epsilon> &&& w \\<noteq> \\<epsilon>", "by auto"], ["proof (state)\nthis:\n  concat (xs \\<cdot> [x]) \\<noteq> \\<epsilon>\n  w \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>concat (xs \\<cdot> [x]) = w; xs \\<noteq> \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> Lyndon_mono (LynFac w)", "have \"x = LynSuf w\" and \"xs = LynFac (w\\<^sup><\\<inverse>LynSuf w )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = LynSuf w &&& xs = LynFac (w\\<^sup><\\<inverse>LynSuf w )", "using Lyndon_fac.simps[of w, folded snoc.hyps(2)] \\<open>w \\<noteq> \\<epsilon>\\<close>\n        Lyndon_fac_longest_dec append1_eq_conv[of xs x \"LynFac (w\\<^sup><\\<inverse>LynSuf w )\" \"LynSuf w\"]"], ["proof (prove)\nusing this:\n  xs \\<cdot> [x] =\n  (if w \\<noteq> \\<epsilon>\n   then LynFac (w\\<^sup><\\<inverse>LynSuf w ) \\<cdot> [LynSuf w]\n   else \\<epsilon>)\n  w \\<noteq> \\<epsilon>\n  concat (LynFac ?w) = ?w\n  (xs \\<cdot> [x] =\n   LynFac (w\\<^sup><\\<inverse>LynSuf w ) \\<cdot> [LynSuf w]) =\n  (xs = LynFac (w\\<^sup><\\<inverse>LynSuf w ) \\<and> x = LynSuf w)\n\ngoal (1 subgoal):\n 1. x = LynSuf w &&& xs = LynFac (w\\<^sup><\\<inverse>LynSuf w )", "by presburger+"], ["proof (state)\nthis:\n  x = LynSuf w\n  xs = LynFac (w\\<^sup><\\<inverse>LynSuf w )\n\ngoal (1 subgoal):\n 1. \\<lbrakk>concat (xs \\<cdot> [x]) = w; xs \\<noteq> \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> Lyndon_mono (LynFac w)", "from Lyndon_mono_sorted[OF snoc.hyps(1)[OF \\<open>xs = LynFac (w\\<^sup><\\<inverse>LynSuf w )\\<close>], folded this]"], ["proof (chain)\npicking this:\n  linorder.sorted (\\<le>lex) (rev xs)", "have \"dual_rlex.sorted  xs\""], ["proof (prove)\nusing this:\n  linorder.sorted (\\<le>lex) (rev xs)\n\ngoal (1 subgoal):\n 1. linorder.sorted (\\<lambda>x y. y \\<le>lex x) xs", "unfolding sorted_dual_rev_iff"], ["proof (prove)\nusing this:\n  linorder.sorted (\\<le>lex) (rev xs)\n\ngoal (1 subgoal):\n 1. linorder.sorted lexordp_eq (rev xs)", "."], ["proof (state)\nthis:\n  linorder.sorted (\\<lambda>x y. y \\<le>lex x) xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>concat (xs \\<cdot> [x]) = w; xs \\<noteq> \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> Lyndon_mono (LynFac w)", "have \"Lyndon (last xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon (last xs)", "using Lyndon_fac_set[of \"last xs\" \"w\\<^sup><\\<inverse>LynSuf w\", folded \\<open>xs = LynFac (w\\<^sup><\\<inverse>LynSuf w)\\<close>, OF last_in_set[OF \\<open>xs \\<noteq> \\<epsilon>\\<close>]]"], ["proof (prove)\nusing this:\n  Lyndon (last xs)\n\ngoal (1 subgoal):\n 1. Lyndon (last xs)", "."], ["proof (state)\nthis:\n  Lyndon (last xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>concat (xs \\<cdot> [x]) = w; xs \\<noteq> \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> Lyndon_mono (LynFac w)", "have \"x \\<le>lex last xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le>lex last xs", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x \\<le>lex last xs \\<Longrightarrow> False", "assume \"\\<not> x \\<le>lex last xs\""], ["proof (state)\nthis:\n  \\<not> x \\<le>lex last xs\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le>lex last xs \\<Longrightarrow> False", "hence \"last xs <lex x\""], ["proof (prove)\nusing this:\n  \\<not> x \\<le>lex last xs\n\ngoal (1 subgoal):\n 1. last xs <lex x", "by auto"], ["proof (state)\nthis:\n  last xs <lex x\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le>lex last xs \\<Longrightarrow> False", "from Lyndon_concat[OF  \\<open>Lyndon (last xs)\\<close> \\<open>Lyndon x\\<close> this]"], ["proof (chain)\npicking this:\n  Lyndon (last xs \\<cdot> x)", "have \"Lyndon ((last xs) \\<cdot> x)\""], ["proof (prove)\nusing this:\n  Lyndon (last xs \\<cdot> x)\n\ngoal (1 subgoal):\n 1. Lyndon (last xs \\<cdot> x)", "."], ["proof (state)\nthis:\n  Lyndon (last xs \\<cdot> x)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le>lex last xs \\<Longrightarrow> False", "have \"(last xs) \\<cdot> x \\<le>s concat (xs \\<cdot> [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last xs \\<cdot> x \\<le>s concat (xs \\<cdot> [x])", "using \\<open>xs \\<noteq> \\<epsilon>\\<close> concat_last_suf"], ["proof (prove)\nusing this:\n  xs \\<noteq> \\<epsilon>\n  ?ws \\<noteq> \\<epsilon> \\<Longrightarrow> last ?ws \\<le>s concat ?ws\n\ngoal (1 subgoal):\n 1. last xs \\<cdot> x \\<le>s concat (xs \\<cdot> [x])", "by auto"], ["proof (state)\nthis:\n  last xs \\<cdot> x \\<le>s concat (xs \\<cdot> [x])\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le>lex last xs \\<Longrightarrow> False", "from longest_Lyndon_suf_longest[OF \\<open>concat (xs \\<cdot> [x]) \\<noteq> \\<epsilon>\\<close>  this \\<open>Lyndon ((last xs) \\<cdot> x)\\<close>, \n          unfolded \\<open>concat (xs \\<cdot> [x]) = w\\<close>, folded \\<open>x = LynSuf w\\<close>]"], ["proof (chain)\npicking this:\n  \\<^bold>|last xs \\<cdot> x\\<^bold>| \\<le> \\<^bold>|x\\<^bold>|", "show False"], ["proof (prove)\nusing this:\n  \\<^bold>|last xs \\<cdot> x\\<^bold>| \\<le> \\<^bold>|x\\<^bold>|\n\ngoal (1 subgoal):\n 1. False", "using \\<open>Lyndon (last xs)\\<close>"], ["proof (prove)\nusing this:\n  \\<^bold>|last xs \\<cdot> x\\<^bold>| \\<le> \\<^bold>|x\\<^bold>|\n  Lyndon (last xs)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<le>lex last xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>concat (xs \\<cdot> [x]) = w; xs \\<noteq> \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> Lyndon_mono (LynFac w)", "have \"dual_rlex.sorted (butlast xs \\<cdot> [last xs])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linorder.sorted (\\<lambda>x y. y \\<le>lex x)\n     (butlast xs \\<cdot> [last xs])", "by (simp add: \\<open>linorder.sorted (\\<lambda>x y. y \\<le>lex x) xs\\<close> \\<open>xs \\<noteq> \\<epsilon>\\<close>)"], ["proof (state)\nthis:\n  linorder.sorted (\\<lambda>x y. y \\<le>lex x)\n   (butlast xs \\<cdot> [last xs])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>concat (xs \\<cdot> [x]) = w; xs \\<noteq> \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> Lyndon_mono (LynFac w)", "from this \\<open>x \\<le>lex last xs\\<close>"], ["proof (chain)\npicking this:\n  linorder.sorted (\\<lambda>x y. y \\<le>lex x)\n   (butlast xs \\<cdot> [last xs])\n  x \\<le>lex last xs", "have \"dual_rlex.sorted (butlast xs \\<cdot> [last xs,x])\""], ["proof (prove)\nusing this:\n  linorder.sorted (\\<lambda>x y. y \\<le>lex x)\n   (butlast xs \\<cdot> [last xs])\n  x \\<le>lex last xs\n\ngoal (1 subgoal):\n 1. linorder.sorted (\\<lambda>x y. y \\<le>lex x)\n     (butlast xs \\<cdot> [last xs, x])", "using dual_rlex.sorted_append"], ["proof (prove)\nusing this:\n  linorder.sorted (\\<lambda>x y. y \\<le>lex x)\n   (butlast xs \\<cdot> [last xs])\n  x \\<le>lex last xs\n  linorder.sorted (\\<lambda>x y. y \\<le>lex x) (?xs \\<cdot> ?ys) =\n  (linorder.sorted (\\<lambda>x y. y \\<le>lex x) ?xs \\<and>\n   linorder.sorted (\\<lambda>x y. y \\<le>lex x) ?ys \\<and>\n   (\\<forall>x\\<in>set ?xs. \\<forall>y\\<in>set ?ys. y \\<le>lex x))\n\ngoal (1 subgoal):\n 1. linorder.sorted (\\<lambda>x y. y \\<le>lex x)\n     (butlast xs \\<cdot> [last xs, x])", "by auto"], ["proof (state)\nthis:\n  linorder.sorted (\\<lambda>x y. y \\<le>lex x)\n   (butlast xs \\<cdot> [last xs, x])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>concat (xs \\<cdot> [x]) = w; xs \\<noteq> \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> Lyndon_mono (LynFac w)", "from this[unfolded hd_word[of \"last xs\" \"[x]\"] lassoc append_butlast_last_id[OF \\<open>xs \\<noteq> \\<epsilon>\\<close>]]"], ["proof (chain)\npicking this:\n  linorder.sorted (\\<lambda>x y. y \\<le>lex x) (xs \\<cdot> [x])", "have \"rlex.sorted (rev (LynFac w))\""], ["proof (prove)\nusing this:\n  linorder.sorted (\\<lambda>x y. y \\<le>lex x) (xs \\<cdot> [x])\n\ngoal (1 subgoal):\n 1. linorder.sorted (\\<le>lex) (rev (LynFac w))", "unfolding  \\<open>xs \\<cdot> [x] = LynFac w\\<close>[symmetric] sorted_dual_rev_iff[symmetric]"], ["proof (prove)\nusing this:\n  linorder.sorted (\\<lambda>x y. y \\<le>lex x) (xs \\<cdot> [x])\n\ngoal (1 subgoal):\n 1. linorder.sorted (\\<lambda>x y. y \\<le>lex x) (xs \\<cdot> [x])", "."], ["proof (state)\nthis:\n  linorder.sorted (\\<le>lex) (rev (LynFac w))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>concat (xs \\<cdot> [x]) = w; xs \\<noteq> \\<epsilon>\\<rbrakk>\n    \\<Longrightarrow> Lyndon_mono (LynFac w)", "thus \"Lyndon_mono (LynFac w)\""], ["proof (prove)\nusing this:\n  linorder.sorted (\\<le>lex) (rev (LynFac w))\n\ngoal (1 subgoal):\n 1. Lyndon_mono (LynFac w)", "unfolding Lyndon_mono_def"], ["proof (prove)\nusing this:\n  linorder.sorted (\\<le>lex) (rev (LynFac w))\n\ngoal (1 subgoal):\n 1. Ball (set (LynFac w)) Lyndon \\<and>\n    linorder.sorted lexordp_eq (rev (LynFac w))", "using Lyndon_fac_set"], ["proof (prove)\nusing this:\n  linorder.sorted (\\<le>lex) (rev (LynFac w))\n  ?z \\<in> set (LynFac ?w) \\<Longrightarrow> Lyndon ?z\n\ngoal (1 subgoal):\n 1. Ball (set (LynFac w)) Lyndon \\<and>\n    linorder.sorted lexordp_eq (rev (LynFac w))", "by blast"], ["proof (state)\nthis:\n  Lyndon_mono (LynFac w)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Lyndon_mono (LynFac w)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Now we want to show the converse: any monotone factorization into Lyndon words is the Lyndon factorization\\<close>"], ["", "text\\<open>The last element in the Lyndon factorization is the smallest suffix.\\<close>"], ["", "lemma Lyndon_mono_last_smallest: \"Lyndon_mono ws \\<Longrightarrow>s \\<le>ns (concat ws) \\<Longrightarrow> last ws \\<le>lex s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Lyndon_mono ws; s \\<le>ns concat ws\\<rbrakk>\n    \\<Longrightarrow> last ws \\<le>lex s", "proof(induct ws arbitrary: s rule: rev_induct, fastforce)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>Lyndon_mono xs; s \\<le>ns concat xs\\<rbrakk>\n                   \\<Longrightarrow> last xs \\<le>lex s;\n        Lyndon_mono (xs \\<cdot> [x]);\n        s \\<le>ns concat (xs \\<cdot> [x])\\<rbrakk>\n       \\<Longrightarrow> last (xs \\<cdot> [x]) \\<le>lex s", "case (snoc a ws)"], ["proof (state)\nthis:\n  \\<lbrakk>Lyndon_mono ws; ?s1 \\<le>ns concat ws\\<rbrakk>\n  \\<Longrightarrow> last ws \\<le>lex ?s1\n  Lyndon_mono (ws \\<cdot> [a])\n  s \\<le>ns concat (ws \\<cdot> [a])\n\ngoal (1 subgoal):\n 1. \\<And>x xs s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>Lyndon_mono xs; s \\<le>ns concat xs\\<rbrakk>\n                   \\<Longrightarrow> last xs \\<le>lex s;\n        Lyndon_mono (xs \\<cdot> [x]);\n        s \\<le>ns concat (xs \\<cdot> [x])\\<rbrakk>\n       \\<Longrightarrow> last (xs \\<cdot> [x]) \\<le>lex s", "have \"ws\\<cdot>[a] \\<noteq> \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ws \\<cdot> [a] \\<noteq> \\<epsilon>", "by blast"], ["proof (state)\nthis:\n  ws \\<cdot> [a] \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>x xs s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>Lyndon_mono xs; s \\<le>ns concat xs\\<rbrakk>\n                   \\<Longrightarrow> last xs \\<le>lex s;\n        Lyndon_mono (xs \\<cdot> [x]);\n        s \\<le>ns concat (xs \\<cdot> [x])\\<rbrakk>\n       \\<Longrightarrow> last (xs \\<cdot> [x]) \\<le>lex s", "have \"last (ws\\<cdot>[a]) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (ws \\<cdot> [a]) = a", "by simp"], ["proof (state)\nthis:\n  last (ws \\<cdot> [a]) = a\n\ngoal (1 subgoal):\n 1. \\<And>x xs s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>Lyndon_mono xs; s \\<le>ns concat xs\\<rbrakk>\n                   \\<Longrightarrow> last xs \\<le>lex s;\n        Lyndon_mono (xs \\<cdot> [x]);\n        s \\<le>ns concat (xs \\<cdot> [x])\\<rbrakk>\n       \\<Longrightarrow> last (xs \\<cdot> [x]) \\<le>lex s", "from last_in_set[OF \\<open>ws\\<cdot>[a] \\<noteq> \\<epsilon>\\<close>, unfolded this] \\<open>Lyndon_mono (ws \\<cdot> [a])\\<close>[unfolded Lyndon_mono_def]"], ["proof (chain)\npicking this:\n  a \\<in> set (ws \\<cdot> [a])\n  Ball (set (ws \\<cdot> [a])) Lyndon \\<and>\n  linorder.sorted lexordp_eq (rev (ws \\<cdot> [a]))", "have \"Lyndon a\""], ["proof (prove)\nusing this:\n  a \\<in> set (ws \\<cdot> [a])\n  Ball (set (ws \\<cdot> [a])) Lyndon \\<and>\n  linorder.sorted lexordp_eq (rev (ws \\<cdot> [a]))\n\ngoal (1 subgoal):\n 1. Lyndon a", "by blast"], ["proof (state)\nthis:\n  Lyndon a\n\ngoal (1 subgoal):\n 1. \\<And>x xs s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>Lyndon_mono xs; s \\<le>ns concat xs\\<rbrakk>\n                   \\<Longrightarrow> last xs \\<le>lex s;\n        Lyndon_mono (xs \\<cdot> [x]);\n        s \\<le>ns concat (xs \\<cdot> [x])\\<rbrakk>\n       \\<Longrightarrow> last (xs \\<cdot> [x]) \\<le>lex s", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. last (ws \\<cdot> [a]) \\<le>lex s", "proof(cases \"s \\<le>ns a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. s \\<le>ns a \\<Longrightarrow> last (ws \\<cdot> [a]) \\<le>lex s\n 2. \\<not> s \\<le>ns a \\<Longrightarrow> last (ws \\<cdot> [a]) \\<le>lex s", "case True"], ["proof (state)\nthis:\n  s \\<le>ns a\n\ngoal (2 subgoals):\n 1. s \\<le>ns a \\<Longrightarrow> last (ws \\<cdot> [a]) \\<le>lex s\n 2. \\<not> s \\<le>ns a \\<Longrightarrow> last (ws \\<cdot> [a]) \\<le>lex s", "from Lyndon_suf_le[OF \\<open>Lyndon a\\<close>] this"], ["proof (chain)\npicking this:\n  ?s \\<le>ns a \\<Longrightarrow> a \\<le>lex ?s\n  s \\<le>ns a", "show ?thesis"], ["proof (prove)\nusing this:\n  ?s \\<le>ns a \\<Longrightarrow> a \\<le>lex ?s\n  s \\<le>ns a\n\ngoal (1 subgoal):\n 1. last (ws \\<cdot> [a]) \\<le>lex s", "by simp"], ["proof (state)\nthis:\n  last (ws \\<cdot> [a]) \\<le>lex s\n\ngoal (1 subgoal):\n 1. \\<not> s \\<le>ns a \\<Longrightarrow> last (ws \\<cdot> [a]) \\<le>lex s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> s \\<le>ns a \\<Longrightarrow> last (ws \\<cdot> [a]) \\<le>lex s", "case False"], ["proof (state)\nthis:\n  \\<not> s \\<le>ns a\n\ngoal (1 subgoal):\n 1. \\<not> s \\<le>ns a \\<Longrightarrow> last (ws \\<cdot> [a]) \\<le>lex s", "hence \"ws \\<noteq> \\<epsilon>\""], ["proof (prove)\nusing this:\n  \\<not> s \\<le>ns a\n\ngoal (1 subgoal):\n 1. ws \\<noteq> \\<epsilon>", "using snoc.prems(2)"], ["proof (prove)\nusing this:\n  \\<not> s \\<le>ns a\n  s \\<le>ns concat (ws \\<cdot> [a])\n\ngoal (1 subgoal):\n 1. ws \\<noteq> \\<epsilon>", "by force"], ["proof (state)\nthis:\n  ws \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<not> s \\<le>ns a \\<Longrightarrow> last (ws \\<cdot> [a]) \\<le>lex s", "obtain s' where \"s = s'\\<cdot>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s'. s = s' \\<cdot> a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using False snoc.prems(2)[unfolded concat_append[of ws \"[a]\", unfolded concat_sing']] suffix_append[of s \"concat ws\" a]"], ["proof (prove)\nusing this:\n  \\<not> s \\<le>ns a\n  s \\<le>ns concat ws \\<cdot> a\n  s \\<le>s concat ws \\<cdot> a =\n  (s \\<le>s a \\<or>\n   (\\<exists>xs'. s = xs' \\<cdot> a \\<and> xs' \\<le>s concat ws))\n\ngoal (1 subgoal):\n 1. (\\<And>s'. s = s' \\<cdot> a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding nonempty_suffix_def"], ["proof (prove)\nusing this:\n  \\<not> (s \\<noteq> \\<epsilon> \\<and> s \\<le>s a)\n  s \\<noteq> \\<epsilon> \\<and> s \\<le>s concat ws \\<cdot> a\n  s \\<le>s concat ws \\<cdot> a =\n  (s \\<le>s a \\<or>\n   (\\<exists>xs'. s = xs' \\<cdot> a \\<and> xs' \\<le>s concat ws))\n\ngoal (1 subgoal):\n 1. (\\<And>s'. s = s' \\<cdot> a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s = s' \\<cdot> a\n\ngoal (1 subgoal):\n 1. \\<not> s \\<le>ns a \\<Longrightarrow> last (ws \\<cdot> [a]) \\<le>lex s", "hence \"s' \\<le>ns concat ws\""], ["proof (prove)\nusing this:\n  s = s' \\<cdot> a\n\ngoal (1 subgoal):\n 1. s' \\<le>ns concat ws", "using False snoc.prems(2)"], ["proof (prove)\nusing this:\n  s = s' \\<cdot> a\n  \\<not> s \\<le>ns a\n  s \\<le>ns concat (ws \\<cdot> [a])\n\ngoal (1 subgoal):\n 1. s' \\<le>ns concat ws", "by fastforce"], ["proof (state)\nthis:\n  s' \\<le>ns concat ws\n\ngoal (1 subgoal):\n 1. \\<not> s \\<le>ns a \\<Longrightarrow> last (ws \\<cdot> [a]) \\<le>lex s", "have \"Lyndon_mono ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon_mono ws", "using \\<open>Lyndon_mono (ws\\<cdot>[a])\\<close> Lyndon_mono_fac_Lyndon_mono"], ["proof (prove)\nusing this:\n  Lyndon_mono (ws \\<cdot> [a])\n  \\<lbrakk>?ps \\<le>f ?ws; Lyndon_mono ?ws\\<rbrakk>\n  \\<Longrightarrow> Lyndon_mono ?ps\n\ngoal (1 subgoal):\n 1. Lyndon_mono ws", "by blast"], ["proof (state)\nthis:\n  Lyndon_mono ws\n\ngoal (1 subgoal):\n 1. \\<not> s \\<le>ns a \\<Longrightarrow> last (ws \\<cdot> [a]) \\<le>lex s", "from snoc.hyps[OF this \\<open>s' \\<le>ns concat ws\\<close>]"], ["proof (chain)\npicking this:\n  last ws \\<le>lex s'", "have \"last ws \\<le>lex s'\""], ["proof (prove)\nusing this:\n  last ws \\<le>lex s'\n\ngoal (1 subgoal):\n 1. last ws \\<le>lex s'", "by auto"], ["proof (state)\nthis:\n  last ws \\<le>lex s'\n\ngoal (1 subgoal):\n 1. \\<not> s \\<le>ns a \\<Longrightarrow> last (ws \\<cdot> [a]) \\<le>lex s", "hence \"last ws \\<le>lex s'\\<cdot>a\""], ["proof (prove)\nusing this:\n  last ws \\<le>lex s'\n\ngoal (1 subgoal):\n 1. last ws \\<le>lex s' \\<cdot> a", "using local.lexordp_eq_trans ord.lexordp_eq_pref"], ["proof (prove)\nusing this:\n  last ws \\<le>lex s'\n  \\<lbrakk>?xs \\<le>lex ?ys; ?ys \\<le>lex ?zs\\<rbrakk>\n  \\<Longrightarrow> ?xs \\<le>lex ?zs\n  ord.lexordp_eq ?less ?u (?u \\<cdot> ?v)\n\ngoal (1 subgoal):\n 1. last ws \\<le>lex s' \\<cdot> a", "by blast"], ["proof (state)\nthis:\n  last ws \\<le>lex s' \\<cdot> a\n\ngoal (1 subgoal):\n 1. \\<not> s \\<le>ns a \\<Longrightarrow> last (ws \\<cdot> [a]) \\<le>lex s", "have \"a \\<le>lex last ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le>lex last ws", "using \\<open>Lyndon_mono (ws\\<cdot>[a])\\<close>"], ["proof (prove)\nusing this:\n  Lyndon_mono (ws \\<cdot> [a])\n\ngoal (1 subgoal):\n 1. a \\<le>lex last ws", "unfolding Lyndon_mono_def"], ["proof (prove)\nusing this:\n  Ball (set (ws \\<cdot> [a])) Lyndon \\<and>\n  linorder.sorted lexordp_eq (rev (ws \\<cdot> [a]))\n\ngoal (1 subgoal):\n 1. a \\<le>lex last ws", "by (simp add: \\<open>ws \\<noteq> \\<epsilon>\\<close> last_ConsL)"], ["proof (state)\nthis:\n  a \\<le>lex last ws\n\ngoal (1 subgoal):\n 1. \\<not> s \\<le>ns a \\<Longrightarrow> last (ws \\<cdot> [a]) \\<le>lex s", "from dual_rlex.order_trans[OF \\<open>last ws \\<le>lex s' \\<cdot> a\\<close> this, folded \\<open>s = s' \\<cdot> a\\<close>]"], ["proof (chain)\npicking this:\n  a \\<le>lex s", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<le>lex s\n\ngoal (1 subgoal):\n 1. last (ws \\<cdot> [a]) \\<le>lex s", "unfolding \\<open>last (ws\\<cdot>[a]) = a\\<close>"], ["proof (prove)\nusing this:\n  a \\<le>lex s\n\ngoal (1 subgoal):\n 1. a \\<le>lex s", "by blast"], ["proof (state)\nthis:\n  last (ws \\<cdot> [a]) \\<le>lex s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  last (ws \\<cdot> [a]) \\<le>lex s\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>A monotone list, if seen as a factorization,\nmust end with the longest suffix\\<close>"], ["", "lemma Lyndon_mono_last_longest: assumes \"ws \\<noteq> \\<epsilon>\" and \"Lyndon_mono ws\" \n  shows \"LynSuf (concat ws) = last ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LynSuf (concat ws) = last ws", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. LynSuf (concat ws) = last ws", "have \"Lyndon (last ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon (last ws)", "using Lyndon_mono_set assms(1) assms(2) last_in_set"], ["proof (prove)\nusing this:\n  \\<lbrakk>Lyndon_mono ?ws; ?u \\<in> set ?ws\\<rbrakk>\n  \\<Longrightarrow> Lyndon ?u\n  ws \\<noteq> \\<epsilon>\n  Lyndon_mono ws\n  ?as \\<noteq> \\<epsilon> \\<Longrightarrow> last ?as \\<in> set ?as\n\ngoal (1 subgoal):\n 1. Lyndon (last ws)", "by blast"], ["proof (state)\nthis:\n  Lyndon (last ws)\n\ngoal (1 subgoal):\n 1. LynSuf (concat ws) = last ws", "hence \"last ws \\<noteq> \\<epsilon>\""], ["proof (prove)\nusing this:\n  Lyndon (last ws)\n\ngoal (1 subgoal):\n 1. last ws \\<noteq> \\<epsilon>", "using LyndonD_nemp"], ["proof (prove)\nusing this:\n  Lyndon (last ws)\n  Lyndon ?w \\<Longrightarrow> ?w \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. last ws \\<noteq> \\<epsilon>", "by blast"], ["proof (state)\nthis:\n  last ws \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. LynSuf (concat ws) = last ws", "hence \"last ws \\<le>ns LynSuf (concat ws)\""], ["proof (prove)\nusing this:\n  last ws \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. last ws \\<le>ns LynSuf (concat ws)", "using longest_Lyndon_suf_max[OF  concat_last_suf[OF assms(1)] \\<open>Lyndon (last ws)\\<close>]"], ["proof (prove)\nusing this:\n  last ws \\<noteq> \\<epsilon>\n  last ws \\<le>s LynSuf (concat ws)\n\ngoal (1 subgoal):\n 1. last ws \\<le>ns LynSuf (concat ws)", "unfolding nonempty_suffix_def"], ["proof (prove)\nusing this:\n  last ws \\<noteq> \\<epsilon>\n  last ws \\<le>s LynSuf (concat ws)\n\ngoal (1 subgoal):\n 1. last ws \\<noteq> \\<epsilon> \\<and> last ws \\<le>s LynSuf (concat ws)", "by blast"], ["proof (state)\nthis:\n  last ws \\<le>ns LynSuf (concat ws)\n\ngoal (1 subgoal):\n 1. LynSuf (concat ws) = last ws", "have \"concat ws \\<noteq> \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat ws \\<noteq> \\<epsilon>", "using Lyndon.simps assms(2)[unfolded Lyndon_mono_def] set_nemp_concat_nemp[OF assms(1)]"], ["proof (prove)\nusing this:\n  Lyndon ?w =\n  (?w \\<noteq> \\<epsilon> \\<and>\n   (\\<forall>n.\n       0 < n \\<and> n < \\<^bold>|?w\\<^bold>| \\<longrightarrow>\n       ?w <lex rotate n ?w))\n  Ball (set ws) Lyndon \\<and> linorder.sorted lexordp_eq (rev ws)\n  \\<epsilon> \\<notin> set ws \\<Longrightarrow> concat ws \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. concat ws \\<noteq> \\<epsilon>", "by blast"], ["proof (state)\nthis:\n  concat ws \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. LynSuf (concat ws) = last ws", "from longest_Lyndon_suf_nemp[OF this] longest_Lyndon_suf_suf[OF this]"], ["proof (chain)\npicking this:\n  LynSuf (concat ws) \\<noteq> \\<epsilon>\n  LynSuf (concat ws) \\<le>s concat ws", "have \"LynSuf (concat ws) \\<le>ns concat ws\""], ["proof (prove)\nusing this:\n  LynSuf (concat ws) \\<noteq> \\<epsilon>\n  LynSuf (concat ws) \\<le>s concat ws\n\ngoal (1 subgoal):\n 1. LynSuf (concat ws) \\<le>ns concat ws", "unfolding nonempty_suffix_def"], ["proof (prove)\nusing this:\n  LynSuf (concat ws) \\<noteq> \\<epsilon>\n  LynSuf (concat ws) \\<le>s concat ws\n\ngoal (1 subgoal):\n 1. LynSuf (concat ws) \\<noteq> \\<epsilon> \\<and>\n    LynSuf (concat ws) \\<le>s concat ws", "by simp"], ["proof (state)\nthis:\n  LynSuf (concat ws) \\<le>ns concat ws\n\ngoal (1 subgoal):\n 1. LynSuf (concat ws) = last ws", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. LynSuf (concat ws) = last ws", "using Lyndon_mono_last_smallest[OF \\<open>Lyndon_mono ws\\<close> \\<open>LynSuf (concat ws) \\<le>ns concat ws\\<close>]\n      Lyndon_suf_le[OF longest_Lyndon_suf_Lyndon[OF \\<open>concat ws \\<noteq> \\<epsilon>\\<close>], OF \\<open>last ws \\<le>ns LynSuf (concat ws)\\<close>]\n      dual_rlex.eq_iff"], ["proof (prove)\nusing this:\n  last ws \\<le>lex LynSuf (concat ws)\n  LynSuf (concat ws) \\<le>lex last ws\n  (?x = ?y) = (?y \\<le>lex ?x \\<and> ?x \\<le>lex ?y)\n\ngoal (1 subgoal):\n 1. LynSuf (concat ws) = last ws", "by simp"], ["proof (state)\nthis:\n  LynSuf (concat ws) = last ws\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Therefore, by construction, \nany monotone list is the Lyndon factorization of its concatenation\\<close>"], ["", "lemma Lyndon_mono_fac:\n  \"Lyndon_mono ws \\<Longrightarrow> ws = Lyndon_fac (concat ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon_mono ws \\<Longrightarrow> ws = LynFac (concat ws)", "proof (induct ws rule: rev_induct, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>Lyndon_mono xs \\<Longrightarrow> xs = LynFac (concat xs);\n        Lyndon_mono (xs \\<cdot> [x])\\<rbrakk>\n       \\<Longrightarrow> xs \\<cdot> [x] = LynFac (concat (xs \\<cdot> [x]))", "case (snoc x xs)"], ["proof (state)\nthis:\n  Lyndon_mono xs \\<Longrightarrow> xs = LynFac (concat xs)\n  Lyndon_mono (xs \\<cdot> [x])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>Lyndon_mono xs \\<Longrightarrow> xs = LynFac (concat xs);\n        Lyndon_mono (xs \\<cdot> [x])\\<rbrakk>\n       \\<Longrightarrow> xs \\<cdot> [x] = LynFac (concat (xs \\<cdot> [x]))", "have \"Lyndon_mono xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon_mono xs", "using \\<open>Lyndon_mono (xs \\<cdot> [x])\\<close>"], ["proof (prove)\nusing this:\n  Lyndon_mono (xs \\<cdot> [x])\n\ngoal (1 subgoal):\n 1. Lyndon_mono xs", "unfolding Lyndon_mono_def"], ["proof (prove)\nusing this:\n  Ball (set (xs \\<cdot> [x])) Lyndon \\<and>\n  linorder.sorted lexordp_eq (rev (xs \\<cdot> [x]))\n\ngoal (1 subgoal):\n 1. Ball (set xs) Lyndon \\<and> linorder.sorted lexordp_eq (rev xs)", "by simp"], ["proof (state)\nthis:\n  Lyndon_mono xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>Lyndon_mono xs \\<Longrightarrow> xs = LynFac (concat xs);\n        Lyndon_mono (xs \\<cdot> [x])\\<rbrakk>\n       \\<Longrightarrow> xs \\<cdot> [x] = LynFac (concat (xs \\<cdot> [x]))", "from snoc.hyps[OF this]"], ["proof (chain)\npicking this:\n  xs = LynFac (concat xs)", "have \"xs = LynFac (concat xs)\""], ["proof (prove)\nusing this:\n  xs = LynFac (concat xs)\n\ngoal (1 subgoal):\n 1. xs = LynFac (concat xs)", "."], ["proof (state)\nthis:\n  xs = LynFac (concat xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>Lyndon_mono xs \\<Longrightarrow> xs = LynFac (concat xs);\n        Lyndon_mono (xs \\<cdot> [x])\\<rbrakk>\n       \\<Longrightarrow> xs \\<cdot> [x] = LynFac (concat (xs \\<cdot> [x]))", "have \"x = LynSuf (concat (xs \\<cdot> [x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = LynSuf (concat (xs \\<cdot> [x]))", "using Lyndon_mono_last_longest[OF _ \\<open>Lyndon_mono (xs \\<cdot> [x])\\<close>, unfolded last_snoc]"], ["proof (prove)\nusing this:\n  xs \\<cdot> [x] \\<noteq> \\<epsilon> \\<Longrightarrow>\n  LynSuf (concat (xs \\<cdot> [x])) = x\n\ngoal (1 subgoal):\n 1. x = LynSuf (concat (xs \\<cdot> [x]))", "by simp"], ["proof (state)\nthis:\n  x = LynSuf (concat (xs \\<cdot> [x]))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>Lyndon_mono xs \\<Longrightarrow> xs = LynFac (concat xs);\n        Lyndon_mono (xs \\<cdot> [x])\\<rbrakk>\n       \\<Longrightarrow> xs \\<cdot> [x] = LynFac (concat (xs \\<cdot> [x]))", "have \"concat (xs \\<cdot> [x])\\<^sup><\\<inverse>x = concat xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (xs \\<cdot> [x])\\<^sup><\\<inverse>x  = concat xs", "by simp"], ["proof (state)\nthis:\n  concat (xs \\<cdot> [x])\\<^sup><\\<inverse>x  = concat xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>Lyndon_mono xs \\<Longrightarrow> xs = LynFac (concat xs);\n        Lyndon_mono (xs \\<cdot> [x])\\<rbrakk>\n       \\<Longrightarrow> xs \\<cdot> [x] = LynFac (concat (xs \\<cdot> [x]))", "have \"concat (xs \\<cdot> [x]) \\<noteq> \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (xs \\<cdot> [x]) \\<noteq> \\<epsilon>", "using Lyndon_mono_set snoc.prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>Lyndon_mono ?ws; ?u \\<in> set ?ws\\<rbrakk>\n  \\<Longrightarrow> Lyndon ?u\n  Lyndon_mono (xs \\<cdot> [x])\n\ngoal (1 subgoal):\n 1. concat (xs \\<cdot> [x]) \\<noteq> \\<epsilon>", "by auto"], ["proof (state)\nthis:\n  concat (xs \\<cdot> [x]) \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>Lyndon_mono xs \\<Longrightarrow> xs = LynFac (concat xs);\n        Lyndon_mono (xs \\<cdot> [x])\\<rbrakk>\n       \\<Longrightarrow> xs \\<cdot> [x] = LynFac (concat (xs \\<cdot> [x]))", "from this"], ["proof (chain)\npicking this:\n  concat (xs \\<cdot> [x]) \\<noteq> \\<epsilon>", "show ?case"], ["proof (prove)\nusing this:\n  concat (xs \\<cdot> [x]) \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. xs \\<cdot> [x] = LynFac (concat (xs \\<cdot> [x]))", "using Lyndon_fac.simps[of \"concat (xs \\<cdot> [x])\", folded \\<open>x = LynSuf (concat (xs \\<cdot> [x]))\\<close>,\n        unfolded \\<open>concat (xs \\<cdot> [x])\\<^sup><\\<inverse>x = concat xs\\<close>, folded \\<open>xs = LynFac (concat xs)\\<close>]"], ["proof (prove)\nusing this:\n  concat (xs \\<cdot> [x]) \\<noteq> \\<epsilon>\n  LynFac (concat (xs \\<cdot> [x])) =\n  (if concat (xs \\<cdot> [x]) \\<noteq> \\<epsilon> then xs \\<cdot> [x]\n   else \\<epsilon>)\n\ngoal (1 subgoal):\n 1. xs \\<cdot> [x] = LynFac (concat (xs \\<cdot> [x]))", "by presburger"], ["proof (state)\nthis:\n  xs \\<cdot> [x] = LynFac (concat (xs \\<cdot> [x]))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>This implies that the Lyndon factorization can be characterized\nin two equivalent ways: as the (unique) monotone factorization (into Lyndon words) or as\nthe \"suffix greedy\" factorization (into Lyndon words).\n\\<close>"], ["", "corollary Lyndon_mono_fac_iff: \"Lyndon_mono ws \\<longleftrightarrow> ws = LynFac (concat ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon_mono ws = (ws = LynFac (concat ws))", "using Lyndon_mono_fac fac_Lyndon_mono[of \"concat ws\"]"], ["proof (prove)\nusing this:\n  Lyndon_mono ?ws \\<Longrightarrow> ?ws = LynFac (concat ?ws)\n  Lyndon_mono (LynFac (concat ws))\n\ngoal (1 subgoal):\n 1. Lyndon_mono ws = (ws = LynFac (concat ws))", "by fastforce"], ["", "corollary Lyndon_mono_unique: assumes \"Lyndon_mono ws\" and \"Lyndon_mono zs\" and \"concat ws = concat zs\" \n  shows \"ws = zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ws = zs", "using Lyndon_mono_fac[OF \\<open>Lyndon_mono ws\\<close>] Lyndon_mono_fac[OF \\<open>Lyndon_mono zs\\<close>]"], ["proof (prove)\nusing this:\n  ws = LynFac (concat ws)\n  zs = LynFac (concat zs)\n\ngoal (1 subgoal):\n 1. ws = zs", "unfolding \\<open>concat ws = concat zs\\<close>"], ["proof (prove)\nusing this:\n  ws = LynFac (concat zs)\n  zs = LynFac (concat zs)\n\ngoal (1 subgoal):\n 1. ws = zs", "by simp"], ["", "subsection \"Standard factorization\""], ["", "lemma Lyndon_std: assumes \"Lyndon w\" \"1 < \\<^bold>|w\\<^bold>|\"\n  obtains l m where \"w = l\\<cdot>m\" and \"Lyndon l\" and \"Lyndon m\" and \"l <lex m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l m.\n        \\<lbrakk>w = l \\<cdot> m; Lyndon l; Lyndon m; l <lex m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>l m.\n        \\<lbrakk>w = l \\<cdot> m; Lyndon l; Lyndon m; l <lex m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"w \\<noteq> \\<epsilon>\" \"tl w \\<noteq> \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<noteq> \\<epsilon> &&& tl w \\<noteq> \\<epsilon>", "using \\<open>1 < \\<^bold>|w\\<^bold>|\\<close> long_list_tl"], ["proof (prove)\nusing this:\n  1 < \\<^bold>|w\\<^bold>|\n  1 < \\<^bold>|?us\\<^bold>| \\<Longrightarrow> tl ?us \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. w \\<noteq> \\<epsilon> &&& tl w \\<noteq> \\<epsilon>", "by auto"], ["proof (state)\nthis:\n  w \\<noteq> \\<epsilon>\n  tl w \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. (\\<And>l m.\n        \\<lbrakk>w = l \\<cdot> m; Lyndon l; Lyndon m; l <lex m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define m where  \"m = LynSuf (tl w)\""], ["proof (state)\nthis:\n  m = LynSuf (tl w)\n\ngoal (1 subgoal):\n 1. (\\<And>l m.\n        \\<lbrakk>w = l \\<cdot> m; Lyndon l; Lyndon m; l <lex m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"Lyndon m\""], ["proof (prove)\nusing this:\n  m = LynSuf (tl w)\n\ngoal (1 subgoal):\n 1. Lyndon m", "using \\<open>tl w \\<noteq> \\<epsilon>\\<close> local.longest_Lyndon_suf_Lyndon"], ["proof (prove)\nusing this:\n  m = LynSuf (tl w)\n  tl w \\<noteq> \\<epsilon>\n  ?w \\<noteq> \\<epsilon> \\<Longrightarrow> Lyndon (LynSuf ?w)\n\ngoal (1 subgoal):\n 1. Lyndon m", "by blast"], ["proof (state)\nthis:\n  Lyndon m\n\ngoal (1 subgoal):\n 1. (\\<And>l m.\n        \\<lbrakk>w = l \\<cdot> m; Lyndon l; Lyndon m; l <lex m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"m \\<le>s w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le>s w", "unfolding m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. LynSuf (tl w) \\<le>s w", "using suffix_order.order.trans[OF longest_Lyndon_suf_suf[OF \\<open>tl w \\<noteq> \\<epsilon>\\<close>] suffix_tl[of w]]"], ["proof (prove)\nusing this:\n  LynSuf (tl w) \\<le>s w\n\ngoal (1 subgoal):\n 1. LynSuf (tl w) \\<le>s w", "."], ["proof (state)\nthis:\n  m \\<le>s w\n\ngoal (1 subgoal):\n 1. (\\<And>l m.\n        \\<lbrakk>w = l \\<cdot> m; Lyndon l; Lyndon m; l <lex m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  m \\<le>s w\n\ngoal (1 subgoal):\n 1. (\\<And>l m.\n        \\<lbrakk>w = l \\<cdot> m; Lyndon l; Lyndon m; l <lex m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"m \\<noteq> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> w", "unfolding m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. LynSuf (tl w) \\<noteq> w", "using  hd_word'[OF \\<open>w \\<noteq> \\<epsilon>\\<close>] list.simps(3) longest_Lyndon_suf_suf[OF \\<open>tl w \\<noteq> \\<epsilon>\\<close>] same_suffix_nil"], ["proof (prove)\nusing this:\n  [hd w] \\<cdot> tl w = w\n  ?x21.0 # ?x22.0 \\<noteq> \\<epsilon>\n  LynSuf (tl w) \\<le>s tl w\n  ?ys \\<cdot> ?xs \\<le>s ?xs = (?ys = \\<epsilon>)\n\ngoal (1 subgoal):\n 1. LynSuf (tl w) \\<noteq> w", "by fastforce"], ["proof (state)\nthis:\n  m \\<noteq> w\n\ngoal (1 subgoal):\n 1. (\\<And>l m.\n        \\<lbrakk>w = l \\<cdot> m; Lyndon l; Lyndon m; l <lex m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  m \\<le>s w\n  m \\<noteq> w", "obtain l where \"w = l\\<cdot>m\" and \"l \\<noteq> \\<epsilon>\""], ["proof (prove)\nusing this:\n  m \\<le>s w\n  m \\<noteq> w\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>w = l \\<cdot> m; l \\<noteq> \\<epsilon>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  w = l \\<cdot> m\n  l \\<noteq> \\<epsilon>\n\ngoal (1 subgoal):\n 1. (\\<And>l m.\n        \\<lbrakk>w = l \\<cdot> m; Lyndon l; Lyndon m; l <lex m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"Lyndon l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon l", "proof (rule unbordered_pref_Lyndon[OF \\<open>Lyndon w\\<close>[unfolded \\<open>w = l\\<cdot>m\\<close>] \\<open>l \\<noteq> \\<epsilon>\\<close>], rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. bordered l \\<Longrightarrow> False", "assume \"bordered l\""], ["proof (state)\nthis:\n  bordered l\n\ngoal (1 subgoal):\n 1. bordered l \\<Longrightarrow> False", "from unbordered_border[OF this, unfolded border_def]"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     (x \\<le>p l \\<and>\n      x \\<le>s l \\<and> x \\<noteq> l \\<and> x \\<noteq> \\<epsilon>) \\<and>\n     \\<not> bordered x", "obtain s where \"s \\<noteq> \\<epsilon>\" and \"s \\<noteq> l\" and \"s \\<le>p l\" and \"s \\<le>s l\" and \"\\<not> bordered s\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     (x \\<le>p l \\<and>\n      x \\<le>s l \\<and> x \\<noteq> l \\<and> x \\<noteq> \\<epsilon>) \\<and>\n     \\<not> bordered x\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>s \\<noteq> \\<epsilon>; s \\<noteq> l; s \\<le>p l;\n         s \\<le>s l; \\<not> bordered s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s \\<noteq> \\<epsilon>\n  s \\<noteq> l\n  s \\<le>p l\n  s \\<le>s l\n  \\<not> bordered s\n\ngoal (1 subgoal):\n 1. bordered l \\<Longrightarrow> False", "have \"Lyndon s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon s", "using unbordered_pref_Lyndon[OF _ \\<open>s \\<noteq> \\<epsilon>\\<close> \\<open>\\<not> bordered s\\<close>, of \"s\\<inverse>\\<^sup>>l\\<cdot>m\", unfolded lassoc lq_pref[OF \\<open>s \\<le>p l\\<close>]]\n      \\<open>Lyndon w\\<close>[unfolded \\<open>w = l \\<cdot> m\\<close>]"], ["proof (prove)\nusing this:\n  Lyndon (l \\<cdot> m) \\<Longrightarrow> Lyndon s\n  Lyndon (l \\<cdot> m)\n\ngoal (1 subgoal):\n 1. Lyndon s", "by blast"], ["proof (state)\nthis:\n  Lyndon s\n\ngoal (1 subgoal):\n 1. bordered l \\<Longrightarrow> False", "have \"s <lex m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s <lex m", "using Lyndon_pref_suf_less[OF \\<open>Lyndon w\\<close> _ nsI[OF LyndonD_nemp[OF \\<open>Lyndon m\\<close>] \\<open>m \\<le>s w\\<close>] \n         \\<open>m \\<noteq> w\\<close>, of s] Lyndon.elims(2)[OF \\<open>Lyndon m\\<close>]  \n         \\<open>s \\<le>p l\\<close> prefix_append[of s l m, folded \\<open>w = l \\<cdot> m\\<close>]"], ["proof (prove)\nusing this:\n  s \\<le>p w \\<Longrightarrow> s <lex m\n  (\\<And>w.\n      \\<lbrakk>m = w;\n       w \\<noteq> \\<epsilon> \\<and>\n       (\\<forall>n.\n           0 < n \\<and> n < \\<^bold>|w\\<^bold>| \\<longrightarrow>\n           w <lex rotate n w)\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n  s \\<le>p l\n  (s \\<le>p w) =\n  (s \\<le>p l \\<or> (\\<exists>us. s = l \\<cdot> us \\<and> us \\<le>p m))\n\ngoal (1 subgoal):\n 1. s <lex m", "by presburger"], ["proof (state)\nthis:\n  s <lex m\n\ngoal (1 subgoal):\n 1. bordered l \\<Longrightarrow> False", "from Lyndon_concat[OF \\<open>Lyndon s\\<close> \\<open>Lyndon m\\<close> this]"], ["proof (chain)\npicking this:\n  Lyndon (s \\<cdot> m)", "have \"Lyndon (s\\<cdot>m)\""], ["proof (prove)\nusing this:\n  Lyndon (s \\<cdot> m)\n\ngoal (1 subgoal):\n 1. Lyndon (s \\<cdot> m)", "."], ["proof (state)\nthis:\n  Lyndon (s \\<cdot> m)\n\ngoal (1 subgoal):\n 1. bordered l \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  Lyndon (s \\<cdot> m)\n\ngoal (1 subgoal):\n 1. bordered l \\<Longrightarrow> False", "have \"s\\<cdot>m \\<le>s tl w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<cdot> m \\<le>s tl w", "unfolding \\<open>w = l \\<cdot> m\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<cdot> m \\<le>s tl (l \\<cdot> m)", "using \\<open>s \\<noteq> l\\<close> \\<open>s \\<le>s l\\<close> list.collapse[OF \\<open>w \\<noteq> \\<epsilon>\\<close>, unfolded \\<open>w = l \\<cdot> m\\<close>]"], ["proof (prove)\nusing this:\n  s \\<noteq> l\n  s \\<le>s l\n  hd (l \\<cdot> m) # tl (l \\<cdot> m) = l \\<cdot> m\n\ngoal (1 subgoal):\n 1. s \\<cdot> m \\<le>s tl (l \\<cdot> m)", "by force"], ["proof (state)\nthis:\n  s \\<cdot> m \\<le>s tl w\n\ngoal (1 subgoal):\n 1. bordered l \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  Lyndon (s \\<cdot> m)\n  s \\<cdot> m \\<le>s tl w", "show False"], ["proof (prove)\nusing this:\n  Lyndon (s \\<cdot> m)\n  s \\<cdot> m \\<le>s tl w\n\ngoal (1 subgoal):\n 1. False", "using m_def \\<open>s \\<noteq> \\<epsilon>\\<close> longest_Lyndon_suf_max same_suffix_nil"], ["proof (prove)\nusing this:\n  Lyndon (s \\<cdot> m)\n  s \\<cdot> m \\<le>s tl w\n  m = LynSuf (tl w)\n  s \\<noteq> \\<epsilon>\n  \\<lbrakk>?v \\<le>s ?w; Lyndon ?v\\<rbrakk>\n  \\<Longrightarrow> ?v \\<le>s LynSuf ?w\n  ?ys \\<cdot> ?xs \\<le>s ?xs = (?ys = \\<epsilon>)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Lyndon l\n\ngoal (1 subgoal):\n 1. (\\<And>l m.\n        \\<lbrakk>w = l \\<cdot> m; Lyndon l; Lyndon m; l <lex m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"l <lex m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l <lex m", "using Lyndon_pref_suf_less[OF \\<open>Lyndon w\\<close> prefI[OF \\<open>w = l \\<cdot> m\\<close>[symmetric]] \n        nsI[OF longest_Lyndon_suf_nemp[OF \\<open>tl w \\<noteq> \\<epsilon>\\<close>, folded  m_def] \\<open>m \\<le>s w\\<close>] \\<open>m \\<noteq> w\\<close>]"], ["proof (prove)\nusing this:\n  l <lex m\n\ngoal (1 subgoal):\n 1. l <lex m", "."], ["proof (state)\nthis:\n  l <lex m\n\ngoal (1 subgoal):\n 1. (\\<And>l m.\n        \\<lbrakk>w = l \\<cdot> m; Lyndon l; Lyndon m; l <lex m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from that[OF \\<open>w = l \\<cdot> m\\<close> \\<open>Lyndon l\\<close>  \\<open>Lyndon m\\<close> this]"], ["proof (chain)\npicking this:\n  thesis", "show thesis"], ["proof (prove)\nusing this:\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary Lyndon_std_iff: \n  \"Lyndon w \\<longleftrightarrow> (\\<^bold>|w\\<^bold>| = 1 \\<or> (\\<exists> l m. w = l\\<cdot>m \\<and> Lyndon l \\<and> Lyndon m \\<and> l <lex m))\" \n  (is \"?L \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon w =\n    (\\<^bold>|w\\<^bold>| = 1 \\<or>\n     (\\<exists>l m.\n         w = l \\<cdot> m \\<and> Lyndon l \\<and> Lyndon m \\<and> l <lex m))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. Lyndon w \\<Longrightarrow>\n    \\<^bold>|w\\<^bold>| = 1 \\<or>\n    (\\<exists>l m.\n        w = l \\<cdot> m \\<and> Lyndon l \\<and> Lyndon m \\<and> l <lex m)\n 2. \\<^bold>|w\\<^bold>| = 1 \\<or>\n    (\\<exists>l m.\n        w = l \\<cdot> m \\<and>\n        Lyndon l \\<and> Lyndon m \\<and> l <lex m) \\<Longrightarrow>\n    Lyndon w", "assume ?L"], ["proof (state)\nthis:\n  Lyndon w\n\ngoal (2 subgoals):\n 1. Lyndon w \\<Longrightarrow>\n    \\<^bold>|w\\<^bold>| = 1 \\<or>\n    (\\<exists>l m.\n        w = l \\<cdot> m \\<and> Lyndon l \\<and> Lyndon m \\<and> l <lex m)\n 2. \\<^bold>|w\\<^bold>| = 1 \\<or>\n    (\\<exists>l m.\n        w = l \\<cdot> m \\<and>\n        Lyndon l \\<and> Lyndon m \\<and> l <lex m) \\<Longrightarrow>\n    Lyndon w", "show ?R"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>|w\\<^bold>| = 1 \\<or>\n    (\\<exists>l m.\n        w = l \\<cdot> m \\<and> Lyndon l \\<and> Lyndon m \\<and> l <lex m)", "using Lyndon_std[OF \\<open>Lyndon w\\<close>] \n      nemp_pos_len[OF LyndonD_nemp[OF \\<open>Lyndon w\\<close>], unfolded le_eq_less_or_eq]"], ["proof (prove)\nusing this:\n  \\<lbrakk>1 < \\<^bold>|w\\<^bold>|;\n   \\<And>l m.\n      \\<lbrakk>w = l \\<cdot> m; Lyndon l; Lyndon m; l <lex m\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  1 < \\<^bold>|w\\<^bold>| \\<or> 1 = \\<^bold>|w\\<^bold>|\n\ngoal (1 subgoal):\n 1. \\<^bold>|w\\<^bold>| = 1 \\<or>\n    (\\<exists>l m.\n        w = l \\<cdot> m \\<and> Lyndon l \\<and> Lyndon m \\<and> l <lex m)", "by metis"], ["proof (state)\nthis:\n  \\<^bold>|w\\<^bold>| = 1 \\<or>\n  (\\<exists>l m.\n      w = l \\<cdot> m \\<and> Lyndon l \\<and> Lyndon m \\<and> l <lex m)\n\ngoal (1 subgoal):\n 1. \\<^bold>|w\\<^bold>| = 1 \\<or>\n    (\\<exists>l m.\n        w = l \\<cdot> m \\<and>\n        Lyndon l \\<and> Lyndon m \\<and> l <lex m) \\<Longrightarrow>\n    Lyndon w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>|w\\<^bold>| = 1 \\<or>\n    (\\<exists>l m.\n        w = l \\<cdot> m \\<and>\n        Lyndon l \\<and> Lyndon m \\<and> l <lex m) \\<Longrightarrow>\n    Lyndon w", "assume ?R"], ["proof (state)\nthis:\n  \\<^bold>|w\\<^bold>| = 1 \\<or>\n  (\\<exists>l m.\n      w = l \\<cdot> m \\<and> Lyndon l \\<and> Lyndon m \\<and> l <lex m)\n\ngoal (1 subgoal):\n 1. \\<^bold>|w\\<^bold>| = 1 \\<or>\n    (\\<exists>l m.\n        w = l \\<cdot> m \\<and>\n        Lyndon l \\<and> Lyndon m \\<and> l <lex m) \\<Longrightarrow>\n    Lyndon w", "thus ?L"], ["proof (prove)\nusing this:\n  \\<^bold>|w\\<^bold>| = 1 \\<or>\n  (\\<exists>l m.\n      w = l \\<cdot> m \\<and> Lyndon l \\<and> Lyndon m \\<and> l <lex m)\n\ngoal (1 subgoal):\n 1. Lyndon w", "proof(rule disjE, fastforce)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>l m.\n       w = l \\<cdot> m \\<and>\n       Lyndon l \\<and> Lyndon m \\<and> l <lex m \\<Longrightarrow>\n    Lyndon w", "show \\<open>\\<exists>l m. w = l \\<cdot> m \\<and> Lyndon l \\<and> Lyndon m \\<and> l <lex m \\<Longrightarrow> Lyndon w\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l m.\n       w = l \\<cdot> m \\<and>\n       Lyndon l \\<and> Lyndon m \\<and> l <lex m \\<Longrightarrow>\n    Lyndon w", "using Lyndon_concat"], ["proof (prove)\nusing this:\n  \\<lbrakk>Lyndon ?u; Lyndon ?v; ?u <lex ?v\\<rbrakk>\n  \\<Longrightarrow> Lyndon (?u \\<cdot> ?v)\n\ngoal (1 subgoal):\n 1. \\<exists>l m.\n       w = l \\<cdot> m \\<and>\n       Lyndon l \\<and> Lyndon m \\<and> l <lex m \\<Longrightarrow>\n    Lyndon w", "by blast"], ["proof (state)\nthis:\n  \\<exists>l m.\n     w = l \\<cdot> m \\<and>\n     Lyndon l \\<and> Lyndon m \\<and> l <lex m \\<Longrightarrow>\n  Lyndon w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Lyndon w\n\ngoal:\nNo subgoals!", "qed"], ["", "end  \\<comment> \\<open>end context linorder\\<close>"], ["", "end"]]}