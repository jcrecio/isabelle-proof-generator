{"file_name": "/home/qj213/afp-2021-10-22/thys/Combinatorics_Words_Lyndon/Lyndon_Addition.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Combinatorics_Words_Lyndon", "problem_names": ["lemma (in linorder) rotate_rel_iff: assumes \"w \\<noteq> \\<epsilon>\"\n  shows  \"Lyndon w \\<longleftrightarrow> rotate_rel w \\<subseteq> {(x,y). x < y}\" (is \"?L \\<longleftrightarrow> ?R\")", "lemma Lyndon_rotate_rel_iff:\n  \"acyclic (rotate_rel w) \\<longleftrightarrow> (\\<exists> r. strict_linear_order r \\<and> rotate_rel w \\<subseteq> r)\" (is \"?L \\<longleftrightarrow> ?R\")", "lemma slo_linorder: \"strict_linear_order r \\<Longrightarrow> class.linorder (\\<lambda> a b. (a,b) \\<in> r\\<^sup>=) (\\<lambda> a b. (a,b) \\<in> r)\"", "lemma assumes \"w \\<noteq> \\<epsilon>\" and \"acyclic (rotate_rel w)\" shows \"primitive w\"", "lemma assumes \"w \\<noteq> \\<epsilon>\" and \"acyclic (rotate_rel w)\" shows \"\\<not> bordered w\""], "translations": [["", "lemma (in linorder) rotate_rel_iff: assumes \"w \\<noteq> \\<epsilon>\"\n  shows  \"Lyndon w \\<longleftrightarrow> rotate_rel w \\<subseteq> {(x,y). x < y}\" (is \"?L \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon w = (rotate_rel w \\<subseteq> {(x, y). x < y})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. Lyndon w \\<Longrightarrow> rotate_rel w \\<subseteq> {(x, y). x < y}\n 2. rotate_rel w \\<subseteq> {(x, y). x < y} \\<Longrightarrow> Lyndon w", "assume \"Lyndon w\""], ["proof (state)\nthis:\n  Lyndon w\n\ngoal (2 subgoals):\n 1. Lyndon w \\<Longrightarrow> rotate_rel w \\<subseteq> {(x, y). x < y}\n 2. rotate_rel w \\<subseteq> {(x, y). x < y} \\<Longrightarrow> Lyndon w", "show \"rotate_rel w \\<subseteq> {(x,y). x < y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rotate_rel w \\<subseteq> {(x, y). x < y}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rotate_rel w \\<Longrightarrow> x \\<in> {(x, y). x < y}", "fix  x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rotate_rel w \\<Longrightarrow> x \\<in> {(x, y). x < y}", "assume \"x \\<in> rotate_rel w\""], ["proof (state)\nthis:\n  x \\<in> rotate_rel w\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rotate_rel w \\<Longrightarrow> x \\<in> {(x, y). x < y}", "then"], ["proof (chain)\npicking this:\n  x \\<in> rotate_rel w", "obtain n where \"x = mismatch_pair w (rotate n w)\" and \"0 < n\" and \"n < \\<^bold>|w\\<^bold>|\""], ["proof (prove)\nusing this:\n  x \\<in> rotate_rel w\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>x = mismatch_pair w (rotate n w); 0 < n;\n         n < \\<^bold>|w\\<^bold>|\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rotate_rel.cases"], ["proof (prove)\nusing this:\n  x \\<in> rotate_rel w\n  \\<lbrakk>?a \\<in> rotate_rel ?w;\n   \\<And>n.\n      \\<lbrakk>?a = mismatch_pair ?w (rotate n ?w); 0 < n;\n       n < \\<^bold>|?w\\<^bold>|\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>x = mismatch_pair w (rotate n w); 0 < n;\n         n < \\<^bold>|w\\<^bold>|\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x = mismatch_pair w (rotate n w)\n  0 < n\n  n < \\<^bold>|w\\<^bold>|\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rotate_rel w \\<Longrightarrow> x \\<in> {(x, y). x < y}", "have \"w <lex rotate n w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w <lex rotate n w", "using LyndonD[OF \\<open>Lyndon w\\<close> \\<open>0 < n\\<close> \\<open>n < \\<^bold>|w\\<^bold>|\\<close>]"], ["proof (prove)\nusing this:\n  w <lex rotate n w\n\ngoal (1 subgoal):\n 1. w <lex rotate n w", "."], ["proof (state)\nthis:\n  w <lex rotate n w\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rotate_rel w \\<Longrightarrow> x \\<in> {(x, y). x < y}", "from this[unfolded lexordp_conv_lexord] \n      prim_no_rotate[OF Lyndon_prim[OF \\<open>Lyndon w\\<close>] \\<open>0 < n\\<close>  \\<open>n < \\<^bold>|w\\<^bold>|\\<close>]"], ["proof (chain)\npicking this:\n  (w, rotate n w) \\<in> lexord {(x, y). x < y}\n  rotate n w \\<noteq> w", "show \"x \\<in> {(a, b). a < b}\""], ["proof (prove)\nusing this:\n  (w, rotate n w) \\<in> lexord {(x, y). x < y}\n  rotate n w \\<noteq> w\n\ngoal (1 subgoal):\n 1. x \\<in> {(x, y). x < y}", "using lexord_mismatch[of w \"rotate n w\" \"{(a,b). a < b}\", folded \\<open>x = mismatch_pair w (rotate n w)\\<close>]\n        \\<open>rotate n w \\<noteq> w\\<close> rotate_comp_eq[of w n]"], ["proof (prove)\nusing this:\n  (w, rotate n w) \\<in> lexord {(x, y). x < y}\n  rotate n w \\<noteq> w\n  \\<lbrakk>\\<not> w \\<bowtie> rotate n w; irrefl {(x, y). x < y}\\<rbrakk>\n  \\<Longrightarrow> (x \\<in> {(x, y). x < y}) =\n                    ((w, rotate n w) \\<in> lexord {(x, y). x < y})\n  rotate n w \\<noteq> w\n  w \\<bowtie> rotate n w \\<Longrightarrow> rotate n w = w\n\ngoal (1 subgoal):\n 1. x \\<in> {(x, y). x < y}", "unfolding irrefl_def"], ["proof (prove)\nusing this:\n  (w, rotate n w) \\<in> lexord {(x, y). x < y}\n  rotate n w \\<noteq> w\n  \\<lbrakk>\\<not> w \\<bowtie> rotate n w;\n   \\<forall>a. (a, a) \\<notin> {(x, y). x < y}\\<rbrakk>\n  \\<Longrightarrow> (x \\<in> {(x, y). x < y}) =\n                    ((w, rotate n w) \\<in> lexord {(x, y). x < y})\n  rotate n w \\<noteq> w\n  w \\<bowtie> rotate n w \\<Longrightarrow> rotate n w = w\n\ngoal (1 subgoal):\n 1. x \\<in> {(x, y). x < y}", "by blast"], ["proof (state)\nthis:\n  x \\<in> {(x, y). x < y}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rotate_rel w \\<subseteq> {(x, y). x < y}\n\ngoal (1 subgoal):\n 1. rotate_rel w \\<subseteq> {(x, y). x < y} \\<Longrightarrow> Lyndon w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rotate_rel w \\<subseteq> {(x, y). x < y} \\<Longrightarrow> Lyndon w", "assume \"?R\""], ["proof (state)\nthis:\n  rotate_rel w \\<subseteq> {(x, y). x < y}\n\ngoal (1 subgoal):\n 1. rotate_rel w \\<subseteq> {(x, y). x < y} \\<Longrightarrow> Lyndon w", "show \"?L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Lyndon w", "unfolding Lyndon.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<noteq> \\<epsilon> \\<and>\n    (\\<forall>n.\n        0 < n \\<and> n < \\<^bold>|w\\<^bold>| \\<longrightarrow>\n        w <lex rotate n w)", "proof(simp add: assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       0 < n \\<and> n < \\<^bold>|w\\<^bold>| \\<longrightarrow>\n       w <lex rotate n w", "have \"w <lex rotate n w\" if \"0 < n\"  \"n < \\<^bold>|w\\<^bold>|\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. w <lex rotate n w", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. w <lex rotate n w", "have \"\\<not> w \\<bowtie> rotate n w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> w \\<bowtie> rotate n w", "using rotate_comp_eq[of w n] subsetD[OF \\<open>?R\\<close>, OF rotate_rel.intros[OF \\<open>0 < n\\<close> \\<open>n < \\<^bold>|w\\<^bold>|\\<close>]]\n          mismatch_pair_lcp[of w \"rotate n w\"]"], ["proof (prove)\nusing this:\n  w \\<bowtie> rotate n w \\<Longrightarrow> rotate n w = w\n  mismatch_pair w (rotate n w) \\<in> {(x, y). x < y}\n  mismatch_pair w (rotate n w) =\n  (w ! \\<^bold>|w \\<and>\\<^sub>p rotate n w\\<^bold>|,\n   rotate n w ! \\<^bold>|w \\<and>\\<^sub>p rotate n w\\<^bold>|)\n\ngoal (1 subgoal):\n 1. \\<not> w \\<bowtie> rotate n w", "by fastforce"], ["proof (state)\nthis:\n  \\<not> w \\<bowtie> rotate n w\n\ngoal (1 subgoal):\n 1. w <lex rotate n w", "from mismatch_lexord_linorder[OF this subsetD[OF \\<open>?R\\<close>, OF rotate_rel.intros[OF \\<open>0 < n\\<close> \\<open>n < \\<^bold>|w\\<^bold>|\\<close>]]]"], ["proof (chain)\npicking this:\n  w <lex rotate n w", "show \"w <lex rotate n w\""], ["proof (prove)\nusing this:\n  w <lex rotate n w\n\ngoal (1 subgoal):\n 1. w <lex rotate n w", "."], ["proof (state)\nthis:\n  w <lex rotate n w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?n; ?n < \\<^bold>|w\\<^bold>|\\<rbrakk>\n  \\<Longrightarrow> w <lex rotate ?n w\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       0 < n \\<and> n < \\<^bold>|w\\<^bold>| \\<longrightarrow>\n       w <lex rotate n w", "thus \"\\<forall>n. 0 < n \\<and> n < \\<^bold>|w\\<^bold>| \\<longrightarrow> w <lex rotate n w\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?n; ?n < \\<^bold>|w\\<^bold>|\\<rbrakk>\n  \\<Longrightarrow> w <lex rotate ?n w\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       0 < n \\<and> n < \\<^bold>|w\\<^bold>| \\<longrightarrow>\n       w <lex rotate n w", "by blast"], ["proof (state)\nthis:\n  \\<forall>n.\n     0 < n \\<and> n < \\<^bold>|w\\<^bold>| \\<longrightarrow>\n     w <lex rotate n w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Lyndon w\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>It is well known that an acyclic order can be extended to a total strict linear order. This means that\na word is Lyndon with respect to some order iff its @{term \"rotate_rel w\"} is acyclic.\n\\<close>"], ["", "lemma Lyndon_rotate_rel_iff:\n  \"acyclic (rotate_rel w) \\<longleftrightarrow> (\\<exists> r. strict_linear_order r \\<and> rotate_rel w \\<subseteq> r)\" (is \"?L \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic (rotate_rel w) =\n    (\\<exists>r. strict_linear_order r \\<and> rotate_rel w \\<subseteq> r)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. acyclic (rotate_rel w) \\<Longrightarrow>\n    \\<exists>r. strict_linear_order r \\<and> rotate_rel w \\<subseteq> r\n 2. \\<exists>r.\n       strict_linear_order r \\<and>\n       rotate_rel w \\<subseteq> r \\<Longrightarrow>\n    acyclic (rotate_rel w)", "assume \"?R\""], ["proof (state)\nthis:\n  \\<exists>r. strict_linear_order r \\<and> rotate_rel w \\<subseteq> r\n\ngoal (2 subgoals):\n 1. acyclic (rotate_rel w) \\<Longrightarrow>\n    \\<exists>r. strict_linear_order r \\<and> rotate_rel w \\<subseteq> r\n 2. \\<exists>r.\n       strict_linear_order r \\<and>\n       rotate_rel w \\<subseteq> r \\<Longrightarrow>\n    acyclic (rotate_rel w)", "thus \"?L\""], ["proof (prove)\nusing this:\n  \\<exists>r. strict_linear_order r \\<and> rotate_rel w \\<subseteq> r\n\ngoal (1 subgoal):\n 1. acyclic (rotate_rel w)", "unfolding strict_linear_order_on_def acyclic_def irrefl_def"], ["proof (prove)\nusing this:\n  \\<exists>r.\n     (trans r \\<and> (\\<forall>a. (a, a) \\<notin> r) \\<and> total r) \\<and>\n     rotate_rel w \\<subseteq> r\n\ngoal (1 subgoal):\n 1. \\<forall>x. (x, x) \\<notin> (rotate_rel w)\\<^sup>+", "using trancl_id trancl_mono"], ["proof (prove)\nusing this:\n  \\<exists>r.\n     (trans r \\<and> (\\<forall>a. (a, a) \\<notin> r) \\<and> total r) \\<and>\n     rotate_rel w \\<subseteq> r\n  trans ?r \\<Longrightarrow> ?r\\<^sup>+ = ?r\n  \\<lbrakk>?p \\<in> ?r\\<^sup>+; ?r \\<subseteq> ?s\\<rbrakk>\n  \\<Longrightarrow> ?p \\<in> ?s\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<forall>x. (x, x) \\<notin> (rotate_rel w)\\<^sup>+", "by metis"], ["proof (state)\nthis:\n  acyclic (rotate_rel w)\n\ngoal (1 subgoal):\n 1. acyclic (rotate_rel w) \\<Longrightarrow>\n    \\<exists>r. strict_linear_order r \\<and> rotate_rel w \\<subseteq> r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. acyclic (rotate_rel w) \\<Longrightarrow>\n    \\<exists>r. strict_linear_order r \\<and> rotate_rel w \\<subseteq> r", "assume \"?L\""], ["proof (state)\nthis:\n  acyclic (rotate_rel w)\n\ngoal (1 subgoal):\n 1. acyclic (rotate_rel w) \\<Longrightarrow>\n    \\<exists>r. strict_linear_order r \\<and> rotate_rel w \\<subseteq> r", "thus \"?R\""], ["proof (prove)\nusing this:\n  acyclic (rotate_rel w)\n\ngoal (1 subgoal):\n 1. \\<exists>r. strict_linear_order r \\<and> rotate_rel w \\<subseteq> r", "using can_extend_acyclic_order_to_strict_linear"], ["proof (prove)\nusing this:\n  acyclic (rotate_rel w)\n  acyclic ?base_r \\<Longrightarrow>\n  \\<exists>r. strict_linear_order r \\<and> ?base_r \\<subseteq> r\n\ngoal (1 subgoal):\n 1. \\<exists>r. strict_linear_order r \\<and> rotate_rel w \\<subseteq> r", "by auto"], ["proof (state)\nthis:\n  \\<exists>r. strict_linear_order r \\<and> rotate_rel w \\<subseteq> r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slo_linorder: \"strict_linear_order r \\<Longrightarrow> class.linorder (\\<lambda> a b. (a,b) \\<in> r\\<^sup>=) (\\<lambda> a b. (a,b) \\<in> r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_linear_order r \\<Longrightarrow>\n    class.linorder (\\<lambda>a b. (a, b) \\<in> r\\<^sup>=)\n     (\\<lambda>a b. (a, b) \\<in> r)", "unfolding strict_linear_order_def strict_partial_order_def irrefl_def trans_def total_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>x y z.\n         (x, y) \\<in> r \\<longrightarrow>\n         (y, z) \\<in> r \\<longrightarrow> (x, z) \\<in> r) \\<and>\n     (\\<forall>a. (a, a) \\<notin> r)) \\<and>\n    (\\<forall>x\\<in>UNIV.\n        \\<forall>y\\<in>UNIV.\n           x \\<noteq> y \\<longrightarrow>\n           (x, y) \\<in> r \\<or> (y, x) \\<in> r) \\<Longrightarrow>\n    class.linorder (\\<lambda>a b. (a, b) \\<in> r\\<^sup>=)\n     (\\<lambda>a b. (a, b) \\<in> r)", "by unfold_locales blast+"], ["", "text\\<open>Application examples\\<close>"], ["", "lemma assumes \"w \\<noteq> \\<epsilon>\" and \"acyclic (rotate_rel w)\" shows \"primitive w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. primitive w", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. primitive w", "obtain r where \"strict_linear_order r\" and \"rotate_rel w \\<subseteq> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>strict_linear_order r; rotate_rel w \\<subseteq> r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Lyndon_rotate_rel_iff assms"], ["proof (prove)\nusing this:\n  acyclic (rotate_rel ?w) =\n  (\\<exists>r. strict_linear_order r \\<and> rotate_rel ?w \\<subseteq> r)\n  w \\<noteq> \\<epsilon>\n  acyclic (rotate_rel w)\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>strict_linear_order r; rotate_rel w \\<subseteq> r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  strict_linear_order r\n  rotate_rel w \\<subseteq> r\n\ngoal (1 subgoal):\n 1. primitive w", "interpret r: linorder \"\\<lambda> a b. (a,b) \\<in> r\\<^sup>=\" \"\\<lambda> a b. (a,b) \\<in> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linorder (\\<lambda>a b. (a, b) \\<in> r\\<^sup>=)\n     (\\<lambda>a b. (a, b) \\<in> r)", "using slo_linorder[OF \\<open>strict_linear_order r\\<close>]"], ["proof (prove)\nusing this:\n  class.linorder (\\<lambda>a b. (a, b) \\<in> r\\<^sup>=)\n   (\\<lambda>a b. (a, b) \\<in> r)\n\ngoal (1 subgoal):\n 1. class.linorder (\\<lambda>a b. (a, b) \\<in> r\\<^sup>=)\n     (\\<lambda>a b. (a, b) \\<in> r)", "."], ["proof (state)\ngoal (1 subgoal):\n 1. primitive w", "have \"r.Lyndon w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r.Lyndon w", "using r.rotate_rel_iff[OF \\<open>w \\<noteq> \\<epsilon>\\<close>] \\<open>rotate_rel w \\<subseteq> r\\<close>"], ["proof (prove)\nusing this:\n  r.Lyndon w = (rotate_rel w \\<subseteq> {(x, y). (x, y) \\<in> r})\n  rotate_rel w \\<subseteq> r\n\ngoal (1 subgoal):\n 1. r.Lyndon w", "by blast"], ["proof (state)\nthis:\n  r.Lyndon w\n\ngoal (1 subgoal):\n 1. primitive w", "from r.Lyndon_prim[OF this]"], ["proof (chain)\npicking this:\n  primitive w", "show \"primitive w\""], ["proof (prove)\nusing this:\n  primitive w\n\ngoal (1 subgoal):\n 1. primitive w", "."], ["proof (state)\nthis:\n  primitive w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma assumes \"w \\<noteq> \\<epsilon>\" and \"acyclic (rotate_rel w)\" shows \"\\<not> bordered w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> bordered w", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> bordered w", "obtain r where \"strict_linear_order r\" and \"rotate_rel w \\<subseteq> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>strict_linear_order r; rotate_rel w \\<subseteq> r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Lyndon_rotate_rel_iff assms"], ["proof (prove)\nusing this:\n  acyclic (rotate_rel ?w) =\n  (\\<exists>r. strict_linear_order r \\<and> rotate_rel ?w \\<subseteq> r)\n  w \\<noteq> \\<epsilon>\n  acyclic (rotate_rel w)\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>strict_linear_order r; rotate_rel w \\<subseteq> r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  strict_linear_order r\n  rotate_rel w \\<subseteq> r\n\ngoal (1 subgoal):\n 1. \\<not> bordered w", "interpret r: linorder \"\\<lambda> a b. (a,b) \\<in> r\\<^sup>=\" \"\\<lambda> a b. (a,b) \\<in> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linorder (\\<lambda>a b. (a, b) \\<in> r\\<^sup>=)\n     (\\<lambda>a b. (a, b) \\<in> r)", "using slo_linorder[OF \\<open>strict_linear_order r\\<close>]"], ["proof (prove)\nusing this:\n  class.linorder (\\<lambda>a b. (a, b) \\<in> r\\<^sup>=)\n   (\\<lambda>a b. (a, b) \\<in> r)\n\ngoal (1 subgoal):\n 1. class.linorder (\\<lambda>a b. (a, b) \\<in> r\\<^sup>=)\n     (\\<lambda>a b. (a, b) \\<in> r)", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> bordered w", "have \"r.Lyndon w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r.Lyndon w", "using r.rotate_rel_iff[OF \\<open>w \\<noteq> \\<epsilon>\\<close>] \\<open>rotate_rel w \\<subseteq> r\\<close>"], ["proof (prove)\nusing this:\n  r.Lyndon w = (rotate_rel w \\<subseteq> {(x, y). (x, y) \\<in> r})\n  rotate_rel w \\<subseteq> r\n\ngoal (1 subgoal):\n 1. r.Lyndon w", "by blast"], ["proof (state)\nthis:\n  r.Lyndon w\n\ngoal (1 subgoal):\n 1. \\<not> bordered w", "from r.Lyndon_unbordered[OF this]"], ["proof (chain)\npicking this:\n  \\<not> bordered w", "show \"\\<not> bordered w\""], ["proof (prove)\nusing this:\n  \\<not> bordered w\n\ngoal (1 subgoal):\n 1. \\<not> bordered w", "."], ["proof (state)\nthis:\n  \\<not> bordered w\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}