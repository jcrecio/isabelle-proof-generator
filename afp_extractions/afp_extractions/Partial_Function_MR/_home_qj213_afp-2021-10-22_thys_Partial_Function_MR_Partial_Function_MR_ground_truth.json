{"file_name": "/home/qj213/afp-2021-10-22/thys/Partial_Function_MR/Partial_Function_MR.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Partial_Function_MR", "problem_names": ["lemma option_map_id: \"map_option (\\<lambda> x. x) x = x\"", "lemma option_map_mono[partial_function_mono]:\n  assumes mf: \"mono_option B\"\n  shows \"mono_option (\\<lambda>f. map_option h (B f))\""], "translations": [["", "lemma option_map_id: \"map_option (\\<lambda> x. x) x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option (\\<lambda>x. x) x = x", "by (cases x, auto)"], ["", "text \\<open>Second, register @{term map_option} as being monotone.\\<close>"], ["", "lemma option_map_mono[partial_function_mono]:\n  assumes mf: \"mono_option B\"\n  shows \"mono_option (\\<lambda>f. map_option h (B f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone option.le_fun option_ord (\\<lambda>f. map_option h (B f))", "proof (rule monotoneI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       option.le_fun x y \\<Longrightarrow>\n       option_ord (map_option h (B x)) (map_option h (B y))", "fix f g :: \"'a \\<Rightarrow> 'b option\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       option.le_fun x y \\<Longrightarrow>\n       option_ord (map_option h (B x)) (map_option h (B y))", "assume fg: \"fun_ord option_ord f g\""], ["proof (state)\nthis:\n  option.le_fun f g\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       option.le_fun x y \\<Longrightarrow>\n       option_ord (map_option h (B x)) (map_option h (B y))", "with mf"], ["proof (chain)\npicking this:\n  monotone option.le_fun option_ord B\n  option.le_fun f g", "have \"option_ord (B f) (B g)\""], ["proof (prove)\nusing this:\n  monotone option.le_fun option_ord B\n  option.le_fun f g\n\ngoal (1 subgoal):\n 1. option_ord (B f) (B g)", "by (rule monotoneD[of _ _ _ f g])"], ["proof (state)\nthis:\n  option_ord (B f) (B g)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       option.le_fun x y \\<Longrightarrow>\n       option_ord (map_option h (B x)) (map_option h (B y))", "then"], ["proof (chain)\npicking this:\n  option_ord (B f) (B g)", "show \"option_ord (map_option h (B f)) (map_option h (B g))\""], ["proof (prove)\nusing this:\n  option_ord (B f) (B g)\n\ngoal (1 subgoal):\n 1. option_ord (map_option h (B f)) (map_option h (B g))", "unfolding flat_ord_def"], ["proof (prove)\nusing this:\n  B f = None \\<or> B f = B g\n\ngoal (1 subgoal):\n 1. map_option h (B f) = None \\<or> map_option h (B f) = map_option h (B g)", "by auto"], ["proof (state)\nthis:\n  option_ord (map_option h (B f)) (map_option h (B g))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>And finally perform the registration. We need \n\\begin{itemize}\n\\item a constructor for map: it takes a monadic term $mt$ of type \\isa{mtT},\n  a list of functions \\isa{t-to-ss} with corresponding types in \\isa{t-to-sTs},\n  a resulting monadic type \\isa{msT}, and it should return a monad term \\isa{ms} of\n  type \\isa{msT} which\n  is obtained by applying the functions on \\isa{mt}. Although for the @{type option}-monad,\n  the lengths of the lists will always be one, there might be more elements for monads having\n  more than one type-parameter.\n\\item a function to perform type-construction for monads: it takes a list of fixed parameters\n  and a list of flexible parameters and has to construct a monadic type out of these parameters.\n  The user can freely choose which parameters should be fixed, and which are flexible.\n  Only flexible parameters can be changes in the return type of each set of mutual recursive functions.\n  Since in the @{type option}-monad we would like to be able to change the type-parameter, we ignore\n  the fixed parameters here.\n\\item a function to deconstruct monadic types into fixed and flexible type arguments.\n\\item a compositionality theorem of the form @{term \"map f (map g x) = map (f o g) x\"} \n\\item an identity theorem of the form @{term \"map (\\<lambda> x. x) m = m\"} \n\\end{itemize}\n\\<close>"], ["", "declaration \\<open>Partial_Function_MR.init \n  \"option\" \n  (fn (mt, t_to_ss, mtT, msT, t_to_sTs) =>\n      list_comb (Const (@{const_name map_option}, t_to_sTs ---> mtT --> msT), t_to_ss) $ mt)\n  (fn (_,argTs) => Type (@{type_name option}, argTs))\n  (fn mT => ([],Term.dest_Type mT |> #2)) \n  @{thms option.map_comp} \n  @{thms option_map_id}\n\\<close>"], ["", "subsection \\<open>Register the \"tailrec\"-monad\\<close>"], ["", "text \\<open>For the \"tailrec\"-monad (which is the identity monad) we take the identity\n  function as map, there are no flexible parameters, and the monadic type itself is\n  the (only) fixed argument. As a consequence, we can only define tail-recursive and \n  mutual recursive functions which share the same return type.\\<close>"], ["", "declaration \\<open>Partial_Function_MR.init \n  \"tailrec\" \n  (fn (mt, t_to_ss, mtT, msT, t_to_sTs) => mt)\n  (fn (commonT,_) => hd commonT)\n  (fn mT => ([mT],[])) \n  [] \n  []\n\\<close>"], ["", "end"]]}