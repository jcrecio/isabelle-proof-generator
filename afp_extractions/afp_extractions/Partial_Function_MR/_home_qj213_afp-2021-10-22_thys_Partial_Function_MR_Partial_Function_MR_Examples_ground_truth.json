{"file_name": "/home/qj213/afp-2021-10-22/thys/Partial_Function_MR/Partial_Function_MR_Examples.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Partial_Function_MR", "problem_names": ["lemma \"length (collatz 327 []) = 144\"", "lemma \"collatz 5 [] = [5,16,8,4,2,1]\""], "translations": [["", "lemma \"length (collatz 327 []) = 144\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (collatz 327 []) = 144", "by eval"], ["", "text \\<open>The equations are accessible via .simps, but are not put in the standard simpset.\\<close>"], ["", "lemma \"collatz 5 [] = [5,16,8,4,2,1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collatz 5 [] = [5, 16, 8, 4, 2, 1]", "by (simp add: collatz.simps even_case.simps)"], ["", "subsection \\<open>Evaluating expressions\\<close>"], ["", "text \\<open>Note that we also provide a least fixpoint operator.\n  Hence, the evaluation function will clearly be partial.\n  The example also illustrates the usage\n  of polymorphism and of different return types.\\<close>"], ["", "text \\<open>In the following datatype, \\isa{Mu b f a} encodes the least $n$ such that $b(f^n(a))$.\\<close>"], ["", "datatype 'a bexp = \n  BConst bool\n| Less \"'a aexp\" \"'a aexp\"\n| Eq \"'a aexp\" \"'a aexp\"\n| And \"'a bexp\" \"'a bexp\"\nand 'a aexp =\n  Plus \"'a aexp\" \"'a aexp\"\n| Div \"'a aexp\" \"'a aexp\"\n| IfThenElse \"'a bexp\" \"'a aexp\" \"'a aexp\"\n| AConst 'a\n| Mu \"'a \\<Rightarrow> 'a bexp\" \"'a \\<Rightarrow> 'a aexp\" \"'a aexp\""], ["", "partial_function_mr (option) \n  b_eval and a_eval and mu_eval where\n  \"b_eval bexp = (case bexp of\n     BConst b \\<Rightarrow> Some b\n   | Less a1 a2 \\<Rightarrow> do {\n        x1 \\<leftarrow> a_eval a1;\n        x2 \\<leftarrow> a_eval a2;\n        Some (x1 < x2)\n     }\n   | Eq a1 a2 \\<Rightarrow> do {\n        x1 \\<leftarrow> a_eval a1;\n        x2 \\<leftarrow> a_eval a2;\n        Some (x1 = x2)\n     }\n   | And be1 be2 \\<Rightarrow> do {\n        b1 \\<leftarrow> b_eval be1;\n        b2 \\<leftarrow> b_eval be2;\n        Some (b1 \\<and> b2)\n     }\n  )\"\n| \"a_eval aexp = (case aexp of\n     AConst x \\<Rightarrow> Some x\n   | Plus a1 a2 \\<Rightarrow> do {\n        x1 \\<leftarrow> a_eval a1;\n        x2 \\<leftarrow> a_eval a2;\n        Some (x1 + x2)\n     }\n   | Div a1 a2 \\<Rightarrow> do {\n        x1 \\<leftarrow> a_eval a1;\n        x2 \\<leftarrow> a_eval a2;\n        if (x2 = 0) then None else Some (x1 / x2)\n     }\n   | IfThenElse bexp a1 a2 \\<Rightarrow> do {\n        b \\<leftarrow> b_eval bexp;\n        (if b then a_eval a1 else a_eval a2)\n     }\n   | Mu b f a \\<Rightarrow> do {\n        mu_eval b f a 0\n     }\n  )\"\n| \"mu_eval b f a n = do {\n      x \\<leftarrow> a_eval a;\n      check \\<leftarrow> b_eval (b x); \n      (if check then Some (of_nat n) else \n       mu_eval b f (f x) (Suc n))\n   }\""], ["", "definition \n  \"five_minus_two = a_eval (Mu (\\<lambda> x. Eq (AConst 5) (AConst x)) (\\<lambda> x. Plus (AConst x) (AConst 1)) (AConst (2 :: rat)))\""], ["", "value five_minus_two"], ["", "subsection \\<open>An example with contexts\\<close>"], ["", "text \\<open>Mutual recursive partial functions also work within contexts.\\<close>"], ["", "context\n  fixes y :: int\nbegin"], ["", "partial_function_mr (tailrec) foo and bar where\n  \"foo x = (if x = y then foo (x - 1) else (bar x (y - 1)))\" \n| \"bar x z = foo (x + (1 :: int) + y)\""], ["", "end"], ["", "end"]]}