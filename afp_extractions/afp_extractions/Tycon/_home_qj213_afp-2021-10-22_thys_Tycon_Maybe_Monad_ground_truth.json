{"file_name": "/home/qj213/afp-2021-10-22/thys/Tycon/Maybe_Monad.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Tycon", "problem_names": ["lemma coerce_maybe_abs [simp]: \"coerce\\<cdot>(maybe_abs\\<cdot>x) = maybe_abs\\<cdot>(coerce\\<cdot>x)\"", "lemma coerce_Nothing [simp]: \"coerce\\<cdot>Nothing = Nothing\"", "lemma coerce_Just [simp]: \"coerce\\<cdot>(Just\\<cdot>x) = Just\\<cdot>(coerce\\<cdot>x)\"", "lemma fmapU_maybe_simps [simp]:\n  \"fmapU\\<cdot>f\\<cdot>(\\<bottom>::udom\\<cdot>maybe) = \\<bottom>\"\n  \"fmapU\\<cdot>f\\<cdot>Nothing = Nothing\"\n  \"fmapU\\<cdot>f\\<cdot>(Just\\<cdot>x) = Just\\<cdot>(f\\<cdot>x)\"", "lemma plusU_maybe_strict [simp]: \"plusU\\<cdot>\\<bottom>\\<cdot>ys = (\\<bottom>::udom\\<cdot>maybe)\"", "lemma bindU_maybe_strict [simp]: \"bindU\\<cdot>\\<bottom>\\<cdot>k = (\\<bottom>::udom\\<cdot>maybe)\"", "lemma plusU_Nothing_right: \"plusU\\<cdot>xs\\<cdot>Nothing = xs\"", "lemma bindU_plusU_maybe:\n  fixes xs ys :: \"udom\\<cdot>maybe\" shows\n  \"bindU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>f = plusU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>(bindU\\<cdot>ys\\<cdot>f)\"", "lemma fmap_maybe_simps [simp]:\n  \"fmap\\<cdot>f\\<cdot>(\\<bottom>::'a\\<cdot>maybe) = \\<bottom>\"\n  \"fmap\\<cdot>f\\<cdot>Nothing = Nothing\"\n  \"fmap\\<cdot>f\\<cdot>(Just\\<cdot>x) = Just\\<cdot>(f\\<cdot>x)\"", "lemma fplus_maybe_simps [simp]:\n  \"fplus\\<cdot>(\\<bottom>::'a\\<cdot>maybe)\\<cdot>ys = \\<bottom>\"\n  \"fplus\\<cdot>Nothing\\<cdot>ys = ys\"\n  \"fplus\\<cdot>(Just\\<cdot>x)\\<cdot>ys = Just\\<cdot>x\"", "lemma fplus_Nothing_right [simp]:\n  \"fplus\\<cdot>m\\<cdot>Nothing = m\"", "lemma bind_maybe_simps [simp]:\n  \"bind\\<cdot>(\\<bottom>::'a\\<cdot>maybe)\\<cdot>f = \\<bottom>\"\n  \"bind\\<cdot>Nothing\\<cdot>f = Nothing\"\n  \"bind\\<cdot>(Just\\<cdot>x)\\<cdot>f = f\\<cdot>x\"", "lemma return_maybe_def: \"return = Just\"", "lemma mzero_maybe_def: \"mzero = Nothing\"", "lemma join_maybe_simps [simp]:\n  \"join\\<cdot>(\\<bottom>::'a\\<cdot>maybe\\<cdot>maybe) = \\<bottom>\"\n  \"join\\<cdot>Nothing = Nothing\"\n  \"join\\<cdot>(Just\\<cdot>xs) = xs\"", "lemma maybe_counterexample1:\n  \"\\<lbrakk>a = Just\\<cdot>x; b = \\<bottom>; k\\<cdot>x = Nothing\\<rbrakk>\n    \\<Longrightarrow> fplus\\<cdot>a\\<cdot>b \\<bind> k \\<noteq> fplus\\<cdot>(a \\<bind> k)\\<cdot>(b \\<bind> k)\"", "lemma maybe_counterexample2:\n  \"\\<lbrakk>a = Just\\<cdot>x; b = Just\\<cdot>y; k\\<cdot>x = Nothing; k\\<cdot>y = Just\\<cdot>z\\<rbrakk>\n    \\<Longrightarrow> fplus\\<cdot>a\\<cdot>b \\<bind> k \\<noteq> fplus\\<cdot>(a \\<bind> k)\\<cdot>(b \\<bind> k)\""], "translations": [["", "lemma coerce_maybe_abs [simp]: \"coerce\\<cdot>(maybe_abs\\<cdot>x) = maybe_abs\\<cdot>(coerce\\<cdot>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('b\\<cdot>maybe, 'a\\<cdot>maybe)\\<cdot>(maybe_abs\\<cdot>x) =\n    maybe_abs\\<cdot>\n    (COERCE\n      (one \\<oplus> 'b\\<^sub>\\<bottom>,\n       one \\<oplus> 'a\\<^sub>\\<bottom>)\\<cdot>\n     x)", "apply (simp add: maybe_abs_def coerce_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. PRJ('a\\<cdot>maybe)\\<cdot>\n    (EMB('b\\<cdot>maybe)\\<cdot>\n     (PRJ('b\\<cdot>maybe)\\<cdot>\n      (EMB(one \\<oplus> 'b\\<^sub>\\<bottom>)\\<cdot>x))) =\n    PRJ('a\\<cdot>maybe)\\<cdot>\n    (EMB(one \\<oplus> 'a\\<^sub>\\<bottom>)\\<cdot>\n     (PRJ(one \\<oplus> 'a\\<^sub>\\<bottom>)\\<cdot>\n      (EMB(one \\<oplus> 'b\\<^sub>\\<bottom>)\\<cdot>x)))", "apply (simp add: emb_prj_emb prj_emb_prj DEFL_eq_maybe)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma coerce_Nothing [simp]: \"coerce\\<cdot>Nothing = Nothing\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('b\\<cdot>maybe, 'a\\<cdot>maybe)\\<cdot>Nothing = Nothing", "unfolding Nothing_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('b\\<cdot>maybe, 'a\\<cdot>maybe)\\<cdot>\n    (maybe_abs\\<cdot>(sinl\\<cdot>ONE)) =\n    maybe_abs\\<cdot>(sinl\\<cdot>ONE)", "by simp"], ["", "lemma coerce_Just [simp]: \"coerce\\<cdot>(Just\\<cdot>x) = Just\\<cdot>(coerce\\<cdot>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('b\\<cdot>maybe, 'a\\<cdot>maybe)\\<cdot>(Just\\<cdot>x) =\n    Just\\<cdot>(COERCE('b, 'a)\\<cdot>x)", "unfolding Just_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('b\\<cdot>maybe, 'a\\<cdot>maybe)\\<cdot>\n    ((\\<Lambda> a. maybe_abs\\<cdot>(sinr\\<cdot>(up\\<cdot>a)))\\<cdot>x) =\n    (\\<Lambda> a. maybe_abs\\<cdot>(sinr\\<cdot>(up\\<cdot>a)))\\<cdot>\n    (COERCE('b, 'a)\\<cdot>x)", "by simp"], ["", "lemma fmapU_maybe_simps [simp]:\n  \"fmapU\\<cdot>f\\<cdot>(\\<bottom>::udom\\<cdot>maybe) = \\<bottom>\"\n  \"fmapU\\<cdot>f\\<cdot>Nothing = Nothing\"\n  \"fmapU\\<cdot>f\\<cdot>(Just\\<cdot>x) = Just\\<cdot>(f\\<cdot>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmapU\\<cdot>f\\<cdot>\\<bottom> = \\<bottom> &&&\n    fmapU\\<cdot>f\\<cdot>Nothing = Nothing &&&\n    fmapU\\<cdot>f\\<cdot>(Just\\<cdot>x) = Just\\<cdot>(f\\<cdot>x)", "unfolding fmapU_maybe_def maybe_map_def fix_const"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> a.\n        maybe_abs oo\n        ssum_map\\<cdot>ID\\<cdot>(u_map\\<cdot>a) oo maybe_rep)\\<cdot>\n    f\\<cdot>\n    \\<bottom> =\n    \\<bottom> &&&\n    (\\<Lambda> a.\n        maybe_abs oo\n        ssum_map\\<cdot>ID\\<cdot>(u_map\\<cdot>a) oo maybe_rep)\\<cdot>\n    f\\<cdot>\n    Nothing =\n    Nothing &&&\n    (\\<Lambda> a.\n        maybe_abs oo\n        ssum_map\\<cdot>ID\\<cdot>(u_map\\<cdot>a) oo maybe_rep)\\<cdot>\n    f\\<cdot>\n    (Just\\<cdot>x) =\n    Just\\<cdot>(f\\<cdot>x)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<Lambda> a.\n        maybe_abs oo\n        ssum_map\\<cdot>ID\\<cdot>(u_map\\<cdot>a) oo maybe_rep)\\<cdot>\n    f\\<cdot>\n    Nothing =\n    Nothing\n 2. (\\<Lambda> a.\n        maybe_abs oo\n        ssum_map\\<cdot>ID\\<cdot>(u_map\\<cdot>a) oo maybe_rep)\\<cdot>\n    f\\<cdot>\n    (Just\\<cdot>x) =\n    Just\\<cdot>(f\\<cdot>x)", "apply (simp add: Nothing_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> a.\n        maybe_abs oo\n        ssum_map\\<cdot>ID\\<cdot>(u_map\\<cdot>a) oo maybe_rep)\\<cdot>\n    f\\<cdot>\n    (Just\\<cdot>x) =\n    Just\\<cdot>(f\\<cdot>x)", "apply (simp add: Just_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Class instance proofs\\<close>"], ["", "instance maybe :: \"functor\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(maybe, functor_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f g xs.\n       fmapU\\<cdot>f\\<cdot>(fmapU\\<cdot>g\\<cdot>xs) =\n       fmapU\\<cdot>(\\<Lambda> x. f\\<cdot>(g\\<cdot>x))\\<cdot>xs", "apply (induct_tac xs rule: maybe.induct, simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "instantiation maybe :: \"{functor_zero_plus, monad_zero}\"\nbegin"], ["", "fixrec plusU_maybe :: \"udom\\<cdot>maybe \\<rightarrow> udom\\<cdot>maybe \\<rightarrow> udom\\<cdot>maybe\"\n  where \"plusU_maybe\\<cdot>Nothing\\<cdot>ys = ys\"\n  | \"plusU_maybe\\<cdot>(Just\\<cdot>x)\\<cdot>ys = Just\\<cdot>x\""], ["", "lemma plusU_maybe_strict [simp]: \"plusU\\<cdot>\\<bottom>\\<cdot>ys = (\\<bottom>::udom\\<cdot>maybe)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plusU\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom>", "by fixrec_simp"], ["", "fixrec bindU_maybe :: \"udom\\<cdot>maybe \\<rightarrow> (udom \\<rightarrow> udom\\<cdot>maybe) \\<rightarrow> udom\\<cdot>maybe\"\n  where \"bindU_maybe\\<cdot>Nothing\\<cdot>k = Nothing\"\n  | \"bindU_maybe\\<cdot>(Just\\<cdot>x)\\<cdot>k = k\\<cdot>x\""], ["", "lemma bindU_maybe_strict [simp]: \"bindU\\<cdot>\\<bottom>\\<cdot>k = (\\<bottom>::udom\\<cdot>maybe)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bindU\\<cdot>\\<bottom>\\<cdot>k = \\<bottom>", "by fixrec_simp"], ["", "definition zeroU_maybe_def:\n  \"zeroU = Nothing\""], ["", "definition returnU_maybe_def:\n  \"returnU = Just\""], ["", "lemma plusU_Nothing_right: \"plusU\\<cdot>xs\\<cdot>Nothing = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plusU\\<cdot>xs\\<cdot>Nothing = xs", "by (induct xs rule: maybe.induct) simp_all"], ["", "lemma bindU_plusU_maybe:\n  fixes xs ys :: \"udom\\<cdot>maybe\" shows\n  \"bindU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>f = plusU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>(bindU\\<cdot>ys\\<cdot>f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bindU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>f =\n    plusU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>(bindU\\<cdot>ys\\<cdot>f)", "apply (induct xs rule: maybe.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. bindU\\<cdot>(plusU\\<cdot>\\<bottom>\\<cdot>ys)\\<cdot>f =\n    plusU\\<cdot>(bindU\\<cdot>\\<bottom>\\<cdot>f)\\<cdot>\n    (bindU\\<cdot>ys\\<cdot>f)\n 2. bindU\\<cdot>(plusU\\<cdot>Nothing\\<cdot>ys)\\<cdot>f =\n    plusU\\<cdot>(bindU\\<cdot>Nothing\\<cdot>f)\\<cdot>(bindU\\<cdot>ys\\<cdot>f)\n 3. \\<And>a.\n       bindU\\<cdot>(plusU\\<cdot>(Just\\<cdot>a)\\<cdot>ys)\\<cdot>f =\n       plusU\\<cdot>(bindU\\<cdot>(Just\\<cdot>a)\\<cdot>f)\\<cdot>\n       (bindU\\<cdot>ys\\<cdot>f)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       f\\<cdot>a = plusU\\<cdot>(f\\<cdot>a)\\<cdot>(bindU\\<cdot>ys\\<cdot>f)", "oops"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(maybe, monad_zero_class) &&&\n    OFCLASS(maybe, functor_zero_plus_class)", "proof"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>f xs.\n       fmapU\\<cdot>f\\<cdot>xs =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. returnU\\<cdot>(f\\<cdot>x))\n 2. \\<And>f x. bindU\\<cdot>(returnU\\<cdot>x)\\<cdot>f = f\\<cdot>x\n 3. \\<And>xs f g.\n       bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>g =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(f\\<cdot>x)\\<cdot>g)\n 4. \\<And>f. bindU\\<cdot>zeroU\\<cdot>f = zeroU\n 5. \\<And>f a b.\n       fmapU\\<cdot>f\\<cdot>(plusU\\<cdot>a\\<cdot>b) =\n       plusU\\<cdot>(fmapU\\<cdot>f\\<cdot>a)\\<cdot>(fmapU\\<cdot>f\\<cdot>b)\n 6. \\<And>a b c.\n       plusU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>c =\n       plusU\\<cdot>a\\<cdot>(plusU\\<cdot>b\\<cdot>c)\n 7. \\<And>f. fmapU\\<cdot>f\\<cdot>zeroU = zeroU\n 8. \\<And>m. plusU\\<cdot>zeroU\\<cdot>m = m\n 9. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "fix x :: \"udom\""], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>f xs.\n       fmapU\\<cdot>f\\<cdot>xs =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. returnU\\<cdot>(f\\<cdot>x))\n 2. \\<And>f x. bindU\\<cdot>(returnU\\<cdot>x)\\<cdot>f = f\\<cdot>x\n 3. \\<And>xs f g.\n       bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>g =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(f\\<cdot>x)\\<cdot>g)\n 4. \\<And>f. bindU\\<cdot>zeroU\\<cdot>f = zeroU\n 5. \\<And>f a b.\n       fmapU\\<cdot>f\\<cdot>(plusU\\<cdot>a\\<cdot>b) =\n       plusU\\<cdot>(fmapU\\<cdot>f\\<cdot>a)\\<cdot>(fmapU\\<cdot>f\\<cdot>b)\n 6. \\<And>a b c.\n       plusU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>c =\n       plusU\\<cdot>a\\<cdot>(plusU\\<cdot>b\\<cdot>c)\n 7. \\<And>f. fmapU\\<cdot>f\\<cdot>zeroU = zeroU\n 8. \\<And>m. plusU\\<cdot>zeroU\\<cdot>m = m\n 9. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "fix f :: \"udom \\<rightarrow> udom\""], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>f xs.\n       fmapU\\<cdot>f\\<cdot>xs =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. returnU\\<cdot>(f\\<cdot>x))\n 2. \\<And>f x. bindU\\<cdot>(returnU\\<cdot>x)\\<cdot>f = f\\<cdot>x\n 3. \\<And>xs f g.\n       bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>g =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(f\\<cdot>x)\\<cdot>g)\n 4. \\<And>f. bindU\\<cdot>zeroU\\<cdot>f = zeroU\n 5. \\<And>f a b.\n       fmapU\\<cdot>f\\<cdot>(plusU\\<cdot>a\\<cdot>b) =\n       plusU\\<cdot>(fmapU\\<cdot>f\\<cdot>a)\\<cdot>(fmapU\\<cdot>f\\<cdot>b)\n 6. \\<And>a b c.\n       plusU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>c =\n       plusU\\<cdot>a\\<cdot>(plusU\\<cdot>b\\<cdot>c)\n 7. \\<And>f. fmapU\\<cdot>f\\<cdot>zeroU = zeroU\n 8. \\<And>m. plusU\\<cdot>zeroU\\<cdot>m = m\n 9. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "fix h k :: \"udom \\<rightarrow> udom\\<cdot>maybe\""], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>f xs.\n       fmapU\\<cdot>f\\<cdot>xs =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. returnU\\<cdot>(f\\<cdot>x))\n 2. \\<And>f x. bindU\\<cdot>(returnU\\<cdot>x)\\<cdot>f = f\\<cdot>x\n 3. \\<And>xs f g.\n       bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>g =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(f\\<cdot>x)\\<cdot>g)\n 4. \\<And>f. bindU\\<cdot>zeroU\\<cdot>f = zeroU\n 5. \\<And>f a b.\n       fmapU\\<cdot>f\\<cdot>(plusU\\<cdot>a\\<cdot>b) =\n       plusU\\<cdot>(fmapU\\<cdot>f\\<cdot>a)\\<cdot>(fmapU\\<cdot>f\\<cdot>b)\n 6. \\<And>a b c.\n       plusU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>c =\n       plusU\\<cdot>a\\<cdot>(plusU\\<cdot>b\\<cdot>c)\n 7. \\<And>f. fmapU\\<cdot>f\\<cdot>zeroU = zeroU\n 8. \\<And>m. plusU\\<cdot>zeroU\\<cdot>m = m\n 9. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "fix xs ys zs :: \"udom\\<cdot>maybe\""], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>f xs.\n       fmapU\\<cdot>f\\<cdot>xs =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. returnU\\<cdot>(f\\<cdot>x))\n 2. \\<And>f x. bindU\\<cdot>(returnU\\<cdot>x)\\<cdot>f = f\\<cdot>x\n 3. \\<And>xs f g.\n       bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>g =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(f\\<cdot>x)\\<cdot>g)\n 4. \\<And>f. bindU\\<cdot>zeroU\\<cdot>f = zeroU\n 5. \\<And>f a b.\n       fmapU\\<cdot>f\\<cdot>(plusU\\<cdot>a\\<cdot>b) =\n       plusU\\<cdot>(fmapU\\<cdot>f\\<cdot>a)\\<cdot>(fmapU\\<cdot>f\\<cdot>b)\n 6. \\<And>a b c.\n       plusU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>c =\n       plusU\\<cdot>a\\<cdot>(plusU\\<cdot>b\\<cdot>c)\n 7. \\<And>f. fmapU\\<cdot>f\\<cdot>zeroU = zeroU\n 8. \\<And>m. plusU\\<cdot>zeroU\\<cdot>m = m\n 9. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "show \"fmapU\\<cdot>f\\<cdot>xs = bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. returnU\\<cdot>(f\\<cdot>x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmapU\\<cdot>f\\<cdot>xs =\n    bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. returnU\\<cdot>(f\\<cdot>x))", "by (induct xs rule: maybe.induct, simp_all add: returnU_maybe_def)"], ["proof (state)\nthis:\n  fmapU\\<cdot>f\\<cdot>xs =\n  bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. returnU\\<cdot>(f\\<cdot>x))\n\ngoal (8 subgoals):\n 1. \\<And>f x. bindU\\<cdot>(returnU\\<cdot>x)\\<cdot>f = f\\<cdot>x\n 2. \\<And>xs f g.\n       bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>g =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(f\\<cdot>x)\\<cdot>g)\n 3. \\<And>f. bindU\\<cdot>zeroU\\<cdot>f = zeroU\n 4. \\<And>f a b.\n       fmapU\\<cdot>f\\<cdot>(plusU\\<cdot>a\\<cdot>b) =\n       plusU\\<cdot>(fmapU\\<cdot>f\\<cdot>a)\\<cdot>(fmapU\\<cdot>f\\<cdot>b)\n 5. \\<And>a b c.\n       plusU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>c =\n       plusU\\<cdot>a\\<cdot>(plusU\\<cdot>b\\<cdot>c)\n 6. \\<And>f. fmapU\\<cdot>f\\<cdot>zeroU = zeroU\n 7. \\<And>m. plusU\\<cdot>zeroU\\<cdot>m = m\n 8. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "show \"bindU\\<cdot>(returnU\\<cdot>x)\\<cdot>k = k\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bindU\\<cdot>(returnU\\<cdot>x)\\<cdot>k = k\\<cdot>x", "by (simp add: returnU_maybe_def plusU_Nothing_right)"], ["proof (state)\nthis:\n  bindU\\<cdot>(returnU\\<cdot>x)\\<cdot>k = k\\<cdot>x\n\ngoal (7 subgoals):\n 1. \\<And>xs f g.\n       bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>g =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(f\\<cdot>x)\\<cdot>g)\n 2. \\<And>f. bindU\\<cdot>zeroU\\<cdot>f = zeroU\n 3. \\<And>f a b.\n       fmapU\\<cdot>f\\<cdot>(plusU\\<cdot>a\\<cdot>b) =\n       plusU\\<cdot>(fmapU\\<cdot>f\\<cdot>a)\\<cdot>(fmapU\\<cdot>f\\<cdot>b)\n 4. \\<And>a b c.\n       plusU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>c =\n       plusU\\<cdot>a\\<cdot>(plusU\\<cdot>b\\<cdot>c)\n 5. \\<And>f. fmapU\\<cdot>f\\<cdot>zeroU = zeroU\n 6. \\<And>m. plusU\\<cdot>zeroU\\<cdot>m = m\n 7. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "show \"bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>h)\\<cdot>k = bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(h\\<cdot>x)\\<cdot>k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>h)\\<cdot>k =\n    bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(h\\<cdot>x)\\<cdot>k)", "by (induct xs rule: maybe.induct) simp_all"], ["proof (state)\nthis:\n  bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>h)\\<cdot>k =\n  bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(h\\<cdot>x)\\<cdot>k)\n\ngoal (6 subgoals):\n 1. \\<And>f. bindU\\<cdot>zeroU\\<cdot>f = zeroU\n 2. \\<And>f a b.\n       fmapU\\<cdot>f\\<cdot>(plusU\\<cdot>a\\<cdot>b) =\n       plusU\\<cdot>(fmapU\\<cdot>f\\<cdot>a)\\<cdot>(fmapU\\<cdot>f\\<cdot>b)\n 3. \\<And>a b c.\n       plusU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>c =\n       plusU\\<cdot>a\\<cdot>(plusU\\<cdot>b\\<cdot>c)\n 4. \\<And>f. fmapU\\<cdot>f\\<cdot>zeroU = zeroU\n 5. \\<And>m. plusU\\<cdot>zeroU\\<cdot>m = m\n 6. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "show \"plusU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>zs = plusU\\<cdot>xs\\<cdot>(plusU\\<cdot>ys\\<cdot>zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plusU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>zs =\n    plusU\\<cdot>xs\\<cdot>(plusU\\<cdot>ys\\<cdot>zs)", "by (induct xs rule: maybe.induct) simp_all"], ["proof (state)\nthis:\n  plusU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>zs =\n  plusU\\<cdot>xs\\<cdot>(plusU\\<cdot>ys\\<cdot>zs)\n\ngoal (5 subgoals):\n 1. \\<And>f. bindU\\<cdot>zeroU\\<cdot>f = zeroU\n 2. \\<And>f a b.\n       fmapU\\<cdot>f\\<cdot>(plusU\\<cdot>a\\<cdot>b) =\n       plusU\\<cdot>(fmapU\\<cdot>f\\<cdot>a)\\<cdot>(fmapU\\<cdot>f\\<cdot>b)\n 3. \\<And>f. fmapU\\<cdot>f\\<cdot>zeroU = zeroU\n 4. \\<And>m. plusU\\<cdot>zeroU\\<cdot>m = m\n 5. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "show \"bindU\\<cdot>zeroU\\<cdot>k = zeroU\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bindU\\<cdot>zeroU\\<cdot>k = zeroU", "by (simp add: zeroU_maybe_def)"], ["proof (state)\nthis:\n  bindU\\<cdot>zeroU\\<cdot>k = zeroU\n\ngoal (4 subgoals):\n 1. \\<And>f a b.\n       fmapU\\<cdot>f\\<cdot>(plusU\\<cdot>a\\<cdot>b) =\n       plusU\\<cdot>(fmapU\\<cdot>f\\<cdot>a)\\<cdot>(fmapU\\<cdot>f\\<cdot>b)\n 2. \\<And>f. fmapU\\<cdot>f\\<cdot>zeroU = zeroU\n 3. \\<And>m. plusU\\<cdot>zeroU\\<cdot>m = m\n 4. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "show \"fmapU\\<cdot>f\\<cdot>(plusU\\<cdot>xs\\<cdot>ys) = plusU\\<cdot>(fmapU\\<cdot>f\\<cdot>xs)\\<cdot>(fmapU\\<cdot>f\\<cdot>ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmapU\\<cdot>f\\<cdot>(plusU\\<cdot>xs\\<cdot>ys) =\n    plusU\\<cdot>(fmapU\\<cdot>f\\<cdot>xs)\\<cdot>(fmapU\\<cdot>f\\<cdot>ys)", "by (induct xs rule: maybe.induct) simp_all"], ["proof (state)\nthis:\n  fmapU\\<cdot>f\\<cdot>(plusU\\<cdot>xs\\<cdot>ys) =\n  plusU\\<cdot>(fmapU\\<cdot>f\\<cdot>xs)\\<cdot>(fmapU\\<cdot>f\\<cdot>ys)\n\ngoal (3 subgoals):\n 1. \\<And>f. fmapU\\<cdot>f\\<cdot>zeroU = zeroU\n 2. \\<And>m. plusU\\<cdot>zeroU\\<cdot>m = m\n 3. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "show \"fmapU\\<cdot>f\\<cdot>zeroU = (zeroU :: udom\\<cdot>maybe)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmapU\\<cdot>f\\<cdot>zeroU = zeroU", "by (simp add: zeroU_maybe_def)"], ["proof (state)\nthis:\n  fmapU\\<cdot>f\\<cdot>zeroU = zeroU\n\ngoal (2 subgoals):\n 1. \\<And>m. plusU\\<cdot>zeroU\\<cdot>m = m\n 2. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "show \"plusU\\<cdot>zeroU\\<cdot>xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plusU\\<cdot>zeroU\\<cdot>xs = xs", "by (simp add: zeroU_maybe_def)"], ["proof (state)\nthis:\n  plusU\\<cdot>zeroU\\<cdot>xs = xs\n\ngoal (1 subgoal):\n 1. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "show \"plusU\\<cdot>xs\\<cdot>zeroU = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plusU\\<cdot>xs\\<cdot>zeroU = xs", "by (simp add: zeroU_maybe_def plusU_Nothing_right)"], ["proof (state)\nthis:\n  plusU\\<cdot>xs\\<cdot>zeroU = xs\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Transfer properties to polymorphic versions\\<close>"], ["", "lemma fmap_maybe_simps [simp]:\n  \"fmap\\<cdot>f\\<cdot>(\\<bottom>::'a\\<cdot>maybe) = \\<bottom>\"\n  \"fmap\\<cdot>f\\<cdot>Nothing = Nothing\"\n  \"fmap\\<cdot>f\\<cdot>(Just\\<cdot>x) = Just\\<cdot>(f\\<cdot>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap\\<cdot>f\\<cdot>\\<bottom> = \\<bottom> &&&\n    fmap\\<cdot>f\\<cdot>Nothing = Nothing &&&\n    fmap\\<cdot>f\\<cdot>(Just\\<cdot>x) = Just\\<cdot>(f\\<cdot>x)", "unfolding fmap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE\n     ((udom \\<rightarrow> udom) \\<rightarrow>\n      udom\\<cdot>maybe \\<rightarrow> udom\\<cdot>maybe,\n      ('a \\<rightarrow> 'b) \\<rightarrow>\n      'a\\<cdot>maybe \\<rightarrow> 'b\\<cdot>maybe)\\<cdot>\n    fmapU\\<cdot>\n    f\\<cdot>\n    \\<bottom> =\n    \\<bottom> &&&\n    COERCE\n     ((udom \\<rightarrow> udom) \\<rightarrow>\n      udom\\<cdot>maybe \\<rightarrow> udom\\<cdot>maybe,\n      ('a \\<rightarrow> 'b) \\<rightarrow>\n      'a\\<cdot>maybe \\<rightarrow> 'b\\<cdot>maybe)\\<cdot>\n    fmapU\\<cdot>\n    f\\<cdot>\n    Nothing =\n    Nothing &&&\n    COERCE\n     ((udom \\<rightarrow> udom) \\<rightarrow>\n      udom\\<cdot>maybe \\<rightarrow> udom\\<cdot>maybe,\n      ('a \\<rightarrow> 'b) \\<rightarrow>\n      'a\\<cdot>maybe \\<rightarrow> 'b\\<cdot>maybe)\\<cdot>\n    fmapU\\<cdot>\n    f\\<cdot>\n    (Just\\<cdot>x) =\n    Just\\<cdot>(f\\<cdot>x)", "by simp_all"], ["", "lemma fplus_maybe_simps [simp]:\n  \"fplus\\<cdot>(\\<bottom>::'a\\<cdot>maybe)\\<cdot>ys = \\<bottom>\"\n  \"fplus\\<cdot>Nothing\\<cdot>ys = ys\"\n  \"fplus\\<cdot>(Just\\<cdot>x)\\<cdot>ys = Just\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fplus\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom> &&&\n    fplus\\<cdot>Nothing\\<cdot>ys = ys &&&\n    fplus\\<cdot>(Just\\<cdot>x)\\<cdot>ys = Just\\<cdot>x", "unfolding fplus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE\n     (udom\\<cdot>maybe \\<rightarrow>\n      udom\\<cdot>maybe \\<rightarrow> udom\\<cdot>maybe,\n      'a\\<cdot>maybe \\<rightarrow>\n      'a\\<cdot>maybe \\<rightarrow> 'a\\<cdot>maybe)\\<cdot>\n    plusU\\<cdot>\n    \\<bottom>\\<cdot>\n    ys =\n    \\<bottom> &&&\n    COERCE\n     (udom\\<cdot>maybe \\<rightarrow>\n      udom\\<cdot>maybe \\<rightarrow> udom\\<cdot>maybe,\n      'a\\<cdot>maybe \\<rightarrow>\n      'a\\<cdot>maybe \\<rightarrow> 'a\\<cdot>maybe)\\<cdot>\n    plusU\\<cdot>\n    Nothing\\<cdot>\n    ys =\n    ys &&&\n    COERCE\n     (udom\\<cdot>maybe \\<rightarrow>\n      udom\\<cdot>maybe \\<rightarrow> udom\\<cdot>maybe,\n      'a\\<cdot>maybe \\<rightarrow>\n      'a\\<cdot>maybe \\<rightarrow> 'a\\<cdot>maybe)\\<cdot>\n    plusU\\<cdot>\n    (Just\\<cdot>x)\\<cdot>\n    ys =\n    Just\\<cdot>x", "by simp_all"], ["", "lemma fplus_Nothing_right [simp]:\n  \"fplus\\<cdot>m\\<cdot>Nothing = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fplus\\<cdot>m\\<cdot>Nothing = m", "by (simp add: fplus_def plusU_Nothing_right)"], ["", "lemma bind_maybe_simps [simp]:\n  \"bind\\<cdot>(\\<bottom>::'a\\<cdot>maybe)\\<cdot>f = \\<bottom>\"\n  \"bind\\<cdot>Nothing\\<cdot>f = Nothing\"\n  \"bind\\<cdot>(Just\\<cdot>x)\\<cdot>f = f\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<bind> f = \\<bottom> &&&\n    Nothing \\<bind> f = Nothing &&& Just\\<cdot>x \\<bind> f = f\\<cdot>x", "unfolding bind_def fplus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE\n     (udom\\<cdot>maybe \\<rightarrow>\n      (udom \\<rightarrow> udom\\<cdot>maybe) \\<rightarrow> udom\\<cdot>maybe,\n      'a\\<cdot>maybe \\<rightarrow>\n      ('a \\<rightarrow> 'b\\<cdot>maybe) \\<rightarrow> 'b\\<cdot>maybe)\\<cdot>\n    bindU\\<cdot>\n    \\<bottom>\\<cdot>\n    f =\n    \\<bottom> &&&\n    COERCE\n     (udom\\<cdot>maybe \\<rightarrow>\n      (udom \\<rightarrow> udom\\<cdot>maybe) \\<rightarrow> udom\\<cdot>maybe,\n      'a\\<cdot>maybe \\<rightarrow>\n      ('a \\<rightarrow> 'b\\<cdot>maybe) \\<rightarrow> 'b\\<cdot>maybe)\\<cdot>\n    bindU\\<cdot>\n    Nothing\\<cdot>\n    f =\n    Nothing &&&\n    COERCE\n     (udom\\<cdot>maybe \\<rightarrow>\n      (udom \\<rightarrow> udom\\<cdot>maybe) \\<rightarrow> udom\\<cdot>maybe,\n      'a\\<cdot>maybe \\<rightarrow>\n      ('a \\<rightarrow> 'b\\<cdot>maybe) \\<rightarrow> 'b\\<cdot>maybe)\\<cdot>\n    bindU\\<cdot>\n    (Just\\<cdot>x)\\<cdot>\n    f =\n    f\\<cdot>x", "by simp_all"], ["", "lemma return_maybe_def: \"return = Just\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return = Just", "unfolding return_def returnU_maybe_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE\n     (udom \\<rightarrow> udom\\<cdot>maybe,\n      'a \\<rightarrow> 'a\\<cdot>maybe)\\<cdot>\n    Just =\n    Just", "by (simp add: coerce_cfun cfcomp1 eta_cfun)"], ["", "lemma mzero_maybe_def: \"mzero = Nothing\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mzero = Nothing", "unfolding mzero_def zeroU_maybe_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE(udom\\<cdot>maybe, 'a\\<cdot>maybe)\\<cdot>Nothing = Nothing", "by simp"], ["", "lemma join_maybe_simps [simp]:\n  \"join\\<cdot>(\\<bottom>::'a\\<cdot>maybe\\<cdot>maybe) = \\<bottom>\"\n  \"join\\<cdot>Nothing = Nothing\"\n  \"join\\<cdot>(Just\\<cdot>xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. join\\<cdot>\\<bottom> = \\<bottom> &&&\n    join\\<cdot>Nothing = Nothing &&& join\\<cdot>(Just\\<cdot>xs) = xs", "unfolding join_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> m. m \\<bind> (\\<Lambda> x. x))\\<cdot>\\<bottom> =\n    \\<bottom> &&&\n    (\\<Lambda> m. m \\<bind> (\\<Lambda> x. x))\\<cdot>Nothing = Nothing &&&\n    (\\<Lambda> m. m \\<bind> (\\<Lambda> x. x))\\<cdot>(Just\\<cdot>xs) = xs", "by simp_all"], ["", "subsection \\<open>Maybe is not in \\<open>monad_plus\\<close>\\<close>"], ["", "text \\<open>\n  The \\<open>maybe\\<close> type does not satisfy the law \\<open>bind_mplus\\<close>.\n\\<close>"], ["", "lemma maybe_counterexample1:\n  \"\\<lbrakk>a = Just\\<cdot>x; b = \\<bottom>; k\\<cdot>x = Nothing\\<rbrakk>\n    \\<Longrightarrow> fplus\\<cdot>a\\<cdot>b \\<bind> k \\<noteq> fplus\\<cdot>(a \\<bind> k)\\<cdot>(b \\<bind> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Just\\<cdot>x; b = \\<bottom>; k\\<cdot>x = Nothing\\<rbrakk>\n    \\<Longrightarrow> fplus\\<cdot>a\\<cdot>b \\<bind> k \\<noteq>\n                      fplus\\<cdot>(a \\<bind> k)\\<cdot>(b \\<bind> k)", "by simp"], ["", "lemma maybe_counterexample2:\n  \"\\<lbrakk>a = Just\\<cdot>x; b = Just\\<cdot>y; k\\<cdot>x = Nothing; k\\<cdot>y = Just\\<cdot>z\\<rbrakk>\n    \\<Longrightarrow> fplus\\<cdot>a\\<cdot>b \\<bind> k \\<noteq> fplus\\<cdot>(a \\<bind> k)\\<cdot>(b \\<bind> k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = Just\\<cdot>x; b = Just\\<cdot>y; k\\<cdot>x = Nothing;\n     k\\<cdot>y = Just\\<cdot>z\\<rbrakk>\n    \\<Longrightarrow> fplus\\<cdot>a\\<cdot>b \\<bind> k \\<noteq>\n                      fplus\\<cdot>(a \\<bind> k)\\<cdot>(b \\<bind> k)", "by simp"], ["", "end"]]}