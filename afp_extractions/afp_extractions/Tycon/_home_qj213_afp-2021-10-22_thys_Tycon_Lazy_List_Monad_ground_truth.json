{"file_name": "/home/qj213/afp-2021-10-22/thys/Tycon/Lazy_List_Monad.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Tycon", "problem_names": ["lemma coerce_llist_abs [simp]: \"coerce\\<cdot>(llist_abs\\<cdot>x) = llist_abs\\<cdot>(coerce\\<cdot>x)\"", "lemma coerce_LNil [simp]: \"coerce\\<cdot>LNil = LNil\"", "lemma coerce_LCons [simp]: \"coerce\\<cdot>(LCons\\<cdot>x\\<cdot>xs) = LCons\\<cdot>(coerce\\<cdot>x)\\<cdot>(coerce\\<cdot>xs)\"", "lemma fmapU_llist_simps [simp]:\n  \"fmapU\\<cdot>f\\<cdot>(\\<bottom>::udom\\<cdot>llist) = \\<bottom>\"\n  \"fmapU\\<cdot>f\\<cdot>LNil = LNil\"\n  \"fmapU\\<cdot>f\\<cdot>(LCons\\<cdot>x\\<cdot>xs) = LCons\\<cdot>(f\\<cdot>x)\\<cdot>(fmapU\\<cdot>f\\<cdot>xs)\"", "lemma plusU_llist_strict [simp]: \"plusU\\<cdot>\\<bottom>\\<cdot>ys = (\\<bottom>::udom\\<cdot>llist)\"", "lemma bindU_llist_strict [simp]: \"bindU\\<cdot>\\<bottom>\\<cdot>k = (\\<bottom>::udom\\<cdot>llist)\"", "lemma plusU_LNil_right: \"plusU\\<cdot>xs\\<cdot>LNil = xs\"", "lemma plusU_llist_assoc:\n  fixes xs ys zs :: \"udom\\<cdot>llist\"\n  shows \"plusU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>zs = plusU\\<cdot>xs\\<cdot>(plusU\\<cdot>ys\\<cdot>zs)\"", "lemma bindU_plusU_llist:\n  fixes xs ys :: \"udom\\<cdot>llist\" shows\n  \"bindU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>f = plusU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>(bindU\\<cdot>ys\\<cdot>f)\"", "lemma fmap_llist_simps [simp]:\n  \"fmap\\<cdot>f\\<cdot>(\\<bottom>::'a\\<cdot>llist) = \\<bottom>\"\n  \"fmap\\<cdot>f\\<cdot>LNil = LNil\"\n  \"fmap\\<cdot>f\\<cdot>(LCons\\<cdot>x\\<cdot>xs) = LCons\\<cdot>(f\\<cdot>x)\\<cdot>(fmap\\<cdot>f\\<cdot>xs)\"", "lemma mplus_llist_simps [simp]:\n  \"mplus\\<cdot>(\\<bottom>::'a\\<cdot>llist)\\<cdot>ys = \\<bottom>\"\n  \"mplus\\<cdot>LNil\\<cdot>ys = ys\"\n  \"mplus\\<cdot>(LCons\\<cdot>x\\<cdot>xs)\\<cdot>ys = LCons\\<cdot>x\\<cdot>(mplus\\<cdot>xs\\<cdot>ys)\"", "lemma bind_llist_simps [simp]:\n  \"bind\\<cdot>(\\<bottom>::'a\\<cdot>llist)\\<cdot>f = \\<bottom>\"\n  \"bind\\<cdot>LNil\\<cdot>f = LNil\"\n  \"bind\\<cdot>(LCons\\<cdot>x\\<cdot>xs)\\<cdot>f = mplus\\<cdot>(f\\<cdot>x)\\<cdot>(bind\\<cdot>xs\\<cdot>f)\"", "lemma return_llist_def:\n  \"return = (\\<Lambda> x. LCons\\<cdot>x\\<cdot>LNil)\"", "lemma mzero_llist_def:\n  \"mzero = LNil\"", "lemma join_llist_simps [simp]:\n  \"join\\<cdot>(\\<bottom>::'a\\<cdot>llist\\<cdot>llist) = \\<bottom>\"\n  \"join\\<cdot>LNil = LNil\"\n  \"join\\<cdot>(LCons\\<cdot>xs\\<cdot>xss) = mplus\\<cdot>xs\\<cdot>(join\\<cdot>xss)\""], "translations": [["", "lemma coerce_llist_abs [simp]: \"coerce\\<cdot>(llist_abs\\<cdot>x) = llist_abs\\<cdot>(coerce\\<cdot>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('b\\<cdot>llist, 'a\\<cdot>llist)\\<cdot>(llist_abs\\<cdot>x) =\n    llist_abs\\<cdot>\n    (COERCE\n      (one \\<oplus>\n       'b\\<^sub>\\<bottom> \\<otimes> ('b\\<cdot>llist)\\<^sub>\\<bottom>,\n       one \\<oplus>\n       'a\\<^sub>\\<bottom> \\<otimes> ('a\\<cdot>llist)\\<^sub>\\<bottom>)\\<cdot>\n     x)", "apply (simp add: llist_abs_def coerce_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. PRJ('a\\<cdot>llist)\\<cdot>\n    (EMB('b\\<cdot>llist)\\<cdot>\n     (PRJ('b\\<cdot>llist)\\<cdot>\n      (EMB(one \\<oplus>\n           'b\\<^sub>\\<bottom> \\<otimes>\n           ('b\\<cdot>llist)\\<^sub>\\<bottom>)\\<cdot>\n       x))) =\n    PRJ('a\\<cdot>llist)\\<cdot>\n    (EMB(one \\<oplus>\n         'a\\<^sub>\\<bottom> \\<otimes>\n         ('a\\<cdot>llist)\\<^sub>\\<bottom>)\\<cdot>\n     (PRJ(one \\<oplus>\n          'a\\<^sub>\\<bottom> \\<otimes>\n          ('a\\<cdot>llist)\\<^sub>\\<bottom>)\\<cdot>\n      (EMB(one \\<oplus>\n           'b\\<^sub>\\<bottom> \\<otimes>\n           ('b\\<cdot>llist)\\<^sub>\\<bottom>)\\<cdot>\n       x)))", "apply (simp add: emb_prj_emb prj_emb_prj DEFL_eq_llist)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma coerce_LNil [simp]: \"coerce\\<cdot>LNil = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('b\\<cdot>llist, 'a\\<cdot>llist)\\<cdot>LNil = LNil", "unfolding LNil_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('b\\<cdot>llist, 'a\\<cdot>llist)\\<cdot>\n    (llist_abs\\<cdot>(sinl\\<cdot>ONE)) =\n    llist_abs\\<cdot>(sinl\\<cdot>ONE)", "by simp"], ["", "lemma coerce_LCons [simp]: \"coerce\\<cdot>(LCons\\<cdot>x\\<cdot>xs) = LCons\\<cdot>(coerce\\<cdot>x)\\<cdot>(coerce\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('b\\<cdot>llist, 'a\\<cdot>llist)\\<cdot>(LCons\\<cdot>x\\<cdot>xs) =\n    LCons\\<cdot>(COERCE('b, 'a)\\<cdot>x)\\<cdot>\n    (COERCE('b\\<cdot>llist, 'a\\<cdot>llist)\\<cdot>xs)", "unfolding LCons_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('b\\<cdot>llist, 'a\\<cdot>llist)\\<cdot>\n    ((\\<Lambda> a app.\n         llist_abs\\<cdot>(sinr\\<cdot>(:up\\<cdot>a, up\\<cdot>app:)))\\<cdot>\n     x\\<cdot>\n     xs) =\n    (\\<Lambda> a app.\n        llist_abs\\<cdot>(sinr\\<cdot>(:up\\<cdot>a, up\\<cdot>app:)))\\<cdot>\n    (COERCE('b, 'a)\\<cdot>x)\\<cdot>\n    (COERCE('b\\<cdot>llist, 'a\\<cdot>llist)\\<cdot>xs)", "by simp"], ["", "lemma fmapU_llist_simps [simp]:\n  \"fmapU\\<cdot>f\\<cdot>(\\<bottom>::udom\\<cdot>llist) = \\<bottom>\"\n  \"fmapU\\<cdot>f\\<cdot>LNil = LNil\"\n  \"fmapU\\<cdot>f\\<cdot>(LCons\\<cdot>x\\<cdot>xs) = LCons\\<cdot>(f\\<cdot>x)\\<cdot>(fmapU\\<cdot>f\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmapU\\<cdot>f\\<cdot>\\<bottom> = \\<bottom> &&&\n    fmapU\\<cdot>f\\<cdot>LNil = LNil &&&\n    fmapU\\<cdot>f\\<cdot>(LCons\\<cdot>x\\<cdot>xs) =\n    LCons\\<cdot>(f\\<cdot>x)\\<cdot>(fmapU\\<cdot>f\\<cdot>xs)", "unfolding fmapU_llist_def llist_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> a.\n        \\<mu> uu.\n           llist_abs oo\n           ssum_map\\<cdot>ID\\<cdot>\n           (sprod_map\\<cdot>(u_map\\<cdot>a)\\<cdot>(u_map\\<cdot>uu)) oo\n           llist_rep)\\<cdot>\n    f\\<cdot>\n    \\<bottom> =\n    \\<bottom> &&&\n    (\\<Lambda> a.\n        \\<mu> uu.\n           llist_abs oo\n           ssum_map\\<cdot>ID\\<cdot>\n           (sprod_map\\<cdot>(u_map\\<cdot>a)\\<cdot>(u_map\\<cdot>uu)) oo\n           llist_rep)\\<cdot>\n    f\\<cdot>\n    LNil =\n    LNil &&&\n    (\\<Lambda> a.\n        \\<mu> uu.\n           llist_abs oo\n           ssum_map\\<cdot>ID\\<cdot>\n           (sprod_map\\<cdot>(u_map\\<cdot>a)\\<cdot>(u_map\\<cdot>uu)) oo\n           llist_rep)\\<cdot>\n    f\\<cdot>\n    (LCons\\<cdot>x\\<cdot>xs) =\n    LCons\\<cdot>(f\\<cdot>x)\\<cdot>\n    ((\\<Lambda> a.\n         \\<mu> uu.\n            llist_abs oo\n            ssum_map\\<cdot>ID\\<cdot>\n            (sprod_map\\<cdot>(u_map\\<cdot>a)\\<cdot>(u_map\\<cdot>uu)) oo\n            llist_rep)\\<cdot>\n     f\\<cdot>\n     xs)", "apply (subst fix_eq, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<Lambda> a.\n        \\<mu> uu.\n           llist_abs oo\n           ssum_map\\<cdot>ID\\<cdot>\n           (sprod_map\\<cdot>(u_map\\<cdot>a)\\<cdot>(u_map\\<cdot>uu)) oo\n           llist_rep)\\<cdot>\n    f\\<cdot>\n    LNil =\n    LNil\n 2. (\\<Lambda> a.\n        \\<mu> uu.\n           llist_abs oo\n           ssum_map\\<cdot>ID\\<cdot>\n           (sprod_map\\<cdot>(u_map\\<cdot>a)\\<cdot>(u_map\\<cdot>uu)) oo\n           llist_rep)\\<cdot>\n    f\\<cdot>\n    (LCons\\<cdot>x\\<cdot>xs) =\n    LCons\\<cdot>(f\\<cdot>x)\\<cdot>\n    ((\\<Lambda> a.\n         \\<mu> uu.\n            llist_abs oo\n            ssum_map\\<cdot>ID\\<cdot>\n            (sprod_map\\<cdot>(u_map\\<cdot>a)\\<cdot>(u_map\\<cdot>uu)) oo\n            llist_rep)\\<cdot>\n     f\\<cdot>\n     xs)", "apply (subst fix_eq, simp add: LNil_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> a.\n        \\<mu> uu.\n           llist_abs oo\n           ssum_map\\<cdot>ID\\<cdot>\n           (sprod_map\\<cdot>(u_map\\<cdot>a)\\<cdot>(u_map\\<cdot>uu)) oo\n           llist_rep)\\<cdot>\n    f\\<cdot>\n    (LCons\\<cdot>x\\<cdot>xs) =\n    LCons\\<cdot>(f\\<cdot>x)\\<cdot>\n    ((\\<Lambda> a.\n         \\<mu> uu.\n            llist_abs oo\n            ssum_map\\<cdot>ID\\<cdot>\n            (sprod_map\\<cdot>(u_map\\<cdot>a)\\<cdot>(u_map\\<cdot>uu)) oo\n            llist_rep)\\<cdot>\n     f\\<cdot>\n     xs)", "apply (subst fix_eq, simp add: LCons_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Class instances\\<close>"], ["", "text \\<open>The \\<open>tycondef\\<close> command defines \\<open>fmapU\\<close> for us and\nproves a \\<open>prefunctor\\<close> class instance automatically. For the\n\\<open>functor\\<close> instance we only need to prove the composition law,\nwhich we can do by induction.\\<close>"], ["", "instance llist :: \"functor\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(llist, functor_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f g xs.\n       fmapU\\<cdot>f\\<cdot>(fmapU\\<cdot>g\\<cdot>xs) =\n       fmapU\\<cdot>(\\<Lambda> x. f\\<cdot>(g\\<cdot>x))\\<cdot>xs", "fix f g and xs :: \"udom\\<cdot>llist\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f g xs.\n       fmapU\\<cdot>f\\<cdot>(fmapU\\<cdot>g\\<cdot>xs) =\n       fmapU\\<cdot>(\\<Lambda> x. f\\<cdot>(g\\<cdot>x))\\<cdot>xs", "show \"fmapU\\<cdot>f\\<cdot>(fmapU\\<cdot>g\\<cdot>xs) = fmapU\\<cdot>(\\<Lambda> x. f\\<cdot>(g\\<cdot>x))\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmapU\\<cdot>f\\<cdot>(fmapU\\<cdot>g\\<cdot>xs) =\n    fmapU\\<cdot>(\\<Lambda> x. f\\<cdot>(g\\<cdot>x))\\<cdot>xs", "by (induct xs rule: llist.induct) simp_all"], ["proof (state)\nthis:\n  fmapU\\<cdot>f\\<cdot>(fmapU\\<cdot>g\\<cdot>xs) =\n  fmapU\\<cdot>(\\<Lambda> x. f\\<cdot>(g\\<cdot>x))\\<cdot>xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>For the other class instances, we need to provide definitions\nfor a few constants: \\<open>returnU\\<close>, \\<open>bindU\\<close> \\<open>zeroU\\<close>, and\n\\<open>plusU\\<close>. We can use ordinary commands like \\<open>definition\\<close>\nand \\<open>fixrec\\<close> for this purpose. Finally we prove the class\naxioms, along with a few helper lemmas, using ordinary proof\nprocedures like induction.\\<close>"], ["", "instantiation llist :: monad_zero_plus\nbegin"], ["", "fixrec plusU_llist :: \"udom\\<cdot>llist \\<rightarrow> udom\\<cdot>llist \\<rightarrow> udom\\<cdot>llist\"\n  where \"plusU_llist\\<cdot>LNil\\<cdot>ys = ys\"\n  | \"plusU_llist\\<cdot>(LCons\\<cdot>x\\<cdot>xs)\\<cdot>ys = LCons\\<cdot>x\\<cdot>(plusU_llist\\<cdot>xs\\<cdot>ys)\""], ["", "lemma plusU_llist_strict [simp]: \"plusU\\<cdot>\\<bottom>\\<cdot>ys = (\\<bottom>::udom\\<cdot>llist)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plusU\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom>", "by fixrec_simp"], ["", "fixrec bindU_llist :: \"udom\\<cdot>llist \\<rightarrow> (udom \\<rightarrow> udom\\<cdot>llist) \\<rightarrow> udom\\<cdot>llist\"\n  where \"bindU_llist\\<cdot>LNil\\<cdot>k = LNil\"\n  | \"bindU_llist\\<cdot>(LCons\\<cdot>x\\<cdot>xs)\\<cdot>k = plusU\\<cdot>(k\\<cdot>x)\\<cdot>(bindU_llist\\<cdot>xs\\<cdot>k)\""], ["", "lemma bindU_llist_strict [simp]: \"bindU\\<cdot>\\<bottom>\\<cdot>k = (\\<bottom>::udom\\<cdot>llist)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bindU\\<cdot>\\<bottom>\\<cdot>k = \\<bottom>", "by fixrec_simp"], ["", "definition zeroU_llist_def:\n  \"zeroU = LNil\""], ["", "definition returnU_llist_def:\n  \"returnU = (\\<Lambda> x. LCons\\<cdot>x\\<cdot>LNil)\""], ["", "lemma plusU_LNil_right: \"plusU\\<cdot>xs\\<cdot>LNil = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plusU\\<cdot>xs\\<cdot>LNil = xs", "by (induct xs rule: llist.induct) simp_all"], ["", "lemma plusU_llist_assoc:\n  fixes xs ys zs :: \"udom\\<cdot>llist\"\n  shows \"plusU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>zs = plusU\\<cdot>xs\\<cdot>(plusU\\<cdot>ys\\<cdot>zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plusU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>zs =\n    plusU\\<cdot>xs\\<cdot>(plusU\\<cdot>ys\\<cdot>zs)", "by (induct xs rule: llist.induct) simp_all"], ["", "lemma bindU_plusU_llist:\n  fixes xs ys :: \"udom\\<cdot>llist\" shows\n  \"bindU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>f = plusU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>(bindU\\<cdot>ys\\<cdot>f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bindU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>f =\n    plusU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>(bindU\\<cdot>ys\\<cdot>f)", "by (induct xs rule: llist.induct) (simp_all add: plusU_llist_assoc)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(llist, monad_zero_plus_class)", "proof"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>f xs.\n       fmapU\\<cdot>f\\<cdot>xs =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. returnU\\<cdot>(f\\<cdot>x))\n 2. \\<And>f x. bindU\\<cdot>(returnU\\<cdot>x)\\<cdot>f = f\\<cdot>x\n 3. \\<And>xs f g.\n       bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>g =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(f\\<cdot>x)\\<cdot>g)\n 4. \\<And>xs ys k.\n       bindU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>k =\n       plusU\\<cdot>(bindU\\<cdot>xs\\<cdot>k)\\<cdot>(bindU\\<cdot>ys\\<cdot>k)\n 5. \\<And>a b c.\n       plusU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>c =\n       plusU\\<cdot>a\\<cdot>(plusU\\<cdot>b\\<cdot>c)\n 6. \\<And>f. bindU\\<cdot>zeroU\\<cdot>f = zeroU\n 7. \\<And>f a b.\n       fmapU\\<cdot>f\\<cdot>(plusU\\<cdot>a\\<cdot>b) =\n       plusU\\<cdot>(fmapU\\<cdot>f\\<cdot>a)\\<cdot>(fmapU\\<cdot>f\\<cdot>b)\n 8. \\<And>f. fmapU\\<cdot>f\\<cdot>zeroU = zeroU\n 9. \\<And>m. plusU\\<cdot>zeroU\\<cdot>m = m\n 10. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "fix x :: \"udom\""], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>f xs.\n       fmapU\\<cdot>f\\<cdot>xs =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. returnU\\<cdot>(f\\<cdot>x))\n 2. \\<And>f x. bindU\\<cdot>(returnU\\<cdot>x)\\<cdot>f = f\\<cdot>x\n 3. \\<And>xs f g.\n       bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>g =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(f\\<cdot>x)\\<cdot>g)\n 4. \\<And>xs ys k.\n       bindU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>k =\n       plusU\\<cdot>(bindU\\<cdot>xs\\<cdot>k)\\<cdot>(bindU\\<cdot>ys\\<cdot>k)\n 5. \\<And>a b c.\n       plusU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>c =\n       plusU\\<cdot>a\\<cdot>(plusU\\<cdot>b\\<cdot>c)\n 6. \\<And>f. bindU\\<cdot>zeroU\\<cdot>f = zeroU\n 7. \\<And>f a b.\n       fmapU\\<cdot>f\\<cdot>(plusU\\<cdot>a\\<cdot>b) =\n       plusU\\<cdot>(fmapU\\<cdot>f\\<cdot>a)\\<cdot>(fmapU\\<cdot>f\\<cdot>b)\n 8. \\<And>f. fmapU\\<cdot>f\\<cdot>zeroU = zeroU\n 9. \\<And>m. plusU\\<cdot>zeroU\\<cdot>m = m\n 10. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "fix f :: \"udom \\<rightarrow> udom\""], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>f xs.\n       fmapU\\<cdot>f\\<cdot>xs =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. returnU\\<cdot>(f\\<cdot>x))\n 2. \\<And>f x. bindU\\<cdot>(returnU\\<cdot>x)\\<cdot>f = f\\<cdot>x\n 3. \\<And>xs f g.\n       bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>g =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(f\\<cdot>x)\\<cdot>g)\n 4. \\<And>xs ys k.\n       bindU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>k =\n       plusU\\<cdot>(bindU\\<cdot>xs\\<cdot>k)\\<cdot>(bindU\\<cdot>ys\\<cdot>k)\n 5. \\<And>a b c.\n       plusU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>c =\n       plusU\\<cdot>a\\<cdot>(plusU\\<cdot>b\\<cdot>c)\n 6. \\<And>f. bindU\\<cdot>zeroU\\<cdot>f = zeroU\n 7. \\<And>f a b.\n       fmapU\\<cdot>f\\<cdot>(plusU\\<cdot>a\\<cdot>b) =\n       plusU\\<cdot>(fmapU\\<cdot>f\\<cdot>a)\\<cdot>(fmapU\\<cdot>f\\<cdot>b)\n 8. \\<And>f. fmapU\\<cdot>f\\<cdot>zeroU = zeroU\n 9. \\<And>m. plusU\\<cdot>zeroU\\<cdot>m = m\n 10. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "fix h k :: \"udom \\<rightarrow> udom\\<cdot>llist\""], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>f xs.\n       fmapU\\<cdot>f\\<cdot>xs =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. returnU\\<cdot>(f\\<cdot>x))\n 2. \\<And>f x. bindU\\<cdot>(returnU\\<cdot>x)\\<cdot>f = f\\<cdot>x\n 3. \\<And>xs f g.\n       bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>g =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(f\\<cdot>x)\\<cdot>g)\n 4. \\<And>xs ys k.\n       bindU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>k =\n       plusU\\<cdot>(bindU\\<cdot>xs\\<cdot>k)\\<cdot>(bindU\\<cdot>ys\\<cdot>k)\n 5. \\<And>a b c.\n       plusU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>c =\n       plusU\\<cdot>a\\<cdot>(plusU\\<cdot>b\\<cdot>c)\n 6. \\<And>f. bindU\\<cdot>zeroU\\<cdot>f = zeroU\n 7. \\<And>f a b.\n       fmapU\\<cdot>f\\<cdot>(plusU\\<cdot>a\\<cdot>b) =\n       plusU\\<cdot>(fmapU\\<cdot>f\\<cdot>a)\\<cdot>(fmapU\\<cdot>f\\<cdot>b)\n 8. \\<And>f. fmapU\\<cdot>f\\<cdot>zeroU = zeroU\n 9. \\<And>m. plusU\\<cdot>zeroU\\<cdot>m = m\n 10. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "fix xs ys zs :: \"udom\\<cdot>llist\""], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>f xs.\n       fmapU\\<cdot>f\\<cdot>xs =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. returnU\\<cdot>(f\\<cdot>x))\n 2. \\<And>f x. bindU\\<cdot>(returnU\\<cdot>x)\\<cdot>f = f\\<cdot>x\n 3. \\<And>xs f g.\n       bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>g =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(f\\<cdot>x)\\<cdot>g)\n 4. \\<And>xs ys k.\n       bindU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>k =\n       plusU\\<cdot>(bindU\\<cdot>xs\\<cdot>k)\\<cdot>(bindU\\<cdot>ys\\<cdot>k)\n 5. \\<And>a b c.\n       plusU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>c =\n       plusU\\<cdot>a\\<cdot>(plusU\\<cdot>b\\<cdot>c)\n 6. \\<And>f. bindU\\<cdot>zeroU\\<cdot>f = zeroU\n 7. \\<And>f a b.\n       fmapU\\<cdot>f\\<cdot>(plusU\\<cdot>a\\<cdot>b) =\n       plusU\\<cdot>(fmapU\\<cdot>f\\<cdot>a)\\<cdot>(fmapU\\<cdot>f\\<cdot>b)\n 8. \\<And>f. fmapU\\<cdot>f\\<cdot>zeroU = zeroU\n 9. \\<And>m. plusU\\<cdot>zeroU\\<cdot>m = m\n 10. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "show \"fmapU\\<cdot>f\\<cdot>xs = bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. returnU\\<cdot>(f\\<cdot>x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmapU\\<cdot>f\\<cdot>xs =\n    bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. returnU\\<cdot>(f\\<cdot>x))", "by (induct xs rule: llist.induct, simp_all add: returnU_llist_def)"], ["proof (state)\nthis:\n  fmapU\\<cdot>f\\<cdot>xs =\n  bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. returnU\\<cdot>(f\\<cdot>x))\n\ngoal (9 subgoals):\n 1. \\<And>f x. bindU\\<cdot>(returnU\\<cdot>x)\\<cdot>f = f\\<cdot>x\n 2. \\<And>xs f g.\n       bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>g =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(f\\<cdot>x)\\<cdot>g)\n 3. \\<And>xs ys k.\n       bindU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>k =\n       plusU\\<cdot>(bindU\\<cdot>xs\\<cdot>k)\\<cdot>(bindU\\<cdot>ys\\<cdot>k)\n 4. \\<And>a b c.\n       plusU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>c =\n       plusU\\<cdot>a\\<cdot>(plusU\\<cdot>b\\<cdot>c)\n 5. \\<And>f. bindU\\<cdot>zeroU\\<cdot>f = zeroU\n 6. \\<And>f a b.\n       fmapU\\<cdot>f\\<cdot>(plusU\\<cdot>a\\<cdot>b) =\n       plusU\\<cdot>(fmapU\\<cdot>f\\<cdot>a)\\<cdot>(fmapU\\<cdot>f\\<cdot>b)\n 7. \\<And>f. fmapU\\<cdot>f\\<cdot>zeroU = zeroU\n 8. \\<And>m. plusU\\<cdot>zeroU\\<cdot>m = m\n 9. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "show \"bindU\\<cdot>(returnU\\<cdot>x)\\<cdot>k = k\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bindU\\<cdot>(returnU\\<cdot>x)\\<cdot>k = k\\<cdot>x", "by (simp add: returnU_llist_def plusU_LNil_right)"], ["proof (state)\nthis:\n  bindU\\<cdot>(returnU\\<cdot>x)\\<cdot>k = k\\<cdot>x\n\ngoal (8 subgoals):\n 1. \\<And>xs f g.\n       bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>g =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(f\\<cdot>x)\\<cdot>g)\n 2. \\<And>xs ys k.\n       bindU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>k =\n       plusU\\<cdot>(bindU\\<cdot>xs\\<cdot>k)\\<cdot>(bindU\\<cdot>ys\\<cdot>k)\n 3. \\<And>a b c.\n       plusU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>c =\n       plusU\\<cdot>a\\<cdot>(plusU\\<cdot>b\\<cdot>c)\n 4. \\<And>f. bindU\\<cdot>zeroU\\<cdot>f = zeroU\n 5. \\<And>f a b.\n       fmapU\\<cdot>f\\<cdot>(plusU\\<cdot>a\\<cdot>b) =\n       plusU\\<cdot>(fmapU\\<cdot>f\\<cdot>a)\\<cdot>(fmapU\\<cdot>f\\<cdot>b)\n 6. \\<And>f. fmapU\\<cdot>f\\<cdot>zeroU = zeroU\n 7. \\<And>m. plusU\\<cdot>zeroU\\<cdot>m = m\n 8. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "show \"bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>h)\\<cdot>k = bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(h\\<cdot>x)\\<cdot>k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>h)\\<cdot>k =\n    bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(h\\<cdot>x)\\<cdot>k)", "by (induct xs rule: llist.induct)\n       (simp_all add: bindU_plusU_llist)"], ["proof (state)\nthis:\n  bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>h)\\<cdot>k =\n  bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(h\\<cdot>x)\\<cdot>k)\n\ngoal (7 subgoals):\n 1. \\<And>xs ys k.\n       bindU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>k =\n       plusU\\<cdot>(bindU\\<cdot>xs\\<cdot>k)\\<cdot>(bindU\\<cdot>ys\\<cdot>k)\n 2. \\<And>a b c.\n       plusU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>c =\n       plusU\\<cdot>a\\<cdot>(plusU\\<cdot>b\\<cdot>c)\n 3. \\<And>f. bindU\\<cdot>zeroU\\<cdot>f = zeroU\n 4. \\<And>f a b.\n       fmapU\\<cdot>f\\<cdot>(plusU\\<cdot>a\\<cdot>b) =\n       plusU\\<cdot>(fmapU\\<cdot>f\\<cdot>a)\\<cdot>(fmapU\\<cdot>f\\<cdot>b)\n 5. \\<And>f. fmapU\\<cdot>f\\<cdot>zeroU = zeroU\n 6. \\<And>m. plusU\\<cdot>zeroU\\<cdot>m = m\n 7. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "show \"bindU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>k = plusU\\<cdot>(bindU\\<cdot>xs\\<cdot>k)\\<cdot>(bindU\\<cdot>ys\\<cdot>k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bindU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>k =\n    plusU\\<cdot>(bindU\\<cdot>xs\\<cdot>k)\\<cdot>(bindU\\<cdot>ys\\<cdot>k)", "by (induct xs rule: llist.induct)\n       (simp_all add: plusU_llist_assoc)"], ["proof (state)\nthis:\n  bindU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>k =\n  plusU\\<cdot>(bindU\\<cdot>xs\\<cdot>k)\\<cdot>(bindU\\<cdot>ys\\<cdot>k)\n\ngoal (6 subgoals):\n 1. \\<And>a b c.\n       plusU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>c =\n       plusU\\<cdot>a\\<cdot>(plusU\\<cdot>b\\<cdot>c)\n 2. \\<And>f. bindU\\<cdot>zeroU\\<cdot>f = zeroU\n 3. \\<And>f a b.\n       fmapU\\<cdot>f\\<cdot>(plusU\\<cdot>a\\<cdot>b) =\n       plusU\\<cdot>(fmapU\\<cdot>f\\<cdot>a)\\<cdot>(fmapU\\<cdot>f\\<cdot>b)\n 4. \\<And>f. fmapU\\<cdot>f\\<cdot>zeroU = zeroU\n 5. \\<And>m. plusU\\<cdot>zeroU\\<cdot>m = m\n 6. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "show \"plusU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>zs = plusU\\<cdot>xs\\<cdot>(plusU\\<cdot>ys\\<cdot>zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plusU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>zs =\n    plusU\\<cdot>xs\\<cdot>(plusU\\<cdot>ys\\<cdot>zs)", "by (rule plusU_llist_assoc)"], ["proof (state)\nthis:\n  plusU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>zs =\n  plusU\\<cdot>xs\\<cdot>(plusU\\<cdot>ys\\<cdot>zs)\n\ngoal (5 subgoals):\n 1. \\<And>f. bindU\\<cdot>zeroU\\<cdot>f = zeroU\n 2. \\<And>f a b.\n       fmapU\\<cdot>f\\<cdot>(plusU\\<cdot>a\\<cdot>b) =\n       plusU\\<cdot>(fmapU\\<cdot>f\\<cdot>a)\\<cdot>(fmapU\\<cdot>f\\<cdot>b)\n 3. \\<And>f. fmapU\\<cdot>f\\<cdot>zeroU = zeroU\n 4. \\<And>m. plusU\\<cdot>zeroU\\<cdot>m = m\n 5. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "show \"bindU\\<cdot>zeroU\\<cdot>k = zeroU\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bindU\\<cdot>zeroU\\<cdot>k = zeroU", "by (simp add: zeroU_llist_def)"], ["proof (state)\nthis:\n  bindU\\<cdot>zeroU\\<cdot>k = zeroU\n\ngoal (4 subgoals):\n 1. \\<And>f a b.\n       fmapU\\<cdot>f\\<cdot>(plusU\\<cdot>a\\<cdot>b) =\n       plusU\\<cdot>(fmapU\\<cdot>f\\<cdot>a)\\<cdot>(fmapU\\<cdot>f\\<cdot>b)\n 2. \\<And>f. fmapU\\<cdot>f\\<cdot>zeroU = zeroU\n 3. \\<And>m. plusU\\<cdot>zeroU\\<cdot>m = m\n 4. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "show \"fmapU\\<cdot>f\\<cdot>(plusU\\<cdot>xs\\<cdot>ys) = plusU\\<cdot>(fmapU\\<cdot>f\\<cdot>xs)\\<cdot>(fmapU\\<cdot>f\\<cdot>ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmapU\\<cdot>f\\<cdot>(plusU\\<cdot>xs\\<cdot>ys) =\n    plusU\\<cdot>(fmapU\\<cdot>f\\<cdot>xs)\\<cdot>(fmapU\\<cdot>f\\<cdot>ys)", "by (induct xs rule: llist.induct) simp_all"], ["proof (state)\nthis:\n  fmapU\\<cdot>f\\<cdot>(plusU\\<cdot>xs\\<cdot>ys) =\n  plusU\\<cdot>(fmapU\\<cdot>f\\<cdot>xs)\\<cdot>(fmapU\\<cdot>f\\<cdot>ys)\n\ngoal (3 subgoals):\n 1. \\<And>f. fmapU\\<cdot>f\\<cdot>zeroU = zeroU\n 2. \\<And>m. plusU\\<cdot>zeroU\\<cdot>m = m\n 3. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "show \"fmapU\\<cdot>f\\<cdot>zeroU = (zeroU :: udom\\<cdot>llist)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmapU\\<cdot>f\\<cdot>zeroU = zeroU", "by (simp add: zeroU_llist_def)"], ["proof (state)\nthis:\n  fmapU\\<cdot>f\\<cdot>zeroU = zeroU\n\ngoal (2 subgoals):\n 1. \\<And>m. plusU\\<cdot>zeroU\\<cdot>m = m\n 2. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "show \"plusU\\<cdot>zeroU\\<cdot>xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plusU\\<cdot>zeroU\\<cdot>xs = xs", "by (simp add: zeroU_llist_def)"], ["proof (state)\nthis:\n  plusU\\<cdot>zeroU\\<cdot>xs = xs\n\ngoal (1 subgoal):\n 1. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "show \"plusU\\<cdot>xs\\<cdot>zeroU = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plusU\\<cdot>xs\\<cdot>zeroU = xs", "by (simp add: zeroU_llist_def plusU_LNil_right)"], ["proof (state)\nthis:\n  plusU\\<cdot>xs\\<cdot>zeroU = xs\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Transfer properties to polymorphic versions\\<close>"], ["", "text \\<open>After proving the class instances, there is still one more\nstep: We must transfer all the list-specific lemmas about the\nmonomorphic constants (e.g., \\<open>fmapU\\<close> and \\<open>bindU\\<close>) to the\ncorresponding polymorphic constants (\\<open>fmap\\<close> and \\<open>bind\\<close>).\nThese lemmas primarily consist of the defining equations for each\nconstant. The polymorphic constants are defined using \\<open>coerce\\<close>,\nso the proofs proceed by unfolding the definitions and simplifying\nwith the \\<open>coerce_simp\\<close> rules.\\<close>"], ["", "lemma fmap_llist_simps [simp]:\n  \"fmap\\<cdot>f\\<cdot>(\\<bottom>::'a\\<cdot>llist) = \\<bottom>\"\n  \"fmap\\<cdot>f\\<cdot>LNil = LNil\"\n  \"fmap\\<cdot>f\\<cdot>(LCons\\<cdot>x\\<cdot>xs) = LCons\\<cdot>(f\\<cdot>x)\\<cdot>(fmap\\<cdot>f\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap\\<cdot>f\\<cdot>\\<bottom> = \\<bottom> &&&\n    fmap\\<cdot>f\\<cdot>LNil = LNil &&&\n    fmap\\<cdot>f\\<cdot>(LCons\\<cdot>x\\<cdot>xs) =\n    LCons\\<cdot>(f\\<cdot>x)\\<cdot>(fmap\\<cdot>f\\<cdot>xs)", "unfolding fmap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE\n     ((udom \\<rightarrow> udom) \\<rightarrow>\n      udom\\<cdot>llist \\<rightarrow> udom\\<cdot>llist,\n      ('a \\<rightarrow> 'b) \\<rightarrow>\n      'a\\<cdot>llist \\<rightarrow> 'b\\<cdot>llist)\\<cdot>\n    fmapU\\<cdot>\n    f\\<cdot>\n    \\<bottom> =\n    \\<bottom> &&&\n    COERCE\n     ((udom \\<rightarrow> udom) \\<rightarrow>\n      udom\\<cdot>llist \\<rightarrow> udom\\<cdot>llist,\n      ('a \\<rightarrow> 'b) \\<rightarrow>\n      'a\\<cdot>llist \\<rightarrow> 'b\\<cdot>llist)\\<cdot>\n    fmapU\\<cdot>\n    f\\<cdot>\n    LNil =\n    LNil &&&\n    COERCE\n     ((udom \\<rightarrow> udom) \\<rightarrow>\n      udom\\<cdot>llist \\<rightarrow> udom\\<cdot>llist,\n      ('a \\<rightarrow> 'b) \\<rightarrow>\n      'a\\<cdot>llist \\<rightarrow> 'b\\<cdot>llist)\\<cdot>\n    fmapU\\<cdot>\n    f\\<cdot>\n    (LCons\\<cdot>x\\<cdot>xs) =\n    LCons\\<cdot>(f\\<cdot>x)\\<cdot>\n    (COERCE\n      ((udom \\<rightarrow> udom) \\<rightarrow>\n       udom\\<cdot>llist \\<rightarrow> udom\\<cdot>llist,\n       ('a \\<rightarrow> 'b) \\<rightarrow>\n       'a\\<cdot>llist \\<rightarrow> 'b\\<cdot>llist)\\<cdot>\n     fmapU\\<cdot>\n     f\\<cdot>\n     xs)", "by simp_all"], ["", "lemma mplus_llist_simps [simp]:\n  \"mplus\\<cdot>(\\<bottom>::'a\\<cdot>llist)\\<cdot>ys = \\<bottom>\"\n  \"mplus\\<cdot>LNil\\<cdot>ys = ys\"\n  \"mplus\\<cdot>(LCons\\<cdot>x\\<cdot>xs)\\<cdot>ys = LCons\\<cdot>x\\<cdot>(mplus\\<cdot>xs\\<cdot>ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mplus\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom> &&&\n    mplus\\<cdot>LNil\\<cdot>ys = ys &&&\n    mplus\\<cdot>(LCons\\<cdot>x\\<cdot>xs)\\<cdot>ys =\n    LCons\\<cdot>x\\<cdot>(mplus\\<cdot>xs\\<cdot>ys)", "unfolding mplus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE\n     (udom\\<cdot>llist \\<rightarrow>\n      udom\\<cdot>llist \\<rightarrow> udom\\<cdot>llist,\n      'a\\<cdot>llist \\<rightarrow>\n      'a\\<cdot>llist \\<rightarrow> 'a\\<cdot>llist)\\<cdot>\n    plusU\\<cdot>\n    \\<bottom>\\<cdot>\n    ys =\n    \\<bottom> &&&\n    COERCE\n     (udom\\<cdot>llist \\<rightarrow>\n      udom\\<cdot>llist \\<rightarrow> udom\\<cdot>llist,\n      'a\\<cdot>llist \\<rightarrow>\n      'a\\<cdot>llist \\<rightarrow> 'a\\<cdot>llist)\\<cdot>\n    plusU\\<cdot>\n    LNil\\<cdot>\n    ys =\n    ys &&&\n    COERCE\n     (udom\\<cdot>llist \\<rightarrow>\n      udom\\<cdot>llist \\<rightarrow> udom\\<cdot>llist,\n      'a\\<cdot>llist \\<rightarrow>\n      'a\\<cdot>llist \\<rightarrow> 'a\\<cdot>llist)\\<cdot>\n    plusU\\<cdot>\n    (LCons\\<cdot>x\\<cdot>xs)\\<cdot>\n    ys =\n    LCons\\<cdot>x\\<cdot>\n    (COERCE\n      (udom\\<cdot>llist \\<rightarrow>\n       udom\\<cdot>llist \\<rightarrow> udom\\<cdot>llist,\n       'a\\<cdot>llist \\<rightarrow>\n       'a\\<cdot>llist \\<rightarrow> 'a\\<cdot>llist)\\<cdot>\n     plusU\\<cdot>\n     xs\\<cdot>\n     ys)", "by simp_all"], ["", "lemma bind_llist_simps [simp]:\n  \"bind\\<cdot>(\\<bottom>::'a\\<cdot>llist)\\<cdot>f = \\<bottom>\"\n  \"bind\\<cdot>LNil\\<cdot>f = LNil\"\n  \"bind\\<cdot>(LCons\\<cdot>x\\<cdot>xs)\\<cdot>f = mplus\\<cdot>(f\\<cdot>x)\\<cdot>(bind\\<cdot>xs\\<cdot>f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<bind> f = \\<bottom> &&&\n    LNil \\<bind> f = LNil &&&\n    LCons\\<cdot>x\\<cdot>xs \\<bind> f =\n    mplus\\<cdot>(f\\<cdot>x)\\<cdot>(xs \\<bind> f)", "unfolding bind_def mplus_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE\n     (udom\\<cdot>llist \\<rightarrow>\n      (udom \\<rightarrow> udom\\<cdot>llist) \\<rightarrow> udom\\<cdot>llist,\n      'a\\<cdot>llist \\<rightarrow>\n      ('a \\<rightarrow> 'b\\<cdot>llist) \\<rightarrow> 'b\\<cdot>llist)\\<cdot>\n    bindU\\<cdot>\n    \\<bottom>\\<cdot>\n    f =\n    \\<bottom> &&&\n    COERCE\n     (udom\\<cdot>llist \\<rightarrow>\n      (udom \\<rightarrow> udom\\<cdot>llist) \\<rightarrow> udom\\<cdot>llist,\n      'a\\<cdot>llist \\<rightarrow>\n      ('a \\<rightarrow> 'b\\<cdot>llist) \\<rightarrow> 'b\\<cdot>llist)\\<cdot>\n    bindU\\<cdot>\n    LNil\\<cdot>\n    f =\n    LNil &&&\n    COERCE\n     (udom\\<cdot>llist \\<rightarrow>\n      (udom \\<rightarrow> udom\\<cdot>llist) \\<rightarrow> udom\\<cdot>llist,\n      'a\\<cdot>llist \\<rightarrow>\n      ('a \\<rightarrow> 'b\\<cdot>llist) \\<rightarrow> 'b\\<cdot>llist)\\<cdot>\n    bindU\\<cdot>\n    (LCons\\<cdot>x\\<cdot>xs)\\<cdot>\n    f =\n    COERCE\n     (udom\\<cdot>llist \\<rightarrow>\n      udom\\<cdot>llist \\<rightarrow> udom\\<cdot>llist,\n      'b\\<cdot>llist \\<rightarrow>\n      'b\\<cdot>llist \\<rightarrow> 'b\\<cdot>llist)\\<cdot>\n    plusU\\<cdot>\n    (f\\<cdot>x)\\<cdot>\n    (COERCE\n      (udom\\<cdot>llist \\<rightarrow>\n       (udom \\<rightarrow> udom\\<cdot>llist) \\<rightarrow> udom\\<cdot>llist,\n       'a\\<cdot>llist \\<rightarrow>\n       ('a \\<rightarrow> 'b\\<cdot>llist) \\<rightarrow>\n       'b\\<cdot>llist)\\<cdot>\n     bindU\\<cdot>\n     xs\\<cdot>\n     f)", "by (simp_all add: coerce_simp)"], ["", "lemma return_llist_def:\n  \"return = (\\<Lambda> x. LCons\\<cdot>x\\<cdot>LNil)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return = (\\<Lambda> x. LCons\\<cdot>x\\<cdot>LNil)", "unfolding return_def returnU_llist_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE\n     (udom \\<rightarrow> udom\\<cdot>llist,\n      'a \\<rightarrow> 'a\\<cdot>llist)\\<cdot>\n    (\\<Lambda> x. LCons\\<cdot>x\\<cdot>LNil) =\n    (\\<Lambda> x. LCons\\<cdot>x\\<cdot>LNil)", "by (simp add: coerce_simp)"], ["", "lemma mzero_llist_def:\n  \"mzero = LNil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mzero = LNil", "unfolding mzero_def zeroU_llist_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE(udom\\<cdot>llist, 'a\\<cdot>llist)\\<cdot>LNil = LNil", "by simp"], ["", "lemma join_llist_simps [simp]:\n  \"join\\<cdot>(\\<bottom>::'a\\<cdot>llist\\<cdot>llist) = \\<bottom>\"\n  \"join\\<cdot>LNil = LNil\"\n  \"join\\<cdot>(LCons\\<cdot>xs\\<cdot>xss) = mplus\\<cdot>xs\\<cdot>(join\\<cdot>xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. join\\<cdot>\\<bottom> = \\<bottom> &&&\n    join\\<cdot>LNil = LNil &&&\n    join\\<cdot>(LCons\\<cdot>xs\\<cdot>xss) =\n    mplus\\<cdot>xs\\<cdot>(join\\<cdot>xss)", "unfolding join_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> m. m \\<bind> (\\<Lambda> x. x))\\<cdot>\\<bottom> =\n    \\<bottom> &&&\n    (\\<Lambda> m. m \\<bind> (\\<Lambda> x. x))\\<cdot>LNil = LNil &&&\n    (\\<Lambda> m. m \\<bind> (\\<Lambda> x. x))\\<cdot>\n    (LCons\\<cdot>xs\\<cdot>xss) =\n    mplus\\<cdot>xs\\<cdot>\n    ((\\<Lambda> m. m \\<bind> (\\<Lambda> x. x))\\<cdot>xss)", "by simp_all"], ["", "end"]]}