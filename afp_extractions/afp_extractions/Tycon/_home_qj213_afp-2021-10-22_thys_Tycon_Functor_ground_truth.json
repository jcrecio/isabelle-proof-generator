{"file_name": "/home/qj213/afp-2021-10-22/thys/Tycon/Functor.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Tycon", "problem_names": ["lemma fmapU_eq_fmap: \"fmapU = fmap\"", "lemma fmap_eq_fmapU: \"fmap = fmapU\"", "lemma cast_TC:\n  \"cast\\<cdot>(TC('f)\\<cdot>t) = emb oo fmapU\\<cdot>(cast\\<cdot>t) oo PRJ(udom\\<cdot>'f::prefunctor)\"", "lemma isodefl_cast: \"isodefl (cast\\<cdot>t) t\"", "lemma cast_cast_below1: \"A \\<sqsubseteq> B \\<Longrightarrow> cast\\<cdot>A\\<cdot>(cast\\<cdot>B\\<cdot>x) = cast\\<cdot>A\\<cdot>x\"", "lemma cast_cast_below2: \"A \\<sqsubseteq> B \\<Longrightarrow> cast\\<cdot>B\\<cdot>(cast\\<cdot>A\\<cdot>x) = cast\\<cdot>A\\<cdot>x\"", "lemma isodefl_fmap:\n  assumes \"isodefl d t\"\n  shows \"isodefl (fmap\\<cdot>d :: 'a\\<cdot>'f \\<rightarrow> _) (TC('f::functor)\\<cdot>t)\"", "lemma fmap_ID [simp]: \"fmap\\<cdot>ID = ID\"", "lemma fmap_ident [simp]: \"fmap\\<cdot>(\\<Lambda> x. x) = ID\"", "lemma coerce_coerce_eq_fmapU_cast [coerce_simp]:\n  fixes xs :: \"udom\\<cdot>'f::functor\"\n  shows \"COERCE('a\\<cdot>'f, udom\\<cdot>'f)\\<cdot>(COERCE(udom\\<cdot>'f, 'a\\<cdot>'f)\\<cdot>xs) =\n    fmapU\\<cdot>(cast\\<cdot>DEFL('a))\\<cdot>xs\"", "lemma fmap_fmap:\n  fixes xs :: \"'a\\<cdot>'f::functor\" and g :: \"'a \\<rightarrow> 'b\" and f :: \"'b \\<rightarrow> 'c\"\n  shows \"fmap\\<cdot>f\\<cdot>(fmap\\<cdot>g\\<cdot>xs) = fmap\\<cdot>(\\<Lambda> x. f\\<cdot>(g\\<cdot>x))\\<cdot>xs\"", "lemma fmap_cfcomp: \"fmap\\<cdot>(f oo g) = fmap\\<cdot>f oo fmap\\<cdot>g\"", "lemma deflation_fmap:\n  \"deflation d \\<Longrightarrow> deflation (fmap\\<cdot>d)\"", "lemma ep_pair_fmap:\n  \"ep_pair e p \\<Longrightarrow> ep_pair (fmap\\<cdot>e) (fmap\\<cdot>p)\"", "lemma fmap_strict:\n  fixes f :: \"'a \\<rightarrow> 'b\"\n  assumes \"f\\<cdot>\\<bottom> = \\<bottom>\" shows \"fmap\\<cdot>f\\<cdot>\\<bottom> = (\\<bottom>::'b\\<cdot>'f::functor)\"", "lemma fmapU_cast_eq:\n  \"fmapU\\<cdot>(cast\\<cdot>A) =\n    PRJ(udom\\<cdot>'f) oo cast\\<cdot>(TC('f::functor)\\<cdot>A) oo emb\"", "lemma fmapU_cast_DEFL:\n  \"fmapU\\<cdot>(cast\\<cdot>DEFL('a)) =\n    PRJ(udom\\<cdot>'f) oo cast\\<cdot>DEFL('a\\<cdot>'f::functor) oo emb\"", "lemma coerce_functor: \"COERCE('a\\<cdot>'f, 'b\\<cdot>'f::functor) = fmap\\<cdot>coerce\"", "lemma fmapU_cast_coerce [coerce_simp]:\n  fixes m :: \"'a\\<cdot>'f::functor\"\n  shows \"fmapU\\<cdot>(cast\\<cdot>DEFL('a))\\<cdot>(COERCE('a\\<cdot>'f, udom\\<cdot>'f)\\<cdot>m) =\n    COERCE('a\\<cdot>'f, udom\\<cdot>'f)\\<cdot>m\"", "lemma coerce_fmap [coerce_simp]:\n  fixes xs :: \"'a\\<cdot>'f::functor\" and f :: \"'a \\<rightarrow> 'b\"\n  shows \"COERCE('b\\<cdot>'f, 'c\\<cdot>'f)\\<cdot>(fmap\\<cdot>f\\<cdot>xs) = fmap\\<cdot>(\\<Lambda> x. COERCE('b,'c)\\<cdot>(f\\<cdot>x))\\<cdot>xs\"", "lemma fmap_coerce [coerce_simp]:\n  fixes xs :: \"'a\\<cdot>'f::functor\" and f :: \"'b \\<rightarrow> 'c\"\n  shows \"fmap\\<cdot>f\\<cdot>(COERCE('a\\<cdot>'f, 'b\\<cdot>'f)\\<cdot>xs) = fmap\\<cdot>(\\<Lambda> x. f\\<cdot>(COERCE('a,'b)\\<cdot>x))\\<cdot>xs\""], "translations": [["", "lemma fmapU_eq_fmap: \"fmapU = fmap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmapU = fmap", "by (simp add: fmap_def eta_cfun)"], ["", "lemma fmap_eq_fmapU: \"fmap = fmapU\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap = fmapU", "by (simp only: fmapU_eq_fmap)"], ["", "lemma cast_TC:\n  \"cast\\<cdot>(TC('f)\\<cdot>t) = emb oo fmapU\\<cdot>(cast\\<cdot>t) oo PRJ(udom\\<cdot>'f::prefunctor)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cast\\<cdot>(TC('f)\\<cdot>t) =\n    EMB(udom\\<cdot>'f) oo fmapU\\<cdot>(cast\\<cdot>t) oo PRJ(udom\\<cdot>'f)", "by (rule isodefl_fmapU [unfolded isodefl_def])"], ["", "lemma isodefl_cast: \"isodefl (cast\\<cdot>t) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isodefl (cast\\<cdot>t) t", "by (simp add: isodefl_def)"], ["", "lemma cast_cast_below1: \"A \\<sqsubseteq> B \\<Longrightarrow> cast\\<cdot>A\\<cdot>(cast\\<cdot>B\\<cdot>x) = cast\\<cdot>A\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<sqsubseteq> B \\<Longrightarrow>\n    cast\\<cdot>A\\<cdot>(cast\\<cdot>B\\<cdot>x) = cast\\<cdot>A\\<cdot>x", "by (intro deflation_below_comp1 deflation_cast monofun_cfun_arg)"], ["", "lemma cast_cast_below2: \"A \\<sqsubseteq> B \\<Longrightarrow> cast\\<cdot>B\\<cdot>(cast\\<cdot>A\\<cdot>x) = cast\\<cdot>A\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<sqsubseteq> B \\<Longrightarrow>\n    cast\\<cdot>B\\<cdot>(cast\\<cdot>A\\<cdot>x) = cast\\<cdot>A\\<cdot>x", "by (intro deflation_below_comp2 deflation_cast monofun_cfun_arg)"], ["", "lemma isodefl_fmap:\n  assumes \"isodefl d t\"\n  shows \"isodefl (fmap\\<cdot>d :: 'a\\<cdot>'f \\<rightarrow> _) (TC('f::functor)\\<cdot>t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isodefl (fmap\\<cdot>d) (TC('f)\\<cdot>t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. isodefl (fmap\\<cdot>d) (TC('f)\\<cdot>t)", "have deflation_d: \"deflation d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deflation d", "using assms"], ["proof (prove)\nusing this:\n  isodefl d t\n\ngoal (1 subgoal):\n 1. deflation d", "by (rule isodefl_imp_deflation)"], ["proof (state)\nthis:\n  deflation d\n\ngoal (1 subgoal):\n 1. isodefl (fmap\\<cdot>d) (TC('f)\\<cdot>t)", "have cast_t: \"cast\\<cdot>t = emb oo d oo prj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cast\\<cdot>t = EMB('a) oo d oo PRJ('a)", "using assms"], ["proof (prove)\nusing this:\n  isodefl d t\n\ngoal (1 subgoal):\n 1. cast\\<cdot>t = EMB('a) oo d oo PRJ('a)", "unfolding isodefl_def"], ["proof (prove)\nusing this:\n  cast\\<cdot>t = EMB('a) oo d oo PRJ('a)\n\ngoal (1 subgoal):\n 1. cast\\<cdot>t = EMB('a) oo d oo PRJ('a)", "."], ["proof (state)\nthis:\n  cast\\<cdot>t = EMB('a) oo d oo PRJ('a)\n\ngoal (1 subgoal):\n 1. isodefl (fmap\\<cdot>d) (TC('f)\\<cdot>t)", "have t_below: \"t \\<sqsubseteq> DEFL('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<sqsubseteq> DEFL('a)", "apply (rule cast_below_imp_below)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cast\\<cdot>t \\<sqsubseteq> cast\\<cdot>DEFL('a)", "apply (simp only: cast_t cast_DEFL)"], ["proof (prove)\ngoal (1 subgoal):\n 1. EMB('a) oo d oo PRJ('a) \\<sqsubseteq> EMB('a) oo PRJ('a)", "apply (simp add: cfun_below_iff deflation.below [OF deflation_d])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  t \\<sqsubseteq> DEFL('a)\n\ngoal (1 subgoal):\n 1. isodefl (fmap\\<cdot>d) (TC('f)\\<cdot>t)", "have fmap_eq: \"fmap\\<cdot>d = PRJ('a\\<cdot>'f) oo cast\\<cdot>(TC('f)\\<cdot>t) oo emb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap\\<cdot>d =\n    PRJ('a\\<cdot>'f) oo cast\\<cdot>(TC('f)\\<cdot>t) oo EMB('a\\<cdot>'f)", "by (simp add: fmap_def coerce_cfun cast_TC cast_t prj_emb cfcomp1)"], ["proof (state)\nthis:\n  fmap\\<cdot>d =\n  PRJ('a\\<cdot>'f) oo cast\\<cdot>(TC('f)\\<cdot>t) oo EMB('a\\<cdot>'f)\n\ngoal (1 subgoal):\n 1. isodefl (fmap\\<cdot>d) (TC('f)\\<cdot>t)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. isodefl (fmap\\<cdot>d) (TC('f)\\<cdot>t)", "apply (simp add: fmap_eq isodefl_def cfun_eq_iff emb_prj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       cast\\<cdot>(TC('f)\\<cdot>t)\\<cdot>x =\n       cast\\<cdot>DEFL('a\\<cdot>'f)\\<cdot>\n       (cast\\<cdot>(TC('f)\\<cdot>t)\\<cdot>\n        (cast\\<cdot>DEFL('a\\<cdot>'f)\\<cdot>x))", "apply (simp add: DEFL_app)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       cast\\<cdot>(TC('f)\\<cdot>t)\\<cdot>x =\n       cast\\<cdot>(TC('f)\\<cdot>DEFL('a))\\<cdot>\n       (cast\\<cdot>(TC('f)\\<cdot>t)\\<cdot>\n        (cast\\<cdot>(TC('f)\\<cdot>DEFL('a))\\<cdot>x))", "apply (simp add: cast_cast_below1 monofun_cfun t_below)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       cast\\<cdot>(TC('f)\\<cdot>t)\\<cdot>x =\n       cast\\<cdot>(TC('f)\\<cdot>DEFL('a))\\<cdot>\n       (cast\\<cdot>(TC('f)\\<cdot>t)\\<cdot>x)", "apply (simp add: cast_cast_below2 monofun_cfun t_below)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  isodefl (fmap\\<cdot>d) (TC('f)\\<cdot>t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fmap_ID [simp]: \"fmap\\<cdot>ID = ID\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap\\<cdot>ID = ID", "apply (rule isodefl_DEFL_imp_ID)"], ["proof (prove)\ngoal (1 subgoal):\n 1. isodefl (fmap\\<cdot>ID) DEFL('a\\<cdot>'b)", "apply (subst DEFL_app)"], ["proof (prove)\ngoal (1 subgoal):\n 1. isodefl (fmap\\<cdot>ID) (TC('b)\\<cdot>DEFL('a))", "apply (rule isodefl_fmap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. isodefl ID DEFL('a)", "apply (rule isodefl_ID_DEFL)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fmap_ident [simp]: \"fmap\\<cdot>(\\<Lambda> x. x) = ID\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap\\<cdot>(\\<Lambda> x. x) = ID", "by (simp add: ID_def [symmetric])"], ["", "lemma coerce_coerce_eq_fmapU_cast [coerce_simp]:\n  fixes xs :: \"udom\\<cdot>'f::functor\"\n  shows \"COERCE('a\\<cdot>'f, udom\\<cdot>'f)\\<cdot>(COERCE(udom\\<cdot>'f, 'a\\<cdot>'f)\\<cdot>xs) =\n    fmapU\\<cdot>(cast\\<cdot>DEFL('a))\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('a\\<cdot>'f, udom\\<cdot>'f)\\<cdot>\n    (COERCE(udom\\<cdot>'f, 'a\\<cdot>'f)\\<cdot>xs) =\n    fmapU\\<cdot>(cast\\<cdot>DEFL('a))\\<cdot>xs", "by (simp add: coerce_def emb_prj DEFL_app cast_TC)"], ["", "lemma fmap_fmap:\n  fixes xs :: \"'a\\<cdot>'f::functor\" and g :: \"'a \\<rightarrow> 'b\" and f :: \"'b \\<rightarrow> 'c\"\n  shows \"fmap\\<cdot>f\\<cdot>(fmap\\<cdot>g\\<cdot>xs) = fmap\\<cdot>(\\<Lambda> x. f\\<cdot>(g\\<cdot>x))\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap\\<cdot>f\\<cdot>(fmap\\<cdot>g\\<cdot>xs) =\n    fmap\\<cdot>(\\<Lambda> x. f\\<cdot>(g\\<cdot>x))\\<cdot>xs", "unfolding fmap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE\n     ((udom \\<rightarrow> udom) \\<rightarrow>\n      udom\\<cdot>'f \\<rightarrow> udom\\<cdot>'f,\n      ('b \\<rightarrow> 'c) \\<rightarrow>\n      'b\\<cdot>'f \\<rightarrow> 'c\\<cdot>'f)\\<cdot>\n    fmapU\\<cdot>\n    f\\<cdot>\n    (COERCE\n      ((udom \\<rightarrow> udom) \\<rightarrow>\n       udom\\<cdot>'f \\<rightarrow> udom\\<cdot>'f,\n       ('a \\<rightarrow> 'b) \\<rightarrow>\n       'a\\<cdot>'f \\<rightarrow> 'b\\<cdot>'f)\\<cdot>\n     fmapU\\<cdot>\n     g\\<cdot>\n     xs) =\n    COERCE\n     ((udom \\<rightarrow> udom) \\<rightarrow>\n      udom\\<cdot>'f \\<rightarrow> udom\\<cdot>'f,\n      ('a \\<rightarrow> 'c) \\<rightarrow>\n      'a\\<cdot>'f \\<rightarrow> 'c\\<cdot>'f)\\<cdot>\n    fmapU\\<cdot>\n    (\\<Lambda> x. f\\<cdot>(g\\<cdot>x))\\<cdot>\n    xs", "by (simp add: coerce_simp)"], ["", "lemma fmap_cfcomp: \"fmap\\<cdot>(f oo g) = fmap\\<cdot>f oo fmap\\<cdot>g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap\\<cdot>(f oo g) = fmap\\<cdot>f oo fmap\\<cdot>g", "by (simp add: cfcomp1 fmap_fmap eta_cfun)"], ["", "subsection \\<open>Derived properties of \\<open>fmap\\<close>\\<close>"], ["", "text \\<open>Other theorems about \\<open>fmap\\<close> can be derived using only\nthe abstract functor laws.\\<close>"], ["", "lemma deflation_fmap:\n  \"deflation d \\<Longrightarrow> deflation (fmap\\<cdot>d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. deflation d \\<Longrightarrow> deflation (fmap\\<cdot>d)", "apply (rule deflation.intro)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       deflation d \\<Longrightarrow>\n       fmap\\<cdot>d\\<cdot>(fmap\\<cdot>d\\<cdot>x) = fmap\\<cdot>d\\<cdot>x\n 2. \\<And>x.\n       deflation d \\<Longrightarrow> fmap\\<cdot>d\\<cdot>x \\<sqsubseteq> x", "apply (simp add: fmap_fmap deflation.idem eta_cfun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       deflation d \\<Longrightarrow> fmap\\<cdot>d\\<cdot>x \\<sqsubseteq> x", "apply (subgoal_tac \"fmap\\<cdot>d\\<cdot>x \\<sqsubseteq> fmap\\<cdot>ID\\<cdot>x\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       deflation d \\<Longrightarrow>\n       fmap\\<cdot>d\\<cdot>x \\<sqsubseteq> fmap\\<cdot>ID\\<cdot>x", "apply (rule monofun_cfun_fun, rule monofun_cfun_arg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. deflation d \\<Longrightarrow> d \\<sqsubseteq> ID", "apply (erule deflation.below_ID)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ep_pair_fmap:\n  \"ep_pair e p \\<Longrightarrow> ep_pair (fmap\\<cdot>e) (fmap\\<cdot>p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ep_pair e p \\<Longrightarrow> ep_pair (fmap\\<cdot>e) (fmap\\<cdot>p)", "apply (rule ep_pair.intro)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       ep_pair e p \\<Longrightarrow>\n       fmap\\<cdot>p\\<cdot>(fmap\\<cdot>e\\<cdot>x) = x\n 2. \\<And>y.\n       ep_pair e p \\<Longrightarrow>\n       fmap\\<cdot>e\\<cdot>(fmap\\<cdot>p\\<cdot>y) \\<sqsubseteq> y", "apply (simp add: fmap_fmap ep_pair.e_inverse)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       ep_pair e p \\<Longrightarrow>\n       fmap\\<cdot>e\\<cdot>(fmap\\<cdot>p\\<cdot>y) \\<sqsubseteq> y", "apply (simp add: fmap_fmap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       ep_pair e p \\<Longrightarrow>\n       fmap\\<cdot>(\\<Lambda> x. e\\<cdot>(p\\<cdot>x))\\<cdot>y \\<sqsubseteq> y", "apply (rule_tac y=\"fmap\\<cdot>ID\\<cdot>y\" in below_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       ep_pair e p \\<Longrightarrow>\n       fmap\\<cdot>(\\<Lambda> x. e\\<cdot>(p\\<cdot>x))\\<cdot>y \\<sqsubseteq>\n       fmap\\<cdot>ID\\<cdot>y\n 2. \\<And>y.\n       ep_pair e p \\<Longrightarrow> fmap\\<cdot>ID\\<cdot>y \\<sqsubseteq> y", "apply (rule monofun_cfun_fun)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       ep_pair e p \\<Longrightarrow>\n       fmap\\<cdot>(\\<Lambda> x. e\\<cdot>(p\\<cdot>x)) \\<sqsubseteq>\n       fmap\\<cdot>ID\n 2. \\<And>y.\n       ep_pair e p \\<Longrightarrow> fmap\\<cdot>ID\\<cdot>y \\<sqsubseteq> y", "apply (rule monofun_cfun_arg)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       ep_pair e p \\<Longrightarrow>\n       (\\<Lambda> x. e\\<cdot>(p\\<cdot>x)) \\<sqsubseteq> ID\n 2. \\<And>y.\n       ep_pair e p \\<Longrightarrow> fmap\\<cdot>ID\\<cdot>y \\<sqsubseteq> y", "apply (rule cfun_belowI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       ep_pair e p \\<Longrightarrow> e\\<cdot>(p\\<cdot>x) \\<sqsubseteq> x\n 2. \\<And>y.\n       ep_pair e p \\<Longrightarrow> fmap\\<cdot>ID\\<cdot>y \\<sqsubseteq> y", "apply (erule ep_pair.e_p_below)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       ep_pair e p \\<Longrightarrow> fmap\\<cdot>ID\\<cdot>y \\<sqsubseteq> y", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fmap_strict:\n  fixes f :: \"'a \\<rightarrow> 'b\"\n  assumes \"f\\<cdot>\\<bottom> = \\<bottom>\" shows \"fmap\\<cdot>f\\<cdot>\\<bottom> = (\\<bottom>::'b\\<cdot>'f::functor)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>", "proof (rule bottomI)"], ["proof (state)\ngoal (1 subgoal):\n 1. fmap\\<cdot>f\\<cdot>\\<bottom> \\<sqsubseteq> \\<bottom>", "have \"fmap\\<cdot>f\\<cdot>(\\<bottom>::'a\\<cdot>'f) \\<sqsubseteq> fmap\\<cdot>f\\<cdot>(fmap\\<cdot>\\<bottom>\\<cdot>(\\<bottom>::'b\\<cdot>'f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap\\<cdot>f\\<cdot>\\<bottom> \\<sqsubseteq>\n    fmap\\<cdot>f\\<cdot>(fmap\\<cdot>\\<bottom>\\<cdot>\\<bottom>)", "by (simp add: monofun_cfun)"], ["proof (state)\nthis:\n  fmap\\<cdot>f\\<cdot>\\<bottom> \\<sqsubseteq>\n  fmap\\<cdot>f\\<cdot>(fmap\\<cdot>\\<bottom>\\<cdot>\\<bottom>)\n\ngoal (1 subgoal):\n 1. fmap\\<cdot>f\\<cdot>\\<bottom> \\<sqsubseteq> \\<bottom>", "also"], ["proof (state)\nthis:\n  fmap\\<cdot>f\\<cdot>\\<bottom> \\<sqsubseteq>\n  fmap\\<cdot>f\\<cdot>(fmap\\<cdot>\\<bottom>\\<cdot>\\<bottom>)\n\ngoal (1 subgoal):\n 1. fmap\\<cdot>f\\<cdot>\\<bottom> \\<sqsubseteq> \\<bottom>", "have \"... = fmap\\<cdot>(\\<Lambda> x. f\\<cdot>(\\<bottom>\\<cdot>x))\\<cdot>(\\<bottom>::'b\\<cdot>'f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap\\<cdot>f\\<cdot>(fmap\\<cdot>\\<bottom>\\<cdot>\\<bottom>) =\n    fmap\\<cdot>(\\<Lambda> x. f\\<cdot>(\\<bottom>\\<cdot>x))\\<cdot>\\<bottom>", "by (simp add: fmap_fmap)"], ["proof (state)\nthis:\n  fmap\\<cdot>f\\<cdot>(fmap\\<cdot>\\<bottom>\\<cdot>\\<bottom>) =\n  fmap\\<cdot>(\\<Lambda> x. f\\<cdot>(\\<bottom>\\<cdot>x))\\<cdot>\\<bottom>\n\ngoal (1 subgoal):\n 1. fmap\\<cdot>f\\<cdot>\\<bottom> \\<sqsubseteq> \\<bottom>", "also"], ["proof (state)\nthis:\n  fmap\\<cdot>f\\<cdot>(fmap\\<cdot>\\<bottom>\\<cdot>\\<bottom>) =\n  fmap\\<cdot>(\\<Lambda> x. f\\<cdot>(\\<bottom>\\<cdot>x))\\<cdot>\\<bottom>\n\ngoal (1 subgoal):\n 1. fmap\\<cdot>f\\<cdot>\\<bottom> \\<sqsubseteq> \\<bottom>", "have \"... \\<sqsubseteq> fmap\\<cdot>ID\\<cdot>\\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap\\<cdot>(\\<Lambda> x. f\\<cdot>(\\<bottom>\\<cdot>x))\\<cdot>\n    \\<bottom> \\<sqsubseteq>\n    fmap\\<cdot>ID\\<cdot>\\<bottom>", "by (simp add: monofun_cfun assms del: fmap_ID)"], ["proof (state)\nthis:\n  fmap\\<cdot>(\\<Lambda> x. f\\<cdot>(\\<bottom>\\<cdot>x))\\<cdot>\n  \\<bottom> \\<sqsubseteq>\n  fmap\\<cdot>ID\\<cdot>\\<bottom>\n\ngoal (1 subgoal):\n 1. fmap\\<cdot>f\\<cdot>\\<bottom> \\<sqsubseteq> \\<bottom>", "also"], ["proof (state)\nthis:\n  fmap\\<cdot>(\\<Lambda> x. f\\<cdot>(\\<bottom>\\<cdot>x))\\<cdot>\n  \\<bottom> \\<sqsubseteq>\n  fmap\\<cdot>ID\\<cdot>\\<bottom>\n\ngoal (1 subgoal):\n 1. fmap\\<cdot>f\\<cdot>\\<bottom> \\<sqsubseteq> \\<bottom>", "have \"... = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap\\<cdot>ID\\<cdot>\\<bottom> = \\<bottom>", "by simp"], ["proof (state)\nthis:\n  fmap\\<cdot>ID\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. fmap\\<cdot>f\\<cdot>\\<bottom> \\<sqsubseteq> \\<bottom>", "finally"], ["proof (chain)\npicking this:\n  fmap\\<cdot>f\\<cdot>\\<bottom> \\<sqsubseteq> \\<bottom>", "show \"fmap\\<cdot>f\\<cdot>\\<bottom> \\<sqsubseteq> (\\<bottom>::'b\\<cdot>'f::functor)\""], ["proof (prove)\nusing this:\n  fmap\\<cdot>f\\<cdot>\\<bottom> \\<sqsubseteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. fmap\\<cdot>f\\<cdot>\\<bottom> \\<sqsubseteq> \\<bottom>", "."], ["proof (state)\nthis:\n  fmap\\<cdot>f\\<cdot>\\<bottom> \\<sqsubseteq> \\<bottom>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Proving that \\<open>fmap\\<cdot>coerce = coerce\\<close>\\<close>"], ["", "lemma fmapU_cast_eq:\n  \"fmapU\\<cdot>(cast\\<cdot>A) =\n    PRJ(udom\\<cdot>'f) oo cast\\<cdot>(TC('f::functor)\\<cdot>A) oo emb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmapU\\<cdot>(cast\\<cdot>A) =\n    PRJ(udom\\<cdot>'f) oo cast\\<cdot>(TC('f)\\<cdot>A) oo EMB(udom\\<cdot>'f)", "by (subst cast_TC, rule cfun_eqI, simp)"], ["", "lemma fmapU_cast_DEFL:\n  \"fmapU\\<cdot>(cast\\<cdot>DEFL('a)) =\n    PRJ(udom\\<cdot>'f) oo cast\\<cdot>DEFL('a\\<cdot>'f::functor) oo emb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmapU\\<cdot>(cast\\<cdot>DEFL('a)) =\n    PRJ(udom\\<cdot>'f) oo cast\\<cdot>DEFL('a\\<cdot>'f) oo EMB(udom\\<cdot>'f)", "by (simp add: fmapU_cast_eq DEFL_app)"], ["", "lemma coerce_functor: \"COERCE('a\\<cdot>'f, 'b\\<cdot>'f::functor) = fmap\\<cdot>coerce\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('a\\<cdot>'f, 'b\\<cdot>'f) = fmap\\<cdot>COERCE('a, 'b)", "apply (rule cfun_eqI, rename_tac xs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       COERCE('a\\<cdot>'f, 'b\\<cdot>'f)\\<cdot>xs =\n       fmap\\<cdot>COERCE('a, 'b)\\<cdot>xs", "apply (simp add: fmap_def coerce_cfun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       COERCE('a\\<cdot>'f, 'b\\<cdot>'f)\\<cdot>xs =\n       COERCE(udom\\<cdot>'f, 'b\\<cdot>'f)\\<cdot>\n       (fmapU\\<cdot>(EMB('b) oo COERCE('a, 'b) oo PRJ('a))\\<cdot>\n        (COERCE('a\\<cdot>'f, udom\\<cdot>'f)\\<cdot>xs))", "apply (simp add: coerce_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       PRJ('b\\<cdot>'f)\\<cdot>(EMB('a\\<cdot>'f)\\<cdot>xs) =\n       PRJ('b\\<cdot>'f)\\<cdot>\n       (EMB(udom\\<cdot>'f)\\<cdot>\n        (fmapU\\<cdot>(EMB('b) oo (PRJ('b) oo EMB('a)) oo PRJ('a))\\<cdot>\n         (PRJ(udom\\<cdot>'f)\\<cdot>(EMB('a\\<cdot>'f)\\<cdot>xs))))", "apply (simp add: cfcomp1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       PRJ('b\\<cdot>'f)\\<cdot>(EMB('a\\<cdot>'f)\\<cdot>xs) =\n       PRJ('b\\<cdot>'f)\\<cdot>\n       (EMB(udom\\<cdot>'f)\\<cdot>\n        (fmapU\\<cdot>\n         (\\<Lambda> x.\n             EMB('b)\\<cdot>\n             (PRJ('b)\\<cdot>(EMB('a)\\<cdot>(PRJ('a)\\<cdot>x))))\\<cdot>\n         (PRJ(udom\\<cdot>'f)\\<cdot>(EMB('a\\<cdot>'f)\\<cdot>xs))))", "apply (simp only: emb_prj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       PRJ('b\\<cdot>'f)\\<cdot>(EMB('a\\<cdot>'f)\\<cdot>xs) =\n       PRJ('b\\<cdot>'f)\\<cdot>\n       (EMB(udom\\<cdot>'f)\\<cdot>\n        (fmapU\\<cdot>\n         (\\<Lambda> x.\n             cast\\<cdot>DEFL('b)\\<cdot>(cast\\<cdot>DEFL('a)\\<cdot>x))\\<cdot>\n         (PRJ(udom\\<cdot>'f)\\<cdot>(EMB('a\\<cdot>'f)\\<cdot>xs))))", "apply (subst fmapU_fmapU [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       PRJ('b\\<cdot>'f)\\<cdot>(EMB('a\\<cdot>'f)\\<cdot>xs) =\n       PRJ('b\\<cdot>'f)\\<cdot>\n       (EMB(udom\\<cdot>'f)\\<cdot>\n        (fmapU\\<cdot>(cast\\<cdot>DEFL('b))\\<cdot>\n         (fmapU\\<cdot>(cast\\<cdot>DEFL('a))\\<cdot>\n          (PRJ(udom\\<cdot>'f)\\<cdot>(EMB('a\\<cdot>'f)\\<cdot>xs)))))", "apply (simp add: fmapU_cast_DEFL)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       PRJ('b\\<cdot>'f)\\<cdot>(EMB('a\\<cdot>'f)\\<cdot>xs) =\n       PRJ('b\\<cdot>'f)\\<cdot>\n       (EMB(udom\\<cdot>'f)\\<cdot>\n        (PRJ(udom\\<cdot>'f)\\<cdot>\n         (cast\\<cdot>DEFL('b\\<cdot>'f)\\<cdot>\n          (EMB(udom\\<cdot>'f)\\<cdot>\n           (PRJ(udom\\<cdot>'f)\\<cdot>\n            (cast\\<cdot>DEFL('a\\<cdot>'f)\\<cdot>\n             (EMB(udom\\<cdot>'f)\\<cdot>\n              (PRJ(udom\\<cdot>'f)\\<cdot>(EMB('a\\<cdot>'f)\\<cdot>xs)))))))))", "apply (simp add: emb_prj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       PRJ('b\\<cdot>'f)\\<cdot>(EMB('a\\<cdot>'f)\\<cdot>xs) =\n       PRJ('b\\<cdot>'f)\\<cdot>\n       (cast\\<cdot>DEFL(udom\\<cdot>'f)\\<cdot>\n        (cast\\<cdot>DEFL('b\\<cdot>'f)\\<cdot>\n         (cast\\<cdot>DEFL(udom\\<cdot>'f)\\<cdot>\n          (cast\\<cdot>DEFL('a\\<cdot>'f)\\<cdot>\n           (cast\\<cdot>DEFL(udom\\<cdot>'f)\\<cdot>\n            (EMB('a\\<cdot>'f)\\<cdot>xs))))))", "apply (simp add: cast_cast_below1 cast_cast_below2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Lemmas for reasoning about coercion\\<close>"], ["", "lemma fmapU_cast_coerce [coerce_simp]:\n  fixes m :: \"'a\\<cdot>'f::functor\"\n  shows \"fmapU\\<cdot>(cast\\<cdot>DEFL('a))\\<cdot>(COERCE('a\\<cdot>'f, udom\\<cdot>'f)\\<cdot>m) =\n    COERCE('a\\<cdot>'f, udom\\<cdot>'f)\\<cdot>m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmapU\\<cdot>(cast\\<cdot>DEFL('a))\\<cdot>\n    (COERCE('a\\<cdot>'f, udom\\<cdot>'f)\\<cdot>m) =\n    COERCE('a\\<cdot>'f, udom\\<cdot>'f)\\<cdot>m", "by (simp add: coerce_functor cast_DEFL fmapU_eq_fmap fmap_fmap eta_cfun)"], ["", "lemma coerce_fmap [coerce_simp]:\n  fixes xs :: \"'a\\<cdot>'f::functor\" and f :: \"'a \\<rightarrow> 'b\"\n  shows \"COERCE('b\\<cdot>'f, 'c\\<cdot>'f)\\<cdot>(fmap\\<cdot>f\\<cdot>xs) = fmap\\<cdot>(\\<Lambda> x. COERCE('b,'c)\\<cdot>(f\\<cdot>x))\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('b\\<cdot>'f, 'c\\<cdot>'f)\\<cdot>(fmap\\<cdot>f\\<cdot>xs) =\n    fmap\\<cdot>(\\<Lambda> x. COERCE('b, 'c)\\<cdot>(f\\<cdot>x))\\<cdot>xs", "by (simp add: coerce_functor fmap_fmap)"], ["", "lemma fmap_coerce [coerce_simp]:\n  fixes xs :: \"'a\\<cdot>'f::functor\" and f :: \"'b \\<rightarrow> 'c\"\n  shows \"fmap\\<cdot>f\\<cdot>(COERCE('a\\<cdot>'f, 'b\\<cdot>'f)\\<cdot>xs) = fmap\\<cdot>(\\<Lambda> x. f\\<cdot>(COERCE('a,'b)\\<cdot>x))\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap\\<cdot>f\\<cdot>(COERCE('a\\<cdot>'f, 'b\\<cdot>'f)\\<cdot>xs) =\n    fmap\\<cdot>(\\<Lambda> x. f\\<cdot>(COERCE('a, 'b)\\<cdot>x))\\<cdot>xs", "by (simp add: coerce_functor fmap_fmap)"], ["", "subsection \\<open>Configuration of Domain package\\<close>"], ["", "text \\<open>We make various theorem declarations to enable Domain\n  package definitions that involve \\<open>tycon\\<close> application.\\<close>"], ["", "setup \\<open>Domain_Take_Proofs.add_rec_type (@{type_name app}, [true, false])\\<close>"], ["", "declare DEFL_app [domain_defl_simps]"], ["", "declare fmap_ID [domain_map_ID]"], ["", "declare deflation_fmap [domain_deflation]"], ["", "declare isodefl_fmap [domain_isodefl]"], ["", "subsection \\<open>Configuration of the Tycon package\\<close>"], ["", "text \\<open>We now set up a new type definition command, which is used for\n  defining new \\<open>tycon\\<close> instances. The \\<open>tycondef\\<close> command\n  is implemented using much of the same code as the Domain package,\n  and supports a similar input syntax. It automatically generates a\n  \\<open>prefunctor\\<close> instance for each new type. (The user must\n  provide a proof of the composition law to obtain a \\<open>functor\\<close>\n  class instance.)\\<close>"], ["", "ML_file \\<open>tycondef.ML\\<close>"], ["", "end"]]}