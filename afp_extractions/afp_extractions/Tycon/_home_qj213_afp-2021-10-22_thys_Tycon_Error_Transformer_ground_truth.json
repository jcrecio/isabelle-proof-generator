{"file_name": "/home/qj213/afp-2021-10-22/thys/Tycon/Error_Transformer.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Tycon", "problem_names": ["lemma coerce_errorT_abs [simp]: \"coerce\\<cdot>(errorT_abs\\<cdot>x) = errorT_abs\\<cdot>(coerce\\<cdot>x)\"", "lemma coerce_ErrorT [simp]: \"coerce\\<cdot>(ErrorT\\<cdot>k) = ErrorT\\<cdot>(coerce\\<cdot>k)\"", "lemma errorT_cases [case_names ErrorT]:\n  obtains k where \"y = ErrorT\\<cdot>k\"", "lemma ErrorT_runErrorT [simp]: \"ErrorT\\<cdot>(runErrorT\\<cdot>m) = m\"", "lemma errorT_induct [case_names ErrorT]:\n  fixes P :: \"'a\\<cdot>('f::functor,'e) errorT \\<Rightarrow> bool\"\n  assumes \"\\<And>k. P (ErrorT\\<cdot>k)\"\n  shows \"P y\"", "lemma errorT_eq_iff:\n  \"a = b \\<longleftrightarrow> runErrorT\\<cdot>a = runErrorT\\<cdot>b\"", "lemma errorT_eqI:\n  \"runErrorT\\<cdot>a = runErrorT\\<cdot>b \\<Longrightarrow> a = b\"", "lemma runErrorT_coerce [simp]:\n  \"runErrorT\\<cdot>(coerce\\<cdot>k) = coerce\\<cdot>(runErrorT\\<cdot>k)\"", "lemma fmap_error_def: \"fmap = error_map\\<cdot>ID\"", "lemma fmapU_ErrorT [simp]:\n  \"fmapU\\<cdot>f\\<cdot>(ErrorT\\<cdot>m) = ErrorT\\<cdot>(fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>m)\"", "lemma runErrorT_fmapU [simp]:\n  \"runErrorT\\<cdot>(fmapU\\<cdot>f\\<cdot>m) = fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>m)\"", "lemma fmap_ErrorT [simp]:\n  fixes f :: \"'a \\<rightarrow> 'b\" and m :: \"'a\\<cdot>'e error\\<cdot>('m::functor)\"\n  shows \"fmap\\<cdot>f\\<cdot>(ErrorT\\<cdot>m) = ErrorT\\<cdot>(fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>m)\"", "lemma runErrorT_fmap [simp]:\n  fixes f :: \"'a \\<rightarrow> 'b\" and m :: \"'a\\<cdot>('m::functor,'e) errorT\"\n  shows \"runErrorT\\<cdot>(fmap\\<cdot>f\\<cdot>m) = fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>m)\"", "lemma errorT_fmap_strict [simp]:\n  shows \"fmap\\<cdot>f\\<cdot>(\\<bottom>::'a\\<cdot>('m::monad,'e) errorT) = \\<bottom>\"", "lemma runErrorT_unitET [simp]:\n  \"runErrorT\\<cdot>(unitET\\<cdot>x) = return\\<cdot>(Ok\\<cdot>x)\"", "lemma runErrorT_bindET [simp]:\n  \"runErrorT\\<cdot>(bindET\\<cdot>m\\<cdot>k) = bind\\<cdot>(runErrorT\\<cdot>m)\\<cdot>\n    (\\<Lambda> n. case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e) | Ok\\<cdot>x \\<Rightarrow> runErrorT\\<cdot>(k\\<cdot>x))\"", "lemma runErrorT_liftET [simp]:\n  \"runErrorT\\<cdot>(liftET\\<cdot>m) = fmap\\<cdot>Ok\\<cdot>m\"", "lemma runErrorT_throwET [simp]:\n  \"runErrorT\\<cdot>(throwET\\<cdot>e) = return\\<cdot>(Err\\<cdot>e)\"", "lemma runErrorT_catchET [simp]:\n  \"runErrorT\\<cdot>(catchET\\<cdot>m\\<cdot>h) =\n    bind\\<cdot>(runErrorT\\<cdot>m)\\<cdot>(\\<Lambda> n. case n of\n      Err\\<cdot>e \\<Rightarrow> runErrorT\\<cdot>(h\\<cdot>e) | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>x))\"", "lemma runErrorT_fmapET [simp]:\n  \"runErrorT\\<cdot>(fmapET\\<cdot>f\\<cdot>m) =\n    bind\\<cdot>(runErrorT\\<cdot>m)\\<cdot>(\\<Lambda> n. case n of\n      Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e) | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)))\"", "lemma bindET_unitET [simp]:\n  \"bindET\\<cdot>(unitET\\<cdot>x)\\<cdot>k = k\\<cdot>x\"", "lemma catchET_unitET [simp]:\n  \"catchET\\<cdot>(unitET\\<cdot>x)\\<cdot>h = unitET\\<cdot>x\"", "lemma catchET_throwET [simp]:\n  \"catchET\\<cdot>(throwET\\<cdot>e)\\<cdot>h = h\\<cdot>e\"", "lemma liftET_return:\n  \"liftET\\<cdot>(return\\<cdot>x) = unitET\\<cdot>x\"", "lemma liftET_bind:\n  \"liftET\\<cdot>(bind\\<cdot>m\\<cdot>k) = bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>(liftET oo k)\"", "lemma bindET_throwET:\n  \"bindET\\<cdot>(throwET\\<cdot>e)\\<cdot>k = throwET\\<cdot>e\"", "lemma bindET_bindET:\n  \"bindET\\<cdot>(bindET\\<cdot>m\\<cdot>h)\\<cdot>k = bindET\\<cdot>m\\<cdot>(\\<Lambda> x. bindET\\<cdot>(h\\<cdot>x)\\<cdot>k)\"", "lemma fmapET_fmapET:\n  \"fmapET\\<cdot>f\\<cdot>(fmapET\\<cdot>g\\<cdot>m) = fmapET\\<cdot>(\\<Lambda> x. f\\<cdot>(g\\<cdot>x))\\<cdot>m\"", "lemma bindET_unitET_right_counterexample:\n  fixes m :: \"'a\\<cdot>('m::monad,'e) errorT\"\n  assumes \"m = ErrorT\\<cdot>(return\\<cdot>\\<bottom>)\"\n  assumes \"return\\<cdot>\\<bottom> \\<noteq> (\\<bottom> :: ('a\\<cdot>'e error)\\<cdot>'m)\"\n  shows \"bindET\\<cdot>m\\<cdot>unitET \\<noteq> m\"", "lemma bindET_unitET_right_restricted:\n  fixes m :: \"'a\\<cdot>('m::monad,'e) errorT\"\n  assumes \"return\\<cdot>\\<bottom> = (\\<bottom> :: ('a\\<cdot>'e error)\\<cdot>'m)\"\n  shows \"bindET\\<cdot>m\\<cdot>unitET = m\"", "lemma bindET_unitET_right_invar:\n  assumes \"invar m\"\n  shows \"bindET\\<cdot>m\\<cdot>unitET = m\"", "lemma errorT_monad_fmap_invar:\n  fixes f :: \"'a \\<rightarrow> 'b\" and m :: \"'a\\<cdot>('m::monad,'e) errorT\"\n  assumes \"invar m\"\n  shows \"fmap\\<cdot>f\\<cdot>m = bindET\\<cdot>m\\<cdot>(\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\"", "lemma invar'_unitET: \"invar' (unitET\\<cdot>x)\"", "lemma invar'_fmapET: \"invar' m \\<Longrightarrow> invar' (fmapET\\<cdot>f\\<cdot>m)\"", "lemma invar'_bindET: \"\\<lbrakk>invar' m; \\<And>x. invar' (k\\<cdot>x)\\<rbrakk> \\<Longrightarrow> invar' (bindET\\<cdot>m\\<cdot>k)\"", "lemma invar'_throwET: \"invar' (throwET\\<cdot>e)\"", "lemma invar'_catchET: \"\\<lbrakk>invar' m; \\<And>e. invar' (h\\<cdot>e)\\<rbrakk> \\<Longrightarrow> invar' (catchET\\<cdot>m\\<cdot>h)\"", "lemma invar'_liftET: \"invar' (liftET\\<cdot>m)\"", "lemma invar'_bottom: \"invar' \\<bottom>\"", "lemma adm_invar': \"adm invar'\"", "lemma bindET_fmapET_unitET:\n  shows \"bindET\\<cdot>(fmapET\\<cdot>f\\<cdot>m)\\<cdot>unitET = fmapET\\<cdot>f\\<cdot>m\"", "lemma invar'_right_unit: \"invar' m \\<Longrightarrow> bindET\\<cdot>m\\<cdot>unitET = m\"", "lemma invar'_monad_fmap:\n  \"invar' m \\<Longrightarrow> fmapET\\<cdot>f\\<cdot>m = bindET\\<cdot>m\\<cdot>(\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\"", "lemma invar'_bind_assoc:\n  \"\\<lbrakk>invar' m; \\<And>x. invar' (f\\<cdot>x); \\<And>y. invar' (g\\<cdot>y)\\<rbrakk>\n    \\<Longrightarrow> bindET\\<cdot>(bindET\\<cdot>m\\<cdot>f)\\<cdot>g = bindET\\<cdot>m\\<cdot>(\\<Lambda> x. bindET\\<cdot>(f\\<cdot>x)\\<cdot>g)\""], "translations": [["", "lemma coerce_errorT_abs [simp]: \"coerce\\<cdot>(errorT_abs\\<cdot>x) = errorT_abs\\<cdot>(coerce\\<cdot>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('d\\<cdot>('e, 'f) errorT, 'a\\<cdot>('b, 'c) errorT)\\<cdot>\n    (errorT_abs\\<cdot>x) =\n    errorT_abs\\<cdot>\n    (COERCE('d\\<cdot>'f error\\<cdot>'e, 'a\\<cdot>'c error\\<cdot>'b)\\<cdot>x)", "apply (simp add: errorT_abs_def coerce_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. PRJ('a\\<cdot>('b, 'c) errorT)\\<cdot>\n    (EMB('d\\<cdot>('e, 'f) errorT)\\<cdot>\n     (PRJ('d\\<cdot>('e, 'f) errorT)\\<cdot>\n      (EMB('d\\<cdot>'f error\\<cdot>'e)\\<cdot>x))) =\n    PRJ('a\\<cdot>('b, 'c) errorT)\\<cdot>\n    (EMB('a\\<cdot>'c error\\<cdot>'b)\\<cdot>\n     (PRJ('a\\<cdot>'c error\\<cdot>'b)\\<cdot>\n      (EMB('d\\<cdot>'f error\\<cdot>'e)\\<cdot>x)))", "apply (simp add: emb_prj_emb prj_emb_prj DEFL_eq_errorT)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma coerce_ErrorT [simp]: \"coerce\\<cdot>(ErrorT\\<cdot>k) = ErrorT\\<cdot>(coerce\\<cdot>k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('d\\<cdot>('e, 'f) errorT, 'a\\<cdot>('b, 'c) errorT)\\<cdot>\n    (ErrorT\\<cdot>k) =\n    ErrorT\\<cdot>\n    (COERCE('d\\<cdot>'f error\\<cdot>'e, 'a\\<cdot>'c error\\<cdot>'b)\\<cdot>k)", "unfolding ErrorT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('d\\<cdot>('e, 'f) errorT, 'a\\<cdot>('b, 'c) errorT)\\<cdot>\n    ((\\<Lambda> app. errorT_abs\\<cdot>app)\\<cdot>k) =\n    (\\<Lambda> app. errorT_abs\\<cdot>app)\\<cdot>\n    (COERCE('d\\<cdot>'f error\\<cdot>'e, 'a\\<cdot>'c error\\<cdot>'b)\\<cdot>k)", "by simp"], ["", "lemma errorT_cases [case_names ErrorT]:\n  obtains k where \"y = ErrorT\\<cdot>k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k. y = ErrorT\\<cdot>k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>k. y = ErrorT\\<cdot>k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    y = ErrorT\\<cdot>?k2", "show \"y = ErrorT\\<cdot>(runErrorT\\<cdot>y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = ErrorT\\<cdot>(runErrorT\\<cdot>y)", "by (cases y, simp_all)"], ["proof (state)\nthis:\n  y = ErrorT\\<cdot>(runErrorT\\<cdot>y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ErrorT_runErrorT [simp]: \"ErrorT\\<cdot>(runErrorT\\<cdot>m) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ErrorT\\<cdot>(runErrorT\\<cdot>m) = m", "by (cases m rule: errorT_cases, simp)"], ["", "lemma errorT_induct [case_names ErrorT]:\n  fixes P :: \"'a\\<cdot>('f::functor,'e) errorT \\<Rightarrow> bool\"\n  assumes \"\\<And>k. P (ErrorT\\<cdot>k)\"\n  shows \"P y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P y", "by (cases y rule: errorT_cases, simp add: assms)"], ["", "lemma errorT_eq_iff:\n  \"a = b \\<longleftrightarrow> runErrorT\\<cdot>a = runErrorT\\<cdot>b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a = b) = (runErrorT\\<cdot>a = runErrorT\\<cdot>b)", "apply (cases a rule: errorT_cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       a = ErrorT\\<cdot>k \\<Longrightarrow>\n       (a = b) = (runErrorT\\<cdot>a = runErrorT\\<cdot>b)", "apply (cases b rule: errorT_cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k ka.\n       \\<lbrakk>a = ErrorT\\<cdot>k; b = ErrorT\\<cdot>ka\\<rbrakk>\n       \\<Longrightarrow> (a = b) = (runErrorT\\<cdot>a = runErrorT\\<cdot>b)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma errorT_eqI:\n  \"runErrorT\\<cdot>a = runErrorT\\<cdot>b \\<Longrightarrow> a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runErrorT\\<cdot>a = runErrorT\\<cdot>b \\<Longrightarrow> a = b", "by (simp add: errorT_eq_iff)"], ["", "lemma runErrorT_coerce [simp]:\n  \"runErrorT\\<cdot>(coerce\\<cdot>k) = coerce\\<cdot>(runErrorT\\<cdot>k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runErrorT\\<cdot>\n    (COERCE('d\\<cdot>('e, 'f) errorT, 'a\\<cdot>('c, 'b) errorT)\\<cdot>k) =\n    COERCE('d\\<cdot>'f error\\<cdot>'e, 'a\\<cdot>'b error\\<cdot>'c)\\<cdot>\n    (runErrorT\\<cdot>k)", "by (induct k rule: errorT_induct, simp)"], ["", "subsection \\<open>Functor class instance\\<close>"], ["", "lemma fmap_error_def: \"fmap = error_map\\<cdot>ID\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap = error_map\\<cdot>ID", "apply (rule cfun_eqI, rename_tac f)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. fmap\\<cdot>f = error_map\\<cdot>ID\\<cdot>f", "apply (rule cfun_eqI, rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x. fmap\\<cdot>f\\<cdot>x = error_map\\<cdot>ID\\<cdot>f\\<cdot>x", "apply (case_tac x rule: error.exhaust, simp_all)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f. error_map\\<cdot>ID\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>\n 2. \\<And>f x e.\n       x = Err\\<cdot>e \\<Longrightarrow>\n       Err\\<cdot>e = error_map\\<cdot>ID\\<cdot>f\\<cdot>(Err\\<cdot>e)\n 3. \\<And>f x a.\n       x = Ok\\<cdot>a \\<Longrightarrow>\n       Ok\\<cdot>(f\\<cdot>a) = error_map\\<cdot>ID\\<cdot>f\\<cdot>(Ok\\<cdot>a)", "apply (simp add: error_map_def fix_const)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f x e.\n       x = Err\\<cdot>e \\<Longrightarrow>\n       Err\\<cdot>e = error_map\\<cdot>ID\\<cdot>f\\<cdot>(Err\\<cdot>e)\n 2. \\<And>f x a.\n       x = Ok\\<cdot>a \\<Longrightarrow>\n       Ok\\<cdot>(f\\<cdot>a) = error_map\\<cdot>ID\\<cdot>f\\<cdot>(Ok\\<cdot>a)", "apply (simp add: error_map_def fix_const Err_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x a.\n       x = Ok\\<cdot>a \\<Longrightarrow>\n       Ok\\<cdot>(f\\<cdot>a) = error_map\\<cdot>ID\\<cdot>f\\<cdot>(Ok\\<cdot>a)", "apply (simp add: error_map_def fix_const Ok_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fmapU_ErrorT [simp]:\n  \"fmapU\\<cdot>f\\<cdot>(ErrorT\\<cdot>m) = ErrorT\\<cdot>(fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmapU\\<cdot>f\\<cdot>(ErrorT\\<cdot>m) =\n    ErrorT\\<cdot>(fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>m)", "unfolding fmapU_errorT_def errorT_map_def fmap_error_def fix_const ErrorT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> e a.\n        errorT_abs oo\n        fmap\\<cdot>(error_map\\<cdot>e\\<cdot>a) oo errorT_rep)\\<cdot>\n    ID\\<cdot>\n    f\\<cdot>\n    ((\\<Lambda> app. errorT_abs\\<cdot>app)\\<cdot>m) =\n    (\\<Lambda> app. errorT_abs\\<cdot>app)\\<cdot>\n    (fmap\\<cdot>(error_map\\<cdot>ID\\<cdot>f)\\<cdot>m)", "by simp"], ["", "lemma runErrorT_fmapU [simp]:\n  \"runErrorT\\<cdot>(fmapU\\<cdot>f\\<cdot>m) = fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runErrorT\\<cdot>(fmapU\\<cdot>f\\<cdot>m) =\n    fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>m)", "by (induct m rule: errorT_induct) simp"], ["", "instance errorT :: (\"functor\", \"domain\") \"functor\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) errorT, functor_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f g xs.\n       fmapU\\<cdot>f\\<cdot>(fmapU\\<cdot>g\\<cdot>xs) =\n       fmapU\\<cdot>(\\<Lambda> x. f\\<cdot>(g\\<cdot>x))\\<cdot>xs", "fix f g and xs :: \"udom\\<cdot>('a, 'b) errorT\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f g xs.\n       fmapU\\<cdot>f\\<cdot>(fmapU\\<cdot>g\\<cdot>xs) =\n       fmapU\\<cdot>(\\<Lambda> x. f\\<cdot>(g\\<cdot>x))\\<cdot>xs", "show \"fmapU\\<cdot>f\\<cdot>(fmapU\\<cdot>g\\<cdot>xs) = fmapU\\<cdot>(\\<Lambda> x. f\\<cdot>(g\\<cdot>x))\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmapU\\<cdot>f\\<cdot>(fmapU\\<cdot>g\\<cdot>xs) =\n    fmapU\\<cdot>(\\<Lambda> x. f\\<cdot>(g\\<cdot>x))\\<cdot>xs", "apply (induct xs rule: errorT_induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       fmapU\\<cdot>f\\<cdot>(fmapU\\<cdot>g\\<cdot>(ErrorT\\<cdot>k)) =\n       fmapU\\<cdot>(\\<Lambda> x. f\\<cdot>(g\\<cdot>x))\\<cdot>(ErrorT\\<cdot>k)", "apply (simp add: fmap_fmap eta_cfun)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fmapU\\<cdot>f\\<cdot>(fmapU\\<cdot>g\\<cdot>xs) =\n  fmapU\\<cdot>(\\<Lambda> x. f\\<cdot>(g\\<cdot>x))\\<cdot>xs\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Transfer properties to polymorphic versions\\<close>"], ["", "lemma fmap_ErrorT [simp]:\n  fixes f :: \"'a \\<rightarrow> 'b\" and m :: \"'a\\<cdot>'e error\\<cdot>('m::functor)\"\n  shows \"fmap\\<cdot>f\\<cdot>(ErrorT\\<cdot>m) = ErrorT\\<cdot>(fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap\\<cdot>f\\<cdot>(ErrorT\\<cdot>m) =\n    ErrorT\\<cdot>(fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>m)", "unfolding fmap_def [where 'f=\"('m,'e) errorT\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE\n     ((udom \\<rightarrow> udom) \\<rightarrow>\n      udom\\<cdot>('m, 'e) errorT \\<rightarrow> udom\\<cdot>('m, 'e) errorT,\n      ('a \\<rightarrow> 'b) \\<rightarrow>\n      'a\\<cdot>('m, 'e) errorT \\<rightarrow>\n      'b\\<cdot>('m, 'e) errorT)\\<cdot>\n    fmapU\\<cdot>\n    f\\<cdot>\n    (ErrorT\\<cdot>m) =\n    ErrorT\\<cdot>(fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>m)", "by (simp_all add: coerce_simp eta_cfun)"], ["", "lemma runErrorT_fmap [simp]:\n  fixes f :: \"'a \\<rightarrow> 'b\" and m :: \"'a\\<cdot>('m::functor,'e) errorT\"\n  shows \"runErrorT\\<cdot>(fmap\\<cdot>f\\<cdot>m) = fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runErrorT\\<cdot>(fmap\\<cdot>f\\<cdot>m) =\n    fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>m)", "using fmap_ErrorT [of f \"runErrorT\\<cdot>m\"]"], ["proof (prove)\nusing this:\n  fmap\\<cdot>f\\<cdot>(ErrorT\\<cdot>(runErrorT\\<cdot>m)) =\n  ErrorT\\<cdot>(fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>m))\n\ngoal (1 subgoal):\n 1. runErrorT\\<cdot>(fmap\\<cdot>f\\<cdot>m) =\n    fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>m)", "by simp"], ["", "lemma errorT_fmap_strict [simp]:\n  shows \"fmap\\<cdot>f\\<cdot>(\\<bottom>::'a\\<cdot>('m::monad,'e) errorT) = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>", "by (simp add: errorT_eq_iff fmap_strict)"], ["", "subsection \\<open>Monad operations\\<close>"], ["", "text \\<open>The error monad transformer does not yield a monad in the\nusual sense: We cannot prove a \\<open>monad\\<close> class instance, because\ntype \\<open>'a\\<cdot>('m,'e) errorT\\<close> contains values that break the monad\nlaws. However, it turns out that such values are inaccessible: The\nmonad laws are satisfied by all values constructible from the abstract\noperations.\\<close>"], ["", "text \\<open>To explore the properties of the error monad transformer\noperations, we define them all as non-overloaded functions. \\medskip\n\\<close>"], ["", "definition unitET :: \"'a \\<rightarrow> 'a\\<cdot>('m::monad,'e) errorT\"\n  where \"unitET = (\\<Lambda> x. ErrorT\\<cdot>(return\\<cdot>(Ok\\<cdot>x)))\""], ["", "definition bindET :: \"'a\\<cdot>('m::monad,'e) errorT \\<rightarrow>\n    ('a \\<rightarrow> 'b\\<cdot>('m,'e) errorT) \\<rightarrow> 'b\\<cdot>('m,'e) errorT\"\n  where \"bindET = (\\<Lambda> m k. ErrorT\\<cdot>(bind\\<cdot>(runErrorT\\<cdot>m)\\<cdot>\n    (\\<Lambda> n. case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e) | Ok\\<cdot>x \\<Rightarrow> runErrorT\\<cdot>(k\\<cdot>x))))\""], ["", "definition liftET :: \"'a\\<cdot>'m::monad \\<rightarrow> 'a\\<cdot>('m,'e) errorT\"\n  where \"liftET = (\\<Lambda> m. ErrorT\\<cdot>(fmap\\<cdot>Ok\\<cdot>m))\""], ["", "definition throwET :: \"'e \\<rightarrow> 'a\\<cdot>('m::monad,'e) errorT\"\n  where \"throwET = (\\<Lambda> e. ErrorT\\<cdot>(return\\<cdot>(Err\\<cdot>e)))\""], ["", "definition catchET :: \"'a\\<cdot>('m::monad,'e) errorT \\<rightarrow>\n    ('e \\<rightarrow> 'a\\<cdot>('m,'e) errorT) \\<rightarrow> 'a\\<cdot>('m,'e) errorT\"\n  where \"catchET = (\\<Lambda> m h. ErrorT\\<cdot>(bind\\<cdot>(runErrorT\\<cdot>m)\\<cdot>(\\<Lambda> n. case n of\n    Err\\<cdot>e \\<Rightarrow> runErrorT\\<cdot>(h\\<cdot>e) | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>x))))\""], ["", "definition fmapET :: \"('a \\<rightarrow> 'b) \\<rightarrow>\n    'a\\<cdot>('m::monad,'e) errorT \\<rightarrow> 'b\\<cdot>('m,'e) errorT\"\n  where \"fmapET = (\\<Lambda> f m. bindET\\<cdot>m\\<cdot>(\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x)))\""], ["", "lemma runErrorT_unitET [simp]:\n  \"runErrorT\\<cdot>(unitET\\<cdot>x) = return\\<cdot>(Ok\\<cdot>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runErrorT\\<cdot>(unitET\\<cdot>x) = return\\<cdot>(Ok\\<cdot>x)", "unfolding unitET_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. runErrorT\\<cdot>\n    ((\\<Lambda> x. ErrorT\\<cdot>(return\\<cdot>(Ok\\<cdot>x)))\\<cdot>x) =\n    return\\<cdot>(Ok\\<cdot>x)", "by simp"], ["", "lemma runErrorT_bindET [simp]:\n  \"runErrorT\\<cdot>(bindET\\<cdot>m\\<cdot>k) = bind\\<cdot>(runErrorT\\<cdot>m)\\<cdot>\n    (\\<Lambda> n. case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e) | Ok\\<cdot>x \\<Rightarrow> runErrorT\\<cdot>(k\\<cdot>x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runErrorT\\<cdot>(bindET\\<cdot>m\\<cdot>k) =\n    runErrorT\\<cdot>m \\<bind>\n    (\\<Lambda> n.\n        case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow> runErrorT\\<cdot>(k\\<cdot>x))", "unfolding bindET_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. runErrorT\\<cdot>\n    ((\\<Lambda> m k.\n         ErrorT\\<cdot>\n         (runErrorT\\<cdot>m \\<bind>\n          Abs_cfun\n           (Rep_cfun\n             (error_case\\<cdot>\n              (\\<Lambda> e. return\\<cdot>(Err\\<cdot>e))\\<cdot>\n              (\\<Lambda> x. runErrorT\\<cdot>(k\\<cdot>x))))))\\<cdot>\n     m\\<cdot>\n     k) =\n    runErrorT\\<cdot>m \\<bind>\n    (\\<Lambda> n.\n        case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow> runErrorT\\<cdot>(k\\<cdot>x))", "by simp"], ["", "lemma runErrorT_liftET [simp]:\n  \"runErrorT\\<cdot>(liftET\\<cdot>m) = fmap\\<cdot>Ok\\<cdot>m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runErrorT\\<cdot>(liftET\\<cdot>m) = fmap\\<cdot>Ok\\<cdot>m", "unfolding liftET_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. runErrorT\\<cdot>\n    ((\\<Lambda> m. ErrorT\\<cdot>(fmap\\<cdot>Ok\\<cdot>m))\\<cdot>m) =\n    fmap\\<cdot>Ok\\<cdot>m", "by simp"], ["", "lemma runErrorT_throwET [simp]:\n  \"runErrorT\\<cdot>(throwET\\<cdot>e) = return\\<cdot>(Err\\<cdot>e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runErrorT\\<cdot>(throwET\\<cdot>e) = return\\<cdot>(Err\\<cdot>e)", "unfolding throwET_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. runErrorT\\<cdot>\n    ((\\<Lambda> e. ErrorT\\<cdot>(return\\<cdot>(Err\\<cdot>e)))\\<cdot>e) =\n    return\\<cdot>(Err\\<cdot>e)", "by simp"], ["", "lemma runErrorT_catchET [simp]:\n  \"runErrorT\\<cdot>(catchET\\<cdot>m\\<cdot>h) =\n    bind\\<cdot>(runErrorT\\<cdot>m)\\<cdot>(\\<Lambda> n. case n of\n      Err\\<cdot>e \\<Rightarrow> runErrorT\\<cdot>(h\\<cdot>e) | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runErrorT\\<cdot>(catchET\\<cdot>m\\<cdot>h) =\n    runErrorT\\<cdot>m \\<bind>\n    (\\<Lambda> n.\n        case n of Err\\<cdot>e \\<Rightarrow> runErrorT\\<cdot>(h\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>x))", "unfolding catchET_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. runErrorT\\<cdot>\n    ((\\<Lambda> m h.\n         ErrorT\\<cdot>\n         (runErrorT\\<cdot>m \\<bind>\n          Abs_cfun\n           (Rep_cfun\n             (error_case\\<cdot>\n              (\\<Lambda> e. runErrorT\\<cdot>(h\\<cdot>e))\\<cdot>\n              (\\<Lambda> x. return\\<cdot>(Ok\\<cdot>x))))))\\<cdot>\n     m\\<cdot>\n     h) =\n    runErrorT\\<cdot>m \\<bind>\n    (\\<Lambda> n.\n        case n of Err\\<cdot>e \\<Rightarrow> runErrorT\\<cdot>(h\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>x))", "by simp"], ["", "lemma runErrorT_fmapET [simp]:\n  \"runErrorT\\<cdot>(fmapET\\<cdot>f\\<cdot>m) =\n    bind\\<cdot>(runErrorT\\<cdot>m)\\<cdot>(\\<Lambda> n. case n of\n      Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e) | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runErrorT\\<cdot>(fmapET\\<cdot>f\\<cdot>m) =\n    runErrorT\\<cdot>m \\<bind>\n    (\\<Lambda> n.\n        case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)))", "unfolding fmapET_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. runErrorT\\<cdot>\n    ((\\<Lambda> f m.\n         bindET\\<cdot>m\\<cdot>\n         (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x)))\\<cdot>\n     f\\<cdot>\n     m) =\n    runErrorT\\<cdot>m \\<bind>\n    (\\<Lambda> n.\n        case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)))", "by simp"], ["", "subsection \\<open>Laws\\<close>"], ["", "lemma bindET_unitET [simp]:\n  \"bindET\\<cdot>(unitET\\<cdot>x)\\<cdot>k = k\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bindET\\<cdot>(unitET\\<cdot>x)\\<cdot>k = k\\<cdot>x", "by (rule errorT_eqI, simp)"], ["", "lemma catchET_unitET [simp]:\n  \"catchET\\<cdot>(unitET\\<cdot>x)\\<cdot>h = unitET\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. catchET\\<cdot>(unitET\\<cdot>x)\\<cdot>h = unitET\\<cdot>x", "by (rule errorT_eqI, simp)"], ["", "lemma catchET_throwET [simp]:\n  \"catchET\\<cdot>(throwET\\<cdot>e)\\<cdot>h = h\\<cdot>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. catchET\\<cdot>(throwET\\<cdot>e)\\<cdot>h = h\\<cdot>e", "by (rule errorT_eqI, simp)"], ["", "lemma liftET_return:\n  \"liftET\\<cdot>(return\\<cdot>x) = unitET\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liftET\\<cdot>(return\\<cdot>x) = unitET\\<cdot>x", "by (rule errorT_eqI, simp add: fmap_return)"], ["", "lemma liftET_bind:\n  \"liftET\\<cdot>(bind\\<cdot>m\\<cdot>k) = bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>(liftET oo k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. liftET\\<cdot>(m \\<bind> k) =\n    bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>(liftET oo k)", "by (rule errorT_eqI, simp add: fmap_bind bind_fmap)"], ["", "lemma bindET_throwET:\n  \"bindET\\<cdot>(throwET\\<cdot>e)\\<cdot>k = throwET\\<cdot>e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bindET\\<cdot>(throwET\\<cdot>e)\\<cdot>k = throwET\\<cdot>e", "by (rule errorT_eqI, simp)"], ["", "lemma bindET_bindET:\n  \"bindET\\<cdot>(bindET\\<cdot>m\\<cdot>h)\\<cdot>k = bindET\\<cdot>m\\<cdot>(\\<Lambda> x. bindET\\<cdot>(h\\<cdot>x)\\<cdot>k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bindET\\<cdot>(bindET\\<cdot>m\\<cdot>h)\\<cdot>k =\n    bindET\\<cdot>m\\<cdot>(\\<Lambda> x. bindET\\<cdot>(h\\<cdot>x)\\<cdot>k)", "apply (rule errorT_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. runErrorT\\<cdot>(bindET\\<cdot>(bindET\\<cdot>m\\<cdot>h)\\<cdot>k) =\n    runErrorT\\<cdot>\n    (bindET\\<cdot>m\\<cdot>(\\<Lambda> x. bindET\\<cdot>(h\\<cdot>x)\\<cdot>k))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. runErrorT\\<cdot>m \\<bind>\n    (\\<Lambda> n.\n        case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow> runErrorT\\<cdot>(h\\<cdot>x)) \\<bind>\n    (\\<Lambda> n.\n        case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow> runErrorT\\<cdot>(k\\<cdot>x)) =\n    runErrorT\\<cdot>m \\<bind>\n    (\\<Lambda> n.\n        case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow>\n            runErrorT\\<cdot>(h\\<cdot>x) \\<bind>\n            (\\<Lambda> n.\n                case n of\n                Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n                | Ok\\<cdot>x \\<Rightarrow> runErrorT\\<cdot>(k\\<cdot>x)))", "apply (simp add: bind_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. runErrorT\\<cdot>m \\<bind>\n    (\\<Lambda> x.\n        (case x of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n         | Ok\\<cdot>x \\<Rightarrow> runErrorT\\<cdot>(h\\<cdot>x)) \\<bind>\n        Abs_cfun\n         (Rep_cfun\n           (error_case\\<cdot>\n            (\\<Lambda> e. return\\<cdot>(Err\\<cdot>e))\\<cdot>\n            (\\<Lambda> x. runErrorT\\<cdot>(k\\<cdot>x))))) =\n    runErrorT\\<cdot>m \\<bind>\n    (\\<Lambda> n.\n        case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow>\n            runErrorT\\<cdot>(h\\<cdot>x) \\<bind>\n            (\\<Lambda> n.\n                case n of\n                Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n                | Ok\\<cdot>x \\<Rightarrow> runErrorT\\<cdot>(k\\<cdot>x)))", "apply (rule cfun_arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> x.\n        (case x of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n         | Ok\\<cdot>x \\<Rightarrow> runErrorT\\<cdot>(h\\<cdot>x)) \\<bind>\n        Abs_cfun\n         (Rep_cfun\n           (error_case\\<cdot>\n            (\\<Lambda> e. return\\<cdot>(Err\\<cdot>e))\\<cdot>\n            (\\<Lambda> x. runErrorT\\<cdot>(k\\<cdot>x))))) =\n    (\\<Lambda> n.\n        case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow>\n            runErrorT\\<cdot>(h\\<cdot>x) \\<bind>\n            (\\<Lambda> n.\n                case n of\n                Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n                | Ok\\<cdot>x \\<Rightarrow> runErrorT\\<cdot>(k\\<cdot>x)))", "apply (rule cfun_eqI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case x of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow> runErrorT\\<cdot>(h\\<cdot>x)) \\<bind>\n       Abs_cfun\n        (Rep_cfun\n          (error_case\\<cdot>(\\<Lambda> e. return\\<cdot>(Err\\<cdot>e))\\<cdot>\n           (\\<Lambda> x. runErrorT\\<cdot>(k\\<cdot>x)))) =\n       (case x of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow>\n            runErrorT\\<cdot>(h\\<cdot>x) \\<bind>\n            Abs_cfun\n             (Rep_cfun\n               (error_case\\<cdot>\n                (\\<Lambda> e. return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                (\\<Lambda> x. runErrorT\\<cdot>(k\\<cdot>x)))))", "apply (case_tac x)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x = \\<bottom> \\<Longrightarrow>\n       (case x of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow> runErrorT\\<cdot>(h\\<cdot>x)) \\<bind>\n       Abs_cfun\n        (Rep_cfun\n          (error_case\\<cdot>(\\<Lambda> e. return\\<cdot>(Err\\<cdot>e))\\<cdot>\n           (\\<Lambda> x. runErrorT\\<cdot>(k\\<cdot>x)))) =\n       (case x of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow>\n            runErrorT\\<cdot>(h\\<cdot>x) \\<bind>\n            Abs_cfun\n             (Rep_cfun\n               (error_case\\<cdot>\n                (\\<Lambda> e. return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                (\\<Lambda> x. runErrorT\\<cdot>(k\\<cdot>x)))))\n 2. \\<And>x e.\n       x = Err\\<cdot>e \\<Longrightarrow>\n       (case x of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow> runErrorT\\<cdot>(h\\<cdot>x)) \\<bind>\n       Abs_cfun\n        (Rep_cfun\n          (error_case\\<cdot>(\\<Lambda> e. return\\<cdot>(Err\\<cdot>e))\\<cdot>\n           (\\<Lambda> x. runErrorT\\<cdot>(k\\<cdot>x)))) =\n       (case x of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow>\n            runErrorT\\<cdot>(h\\<cdot>x) \\<bind>\n            Abs_cfun\n             (Rep_cfun\n               (error_case\\<cdot>\n                (\\<Lambda> e. return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                (\\<Lambda> x. runErrorT\\<cdot>(k\\<cdot>x)))))\n 3. \\<And>x a.\n       x = Ok\\<cdot>a \\<Longrightarrow>\n       (case x of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow> runErrorT\\<cdot>(h\\<cdot>x)) \\<bind>\n       Abs_cfun\n        (Rep_cfun\n          (error_case\\<cdot>(\\<Lambda> e. return\\<cdot>(Err\\<cdot>e))\\<cdot>\n           (\\<Lambda> x. runErrorT\\<cdot>(k\\<cdot>x)))) =\n       (case x of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow>\n            runErrorT\\<cdot>(h\\<cdot>x) \\<bind>\n            Abs_cfun\n             (Rep_cfun\n               (error_case\\<cdot>\n                (\\<Lambda> e. return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                (\\<Lambda> x. runErrorT\\<cdot>(k\\<cdot>x)))))", "apply (simp add: bind_strict)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x e.\n       x = Err\\<cdot>e \\<Longrightarrow>\n       (case x of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow> runErrorT\\<cdot>(h\\<cdot>x)) \\<bind>\n       Abs_cfun\n        (Rep_cfun\n          (error_case\\<cdot>(\\<Lambda> e. return\\<cdot>(Err\\<cdot>e))\\<cdot>\n           (\\<Lambda> x. runErrorT\\<cdot>(k\\<cdot>x)))) =\n       (case x of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow>\n            runErrorT\\<cdot>(h\\<cdot>x) \\<bind>\n            Abs_cfun\n             (Rep_cfun\n               (error_case\\<cdot>\n                (\\<Lambda> e. return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                (\\<Lambda> x. runErrorT\\<cdot>(k\\<cdot>x)))))\n 2. \\<And>x a.\n       x = Ok\\<cdot>a \\<Longrightarrow>\n       (case x of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow> runErrorT\\<cdot>(h\\<cdot>x)) \\<bind>\n       Abs_cfun\n        (Rep_cfun\n          (error_case\\<cdot>(\\<Lambda> e. return\\<cdot>(Err\\<cdot>e))\\<cdot>\n           (\\<Lambda> x. runErrorT\\<cdot>(k\\<cdot>x)))) =\n       (case x of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow>\n            runErrorT\\<cdot>(h\\<cdot>x) \\<bind>\n            Abs_cfun\n             (Rep_cfun\n               (error_case\\<cdot>\n                (\\<Lambda> e. return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                (\\<Lambda> x. runErrorT\\<cdot>(k\\<cdot>x)))))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a.\n       x = Ok\\<cdot>a \\<Longrightarrow>\n       (case x of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow> runErrorT\\<cdot>(h\\<cdot>x)) \\<bind>\n       Abs_cfun\n        (Rep_cfun\n          (error_case\\<cdot>(\\<Lambda> e. return\\<cdot>(Err\\<cdot>e))\\<cdot>\n           (\\<Lambda> x. runErrorT\\<cdot>(k\\<cdot>x)))) =\n       (case x of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow>\n            runErrorT\\<cdot>(h\\<cdot>x) \\<bind>\n            Abs_cfun\n             (Rep_cfun\n               (error_case\\<cdot>\n                (\\<Lambda> e. return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                (\\<Lambda> x. runErrorT\\<cdot>(k\\<cdot>x)))))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fmapET_fmapET:\n  \"fmapET\\<cdot>f\\<cdot>(fmapET\\<cdot>g\\<cdot>m) = fmapET\\<cdot>(\\<Lambda> x. f\\<cdot>(g\\<cdot>x))\\<cdot>m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmapET\\<cdot>f\\<cdot>(fmapET\\<cdot>g\\<cdot>m) =\n    fmapET\\<cdot>(\\<Lambda> x. f\\<cdot>(g\\<cdot>x))\\<cdot>m", "by (simp add: fmapET_def bindET_bindET)"], ["", "text \\<open>Right unit monad law is not satisfied in general.\\<close>"], ["", "lemma bindET_unitET_right_counterexample:\n  fixes m :: \"'a\\<cdot>('m::monad,'e) errorT\"\n  assumes \"m = ErrorT\\<cdot>(return\\<cdot>\\<bottom>)\"\n  assumes \"return\\<cdot>\\<bottom> \\<noteq> (\\<bottom> :: ('a\\<cdot>'e error)\\<cdot>'m)\"\n  shows \"bindET\\<cdot>m\\<cdot>unitET \\<noteq> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bindET\\<cdot>m\\<cdot>unitET \\<noteq> m", "by (simp add: errorT_eq_iff assms)"], ["", "text \\<open>Right unit is satisfied for inner monads with strict return.\\<close>"], ["", "lemma bindET_unitET_right_restricted:\n  fixes m :: \"'a\\<cdot>('m::monad,'e) errorT\"\n  assumes \"return\\<cdot>\\<bottom> = (\\<bottom> :: ('a\\<cdot>'e error)\\<cdot>'m)\"\n  shows \"bindET\\<cdot>m\\<cdot>unitET = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bindET\\<cdot>m\\<cdot>unitET = m", "unfolding errorT_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. runErrorT\\<cdot>(bindET\\<cdot>m\\<cdot>unitET) = runErrorT\\<cdot>m", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. runErrorT\\<cdot>m \\<bind>\n    (\\<Lambda> n.\n        case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>x)) =\n    runErrorT\\<cdot>m", "apply (rule trans [OF _ monad_right_unit])"], ["proof (prove)\ngoal (1 subgoal):\n 1. runErrorT\\<cdot>m \\<bind>\n    (\\<Lambda> n.\n        case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>x)) =\n    runErrorT\\<cdot>m \\<bind> return", "apply (rule cfun_arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> n.\n        case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>x)) =\n    return", "apply (rule cfun_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<Lambda> n.\n           case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n           | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>x))\\<cdot>\n       x =\n       return\\<cdot>x", "apply (case_tac x, simp_all add: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Error monad transformer invariant\\<close>"], ["", "text \\<open>This inductively-defined invariant is supposed to represent\nthe set of all values constructible using the standard \\<open>errorT\\<close>\noperations.\\<close>"], ["", "inductive invar :: \"'a\\<cdot>('m::monad, 'e) errorT \\<Rightarrow> bool\"\n  where invar_bottom: \"invar \\<bottom>\"\n  | invar_lub: \"\\<And>Y. \\<lbrakk>chain Y; \\<And>i. invar (Y i)\\<rbrakk> \\<Longrightarrow> invar (\\<Squnion>i. Y i)\"\n  | invar_unitET: \"\\<And>x. invar (unitET\\<cdot>x)\"\n  | invar_bindET: \"\\<And>m k. \\<lbrakk>invar m; \\<And>x. invar (k\\<cdot>x)\\<rbrakk> \\<Longrightarrow> invar (bindET\\<cdot>m\\<cdot>k)\"\n  | invar_throwET: \"\\<And>e. invar (throwET\\<cdot>e)\"\n  | invar_catchET: \"\\<And>m h. \\<lbrakk>invar m; \\<And>e. invar (h\\<cdot>e)\\<rbrakk> \\<Longrightarrow> invar (catchET\\<cdot>m\\<cdot>h)\"\n  | invar_liftET: \"\\<And>m. invar (liftET\\<cdot>m)\""], ["", "text \\<open>Right unit is satisfied for arguments built from standard functions.\\<close>"], ["", "lemma bindET_unitET_right_invar:\n  assumes \"invar m\"\n  shows \"bindET\\<cdot>m\\<cdot>unitET = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bindET\\<cdot>m\\<cdot>unitET = m", "using assms"], ["proof (prove)\nusing this:\n  invar m\n\ngoal (1 subgoal):\n 1. bindET\\<cdot>m\\<cdot>unitET = m", "apply (induct set: invar)"], ["proof (prove)\ngoal (7 subgoals):\n 1. bindET\\<cdot>\\<bottom>\\<cdot>unitET = \\<bottom>\n 2. \\<And>Y.\n       \\<lbrakk>chain Y; \\<And>i. invar (Y i);\n        \\<And>i. bindET\\<cdot>(Y i)\\<cdot>unitET = Y i\\<rbrakk>\n       \\<Longrightarrow> bindET\\<cdot>(Lub Y)\\<cdot>unitET = Lub Y\n 3. \\<And>x. bindET\\<cdot>(unitET\\<cdot>x)\\<cdot>unitET = unitET\\<cdot>x\n 4. \\<And>m k.\n       \\<lbrakk>invar m; bindET\\<cdot>m\\<cdot>unitET = m;\n        \\<And>x. invar (k\\<cdot>x);\n        \\<And>x. bindET\\<cdot>(k\\<cdot>x)\\<cdot>unitET = k\\<cdot>x\\<rbrakk>\n       \\<Longrightarrow> bindET\\<cdot>(bindET\\<cdot>m\\<cdot>k)\\<cdot>\n                         unitET =\n                         bindET\\<cdot>m\\<cdot>k\n 5. \\<And>e. bindET\\<cdot>(throwET\\<cdot>e)\\<cdot>unitET = throwET\\<cdot>e\n 6. \\<And>m h.\n       \\<lbrakk>invar m; bindET\\<cdot>m\\<cdot>unitET = m;\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e. bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET = h\\<cdot>e\\<rbrakk>\n       \\<Longrightarrow> bindET\\<cdot>(catchET\\<cdot>m\\<cdot>h)\\<cdot>\n                         unitET =\n                         catchET\\<cdot>m\\<cdot>h\n 7. \\<And>m. bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>unitET = liftET\\<cdot>m", "apply (rule errorT_eqI, simp add: bind_strict)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; \\<And>i. invar (Y i);\n        \\<And>i. bindET\\<cdot>(Y i)\\<cdot>unitET = Y i\\<rbrakk>\n       \\<Longrightarrow> bindET\\<cdot>(Lub Y)\\<cdot>unitET = Lub Y\n 2. \\<And>x. bindET\\<cdot>(unitET\\<cdot>x)\\<cdot>unitET = unitET\\<cdot>x\n 3. \\<And>m k.\n       \\<lbrakk>invar m; bindET\\<cdot>m\\<cdot>unitET = m;\n        \\<And>x. invar (k\\<cdot>x);\n        \\<And>x. bindET\\<cdot>(k\\<cdot>x)\\<cdot>unitET = k\\<cdot>x\\<rbrakk>\n       \\<Longrightarrow> bindET\\<cdot>(bindET\\<cdot>m\\<cdot>k)\\<cdot>\n                         unitET =\n                         bindET\\<cdot>m\\<cdot>k\n 4. \\<And>e. bindET\\<cdot>(throwET\\<cdot>e)\\<cdot>unitET = throwET\\<cdot>e\n 5. \\<And>m h.\n       \\<lbrakk>invar m; bindET\\<cdot>m\\<cdot>unitET = m;\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e. bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET = h\\<cdot>e\\<rbrakk>\n       \\<Longrightarrow> bindET\\<cdot>(catchET\\<cdot>m\\<cdot>h)\\<cdot>\n                         unitET =\n                         catchET\\<cdot>m\\<cdot>h\n 6. \\<And>m. bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>unitET = liftET\\<cdot>m", "apply (rule admD, simp, assumption, assumption)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x. bindET\\<cdot>(unitET\\<cdot>x)\\<cdot>unitET = unitET\\<cdot>x\n 2. \\<And>m k.\n       \\<lbrakk>invar m; bindET\\<cdot>m\\<cdot>unitET = m;\n        \\<And>x. invar (k\\<cdot>x);\n        \\<And>x. bindET\\<cdot>(k\\<cdot>x)\\<cdot>unitET = k\\<cdot>x\\<rbrakk>\n       \\<Longrightarrow> bindET\\<cdot>(bindET\\<cdot>m\\<cdot>k)\\<cdot>\n                         unitET =\n                         bindET\\<cdot>m\\<cdot>k\n 3. \\<And>e. bindET\\<cdot>(throwET\\<cdot>e)\\<cdot>unitET = throwET\\<cdot>e\n 4. \\<And>m h.\n       \\<lbrakk>invar m; bindET\\<cdot>m\\<cdot>unitET = m;\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e. bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET = h\\<cdot>e\\<rbrakk>\n       \\<Longrightarrow> bindET\\<cdot>(catchET\\<cdot>m\\<cdot>h)\\<cdot>\n                         unitET =\n                         catchET\\<cdot>m\\<cdot>h\n 5. \\<And>m. bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>unitET = liftET\\<cdot>m", "apply (rule errorT_eqI, simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m k.\n       \\<lbrakk>invar m; bindET\\<cdot>m\\<cdot>unitET = m;\n        \\<And>x. invar (k\\<cdot>x);\n        \\<And>x. bindET\\<cdot>(k\\<cdot>x)\\<cdot>unitET = k\\<cdot>x\\<rbrakk>\n       \\<Longrightarrow> bindET\\<cdot>(bindET\\<cdot>m\\<cdot>k)\\<cdot>\n                         unitET =\n                         bindET\\<cdot>m\\<cdot>k\n 2. \\<And>e. bindET\\<cdot>(throwET\\<cdot>e)\\<cdot>unitET = throwET\\<cdot>e\n 3. \\<And>m h.\n       \\<lbrakk>invar m; bindET\\<cdot>m\\<cdot>unitET = m;\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e. bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET = h\\<cdot>e\\<rbrakk>\n       \\<Longrightarrow> bindET\\<cdot>(catchET\\<cdot>m\\<cdot>h)\\<cdot>\n                         unitET =\n                         catchET\\<cdot>m\\<cdot>h\n 4. \\<And>m. bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>unitET = liftET\\<cdot>m", "apply (simp add: errorT_eq_iff bind_bind)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m k.\n       \\<lbrakk>invar m;\n        runErrorT\\<cdot>m \\<bind>\n        (\\<Lambda> n.\n            case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n            | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>x)) =\n        runErrorT\\<cdot>m;\n        \\<And>x. invar (k\\<cdot>x);\n        \\<And>x.\n           runErrorT\\<cdot>(k\\<cdot>x) \\<bind>\n           (\\<Lambda> n.\n               case n of\n               Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n               | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>x)) =\n           runErrorT\\<cdot>(k\\<cdot>x)\\<rbrakk>\n       \\<Longrightarrow> runErrorT\\<cdot>m \\<bind>\n                         (\\<Lambda> x.\n                             (case x of\n                              Err\\<cdot>e \\<Rightarrow>\n                                return\\<cdot>(Err\\<cdot>e)\n                              | Ok\\<cdot>x \\<Rightarrow>\n                                  runErrorT\\<cdot>(k\\<cdot>x)) \\<bind>\n                             Abs_cfun\n                              (Rep_cfun\n                                (error_case\\<cdot>\n                                 (\\<Lambda> e.\n                                     return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                                 (\\<Lambda> x.\n                                     return\\<cdot>(Ok\\<cdot>x))))) =\n                         runErrorT\\<cdot>m \\<bind>\n                         (\\<Lambda> n.\n                             case n of\n                             Err\\<cdot>e \\<Rightarrow>\n                               return\\<cdot>(Err\\<cdot>e)\n                             | Ok\\<cdot>x \\<Rightarrow>\n                                 runErrorT\\<cdot>(k\\<cdot>x))\n 2. \\<And>e. bindET\\<cdot>(throwET\\<cdot>e)\\<cdot>unitET = throwET\\<cdot>e\n 3. \\<And>m h.\n       \\<lbrakk>invar m; bindET\\<cdot>m\\<cdot>unitET = m;\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e. bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET = h\\<cdot>e\\<rbrakk>\n       \\<Longrightarrow> bindET\\<cdot>(catchET\\<cdot>m\\<cdot>h)\\<cdot>\n                         unitET =\n                         catchET\\<cdot>m\\<cdot>h\n 4. \\<And>m. bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>unitET = liftET\\<cdot>m", "apply (rule cfun_arg_cong, rule cfun_eqI, simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m k x.\n       \\<lbrakk>invar m;\n        runErrorT\\<cdot>m \\<bind>\n        (\\<Lambda> n.\n            case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n            | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>x)) =\n        runErrorT\\<cdot>m;\n        \\<And>x. invar (k\\<cdot>x);\n        \\<And>x.\n           runErrorT\\<cdot>(k\\<cdot>x) \\<bind>\n           (\\<Lambda> n.\n               case n of\n               Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n               | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>x)) =\n           runErrorT\\<cdot>(k\\<cdot>x)\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            return\\<cdot>(Err\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              runErrorT\\<cdot>(k\\<cdot>x)) \\<bind>\n                         Abs_cfun\n                          (Rep_cfun\n                            (error_case\\<cdot>\n                             (\\<Lambda> e.\n                                 return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                             (\\<Lambda> x. return\\<cdot>(Ok\\<cdot>x)))) =\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            return\\<cdot>(Err\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              runErrorT\\<cdot>(k\\<cdot>x))\n 2. \\<And>e. bindET\\<cdot>(throwET\\<cdot>e)\\<cdot>unitET = throwET\\<cdot>e\n 3. \\<And>m h.\n       \\<lbrakk>invar m; bindET\\<cdot>m\\<cdot>unitET = m;\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e. bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET = h\\<cdot>e\\<rbrakk>\n       \\<Longrightarrow> bindET\\<cdot>(catchET\\<cdot>m\\<cdot>h)\\<cdot>\n                         unitET =\n                         catchET\\<cdot>m\\<cdot>h\n 4. \\<And>m. bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>unitET = liftET\\<cdot>m", "apply (case_tac x, simp add: bind_strict, simp, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e. bindET\\<cdot>(throwET\\<cdot>e)\\<cdot>unitET = throwET\\<cdot>e\n 2. \\<And>m h.\n       \\<lbrakk>invar m; bindET\\<cdot>m\\<cdot>unitET = m;\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e. bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET = h\\<cdot>e\\<rbrakk>\n       \\<Longrightarrow> bindET\\<cdot>(catchET\\<cdot>m\\<cdot>h)\\<cdot>\n                         unitET =\n                         catchET\\<cdot>m\\<cdot>h\n 3. \\<And>m. bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>unitET = liftET\\<cdot>m", "apply (rule errorT_eqI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m h.\n       \\<lbrakk>invar m; bindET\\<cdot>m\\<cdot>unitET = m;\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e. bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET = h\\<cdot>e\\<rbrakk>\n       \\<Longrightarrow> bindET\\<cdot>(catchET\\<cdot>m\\<cdot>h)\\<cdot>\n                         unitET =\n                         catchET\\<cdot>m\\<cdot>h\n 2. \\<And>m. bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>unitET = liftET\\<cdot>m", "apply (simp add: errorT_eq_iff bind_bind)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m h.\n       \\<lbrakk>invar m;\n        runErrorT\\<cdot>m \\<bind>\n        (\\<Lambda> n.\n            case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n            | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>x)) =\n        runErrorT\\<cdot>m;\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e.\n           runErrorT\\<cdot>(h\\<cdot>e) \\<bind>\n           (\\<Lambda> n.\n               case n of\n               Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n               | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>x)) =\n           runErrorT\\<cdot>(h\\<cdot>e)\\<rbrakk>\n       \\<Longrightarrow> runErrorT\\<cdot>m \\<bind>\n                         (\\<Lambda> x.\n                             (case x of\n                              Err\\<cdot>e \\<Rightarrow>\n                                runErrorT\\<cdot>(h\\<cdot>e)\n                              | Ok\\<cdot>x \\<Rightarrow>\n                                  return\\<cdot>(Ok\\<cdot>x)) \\<bind>\n                             Abs_cfun\n                              (Rep_cfun\n                                (error_case\\<cdot>\n                                 (\\<Lambda> e.\n                                     return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                                 (\\<Lambda> x.\n                                     return\\<cdot>(Ok\\<cdot>x))))) =\n                         runErrorT\\<cdot>m \\<bind>\n                         (\\<Lambda> n.\n                             case n of\n                             Err\\<cdot>e \\<Rightarrow>\n                               runErrorT\\<cdot>(h\\<cdot>e)\n                             | Ok\\<cdot>x \\<Rightarrow>\n                                 return\\<cdot>(Ok\\<cdot>x))\n 2. \\<And>m. bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>unitET = liftET\\<cdot>m", "apply (rule cfun_arg_cong, rule cfun_eqI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m h x.\n       \\<lbrakk>invar m;\n        runErrorT\\<cdot>m \\<bind>\n        (\\<Lambda> n.\n            case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n            | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>x)) =\n        runErrorT\\<cdot>m;\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e.\n           runErrorT\\<cdot>(h\\<cdot>e) \\<bind>\n           (\\<Lambda> n.\n               case n of\n               Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n               | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>x)) =\n           runErrorT\\<cdot>(h\\<cdot>e)\\<rbrakk>\n       \\<Longrightarrow> (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            runErrorT\\<cdot>(h\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              return\\<cdot>(Ok\\<cdot>x)) \\<bind>\n                         Abs_cfun\n                          (Rep_cfun\n                            (error_case\\<cdot>\n                             (\\<Lambda> e.\n                                 return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                             (\\<Lambda> x. return\\<cdot>(Ok\\<cdot>x)))) =\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            runErrorT\\<cdot>(h\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              return\\<cdot>(Ok\\<cdot>x))\n 2. \\<And>m. bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>unitET = liftET\\<cdot>m", "apply (case_tac x, simp add: bind_strict, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m. bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>unitET = liftET\\<cdot>m", "apply (rule errorT_eqI, simp add: monad_fmap bind_bind)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Monad-fmap is satisfied for arguments built from standard functions.\\<close>"], ["", "lemma errorT_monad_fmap_invar:\n  fixes f :: \"'a \\<rightarrow> 'b\" and m :: \"'a\\<cdot>('m::monad,'e) errorT\"\n  assumes \"invar m\"\n  shows \"fmap\\<cdot>f\\<cdot>m = bindET\\<cdot>m\\<cdot>(\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap\\<cdot>f\\<cdot>m =\n    bindET\\<cdot>m\\<cdot>(\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))", "using assms"], ["proof (prove)\nusing this:\n  invar m\n\ngoal (1 subgoal):\n 1. fmap\\<cdot>f\\<cdot>m =\n    bindET\\<cdot>m\\<cdot>(\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))", "apply (induct set: invar)"], ["proof (prove)\ngoal (7 subgoals):\n 1. fmap\\<cdot>f\\<cdot>\\<bottom> =\n    bindET\\<cdot>\\<bottom>\\<cdot>(\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 2. \\<And>Y.\n       \\<lbrakk>chain Y; \\<And>i. invar (Y i);\n        \\<And>i.\n           fmap\\<cdot>f\\<cdot>(Y i) =\n           bindET\\<cdot>(Y i)\\<cdot>\n           (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>f\\<cdot>(Lub Y) =\n                         bindET\\<cdot>(Lub Y)\\<cdot>\n                         (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 3. \\<And>x.\n       fmap\\<cdot>f\\<cdot>(unitET\\<cdot>x) =\n       bindET\\<cdot>(unitET\\<cdot>x)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 4. \\<And>m k.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>f\\<cdot>m =\n        bindET\\<cdot>m\\<cdot>(\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x));\n        \\<And>x. invar (k\\<cdot>x);\n        \\<And>x.\n           fmap\\<cdot>f\\<cdot>(k\\<cdot>x) =\n           bindET\\<cdot>(k\\<cdot>x)\\<cdot>\n           (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>f\\<cdot>(bindET\\<cdot>m\\<cdot>k) =\n                         bindET\\<cdot>(bindET\\<cdot>m\\<cdot>k)\\<cdot>\n                         (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 5. \\<And>e.\n       fmap\\<cdot>f\\<cdot>(throwET\\<cdot>e) =\n       bindET\\<cdot>(throwET\\<cdot>e)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 6. \\<And>m h.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>f\\<cdot>m =\n        bindET\\<cdot>m\\<cdot>(\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x));\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e.\n           fmap\\<cdot>f\\<cdot>(h\\<cdot>e) =\n           bindET\\<cdot>(h\\<cdot>e)\\<cdot>\n           (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>f\\<cdot>(catchET\\<cdot>m\\<cdot>h) =\n                         bindET\\<cdot>(catchET\\<cdot>m\\<cdot>h)\\<cdot>\n                         (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 7. \\<And>m.\n       fmap\\<cdot>f\\<cdot>(liftET\\<cdot>m) =\n       bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))", "apply (rule errorT_eqI, simp add: bind_strict fmap_strict)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>Y.\n       \\<lbrakk>chain Y; \\<And>i. invar (Y i);\n        \\<And>i.\n           fmap\\<cdot>f\\<cdot>(Y i) =\n           bindET\\<cdot>(Y i)\\<cdot>\n           (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>f\\<cdot>(Lub Y) =\n                         bindET\\<cdot>(Lub Y)\\<cdot>\n                         (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 2. \\<And>x.\n       fmap\\<cdot>f\\<cdot>(unitET\\<cdot>x) =\n       bindET\\<cdot>(unitET\\<cdot>x)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 3. \\<And>m k.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>f\\<cdot>m =\n        bindET\\<cdot>m\\<cdot>(\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x));\n        \\<And>x. invar (k\\<cdot>x);\n        \\<And>x.\n           fmap\\<cdot>f\\<cdot>(k\\<cdot>x) =\n           bindET\\<cdot>(k\\<cdot>x)\\<cdot>\n           (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>f\\<cdot>(bindET\\<cdot>m\\<cdot>k) =\n                         bindET\\<cdot>(bindET\\<cdot>m\\<cdot>k)\\<cdot>\n                         (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 4. \\<And>e.\n       fmap\\<cdot>f\\<cdot>(throwET\\<cdot>e) =\n       bindET\\<cdot>(throwET\\<cdot>e)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 5. \\<And>m h.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>f\\<cdot>m =\n        bindET\\<cdot>m\\<cdot>(\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x));\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e.\n           fmap\\<cdot>f\\<cdot>(h\\<cdot>e) =\n           bindET\\<cdot>(h\\<cdot>e)\\<cdot>\n           (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>f\\<cdot>(catchET\\<cdot>m\\<cdot>h) =\n                         bindET\\<cdot>(catchET\\<cdot>m\\<cdot>h)\\<cdot>\n                         (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 6. \\<And>m.\n       fmap\\<cdot>f\\<cdot>(liftET\\<cdot>m) =\n       bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))", "apply (rule admD, simp, assumption, assumption)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       fmap\\<cdot>f\\<cdot>(unitET\\<cdot>x) =\n       bindET\\<cdot>(unitET\\<cdot>x)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 2. \\<And>m k.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>f\\<cdot>m =\n        bindET\\<cdot>m\\<cdot>(\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x));\n        \\<And>x. invar (k\\<cdot>x);\n        \\<And>x.\n           fmap\\<cdot>f\\<cdot>(k\\<cdot>x) =\n           bindET\\<cdot>(k\\<cdot>x)\\<cdot>\n           (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>f\\<cdot>(bindET\\<cdot>m\\<cdot>k) =\n                         bindET\\<cdot>(bindET\\<cdot>m\\<cdot>k)\\<cdot>\n                         (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 3. \\<And>e.\n       fmap\\<cdot>f\\<cdot>(throwET\\<cdot>e) =\n       bindET\\<cdot>(throwET\\<cdot>e)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 4. \\<And>m h.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>f\\<cdot>m =\n        bindET\\<cdot>m\\<cdot>(\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x));\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e.\n           fmap\\<cdot>f\\<cdot>(h\\<cdot>e) =\n           bindET\\<cdot>(h\\<cdot>e)\\<cdot>\n           (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>f\\<cdot>(catchET\\<cdot>m\\<cdot>h) =\n                         bindET\\<cdot>(catchET\\<cdot>m\\<cdot>h)\\<cdot>\n                         (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 5. \\<And>m.\n       fmap\\<cdot>f\\<cdot>(liftET\\<cdot>m) =\n       bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))", "apply (rule errorT_eqI, simp add: fmap_return)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m k.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>f\\<cdot>m =\n        bindET\\<cdot>m\\<cdot>(\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x));\n        \\<And>x. invar (k\\<cdot>x);\n        \\<And>x.\n           fmap\\<cdot>f\\<cdot>(k\\<cdot>x) =\n           bindET\\<cdot>(k\\<cdot>x)\\<cdot>\n           (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>f\\<cdot>(bindET\\<cdot>m\\<cdot>k) =\n                         bindET\\<cdot>(bindET\\<cdot>m\\<cdot>k)\\<cdot>\n                         (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 2. \\<And>e.\n       fmap\\<cdot>f\\<cdot>(throwET\\<cdot>e) =\n       bindET\\<cdot>(throwET\\<cdot>e)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 3. \\<And>m h.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>f\\<cdot>m =\n        bindET\\<cdot>m\\<cdot>(\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x));\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e.\n           fmap\\<cdot>f\\<cdot>(h\\<cdot>e) =\n           bindET\\<cdot>(h\\<cdot>e)\\<cdot>\n           (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>f\\<cdot>(catchET\\<cdot>m\\<cdot>h) =\n                         bindET\\<cdot>(catchET\\<cdot>m\\<cdot>h)\\<cdot>\n                         (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 4. \\<And>m.\n       fmap\\<cdot>f\\<cdot>(liftET\\<cdot>m) =\n       bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))", "apply (simp add: errorT_eq_iff bind_bind fmap_bind)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m k.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>m) =\n        runErrorT\\<cdot>m \\<bind>\n        (\\<Lambda> n.\n            case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n            | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        \\<And>x. invar (k\\<cdot>x);\n        \\<And>x.\n           fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>(k\\<cdot>x)) =\n           runErrorT\\<cdot>(k\\<cdot>x) \\<bind>\n           (\\<Lambda> n.\n               case n of\n               Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n               | Ok\\<cdot>x \\<Rightarrow>\n                   return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)))\\<rbrakk>\n       \\<Longrightarrow> runErrorT\\<cdot>m \\<bind>\n                         (\\<Lambda> x.\n                             fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>\n                             (case x of\n                              Err\\<cdot>e \\<Rightarrow>\n                                return\\<cdot>(Err\\<cdot>e)\n                              | Ok\\<cdot>x \\<Rightarrow>\n                                  runErrorT\\<cdot>(k\\<cdot>x))) =\n                         runErrorT\\<cdot>m \\<bind>\n                         (\\<Lambda> x.\n                             (case x of\n                              Err\\<cdot>e \\<Rightarrow>\n                                return\\<cdot>(Err\\<cdot>e)\n                              | Ok\\<cdot>x \\<Rightarrow>\n                                  runErrorT\\<cdot>(k\\<cdot>x)) \\<bind>\n                             Abs_cfun\n                              (Rep_cfun\n                                (error_case\\<cdot>\n                                 (\\<Lambda> e.\n                                     return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                                 (\\<Lambda> x.\n                                     return\\<cdot>(Ok\\<cdot>(f\\<cdot>x))))))\n 2. \\<And>e.\n       fmap\\<cdot>f\\<cdot>(throwET\\<cdot>e) =\n       bindET\\<cdot>(throwET\\<cdot>e)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 3. \\<And>m h.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>f\\<cdot>m =\n        bindET\\<cdot>m\\<cdot>(\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x));\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e.\n           fmap\\<cdot>f\\<cdot>(h\\<cdot>e) =\n           bindET\\<cdot>(h\\<cdot>e)\\<cdot>\n           (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>f\\<cdot>(catchET\\<cdot>m\\<cdot>h) =\n                         bindET\\<cdot>(catchET\\<cdot>m\\<cdot>h)\\<cdot>\n                         (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 4. \\<And>m.\n       fmap\\<cdot>f\\<cdot>(liftET\\<cdot>m) =\n       bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))", "apply (rule cfun_arg_cong, rule cfun_eqI, simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m k x.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>m) =\n        runErrorT\\<cdot>m \\<bind>\n        (\\<Lambda> n.\n            case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n            | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        \\<And>x. invar (k\\<cdot>x);\n        \\<And>x.\n           fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>(k\\<cdot>x)) =\n           runErrorT\\<cdot>(k\\<cdot>x) \\<bind>\n           (\\<Lambda> n.\n               case n of\n               Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n               | Ok\\<cdot>x \\<Rightarrow>\n                   return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)))\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            return\\<cdot>(Err\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              runErrorT\\<cdot>(k\\<cdot>x)) =\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            return\\<cdot>(Err\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              runErrorT\\<cdot>(k\\<cdot>x)) \\<bind>\n                         Abs_cfun\n                          (Rep_cfun\n                            (error_case\\<cdot>\n                             (\\<Lambda> e.\n                                 return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                             (\\<Lambda> x.\n                                 return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)))))\n 2. \\<And>e.\n       fmap\\<cdot>f\\<cdot>(throwET\\<cdot>e) =\n       bindET\\<cdot>(throwET\\<cdot>e)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 3. \\<And>m h.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>f\\<cdot>m =\n        bindET\\<cdot>m\\<cdot>(\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x));\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e.\n           fmap\\<cdot>f\\<cdot>(h\\<cdot>e) =\n           bindET\\<cdot>(h\\<cdot>e)\\<cdot>\n           (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>f\\<cdot>(catchET\\<cdot>m\\<cdot>h) =\n                         bindET\\<cdot>(catchET\\<cdot>m\\<cdot>h)\\<cdot>\n                         (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 4. \\<And>m.\n       fmap\\<cdot>f\\<cdot>(liftET\\<cdot>m) =\n       bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))", "apply (case_tac x)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>m k x.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>m) =\n        runErrorT\\<cdot>m \\<bind>\n        (\\<Lambda> n.\n            case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n            | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        \\<And>x. invar (k\\<cdot>x);\n        \\<And>x.\n           fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>(k\\<cdot>x)) =\n           runErrorT\\<cdot>(k\\<cdot>x) \\<bind>\n           (\\<Lambda> n.\n               case n of\n               Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n               | Ok\\<cdot>x \\<Rightarrow>\n                   return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        x = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            return\\<cdot>(Err\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              runErrorT\\<cdot>(k\\<cdot>x)) =\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            return\\<cdot>(Err\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              runErrorT\\<cdot>(k\\<cdot>x)) \\<bind>\n                         Abs_cfun\n                          (Rep_cfun\n                            (error_case\\<cdot>\n                             (\\<Lambda> e.\n                                 return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                             (\\<Lambda> x.\n                                 return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)))))\n 2. \\<And>m k x e.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>m) =\n        runErrorT\\<cdot>m \\<bind>\n        (\\<Lambda> n.\n            case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n            | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        \\<And>x. invar (k\\<cdot>x);\n        \\<And>x.\n           fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>(k\\<cdot>x)) =\n           runErrorT\\<cdot>(k\\<cdot>x) \\<bind>\n           (\\<Lambda> n.\n               case n of\n               Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n               | Ok\\<cdot>x \\<Rightarrow>\n                   return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        x = Err\\<cdot>e\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            return\\<cdot>(Err\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              runErrorT\\<cdot>(k\\<cdot>x)) =\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            return\\<cdot>(Err\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              runErrorT\\<cdot>(k\\<cdot>x)) \\<bind>\n                         Abs_cfun\n                          (Rep_cfun\n                            (error_case\\<cdot>\n                             (\\<Lambda> e.\n                                 return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                             (\\<Lambda> x.\n                                 return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)))))\n 3. \\<And>m k x a.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>m) =\n        runErrorT\\<cdot>m \\<bind>\n        (\\<Lambda> n.\n            case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n            | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        \\<And>x. invar (k\\<cdot>x);\n        \\<And>x.\n           fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>(k\\<cdot>x)) =\n           runErrorT\\<cdot>(k\\<cdot>x) \\<bind>\n           (\\<Lambda> n.\n               case n of\n               Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n               | Ok\\<cdot>x \\<Rightarrow>\n                   return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        x = Ok\\<cdot>a\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            return\\<cdot>(Err\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              runErrorT\\<cdot>(k\\<cdot>x)) =\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            return\\<cdot>(Err\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              runErrorT\\<cdot>(k\\<cdot>x)) \\<bind>\n                         Abs_cfun\n                          (Rep_cfun\n                            (error_case\\<cdot>\n                             (\\<Lambda> e.\n                                 return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                             (\\<Lambda> x.\n                                 return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)))))\n 4. \\<And>e.\n       fmap\\<cdot>f\\<cdot>(throwET\\<cdot>e) =\n       bindET\\<cdot>(throwET\\<cdot>e)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 5. \\<And>m h.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>f\\<cdot>m =\n        bindET\\<cdot>m\\<cdot>(\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x));\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e.\n           fmap\\<cdot>f\\<cdot>(h\\<cdot>e) =\n           bindET\\<cdot>(h\\<cdot>e)\\<cdot>\n           (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>f\\<cdot>(catchET\\<cdot>m\\<cdot>h) =\n                         bindET\\<cdot>(catchET\\<cdot>m\\<cdot>h)\\<cdot>\n                         (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 6. \\<And>m.\n       fmap\\<cdot>f\\<cdot>(liftET\\<cdot>m) =\n       bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))", "apply (simp add: bind_strict fmap_strict)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>m k x e.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>m) =\n        runErrorT\\<cdot>m \\<bind>\n        (\\<Lambda> n.\n            case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n            | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        \\<And>x. invar (k\\<cdot>x);\n        \\<And>x.\n           fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>(k\\<cdot>x)) =\n           runErrorT\\<cdot>(k\\<cdot>x) \\<bind>\n           (\\<Lambda> n.\n               case n of\n               Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n               | Ok\\<cdot>x \\<Rightarrow>\n                   return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        x = Err\\<cdot>e\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            return\\<cdot>(Err\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              runErrorT\\<cdot>(k\\<cdot>x)) =\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            return\\<cdot>(Err\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              runErrorT\\<cdot>(k\\<cdot>x)) \\<bind>\n                         Abs_cfun\n                          (Rep_cfun\n                            (error_case\\<cdot>\n                             (\\<Lambda> e.\n                                 return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                             (\\<Lambda> x.\n                                 return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)))))\n 2. \\<And>m k x a.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>m) =\n        runErrorT\\<cdot>m \\<bind>\n        (\\<Lambda> n.\n            case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n            | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        \\<And>x. invar (k\\<cdot>x);\n        \\<And>x.\n           fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>(k\\<cdot>x)) =\n           runErrorT\\<cdot>(k\\<cdot>x) \\<bind>\n           (\\<Lambda> n.\n               case n of\n               Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n               | Ok\\<cdot>x \\<Rightarrow>\n                   return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        x = Ok\\<cdot>a\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            return\\<cdot>(Err\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              runErrorT\\<cdot>(k\\<cdot>x)) =\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            return\\<cdot>(Err\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              runErrorT\\<cdot>(k\\<cdot>x)) \\<bind>\n                         Abs_cfun\n                          (Rep_cfun\n                            (error_case\\<cdot>\n                             (\\<Lambda> e.\n                                 return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                             (\\<Lambda> x.\n                                 return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)))))\n 3. \\<And>e.\n       fmap\\<cdot>f\\<cdot>(throwET\\<cdot>e) =\n       bindET\\<cdot>(throwET\\<cdot>e)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 4. \\<And>m h.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>f\\<cdot>m =\n        bindET\\<cdot>m\\<cdot>(\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x));\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e.\n           fmap\\<cdot>f\\<cdot>(h\\<cdot>e) =\n           bindET\\<cdot>(h\\<cdot>e)\\<cdot>\n           (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>f\\<cdot>(catchET\\<cdot>m\\<cdot>h) =\n                         bindET\\<cdot>(catchET\\<cdot>m\\<cdot>h)\\<cdot>\n                         (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 5. \\<And>m.\n       fmap\\<cdot>f\\<cdot>(liftET\\<cdot>m) =\n       bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))", "apply (simp add: fmap_return)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m k x a.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>m) =\n        runErrorT\\<cdot>m \\<bind>\n        (\\<Lambda> n.\n            case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n            | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        \\<And>x. invar (k\\<cdot>x);\n        \\<And>x.\n           fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>(k\\<cdot>x)) =\n           runErrorT\\<cdot>(k\\<cdot>x) \\<bind>\n           (\\<Lambda> n.\n               case n of\n               Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n               | Ok\\<cdot>x \\<Rightarrow>\n                   return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        x = Ok\\<cdot>a\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            return\\<cdot>(Err\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              runErrorT\\<cdot>(k\\<cdot>x)) =\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            return\\<cdot>(Err\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              runErrorT\\<cdot>(k\\<cdot>x)) \\<bind>\n                         Abs_cfun\n                          (Rep_cfun\n                            (error_case\\<cdot>\n                             (\\<Lambda> e.\n                                 return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                             (\\<Lambda> x.\n                                 return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)))))\n 2. \\<And>e.\n       fmap\\<cdot>f\\<cdot>(throwET\\<cdot>e) =\n       bindET\\<cdot>(throwET\\<cdot>e)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 3. \\<And>m h.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>f\\<cdot>m =\n        bindET\\<cdot>m\\<cdot>(\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x));\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e.\n           fmap\\<cdot>f\\<cdot>(h\\<cdot>e) =\n           bindET\\<cdot>(h\\<cdot>e)\\<cdot>\n           (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>f\\<cdot>(catchET\\<cdot>m\\<cdot>h) =\n                         bindET\\<cdot>(catchET\\<cdot>m\\<cdot>h)\\<cdot>\n                         (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 4. \\<And>m.\n       fmap\\<cdot>f\\<cdot>(liftET\\<cdot>m) =\n       bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e.\n       fmap\\<cdot>f\\<cdot>(throwET\\<cdot>e) =\n       bindET\\<cdot>(throwET\\<cdot>e)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 2. \\<And>m h.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>f\\<cdot>m =\n        bindET\\<cdot>m\\<cdot>(\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x));\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e.\n           fmap\\<cdot>f\\<cdot>(h\\<cdot>e) =\n           bindET\\<cdot>(h\\<cdot>e)\\<cdot>\n           (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>f\\<cdot>(catchET\\<cdot>m\\<cdot>h) =\n                         bindET\\<cdot>(catchET\\<cdot>m\\<cdot>h)\\<cdot>\n                         (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 3. \\<And>m.\n       fmap\\<cdot>f\\<cdot>(liftET\\<cdot>m) =\n       bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))", "apply (rule errorT_eqI, simp add: fmap_return)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m h.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>f\\<cdot>m =\n        bindET\\<cdot>m\\<cdot>(\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x));\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e.\n           fmap\\<cdot>f\\<cdot>(h\\<cdot>e) =\n           bindET\\<cdot>(h\\<cdot>e)\\<cdot>\n           (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>f\\<cdot>(catchET\\<cdot>m\\<cdot>h) =\n                         bindET\\<cdot>(catchET\\<cdot>m\\<cdot>h)\\<cdot>\n                         (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\n 2. \\<And>m.\n       fmap\\<cdot>f\\<cdot>(liftET\\<cdot>m) =\n       bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))", "apply (simp add: errorT_eq_iff bind_bind fmap_bind)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m h.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>m) =\n        runErrorT\\<cdot>m \\<bind>\n        (\\<Lambda> n.\n            case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n            | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e.\n           fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>(h\\<cdot>e)) =\n           runErrorT\\<cdot>(h\\<cdot>e) \\<bind>\n           (\\<Lambda> n.\n               case n of\n               Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n               | Ok\\<cdot>x \\<Rightarrow>\n                   return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)))\\<rbrakk>\n       \\<Longrightarrow> runErrorT\\<cdot>m \\<bind>\n                         (\\<Lambda> x.\n                             fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>\n                             (case x of\n                              Err\\<cdot>e \\<Rightarrow>\n                                runErrorT\\<cdot>(h\\<cdot>e)\n                              | Ok\\<cdot>x \\<Rightarrow>\n                                  return\\<cdot>(Ok\\<cdot>x))) =\n                         runErrorT\\<cdot>m \\<bind>\n                         (\\<Lambda> x.\n                             (case x of\n                              Err\\<cdot>e \\<Rightarrow>\n                                runErrorT\\<cdot>(h\\<cdot>e)\n                              | Ok\\<cdot>x \\<Rightarrow>\n                                  return\\<cdot>(Ok\\<cdot>x)) \\<bind>\n                             Abs_cfun\n                              (Rep_cfun\n                                (error_case\\<cdot>\n                                 (\\<Lambda> e.\n                                     return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                                 (\\<Lambda> x.\n                                     return\\<cdot>(Ok\\<cdot>(f\\<cdot>x))))))\n 2. \\<And>m.\n       fmap\\<cdot>f\\<cdot>(liftET\\<cdot>m) =\n       bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))", "apply (rule cfun_arg_cong, rule cfun_eqI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m h x.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>m) =\n        runErrorT\\<cdot>m \\<bind>\n        (\\<Lambda> n.\n            case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n            | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e.\n           fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>(h\\<cdot>e)) =\n           runErrorT\\<cdot>(h\\<cdot>e) \\<bind>\n           (\\<Lambda> n.\n               case n of\n               Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n               | Ok\\<cdot>x \\<Rightarrow>\n                   return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)))\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            runErrorT\\<cdot>(h\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              return\\<cdot>(Ok\\<cdot>x)) =\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            runErrorT\\<cdot>(h\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              return\\<cdot>(Ok\\<cdot>x)) \\<bind>\n                         Abs_cfun\n                          (Rep_cfun\n                            (error_case\\<cdot>\n                             (\\<Lambda> e.\n                                 return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                             (\\<Lambda> x.\n                                 return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)))))\n 2. \\<And>m.\n       fmap\\<cdot>f\\<cdot>(liftET\\<cdot>m) =\n       bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))", "apply (case_tac x)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m h x.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>m) =\n        runErrorT\\<cdot>m \\<bind>\n        (\\<Lambda> n.\n            case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n            | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e.\n           fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>(h\\<cdot>e)) =\n           runErrorT\\<cdot>(h\\<cdot>e) \\<bind>\n           (\\<Lambda> n.\n               case n of\n               Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n               | Ok\\<cdot>x \\<Rightarrow>\n                   return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        x = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            runErrorT\\<cdot>(h\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              return\\<cdot>(Ok\\<cdot>x)) =\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            runErrorT\\<cdot>(h\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              return\\<cdot>(Ok\\<cdot>x)) \\<bind>\n                         Abs_cfun\n                          (Rep_cfun\n                            (error_case\\<cdot>\n                             (\\<Lambda> e.\n                                 return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                             (\\<Lambda> x.\n                                 return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)))))\n 2. \\<And>m h x e.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>m) =\n        runErrorT\\<cdot>m \\<bind>\n        (\\<Lambda> n.\n            case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n            | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e.\n           fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>(h\\<cdot>e)) =\n           runErrorT\\<cdot>(h\\<cdot>e) \\<bind>\n           (\\<Lambda> n.\n               case n of\n               Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n               | Ok\\<cdot>x \\<Rightarrow>\n                   return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        x = Err\\<cdot>e\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            runErrorT\\<cdot>(h\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              return\\<cdot>(Ok\\<cdot>x)) =\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            runErrorT\\<cdot>(h\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              return\\<cdot>(Ok\\<cdot>x)) \\<bind>\n                         Abs_cfun\n                          (Rep_cfun\n                            (error_case\\<cdot>\n                             (\\<Lambda> e.\n                                 return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                             (\\<Lambda> x.\n                                 return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)))))\n 3. \\<And>m h x a.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>m) =\n        runErrorT\\<cdot>m \\<bind>\n        (\\<Lambda> n.\n            case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n            | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e.\n           fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>(h\\<cdot>e)) =\n           runErrorT\\<cdot>(h\\<cdot>e) \\<bind>\n           (\\<Lambda> n.\n               case n of\n               Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n               | Ok\\<cdot>x \\<Rightarrow>\n                   return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        x = Ok\\<cdot>a\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            runErrorT\\<cdot>(h\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              return\\<cdot>(Ok\\<cdot>x)) =\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            runErrorT\\<cdot>(h\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              return\\<cdot>(Ok\\<cdot>x)) \\<bind>\n                         Abs_cfun\n                          (Rep_cfun\n                            (error_case\\<cdot>\n                             (\\<Lambda> e.\n                                 return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                             (\\<Lambda> x.\n                                 return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)))))\n 4. \\<And>m.\n       fmap\\<cdot>f\\<cdot>(liftET\\<cdot>m) =\n       bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))", "apply (simp add: bind_strict fmap_strict)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m h x e.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>m) =\n        runErrorT\\<cdot>m \\<bind>\n        (\\<Lambda> n.\n            case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n            | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e.\n           fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>(h\\<cdot>e)) =\n           runErrorT\\<cdot>(h\\<cdot>e) \\<bind>\n           (\\<Lambda> n.\n               case n of\n               Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n               | Ok\\<cdot>x \\<Rightarrow>\n                   return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        x = Err\\<cdot>e\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            runErrorT\\<cdot>(h\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              return\\<cdot>(Ok\\<cdot>x)) =\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            runErrorT\\<cdot>(h\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              return\\<cdot>(Ok\\<cdot>x)) \\<bind>\n                         Abs_cfun\n                          (Rep_cfun\n                            (error_case\\<cdot>\n                             (\\<Lambda> e.\n                                 return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                             (\\<Lambda> x.\n                                 return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)))))\n 2. \\<And>m h x a.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>m) =\n        runErrorT\\<cdot>m \\<bind>\n        (\\<Lambda> n.\n            case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n            | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e.\n           fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>(h\\<cdot>e)) =\n           runErrorT\\<cdot>(h\\<cdot>e) \\<bind>\n           (\\<Lambda> n.\n               case n of\n               Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n               | Ok\\<cdot>x \\<Rightarrow>\n                   return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        x = Ok\\<cdot>a\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            runErrorT\\<cdot>(h\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              return\\<cdot>(Ok\\<cdot>x)) =\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            runErrorT\\<cdot>(h\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              return\\<cdot>(Ok\\<cdot>x)) \\<bind>\n                         Abs_cfun\n                          (Rep_cfun\n                            (error_case\\<cdot>\n                             (\\<Lambda> e.\n                                 return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                             (\\<Lambda> x.\n                                 return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)))))\n 3. \\<And>m.\n       fmap\\<cdot>f\\<cdot>(liftET\\<cdot>m) =\n       bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m h x a.\n       \\<lbrakk>invar m;\n        fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>m) =\n        runErrorT\\<cdot>m \\<bind>\n        (\\<Lambda> n.\n            case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n            | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        \\<And>e. invar (h\\<cdot>e);\n        \\<And>e.\n           fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>(runErrorT\\<cdot>(h\\<cdot>e)) =\n           runErrorT\\<cdot>(h\\<cdot>e) \\<bind>\n           (\\<Lambda> n.\n               case n of\n               Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n               | Ok\\<cdot>x \\<Rightarrow>\n                   return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)));\n        x = Ok\\<cdot>a\\<rbrakk>\n       \\<Longrightarrow> fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            runErrorT\\<cdot>(h\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              return\\<cdot>(Ok\\<cdot>x)) =\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            runErrorT\\<cdot>(h\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              return\\<cdot>(Ok\\<cdot>x)) \\<bind>\n                         Abs_cfun\n                          (Rep_cfun\n                            (error_case\\<cdot>\n                             (\\<Lambda> e.\n                                 return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                             (\\<Lambda> x.\n                                 return\\<cdot>(Ok\\<cdot>(f\\<cdot>x)))))\n 2. \\<And>m.\n       fmap\\<cdot>f\\<cdot>(liftET\\<cdot>m) =\n       bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))", "apply (simp add: fmap_return)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       fmap\\<cdot>f\\<cdot>(liftET\\<cdot>m) =\n       bindET\\<cdot>(liftET\\<cdot>m)\\<cdot>\n       (\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))", "apply (rule errorT_eqI, simp add: monad_fmap bind_bind return_error_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Invariant expressed as a deflation\\<close>"], ["", "text \\<open>We can also define an invariant in a more semantic way, as the\nset of fixed-points of a deflation.\\<close>"], ["", "definition invar' :: \"'a\\<cdot>('m::monad, 'e) errorT \\<Rightarrow> bool\"\n  where \"invar' m \\<longleftrightarrow> fmapET\\<cdot>ID\\<cdot>m = m\""], ["", "text \\<open>All standard operations preserve the invariant.\\<close>"], ["", "lemma invar'_unitET: \"invar' (unitET\\<cdot>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar' (unitET\\<cdot>x)", "unfolding invar'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmapET\\<cdot>ID\\<cdot>(unitET\\<cdot>x) = unitET\\<cdot>x", "by (simp add: fmapET_def)"], ["", "lemma invar'_fmapET: \"invar' m \\<Longrightarrow> invar' (fmapET\\<cdot>f\\<cdot>m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar' m \\<Longrightarrow> invar' (fmapET\\<cdot>f\\<cdot>m)", "unfolding invar'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmapET\\<cdot>ID\\<cdot>m = m \\<Longrightarrow>\n    fmapET\\<cdot>ID\\<cdot>(fmapET\\<cdot>f\\<cdot>m) = fmapET\\<cdot>f\\<cdot>m", "by (erule subst, simp add: fmapET_def bindET_bindET eta_cfun)"], ["", "lemma invar'_bindET: \"\\<lbrakk>invar' m; \\<And>x. invar' (k\\<cdot>x)\\<rbrakk> \\<Longrightarrow> invar' (bindET\\<cdot>m\\<cdot>k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar' m; \\<And>x. invar' (k\\<cdot>x)\\<rbrakk>\n    \\<Longrightarrow> invar' (bindET\\<cdot>m\\<cdot>k)", "unfolding invar'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fmapET\\<cdot>ID\\<cdot>m = m;\n     \\<And>x. fmapET\\<cdot>ID\\<cdot>(k\\<cdot>x) = k\\<cdot>x\\<rbrakk>\n    \\<Longrightarrow> fmapET\\<cdot>ID\\<cdot>(bindET\\<cdot>m\\<cdot>k) =\n                      bindET\\<cdot>m\\<cdot>k", "by (simp add: fmapET_def bindET_bindET eta_cfun)"], ["", "lemma invar'_throwET: \"invar' (throwET\\<cdot>e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar' (throwET\\<cdot>e)", "unfolding invar'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmapET\\<cdot>ID\\<cdot>(throwET\\<cdot>e) = throwET\\<cdot>e", "by (simp add: fmapET_def bindET_throwET eta_cfun)"], ["", "lemma invar'_catchET: \"\\<lbrakk>invar' m; \\<And>e. invar' (h\\<cdot>e)\\<rbrakk> \\<Longrightarrow> invar' (catchET\\<cdot>m\\<cdot>h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar' m; \\<And>e. invar' (h\\<cdot>e)\\<rbrakk>\n    \\<Longrightarrow> invar' (catchET\\<cdot>m\\<cdot>h)", "unfolding invar'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fmapET\\<cdot>ID\\<cdot>m = m;\n     \\<And>e. fmapET\\<cdot>ID\\<cdot>(h\\<cdot>e) = h\\<cdot>e\\<rbrakk>\n    \\<Longrightarrow> fmapET\\<cdot>ID\\<cdot>(catchET\\<cdot>m\\<cdot>h) =\n                      catchET\\<cdot>m\\<cdot>h", "apply (simp add: fmapET_def eta_cfun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bindET\\<cdot>m\\<cdot>unitET = m;\n     \\<And>e. bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET = h\\<cdot>e\\<rbrakk>\n    \\<Longrightarrow> bindET\\<cdot>(catchET\\<cdot>m\\<cdot>h)\\<cdot>unitET =\n                      catchET\\<cdot>m\\<cdot>h", "apply (rule errorT_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bindET\\<cdot>m\\<cdot>unitET = m;\n     \\<And>e. bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET = h\\<cdot>e\\<rbrakk>\n    \\<Longrightarrow> runErrorT\\<cdot>\n                      (bindET\\<cdot>(catchET\\<cdot>m\\<cdot>h)\\<cdot>\n                       unitET) =\n                      runErrorT\\<cdot>(catchET\\<cdot>m\\<cdot>h)", "apply (simp add: bind_bind eta_cfun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bindET\\<cdot>m\\<cdot>unitET = m;\n     \\<And>e. bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET = h\\<cdot>e\\<rbrakk>\n    \\<Longrightarrow> runErrorT\\<cdot>m \\<bind>\n                      (\\<Lambda> x.\n                          (case x of\n                           Err\\<cdot>e \\<Rightarrow>\n                             runErrorT\\<cdot>(h\\<cdot>e)\n                           | Ok\\<cdot>x \\<Rightarrow>\n                               return\\<cdot>(Ok\\<cdot>x)) \\<bind>\n                          error_case\\<cdot>\n                          (\\<Lambda> e. return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                          (\\<Lambda> x. return\\<cdot>(Ok\\<cdot>x))) =\n                      runErrorT\\<cdot>m \\<bind>\n                      error_case\\<cdot>\n                      (\\<Lambda> e. runErrorT\\<cdot>(h\\<cdot>e))\\<cdot>\n                      (\\<Lambda> x. return\\<cdot>(Ok\\<cdot>x))", "apply (rule cfun_arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bindET\\<cdot>m\\<cdot>unitET = m;\n     \\<And>e. bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET = h\\<cdot>e\\<rbrakk>\n    \\<Longrightarrow> (\\<Lambda> x.\n                          (case x of\n                           Err\\<cdot>e \\<Rightarrow>\n                             runErrorT\\<cdot>(h\\<cdot>e)\n                           | Ok\\<cdot>x \\<Rightarrow>\n                               return\\<cdot>(Ok\\<cdot>x)) \\<bind>\n                          error_case\\<cdot>\n                          (\\<Lambda> e. return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                          (\\<Lambda> x. return\\<cdot>(Ok\\<cdot>x))) =\n                      error_case\\<cdot>\n                      (\\<Lambda> e. runErrorT\\<cdot>(h\\<cdot>e))\\<cdot>\n                      (\\<Lambda> x. return\\<cdot>(Ok\\<cdot>x))", "apply (rule cfun_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>bindET\\<cdot>m\\<cdot>unitET = m;\n        \\<And>e. bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET = h\\<cdot>e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             (case x of\n                              Err\\<cdot>e \\<Rightarrow>\n                                runErrorT\\<cdot>(h\\<cdot>e)\n                              | Ok\\<cdot>x \\<Rightarrow>\n                                  return\\<cdot>(Ok\\<cdot>x)) \\<bind>\n                             error_case\\<cdot>\n                             (\\<Lambda> e.\n                                 return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                             (\\<Lambda> x.\n                                 return\\<cdot>(Ok\\<cdot>x)))\\<cdot>\n                         x =\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            runErrorT\\<cdot>(h\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              return\\<cdot>(Ok\\<cdot>x))", "apply (case_tac x)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>bindET\\<cdot>m\\<cdot>unitET = m;\n        \\<And>e. bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET = h\\<cdot>e;\n        x = \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             (case x of\n                              Err\\<cdot>e \\<Rightarrow>\n                                runErrorT\\<cdot>(h\\<cdot>e)\n                              | Ok\\<cdot>x \\<Rightarrow>\n                                  return\\<cdot>(Ok\\<cdot>x)) \\<bind>\n                             error_case\\<cdot>\n                             (\\<Lambda> e.\n                                 return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                             (\\<Lambda> x.\n                                 return\\<cdot>(Ok\\<cdot>x)))\\<cdot>\n                         x =\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            runErrorT\\<cdot>(h\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              return\\<cdot>(Ok\\<cdot>x))\n 2. \\<And>x e.\n       \\<lbrakk>bindET\\<cdot>m\\<cdot>unitET = m;\n        \\<And>e. bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET = h\\<cdot>e;\n        x = Err\\<cdot>e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             (case x of\n                              Err\\<cdot>e \\<Rightarrow>\n                                runErrorT\\<cdot>(h\\<cdot>e)\n                              | Ok\\<cdot>x \\<Rightarrow>\n                                  return\\<cdot>(Ok\\<cdot>x)) \\<bind>\n                             error_case\\<cdot>\n                             (\\<Lambda> e.\n                                 return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                             (\\<Lambda> x.\n                                 return\\<cdot>(Ok\\<cdot>x)))\\<cdot>\n                         x =\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            runErrorT\\<cdot>(h\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              return\\<cdot>(Ok\\<cdot>x))\n 3. \\<And>x a.\n       \\<lbrakk>bindET\\<cdot>m\\<cdot>unitET = m;\n        \\<And>e. bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET = h\\<cdot>e;\n        x = Ok\\<cdot>a\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             (case x of\n                              Err\\<cdot>e \\<Rightarrow>\n                                runErrorT\\<cdot>(h\\<cdot>e)\n                              | Ok\\<cdot>x \\<Rightarrow>\n                                  return\\<cdot>(Ok\\<cdot>x)) \\<bind>\n                             error_case\\<cdot>\n                             (\\<Lambda> e.\n                                 return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                             (\\<Lambda> x.\n                                 return\\<cdot>(Ok\\<cdot>x)))\\<cdot>\n                         x =\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            runErrorT\\<cdot>(h\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              return\\<cdot>(Ok\\<cdot>x))", "apply (simp add: bind_strict)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x e.\n       \\<lbrakk>bindET\\<cdot>m\\<cdot>unitET = m;\n        \\<And>e. bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET = h\\<cdot>e;\n        x = Err\\<cdot>e\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             (case x of\n                              Err\\<cdot>e \\<Rightarrow>\n                                runErrorT\\<cdot>(h\\<cdot>e)\n                              | Ok\\<cdot>x \\<Rightarrow>\n                                  return\\<cdot>(Ok\\<cdot>x)) \\<bind>\n                             error_case\\<cdot>\n                             (\\<Lambda> e.\n                                 return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                             (\\<Lambda> x.\n                                 return\\<cdot>(Ok\\<cdot>x)))\\<cdot>\n                         x =\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            runErrorT\\<cdot>(h\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              return\\<cdot>(Ok\\<cdot>x))\n 2. \\<And>x a.\n       \\<lbrakk>bindET\\<cdot>m\\<cdot>unitET = m;\n        \\<And>e. bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET = h\\<cdot>e;\n        x = Ok\\<cdot>a\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             (case x of\n                              Err\\<cdot>e \\<Rightarrow>\n                                runErrorT\\<cdot>(h\\<cdot>e)\n                              | Ok\\<cdot>x \\<Rightarrow>\n                                  return\\<cdot>(Ok\\<cdot>x)) \\<bind>\n                             error_case\\<cdot>\n                             (\\<Lambda> e.\n                                 return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                             (\\<Lambda> x.\n                                 return\\<cdot>(Ok\\<cdot>x)))\\<cdot>\n                         x =\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            runErrorT\\<cdot>(h\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              return\\<cdot>(Ok\\<cdot>x))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x e.\n       \\<lbrakk>bindET\\<cdot>m\\<cdot>unitET = m;\n        \\<And>e. bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET = h\\<cdot>e;\n        x = Err\\<cdot>e\\<rbrakk>\n       \\<Longrightarrow> runErrorT\\<cdot>(h\\<cdot>e) \\<bind>\n                         error_case\\<cdot>\n                         (\\<Lambda> e. return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                         (\\<Lambda> x. return\\<cdot>(Ok\\<cdot>x)) =\n                         runErrorT\\<cdot>(h\\<cdot>e)\n 2. \\<And>x a.\n       \\<lbrakk>bindET\\<cdot>m\\<cdot>unitET = m;\n        \\<And>e. bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET = h\\<cdot>e;\n        x = Ok\\<cdot>a\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             (case x of\n                              Err\\<cdot>e \\<Rightarrow>\n                                runErrorT\\<cdot>(h\\<cdot>e)\n                              | Ok\\<cdot>x \\<Rightarrow>\n                                  return\\<cdot>(Ok\\<cdot>x)) \\<bind>\n                             error_case\\<cdot>\n                             (\\<Lambda> e.\n                                 return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                             (\\<Lambda> x.\n                                 return\\<cdot>(Ok\\<cdot>x)))\\<cdot>\n                         x =\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            runErrorT\\<cdot>(h\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              return\\<cdot>(Ok\\<cdot>x))", "apply (drule_tac x=e in meta_spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x e.\n       \\<lbrakk>bindET\\<cdot>m\\<cdot>unitET = m; x = Err\\<cdot>e;\n        bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET = h\\<cdot>e\\<rbrakk>\n       \\<Longrightarrow> runErrorT\\<cdot>(h\\<cdot>e) \\<bind>\n                         error_case\\<cdot>\n                         (\\<Lambda> e. return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                         (\\<Lambda> x. return\\<cdot>(Ok\\<cdot>x)) =\n                         runErrorT\\<cdot>(h\\<cdot>e)\n 2. \\<And>x a.\n       \\<lbrakk>bindET\\<cdot>m\\<cdot>unitET = m;\n        \\<And>e. bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET = h\\<cdot>e;\n        x = Ok\\<cdot>a\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             (case x of\n                              Err\\<cdot>e \\<Rightarrow>\n                                runErrorT\\<cdot>(h\\<cdot>e)\n                              | Ok\\<cdot>x \\<Rightarrow>\n                                  return\\<cdot>(Ok\\<cdot>x)) \\<bind>\n                             error_case\\<cdot>\n                             (\\<Lambda> e.\n                                 return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                             (\\<Lambda> x.\n                                 return\\<cdot>(Ok\\<cdot>x)))\\<cdot>\n                         x =\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            runErrorT\\<cdot>(h\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              return\\<cdot>(Ok\\<cdot>x))", "apply (erule_tac t=\"h\\<cdot>e\" in subst)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x e.\n       \\<lbrakk>bindET\\<cdot>m\\<cdot>unitET = m; x = Err\\<cdot>e\\<rbrakk>\n       \\<Longrightarrow> runErrorT\\<cdot>\n                         (bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET) \\<bind>\n                         error_case\\<cdot>\n                         (\\<Lambda> e. return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                         (\\<Lambda> x. return\\<cdot>(Ok\\<cdot>x)) =\n                         runErrorT\\<cdot>\n                         (bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET)\n 2. \\<And>x a.\n       \\<lbrakk>bindET\\<cdot>m\\<cdot>unitET = m;\n        \\<And>e. bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET = h\\<cdot>e;\n        x = Ok\\<cdot>a\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             (case x of\n                              Err\\<cdot>e \\<Rightarrow>\n                                runErrorT\\<cdot>(h\\<cdot>e)\n                              | Ok\\<cdot>x \\<Rightarrow>\n                                  return\\<cdot>(Ok\\<cdot>x)) \\<bind>\n                             error_case\\<cdot>\n                             (\\<Lambda> e.\n                                 return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                             (\\<Lambda> x.\n                                 return\\<cdot>(Ok\\<cdot>x)))\\<cdot>\n                         x =\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            runErrorT\\<cdot>(h\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              return\\<cdot>(Ok\\<cdot>x))", "back"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x e.\n       \\<lbrakk>bindET\\<cdot>m\\<cdot>unitET = m; x = Err\\<cdot>e\\<rbrakk>\n       \\<Longrightarrow> runErrorT\\<cdot>(h\\<cdot>e) \\<bind>\n                         error_case\\<cdot>\n                         (\\<Lambda> e. return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                         (\\<Lambda> x. return\\<cdot>(Ok\\<cdot>x)) =\n                         runErrorT\\<cdot>\n                         (bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET)\n 2. \\<And>x a.\n       \\<lbrakk>bindET\\<cdot>m\\<cdot>unitET = m;\n        \\<And>e. bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET = h\\<cdot>e;\n        x = Ok\\<cdot>a\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             (case x of\n                              Err\\<cdot>e \\<Rightarrow>\n                                runErrorT\\<cdot>(h\\<cdot>e)\n                              | Ok\\<cdot>x \\<Rightarrow>\n                                  return\\<cdot>(Ok\\<cdot>x)) \\<bind>\n                             error_case\\<cdot>\n                             (\\<Lambda> e.\n                                 return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                             (\\<Lambda> x.\n                                 return\\<cdot>(Ok\\<cdot>x)))\\<cdot>\n                         x =\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            runErrorT\\<cdot>(h\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              return\\<cdot>(Ok\\<cdot>x))", "apply (simp add: eta_cfun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a.\n       \\<lbrakk>bindET\\<cdot>m\\<cdot>unitET = m;\n        \\<And>e. bindET\\<cdot>(h\\<cdot>e)\\<cdot>unitET = h\\<cdot>e;\n        x = Ok\\<cdot>a\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> x.\n                             (case x of\n                              Err\\<cdot>e \\<Rightarrow>\n                                runErrorT\\<cdot>(h\\<cdot>e)\n                              | Ok\\<cdot>x \\<Rightarrow>\n                                  return\\<cdot>(Ok\\<cdot>x)) \\<bind>\n                             error_case\\<cdot>\n                             (\\<Lambda> e.\n                                 return\\<cdot>(Err\\<cdot>e))\\<cdot>\n                             (\\<Lambda> x.\n                                 return\\<cdot>(Ok\\<cdot>x)))\\<cdot>\n                         x =\n                         (case x of\n                          Err\\<cdot>e \\<Rightarrow>\n                            runErrorT\\<cdot>(h\\<cdot>e)\n                          | Ok\\<cdot>x \\<Rightarrow>\n                              return\\<cdot>(Ok\\<cdot>x))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma invar'_liftET: \"invar' (liftET\\<cdot>m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar' (liftET\\<cdot>m)", "unfolding invar'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmapET\\<cdot>ID\\<cdot>(liftET\\<cdot>m) = liftET\\<cdot>m", "apply (simp add: fmapET_def errorT_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap\\<cdot>Ok\\<cdot>m \\<bind>\n    (\\<Lambda> n.\n        case n of Err\\<cdot>e \\<Rightarrow> return\\<cdot>(Err\\<cdot>e)\n        | Ok\\<cdot>x \\<Rightarrow> return\\<cdot>(Ok\\<cdot>x)) =\n    fmap\\<cdot>Ok\\<cdot>m", "apply (simp add: monad_fmap bind_bind)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma invar'_bottom: \"invar' \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar' \\<bottom>", "unfolding invar'_def fmapET_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> f m.\n        bindET\\<cdot>m\\<cdot>(\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x)))\\<cdot>\n    ID\\<cdot>\n    \\<bottom> =\n    \\<bottom>", "by (simp add: errorT_eq_iff bind_strict)"], ["", "lemma adm_invar': \"adm invar'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adm invar'", "unfolding invar'_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. adm (\\<lambda>m. fmapET\\<cdot>ID\\<cdot>m = m)", "by simp"], ["", "text \\<open>All monad laws are preserved by values satisfying the invariant.\\<close>"], ["", "lemma bindET_fmapET_unitET:\n  shows \"bindET\\<cdot>(fmapET\\<cdot>f\\<cdot>m)\\<cdot>unitET = fmapET\\<cdot>f\\<cdot>m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bindET\\<cdot>(fmapET\\<cdot>f\\<cdot>m)\\<cdot>unitET =\n    fmapET\\<cdot>f\\<cdot>m", "by (simp add: fmapET_def bindET_bindET)"], ["", "lemma invar'_right_unit: \"invar' m \\<Longrightarrow> bindET\\<cdot>m\\<cdot>unitET = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar' m \\<Longrightarrow> bindET\\<cdot>m\\<cdot>unitET = m", "unfolding invar'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmapET\\<cdot>ID\\<cdot>m = m \\<Longrightarrow>\n    bindET\\<cdot>m\\<cdot>unitET = m", "by (erule subst, rule bindET_fmapET_unitET)"], ["", "lemma invar'_monad_fmap:\n  \"invar' m \\<Longrightarrow> fmapET\\<cdot>f\\<cdot>m = bindET\\<cdot>m\\<cdot>(\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar' m \\<Longrightarrow>\n    fmapET\\<cdot>f\\<cdot>m =\n    bindET\\<cdot>m\\<cdot>(\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))", "unfolding invar'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmapET\\<cdot>ID\\<cdot>m = m \\<Longrightarrow>\n    fmapET\\<cdot>f\\<cdot>m =\n    bindET\\<cdot>m\\<cdot>(\\<Lambda> x. unitET\\<cdot>(f\\<cdot>x))", "by (erule subst, simp add: errorT_eq_iff)"], ["", "lemma invar'_bind_assoc:\n  \"\\<lbrakk>invar' m; \\<And>x. invar' (f\\<cdot>x); \\<And>y. invar' (g\\<cdot>y)\\<rbrakk>\n    \\<Longrightarrow> bindET\\<cdot>(bindET\\<cdot>m\\<cdot>f)\\<cdot>g = bindET\\<cdot>m\\<cdot>(\\<Lambda> x. bindET\\<cdot>(f\\<cdot>x)\\<cdot>g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar' m; \\<And>x. invar' (f\\<cdot>x);\n     \\<And>y. invar' (g\\<cdot>y)\\<rbrakk>\n    \\<Longrightarrow> bindET\\<cdot>(bindET\\<cdot>m\\<cdot>f)\\<cdot>g =\n                      bindET\\<cdot>m\\<cdot>\n                      (\\<Lambda> x. bindET\\<cdot>(f\\<cdot>x)\\<cdot>g)", "by (rule bindET_bindET)"], ["", "end"]]}