{"file_name": "/home/qj213/afp-2021-10-22/thys/Tycon/Coerce.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Tycon", "problem_names": ["lemma beta_coerce: \"coerce\\<cdot>x = prj\\<cdot>(emb\\<cdot>x)\"", "lemma prj_emb: \"prj\\<cdot>(emb\\<cdot>x) = coerce\\<cdot>x\"", "lemma coerce_strict [simp]: \"coerce\\<cdot>\\<bottom> = \\<bottom>\"", "lemma coerce_eq_ID [simp]: \"COERCE('a, 'a) = ID\"", "lemma coerce_eq_emb [simp]: \"COERCE('a, udom) = EMB('a)\"", "lemma coerce_eq_prj [simp]: \"COERCE(udom, 'a) = PRJ('a)\"", "lemma emb_coerce:\n  \"DEFL('a) \\<sqsubseteq> DEFL('b)\n   \\<Longrightarrow> EMB('b)\\<cdot>(COERCE('a,'b)\\<cdot>x) = EMB('a)\\<cdot>x\"", "lemma coerce_prj:\n  \"DEFL('a) \\<sqsubseteq> DEFL('b)\n   \\<Longrightarrow> COERCE('b,'a)\\<cdot>(PRJ('b)\\<cdot>x) = PRJ('a)\\<cdot>x\"", "lemma coerce_idem [simp]:\n  \"DEFL('a) \\<sqsubseteq> DEFL('b)\n   \\<Longrightarrow> COERCE('b,'c)\\<cdot>(COERCE('a,'b)\\<cdot>x) = COERCE('a,'c)\\<cdot>x\"", "lemma prj_cast_DEFL [simp]: \"PRJ('a)\\<cdot>(cast\\<cdot>DEFL('a)\\<cdot>x) = PRJ('a)\\<cdot>x\"", "lemma cast_DEFL_emb [simp]: \"cast\\<cdot>DEFL('a)\\<cdot>(EMB('a)\\<cdot>x) = EMB('a)\\<cdot>x\"", "lemma below_DEFL_udom [simp]: \"A \\<sqsubseteq> DEFL(udom)\"", "lemma coerce_u: \"coerce = u_map\\<cdot>coerce\"", "lemma coerce_sfun: \"coerce = sfun_map\\<cdot>coerce\\<cdot>coerce\"", "lemma coerce_cfun': \"coerce = cfun_map\\<cdot>coerce\\<cdot>coerce\"", "lemma coerce_ssum: \"coerce = ssum_map\\<cdot>coerce\\<cdot>coerce\"", "lemma coerce_sprod: \"coerce = sprod_map\\<cdot>coerce\\<cdot>coerce\"", "lemma coerce_prod: \"coerce = prod_map\\<cdot>coerce\\<cdot>coerce\"", "lemma coerce_up [simp]: \"coerce\\<cdot>(up\\<cdot>x) = up\\<cdot>(coerce\\<cdot>x)\"", "lemma coerce_sinl [simp]: \"coerce\\<cdot>(sinl\\<cdot>x) = sinl\\<cdot>(coerce\\<cdot>x)\"", "lemma coerce_sinr [simp]: \"coerce\\<cdot>(sinr\\<cdot>x) = sinr\\<cdot>(coerce\\<cdot>x)\"", "lemma coerce_spair [simp]: \"coerce\\<cdot>(:x, y:) = (:coerce\\<cdot>x, coerce\\<cdot>y:)\"", "lemma coerce_Pair [simp]: \"coerce\\<cdot>(x, y) = (coerce\\<cdot>x, coerce\\<cdot>y)\"", "lemma beta_coerce_cfun [simp]: \"coerce\\<cdot>f\\<cdot>x = coerce\\<cdot>(f\\<cdot>(coerce\\<cdot>x))\"", "lemma coerce_cfun: \"coerce\\<cdot>f = coerce oo f oo coerce\"", "lemma coerce_cfun_app [coerce_simp]:\n  \"coerce\\<cdot>f = (\\<Lambda> x. coerce\\<cdot>(f\\<cdot>(coerce\\<cdot>x)))\""], "translations": [["", "lemma beta_coerce: \"coerce\\<cdot>x = prj\\<cdot>(emb\\<cdot>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('b, 'a)\\<cdot>x = PRJ('a)\\<cdot>(EMB('b)\\<cdot>x)", "by (simp add: coerce_def)"], ["", "lemma prj_emb: \"prj\\<cdot>(emb\\<cdot>x) = coerce\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PRJ('a)\\<cdot>(EMB('b)\\<cdot>x) = COERCE('b, 'a)\\<cdot>x", "by (simp add: coerce_def)"], ["", "lemma coerce_strict [simp]: \"coerce\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('b, 'a)\\<cdot>\\<bottom> = \\<bottom>", "by (simp add: coerce_def)"], ["", "text \\<open>Certain type instances of \\<open>coerce\\<close> may reduce to the\nidentity function, \\<open>emb\\<close>, or \\<open>prj\\<close>. \\medskip\\<close>"], ["", "lemma coerce_eq_ID [simp]: \"COERCE('a, 'a) = ID\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('a, 'a) = ID", "by (rule cfun_eqI, simp add: beta_coerce)"], ["", "lemma coerce_eq_emb [simp]: \"COERCE('a, udom) = EMB('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('a, udom) = EMB('a)", "by (rule cfun_eqI, simp add: beta_coerce)"], ["", "lemma coerce_eq_prj [simp]: \"COERCE(udom, 'a) = PRJ('a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE(udom, 'a) = PRJ('a)", "by (rule cfun_eqI, simp add: beta_coerce)"], ["", "text \"Cancellation rules\""], ["", "lemma emb_coerce:\n  \"DEFL('a) \\<sqsubseteq> DEFL('b)\n   \\<Longrightarrow> EMB('b)\\<cdot>(COERCE('a,'b)\\<cdot>x) = EMB('a)\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DEFL('a) \\<sqsubseteq> DEFL('b) \\<Longrightarrow>\n    EMB('b)\\<cdot>(COERCE('a, 'b)\\<cdot>x) = EMB('a)\\<cdot>x", "by (simp add: beta_coerce emb_prj_emb)"], ["", "lemma coerce_prj:\n  \"DEFL('a) \\<sqsubseteq> DEFL('b)\n   \\<Longrightarrow> COERCE('b,'a)\\<cdot>(PRJ('b)\\<cdot>x) = PRJ('a)\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DEFL('a) \\<sqsubseteq> DEFL('b) \\<Longrightarrow>\n    COERCE('b, 'a)\\<cdot>(PRJ('b)\\<cdot>x) = PRJ('a)\\<cdot>x", "by (simp add: beta_coerce prj_emb_prj)"], ["", "lemma coerce_idem [simp]:\n  \"DEFL('a) \\<sqsubseteq> DEFL('b)\n   \\<Longrightarrow> COERCE('b,'c)\\<cdot>(COERCE('a,'b)\\<cdot>x) = COERCE('a,'c)\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DEFL('a) \\<sqsubseteq> DEFL('b) \\<Longrightarrow>\n    COERCE('b, 'c)\\<cdot>(COERCE('a, 'b)\\<cdot>x) = COERCE('a, 'c)\\<cdot>x", "by (simp add: beta_coerce emb_prj_emb)"], ["", "subsection \\<open>More lemmas about emb and prj\\<close>"], ["", "lemma prj_cast_DEFL [simp]: \"PRJ('a)\\<cdot>(cast\\<cdot>DEFL('a)\\<cdot>x) = PRJ('a)\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PRJ('a)\\<cdot>(cast\\<cdot>DEFL('a)\\<cdot>x) = PRJ('a)\\<cdot>x", "by (simp add: cast_DEFL)"], ["", "lemma cast_DEFL_emb [simp]: \"cast\\<cdot>DEFL('a)\\<cdot>(EMB('a)\\<cdot>x) = EMB('a)\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cast\\<cdot>DEFL('a)\\<cdot>(EMB('a)\\<cdot>x) = EMB('a)\\<cdot>x", "by (simp add: cast_DEFL)"], ["", "text \\<open>@{term \"DEFL(udom)\"}\\<close>"], ["", "lemma below_DEFL_udom [simp]: \"A \\<sqsubseteq> DEFL(udom)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<sqsubseteq> DEFL(udom)", "apply (rule cast_below_imp_below)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cast\\<cdot>A \\<sqsubseteq> cast\\<cdot>DEFL(udom)", "apply (rule cast.belowI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       cast\\<cdot>A\\<cdot>x = x \\<Longrightarrow>\n       cast\\<cdot>DEFL(udom)\\<cdot>x = x", "apply (simp add: cast_DEFL)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Coercing various datatypes\\<close>"], ["", "text \\<open>Coercing from the strict product type @{typ \"'a \\<otimes> 'b\"} to\nanother strict product type @{typ \"'c \\<otimes> 'd\"} is equivalent to mapping\nthe \\<open>coerce\\<close> function separately over each component using\n\\<open>sprod_map :: ('a \\<rightarrow> 'c) \\<rightarrow> ('b \\<rightarrow> 'd) \\<rightarrow> 'a \\<otimes> 'b \\<rightarrow> 'c \\<otimes> 'd\\<close>. Each\nof the several type constructors defined in HOLCF satisfies a similar\nproperty, with respect to its own map combinator. \\medskip\\<close>"], ["", "lemma coerce_u: \"coerce = u_map\\<cdot>coerce\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('a\\<^sub>\\<bottom>, 'b\\<^sub>\\<bottom>) =\n    u_map\\<cdot>COERCE('a, 'b)", "apply (rule cfun_eqI, simp add: coerce_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       PRJ('b\\<^sub>\\<bottom>)\\<cdot>(EMB('a\\<^sub>\\<bottom>)\\<cdot>x) =\n       u_map\\<cdot>(PRJ('b) oo EMB('a))\\<cdot>x", "apply (simp add: emb_u_def prj_u_def liftemb_eq liftprj_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       u_map\\<cdot>PRJ('b)\\<cdot>\n       (u_prj\\<cdot>(u_emb\\<cdot>(u_map\\<cdot>EMB('a)\\<cdot>x))) =\n       u_map\\<cdot>(PRJ('b) oo EMB('a))\\<cdot>x", "apply (subst ep_pair.e_inverse [OF ep_pair_u])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       u_map\\<cdot>PRJ('b)\\<cdot>(u_map\\<cdot>EMB('a)\\<cdot>x) =\n       u_map\\<cdot>(PRJ('b) oo EMB('a))\\<cdot>x", "apply (simp add: u_map_map cfcomp1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma coerce_sfun: \"coerce = sfun_map\\<cdot>coerce\\<cdot>coerce\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('a \\<rightarrow>! 'b, 'c \\<rightarrow>! 'd) =\n    sfun_map\\<cdot>COERCE('c, 'a)\\<cdot>COERCE('b, 'd)", "apply (rule cfun_eqI, simp add: coerce_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       PRJ('c \\<rightarrow>! 'd)\\<cdot>(EMB('a \\<rightarrow>! 'b)\\<cdot>x) =\n       sfun_map\\<cdot>(PRJ('a) oo EMB('c))\\<cdot>(PRJ('d) oo EMB('b))\\<cdot>\n       x", "apply (simp add: emb_sfun_def prj_sfun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       sfun_map\\<cdot>EMB('c)\\<cdot>PRJ('d)\\<cdot>\n       (sfun_prj\\<cdot>\n        (sfun_emb\\<cdot>(sfun_map\\<cdot>PRJ('a)\\<cdot>EMB('b)\\<cdot>x))) =\n       sfun_map\\<cdot>(PRJ('a) oo EMB('c))\\<cdot>(PRJ('d) oo EMB('b))\\<cdot>\n       x", "apply (subst ep_pair.e_inverse [OF ep_pair_sfun])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       sfun_map\\<cdot>EMB('c)\\<cdot>PRJ('d)\\<cdot>\n       (sfun_map\\<cdot>PRJ('a)\\<cdot>EMB('b)\\<cdot>x) =\n       sfun_map\\<cdot>(PRJ('a) oo EMB('c))\\<cdot>(PRJ('d) oo EMB('b))\\<cdot>\n       x", "apply (simp add: sfun_map_map cfcomp1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma coerce_cfun': \"coerce = cfun_map\\<cdot>coerce\\<cdot>coerce\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('a \\<rightarrow> 'b, 'c \\<rightarrow> 'd) =\n    cfun_map\\<cdot>COERCE('c, 'a)\\<cdot>COERCE('b, 'd)", "apply (rule cfun_eqI, simp add: prj_emb [symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       PRJ('c \\<rightarrow> 'd)\\<cdot>(EMB('a \\<rightarrow> 'b)\\<cdot>x) =\n       cfun_map\\<cdot>COERCE('c, 'a)\\<cdot>COERCE('b, 'd)\\<cdot>x", "apply (simp add: emb_cfun_def prj_cfun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       decode_cfun\\<cdot>\n       (PRJ('c\\<^sub>\\<bottom> \\<rightarrow>! 'd)\\<cdot>\n        (EMB('a\\<^sub>\\<bottom> \\<rightarrow>! 'b)\\<cdot>\n         (encode_cfun\\<cdot>x))) =\n       cfun_map\\<cdot>COERCE('c, 'a)\\<cdot>COERCE('b, 'd)\\<cdot>x", "apply (simp add: prj_emb coerce_sfun coerce_u)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       decode_cfun\\<cdot>\n       (sfun_map\\<cdot>(u_map\\<cdot>COERCE('c, 'a))\\<cdot>\n        COERCE('b, 'd)\\<cdot>\n        (encode_cfun\\<cdot>x)) =\n       cfun_map\\<cdot>COERCE('c, 'a)\\<cdot>COERCE('b, 'd)\\<cdot>x", "apply (simp add: encode_cfun_map [symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma coerce_ssum: \"coerce = ssum_map\\<cdot>coerce\\<cdot>coerce\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('a \\<oplus> 'b, 'c \\<oplus> 'd) =\n    ssum_map\\<cdot>COERCE('a, 'c)\\<cdot>COERCE('b, 'd)", "apply (rule cfun_eqI, simp add: coerce_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       PRJ('c \\<oplus> 'd)\\<cdot>(EMB('a \\<oplus> 'b)\\<cdot>x) =\n       ssum_map\\<cdot>(PRJ('c) oo EMB('a))\\<cdot>(PRJ('d) oo EMB('b))\\<cdot>\n       x", "apply (simp add: emb_ssum_def prj_ssum_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ssum_map\\<cdot>PRJ('c)\\<cdot>PRJ('d)\\<cdot>\n       (ssum_prj\\<cdot>\n        (ssum_emb\\<cdot>(ssum_map\\<cdot>EMB('a)\\<cdot>EMB('b)\\<cdot>x))) =\n       ssum_map\\<cdot>(PRJ('c) oo EMB('a))\\<cdot>(PRJ('d) oo EMB('b))\\<cdot>\n       x", "apply (subst ep_pair.e_inverse [OF ep_pair_ssum])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ssum_map\\<cdot>PRJ('c)\\<cdot>PRJ('d)\\<cdot>\n       (ssum_map\\<cdot>EMB('a)\\<cdot>EMB('b)\\<cdot>x) =\n       ssum_map\\<cdot>(PRJ('c) oo EMB('a))\\<cdot>(PRJ('d) oo EMB('b))\\<cdot>\n       x", "apply (simp add: ssum_map_map cfcomp1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma coerce_sprod: \"coerce = sprod_map\\<cdot>coerce\\<cdot>coerce\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('a \\<otimes> 'b, 'c \\<otimes> 'd) =\n    sprod_map\\<cdot>COERCE('a, 'c)\\<cdot>COERCE('b, 'd)", "apply (rule cfun_eqI, simp add: coerce_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       PRJ('c \\<otimes> 'd)\\<cdot>(EMB('a \\<otimes> 'b)\\<cdot>x) =\n       sprod_map\\<cdot>(PRJ('c) oo EMB('a))\\<cdot>\n       (PRJ('d) oo EMB('b))\\<cdot>\n       x", "apply (simp add: emb_sprod_def prj_sprod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       sprod_map\\<cdot>PRJ('c)\\<cdot>PRJ('d)\\<cdot>\n       (sprod_prj\\<cdot>\n        (sprod_emb\\<cdot>(sprod_map\\<cdot>EMB('a)\\<cdot>EMB('b)\\<cdot>x))) =\n       sprod_map\\<cdot>(PRJ('c) oo EMB('a))\\<cdot>\n       (PRJ('d) oo EMB('b))\\<cdot>\n       x", "apply (subst ep_pair.e_inverse [OF ep_pair_sprod])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       sprod_map\\<cdot>PRJ('c)\\<cdot>PRJ('d)\\<cdot>\n       (sprod_map\\<cdot>EMB('a)\\<cdot>EMB('b)\\<cdot>x) =\n       sprod_map\\<cdot>(PRJ('c) oo EMB('a))\\<cdot>\n       (PRJ('d) oo EMB('b))\\<cdot>\n       x", "apply (simp add: sprod_map_map cfcomp1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma coerce_prod: \"coerce = prod_map\\<cdot>coerce\\<cdot>coerce\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('a \\<times> 'b, 'c \\<times> 'd) =\n    prod_map\\<cdot>COERCE('a, 'c)\\<cdot>COERCE('b, 'd)", "apply (rule cfun_eqI, simp add: coerce_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       PRJ('c \\<times> 'd)\\<cdot>(EMB('a \\<times> 'b)\\<cdot>x) =\n       prod_map\\<cdot>(PRJ('c) oo EMB('a))\\<cdot>(PRJ('d) oo EMB('b))\\<cdot>\n       x", "apply (simp add: emb_prod_def prj_prod_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       prod_map\\<cdot>PRJ('c)\\<cdot>PRJ('d)\\<cdot>\n       (prod_prj\\<cdot>\n        (prod_emb\\<cdot>(prod_map\\<cdot>EMB('a)\\<cdot>EMB('b)\\<cdot>x))) =\n       prod_map\\<cdot>(PRJ('c) oo EMB('a))\\<cdot>(PRJ('d) oo EMB('b))\\<cdot>\n       x", "apply (subst ep_pair.e_inverse [OF ep_pair_prod])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       prod_map\\<cdot>PRJ('c)\\<cdot>PRJ('d)\\<cdot>\n       (prod_map\\<cdot>EMB('a)\\<cdot>EMB('b)\\<cdot>x) =\n       prod_map\\<cdot>(PRJ('c) oo EMB('a))\\<cdot>(PRJ('d) oo EMB('b))\\<cdot>\n       x", "apply (simp add: prod_map_map cfcomp1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Simplifying coercions\\<close>"], ["", "text \\<open>When simplifying applications of the \\<open>coerce\\<close> function,\nrewrite rules are always oriented to replace \\<open>coerce\\<close> at complex\ntypes with other applications of \\<open>coerce\\<close> at simpler types.\\<close>"], ["", "text \\<open>The safest rewrite rules for \\<open>coerce\\<close> are given the\n\\<open>[simp]\\<close> attribute. For other rules that do not belong in the\nglobal simpset, we use dynamic theorem list called \\<open>coerce_simp\\<close>,\nwhich will collect additional rules for simplifying coercions. \\medskip\\<close>"], ["", "named_theorems coerce_simp \"rule for simplifying coercions\""], ["", "text \\<open>The \\<open>coerce\\<close> function commutes with data constructors\nfor various HOLCF datatypes. \\medskip\\<close>"], ["", "lemma coerce_up [simp]: \"coerce\\<cdot>(up\\<cdot>x) = up\\<cdot>(coerce\\<cdot>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('b\\<^sub>\\<bottom>, 'a\\<^sub>\\<bottom>)\\<cdot>(up\\<cdot>x) =\n    up\\<cdot>(COERCE('b, 'a)\\<cdot>x)", "by (simp add: coerce_u)"], ["", "lemma coerce_sinl [simp]: \"coerce\\<cdot>(sinl\\<cdot>x) = sinl\\<cdot>(coerce\\<cdot>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('c \\<oplus> 'd, 'a \\<oplus> 'b)\\<cdot>(sinl\\<cdot>x) =\n    sinl\\<cdot>(COERCE('c, 'a)\\<cdot>x)", "by (simp add: coerce_ssum ssum_map_sinl')"], ["", "lemma coerce_sinr [simp]: \"coerce\\<cdot>(sinr\\<cdot>x) = sinr\\<cdot>(coerce\\<cdot>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('c \\<oplus> 'd, 'a \\<oplus> 'b)\\<cdot>(sinr\\<cdot>x) =\n    sinr\\<cdot>(COERCE('d, 'b)\\<cdot>x)", "by (simp add: coerce_ssum ssum_map_sinr')"], ["", "lemma coerce_spair [simp]: \"coerce\\<cdot>(:x, y:) = (:coerce\\<cdot>x, coerce\\<cdot>y:)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('c \\<otimes> 'd, 'a \\<otimes> 'b)\\<cdot>(:x, y:) =\n    (:COERCE('c, 'a)\\<cdot>x, COERCE('d, 'b)\\<cdot>y:)", "by (simp add: coerce_sprod sprod_map_spair')"], ["", "lemma coerce_Pair [simp]: \"coerce\\<cdot>(x, y) = (coerce\\<cdot>x, coerce\\<cdot>y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('c \\<times> 'd, 'a \\<times> 'b)\\<cdot>(x, y) =\n    (COERCE('c, 'a)\\<cdot>x, COERCE('d, 'b)\\<cdot>y)", "by (simp add: coerce_prod)"], ["", "lemma beta_coerce_cfun [simp]: \"coerce\\<cdot>f\\<cdot>x = coerce\\<cdot>(f\\<cdot>(coerce\\<cdot>x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('c \\<rightarrow> 'd, 'b \\<rightarrow> 'a)\\<cdot>f\\<cdot>x =\n    COERCE('d, 'a)\\<cdot>(f\\<cdot>(COERCE('b, 'c)\\<cdot>x))", "by (simp add: coerce_cfun')"], ["", "lemma coerce_cfun: \"coerce\\<cdot>f = coerce oo f oo coerce\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('c \\<rightarrow> 'd, 'a \\<rightarrow> 'b)\\<cdot>f =\n    COERCE('d, 'b) oo f oo COERCE('a, 'c)", "by (simp add: cfun_eqI)"], ["", "lemma coerce_cfun_app [coerce_simp]:\n  \"coerce\\<cdot>f = (\\<Lambda> x. coerce\\<cdot>(f\\<cdot>(coerce\\<cdot>x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('c \\<rightarrow> 'd, 'a \\<rightarrow> 'b)\\<cdot>f =\n    (\\<Lambda> x. COERCE('d, 'b)\\<cdot>(f\\<cdot>(COERCE('a, 'c)\\<cdot>x)))", "by (simp add: cfun_eqI)"], ["", "end"]]}