{"file_name": "/home/qj213/afp-2021-10-22/thys/Tycon/State_Transformer.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Tycon", "problem_names": ["lemma coerce_stateT_abs [simp]: \"coerce\\<cdot>(stateT_abs\\<cdot>x) = stateT_abs\\<cdot>(coerce\\<cdot>x)\"", "lemma coerce_StateT [simp]: \"coerce\\<cdot>(StateT\\<cdot>k) = StateT\\<cdot>(coerce\\<cdot>k)\"", "lemma stateT_cases [case_names StateT]:\n  obtains k where \"y = StateT\\<cdot>k\"", "lemma stateT_induct [case_names StateT]:\n  fixes P :: \"'a\\<cdot>('f::functor,'s) stateT \\<Rightarrow> bool\"\n  assumes \"\\<And>k. P (StateT\\<cdot>k)\"\n  shows \"P y\"", "lemma stateT_eqI:\n  \"(\\<And>s. runStateT\\<cdot>a\\<cdot>s = runStateT\\<cdot>b\\<cdot>s) \\<Longrightarrow> a = b\"", "lemma runStateT_coerce [simp]:\n  \"runStateT\\<cdot>(coerce\\<cdot>k)\\<cdot>s = coerce\\<cdot>(runStateT\\<cdot>k\\<cdot>s)\"", "lemma fmapU_StateT [simp]:\n  \"fmapU\\<cdot>f\\<cdot>(StateT\\<cdot>k) =\n    StateT\\<cdot>(\\<Lambda> s. fmap\\<cdot>(\\<Lambda>(x, s'). (f\\<cdot>x, s'))\\<cdot>(k\\<cdot>s))\"", "lemma runStateT_fmapU [simp]:\n  \"runStateT\\<cdot>(fmapU\\<cdot>f\\<cdot>m)\\<cdot>s =\n    fmap\\<cdot>(\\<Lambda>(x, s'). (f\\<cdot>x, s'))\\<cdot>(runStateT\\<cdot>m\\<cdot>s)\"", "lemma bindU_stateT_StateT [simp]:\n  \"bindU\\<cdot>(StateT\\<cdot>f)\\<cdot>k =\n    StateT\\<cdot>(\\<Lambda> s. f\\<cdot>s \\<bind> (\\<Lambda> (x, s'). runStateT\\<cdot>(k\\<cdot>x)\\<cdot>s'))\"", "lemma runStateT_bindU [simp]:\n  \"runStateT\\<cdot>(bindU\\<cdot>m\\<cdot>k)\\<cdot>s = runStateT\\<cdot>m\\<cdot>s \\<bind> (\\<Lambda> (x, s'). runStateT\\<cdot>(k\\<cdot>x)\\<cdot>s')\"", "lemma runStateT_zeroU [simp]:\n  \"runStateT\\<cdot>zeroU\\<cdot>s = mzero\"", "lemma runStateT_plusU [simp]:\n  \"runStateT\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>s =\n    mplus\\<cdot>(runStateT\\<cdot>a\\<cdot>s)\\<cdot>(runStateT\\<cdot>b\\<cdot>s)\"", "lemma coerce_csplit [coerce_simp]:\n  shows \"coerce\\<cdot>(csplit\\<cdot>f\\<cdot>p) = csplit\\<cdot>(\\<Lambda> x y. coerce\\<cdot>(f\\<cdot>x\\<cdot>y))\\<cdot>p\"", "lemma csplit_coerce [coerce_simp]:\n  fixes p :: \"'a \\<times> 'b\"\n  shows \"csplit\\<cdot>f\\<cdot>(COERCE('a \\<times> 'b, 'c \\<times> 'd)\\<cdot>p) =\n    csplit\\<cdot>(\\<Lambda> x y. f\\<cdot>(COERCE('a, 'c)\\<cdot>x)\\<cdot>(COERCE('b, 'd)\\<cdot>y))\\<cdot>p\"", "lemma fmap_stateT_simps [simp]:\n  \"fmap\\<cdot>f\\<cdot>(StateT\\<cdot>m :: 'a\\<cdot>('f::functor,'s) stateT) =\n    StateT\\<cdot>(\\<Lambda> s. fmap\\<cdot>(\\<Lambda> (x, s'). (f\\<cdot>x, s'))\\<cdot>(m\\<cdot>s))\"", "lemma runStateT_fmap [simp]:\n  \"runStateT\\<cdot>(fmap\\<cdot>f\\<cdot>m)\\<cdot>s = fmap\\<cdot>(\\<Lambda> (x, s'). (f\\<cdot>x, s'))\\<cdot>(runStateT\\<cdot>m\\<cdot>s)\"", "lemma return_stateT_def:\n  \"(return :: _ \\<rightarrow> 'a\\<cdot>('m::monad, 's) stateT) =\n    (\\<Lambda> x. StateT\\<cdot>(\\<Lambda> s. return\\<cdot>(x, s)))\"", "lemma bind_stateT_def:\n  \"bind = (\\<Lambda> m k. StateT\\<cdot>(\\<Lambda> s. runStateT\\<cdot>m\\<cdot>s \\<bind> (\\<Lambda> (x, s'). runStateT\\<cdot>(k\\<cdot>x)\\<cdot>s')))\"", "lemma bind_stateT_simps [simp]:\n  \"bind\\<cdot>(StateT\\<cdot>m :: 'a\\<cdot>('m::monad,'s) stateT)\\<cdot>k =\n    StateT\\<cdot>(\\<Lambda> s. m\\<cdot>s \\<bind> (\\<Lambda> (x, s'). runStateT\\<cdot>(k\\<cdot>x)\\<cdot>s'))\"", "lemma runStateT_bind [simp]:\n  \"runStateT\\<cdot>(m \\<bind> k)\\<cdot>s = runStateT\\<cdot>m\\<cdot>s \\<bind> (\\<Lambda> (x, s'). runStateT\\<cdot>(k\\<cdot>x)\\<cdot>s')\""], "translations": [["", "lemma coerce_stateT_abs [simp]: \"coerce\\<cdot>(stateT_abs\\<cdot>x) = stateT_abs\\<cdot>(coerce\\<cdot>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('d\\<cdot>('e, 'f) stateT, 'a\\<cdot>('b, 'c) stateT)\\<cdot>\n    (stateT_abs\\<cdot>x) =\n    stateT_abs\\<cdot>\n    (COERCE\n      ('f \\<rightarrow> ('d \\<times> 'f)\\<cdot>'e,\n       'c \\<rightarrow> ('a \\<times> 'c)\\<cdot>'b)\\<cdot>\n     x)", "apply (simp add: stateT_abs_def coerce_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. PRJ('a\\<cdot>('b, 'c) stateT)\\<cdot>\n    (EMB('d\\<cdot>('e, 'f) stateT)\\<cdot>\n     (PRJ('d\\<cdot>('e, 'f) stateT)\\<cdot>\n      (EMB('f \\<rightarrow> ('d \\<times> 'f)\\<cdot>'e)\\<cdot>x))) =\n    PRJ('a\\<cdot>('b, 'c) stateT)\\<cdot>\n    (EMB('c \\<rightarrow> ('a \\<times> 'c)\\<cdot>'b)\\<cdot>\n     (PRJ('c \\<rightarrow> ('a \\<times> 'c)\\<cdot>'b)\\<cdot>\n      (EMB('f \\<rightarrow> ('d \\<times> 'f)\\<cdot>'e)\\<cdot>x)))", "apply (simp add: emb_prj_emb prj_emb_prj DEFL_eq_stateT)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma coerce_StateT [simp]: \"coerce\\<cdot>(StateT\\<cdot>k) = StateT\\<cdot>(coerce\\<cdot>k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('d\\<cdot>('e, 'f) stateT, 'a\\<cdot>('b, 'c) stateT)\\<cdot>\n    (StateT\\<cdot>k) =\n    StateT\\<cdot>\n    (COERCE\n      ('f \\<rightarrow> ('d \\<times> 'f)\\<cdot>'e,\n       'c \\<rightarrow> ('a \\<times> 'c)\\<cdot>'b)\\<cdot>\n     k)", "unfolding StateT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('d\\<cdot>('e, 'f) stateT, 'a\\<cdot>('b, 'c) stateT)\\<cdot>\n    ((\\<Lambda> cfun. stateT_abs\\<cdot>cfun)\\<cdot>k) =\n    (\\<Lambda> cfun. stateT_abs\\<cdot>cfun)\\<cdot>\n    (COERCE\n      ('f \\<rightarrow> ('d \\<times> 'f)\\<cdot>'e,\n       'c \\<rightarrow> ('a \\<times> 'c)\\<cdot>'b)\\<cdot>\n     k)", "by simp"], ["", "lemma stateT_cases [case_names StateT]:\n  obtains k where \"y = StateT\\<cdot>k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k. y = StateT\\<cdot>k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>k. y = StateT\\<cdot>k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    y = StateT\\<cdot>?k2", "show \"y = StateT\\<cdot>(runStateT\\<cdot>y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = StateT\\<cdot>(runStateT\\<cdot>y)", "by (cases y, simp_all)"], ["proof (state)\nthis:\n  y = StateT\\<cdot>(runStateT\\<cdot>y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma stateT_induct [case_names StateT]:\n  fixes P :: \"'a\\<cdot>('f::functor,'s) stateT \\<Rightarrow> bool\"\n  assumes \"\\<And>k. P (StateT\\<cdot>k)\"\n  shows \"P y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P y", "by (cases y rule: stateT_cases, simp add: assms)"], ["", "lemma stateT_eqI:\n  \"(\\<And>s. runStateT\\<cdot>a\\<cdot>s = runStateT\\<cdot>b\\<cdot>s) \\<Longrightarrow> a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        runStateT\\<cdot>a\\<cdot>s =\n        runStateT\\<cdot>b\\<cdot>s) \\<Longrightarrow>\n    a = b", "apply (cases a rule: stateT_cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<And>s.\n                   runStateT\\<cdot>a\\<cdot>s = runStateT\\<cdot>b\\<cdot>s;\n        a = StateT\\<cdot>k\\<rbrakk>\n       \\<Longrightarrow> a = b", "apply (cases b rule: stateT_cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k ka.\n       \\<lbrakk>\\<And>s.\n                   runStateT\\<cdot>a\\<cdot>s = runStateT\\<cdot>b\\<cdot>s;\n        a = StateT\\<cdot>k; b = StateT\\<cdot>ka\\<rbrakk>\n       \\<Longrightarrow> a = b", "apply (simp add: cfun_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma runStateT_coerce [simp]:\n  \"runStateT\\<cdot>(coerce\\<cdot>k)\\<cdot>s = coerce\\<cdot>(runStateT\\<cdot>k\\<cdot>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runStateT\\<cdot>\n    (COERCE('d\\<cdot>('e, 'b) stateT, 'a\\<cdot>('c, 'b) stateT)\\<cdot>\n     k)\\<cdot>\n    s =\n    COERCE(('d \\<times> 'b)\\<cdot>'e, ('a \\<times> 'b)\\<cdot>'c)\\<cdot>\n    (runStateT\\<cdot>k\\<cdot>s)", "by (induct k rule: stateT_induct, simp)"], ["", "subsection \\<open>Functor class instance\\<close>"], ["", "lemma fmapU_StateT [simp]:\n  \"fmapU\\<cdot>f\\<cdot>(StateT\\<cdot>k) =\n    StateT\\<cdot>(\\<Lambda> s. fmap\\<cdot>(\\<Lambda>(x, s'). (f\\<cdot>x, s'))\\<cdot>(k\\<cdot>s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmapU\\<cdot>f\\<cdot>(StateT\\<cdot>k) =\n    StateT\\<cdot>\n    (\\<Lambda> s.\n        fmap\\<cdot>(\\<Lambda> (x, s'). (f\\<cdot>x, s'))\\<cdot>(k\\<cdot>s))", "unfolding fmapU_stateT_def stateT_map_def StateT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> s a.\n        \\<mu> uu.\n           stateT_abs oo\n           cfun_map\\<cdot>s\\<cdot>(fmap\\<cdot>(prod_map\\<cdot>a\\<cdot>s)) oo\n           stateT_rep)\\<cdot>\n    ID\\<cdot>\n    f\\<cdot>\n    ((\\<Lambda> cfun. stateT_abs\\<cdot>cfun)\\<cdot>k) =\n    (\\<Lambda> cfun. stateT_abs\\<cdot>cfun)\\<cdot>\n    (\\<Lambda> s.\n        fmap\\<cdot>(\\<Lambda> (x, s'). (f\\<cdot>x, s'))\\<cdot>(k\\<cdot>s))", "by (subst fix_eq, simp add: cfun_map_def csplit_def prod_map_def)"], ["", "lemma runStateT_fmapU [simp]:\n  \"runStateT\\<cdot>(fmapU\\<cdot>f\\<cdot>m)\\<cdot>s =\n    fmap\\<cdot>(\\<Lambda>(x, s'). (f\\<cdot>x, s'))\\<cdot>(runStateT\\<cdot>m\\<cdot>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runStateT\\<cdot>(fmapU\\<cdot>f\\<cdot>m)\\<cdot>s =\n    fmap\\<cdot>(\\<Lambda> (x, s'). (f\\<cdot>x, s'))\\<cdot>\n    (runStateT\\<cdot>m\\<cdot>s)", "by (cases m rule: stateT_cases, simp)"], ["", "instantiation stateT :: (\"functor\", \"domain\") \"functor\"\nbegin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) stateT, functor_class)", "apply standard"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f g xs.\n       fmapU\\<cdot>f\\<cdot>(fmapU\\<cdot>g\\<cdot>xs) =\n       fmapU\\<cdot>(\\<Lambda> x. f\\<cdot>(g\\<cdot>x))\\<cdot>xs", "apply (induct_tac xs rule: stateT_induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f g xs k.\n       fmapU\\<cdot>f\\<cdot>(fmapU\\<cdot>g\\<cdot>(StateT\\<cdot>k)) =\n       fmapU\\<cdot>(\\<Lambda> x. f\\<cdot>(g\\<cdot>x))\\<cdot>(StateT\\<cdot>k)", "apply (simp_all add: fmap_fmap ID_def csplit_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection \\<open>Monad class instance\\<close>"], ["", "instantiation stateT :: (monad, \"domain\") monad\nbegin"], ["", "definition returnU_stateT_def:\n  \"returnU = (\\<Lambda> x. StateT\\<cdot>(\\<Lambda> s. return\\<cdot>(x, s)))\""], ["", "definition bindU_stateT_def:\n  \"bindU = (\\<Lambda> m k. StateT\\<cdot>(\\<Lambda> s. runStateT\\<cdot>m\\<cdot>s \\<bind> (\\<Lambda> (x, s'). runStateT\\<cdot>(k\\<cdot>x)\\<cdot>s')))\""], ["", "lemma bindU_stateT_StateT [simp]:\n  \"bindU\\<cdot>(StateT\\<cdot>f)\\<cdot>k =\n    StateT\\<cdot>(\\<Lambda> s. f\\<cdot>s \\<bind> (\\<Lambda> (x, s'). runStateT\\<cdot>(k\\<cdot>x)\\<cdot>s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bindU\\<cdot>(StateT\\<cdot>f)\\<cdot>k =\n    StateT\\<cdot>\n    (\\<Lambda> s.\n        f\\<cdot>s \\<bind>\n        (\\<Lambda> (x, s'). runStateT\\<cdot>(k\\<cdot>x)\\<cdot>s'))", "unfolding bindU_stateT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> m k.\n        StateT\\<cdot>\n        (\\<Lambda> s.\n            runStateT\\<cdot>m\\<cdot>s \\<bind>\n            csplit\\<cdot>\n            (\\<Lambda> x.\n                Abs_cfun (Rep_cfun (runStateT\\<cdot>(k\\<cdot>x))))))\\<cdot>\n    (StateT\\<cdot>f)\\<cdot>\n    k =\n    StateT\\<cdot>\n    (\\<Lambda> s.\n        f\\<cdot>s \\<bind>\n        (\\<Lambda> (x, s'). runStateT\\<cdot>(k\\<cdot>x)\\<cdot>s'))", "by simp"], ["", "lemma runStateT_bindU [simp]:\n  \"runStateT\\<cdot>(bindU\\<cdot>m\\<cdot>k)\\<cdot>s = runStateT\\<cdot>m\\<cdot>s \\<bind> (\\<Lambda> (x, s'). runStateT\\<cdot>(k\\<cdot>x)\\<cdot>s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runStateT\\<cdot>(bindU\\<cdot>m\\<cdot>k)\\<cdot>s =\n    runStateT\\<cdot>m\\<cdot>s \\<bind>\n    (\\<Lambda> (x, s'). runStateT\\<cdot>(k\\<cdot>x)\\<cdot>s')", "unfolding bindU_stateT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. runStateT\\<cdot>\n    ((\\<Lambda> m k.\n         StateT\\<cdot>\n         (\\<Lambda> s.\n             runStateT\\<cdot>m\\<cdot>s \\<bind>\n             csplit\\<cdot>\n             (\\<Lambda> x.\n                 Abs_cfun (Rep_cfun (runStateT\\<cdot>(k\\<cdot>x))))))\\<cdot>\n     m\\<cdot>\n     k)\\<cdot>\n    s =\n    runStateT\\<cdot>m\\<cdot>s \\<bind>\n    (\\<Lambda> (x, s'). runStateT\\<cdot>(k\\<cdot>x)\\<cdot>s')", "by simp"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) stateT, monad_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f xs.\n       fmapU\\<cdot>f\\<cdot>xs =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. returnU\\<cdot>(f\\<cdot>x))\n 2. \\<And>f x. bindU\\<cdot>(returnU\\<cdot>x)\\<cdot>f = f\\<cdot>x\n 3. \\<And>xs f g.\n       bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>g =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(f\\<cdot>x)\\<cdot>g)", "fix f :: \"udom \\<rightarrow> udom\" and r :: \"udom\\<cdot>('a,'b) stateT\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>f xs.\n       fmapU\\<cdot>f\\<cdot>xs =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. returnU\\<cdot>(f\\<cdot>x))\n 2. \\<And>f x. bindU\\<cdot>(returnU\\<cdot>x)\\<cdot>f = f\\<cdot>x\n 3. \\<And>xs f g.\n       bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>g =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(f\\<cdot>x)\\<cdot>g)", "show \"fmapU\\<cdot>f\\<cdot>r = bindU\\<cdot>r\\<cdot>(\\<Lambda> x. returnU\\<cdot>(f\\<cdot>x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmapU\\<cdot>f\\<cdot>r =\n    bindU\\<cdot>r\\<cdot>(\\<Lambda> x. returnU\\<cdot>(f\\<cdot>x))", "by (rule stateT_eqI)\n       (simp add: returnU_stateT_def monad_fmap prod_map_def csplit_def)"], ["proof (state)\nthis:\n  fmapU\\<cdot>f\\<cdot>r =\n  bindU\\<cdot>r\\<cdot>(\\<Lambda> x. returnU\\<cdot>(f\\<cdot>x))\n\ngoal (2 subgoals):\n 1. \\<And>f x. bindU\\<cdot>(returnU\\<cdot>x)\\<cdot>f = f\\<cdot>x\n 2. \\<And>xs f g.\n       bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>g =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(f\\<cdot>x)\\<cdot>g)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f x. bindU\\<cdot>(returnU\\<cdot>x)\\<cdot>f = f\\<cdot>x\n 2. \\<And>xs f g.\n       bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>g =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(f\\<cdot>x)\\<cdot>g)", "fix f :: \"udom \\<rightarrow> udom\\<cdot>('a,'b) stateT\" and x :: \"udom\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f x. bindU\\<cdot>(returnU\\<cdot>x)\\<cdot>f = f\\<cdot>x\n 2. \\<And>xs f g.\n       bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>g =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(f\\<cdot>x)\\<cdot>g)", "show \"bindU\\<cdot>(returnU\\<cdot>x)\\<cdot>f = f\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bindU\\<cdot>(returnU\\<cdot>x)\\<cdot>f = f\\<cdot>x", "by (rule stateT_eqI)\n       (simp add: returnU_stateT_def eta_cfun)"], ["proof (state)\nthis:\n  bindU\\<cdot>(returnU\\<cdot>x)\\<cdot>f = f\\<cdot>x\n\ngoal (1 subgoal):\n 1. \\<And>xs f g.\n       bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>g =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(f\\<cdot>x)\\<cdot>g)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs f g.\n       bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>g =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(f\\<cdot>x)\\<cdot>g)", "fix r :: \"udom\\<cdot>('a,'b) stateT\" and f g :: \"udom \\<rightarrow> udom\\<cdot>('a,'b) stateT\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs f g.\n       bindU\\<cdot>(bindU\\<cdot>xs\\<cdot>f)\\<cdot>g =\n       bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. bindU\\<cdot>(f\\<cdot>x)\\<cdot>g)", "show \"bindU\\<cdot>(bindU\\<cdot>r\\<cdot>f)\\<cdot>g = bindU\\<cdot>r\\<cdot>(\\<Lambda> x. bindU\\<cdot>(f\\<cdot>x)\\<cdot>g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bindU\\<cdot>(bindU\\<cdot>r\\<cdot>f)\\<cdot>g =\n    bindU\\<cdot>r\\<cdot>(\\<Lambda> x. bindU\\<cdot>(f\\<cdot>x)\\<cdot>g)", "by (rule stateT_eqI)\n       (simp add: bind_bind csplit_def)"], ["proof (state)\nthis:\n  bindU\\<cdot>(bindU\\<cdot>r\\<cdot>f)\\<cdot>g =\n  bindU\\<cdot>r\\<cdot>(\\<Lambda> x. bindU\\<cdot>(f\\<cdot>x)\\<cdot>g)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Monad zero instance\\<close>"], ["", "instantiation stateT :: (monad_zero, \"domain\") monad_zero\nbegin"], ["", "definition zeroU_stateT_def:\n  \"zeroU = StateT\\<cdot>(\\<Lambda> s. mzero)\""], ["", "lemma runStateT_zeroU [simp]:\n  \"runStateT\\<cdot>zeroU\\<cdot>s = mzero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runStateT\\<cdot>zeroU\\<cdot>s = mzero", "unfolding zeroU_stateT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. runStateT\\<cdot>(StateT\\<cdot>(\\<Lambda> s. mzero))\\<cdot>s = mzero", "by simp"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) stateT, monad_zero_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. bindU\\<cdot>zeroU\\<cdot>f = zeroU", "fix k :: \"udom \\<rightarrow> udom\\<cdot>('a,'b) stateT\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. bindU\\<cdot>zeroU\\<cdot>f = zeroU", "show \"bindU\\<cdot>zeroU\\<cdot>k = zeroU\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bindU\\<cdot>zeroU\\<cdot>k = zeroU", "by (rule stateT_eqI, simp add: bind_mzero)"], ["proof (state)\nthis:\n  bindU\\<cdot>zeroU\\<cdot>k = zeroU\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Monad plus instance\\<close>"], ["", "instantiation stateT :: (monad_plus, \"domain\") monad_plus\nbegin"], ["", "definition plusU_stateT_def:\n  \"plusU = (\\<Lambda> a b. StateT\\<cdot>(\\<Lambda> s. mplus\\<cdot>(runStateT\\<cdot>a\\<cdot>s)\\<cdot>(runStateT\\<cdot>b\\<cdot>s)))\""], ["", "lemma runStateT_plusU [simp]:\n  \"runStateT\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>s =\n    mplus\\<cdot>(runStateT\\<cdot>a\\<cdot>s)\\<cdot>(runStateT\\<cdot>b\\<cdot>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runStateT\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>s =\n    mplus\\<cdot>(runStateT\\<cdot>a\\<cdot>s)\\<cdot>\n    (runStateT\\<cdot>b\\<cdot>s)", "unfolding plusU_stateT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. runStateT\\<cdot>\n    ((\\<Lambda> a b.\n         StateT\\<cdot>\n         (\\<Lambda> s.\n             mplus\\<cdot>(runStateT\\<cdot>a\\<cdot>s)\\<cdot>\n             (runStateT\\<cdot>b\\<cdot>s)))\\<cdot>\n     a\\<cdot>\n     b)\\<cdot>\n    s =\n    mplus\\<cdot>(runStateT\\<cdot>a\\<cdot>s)\\<cdot>\n    (runStateT\\<cdot>b\\<cdot>s)", "by simp"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) stateT, monad_plus_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs ys k.\n       bindU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>k =\n       plusU\\<cdot>(bindU\\<cdot>xs\\<cdot>k)\\<cdot>(bindU\\<cdot>ys\\<cdot>k)\n 2. \\<And>a b c.\n       plusU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>c =\n       plusU\\<cdot>a\\<cdot>(plusU\\<cdot>b\\<cdot>c)", "fix a b :: \"udom\\<cdot>('a, 'b) stateT\" and k :: \"udom \\<rightarrow> udom\\<cdot>('a, 'b) stateT\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs ys k.\n       bindU\\<cdot>(plusU\\<cdot>xs\\<cdot>ys)\\<cdot>k =\n       plusU\\<cdot>(bindU\\<cdot>xs\\<cdot>k)\\<cdot>(bindU\\<cdot>ys\\<cdot>k)\n 2. \\<And>a b c.\n       plusU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>c =\n       plusU\\<cdot>a\\<cdot>(plusU\\<cdot>b\\<cdot>c)", "show \"bindU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>k = plusU\\<cdot>(bindU\\<cdot>a\\<cdot>k)\\<cdot>(bindU\\<cdot>b\\<cdot>k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bindU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>k =\n    plusU\\<cdot>(bindU\\<cdot>a\\<cdot>k)\\<cdot>(bindU\\<cdot>b\\<cdot>k)", "by (rule stateT_eqI, simp add: bind_mplus)"], ["proof (state)\nthis:\n  bindU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>k =\n  plusU\\<cdot>(bindU\\<cdot>a\\<cdot>k)\\<cdot>(bindU\\<cdot>b\\<cdot>k)\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       plusU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>c =\n       plusU\\<cdot>a\\<cdot>(plusU\\<cdot>b\\<cdot>c)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       plusU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>c =\n       plusU\\<cdot>a\\<cdot>(plusU\\<cdot>b\\<cdot>c)", "fix a b c :: \"udom\\<cdot>('a, 'b) stateT\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       plusU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>c =\n       plusU\\<cdot>a\\<cdot>(plusU\\<cdot>b\\<cdot>c)", "show \"plusU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>c = plusU\\<cdot>a\\<cdot>(plusU\\<cdot>b\\<cdot>c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plusU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>c =\n    plusU\\<cdot>a\\<cdot>(plusU\\<cdot>b\\<cdot>c)", "by (rule stateT_eqI, simp add: mplus_assoc)"], ["proof (state)\nthis:\n  plusU\\<cdot>(plusU\\<cdot>a\\<cdot>b)\\<cdot>c =\n  plusU\\<cdot>a\\<cdot>(plusU\\<cdot>b\\<cdot>c)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Monad zero plus instance\\<close>"], ["", "instance stateT :: (monad_zero_plus, \"domain\") monad_zero_plus"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) stateT, monad_zero_plus_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m. plusU\\<cdot>zeroU\\<cdot>m = m\n 2. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "fix m :: \"udom\\<cdot>('a, 'b) stateT\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m. plusU\\<cdot>zeroU\\<cdot>m = m\n 2. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "show \"plusU\\<cdot>zeroU\\<cdot>m = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plusU\\<cdot>zeroU\\<cdot>m = m", "by (rule stateT_eqI, simp add: mplus_mzero_left)"], ["proof (state)\nthis:\n  plusU\\<cdot>zeroU\\<cdot>m = m\n\ngoal (1 subgoal):\n 1. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "fix m :: \"udom\\<cdot>('a, 'b) stateT\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m. plusU\\<cdot>m\\<cdot>zeroU = m", "show \"plusU\\<cdot>m\\<cdot>zeroU = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plusU\\<cdot>m\\<cdot>zeroU = m", "by (rule stateT_eqI, simp add: mplus_mzero_right)"], ["proof (state)\nthis:\n  plusU\\<cdot>m\\<cdot>zeroU = m\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Transfer properties to polymorphic versions\\<close>"], ["", "lemma coerce_csplit [coerce_simp]:\n  shows \"coerce\\<cdot>(csplit\\<cdot>f\\<cdot>p) = csplit\\<cdot>(\\<Lambda> x y. coerce\\<cdot>(f\\<cdot>x\\<cdot>y))\\<cdot>p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('b, 'a)\\<cdot>(csplit\\<cdot>f\\<cdot>p) =\n    (\\<Lambda> (x, y). COERCE('b, 'a)\\<cdot>(f\\<cdot>x\\<cdot>y))\\<cdot>p", "unfolding csplit_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('b, 'a)\\<cdot>\n    ((\\<Lambda> f p. f\\<cdot>(fst p)\\<cdot>(snd p))\\<cdot>f\\<cdot>p) =\n    (\\<Lambda> f p. f\\<cdot>(fst p)\\<cdot>(snd p))\\<cdot>\n    (\\<Lambda> x y. COERCE('b, 'a)\\<cdot>(f\\<cdot>x\\<cdot>y))\\<cdot>\n    p", "by simp"], ["", "lemma csplit_coerce [coerce_simp]:\n  fixes p :: \"'a \\<times> 'b\"\n  shows \"csplit\\<cdot>f\\<cdot>(COERCE('a \\<times> 'b, 'c \\<times> 'd)\\<cdot>p) =\n    csplit\\<cdot>(\\<Lambda> x y. f\\<cdot>(COERCE('a, 'c)\\<cdot>x)\\<cdot>(COERCE('b, 'd)\\<cdot>y))\\<cdot>p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csplit\\<cdot>f\\<cdot>(COERCE('a \\<times> 'b, 'c \\<times> 'd)\\<cdot>p) =\n    (\\<Lambda> (x, y).\n        f\\<cdot>(COERCE('a, 'c)\\<cdot>x)\\<cdot>\n        (COERCE('b, 'd)\\<cdot>y))\\<cdot>\n    p", "unfolding coerce_prod csplit_def prod_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> f p. f\\<cdot>(fst p)\\<cdot>(snd p))\\<cdot>f\\<cdot>\n    ((\\<Lambda> f g p. (f\\<cdot>(fst p), g\\<cdot>(snd p)))\\<cdot>\n     COERCE('a, 'c)\\<cdot>\n     COERCE('b, 'd)\\<cdot>\n     p) =\n    (\\<Lambda> f p. f\\<cdot>(fst p)\\<cdot>(snd p))\\<cdot>\n    (\\<Lambda> x y.\n        f\\<cdot>(COERCE('a, 'c)\\<cdot>x)\\<cdot>\n        (COERCE('b, 'd)\\<cdot>y))\\<cdot>\n    p", "by simp"], ["", "lemma fmap_stateT_simps [simp]:\n  \"fmap\\<cdot>f\\<cdot>(StateT\\<cdot>m :: 'a\\<cdot>('f::functor,'s) stateT) =\n    StateT\\<cdot>(\\<Lambda> s. fmap\\<cdot>(\\<Lambda> (x, s'). (f\\<cdot>x, s'))\\<cdot>(m\\<cdot>s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap\\<cdot>f\\<cdot>(StateT\\<cdot>m) =\n    StateT\\<cdot>\n    (\\<Lambda> s.\n        fmap\\<cdot>(\\<Lambda> (x, s'). (f\\<cdot>x, s'))\\<cdot>(m\\<cdot>s))", "unfolding fmap_def [where 'f=\"('f, 's) stateT\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE\n     ((udom \\<rightarrow> udom) \\<rightarrow>\n      udom\\<cdot>('f, 's) stateT \\<rightarrow> udom\\<cdot>('f, 's) stateT,\n      ('a \\<rightarrow> 'b) \\<rightarrow>\n      'a\\<cdot>('f, 's) stateT \\<rightarrow>\n      'b\\<cdot>('f, 's) stateT)\\<cdot>\n    fmapU\\<cdot>\n    f\\<cdot>\n    (StateT\\<cdot>m) =\n    StateT\\<cdot>\n    (\\<Lambda> s.\n        fmap\\<cdot>(\\<Lambda> (x, s'). (f\\<cdot>x, s'))\\<cdot>(m\\<cdot>s))", "by (simp add: coerce_simp eta_cfun)"], ["", "lemma runStateT_fmap [simp]:\n  \"runStateT\\<cdot>(fmap\\<cdot>f\\<cdot>m)\\<cdot>s = fmap\\<cdot>(\\<Lambda> (x, s'). (f\\<cdot>x, s'))\\<cdot>(runStateT\\<cdot>m\\<cdot>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runStateT\\<cdot>(fmap\\<cdot>f\\<cdot>m)\\<cdot>s =\n    fmap\\<cdot>(\\<Lambda> (x, s'). (f\\<cdot>x, s'))\\<cdot>\n    (runStateT\\<cdot>m\\<cdot>s)", "by (induct m rule: stateT_induct, simp)"], ["", "lemma return_stateT_def:\n  \"(return :: _ \\<rightarrow> 'a\\<cdot>('m::monad, 's) stateT) =\n    (\\<Lambda> x. StateT\\<cdot>(\\<Lambda> s. return\\<cdot>(x, s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return = (\\<Lambda> x. StateT\\<cdot>(\\<Lambda> s. return\\<cdot>(x, s)))", "unfolding return_def [where 'm=\"('m, 's) stateT\"] returnU_stateT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE\n     (udom \\<rightarrow> udom\\<cdot>('m, 's) stateT,\n      'a \\<rightarrow> 'a\\<cdot>('m, 's) stateT)\\<cdot>\n    (\\<Lambda> x. StateT\\<cdot>(\\<Lambda> s. return\\<cdot>(x, s))) =\n    (\\<Lambda> x. StateT\\<cdot>(\\<Lambda> s. return\\<cdot>(x, s)))", "by (simp add: coerce_simp)"], ["", "lemma bind_stateT_def:\n  \"bind = (\\<Lambda> m k. StateT\\<cdot>(\\<Lambda> s. runStateT\\<cdot>m\\<cdot>s \\<bind> (\\<Lambda> (x, s'). runStateT\\<cdot>(k\\<cdot>x)\\<cdot>s')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind =\n    (\\<Lambda> m k.\n        StateT\\<cdot>\n        (\\<Lambda> s.\n            runStateT\\<cdot>m\\<cdot>s \\<bind>\n            (\\<Lambda> (x, s'). runStateT\\<cdot>(k\\<cdot>x)\\<cdot>s')))", "apply (subst bind_def, subst bindU_stateT_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE\n     (udom\\<cdot>('b, 'c) stateT \\<rightarrow>\n      (udom \\<rightarrow> udom\\<cdot>('b, 'c) stateT) \\<rightarrow>\n      udom\\<cdot>('b, 'c) stateT,\n      'a\\<cdot>('b, 'c) stateT \\<rightarrow>\n      ('a \\<rightarrow> 'd\\<cdot>('b, 'c) stateT) \\<rightarrow>\n      'd\\<cdot>('b, 'c) stateT)\\<cdot>\n    (\\<Lambda> m k.\n        StateT\\<cdot>\n        (\\<Lambda> s.\n            runStateT\\<cdot>m\\<cdot>s \\<bind>\n            csplit\\<cdot>\n            (\\<Lambda> x.\n                Abs_cfun (Rep_cfun (runStateT\\<cdot>(k\\<cdot>x)))))) =\n    (\\<Lambda> m k.\n        StateT\\<cdot>\n        (\\<Lambda> s.\n            runStateT\\<cdot>m\\<cdot>s \\<bind>\n            csplit\\<cdot>\n            (\\<Lambda> x.\n                Abs_cfun (Rep_cfun (runStateT\\<cdot>(k\\<cdot>x))))))", "apply (simp add: coerce_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> x xa.\n        StateT\\<cdot>\n        (\\<Lambda> xb.\n            runStateT\\<cdot>x\\<cdot>xb \\<bind>\n            (\\<Lambda> x.\n                (\\<Lambda> (x, y).\n                    COERCE\n                     ((udom \\<times> 'c)\\<cdot>'b,\n                      ('d \\<times> 'c)\\<cdot>'b)\\<cdot>\n                    (COERCE\n                      (('d \\<times> 'c)\\<cdot>'b,\n                       (udom \\<times> 'c)\\<cdot>'b)\\<cdot>\n                     (runStateT\\<cdot>(xa\\<cdot>x)\\<cdot>y)))\\<cdot>\n                x))) =\n    (\\<Lambda> m k.\n        StateT\\<cdot>\n        (\\<Lambda> s.\n            runStateT\\<cdot>m\\<cdot>s \\<bind>\n            csplit\\<cdot>\n            (\\<Lambda> x.\n                Abs_cfun (Rep_cfun (runStateT\\<cdot>(k\\<cdot>x))))))", "apply (simp add: coerce_idem domain_defl_simps monofun_cfun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> x xa.\n        StateT\\<cdot>\n        (\\<Lambda> xb.\n            runStateT\\<cdot>x\\<cdot>xb \\<bind>\n            (\\<Lambda> x.\n                (\\<Lambda> (x, y).\n                    runStateT\\<cdot>(xa\\<cdot>x)\\<cdot>y)\\<cdot>\n                x))) =\n    (\\<Lambda> m k.\n        StateT\\<cdot>\n        (\\<Lambda> s.\n            runStateT\\<cdot>m\\<cdot>s \\<bind>\n            csplit\\<cdot>\n            (\\<Lambda> x.\n                Abs_cfun (Rep_cfun (runStateT\\<cdot>(k\\<cdot>x))))))", "apply (simp add: eta_cfun)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \"TODO: add \\<open>coerce_idem\\<close> to \\<open>coerce_simps\\<close>, along\\010with monotonicity rules for DEFL.\""], ["", "lemma bind_stateT_simps [simp]:\n  \"bind\\<cdot>(StateT\\<cdot>m :: 'a\\<cdot>('m::monad,'s) stateT)\\<cdot>k =\n    StateT\\<cdot>(\\<Lambda> s. m\\<cdot>s \\<bind> (\\<Lambda> (x, s'). runStateT\\<cdot>(k\\<cdot>x)\\<cdot>s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StateT\\<cdot>m \\<bind> k =\n    StateT\\<cdot>\n    (\\<Lambda> s.\n        m\\<cdot>s \\<bind>\n        (\\<Lambda> (x, s'). runStateT\\<cdot>(k\\<cdot>x)\\<cdot>s'))", "unfolding bind_stateT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> m k.\n        StateT\\<cdot>\n        (\\<Lambda> s.\n            runStateT\\<cdot>m\\<cdot>s \\<bind>\n            csplit\\<cdot>\n            (\\<Lambda> x.\n                Abs_cfun (Rep_cfun (runStateT\\<cdot>(k\\<cdot>x))))))\\<cdot>\n    (StateT\\<cdot>m)\\<cdot>\n    k =\n    StateT\\<cdot>\n    (\\<Lambda> s.\n        m\\<cdot>s \\<bind>\n        (\\<Lambda> (x, s'). runStateT\\<cdot>(k\\<cdot>x)\\<cdot>s'))", "by simp"], ["", "lemma runStateT_bind [simp]:\n  \"runStateT\\<cdot>(m \\<bind> k)\\<cdot>s = runStateT\\<cdot>m\\<cdot>s \\<bind> (\\<Lambda> (x, s'). runStateT\\<cdot>(k\\<cdot>x)\\<cdot>s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runStateT\\<cdot>(m \\<bind> k)\\<cdot>s =\n    runStateT\\<cdot>m\\<cdot>s \\<bind>\n    (\\<Lambda> (x, s'). runStateT\\<cdot>(k\\<cdot>x)\\<cdot>s')", "unfolding bind_stateT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. runStateT\\<cdot>\n    ((\\<Lambda> m k.\n         StateT\\<cdot>\n         (\\<Lambda> s.\n             runStateT\\<cdot>m\\<cdot>s \\<bind>\n             csplit\\<cdot>\n             (\\<Lambda> x.\n                 Abs_cfun (Rep_cfun (runStateT\\<cdot>(k\\<cdot>x))))))\\<cdot>\n     m\\<cdot>\n     k)\\<cdot>\n    s =\n    runStateT\\<cdot>m\\<cdot>s \\<bind>\n    (\\<Lambda> (x, s'). runStateT\\<cdot>(k\\<cdot>x)\\<cdot>s')", "by simp"], ["", "end"]]}