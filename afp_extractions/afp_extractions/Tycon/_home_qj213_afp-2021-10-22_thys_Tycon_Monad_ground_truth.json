{"file_name": "/home/qj213/afp-2021-10-22/thys/Tycon/Monad.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Tycon", "problem_names": ["lemma fmapU_returnU [coerce_simp]:\n  \"fmapU\\<cdot>f\\<cdot>(returnU\\<cdot>x) = returnU\\<cdot>(f\\<cdot>x)\"", "lemma fmapU_bindU [coerce_simp]:\n  \"fmapU\\<cdot>f\\<cdot>(bindU\\<cdot>m\\<cdot>k) = bindU\\<cdot>m\\<cdot>(\\<Lambda> x. fmapU\\<cdot>f\\<cdot>(k\\<cdot>x))\"", "lemma bindU_fmapU:\n  \"bindU\\<cdot>(fmapU\\<cdot>f\\<cdot>xs)\\<cdot>k = bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. k\\<cdot>(f\\<cdot>x))\"", "lemma monad_fmap:\n  fixes xs :: \"'a\\<cdot>'m::monad\" and f :: \"'a \\<rightarrow> 'b\"\n  shows \"fmap\\<cdot>f\\<cdot>xs = xs \\<bind> (\\<Lambda> x. return\\<cdot>(f\\<cdot>x))\"", "lemma monad_left_unit [simp]: \"(return\\<cdot>x \\<bind> f) = (f\\<cdot>x)\"", "lemma bind_bind:\n  fixes m :: \"'a\\<cdot>'m::monad\"\n  shows \"((m \\<bind> f) \\<bind> g) = (m \\<bind> (\\<Lambda> x. f\\<cdot>x \\<bind> g))\"", "lemma monad_right_unit [simp]: \"(m \\<bind> return) = m\"", "lemma fmap_return: \"fmap\\<cdot>f\\<cdot>(return\\<cdot>x) = return\\<cdot>(f\\<cdot>x)\"", "lemma fmap_bind: \"fmap\\<cdot>f\\<cdot>(bind\\<cdot>xs\\<cdot>k) = bind\\<cdot>xs\\<cdot>(\\<Lambda> x. fmap\\<cdot>f\\<cdot>(k\\<cdot>x))\"", "lemma bind_fmap: \"bind\\<cdot>(fmap\\<cdot>f\\<cdot>xs)\\<cdot>k = bind\\<cdot>xs\\<cdot>(\\<Lambda> x. k\\<cdot>(f\\<cdot>x))\"", "lemma bind_strict:\n  assumes \"k\\<cdot>\\<bottom> = \\<bottom>\" shows \"\\<bottom> \\<bind> k = \\<bottom>\"", "lemma congruent_bind:\n  \"(\\<forall>m. m \\<bind> k1 = m \\<bind> k2) = (k1 = k2)\"", "lemma join_fmap_fmap: \"join\\<cdot>(fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>xss) = fmap\\<cdot>f\\<cdot>(join\\<cdot>xss)\"", "lemma join_return: \"join\\<cdot>(return\\<cdot>xs) = xs\"", "lemma join_fmap_return: \"join\\<cdot>(fmap\\<cdot>return\\<cdot>xs) = xs\"", "lemma join_fmap_join: \"join\\<cdot>(fmap\\<cdot>join\\<cdot>xsss) = join\\<cdot>(join\\<cdot>xsss)\"", "lemma bind_def2: \"m \\<bind> k = join\\<cdot>(fmap\\<cdot>k\\<cdot>m)\"", "lemma \"(return\\<cdot>x \\<bind> f) = (f\\<cdot>x)\"", "lemma \"(m \\<bind> return) = m\"", "lemma \"((m \\<bind> f) \\<bind> g) = (m \\<bind> (\\<Lambda> x. f\\<cdot>x \\<bind> g))\"", "lemma coerce_return [coerce_simp]:\n  \"COERCE('a\\<cdot>'m,'b\\<cdot>'m::monad)\\<cdot>(return\\<cdot>x) = return\\<cdot>(COERCE('a,'b)\\<cdot>x)\"", "lemma coerce_bind [coerce_simp]:\n  fixes m :: \"'a\\<cdot>'m::monad\" and k :: \"'a \\<rightarrow> 'b\\<cdot>'m\"\n  shows \"COERCE('b\\<cdot>'m,'c\\<cdot>'m)\\<cdot>(m \\<bind> k) = m \\<bind> (\\<Lambda> x. COERCE('b\\<cdot>'m,'c\\<cdot>'m)\\<cdot>(k\\<cdot>x))\"", "lemma bind_coerce [coerce_simp]:\n  fixes m :: \"'a\\<cdot>'m::monad\" and k :: \"'b \\<rightarrow> 'c\\<cdot>'m\"\n  shows \"COERCE('a\\<cdot>'m,'b\\<cdot>'m)\\<cdot>m \\<bind> k = m \\<bind> (\\<Lambda> x. k\\<cdot>(COERCE('a,'b)\\<cdot>x))\""], "translations": [["", "lemma fmapU_returnU [coerce_simp]:\n  \"fmapU\\<cdot>f\\<cdot>(returnU\\<cdot>x) = returnU\\<cdot>(f\\<cdot>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmapU\\<cdot>f\\<cdot>(returnU\\<cdot>x) = returnU\\<cdot>(f\\<cdot>x)", "by (simp add: fmapU_eq_bindU bindU_returnU)"], ["", "lemma fmapU_bindU [coerce_simp]:\n  \"fmapU\\<cdot>f\\<cdot>(bindU\\<cdot>m\\<cdot>k) = bindU\\<cdot>m\\<cdot>(\\<Lambda> x. fmapU\\<cdot>f\\<cdot>(k\\<cdot>x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmapU\\<cdot>f\\<cdot>(bindU\\<cdot>m\\<cdot>k) =\n    bindU\\<cdot>m\\<cdot>(\\<Lambda> x. fmapU\\<cdot>f\\<cdot>(k\\<cdot>x))", "by (simp add: fmapU_eq_bindU bindU_bindU)"], ["", "lemma bindU_fmapU:\n  \"bindU\\<cdot>(fmapU\\<cdot>f\\<cdot>xs)\\<cdot>k = bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. k\\<cdot>(f\\<cdot>x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bindU\\<cdot>(fmapU\\<cdot>f\\<cdot>xs)\\<cdot>k =\n    bindU\\<cdot>xs\\<cdot>(\\<Lambda> x. k\\<cdot>(f\\<cdot>x))", "by (simp add: fmapU_eq_bindU bindU_returnU bindU_bindU)"], ["", "subsection \\<open>Polymorphic versions of class assumptions\\<close>"], ["", "lemma monad_fmap:\n  fixes xs :: \"'a\\<cdot>'m::monad\" and f :: \"'a \\<rightarrow> 'b\"\n  shows \"fmap\\<cdot>f\\<cdot>xs = xs \\<bind> (\\<Lambda> x. return\\<cdot>(f\\<cdot>x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap\\<cdot>f\\<cdot>xs =\n    xs \\<bind> (\\<Lambda> x. return\\<cdot>(f\\<cdot>x))", "unfolding bind_def return_def fmap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE\n     ((udom \\<rightarrow> udom) \\<rightarrow>\n      udom\\<cdot>'m \\<rightarrow> udom\\<cdot>'m,\n      ('a \\<rightarrow> 'b) \\<rightarrow>\n      'a\\<cdot>'m \\<rightarrow> 'b\\<cdot>'m)\\<cdot>\n    fmapU\\<cdot>\n    f\\<cdot>\n    xs =\n    COERCE\n     (udom\\<cdot>'m \\<rightarrow>\n      (udom \\<rightarrow> udom\\<cdot>'m) \\<rightarrow> udom\\<cdot>'m,\n      'a\\<cdot>'m \\<rightarrow>\n      ('a \\<rightarrow> 'b\\<cdot>'m) \\<rightarrow> 'b\\<cdot>'m)\\<cdot>\n    bindU\\<cdot>\n    xs\\<cdot>\n    (\\<Lambda> x.\n        COERCE\n         (udom \\<rightarrow> udom\\<cdot>'m,\n          'b \\<rightarrow> 'b\\<cdot>'m)\\<cdot>\n        returnU\\<cdot>\n        (f\\<cdot>x))", "by (simp add: coerce_simp fmapU_eq_bindU bindU_returnU)"], ["", "lemma monad_left_unit [simp]: \"(return\\<cdot>x \\<bind> f) = (f\\<cdot>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return\\<cdot>x \\<bind> f = f\\<cdot>x", "unfolding bind_def return_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE\n     (udom\\<cdot>'b \\<rightarrow>\n      (udom \\<rightarrow> udom\\<cdot>'b) \\<rightarrow> udom\\<cdot>'b,\n      'c\\<cdot>'b \\<rightarrow>\n      ('c \\<rightarrow> 'a\\<cdot>'b) \\<rightarrow> 'a\\<cdot>'b)\\<cdot>\n    bindU\\<cdot>\n    (COERCE\n      (udom \\<rightarrow> udom\\<cdot>'b,\n       'c \\<rightarrow> 'c\\<cdot>'b)\\<cdot>\n     returnU\\<cdot>\n     x)\\<cdot>\n    f =\n    f\\<cdot>x", "by (simp add: coerce_simp bindU_returnU)"], ["", "lemma bind_bind:\n  fixes m :: \"'a\\<cdot>'m::monad\"\n  shows \"((m \\<bind> f) \\<bind> g) = (m \\<bind> (\\<Lambda> x. f\\<cdot>x \\<bind> g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> f \\<bind> g = m \\<bind> (\\<Lambda> x. f\\<cdot>x \\<bind> g)", "unfolding bind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE\n     (udom\\<cdot>'m \\<rightarrow>\n      (udom \\<rightarrow> udom\\<cdot>'m) \\<rightarrow> udom\\<cdot>'m,\n      'c\\<cdot>'m \\<rightarrow>\n      ('c \\<rightarrow> 'b\\<cdot>'m) \\<rightarrow> 'b\\<cdot>'m)\\<cdot>\n    bindU\\<cdot>\n    (COERCE\n      (udom\\<cdot>'m \\<rightarrow>\n       (udom \\<rightarrow> udom\\<cdot>'m) \\<rightarrow> udom\\<cdot>'m,\n       'a\\<cdot>'m \\<rightarrow>\n       ('a \\<rightarrow> 'c\\<cdot>'m) \\<rightarrow> 'c\\<cdot>'m)\\<cdot>\n     bindU\\<cdot>\n     m\\<cdot>\n     f)\\<cdot>\n    g =\n    COERCE\n     (udom\\<cdot>'m \\<rightarrow>\n      (udom \\<rightarrow> udom\\<cdot>'m) \\<rightarrow> udom\\<cdot>'m,\n      'a\\<cdot>'m \\<rightarrow>\n      ('a \\<rightarrow> 'b\\<cdot>'m) \\<rightarrow> 'b\\<cdot>'m)\\<cdot>\n    bindU\\<cdot>\n    m\\<cdot>\n    (\\<Lambda> x.\n        COERCE\n         (udom\\<cdot>'m \\<rightarrow>\n          (udom \\<rightarrow> udom\\<cdot>'m) \\<rightarrow> udom\\<cdot>'m,\n          'c\\<cdot>'m \\<rightarrow>\n          ('c \\<rightarrow> 'b\\<cdot>'m) \\<rightarrow> 'b\\<cdot>'m)\\<cdot>\n        bindU\\<cdot>\n        (f\\<cdot>x)\\<cdot>\n        g)", "by (simp add: coerce_simp bindU_bindU)"], ["", "subsection \\<open>Derived rules\\<close>"], ["", "text \\<open>The following properties can be derived using only the\nabstract monad laws.\\<close>"], ["", "lemma monad_right_unit [simp]: \"(m \\<bind> return) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> return = m", "apply (subgoal_tac \"fmap\\<cdot>ID\\<cdot>m = m\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. fmap\\<cdot>ID\\<cdot>m = m \\<Longrightarrow> m \\<bind> return = m\n 2. fmap\\<cdot>ID\\<cdot>m = m", "apply (simp only: monad_fmap)"], ["proof (prove)\ngoal (2 subgoals):\n 1. m \\<bind> (\\<Lambda> x. return\\<cdot>(ID\\<cdot>x)) = m \\<Longrightarrow>\n    m \\<bind> return = m\n 2. fmap\\<cdot>ID\\<cdot>m = m", "apply (simp add: eta_cfun)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap\\<cdot>ID\\<cdot>m = m", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fmap_return: \"fmap\\<cdot>f\\<cdot>(return\\<cdot>x) = return\\<cdot>(f\\<cdot>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap\\<cdot>f\\<cdot>(return\\<cdot>x) = return\\<cdot>(f\\<cdot>x)", "by (simp add: monad_fmap)"], ["", "lemma fmap_bind: \"fmap\\<cdot>f\\<cdot>(bind\\<cdot>xs\\<cdot>k) = bind\\<cdot>xs\\<cdot>(\\<Lambda> x. fmap\\<cdot>f\\<cdot>(k\\<cdot>x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap\\<cdot>f\\<cdot>(xs \\<bind> k) =\n    xs \\<bind> (\\<Lambda> x. fmap\\<cdot>f\\<cdot>(k\\<cdot>x))", "by (simp add: monad_fmap bind_bind)"], ["", "lemma bind_fmap: \"bind\\<cdot>(fmap\\<cdot>f\\<cdot>xs)\\<cdot>k = bind\\<cdot>xs\\<cdot>(\\<Lambda> x. k\\<cdot>(f\\<cdot>x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmap\\<cdot>f\\<cdot>xs \\<bind> k =\n    xs \\<bind> (\\<Lambda> x. k\\<cdot>(f\\<cdot>x))", "by (simp add: monad_fmap bind_bind)"], ["", "text \\<open>Bind is strict in its first argument, if its second argument\nis a strict function.\\<close>"], ["", "lemma bind_strict:\n  assumes \"k\\<cdot>\\<bottom> = \\<bottom>\" shows \"\\<bottom> \\<bind> k = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<bind> k = \\<bottom>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bottom> \\<bind> k = \\<bottom>", "have \"\\<bottom> \\<bind> k \\<sqsubseteq> return\\<cdot>\\<bottom> \\<bind> k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> \\<bind> k \\<sqsubseteq> return\\<cdot>\\<bottom> \\<bind> k", "by (intro monofun_cfun below_refl minimal)"], ["proof (state)\nthis:\n  \\<bottom> \\<bind> k \\<sqsubseteq> return\\<cdot>\\<bottom> \\<bind> k\n\ngoal (1 subgoal):\n 1. \\<bottom> \\<bind> k = \\<bottom>", "thus \"\\<bottom> \\<bind> k = \\<bottom>\""], ["proof (prove)\nusing this:\n  \\<bottom> \\<bind> k \\<sqsubseteq> return\\<cdot>\\<bottom> \\<bind> k\n\ngoal (1 subgoal):\n 1. \\<bottom> \\<bind> k = \\<bottom>", "by (simp add: assms)"], ["proof (state)\nthis:\n  \\<bottom> \\<bind> k = \\<bottom>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma congruent_bind:\n  \"(\\<forall>m. m \\<bind> k1 = m \\<bind> k2) = (k1 = k2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>m. m \\<bind> k1 = m \\<bind> k2) = (k1 = k2)", "apply (safe, rule cfun_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>m. m \\<bind> k1 = m \\<bind> k2 \\<Longrightarrow>\n       k1\\<cdot>x = k2\\<cdot>x", "apply (drule_tac x=\"return\\<cdot>x\" in spec, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Laws for join\\<close>"], ["", "definition join :: \"('a\\<cdot>'m)\\<cdot>'m \\<rightarrow> 'a\\<cdot>'m::monad\"\n  where \"join \\<equiv> \\<Lambda> m. m \\<bind> (\\<Lambda> x. x)\""], ["", "lemma join_fmap_fmap: \"join\\<cdot>(fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>xss) = fmap\\<cdot>f\\<cdot>(join\\<cdot>xss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. join\\<cdot>(fmap\\<cdot>(fmap\\<cdot>f)\\<cdot>xss) =\n    fmap\\<cdot>f\\<cdot>(join\\<cdot>xss)", "by (simp add: join_def monad_fmap bind_bind)"], ["", "lemma join_return: \"join\\<cdot>(return\\<cdot>xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. join\\<cdot>(return\\<cdot>xs) = xs", "by (simp add: join_def)"], ["", "lemma join_fmap_return: \"join\\<cdot>(fmap\\<cdot>return\\<cdot>xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. join\\<cdot>(fmap\\<cdot>return\\<cdot>xs) = xs", "by (simp add: join_def monad_fmap eta_cfun bind_bind)"], ["", "lemma join_fmap_join: \"join\\<cdot>(fmap\\<cdot>join\\<cdot>xsss) = join\\<cdot>(join\\<cdot>xsss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. join\\<cdot>(fmap\\<cdot>join\\<cdot>xsss) = join\\<cdot>(join\\<cdot>xsss)", "by (simp add: join_def monad_fmap bind_bind)"], ["", "lemma bind_def2: \"m \\<bind> k = join\\<cdot>(fmap\\<cdot>k\\<cdot>m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> k = join\\<cdot>(fmap\\<cdot>k\\<cdot>m)", "by (simp add: join_def monad_fmap eta_cfun bind_bind)"], ["", "subsection \\<open>Equivalence of monad laws and fmap/join laws\\<close>"], ["", "lemma \"(return\\<cdot>x \\<bind> f) = (f\\<cdot>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return\\<cdot>x \\<bind> f = f\\<cdot>x", "by (simp only: bind_def2 fmap_return join_return)"], ["", "lemma \"(m \\<bind> return) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> return = m", "by (simp only: bind_def2 join_fmap_return)"], ["", "lemma \"((m \\<bind> f) \\<bind> g) = (m \\<bind> (\\<Lambda> x. f\\<cdot>x \\<bind> g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> f \\<bind> g = m \\<bind> (\\<Lambda> x. f\\<cdot>x \\<bind> g)", "apply (simp only: bind_def2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. join\\<cdot>(fmap\\<cdot>g\\<cdot>(join\\<cdot>(fmap\\<cdot>f\\<cdot>m))) =\n    join\\<cdot>\n    (fmap\\<cdot>\n     (\\<Lambda> x. join\\<cdot>(fmap\\<cdot>g\\<cdot>(f\\<cdot>x)))\\<cdot>\n     m)", "apply (subgoal_tac \"join\\<cdot>(fmap\\<cdot>g\\<cdot>(join\\<cdot>(fmap\\<cdot>f\\<cdot>m))) =\n    join\\<cdot>(fmap\\<cdot>join\\<cdot>(fmap\\<cdot>(fmap\\<cdot>g)\\<cdot>(fmap\\<cdot>f\\<cdot>m)))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. join\\<cdot>(fmap\\<cdot>g\\<cdot>(join\\<cdot>(fmap\\<cdot>f\\<cdot>m))) =\n    join\\<cdot>\n    (fmap\\<cdot>join\\<cdot>\n     (fmap\\<cdot>(fmap\\<cdot>g)\\<cdot>\n      (fmap\\<cdot>f\\<cdot>m))) \\<Longrightarrow>\n    join\\<cdot>(fmap\\<cdot>g\\<cdot>(join\\<cdot>(fmap\\<cdot>f\\<cdot>m))) =\n    join\\<cdot>\n    (fmap\\<cdot>\n     (\\<Lambda> x. join\\<cdot>(fmap\\<cdot>g\\<cdot>(f\\<cdot>x)))\\<cdot>\n     m)\n 2. join\\<cdot>(fmap\\<cdot>g\\<cdot>(join\\<cdot>(fmap\\<cdot>f\\<cdot>m))) =\n    join\\<cdot>\n    (fmap\\<cdot>join\\<cdot>\n     (fmap\\<cdot>(fmap\\<cdot>g)\\<cdot>(fmap\\<cdot>f\\<cdot>m)))", "apply (simp add: fmap_fmap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. join\\<cdot>(fmap\\<cdot>g\\<cdot>(join\\<cdot>(fmap\\<cdot>f\\<cdot>m))) =\n    join\\<cdot>\n    (fmap\\<cdot>join\\<cdot>\n     (fmap\\<cdot>(fmap\\<cdot>g)\\<cdot>(fmap\\<cdot>f\\<cdot>m)))", "apply (simp add: join_fmap_join join_fmap_fmap)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Simplification of coercions\\<close>"], ["", "text \\<open>We configure rewrite rules that push coercions inwards, and\nreduce them to coercions on simpler types.\\<close>"], ["", "lemma coerce_return [coerce_simp]:\n  \"COERCE('a\\<cdot>'m,'b\\<cdot>'m::monad)\\<cdot>(return\\<cdot>x) = return\\<cdot>(COERCE('a,'b)\\<cdot>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('a\\<cdot>'m, 'b\\<cdot>'m)\\<cdot>(return\\<cdot>x) =\n    return\\<cdot>(COERCE('a, 'b)\\<cdot>x)", "by (simp add: coerce_functor fmap_return)"], ["", "lemma coerce_bind [coerce_simp]:\n  fixes m :: \"'a\\<cdot>'m::monad\" and k :: \"'a \\<rightarrow> 'b\\<cdot>'m\"\n  shows \"COERCE('b\\<cdot>'m,'c\\<cdot>'m)\\<cdot>(m \\<bind> k) = m \\<bind> (\\<Lambda> x. COERCE('b\\<cdot>'m,'c\\<cdot>'m)\\<cdot>(k\\<cdot>x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('b\\<cdot>'m, 'c\\<cdot>'m)\\<cdot>(m \\<bind> k) =\n    m \\<bind>\n    (\\<Lambda> x. COERCE('b\\<cdot>'m, 'c\\<cdot>'m)\\<cdot>(k\\<cdot>x))", "by (simp add: coerce_functor fmap_bind)"], ["", "lemma bind_coerce [coerce_simp]:\n  fixes m :: \"'a\\<cdot>'m::monad\" and k :: \"'b \\<rightarrow> 'c\\<cdot>'m\"\n  shows \"COERCE('a\\<cdot>'m,'b\\<cdot>'m)\\<cdot>m \\<bind> k = m \\<bind> (\\<Lambda> x. k\\<cdot>(COERCE('a,'b)\\<cdot>x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COERCE('a\\<cdot>'m, 'b\\<cdot>'m)\\<cdot>m \\<bind> k =\n    m \\<bind> (\\<Lambda> x. k\\<cdot>(COERCE('a, 'b)\\<cdot>x))", "by (simp add: coerce_functor bind_fmap)"], ["", "end"]]}