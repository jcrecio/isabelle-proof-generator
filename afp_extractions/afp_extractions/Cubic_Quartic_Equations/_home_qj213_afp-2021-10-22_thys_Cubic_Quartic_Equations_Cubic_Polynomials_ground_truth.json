{"file_name": "/home/qj213/afp-2021-10-22/thys/Cubic_Quartic_Equations/Cubic_Polynomials.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Cubic_Quartic_Equations", "problem_names": ["lemma complex_of_real_code[code_unfold]: \"complex_of_real = (\\<lambda> x. Complex x 0)\"", "lemma solve_depressed_cubic_Cardano_real: \n  assumes \"solve_depressed_cubic_Cardano_real e f = Some y\" \n  shows \"{y. y^3 + e * y + f = 0} = {y}\"", "lemma solve_depressed_cubic_complex_code[code]: \n  \"solve_depressed_cubic_complex e f = (let\n          ys = (if e = 0 then all_croots 3 (- f) else (let\n            f2 = f / 2;\n            u = - f2 + csqrt (f2^2 + e ^ 3 / 27);\n            zs = all_croots 3 u \n            in map (\\<lambda> z. z - e / (3 * z)) zs))\n      in remdups ys)\"", "lemma solve_depressed_cubic_complex: \"y \\<in> set (solve_depressed_cubic_complex e f) \n  \\<longleftrightarrow> (y^3 + e * y + f = 0)\"", "lemma solve_depressed_cubic_real_code[code]: \"solve_depressed_cubic_real e f =\n  (if e = 0 then [root 3 (-f)] else \n   let v = e ^ 3 / 27; \n       f2 = f / 2;\n       f2v = f2^2 + v in\n   if f2v > 0 then \n     let u = -f2 + sqrt f2v;\n         rt = root 3 u\n      in [rt - e / (3 * rt)]\n  else \n  let ce3 = of_real e / 3; \n      u = - of_real f2 + csqrt (of_real f2v) in\n   map Re (remdups (map (\\<lambda>rt. rt - ce3 / rt) (all_croots 3 u))))\"", "lemma solve_depressed_cubic_real: \"y \\<in> set (solve_depressed_cubic_real e f) \n  \\<longleftrightarrow> (y^3 + e * y + f = 0)\"", "lemma degree3_coeffs: \"degree p = 3 \\<Longrightarrow>\n  \\<exists> a b c d. p = [: d, c, b, a :] \\<and> a \\<noteq> 0\"", "lemma roots3_generic: assumes deg: \"degree p = 3\" \n  and solver: \"\\<And> e f y. y \\<in> set (depressed_solver e f) \\<longleftrightarrow> y^3 + e * y + f = 0\" \n  shows \"set (roots3_generic depressed_solver p) = {x. poly p x = 0}\"", "lemma croots3: assumes deg: \"degree p = 3\" \n  shows \"set (croots3 p) = { x. poly p x = 0}\"", "lemma rroots3: assumes deg: \"degree p = 3\" \n  shows \"set (rroots3 p) = { x. poly p x = 0}\""], "translations": [["", "lemma complex_of_real_code[code_unfold]: \"complex_of_real = (\\<lambda> x. Complex x 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cor = (\\<lambda>x. Complex x 0)", "by (intro ext, auto simp: complex_eq_iff)"], ["", "text \\<open>The real case where a result is only delivered if the discriminant is negative\\<close>"], ["", "definition solve_depressed_cubic_Cardano_real :: \"real \\<Rightarrow> real \\<Rightarrow> real option\" where\n  \"solve_depressed_cubic_Cardano_real e f = (\n    if e = 0 then Some (root 3 (-f)) else\n     let v = - (e ^ 3 / 27) in\n     case rroots2 [:v,f,1:] of \n       [u,_] \\<Rightarrow> let rt = root 3 u in Some (rt - e / (3 * rt))\n     | _ \\<Rightarrow> None)\""], ["", "lemma solve_depressed_cubic_Cardano_real: \n  assumes \"solve_depressed_cubic_Cardano_real e f = Some y\" \n  shows \"{y. y^3 + e * y + f = 0} = {y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. y ^ 3 + e * y + f = 0} = {y}", "proof (cases \"e = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. e = 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}\n 2. e \\<noteq> 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}", "case True"], ["proof (state)\nthis:\n  e = 0\n\ngoal (2 subgoals):\n 1. e = 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}\n 2. e \\<noteq> 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}", "have \"{y. y^3 + e * y + f = 0} = {y. y^3 = -f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. y ^ 3 + e * y + f = 0} = {y. y ^ 3 = - f}", "unfolding True"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. y ^ 3 + 0 * y + f = 0} = {y. y ^ 3 = - f}", "by (auto simp add: field_simps)"], ["proof (state)\nthis:\n  {y. y ^ 3 + e * y + f = 0} = {y. y ^ 3 = - f}\n\ngoal (2 subgoals):\n 1. e = 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}\n 2. e \\<noteq> 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}", "also"], ["proof (state)\nthis:\n  {y. y ^ 3 + e * y + f = 0} = {y. y ^ 3 = - f}\n\ngoal (2 subgoals):\n 1. e = 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}\n 2. e \\<noteq> 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}", "have \"\\<dots> = {root 3 (-f)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. y ^ 3 = - f} = {root 3 (- f)}", "using odd_real_root_unique[of 3 _ \"-f\"] odd_real_root_pow[of 3]"], ["proof (prove)\nusing this:\n  \\<lbrakk>odd 3; ?y ^ 3 = - f\\<rbrakk> \\<Longrightarrow> root 3 (- f) = ?y\n  odd 3 \\<Longrightarrow> root 3 ?x ^ 3 = ?x\n\ngoal (1 subgoal):\n 1. {y. y ^ 3 = - f} = {root 3 (- f)}", "by auto"], ["proof (state)\nthis:\n  {y. y ^ 3 = - f} = {root 3 (- f)}\n\ngoal (2 subgoals):\n 1. e = 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}\n 2. e \\<noteq> 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}", "also"], ["proof (state)\nthis:\n  {y. y ^ 3 = - f} = {root 3 (- f)}\n\ngoal (2 subgoals):\n 1. e = 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}\n 2. e \\<noteq> 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}", "have \"root 3 (-f) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. root 3 (- f) = y", "using assms"], ["proof (prove)\nusing this:\n  solve_depressed_cubic_Cardano_real e f = Some y\n\ngoal (1 subgoal):\n 1. root 3 (- f) = y", "unfolding True solve_depressed_cubic_Cardano_real_def"], ["proof (prove)\nusing this:\n  (if 0 = 0 then Some (root 3 (- f))\n   else let v = - (0 ^ 3 / 27)\n        in case rroots2 [:v, f, 1:] of [] \\<Rightarrow> None\n           | [u] \\<Rightarrow> None\n           | [u, xa] \\<Rightarrow>\n               let rt = root 3 u in Some (rt - 0 / (3 * rt))\n           | u # xa # ab # x \\<Rightarrow> Map.empty x) =\n  Some y\n\ngoal (1 subgoal):\n 1. root 3 (- f) = y", "by auto"], ["proof (state)\nthis:\n  root 3 (- f) = y\n\ngoal (2 subgoals):\n 1. e = 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}\n 2. e \\<noteq> 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}", "finally"], ["proof (chain)\npicking this:\n  {y. y ^ 3 + e * y + f = 0} = {y}", "show ?thesis"], ["proof (prove)\nusing this:\n  {y. y ^ 3 + e * y + f = 0} = {y}\n\ngoal (1 subgoal):\n 1. {y. y ^ 3 + e * y + f = 0} = {y}", "."], ["proof (state)\nthis:\n  {y. y ^ 3 + e * y + f = 0} = {y}\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}", "case False"], ["proof (state)\nthis:\n  e \\<noteq> 0\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}", "define v where \"v = - (e ^ 3 / 27)\""], ["proof (state)\nthis:\n  v = - (e ^ 3 / 27)\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}", "note * = assms[unfolded solve_depressed_cubic_Cardano_real_def Let_def, folded v_def]"], ["proof (state)\nthis:\n  (if e = 0 then Some (root 3 (- f))\n   else case rroots2 [:v, f, 1:] of [] \\<Rightarrow> None\n        | [u] \\<Rightarrow> None\n        | [u, xa] \\<Rightarrow> Some (root 3 u - e / (3 * root 3 u))\n        | u # xa # ab # x \\<Rightarrow> Map.empty x) =\n  Some y\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}", "let ?rr = \"rroots2 [:v,f,1:]\""], ["proof (state)\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}", "from * False"], ["proof (chain)\npicking this:\n  (if e = 0 then Some (root 3 (- f))\n   else case rroots2 [:v, f, 1:] of [] \\<Rightarrow> None\n        | [u] \\<Rightarrow> None\n        | [u, xa] \\<Rightarrow> Some (root 3 u - e / (3 * root 3 u))\n        | u # xa # ab # x \\<Rightarrow> Map.empty x) =\n  Some y\n  e \\<noteq> 0", "obtain u u' where rr: \"?rr = [u,u']\""], ["proof (prove)\nusing this:\n  (if e = 0 then Some (root 3 (- f))\n   else case rroots2 [:v, f, 1:] of [] \\<Rightarrow> None\n        | [u] \\<Rightarrow> None\n        | [u, xa] \\<Rightarrow> Some (root 3 u - e / (3 * root 3 u))\n        | u # xa # ab # x \\<Rightarrow> Map.empty x) =\n  Some y\n  e \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>u u'.\n        rroots2 [:v, f, 1:] = [u, u'] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?rr; cases \"tl ?rr\"; cases \"tl (tl ?rr)\"; auto split: if_splits)"], ["proof (state)\nthis:\n  rroots2 [:v, f, 1:] = [u, u']\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}", "from *[unfolded rr list.simps] False"], ["proof (chain)\npicking this:\n  (if e = 0 then Some (root 3 (- f))\n   else Some (root 3 u - e / (3 * root 3 u))) =\n  Some y\n  e \\<noteq> 0", "have y: \"y = root 3 u - e / (3 * root 3 u)\""], ["proof (prove)\nusing this:\n  (if e = 0 then Some (root 3 (- f))\n   else Some (root 3 u - e / (3 * root 3 u))) =\n  Some y\n  e \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y = root 3 u - e / (3 * root 3 u)", "by auto"], ["proof (state)\nthis:\n  y = root 3 u - e / (3 * root 3 u)\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}", "have \"u \\<in> set (rroots2 [:v,f,1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> set (rroots2 [:v, f, 1:])", "unfolding rr"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> set [u, u']", "by auto"], ["proof (state)\nthis:\n  u \\<in> set (rroots2 [:v, f, 1:])\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}", "also"], ["proof (state)\nthis:\n  u \\<in> set (rroots2 [:v, f, 1:])\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}", "have \"set (rroots2 [:v,f,1:]) = {u. poly [:v,f,1:] u = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rroots2 [:v, f, 1:]) = {u. poly [:v, f, 1:] u = 0}", "by (subst rroots2, auto)"], ["proof (state)\nthis:\n  set (rroots2 [:v, f, 1:]) = {u. poly [:v, f, 1:] u = 0}\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}", "finally"], ["proof (chain)\npicking this:\n  u \\<in> {u. poly [:v, f, 1:] u = 0}", "have u: \"u^2 + f * u + v = 0\""], ["proof (prove)\nusing this:\n  u \\<in> {u. poly [:v, f, 1:] u = 0}\n\ngoal (1 subgoal):\n 1. u\\<^sup>2 + f * u + v = 0", "by (simp add: field_simps power2_eq_square)"], ["proof (state)\nthis:\n  u\\<^sup>2 + f * u + v = 0\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}", "note Cardano = solve_cubic_depressed_Cardano_real[OF False v_def u]"], ["proof (state)\nthis:\n  (root 3 u - e / (3 * root 3 u)) ^ 3 +\n  e * (root 3 u - e / (3 * root 3 u)) +\n  f =\n  0\n  \\<lbrakk>discriminant_cubic_depressed e f \\<noteq> 0;\n   ?y ^ 3 + e * ?y + f = 0\\<rbrakk>\n  \\<Longrightarrow> ?y = root 3 u - e / (3 * root 3 u)\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}", "have 2: \"2 = Suc (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 = Suc (Suc 0)", "by simp"], ["proof (state)\nthis:\n  2 = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}", "from rr"], ["proof (chain)\npicking this:\n  rroots2 [:v, f, 1:] = [u, u']", "have 0: \"f\\<^sup>2 - 4 * v \\<noteq> 0\""], ["proof (prove)\nusing this:\n  rroots2 [:v, f, 1:] = [u, u']\n\ngoal (1 subgoal):\n 1. f\\<^sup>2 - 4 * v \\<noteq> 0", "unfolding rroots2_def Let_def"], ["proof (prove)\nusing this:\n  (if (poly.coeff [:v, f, 1:] 1 / (2 * poly.coeff [:v, f, 1:] 2))\\<^sup>2 -\n      poly.coeff [:v, f, 1:] 0 / poly.coeff [:v, f, 1:] 2 =\n      0\n   then [- (poly.coeff [:v, f, 1:] 1 / (2 * poly.coeff [:v, f, 1:] 2))]\n   else if (poly.coeff [:v, f, 1:] 1 /\n            (2 * poly.coeff [:v, f, 1:] 2))\\<^sup>2 -\n           poly.coeff [:v, f, 1:] 0 / poly.coeff [:v, f, 1:] 2\n           < 0\n        then []\n        else [- (poly.coeff [:v, f, 1:] 1 /\n                 (2 * poly.coeff [:v, f, 1:] 2)) +\n              sqrt\n               ((poly.coeff [:v, f, 1:] 1 /\n                 (2 * poly.coeff [:v, f, 1:] 2))\\<^sup>2 -\n                poly.coeff [:v, f, 1:] 0 / poly.coeff [:v, f, 1:] 2),\n              - (poly.coeff [:v, f, 1:] 1 /\n                 (2 * poly.coeff [:v, f, 1:] 2)) -\n              sqrt\n               ((poly.coeff [:v, f, 1:] 1 /\n                 (2 * poly.coeff [:v, f, 1:] 2))\\<^sup>2 -\n                poly.coeff [:v, f, 1:] 0 / poly.coeff [:v, f, 1:] 2)]) =\n  [u, u']\n\ngoal (1 subgoal):\n 1. f\\<^sup>2 - 4 * v \\<noteq> 0", "by (auto split: if_splits simp: 2)"], ["proof (state)\nthis:\n  f\\<^sup>2 - 4 * v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}", "hence 0: \"discriminant_cubic_depressed e f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  f\\<^sup>2 - 4 * v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. discriminant_cubic_depressed e f \\<noteq> 0", "unfolding discriminant_cubic_depressed_def v_def"], ["proof (prove)\nusing this:\n  f\\<^sup>2 - 4 * - (e ^ 3 / 27) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. - (4 * e ^ 3 + 27 * f\\<^sup>2) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  discriminant_cubic_depressed e f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow> {y. y ^ 3 + e * y + f = 0} = {y}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. y ^ 3 + e * y + f = 0} = {y}", "using Cardano(1) Cardano(2)[OF 0]"], ["proof (prove)\nusing this:\n  (root 3 u - e / (3 * root 3 u)) ^ 3 +\n  e * (root 3 u - e / (3 * root 3 u)) +\n  f =\n  0\n  ?y ^ 3 + e * ?y + f = 0 \\<Longrightarrow>\n  ?y = root 3 u - e / (3 * root 3 u)\n\ngoal (1 subgoal):\n 1. {y. y ^ 3 + e * y + f = 0} = {y}", "unfolding y[symmetric]"], ["proof (prove)\nusing this:\n  y ^ 3 + e * y + f = 0\n  ?y ^ 3 + e * ?y + f = 0 \\<Longrightarrow> ?y = y\n\ngoal (1 subgoal):\n 1. {y. y ^ 3 + e * y + f = 0} = {y}", "by blast"], ["proof (state)\nthis:\n  {y. y ^ 3 + e * y + f = 0} = {y}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The complex case\\<close>"], ["", "definition solve_depressed_cubic_complex :: \"complex \\<Rightarrow> complex \\<Rightarrow> complex list\" where\n  \"solve_depressed_cubic_complex e f = (let\n          ys = (if e = 0 then all_croots 3 (- f) else (let\n       u = hd (croots2 [: - (e ^ 3 / 27) ,f,1:]); \n       zs = all_croots 3 u \n       in map (\\<lambda> z. z - e / (3 * z)) zs))\n      in remdups ys)\""], ["", "lemma solve_depressed_cubic_complex_code[code]: \n  \"solve_depressed_cubic_complex e f = (let\n          ys = (if e = 0 then all_croots 3 (- f) else (let\n            f2 = f / 2;\n            u = - f2 + csqrt (f2^2 + e ^ 3 / 27);\n            zs = all_croots 3 u \n            in map (\\<lambda> z. z - e / (3 * z)) zs))\n      in remdups ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solve_depressed_cubic_complex e f =\n    Let (if e = 0 then all_croots 3 (- f)\n         else let f2 = f / 2; u = - f2 + csqrt (f2\\<^sup>2 + e ^ 3 / 27)\n              in Let (all_croots 3 u) (map (\\<lambda>z. z - e / (3 * z))))\n     remdups", "unfolding solve_depressed_cubic_complex_def Let_def croots2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. remdups\n     (if e = 0 then all_croots 3 (- f)\n      else map (\\<lambda>z. z - e / (3 * z))\n            (all_croots 3\n              (hd (remdups\n                    [- (poly.coeff [:- (e ^ 3 / 27), f, 1:] 1 /\n                        (2 * poly.coeff [:- (e ^ 3 / 27), f, 1:] 2)) +\n                     csqrt\n                      ((poly.coeff [:- (e ^ 3 / 27), f, 1:] 1 /\n                        (2 *\n                         poly.coeff [:- (e ^ 3 / 27), f, 1:] 2))\\<^sup>2 -\n                       poly.coeff [:- (e ^ 3 / 27), f, 1:] 0 /\n                       poly.coeff [:- (e ^ 3 / 27), f, 1:] 2),\n                     - (poly.coeff [:- (e ^ 3 / 27), f, 1:] 1 /\n                        (2 * poly.coeff [:- (e ^ 3 / 27), f, 1:] 2)) -\n                     csqrt\n                      ((poly.coeff [:- (e ^ 3 / 27), f, 1:] 1 /\n                        (2 *\n                         poly.coeff [:- (e ^ 3 / 27), f, 1:] 2))\\<^sup>2 -\n                       poly.coeff [:- (e ^ 3 / 27), f, 1:] 0 /\n                       poly.coeff [:- (e ^ 3 / 27), f, 1:] 2)])))) =\n    remdups\n     (if e = 0 then all_croots 3 (- f)\n      else map (\\<lambda>z. z - e / (3 * z))\n            (all_croots 3\n              (- (f / 2) + csqrt ((f / 2)\\<^sup>2 + e ^ 3 / 27))))", "by (simp add: numeral_2_eq_2)"], ["", "lemma solve_depressed_cubic_complex: \"y \\<in> set (solve_depressed_cubic_complex e f) \n  \\<longleftrightarrow> (y^3 + e * y + f = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<in> set (solve_depressed_cubic_complex e f)) =\n    (y ^ 3 + e * y + f = 0)", "proof (cases \"e = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. e = 0 \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_complex e f)) =\n    (y ^ 3 + e * y + f = 0)\n 2. e \\<noteq> 0 \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_complex e f)) =\n    (y ^ 3 + e * y + f = 0)", "case True"], ["proof (state)\nthis:\n  e = 0\n\ngoal (2 subgoals):\n 1. e = 0 \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_complex e f)) =\n    (y ^ 3 + e * y + f = 0)\n 2. e \\<noteq> 0 \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_complex e f)) =\n    (y ^ 3 + e * y + f = 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  e = 0\n\ngoal (1 subgoal):\n 1. (y \\<in> set (solve_depressed_cubic_complex e f)) =\n    (y ^ 3 + e * y + f = 0)", "by (simp add: solve_depressed_cubic_complex_def Let_def all_croots eq_neg_iff_add_eq_0)"], ["proof (state)\nthis:\n  (y \\<in> set (solve_depressed_cubic_complex e f)) =\n  (y ^ 3 + e * y + f = 0)\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_complex e f)) =\n    (y ^ 3 + e * y + f = 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_complex e f)) =\n    (y ^ 3 + e * y + f = 0)", "case e0: False"], ["proof (state)\nthis:\n  e \\<noteq> 0\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_complex e f)) =\n    (y ^ 3 + e * y + f = 0)", "hence id: \"(if e = 0 then x else y) = y\" for x y :: \"complex list\""], ["proof (prove)\nusing this:\n  e \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if e = 0 then x else y) = y", "by simp"], ["proof (state)\nthis:\n  (if e = 0 then ?x else ?y) = ?y\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_complex e f)) =\n    (y ^ 3 + e * y + f = 0)", "define v where \"v = - (e ^ 3 / 27)\""], ["proof (state)\nthis:\n  v = - (e ^ 3 / 27)\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_complex e f)) =\n    (y ^ 3 + e * y + f = 0)", "define p where \"p = [:v, f, 1:]\""], ["proof (state)\nthis:\n  p = [:v, f, 1:]\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_complex e f)) =\n    (y ^ 3 + e * y + f = 0)", "have p2: \"degree p = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p = 2", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree [:v, f, 1:] = 2", "by auto"], ["proof (state)\nthis:\n  degree p = 2\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_complex e f)) =\n    (y ^ 3 + e * y + f = 0)", "let ?u = \"hd (croots2 p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_complex e f)) =\n    (y ^ 3 + e * y + f = 0)", "define u where \"u = ?u\""], ["proof (state)\nthis:\n  u = hd (croots2 p)\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_complex e f)) =\n    (y ^ 3 + e * y + f = 0)", "have \"u \\<in> set (croots2 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> set (croots2 p)", "unfolding croots2_def Let_def u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (remdups\n         [- (poly.coeff p 1 / (2 * poly.coeff p 2)) +\n          csqrt\n           ((poly.coeff p 1 / (2 * poly.coeff p 2))\\<^sup>2 -\n            poly.coeff p 0 / poly.coeff p 2),\n          - (poly.coeff p 1 / (2 * poly.coeff p 2)) -\n          csqrt\n           ((poly.coeff p 1 / (2 * poly.coeff p 2))\\<^sup>2 -\n            poly.coeff p 0 / poly.coeff p 2)])\n    \\<in> set (remdups\n                [- (poly.coeff p 1 / (2 * poly.coeff p 2)) +\n                 csqrt\n                  ((poly.coeff p 1 / (2 * poly.coeff p 2))\\<^sup>2 -\n                   poly.coeff p 0 / poly.coeff p 2),\n                 - (poly.coeff p 1 / (2 * poly.coeff p 2)) -\n                 csqrt\n                  ((poly.coeff p 1 / (2 * poly.coeff p 2))\\<^sup>2 -\n                   poly.coeff p 0 / poly.coeff p 2)])", "by auto"], ["proof (state)\nthis:\n  u \\<in> set (croots2 p)\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_complex e f)) =\n    (y ^ 3 + e * y + f = 0)", "with croots2[OF p2]"], ["proof (chain)\npicking this:\n  {x. poly p x = 0} = set (croots2 p)\n  u \\<in> set (croots2 p)", "have \"poly p u = 0\""], ["proof (prove)\nusing this:\n  {x. poly p x = 0} = set (croots2 p)\n  u \\<in> set (croots2 p)\n\ngoal (1 subgoal):\n 1. poly p u = 0", "by auto"], ["proof (state)\nthis:\n  poly p u = 0\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_complex e f)) =\n    (y ^ 3 + e * y + f = 0)", "hence u: \"u^2 + f * u + v = 0\""], ["proof (prove)\nusing this:\n  poly p u = 0\n\ngoal (1 subgoal):\n 1. u\\<^sup>2 + f * u + v = 0", "unfolding p_def"], ["proof (prove)\nusing this:\n  poly [:v, f, 1:] u = 0\n\ngoal (1 subgoal):\n 1. u\\<^sup>2 + f * u + v = 0", "by (simp add: field_simps power2_eq_square)"], ["proof (state)\nthis:\n  u\\<^sup>2 + f * u + v = 0\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_complex e f)) =\n    (y ^ 3 + e * y + f = 0)", "note cube_roots = all_croots[of 3, simplified]"], ["proof (state)\nthis:\n  set (all_croots 3 ?x) = {y. y ^ 3 = ?x}\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_complex e f)) =\n    (y ^ 3 + e * y + f = 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<in> set (solve_depressed_cubic_complex e f)) =\n    (y ^ 3 + e * y + f = 0)", "unfolding solve_depressed_cubic_complex_def Let_def set_remdups set_map id cube_roots"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<in> (\\<lambda>z. z - e / (3 * z)) `\n             {y. y ^ 3 = hd (croots2 [:- (e ^ 3 / 27), f, 1:])}) =\n    (y ^ 3 + e * y + f = 0)", "unfolding v_def[symmetric] p_def[symmetric] set_concat set_map\n      u_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<in> (\\<lambda>z. z - e / (3 * z)) ` {y. y ^ 3 = u}) =\n    (y ^ 3 + e * y + f = 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (y \\<in> (\\<lambda>z. z - e / (3 * z)) ` {y. y ^ 3 = u}) =\n    (y ^ 3 + e * y + f = 0)", "have p: \"{x. poly p x = 0} = {u. u^2 + f * u + v = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly p x = 0} = {u. u\\<^sup>2 + f * u + v = 0}", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. poly [:v, f, 1:] x = 0} = {u. u\\<^sup>2 + f * u + v = 0}", "by (auto simp: field_simps power2_eq_square)"], ["proof (state)\nthis:\n  {x. poly p x = 0} = {u. u\\<^sup>2 + f * u + v = 0}\n\ngoal (1 subgoal):\n 1. (y \\<in> (\\<lambda>z. z - e / (3 * z)) ` {y. y ^ 3 = u}) =\n    (y ^ 3 + e * y + f = 0)", "have cube: \"\\<Union> (set ` all_croots 3 ` {x. poly p x = 0}) = {z. \\<exists> u. u\\<^sup>2 + f * u + v = 0 \\<and> z ^ 3 = u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set ` all_croots 3 ` {x. poly p x = 0}) =\n    {z. \\<exists>u. u\\<^sup>2 + f * u + v = 0 \\<and> z ^ 3 = u}", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set ` all_croots 3 ` {u. u\\<^sup>2 + f * u + v = 0}) =\n    {z. \\<exists>u. u\\<^sup>2 + f * u + v = 0 \\<and> z ^ 3 = u}", "by (auto simp: cube_roots)"], ["proof (state)\nthis:\n  \\<Union> (set ` all_croots 3 ` {x. poly p x = 0}) =\n  {z. \\<exists>u. u\\<^sup>2 + f * u + v = 0 \\<and> z ^ 3 = u}\n\ngoal (1 subgoal):\n 1. (y \\<in> (\\<lambda>z. z - e / (3 * z)) ` {y. y ^ 3 = u}) =\n    (y ^ 3 + e * y + f = 0)", "show \"(y \\<in> (\\<lambda>z. z - e / (3 * z)) ` {y. y ^ 3 = u}) = (y ^ 3 + e * y + f = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<in> (\\<lambda>z. z - e / (3 * z)) ` {y. y ^ 3 = u}) =\n    (y ^ 3 + e * y + f = 0)", "using solve_cubic_depressed_Cardano_complex[OF e0 v_def u] cube"], ["proof (prove)\nusing this:\n  (?y ^ 3 + e * ?y + f = 0) =\n  (\\<exists>z. z ^ 3 = u \\<and> ?y = z - e / (3 * z))\n  \\<Union> (set ` all_croots 3 ` {x. poly p x = 0}) =\n  {z. \\<exists>u. u\\<^sup>2 + f * u + v = 0 \\<and> z ^ 3 = u}\n\ngoal (1 subgoal):\n 1. (y \\<in> (\\<lambda>z. z - e / (3 * z)) ` {y. y ^ 3 = u}) =\n    (y ^ 3 + e * y + f = 0)", "by blast"], ["proof (state)\nthis:\n  (y \\<in> (\\<lambda>z. z - e / (3 * z)) ` {y. y ^ 3 = u}) =\n  (y ^ 3 + e * y + f = 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (y \\<in> set (solve_depressed_cubic_complex e f)) =\n  (y ^ 3 + e * y + f = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>For the general real case, we first try Cardano with negative discrimiant and only if it is not applicable,\n   then we go for the calculation using complex numbers. Note that for for non-negative delta \n   no filter is required to identify the real roots from the list of complex roots, since in that case we \n   already know that all roots are real.\\<close>"], ["", "definition solve_depressed_cubic_real :: \"real \\<Rightarrow> real \\<Rightarrow> real list\" where\n  \"solve_depressed_cubic_real e f = (case solve_depressed_cubic_Cardano_real e f \n      of Some y \\<Rightarrow> [y] \n       | None \\<Rightarrow> map Re (solve_depressed_cubic_complex (of_real e) (of_real f)))\""], ["", "lemma solve_depressed_cubic_real_code[code]: \"solve_depressed_cubic_real e f =\n  (if e = 0 then [root 3 (-f)] else \n   let v = e ^ 3 / 27; \n       f2 = f / 2;\n       f2v = f2^2 + v in\n   if f2v > 0 then \n     let u = -f2 + sqrt f2v;\n         rt = root 3 u\n      in [rt - e / (3 * rt)]\n  else \n  let ce3 = of_real e / 3; \n      u = - of_real f2 + csqrt (of_real f2v) in\n   map Re (remdups (map (\\<lambda>rt. rt - ce3 / rt) (all_croots 3 u))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solve_depressed_cubic_real e f =\n    (if e = 0 then [root 3 (- f)]\n     else let v = e ^ 3 / 27; f2 = f / 2; f2v = f2\\<^sup>2 + v\n          in if 0 < f2v\n             then let u = - f2 + sqrt f2v; rt = root 3 u\n                  in [rt - e / (3 * rt)]\n             else let ce3 = cor e / 3; u = - cor f2 + csqrt (cor f2v)\n                  in map Re\n                      (remdups\n                        (map (\\<lambda>rt. rt - ce3 / rt)\n                          (all_croots 3 u))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. solve_depressed_cubic_real e f =\n    (if e = 0 then [root 3 (- f)]\n     else let v = e ^ 3 / 27; f2 = f / 2; f2v = f2\\<^sup>2 + v\n          in if 0 < f2v\n             then let u = - f2 + sqrt f2v; rt = root 3 u\n                  in [rt - e / (3 * rt)]\n             else let ce3 = cor e / 3; u = - cor f2 + csqrt (cor f2v)\n                  in map Re\n                      (remdups\n                        (map (\\<lambda>rt. rt - ce3 / rt)\n                          (all_croots 3 u))))", "have id: \"rroots2 [:v, f, 1:] = (let \n     f2 = f / 2;\n     bac = f2\\<^sup>2 - v in \n     if bac = 0 then [- f2] else \n     if bac < 0 then [] else let e = sqrt bac in [- f2 + e, - f2 - e])\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. rroots2 [:v, f, 1:] =\n    (let f2 = f / 2; bac = f2\\<^sup>2 - v\n     in if bac = 0 then [- f2]\n        else if bac < 0 then []\n             else let e = sqrt bac in [- f2 + e, - f2 - e])", "unfolding rroots2_def Let_def numeral_2_eq_2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (poly.coeff [:v, f, 1:] 1 /\n         (2 * poly.coeff [:v, f, 1:] (Suc (Suc 0)))) ^\n        Suc (Suc 0) -\n        poly.coeff [:v, f, 1:] 0 / poly.coeff [:v, f, 1:] (Suc (Suc 0)) =\n        0\n     then [- (poly.coeff [:v, f, 1:] 1 /\n              (2 * poly.coeff [:v, f, 1:] (Suc (Suc 0))))]\n     else if (poly.coeff [:v, f, 1:] 1 /\n              (2 * poly.coeff [:v, f, 1:] (Suc (Suc 0)))) ^\n             Suc (Suc 0) -\n             poly.coeff [:v, f, 1:] 0 / poly.coeff [:v, f, 1:] (Suc (Suc 0))\n             < 0\n          then []\n          else [- (poly.coeff [:v, f, 1:] 1 /\n                   (2 * poly.coeff [:v, f, 1:] (Suc (Suc 0)))) +\n                sqrt\n                 ((poly.coeff [:v, f, 1:] 1 /\n                   (2 * poly.coeff [:v, f, 1:] (Suc (Suc 0)))) ^\n                  Suc (Suc 0) -\n                  poly.coeff [:v, f, 1:] 0 /\n                  poly.coeff [:v, f, 1:] (Suc (Suc 0))),\n                - (poly.coeff [:v, f, 1:] 1 /\n                   (2 * poly.coeff [:v, f, 1:] (Suc (Suc 0)))) -\n                sqrt\n                 ((poly.coeff [:v, f, 1:] 1 /\n                   (2 * poly.coeff [:v, f, 1:] (Suc (Suc 0)))) ^\n                  Suc (Suc 0) -\n                  poly.coeff [:v, f, 1:] 0 /\n                  poly.coeff [:v, f, 1:] (Suc (Suc 0)))]) =\n    (if (f / 2) ^ Suc (Suc 0) - v = 0 then [- (f / 2)]\n     else if (f / 2) ^ Suc (Suc 0) - v < 0 then []\n          else [- (f / 2) + sqrt ((f / 2) ^ Suc (Suc 0) - v),\n                - (f / 2) - sqrt ((f / 2) ^ Suc (Suc 0) - v)])", "by auto"], ["proof (state)\nthis:\n  rroots2 [:?v, f, 1:] =\n  (let f2 = f / 2; bac = f2\\<^sup>2 - ?v\n   in if bac = 0 then [- f2]\n      else if bac < 0 then [] else let e = sqrt bac in [- f2 + e, - f2 - e])\n\ngoal (1 subgoal):\n 1. solve_depressed_cubic_real e f =\n    (if e = 0 then [root 3 (- f)]\n     else let v = e ^ 3 / 27; f2 = f / 2; f2v = f2\\<^sup>2 + v\n          in if 0 < f2v\n             then let u = - f2 + sqrt f2v; rt = root 3 u\n                  in [rt - e / (3 * rt)]\n             else let ce3 = cor e / 3; u = - cor f2 + csqrt (cor f2v)\n                  in map Re\n                      (remdups\n                        (map (\\<lambda>rt. rt - ce3 / rt)\n                          (all_croots 3 u))))", "define foo :: \"real \\<Rightarrow> real \\<Rightarrow> real option\" where \n    \"foo f2v f2 = (case (if f2v = 0 then [- f2] else []) of [] \\<Rightarrow> None | _ \\<Rightarrow> None)\" \n    for f2v f2"], ["proof (state)\nthis:\n  foo ?f2v ?f2.0 =\n  (case if ?f2v = 0 then [- ?f2.0] else [] of [] \\<Rightarrow> None\n   | a # x \\<Rightarrow> Map.empty x)\n\ngoal (1 subgoal):\n 1. solve_depressed_cubic_real e f =\n    (if e = 0 then [root 3 (- f)]\n     else let v = e ^ 3 / 27; f2 = f / 2; f2v = f2\\<^sup>2 + v\n          in if 0 < f2v\n             then let u = - f2 + sqrt f2v; rt = root 3 u\n                  in [rt - e / (3 * rt)]\n             else let ce3 = cor e / 3; u = - cor f2 + csqrt (cor f2v)\n                  in map Re\n                      (remdups\n                        (map (\\<lambda>rt. rt - ce3 / rt)\n                          (all_croots 3 u))))", "have \"solve_depressed_cubic_real e f = (if e = 0 then [root 3 (-f)] else \n   let v = e ^ 3 / 27; \n       f2 = f / 2;\n       f2v = f2\\<^sup>2 + v in\n   if f2v > 0 then \n     let u = -f2 + sqrt f2v;\n         rt = root 3 u\n      in [rt - e / (3 * rt)]\n  else \n  (case foo f2v f2 of\n     None \\<Rightarrow> let u = - cor f2 + csqrt (cor f2v) in\n   map Re\n    (remdups (map (\\<lambda>z. z - cor e / (3 * z)) (all_croots 3 u)))\n   | Some y \\<Rightarrow> []))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. solve_depressed_cubic_real e f =\n    (if e = 0 then [root 3 (- f)]\n     else let v = e ^ 3 / 27; f2 = f / 2; f2v = f2\\<^sup>2 + v\n          in if 0 < f2v\n             then let u = - f2 + sqrt f2v; rt = root 3 u\n                  in [rt - e / (3 * rt)]\n             else case foo f2v f2 of\n                  None \\<Rightarrow>\n                    let u = - cor f2 + csqrt (cor f2v)\n                    in map Re\n                        (remdups\n                          (map (\\<lambda>z. z - cor e / (3 * z))\n                            (all_croots 3 u)))\n                  | Some y \\<Rightarrow> [])", "unfolding solve_depressed_cubic_real_def solve_depressed_cubic_Cardano_real_def \n      solve_depressed_cubic_complex_code\n      Let_def id foo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case if e = 0 then Some (root 3 (- f))\n          else case if (f / 2)\\<^sup>2 - - (e ^ 3 / 27) = 0 then [- (f / 2)]\n                    else if (f / 2)\\<^sup>2 - - (e ^ 3 / 27) < 0 then []\n                         else [- (f / 2) +\n                               sqrt ((f / 2)\\<^sup>2 - - (e ^ 3 / 27)),\n                               - (f / 2) -\n                               sqrt ((f / 2)\\<^sup>2 - - (e ^ 3 / 27))] of\n               [] \\<Rightarrow> None | [u] \\<Rightarrow> None\n               | [u, xa] \\<Rightarrow> Some (root 3 u - e / (3 * root 3 u))\n               | u # xa # ab # x \\<Rightarrow> Map.empty x of\n     None \\<Rightarrow>\n       map Re\n        (remdups\n          (if cor e = 0 then all_croots 3 (- cor f)\n           else map (\\<lambda>z. z - cor e / (3 * z))\n                 (all_croots 3\n                   (- (cor f / 2) +\n                    csqrt ((cor f / 2)\\<^sup>2 + cor e ^ 3 / 27)))))\n     | Some y \\<Rightarrow> [y]) =\n    (if e = 0 then [root 3 (- f)]\n     else if 0 < (f / 2)\\<^sup>2 + e ^ 3 / 27\n          then [root 3 (- (f / 2) + sqrt ((f / 2)\\<^sup>2 + e ^ 3 / 27)) -\n                e /\n                (3 *\n                 root 3 (- (f / 2) + sqrt ((f / 2)\\<^sup>2 + e ^ 3 / 27)))]\n          else case case if (f / 2)\\<^sup>2 + e ^ 3 / 27 = 0\n                         then [- (f / 2)] else [] of\n                    [] \\<Rightarrow> None\n                    | a # x \\<Rightarrow> Map.empty x of\n               None \\<Rightarrow>\n                 map Re\n                  (remdups\n                    (map (\\<lambda>z. z - cor e / (3 * z))\n                      (all_croots 3\n                        (- cor (f / 2) +\n                         csqrt (cor ((f / 2)\\<^sup>2 + e ^ 3 / 27))))))\n               | Some y \\<Rightarrow> [])", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  solve_depressed_cubic_real e f =\n  (if e = 0 then [root 3 (- f)]\n   else let v = e ^ 3 / 27; f2 = f / 2; f2v = f2\\<^sup>2 + v\n        in if 0 < f2v\n           then let u = - f2 + sqrt f2v; rt = root 3 u\n                in [rt - e / (3 * rt)]\n           else case foo f2v f2 of\n                None \\<Rightarrow>\n                  let u = - cor f2 + csqrt (cor f2v)\n                  in map Re\n                      (remdups\n                        (map (\\<lambda>z. z - cor e / (3 * z))\n                          (all_croots 3 u)))\n                | Some y \\<Rightarrow> [])\n\ngoal (1 subgoal):\n 1. solve_depressed_cubic_real e f =\n    (if e = 0 then [root 3 (- f)]\n     else let v = e ^ 3 / 27; f2 = f / 2; f2v = f2\\<^sup>2 + v\n          in if 0 < f2v\n             then let u = - f2 + sqrt f2v; rt = root 3 u\n                  in [rt - e / (3 * rt)]\n             else let ce3 = cor e / 3; u = - cor f2 + csqrt (cor f2v)\n                  in map Re\n                      (remdups\n                        (map (\\<lambda>rt. rt - ce3 / rt)\n                          (all_croots 3 u))))", "also"], ["proof (state)\nthis:\n  solve_depressed_cubic_real e f =\n  (if e = 0 then [root 3 (- f)]\n   else let v = e ^ 3 / 27; f2 = f / 2; f2v = f2\\<^sup>2 + v\n        in if 0 < f2v\n           then let u = - f2 + sqrt f2v; rt = root 3 u\n                in [rt - e / (3 * rt)]\n           else case foo f2v f2 of\n                None \\<Rightarrow>\n                  let u = - cor f2 + csqrt (cor f2v)\n                  in map Re\n                      (remdups\n                        (map (\\<lambda>z. z - cor e / (3 * z))\n                          (all_croots 3 u)))\n                | Some y \\<Rightarrow> [])\n\ngoal (1 subgoal):\n 1. solve_depressed_cubic_real e f =\n    (if e = 0 then [root 3 (- f)]\n     else let v = e ^ 3 / 27; f2 = f / 2; f2v = f2\\<^sup>2 + v\n          in if 0 < f2v\n             then let u = - f2 + sqrt f2v; rt = root 3 u\n                  in [rt - e / (3 * rt)]\n             else let ce3 = cor e / 3; u = - cor f2 + csqrt (cor f2v)\n                  in map Re\n                      (remdups\n                        (map (\\<lambda>rt. rt - ce3 / rt)\n                          (all_croots 3 u))))", "have id: \"foo f2v f2 = None\" \n    for f2v f2"], ["proof (prove)\ngoal (1 subgoal):\n 1. foo f2v f2 = None", "unfolding foo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case if f2v = 0 then [- f2] else [] of [] \\<Rightarrow> None\n     | a # x \\<Rightarrow> Map.empty x) =\n    None", "by auto"], ["proof (state)\nthis:\n  foo ?f2v ?f2.0 = None\n\ngoal (1 subgoal):\n 1. solve_depressed_cubic_real e f =\n    (if e = 0 then [root 3 (- f)]\n     else let v = e ^ 3 / 27; f2 = f / 2; f2v = f2\\<^sup>2 + v\n          in if 0 < f2v\n             then let u = - f2 + sqrt f2v; rt = root 3 u\n                  in [rt - e / (3 * rt)]\n             else let ce3 = cor e / 3; u = - cor f2 + csqrt (cor f2v)\n                  in map Re\n                      (remdups\n                        (map (\\<lambda>rt. rt - ce3 / rt)\n                          (all_croots 3 u))))", "ultimately"], ["proof (chain)\npicking this:\n  solve_depressed_cubic_real e f =\n  (if e = 0 then [root 3 (- f)]\n   else let v = e ^ 3 / 27; f2 = f / 2; f2v = f2\\<^sup>2 + v\n        in if 0 < f2v\n           then let u = - f2 + sqrt f2v; rt = root 3 u\n                in [rt - e / (3 * rt)]\n           else case foo f2v f2 of\n                None \\<Rightarrow>\n                  let u = - cor f2 + csqrt (cor f2v)\n                  in map Re\n                      (remdups\n                        (map (\\<lambda>z. z - cor e / (3 * z))\n                          (all_croots 3 u)))\n                | Some y \\<Rightarrow> [])\n  foo ?f2v ?f2.0 = None", "show ?thesis"], ["proof (prove)\nusing this:\n  solve_depressed_cubic_real e f =\n  (if e = 0 then [root 3 (- f)]\n   else let v = e ^ 3 / 27; f2 = f / 2; f2v = f2\\<^sup>2 + v\n        in if 0 < f2v\n           then let u = - f2 + sqrt f2v; rt = root 3 u\n                in [rt - e / (3 * rt)]\n           else case foo f2v f2 of\n                None \\<Rightarrow>\n                  let u = - cor f2 + csqrt (cor f2v)\n                  in map Re\n                      (remdups\n                        (map (\\<lambda>z. z - cor e / (3 * z))\n                          (all_croots 3 u)))\n                | Some y \\<Rightarrow> [])\n  foo ?f2v ?f2.0 = None\n\ngoal (1 subgoal):\n 1. solve_depressed_cubic_real e f =\n    (if e = 0 then [root 3 (- f)]\n     else let v = e ^ 3 / 27; f2 = f / 2; f2v = f2\\<^sup>2 + v\n          in if 0 < f2v\n             then let u = - f2 + sqrt f2v; rt = root 3 u\n                  in [rt - e / (3 * rt)]\n             else let ce3 = cor e / 3; u = - cor f2 + csqrt (cor f2v)\n                  in map Re\n                      (remdups\n                        (map (\\<lambda>rt. rt - ce3 / rt)\n                          (all_croots 3 u))))", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  solve_depressed_cubic_real e f =\n  (if e = 0 then [root 3 (- f)]\n   else let v = e ^ 3 / 27; f2 = f / 2; f2v = f2\\<^sup>2 + v\n        in if 0 < f2v\n           then let u = - f2 + sqrt f2v; rt = root 3 u\n                in [rt - e / (3 * rt)]\n           else let ce3 = cor e / 3; u = - cor f2 + csqrt (cor f2v)\n                in map Re\n                    (remdups\n                      (map (\\<lambda>rt. rt - ce3 / rt) (all_croots 3 u))))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma solve_depressed_cubic_real: \"y \\<in> set (solve_depressed_cubic_real e f) \n  \\<longleftrightarrow> (y^3 + e * y + f = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<in> set (solve_depressed_cubic_real e f)) = (y ^ 3 + e * y + f = 0)", "proof (cases \"solve_depressed_cubic_Cardano_real e f\")"], ["proof (state)\ngoal (2 subgoals):\n 1. solve_depressed_cubic_Cardano_real e f = None \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_real e f)) = (y ^ 3 + e * y + f = 0)\n 2. \\<And>a.\n       solve_depressed_cubic_Cardano_real e f = Some a \\<Longrightarrow>\n       (y \\<in> set (solve_depressed_cubic_real e f)) =\n       (y ^ 3 + e * y + f = 0)", "case (Some x)"], ["proof (state)\nthis:\n  solve_depressed_cubic_Cardano_real e f = Some x\n\ngoal (2 subgoals):\n 1. solve_depressed_cubic_Cardano_real e f = None \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_real e f)) = (y ^ 3 + e * y + f = 0)\n 2. \\<And>a.\n       solve_depressed_cubic_Cardano_real e f = Some a \\<Longrightarrow>\n       (y \\<in> set (solve_depressed_cubic_real e f)) =\n       (y ^ 3 + e * y + f = 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<in> set (solve_depressed_cubic_real e f)) = (y ^ 3 + e * y + f = 0)", "unfolding solve_depressed_cubic_real_def Some option.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<in> set [x]) = (y ^ 3 + e * y + f = 0)", "using solve_depressed_cubic_Cardano_real[OF Some]"], ["proof (prove)\nusing this:\n  {y. y ^ 3 + e * y + f = 0} = {x}\n\ngoal (1 subgoal):\n 1. (y \\<in> set [x]) = (y ^ 3 + e * y + f = 0)", "by auto"], ["proof (state)\nthis:\n  (y \\<in> set (solve_depressed_cubic_real e f)) = (y ^ 3 + e * y + f = 0)\n\ngoal (1 subgoal):\n 1. solve_depressed_cubic_Cardano_real e f = None \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_real e f)) = (y ^ 3 + e * y + f = 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. solve_depressed_cubic_Cardano_real e f = None \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_real e f)) = (y ^ 3 + e * y + f = 0)", "case None"], ["proof (state)\nthis:\n  solve_depressed_cubic_Cardano_real e f = None\n\ngoal (1 subgoal):\n 1. solve_depressed_cubic_Cardano_real e f = None \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_real e f)) = (y ^ 3 + e * y + f = 0)", "from this[unfolded solve_depressed_cubic_Cardano_real_def Let_def rroots2_def]"], ["proof (chain)\npicking this:\n  (if e = 0 then Some (root 3 (- f))\n   else case if (poly.coeff [:- (e ^ 3 / 27), f, 1:] 1 /\n                 (2 * poly.coeff [:- (e ^ 3 / 27), f, 1:] 2))\\<^sup>2 -\n                poly.coeff [:- (e ^ 3 / 27), f, 1:] 0 /\n                poly.coeff [:- (e ^ 3 / 27), f, 1:] 2 =\n                0\n             then [- (poly.coeff [:- (e ^ 3 / 27), f, 1:] 1 /\n                      (2 * poly.coeff [:- (e ^ 3 / 27), f, 1:] 2))]\n             else if (poly.coeff [:- (e ^ 3 / 27), f, 1:] 1 /\n                      (2 * poly.coeff [:- (e ^ 3 / 27), f, 1:] 2))\\<^sup>2 -\n                     poly.coeff [:- (e ^ 3 / 27), f, 1:] 0 /\n                     poly.coeff [:- (e ^ 3 / 27), f, 1:] 2\n                     < 0\n                  then []\n                  else [- (poly.coeff [:- (e ^ 3 / 27), f, 1:] 1 /\n                           (2 * poly.coeff [:- (e ^ 3 / 27), f, 1:] 2)) +\n                        sqrt\n                         ((poly.coeff [:- (e ^ 3 / 27), f, 1:] 1 /\n                           (2 *\n                            poly.coeff [:- (e ^ 3 / 27), f, 1:]\n                             2))\\<^sup>2 -\n                          poly.coeff [:- (e ^ 3 / 27), f, 1:] 0 /\n                          poly.coeff [:- (e ^ 3 / 27), f, 1:] 2),\n                        - (poly.coeff [:- (e ^ 3 / 27), f, 1:] 1 /\n                           (2 * poly.coeff [:- (e ^ 3 / 27), f, 1:] 2)) -\n                        sqrt\n                         ((poly.coeff [:- (e ^ 3 / 27), f, 1:] 1 /\n                           (2 *\n                            poly.coeff [:- (e ^ 3 / 27), f, 1:]\n                             2))\\<^sup>2 -\n                          poly.coeff [:- (e ^ 3 / 27), f, 1:] 0 /\n                          poly.coeff [:- (e ^ 3 / 27), f, 1:] 2)] of\n        [] \\<Rightarrow> None | [u] \\<Rightarrow> None\n        | [u, xa] \\<Rightarrow> Some (root 3 u - e / (3 * root 3 u))\n        | u # xa # ab # x \\<Rightarrow> Map.empty x) =\n  None", "have disc: \"0 \\<le> discriminant_cubic_depressed e f\""], ["proof (prove)\nusing this:\n  (if e = 0 then Some (root 3 (- f))\n   else case if (poly.coeff [:- (e ^ 3 / 27), f, 1:] 1 /\n                 (2 * poly.coeff [:- (e ^ 3 / 27), f, 1:] 2))\\<^sup>2 -\n                poly.coeff [:- (e ^ 3 / 27), f, 1:] 0 /\n                poly.coeff [:- (e ^ 3 / 27), f, 1:] 2 =\n                0\n             then [- (poly.coeff [:- (e ^ 3 / 27), f, 1:] 1 /\n                      (2 * poly.coeff [:- (e ^ 3 / 27), f, 1:] 2))]\n             else if (poly.coeff [:- (e ^ 3 / 27), f, 1:] 1 /\n                      (2 * poly.coeff [:- (e ^ 3 / 27), f, 1:] 2))\\<^sup>2 -\n                     poly.coeff [:- (e ^ 3 / 27), f, 1:] 0 /\n                     poly.coeff [:- (e ^ 3 / 27), f, 1:] 2\n                     < 0\n                  then []\n                  else [- (poly.coeff [:- (e ^ 3 / 27), f, 1:] 1 /\n                           (2 * poly.coeff [:- (e ^ 3 / 27), f, 1:] 2)) +\n                        sqrt\n                         ((poly.coeff [:- (e ^ 3 / 27), f, 1:] 1 /\n                           (2 *\n                            poly.coeff [:- (e ^ 3 / 27), f, 1:]\n                             2))\\<^sup>2 -\n                          poly.coeff [:- (e ^ 3 / 27), f, 1:] 0 /\n                          poly.coeff [:- (e ^ 3 / 27), f, 1:] 2),\n                        - (poly.coeff [:- (e ^ 3 / 27), f, 1:] 1 /\n                           (2 * poly.coeff [:- (e ^ 3 / 27), f, 1:] 2)) -\n                        sqrt\n                         ((poly.coeff [:- (e ^ 3 / 27), f, 1:] 1 /\n                           (2 *\n                            poly.coeff [:- (e ^ 3 / 27), f, 1:]\n                             2))\\<^sup>2 -\n                          poly.coeff [:- (e ^ 3 / 27), f, 1:] 0 /\n                          poly.coeff [:- (e ^ 3 / 27), f, 1:] 2)] of\n        [] \\<Rightarrow> None | [u] \\<Rightarrow> None\n        | [u, xa] \\<Rightarrow> Some (root 3 u - e / (3 * root 3 u))\n        | u # xa # ab # x \\<Rightarrow> Map.empty x) =\n  None\n\ngoal (1 subgoal):\n 1. 0 \\<le> discriminant_cubic_depressed e f", "unfolding discriminant_cubic_depressed_def"], ["proof (prove)\nusing this:\n  (if e = 0 then Some (root 3 (- f))\n   else case if (poly.coeff [:- (e ^ 3 / 27), f, 1:] 1 /\n                 (2 * poly.coeff [:- (e ^ 3 / 27), f, 1:] 2))\\<^sup>2 -\n                poly.coeff [:- (e ^ 3 / 27), f, 1:] 0 /\n                poly.coeff [:- (e ^ 3 / 27), f, 1:] 2 =\n                0\n             then [- (poly.coeff [:- (e ^ 3 / 27), f, 1:] 1 /\n                      (2 * poly.coeff [:- (e ^ 3 / 27), f, 1:] 2))]\n             else if (poly.coeff [:- (e ^ 3 / 27), f, 1:] 1 /\n                      (2 * poly.coeff [:- (e ^ 3 / 27), f, 1:] 2))\\<^sup>2 -\n                     poly.coeff [:- (e ^ 3 / 27), f, 1:] 0 /\n                     poly.coeff [:- (e ^ 3 / 27), f, 1:] 2\n                     < 0\n                  then []\n                  else [- (poly.coeff [:- (e ^ 3 / 27), f, 1:] 1 /\n                           (2 * poly.coeff [:- (e ^ 3 / 27), f, 1:] 2)) +\n                        sqrt\n                         ((poly.coeff [:- (e ^ 3 / 27), f, 1:] 1 /\n                           (2 *\n                            poly.coeff [:- (e ^ 3 / 27), f, 1:]\n                             2))\\<^sup>2 -\n                          poly.coeff [:- (e ^ 3 / 27), f, 1:] 0 /\n                          poly.coeff [:- (e ^ 3 / 27), f, 1:] 2),\n                        - (poly.coeff [:- (e ^ 3 / 27), f, 1:] 1 /\n                           (2 * poly.coeff [:- (e ^ 3 / 27), f, 1:] 2)) -\n                        sqrt\n                         ((poly.coeff [:- (e ^ 3 / 27), f, 1:] 1 /\n                           (2 *\n                            poly.coeff [:- (e ^ 3 / 27), f, 1:]\n                             2))\\<^sup>2 -\n                          poly.coeff [:- (e ^ 3 / 27), f, 1:] 0 /\n                          poly.coeff [:- (e ^ 3 / 27), f, 1:] 2)] of\n        [] \\<Rightarrow> None | [u] \\<Rightarrow> None\n        | [u, xa] \\<Rightarrow> Some (root 3 u - e / (3 * root 3 u))\n        | u # xa # ab # x \\<Rightarrow> Map.empty x) =\n  None\n\ngoal (1 subgoal):\n 1. 0 \\<le> - (4 * e ^ 3 + 27 * f\\<^sup>2)", "by (auto split: if_splits simp: numeral_2_eq_2)"], ["proof (state)\nthis:\n  0 \\<le> discriminant_cubic_depressed e f\n\ngoal (1 subgoal):\n 1. solve_depressed_cubic_Cardano_real e f = None \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_real e f)) = (y ^ 3 + e * y + f = 0)", "let ?c = \"complex_of_real\""], ["proof (state)\ngoal (1 subgoal):\n 1. solve_depressed_cubic_Cardano_real e f = None \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_real e f)) = (y ^ 3 + e * y + f = 0)", "let ?y = \"?c y\""], ["proof (state)\ngoal (1 subgoal):\n 1. solve_depressed_cubic_Cardano_real e f = None \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_real e f)) = (y ^ 3 + e * y + f = 0)", "let ?e = \"?c e\""], ["proof (state)\ngoal (1 subgoal):\n 1. solve_depressed_cubic_Cardano_real e f = None \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_real e f)) = (y ^ 3 + e * y + f = 0)", "let ?f = \"?c f\""], ["proof (state)\ngoal (1 subgoal):\n 1. solve_depressed_cubic_Cardano_real e f = None \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_real e f)) = (y ^ 3 + e * y + f = 0)", "have sub: \"set (solve_depressed_cubic_complex ?e ?f) \\<subseteq> \\<real>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (solve_depressed_cubic_complex (cor e) (cor f)) \\<subseteq> \\<real>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (solve_depressed_cubic_complex (cor e)\n                     (cor f)) \\<Longrightarrow>\n       x \\<in> \\<real>", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (solve_depressed_cubic_complex (cor e)\n                     (cor f)) \\<Longrightarrow>\n       x \\<in> \\<real>", "assume y: \"y \\<in> set (solve_depressed_cubic_complex ?e ?f)\""], ["proof (state)\nthis:\n  y \\<in> set (solve_depressed_cubic_complex (cor e) (cor f))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set (solve_depressed_cubic_complex (cor e)\n                     (cor f)) \\<Longrightarrow>\n       x \\<in> \\<real>", "show \"y \\<in> \\<real>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> \\<real>", "by (rule solve_cubic_depressed_Cardano_all_real_roots[OF disc y[unfolded solve_depressed_cubic_complex]])"], ["proof (state)\nthis:\n  y \\<in> \\<real>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (solve_depressed_cubic_complex (cor e) (cor f)) \\<subseteq> \\<real>\n\ngoal (1 subgoal):\n 1. solve_depressed_cubic_Cardano_real e f = None \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_real e f)) = (y ^ 3 + e * y + f = 0)", "have \"y^3 + e * y + f = 0 \\<longleftrightarrow> (?c (y^3 + e * y + f) = ?c 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y ^ 3 + e * y + f = 0) = (cor (y ^ 3 + e * y + f) = cor 0)", "unfolding of_real_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y ^ 3 + e * y + f = 0) = (y ^ 3 + e * y + f = 0)", "by simp"], ["proof (state)\nthis:\n  (y ^ 3 + e * y + f = 0) = (cor (y ^ 3 + e * y + f) = cor 0)\n\ngoal (1 subgoal):\n 1. solve_depressed_cubic_Cardano_real e f = None \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_real e f)) = (y ^ 3 + e * y + f = 0)", "also"], ["proof (state)\nthis:\n  (y ^ 3 + e * y + f = 0) = (cor (y ^ 3 + e * y + f) = cor 0)\n\ngoal (1 subgoal):\n 1. solve_depressed_cubic_Cardano_real e f = None \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_real e f)) = (y ^ 3 + e * y + f = 0)", "have \"\\<dots> \\<longleftrightarrow> ?y^3 + ?e * ?y + ?f = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cor (y ^ 3 + e * y + f) = cor 0) =\n    (cor y ^ 3 + cor e * cor y + cor f = 0)", "by simp"], ["proof (state)\nthis:\n  (cor (y ^ 3 + e * y + f) = cor 0) =\n  (cor y ^ 3 + cor e * cor y + cor f = 0)\n\ngoal (1 subgoal):\n 1. solve_depressed_cubic_Cardano_real e f = None \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_real e f)) = (y ^ 3 + e * y + f = 0)", "also"], ["proof (state)\nthis:\n  (cor (y ^ 3 + e * y + f) = cor 0) =\n  (cor y ^ 3 + cor e * cor y + cor f = 0)\n\ngoal (1 subgoal):\n 1. solve_depressed_cubic_Cardano_real e f = None \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_real e f)) = (y ^ 3 + e * y + f = 0)", "have \"\\<dots> \\<longleftrightarrow> ?y \\<in> set (solve_depressed_cubic_complex ?e ?f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cor y ^ 3 + cor e * cor y + cor f = 0) =\n    (cor y \\<in> set (solve_depressed_cubic_complex (cor e) (cor f)))", "unfolding solve_depressed_cubic_complex"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cor y ^ 3 + cor e * cor y + cor f = 0) =\n    (cor y ^ 3 + cor e * cor y + cor f = 0)", ".."], ["proof (state)\nthis:\n  (cor y ^ 3 + cor e * cor y + cor f = 0) =\n  (cor y \\<in> set (solve_depressed_cubic_complex (cor e) (cor f)))\n\ngoal (1 subgoal):\n 1. solve_depressed_cubic_Cardano_real e f = None \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_real e f)) = (y ^ 3 + e * y + f = 0)", "also"], ["proof (state)\nthis:\n  (cor y ^ 3 + cor e * cor y + cor f = 0) =\n  (cor y \\<in> set (solve_depressed_cubic_complex (cor e) (cor f)))\n\ngoal (1 subgoal):\n 1. solve_depressed_cubic_Cardano_real e f = None \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_real e f)) = (y ^ 3 + e * y + f = 0)", "have \"\\<dots> \\<longleftrightarrow> y \\<in> Re ` set (solve_depressed_cubic_complex ?e ?f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cor y \\<in> set (solve_depressed_cubic_complex (cor e) (cor f))) =\n    (y \\<in> Re ` set (solve_depressed_cubic_complex (cor e) (cor f)))", "using sub"], ["proof (prove)\nusing this:\n  set (solve_depressed_cubic_complex (cor e) (cor f)) \\<subseteq> \\<real>\n\ngoal (1 subgoal):\n 1. (cor y \\<in> set (solve_depressed_cubic_complex (cor e) (cor f))) =\n    (y \\<in> Re ` set (solve_depressed_cubic_complex (cor e) (cor f)))", "by force"], ["proof (state)\nthis:\n  (cor y \\<in> set (solve_depressed_cubic_complex (cor e) (cor f))) =\n  (y \\<in> Re ` set (solve_depressed_cubic_complex (cor e) (cor f)))\n\ngoal (1 subgoal):\n 1. solve_depressed_cubic_Cardano_real e f = None \\<Longrightarrow>\n    (y \\<in> set (solve_depressed_cubic_real e f)) = (y ^ 3 + e * y + f = 0)", "finally"], ["proof (chain)\npicking this:\n  (y ^ 3 + e * y + f = 0) =\n  (y \\<in> Re ` set (solve_depressed_cubic_complex (cor e) (cor f)))", "show ?thesis"], ["proof (prove)\nusing this:\n  (y ^ 3 + e * y + f = 0) =\n  (y \\<in> Re ` set (solve_depressed_cubic_complex (cor e) (cor f)))\n\ngoal (1 subgoal):\n 1. (y \\<in> set (solve_depressed_cubic_real e f)) = (y ^ 3 + e * y + f = 0)", "unfolding solve_depressed_cubic_real_def None"], ["proof (prove)\nusing this:\n  (y ^ 3 + e * y + f = 0) =\n  (y \\<in> Re ` set (solve_depressed_cubic_complex (cor e) (cor f)))\n\ngoal (1 subgoal):\n 1. (y \\<in> set (case None of\n                  None \\<Rightarrow>\n                    map Re (solve_depressed_cubic_complex (cor e) (cor f))\n                  | Some y \\<Rightarrow> [y])) =\n    (y ^ 3 + e * y + f = 0)", "by auto"], ["proof (state)\nthis:\n  (y \\<in> set (solve_depressed_cubic_real e f)) = (y ^ 3 + e * y + f = 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Combining the various algorithms\\<close>"], ["", "lemma degree3_coeffs: \"degree p = 3 \\<Longrightarrow>\n  \\<exists> a b c d. p = [: d, c, b, a :] \\<and> a \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p = 3 \\<Longrightarrow>\n    \\<exists>a b c d. p = [:d, c, b, a:] \\<and> a \\<noteq> (0::'a)", "by (metis One_nat_def Suc_1 degree2_coeffs degree_pCons_eq_if nat.inject numeral_3_eq_3 pCons_cases zero_neq_numeral)"], ["", "definition roots3_generic :: \"('a :: field_char_0 \\<Rightarrow> 'a \\<Rightarrow> 'a list) \\<Rightarrow> 'a poly \\<Rightarrow> 'a list\" where\n  \"roots3_generic depressed_solver p = (let \n     cs = coeffs p; \n     a = cs ! 3; b = cs ! 2; c = cs ! 1; d = cs ! 0;\n     a3 = 3 * a;\n     ba3 = b / a3;\n     b2 = b * b;\n     b3 = b2 * b;\n     e = (c - b2 / a3) / a;\n     f = (d + 2 * b3 / (27 * a^2) - b * c / a3) / a;\n     roots = depressed_solver e f\n     in map (\\<lambda> y. y - ba3) roots)\""], ["", "lemma roots3_generic: assumes deg: \"degree p = 3\" \n  and solver: \"\\<And> e f y. y \\<in> set (depressed_solver e f) \\<longleftrightarrow> y^3 + e * y + f = 0\" \n  shows \"set (roots3_generic depressed_solver p) = {x. poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (roots3_generic depressed_solver p) = {x. poly p x = (0::'a)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (roots3_generic depressed_solver p) = {x. poly p x = (0::'a)}", "note powers = field_simps power3_eq_cube power2_eq_square"], ["proof (state)\nthis:\n  ?a + ?b + ?c = ?a + (?b + ?c)\n  ?a + ?b = ?b + ?a\n  ?b + (?a + ?c) = ?a + (?b + ?c)\n  ?a * ?b * ?c = ?a * (?b * ?c)\n  ?a * ?b = ?b * ?a\n  ?b * (?a * ?c) = ?a * (?b * ?c)\n  ?a - ?b - ?c = ?a - (?b + ?c)\n  ?a + (?b - ?c) = ?a + ?b - ?c\n  (?a - ?b = ?c) = (?a = ?c + ?b)\n  (?a = ?c - ?b) = (?a + ?b = ?c)\n  ?a - (?b - ?c) = ?a + ?c - ?b\n  ?a - ?b + ?c = ?a + ?c - ?b\n  (?a - ?b < ?c) = (?a < ?c + ?b)\n  (?a < ?c - ?b) = (?a + ?b < ?c)\n  (?a - ?b \\<le> ?c) = (?a \\<le> ?c + ?b)\n  (?a \\<le> ?c - ?b) = (?a + ?b \\<le> ?c)\n  NO_MATCH (?x div ?y) ?a \\<Longrightarrow>\n  ?a * (?b + ?c) = ?a * ?b + ?a * ?c\n  NO_MATCH (?x div ?y) ?c \\<Longrightarrow>\n  (?a + ?b) * ?c = ?a * ?c + ?b * ?c\n  NO_MATCH (?x div ?y) ?c \\<Longrightarrow>\n  (?a - ?b) * ?c = ?a * ?c - ?b * ?c\n  NO_MATCH (?x div ?y) ?a \\<Longrightarrow>\n  ?a * (?b - ?c) = ?a * ?b - ?a * ?c\n  inverse ?a = (1::?'a) / ?a\n  ?c \\<noteq> (0::?'a) \\<Longrightarrow> (?a = ?b / ?c) = (?a * ?c = ?b)\n  ?c \\<noteq> (0::?'a) \\<Longrightarrow> (?b / ?c = ?a) = (?b = ?a * ?c)\n  ?b \\<noteq> (0::?'a) \\<Longrightarrow>\n  (- (?a / ?b) = ?c) = (- ?a = ?c * ?b)\n  ?b \\<noteq> (0::?'a) \\<Longrightarrow>\n  (?c = - (?a / ?b)) = (?c * ?b = - ?a)\n  ?z \\<noteq> (0::?'a) \\<Longrightarrow> ?x + ?y / ?z = (?x * ?z + ?y) / ?z\n  ?z \\<noteq> (0::?'a) \\<Longrightarrow> ?x / ?z + ?y = (?x + ?y * ?z) / ?z\n  ?z \\<noteq> (0::?'a) \\<Longrightarrow> ?x - ?y / ?z = (?x * ?z - ?y) / ?z\n  ?z \\<noteq> (0::?'a) \\<Longrightarrow>\n  - (?x / ?z) + ?y = (- ?x + ?y * ?z) / ?z\n  ?z \\<noteq> (0::?'a) \\<Longrightarrow> ?x / ?z - ?y = (?x - ?y * ?z) / ?z\n  ?z \\<noteq> (0::?'a) \\<Longrightarrow>\n  - (?x / ?z) - ?y = (- ?x - ?y * ?z) / ?z\n  (0::?'a) < ?c \\<Longrightarrow> (?a \\<le> ?b / ?c) = (?a * ?c \\<le> ?b)\n  (0::?'a) < ?c \\<Longrightarrow> (?a < ?b / ?c) = (?a * ?c < ?b)\n  ?c < (0::?'a) \\<Longrightarrow> (?a < ?b / ?c) = (?b < ?a * ?c)\n  ?c < (0::?'a) \\<Longrightarrow> (?a \\<le> ?b / ?c) = (?b \\<le> ?a * ?c)\n  (0::?'a) < ?c \\<Longrightarrow> (?b / ?c \\<le> ?a) = (?b \\<le> ?a * ?c)\n  (0::?'a) < ?c \\<Longrightarrow> (?b / ?c < ?a) = (?b < ?a * ?c)\n  ?c < (0::?'a) \\<Longrightarrow> (?b / ?c \\<le> ?a) = (?a * ?c \\<le> ?b)\n  ?c < (0::?'a) \\<Longrightarrow> (?b / ?c < ?a) = (?a * ?c < ?b)\n  (0::?'a) < ?c \\<Longrightarrow>\n  (?a \\<le> - (?b / ?c)) = (?a * ?c \\<le> - ?b)\n  ?c < (0::?'a) \\<Longrightarrow>\n  (?a \\<le> - (?b / ?c)) = (- ?b \\<le> ?a * ?c)\n  (0::?'a) < ?c \\<Longrightarrow> (?a < - (?b / ?c)) = (?a * ?c < - ?b)\n  ?c < (0::?'a) \\<Longrightarrow> (?a < - (?b / ?c)) = (- ?b < ?a * ?c)\n  (0::?'a) < ?c \\<Longrightarrow> (- (?b / ?c) < ?a) = (- ?b < ?a * ?c)\n  ?c < (0::?'a) \\<Longrightarrow> (- (?b / ?c) < ?a) = (?a * ?c < - ?b)\n  (0::?'a) < ?c \\<Longrightarrow>\n  (- (?b / ?c) \\<le> ?a) = (- ?b \\<le> ?a * ?c)\n  ?c < (0::?'a) \\<Longrightarrow>\n  (- (?b / ?c) \\<le> ?a) = (?a * ?c \\<le> - ?b)\n  (?a * ?b) ^ ?n = ?a ^ ?n * ?b ^ ?n\n  inverse ?a ^ ?n = inverse (?a ^ ?n)\n  ((1::?'a) / ?a) ^ ?n = (1::?'a) / ?a ^ ?n\n  (?a / ?b) ^ ?n = ?a ^ ?n / ?b ^ ?n\n  inverse ?x powi ?n = inverse (?x powi ?n)\n  ((1::?'a) / ?x) powi ?n = (1::?'a) / ?x powi ?n\n  NO_MATCH (?x div ?y) ?c \\<Longrightarrow>\n  (?a + ?b) *\\<^sub>R ?x = ?a *\\<^sub>R ?x + ?b *\\<^sub>R ?x\n  NO_MATCH (?x div ?y) ?a \\<Longrightarrow>\n  ?a *\\<^sub>R (?x + ?y) = ?a *\\<^sub>R ?x + ?a *\\<^sub>R ?y\n  NO_MATCH (?x div ?y) ?c \\<Longrightarrow>\n  (?a - ?b) *\\<^sub>R ?x = ?a *\\<^sub>R ?x - ?b *\\<^sub>R ?x\n  NO_MATCH (?x div ?y) ?a \\<Longrightarrow>\n  ?a *\\<^sub>R (?x - ?y) = ?a *\\<^sub>R ?x - ?a *\\<^sub>R ?y\n  ?c \\<noteq> 0 \\<Longrightarrow>\n  (?a = ?b /\\<^sub>R ?c) = (?c *\\<^sub>R ?a = ?b)\n  ?c \\<noteq> 0 \\<Longrightarrow>\n  (?b /\\<^sub>R ?c = ?a) = (?b = ?c *\\<^sub>R ?a)\n  ?c \\<noteq> 0 \\<Longrightarrow>\n  ?a + ?b /\\<^sub>R ?c = (?c *\\<^sub>R ?a + ?b) /\\<^sub>R ?c\n  ?c \\<noteq> 0 \\<Longrightarrow>\n  ?a /\\<^sub>R ?c + ?b = (?a + ?c *\\<^sub>R ?b) /\\<^sub>R ?c\n  ?c \\<noteq> 0 \\<Longrightarrow>\n  ?a - ?b /\\<^sub>R ?c = (?c *\\<^sub>R ?a - ?b) /\\<^sub>R ?c\n  ?c \\<noteq> 0 \\<Longrightarrow>\n  ?a /\\<^sub>R ?c - ?b = (?a - ?c *\\<^sub>R ?b) /\\<^sub>R ?c\n  ?c \\<noteq> 0 \\<Longrightarrow>\n  - (?a /\\<^sub>R ?c) + ?b = (- ?a + ?c *\\<^sub>R ?b) /\\<^sub>R ?c\n  ?c \\<noteq> 0 \\<Longrightarrow>\n  - (?a /\\<^sub>R ?c) - ?b = (- ?a - ?c *\\<^sub>R ?b) /\\<^sub>R ?c\n  0 < ?c \\<Longrightarrow>\n  (?a \\<le> ?b /\\<^sub>R ?c) = (?c *\\<^sub>R ?a \\<le> ?b)\n  0 < ?c \\<Longrightarrow> (?a < ?b /\\<^sub>R ?c) = (?c *\\<^sub>R ?a < ?b)\n  0 < ?c \\<Longrightarrow>\n  (?b /\\<^sub>R ?c \\<le> ?a) = (?b \\<le> ?c *\\<^sub>R ?a)\n  0 < ?c \\<Longrightarrow> (?b /\\<^sub>R ?c < ?a) = (?b < ?c *\\<^sub>R ?a)\n  0 < ?c \\<Longrightarrow>\n  (?a \\<le> - (?b /\\<^sub>R ?c)) = (?c *\\<^sub>R ?a \\<le> - ?b)\n  0 < ?c \\<Longrightarrow>\n  (?a < - (?b /\\<^sub>R ?c)) = (?c *\\<^sub>R ?a < - ?b)\n  0 < ?c \\<Longrightarrow>\n  (- (?b /\\<^sub>R ?c) \\<le> ?a) = (- ?b \\<le> ?c *\\<^sub>R ?a)\n  0 < ?c \\<Longrightarrow>\n  (- (?b /\\<^sub>R ?c) < ?a) = (- ?b < ?c *\\<^sub>R ?a)\n  ?c < 0 \\<Longrightarrow>\n  (?a \\<le> ?b /\\<^sub>R ?c) = (?b \\<le> ?c *\\<^sub>R ?a)\n  ?c < 0 \\<Longrightarrow> (?a < ?b /\\<^sub>R ?c) = (?b < ?c *\\<^sub>R ?a)\n  ?c < 0 \\<Longrightarrow>\n  (?b /\\<^sub>R ?c \\<le> ?a) = (?c *\\<^sub>R ?a \\<le> ?b)\n  ?c < 0 \\<Longrightarrow> (?b /\\<^sub>R ?c < ?a) = (?c *\\<^sub>R ?a < ?b)\n  ?c < 0 \\<Longrightarrow>\n  (?a \\<le> - (?b /\\<^sub>R ?c)) = (- ?b \\<le> ?c *\\<^sub>R ?a)\n  ?c < 0 \\<Longrightarrow>\n  (?a < - (?b /\\<^sub>R ?c)) = (- ?b < ?c *\\<^sub>R ?a)\n  ?c < 0 \\<Longrightarrow>\n  (- (?b /\\<^sub>R ?c) \\<le> ?a) = (?c *\\<^sub>R ?a \\<le> - ?b)\n  ?c < 0 \\<Longrightarrow>\n  (- (?b /\\<^sub>R ?c) < ?a) = (?c *\\<^sub>R ?a < - ?b)\n  ?a ^ 3 = ?a * ?a * ?a\n  ?a\\<^sup>2 = ?a * ?a\n\ngoal (1 subgoal):\n 1. set (roots3_generic depressed_solver p) = {x. poly p x = (0::'a)}", "from degree3_coeffs[OF deg]"], ["proof (chain)\npicking this:\n  \\<exists>a b c d. p = [:d, c, b, a:] \\<and> a \\<noteq> (0::'a)", "obtain a b c d where\n    p: \"p = [:d,c,b,a:]\" and a: \"a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>a b c d. p = [:d, c, b, a:] \\<and> a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>d c b a.\n        \\<lbrakk>p = [:d, c, b, a:]; a \\<noteq> (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = [:d, c, b, a:]\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. set (roots3_generic depressed_solver p) = {x. poly p x = (0::'a)}", "have coeffs: \"coeffs p ! 3 = a\" \"coeffs p ! 2 = b\" \"coeffs p ! 1 = c\" \"coeffs p ! 0 = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (coeffs p ! 3 = a &&& coeffs p ! 2 = b) &&&\n    coeffs p ! 1 = c &&& coeffs p ! 0 = d", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. (coeffs [:d, c, b, a:] ! 3 = a &&& coeffs [:d, c, b, a:] ! 2 = b) &&&\n    coeffs [:d, c, b, a:] ! 1 = c &&& coeffs [:d, c, b, a:] ! 0 = d", "using a"], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (coeffs [:d, c, b, a:] ! 3 = a &&& coeffs [:d, c, b, a:] ! 2 = b) &&&\n    coeffs [:d, c, b, a:] ! 1 = c &&& coeffs [:d, c, b, a:] ! 0 = d", "by auto"], ["proof (state)\nthis:\n  coeffs p ! 3 = a\n  coeffs p ! 2 = b\n  coeffs p ! 1 = c\n  coeffs p ! 0 = d\n\ngoal (1 subgoal):\n 1. set (roots3_generic depressed_solver p) = {x. poly p x = (0::'a)}", "define e where \"e = (c - b^2 / (3 * a)) / a\""], ["proof (state)\nthis:\n  e = (c - b\\<^sup>2 / ((3::'a) * a)) / a\n\ngoal (1 subgoal):\n 1. set (roots3_generic depressed_solver p) = {x. poly p x = (0::'a)}", "define f where \"f = (d + 2 * b^3 / (27 * a^2) - b * c / (3 * a)) / a\""], ["proof (state)\nthis:\n  f =\n  (d + (2::'a) * b ^ 3 / ((27::'a) * a\\<^sup>2) - b * c / ((3::'a) * a)) / a\n\ngoal (1 subgoal):\n 1. set (roots3_generic depressed_solver p) = {x. poly p x = (0::'a)}", "note def = roots3_generic_def[of depressed_solver p, unfolded Let_def coeffs,\n      folded power3_eq_cube, folded power2_eq_square,  folded e_def f_def]"], ["proof (state)\nthis:\n  roots3_generic depressed_solver p =\n  map (\\<lambda>y. y - b / ((3::'a) * a)) (depressed_solver e f)\n\ngoal (1 subgoal):\n 1. set (roots3_generic depressed_solver p) = {x. poly p x = (0::'a)}", "{"], ["proof (state)\nthis:\n  roots3_generic depressed_solver p =\n  map (\\<lambda>y. y - b / ((3::'a) * a)) (depressed_solver e f)\n\ngoal (1 subgoal):\n 1. set (roots3_generic depressed_solver p) = {x. poly p x = (0::'a)}", "fix x :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. set (roots3_generic depressed_solver p) = {x. poly p x = (0::'a)}", "define y where \"y = x + b / (3 * a)\""], ["proof (state)\nthis:\n  y = x + b / ((3::'a) * a)\n\ngoal (1 subgoal):\n 1. set (roots3_generic depressed_solver p) = {x. poly p x = (0::'a)}", "have xy: \"x = y - b / (3 * a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y - b / ((3::'a) * a)", "unfolding y_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x + b / ((3::'a) * a) - b / ((3::'a) * a)", "by auto"], ["proof (state)\nthis:\n  x = y - b / ((3::'a) * a)\n\ngoal (1 subgoal):\n 1. set (roots3_generic depressed_solver p) = {x. poly p x = (0::'a)}", "have \"poly p x = 0 \\<longleftrightarrow> a * x^3 + b * x^2 + c * x + d = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly p x = (0::'a)) = (a * x ^ 3 + b * x\\<^sup>2 + c * x + d = (0::'a))", "unfolding p"], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly [:d, c, b, a:] x = (0::'a)) =\n    (a * x ^ 3 + b * x\\<^sup>2 + c * x + d = (0::'a))", "by (simp add: powers)"], ["proof (state)\nthis:\n  (poly p x = (0::'a)) = (a * x ^ 3 + b * x\\<^sup>2 + c * x + d = (0::'a))\n\ngoal (1 subgoal):\n 1. set (roots3_generic depressed_solver p) = {x. poly p x = (0::'a)}", "also"], ["proof (state)\nthis:\n  (poly p x = (0::'a)) = (a * x ^ 3 + b * x\\<^sup>2 + c * x + d = (0::'a))\n\ngoal (1 subgoal):\n 1. set (roots3_generic depressed_solver p) = {x. poly p x = (0::'a)}", "have \"\\<dots> \\<longleftrightarrow> (y ^ 3 + e * y + f = 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a * x ^ 3 + b * x\\<^sup>2 + c * x + d = (0::'a)) =\n    (y ^ 3 + e * y + f = (0::'a))", "unfolding to_depressed_cubic[OF a xy e_def f_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y ^ 3 + e * y + f = (0::'a)) = (y ^ 3 + e * y + f = (0::'a))", ".."], ["proof (state)\nthis:\n  (a * x ^ 3 + b * x\\<^sup>2 + c * x + d = (0::'a)) =\n  (y ^ 3 + e * y + f = (0::'a))\n\ngoal (1 subgoal):\n 1. set (roots3_generic depressed_solver p) = {x. poly p x = (0::'a)}", "also"], ["proof (state)\nthis:\n  (a * x ^ 3 + b * x\\<^sup>2 + c * x + d = (0::'a)) =\n  (y ^ 3 + e * y + f = (0::'a))\n\ngoal (1 subgoal):\n 1. set (roots3_generic depressed_solver p) = {x. poly p x = (0::'a)}", "have \"\\<dots> \\<longleftrightarrow> y \\<in> set (depressed_solver e f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y ^ 3 + e * y + f = (0::'a)) = (y \\<in> set (depressed_solver e f))", "unfolding solver"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y ^ 3 + e * y + f = (0::'a)) = (y ^ 3 + e * y + f = (0::'a))", ".."], ["proof (state)\nthis:\n  (y ^ 3 + e * y + f = (0::'a)) = (y \\<in> set (depressed_solver e f))\n\ngoal (1 subgoal):\n 1. set (roots3_generic depressed_solver p) = {x. poly p x = (0::'a)}", "also"], ["proof (state)\nthis:\n  (y ^ 3 + e * y + f = (0::'a)) = (y \\<in> set (depressed_solver e f))\n\ngoal (1 subgoal):\n 1. set (roots3_generic depressed_solver p) = {x. poly p x = (0::'a)}", "have \"\\<dots> \\<longleftrightarrow> x \\<in> set (roots3_generic depressed_solver p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<in> set (depressed_solver e f)) =\n    (x \\<in> set (roots3_generic depressed_solver p))", "unfolding xy def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<in> set (depressed_solver e f)) =\n    (y - b / ((3::'a) * a)\n     \\<in> set (map (\\<lambda>y. y - b / ((3::'a) * a))\n                 (depressed_solver e f)))", "by auto"], ["proof (state)\nthis:\n  (y \\<in> set (depressed_solver e f)) =\n  (x \\<in> set (roots3_generic depressed_solver p))\n\ngoal (1 subgoal):\n 1. set (roots3_generic depressed_solver p) = {x. poly p x = (0::'a)}", "finally"], ["proof (chain)\npicking this:\n  (poly p x = (0::'a)) = (x \\<in> set (roots3_generic depressed_solver p))", "have \"poly p x = 0 \\<longleftrightarrow> x \\<in> set (roots3_generic depressed_solver p)\""], ["proof (prove)\nusing this:\n  (poly p x = (0::'a)) = (x \\<in> set (roots3_generic depressed_solver p))\n\ngoal (1 subgoal):\n 1. (poly p x = (0::'a)) = (x \\<in> set (roots3_generic depressed_solver p))", "by auto"], ["proof (state)\nthis:\n  (poly p x = (0::'a)) = (x \\<in> set (roots3_generic depressed_solver p))\n\ngoal (1 subgoal):\n 1. set (roots3_generic depressed_solver p) = {x. poly p x = (0::'a)}", "}"], ["proof (state)\nthis:\n  (poly p ?x2 = (0::'a)) =\n  (?x2 \\<in> set (roots3_generic depressed_solver p))\n\ngoal (1 subgoal):\n 1. set (roots3_generic depressed_solver p) = {x. poly p x = (0::'a)}", "thus ?thesis"], ["proof (prove)\nusing this:\n  (poly p ?x2 = (0::'a)) =\n  (?x2 \\<in> set (roots3_generic depressed_solver p))\n\ngoal (1 subgoal):\n 1. set (roots3_generic depressed_solver p) = {x. poly p x = (0::'a)}", "by auto"], ["proof (state)\nthis:\n  set (roots3_generic depressed_solver p) = {x. poly p x = (0::'a)}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition croots3 :: \"complex poly \\<Rightarrow> complex list\" where\n  \"croots3 = roots3_generic solve_depressed_cubic_complex\""], ["", "lemma croots3: assumes deg: \"degree p = 3\" \n  shows \"set (croots3 p) = { x. poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Cubic_Polynomials.croots3 p) = {x. poly p x = 0}", "unfolding croots3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (roots3_generic solve_depressed_cubic_complex p) = {x. poly p x = 0}", "by (rule roots3_generic[OF deg solve_depressed_cubic_complex])"], ["", "definition rroots3 :: \"real poly \\<Rightarrow> real list\" where\n  \"rroots3 = roots3_generic solve_depressed_cubic_real\""], ["", "lemma rroots3: assumes deg: \"degree p = 3\" \n  shows \"set (rroots3 p) = { x. poly p x = 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (rroots3 p) = {x. poly p x = 0}", "unfolding rroots3_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (roots3_generic solve_depressed_cubic_real p) = {x. poly p x = 0}", "by (rule roots3_generic[OF deg solve_depressed_cubic_real])"], ["", "end"]]}