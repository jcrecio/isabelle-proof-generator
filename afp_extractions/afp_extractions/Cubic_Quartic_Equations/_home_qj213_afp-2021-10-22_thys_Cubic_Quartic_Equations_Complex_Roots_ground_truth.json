{"file_name": "/home/qj213/afp-2021-10-22/thys/Cubic_Quartic_Equations/Complex_Roots.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Cubic_Quartic_Equations", "problem_names": ["lemma all_croots_code[code]:\n  \"all_croots n x = (if n = 0 then [] else\n     if algebraic x then\n       (let p = min_int_poly x;\n         q = poly_nth_root n p;\n         xs = complex_roots_of_int_poly q\n         in filter (\\<lambda> y. y^n = x) xs)\n     else Code.abort (STR ''all_croots invoked on non-algebraic number'') (\\<lambda> _. all_croots n x))\"", "lemma all_croots: assumes n0: \"n \\<noteq> 0\" shows \"set (all_croots n x) = {y. y^n = x}\"", "lemma croot_0[simp]: \"croot n 0 = 0\" \"croot 0 x = 0\"", "lemma croot_power: assumes n: \"n \\<noteq> 0\" \n  shows \"(croot n x) ^ n = x\"", "lemma arg_of_real: \"arg (of_real x) = \n  (if x < 0 then pi else 0)\"", "lemma arg_rcis_cis[simp]: assumes \"x > 0\" \n  shows \"arg (rcis x y) = arg (cis y)\"", "lemma cis_arg_1[simp]: \"cis (arg 1) = 1\"", "lemma cis_arg_power[simp]: assumes \"x \\<noteq> 0\" \n  shows \"cis (arg (x ^ n)) = cis (arg x * real n)\"", "lemma arg_croot[simp]: \"arg (croot n x) = arg x / real n\"", "lemma cos_abs[simp]: \"cos (abs x :: real) = cos x\"", "lemma cos_mono_le: assumes \"abs x \\<le> pi\" \n  and \"abs y \\<le> pi\" \nshows \"cos x \\<le> cos y \\<longleftrightarrow> abs y \\<le> abs x\"", "lemma abs_add_2_mult_bound: fixes x :: \"'a :: linordered_idom\" \n  assumes xy: \"\\<bar>x\\<bar> \\<le> y\" \n  shows \"\\<bar>x\\<bar> \\<le> \\<bar>x + 2 * of_int i * y\\<bar>\"", "lemma abs_eq_add_2_mult: fixes y :: \"'a :: linordered_idom\" \n  assumes abs_id: \"\\<bar>x\\<bar> = \\<bar>x + 2 * of_int i * y\\<bar>\" \n  and xy: \"- y < x\" \"x \\<le> y\" \n  and i: \"i \\<noteq> 0\" \nshows \"x = y \\<and> i = -1\"", "lemma croot_principal: assumes n: \"n \\<noteq> 0\"\n  and y: \"y ^ n = x\"\n  and neq: \"y \\<noteq> croot n x\"\nshows \"Re y < Re (croot n x) \\<or> Re y = Re (croot n x) \\<and> Im y < Im (croot n x)\"", "lemma croot_unique: assumes n: \"n \\<noteq> 0\"\n  and y: \"y ^ n = x\"\n  and y_max_Re_Im: \"\\<And> z. z ^ n = x \\<Longrightarrow>\n      Re z < Re y \\<or> Re z = Re y \\<and> Im z \\<le> Im y\" \nshows \"croot n x = y\"", "lemma csqrt_is_croot_2: \"csqrt = croot 2\"", "lemma croot_via_root_selection: assumes roots: \"set ys = { y. y^n = x}\" \n  and n: \"n \\<noteq> 0\" \nshows \"croot n x = arg_min_list (\\<lambda> y. (- Re y, - Im y)) ys\" \n  (is \"_ = arg_min_list ?f ys\")", "lemma croot_impl[code]: \"croot n x = (if n = 0 then 0 else \n  arg_min_list (\\<lambda> y. (- Re y, - Im y)) (all_croots n x))\""], "translations": [["", "lemma all_croots_code[code]:\n  \"all_croots n x = (if n = 0 then [] else\n     if algebraic x then\n       (let p = min_int_poly x;\n         q = poly_nth_root n p;\n         xs = complex_roots_of_int_poly q\n         in filter (\\<lambda> y. y^n = x) xs)\n     else Code.abort (STR ''all_croots invoked on non-algebraic number'') (\\<lambda> _. all_croots n x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. all_croots n x =\n    (if n = 0 then []\n     else if algebraic x\n          then let p = min_int_poly x; q = poly_nth_root n p\n               in Let (complex_roots_of_int_poly q)\n                   (filter (\\<lambda>y. y ^ n = x))\n          else Code.abort STR ''all_croots invoked on non-algebraic number''\n                (\\<lambda>_. all_croots n x))", "by (auto simp: all_croots_def)"], ["", "lemma all_croots: assumes n0: \"n \\<noteq> 0\" shows \"set (all_croots n x) = {y. y^n = x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (all_croots n x) = {y. y ^ n = x}", "proof (cases \"algebraic x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. algebraic x \\<Longrightarrow> set (all_croots n x) = {y. y ^ n = x}\n 2. \\<not> algebraic x \\<Longrightarrow>\n    set (all_croots n x) = {y. y ^ n = x}", "case True"], ["proof (state)\nthis:\n  algebraic x\n\ngoal (2 subgoals):\n 1. algebraic x \\<Longrightarrow> set (all_croots n x) = {y. y ^ n = x}\n 2. \\<not> algebraic x \\<Longrightarrow>\n    set (all_croots n x) = {y. y ^ n = x}", "hence id: \"(if n = 0 then y else if algebraic x then z else u) = z\" \n    for y z u :: \"complex list\""], ["proof (prove)\nusing this:\n  algebraic x\n\ngoal (1 subgoal):\n 1. (if n = 0 then y else if algebraic x then z else u) = z", "using n0"], ["proof (prove)\nusing this:\n  algebraic x\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if n = 0 then y else if algebraic x then z else u) = z", "by auto"], ["proof (state)\nthis:\n  (if n = 0 then ?y else if algebraic x then ?z else ?u) = ?z\n\ngoal (2 subgoals):\n 1. algebraic x \\<Longrightarrow> set (all_croots n x) = {y. y ^ n = x}\n 2. \\<not> algebraic x \\<Longrightarrow>\n    set (all_croots n x) = {y. y ^ n = x}", "define p where \"p = poly_nth_root n (min_int_poly x)\""], ["proof (state)\nthis:\n  p = poly_nth_root n (min_int_poly x)\n\ngoal (2 subgoals):\n 1. algebraic x \\<Longrightarrow> set (all_croots n x) = {y. y ^ n = x}\n 2. \\<not> algebraic x \\<Longrightarrow>\n    set (all_croots n x) = {y. y ^ n = x}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (all_croots n x) = {y. y ^ n = x}", "unfolding Let_def p_def[symmetric] all_croots_def id"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (filter (\\<lambda>y. y ^ n = x) (complex_roots_of_int_poly p)) =\n    {y. y ^ n = x}", "proof (standard, force, standard, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa ^ n = x \\<Longrightarrow>\n       xa \\<in> set (complex_roots_of_int_poly p)", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa ^ n = x \\<Longrightarrow>\n       xa \\<in> set (complex_roots_of_int_poly p)", "assume y: \"y ^n  = x\""], ["proof (state)\nthis:\n  y ^ n = x\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa ^ n = x \\<Longrightarrow>\n       xa \\<in> set (complex_roots_of_int_poly p)", "have \"min_int_poly x represents x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_int_poly x represents x", "using True"], ["proof (prove)\nusing this:\n  algebraic x\n\ngoal (1 subgoal):\n 1. min_int_poly x represents x", "by auto"], ["proof (state)\nthis:\n  min_int_poly x represents x\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa ^ n = x \\<Longrightarrow>\n       xa \\<in> set (complex_roots_of_int_poly p)", "from represents_nth_root[OF n0 y this]"], ["proof (chain)\npicking this:\n  poly_nth_root n (min_int_poly x) represents y", "have \"p represents y\""], ["proof (prove)\nusing this:\n  poly_nth_root n (min_int_poly x) represents y\n\ngoal (1 subgoal):\n 1. p represents y", "unfolding p_def"], ["proof (prove)\nusing this:\n  poly_nth_root n (min_int_poly x) represents y\n\ngoal (1 subgoal):\n 1. poly_nth_root n (min_int_poly x) represents y", "by auto"], ["proof (state)\nthis:\n  p represents y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa ^ n = x \\<Longrightarrow>\n       xa \\<in> set (complex_roots_of_int_poly p)", "thus \"y \\<in> set (complex_roots_of_int_poly p)\""], ["proof (prove)\nusing this:\n  p represents y\n\ngoal (1 subgoal):\n 1. y \\<in> set (complex_roots_of_int_poly p)", "by (subst complex_roots_of_int_poly, auto)"], ["proof (state)\nthis:\n  y \\<in> set (complex_roots_of_int_poly p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (all_croots n x) = {y. y ^ n = x}\n\ngoal (1 subgoal):\n 1. \\<not> algebraic x \\<Longrightarrow>\n    set (all_croots n x) = {y. y ^ n = x}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> algebraic x \\<Longrightarrow>\n    set (all_croots n x) = {y. y ^ n = x}", "case False"], ["proof (state)\nthis:\n  \\<not> algebraic x\n\ngoal (1 subgoal):\n 1. \\<not> algebraic x \\<Longrightarrow>\n    set (all_croots n x) = {y. y ^ n = x}", "hence id: \"(if n = 0 then y else if algebraic x then z else u) = u\" \n    for y z u :: \"complex list\""], ["proof (prove)\nusing this:\n  \\<not> algebraic x\n\ngoal (1 subgoal):\n 1. (if n = 0 then y else if algebraic x then z else u) = u", "using n0"], ["proof (prove)\nusing this:\n  \\<not> algebraic x\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if n = 0 then y else if algebraic x then z else u) = u", "by auto"], ["proof (state)\nthis:\n  (if n = 0 then ?y else if algebraic x then ?z else ?u) = ?u\n\ngoal (1 subgoal):\n 1. \\<not> algebraic x \\<Longrightarrow>\n    set (all_croots n x) = {y. y ^ n = x}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (all_croots n x) = {y. y ^ n = x}", "unfolding Let_def all_croots_def id"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (SOME ys. set ys = {y. y ^ n = x}) = {y. y ^ n = x}", "by (rule someI_ex, rule finite_list, insert n0, blast)"], ["proof (state)\nthis:\n  set (all_croots n x) = {y. y ^ n = x}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>A definition of \\emph{the} complex root of a complex number\\<close>"], ["", "text \\<open>While the definition of the complex root is quite natural and easy,\n  the main task is a criterion to determine which of all possible roots of a\n  complex number is the chosen one.\\<close>"], ["", "definition croot :: \"nat \\<Rightarrow> complex \\<Rightarrow> complex\" where\n  \"croot n x = (rcis (root n (cmod x)) (arg x / of_nat n))\""], ["", "lemma croot_0[simp]: \"croot n 0 = 0\" \"croot 0 x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. croot n 0 = 0 &&& croot 0 x = 0", "unfolding croot_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rcis (root n (cmod 0)) (arg 0 / real n) = 0 &&&\n    rcis (root 0 (cmod x)) (arg x / real 0) = 0", "by auto"], ["", "lemma croot_power: assumes n: \"n \\<noteq> 0\" \n  shows \"(croot n x) ^ n = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. croot n x ^ n = x", "unfolding croot_def DeMoivre2"], ["proof (prove)\ngoal (1 subgoal):\n 1. rcis (root n (cmod x) ^ n) (real n * (arg x / real n)) = x", "by (subst real_root_pow_pos2, insert n, auto simp: rcis_cmod_arg)"], ["", "lemma arg_of_real: \"arg (of_real x) = \n  (if x < 0 then pi else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg (cor x) = (if x < 0 then pi else 0)", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> arg (cor x) = (if x < 0 then pi else 0)\n 2. x \\<noteq> 0 \\<Longrightarrow> arg (cor x) = (if x < 0 then pi else 0)", "case False"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> arg (cor x) = (if x < 0 then pi else 0)\n 2. x \\<noteq> 0 \\<Longrightarrow> arg (cor x) = (if x < 0 then pi else 0)", "hence \"x < 0 \\<or> x > 0\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x < 0 \\<or> 0 < x", "by auto"], ["proof (state)\nthis:\n  x < 0 \\<or> 0 < x\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> arg (cor x) = (if x < 0 then pi else 0)\n 2. x \\<noteq> 0 \\<Longrightarrow> arg (cor x) = (if x < 0 then pi else 0)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x < 0 \\<or> 0 < x\n\ngoal (1 subgoal):\n 1. arg (cor x) = (if x < 0 then pi else 0)", "by (intro arg_unique, auto\n      simp: complex_sgn_def scaleR_complex.ctr complex_eq_iff)"], ["proof (state)\nthis:\n  arg (cor x) = (if x < 0 then pi else 0)\n\ngoal (1 subgoal):\n 1. x = 0 \\<Longrightarrow> arg (cor x) = (if x < 0 then pi else 0)", "qed (auto simp: arg_def)"], ["", "lemma arg_rcis_cis[simp]: assumes \"x > 0\" \n  shows \"arg (rcis x y) = arg (cis y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg (rcis x y) = arg (cis y)", "using assms"], ["proof (prove)\nusing this:\n  0 < x\n\ngoal (1 subgoal):\n 1. arg (rcis x y) = arg (cis y)", "unfolding rcis_def"], ["proof (prove)\nusing this:\n  0 < x\n\ngoal (1 subgoal):\n 1. arg (cor x * cis y) = arg (cis y)", "by simp"], ["", "lemma cis_arg_1[simp]: \"cis (arg 1) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (arg 1) = 1", "using arg_of_real[of 1]"], ["proof (prove)\nusing this:\n  arg (cor 1) = (if 1 < 0 then pi else 0)\n\ngoal (1 subgoal):\n 1. cis (arg 1) = 1", "by simp"], ["", "lemma cis_arg_power[simp]: assumes \"x \\<noteq> 0\" \n  shows \"cis (arg (x ^ n)) = cis (arg x * real n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (arg (x ^ n)) = cis (arg x * real n)", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. cis (arg (x ^ 0)) = cis (arg x * real 0)\n 2. \\<And>n.\n       cis (arg (x ^ n)) = cis (arg x * real n) \\<Longrightarrow>\n       cis (arg (x ^ Suc n)) = cis (arg x * real (Suc n))", "case (Suc n)"], ["proof (state)\nthis:\n  cis (arg (x ^ n)) = cis (arg x * real n)\n\ngoal (2 subgoals):\n 1. cis (arg (x ^ 0)) = cis (arg x * real 0)\n 2. \\<And>n.\n       cis (arg (x ^ n)) = cis (arg x * real n) \\<Longrightarrow>\n       cis (arg (x ^ Suc n)) = cis (arg x * real (Suc n))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (arg (x ^ Suc n)) = cis (arg x * real (Suc n))", "unfolding power.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (arg (x * x ^ n)) = cis (arg x * real (Suc n))", "proof (subst cis_arg_mult)"], ["proof (state)\ngoal (2 subgoals):\n 1. x * x ^ n \\<noteq> 0\n 2. cis (arg x + arg (x ^ n)) = cis (arg x * real (Suc n))", "show \"cis (arg x + arg (x ^ n)) = cis (arg x * real (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (arg x + arg (x ^ n)) = cis (arg x * real (Suc n))", "unfolding mult.commute[of \"arg x\"] DeMoivre[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (arg x + arg (x ^ n)) = cis (arg x) ^ Suc n", "unfolding power.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (arg x + arg (x ^ n)) = cis (arg x) * cis (arg x) ^ n", "using Suc"], ["proof (prove)\nusing this:\n  cis (arg (x ^ n)) = cis (arg x * real n)\n\ngoal (1 subgoal):\n 1. cis (arg x + arg (x ^ n)) = cis (arg x) * cis (arg x) ^ n", "by (metis DeMoivre cis_mult mult.commute)"], ["proof (state)\nthis:\n  cis (arg x + arg (x ^ n)) = cis (arg x * real (Suc n))\n\ngoal (1 subgoal):\n 1. x * x ^ n \\<noteq> 0", "show \"x * x ^ n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * x ^ n \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x * x ^ n \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  x * x ^ n \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cis (arg (x ^ Suc n)) = cis (arg x * real (Suc n))\n\ngoal (1 subgoal):\n 1. cis (arg (x ^ 0)) = cis (arg x * real 0)", "qed simp"], ["", "lemma arg_croot[simp]: \"arg (croot n x) = arg x / real n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg (croot n x) = arg x / real n", "proof (cases \"n = 0 \\<or> x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<or> x = 0 \\<Longrightarrow> arg (croot n x) = arg x / real n\n 2. \\<not> (n = 0 \\<or> x = 0) \\<Longrightarrow>\n    arg (croot n x) = arg x / real n", "case True"], ["proof (state)\nthis:\n  n = 0 \\<or> x = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<or> x = 0 \\<Longrightarrow> arg (croot n x) = arg x / real n\n 2. \\<not> (n = 0 \\<or> x = 0) \\<Longrightarrow>\n    arg (croot n x) = arg x / real n", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = 0 \\<or> x = 0\n\ngoal (1 subgoal):\n 1. arg (croot n x) = arg x / real n", "by (auto simp: arg_def)"], ["proof (state)\nthis:\n  arg (croot n x) = arg x / real n\n\ngoal (1 subgoal):\n 1. \\<not> (n = 0 \\<or> x = 0) \\<Longrightarrow>\n    arg (croot n x) = arg x / real n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (n = 0 \\<or> x = 0) \\<Longrightarrow>\n    arg (croot n x) = arg x / real n", "case False"], ["proof (state)\nthis:\n  \\<not> (n = 0 \\<or> x = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (n = 0 \\<or> x = 0) \\<Longrightarrow>\n    arg (croot n x) = arg x / real n", "hence n: \"n \\<noteq> 0\" and x: \"x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> (n = 0 \\<or> x = 0)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 &&& x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  n \\<noteq> 0\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (n = 0 \\<or> x = 0) \\<Longrightarrow>\n    arg (croot n x) = arg x / real n", "let ?root = \"croot n x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (n = 0 \\<or> x = 0) \\<Longrightarrow>\n    arg (croot n x) = arg x / real n", "from n"], ["proof (chain)\npicking this:\n  n \\<noteq> 0", "have n1: \"real n \\<ge> 1\" \"real n > 0\" \"real n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<le> real n &&& 0 < real n &&& real n \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  1 \\<le> real n\n  0 < real n\n  real n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (n = 0 \\<or> x = 0) \\<Longrightarrow>\n    arg (croot n x) = arg x / real n", "have bounded: \"- pi < arg x / real n \\<and> arg x / real n \\<le> pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - pi < arg x / real n \\<and> arg x / real n \\<le> pi", "proof (cases \"arg x < 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi\n 2. \\<not> arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi", "case True"], ["proof (state)\nthis:\n  arg x < 0\n\ngoal (2 subgoals):\n 1. arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi\n 2. \\<not> arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi", "from arg_bounded[of x]"], ["proof (chain)\npicking this:\n  - pi < arg x \\<and> arg x \\<le> pi", "have \"- pi < arg x\""], ["proof (prove)\nusing this:\n  - pi < arg x \\<and> arg x \\<le> pi\n\ngoal (1 subgoal):\n 1. - pi < arg x", "by auto"], ["proof (state)\nthis:\n  - pi < arg x\n\ngoal (2 subgoals):\n 1. arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi\n 2. \\<not> arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi", "also"], ["proof (state)\nthis:\n  - pi < arg x\n\ngoal (2 subgoals):\n 1. arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi\n 2. \\<not> arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi", "have \"\\<dots> \\<le> arg x / real n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg x \\<le> arg x / real n", "using n1 True"], ["proof (prove)\nusing this:\n  1 \\<le> real n\n  0 < real n\n  real n \\<noteq> 0\n  arg x < 0\n\ngoal (1 subgoal):\n 1. arg x \\<le> arg x / real n", "by (smt (z3) div_by_1 divide_minus_left frac_le)"], ["proof (state)\nthis:\n  arg x \\<le> arg x / real n\n\ngoal (2 subgoals):\n 1. arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi\n 2. \\<not> arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi", "finally"], ["proof (chain)\npicking this:\n  - pi < arg x / real n", "have one: \"- pi < arg x / real n\""], ["proof (prove)\nusing this:\n  - pi < arg x / real n\n\ngoal (1 subgoal):\n 1. - pi < arg x / real n", "."], ["proof (state)\nthis:\n  - pi < arg x / real n\n\ngoal (2 subgoals):\n 1. arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi\n 2. \\<not> arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi", "have \"arg x / real n \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg x / real n \\<le> 0", "using True n1"], ["proof (prove)\nusing this:\n  arg x < 0\n  1 \\<le> real n\n  0 < real n\n  real n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arg x / real n \\<le> 0", "by (smt (verit) divide_less_0_iff)"], ["proof (state)\nthis:\n  arg x / real n \\<le> 0\n\ngoal (2 subgoals):\n 1. arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi\n 2. \\<not> arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi", "also"], ["proof (state)\nthis:\n  arg x / real n \\<le> 0\n\ngoal (2 subgoals):\n 1. arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi\n 2. \\<not> arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi", "have \"\\<dots> \\<le> pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> pi", "by simp"], ["proof (state)\nthis:\n  0 \\<le> pi\n\ngoal (2 subgoals):\n 1. arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi\n 2. \\<not> arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi", "finally"], ["proof (chain)\npicking this:\n  arg x / real n \\<le> pi", "show ?thesis"], ["proof (prove)\nusing this:\n  arg x / real n \\<le> pi\n\ngoal (1 subgoal):\n 1. - pi < arg x / real n \\<and> arg x / real n \\<le> pi", "using one"], ["proof (prove)\nusing this:\n  arg x / real n \\<le> pi\n  - pi < arg x / real n\n\ngoal (1 subgoal):\n 1. - pi < arg x / real n \\<and> arg x / real n \\<le> pi", "by auto"], ["proof (state)\nthis:\n  - pi < arg x / real n \\<and> arg x / real n \\<le> pi\n\ngoal (1 subgoal):\n 1. \\<not> arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi", "case False"], ["proof (state)\nthis:\n  \\<not> arg x < 0\n\ngoal (1 subgoal):\n 1. \\<not> arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi", "hence ax: \"arg x \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<not> arg x < 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> arg x", "by auto"], ["proof (state)\nthis:\n  0 \\<le> arg x\n\ngoal (1 subgoal):\n 1. \\<not> arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi", "have \"arg x / real n \\<le> arg x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg x / real n \\<le> arg x", "using n1 ax"], ["proof (prove)\nusing this:\n  1 \\<le> real n\n  0 < real n\n  real n \\<noteq> 0\n  0 \\<le> arg x\n\ngoal (1 subgoal):\n 1. arg x / real n \\<le> arg x", "by (smt (verit) div_by_1 frac_le)"], ["proof (state)\nthis:\n  arg x / real n \\<le> arg x\n\ngoal (1 subgoal):\n 1. \\<not> arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi", "also"], ["proof (state)\nthis:\n  arg x / real n \\<le> arg x\n\ngoal (1 subgoal):\n 1. \\<not> arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi", "have \"\\<dots> \\<le> pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg x \\<le> pi", "using arg_bounded[of x]"], ["proof (prove)\nusing this:\n  - pi < arg x \\<and> arg x \\<le> pi\n\ngoal (1 subgoal):\n 1. arg x \\<le> pi", "by simp"], ["proof (state)\nthis:\n  arg x \\<le> pi\n\ngoal (1 subgoal):\n 1. \\<not> arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi", "finally"], ["proof (chain)\npicking this:\n  arg x / real n \\<le> pi", "have one: \"arg x / real n \\<le> pi\""], ["proof (prove)\nusing this:\n  arg x / real n \\<le> pi\n\ngoal (1 subgoal):\n 1. arg x / real n \\<le> pi", "."], ["proof (state)\nthis:\n  arg x / real n \\<le> pi\n\ngoal (1 subgoal):\n 1. \\<not> arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi", "have \"-pi < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - pi < 0", "by simp"], ["proof (state)\nthis:\n  - pi < 0\n\ngoal (1 subgoal):\n 1. \\<not> arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi", "also"], ["proof (state)\nthis:\n  - pi < 0\n\ngoal (1 subgoal):\n 1. \\<not> arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi", "have \"\\<dots> \\<le> arg x / real n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> arg x / real n", "using ax n1"], ["proof (prove)\nusing this:\n  0 \\<le> arg x\n  1 \\<le> real n\n  0 < real n\n  real n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 \\<le> arg x / real n", "by simp"], ["proof (state)\nthis:\n  0 \\<le> arg x / real n\n\ngoal (1 subgoal):\n 1. \\<not> arg x < 0 \\<Longrightarrow>\n    - pi < arg x / real n \\<and> arg x / real n \\<le> pi", "finally"], ["proof (chain)\npicking this:\n  - pi < arg x / real n", "show ?thesis"], ["proof (prove)\nusing this:\n  - pi < arg x / real n\n\ngoal (1 subgoal):\n 1. - pi < arg x / real n \\<and> arg x / real n \\<le> pi", "using one"], ["proof (prove)\nusing this:\n  - pi < arg x / real n\n  arg x / real n \\<le> pi\n\ngoal (1 subgoal):\n 1. - pi < arg x / real n \\<and> arg x / real n \\<le> pi", "by auto"], ["proof (state)\nthis:\n  - pi < arg x / real n \\<and> arg x / real n \\<le> pi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  - pi < arg x / real n \\<and> arg x / real n \\<le> pi\n\ngoal (1 subgoal):\n 1. \\<not> (n = 0 \\<or> x = 0) \\<Longrightarrow>\n    arg (croot n x) = arg x / real n", "have \"arg ?root = arg (cis (arg x / real n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg (croot n x) = arg (cis (arg x / real n))", "unfolding croot_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. arg (rcis (root n (cmod x)) (arg x / real n)) =\n    arg (cis (arg x / real n))", "using x n"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arg (rcis (root n (cmod x)) (arg x / real n)) =\n    arg (cis (arg x / real n))", "by simp"], ["proof (state)\nthis:\n  arg (croot n x) = arg (cis (arg x / real n))\n\ngoal (1 subgoal):\n 1. \\<not> (n = 0 \\<or> x = 0) \\<Longrightarrow>\n    arg (croot n x) = arg x / real n", "also"], ["proof (state)\nthis:\n  arg (croot n x) = arg (cis (arg x / real n))\n\ngoal (1 subgoal):\n 1. \\<not> (n = 0 \\<or> x = 0) \\<Longrightarrow>\n    arg (croot n x) = arg x / real n", "have \"\\<dots> = arg x / real n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg (cis (arg x / real n)) = arg x / real n", "by (rule arg_unique, force, insert bounded, auto)"], ["proof (state)\nthis:\n  arg (cis (arg x / real n)) = arg x / real n\n\ngoal (1 subgoal):\n 1. \\<not> (n = 0 \\<or> x = 0) \\<Longrightarrow>\n    arg (croot n x) = arg x / real n", "finally"], ["proof (chain)\npicking this:\n  arg (croot n x) = arg x / real n", "show ?thesis"], ["proof (prove)\nusing this:\n  arg (croot n x) = arg x / real n\n\ngoal (1 subgoal):\n 1. arg (croot n x) = arg x / real n", "."], ["proof (state)\nthis:\n  arg (croot n x) = arg x / real n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cos_abs[simp]: \"cos (abs x :: real) = cos x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos \\<bar>x\\<bar> = cos x", "proof (cases \"x < 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x < 0 \\<Longrightarrow> cos \\<bar>x\\<bar> = cos x\n 2. \\<not> x < 0 \\<Longrightarrow> cos \\<bar>x\\<bar> = cos x", "case True"], ["proof (state)\nthis:\n  x < 0\n\ngoal (2 subgoals):\n 1. x < 0 \\<Longrightarrow> cos \\<bar>x\\<bar> = cos x\n 2. \\<not> x < 0 \\<Longrightarrow> cos \\<bar>x\\<bar> = cos x", "hence abs: \"abs x = - x\""], ["proof (prove)\nusing this:\n  x < 0\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> = - x", "by simp"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> = - x\n\ngoal (2 subgoals):\n 1. x < 0 \\<Longrightarrow> cos \\<bar>x\\<bar> = cos x\n 2. \\<not> x < 0 \\<Longrightarrow> cos \\<bar>x\\<bar> = cos x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cos \\<bar>x\\<bar> = cos x", "unfolding abs"], ["proof (prove)\ngoal (1 subgoal):\n 1. cos (- x) = cos x", "by simp"], ["proof (state)\nthis:\n  cos \\<bar>x\\<bar> = cos x\n\ngoal (1 subgoal):\n 1. \\<not> x < 0 \\<Longrightarrow> cos \\<bar>x\\<bar> = cos x", "qed simp"], ["", "lemma cos_mono_le: assumes \"abs x \\<le> pi\" \n  and \"abs y \\<le> pi\" \nshows \"cos x \\<le> cos y \\<longleftrightarrow> abs y \\<le> abs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cos x \\<le> cos y) = (\\<bar>y\\<bar> \\<le> \\<bar>x\\<bar>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (cos x \\<le> cos y) = (\\<bar>y\\<bar> \\<le> \\<bar>x\\<bar>)", "have \"cos x \\<le> cos y \\<longleftrightarrow> cos (abs x) \\<le> cos (abs y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cos x \\<le> cos y) = (cos \\<bar>x\\<bar> \\<le> cos \\<bar>y\\<bar>)", "by simp"], ["proof (state)\nthis:\n  (cos x \\<le> cos y) = (cos \\<bar>x\\<bar> \\<le> cos \\<bar>y\\<bar>)\n\ngoal (1 subgoal):\n 1. (cos x \\<le> cos y) = (\\<bar>y\\<bar> \\<le> \\<bar>x\\<bar>)", "also"], ["proof (state)\nthis:\n  (cos x \\<le> cos y) = (cos \\<bar>x\\<bar> \\<le> cos \\<bar>y\\<bar>)\n\ngoal (1 subgoal):\n 1. (cos x \\<le> cos y) = (\\<bar>y\\<bar> \\<le> \\<bar>x\\<bar>)", "have \"\\<dots> \\<longleftrightarrow> abs y \\<le> abs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cos \\<bar>x\\<bar> \\<le> cos \\<bar>y\\<bar>) =\n    (\\<bar>y\\<bar> \\<le> \\<bar>x\\<bar>)", "by (subst cos_mono_le_eq, insert assms, auto)"], ["proof (state)\nthis:\n  (cos \\<bar>x\\<bar> \\<le> cos \\<bar>y\\<bar>) =\n  (\\<bar>y\\<bar> \\<le> \\<bar>x\\<bar>)\n\ngoal (1 subgoal):\n 1. (cos x \\<le> cos y) = (\\<bar>y\\<bar> \\<le> \\<bar>x\\<bar>)", "finally"], ["proof (chain)\npicking this:\n  (cos x \\<le> cos y) = (\\<bar>y\\<bar> \\<le> \\<bar>x\\<bar>)", "show ?thesis"], ["proof (prove)\nusing this:\n  (cos x \\<le> cos y) = (\\<bar>y\\<bar> \\<le> \\<bar>x\\<bar>)\n\ngoal (1 subgoal):\n 1. (cos x \\<le> cos y) = (\\<bar>y\\<bar> \\<le> \\<bar>x\\<bar>)", "."], ["proof (state)\nthis:\n  (cos x \\<le> cos y) = (\\<bar>y\\<bar> \\<le> \\<bar>x\\<bar>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma abs_add_2_mult_bound: fixes x :: \"'a :: linordered_idom\" \n  assumes xy: \"\\<bar>x\\<bar> \\<le> y\" \n  shows \"\\<bar>x\\<bar> \\<le> \\<bar>x + 2 * of_int i * y\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "proof (cases \"i = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "case i: False"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "let ?oi = \"of_int :: int \\<Rightarrow> 'a\""], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "from xy"], ["proof (chain)\npicking this:\n  \\<bar>x\\<bar> \\<le> y", "have y: \"y \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> \\<le> y\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> y", "by auto"], ["proof (state)\nthis:\n  (0::'a) \\<le> y\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "consider (pp) \"x \\<ge> 0\" \"i \\<ge> 0\" \n    | (nn) \"x \\<le> 0\" \"i \\<le> 0\" \n    | (pn) \"x \\<ge> 0\" \"i \\<le> 0\" \n    | (np) \"x \\<le> 0\" \"i \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>(0::'a) \\<le> x; 0 \\<le> i\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>x \\<le> (0::'a); i \\<le> 0\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>(0::'a) \\<le> x; 0 \\<le> i\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x \\<le> (0::'a); i \\<le> 0\\<rbrakk> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>(0::'a) \\<le> x; 0 \\<le> i\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x \\<le> (0::'a); i \\<le> 0\\<rbrakk> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 2. \\<lbrakk>x \\<le> (0::'a); i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 3. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 4. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "case pp"], ["proof (state)\nthis:\n  (0::'a) \\<le> x\n  0 \\<le> i\n\ngoal (4 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 2. \\<lbrakk>x \\<le> (0::'a); i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 3. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 4. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "thus ?thesis"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> x\n  0 \\<le> i\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "using y"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> x\n  0 \\<le> i\n  (0::'a) \\<le> y\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<le> (0::'a); i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 2. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 3. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<le> (0::'a); i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 2. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 3. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "case nn"], ["proof (state)\nthis:\n  x \\<le> (0::'a)\n  i \\<le> 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<le> (0::'a); i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 2. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 3. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "have \"x \\<ge> x + 2 * ?oi i * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + (2::'a) * of_int i * y \\<le> x", "using nn y"], ["proof (prove)\nusing this:\n  x \\<le> (0::'a)\n  i \\<le> 0\n  (0::'a) \\<le> y\n\ngoal (1 subgoal):\n 1. x + (2::'a) * of_int i * y \\<le> x", "by (simp add: mult_nonneg_nonpos2)"], ["proof (state)\nthis:\n  x + (2::'a) * of_int i * y \\<le> x\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<le> (0::'a); i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 2. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 3. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "with nn"], ["proof (chain)\npicking this:\n  x \\<le> (0::'a)\n  i \\<le> 0\n  x + (2::'a) * of_int i * y \\<le> x", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> (0::'a)\n  i \\<le> 0\n  x + (2::'a) * of_int i * y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "by linarith"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 2. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 2. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "case pn"], ["proof (state)\nthis:\n  (0::'a) \\<le> x\n  i \\<le> 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 2. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "with i"], ["proof (chain)\npicking this:\n  i \\<noteq> 0\n  (0::'a) \\<le> x\n  i \\<le> 0", "have \"0 \\<le> x\" \"i < 0\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  (0::'a) \\<le> x\n  i \\<le> 0\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> x &&& i < 0", "by auto"], ["proof (state)\nthis:\n  (0::'a) \\<le> x\n  i < 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 2. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "define j where \"j = nat (-i) - 1\""], ["proof (state)\nthis:\n  j = nat (- i) - 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 2. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "define z where \"z = x - 2 * y\""], ["proof (state)\nthis:\n  z = x - (2::'a) * y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 2. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "define u where \"u = 2 * ?oi (nat j) * y\""], ["proof (state)\nthis:\n  u = (2::'a) * of_int (int (nat (int j))) * y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 2. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "have u: \"u \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> u", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (2::'a) * of_int (int (nat (int j))) * y", "using y"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> y\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (2::'a) * of_int (int (nat (int j))) * y", "by auto"], ["proof (state)\nthis:\n  (0::'a) \\<le> u\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 2. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "have i: \"i = - int (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = - int (Suc j)", "using \\<open>i < 0\\<close>"], ["proof (prove)\nusing this:\n  i < 0\n\ngoal (1 subgoal):\n 1. i = - int (Suc j)", "unfolding j_def"], ["proof (prove)\nusing this:\n  i < 0\n\ngoal (1 subgoal):\n 1. i = - int (Suc (nat (- i) - 1))", "by simp"], ["proof (state)\nthis:\n  i = - int (Suc j)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 2. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "have id: \"x + 2 * ?oi i * y = z - u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + (2::'a) * of_int i * y = z - u", "unfolding i z_def u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + (2::'a) * of_int (- int (Suc j)) * y =\n    x - (2::'a) * y - (2::'a) * of_int (int (nat (int j))) * y", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  x + (2::'a) * of_int i * y = z - u\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 2. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "have z: \"z \\<le> 0\" \"abs z \\<ge> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<le> (0::'a) &&& x \\<le> \\<bar>z\\<bar>", "using xy y pn(1)"], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> \\<le> y\n  (0::'a) \\<le> y\n  (0::'a) \\<le> x\n\ngoal (1 subgoal):\n 1. z \\<le> (0::'a) &&& x \\<le> \\<bar>z\\<bar>", "unfolding z_def"], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> \\<le> y\n  (0::'a) \\<le> y\n  (0::'a) \\<le> x\n\ngoal (1 subgoal):\n 1. x - (2::'a) * y \\<le> (0::'a) &&& x \\<le> \\<bar>x - (2::'a) * y\\<bar>", "by auto"], ["proof (state)\nthis:\n  z \\<le> (0::'a)\n  x \\<le> \\<bar>z\\<bar>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n 2. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> \\<bar>z - u\\<bar>", "using pn(1) z u"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> x\n  z \\<le> (0::'a)\n  x \\<le> \\<bar>z\\<bar>\n  (0::'a) \\<le> u\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> \\<bar>z - u\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "case np"], ["proof (state)\nthis:\n  x \\<le> (0::'a)\n  0 \\<le> i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "with i"], ["proof (chain)\npicking this:\n  i \\<noteq> 0\n  x \\<le> (0::'a)\n  0 \\<le> i", "have \"0 \\<ge> x\" \"i > 0\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  x \\<le> (0::'a)\n  0 \\<le> i\n\ngoal (1 subgoal):\n 1. x \\<le> (0::'a) &&& 0 < i", "by auto"], ["proof (state)\nthis:\n  x \\<le> (0::'a)\n  0 < i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "define j where \"j = nat i - 1\""], ["proof (state)\nthis:\n  j = nat i - 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "have i: \"i = int (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = int (Suc j)", "using \\<open>i > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < i\n\ngoal (1 subgoal):\n 1. i = int (Suc j)", "unfolding j_def"], ["proof (prove)\nusing this:\n  0 < i\n\ngoal (1 subgoal):\n 1. i = int (Suc (nat i - 1))", "by simp"], ["proof (state)\nthis:\n  i = int (Suc j)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "define u where \"u = 2 * ?oi (nat j) * y\""], ["proof (state)\nthis:\n  u = (2::'a) * of_int (int (nat (int j))) * y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "have u: \"u \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> u", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (2::'a) * of_int (int (nat (int j))) * y", "using y"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> y\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (2::'a) * of_int (int (nat (int j))) * y", "by auto"], ["proof (state)\nthis:\n  (0::'a) \\<le> u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "define z where \"z = - x - 2 * y\""], ["proof (state)\nthis:\n  z = - x - (2::'a) * y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "have id: \"x + 2 * ?oi i * y = - z + u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + (2::'a) * of_int i * y = - z + u", "unfolding i z_def u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + (2::'a) * of_int (int (Suc j)) * y =\n    - (- x - (2::'a) * y) + (2::'a) * of_int (int (nat (int j))) * y", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  x + (2::'a) * of_int i * y = - z + u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "have z: \"z \\<le> 0\" \"abs z \\<ge> - x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<le> (0::'a) &&& - x \\<le> \\<bar>z\\<bar>", "using xy y np(1)"], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> \\<le> y\n  (0::'a) \\<le> y\n  x \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. z \\<le> (0::'a) &&& - x \\<le> \\<bar>z\\<bar>", "unfolding z_def"], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> \\<le> y\n  (0::'a) \\<le> y\n  x \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. - x - (2::'a) * y \\<le> (0::'a) &&&\n    - x \\<le> \\<bar>- x - (2::'a) * y\\<bar>", "by auto"], ["proof (state)\nthis:\n  z \\<le> (0::'a)\n  - x \\<le> \\<bar>z\\<bar>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<bar>x\\<bar>\n                      \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> \\<bar>- z + u\\<bar>", "using np(1) z u"], ["proof (prove)\nusing this:\n  x \\<le> (0::'a)\n  z \\<le> (0::'a)\n  - x \\<le> \\<bar>z\\<bar>\n  (0::'a) \\<le> u\n\ngoal (1 subgoal):\n 1. \\<bar>x\\<bar> \\<le> \\<bar>- z + u\\<bar>", "by simp"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>x\\<bar> \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow>\n    \\<bar>x\\<bar> \\<le> \\<bar>x + (2::'a) * of_int i * y\\<bar>", "qed simp"], ["", "lemma abs_eq_add_2_mult: fixes y :: \"'a :: linordered_idom\" \n  assumes abs_id: \"\\<bar>x\\<bar> = \\<bar>x + 2 * of_int i * y\\<bar>\" \n  and xy: \"- y < x\" \"x \\<le> y\" \n  and i: \"i \\<noteq> 0\" \nshows \"x = y \\<and> i = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y \\<and> i = - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = y \\<and> i = - 1", "let ?oi = \"of_int :: int \\<Rightarrow> 'a\""], ["proof (state)\ngoal (1 subgoal):\n 1. x = y \\<and> i = - 1", "from xy"], ["proof (chain)\npicking this:\n  - y < x\n  x \\<le> y", "have y: \"y > 0\""], ["proof (prove)\nusing this:\n  - y < x\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. (0::'a) < y", "by auto"], ["proof (state)\nthis:\n  (0::'a) < y\n\ngoal (1 subgoal):\n 1. x = y \\<and> i = - 1", "consider (pp) \"x \\<ge> 0\" \"i \\<ge> 0\" \n    | (nn) \"x < 0\" \"i \\<le> 0\" \n    | (pn) \"x \\<ge> 0\" \"i \\<le> 0\" \n    | (np) \"x < 0\" \"i \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>(0::'a) \\<le> x; 0 \\<le> i\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>x < (0::'a); i \\<le> 0\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>(0::'a) \\<le> x; 0 \\<le> i\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x < (0::'a); i \\<le> 0\\<rbrakk> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. x = y \\<and> i = - 1", "hence \"?thesis \\<or> x = ?oi (- i) * y\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>(0::'a) \\<le> x; 0 \\<le> i\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x < (0::'a); i \\<le> 0\\<rbrakk> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk> \\<Longrightarrow> ?thesis;\n   \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n 2. \\<lbrakk>x < (0::'a); i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n 3. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n 4. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "case pp"], ["proof (state)\nthis:\n  (0::'a) \\<le> x\n  0 \\<le> i\n\ngoal (4 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n 2. \\<lbrakk>x < (0::'a); i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n 3. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n 4. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "thus ?thesis"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> x\n  0 \\<le> i\n\ngoal (1 subgoal):\n 1. x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "using y abs_id xy i"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> x\n  0 \\<le> i\n  (0::'a) < y\n  \\<bar>x\\<bar> = \\<bar>x + (2::'a) * of_int i * y\\<bar>\n  - y < x\n  x \\<le> y\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "by simp"], ["proof (state)\nthis:\n  x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x < (0::'a); i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n 2. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n 3. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>x < (0::'a); i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n 2. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n 3. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "case nn"], ["proof (state)\nthis:\n  x < (0::'a)\n  i \\<le> 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x < (0::'a); i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n 2. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n 3. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "hence \"\\<bar>x + 2 * ?oi i * y\\<bar> = \n      - (x + 2 * ?oi i * y)\""], ["proof (prove)\nusing this:\n  x < (0::'a)\n  i \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<bar>x + (2::'a) * of_int i * y\\<bar> = - (x + (2::'a) * of_int i * y)", "using y nn"], ["proof (prove)\nusing this:\n  x < (0::'a)\n  i \\<le> 0\n  (0::'a) < y\n  x < (0::'a)\n  i \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<bar>x + (2::'a) * of_int i * y\\<bar> = - (x + (2::'a) * of_int i * y)", "by (intro abs_of_nonpos add_nonpos_nonpos, \n          force, simp, intro mult_nonneg_nonpos, auto)"], ["proof (state)\nthis:\n  \\<bar>x + (2::'a) * of_int i * y\\<bar> = - (x + (2::'a) * of_int i * y)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>x < (0::'a); i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n 2. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n 3. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>x + (2::'a) * of_int i * y\\<bar> = - (x + (2::'a) * of_int i * y)\n\ngoal (1 subgoal):\n 1. x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "using y abs_id xy i nn"], ["proof (prove)\nusing this:\n  \\<bar>x + (2::'a) * of_int i * y\\<bar> = - (x + (2::'a) * of_int i * y)\n  (0::'a) < y\n  \\<bar>x\\<bar> = \\<bar>x + (2::'a) * of_int i * y\\<bar>\n  - y < x\n  x \\<le> y\n  i \\<noteq> 0\n  x < (0::'a)\n  i \\<le> 0\n\ngoal (1 subgoal):\n 1. x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "by auto"], ["proof (state)\nthis:\n  x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n 2. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n 2. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "case pn"], ["proof (state)\nthis:\n  (0::'a) \\<le> x\n  i \\<le> 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n 2. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "with i"], ["proof (chain)\npicking this:\n  i \\<noteq> 0\n  (0::'a) \\<le> x\n  i \\<le> 0", "have \"0 \\<le> x\" \"i < 0\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  (0::'a) \\<le> x\n  i \\<le> 0\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> x &&& i < 0", "by auto"], ["proof (state)\nthis:\n  (0::'a) \\<le> x\n  i < 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n 2. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "define j where \"j = nat (-i) - 1\""], ["proof (state)\nthis:\n  j = nat (- i) - 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n 2. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "define z where \"z = x - 2 * y\""], ["proof (state)\nthis:\n  z = x - (2::'a) * y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n 2. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "define u where \"u = 2 * ?oi (nat j) * y\""], ["proof (state)\nthis:\n  u = (2::'a) * of_int (int (nat (int j))) * y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n 2. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "have u: \"u \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> u", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (2::'a) * of_int (int (nat (int j))) * y", "using y"], ["proof (prove)\nusing this:\n  (0::'a) < y\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (2::'a) * of_int (int (nat (int j))) * y", "by auto"], ["proof (state)\nthis:\n  (0::'a) \\<le> u\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n 2. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "have i: \"i = - int (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = - int (Suc j)", "using \\<open>i < 0\\<close>"], ["proof (prove)\nusing this:\n  i < 0\n\ngoal (1 subgoal):\n 1. i = - int (Suc j)", "unfolding j_def"], ["proof (prove)\nusing this:\n  i < 0\n\ngoal (1 subgoal):\n 1. i = - int (Suc (nat (- i) - 1))", "by simp"], ["proof (state)\nthis:\n  i = - int (Suc j)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n 2. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "have id: \"x + 2 * ?oi i * y = z - u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + (2::'a) * of_int i * y = z - u", "unfolding i z_def u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + (2::'a) * of_int (- int (Suc j)) * y =\n    x - (2::'a) * y - (2::'a) * of_int (int (nat (int j))) * y", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  x + (2::'a) * of_int i * y = z - u\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n 2. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "have z: \"z \\<le> 0\" \"abs z \\<ge> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<le> (0::'a) &&& x \\<le> \\<bar>z\\<bar>", "using xy y pn(1)"], ["proof (prove)\nusing this:\n  - y < x\n  x \\<le> y\n  (0::'a) < y\n  (0::'a) \\<le> x\n\ngoal (1 subgoal):\n 1. z \\<le> (0::'a) &&& x \\<le> \\<bar>z\\<bar>", "unfolding z_def"], ["proof (prove)\nusing this:\n  - y < x\n  x \\<le> y\n  (0::'a) < y\n  (0::'a) \\<le> x\n\ngoal (1 subgoal):\n 1. x - (2::'a) * y \\<le> (0::'a) &&& x \\<le> \\<bar>x - (2::'a) * y\\<bar>", "by auto"], ["proof (state)\nthis:\n  z \\<le> (0::'a)\n  x \\<le> \\<bar>z\\<bar>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n 2. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "from abs_id[unfolded id]"], ["proof (chain)\npicking this:\n  \\<bar>x\\<bar> = \\<bar>z - u\\<bar>", "have \"z - u = -x \""], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> = \\<bar>z - u\\<bar>\n\ngoal (1 subgoal):\n 1. z - u = - x", "using z u pn"], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> = \\<bar>z - u\\<bar>\n  z \\<le> (0::'a)\n  x \\<le> \\<bar>z\\<bar>\n  (0::'a) \\<le> u\n  (0::'a) \\<le> x\n  i \\<le> 0\n\ngoal (1 subgoal):\n 1. z - u = - x", "by auto"], ["proof (state)\nthis:\n  z - u = - x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n 2. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "from this[folded id]"], ["proof (chain)\npicking this:\n  x + (2::'a) * of_int i * y = - x", "have \"x = of_int (-i) * y\""], ["proof (prove)\nusing this:\n  x + (2::'a) * of_int i * y = - x\n\ngoal (1 subgoal):\n 1. x = of_int (- i) * y", "by auto"], ["proof (state)\nthis:\n  x = of_int (- i) * y\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(0::'a) \\<le> x; i \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n 2. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = of_int (- i) * y\n\ngoal (1 subgoal):\n 1. x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "by auto"], ["proof (state)\nthis:\n  x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "case np"], ["proof (state)\nthis:\n  x < (0::'a)\n  0 \\<le> i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "with i"], ["proof (chain)\npicking this:\n  i \\<noteq> 0\n  x < (0::'a)\n  0 \\<le> i", "have \"0 \\<ge> x\" \"i > 0\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  x < (0::'a)\n  0 \\<le> i\n\ngoal (1 subgoal):\n 1. x \\<le> (0::'a) &&& 0 < i", "by auto"], ["proof (state)\nthis:\n  x \\<le> (0::'a)\n  0 < i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "define j where \"j = nat i - 1\""], ["proof (state)\nthis:\n  j = nat i - 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "have i: \"i = int (Suc j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = int (Suc j)", "using \\<open>i > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < i\n\ngoal (1 subgoal):\n 1. i = int (Suc j)", "unfolding j_def"], ["proof (prove)\nusing this:\n  0 < i\n\ngoal (1 subgoal):\n 1. i = int (Suc (nat i - 1))", "by simp"], ["proof (state)\nthis:\n  i = int (Suc j)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "define u where \"u = 2 * ?oi (nat j) * y\""], ["proof (state)\nthis:\n  u = (2::'a) * of_int (int (nat (int j))) * y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "have u: \"u \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> u", "unfolding u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (2::'a) * of_int (int (nat (int j))) * y", "using y"], ["proof (prove)\nusing this:\n  (0::'a) < y\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> (2::'a) * of_int (int (nat (int j))) * y", "by auto"], ["proof (state)\nthis:\n  (0::'a) \\<le> u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "define z where \"z = - x - 2 * y\""], ["proof (state)\nthis:\n  z = - x - (2::'a) * y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "have id: \"x + 2 * ?oi i * y = - z + u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x + (2::'a) * of_int i * y = - z + u", "unfolding i z_def u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x + (2::'a) * of_int (int (Suc j)) * y =\n    - (- x - (2::'a) * y) + (2::'a) * of_int (int (nat (int j))) * y", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  x + (2::'a) * of_int i * y = - z + u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "have z: \"z \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<le> (0::'a)", "using xy y np(1)"], ["proof (prove)\nusing this:\n  - y < x\n  x \\<le> y\n  (0::'a) < y\n  x < (0::'a)\n\ngoal (1 subgoal):\n 1. z \\<le> (0::'a)", "unfolding z_def"], ["proof (prove)\nusing this:\n  - y < x\n  x \\<le> y\n  (0::'a) < y\n  x < (0::'a)\n\ngoal (1 subgoal):\n 1. - x - (2::'a) * y \\<le> (0::'a)", "by auto"], ["proof (state)\nthis:\n  z \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "from abs_id[unfolded id]"], ["proof (chain)\npicking this:\n  \\<bar>x\\<bar> = \\<bar>- z + u\\<bar>", "have \"- z + u = - x\""], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> = \\<bar>- z + u\\<bar>\n\ngoal (1 subgoal):\n 1. - z + u = - x", "using u z np"], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> = \\<bar>- z + u\\<bar>\n  (0::'a) \\<le> u\n  z \\<le> (0::'a)\n  x < (0::'a)\n  0 \\<le> i\n\ngoal (1 subgoal):\n 1. - z + u = - x", "by auto"], ["proof (state)\nthis:\n  - z + u = - x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "from this[folded id]"], ["proof (chain)\npicking this:\n  x + (2::'a) * of_int i * y = - x", "have \"x = of_int (- i) * y\""], ["proof (prove)\nusing this:\n  x + (2::'a) * of_int i * y = - x\n\ngoal (1 subgoal):\n 1. x = of_int (- i) * y", "by auto"], ["proof (state)\nthis:\n  x = of_int (- i) * y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x < (0::'a); 0 \\<le> i\\<rbrakk>\n    \\<Longrightarrow> x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = of_int (- i) * y\n\ngoal (1 subgoal):\n 1. x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y", "by auto"], ["proof (state)\nthis:\n  x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n\ngoal (1 subgoal):\n 1. x = y \\<and> i = - 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = y \\<and> i = - 1 \\<or> x = of_int (- i) * y\n\ngoal (1 subgoal):\n 1. x = y \\<and> i = - 1", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<and> i = - 1 \\<Longrightarrow> x = y \\<and> i = - 1\n 2. x = of_int (- i) * y \\<Longrightarrow> x = y \\<and> i = - 1", "assume \"x = ?oi (- i) * y\""], ["proof (state)\nthis:\n  x = of_int (- i) * y\n\ngoal (2 subgoals):\n 1. x = y \\<and> i = - 1 \\<Longrightarrow> x = y \\<and> i = - 1\n 2. x = of_int (- i) * y \\<Longrightarrow> x = y \\<and> i = - 1", "with xy i y"], ["proof (chain)\npicking this:\n  - y < x\n  x \\<le> y\n  i \\<noteq> 0\n  (0::'a) < y\n  x = of_int (- i) * y", "show ?thesis"], ["proof (prove)\nusing this:\n  - y < x\n  x \\<le> y\n  i \\<noteq> 0\n  (0::'a) < y\n  x = of_int (- i) * y\n\ngoal (1 subgoal):\n 1. x = y \\<and> i = - 1", "by (smt (verit, ccfv_SIG) less_le minus_less_iff mult_le_cancel_right2 mult_minus1_right mult_minus_left mult_of_int_commute of_int_hom.hom_one of_int_le_1_iff of_int_minus)"], ["proof (state)\nthis:\n  x = y \\<and> i = - 1\n\ngoal (1 subgoal):\n 1. x = y \\<and> i = - 1 \\<Longrightarrow> x = y \\<and> i = - 1", "qed"], ["proof (state)\nthis:\n  x = y \\<and> i = - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>This is the core lemma. It tells us that @{const croot} will choose the \n  principal root, i.e. the root with\n  largest real part and if there are two roots with identical real part, then the largest imaginary part.\n  This criterion will be crucial for implementing @{const croot}.\\<close>"], ["", "lemma croot_principal: assumes n: \"n \\<noteq> 0\"\n  and y: \"y ^ n = x\"\n  and neq: \"y \\<noteq> croot n x\"\nshows \"Re y < Re (croot n x) \\<or> Re y = Re (croot n x) \\<and> Im y < Im (croot n x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "case True"], ["proof (state)\nthis:\n  x = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "with neq y"], ["proof (chain)\npicking this:\n  y \\<noteq> croot n x\n  y ^ n = x\n  x = 0", "have False"], ["proof (prove)\nusing this:\n  y \\<noteq> croot n x\n  y ^ n = x\n  x = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)\n 2. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", ".."], ["proof (state)\nthis:\n  Re y < Re (croot n x) \\<or>\n  Re y = Re (croot n x) \\<and> Im y < Im (croot n x)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "case x: False"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "let ?root = \"croot n x\""], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "from n"], ["proof (chain)\npicking this:\n  n \\<noteq> 0", "have n1: \"real n \\<ge> 1\" \"real n > 0\" \"real n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 1 \\<le> real n &&& 0 < real n &&& real n \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  1 \\<le> real n\n  0 < real n\n  real n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "from x y n"], ["proof (chain)\npicking this:\n  x \\<noteq> 0\n  y ^ n = x\n  n \\<noteq> 0", "have y0: \"y \\<noteq> 0\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  y ^ n = x\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "from croot_power[OF n, of x] y"], ["proof (chain)\npicking this:\n  croot n x ^ n = x\n  y ^ n = x", "have id: \"?root ^ n = y ^ n\""], ["proof (prove)\nusing this:\n  croot n x ^ n = x\n  y ^ n = x\n\ngoal (1 subgoal):\n 1. croot n x ^ n = y ^ n", "by simp"], ["proof (state)\nthis:\n  croot n x ^ n = y ^ n\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "hence \"cmod (?root ^ n) = cmod (y ^ n)\""], ["proof (prove)\nusing this:\n  croot n x ^ n = y ^ n\n\ngoal (1 subgoal):\n 1. cmod (croot n x ^ n) = cmod (y ^ n)", "by simp"], ["proof (state)\nthis:\n  cmod (croot n x ^ n) = cmod (y ^ n)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "hence norm_eq: \"cmod ?root = cmod y\""], ["proof (prove)\nusing this:\n  cmod (croot n x ^ n) = cmod (y ^ n)\n\ngoal (1 subgoal):\n 1. cmod (croot n x) = cmod y", "using n"], ["proof (prove)\nusing this:\n  cmod (croot n x ^ n) = cmod (y ^ n)\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cmod (croot n x) = cmod y", "unfolding norm_power"], ["proof (prove)\nusing this:\n  cmod (croot n x) ^ n = cmod y ^ n\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. cmod (croot n x) = cmod y", "by (meson gr_zeroI norm_ge_zero power_eq_imp_eq_base)"], ["proof (state)\nthis:\n  cmod (croot n x) = cmod y\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "have \"cis (arg y * real n) = cis (arg (y^n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (arg y * real n) = cis (arg (y ^ n))", "by (subst cis_arg_power[OF y0], simp)"], ["proof (state)\nthis:\n  cis (arg y * real n) = cis (arg (y ^ n))\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "also"], ["proof (state)\nthis:\n  cis (arg y * real n) = cis (arg (y ^ n))\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "have \"\\<dots> = cis (arg x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cis (arg (y ^ n)) = cis (arg x)", "using y"], ["proof (prove)\nusing this:\n  y ^ n = x\n\ngoal (1 subgoal):\n 1. cis (arg (y ^ n)) = cis (arg x)", "by simp"], ["proof (state)\nthis:\n  cis (arg (y ^ n)) = cis (arg x)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "finally"], ["proof (chain)\npicking this:\n  cis (arg y * real n) = cis (arg x)", "have ciseq: \"cis (arg y * real n) = cis (arg x)\""], ["proof (prove)\nusing this:\n  cis (arg y * real n) = cis (arg x)\n\ngoal (1 subgoal):\n 1. cis (arg y * real n) = cis (arg x)", "by simp"], ["proof (state)\nthis:\n  cis (arg y * real n) = cis (arg x)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "from cis_eq[OF ciseq]"], ["proof (chain)\npicking this:\n  \\<exists>xa. arg y * real n - arg x = 2 * real_of_int xa * pi", "obtain i where\n    \"arg y * real n - arg x = 2 * real_of_int i * pi\""], ["proof (prove)\nusing this:\n  \\<exists>xa. arg y * real n - arg x = 2 * real_of_int xa * pi\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        arg y * real n - arg x = 2 * real_of_int i * pi \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  arg y * real n - arg x = 2 * real_of_int i * pi\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "hence \"arg y * real n = arg x + 2 * real_of_int i * pi\""], ["proof (prove)\nusing this:\n  arg y * real n - arg x = 2 * real_of_int i * pi\n\ngoal (1 subgoal):\n 1. arg y * real n = arg x + 2 * real_of_int i * pi", "by auto"], ["proof (state)\nthis:\n  arg y * real n = arg x + 2 * real_of_int i * pi\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "from arg_cong[OF this, of \"\\<lambda> x. x / real n\"] n1"], ["proof (chain)\npicking this:\n  arg y * real n / real n = (arg x + 2 * real_of_int i * pi) / real n\n  1 \\<le> real n\n  0 < real n\n  real n \\<noteq> 0", "have argy: \"arg y = arg ?root + 2 * real_of_int i * pi / real n\""], ["proof (prove)\nusing this:\n  arg y * real n / real n = (arg x + 2 * real_of_int i * pi) / real n\n  1 \\<le> real n\n  0 < real n\n  real n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arg y = arg (croot n x) + 2 * real_of_int i * pi / real n", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  arg y = arg (croot n x) + 2 * real_of_int i * pi / real n\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "have i0: \"i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow> False", "assume \"i = 0\""], ["proof (state)\nthis:\n  i = 0\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow> False", "hence \"arg y = arg ?root\""], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. arg y = arg (croot n x)", "unfolding argy"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. arg (croot n x) + 2 * real_of_int i * pi / real n = arg (croot n x)", "by simp"], ["proof (state)\nthis:\n  arg y = arg (croot n x)\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow> False", "with norm_eq"], ["proof (chain)\npicking this:\n  cmod (croot n x) = cmod y\n  arg y = arg (croot n x)", "have \"?root = y\""], ["proof (prove)\nusing this:\n  cmod (croot n x) = cmod y\n  arg y = arg (croot n x)\n\ngoal (1 subgoal):\n 1. croot n x = y", "by (metis rcis_cmod_arg)"], ["proof (state)\nthis:\n  croot n x = y\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow> False", "with neq"], ["proof (chain)\npicking this:\n  y \\<noteq> croot n x\n  croot n x = y", "show False"], ["proof (prove)\nusing this:\n  y \\<noteq> croot n x\n  croot n x = y\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "from y0"], ["proof (chain)\npicking this:\n  y \\<noteq> 0", "have cy0: \"cmod y > 0\""], ["proof (prove)\nusing this:\n  y \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < cmod y", "by auto"], ["proof (state)\nthis:\n  0 < cmod y\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "from arg_bounded[of x]"], ["proof (chain)\npicking this:\n  - pi < arg x \\<and> arg x \\<le> pi", "have abs_pi: \"abs (arg x) \\<le> pi\""], ["proof (prove)\nusing this:\n  - pi < arg x \\<and> arg x \\<le> pi\n\ngoal (1 subgoal):\n 1. \\<bar>arg x\\<bar> \\<le> pi", "by auto"], ["proof (state)\nthis:\n  \\<bar>arg x\\<bar> \\<le> pi\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "have \"Re y \\<le> Re ?root \\<longleftrightarrow> Re y / cmod y \\<le> Re ?root / cmod y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Re y \\<le> Re (croot n x)) =\n    (Re y / cmod y \\<le> Re (croot n x) / cmod y)", "using cy0"], ["proof (prove)\nusing this:\n  0 < cmod y\n\ngoal (1 subgoal):\n 1. (Re y \\<le> Re (croot n x)) =\n    (Re y / cmod y \\<le> Re (croot n x) / cmod y)", "unfolding divide_le_cancel"], ["proof (prove)\nusing this:\n  0 < cmod y\n\ngoal (1 subgoal):\n 1. (Re y \\<le> Re (croot n x)) =\n    ((0 < cmod y \\<longrightarrow> Re y \\<le> Re (croot n x)) \\<and>\n     (cmod y < 0 \\<longrightarrow> Re (croot n x) \\<le> Re y))", "by simp"], ["proof (state)\nthis:\n  (Re y \\<le> Re (croot n x)) =\n  (Re y / cmod y \\<le> Re (croot n x) / cmod y)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "also"], ["proof (state)\nthis:\n  (Re y \\<le> Re (croot n x)) =\n  (Re y / cmod y \\<le> Re (croot n x) / cmod y)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "have cosy: \"Re y / cmod y = cos (arg y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re y / cmod y = cos (arg y)", "unfolding cos_arg[OF y0]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re y / cmod y = Re y / cmod y", ".."], ["proof (state)\nthis:\n  Re y / cmod y = cos (arg y)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "also"], ["proof (state)\nthis:\n  Re y / cmod y = cos (arg y)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "have cosrt: \"Re ?root / cmod y = cos (arg ?root)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (croot n x) / cmod y = cos (arg (croot n x))", "unfolding norm_eq[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re (croot n x) / cmod (croot n x) = cos (arg (croot n x))", "by (subst cos_arg, insert norm_eq cy0, auto)"], ["proof (state)\nthis:\n  Re (croot n x) / cmod y = cos (arg (croot n x))\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "also"], ["proof (state)\nthis:\n  Re (croot n x) / cmod y = cos (arg (croot n x))\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "have \"cos (arg y) \\<le> cos (arg ?root) \\<longleftrightarrow> abs (arg ?root) \\<le> abs (arg y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cos (arg y) \\<le> cos (arg (croot n x))) =\n    (\\<bar>arg (croot n x)\\<bar> \\<le> \\<bar>arg y\\<bar>)", "by (rule cos_mono_le, insert arg_bounded[of y] arg_bounded[of ?root], auto)"], ["proof (state)\nthis:\n  (cos (arg y) \\<le> cos (arg (croot n x))) =\n  (\\<bar>arg (croot n x)\\<bar> \\<le> \\<bar>arg y\\<bar>)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "also"], ["proof (state)\nthis:\n  (cos (arg y) \\<le> cos (arg (croot n x))) =\n  (\\<bar>arg (croot n x)\\<bar> \\<le> \\<bar>arg y\\<bar>)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "have \"\\<dots> \\<longleftrightarrow> abs (arg ?root) * real n \\<le> abs (arg y) * real n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<bar>arg (croot n x)\\<bar> \\<le> \\<bar>arg y\\<bar>) =\n    (\\<bar>arg (croot n x)\\<bar> * real n \\<le> \\<bar>arg y\\<bar> * real n)", "unfolding mult_le_cancel_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<bar>arg (croot n x)\\<bar> \\<le> \\<bar>arg y\\<bar>) =\n    ((0 < real n \\<longrightarrow>\n      \\<bar>arg (croot n x)\\<bar> \\<le> \\<bar>arg y\\<bar>) \\<and>\n     (real n < 0 \\<longrightarrow>\n      \\<bar>arg y\\<bar> \\<le> \\<bar>arg (croot n x)\\<bar>))", "using n1"], ["proof (prove)\nusing this:\n  1 \\<le> real n\n  0 < real n\n  real n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<bar>arg (croot n x)\\<bar> \\<le> \\<bar>arg y\\<bar>) =\n    ((0 < real n \\<longrightarrow>\n      \\<bar>arg (croot n x)\\<bar> \\<le> \\<bar>arg y\\<bar>) \\<and>\n     (real n < 0 \\<longrightarrow>\n      \\<bar>arg y\\<bar> \\<le> \\<bar>arg (croot n x)\\<bar>))", "by simp"], ["proof (state)\nthis:\n  (\\<bar>arg (croot n x)\\<bar> \\<le> \\<bar>arg y\\<bar>) =\n  (\\<bar>arg (croot n x)\\<bar> * real n \\<le> \\<bar>arg y\\<bar> * real n)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "also"], ["proof (state)\nthis:\n  (\\<bar>arg (croot n x)\\<bar> \\<le> \\<bar>arg y\\<bar>) =\n  (\\<bar>arg (croot n x)\\<bar> * real n \\<le> \\<bar>arg y\\<bar> * real n)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "have \"\\<dots> \\<longleftrightarrow> abs (arg x) \\<le> \\<bar>arg x + 2 * real_of_int i * pi\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<bar>arg (croot n x)\\<bar> * real n\n     \\<le> \\<bar>arg y\\<bar> * real n) =\n    (\\<bar>arg x\\<bar> \\<le> \\<bar>arg x + 2 * real_of_int i * pi\\<bar>)", "unfolding argy"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<bar>arg (croot n x)\\<bar> * real n\n     \\<le> \\<bar>arg (croot n x) + 2 * real_of_int i * pi / real n\\<bar> *\n           real n) =\n    (\\<bar>arg x\\<bar> \\<le> \\<bar>arg x + 2 * real_of_int i * pi\\<bar>)", "using n1"], ["proof (prove)\nusing this:\n  1 \\<le> real n\n  0 < real n\n  real n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<bar>arg (croot n x)\\<bar> * real n\n     \\<le> \\<bar>arg (croot n x) + 2 * real_of_int i * pi / real n\\<bar> *\n           real n) =\n    (\\<bar>arg x\\<bar> \\<le> \\<bar>arg x + 2 * real_of_int i * pi\\<bar>)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (\\<bar>arg (croot n x)\\<bar> * real n \\<le> \\<bar>arg y\\<bar> * real n) =\n  (\\<bar>arg x\\<bar> \\<le> \\<bar>arg x + 2 * real_of_int i * pi\\<bar>)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "also"], ["proof (state)\nthis:\n  (\\<bar>arg (croot n x)\\<bar> * real n \\<le> \\<bar>arg y\\<bar> * real n) =\n  (\\<bar>arg x\\<bar> \\<le> \\<bar>arg x + 2 * real_of_int i * pi\\<bar>)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "have \"\\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>arg x\\<bar> \\<le> \\<bar>arg x + 2 * real_of_int i * pi\\<bar>", "using abs_pi"], ["proof (prove)\nusing this:\n  \\<bar>arg x\\<bar> \\<le> pi\n\ngoal (1 subgoal):\n 1. \\<bar>arg x\\<bar> \\<le> \\<bar>arg x + 2 * real_of_int i * pi\\<bar>", "by (rule abs_add_2_mult_bound)"], ["proof (state)\nthis:\n  \\<bar>arg x\\<bar> \\<le> \\<bar>arg x + 2 * real_of_int i * pi\\<bar>\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "finally"], ["proof (chain)\npicking this:\n  Re y \\<le> Re (croot n x)", "have le: \"Re y \\<le> Re (croot n x)\""], ["proof (prove)\nusing this:\n  Re y \\<le> Re (croot n x)\n\ngoal (1 subgoal):\n 1. Re y \\<le> Re (croot n x)", "."], ["proof (state)\nthis:\n  Re y \\<le> Re (croot n x)\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "proof (cases \"Re y = Re (croot n x)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Re y = Re (croot n x) \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)\n 2. Re y \\<noteq> Re (croot n x) \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "case False"], ["proof (state)\nthis:\n  Re y \\<noteq> Re (croot n x)\n\ngoal (2 subgoals):\n 1. Re y = Re (croot n x) \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)\n 2. Re y \\<noteq> Re (croot n x) \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "with le"], ["proof (chain)\npicking this:\n  Re y \\<le> Re (croot n x)\n  Re y \\<noteq> Re (croot n x)", "show ?thesis"], ["proof (prove)\nusing this:\n  Re y \\<le> Re (croot n x)\n  Re y \\<noteq> Re (croot n x)\n\ngoal (1 subgoal):\n 1. Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "by auto"], ["proof (state)\nthis:\n  Re y < Re (croot n x) \\<or>\n  Re y = Re (croot n x) \\<and> Im y < Im (croot n x)\n\ngoal (1 subgoal):\n 1. Re y = Re (croot n x) \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Re y = Re (croot n x) \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "case True"], ["proof (state)\nthis:\n  Re y = Re (croot n x)\n\ngoal (1 subgoal):\n 1. Re y = Re (croot n x) \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "hence \"Re y / cmod y = Re ?root / cmod y\""], ["proof (prove)\nusing this:\n  Re y = Re (croot n x)\n\ngoal (1 subgoal):\n 1. Re y / cmod y = Re (croot n x) / cmod y", "by simp"], ["proof (state)\nthis:\n  Re y / cmod y = Re (croot n x) / cmod y\n\ngoal (1 subgoal):\n 1. Re y = Re (croot n x) \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "hence \"cos (arg y) = cos (arg ?root)\""], ["proof (prove)\nusing this:\n  Re y / cmod y = Re (croot n x) / cmod y\n\ngoal (1 subgoal):\n 1. cos (arg y) = cos (arg (croot n x))", "unfolding cosy cosrt"], ["proof (prove)\nusing this:\n  cos (arg y) = cos (arg (croot n x))\n\ngoal (1 subgoal):\n 1. cos (arg y) = cos (arg (croot n x))", "."], ["proof (state)\nthis:\n  cos (arg y) = cos (arg (croot n x))\n\ngoal (1 subgoal):\n 1. Re y = Re (croot n x) \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "hence \"cos (abs (arg y)) = cos (abs (arg ?root))\""], ["proof (prove)\nusing this:\n  cos (arg y) = cos (arg (croot n x))\n\ngoal (1 subgoal):\n 1. cos \\<bar>arg y\\<bar> = cos \\<bar>arg (croot n x)\\<bar>", "unfolding cos_abs"], ["proof (prove)\nusing this:\n  cos (arg y) = cos (arg (croot n x))\n\ngoal (1 subgoal):\n 1. cos (arg y) = cos (arg (croot n x))", "."], ["proof (state)\nthis:\n  cos \\<bar>arg y\\<bar> = cos \\<bar>arg (croot n x)\\<bar>\n\ngoal (1 subgoal):\n 1. Re y = Re (croot n x) \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "from cos_inj_pi[OF _ _ _ _ this]"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> \\<bar>arg y\\<bar>; \\<bar>arg y\\<bar> \\<le> pi;\n   0 \\<le> \\<bar>arg (croot n x)\\<bar>;\n   \\<bar>arg (croot n x)\\<bar> \\<le> pi\\<rbrakk>\n  \\<Longrightarrow> \\<bar>arg y\\<bar> = \\<bar>arg (croot n x)\\<bar>", "have \"abs (arg y) = abs (arg ?root)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> \\<bar>arg y\\<bar>; \\<bar>arg y\\<bar> \\<le> pi;\n   0 \\<le> \\<bar>arg (croot n x)\\<bar>;\n   \\<bar>arg (croot n x)\\<bar> \\<le> pi\\<rbrakk>\n  \\<Longrightarrow> \\<bar>arg y\\<bar> = \\<bar>arg (croot n x)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>arg y\\<bar> = \\<bar>arg (croot n x)\\<bar>", "using arg_bounded[of y] arg_bounded[of ?root]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> \\<bar>arg y\\<bar>; \\<bar>arg y\\<bar> \\<le> pi;\n   0 \\<le> \\<bar>arg (croot n x)\\<bar>;\n   \\<bar>arg (croot n x)\\<bar> \\<le> pi\\<rbrakk>\n  \\<Longrightarrow> \\<bar>arg y\\<bar> = \\<bar>arg (croot n x)\\<bar>\n  - pi < arg y \\<and> arg y \\<le> pi\n  - pi < arg (croot n x) \\<and> arg (croot n x) \\<le> pi\n\ngoal (1 subgoal):\n 1. \\<bar>arg y\\<bar> = \\<bar>arg (croot n x)\\<bar>", "by auto"], ["proof (state)\nthis:\n  \\<bar>arg y\\<bar> = \\<bar>arg (croot n x)\\<bar>\n\ngoal (1 subgoal):\n 1. Re y = Re (croot n x) \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "hence \"abs (arg y) * real n = abs (arg ?root) * real n\""], ["proof (prove)\nusing this:\n  \\<bar>arg y\\<bar> = \\<bar>arg (croot n x)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>arg y\\<bar> * real n = \\<bar>arg (croot n x)\\<bar> * real n", "by simp"], ["proof (state)\nthis:\n  \\<bar>arg y\\<bar> * real n = \\<bar>arg (croot n x)\\<bar> * real n\n\ngoal (1 subgoal):\n 1. Re y = Re (croot n x) \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "hence \"abs (arg x) = \\<bar>arg x + 2 * real_of_int i * pi\\<bar>\""], ["proof (prove)\nusing this:\n  \\<bar>arg y\\<bar> * real n = \\<bar>arg (croot n x)\\<bar> * real n\n\ngoal (1 subgoal):\n 1. \\<bar>arg x\\<bar> = \\<bar>arg x + 2 * real_of_int i * pi\\<bar>", "unfolding argy"], ["proof (prove)\nusing this:\n  \\<bar>arg (croot n x) + 2 * real_of_int i * pi / real n\\<bar> * real n =\n  \\<bar>arg (croot n x)\\<bar> * real n\n\ngoal (1 subgoal):\n 1. \\<bar>arg x\\<bar> = \\<bar>arg x + 2 * real_of_int i * pi\\<bar>", "using n1"], ["proof (prove)\nusing this:\n  \\<bar>arg (croot n x) + 2 * real_of_int i * pi / real n\\<bar> * real n =\n  \\<bar>arg (croot n x)\\<bar> * real n\n  1 \\<le> real n\n  0 < real n\n  real n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<bar>arg x\\<bar> = \\<bar>arg x + 2 * real_of_int i * pi\\<bar>", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  \\<bar>arg x\\<bar> = \\<bar>arg x + 2 * real_of_int i * pi\\<bar>\n\ngoal (1 subgoal):\n 1. Re y = Re (croot n x) \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "from abs_eq_add_2_mult[OF this _ _ \\<open>i \\<noteq> 0\\<close>] arg_bounded[of x]"], ["proof (chain)\npicking this:\n  \\<lbrakk>- pi < arg x; arg x \\<le> pi\\<rbrakk>\n  \\<Longrightarrow> arg x = pi \\<and> i = - 1\n  - pi < arg x \\<and> arg x \\<le> pi", "have argx: \"arg x = pi\" and i: \"i = -1\""], ["proof (prove)\nusing this:\n  \\<lbrakk>- pi < arg x; arg x \\<le> pi\\<rbrakk>\n  \\<Longrightarrow> arg x = pi \\<and> i = - 1\n  - pi < arg x \\<and> arg x \\<le> pi\n\ngoal (1 subgoal):\n 1. arg x = pi &&& i = - 1", "by auto"], ["proof (state)\nthis:\n  arg x = pi\n  i = - 1\n\ngoal (1 subgoal):\n 1. Re y = Re (croot n x) \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "have argy: \"arg y = -pi / real n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg y = - pi / real n", "unfolding argy arg_croot i argx"], ["proof (prove)\ngoal (1 subgoal):\n 1. pi / real n + 2 * real_of_int (- 1) * pi / real n = - pi / real n", "by simp"], ["proof (state)\nthis:\n  arg y = - pi / real n\n\ngoal (1 subgoal):\n 1. Re y = Re (croot n x) \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "have \"Im ?root > Im y \\<longleftrightarrow> Im ?root / cmod ?root > Im y / cmod y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Im y < Im (croot n x)) =\n    (Im y / cmod y < Im (croot n x) / cmod (croot n x))", "unfolding norm_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Im y < Im (croot n x)) = (Im y / cmod y < Im (croot n x) / cmod y)", "using cy0"], ["proof (prove)\nusing this:\n  0 < cmod y\n\ngoal (1 subgoal):\n 1. (Im y < Im (croot n x)) = (Im y / cmod y < Im (croot n x) / cmod y)", "by (meson divide_less_cancel divide_strict_right_mono)"], ["proof (state)\nthis:\n  (Im y < Im (croot n x)) =\n  (Im y / cmod y < Im (croot n x) / cmod (croot n x))\n\ngoal (1 subgoal):\n 1. Re y = Re (croot n x) \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "also"], ["proof (state)\nthis:\n  (Im y < Im (croot n x)) =\n  (Im y / cmod y < Im (croot n x) / cmod (croot n x))\n\ngoal (1 subgoal):\n 1. Re y = Re (croot n x) \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "have \"\\<dots> \\<longleftrightarrow> sin (arg ?root) > sin (arg y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Im y / cmod y < Im (croot n x) / cmod (croot n x)) =\n    (sin (arg y) < sin (arg (croot n x)))", "by (subst (1 2) sin_arg, insert y0 norm_eq, auto)"], ["proof (state)\nthis:\n  (Im y / cmod y < Im (croot n x) / cmod (croot n x)) =\n  (sin (arg y) < sin (arg (croot n x)))\n\ngoal (1 subgoal):\n 1. Re y = Re (croot n x) \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "also"], ["proof (state)\nthis:\n  (Im y / cmod y < Im (croot n x) / cmod (croot n x)) =\n  (sin (arg y) < sin (arg (croot n x)))\n\ngoal (1 subgoal):\n 1. Re y = Re (croot n x) \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "have \"\\<dots> \\<longleftrightarrow> sin (- pi / real n) < sin (pi / real n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sin (arg y) < sin (arg (croot n x))) =\n    (sin (- pi / real n) < sin (pi / real n))", "unfolding argy arg_croot argx"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sin (- pi / real n) < sin (pi / real n)) =\n    (sin (- pi / real n) < sin (pi / real n))", "by simp"], ["proof (state)\nthis:\n  (sin (arg y) < sin (arg (croot n x))) =\n  (sin (- pi / real n) < sin (pi / real n))\n\ngoal (1 subgoal):\n 1. Re y = Re (croot n x) \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "also"], ["proof (state)\nthis:\n  (sin (arg y) < sin (arg (croot n x))) =\n  (sin (- pi / real n) < sin (pi / real n))\n\ngoal (1 subgoal):\n 1. Re y = Re (croot n x) \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "have \\<dots>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sin (- pi / real n) < sin (pi / real n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sin (- pi / real n) < sin (pi / real n)", "have \"sin (- pi / real n) < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sin (- pi / real n) < 0", "using n1"], ["proof (prove)\nusing this:\n  1 \\<le> real n\n  0 < real n\n  real n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sin (- pi / real n) < 0", "by (smt (verit) arg_bounded argy divide_neg_pos sin_gt_zero sin_minus)"], ["proof (state)\nthis:\n  sin (- pi / real n) < 0\n\ngoal (1 subgoal):\n 1. sin (- pi / real n) < sin (pi / real n)", "also"], ["proof (state)\nthis:\n  sin (- pi / real n) < 0\n\ngoal (1 subgoal):\n 1. sin (- pi / real n) < sin (pi / real n)", "have \"\\<dots> < sin (pi / real n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < sin (pi / real n)", "using n1 calculation"], ["proof (prove)\nusing this:\n  1 \\<le> real n\n  0 < real n\n  real n \\<noteq> 0\n  sin (- pi / real n) < 0\n\ngoal (1 subgoal):\n 1. 0 < sin (pi / real n)", "by fastforce"], ["proof (state)\nthis:\n  0 < sin (pi / real n)\n\ngoal (1 subgoal):\n 1. sin (- pi / real n) < sin (pi / real n)", "finally"], ["proof (chain)\npicking this:\n  sin (- pi / real n) < sin (pi / real n)", "show ?thesis"], ["proof (prove)\nusing this:\n  sin (- pi / real n) < sin (pi / real n)\n\ngoal (1 subgoal):\n 1. sin (- pi / real n) < sin (pi / real n)", "."], ["proof (state)\nthis:\n  sin (- pi / real n) < sin (pi / real n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sin (- pi / real n) < sin (pi / real n)\n\ngoal (1 subgoal):\n 1. Re y = Re (croot n x) \\<Longrightarrow>\n    Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "finally"], ["proof (chain)\npicking this:\n  Im y < Im (croot n x)", "show ?thesis"], ["proof (prove)\nusing this:\n  Im y < Im (croot n x)\n\ngoal (1 subgoal):\n 1. Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "using le"], ["proof (prove)\nusing this:\n  Im y < Im (croot n x)\n  Re y \\<le> Re (croot n x)\n\ngoal (1 subgoal):\n 1. Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "by auto"], ["proof (state)\nthis:\n  Re y < Re (croot n x) \\<or>\n  Re y = Re (croot n x) \\<and> Im y < Im (croot n x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re y < Re (croot n x) \\<or>\n  Re y = Re (croot n x) \\<and> Im y < Im (croot n x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma croot_unique: assumes n: \"n \\<noteq> 0\"\n  and y: \"y ^ n = x\"\n  and y_max_Re_Im: \"\\<And> z. z ^ n = x \\<Longrightarrow>\n      Re z < Re y \\<or> Re z = Re y \\<and> Im z \\<le> Im y\" \nshows \"croot n x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. croot n x = y", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. croot n x \\<noteq> y \\<Longrightarrow> False", "assume \"croot n x \\<noteq> y\""], ["proof (state)\nthis:\n  croot n x \\<noteq> y\n\ngoal (1 subgoal):\n 1. croot n x \\<noteq> y \\<Longrightarrow> False", "from croot_principal[OF n y this[symmetric]]"], ["proof (chain)\npicking this:\n  Re y < Re (croot n x) \\<or>\n  Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "have \"Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)\""], ["proof (prove)\nusing this:\n  Re y < Re (croot n x) \\<or>\n  Re y = Re (croot n x) \\<and> Im y < Im (croot n x)\n\ngoal (1 subgoal):\n 1. Re y < Re (croot n x) \\<or>\n    Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "."], ["proof (state)\nthis:\n  Re y < Re (croot n x) \\<or>\n  Re y = Re (croot n x) \\<and> Im y < Im (croot n x)\n\ngoal (1 subgoal):\n 1. croot n x \\<noteq> y \\<Longrightarrow> False", "with y_max_Re_Im[OF croot_power[OF n]]"], ["proof (chain)\npicking this:\n  Re (croot n x) < Re y \\<or>\n  Re (croot n x) = Re y \\<and> Im (croot n x) \\<le> Im y\n  Re y < Re (croot n x) \\<or>\n  Re y = Re (croot n x) \\<and> Im y < Im (croot n x)", "show False"], ["proof (prove)\nusing this:\n  Re (croot n x) < Re y \\<or>\n  Re (croot n x) = Re y \\<and> Im (croot n x) \\<le> Im y\n  Re y < Re (croot n x) \\<or>\n  Re y = Re (croot n x) \\<and> Im y < Im (croot n x)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma csqrt_is_croot_2: \"csqrt = croot 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csqrt = croot 2", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. csqrt x = croot 2 x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. csqrt x = croot 2 x", "show \"csqrt x = croot 2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csqrt x = croot 2 x", "proof (rule sym, rule croot_unique, force, force)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z\\<^sup>2 = x \\<Longrightarrow>\n       Re z < Re (csqrt x) \\<or>\n       Re z = Re (csqrt x) \\<and> Im z \\<le> Im (csqrt x)", "let ?p = \"[:-x,0,1:]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z\\<^sup>2 = x \\<Longrightarrow>\n       Re z < Re (csqrt x) \\<or>\n       Re z = Re (csqrt x) \\<and> Im z \\<le> Im (csqrt x)", "let ?cx = \"csqrt x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z\\<^sup>2 = x \\<Longrightarrow>\n       Re z < Re (csqrt x) \\<or>\n       Re z = Re (csqrt x) \\<and> Im z \\<le> Im (csqrt x)", "have p: \"?p = [:?cx,1:] * [:-?cx,1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- x, 0, 1:] = [:csqrt x, 1:] * [:- csqrt x, 1:]", "by (simp add: power2_eq_square[symmetric])"], ["proof (state)\nthis:\n  [:- x, 0, 1:] = [:csqrt x, 1:] * [:- csqrt x, 1:]\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z\\<^sup>2 = x \\<Longrightarrow>\n       Re z < Re (csqrt x) \\<or>\n       Re z = Re (csqrt x) \\<and> Im z \\<le> Im (csqrt x)", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z\\<^sup>2 = x \\<Longrightarrow>\n       Re z < Re (csqrt x) \\<or>\n       Re z = Re (csqrt x) \\<and> Im z \\<le> Im (csqrt x)", "assume \"y^2 = x\""], ["proof (state)\nthis:\n  y\\<^sup>2 = x\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z\\<^sup>2 = x \\<Longrightarrow>\n       Re z < Re (csqrt x) \\<or>\n       Re z = Re (csqrt x) \\<and> Im z \\<le> Im (csqrt x)", "hence \"True \\<longleftrightarrow> poly ?p y = 0\""], ["proof (prove)\nusing this:\n  y\\<^sup>2 = x\n\ngoal (1 subgoal):\n 1. True = (poly [:- x, 0, 1:] y = 0)", "by (auto simp: power2_eq_square)"], ["proof (state)\nthis:\n  True = (poly [:- x, 0, 1:] y = 0)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z\\<^sup>2 = x \\<Longrightarrow>\n       Re z < Re (csqrt x) \\<or>\n       Re z = Re (csqrt x) \\<and> Im z \\<le> Im (csqrt x)", "also"], ["proof (state)\nthis:\n  True = (poly [:- x, 0, 1:] y = 0)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z\\<^sup>2 = x \\<Longrightarrow>\n       Re z < Re (csqrt x) \\<or>\n       Re z = Re (csqrt x) \\<and> Im z \\<le> Im (csqrt x)", "have \"\\<dots> \\<longleftrightarrow> y = - ?cx \\<or> y = ?cx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (poly [:- x, 0, 1:] y = 0) = (y = - csqrt x \\<or> y = csqrt x)", "unfolding p poly_mult mult_eq_0_iff poly_root_factor"], ["proof (prove)\ngoal (1 subgoal):\n 1. (y = - csqrt x \\<or> y = - (- csqrt x)) =\n    (y = - csqrt x \\<or> y = csqrt x)", "by auto"], ["proof (state)\nthis:\n  (poly [:- x, 0, 1:] y = 0) = (y = - csqrt x \\<or> y = csqrt x)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z\\<^sup>2 = x \\<Longrightarrow>\n       Re z < Re (csqrt x) \\<or>\n       Re z = Re (csqrt x) \\<and> Im z \\<le> Im (csqrt x)", "finally"], ["proof (chain)\npicking this:\n  True = (y = - csqrt x \\<or> y = csqrt x)", "have \"y = - ?cx \\<or> y = ?cx\""], ["proof (prove)\nusing this:\n  True = (y = - csqrt x \\<or> y = csqrt x)\n\ngoal (1 subgoal):\n 1. y = - csqrt x \\<or> y = csqrt x", "by simp"], ["proof (state)\nthis:\n  y = - csqrt x \\<or> y = csqrt x\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z\\<^sup>2 = x \\<Longrightarrow>\n       Re z < Re (csqrt x) \\<or>\n       Re z = Re (csqrt x) \\<and> Im z \\<le> Im (csqrt x)", "thus \"Re y < Re ?cx \\<or> Re y = Re ?cx \\<and> Im y \\<le> Im ?cx\""], ["proof (prove)\nusing this:\n  y = - csqrt x \\<or> y = csqrt x\n\ngoal (1 subgoal):\n 1. Re y < Re (csqrt x) \\<or>\n    Re y = Re (csqrt x) \\<and> Im y \\<le> Im (csqrt x)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. y = - csqrt x \\<Longrightarrow>\n    Re y < Re (csqrt x) \\<or>\n    Re y = Re (csqrt x) \\<and> Im y \\<le> Im (csqrt x)\n 2. y = csqrt x \\<Longrightarrow>\n    Re y < Re (csqrt x) \\<or>\n    Re y = Re (csqrt x) \\<and> Im y \\<le> Im (csqrt x)", "assume y: \"y = - ?cx\""], ["proof (state)\nthis:\n  y = - csqrt x\n\ngoal (2 subgoals):\n 1. y = - csqrt x \\<Longrightarrow>\n    Re y < Re (csqrt x) \\<or>\n    Re y = Re (csqrt x) \\<and> Im y \\<le> Im (csqrt x)\n 2. y = csqrt x \\<Longrightarrow>\n    Re y < Re (csqrt x) \\<or>\n    Re y = Re (csqrt x) \\<and> Im y \\<le> Im (csqrt x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Re y < Re (csqrt x) \\<or>\n    Re y = Re (csqrt x) \\<and> Im y \\<le> Im (csqrt x)", "proof (cases \"Re ?cx = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_imag (csqrt x) \\<Longrightarrow>\n    Re y < Re (csqrt x) \\<or>\n    Re y = Re (csqrt x) \\<and> Im y \\<le> Im (csqrt x)\n 2. Re (csqrt x) \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (csqrt x) \\<or>\n    Re y = Re (csqrt x) \\<and> Im y \\<le> Im (csqrt x)", "case False"], ["proof (state)\nthis:\n  Re (csqrt x) \\<noteq> 0\n\ngoal (2 subgoals):\n 1. is_imag (csqrt x) \\<Longrightarrow>\n    Re y < Re (csqrt x) \\<or>\n    Re y = Re (csqrt x) \\<and> Im y \\<le> Im (csqrt x)\n 2. Re (csqrt x) \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (csqrt x) \\<or>\n    Re y = Re (csqrt x) \\<and> Im y \\<le> Im (csqrt x)", "with csqrt_principal[of x]"], ["proof (chain)\npicking this:\n  0 < Re (csqrt x) \\<or> is_imag (csqrt x) \\<and> 0 \\<le> Im (csqrt x)\n  Re (csqrt x) \\<noteq> 0", "have \"Re ?cx > 0\""], ["proof (prove)\nusing this:\n  0 < Re (csqrt x) \\<or> is_imag (csqrt x) \\<and> 0 \\<le> Im (csqrt x)\n  Re (csqrt x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < Re (csqrt x)", "by simp"], ["proof (state)\nthis:\n  0 < Re (csqrt x)\n\ngoal (2 subgoals):\n 1. is_imag (csqrt x) \\<Longrightarrow>\n    Re y < Re (csqrt x) \\<or>\n    Re y = Re (csqrt x) \\<and> Im y \\<le> Im (csqrt x)\n 2. Re (csqrt x) \\<noteq> 0 \\<Longrightarrow>\n    Re y < Re (csqrt x) \\<or>\n    Re y = Re (csqrt x) \\<and> Im y \\<le> Im (csqrt x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < Re (csqrt x)\n\ngoal (1 subgoal):\n 1. Re y < Re (csqrt x) \\<or>\n    Re y = Re (csqrt x) \\<and> Im y \\<le> Im (csqrt x)", "unfolding y"], ["proof (prove)\nusing this:\n  0 < Re (csqrt x)\n\ngoal (1 subgoal):\n 1. Re (- csqrt x) < Re (csqrt x) \\<or>\n    Re (- csqrt x) = Re (csqrt x) \\<and> Im (- csqrt x) \\<le> Im (csqrt x)", "by simp"], ["proof (state)\nthis:\n  Re y < Re (csqrt x) \\<or>\n  Re y = Re (csqrt x) \\<and> Im y \\<le> Im (csqrt x)\n\ngoal (1 subgoal):\n 1. is_imag (csqrt x) \\<Longrightarrow>\n    Re y < Re (csqrt x) \\<or>\n    Re y = Re (csqrt x) \\<and> Im y \\<le> Im (csqrt x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. is_imag (csqrt x) \\<Longrightarrow>\n    Re y < Re (csqrt x) \\<or>\n    Re y = Re (csqrt x) \\<and> Im y \\<le> Im (csqrt x)", "case True"], ["proof (state)\nthis:\n  is_imag (csqrt x)\n\ngoal (1 subgoal):\n 1. is_imag (csqrt x) \\<Longrightarrow>\n    Re y < Re (csqrt x) \\<or>\n    Re y = Re (csqrt x) \\<and> Im y \\<le> Im (csqrt x)", "with csqrt_principal[of x]"], ["proof (chain)\npicking this:\n  0 < Re (csqrt x) \\<or> is_imag (csqrt x) \\<and> 0 \\<le> Im (csqrt x)\n  is_imag (csqrt x)", "have \"Im ?cx \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 < Re (csqrt x) \\<or> is_imag (csqrt x) \\<and> 0 \\<le> Im (csqrt x)\n  is_imag (csqrt x)\n\ngoal (1 subgoal):\n 1. 0 \\<le> Im (csqrt x)", "by simp"], ["proof (state)\nthis:\n  0 \\<le> Im (csqrt x)\n\ngoal (1 subgoal):\n 1. is_imag (csqrt x) \\<Longrightarrow>\n    Re y < Re (csqrt x) \\<or>\n    Re y = Re (csqrt x) \\<and> Im y \\<le> Im (csqrt x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> Im (csqrt x)\n\ngoal (1 subgoal):\n 1. Re y < Re (csqrt x) \\<or>\n    Re y = Re (csqrt x) \\<and> Im y \\<le> Im (csqrt x)", "unfolding y"], ["proof (prove)\nusing this:\n  0 \\<le> Im (csqrt x)\n\ngoal (1 subgoal):\n 1. Re (- csqrt x) < Re (csqrt x) \\<or>\n    Re (- csqrt x) = Re (csqrt x) \\<and> Im (- csqrt x) \\<le> Im (csqrt x)", "using True"], ["proof (prove)\nusing this:\n  0 \\<le> Im (csqrt x)\n  is_imag (csqrt x)\n\ngoal (1 subgoal):\n 1. Re (- csqrt x) < Re (csqrt x) \\<or>\n    Re (- csqrt x) = Re (csqrt x) \\<and> Im (- csqrt x) \\<le> Im (csqrt x)", "by auto"], ["proof (state)\nthis:\n  Re y < Re (csqrt x) \\<or>\n  Re y = Re (csqrt x) \\<and> Im y \\<le> Im (csqrt x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Re y < Re (csqrt x) \\<or>\n  Re y = Re (csqrt x) \\<and> Im y \\<le> Im (csqrt x)\n\ngoal (1 subgoal):\n 1. y = csqrt x \\<Longrightarrow>\n    Re y < Re (csqrt x) \\<or>\n    Re y = Re (csqrt x) \\<and> Im y \\<le> Im (csqrt x)", "qed auto"], ["proof (state)\nthis:\n  Re y < Re (csqrt x) \\<or>\n  Re y = Re (csqrt x) \\<and> Im y \\<le> Im (csqrt x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  csqrt x = croot 2 x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma croot_via_root_selection: assumes roots: \"set ys = { y. y^n = x}\" \n  and n: \"n \\<noteq> 0\" \nshows \"croot n x = arg_min_list (\\<lambda> y. (- Re y, - Im y)) ys\" \n  (is \"_ = arg_min_list ?f ys\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. croot n x = arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys", "proof (rule croot_unique[OF n])"], ["proof (state)\ngoal (2 subgoals):\n 1. arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys ^ n = x\n 2. \\<And>z.\n       z ^ n = x \\<Longrightarrow>\n       Re z < Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys) \\<or>\n       Re z = Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys) \\<and>\n       Im z \\<le> Im (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys)", "let ?y = \"arg_min_list ?f ys\""], ["proof (state)\ngoal (2 subgoals):\n 1. arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys ^ n = x\n 2. \\<And>z.\n       z ^ n = x \\<Longrightarrow>\n       Re z < Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys) \\<or>\n       Re z = Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys) \\<and>\n       Im z \\<le> Im (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys)", "have rt: \"croot n x ^ n = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. croot n x ^ n = x", "using n"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. croot n x ^ n = x", "by (rule croot_power)"], ["proof (state)\nthis:\n  croot n x ^ n = x\n\ngoal (2 subgoals):\n 1. arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys ^ n = x\n 2. \\<And>z.\n       z ^ n = x \\<Longrightarrow>\n       Re z < Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys) \\<or>\n       Re z = Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys) \\<and>\n       Im z \\<le> Im (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys)", "hence \"croot n x \\<in> set ys\""], ["proof (prove)\nusing this:\n  croot n x ^ n = x\n\ngoal (1 subgoal):\n 1. croot n x \\<in> set ys", "unfolding roots"], ["proof (prove)\nusing this:\n  croot n x ^ n = x\n\ngoal (1 subgoal):\n 1. croot n x \\<in> {y. y ^ n = x}", "by auto"], ["proof (state)\nthis:\n  croot n x \\<in> set ys\n\ngoal (2 subgoals):\n 1. arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys ^ n = x\n 2. \\<And>z.\n       z ^ n = x \\<Longrightarrow>\n       Re z < Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys) \\<or>\n       Re z = Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys) \\<and>\n       Im z \\<le> Im (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys)", "hence ys: \"ys \\<noteq> []\""], ["proof (prove)\nusing this:\n  croot n x \\<in> set ys\n\ngoal (1 subgoal):\n 1. ys \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  ys \\<noteq> []\n\ngoal (2 subgoals):\n 1. arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys ^ n = x\n 2. \\<And>z.\n       z ^ n = x \\<Longrightarrow>\n       Re z < Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys) \\<or>\n       Re z = Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys) \\<and>\n       Im z \\<le> Im (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys)", "from arg_min_list_in[OF this]"], ["proof (chain)\npicking this:\n  arg_min_list ?f ys \\<in> set ys", "have \"?y \\<in> set ys\""], ["proof (prove)\nusing this:\n  arg_min_list ?f ys \\<in> set ys\n\ngoal (1 subgoal):\n 1. arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys \\<in> set ys", "by auto"], ["proof (state)\nthis:\n  arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys \\<in> set ys\n\ngoal (2 subgoals):\n 1. arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys ^ n = x\n 2. \\<And>z.\n       z ^ n = x \\<Longrightarrow>\n       Re z < Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys) \\<or>\n       Re z = Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys) \\<and>\n       Im z \\<le> Im (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys)", "from this[unfolded roots]"], ["proof (chain)\npicking this:\n  arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys \\<in> {y. y ^ n = x}", "show \"?y^n = x\""], ["proof (prove)\nusing this:\n  arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys \\<in> {y. y ^ n = x}\n\ngoal (1 subgoal):\n 1. arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys ^ n = x", "by auto"], ["proof (state)\nthis:\n  arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys ^ n = x\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z ^ n = x \\<Longrightarrow>\n       Re z < Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys) \\<or>\n       Re z = Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys) \\<and>\n       Im z \\<le> Im (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys)", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z ^ n = x \\<Longrightarrow>\n       Re z < Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys) \\<or>\n       Re z = Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys) \\<and>\n       Im z \\<le> Im (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys)", "assume \"z^n = x\""], ["proof (state)\nthis:\n  z ^ n = x\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z ^ n = x \\<Longrightarrow>\n       Re z < Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys) \\<or>\n       Re z = Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys) \\<and>\n       Im z \\<le> Im (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys)", "hence z: \"z \\<in> set ys\""], ["proof (prove)\nusing this:\n  z ^ n = x\n\ngoal (1 subgoal):\n 1. z \\<in> set ys", "unfolding roots"], ["proof (prove)\nusing this:\n  z ^ n = x\n\ngoal (1 subgoal):\n 1. z \\<in> {y. y ^ n = x}", "by auto"], ["proof (state)\nthis:\n  z \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z ^ n = x \\<Longrightarrow>\n       Re z < Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys) \\<or>\n       Re z = Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys) \\<and>\n       Im z \\<le> Im (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys)", "from f_arg_min_list_f[OF ys, of ?f] z"], ["proof (chain)\npicking this:\n  (- Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys),\n   - Im (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys)) =\n  (MIN y\\<in>set ys. (- Re y, - Im y))\n  z \\<in> set ys", "have \"?f ?y \\<le> ?f z\""], ["proof (prove)\nusing this:\n  (- Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys),\n   - Im (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys)) =\n  (MIN y\\<in>set ys. (- Re y, - Im y))\n  z \\<in> set ys\n\ngoal (1 subgoal):\n 1. (- Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys),\n     - Im (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys))\n    \\<le> (- Re z, - Im z)", "by simp"], ["proof (state)\nthis:\n  (- Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys),\n   - Im (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys))\n  \\<le> (- Re z, - Im z)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z ^ n = x \\<Longrightarrow>\n       Re z < Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys) \\<or>\n       Re z = Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys) \\<and>\n       Im z \\<le> Im (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys)", "thus \"Re z < Re ?y \\<or> Re z = Re ?y \\<and> Im z \\<le> Im ?y\""], ["proof (prove)\nusing this:\n  (- Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys),\n   - Im (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys))\n  \\<le> (- Re z, - Im z)\n\ngoal (1 subgoal):\n 1. Re z < Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys) \\<or>\n    Re z = Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys) \\<and>\n    Im z \\<le> Im (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys)", "by auto"], ["proof (state)\nthis:\n  Re z < Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys) \\<or>\n  Re z = Re (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys) \\<and>\n  Im z \\<le> Im (arg_min_list (\\<lambda>y. (- Re y, - Im y)) ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma croot_impl[code]: \"croot n x = (if n = 0 then 0 else \n  arg_min_list (\\<lambda> y. (- Re y, - Im y)) (all_croots n x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. croot n x =\n    (if n = 0 then 0\n     else arg_min_list (\\<lambda>y. (- Re y, - Im y)) (all_croots n x))", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    croot n x =\n    (if n = 0 then 0\n     else arg_min_list (\\<lambda>y. (- Re y, - Im y)) (all_croots n x))\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    croot n x =\n    (if n = 0 then 0\n     else arg_min_list (\\<lambda>y. (- Re y, - Im y)) (all_croots n x))", "case n0: False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    croot n x =\n    (if n = 0 then 0\n     else arg_min_list (\\<lambda>y. (- Re y, - Im y)) (all_croots n x))\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    croot n x =\n    (if n = 0 then 0\n     else arg_min_list (\\<lambda>y. (- Re y, - Im y)) (all_croots n x))", "hence id: \"(if n = 0 then y else z) = z\" \n    for y z u :: complex"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if n = 0 then y else z) = z", "by auto"], ["proof (state)\nthis:\n  (if n = 0 then ?y else ?z) = ?z\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    croot n x =\n    (if n = 0 then 0\n     else arg_min_list (\\<lambda>y. (- Re y, - Im y)) (all_croots n x))\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    croot n x =\n    (if n = 0 then 0\n     else arg_min_list (\\<lambda>y. (- Re y, - Im y)) (all_croots n x))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. croot n x =\n    (if n = 0 then 0\n     else arg_min_list (\\<lambda>y. (- Re y, - Im y)) (all_croots n x))", "unfolding id Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. croot n x = arg_min_list (\\<lambda>y. (- Re y, - Im y)) (all_croots n x)", "by (rule croot_via_root_selection[OF _ n0], rule all_croots[OF n0])"], ["proof (state)\nthis:\n  croot n x =\n  (if n = 0 then 0\n   else arg_min_list (\\<lambda>y. (- Re y, - Im y)) (all_croots n x))\n\ngoal (1 subgoal):\n 1. n = 0 \\<Longrightarrow>\n    croot n x =\n    (if n = 0 then 0\n     else arg_min_list (\\<lambda>y. (- Re y, - Im y)) (all_croots n x))", "qed auto"], ["", "end"]]}