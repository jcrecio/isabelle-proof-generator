{"file_name": "/home/qj213/afp-2021-10-22/thys/Cubic_Quartic_Equations/Min_Int_Poly_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Cubic_Quartic_Equations", "problem_names": ["lemma min_int_poly_of_rat: \"min_int_poly (of_rat r :: 'a :: {field_char_0, field_gcd}) = poly_rat r\"", "lemma min_int_poly_real_alg: \"min_int_poly_real_alg x = min_int_poly (real_of x)\"", "lemma min_int_poly_real_code_unfold [code_unfold]: \"min_int_poly = min_int_poly_real\"", "lemma min_int_poly_real_code[code]: \"min_int_poly_real (real_of x) = min_int_poly_real_alg x\"", "lemma complex_poly: assumes re: \"re represents (Re x)\" \n   and im: \"im represents (Im x)\" \n  shows \"\\<exists> f \\<in> set (complex_poly re im). f represents x\" \"\\<And> f. f \\<in> set (complex_poly re im) \\<Longrightarrow> poly_cond f\"", "lemma algebraic_real_iff[code_unfold]: \"algebraic = algebraic_real\"", "lemma algebraic_real_code[code]: \"algebraic_real (real_of x) = True\"", "lemma algebraic_complex_iff[code_unfold]: \"algebraic x \\<longleftrightarrow> algebraic (Re x) \\<and> algebraic (Im x)\"", "lemma algebraic_0[simp]: \"algebraic 0\"", "lemma min_int_poly_complex_of_real[simp]: \"min_int_poly (complex_of_real x) = min_int_poly x\"", "lemma min_int_poly_complex[code_unfold]: \"min_int_poly = min_int_poly_complex\""], "translations": [["", "lemma min_int_poly_of_rat: \"min_int_poly (of_rat r :: 'a :: {field_char_0, field_gcd}) = poly_rat r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_int_poly (of_rat r) = poly_rat r", "by (intro min_int_poly_unique, auto)"], ["", "lemma min_int_poly_real_alg: \"min_int_poly_real_alg x = min_int_poly (real_of x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_int_poly_real_alg x = min_int_poly (real_of x)", "proof (cases \"info_real_alg x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       info_real_alg x = Inl a \\<Longrightarrow>\n       min_int_poly_real_alg x = min_int_poly (real_of x)\n 2. \\<And>b.\n       info_real_alg x = Inr b \\<Longrightarrow>\n       min_int_poly_real_alg x = min_int_poly (real_of x)", "case (Inl r)"], ["proof (state)\nthis:\n  info_real_alg x = Inl r\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       info_real_alg x = Inl a \\<Longrightarrow>\n       min_int_poly_real_alg x = min_int_poly (real_of x)\n 2. \\<And>b.\n       info_real_alg x = Inr b \\<Longrightarrow>\n       min_int_poly_real_alg x = min_int_poly (real_of x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. min_int_poly_real_alg x = min_int_poly (real_of x)", "unfolding info_real_alg(2)[OF Inl] min_int_poly_real_alg_def Inl"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case Inl r of Inl x \\<Rightarrow> poly_rat x\n     | Inr (p, xa) \\<Rightarrow> p) =\n    min_int_poly (real_of_rat r)", "by (simp add: min_int_poly_of_rat)"], ["proof (state)\nthis:\n  min_int_poly_real_alg x = min_int_poly (real_of x)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       info_real_alg x = Inr b \\<Longrightarrow>\n       min_int_poly_real_alg x = min_int_poly (real_of x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       info_real_alg x = Inr b \\<Longrightarrow>\n       min_int_poly_real_alg x = min_int_poly (real_of x)", "case (Inr pair)"], ["proof (state)\nthis:\n  info_real_alg x = Inr pair\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       info_real_alg x = Inr b \\<Longrightarrow>\n       min_int_poly_real_alg x = min_int_poly (real_of x)", "then"], ["proof (chain)\npicking this:\n  info_real_alg x = Inr pair", "obtain p n where Inr: \"info_real_alg x = Inr (p,n)\""], ["proof (prove)\nusing this:\n  info_real_alg x = Inr pair\n\ngoal (1 subgoal):\n 1. (\\<And>p n.\n        info_real_alg x = Inr (p, n) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases pair, auto)"], ["proof (state)\nthis:\n  info_real_alg x = Inr (p, n)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       info_real_alg x = Inr b \\<Longrightarrow>\n       min_int_poly_real_alg x = min_int_poly (real_of x)", "hence \"poly_cond p\""], ["proof (prove)\nusing this:\n  info_real_alg x = Inr (p, n)\n\ngoal (1 subgoal):\n 1. poly_cond p", "by (transfer, transfer, auto simp: info_2_card)"], ["proof (state)\nthis:\n  poly_cond p\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       info_real_alg x = Inr b \\<Longrightarrow>\n       min_int_poly_real_alg x = min_int_poly (real_of x)", "hence \"min_int_poly (real_of x) = p\""], ["proof (prove)\nusing this:\n  poly_cond p\n\ngoal (1 subgoal):\n 1. min_int_poly (real_of x) = p", "using info_real_alg(1)[OF Inr]"], ["proof (prove)\nusing this:\n  poly_cond p\n  p represents real_of x \\<and>\n  card {y. y \\<le> real_of x \\<and> poly (real_of_int_poly p) y = 0} =\n  n \\<and>\n  irreducible p\n\ngoal (1 subgoal):\n 1. min_int_poly (real_of x) = p", "by (intro min_int_poly_unique, auto)"], ["proof (state)\nthis:\n  min_int_poly (real_of x) = p\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       info_real_alg x = Inr b \\<Longrightarrow>\n       min_int_poly_real_alg x = min_int_poly (real_of x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  min_int_poly (real_of x) = p\n\ngoal (1 subgoal):\n 1. min_int_poly_real_alg x = min_int_poly (real_of x)", "unfolding min_int_poly_real_alg_def Inr"], ["proof (prove)\nusing this:\n  min_int_poly (real_of x) = p\n\ngoal (1 subgoal):\n 1. (case Inr (p, n) of Inl x \\<Rightarrow> poly_rat x\n     | Inr (p, xa) \\<Rightarrow> p) =\n    min_int_poly (real_of x)", "by simp"], ["proof (state)\nthis:\n  min_int_poly_real_alg x = min_int_poly (real_of x)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition min_int_poly_real :: \"real \\<Rightarrow> int poly\" where\n  [simp]: \"min_int_poly_real = min_int_poly\""], ["", "lemma min_int_poly_real_code_unfold [code_unfold]: \"min_int_poly = min_int_poly_real\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_int_poly = min_int_poly_real", "by simp"], ["", "lemma min_int_poly_real_code[code]: \"min_int_poly_real (real_of x) = min_int_poly_real_alg x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_int_poly_real (real_of x) = min_int_poly_real_alg x", "by (simp add: min_int_poly_real_alg)"], ["", "text \\<open>Now let us head for the complex numbers\\<close>"], ["", "definition complex_poly :: \"int poly \\<Rightarrow> int poly \\<Rightarrow> int poly list\" where\n  \"complex_poly re im = (let i = [:1,0,1:] \n     in factors_of_int_poly (poly_add re (poly_mult im i)))\""], ["", "lemma complex_poly: assumes re: \"re represents (Re x)\" \n   and im: \"im represents (Im x)\" \n  shows \"\\<exists> f \\<in> set (complex_poly re im). f represents x\" \"\\<And> f. f \\<in> set (complex_poly re im) \\<Longrightarrow> poly_cond f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>set (complex_poly re im). f represents x &&&\n    (\\<And>f.\n        f \\<in> set (complex_poly re im) \\<Longrightarrow> poly_cond f)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>f\\<in>set (complex_poly re im). f represents x\n 2. \\<And>f. f \\<in> set (complex_poly re im) \\<Longrightarrow> poly_cond f", "let ?p = \"poly_add re (poly_mult im [:1, 0, 1:])\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>f\\<in>set (complex_poly re im). f represents x\n 2. \\<And>f. f \\<in> set (complex_poly re im) \\<Longrightarrow> poly_cond f", "from re"], ["proof (chain)\npicking this:\n  re represents Re x", "have re: \"re represents complex_of_real (Re x)\""], ["proof (prove)\nusing this:\n  re represents Re x\n\ngoal (1 subgoal):\n 1. re represents complex_of_real (Re x)", "by simp"], ["proof (state)\nthis:\n  re represents complex_of_real (Re x)\n\ngoal (2 subgoals):\n 1. \\<exists>f\\<in>set (complex_poly re im). f represents x\n 2. \\<And>f. f \\<in> set (complex_poly re im) \\<Longrightarrow> poly_cond f", "from im"], ["proof (chain)\npicking this:\n  im represents Im x", "have im: \"im represents complex_of_real (Im x)\""], ["proof (prove)\nusing this:\n  im represents Im x\n\ngoal (1 subgoal):\n 1. im represents complex_of_real (Im x)", "by simp"], ["proof (state)\nthis:\n  im represents complex_of_real (Im x)\n\ngoal (2 subgoals):\n 1. \\<exists>f\\<in>set (complex_poly re im). f represents x\n 2. \\<And>f. f \\<in> set (complex_poly re im) \\<Longrightarrow> poly_cond f", "have \"[:1,0,1:] represents \\<i>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:1, 0, 1:] represents \\<i>", "by auto"], ["proof (state)\nthis:\n  [:1, 0, 1:] represents \\<i>\n\ngoal (2 subgoals):\n 1. \\<exists>f\\<in>set (complex_poly re im). f represents x\n 2. \\<And>f. f \\<in> set (complex_poly re im) \\<Longrightarrow> poly_cond f", "from represents_add[OF re represents_mult[OF im this]]"], ["proof (chain)\npicking this:\n  poly [:1, 0, 1:] 0 \\<noteq> 0 \\<Longrightarrow>\n  poly_add re (poly_mult im [:1, 0, 1:]) represents\n  complex_of_real (Re x) + complex_of_real (Im x) * \\<i>", "have \"?p represents of_real (Re x) + complex_of_real (Im x) * \\<i>\""], ["proof (prove)\nusing this:\n  poly [:1, 0, 1:] 0 \\<noteq> 0 \\<Longrightarrow>\n  poly_add re (poly_mult im [:1, 0, 1:]) represents\n  complex_of_real (Re x) + complex_of_real (Im x) * \\<i>\n\ngoal (1 subgoal):\n 1. poly_add re (poly_mult im [:1, 0, 1:]) represents\n    complex_of_real (Re x) + complex_of_real (Im x) * \\<i>", "by simp"], ["proof (state)\nthis:\n  poly_add re (poly_mult im [:1, 0, 1:]) represents\n  complex_of_real (Re x) + complex_of_real (Im x) * \\<i>\n\ngoal (2 subgoals):\n 1. \\<exists>f\\<in>set (complex_poly re im). f represents x\n 2. \\<And>f. f \\<in> set (complex_poly re im) \\<Longrightarrow> poly_cond f", "also"], ["proof (state)\nthis:\n  poly_add re (poly_mult im [:1, 0, 1:]) represents\n  complex_of_real (Re x) + complex_of_real (Im x) * \\<i>\n\ngoal (2 subgoals):\n 1. \\<exists>f\\<in>set (complex_poly re im). f represents x\n 2. \\<And>f. f \\<in> set (complex_poly re im) \\<Longrightarrow> poly_cond f", "have \"of_real (Re x) + complex_of_real (Im x) * \\<i> = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (Re x) + complex_of_real (Im x) * \\<i> = x", "by (metis complex_eq mult.commute)"], ["proof (state)\nthis:\n  complex_of_real (Re x) + complex_of_real (Im x) * \\<i> = x\n\ngoal (2 subgoals):\n 1. \\<exists>f\\<in>set (complex_poly re im). f represents x\n 2. \\<And>f. f \\<in> set (complex_poly re im) \\<Longrightarrow> poly_cond f", "finally"], ["proof (chain)\npicking this:\n  poly_add re (poly_mult im [:1, 0, 1:]) represents x", "have p: \"?p represents x\""], ["proof (prove)\nusing this:\n  poly_add re (poly_mult im [:1, 0, 1:]) represents x\n\ngoal (1 subgoal):\n 1. poly_add re (poly_mult im [:1, 0, 1:]) represents x", "by auto"], ["proof (state)\nthis:\n  poly_add re (poly_mult im [:1, 0, 1:]) represents x\n\ngoal (2 subgoals):\n 1. \\<exists>f\\<in>set (complex_poly re im). f represents x\n 2. \\<And>f. f \\<in> set (complex_poly re im) \\<Longrightarrow> poly_cond f", "have \"factors_of_int_poly ?p = complex_poly re im\""], ["proof (prove)\ngoal (1 subgoal):\n 1. factors_of_int_poly (poly_add re (poly_mult im [:1, 0, 1:])) =\n    complex_poly re im", "unfolding complex_poly_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. factors_of_int_poly (poly_add re (poly_mult im [:1, 0, 1:])) =\n    factors_of_int_poly (poly_add re (poly_mult im [:1, 0, 1:]))", "by simp"], ["proof (state)\nthis:\n  factors_of_int_poly (poly_add re (poly_mult im [:1, 0, 1:])) =\n  complex_poly re im\n\ngoal (2 subgoals):\n 1. \\<exists>f\\<in>set (complex_poly re im). f represents x\n 2. \\<And>f. f \\<in> set (complex_poly re im) \\<Longrightarrow> poly_cond f", "from factors_of_int_poly(1)[OF this] factors_of_int_poly(2)[OF this, of x] p"], ["proof (chain)\npicking this:\n  ?q \\<in> set (complex_poly re im) \\<Longrightarrow>\n  irreducible ?q \\<and>\n  0 < Polynomial.lead_coeff ?q \\<and>\n  Polynomial.degree ?q\n  \\<le> Polynomial.degree (poly_add re (poly_mult im [:1, 0, 1:])) \\<and>\n  Polynomial.degree ?q \\<noteq> 0\n  poly_add re (poly_mult im [:1, 0, 1:]) \\<noteq> 0 \\<Longrightarrow>\n  (poly (complex_of_int_poly (poly_add re (poly_mult im [:1, 0, 1:]))) x =\n   0) =\n  (\\<exists>q\\<in>set (complex_poly re im).\n      poly (complex_of_int_poly q) x = 0)\n  poly_add re (poly_mult im [:1, 0, 1:]) represents x", "show \"\\<exists> f \\<in> set (complex_poly re im). f represents x\" \"\\<And> f. f \\<in> set (complex_poly re im) \\<Longrightarrow> poly_cond f\""], ["proof (prove)\nusing this:\n  ?q \\<in> set (complex_poly re im) \\<Longrightarrow>\n  irreducible ?q \\<and>\n  0 < Polynomial.lead_coeff ?q \\<and>\n  Polynomial.degree ?q\n  \\<le> Polynomial.degree (poly_add re (poly_mult im [:1, 0, 1:])) \\<and>\n  Polynomial.degree ?q \\<noteq> 0\n  poly_add re (poly_mult im [:1, 0, 1:]) \\<noteq> 0 \\<Longrightarrow>\n  (poly (complex_of_int_poly (poly_add re (poly_mult im [:1, 0, 1:]))) x =\n   0) =\n  (\\<exists>q\\<in>set (complex_poly re im).\n      poly (complex_of_int_poly q) x = 0)\n  poly_add re (poly_mult im [:1, 0, 1:]) represents x\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>set (complex_poly re im). f represents x &&&\n    (\\<And>f.\n        f \\<in> set (complex_poly re im) \\<Longrightarrow> poly_cond f)", "unfolding represents_def"], ["proof (prove)\nusing this:\n  ?q \\<in> set (complex_poly re im) \\<Longrightarrow>\n  irreducible ?q \\<and>\n  0 < Polynomial.lead_coeff ?q \\<and>\n  Polynomial.degree ?q\n  \\<le> Polynomial.degree (poly_add re (poly_mult im [:1, 0, 1:])) \\<and>\n  Polynomial.degree ?q \\<noteq> 0\n  poly_add re (poly_mult im [:1, 0, 1:]) \\<noteq> 0 \\<Longrightarrow>\n  (poly (complex_of_int_poly (poly_add re (poly_mult im [:1, 0, 1:]))) x =\n   0) =\n  (\\<exists>q\\<in>set (complex_poly re im).\n      poly (complex_of_int_poly q) x = 0)\n  poly (complex_of_int_poly (poly_add re (poly_mult im [:1, 0, 1:]))) x =\n  0 \\<and>\n  poly_add re (poly_mult im [:1, 0, 1:]) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>set (complex_poly re im).\n       poly (complex_of_int_poly f) x = 0 \\<and> f \\<noteq> 0 &&&\n    (\\<And>f.\n        f \\<in> set (complex_poly re im) \\<Longrightarrow> poly_cond f)", "by auto"], ["proof (state)\nthis:\n  \\<exists>f\\<in>set (complex_poly re im). f represents x\n  ?f \\<in> set (complex_poly re im) \\<Longrightarrow> poly_cond ?f\n\ngoal:\nNo subgoals!", "qed"], ["", "definition algebraic_real :: \"real \\<Rightarrow> bool\" where \n  [simp]: \"algebraic_real = algebraic\""], ["", "lemma algebraic_real_iff[code_unfold]: \"algebraic = algebraic_real\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic = algebraic_real", "by simp"], ["", "lemma algebraic_real_code[code]: \"algebraic_real (real_of x) = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_real (real_of x) = True", "proof (cases \"info_real_alg x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       info_real_alg x = Inl a \\<Longrightarrow>\n       algebraic_real (real_of x) = True\n 2. \\<And>b.\n       info_real_alg x = Inr b \\<Longrightarrow>\n       algebraic_real (real_of x) = True", "case (Inl r)"], ["proof (state)\nthis:\n  info_real_alg x = Inl r\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       info_real_alg x = Inl a \\<Longrightarrow>\n       algebraic_real (real_of x) = True\n 2. \\<And>b.\n       info_real_alg x = Inr b \\<Longrightarrow>\n       algebraic_real (real_of x) = True", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_real (real_of x) = True", "using info_real_alg(2)[OF Inl]"], ["proof (prove)\nusing this:\n  real_of x = real_of_rat r\n\ngoal (1 subgoal):\n 1. algebraic_real (real_of x) = True", "by (auto simp: algebraic_of_rat)"], ["proof (state)\nthis:\n  algebraic_real (real_of x) = True\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       info_real_alg x = Inr b \\<Longrightarrow>\n       algebraic_real (real_of x) = True", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       info_real_alg x = Inr b \\<Longrightarrow>\n       algebraic_real (real_of x) = True", "case (Inr pair)"], ["proof (state)\nthis:\n  info_real_alg x = Inr pair\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       info_real_alg x = Inr b \\<Longrightarrow>\n       algebraic_real (real_of x) = True", "then"], ["proof (chain)\npicking this:\n  info_real_alg x = Inr pair", "obtain p n where Inr: \"info_real_alg x = Inr (p,n)\""], ["proof (prove)\nusing this:\n  info_real_alg x = Inr pair\n\ngoal (1 subgoal):\n 1. (\\<And>p n.\n        info_real_alg x = Inr (p, n) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases pair, auto)"], ["proof (state)\nthis:\n  info_real_alg x = Inr (p, n)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       info_real_alg x = Inr b \\<Longrightarrow>\n       algebraic_real (real_of x) = True", "from info_real_alg(1)[OF Inr]"], ["proof (chain)\npicking this:\n  p represents real_of x \\<and>\n  card {y. y \\<le> real_of x \\<and> poly (real_of_int_poly p) y = 0} =\n  n \\<and>\n  irreducible p", "have \"p represents (real_of x)\""], ["proof (prove)\nusing this:\n  p represents real_of x \\<and>\n  card {y. y \\<le> real_of x \\<and> poly (real_of_int_poly p) y = 0} =\n  n \\<and>\n  irreducible p\n\ngoal (1 subgoal):\n 1. p represents real_of x", "by auto"], ["proof (state)\nthis:\n  p represents real_of x\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       info_real_alg x = Inr b \\<Longrightarrow>\n       algebraic_real (real_of x) = True", "thus ?thesis"], ["proof (prove)\nusing this:\n  p represents real_of x\n\ngoal (1 subgoal):\n 1. algebraic_real (real_of x) = True", "by (auto simp: algebraic_altdef_ipoly)"], ["proof (state)\nthis:\n  algebraic_real (real_of x) = True\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma algebraic_complex_iff[code_unfold]: \"algebraic x \\<longleftrightarrow> algebraic (Re x) \\<and> algebraic (Im x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic x = (algebraic (Re x) \\<and> algebraic (Im x))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. algebraic x \\<Longrightarrow> algebraic (Re x) \\<and> algebraic (Im x)\n 2. algebraic (Re x) \\<and> algebraic (Im x) \\<Longrightarrow> algebraic x", "assume \"algebraic x\""], ["proof (state)\nthis:\n  algebraic x\n\ngoal (2 subgoals):\n 1. algebraic x \\<Longrightarrow> algebraic (Re x) \\<and> algebraic (Im x)\n 2. algebraic (Re x) \\<and> algebraic (Im x) \\<Longrightarrow> algebraic x", "from this[unfolded algebraic_altdef_ipoly]"], ["proof (chain)\npicking this:\n  \\<exists>p. poly (complex_of_int_poly p) x = 0 \\<and> p \\<noteq> 0", "obtain p where \"ipoly p x = 0\" \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>p. poly (complex_of_int_poly p) x = 0 \\<and> p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>poly (complex_of_int_poly p) x = 0; p \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  poly (complex_of_int_poly p) x = 0\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. algebraic x \\<Longrightarrow> algebraic (Re x) \\<and> algebraic (Im x)\n 2. algebraic (Re x) \\<and> algebraic (Im x) \\<Longrightarrow> algebraic x", "from represents_root_poly[OF this]"], ["proof (chain)\npicking this:\n  root_poly_Re p represents Re x\n  \\<exists>q\\<in>set (root_poly_Im p). q represents Im x", "show \"algebraic (Re x) \\<and> algebraic (Im x)\""], ["proof (prove)\nusing this:\n  root_poly_Re p represents Re x\n  \\<exists>q\\<in>set (root_poly_Im p). q represents Im x\n\ngoal (1 subgoal):\n 1. algebraic (Re x) \\<and> algebraic (Im x)", "unfolding represents_def algebraic_altdef_ipoly"], ["proof (prove)\nusing this:\n  poly (real_of_int_poly (root_poly_Re p)) (Re x) = 0 \\<and>\n  root_poly_Re p \\<noteq> 0\n  \\<exists>q\\<in>set (root_poly_Im p).\n     poly (real_of_int_poly q) (Im x) = 0 \\<and> q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<exists>p.\n        poly (real_of_int_poly p) (Re x) = 0 \\<and> p \\<noteq> 0) \\<and>\n    (\\<exists>p. poly (real_of_int_poly p) (Im x) = 0 \\<and> p \\<noteq> 0)", "by auto"], ["proof (state)\nthis:\n  algebraic (Re x) \\<and> algebraic (Im x)\n\ngoal (1 subgoal):\n 1. algebraic (Re x) \\<and> algebraic (Im x) \\<Longrightarrow> algebraic x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. algebraic (Re x) \\<and> algebraic (Im x) \\<Longrightarrow> algebraic x", "assume \"algebraic (Re x) \\<and> algebraic (Im x)\""], ["proof (state)\nthis:\n  algebraic (Re x) \\<and> algebraic (Im x)\n\ngoal (1 subgoal):\n 1. algebraic (Re x) \\<and> algebraic (Im x) \\<Longrightarrow> algebraic x", "from this[unfolded algebraic_altdef_ipoly]"], ["proof (chain)\npicking this:\n  (\\<exists>p.\n      poly (real_of_int_poly p) (Re x) = 0 \\<and> p \\<noteq> 0) \\<and>\n  (\\<exists>p. poly (real_of_int_poly p) (Im x) = 0 \\<and> p \\<noteq> 0)", "obtain re im where \n    \"re represents (Re x)\" \"im represents (Im x)\""], ["proof (prove)\nusing this:\n  (\\<exists>p.\n      poly (real_of_int_poly p) (Re x) = 0 \\<and> p \\<noteq> 0) \\<and>\n  (\\<exists>p. poly (real_of_int_poly p) (Im x) = 0 \\<and> p \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (\\<And>re im.\n        \\<lbrakk>re represents Re x; im represents Im x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  re represents Re x\n  im represents Im x\n\ngoal (1 subgoal):\n 1. algebraic (Re x) \\<and> algebraic (Im x) \\<Longrightarrow> algebraic x", "from complex_poly[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>f\\<in>set (complex_poly re im). f represents x\n  ?f \\<in> set (complex_poly re im) \\<Longrightarrow> poly_cond ?f", "show \"algebraic x\""], ["proof (prove)\nusing this:\n  \\<exists>f\\<in>set (complex_poly re im). f represents x\n  ?f \\<in> set (complex_poly re im) \\<Longrightarrow> poly_cond ?f\n\ngoal (1 subgoal):\n 1. algebraic x", "unfolding represents_def algebraic_altdef_ipoly"], ["proof (prove)\nusing this:\n  \\<exists>f\\<in>set (complex_poly re im).\n     poly (complex_of_int_poly f) x = 0 \\<and> f \\<noteq> 0\n  ?f \\<in> set (complex_poly re im) \\<Longrightarrow> poly_cond ?f\n\ngoal (1 subgoal):\n 1. \\<exists>p. poly (complex_of_int_poly p) x = 0 \\<and> p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  algebraic x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma algebraic_0[simp]: \"algebraic 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic (0::'a)", "unfolding algebraic_altdef_ipoly"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. ipoly p (0::'a) = (0::'a) \\<and> p \\<noteq> 0", "by (intro exI[of _ \"[:0,1:]\"], auto)"], ["", "lemma min_int_poly_complex_of_real[simp]: \"min_int_poly (complex_of_real x) = min_int_poly x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_int_poly (complex_of_real x) = min_int_poly x", "proof (cases \"algebraic x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. algebraic x \\<Longrightarrow>\n    min_int_poly (complex_of_real x) = min_int_poly x\n 2. \\<not> algebraic x \\<Longrightarrow>\n    min_int_poly (complex_of_real x) = min_int_poly x", "case False"], ["proof (state)\nthis:\n  \\<not> algebraic x\n\ngoal (2 subgoals):\n 1. algebraic x \\<Longrightarrow>\n    min_int_poly (complex_of_real x) = min_int_poly x\n 2. \\<not> algebraic x \\<Longrightarrow>\n    min_int_poly (complex_of_real x) = min_int_poly x", "hence \"\\<not> algebraic (complex_of_real x)\""], ["proof (prove)\nusing this:\n  \\<not> algebraic x\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (complex_of_real x)", "unfolding algebraic_complex_iff"], ["proof (prove)\nusing this:\n  \\<not> algebraic x\n\ngoal (1 subgoal):\n 1. \\<not> (algebraic (Re (complex_of_real x)) \\<and>\n            algebraic (Im (complex_of_real x)))", "by auto"], ["proof (state)\nthis:\n  \\<not> algebraic (complex_of_real x)\n\ngoal (2 subgoals):\n 1. algebraic x \\<Longrightarrow>\n    min_int_poly (complex_of_real x) = min_int_poly x\n 2. \\<not> algebraic x \\<Longrightarrow>\n    min_int_poly (complex_of_real x) = min_int_poly x", "with False"], ["proof (chain)\npicking this:\n  \\<not> algebraic x\n  \\<not> algebraic (complex_of_real x)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> algebraic x\n  \\<not> algebraic (complex_of_real x)\n\ngoal (1 subgoal):\n 1. min_int_poly (complex_of_real x) = min_int_poly x", "unfolding min_int_poly_def"], ["proof (prove)\nusing this:\n  \\<not> algebraic x\n  \\<not> algebraic (complex_of_real x)\n\ngoal (1 subgoal):\n 1. (if algebraic (complex_of_real x)\n     then THE p.\n             p represents complex_of_real x \\<and>\n             irreducible p \\<and> 0 < Polynomial.lead_coeff p\n     else [:0, 1:]) =\n    (if algebraic x\n     then THE p.\n             p represents x \\<and>\n             irreducible p \\<and> 0 < Polynomial.lead_coeff p\n     else [:0, 1:])", "by auto"], ["proof (state)\nthis:\n  min_int_poly (complex_of_real x) = min_int_poly x\n\ngoal (1 subgoal):\n 1. algebraic x \\<Longrightarrow>\n    min_int_poly (complex_of_real x) = min_int_poly x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. algebraic x \\<Longrightarrow>\n    min_int_poly (complex_of_real x) = min_int_poly x", "case True"], ["proof (state)\nthis:\n  algebraic x\n\ngoal (1 subgoal):\n 1. algebraic x \\<Longrightarrow>\n    min_int_poly (complex_of_real x) = min_int_poly x", "from min_int_poly_represents[OF True]"], ["proof (chain)\npicking this:\n  min_int_poly x represents x", "have \"min_int_poly x represents x\""], ["proof (prove)\nusing this:\n  min_int_poly x represents x\n\ngoal (1 subgoal):\n 1. min_int_poly x represents x", "by auto"], ["proof (state)\nthis:\n  min_int_poly x represents x\n\ngoal (1 subgoal):\n 1. algebraic x \\<Longrightarrow>\n    min_int_poly (complex_of_real x) = min_int_poly x", "thus ?thesis"], ["proof (prove)\nusing this:\n  min_int_poly x represents x\n\ngoal (1 subgoal):\n 1. min_int_poly (complex_of_real x) = min_int_poly x", "by (intro min_int_poly_unique, auto simp: lead_coeff_min_int_poly_pos)"], ["proof (state)\nthis:\n  min_int_poly (complex_of_real x) = min_int_poly x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>TODO: the implemention might be tuned, since the search process should be faster when\n  using interval arithmetic to figure out the correct factor.\n  (One might also implement the search via checking @{term \"ipoly f x = 0\"}, but because of complex-algebraic-number\n   arithmetic, I think that search would be slower than the current one via \"@{term \"x \\<in> set (complex_roots_of_int_poly f)\"}\\<close>"], ["", "definition min_int_poly_complex :: \"complex \\<Rightarrow> int poly\" where\n  \"min_int_poly_complex x = (if algebraic x then if Im x = 0 then min_int_poly_real (Re x)\n     else the (find (\\<lambda> f. x \\<in> set (complex_roots_of_int_poly f)) (complex_poly (min_int_poly (Re x)) (min_int_poly (Im x))))\n     else [:0,1:])\""], ["", "lemma min_int_poly_complex[code_unfold]: \"min_int_poly = min_int_poly_complex\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_int_poly = min_int_poly_complex", "proof (standard)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. min_int_poly x = min_int_poly_complex x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. min_int_poly x = min_int_poly_complex x", "define fs where \"fs = complex_poly (min_int_poly (Re x)) (min_int_poly (Im x))\""], ["proof (state)\nthis:\n  fs = complex_poly (min_int_poly (Re x)) (min_int_poly (Im x))\n\ngoal (1 subgoal):\n 1. \\<And>x. min_int_poly x = min_int_poly_complex x", "let ?f = \"min_int_poly_complex x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. min_int_poly x = min_int_poly_complex x", "show \"min_int_poly x = ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_int_poly x = min_int_poly_complex x", "proof (cases \"algebraic x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. algebraic x \\<Longrightarrow> min_int_poly x = min_int_poly_complex x\n 2. \\<not> algebraic x \\<Longrightarrow>\n    min_int_poly x = min_int_poly_complex x", "case False"], ["proof (state)\nthis:\n  \\<not> algebraic x\n\ngoal (2 subgoals):\n 1. algebraic x \\<Longrightarrow> min_int_poly x = min_int_poly_complex x\n 2. \\<not> algebraic x \\<Longrightarrow>\n    min_int_poly x = min_int_poly_complex x", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> algebraic x\n\ngoal (1 subgoal):\n 1. min_int_poly x = min_int_poly_complex x", "unfolding min_int_poly_def min_int_poly_complex_def"], ["proof (prove)\nusing this:\n  \\<not> algebraic x\n\ngoal (1 subgoal):\n 1. (if algebraic x\n     then THE p.\n             p represents x \\<and>\n             irreducible p \\<and> 0 < Polynomial.lead_coeff p\n     else [:0, 1:]) =\n    (if algebraic x\n     then if Im x = 0 then min_int_poly_real (Re x)\n          else the (find\n                     (\\<lambda>f. x \\<in> set (complex_roots_of_int_poly f))\n                     (complex_poly\n                       (if algebraic (Re x)\n                        then THE p.\n                                p represents Re x \\<and>\n                                irreducible p \\<and>\n                                0 < Polynomial.lead_coeff p\n                        else [:0, 1:])\n                       (if algebraic (Im x)\n                        then THE p.\n                                p represents Im x \\<and>\n                                irreducible p \\<and>\n                                0 < Polynomial.lead_coeff p\n                        else [:0, 1:])))\n     else [:0, 1:])", "by auto"], ["proof (state)\nthis:\n  min_int_poly x = min_int_poly_complex x\n\ngoal (1 subgoal):\n 1. algebraic x \\<Longrightarrow> min_int_poly x = min_int_poly_complex x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. algebraic x \\<Longrightarrow> min_int_poly x = min_int_poly_complex x", "case True"], ["proof (state)\nthis:\n  algebraic x\n\ngoal (1 subgoal):\n 1. algebraic x \\<Longrightarrow> min_int_poly x = min_int_poly_complex x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. min_int_poly x = min_int_poly_complex x", "proof (cases \"Im x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Im x = 0 \\<Longrightarrow> min_int_poly x = min_int_poly_complex x\n 2. Im x \\<noteq> 0 \\<Longrightarrow>\n    min_int_poly x = min_int_poly_complex x", "case *: True"], ["proof (state)\nthis:\n  Im x = 0\n\ngoal (2 subgoals):\n 1. Im x = 0 \\<Longrightarrow> min_int_poly x = min_int_poly_complex x\n 2. Im x \\<noteq> 0 \\<Longrightarrow>\n    min_int_poly x = min_int_poly_complex x", "have id: \"?f = min_int_poly_real (Re x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_int_poly_complex x = min_int_poly_real (Re x)", "unfolding min_int_poly_complex_def *"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if algebraic x\n     then if 0 = 0 then min_int_poly_real (Re x)\n          else the (find\n                     (\\<lambda>f. x \\<in> set (complex_roots_of_int_poly f))\n                     (complex_poly (min_int_poly (Re x)) (min_int_poly 0)))\n     else [:0, 1:]) =\n    min_int_poly_real (Re x)", "using True"], ["proof (prove)\nusing this:\n  algebraic x\n\ngoal (1 subgoal):\n 1. (if algebraic x\n     then if 0 = 0 then min_int_poly_real (Re x)\n          else the (find\n                     (\\<lambda>f. x \\<in> set (complex_roots_of_int_poly f))\n                     (complex_poly (min_int_poly (Re x)) (min_int_poly 0)))\n     else [:0, 1:]) =\n    min_int_poly_real (Re x)", "by auto"], ["proof (state)\nthis:\n  min_int_poly_complex x = min_int_poly_real (Re x)\n\ngoal (2 subgoals):\n 1. Im x = 0 \\<Longrightarrow> min_int_poly x = min_int_poly_complex x\n 2. Im x \\<noteq> 0 \\<Longrightarrow>\n    min_int_poly x = min_int_poly_complex x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. min_int_poly x = min_int_poly_complex x", "unfolding id min_int_poly_real_code_unfold[symmetric] min_int_poly_complex_of_real[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. min_int_poly x = min_int_poly (complex_of_real (Re x))", "using *"], ["proof (prove)\nusing this:\n  Im x = 0\n\ngoal (1 subgoal):\n 1. min_int_poly x = min_int_poly (complex_of_real (Re x))", "by (intro arg_cong[of _ _ min_int_poly] complex_eqI, auto)"], ["proof (state)\nthis:\n  min_int_poly x = min_int_poly_complex x\n\ngoal (1 subgoal):\n 1. Im x \\<noteq> 0 \\<Longrightarrow>\n    min_int_poly x = min_int_poly_complex x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Im x \\<noteq> 0 \\<Longrightarrow>\n    min_int_poly x = min_int_poly_complex x", "case False"], ["proof (state)\nthis:\n  Im x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Im x \\<noteq> 0 \\<Longrightarrow>\n    min_int_poly x = min_int_poly_complex x", "from True[unfolded algebraic_complex_iff]"], ["proof (chain)\npicking this:\n  algebraic (Re x) \\<and> algebraic (Im x)", "have \"algebraic (Re x)\" \"algebraic (Im x)\""], ["proof (prove)\nusing this:\n  algebraic (Re x) \\<and> algebraic (Im x)\n\ngoal (1 subgoal):\n 1. algebraic (Re x) &&& algebraic (Im x)", "by auto"], ["proof (state)\nthis:\n  algebraic (Re x)\n  algebraic (Im x)\n\ngoal (1 subgoal):\n 1. Im x \\<noteq> 0 \\<Longrightarrow>\n    min_int_poly x = min_int_poly_complex x", "from complex_poly[OF min_int_poly_represents[OF this(1)] min_int_poly_represents[OF this(2)]]"], ["proof (chain)\npicking this:\n  \\<exists>f\\<in>set (complex_poly (min_int_poly (Re x))\n                       (min_int_poly (Im x))).\n     f represents x\n  ?f \\<in> set (complex_poly (min_int_poly (Re x))\n                 (min_int_poly (Im x))) \\<Longrightarrow>\n  poly_cond ?f", "have fs: \"\\<exists> f \\<in> set fs. ipoly f x = 0\" \"\\<And> f. f \\<in> set fs \\<Longrightarrow> poly_cond f\""], ["proof (prove)\nusing this:\n  \\<exists>f\\<in>set (complex_poly (min_int_poly (Re x))\n                       (min_int_poly (Im x))).\n     f represents x\n  ?f \\<in> set (complex_poly (min_int_poly (Re x))\n                 (min_int_poly (Im x))) \\<Longrightarrow>\n  poly_cond ?f\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>set fs. poly (complex_of_int_poly f) x = 0 &&&\n    (\\<And>f. f \\<in> set fs \\<Longrightarrow> poly_cond f)", "unfolding fs_def"], ["proof (prove)\nusing this:\n  \\<exists>f\\<in>set (complex_poly (min_int_poly (Re x))\n                       (min_int_poly (Im x))).\n     f represents x\n  ?f \\<in> set (complex_poly (min_int_poly (Re x))\n                 (min_int_poly (Im x))) \\<Longrightarrow>\n  poly_cond ?f\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>set (complex_poly (min_int_poly (Re x))\n                         (min_int_poly (Im x))).\n       poly (complex_of_int_poly f) x = 0 &&&\n    (\\<And>f.\n        f \\<in> set (complex_poly (min_int_poly (Re x))\n                      (min_int_poly (Im x))) \\<Longrightarrow>\n        poly_cond f)", "by auto"], ["proof (state)\nthis:\n  \\<exists>f\\<in>set fs. poly (complex_of_int_poly f) x = 0\n  ?f \\<in> set fs \\<Longrightarrow> poly_cond ?f\n\ngoal (1 subgoal):\n 1. Im x \\<noteq> 0 \\<Longrightarrow>\n    min_int_poly x = min_int_poly_complex x", "let ?fs = \"find (\\<lambda> f. ipoly f x = 0) fs\""], ["proof (state)\ngoal (1 subgoal):\n 1. Im x \\<noteq> 0 \\<Longrightarrow>\n    min_int_poly x = min_int_poly_complex x", "let ?fs' = \"find (\\<lambda> f. x \\<in> set (complex_roots_of_int_poly f)) fs\""], ["proof (state)\ngoal (1 subgoal):\n 1. Im x \\<noteq> 0 \\<Longrightarrow>\n    min_int_poly x = min_int_poly_complex x", "have \"?f = the ?fs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_int_poly_complex x =\n    the (find (\\<lambda>f. x \\<in> set (complex_roots_of_int_poly f)) fs)", "unfolding min_int_poly_complex_def fs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if algebraic x\n     then if Im x = 0 then min_int_poly_real (Re x)\n          else the (find\n                     (\\<lambda>f. x \\<in> set (complex_roots_of_int_poly f))\n                     (complex_poly (min_int_poly (Re x))\n                       (min_int_poly (Im x))))\n     else [:0, 1:]) =\n    the (find (\\<lambda>f. x \\<in> set (complex_roots_of_int_poly f))\n          (complex_poly (min_int_poly (Re x)) (min_int_poly (Im x))))", "using True False"], ["proof (prove)\nusing this:\n  algebraic x\n  Im x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if algebraic x\n     then if Im x = 0 then min_int_poly_real (Re x)\n          else the (find\n                     (\\<lambda>f. x \\<in> set (complex_roots_of_int_poly f))\n                     (complex_poly (min_int_poly (Re x))\n                       (min_int_poly (Im x))))\n     else [:0, 1:]) =\n    the (find (\\<lambda>f. x \\<in> set (complex_roots_of_int_poly f))\n          (complex_poly (min_int_poly (Re x)) (min_int_poly (Im x))))", "by auto"], ["proof (state)\nthis:\n  min_int_poly_complex x =\n  the (find (\\<lambda>f. x \\<in> set (complex_roots_of_int_poly f)) fs)\n\ngoal (1 subgoal):\n 1. Im x \\<noteq> 0 \\<Longrightarrow>\n    min_int_poly x = min_int_poly_complex x", "also"], ["proof (state)\nthis:\n  min_int_poly_complex x =\n  the (find (\\<lambda>f. x \\<in> set (complex_roots_of_int_poly f)) fs)\n\ngoal (1 subgoal):\n 1. Im x \\<noteq> 0 \\<Longrightarrow>\n    min_int_poly x = min_int_poly_complex x", "have \"?fs' = ?fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find (\\<lambda>f. x \\<in> set (complex_roots_of_int_poly f)) fs =\n    find (\\<lambda>f. poly (complex_of_int_poly f) x = 0) fs", "by (rule find_cong[OF refl], subst complex_roots_of_int_poly, insert fs, auto)"], ["proof (state)\nthis:\n  find (\\<lambda>f. x \\<in> set (complex_roots_of_int_poly f)) fs =\n  find (\\<lambda>f. poly (complex_of_int_poly f) x = 0) fs\n\ngoal (1 subgoal):\n 1. Im x \\<noteq> 0 \\<Longrightarrow>\n    min_int_poly x = min_int_poly_complex x", "finally"], ["proof (chain)\npicking this:\n  min_int_poly_complex x =\n  the (find (\\<lambda>f. poly (complex_of_int_poly f) x = 0) fs)", "have id: \"?f = the ?fs\""], ["proof (prove)\nusing this:\n  min_int_poly_complex x =\n  the (find (\\<lambda>f. poly (complex_of_int_poly f) x = 0) fs)\n\ngoal (1 subgoal):\n 1. min_int_poly_complex x =\n    the (find (\\<lambda>f. poly (complex_of_int_poly f) x = 0) fs)", "."], ["proof (state)\nthis:\n  min_int_poly_complex x =\n  the (find (\\<lambda>f. poly (complex_of_int_poly f) x = 0) fs)\n\ngoal (1 subgoal):\n 1. Im x \\<noteq> 0 \\<Longrightarrow>\n    min_int_poly x = min_int_poly_complex x", "from fs(1)"], ["proof (chain)\npicking this:\n  \\<exists>f\\<in>set fs. poly (complex_of_int_poly f) x = 0", "have \"?fs \\<noteq> None\""], ["proof (prove)\nusing this:\n  \\<exists>f\\<in>set fs. poly (complex_of_int_poly f) x = 0\n\ngoal (1 subgoal):\n 1. find (\\<lambda>f. poly (complex_of_int_poly f) x = 0) fs \\<noteq> None", "unfolding find_None_iff"], ["proof (prove)\nusing this:\n  \\<exists>f\\<in>set fs. poly (complex_of_int_poly f) x = 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<nexists>xa.\n               xa \\<in> set fs \\<and> poly (complex_of_int_poly xa) x = 0)", "by auto"], ["proof (state)\nthis:\n  find (\\<lambda>f. poly (complex_of_int_poly f) x = 0) fs \\<noteq> None\n\ngoal (1 subgoal):\n 1. Im x \\<noteq> 0 \\<Longrightarrow>\n    min_int_poly x = min_int_poly_complex x", "then"], ["proof (chain)\npicking this:\n  find (\\<lambda>f. poly (complex_of_int_poly f) x = 0) fs \\<noteq> None", "obtain f where Some: \"?fs = Some f\""], ["proof (prove)\nusing this:\n  find (\\<lambda>f. poly (complex_of_int_poly f) x = 0) fs \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        find (\\<lambda>f. poly (complex_of_int_poly f) x = 0) fs =\n        Some f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  find (\\<lambda>f. poly (complex_of_int_poly f) x = 0) fs = Some f\n\ngoal (1 subgoal):\n 1. Im x \\<noteq> 0 \\<Longrightarrow>\n    min_int_poly x = min_int_poly_complex x", "from find_Some_D[OF this] fs(2)[of f]"], ["proof (chain)\npicking this:\n  f \\<in> set fs \\<and> poly (complex_of_int_poly f) x = 0\n  f \\<in> set fs \\<Longrightarrow> poly_cond f", "show ?thesis"], ["proof (prove)\nusing this:\n  f \\<in> set fs \\<and> poly (complex_of_int_poly f) x = 0\n  f \\<in> set fs \\<Longrightarrow> poly_cond f\n\ngoal (1 subgoal):\n 1. min_int_poly x = min_int_poly_complex x", "unfolding id Some"], ["proof (prove)\nusing this:\n  f \\<in> set fs \\<and> poly (complex_of_int_poly f) x = 0\n  f \\<in> set fs \\<Longrightarrow> poly_cond f\n\ngoal (1 subgoal):\n 1. min_int_poly x = the (Some f)", "by (intro min_int_poly_unique, auto)"], ["proof (state)\nthis:\n  min_int_poly x = min_int_poly_complex x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  min_int_poly x = min_int_poly_complex x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  min_int_poly x = min_int_poly_complex x\n\ngoal:\nNo subgoals!", "qed"], ["", "(* outcommented tests, since time-consuming:\n\nvalue (code) \"min_int_poly (sqrt 2 + 3)\" \nvalue (code) \"min_int_poly (sqrt 2 + \\<i>)\" \n\n*)"], ["", "end"]]}