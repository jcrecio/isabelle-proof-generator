{"file_name": "/home/qj213/afp-2021-10-22/thys/Amortized_Complexity/Skew_Heap_Analysis.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Amortized_Complexity", "problem_names": ["lemma Gexp: \"2 ^ lrh t \\<le> size t + 1\"", "lemma Dexp: \"2 ^ rlh t \\<le> size t + 1\"", "lemma \\<Phi>_nneg: \"\\<Phi> t \\<ge> 0\"", "lemma plus_log_le_2log_plus: \"\\<lbrakk> x > 0; y > 0; b > 1 \\<rbrakk>\n  \\<Longrightarrow> log b x + log b y \\<le> 2 * log b (x + y)\"", "lemma rh1: \"rh l r \\<le> 1\"", "lemma amor_le_long:\n  \"T_merge t1 t2 + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2 \\<le>\n   lrh(merge t1 t2) + rlh t1 + rlh t2 + 1\"", "lemma amor_le:\n  \"T_merge t1 t2 + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2 \\<le>\n   lrh(merge t1 t2) + rlh t1 + rlh t2 + 1\"", "lemma a_merge:\n  \"T_merge t1 t2 + \\<Phi>(merge t1 t2) - \\<Phi> t1 - \\<Phi> t2 \\<le>\n   3 * log 2 (size1 t1 + size1 t2) + 1\" (is \"?l \\<le> _\")", "lemma a_insert: \"T_insert a t + \\<Phi>(skew_heap.insert a t) - \\<Phi> t \\<le> 3 * log 2 (size1 t + 2) + 2\"", "lemma a_del_min: \"T_del_min t + \\<Phi>(skew_heap.del_min t) - \\<Phi> t \\<le> 3 * log 2 (size1 t + 2) + 2\"", "lemma T_merge_nneg: \"T_merge t1 t2 \\<ge> 0\""], "translations": [["", "lemma Gexp: \"2 ^ lrh t \\<le> size t + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ lrh t \\<le> size t + 1", "by (induction t) (auto simp: rh_def)"], ["", "corollary Glog: \"lrh t \\<le> log 2 (size1 t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (lrh t) \\<le> log 2 (real (size1 t))", "by (metis Gexp le_log2_of_power size1_size)"], ["", "lemma Dexp: \"2 ^ rlh t \\<le> size t + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ rlh t \\<le> size t + 1", "by (induction t) (auto simp: rh_def)"], ["", "corollary Dlog: \"rlh t \\<le> log 2 (size1 t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (rlh t) \\<le> log 2 (real (size1 t))", "by (metis Dexp le_log2_of_power size1_size)"], ["", "function T_merge :: \"'a::linorder tree \\<Rightarrow> 'a tree \\<Rightarrow> nat\" where\n\"T_merge Leaf t = 1\" |\n\"T_merge t Leaf = 1\" |\n\"T_merge (Node l1 a1 r1) (Node l2 a2 r2) =\n   (if a1 \\<le> a2 then T_merge (Node l2 a2 r2) r1 else T_merge (Node l1 a1 r1) r2) + 1\""], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>t. x = (\\<langle>\\<rangle>, t) \\<Longrightarrow> P;\n        \\<And>t. x = (t, \\<langle>\\<rangle>) \\<Longrightarrow> P;\n        \\<And>l1 a1 r1 l2 a2 r2.\n           x =\n           (\\<langle>l1, a1, r1\\<rangle>,\n            \\<langle>l2, a2, r2\\<rangle>) \\<Longrightarrow>\n           P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>t ta.\n       (\\<langle>\\<rangle>, t) = (\\<langle>\\<rangle>, ta) \\<Longrightarrow>\n       1 = 1\n 3. \\<And>t ta.\n       (\\<langle>\\<rangle>, t) = (ta, \\<langle>\\<rangle>) \\<Longrightarrow>\n       1 = 1\n 4. \\<And>t l1 a1 r1 l2 a2 r2.\n       (\\<langle>\\<rangle>, t) =\n       (\\<langle>l1, a1, r1\\<rangle>,\n        \\<langle>l2, a2, r2\\<rangle>) \\<Longrightarrow>\n       1 =\n       (if a1 \\<le> a2 then T_merge_sumC (\\<langle>l2, a2, r2\\<rangle>, r1)\n        else T_merge_sumC (\\<langle>l1, a1, r1\\<rangle>, r2)) +\n       1\n 5. \\<And>t ta.\n       (t, \\<langle>\\<rangle>) = (ta, \\<langle>\\<rangle>) \\<Longrightarrow>\n       1 = 1\n 6. \\<And>t l1 a1 r1 l2 a2 r2.\n       (t, \\<langle>\\<rangle>) =\n       (\\<langle>l1, a1, r1\\<rangle>,\n        \\<langle>l2, a2, r2\\<rangle>) \\<Longrightarrow>\n       1 =\n       (if a1 \\<le> a2 then T_merge_sumC (\\<langle>l2, a2, r2\\<rangle>, r1)\n        else T_merge_sumC (\\<langle>l1, a1, r1\\<rangle>, r2)) +\n       1\n 7. \\<And>l1 a1 r1 l2 a2 r2 l1a a1a r1a l2a a2a r2a.\n       (\\<langle>l1, a1, r1\\<rangle>, \\<langle>l2, a2, r2\\<rangle>) =\n       (\\<langle>l1a, a1a, r1a\\<rangle>,\n        \\<langle>l2a, a2a, r2a\\<rangle>) \\<Longrightarrow>\n       (if a1 \\<le> a2 then T_merge_sumC (\\<langle>l2, a2, r2\\<rangle>, r1)\n        else T_merge_sumC (\\<langle>l1, a1, r1\\<rangle>, r2)) +\n       1 =\n       (if a1a \\<le> a2a\n        then T_merge_sumC (\\<langle>l2a, a2a, r2a\\<rangle>, r1a)\n        else T_merge_sumC (\\<langle>l1a, a1a, r1a\\<rangle>, r2a)) +\n       1", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All T_merge_dom", "by (relation \"measure (\\<lambda>(x, y). size x + size y)\") auto"], ["", "fun \\<Phi> :: \"'a tree \\<Rightarrow> int\" where\n\"\\<Phi> Leaf = 0\" |\n\"\\<Phi> (Node l _ r) = \\<Phi> l + \\<Phi> r + rh l r\""], ["", "lemma \\<Phi>_nneg: \"\\<Phi> t \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<Phi> t", "by (induction t) auto"], ["", "lemma plus_log_le_2log_plus: \"\\<lbrakk> x > 0; y > 0; b > 1 \\<rbrakk>\n  \\<Longrightarrow> log b x + log b y \\<le> 2 * log b (x + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < x; 0 < y; 1 < b\\<rbrakk>\n    \\<Longrightarrow> log b x + log b y \\<le> 2 * log b (x + y)", "by(subst mult_2; rule add_mono; auto)"], ["", "lemma rh1: \"rh l r \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rh l r \\<le> 1", "by(simp add: rh_def)"], ["", "lemma amor_le_long:\n  \"T_merge t1 t2 + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2 \\<le>\n   lrh(merge t1 t2) + rlh t1 + rlh t2 + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2\n    \\<le> int (lrh (merge t1 t2) + rlh t1 + rlh t2 + 1)", "proof (induction t1 t2 rule: merge.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t.\n       int (T_merge \\<langle>\\<rangle> t) +\n       \\<Phi> (merge \\<langle>\\<rangle> t) -\n       \\<Phi> \\<langle>\\<rangle> -\n       \\<Phi> t\n       \\<le> int (lrh (merge \\<langle>\\<rangle> t) +\n                  rlh \\<langle>\\<rangle> +\n                  rlh t +\n                  1)\n 2. \\<And>t.\n       int (T_merge t \\<langle>\\<rangle>) +\n       \\<Phi> (merge t \\<langle>\\<rangle>) -\n       \\<Phi> t -\n       \\<Phi> \\<langle>\\<rangle>\n       \\<le> int (lrh (merge t \\<langle>\\<rangle>) + rlh t +\n                  rlh \\<langle>\\<rangle> +\n                  1)\n 3. \\<And>l1 a1 r1 l2 a2 r2.\n       \\<lbrakk>a1 \\<le> a2 \\<Longrightarrow>\n                int (T_merge \\<langle>l2, a2, r2\\<rangle> r1) +\n                \\<Phi> (merge \\<langle>l2, a2, r2\\<rangle> r1) -\n                \\<Phi> \\<langle>l2, a2, r2\\<rangle> -\n                \\<Phi> r1\n                \\<le> int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n                           rlh \\<langle>l2, a2, r2\\<rangle> +\n                           rlh r1 +\n                           1);\n        \\<not> a1 \\<le> a2 \\<Longrightarrow>\n        int (T_merge \\<langle>l1, a1, r1\\<rangle> r2) +\n        \\<Phi> (merge \\<langle>l1, a1, r1\\<rangle> r2) -\n        \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n        \\<Phi> r2\n        \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle> r2) +\n                   rlh \\<langle>l1, a1, r1\\<rangle> +\n                   rlh r2 +\n                   1)\\<rbrakk>\n       \\<Longrightarrow> int (T_merge \\<langle>l1, a1, r1\\<rangle>\n                               \\<langle>l2, a2, r2\\<rangle>) +\n                         \\<Phi>\n                          (merge \\<langle>l1, a1, r1\\<rangle>\n                            \\<langle>l2, a2, r2\\<rangle>) -\n                         \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n                         \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n                         \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n    \\<langle>l2, a2, r2\\<rangle>) +\n                                    rlh \\<langle>l1, a1, r1\\<rangle> +\n                                    rlh \\<langle>l2, a2, r2\\<rangle> +\n                                    1)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>t.\n       int (T_merge \\<langle>\\<rangle> t) +\n       \\<Phi> (merge \\<langle>\\<rangle> t) -\n       \\<Phi> \\<langle>\\<rangle> -\n       \\<Phi> t\n       \\<le> int (lrh (merge \\<langle>\\<rangle> t) +\n                  rlh \\<langle>\\<rangle> +\n                  rlh t +\n                  1)\n 2. \\<And>t.\n       int (T_merge t \\<langle>\\<rangle>) +\n       \\<Phi> (merge t \\<langle>\\<rangle>) -\n       \\<Phi> t -\n       \\<Phi> \\<langle>\\<rangle>\n       \\<le> int (lrh (merge t \\<langle>\\<rangle>) + rlh t +\n                  rlh \\<langle>\\<rangle> +\n                  1)\n 3. \\<And>l1 a1 r1 l2 a2 r2.\n       \\<lbrakk>a1 \\<le> a2 \\<Longrightarrow>\n                int (T_merge \\<langle>l2, a2, r2\\<rangle> r1) +\n                \\<Phi> (merge \\<langle>l2, a2, r2\\<rangle> r1) -\n                \\<Phi> \\<langle>l2, a2, r2\\<rangle> -\n                \\<Phi> r1\n                \\<le> int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n                           rlh \\<langle>l2, a2, r2\\<rangle> +\n                           rlh r1 +\n                           1);\n        \\<not> a1 \\<le> a2 \\<Longrightarrow>\n        int (T_merge \\<langle>l1, a1, r1\\<rangle> r2) +\n        \\<Phi> (merge \\<langle>l1, a1, r1\\<rangle> r2) -\n        \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n        \\<Phi> r2\n        \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle> r2) +\n                   rlh \\<langle>l1, a1, r1\\<rangle> +\n                   rlh r2 +\n                   1)\\<rbrakk>\n       \\<Longrightarrow> int (T_merge \\<langle>l1, a1, r1\\<rangle>\n                               \\<langle>l2, a2, r2\\<rangle>) +\n                         \\<Phi>\n                          (merge \\<langle>l1, a1, r1\\<rangle>\n                            \\<langle>l2, a2, r2\\<rangle>) -\n                         \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n                         \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n                         \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n    \\<langle>l2, a2, r2\\<rangle>) +\n                                    rlh \\<langle>l1, a1, r1\\<rangle> +\n                                    rlh \\<langle>l2, a2, r2\\<rangle> +\n                                    1)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (T_merge \\<langle>\\<rangle> t_) +\n    \\<Phi> (merge \\<langle>\\<rangle> t_) -\n    \\<Phi> \\<langle>\\<rangle> -\n    \\<Phi> t_\n    \\<le> int (lrh (merge \\<langle>\\<rangle> t_) + rlh \\<langle>\\<rangle> +\n               rlh t_ +\n               1)", "by simp"], ["proof (state)\nthis:\n  int (T_merge \\<langle>\\<rangle> t_) +\n  \\<Phi> (merge \\<langle>\\<rangle> t_) -\n  \\<Phi> \\<langle>\\<rangle> -\n  \\<Phi> t_\n  \\<le> int (lrh (merge \\<langle>\\<rangle> t_) + rlh \\<langle>\\<rangle> +\n             rlh t_ +\n             1)\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       int (T_merge t \\<langle>\\<rangle>) +\n       \\<Phi> (merge t \\<langle>\\<rangle>) -\n       \\<Phi> t -\n       \\<Phi> \\<langle>\\<rangle>\n       \\<le> int (lrh (merge t \\<langle>\\<rangle>) + rlh t +\n                  rlh \\<langle>\\<rangle> +\n                  1)\n 2. \\<And>l1 a1 r1 l2 a2 r2.\n       \\<lbrakk>a1 \\<le> a2 \\<Longrightarrow>\n                int (T_merge \\<langle>l2, a2, r2\\<rangle> r1) +\n                \\<Phi> (merge \\<langle>l2, a2, r2\\<rangle> r1) -\n                \\<Phi> \\<langle>l2, a2, r2\\<rangle> -\n                \\<Phi> r1\n                \\<le> int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n                           rlh \\<langle>l2, a2, r2\\<rangle> +\n                           rlh r1 +\n                           1);\n        \\<not> a1 \\<le> a2 \\<Longrightarrow>\n        int (T_merge \\<langle>l1, a1, r1\\<rangle> r2) +\n        \\<Phi> (merge \\<langle>l1, a1, r1\\<rangle> r2) -\n        \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n        \\<Phi> r2\n        \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle> r2) +\n                   rlh \\<langle>l1, a1, r1\\<rangle> +\n                   rlh r2 +\n                   1)\\<rbrakk>\n       \\<Longrightarrow> int (T_merge \\<langle>l1, a1, r1\\<rangle>\n                               \\<langle>l2, a2, r2\\<rangle>) +\n                         \\<Phi>\n                          (merge \\<langle>l1, a1, r1\\<rangle>\n                            \\<langle>l2, a2, r2\\<rangle>) -\n                         \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n                         \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n                         \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n    \\<langle>l2, a2, r2\\<rangle>) +\n                                    rlh \\<langle>l1, a1, r1\\<rangle> +\n                                    rlh \\<langle>l2, a2, r2\\<rangle> +\n                                    1)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       int (T_merge t \\<langle>\\<rangle>) +\n       \\<Phi> (merge t \\<langle>\\<rangle>) -\n       \\<Phi> t -\n       \\<Phi> \\<langle>\\<rangle>\n       \\<le> int (lrh (merge t \\<langle>\\<rangle>) + rlh t +\n                  rlh \\<langle>\\<rangle> +\n                  1)\n 2. \\<And>l1 a1 r1 l2 a2 r2.\n       \\<lbrakk>a1 \\<le> a2 \\<Longrightarrow>\n                int (T_merge \\<langle>l2, a2, r2\\<rangle> r1) +\n                \\<Phi> (merge \\<langle>l2, a2, r2\\<rangle> r1) -\n                \\<Phi> \\<langle>l2, a2, r2\\<rangle> -\n                \\<Phi> r1\n                \\<le> int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n                           rlh \\<langle>l2, a2, r2\\<rangle> +\n                           rlh r1 +\n                           1);\n        \\<not> a1 \\<le> a2 \\<Longrightarrow>\n        int (T_merge \\<langle>l1, a1, r1\\<rangle> r2) +\n        \\<Phi> (merge \\<langle>l1, a1, r1\\<rangle> r2) -\n        \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n        \\<Phi> r2\n        \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle> r2) +\n                   rlh \\<langle>l1, a1, r1\\<rangle> +\n                   rlh r2 +\n                   1)\\<rbrakk>\n       \\<Longrightarrow> int (T_merge \\<langle>l1, a1, r1\\<rangle>\n                               \\<langle>l2, a2, r2\\<rangle>) +\n                         \\<Phi>\n                          (merge \\<langle>l1, a1, r1\\<rangle>\n                            \\<langle>l2, a2, r2\\<rangle>) -\n                         \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n                         \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n                         \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n    \\<langle>l2, a2, r2\\<rangle>) +\n                                    rlh \\<langle>l1, a1, r1\\<rangle> +\n                                    rlh \\<langle>l2, a2, r2\\<rangle> +\n                                    1)", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>t.\n       int (T_merge t \\<langle>\\<rangle>) +\n       \\<Phi> (merge t \\<langle>\\<rangle>) -\n       \\<Phi> t -\n       \\<Phi> \\<langle>\\<rangle>\n       \\<le> int (lrh (merge t \\<langle>\\<rangle>) + rlh t +\n                  rlh \\<langle>\\<rangle> +\n                  1)\n 2. \\<And>l1 a1 r1 l2 a2 r2.\n       \\<lbrakk>a1 \\<le> a2 \\<Longrightarrow>\n                int (T_merge \\<langle>l2, a2, r2\\<rangle> r1) +\n                \\<Phi> (merge \\<langle>l2, a2, r2\\<rangle> r1) -\n                \\<Phi> \\<langle>l2, a2, r2\\<rangle> -\n                \\<Phi> r1\n                \\<le> int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n                           rlh \\<langle>l2, a2, r2\\<rangle> +\n                           rlh r1 +\n                           1);\n        \\<not> a1 \\<le> a2 \\<Longrightarrow>\n        int (T_merge \\<langle>l1, a1, r1\\<rangle> r2) +\n        \\<Phi> (merge \\<langle>l1, a1, r1\\<rangle> r2) -\n        \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n        \\<Phi> r2\n        \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle> r2) +\n                   rlh \\<langle>l1, a1, r1\\<rangle> +\n                   rlh r2 +\n                   1)\\<rbrakk>\n       \\<Longrightarrow> int (T_merge \\<langle>l1, a1, r1\\<rangle>\n                               \\<langle>l2, a2, r2\\<rangle>) +\n                         \\<Phi>\n                          (merge \\<langle>l1, a1, r1\\<rangle>\n                            \\<langle>l2, a2, r2\\<rangle>) -\n                         \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n                         \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n                         \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n    \\<langle>l2, a2, r2\\<rangle>) +\n                                    rlh \\<langle>l1, a1, r1\\<rangle> +\n                                    rlh \\<langle>l2, a2, r2\\<rangle> +\n                                    1)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (T_merge t_ \\<langle>\\<rangle>) +\n    \\<Phi> (merge t_ \\<langle>\\<rangle>) -\n    \\<Phi> t_ -\n    \\<Phi> \\<langle>\\<rangle>\n    \\<le> int (lrh (merge t_ \\<langle>\\<rangle>) + rlh t_ +\n               rlh \\<langle>\\<rangle> +\n               1)", "by simp"], ["proof (state)\nthis:\n  int (T_merge t_ \\<langle>\\<rangle>) +\n  \\<Phi> (merge t_ \\<langle>\\<rangle>) -\n  \\<Phi> t_ -\n  \\<Phi> \\<langle>\\<rangle>\n  \\<le> int (lrh (merge t_ \\<langle>\\<rangle>) + rlh t_ +\n             rlh \\<langle>\\<rangle> +\n             1)\n\ngoal (1 subgoal):\n 1. \\<And>l1 a1 r1 l2 a2 r2.\n       \\<lbrakk>a1 \\<le> a2 \\<Longrightarrow>\n                int (T_merge \\<langle>l2, a2, r2\\<rangle> r1) +\n                \\<Phi> (merge \\<langle>l2, a2, r2\\<rangle> r1) -\n                \\<Phi> \\<langle>l2, a2, r2\\<rangle> -\n                \\<Phi> r1\n                \\<le> int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n                           rlh \\<langle>l2, a2, r2\\<rangle> +\n                           rlh r1 +\n                           1);\n        \\<not> a1 \\<le> a2 \\<Longrightarrow>\n        int (T_merge \\<langle>l1, a1, r1\\<rangle> r2) +\n        \\<Phi> (merge \\<langle>l1, a1, r1\\<rangle> r2) -\n        \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n        \\<Phi> r2\n        \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle> r2) +\n                   rlh \\<langle>l1, a1, r1\\<rangle> +\n                   rlh r2 +\n                   1)\\<rbrakk>\n       \\<Longrightarrow> int (T_merge \\<langle>l1, a1, r1\\<rangle>\n                               \\<langle>l2, a2, r2\\<rangle>) +\n                         \\<Phi>\n                          (merge \\<langle>l1, a1, r1\\<rangle>\n                            \\<langle>l2, a2, r2\\<rangle>) -\n                         \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n                         \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n                         \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n    \\<langle>l2, a2, r2\\<rangle>) +\n                                    rlh \\<langle>l1, a1, r1\\<rangle> +\n                                    rlh \\<langle>l2, a2, r2\\<rangle> +\n                                    1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l1 a1 r1 l2 a2 r2.\n       \\<lbrakk>a1 \\<le> a2 \\<Longrightarrow>\n                int (T_merge \\<langle>l2, a2, r2\\<rangle> r1) +\n                \\<Phi> (merge \\<langle>l2, a2, r2\\<rangle> r1) -\n                \\<Phi> \\<langle>l2, a2, r2\\<rangle> -\n                \\<Phi> r1\n                \\<le> int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n                           rlh \\<langle>l2, a2, r2\\<rangle> +\n                           rlh r1 +\n                           1);\n        \\<not> a1 \\<le> a2 \\<Longrightarrow>\n        int (T_merge \\<langle>l1, a1, r1\\<rangle> r2) +\n        \\<Phi> (merge \\<langle>l1, a1, r1\\<rangle> r2) -\n        \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n        \\<Phi> r2\n        \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle> r2) +\n                   rlh \\<langle>l1, a1, r1\\<rangle> +\n                   rlh r2 +\n                   1)\\<rbrakk>\n       \\<Longrightarrow> int (T_merge \\<langle>l1, a1, r1\\<rangle>\n                               \\<langle>l2, a2, r2\\<rangle>) +\n                         \\<Phi>\n                          (merge \\<langle>l1, a1, r1\\<rangle>\n                            \\<langle>l2, a2, r2\\<rangle>) -\n                         \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n                         \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n                         \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n    \\<langle>l2, a2, r2\\<rangle>) +\n                                    rlh \\<langle>l1, a1, r1\\<rangle> +\n                                    rlh \\<langle>l2, a2, r2\\<rangle> +\n                                    1)", "case (3 l1 a1 r1 l2 a2 r2)"], ["proof (state)\nthis:\n  a1 \\<le> a2 \\<Longrightarrow>\n  int (T_merge \\<langle>l2, a2, r2\\<rangle> r1) +\n  \\<Phi> (merge \\<langle>l2, a2, r2\\<rangle> r1) -\n  \\<Phi> \\<langle>l2, a2, r2\\<rangle> -\n  \\<Phi> r1\n  \\<le> int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n             rlh \\<langle>l2, a2, r2\\<rangle> +\n             rlh r1 +\n             1)\n  \\<not> a1 \\<le> a2 \\<Longrightarrow>\n  int (T_merge \\<langle>l1, a1, r1\\<rangle> r2) +\n  \\<Phi> (merge \\<langle>l1, a1, r1\\<rangle> r2) -\n  \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n  \\<Phi> r2\n  \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle> r2) +\n             rlh \\<langle>l1, a1, r1\\<rangle> +\n             rlh r2 +\n             1)\n\ngoal (1 subgoal):\n 1. \\<And>l1 a1 r1 l2 a2 r2.\n       \\<lbrakk>a1 \\<le> a2 \\<Longrightarrow>\n                int (T_merge \\<langle>l2, a2, r2\\<rangle> r1) +\n                \\<Phi> (merge \\<langle>l2, a2, r2\\<rangle> r1) -\n                \\<Phi> \\<langle>l2, a2, r2\\<rangle> -\n                \\<Phi> r1\n                \\<le> int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n                           rlh \\<langle>l2, a2, r2\\<rangle> +\n                           rlh r1 +\n                           1);\n        \\<not> a1 \\<le> a2 \\<Longrightarrow>\n        int (T_merge \\<langle>l1, a1, r1\\<rangle> r2) +\n        \\<Phi> (merge \\<langle>l1, a1, r1\\<rangle> r2) -\n        \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n        \\<Phi> r2\n        \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle> r2) +\n                   rlh \\<langle>l1, a1, r1\\<rangle> +\n                   rlh r2 +\n                   1)\\<rbrakk>\n       \\<Longrightarrow> int (T_merge \\<langle>l1, a1, r1\\<rangle>\n                               \\<langle>l2, a2, r2\\<rangle>) +\n                         \\<Phi>\n                          (merge \\<langle>l1, a1, r1\\<rangle>\n                            \\<langle>l2, a2, r2\\<rangle>) -\n                         \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n                         \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n                         \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n    \\<langle>l2, a2, r2\\<rangle>) +\n                                    rlh \\<langle>l1, a1, r1\\<rangle> +\n                                    rlh \\<langle>l2, a2, r2\\<rangle> +\n                                    1)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)", "proof (cases \"a1 \\<le> a2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)\n 2. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)", "case True"], ["proof (state)\nthis:\n  a1 \\<le> a2\n\ngoal (2 subgoals):\n 1. a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)\n 2. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)", "let ?t1 = \"Node l1 a1 r1\""], ["proof (state)\ngoal (2 subgoals):\n 1. a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)\n 2. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)", "let ?t2 = \"Node l2 a2 r2\""], ["proof (state)\ngoal (2 subgoals):\n 1. a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)\n 2. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)", "let ?m = \"merge ?t2 r1\""], ["proof (state)\ngoal (2 subgoals):\n 1. a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)\n 2. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)", "have \"T_merge ?t1 ?t2 + \\<Phi> (merge ?t1 ?t2) - \\<Phi> ?t1 - \\<Phi> ?t2\n          = T_merge ?t2 r1 + 1 + \\<Phi> ?m + \\<Phi> l1 + rh ?m l1 - \\<Phi> ?t1 - \\<Phi> ?t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle> =\n    int (T_merge \\<langle>l2, a2, r2\\<rangle> r1 + 1) +\n    \\<Phi> (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n    \\<Phi> l1 +\n    int (rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>", "using True"], ["proof (prove)\nusing this:\n  a1 \\<le> a2\n\ngoal (1 subgoal):\n 1. int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle> =\n    int (T_merge \\<langle>l2, a2, r2\\<rangle> r1 + 1) +\n    \\<Phi> (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n    \\<Phi> l1 +\n    int (rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>", "by (simp)"], ["proof (state)\nthis:\n  int (T_merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) +\n  \\<Phi> (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n  \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n  \\<Phi> \\<langle>l2, a2, r2\\<rangle> =\n  int (T_merge \\<langle>l2, a2, r2\\<rangle> r1 + 1) +\n  \\<Phi> (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n  \\<Phi> l1 +\n  int (rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1) -\n  \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n  \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n\ngoal (2 subgoals):\n 1. a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)\n 2. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)", "also"], ["proof (state)\nthis:\n  int (T_merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) +\n  \\<Phi> (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n  \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n  \\<Phi> \\<langle>l2, a2, r2\\<rangle> =\n  int (T_merge \\<langle>l2, a2, r2\\<rangle> r1 + 1) +\n  \\<Phi> (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n  \\<Phi> l1 +\n  int (rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1) -\n  \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n  \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n\ngoal (2 subgoals):\n 1. a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)\n 2. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)", "have \"\\<dots> = T_merge ?t2 r1 + 1 + \\<Phi> ?m + rh ?m l1 - \\<Phi> r1 - rh l1 r1 - \\<Phi> ?t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (T_merge \\<langle>l2, a2, r2\\<rangle> r1 + 1) +\n    \\<Phi> (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n    \\<Phi> l1 +\n    int (rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle> =\n    int (T_merge \\<langle>l2, a2, r2\\<rangle> r1 + 1) +\n    \\<Phi> (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n    int (rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1) -\n    \\<Phi> r1 -\n    int (rh l1 r1) -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>", "by simp"], ["proof (state)\nthis:\n  int (T_merge \\<langle>l2, a2, r2\\<rangle> r1 + 1) +\n  \\<Phi> (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n  \\<Phi> l1 +\n  int (rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1) -\n  \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n  \\<Phi> \\<langle>l2, a2, r2\\<rangle> =\n  int (T_merge \\<langle>l2, a2, r2\\<rangle> r1 + 1) +\n  \\<Phi> (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n  int (rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1) -\n  \\<Phi> r1 -\n  int (rh l1 r1) -\n  \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n\ngoal (2 subgoals):\n 1. a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)\n 2. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)", "also"], ["proof (state)\nthis:\n  int (T_merge \\<langle>l2, a2, r2\\<rangle> r1 + 1) +\n  \\<Phi> (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n  \\<Phi> l1 +\n  int (rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1) -\n  \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n  \\<Phi> \\<langle>l2, a2, r2\\<rangle> =\n  int (T_merge \\<langle>l2, a2, r2\\<rangle> r1 + 1) +\n  \\<Phi> (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n  int (rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1) -\n  \\<Phi> r1 -\n  int (rh l1 r1) -\n  \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n\ngoal (2 subgoals):\n 1. a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)\n 2. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)", "have \"\\<dots> \\<le> lrh ?m + rlh ?t2 + rlh r1 + rh ?m l1 + 2 - rh l1 r1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (T_merge \\<langle>l2, a2, r2\\<rangle> r1 + 1) +\n    \\<Phi> (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n    int (rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1) -\n    \\<Phi> r1 -\n    int (rh l1 r1) -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               rlh r1 +\n               rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1 +\n               2 -\n               rh l1 r1)", "using \"3.IH\"(1)[OF True]"], ["proof (prove)\nusing this:\n  int (T_merge \\<langle>l2, a2, r2\\<rangle> r1) +\n  \\<Phi> (merge \\<langle>l2, a2, r2\\<rangle> r1) -\n  \\<Phi> \\<langle>l2, a2, r2\\<rangle> -\n  \\<Phi> r1\n  \\<le> int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n             rlh \\<langle>l2, a2, r2\\<rangle> +\n             rlh r1 +\n             1)\n\ngoal (1 subgoal):\n 1. int (T_merge \\<langle>l2, a2, r2\\<rangle> r1 + 1) +\n    \\<Phi> (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n    int (rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1) -\n    \\<Phi> r1 -\n    int (rh l1 r1) -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               rlh r1 +\n               rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1 +\n               2 -\n               rh l1 r1)", "by linarith"], ["proof (state)\nthis:\n  int (T_merge \\<langle>l2, a2, r2\\<rangle> r1 + 1) +\n  \\<Phi> (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n  int (rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1) -\n  \\<Phi> r1 -\n  int (rh l1 r1) -\n  \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n  \\<le> int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n             rlh \\<langle>l2, a2, r2\\<rangle> +\n             rlh r1 +\n             rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1 +\n             2 -\n             rh l1 r1)\n\ngoal (2 subgoals):\n 1. a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)\n 2. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)", "also"], ["proof (state)\nthis:\n  int (T_merge \\<langle>l2, a2, r2\\<rangle> r1 + 1) +\n  \\<Phi> (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n  int (rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1) -\n  \\<Phi> r1 -\n  int (rh l1 r1) -\n  \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n  \\<le> int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n             rlh \\<langle>l2, a2, r2\\<rangle> +\n             rlh r1 +\n             rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1 +\n             2 -\n             rh l1 r1)\n\ngoal (2 subgoals):\n 1. a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)\n 2. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)", "have \"\\<dots> = lrh ?m + rlh ?t2 + rlh r1 + rh ?m l1 + 1 + (1 - rh l1 r1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n         rlh \\<langle>l2, a2, r2\\<rangle> +\n         rlh r1 +\n         rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1 +\n         2 -\n         rh l1 r1) =\n    int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n         rlh \\<langle>l2, a2, r2\\<rangle> +\n         rlh r1 +\n         rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1 +\n         1 +\n         (1 - rh l1 r1))", "using rh1[of l1 r1]"], ["proof (prove)\nusing this:\n  rh l1 r1 \\<le> 1\n\ngoal (1 subgoal):\n 1. int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n         rlh \\<langle>l2, a2, r2\\<rangle> +\n         rlh r1 +\n         rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1 +\n         2 -\n         rh l1 r1) =\n    int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n         rlh \\<langle>l2, a2, r2\\<rangle> +\n         rlh r1 +\n         rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1 +\n         1 +\n         (1 - rh l1 r1))", "by (simp)"], ["proof (state)\nthis:\n  int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n       rlh \\<langle>l2, a2, r2\\<rangle> +\n       rlh r1 +\n       rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1 +\n       2 -\n       rh l1 r1) =\n  int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n       rlh \\<langle>l2, a2, r2\\<rangle> +\n       rlh r1 +\n       rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1 +\n       1 +\n       (1 - rh l1 r1))\n\ngoal (2 subgoals):\n 1. a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)\n 2. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)", "also"], ["proof (state)\nthis:\n  int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n       rlh \\<langle>l2, a2, r2\\<rangle> +\n       rlh r1 +\n       rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1 +\n       2 -\n       rh l1 r1) =\n  int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n       rlh \\<langle>l2, a2, r2\\<rangle> +\n       rlh r1 +\n       rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1 +\n       1 +\n       (1 - rh l1 r1))\n\ngoal (2 subgoals):\n 1. a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)\n 2. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)", "have \"\\<dots> = lrh ?m + rlh ?t2 + rlh ?t1 + rh ?m l1 + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n         rlh \\<langle>l2, a2, r2\\<rangle> +\n         rlh r1 +\n         rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1 +\n         1 +\n         (1 - rh l1 r1)) =\n    int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n         rlh \\<langle>l2, a2, r2\\<rangle> +\n         rlh \\<langle>l1, a1, r1\\<rangle> +\n         rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1 +\n         1)", "by (simp)"], ["proof (state)\nthis:\n  int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n       rlh \\<langle>l2, a2, r2\\<rangle> +\n       rlh r1 +\n       rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1 +\n       1 +\n       (1 - rh l1 r1)) =\n  int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n       rlh \\<langle>l2, a2, r2\\<rangle> +\n       rlh \\<langle>l1, a1, r1\\<rangle> +\n       rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1 +\n       1)\n\ngoal (2 subgoals):\n 1. a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)\n 2. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)", "also"], ["proof (state)\nthis:\n  int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n       rlh \\<langle>l2, a2, r2\\<rangle> +\n       rlh r1 +\n       rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1 +\n       1 +\n       (1 - rh l1 r1)) =\n  int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n       rlh \\<langle>l2, a2, r2\\<rangle> +\n       rlh \\<langle>l1, a1, r1\\<rangle> +\n       rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1 +\n       1)\n\ngoal (2 subgoals):\n 1. a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)\n 2. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)", "have \"\\<dots> = lrh (merge ?t1 ?t2) + rlh ?t1 + rlh ?t2 + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n         rlh \\<langle>l2, a2, r2\\<rangle> +\n         rlh \\<langle>l1, a1, r1\\<rangle> +\n         rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1 +\n         1) =\n    int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n               \\<langle>l2, a2, r2\\<rangle>) +\n         rlh \\<langle>l1, a1, r1\\<rangle> +\n         rlh \\<langle>l2, a2, r2\\<rangle> +\n         1)", "using True"], ["proof (prove)\nusing this:\n  a1 \\<le> a2\n\ngoal (1 subgoal):\n 1. int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n         rlh \\<langle>l2, a2, r2\\<rangle> +\n         rlh \\<langle>l1, a1, r1\\<rangle> +\n         rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1 +\n         1) =\n    int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n               \\<langle>l2, a2, r2\\<rangle>) +\n         rlh \\<langle>l1, a1, r1\\<rangle> +\n         rlh \\<langle>l2, a2, r2\\<rangle> +\n         1)", "by(simp)"], ["proof (state)\nthis:\n  int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n       rlh \\<langle>l2, a2, r2\\<rangle> +\n       rlh \\<langle>l1, a1, r1\\<rangle> +\n       rh (merge \\<langle>l2, a2, r2\\<rangle> r1) l1 +\n       1) =\n  int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n             \\<langle>l2, a2, r2\\<rangle>) +\n       rlh \\<langle>l1, a1, r1\\<rangle> +\n       rlh \\<langle>l2, a2, r2\\<rangle> +\n       1)\n\ngoal (2 subgoals):\n 1. a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)\n 2. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)", "finally"], ["proof (chain)\npicking this:\n  int (T_merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) +\n  \\<Phi> (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n  \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n  \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n  \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                   \\<langle>l2, a2, r2\\<rangle>) +\n             rlh \\<langle>l1, a1, r1\\<rangle> +\n             rlh \\<langle>l2, a2, r2\\<rangle> +\n             1)", "show ?thesis"], ["proof (prove)\nusing this:\n  int (T_merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) +\n  \\<Phi> (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n  \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n  \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n  \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                   \\<langle>l2, a2, r2\\<rangle>) +\n             rlh \\<langle>l1, a1, r1\\<rangle> +\n             rlh \\<langle>l2, a2, r2\\<rangle> +\n             1)\n\ngoal (1 subgoal):\n 1. int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)", "."], ["proof (state)\nthis:\n  int (T_merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) +\n  \\<Phi> (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n  \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n  \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n  \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                   \\<langle>l2, a2, r2\\<rangle>) +\n             rlh \\<langle>l1, a1, r1\\<rangle> +\n             rlh \\<langle>l2, a2, r2\\<rangle> +\n             1)\n\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)", "case False"], ["proof (state)\nthis:\n  \\<not> a1 \\<le> a2\n\ngoal (1 subgoal):\n 1. \\<not> a1 \\<le> a2 \\<Longrightarrow>\n    int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)", "with 3"], ["proof (chain)\npicking this:\n  a1 \\<le> a2 \\<Longrightarrow>\n  int (T_merge \\<langle>l2, a2, r2\\<rangle> r1) +\n  \\<Phi> (merge \\<langle>l2, a2, r2\\<rangle> r1) -\n  \\<Phi> \\<langle>l2, a2, r2\\<rangle> -\n  \\<Phi> r1\n  \\<le> int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n             rlh \\<langle>l2, a2, r2\\<rangle> +\n             rlh r1 +\n             1)\n  \\<not> a1 \\<le> a2 \\<Longrightarrow>\n  int (T_merge \\<langle>l1, a1, r1\\<rangle> r2) +\n  \\<Phi> (merge \\<langle>l1, a1, r1\\<rangle> r2) -\n  \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n  \\<Phi> r2\n  \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle> r2) +\n             rlh \\<langle>l1, a1, r1\\<rangle> +\n             rlh r2 +\n             1)\n  \\<not> a1 \\<le> a2", "show ?thesis"], ["proof (prove)\nusing this:\n  a1 \\<le> a2 \\<Longrightarrow>\n  int (T_merge \\<langle>l2, a2, r2\\<rangle> r1) +\n  \\<Phi> (merge \\<langle>l2, a2, r2\\<rangle> r1) -\n  \\<Phi> \\<langle>l2, a2, r2\\<rangle> -\n  \\<Phi> r1\n  \\<le> int (lrh (merge \\<langle>l2, a2, r2\\<rangle> r1) +\n             rlh \\<langle>l2, a2, r2\\<rangle> +\n             rlh r1 +\n             1)\n  \\<not> a1 \\<le> a2 \\<Longrightarrow>\n  int (T_merge \\<langle>l1, a1, r1\\<rangle> r2) +\n  \\<Phi> (merge \\<langle>l1, a1, r1\\<rangle> r2) -\n  \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n  \\<Phi> r2\n  \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle> r2) +\n             rlh \\<langle>l1, a1, r1\\<rangle> +\n             rlh r2 +\n             1)\n  \\<not> a1 \\<le> a2\n\ngoal (1 subgoal):\n 1. int (T_merge \\<langle>l1, a1, r1\\<rangle>\n          \\<langle>l2, a2, r2\\<rangle>) +\n    \\<Phi>\n     (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n    \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n    \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n    \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                     \\<langle>l2, a2, r2\\<rangle>) +\n               rlh \\<langle>l1, a1, r1\\<rangle> +\n               rlh \\<langle>l2, a2, r2\\<rangle> +\n               1)", "by auto"], ["proof (state)\nthis:\n  int (T_merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) +\n  \\<Phi> (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n  \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n  \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n  \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                   \\<langle>l2, a2, r2\\<rangle>) +\n             rlh \\<langle>l1, a1, r1\\<rangle> +\n             rlh \\<langle>l2, a2, r2\\<rangle> +\n             1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  int (T_merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) +\n  \\<Phi> (merge \\<langle>l1, a1, r1\\<rangle> \\<langle>l2, a2, r2\\<rangle>) -\n  \\<Phi> \\<langle>l1, a1, r1\\<rangle> -\n  \\<Phi> \\<langle>l2, a2, r2\\<rangle>\n  \\<le> int (lrh (merge \\<langle>l1, a1, r1\\<rangle>\n                   \\<langle>l2, a2, r2\\<rangle>) +\n             rlh \\<langle>l1, a1, r1\\<rangle> +\n             rlh \\<langle>l2, a2, r2\\<rangle> +\n             1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma amor_le:\n  \"T_merge t1 t2 + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2 \\<le>\n   lrh(merge t1 t2) + rlh t1 + rlh t2 + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2\n    \\<le> int (lrh (merge t1 t2) + rlh t1 + rlh t2 + 1)", "by(induction t1 t2 rule: merge.induct)(auto)"], ["", "lemma a_merge:\n  \"T_merge t1 t2 + \\<Phi>(merge t1 t2) - \\<Phi> t1 - \\<Phi> t2 \\<le>\n   3 * log 2 (size1 t1 + size1 t2) + 1\" (is \"?l \\<le> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int\n     (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n    \\<le> 3 * log 2 (real (size1 t1 + size1 t2)) + 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int\n     (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n    \\<le> 3 * log 2 (real (size1 t1 + size1 t2)) + 1", "have \"?l \\<le> lrh(merge t1 t2) + rlh t1 + rlh t2 + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int\n     (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n    \\<le> real (lrh (merge t1 t2) + rlh t1 + rlh t2 + 1)", "using amor_le[of t1 t2]"], ["proof (prove)\nusing this:\n  int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2\n  \\<le> int (lrh (merge t1 t2) + rlh t1 + rlh t2 + 1)\n\ngoal (1 subgoal):\n 1. real_of_int\n     (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n    \\<le> real (lrh (merge t1 t2) + rlh t1 + rlh t2 + 1)", "by arith"], ["proof (state)\nthis:\n  real_of_int\n   (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n  \\<le> real (lrh (merge t1 t2) + rlh t1 + rlh t2 + 1)\n\ngoal (1 subgoal):\n 1. real_of_int\n     (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n    \\<le> 3 * log 2 (real (size1 t1 + size1 t2)) + 1", "also"], ["proof (state)\nthis:\n  real_of_int\n   (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n  \\<le> real (lrh (merge t1 t2) + rlh t1 + rlh t2 + 1)\n\ngoal (1 subgoal):\n 1. real_of_int\n     (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n    \\<le> 3 * log 2 (real (size1 t1 + size1 t2)) + 1", "have \"\\<dots> = real(lrh(merge t1 t2)) + rlh t1 + rlh t2 + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (lrh (merge t1 t2) + rlh t1 + rlh t2 + 1) =\n    real (lrh (merge t1 t2)) + real (rlh t1) + real (rlh t2) + 1", "by simp"], ["proof (state)\nthis:\n  real (lrh (merge t1 t2) + rlh t1 + rlh t2 + 1) =\n  real (lrh (merge t1 t2)) + real (rlh t1) + real (rlh t2) + 1\n\ngoal (1 subgoal):\n 1. real_of_int\n     (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n    \\<le> 3 * log 2 (real (size1 t1 + size1 t2)) + 1", "also"], ["proof (state)\nthis:\n  real (lrh (merge t1 t2) + rlh t1 + rlh t2 + 1) =\n  real (lrh (merge t1 t2)) + real (rlh t1) + real (rlh t2) + 1\n\ngoal (1 subgoal):\n 1. real_of_int\n     (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n    \\<le> 3 * log 2 (real (size1 t1 + size1 t2)) + 1", "have \"\\<dots> = real(lrh(merge t1 t2)) + (real(rlh t1) + rlh t2) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (lrh (merge t1 t2)) + real (rlh t1) + real (rlh t2) + 1 =\n    real (lrh (merge t1 t2)) + (real (rlh t1) + real (rlh t2)) + 1", "by simp"], ["proof (state)\nthis:\n  real (lrh (merge t1 t2)) + real (rlh t1) + real (rlh t2) + 1 =\n  real (lrh (merge t1 t2)) + (real (rlh t1) + real (rlh t2)) + 1\n\ngoal (1 subgoal):\n 1. real_of_int\n     (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n    \\<le> 3 * log 2 (real (size1 t1 + size1 t2)) + 1", "also"], ["proof (state)\nthis:\n  real (lrh (merge t1 t2)) + real (rlh t1) + real (rlh t2) + 1 =\n  real (lrh (merge t1 t2)) + (real (rlh t1) + real (rlh t2)) + 1\n\ngoal (1 subgoal):\n 1. real_of_int\n     (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n    \\<le> 3 * log 2 (real (size1 t1 + size1 t2)) + 1", "have \"rlh t1 \\<le> log 2 (size1 t1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (rlh t1) \\<le> log 2 (real (size1 t1))", "by(rule Dlog)"], ["proof (state)\nthis:\n  real (rlh t1) \\<le> log 2 (real (size1 t1))\n\ngoal (1 subgoal):\n 1. real_of_int\n     (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n    \\<le> 3 * log 2 (real (size1 t1 + size1 t2)) + 1", "also"], ["proof (state)\nthis:\n  real (rlh t1) \\<le> log 2 (real (size1 t1))\n\ngoal (1 subgoal):\n 1. real_of_int\n     (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n    \\<le> 3 * log 2 (real (size1 t1 + size1 t2)) + 1", "have \"rlh t2 \\<le> log 2 (size1 t2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (rlh t2) \\<le> log 2 (real (size1 t2))", "by(rule Dlog)"], ["proof (state)\nthis:\n  real (rlh t2) \\<le> log 2 (real (size1 t2))\n\ngoal (1 subgoal):\n 1. real_of_int\n     (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n    \\<le> 3 * log 2 (real (size1 t1 + size1 t2)) + 1", "also"], ["proof (state)\nthis:\n  real (rlh t2) \\<le> log 2 (real (size1 t2))\n\ngoal (1 subgoal):\n 1. real_of_int\n     (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n    \\<le> 3 * log 2 (real (size1 t1 + size1 t2)) + 1", "have \"lrh (merge t1 t2) \\<le> log 2 (size1(merge t1 t2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (lrh (merge t1 t2)) \\<le> log 2 (real (size1 (merge t1 t2)))", "by(rule Glog)"], ["proof (state)\nthis:\n  real (lrh (merge t1 t2)) \\<le> log 2 (real (size1 (merge t1 t2)))\n\ngoal (1 subgoal):\n 1. real_of_int\n     (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n    \\<le> 3 * log 2 (real (size1 t1 + size1 t2)) + 1", "also"], ["proof (state)\nthis:\n  real (lrh (merge t1 t2)) \\<le> log 2 (real (size1 (merge t1 t2)))\n\ngoal (1 subgoal):\n 1. real_of_int\n     (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n    \\<le> 3 * log 2 (real (size1 t1 + size1 t2)) + 1", "have \"size1(merge t1 t2) = size1 t1 + size1 t2 - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size1 (merge t1 t2) = size1 t1 + size1 t2 - 1", "by(simp add: size1_size size_merge)"], ["proof (state)\nthis:\n  size1 (merge t1 t2) = size1 t1 + size1 t2 - 1\n\ngoal (1 subgoal):\n 1. real_of_int\n     (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n    \\<le> 3 * log 2 (real (size1 t1 + size1 t2)) + 1", "also"], ["proof (state)\nthis:\n  size1 (merge t1 t2) = size1 t1 + size1 t2 - 1\n\ngoal (1 subgoal):\n 1. real_of_int\n     (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n    \\<le> 3 * log 2 (real (size1 t1 + size1 t2)) + 1", "have \"log 2 (size1 t1 + size1 t2 - 1) \\<le> log 2 (size1 t1 + size1 t2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real (size1 t1 + size1 t2 - 1))\n    \\<le> log 2 (real (size1 t1 + size1 t2))", "by(simp add: size1_size)"], ["proof (state)\nthis:\n  log 2 (real (size1 t1 + size1 t2 - 1))\n  \\<le> log 2 (real (size1 t1 + size1 t2))\n\ngoal (1 subgoal):\n 1. real_of_int\n     (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n    \\<le> 3 * log 2 (real (size1 t1 + size1 t2)) + 1", "also"], ["proof (state)\nthis:\n  log 2 (real (size1 t1 + size1 t2 - 1))\n  \\<le> log 2 (real (size1 t1 + size1 t2))\n\ngoal (1 subgoal):\n 1. real_of_int\n     (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n    \\<le> 3 * log 2 (real (size1 t1 + size1 t2)) + 1", "have \"log 2 (size1 t1) + log 2 (size1 t2) \\<le> 2 * log 2 (real(size1 t1) + (size1 t2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real (size1 t1)) + log 2 (real (size1 t2))\n    \\<le> 2 * log 2 (real (size1 t1) + real (size1 t2))", "by(rule plus_log_le_2log_plus) (auto simp: size1_size)"], ["proof (state)\nthis:\n  log 2 (real (size1 t1)) + log 2 (real (size1 t2))\n  \\<le> 2 * log 2 (real (size1 t1) + real (size1 t2))\n\ngoal (1 subgoal):\n 1. real_of_int\n     (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n    \\<le> 3 * log 2 (real (size1 t1 + size1 t2)) + 1", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              real (lrh (merge t1 t2)) + (x + real (rlh t2)) + 1\n              \\<le> real (lrh (merge t1 t2)) + (y + real (rlh t2)) + 1;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      real (lrh (merge t1 t2)) + (log 2 (real (size1 t1)) + x) + 1\n      \\<le> real (lrh (merge t1 t2)) + (log 2 (real (size1 t1)) + y) + 1;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + (log 2 (real (size1 t1)) + log 2 (real (size1 t2))) + 1\n      \\<le> y + (log 2 (real (size1 t1)) + log 2 (real (size1 t2))) + 1;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + (log 2 (real (size1 t1)) + log 2 (real (size1 t2))) + 1\n      \\<le> y + (log 2 (real (size1 t1)) + log 2 (real (size1 t2))) + 1;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      log 2 (real (size1 t1 + size1 t2)) + x + 1\n      \\<le> log 2 (real (size1 t1 + size1 t2)) + y + 1\\<rbrakk>\n  \\<Longrightarrow> real_of_int\n                     (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) -\n                      \\<Phi> t1 -\n                      \\<Phi> t2)\n                    \\<le> log 2 (real (size1 t1 + size1 t2)) +\n                          2 * log 2 (real (size1 t1) + real (size1 t2)) +\n                          1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              x \\<le> y \\<Longrightarrow>\n              real (lrh (merge t1 t2)) + (x + real (rlh t2)) + 1\n              \\<le> real (lrh (merge t1 t2)) + (y + real (rlh t2)) + 1;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      real (lrh (merge t1 t2)) + (log 2 (real (size1 t1)) + x) + 1\n      \\<le> real (lrh (merge t1 t2)) + (log 2 (real (size1 t1)) + y) + 1;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + (log 2 (real (size1 t1)) + log 2 (real (size1 t2))) + 1\n      \\<le> y + (log 2 (real (size1 t1)) + log 2 (real (size1 t2))) + 1;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + (log 2 (real (size1 t1)) + log 2 (real (size1 t2))) + 1\n      \\<le> y + (log 2 (real (size1 t1)) + log 2 (real (size1 t2))) + 1;\n   \\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      log 2 (real (size1 t1 + size1 t2)) + x + 1\n      \\<le> log 2 (real (size1 t1 + size1 t2)) + y + 1\\<rbrakk>\n  \\<Longrightarrow> real_of_int\n                     (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) -\n                      \\<Phi> t1 -\n                      \\<Phi> t2)\n                    \\<le> log 2 (real (size1 t1 + size1 t2)) +\n                          2 * log 2 (real (size1 t1) + real (size1 t2)) +\n                          1\n\ngoal (1 subgoal):\n 1. real_of_int\n     (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n    \\<le> 3 * log 2 (real (size1 t1 + size1 t2)) + 1", "by(simp)"], ["proof (state)\nthis:\n  real_of_int\n   (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n  \\<le> 3 * log 2 (real (size1 t1 + size1 t2)) + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "definition T_insert :: \"'a::linorder \\<Rightarrow> 'a tree \\<Rightarrow> int\" where\n\"T_insert a t = T_merge (Node Leaf a Leaf) t + 1\""], ["", "lemma a_insert: \"T_insert a t + \\<Phi>(skew_heap.insert a t) - \\<Phi> t \\<le> 3 * log 2 (size1 t + 2) + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (T_insert a t + \\<Phi> (skew_heap.insert a t) - \\<Phi> t)\n    \\<le> 3 * log 2 (real (size1 t + 2)) + 2", "using a_merge[of \"Node Leaf a Leaf\" \"t\"]"], ["proof (prove)\nusing this:\n  real_of_int\n   (int (T_merge \\<langle>\\<langle>\\<rangle>, a, \\<langle>\\<rangle>\\<rangle>\n          t) +\n    \\<Phi>\n     (merge \\<langle>\\<langle>\\<rangle>, a, \\<langle>\\<rangle>\\<rangle> t) -\n    \\<Phi> \\<langle>\\<langle>\\<rangle>, a, \\<langle>\\<rangle>\\<rangle> -\n    \\<Phi> t)\n  \\<le> 3 *\n        log 2\n         (real\n           (size1\n             \\<langle>\\<langle>\\<rangle>, a, \\<langle>\\<rangle>\\<rangle> +\n            size1 t)) +\n        1\n\ngoal (1 subgoal):\n 1. real_of_int (T_insert a t + \\<Phi> (skew_heap.insert a t) - \\<Phi> t)\n    \\<le> 3 * log 2 (real (size1 t + 2)) + 2", "by (simp add: numeral_eq_Suc T_insert_def rh_def)"], ["", "definition T_del_min :: \"('a::linorder) tree \\<Rightarrow> int\" where\n\"T_del_min t = (case t of Leaf \\<Rightarrow> 1 | Node t1 a t2 \\<Rightarrow> T_merge t1 t2 + 1)\""], ["", "lemma a_del_min: \"T_del_min t + \\<Phi>(skew_heap.del_min t) - \\<Phi> t \\<le> 3 * log 2 (size1 t + 2) + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (T_del_min t + \\<Phi> (skew_heap.del_min t) - \\<Phi> t)\n    \\<le> 3 * log 2 (real (size1 t + 2)) + 2", "proof (cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. t = \\<langle>\\<rangle> \\<Longrightarrow>\n    real_of_int (T_del_min t + \\<Phi> (skew_heap.del_min t) - \\<Phi> t)\n    \\<le> 3 * log 2 (real (size1 t + 2)) + 2\n 2. \\<And>x21 x22 x23.\n       t = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       real_of_int (T_del_min t + \\<Phi> (skew_heap.del_min t) - \\<Phi> t)\n       \\<le> 3 * log 2 (real (size1 t + 2)) + 2", "case Leaf"], ["proof (state)\nthis:\n  t = \\<langle>\\<rangle>\n\ngoal (2 subgoals):\n 1. t = \\<langle>\\<rangle> \\<Longrightarrow>\n    real_of_int (T_del_min t + \\<Phi> (skew_heap.del_min t) - \\<Phi> t)\n    \\<le> 3 * log 2 (real (size1 t + 2)) + 2\n 2. \\<And>x21 x22 x23.\n       t = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       real_of_int (T_del_min t + \\<Phi> (skew_heap.del_min t) - \\<Phi> t)\n       \\<le> 3 * log 2 (real (size1 t + 2)) + 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  t = \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. real_of_int (T_del_min t + \\<Phi> (skew_heap.del_min t) - \\<Phi> t)\n    \\<le> 3 * log 2 (real (size1 t + 2)) + 2", "by (simp add: T_del_min_def)"], ["proof (state)\nthis:\n  real_of_int (T_del_min t + \\<Phi> (skew_heap.del_min t) - \\<Phi> t)\n  \\<le> 3 * log 2 (real (size1 t + 2)) + 2\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       t = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       real_of_int (T_del_min t + \\<Phi> (skew_heap.del_min t) - \\<Phi> t)\n       \\<le> 3 * log 2 (real (size1 t + 2)) + 2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       t = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       real_of_int (T_del_min t + \\<Phi> (skew_heap.del_min t) - \\<Phi> t)\n       \\<le> 3 * log 2 (real (size1 t + 2)) + 2", "case (Node t1 _ t2)"], ["proof (state)\nthis:\n  t = \\<langle>t1, x22_, t2\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       t = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       real_of_int (T_del_min t + \\<Phi> (skew_heap.del_min t) - \\<Phi> t)\n       \\<le> 3 * log 2 (real (size1 t + 2)) + 2", "have [arith]: \"log 2 (2 + (real (size t1) + real (size t2))) \\<le>\n                log 2 (4 + (real (size t1) + real (size t2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (2 + (real (size t1) + real (size t2)))\n    \\<le> log 2 (4 + (real (size t1) + real (size t2)))", "by simp"], ["proof (state)\nthis:\n  log 2 (2 + (real (size t1) + real (size t2)))\n  \\<le> log 2 (4 + (real (size t1) + real (size t2)))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       t = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       real_of_int (T_del_min t + \\<Phi> (skew_heap.del_min t) - \\<Phi> t)\n       \\<le> 3 * log 2 (real (size1 t + 2)) + 2", "from Node"], ["proof (chain)\npicking this:\n  t = \\<langle>t1, x22_, t2\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  t = \\<langle>t1, x22_, t2\\<rangle>\n\ngoal (1 subgoal):\n 1. real_of_int (T_del_min t + \\<Phi> (skew_heap.del_min t) - \\<Phi> t)\n    \\<le> 3 * log 2 (real (size1 t + 2)) + 2", "using a_merge[of t1 t2]"], ["proof (prove)\nusing this:\n  t = \\<langle>t1, x22_, t2\\<rangle>\n  real_of_int\n   (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n  \\<le> 3 * log 2 (real (size1 t1 + size1 t2)) + 1\n\ngoal (1 subgoal):\n 1. real_of_int (T_del_min t + \\<Phi> (skew_heap.del_min t) - \\<Phi> t)\n    \\<le> 3 * log 2 (real (size1 t + 2)) + 2", "by (simp add: size1_size T_del_min_def rh_def)"], ["proof (state)\nthis:\n  real_of_int (T_del_min t + \\<Phi> (skew_heap.del_min t) - \\<Phi> t)\n  \\<le> 3 * log 2 (real (size1 t + 2)) + 2\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Instantiation of Amortized Framework\""], ["", "lemma T_merge_nneg: \"T_merge t1 t2 \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> T_merge t1 t2", "by(induction t1 t2 rule: T_merge.induct) auto"], ["", "fun exec :: \"'a::linorder op \\<Rightarrow> 'a tree list \\<Rightarrow> 'a tree\" where\n\"exec Empty [] = Leaf\" |\n\"exec (Insert a) [t] = skew_heap.insert a t\" |\n\"exec Del_min [t] = skew_heap.del_min t\" |\n\"exec Merge [t1,t2] = merge t1 t2\""], ["", "fun cost :: \"'a::linorder op \\<Rightarrow> 'a tree list \\<Rightarrow> nat\" where\n\"cost Empty [] = 1\" |\n\"cost (Insert a) [t] = T_merge (Node Leaf a Leaf) t + 1\" |\n\"cost Del_min [t] = (case t of Leaf \\<Rightarrow> 1 | Node t1 a t2 \\<Rightarrow> T_merge t1 t2 + 1)\" |\n\"cost Merge [t1,t2] = T_merge t1 t2\""], ["", "fun U where\n\"U Empty [] = 1\" |\n\"U (Insert _) [t] = 3 * log 2 (size1 t + 2) + 2\" |\n\"U Del_min [t] = 3 * log 2 (size1 t + 2) + 2\" |\n\"U Merge [t1,t2] = 3 * log 2 (size1 t1 + size1 t2) + 1\""], ["", "interpretation Amortized\nwhere arity = arity and exec = exec and inv = \"\\<lambda>_. True\"\nand cost = cost and \\<Phi> = \\<Phi> and U = U"], ["proof (prove)\ngoal (1 subgoal):\n 1. Amortized arity exec (\\<lambda>_. True) cost\n     (\\<lambda>x. real_of_int (\\<Phi> x)) U", "proof (standard, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. True; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> True\n 2. \\<And>s. True \\<Longrightarrow> 0 \\<le> real_of_int (\\<Phi> s)\n 3. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. True; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) +\n                         real_of_int (\\<Phi> (exec f ss)) -\n                         (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n                         \\<le> U f ss", "case 1"], ["proof (state)\nthis:\n  \\<forall>s\\<in>set ss_. True\n  length ss_ = arity f_\n\ngoal (3 subgoals):\n 1. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. True; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> True\n 2. \\<And>s. True \\<Longrightarrow> 0 \\<le> real_of_int (\\<Phi> s)\n 3. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. True; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) +\n                         real_of_int (\\<Phi> (exec f ss)) -\n                         (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n                         \\<le> U f ss", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. True", "by simp"], ["proof (state)\nthis:\n  True\n\ngoal (2 subgoals):\n 1. \\<And>s. True \\<Longrightarrow> 0 \\<le> real_of_int (\\<Phi> s)\n 2. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. True; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) +\n                         real_of_int (\\<Phi> (exec f ss)) -\n                         (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n                         \\<le> U f ss", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. True \\<Longrightarrow> 0 \\<le> real_of_int (\\<Phi> s)\n 2. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. True; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) +\n                         real_of_int (\\<Phi> (exec f ss)) -\n                         (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n                         \\<le> U f ss", "case (2 t)"], ["proof (state)\nthis:\n  True\n\ngoal (2 subgoals):\n 1. \\<And>s. True \\<Longrightarrow> 0 \\<le> real_of_int (\\<Phi> s)\n 2. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. True; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) +\n                         real_of_int (\\<Phi> (exec f ss)) -\n                         (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n                         \\<le> U f ss", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> real_of_int (\\<Phi> t)", "using \\<Phi>_nneg[of t]"], ["proof (prove)\nusing this:\n  0 \\<le> \\<Phi> t\n\ngoal (1 subgoal):\n 1. 0 \\<le> real_of_int (\\<Phi> t)", "by linarith"], ["proof (state)\nthis:\n  0 \\<le> real_of_int (\\<Phi> t)\n\ngoal (1 subgoal):\n 1. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. True; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) +\n                         real_of_int (\\<Phi> (exec f ss)) -\n                         (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n                         \\<le> U f ss", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. True; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) +\n                         real_of_int (\\<Phi> (exec f ss)) -\n                         (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n                         \\<le> U f ss", "case (3 ss f)"], ["proof (state)\nthis:\n  \\<forall>s\\<in>set ss. True\n  length ss = arity f\n\ngoal (1 subgoal):\n 1. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. True; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) +\n                         real_of_int (\\<Phi> (exec f ss)) -\n                         (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n                         \\<le> U f ss", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss", "proof (cases f)"], ["proof (state)\ngoal (4 subgoals):\n 1. f = Empty \\<Longrightarrow>\n    real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss\n 2. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n       (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n       \\<le> U f ss\n 3. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss\n 4. f = Merge \\<Longrightarrow>\n    real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss", "case Empty"], ["proof (state)\nthis:\n  f = Empty\n\ngoal (4 subgoals):\n 1. f = Empty \\<Longrightarrow>\n    real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss\n 2. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n       (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n       \\<le> U f ss\n 3. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss\n 4. f = Merge \\<Longrightarrow>\n    real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss", "thus ?thesis"], ["proof (prove)\nusing this:\n  f = Empty\n\ngoal (1 subgoal):\n 1. real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss", "using 3(2)"], ["proof (prove)\nusing this:\n  f = Empty\n  length ss = arity f\n\ngoal (1 subgoal):\n 1. real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss", "by (auto)"], ["proof (state)\nthis:\n  real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n  (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n  \\<le> U f ss\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n       (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n       \\<le> U f ss\n 2. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss\n 3. f = Merge \\<Longrightarrow>\n    real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n       (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n       \\<le> U f ss\n 2. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss\n 3. f = Merge \\<Longrightarrow>\n    real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss", "case [simp]: (Insert a)"], ["proof (state)\nthis:\n  f = Insert a\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n       (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n       \\<le> U f ss\n 2. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss\n 3. f = Merge \\<Longrightarrow>\n    real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss", "obtain t where [simp]: \"ss = [t]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t. ss = [t] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using 3(2)"], ["proof (prove)\nusing this:\n  length ss = arity f\n\ngoal (1 subgoal):\n 1. (\\<And>t. ss = [t] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto)"], ["proof (state)\nthis:\n  ss = [t]\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n       (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n       \\<le> U f ss\n 2. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss\n 3. f = Merge \\<Longrightarrow>\n    real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss", "thus ?thesis"], ["proof (prove)\nusing this:\n  ss = [t]\n\ngoal (1 subgoal):\n 1. real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss", "using a_merge[of \"Node Leaf a Leaf\" \"t\"]"], ["proof (prove)\nusing this:\n  ss = [t]\n  real_of_int\n   (int (T_merge \\<langle>\\<langle>\\<rangle>, a, \\<langle>\\<rangle>\\<rangle>\n          t) +\n    \\<Phi>\n     (merge \\<langle>\\<langle>\\<rangle>, a, \\<langle>\\<rangle>\\<rangle> t) -\n    \\<Phi> \\<langle>\\<langle>\\<rangle>, a, \\<langle>\\<rangle>\\<rangle> -\n    \\<Phi> t)\n  \\<le> 3 *\n        log 2\n         (real\n           (size1\n             \\<langle>\\<langle>\\<rangle>, a, \\<langle>\\<rangle>\\<rangle> +\n            size1 t)) +\n        1\n\ngoal (1 subgoal):\n 1. real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss", "by (simp add: numeral_eq_Suc insert_def rh_def T_merge_nneg)"], ["proof (state)\nthis:\n  real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n  (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n  \\<le> U f ss\n\ngoal (2 subgoals):\n 1. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss\n 2. f = Merge \\<Longrightarrow>\n    real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss\n 2. f = Merge \\<Longrightarrow>\n    real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss", "case [simp]: Del_min"], ["proof (state)\nthis:\n  f = Del_min\n\ngoal (2 subgoals):\n 1. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss\n 2. f = Merge \\<Longrightarrow>\n    real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss", "obtain t where [simp]: \"ss = [t]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t. ss = [t] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using 3(2)"], ["proof (prove)\nusing this:\n  length ss = arity f\n\ngoal (1 subgoal):\n 1. (\\<And>t. ss = [t] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (auto)"], ["proof (state)\nthis:\n  ss = [t]\n\ngoal (2 subgoals):\n 1. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss\n 2. f = Merge \\<Longrightarrow>\n    real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss", "thus ?thesis"], ["proof (prove)\nusing this:\n  ss = [t]\n\ngoal (1 subgoal):\n 1. real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss", "proof (cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ss = [t]; t = \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n                      (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n                      \\<le> U f ss\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>ss = [t]; t = \\<langle>x21, x22, x23\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) +\n                         real_of_int (\\<Phi> (exec f ss)) -\n                         (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n                         \\<le> U f ss", "case Leaf"], ["proof (state)\nthis:\n  t = \\<langle>\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ss = [t]; t = \\<langle>\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n                      (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n                      \\<le> U f ss\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>ss = [t]; t = \\<langle>x21, x22, x23\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) +\n                         real_of_int (\\<Phi> (exec f ss)) -\n                         (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n                         \\<le> U f ss", "with Del_min"], ["proof (chain)\npicking this:\n  f = Del_min\n  t = \\<langle>\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  f = Del_min\n  t = \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss", "by simp"], ["proof (state)\nthis:\n  real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n  (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n  \\<le> U f ss\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>ss = [t]; t = \\<langle>x21, x22, x23\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) +\n                         real_of_int (\\<Phi> (exec f ss)) -\n                         (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n                         \\<le> U f ss", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>ss = [t]; t = \\<langle>x21, x22, x23\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) +\n                         real_of_int (\\<Phi> (exec f ss)) -\n                         (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n                         \\<le> U f ss", "case (Node t1 _ t2)"], ["proof (state)\nthis:\n  t = \\<langle>t1, x22_, t2\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>ss = [t]; t = \\<langle>x21, x22, x23\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) +\n                         real_of_int (\\<Phi> (exec f ss)) -\n                         (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n                         \\<le> U f ss", "have [arith]: \"log 2 (2 + (real (size t1) + real (size t2))) \\<le>\n               log 2 (4 + (real (size t1) + real (size t2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (2 + (real (size t1) + real (size t2)))\n    \\<le> log 2 (4 + (real (size t1) + real (size t2)))", "by simp"], ["proof (state)\nthis:\n  log 2 (2 + (real (size t1) + real (size t2)))\n  \\<le> log 2 (4 + (real (size t1) + real (size t2)))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       \\<lbrakk>ss = [t]; t = \\<langle>x21, x22, x23\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) +\n                         real_of_int (\\<Phi> (exec f ss)) -\n                         (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n                         \\<le> U f ss", "from Del_min Node"], ["proof (chain)\npicking this:\n  f = Del_min\n  t = \\<langle>t1, x22_, t2\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  f = Del_min\n  t = \\<langle>t1, x22_, t2\\<rangle>\n\ngoal (1 subgoal):\n 1. real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss", "using a_merge[of t1 t2]"], ["proof (prove)\nusing this:\n  f = Del_min\n  t = \\<langle>t1, x22_, t2\\<rangle>\n  real_of_int\n   (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n  \\<le> 3 * log 2 (real (size1 t1 + size1 t2)) + 1\n\ngoal (1 subgoal):\n 1. real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss", "by (simp add: size1_size T_merge_nneg)"], ["proof (state)\nthis:\n  real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n  (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n  \\<le> U f ss\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n  (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n  \\<le> U f ss\n\ngoal (1 subgoal):\n 1. f = Merge \\<Longrightarrow>\n    real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f = Merge \\<Longrightarrow>\n    real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss", "case [simp]: Merge"], ["proof (state)\nthis:\n  f = Merge\n\ngoal (1 subgoal):\n 1. f = Merge \\<Longrightarrow>\n    real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss", "obtain t1 t2 where \"ss = [t1,t2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t1 t2. ss = [t1, t2] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 3(2)"], ["proof (prove)\nusing this:\n  length ss = arity f\n\ngoal (1 subgoal):\n 1. (\\<And>t1 t2. ss = [t1, t2] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: numeral_eq_Suc)"], ["proof (state)\nthis:\n  ss = [t1, t2]\n\ngoal (1 subgoal):\n 1. f = Merge \\<Longrightarrow>\n    real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss", "thus ?thesis"], ["proof (prove)\nusing this:\n  ss = [t1, t2]\n\ngoal (1 subgoal):\n 1. real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss", "using a_merge[of t1 t2]"], ["proof (prove)\nusing this:\n  ss = [t1, t2]\n  real_of_int\n   (int (T_merge t1 t2) + \\<Phi> (merge t1 t2) - \\<Phi> t1 - \\<Phi> t2)\n  \\<le> 3 * log 2 (real (size1 t1 + size1 t2)) + 1\n\ngoal (1 subgoal):\n 1. real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n    (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n    \\<le> U f ss", "by (simp add: T_merge_nneg)"], ["proof (state)\nthis:\n  real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n  (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n  \\<le> U f ss\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real (cost f ss) + real_of_int (\\<Phi> (exec f ss)) -\n  (\\<Sum>x\\<leftarrow>ss. real_of_int (\\<Phi> x))\n  \\<le> U f ss\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}