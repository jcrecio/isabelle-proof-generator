{"file_name": "/home/qj213/afp-2021-10-22/thys/Amortized_Complexity/Pairing_Heap_List2_Analysis.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Amortized_Complexity", "problem_names": ["lemma \\<Phi>_hps_ge0: \"\\<Phi>_hps hs \\<ge> 0\"", "lemma size_hps_Cons[simp]: \"size_hps(h # hs) = size_hp h + size_hps hs\"", "lemma link2: \"link (Hp x lx) h = (case h of (Hp y ly) \\<Rightarrow> \n    (if x < y then Hp x (Hp y ly # lx) else Hp y (Hp x lx # ly)))\"", "lemma size_hps_link: \"size_hps(hps (link h1 h2)) = size_hp h1 + size_hp h2 - 1\"", "lemma pass\\<^sub>1_size[simp]: \"size_hps (pass\\<^sub>1 hs) = size_hps hs\"", "lemma pass\\<^sub>2_None[simp]: \"pass\\<^sub>2 hs = None \\<longleftrightarrow> hs = []\"", "lemma \\<Delta>\\<Phi>_insert:\n  \"\\<Phi> (Pairing_Heap_List2.insert x h) - \\<Phi> h \\<le> log 2 (size_heap h + 1)\"", "lemma \\<Delta>\\<Phi>_link: \"\\<Phi>_hp (link h1 h2) - \\<Phi>_hp h1 - \\<Phi>_hp h2 \\<le> 2 * log 2 (size_hp h1 + size_hp h2)\"", "lemma \\<Delta>\\<Phi>_pass1_sum_ub: \"\\<Phi>_hps (pass\\<^sub>1 h) - \\<Phi>_hps h  \\<le> sum_ub h\"", "lemma \\<Delta>\\<Phi>_pass1: assumes \"hs \\<noteq> []\"\n  shows \"\\<Phi>_hps (pass\\<^sub>1 hs) - \\<Phi>_hps hs \\<le> 2 * log 2 (size_hps hs) - length hs + 2\"", "lemma size_hps_pass2: \"pass\\<^sub>2 hs = Some h \\<Longrightarrow> size_hps hs = size_hps(hps h)+1\"", "lemma \\<Delta>\\<Phi>_pass2: \"hs \\<noteq> [] \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs \\<le> log 2 (size_hps hs)\"", "lemma \\<Delta>\\<Phi>_del_min: assumes \"hps h \\<noteq> []\"\n  shows \"\\<Phi> (del_min (Some h)) - \\<Phi> (Some h) \n  \\<le> 3 * log 2 (size_hps(hps h)) - length(hps h) + 2\""], "translations": [["", "lemma \\<Phi>_hps_ge0: \"\\<Phi>_hps hs \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<Phi>_hps hs", "by (induction hs rule: size_hps.induct) auto"], ["", "declare algebra_simps[simp]"], ["", "lemma size_hps_Cons[simp]: \"size_hps(h # hs) = size_hp h + size_hps hs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size_hps (h # hs) = Pairing_Heap_List2_Analysis.size_hp h + size_hps hs", "by(cases h) simp"], ["", "lemma link2: \"link (Hp x lx) h = (case h of (Hp y ly) \\<Rightarrow> \n    (if x < y then Hp x (Hp y ly # lx) else Hp y (Hp x lx # ly)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. link (Hp x lx) h =\n    (case h of\n     Hp y ly \\<Rightarrow>\n       if x < y then Hp x (Hp y ly # lx) else Hp y (Hp x lx # ly))", "by(simp split: hp.split)"], ["", "lemma size_hps_link: \"size_hps(hps (link h1 h2)) = size_hp h1 + size_hp h2 - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size_hps (hps (link h1 h2)) =\n    Pairing_Heap_List2_Analysis.size_hp h1 +\n    Pairing_Heap_List2_Analysis.size_hp h2 -\n    1", "by (induction rule: link.induct) simp_all"], ["", "lemma pass\\<^sub>1_size[simp]: \"size_hps (pass\\<^sub>1 hs) = size_hps hs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size_hps (pass\\<^sub>1 hs) = size_hps hs", "by (induct hs rule: pass\\<^sub>1.induct) (simp_all add: size_hps_link)"], ["", "lemma pass\\<^sub>2_None[simp]: \"pass\\<^sub>2 hs = None \\<longleftrightarrow> hs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pass\\<^sub>2 hs = None) = (hs = [])", "by(cases hs) auto"], ["", "lemma \\<Delta>\\<Phi>_insert:\n  \"\\<Phi> (Pairing_Heap_List2.insert x h) - \\<Phi> h \\<le> log 2 (size_heap h + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> (Pairing_Heap_List2.insert x h) - \\<Phi> h\n    \\<le> log 2 (real (size_heap h + 1))", "by(induct h)(auto simp: link2 split: hp.split)"], ["", "lemma \\<Delta>\\<Phi>_link: \"\\<Phi>_hp (link h1 h2) - \\<Phi>_hp h1 - \\<Phi>_hp h2 \\<le> 2 * log 2 (size_hp h1 + size_hp h2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>_hp (link h1 h2) - \\<Phi>_hp h1 - \\<Phi>_hp h2\n    \\<le> 2 *\n          log 2\n           (real\n             (Pairing_Heap_List2_Analysis.size_hp h1 +\n              Pairing_Heap_List2_Analysis.size_hp h2))", "by (induction h1 h2 rule: link.induct) (simp  add: add_increasing)"], ["", "fun sum_ub :: \"'a hp list \\<Rightarrow> real\" where\n  \"sum_ub [] = 0\"\n| \"sum_ub [Hp _ _] = 0\"\n| \"sum_ub [Hp _ lx, Hp _ ly] = 2*log 2 (2 + size_hps lx + size_hps ly)\" \n| \"sum_ub (Hp _ lx # Hp _ ly # ry) = 2*log 2 (2 + size_hps lx + size_hps ly + size_hps ry) \n    - 2*log 2 (size_hps ry) - 2 + sum_ub ry\""], ["", "lemma \\<Delta>\\<Phi>_pass1_sum_ub: \"\\<Phi>_hps (pass\\<^sub>1 h) - \\<Phi>_hps h  \\<le> sum_ub h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>_hps (pass\\<^sub>1 h) - \\<Phi>_hps h \\<le> sum_ub h", "proof (induction h rule: sum_ub.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_ uv_.\n       \\<Phi>_hps (pass\\<^sub>1 [Hp uu_ uv_]) - \\<Phi>_hps [Hp uu_ uv_]\n       \\<le> sum_ub [Hp uu_ uv_]\n 3. \\<And>uw_ lx ux_ ly.\n       \\<Phi>_hps (pass\\<^sub>1 [Hp uw_ lx, Hp ux_ ly]) -\n       \\<Phi>_hps [Hp uw_ lx, Hp ux_ ly]\n       \\<le> sum_ub [Hp uw_ lx, Hp ux_ ly]\n 4. \\<And>uy_ lx uz_ ly v va.\n       \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n       \\<le> sum_ub (v # va) \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 (Hp uy_ lx # Hp uz_ ly # v # va)) -\n       \\<Phi>_hps (Hp uy_ lx # Hp uz_ ly # v # va)\n       \\<le> sum_ub (Hp uy_ lx # Hp uz_ ly # v # va)", "case (3 lx x ly y)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_ uv_.\n       \\<Phi>_hps (pass\\<^sub>1 [Hp uu_ uv_]) - \\<Phi>_hps [Hp uu_ uv_]\n       \\<le> sum_ub [Hp uu_ uv_]\n 3. \\<And>uw_ lx ux_ ly.\n       \\<Phi>_hps (pass\\<^sub>1 [Hp uw_ lx, Hp ux_ ly]) -\n       \\<Phi>_hps [Hp uw_ lx, Hp ux_ ly]\n       \\<le> sum_ub [Hp uw_ lx, Hp ux_ ly]\n 4. \\<And>uy_ lx uz_ ly v va.\n       \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n       \\<le> sum_ub (v # va) \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 (Hp uy_ lx # Hp uz_ ly # v # va)) -\n       \\<Phi>_hps (Hp uy_ lx # Hp uz_ ly # v # va)\n       \\<le> sum_ub (Hp uy_ lx # Hp uz_ ly # v # va)", "have 0: \"\\<And>x y::real. 0 \\<le> x \\<Longrightarrow> x \\<le> y \\<Longrightarrow> x \\<le> 2*y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>0 \\<le> x; x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x \\<le> 2 * y", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> 2 * ?y\n\ngoal (4 subgoals):\n 1. \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_ uv_.\n       \\<Phi>_hps (pass\\<^sub>1 [Hp uu_ uv_]) - \\<Phi>_hps [Hp uu_ uv_]\n       \\<le> sum_ub [Hp uu_ uv_]\n 3. \\<And>uw_ lx ux_ ly.\n       \\<Phi>_hps (pass\\<^sub>1 [Hp uw_ lx, Hp ux_ ly]) -\n       \\<Phi>_hps [Hp uw_ lx, Hp ux_ ly]\n       \\<le> sum_ub [Hp uw_ lx, Hp ux_ ly]\n 4. \\<And>uy_ lx uz_ ly v va.\n       \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n       \\<le> sum_ub (v # va) \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 (Hp uy_ lx # Hp uz_ ly # v # va)) -\n       \\<Phi>_hps (Hp uy_ lx # Hp uz_ ly # v # va)\n       \\<le> sum_ub (Hp uy_ lx # Hp uz_ ly # v # va)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>_hps (pass\\<^sub>1 [Hp lx x, Hp ly y]) -\n    \\<Phi>_hps [Hp lx x, Hp ly y]\n    \\<le> sum_ub [Hp lx x, Hp ly y]", "by (simp add: add_increasing 0)"], ["proof (state)\nthis:\n  \\<Phi>_hps (pass\\<^sub>1 [Hp lx x, Hp ly y]) -\n  \\<Phi>_hps [Hp lx x, Hp ly y]\n  \\<le> sum_ub [Hp lx x, Hp ly y]\n\ngoal (3 subgoals):\n 1. \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_ uv_.\n       \\<Phi>_hps (pass\\<^sub>1 [Hp uu_ uv_]) - \\<Phi>_hps [Hp uu_ uv_]\n       \\<le> sum_ub [Hp uu_ uv_]\n 3. \\<And>uy_ lx uz_ ly v va.\n       \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n       \\<le> sum_ub (v # va) \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 (Hp uy_ lx # Hp uz_ ly # v # va)) -\n       \\<Phi>_hps (Hp uy_ lx # Hp uz_ ly # v # va)\n       \\<le> sum_ub (Hp uy_ lx # Hp uz_ ly # v # va)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_ uv_.\n       \\<Phi>_hps (pass\\<^sub>1 [Hp uu_ uv_]) - \\<Phi>_hps [Hp uu_ uv_]\n       \\<le> sum_ub [Hp uu_ uv_]\n 3. \\<And>uy_ lx uz_ ly v va.\n       \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n       \\<le> sum_ub (v # va) \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 (Hp uy_ lx # Hp uz_ ly # v # va)) -\n       \\<Phi>_hps (Hp uy_ lx # Hp uz_ ly # v # va)\n       \\<le> sum_ub (Hp uy_ lx # Hp uz_ ly # v # va)", "case (4 x hsx y hsy z hsize_hp)"], ["proof (state)\nthis:\n  \\<Phi>_hps (pass\\<^sub>1 (z # hsize_hp)) - \\<Phi>_hps (z # hsize_hp)\n  \\<le> sum_ub (z # hsize_hp)\n\ngoal (3 subgoals):\n 1. \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_ uv_.\n       \\<Phi>_hps (pass\\<^sub>1 [Hp uu_ uv_]) - \\<Phi>_hps [Hp uu_ uv_]\n       \\<le> sum_ub [Hp uu_ uv_]\n 3. \\<And>uy_ lx uz_ ly v va.\n       \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n       \\<le> sum_ub (v # va) \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 (Hp uy_ lx # Hp uz_ ly # v # va)) -\n       \\<Phi>_hps (Hp uy_ lx # Hp uz_ ly # v # va)\n       \\<le> sum_ub (Hp uy_ lx # Hp uz_ ly # v # va)", "let ?ry = \"z # hsize_hp\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_ uv_.\n       \\<Phi>_hps (pass\\<^sub>1 [Hp uu_ uv_]) - \\<Phi>_hps [Hp uu_ uv_]\n       \\<le> sum_ub [Hp uu_ uv_]\n 3. \\<And>uy_ lx uz_ ly v va.\n       \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n       \\<le> sum_ub (v # va) \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 (Hp uy_ lx # Hp uz_ ly # v # va)) -\n       \\<Phi>_hps (Hp uy_ lx # Hp uz_ ly # v # va)\n       \\<le> sum_ub (Hp uy_ lx # Hp uz_ ly # v # va)", "let ?rx = \"Hp y hsy # ?ry\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_ uv_.\n       \\<Phi>_hps (pass\\<^sub>1 [Hp uu_ uv_]) - \\<Phi>_hps [Hp uu_ uv_]\n       \\<le> sum_ub [Hp uu_ uv_]\n 3. \\<And>uy_ lx uz_ ly v va.\n       \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n       \\<le> sum_ub (v # va) \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 (Hp uy_ lx # Hp uz_ ly # v # va)) -\n       \\<Phi>_hps (Hp uy_ lx # Hp uz_ ly # v # va)\n       \\<le> sum_ub (Hp uy_ lx # Hp uz_ ly # v # va)", "let ?h = \"Hp x hsx # ?rx\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_ uv_.\n       \\<Phi>_hps (pass\\<^sub>1 [Hp uu_ uv_]) - \\<Phi>_hps [Hp uu_ uv_]\n       \\<le> sum_ub [Hp uu_ uv_]\n 3. \\<And>uy_ lx uz_ ly v va.\n       \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n       \\<le> sum_ub (v # va) \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 (Hp uy_ lx # Hp uz_ ly # v # va)) -\n       \\<Phi>_hps (Hp uy_ lx # Hp uz_ ly # v # va)\n       \\<le> sum_ub (Hp uy_ lx # Hp uz_ ly # v # va)", "have \"\\<Phi>_hps(pass\\<^sub>1 ?h) - \\<Phi>_hps ?h  \n    \\<le> log 2 (1 + size_hps hsx + size_hps hsy) - log 2 (1 + size_hps hsy + size_hps ?ry) + sum_ub ?ry\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>_hps (pass\\<^sub>1 (Hp x hsx # Hp y hsy # z # hsize_hp)) -\n    \\<Phi>_hps (Hp x hsx # Hp y hsy # z # hsize_hp)\n    \\<le> log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n          log 2 (real (1 + size_hps hsy + size_hps (z # hsize_hp))) +\n          sum_ub (z # hsize_hp)", "using \"4.IH\""], ["proof (prove)\nusing this:\n  \\<Phi>_hps (pass\\<^sub>1 (z # hsize_hp)) - \\<Phi>_hps (z # hsize_hp)\n  \\<le> sum_ub (z # hsize_hp)\n\ngoal (1 subgoal):\n 1. \\<Phi>_hps (pass\\<^sub>1 (Hp x hsx # Hp y hsy # z # hsize_hp)) -\n    \\<Phi>_hps (Hp x hsx # Hp y hsy # z # hsize_hp)\n    \\<le> log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n          log 2 (real (1 + size_hps hsy + size_hps (z # hsize_hp))) +\n          sum_ub (z # hsize_hp)", "by simp"], ["proof (state)\nthis:\n  \\<Phi>_hps (pass\\<^sub>1 (Hp x hsx # Hp y hsy # z # hsize_hp)) -\n  \\<Phi>_hps (Hp x hsx # Hp y hsy # z # hsize_hp)\n  \\<le> log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n        log 2 (real (1 + size_hps hsy + size_hps (z # hsize_hp))) +\n        sum_ub (z # hsize_hp)\n\ngoal (3 subgoals):\n 1. \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_ uv_.\n       \\<Phi>_hps (pass\\<^sub>1 [Hp uu_ uv_]) - \\<Phi>_hps [Hp uu_ uv_]\n       \\<le> sum_ub [Hp uu_ uv_]\n 3. \\<And>uy_ lx uz_ ly v va.\n       \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n       \\<le> sum_ub (v # va) \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 (Hp uy_ lx # Hp uz_ ly # v # va)) -\n       \\<Phi>_hps (Hp uy_ lx # Hp uz_ ly # v # va)\n       \\<le> sum_ub (Hp uy_ lx # Hp uz_ ly # v # va)", "also"], ["proof (state)\nthis:\n  \\<Phi>_hps (pass\\<^sub>1 (Hp x hsx # Hp y hsy # z # hsize_hp)) -\n  \\<Phi>_hps (Hp x hsx # Hp y hsy # z # hsize_hp)\n  \\<le> log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n        log 2 (real (1 + size_hps hsy + size_hps (z # hsize_hp))) +\n        sum_ub (z # hsize_hp)\n\ngoal (3 subgoals):\n 1. \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_ uv_.\n       \\<Phi>_hps (pass\\<^sub>1 [Hp uu_ uv_]) - \\<Phi>_hps [Hp uu_ uv_]\n       \\<le> sum_ub [Hp uu_ uv_]\n 3. \\<And>uy_ lx uz_ ly v va.\n       \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n       \\<le> sum_ub (v # va) \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 (Hp uy_ lx # Hp uz_ ly # v # va)) -\n       \\<Phi>_hps (Hp uy_ lx # Hp uz_ ly # v # va)\n       \\<le> sum_ub (Hp uy_ lx # Hp uz_ ly # v # va)", "have \"log 2 (1 + size_hps hsx + size_hps hsy) - log 2 (1 + size_hps hsy + size_hps ?ry) \n    \\<le> 2*log 2 (size_hps ?h) - 2*log 2 (size_hps ?ry) - 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n    log 2 (real (1 + size_hps hsy + size_hps (z # hsize_hp)))\n    \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) -\n          2 * log 2 (real (size_hps (z # hsize_hp))) -\n          2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n    log 2 (real (1 + size_hps hsy + size_hps (z # hsize_hp)))\n    \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) -\n          2 * log 2 (real (size_hps (z # hsize_hp))) -\n          2", "have \"log 2 (1 + size_hps hsx + size_hps hsy) + log 2 (size_hps ?ry) - 2*log 2 (size_hps ?h) \n      = log 2 ((1 + size_hps hsx + size_hps hsy)/(size_hps ?h) ) + log 2 (size_hps ?ry / size_hps ?h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real (1 + size_hps hsx + size_hps hsy)) +\n    log 2 (real (size_hps (z # hsize_hp))) -\n    2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) =\n    log 2\n     (real (1 + size_hps hsx + size_hps hsy) /\n      real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) +\n    log 2\n     (real (size_hps (z # hsize_hp)) /\n      real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)))", "by (simp add: log_divide)"], ["proof (state)\nthis:\n  log 2 (real (1 + size_hps hsx + size_hps hsy)) +\n  log 2 (real (size_hps (z # hsize_hp))) -\n  2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) =\n  log 2\n   (real (1 + size_hps hsx + size_hps hsy) /\n    real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) +\n  log 2\n   (real (size_hps (z # hsize_hp)) /\n    real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)))\n\ngoal (1 subgoal):\n 1. log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n    log 2 (real (1 + size_hps hsy + size_hps (z # hsize_hp)))\n    \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) -\n          2 * log 2 (real (size_hps (z # hsize_hp))) -\n          2", "also"], ["proof (state)\nthis:\n  log 2 (real (1 + size_hps hsx + size_hps hsy)) +\n  log 2 (real (size_hps (z # hsize_hp))) -\n  2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) =\n  log 2\n   (real (1 + size_hps hsx + size_hps hsy) /\n    real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) +\n  log 2\n   (real (size_hps (z # hsize_hp)) /\n    real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)))\n\ngoal (1 subgoal):\n 1. log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n    log 2 (real (1 + size_hps hsy + size_hps (z # hsize_hp)))\n    \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) -\n          2 * log 2 (real (size_hps (z # hsize_hp))) -\n          2", "have \"\\<dots> \\<le> -2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2\n     (real (1 + size_hps hsx + size_hps hsy) /\n      real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) +\n    log 2\n     (real (size_hps (z # hsize_hp)) /\n      real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)))\n    \\<le> - 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. log 2\n     (real (1 + size_hps hsx + size_hps hsy) /\n      real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) +\n    log 2\n     (real (size_hps (z # hsize_hp)) /\n      real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)))\n    \\<le> - 2", "have \"2 + \\<dots>\n        \\<le> 2*log 2 ((1 + size_hps hsx + size_hps hsy) / size_hps ?h +  size_hps ?ry / size_hps ?h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 +\n    (log 2\n      (real (1 + size_hps hsx + size_hps hsy) /\n       real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) +\n     log 2\n      (real (size_hps (z # hsize_hp)) /\n       real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))))\n    \\<le> 2 *\n          log 2\n           (real (1 + size_hps hsx + size_hps hsy) /\n            real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)) +\n            real (size_hps (z # hsize_hp)) /\n            real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)))", "using ld_sum_inequality [of \"(1 + size_hps hsx + size_hps hsy) / size_hps ?h\" \"(size_hps ?ry / size_hps ?h)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < real (1 + size_hps hsx + size_hps hsy) /\n               real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp));\n   0 < real (size_hps (z # hsize_hp)) /\n       real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))\\<rbrakk>\n  \\<Longrightarrow> log 2\n                     (real (1 + size_hps hsx + size_hps hsy) /\n                      real\n                       (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) +\n                    log 2\n                     (real (size_hps (z # hsize_hp)) /\n                      real\n                       (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) +\n                    2\n                    \\<le> 2 *\n                          log 2\n                           (real (1 + size_hps hsx + size_hps hsy) /\n                            real\n                             (size_hps\n                               (Hp x hsx # Hp y hsy # z # hsize_hp)) +\n                            real (size_hps (z # hsize_hp)) /\n                            real\n                             (size_hps\n                               (Hp x hsx # Hp y hsy # z # hsize_hp)))\n\ngoal (1 subgoal):\n 1. 2 +\n    (log 2\n      (real (1 + size_hps hsx + size_hps hsy) /\n       real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) +\n     log 2\n      (real (size_hps (z # hsize_hp)) /\n       real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))))\n    \\<le> 2 *\n          log 2\n           (real (1 + size_hps hsx + size_hps hsy) /\n            real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)) +\n            real (size_hps (z # hsize_hp)) /\n            real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)))", "by simp"], ["proof (state)\nthis:\n  2 +\n  (log 2\n    (real (1 + size_hps hsx + size_hps hsy) /\n     real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) +\n   log 2\n    (real (size_hps (z # hsize_hp)) /\n     real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))))\n  \\<le> 2 *\n        log 2\n         (real (1 + size_hps hsx + size_hps hsy) /\n          real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)) +\n          real (size_hps (z # hsize_hp)) /\n          real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)))\n\ngoal (1 subgoal):\n 1. log 2\n     (real (1 + size_hps hsx + size_hps hsy) /\n      real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) +\n    log 2\n     (real (size_hps (z # hsize_hp)) /\n      real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)))\n    \\<le> - 2", "also"], ["proof (state)\nthis:\n  2 +\n  (log 2\n    (real (1 + size_hps hsx + size_hps hsy) /\n     real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) +\n   log 2\n    (real (size_hps (z # hsize_hp)) /\n     real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))))\n  \\<le> 2 *\n        log 2\n         (real (1 + size_hps hsx + size_hps hsy) /\n          real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)) +\n          real (size_hps (z # hsize_hp)) /\n          real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)))\n\ngoal (1 subgoal):\n 1. log 2\n     (real (1 + size_hps hsx + size_hps hsy) /\n      real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) +\n    log 2\n     (real (size_hps (z # hsize_hp)) /\n      real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)))\n    \\<le> - 2", "have \"\\<dots> \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 *\n    log 2\n     (real (1 + size_hps hsx + size_hps hsy) /\n      real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)) +\n      real (size_hps (z # hsize_hp)) /\n      real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)))\n    \\<le> 0", "by (simp add: field_simps log_divide add_pos_nonneg)"], ["proof (state)\nthis:\n  2 *\n  log 2\n   (real (1 + size_hps hsx + size_hps hsy) /\n    real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)) +\n    real (size_hps (z # hsize_hp)) /\n    real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)))\n  \\<le> 0\n\ngoal (1 subgoal):\n 1. log 2\n     (real (1 + size_hps hsx + size_hps hsy) /\n      real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) +\n    log 2\n     (real (size_hps (z # hsize_hp)) /\n      real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)))\n    \\<le> - 2", "finally"], ["proof (chain)\npicking this:\n  2 +\n  (log 2\n    (real (1 + size_hps hsx + size_hps hsy) /\n     real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) +\n   log 2\n    (real (size_hps (z # hsize_hp)) /\n     real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))))\n  \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  2 +\n  (log 2\n    (real (1 + size_hps hsx + size_hps hsy) /\n     real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) +\n   log 2\n    (real (size_hps (z # hsize_hp)) /\n     real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))))\n  \\<le> 0\n\ngoal (1 subgoal):\n 1. log 2\n     (real (1 + size_hps hsx + size_hps hsy) /\n      real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) +\n    log 2\n     (real (size_hps (z # hsize_hp)) /\n      real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)))\n    \\<le> - 2", "by linarith"], ["proof (state)\nthis:\n  log 2\n   (real (1 + size_hps hsx + size_hps hsy) /\n    real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) +\n  log 2\n   (real (size_hps (z # hsize_hp)) /\n    real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)))\n  \\<le> - 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  log 2\n   (real (1 + size_hps hsx + size_hps hsy) /\n    real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) +\n  log 2\n   (real (size_hps (z # hsize_hp)) /\n    real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)))\n  \\<le> - 2\n\ngoal (1 subgoal):\n 1. log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n    log 2 (real (1 + size_hps hsy + size_hps (z # hsize_hp)))\n    \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) -\n          2 * log 2 (real (size_hps (z # hsize_hp))) -\n          2", "finally"], ["proof (chain)\npicking this:\n  log 2 (real (1 + size_hps hsx + size_hps hsy)) +\n  log 2 (real (size_hps (z # hsize_hp))) -\n  2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)))\n  \\<le> - 2", "have \"log 2 (1 + size_hps hsx + size_hps hsy) + log 2 (size_hps ?ry) + 2\n      \\<le>  2*log 2 (size_hps ?h)\""], ["proof (prove)\nusing this:\n  log 2 (real (1 + size_hps hsx + size_hps hsy)) +\n  log 2 (real (size_hps (z # hsize_hp))) -\n  2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)))\n  \\<le> - 2\n\ngoal (1 subgoal):\n 1. log 2 (real (1 + size_hps hsx + size_hps hsy)) +\n    log 2 (real (size_hps (z # hsize_hp))) +\n    2\n    \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)))", "by simp"], ["proof (state)\nthis:\n  log 2 (real (1 + size_hps hsx + size_hps hsy)) +\n  log 2 (real (size_hps (z # hsize_hp))) +\n  2\n  \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)))\n\ngoal (1 subgoal):\n 1. log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n    log 2 (real (1 + size_hps hsy + size_hps (z # hsize_hp)))\n    \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) -\n          2 * log 2 (real (size_hps (z # hsize_hp))) -\n          2", "moreover"], ["proof (state)\nthis:\n  log 2 (real (1 + size_hps hsx + size_hps hsy)) +\n  log 2 (real (size_hps (z # hsize_hp))) +\n  2\n  \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)))\n\ngoal (1 subgoal):\n 1. log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n    log 2 (real (1 + size_hps hsy + size_hps (z # hsize_hp)))\n    \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) -\n          2 * log 2 (real (size_hps (z # hsize_hp))) -\n          2", "have \"log 2 (size_hps ?ry) \\<le> log 2 (size_hps ?rx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real (size_hps (z # hsize_hp)))\n    \\<le> log 2 (real (size_hps (Hp y hsy # z # hsize_hp)))", "by simp"], ["proof (state)\nthis:\n  log 2 (real (size_hps (z # hsize_hp)))\n  \\<le> log 2 (real (size_hps (Hp y hsy # z # hsize_hp)))\n\ngoal (1 subgoal):\n 1. log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n    log 2 (real (1 + size_hps hsy + size_hps (z # hsize_hp)))\n    \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) -\n          2 * log 2 (real (size_hps (z # hsize_hp))) -\n          2", "ultimately"], ["proof (chain)\npicking this:\n  log 2 (real (1 + size_hps hsx + size_hps hsy)) +\n  log 2 (real (size_hps (z # hsize_hp))) +\n  2\n  \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)))\n  log 2 (real (size_hps (z # hsize_hp)))\n  \\<le> log 2 (real (size_hps (Hp y hsy # z # hsize_hp)))", "have \"log 2 (1 + size_hps hsx + size_hps hsy) - \\<dots> \n      \\<le>  2*log 2 (size_hps ?h) - 2*log 2 (size_hps ?ry) - 2\""], ["proof (prove)\nusing this:\n  log 2 (real (1 + size_hps hsx + size_hps hsy)) +\n  log 2 (real (size_hps (z # hsize_hp))) +\n  2\n  \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp)))\n  log 2 (real (size_hps (z # hsize_hp)))\n  \\<le> log 2 (real (size_hps (Hp y hsy # z # hsize_hp)))\n\ngoal (1 subgoal):\n 1. log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n    log 2 (real (size_hps (Hp y hsy # z # hsize_hp)))\n    \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) -\n          2 * log 2 (real (size_hps (z # hsize_hp))) -\n          2", "by linarith"], ["proof (state)\nthis:\n  log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n  log 2 (real (size_hps (Hp y hsy # z # hsize_hp)))\n  \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) -\n        2 * log 2 (real (size_hps (z # hsize_hp))) -\n        2\n\ngoal (1 subgoal):\n 1. log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n    log 2 (real (1 + size_hps hsy + size_hps (z # hsize_hp)))\n    \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) -\n          2 * log 2 (real (size_hps (z # hsize_hp))) -\n          2", "thus ?thesis"], ["proof (prove)\nusing this:\n  log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n  log 2 (real (size_hps (Hp y hsy # z # hsize_hp)))\n  \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) -\n        2 * log 2 (real (size_hps (z # hsize_hp))) -\n        2\n\ngoal (1 subgoal):\n 1. log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n    log 2 (real (1 + size_hps hsy + size_hps (z # hsize_hp)))\n    \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) -\n          2 * log 2 (real (size_hps (z # hsize_hp))) -\n          2", "by simp"], ["proof (state)\nthis:\n  log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n  log 2 (real (1 + size_hps hsy + size_hps (z # hsize_hp)))\n  \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) -\n        2 * log 2 (real (size_hps (z # hsize_hp))) -\n        2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n  log 2 (real (1 + size_hps hsy + size_hps (z # hsize_hp)))\n  \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) -\n        2 * log 2 (real (size_hps (z # hsize_hp))) -\n        2\n\ngoal (3 subgoals):\n 1. \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_ uv_.\n       \\<Phi>_hps (pass\\<^sub>1 [Hp uu_ uv_]) - \\<Phi>_hps [Hp uu_ uv_]\n       \\<le> sum_ub [Hp uu_ uv_]\n 3. \\<And>uy_ lx uz_ ly v va.\n       \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n       \\<le> sum_ub (v # va) \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 (Hp uy_ lx # Hp uz_ ly # v # va)) -\n       \\<Phi>_hps (Hp uy_ lx # Hp uz_ ly # v # va)\n       \\<le> sum_ub (Hp uy_ lx # Hp uz_ ly # v # va)", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + sum_ub (z # hsize_hp)\n      \\<le> y + sum_ub (z # hsize_hp)) \\<Longrightarrow>\n  \\<Phi>_hps (pass\\<^sub>1 (Hp x hsx # Hp y hsy # z # hsize_hp)) -\n  \\<Phi>_hps (Hp x hsx # Hp y hsy # z # hsize_hp)\n  \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) -\n        2 * log 2 (real (size_hps (z # hsize_hp))) -\n        2 +\n        sum_ub (z # hsize_hp)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + sum_ub (z # hsize_hp)\n      \\<le> y + sum_ub (z # hsize_hp)) \\<Longrightarrow>\n  \\<Phi>_hps (pass\\<^sub>1 (Hp x hsx # Hp y hsy # z # hsize_hp)) -\n  \\<Phi>_hps (Hp x hsx # Hp y hsy # z # hsize_hp)\n  \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # z # hsize_hp))) -\n        2 * log 2 (real (size_hps (z # hsize_hp))) -\n        2 +\n        sum_ub (z # hsize_hp)\n\ngoal (1 subgoal):\n 1. \\<Phi>_hps (pass\\<^sub>1 (Hp x hsx # Hp y hsy # z # hsize_hp)) -\n    \\<Phi>_hps (Hp x hsx # Hp y hsy # z # hsize_hp)\n    \\<le> sum_ub (Hp x hsx # Hp y hsy # z # hsize_hp)", "by (simp)"], ["proof (state)\nthis:\n  \\<Phi>_hps (pass\\<^sub>1 (Hp x hsx # Hp y hsy # z # hsize_hp)) -\n  \\<Phi>_hps (Hp x hsx # Hp y hsy # z # hsize_hp)\n  \\<le> sum_ub (Hp x hsx # Hp y hsy # z # hsize_hp)\n\ngoal (2 subgoals):\n 1. \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_ uv_.\n       \\<Phi>_hps (pass\\<^sub>1 [Hp uu_ uv_]) - \\<Phi>_hps [Hp uu_ uv_]\n       \\<le> sum_ub [Hp uu_ uv_]", "qed simp_all"], ["", "lemma \\<Delta>\\<Phi>_pass1: assumes \"hs \\<noteq> []\"\n  shows \"\\<Phi>_hps (pass\\<^sub>1 hs) - \\<Phi>_hps hs \\<le> 2 * log 2 (size_hps hs) - length hs + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>_hps (pass\\<^sub>1 hs) - \\<Phi>_hps hs\n    \\<le> 2 * log 2 (real (size_hps hs)) - real (length hs) + 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi>_hps (pass\\<^sub>1 hs) - \\<Phi>_hps hs\n    \\<le> 2 * log 2 (real (size_hps hs)) - real (length hs) + 2", "have \"sum_ub hs \\<le> 2 * log 2 (size_hps hs) - length hs + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_ub hs \\<le> 2 * log 2 (real (size_hps hs)) - real (length hs) + 2", "using assms"], ["proof (prove)\nusing this:\n  hs \\<noteq> []\n\ngoal (1 subgoal):\n 1. sum_ub hs \\<le> 2 * log 2 (real (size_hps hs)) - real (length hs) + 2", "by (induct hs rule: sum_ub.induct) (simp_all)"], ["proof (state)\nthis:\n  sum_ub hs \\<le> 2 * log 2 (real (size_hps hs)) - real (length hs) + 2\n\ngoal (1 subgoal):\n 1. \\<Phi>_hps (pass\\<^sub>1 hs) - \\<Phi>_hps hs\n    \\<le> 2 * log 2 (real (size_hps hs)) - real (length hs) + 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  sum_ub hs \\<le> 2 * log 2 (real (size_hps hs)) - real (length hs) + 2\n\ngoal (1 subgoal):\n 1. \\<Phi>_hps (pass\\<^sub>1 hs) - \\<Phi>_hps hs\n    \\<le> 2 * log 2 (real (size_hps hs)) - real (length hs) + 2", "using \\<Delta>\\<Phi>_pass1_sum_ub[of hs]"], ["proof (prove)\nusing this:\n  sum_ub hs \\<le> 2 * log 2 (real (size_hps hs)) - real (length hs) + 2\n  \\<Phi>_hps (pass\\<^sub>1 hs) - \\<Phi>_hps hs \\<le> sum_ub hs\n\ngoal (1 subgoal):\n 1. \\<Phi>_hps (pass\\<^sub>1 hs) - \\<Phi>_hps hs\n    \\<le> 2 * log 2 (real (size_hps hs)) - real (length hs) + 2", "by linarith"], ["proof (state)\nthis:\n  \\<Phi>_hps (pass\\<^sub>1 hs) - \\<Phi>_hps hs\n  \\<le> 2 * log 2 (real (size_hps hs)) - real (length hs) + 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma size_hps_pass2: \"pass\\<^sub>2 hs = Some h \\<Longrightarrow> size_hps hs = size_hps(hps h)+1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pass\\<^sub>2 hs = Some h \\<Longrightarrow>\n    size_hps hs = size_hps (hps h) + 1", "apply(induction hs arbitrary: h rule: \\<Phi>_hps.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h.\n       pass\\<^sub>2 [] = Some h \\<Longrightarrow>\n       size_hps [] = size_hps (hps h) + 1\n 2. \\<And>x hsl hsr h.\n       \\<lbrakk>\\<And>h.\n                   pass\\<^sub>2 hsl = Some h \\<Longrightarrow>\n                   size_hps hsl = size_hps (hps h) + 1;\n        \\<And>h.\n           pass\\<^sub>2 hsr = Some h \\<Longrightarrow>\n           size_hps hsr = size_hps (hps h) + 1;\n        pass\\<^sub>2 (Hp x hsl # hsr) = Some h\\<rbrakk>\n       \\<Longrightarrow> size_hps (Hp x hsl # hsr) = size_hps (hps h) + 1", "apply (auto simp: link2 split: option.split hp.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<Delta>\\<Phi>_pass2: \"hs \\<noteq> [] \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs \\<le> log 2 (size_hps hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hs \\<noteq> [] \\<Longrightarrow>\n    \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs\n    \\<le> log 2 (real (size_hps hs))", "proof (induction hs)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    \\<Phi> (pass\\<^sub>2 []) - \\<Phi>_hps []\n    \\<le> log 2 (real (size_hps []))\n 2. \\<And>a hs.\n       \\<lbrakk>hs \\<noteq> [] \\<Longrightarrow>\n                \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs\n                \\<le> log 2 (real (size_hps hs));\n        a # hs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 (a # hs)) -\n                         \\<Phi>_hps (a # hs)\n                         \\<le> log 2 (real (size_hps (a # hs)))", "case (Cons h hs)"], ["proof (state)\nthis:\n  hs \\<noteq> [] \\<Longrightarrow>\n  \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs \\<le> log 2 (real (size_hps hs))\n  h # hs \\<noteq> []\n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    \\<Phi> (pass\\<^sub>2 []) - \\<Phi>_hps []\n    \\<le> log 2 (real (size_hps []))\n 2. \\<And>a hs.\n       \\<lbrakk>hs \\<noteq> [] \\<Longrightarrow>\n                \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs\n                \\<le> log 2 (real (size_hps hs));\n        a # hs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 (a # hs)) -\n                         \\<Phi>_hps (a # hs)\n                         \\<le> log 2 (real (size_hps (a # hs)))", "thus ?case"], ["proof (prove)\nusing this:\n  hs \\<noteq> [] \\<Longrightarrow>\n  \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs \\<le> log 2 (real (size_hps hs))\n  h # hs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n    \\<le> log 2 (real (size_hps (h # hs)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>hs \\<noteq> [] \\<Longrightarrow>\n             \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs\n             \\<le> log 2 (real (size_hps hs));\n     h # hs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n                      \\<le> log 2 (real (size_hps (h # hs)))", "obtain x hs2 where [simp]: \"h = Hp x hs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x hs2. h = Hp x hs2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis hp.exhaust)"], ["proof (state)\nthis:\n  h = Hp x hs2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>hs \\<noteq> [] \\<Longrightarrow>\n             \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs\n             \\<le> log 2 (real (size_hps hs));\n     h # hs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n                      \\<le> log 2 (real (size_hps (h # hs)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n    \\<le> log 2 (real (size_hps (h # hs)))", "proof (cases \"pass\\<^sub>2 hs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. pass\\<^sub>2 hs = None \\<Longrightarrow>\n    \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n    \\<le> log 2 (real (size_hps (h # hs)))\n 2. \\<And>a.\n       pass\\<^sub>2 hs = Some a \\<Longrightarrow>\n       \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n       \\<le> log 2 (real (size_hps (h # hs)))", "case [simp]: (Some h2)"], ["proof (state)\nthis:\n  pass\\<^sub>2 hs = Some h2\n\ngoal (2 subgoals):\n 1. pass\\<^sub>2 hs = None \\<Longrightarrow>\n    \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n    \\<le> log 2 (real (size_hps (h # hs)))\n 2. \\<And>a.\n       pass\\<^sub>2 hs = Some a \\<Longrightarrow>\n       \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n       \\<le> log 2 (real (size_hps (h # hs)))", "obtain y hs3 where [simp]: \"h2 = Hp y hs3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y hs3. h2 = Hp y hs3 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis hp.exhaust)"], ["proof (state)\nthis:\n  h2 = Hp y hs3\n\ngoal (2 subgoals):\n 1. pass\\<^sub>2 hs = None \\<Longrightarrow>\n    \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n    \\<le> log 2 (real (size_hps (h # hs)))\n 2. \\<And>a.\n       pass\\<^sub>2 hs = Some a \\<Longrightarrow>\n       \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n       \\<le> log 2 (real (size_hps (h # hs)))", "from size_hps_pass2[OF Some] Cons"], ["proof (chain)\npicking this:\n  size_hps hs = size_hps (hps h2) + 1\n  hs \\<noteq> [] \\<Longrightarrow>\n  \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs \\<le> log 2 (real (size_hps hs))\n  h # hs \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  size_hps hs = size_hps (hps h2) + 1\n  hs \\<noteq> [] \\<Longrightarrow>\n  \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs \\<le> log 2 (real (size_hps hs))\n  h # hs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n    \\<le> log 2 (real (size_hps (h # hs)))", "by(cases \"hs=[]\")(auto simp: add_mono)"], ["proof (state)\nthis:\n  \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n  \\<le> log 2 (real (size_hps (h # hs)))\n\ngoal (1 subgoal):\n 1. pass\\<^sub>2 hs = None \\<Longrightarrow>\n    \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n    \\<le> log 2 (real (size_hps (h # hs)))", "qed simp"], ["proof (state)\nthis:\n  \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n  \\<le> log 2 (real (size_hps (h # hs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n  \\<le> log 2 (real (size_hps (h # hs)))\n\ngoal (1 subgoal):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    \\<Phi> (pass\\<^sub>2 []) - \\<Phi>_hps []\n    \\<le> log 2 (real (size_hps []))", "qed simp"], ["", "lemma \\<Delta>\\<Phi>_del_min: assumes \"hps h \\<noteq> []\"\n  shows \"\\<Phi> (del_min (Some h)) - \\<Phi> (Some h) \n  \\<le> 3 * log 2 (size_hps(hps h)) - length(hps h) + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> (del_min (Some h)) - \\<Phi> (Some h)\n    \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> (del_min (Some h)) - \\<Phi> (Some h)\n    \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "let ?\\<Delta>\\<Phi>\\<^sub>1 = \"\\<Phi>_hps(hps h) - \\<Phi>_hp h\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> (del_min (Some h)) - \\<Phi> (Some h)\n    \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "let ?\\<Delta>\\<Phi>\\<^sub>2 = \"\\<Phi>(pass\\<^sub>2(pass\\<^sub>1 (hps h))) - \\<Phi>_hps (hps h)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> (del_min (Some h)) - \\<Phi> (Some h)\n    \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "let ?\\<Delta>\\<Phi> = \"\\<Phi> (del_min (Some h)) - \\<Phi> (Some h)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> (del_min (Some h)) - \\<Phi> (Some h)\n    \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "have \"\\<Phi>(pass\\<^sub>2(pass\\<^sub>1(hps h))) - \\<Phi>_hps (pass\\<^sub>1(hps h)) \\<le> log 2 (size_hps(hps h))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> (pass\\<^sub>2 (pass\\<^sub>1 (hps h))) -\n    \\<Phi>_hps (pass\\<^sub>1 (hps h))\n    \\<le> log 2 (real (size_hps (hps h)))", "using \\<Delta>\\<Phi>_pass2[of \"pass\\<^sub>1(hps h)\"]"], ["proof (prove)\nusing this:\n  pass\\<^sub>1 (hps h) \\<noteq> [] \\<Longrightarrow>\n  \\<Phi> (pass\\<^sub>2 (pass\\<^sub>1 (hps h))) -\n  \\<Phi>_hps (pass\\<^sub>1 (hps h))\n  \\<le> log 2 (real (size_hps (pass\\<^sub>1 (hps h))))\n\ngoal (1 subgoal):\n 1. \\<Phi> (pass\\<^sub>2 (pass\\<^sub>1 (hps h))) -\n    \\<Phi>_hps (pass\\<^sub>1 (hps h))\n    \\<le> log 2 (real (size_hps (hps h)))", "using size_hps.elims assms"], ["proof (prove)\nusing this:\n  pass\\<^sub>1 (hps h) \\<noteq> [] \\<Longrightarrow>\n  \\<Phi> (pass\\<^sub>2 (pass\\<^sub>1 (hps h))) -\n  \\<Phi>_hps (pass\\<^sub>1 (hps h))\n  \\<le> log 2 (real (size_hps (pass\\<^sub>1 (hps h))))\n  \\<lbrakk>size_hps ?x = ?y;\n   \\<And>x hsl hsr.\n      \\<lbrakk>?x = Hp x hsl # hsr;\n       ?y = size_hps hsl + size_hps hsr + 1\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<lbrakk>?x = []; ?y = 0\\<rbrakk> \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  hps h \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<Phi> (pass\\<^sub>2 (pass\\<^sub>1 (hps h))) -\n    \\<Phi>_hps (pass\\<^sub>1 (hps h))\n    \\<le> log 2 (real (size_hps (hps h)))", "by force"], ["proof (state)\nthis:\n  \\<Phi> (pass\\<^sub>2 (pass\\<^sub>1 (hps h))) -\n  \\<Phi>_hps (pass\\<^sub>1 (hps h))\n  \\<le> log 2 (real (size_hps (hps h)))\n\ngoal (1 subgoal):\n 1. \\<Phi> (del_min (Some h)) - \\<Phi> (Some h)\n    \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "moreover"], ["proof (state)\nthis:\n  \\<Phi> (pass\\<^sub>2 (pass\\<^sub>1 (hps h))) -\n  \\<Phi>_hps (pass\\<^sub>1 (hps h))\n  \\<le> log 2 (real (size_hps (hps h)))\n\ngoal (1 subgoal):\n 1. \\<Phi> (del_min (Some h)) - \\<Phi> (Some h)\n    \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "have \"\\<Phi>_hps (pass\\<^sub>1 (hps h)) - \\<Phi>_hps (hps h) \\<le>  2*\\<dots> - length (hps h) + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>_hps (pass\\<^sub>1 (hps h)) - \\<Phi>_hps (hps h)\n    \\<le> 2 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "using \\<Delta>\\<Phi>_pass1[OF assms]"], ["proof (prove)\nusing this:\n  \\<Phi>_hps (pass\\<^sub>1 (hps h)) - \\<Phi>_hps (hps h)\n  \\<le> 2 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2\n\ngoal (1 subgoal):\n 1. \\<Phi>_hps (pass\\<^sub>1 (hps h)) - \\<Phi>_hps (hps h)\n    \\<le> 2 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "by blast"], ["proof (state)\nthis:\n  \\<Phi>_hps (pass\\<^sub>1 (hps h)) - \\<Phi>_hps (hps h)\n  \\<le> 2 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2\n\ngoal (1 subgoal):\n 1. \\<Phi> (del_min (Some h)) - \\<Phi> (Some h)\n    \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "moreover"], ["proof (state)\nthis:\n  \\<Phi>_hps (pass\\<^sub>1 (hps h)) - \\<Phi>_hps (hps h)\n  \\<le> 2 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2\n\ngoal (1 subgoal):\n 1. \\<Phi> (del_min (Some h)) - \\<Phi> (Some h)\n    \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "have \"?\\<Delta>\\<Phi>\\<^sub>1 \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>_hps (hps h) - \\<Phi>_hp h \\<le> 0", "by (cases h) simp"], ["proof (state)\nthis:\n  \\<Phi>_hps (hps h) - \\<Phi>_hp h \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<Phi> (del_min (Some h)) - \\<Phi> (Some h)\n    \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "moreover"], ["proof (state)\nthis:\n  \\<Phi>_hps (hps h) - \\<Phi>_hp h \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<Phi> (del_min (Some h)) - \\<Phi> (Some h)\n    \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "have \"?\\<Delta>\\<Phi> = ?\\<Delta>\\<Phi>\\<^sub>1 + ?\\<Delta>\\<Phi>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> (del_min (Some h)) - \\<Phi> (Some h) =\n    \\<Phi>_hps (hps h) - \\<Phi>_hp h +\n    (\\<Phi> (pass\\<^sub>2 (pass\\<^sub>1 (hps h))) - \\<Phi>_hps (hps h))", "by (cases h) simp"], ["proof (state)\nthis:\n  \\<Phi> (del_min (Some h)) - \\<Phi> (Some h) =\n  \\<Phi>_hps (hps h) - \\<Phi>_hp h +\n  (\\<Phi> (pass\\<^sub>2 (pass\\<^sub>1 (hps h))) - \\<Phi>_hps (hps h))\n\ngoal (1 subgoal):\n 1. \\<Phi> (del_min (Some h)) - \\<Phi> (Some h)\n    \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "ultimately"], ["proof (chain)\npicking this:\n  \\<Phi> (pass\\<^sub>2 (pass\\<^sub>1 (hps h))) -\n  \\<Phi>_hps (pass\\<^sub>1 (hps h))\n  \\<le> log 2 (real (size_hps (hps h)))\n  \\<Phi>_hps (pass\\<^sub>1 (hps h)) - \\<Phi>_hps (hps h)\n  \\<le> 2 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2\n  \\<Phi>_hps (hps h) - \\<Phi>_hp h \\<le> 0\n  \\<Phi> (del_min (Some h)) - \\<Phi> (Some h) =\n  \\<Phi>_hps (hps h) - \\<Phi>_hp h +\n  (\\<Phi> (pass\\<^sub>2 (pass\\<^sub>1 (hps h))) - \\<Phi>_hps (hps h))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Phi> (pass\\<^sub>2 (pass\\<^sub>1 (hps h))) -\n  \\<Phi>_hps (pass\\<^sub>1 (hps h))\n  \\<le> log 2 (real (size_hps (hps h)))\n  \\<Phi>_hps (pass\\<^sub>1 (hps h)) - \\<Phi>_hps (hps h)\n  \\<le> 2 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2\n  \\<Phi>_hps (hps h) - \\<Phi>_hp h \\<le> 0\n  \\<Phi> (del_min (Some h)) - \\<Phi> (Some h) =\n  \\<Phi>_hps (hps h) - \\<Phi>_hp h +\n  (\\<Phi> (pass\\<^sub>2 (pass\\<^sub>1 (hps h))) - \\<Phi>_hps (hps h))\n\ngoal (1 subgoal):\n 1. \\<Phi> (del_min (Some h)) - \\<Phi> (Some h)\n    \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "by linarith"], ["proof (state)\nthis:\n  \\<Phi> (del_min (Some h)) - \\<Phi> (Some h)\n  \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2\n\ngoal:\nNo subgoals!", "qed"], ["", "fun exec :: \"'a :: linorder op \\<Rightarrow> 'a heap list \\<Rightarrow> 'a heap\" where\n\"exec Empty [] = None\" | \n\"exec Del_min [h] = del_min h\" |\n\"exec (Insert x) [h] = Pairing_Heap_List2.insert x h\" |\n\"exec Merge [h1,h2] = merge h1 h2\""], ["", "fun T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1 :: \"'a hp list \\<Rightarrow> nat\" where\n  \"T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1 [] = 1\"\n| \"T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1 [_] = 1\"\n| \"T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1 (_ # _ # hs) = 1 + T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1 hs\""], ["", "fun T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>2 :: \"'a hp list \\<Rightarrow> nat\" where\n\"T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>2 [] = 1\" |\n\"T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>2 (_ # hs) = 1 + T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>2 hs\""], ["", "fun cost :: \"'a :: linorder op \\<Rightarrow> 'a heap list \\<Rightarrow> nat\" where\n\"cost Empty _ = 1\" |\n\"cost Del_min [None] = 1\" |\n\"cost Del_min [Some(Hp x hs)] = 1 + T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>2 (pass\\<^sub>1 hs) + T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1 hs\" |\n\"cost (Insert a) _ = 1\" |\n\"cost Merge _ = 1\""], ["", "fun U :: \"'a :: linorder op \\<Rightarrow> 'a heap list \\<Rightarrow> real\" where\n\"U Empty _ = 1\" |\n\"U (Insert a) [h] = log 2 (size_heap h + 1) + 1\" |\n\"U Del_min [h] = 3*log 2 (size_heap h + 1) + 5\" |\n\"U Merge [h1,h2] = 2*log 2 (size_heap h1 + size_heap h2 + 1) + 1\""], ["", "interpretation pairing: Amortized\nwhere arity = arity and exec = exec and cost = cost and inv = \"\\<lambda>_. True\"\nand \\<Phi> = \\<Phi> and U = U"], ["proof (prove)\ngoal (1 subgoal):\n 1. Amortized arity exec (\\<lambda>_. True) cost \\<Phi> U", "proof (standard, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. True; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> True\n 2. \\<And>s. True \\<Longrightarrow> 0 \\<le> \\<Phi> s\n 3. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. True; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) + \\<Phi> (exec f ss) -\n                         sum_list (map \\<Phi> ss)\n                         \\<le> U f ss", "case (2 s)"], ["proof (state)\nthis:\n  True\n\ngoal (3 subgoals):\n 1. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. True; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> True\n 2. \\<And>s. True \\<Longrightarrow> 0 \\<le> \\<Phi> s\n 3. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. True; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) + \\<Phi> (exec f ss) -\n                         sum_list (map \\<Phi> ss)\n                         \\<le> U f ss", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<Phi> s", "by (cases s) (auto simp: \\<Phi>_hps_ge0)"], ["proof (state)\nthis:\n  0 \\<le> \\<Phi> s\n\ngoal (2 subgoals):\n 1. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. True; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> True\n 2. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. True; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) + \\<Phi> (exec f ss) -\n                         sum_list (map \\<Phi> ss)\n                         \\<le> U f ss", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. True; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> True\n 2. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. True; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) + \\<Phi> (exec f ss) -\n                         sum_list (map \\<Phi> ss)\n                         \\<le> U f ss", "case (3 ss f)"], ["proof (state)\nthis:\n  \\<forall>s\\<in>set ss. True\n  length ss = arity f\n\ngoal (2 subgoals):\n 1. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. True; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> True\n 2. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. True; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) + \\<Phi> (exec f ss) -\n                         sum_list (map \\<Phi> ss)\n                         \\<le> U f ss", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "proof (cases f)"], ["proof (state)\ngoal (4 subgoals):\n 1. f = Empty \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 2. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n       \\<le> U f ss\n 3. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 4. f = Merge \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "case Empty"], ["proof (state)\nthis:\n  f = Empty\n\ngoal (4 subgoals):\n 1. f = Empty \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 2. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n       \\<le> U f ss\n 3. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 4. f = Merge \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "with 3"], ["proof (chain)\npicking this:\n  \\<forall>s\\<in>set ss. True\n  length ss = arity f\n  f = Empty", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>set ss. True\n  length ss = arity f\n  f = Empty\n\ngoal (1 subgoal):\n 1. real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "by(auto)"], ["proof (state)\nthis:\n  real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n  \\<le> U f ss\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n       \\<le> U f ss\n 2. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 3. f = Merge \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n       \\<le> U f ss\n 2. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 3. f = Merge \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "case Insert"], ["proof (state)\nthis:\n  f = Insert x2_\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n       \\<le> U f ss\n 2. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 3. f = Merge \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "thus ?thesis"], ["proof (prove)\nusing this:\n  f = Insert x2_\n\ngoal (1 subgoal):\n 1. real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "using Insert \\<Delta>\\<Phi>_insert 3"], ["proof (prove)\nusing this:\n  f = Insert x2_\n  f = Insert x2_\n  \\<Phi> (Pairing_Heap_List2.insert ?x ?h) - \\<Phi> ?h\n  \\<le> log 2 (real (size_heap ?h + 1))\n  \\<forall>s\\<in>set ss. True\n  length ss = arity f\n\ngoal (1 subgoal):\n 1. real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "by auto"], ["proof (state)\nthis:\n  real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n  \\<le> U f ss\n\ngoal (2 subgoals):\n 1. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 2. f = Merge \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 2. f = Merge \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "case [simp]: Del_min"], ["proof (state)\nthis:\n  f = Del_min\n\ngoal (2 subgoals):\n 1. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 2. f = Merge \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "then"], ["proof (chain)\npicking this:\n  f = Del_min", "obtain ho where [simp]: \"ss = [ho]\""], ["proof (prove)\nusing this:\n  f = Del_min\n\ngoal (1 subgoal):\n 1. (\\<And>ho. ss = [ho] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using 3"], ["proof (prove)\nusing this:\n  f = Del_min\n  \\<forall>s\\<in>set ss. True\n  length ss = arity f\n\ngoal (1 subgoal):\n 1. (\\<And>ho. ss = [ho] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  ss = [ho]\n\ngoal (2 subgoals):\n 1. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 2. f = Merge \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "proof (cases ho)"], ["proof (state)\ngoal (2 subgoals):\n 1. ho = None \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 2. \\<And>a.\n       ho = Some a \\<Longrightarrow>\n       real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n       \\<le> U f ss", "case [simp]: (Some h)"], ["proof (state)\nthis:\n  ho = Some h\n\ngoal (2 subgoals):\n 1. ho = None \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 2. \\<And>a.\n       ho = Some a \\<Longrightarrow>\n       real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n       \\<le> U f ss", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "proof (cases h)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       h = Hp x1 x2 \\<Longrightarrow>\n       real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n       \\<le> U f ss", "case [simp]: (Hp x hs)"], ["proof (state)\nthis:\n  h = Hp x hs\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       h = Hp x1 x2 \\<Longrightarrow>\n       real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n       \\<le> U f ss", "have \"T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>2 (pass\\<^sub>1 hs) + T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1 hs \\<le> 2 + length hs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>2 (pass\\<^sub>1 hs) +\n    T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1 hs\n    \\<le> 2 + length hs", "by (induct hs rule: pass\\<^sub>1.induct) simp_all"], ["proof (state)\nthis:\n  T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>2 (pass\\<^sub>1 hs) +\n  T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1 hs\n  \\<le> 2 + length hs\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       h = Hp x1 x2 \\<Longrightarrow>\n       real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n       \\<le> U f ss", "hence  \"cost f ss \\<le> 1 + \\<dots>\""], ["proof (prove)\nusing this:\n  T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>2 (pass\\<^sub>1 hs) +\n  T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1 hs\n  \\<le> 2 + length hs\n\ngoal (1 subgoal):\n 1. cost f ss \\<le> 1 + (2 + length hs)", "by simp"], ["proof (state)\nthis:\n  cost f ss \\<le> 1 + (2 + length hs)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       h = Hp x1 x2 \\<Longrightarrow>\n       real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n       \\<le> U f ss", "moreover"], ["proof (state)\nthis:\n  cost f ss \\<le> 1 + (2 + length hs)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       h = Hp x1 x2 \\<Longrightarrow>\n       real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n       \\<le> U f ss", "have  \"\\<Phi> (del_min ho) - \\<Phi> ho \\<le> 3*log 2 (size_heap ho + 1) - length hs + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> (del_min ho) - \\<Phi> ho\n    \\<le> 3 * log 2 (real (size_heap ho + 1)) - real (length hs) + 2", "proof (cases \"hs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. hs = [] \\<Longrightarrow>\n    \\<Phi> (del_min ho) - \\<Phi> ho\n    \\<le> 3 * log 2 (real (size_heap ho + 1)) - real (length hs) + 2\n 2. hs \\<noteq> [] \\<Longrightarrow>\n    \\<Phi> (del_min ho) - \\<Phi> ho\n    \\<le> 3 * log 2 (real (size_heap ho + 1)) - real (length hs) + 2", "case False"], ["proof (state)\nthis:\n  hs \\<noteq> []\n\ngoal (2 subgoals):\n 1. hs = [] \\<Longrightarrow>\n    \\<Phi> (del_min ho) - \\<Phi> ho\n    \\<le> 3 * log 2 (real (size_heap ho + 1)) - real (length hs) + 2\n 2. hs \\<noteq> [] \\<Longrightarrow>\n    \\<Phi> (del_min ho) - \\<Phi> ho\n    \\<le> 3 * log 2 (real (size_heap ho + 1)) - real (length hs) + 2", "hence \"\\<Phi> (del_min ho) - \\<Phi> ho \\<le> 3*log 2 (size_hps hs) - length hs + 2\""], ["proof (prove)\nusing this:\n  hs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<Phi> (del_min ho) - \\<Phi> ho\n    \\<le> 3 * log 2 (real (size_hps hs)) - real (length hs) + 2", "using  \\<Delta>\\<Phi>_del_min[of h]"], ["proof (prove)\nusing this:\n  hs \\<noteq> []\n  hps h \\<noteq> [] \\<Longrightarrow>\n  \\<Phi> (del_min (Some h)) - \\<Phi> (Some h)\n  \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2\n\ngoal (1 subgoal):\n 1. \\<Phi> (del_min ho) - \\<Phi> ho\n    \\<le> 3 * log 2 (real (size_hps hs)) - real (length hs) + 2", "by simp"], ["proof (state)\nthis:\n  \\<Phi> (del_min ho) - \\<Phi> ho\n  \\<le> 3 * log 2 (real (size_hps hs)) - real (length hs) + 2\n\ngoal (2 subgoals):\n 1. hs = [] \\<Longrightarrow>\n    \\<Phi> (del_min ho) - \\<Phi> ho\n    \\<le> 3 * log 2 (real (size_heap ho + 1)) - real (length hs) + 2\n 2. hs \\<noteq> [] \\<Longrightarrow>\n    \\<Phi> (del_min ho) - \\<Phi> ho\n    \\<le> 3 * log 2 (real (size_heap ho + 1)) - real (length hs) + 2", "also"], ["proof (state)\nthis:\n  \\<Phi> (del_min ho) - \\<Phi> ho\n  \\<le> 3 * log 2 (real (size_hps hs)) - real (length hs) + 2\n\ngoal (2 subgoals):\n 1. hs = [] \\<Longrightarrow>\n    \\<Phi> (del_min ho) - \\<Phi> ho\n    \\<le> 3 * log 2 (real (size_heap ho + 1)) - real (length hs) + 2\n 2. hs \\<noteq> [] \\<Longrightarrow>\n    \\<Phi> (del_min ho) - \\<Phi> ho\n    \\<le> 3 * log 2 (real (size_heap ho + 1)) - real (length hs) + 2", "have \"\\<dots> \\<le> 3*log 2 (size_heap ho + 1) - length hs + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 * log 2 (real (size_hps hs)) - real (length hs) + 2\n    \\<le> 3 * log 2 (real (size_heap ho + 1)) - real (length hs) + 2", "using False size_hps.elims"], ["proof (prove)\nusing this:\n  hs \\<noteq> []\n  \\<lbrakk>size_hps ?x = ?y;\n   \\<And>x hsl hsr.\n      \\<lbrakk>?x = Hp x hsl # hsr;\n       ?y = size_hps hsl + size_hps hsr + 1\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<lbrakk>?x = []; ?y = 0\\<rbrakk> \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. 3 * log 2 (real (size_hps hs)) - real (length hs) + 2\n    \\<le> 3 * log 2 (real (size_heap ho + 1)) - real (length hs) + 2", "by force"], ["proof (state)\nthis:\n  3 * log 2 (real (size_hps hs)) - real (length hs) + 2\n  \\<le> 3 * log 2 (real (size_heap ho + 1)) - real (length hs) + 2\n\ngoal (2 subgoals):\n 1. hs = [] \\<Longrightarrow>\n    \\<Phi> (del_min ho) - \\<Phi> ho\n    \\<le> 3 * log 2 (real (size_heap ho + 1)) - real (length hs) + 2\n 2. hs \\<noteq> [] \\<Longrightarrow>\n    \\<Phi> (del_min ho) - \\<Phi> ho\n    \\<le> 3 * log 2 (real (size_heap ho + 1)) - real (length hs) + 2", "finally"], ["proof (chain)\npicking this:\n  \\<Phi> (del_min ho) - \\<Phi> ho\n  \\<le> 3 * log 2 (real (size_heap ho + 1)) - real (length hs) + 2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Phi> (del_min ho) - \\<Phi> ho\n  \\<le> 3 * log 2 (real (size_heap ho + 1)) - real (length hs) + 2\n\ngoal (1 subgoal):\n 1. \\<Phi> (del_min ho) - \\<Phi> ho\n    \\<le> 3 * log 2 (real (size_heap ho + 1)) - real (length hs) + 2", "."], ["proof (state)\nthis:\n  \\<Phi> (del_min ho) - \\<Phi> ho\n  \\<le> 3 * log 2 (real (size_heap ho + 1)) - real (length hs) + 2\n\ngoal (1 subgoal):\n 1. hs = [] \\<Longrightarrow>\n    \\<Phi> (del_min ho) - \\<Phi> ho\n    \\<le> 3 * log 2 (real (size_heap ho + 1)) - real (length hs) + 2", "qed simp"], ["proof (state)\nthis:\n  \\<Phi> (del_min ho) - \\<Phi> ho\n  \\<le> 3 * log 2 (real (size_heap ho + 1)) - real (length hs) + 2\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       h = Hp x1 x2 \\<Longrightarrow>\n       real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n       \\<le> U f ss", "ultimately"], ["proof (chain)\npicking this:\n  cost f ss \\<le> 1 + (2 + length hs)\n  \\<Phi> (del_min ho) - \\<Phi> ho\n  \\<le> 3 * log 2 (real (size_heap ho + 1)) - real (length hs) + 2", "show ?thesis"], ["proof (prove)\nusing this:\n  cost f ss \\<le> 1 + (2 + length hs)\n  \\<Phi> (del_min ho) - \\<Phi> ho\n  \\<le> 3 * log 2 (real (size_heap ho + 1)) - real (length hs) + 2\n\ngoal (1 subgoal):\n 1. real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "by simp"], ["proof (state)\nthis:\n  real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n  \\<le> U f ss\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n  \\<le> U f ss\n\ngoal (1 subgoal):\n 1. ho = None \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "qed simp"], ["proof (state)\nthis:\n  real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n  \\<le> U f ss\n\ngoal (1 subgoal):\n 1. f = Merge \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f = Merge \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "case [simp]: Merge"], ["proof (state)\nthis:\n  f = Merge\n\ngoal (1 subgoal):\n 1. f = Merge \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "then"], ["proof (chain)\npicking this:\n  f = Merge", "obtain ho1 ho2 where [simp]: \"ss = [ho1, ho2]\""], ["proof (prove)\nusing this:\n  f = Merge\n\ngoal (1 subgoal):\n 1. (\\<And>ho1 ho2.\n        ss = [ho1, ho2] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 3"], ["proof (prove)\nusing this:\n  f = Merge\n  \\<forall>s\\<in>set ss. True\n  length ss = arity f\n\ngoal (1 subgoal):\n 1. (\\<And>ho1 ho2.\n        ss = [ho1, ho2] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp: numeral_eq_Suc)"], ["proof (state)\nthis:\n  ss = [ho1, ho2]\n\ngoal (1 subgoal):\n 1. f = Merge \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "proof (cases \"ho1 = None \\<or> ho2 = None\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ho1 = None \\<or> ho2 = None \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 2. \\<not> (ho1 = None \\<or> ho2 = None) \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "case True"], ["proof (state)\nthis:\n  ho1 = None \\<or> ho2 = None\n\ngoal (2 subgoals):\n 1. ho1 = None \\<or> ho2 = None \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 2. \\<not> (ho1 = None \\<or> ho2 = None) \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "thus ?thesis"], ["proof (prove)\nusing this:\n  ho1 = None \\<or> ho2 = None\n\ngoal (1 subgoal):\n 1. real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "by auto"], ["proof (state)\nthis:\n  real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n  \\<le> U f ss\n\ngoal (1 subgoal):\n 1. \\<not> (ho1 = None \\<or> ho2 = None) \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (ho1 = None \\<or> ho2 = None) \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "case False"], ["proof (state)\nthis:\n  \\<not> (ho1 = None \\<or> ho2 = None)\n\ngoal (1 subgoal):\n 1. \\<not> (ho1 = None \\<or> ho2 = None) \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "then"], ["proof (chain)\npicking this:\n  \\<not> (ho1 = None \\<or> ho2 = None)", "obtain h1 h2 where [simp]: \"ho1 = Some h1\" \"ho2 = Some h2\""], ["proof (prove)\nusing this:\n  \\<not> (ho1 = None \\<or> ho2 = None)\n\ngoal (1 subgoal):\n 1. (\\<And>h1 h2.\n        \\<lbrakk>ho1 = Some h1; ho2 = Some h2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ho1 = Some h1\n  ho2 = Some h2\n\ngoal (1 subgoal):\n 1. \\<not> (ho1 = None \\<or> ho2 = None) \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "have \"\\<Phi> (merge ho1 ho2) - \\<Phi> ho1 - \\<Phi> ho2 \\<le> 2 * log 2 (size_heap ho1 + size_heap ho2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> (merge ho1 ho2) - \\<Phi> ho1 - \\<Phi> ho2\n    \\<le> 2 * log 2 (real (size_heap ho1 + size_heap ho2))", "using \\<Delta>\\<Phi>_link[of h1 h2]"], ["proof (prove)\nusing this:\n  \\<Phi>_hp (link h1 h2) - \\<Phi>_hp h1 - \\<Phi>_hp h2\n  \\<le> 2 *\n        log 2\n         (real\n           (Pairing_Heap_List2_Analysis.size_hp h1 +\n            Pairing_Heap_List2_Analysis.size_hp h2))\n\ngoal (1 subgoal):\n 1. \\<Phi> (merge ho1 ho2) - \\<Phi> ho1 - \\<Phi> ho2\n    \\<le> 2 * log 2 (real (size_heap ho1 + size_heap ho2))", "by simp"], ["proof (state)\nthis:\n  \\<Phi> (merge ho1 ho2) - \\<Phi> ho1 - \\<Phi> ho2\n  \\<le> 2 * log 2 (real (size_heap ho1 + size_heap ho2))\n\ngoal (1 subgoal):\n 1. \\<not> (ho1 = None \\<or> ho2 = None) \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "also"], ["proof (state)\nthis:\n  \\<Phi> (merge ho1 ho2) - \\<Phi> ho1 - \\<Phi> ho2\n  \\<le> 2 * log 2 (real (size_heap ho1 + size_heap ho2))\n\ngoal (1 subgoal):\n 1. \\<not> (ho1 = None \\<or> ho2 = None) \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "have \"\\<dots> \\<le> 2 * log 2 (size_hp h1 + size_hp h2 + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * log 2 (real (size_heap ho1 + size_heap ho2))\n    \\<le> 2 *\n          log 2\n           (real\n             (Pairing_Heap_List2_Analysis.size_hp h1 +\n              Pairing_Heap_List2_Analysis.size_hp h2 +\n              1))", "by (simp)"], ["proof (state)\nthis:\n  2 * log 2 (real (size_heap ho1 + size_heap ho2))\n  \\<le> 2 *\n        log 2\n         (real\n           (Pairing_Heap_List2_Analysis.size_hp h1 +\n            Pairing_Heap_List2_Analysis.size_hp h2 +\n            1))\n\ngoal (1 subgoal):\n 1. \\<not> (ho1 = None \\<or> ho2 = None) \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "finally"], ["proof (chain)\npicking this:\n  \\<Phi> (merge ho1 ho2) - \\<Phi> ho1 - \\<Phi> ho2\n  \\<le> 2 *\n        log 2\n         (real\n           (Pairing_Heap_List2_Analysis.size_hp h1 +\n            Pairing_Heap_List2_Analysis.size_hp h2 +\n            1))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Phi> (merge ho1 ho2) - \\<Phi> ho1 - \\<Phi> ho2\n  \\<le> 2 *\n        log 2\n         (real\n           (Pairing_Heap_List2_Analysis.size_hp h1 +\n            Pairing_Heap_List2_Analysis.size_hp h2 +\n            1))\n\ngoal (1 subgoal):\n 1. real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "by(simp)"], ["proof (state)\nthis:\n  real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n  \\<le> U f ss\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n  \\<le> U f ss\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n  \\<le> U f ss\n\ngoal (1 subgoal):\n 1. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. True; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> True", "qed simp"], ["", "end"]]}