{"file_name": "/home/qj213/afp-2021-10-22/thys/Amortized_Complexity/Splay_Heap_Analysis.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Amortized_Complexity", "problem_names": ["lemma amor_del_min: \"T_dm t + \\<Phi> (del_min t) - \\<Phi> t \\<le> 2 * \\<phi> t + 1\"", "lemma zig_zig:\nfixes s u r r1' r2' T a b\ndefines \"t == Node s a (Node u b r)\" and \"t' == Node (Node s a u) b r1'\"\nassumes \"size r1' \\<le> size r\"\n    \"T_part p r + \\<Phi> r1' + \\<Phi> r2' - \\<Phi> r \\<le> 2 * \\<phi> r + 1\"\nshows \"T_part p r + 1 + \\<Phi> t' + \\<Phi> r2' - \\<Phi> t \\<le> 2 * \\<phi> t + 1\"", "lemma zig_zag:\nfixes s u r r1' r2' a b\ndefines \"t \\<equiv> Node s a (Node r b u)\" and \"t1' == Node s a r1'\" and \"t2' \\<equiv> Node u b r2'\"\nassumes \"size r = size r1' + size r2'\"\n    \"T_part p r + \\<Phi> r1' + \\<Phi> r2' - \\<Phi> r \\<le> 2 * \\<phi> r + 1\"\nshows \"T_part p r + 1 + \\<Phi> t1' + \\<Phi> t2' - \\<Phi> t \\<le> 2 * \\<phi> t + 1\"", "lemma amor_partition: \"bst_wrt (\\<le>) t \\<Longrightarrow> partition p t = (l',r')\n  \\<Longrightarrow> T_part p t + \\<Phi> l' + \\<Phi> r' - \\<Phi> t \\<le> 2 * log 2 (size1 t) + 1\""], "translations": [["", "lemma amor_del_min: \"T_dm t + \\<Phi> (del_min t) - \\<Phi> t \\<le> 2 * \\<phi> t + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (T_dm t) + \\<Phi> (del_min t) - \\<Phi> t \\<le> 2 * \\<phi> t + 1", "proof(induction t rule: T_dm.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. real (T_dm \\<langle>\\<rangle>) + \\<Phi> (del_min \\<langle>\\<rangle>) -\n    \\<Phi> \\<langle>\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<rangle> + 1\n 2. \\<And>uu_ r.\n       real (T_dm \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle>) +\n       \\<Phi> (del_min \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle>) -\n       \\<Phi> \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle>\n       \\<le> 2 * \\<phi> \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle> + 1\n 3. \\<And>ll a lr b r.\n       (ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n        real (T_dm ll) + \\<Phi> (del_min ll) - \\<Phi> ll\n        \\<le> 2 * \\<phi> ll + 1) \\<Longrightarrow>\n       real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n       \\<Phi>\n        (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n       \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n       \\<le> 2 *\n             \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> +\n             1", "case (3 ll a lr b r)"], ["proof (state)\nthis:\n  ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n  real (T_dm ll) + \\<Phi> (del_min ll) - \\<Phi> ll \\<le> 2 * \\<phi> ll + 1\n\ngoal (3 subgoals):\n 1. real (T_dm \\<langle>\\<rangle>) + \\<Phi> (del_min \\<langle>\\<rangle>) -\n    \\<Phi> \\<langle>\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<rangle> + 1\n 2. \\<And>uu_ r.\n       real (T_dm \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle>) +\n       \\<Phi> (del_min \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle>) -\n       \\<Phi> \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle>\n       \\<le> 2 * \\<phi> \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle> + 1\n 3. \\<And>ll a lr b r.\n       (ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n        real (T_dm ll) + \\<Phi> (del_min ll) - \\<Phi> ll\n        \\<le> 2 * \\<phi> ll + 1) \\<Longrightarrow>\n       real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n       \\<Phi>\n        (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n       \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n       \\<le> 2 *\n             \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> +\n             1", "let ?t = \"Node (Node ll a lr) b r\""], ["proof (state)\ngoal (3 subgoals):\n 1. real (T_dm \\<langle>\\<rangle>) + \\<Phi> (del_min \\<langle>\\<rangle>) -\n    \\<Phi> \\<langle>\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<rangle> + 1\n 2. \\<And>uu_ r.\n       real (T_dm \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle>) +\n       \\<Phi> (del_min \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle>) -\n       \\<Phi> \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle>\n       \\<le> 2 * \\<phi> \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle> + 1\n 3. \\<And>ll a lr b r.\n       (ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n        real (T_dm ll) + \\<Phi> (del_min ll) - \\<Phi> ll\n        \\<le> 2 * \\<phi> ll + 1) \\<Longrightarrow>\n       real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n       \\<Phi>\n        (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n       \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n       \\<le> 2 *\n             \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> +\n             1", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1\n 2. \\<not> ?P \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "assume [simp]: \"ll = Leaf\""], ["proof (state)\nthis:\n  ll = \\<langle>\\<rangle>\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1\n 2. \\<not> ?P \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "have 1: \"log 2 (real (size1 lr) + real (size1 r))\n        \\<le> 3 * log 2 (1 + (real (size1 lr) + real (size1 r)))\" (is \"?l \\<le> 3 * ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real (size1 lr) + real (size1 r))\n    \\<le> 3 * log 2 (1 + (real (size1 lr) + real (size1 r)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. log 2 (real (size1 lr) + real (size1 r))\n    \\<le> 3 * log 2 (1 + (real (size1 lr) + real (size1 r)))", "have \"?l \\<le> ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real (size1 lr) + real (size1 r))\n    \\<le> log 2 (1 + (real (size1 lr) + real (size1 r)))", "by(simp add: size1_size)"], ["proof (state)\nthis:\n  log 2 (real (size1 lr) + real (size1 r))\n  \\<le> log 2 (1 + (real (size1 lr) + real (size1 r)))\n\ngoal (1 subgoal):\n 1. log 2 (real (size1 lr) + real (size1 r))\n    \\<le> 3 * log 2 (1 + (real (size1 lr) + real (size1 r)))", "also"], ["proof (state)\nthis:\n  log 2 (real (size1 lr) + real (size1 r))\n  \\<le> log 2 (1 + (real (size1 lr) + real (size1 r)))\n\ngoal (1 subgoal):\n 1. log 2 (real (size1 lr) + real (size1 r))\n    \\<le> 3 * log 2 (1 + (real (size1 lr) + real (size1 r)))", "have \"\\<dots> \\<le> 3 * ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (1 + (real (size1 lr) + real (size1 r)))\n    \\<le> 3 * log 2 (1 + (real (size1 lr) + real (size1 r)))", "by(simp)"], ["proof (state)\nthis:\n  log 2 (1 + (real (size1 lr) + real (size1 r)))\n  \\<le> 3 * log 2 (1 + (real (size1 lr) + real (size1 r)))\n\ngoal (1 subgoal):\n 1. log 2 (real (size1 lr) + real (size1 r))\n    \\<le> 3 * log 2 (1 + (real (size1 lr) + real (size1 r)))", "finally"], ["proof (chain)\npicking this:\n  log 2 (real (size1 lr) + real (size1 r))\n  \\<le> 3 * log 2 (1 + (real (size1 lr) + real (size1 r)))", "show ?thesis"], ["proof (prove)\nusing this:\n  log 2 (real (size1 lr) + real (size1 r))\n  \\<le> 3 * log 2 (1 + (real (size1 lr) + real (size1 r)))\n\ngoal (1 subgoal):\n 1. log 2 (real (size1 lr) + real (size1 r))\n    \\<le> 3 * log 2 (1 + (real (size1 lr) + real (size1 r)))", "."], ["proof (state)\nthis:\n  log 2 (real (size1 lr) + real (size1 r))\n  \\<le> 3 * log 2 (1 + (real (size1 lr) + real (size1 r)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  log 2 (real (size1 lr) + real (size1 r))\n  \\<le> 3 * log 2 (1 + (real (size1 lr) + real (size1 r)))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1\n 2. \\<not> ?P \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "have 2: \"log 2 (1 + real (size1 lr)) \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> log 2 (1 + real (size1 lr))", "by simp"], ["proof (state)\nthis:\n  0 \\<le> log 2 (1 + real (size1 lr))\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1\n 2. \\<not> ?P \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "thus ?case"], ["proof (prove)\nusing this:\n  0 \\<le> log 2 (1 + real (size1 lr))\n\ngoal (1 subgoal):\n 1. real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real (size1 lr) + real (size1 r)) - log 2 (1 + real (size1 lr))\n    \\<le> 3 * log 2 (1 + (real (size1 lr) + real (size1 r)))", "using 1 2"], ["proof (prove)\nusing this:\n  log 2 (real (size1 lr) + real (size1 r))\n  \\<le> 3 * log 2 (1 + (real (size1 lr) + real (size1 r)))\n  0 \\<le> log 2 (1 + real (size1 lr))\n\ngoal (1 subgoal):\n 1. log 2 (real (size1 lr) + real (size1 r)) - log 2 (1 + real (size1 lr))\n    \\<le> 3 * log 2 (1 + (real (size1 lr) + real (size1 r)))", "by linarith"], ["proof (state)\nthis:\n  real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n  \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n  \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n  \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1\n\ngoal (1 subgoal):\n 1. ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "assume ll[simp]: \"\\<not> ll = Leaf\""], ["proof (state)\nthis:\n  ll \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "let ?l' = \"del_min ll\""], ["proof (state)\ngoal (1 subgoal):\n 1. ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "let ?s = \"Node ll a lr\""], ["proof (state)\ngoal (1 subgoal):\n 1. ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "let ?t = \"Node ?s b r\""], ["proof (state)\ngoal (1 subgoal):\n 1. ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "let ?s' = \"Node lr b r\""], ["proof (state)\ngoal (1 subgoal):\n 1. ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "let ?t' = \"Node ?l' a ?s'\""], ["proof (state)\ngoal (1 subgoal):\n 1. ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "have 0: \"\\<phi> ?t' \\<le> \\<phi> ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> \\<langle>del_min ll, a, \\<langle>lr, b, r\\<rangle>\\<rangle>\n    \\<le> \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>", "by(simp add: size1_size)"], ["proof (state)\nthis:\n  \\<phi> \\<langle>del_min ll, a, \\<langle>lr, b, r\\<rangle>\\<rangle>\n  \\<le> \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n\ngoal (1 subgoal):\n 1. ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "have 1: \"\\<phi> ll < \\<phi> ?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> ll < \\<phi> \\<langle>ll, a, lr\\<rangle>", "by(simp add: size1_size)"], ["proof (state)\nthis:\n  \\<phi> ll < \\<phi> \\<langle>ll, a, lr\\<rangle>\n\ngoal (1 subgoal):\n 1. ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "have 2: \"log 2 (size1 ll + size1 ?s') \\<le> log 2 (size1 ?t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real (size1 ll + size1 \\<langle>lr, b, r\\<rangle>))\n    \\<le> \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>", "by(simp add: size1_size)"], ["proof (state)\nthis:\n  log 2 (real (size1 ll + size1 \\<langle>lr, b, r\\<rangle>))\n  \\<le> \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n\ngoal (1 subgoal):\n 1. ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "have \"T_dm ?t + \\<Phi> (del_min ?t) - \\<Phi> ?t\n        = 1 + T_dm ll + \\<Phi> (del_min ?t) - \\<Phi> ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> =\n    real (1 + T_dm ll) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>", "by simp"], ["proof (state)\nthis:\n  real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n  \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n  \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> =\n  real (1 + T_dm ll) +\n  \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n  \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n\ngoal (1 subgoal):\n 1. ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "also"], ["proof (state)\nthis:\n  real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n  \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n  \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> =\n  real (1 + T_dm ll) +\n  \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n  \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n\ngoal (1 subgoal):\n 1. ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "have \"\\<dots> \\<le> 2 + 2 * \\<phi> ll + \\<Phi> ll - \\<Phi> ?l'  + \\<Phi> (del_min ?t) - \\<Phi> ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (1 + T_dm ll) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 + 2 * \\<phi> ll + \\<Phi> ll - \\<Phi> (del_min ll) +\n          \\<Phi>\n           (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n          \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>", "using 3 ll"], ["proof (prove)\nusing this:\n  ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n  real (T_dm ll) + \\<Phi> (del_min ll) - \\<Phi> ll \\<le> 2 * \\<phi> ll + 1\n  ll \\<noteq> \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. real (1 + T_dm ll) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 + 2 * \\<phi> ll + \\<Phi> ll - \\<Phi> (del_min ll) +\n          \\<Phi>\n           (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n          \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>", "by linarith"], ["proof (state)\nthis:\n  real (1 + T_dm ll) +\n  \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n  \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n  \\<le> 2 + 2 * \\<phi> ll + \\<Phi> ll - \\<Phi> (del_min ll) +\n        \\<Phi>\n         (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n        \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n\ngoal (1 subgoal):\n 1. ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "also"], ["proof (state)\nthis:\n  real (1 + T_dm ll) +\n  \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n  \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n  \\<le> 2 + 2 * \\<phi> ll + \\<Phi> ll - \\<Phi> (del_min ll) +\n        \\<Phi>\n         (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n        \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n\ngoal (1 subgoal):\n 1. ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "have \"\\<dots> = 2 + 2 * \\<phi> ll + \\<phi> ?t' + \\<phi> ?s' - \\<phi> ?t - \\<phi> ?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 + 2 * \\<phi> ll + \\<Phi> ll - \\<Phi> (del_min ll) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> =\n    2 + 2 * \\<phi> ll +\n    \\<phi> \\<langle>del_min ll, a, \\<langle>lr, b, r\\<rangle>\\<rangle> +\n    \\<phi> \\<langle>lr, b, r\\<rangle> -\n    \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> -\n    \\<phi> \\<langle>ll, a, lr\\<rangle>", "by(simp)"], ["proof (state)\nthis:\n  2 + 2 * \\<phi> ll + \\<Phi> ll - \\<Phi> (del_min ll) +\n  \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n  \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> =\n  2 + 2 * \\<phi> ll +\n  \\<phi> \\<langle>del_min ll, a, \\<langle>lr, b, r\\<rangle>\\<rangle> +\n  \\<phi> \\<langle>lr, b, r\\<rangle> -\n  \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> -\n  \\<phi> \\<langle>ll, a, lr\\<rangle>\n\ngoal (1 subgoal):\n 1. ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "also"], ["proof (state)\nthis:\n  2 + 2 * \\<phi> ll + \\<Phi> ll - \\<Phi> (del_min ll) +\n  \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n  \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> =\n  2 + 2 * \\<phi> ll +\n  \\<phi> \\<langle>del_min ll, a, \\<langle>lr, b, r\\<rangle>\\<rangle> +\n  \\<phi> \\<langle>lr, b, r\\<rangle> -\n  \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> -\n  \\<phi> \\<langle>ll, a, lr\\<rangle>\n\ngoal (1 subgoal):\n 1. ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "have \"\\<dots> \\<le> 2 + \\<phi> ll + \\<phi> ?s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 + 2 * \\<phi> ll +\n    \\<phi> \\<langle>del_min ll, a, \\<langle>lr, b, r\\<rangle>\\<rangle> +\n    \\<phi> \\<langle>lr, b, r\\<rangle> -\n    \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> -\n    \\<phi> \\<langle>ll, a, lr\\<rangle>\n    \\<le> 2 + \\<phi> ll + \\<phi> \\<langle>lr, b, r\\<rangle>", "using 0 1"], ["proof (prove)\nusing this:\n  \\<phi> \\<langle>del_min ll, a, \\<langle>lr, b, r\\<rangle>\\<rangle>\n  \\<le> \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n  \\<phi> ll < \\<phi> \\<langle>ll, a, lr\\<rangle>\n\ngoal (1 subgoal):\n 1. 2 + 2 * \\<phi> ll +\n    \\<phi> \\<langle>del_min ll, a, \\<langle>lr, b, r\\<rangle>\\<rangle> +\n    \\<phi> \\<langle>lr, b, r\\<rangle> -\n    \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> -\n    \\<phi> \\<langle>ll, a, lr\\<rangle>\n    \\<le> 2 + \\<phi> ll + \\<phi> \\<langle>lr, b, r\\<rangle>", "by linarith"], ["proof (state)\nthis:\n  2 + 2 * \\<phi> ll +\n  \\<phi> \\<langle>del_min ll, a, \\<langle>lr, b, r\\<rangle>\\<rangle> +\n  \\<phi> \\<langle>lr, b, r\\<rangle> -\n  \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> -\n  \\<phi> \\<langle>ll, a, lr\\<rangle>\n  \\<le> 2 + \\<phi> ll + \\<phi> \\<langle>lr, b, r\\<rangle>\n\ngoal (1 subgoal):\n 1. ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "also"], ["proof (state)\nthis:\n  2 + 2 * \\<phi> ll +\n  \\<phi> \\<langle>del_min ll, a, \\<langle>lr, b, r\\<rangle>\\<rangle> +\n  \\<phi> \\<langle>lr, b, r\\<rangle> -\n  \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> -\n  \\<phi> \\<langle>ll, a, lr\\<rangle>\n  \\<le> 2 + \\<phi> ll + \\<phi> \\<langle>lr, b, r\\<rangle>\n\ngoal (1 subgoal):\n 1. ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "have \"\\<dots> < 2 * \\<phi> ?t + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 + \\<phi> ll + \\<phi> \\<langle>lr, b, r\\<rangle>\n    < 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "using 2 ld_ld_1_less[of \"size1 ll\" \"size1 ?s'\"]"], ["proof (prove)\nusing this:\n  log 2 (real (size1 ll + size1 \\<langle>lr, b, r\\<rangle>))\n  \\<le> \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n  \\<lbrakk>0 < real (size1 ll);\n   0 < real (size1 \\<langle>lr, b, r\\<rangle>)\\<rbrakk>\n  \\<Longrightarrow> 1 + \\<phi> ll + \\<phi> \\<langle>lr, b, r\\<rangle>\n                    < 2 *\n                      log 2\n                       (real (size1 ll) +\n                        real (size1 \\<langle>lr, b, r\\<rangle>))\n\ngoal (1 subgoal):\n 1. 2 + \\<phi> ll + \\<phi> \\<langle>lr, b, r\\<rangle>\n    < 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "by (simp add: size1_size)"], ["proof (state)\nthis:\n  2 + \\<phi> ll + \\<phi> \\<langle>lr, b, r\\<rangle>\n  < 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1\n\ngoal (1 subgoal):\n 1. ll \\<noteq> \\<langle>\\<rangle> \\<Longrightarrow>\n    real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "finally"], ["proof (chain)\npicking this:\n  real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n  \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n  \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n  < 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "show ?case"], ["proof (prove)\nusing this:\n  real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n  \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n  \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n  < 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1\n\ngoal (1 subgoal):\n 1. real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n    \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n    \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1", "by simp"], ["proof (state)\nthis:\n  real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n  \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n  \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n  \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real (T_dm \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) +\n  \\<Phi> (del_min \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>) -\n  \\<Phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle>\n  \\<le> 2 * \\<phi> \\<langle>\\<langle>ll, a, lr\\<rangle>, b, r\\<rangle> + 1\n\ngoal (2 subgoals):\n 1. real (T_dm \\<langle>\\<rangle>) + \\<Phi> (del_min \\<langle>\\<rangle>) -\n    \\<Phi> \\<langle>\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<rangle> + 1\n 2. \\<And>uu_ r.\n       real (T_dm \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle>) +\n       \\<Phi> (del_min \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle>) -\n       \\<Phi> \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle>\n       \\<le> 2 * \\<phi> \\<langle>\\<langle>\\<rangle>, uu_, r\\<rangle> + 1", "qed auto"], ["", "lemma zig_zig:\nfixes s u r r1' r2' T a b\ndefines \"t == Node s a (Node u b r)\" and \"t' == Node (Node s a u) b r1'\"\nassumes \"size r1' \\<le> size r\"\n    \"T_part p r + \\<Phi> r1' + \\<Phi> r2' - \\<Phi> r \\<le> 2 * \\<phi> r + 1\"\nshows \"T_part p r + 1 + \\<Phi> t' + \\<Phi> r2' - \\<Phi> t \\<le> 2 * \\<phi> t + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (T_part p r + 1) + \\<Phi> t' + \\<Phi> r2' - \\<Phi> t\n    \\<le> 2 * \\<phi> t + 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real (T_part p r + 1) + \\<Phi> t' + \\<Phi> r2' - \\<Phi> t\n    \\<le> 2 * \\<phi> t + 1", "have 1: \"\\<phi> r \\<le> \\<phi> (Node u b r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> r \\<le> \\<phi> \\<langle>u, b, r\\<rangle>", "by (simp add: size1_size)"], ["proof (state)\nthis:\n  \\<phi> r \\<le> \\<phi> \\<langle>u, b, r\\<rangle>\n\ngoal (1 subgoal):\n 1. real (T_part p r + 1) + \\<Phi> t' + \\<Phi> r2' - \\<Phi> t\n    \\<le> 2 * \\<phi> t + 1", "have 2: \"log 2 (real (size1 s + size1 u + size1 r1')) \\<le> \\<phi> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real (size1 s + size1 u + size1 r1')) \\<le> \\<phi> t", "using assms(3)"], ["proof (prove)\nusing this:\n  size r1' \\<le> size r\n\ngoal (1 subgoal):\n 1. log 2 (real (size1 s + size1 u + size1 r1')) \\<le> \\<phi> t", "by (simp add: t_def size1_size)"], ["proof (state)\nthis:\n  log 2 (real (size1 s + size1 u + size1 r1')) \\<le> \\<phi> t\n\ngoal (1 subgoal):\n 1. real (T_part p r + 1) + \\<Phi> t' + \\<Phi> r2' - \\<Phi> t\n    \\<le> 2 * \\<phi> t + 1", "from ld_ld_1_less[of \"size1 s + size1 u\" \"size1 r\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < real (size1 s + size1 u); 0 < real (size1 r)\\<rbrakk>\n  \\<Longrightarrow> 1 + log 2 (real (size1 s + size1 u)) + \\<phi> r\n                    < 2 * log 2 (real (size1 s + size1 u) + real (size1 r))", "have \"1 + \\<phi> r + log 2 (size1 s + size1 u) \\<le> 2 * log 2 (size1 s + size1 u + size1 r)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < real (size1 s + size1 u); 0 < real (size1 r)\\<rbrakk>\n  \\<Longrightarrow> 1 + log 2 (real (size1 s + size1 u)) + \\<phi> r\n                    < 2 * log 2 (real (size1 s + size1 u) + real (size1 r))\n\ngoal (1 subgoal):\n 1. 1 + \\<phi> r + log 2 (real (size1 s + size1 u))\n    \\<le> 2 * log 2 (real (size1 s + size1 u + size1 r))", "by(simp add: size1_size)"], ["proof (state)\nthis:\n  1 + \\<phi> r + log 2 (real (size1 s + size1 u))\n  \\<le> 2 * log 2 (real (size1 s + size1 u + size1 r))\n\ngoal (1 subgoal):\n 1. real (T_part p r + 1) + \\<Phi> t' + \\<Phi> r2' - \\<Phi> t\n    \\<le> 2 * \\<phi> t + 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  1 + \\<phi> r + log 2 (real (size1 s + size1 u))\n  \\<le> 2 * log 2 (real (size1 s + size1 u + size1 r))\n\ngoal (1 subgoal):\n 1. real (T_part p r + 1) + \\<Phi> t' + \\<Phi> r2' - \\<Phi> t\n    \\<le> 2 * \\<phi> t + 1", "using assms 1 2"], ["proof (prove)\nusing this:\n  1 + \\<phi> r + log 2 (real (size1 s + size1 u))\n  \\<le> 2 * log 2 (real (size1 s + size1 u + size1 r))\n  t \\<equiv> \\<langle>s, a, \\<langle>u, b, r\\<rangle>\\<rangle>\n  t' \\<equiv> \\<langle>\\<langle>s, a, u\\<rangle>, b, r1'\\<rangle>\n  size r1' \\<le> size r\n  real (T_part p r) + \\<Phi> r1' + \\<Phi> r2' - \\<Phi> r\n  \\<le> 2 * \\<phi> r + 1\n  \\<phi> r \\<le> \\<phi> \\<langle>u, b, r\\<rangle>\n  log 2 (real (size1 s + size1 u + size1 r1')) \\<le> \\<phi> t\n\ngoal (1 subgoal):\n 1. real (T_part p r + 1) + \\<Phi> t' + \\<Phi> r2' - \\<Phi> t\n    \\<le> 2 * \\<phi> t + 1", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  real (T_part p r + 1) + \\<Phi> t' + \\<Phi> r2' - \\<Phi> t\n  \\<le> 2 * \\<phi> t + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zig_zag:\nfixes s u r r1' r2' a b\ndefines \"t \\<equiv> Node s a (Node r b u)\" and \"t1' == Node s a r1'\" and \"t2' \\<equiv> Node u b r2'\"\nassumes \"size r = size r1' + size r2'\"\n    \"T_part p r + \\<Phi> r1' + \\<Phi> r2' - \\<Phi> r \\<le> 2 * \\<phi> r + 1\"\nshows \"T_part p r + 1 + \\<Phi> t1' + \\<Phi> t2' - \\<Phi> t \\<le> 2 * \\<phi> t + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (T_part p r + 1) + \\<Phi> t1' + \\<Phi> t2' - \\<Phi> t\n    \\<le> 2 * \\<phi> t + 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real (T_part p r + 1) + \\<Phi> t1' + \\<Phi> t2' - \\<Phi> t\n    \\<le> 2 * \\<phi> t + 1", "have 1: \"\\<phi> r \\<le> \\<phi> (Node u b r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> r \\<le> \\<phi> \\<langle>u, b, r\\<rangle>", "by (simp add: size1_size)"], ["proof (state)\nthis:\n  \\<phi> r \\<le> \\<phi> \\<langle>u, b, r\\<rangle>\n\ngoal (1 subgoal):\n 1. real (T_part p r + 1) + \\<Phi> t1' + \\<Phi> t2' - \\<Phi> t\n    \\<le> 2 * \\<phi> t + 1", "have 2: \"\\<phi> r \\<le> \\<phi> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> r \\<le> \\<phi> t", "by (simp add: t_def size1_size)"], ["proof (state)\nthis:\n  \\<phi> r \\<le> \\<phi> t\n\ngoal (1 subgoal):\n 1. real (T_part p r + 1) + \\<Phi> t1' + \\<Phi> t2' - \\<Phi> t\n    \\<le> 2 * \\<phi> t + 1", "from ld_ld_less2[of \"size1 s + size1 r1'\" \"size1 u + size1 r2'\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>2 \\<le> real (size1 s + size1 r1');\n   2 \\<le> real (size1 u + size1 r2')\\<rbrakk>\n  \\<Longrightarrow> 1 + log 2 (real (size1 s + size1 r1')) +\n                    log 2 (real (size1 u + size1 r2'))\n                    \\<le> 2 *\n                          log 2\n                           (real (size1 s + size1 r1') +\n                            real (size1 u + size1 r2') -\n                            1)", "have \"1 + log 2 (size1 s + size1 r1') + log 2 (size1 u + size1 r2') \\<le> 2 * \\<phi> t\""], ["proof (prove)\nusing this:\n  \\<lbrakk>2 \\<le> real (size1 s + size1 r1');\n   2 \\<le> real (size1 u + size1 r2')\\<rbrakk>\n  \\<Longrightarrow> 1 + log 2 (real (size1 s + size1 r1')) +\n                    log 2 (real (size1 u + size1 r2'))\n                    \\<le> 2 *\n                          log 2\n                           (real (size1 s + size1 r1') +\n                            real (size1 u + size1 r2') -\n                            1)\n\ngoal (1 subgoal):\n 1. 1 + log 2 (real (size1 s + size1 r1')) +\n    log 2 (real (size1 u + size1 r2'))\n    \\<le> 2 * \\<phi> t", "by(simp add: assms(4) size1_size t_def ac_simps)"], ["proof (state)\nthis:\n  1 + log 2 (real (size1 s + size1 r1')) +\n  log 2 (real (size1 u + size1 r2'))\n  \\<le> 2 * \\<phi> t\n\ngoal (1 subgoal):\n 1. real (T_part p r + 1) + \\<Phi> t1' + \\<Phi> t2' - \\<Phi> t\n    \\<le> 2 * \\<phi> t + 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  1 + log 2 (real (size1 s + size1 r1')) +\n  log 2 (real (size1 u + size1 r2'))\n  \\<le> 2 * \\<phi> t\n\ngoal (1 subgoal):\n 1. real (T_part p r + 1) + \\<Phi> t1' + \\<Phi> t2' - \\<Phi> t\n    \\<le> 2 * \\<phi> t + 1", "using assms 1 2"], ["proof (prove)\nusing this:\n  1 + log 2 (real (size1 s + size1 r1')) +\n  log 2 (real (size1 u + size1 r2'))\n  \\<le> 2 * \\<phi> t\n  t \\<equiv> \\<langle>s, a, \\<langle>r, b, u\\<rangle>\\<rangle>\n  t1' \\<equiv> \\<langle>s, a, r1'\\<rangle>\n  t2' \\<equiv> \\<langle>u, b, r2'\\<rangle>\n  size r = size r1' + size r2'\n  real (T_part p r) + \\<Phi> r1' + \\<Phi> r2' - \\<Phi> r\n  \\<le> 2 * \\<phi> r + 1\n  \\<phi> r \\<le> \\<phi> \\<langle>u, b, r\\<rangle>\n  \\<phi> r \\<le> \\<phi> t\n\ngoal (1 subgoal):\n 1. real (T_part p r + 1) + \\<Phi> t1' + \\<Phi> t2' - \\<Phi> t\n    \\<le> 2 * \\<phi> t + 1", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  real (T_part p r + 1) + \\<Phi> t1' + \\<Phi> t2' - \\<Phi> t\n  \\<le> 2 * \\<phi> t + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma amor_partition: \"bst_wrt (\\<le>) t \\<Longrightarrow> partition p t = (l',r')\n  \\<Longrightarrow> T_part p t + \\<Phi> l' + \\<Phi> r' - \\<Phi> t \\<le> 2 * log 2 (size1 t) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bst_wrt (\\<le>) t; Splay_Heap.partition p t = (l', r')\\<rbrakk>\n    \\<Longrightarrow> real (T_part p t) + \\<Phi> l' + \\<Phi> r' - \\<Phi> t\n                      \\<le> 2 * \\<phi> t + 1", "proof(induction p t arbitrary: l' r' rule: partition.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p l' r'.\n       \\<lbrakk>bst_wrt (\\<le>) \\<langle>\\<rangle>;\n        Splay_Heap.partition p \\<langle>\\<rangle> = (l', r')\\<rbrakk>\n       \\<Longrightarrow> real (T_part p \\<langle>\\<rangle>) + \\<Phi> l' +\n                         \\<Phi> r' -\n                         \\<Phi> \\<langle>\\<rangle>\n                         \\<le> 2 * \\<phi> \\<langle>\\<rangle> + 1\n 2. \\<And>p al a ar l' r'.\n       \\<lbrakk>\\<And>x21 x22 x23 l' r'.\n                   \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n                    x22 \\<le> p; bst_wrt (\\<le>) x23;\n                    Splay_Heap.partition p x23 = (l', r')\\<rbrakk>\n                   \\<Longrightarrow> real (T_part p x23) + \\<Phi> l' +\n                                     \\<Phi> r' -\n                                     \\<Phi> x23\n                                     \\<le> 2 * \\<phi> x23 + 1;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; bst_wrt (\\<le>) x21;\n            Splay_Heap.partition p x21 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> real (T_part p x21) + \\<Phi> l' + \\<Phi> r' -\n                             \\<Phi> x21\n                             \\<le> 2 * \\<phi> x21 + 1;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            x22 \\<le> p; bst_wrt (\\<le>) x23;\n            Splay_Heap.partition p x23 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> real (T_part p x23) + \\<Phi> l' + \\<Phi> r' -\n                             \\<Phi> x23\n                             \\<le> 2 * \\<phi> x23 + 1;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; bst_wrt (\\<le>) x21;\n            Splay_Heap.partition p x21 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> real (T_part p x21) + \\<Phi> l' + \\<Phi> r' -\n                             \\<Phi> x21\n                             \\<le> 2 * \\<phi> x21 + 1;\n        bst_wrt (\\<le>) \\<langle>al, a, ar\\<rangle>;\n        Splay_Heap.partition p \\<langle>al, a, ar\\<rangle> =\n        (l', r')\\<rbrakk>\n       \\<Longrightarrow> real (T_part p \\<langle>al, a, ar\\<rangle>) +\n                         \\<Phi> l' +\n                         \\<Phi> r' -\n                         \\<Phi> \\<langle>al, a, ar\\<rangle>\n                         \\<le> 2 * \\<phi> \\<langle>al, a, ar\\<rangle> + 1", "case 1"], ["proof (state)\nthis:\n  bst_wrt (\\<le>) \\<langle>\\<rangle>\n  Splay_Heap.partition p_ \\<langle>\\<rangle> = (l', r')\n\ngoal (2 subgoals):\n 1. \\<And>p l' r'.\n       \\<lbrakk>bst_wrt (\\<le>) \\<langle>\\<rangle>;\n        Splay_Heap.partition p \\<langle>\\<rangle> = (l', r')\\<rbrakk>\n       \\<Longrightarrow> real (T_part p \\<langle>\\<rangle>) + \\<Phi> l' +\n                         \\<Phi> r' -\n                         \\<Phi> \\<langle>\\<rangle>\n                         \\<le> 2 * \\<phi> \\<langle>\\<rangle> + 1\n 2. \\<And>p al a ar l' r'.\n       \\<lbrakk>\\<And>x21 x22 x23 l' r'.\n                   \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n                    x22 \\<le> p; bst_wrt (\\<le>) x23;\n                    Splay_Heap.partition p x23 = (l', r')\\<rbrakk>\n                   \\<Longrightarrow> real (T_part p x23) + \\<Phi> l' +\n                                     \\<Phi> r' -\n                                     \\<Phi> x23\n                                     \\<le> 2 * \\<phi> x23 + 1;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; bst_wrt (\\<le>) x21;\n            Splay_Heap.partition p x21 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> real (T_part p x21) + \\<Phi> l' + \\<Phi> r' -\n                             \\<Phi> x21\n                             \\<le> 2 * \\<phi> x21 + 1;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            x22 \\<le> p; bst_wrt (\\<le>) x23;\n            Splay_Heap.partition p x23 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> real (T_part p x23) + \\<Phi> l' + \\<Phi> r' -\n                             \\<Phi> x23\n                             \\<le> 2 * \\<phi> x23 + 1;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; bst_wrt (\\<le>) x21;\n            Splay_Heap.partition p x21 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> real (T_part p x21) + \\<Phi> l' + \\<Phi> r' -\n                             \\<Phi> x21\n                             \\<le> 2 * \\<phi> x21 + 1;\n        bst_wrt (\\<le>) \\<langle>al, a, ar\\<rangle>;\n        Splay_Heap.partition p \\<langle>al, a, ar\\<rangle> =\n        (l', r')\\<rbrakk>\n       \\<Longrightarrow> real (T_part p \\<langle>al, a, ar\\<rangle>) +\n                         \\<Phi> l' +\n                         \\<Phi> r' -\n                         \\<Phi> \\<langle>al, a, ar\\<rangle>\n                         \\<le> 2 * \\<phi> \\<langle>al, a, ar\\<rangle> + 1", "thus ?case"], ["proof (prove)\nusing this:\n  bst_wrt (\\<le>) \\<langle>\\<rangle>\n  Splay_Heap.partition p_ \\<langle>\\<rangle> = (l', r')\n\ngoal (1 subgoal):\n 1. real (T_part p_ \\<langle>\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>\\<rangle> + 1", "by simp"], ["proof (state)\nthis:\n  real (T_part p_ \\<langle>\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n  \\<Phi> \\<langle>\\<rangle>\n  \\<le> 2 * \\<phi> \\<langle>\\<rangle> + 1\n\ngoal (1 subgoal):\n 1. \\<And>p al a ar l' r'.\n       \\<lbrakk>\\<And>x21 x22 x23 l' r'.\n                   \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n                    x22 \\<le> p; bst_wrt (\\<le>) x23;\n                    Splay_Heap.partition p x23 = (l', r')\\<rbrakk>\n                   \\<Longrightarrow> real (T_part p x23) + \\<Phi> l' +\n                                     \\<Phi> r' -\n                                     \\<Phi> x23\n                                     \\<le> 2 * \\<phi> x23 + 1;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; bst_wrt (\\<le>) x21;\n            Splay_Heap.partition p x21 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> real (T_part p x21) + \\<Phi> l' + \\<Phi> r' -\n                             \\<Phi> x21\n                             \\<le> 2 * \\<phi> x21 + 1;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            x22 \\<le> p; bst_wrt (\\<le>) x23;\n            Splay_Heap.partition p x23 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> real (T_part p x23) + \\<Phi> l' + \\<Phi> r' -\n                             \\<Phi> x23\n                             \\<le> 2 * \\<phi> x23 + 1;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; bst_wrt (\\<le>) x21;\n            Splay_Heap.partition p x21 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> real (T_part p x21) + \\<Phi> l' + \\<Phi> r' -\n                             \\<Phi> x21\n                             \\<le> 2 * \\<phi> x21 + 1;\n        bst_wrt (\\<le>) \\<langle>al, a, ar\\<rangle>;\n        Splay_Heap.partition p \\<langle>al, a, ar\\<rangle> =\n        (l', r')\\<rbrakk>\n       \\<Longrightarrow> real (T_part p \\<langle>al, a, ar\\<rangle>) +\n                         \\<Phi> l' +\n                         \\<Phi> r' -\n                         \\<Phi> \\<langle>al, a, ar\\<rangle>\n                         \\<le> 2 * \\<phi> \\<langle>al, a, ar\\<rangle> + 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p al a ar l' r'.\n       \\<lbrakk>\\<And>x21 x22 x23 l' r'.\n                   \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n                    x22 \\<le> p; bst_wrt (\\<le>) x23;\n                    Splay_Heap.partition p x23 = (l', r')\\<rbrakk>\n                   \\<Longrightarrow> real (T_part p x23) + \\<Phi> l' +\n                                     \\<Phi> r' -\n                                     \\<Phi> x23\n                                     \\<le> 2 * \\<phi> x23 + 1;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; bst_wrt (\\<le>) x21;\n            Splay_Heap.partition p x21 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> real (T_part p x21) + \\<Phi> l' + \\<Phi> r' -\n                             \\<Phi> x21\n                             \\<le> 2 * \\<phi> x21 + 1;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            x22 \\<le> p; bst_wrt (\\<le>) x23;\n            Splay_Heap.partition p x23 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> real (T_part p x23) + \\<Phi> l' + \\<Phi> r' -\n                             \\<Phi> x23\n                             \\<le> 2 * \\<phi> x23 + 1;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; bst_wrt (\\<le>) x21;\n            Splay_Heap.partition p x21 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> real (T_part p x21) + \\<Phi> l' + \\<Phi> r' -\n                             \\<Phi> x21\n                             \\<le> 2 * \\<phi> x21 + 1;\n        bst_wrt (\\<le>) \\<langle>al, a, ar\\<rangle>;\n        Splay_Heap.partition p \\<langle>al, a, ar\\<rangle> =\n        (l', r')\\<rbrakk>\n       \\<Longrightarrow> real (T_part p \\<langle>al, a, ar\\<rangle>) +\n                         \\<Phi> l' +\n                         \\<Phi> r' -\n                         \\<Phi> \\<langle>al, a, ar\\<rangle>\n                         \\<le> 2 * \\<phi> \\<langle>al, a, ar\\<rangle> + 1", "case (2 p l a r)"], ["proof (state)\nthis:\n  \\<lbrakk>a \\<le> p; r = \\<langle>?x21.0, ?x22.0, ?x23.0\\<rangle>;\n   ?x22.0 \\<le> p; bst_wrt (\\<le>) ?x23.0;\n   Splay_Heap.partition p ?x23.0 = (?l', ?r')\\<rbrakk>\n  \\<Longrightarrow> real (T_part p ?x23.0) + \\<Phi> ?l' + \\<Phi> ?r' -\n                    \\<Phi> ?x23.0\n                    \\<le> 2 * \\<phi> ?x23.0 + 1\n  \\<lbrakk>a \\<le> p; r = \\<langle>?x21.0, ?x22.0, ?x23.0\\<rangle>;\n   \\<not> ?x22.0 \\<le> p; bst_wrt (\\<le>) ?x21.0;\n   Splay_Heap.partition p ?x21.0 = (?l', ?r')\\<rbrakk>\n  \\<Longrightarrow> real (T_part p ?x21.0) + \\<Phi> ?l' + \\<Phi> ?r' -\n                    \\<Phi> ?x21.0\n                    \\<le> 2 * \\<phi> ?x21.0 + 1\n  \\<lbrakk>\\<not> a \\<le> p; l = \\<langle>?x21.0, ?x22.0, ?x23.0\\<rangle>;\n   ?x22.0 \\<le> p; bst_wrt (\\<le>) ?x23.0;\n   Splay_Heap.partition p ?x23.0 = (?l', ?r')\\<rbrakk>\n  \\<Longrightarrow> real (T_part p ?x23.0) + \\<Phi> ?l' + \\<Phi> ?r' -\n                    \\<Phi> ?x23.0\n                    \\<le> 2 * \\<phi> ?x23.0 + 1\n  \\<lbrakk>\\<not> a \\<le> p; l = \\<langle>?x21.0, ?x22.0, ?x23.0\\<rangle>;\n   \\<not> ?x22.0 \\<le> p; bst_wrt (\\<le>) ?x21.0;\n   Splay_Heap.partition p ?x21.0 = (?l', ?r')\\<rbrakk>\n  \\<Longrightarrow> real (T_part p ?x21.0) + \\<Phi> ?l' + \\<Phi> ?r' -\n                    \\<Phi> ?x21.0\n                    \\<le> 2 * \\<phi> ?x21.0 + 1\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  Splay_Heap.partition p \\<langle>l, a, r\\<rangle> = (l', r')\n\ngoal (1 subgoal):\n 1. \\<And>p al a ar l' r'.\n       \\<lbrakk>\\<And>x21 x22 x23 l' r'.\n                   \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n                    x22 \\<le> p; bst_wrt (\\<le>) x23;\n                    Splay_Heap.partition p x23 = (l', r')\\<rbrakk>\n                   \\<Longrightarrow> real (T_part p x23) + \\<Phi> l' +\n                                     \\<Phi> r' -\n                                     \\<Phi> x23\n                                     \\<le> 2 * \\<phi> x23 + 1;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>a \\<le> p; ar = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; bst_wrt (\\<le>) x21;\n            Splay_Heap.partition p x21 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> real (T_part p x21) + \\<Phi> l' + \\<Phi> r' -\n                             \\<Phi> x21\n                             \\<le> 2 * \\<phi> x21 + 1;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            x22 \\<le> p; bst_wrt (\\<le>) x23;\n            Splay_Heap.partition p x23 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> real (T_part p x23) + \\<Phi> l' + \\<Phi> r' -\n                             \\<Phi> x23\n                             \\<le> 2 * \\<phi> x23 + 1;\n        \\<And>x21 x22 x23 l' r'.\n           \\<lbrakk>\\<not> a \\<le> p; al = \\<langle>x21, x22, x23\\<rangle>;\n            \\<not> x22 \\<le> p; bst_wrt (\\<le>) x21;\n            Splay_Heap.partition p x21 = (l', r')\\<rbrakk>\n           \\<Longrightarrow> real (T_part p x21) + \\<Phi> l' + \\<Phi> r' -\n                             \\<Phi> x21\n                             \\<le> 2 * \\<phi> x21 + 1;\n        bst_wrt (\\<le>) \\<langle>al, a, ar\\<rangle>;\n        Splay_Heap.partition p \\<langle>al, a, ar\\<rangle> =\n        (l', r')\\<rbrakk>\n       \\<Longrightarrow> real (T_part p \\<langle>al, a, ar\\<rangle>) +\n                         \\<Phi> l' +\n                         \\<Phi> r' -\n                         \\<Phi> \\<langle>al, a, ar\\<rangle>\n                         \\<le> 2 * \\<phi> \\<langle>al, a, ar\\<rangle> + 1", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1\n 2. \\<not> ?P \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "assume \"a \\<le> p\""], ["proof (state)\nthis:\n  a \\<le> p\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1\n 2. \\<not> ?P \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "proof (cases r)"], ["proof (state)\ngoal (2 subgoals):\n 1. r = \\<langle>\\<rangle> \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1\n 2. \\<And>x21 x22 x23.\n       r = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n       \\<Phi> \\<langle>l, a, r\\<rangle>\n       \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "case Leaf"], ["proof (state)\nthis:\n  r = \\<langle>\\<rangle>\n\ngoal (2 subgoals):\n 1. r = \\<langle>\\<rangle> \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1\n 2. \\<And>x21 x22 x23.\n       r = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n       \\<Phi> \\<langle>l, a, r\\<rangle>\n       \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  r = \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "using \\<open>a \\<le> p\\<close> \"2.prems\""], ["proof (prove)\nusing this:\n  r = \\<langle>\\<rangle>\n  a \\<le> p\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  Splay_Heap.partition p \\<langle>l, a, r\\<rangle> = (l', r')\n\ngoal (1 subgoal):\n 1. real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "by fastforce"], ["proof (state)\nthis:\n  real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n  \\<Phi> \\<langle>l, a, r\\<rangle>\n  \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       r = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n       \\<Phi> \\<langle>l, a, r\\<rangle>\n       \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       r = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n       \\<Phi> \\<langle>l, a, r\\<rangle>\n       \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "case [simp]: (Node rl b rr)"], ["proof (state)\nthis:\n  r = \\<langle>rl, b, rr\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       r = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n       \\<Phi> \\<langle>l, a, r\\<rangle>\n       \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "let ?t = \"Node l a r\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       r = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n       \\<Phi> \\<langle>l, a, r\\<rangle>\n       \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1\n 2. \\<not> ?P \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "assume \"b \\<le> p\""], ["proof (state)\nthis:\n  b \\<le> p\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1\n 2. \\<not> ?P \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "with \\<open>a \\<le> p\\<close> \"2.prems\""], ["proof (chain)\npicking this:\n  a \\<le> p\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  Splay_Heap.partition p \\<langle>l, a, r\\<rangle> = (l', r')\n  b \\<le> p", "obtain rrl\n          where 0: \"partition p rr = (rrl, r')\" \"l' = Node (Node l a rl) b rrl\""], ["proof (prove)\nusing this:\n  a \\<le> p\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  Splay_Heap.partition p \\<langle>l, a, r\\<rangle> = (l', r')\n  b \\<le> p\n\ngoal (1 subgoal):\n 1. (\\<And>rrl.\n        \\<lbrakk>Splay_Heap.partition p rr = (rrl, r');\n         l' = \\<langle>\\<langle>l, a, rl\\<rangle>, b, rrl\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto split: tree.splits prod.splits)"], ["proof (state)\nthis:\n  Splay_Heap.partition p rr = (rrl, r')\n  l' = \\<langle>\\<langle>l, a, rl\\<rangle>, b, rrl\\<rangle>\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1\n 2. \\<not> ?P \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "have \"size rrl \\<le> size rr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size rrl \\<le> size rr", "using size_partition[OF 0(1)]"], ["proof (prove)\nusing this:\n  size rr = size rrl + size r'\n\ngoal (1 subgoal):\n 1. size rrl \\<le> size rr", "by (simp add: size1_size)"], ["proof (state)\nthis:\n  size rrl \\<le> size rr\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1\n 2. \\<not> ?P \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "with 0 \\<open>a \\<le> p\\<close> \\<open>b \\<le> p\\<close> \"2.prems\"(1) \"2.IH\"(1)[OF _ Node , of rrl r']\n          zig_zig[where s=l and u=rl and r=rr and r1'=rrl and r2'=r' and p=p, of a b]"], ["proof (chain)\npicking this:\n  Splay_Heap.partition p rr = (rrl, r')\n  l' = \\<langle>\\<langle>l, a, rl\\<rangle>, b, rrl\\<rangle>\n  a \\<le> p\n  b \\<le> p\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  \\<lbrakk>a \\<le> p; b \\<le> p; bst_wrt (\\<le>) rr;\n   Splay_Heap.partition p rr = (rrl, r')\\<rbrakk>\n  \\<Longrightarrow> real (T_part p rr) + \\<Phi> rrl + \\<Phi> r' - \\<Phi> rr\n                    \\<le> 2 * \\<phi> rr + 1\n  \\<lbrakk>size rrl \\<le> size rr;\n   real (T_part p rr) + \\<Phi> rrl + \\<Phi> r' - \\<Phi> rr\n   \\<le> 2 * \\<phi> rr + 1\\<rbrakk>\n  \\<Longrightarrow> real (T_part p rr + 1) +\n                    \\<Phi>\n                     \\<langle>\\<langle>l, a, rl\\<rangle>, b, rrl\\<rangle> +\n                    \\<Phi> r' -\n                    \\<Phi>\n                     \\<langle>l, a, \\<langle>rl, b, rr\\<rangle>\\<rangle>\n                    \\<le> 2 *\n                          \\<phi>\n                           \\<langle>l, a,\n                            \\<langle>rl, b, rr\\<rangle>\\<rangle> +\n                          1\n  size rrl \\<le> size rr", "show ?thesis"], ["proof (prove)\nusing this:\n  Splay_Heap.partition p rr = (rrl, r')\n  l' = \\<langle>\\<langle>l, a, rl\\<rangle>, b, rrl\\<rangle>\n  a \\<le> p\n  b \\<le> p\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  \\<lbrakk>a \\<le> p; b \\<le> p; bst_wrt (\\<le>) rr;\n   Splay_Heap.partition p rr = (rrl, r')\\<rbrakk>\n  \\<Longrightarrow> real (T_part p rr) + \\<Phi> rrl + \\<Phi> r' - \\<Phi> rr\n                    \\<le> 2 * \\<phi> rr + 1\n  \\<lbrakk>size rrl \\<le> size rr;\n   real (T_part p rr) + \\<Phi> rrl + \\<Phi> r' - \\<Phi> rr\n   \\<le> 2 * \\<phi> rr + 1\\<rbrakk>\n  \\<Longrightarrow> real (T_part p rr + 1) +\n                    \\<Phi>\n                     \\<langle>\\<langle>l, a, rl\\<rangle>, b, rrl\\<rangle> +\n                    \\<Phi> r' -\n                    \\<Phi>\n                     \\<langle>l, a, \\<langle>rl, b, rr\\<rangle>\\<rangle>\n                    \\<le> 2 *\n                          \\<phi>\n                           \\<langle>l, a,\n                            \\<langle>rl, b, rr\\<rangle>\\<rangle> +\n                          1\n  size rrl \\<le> size rr\n\ngoal (1 subgoal):\n 1. real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n  \\<Phi> \\<langle>l, a, r\\<rangle>\n  \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1\n\ngoal (1 subgoal):\n 1. \\<not> b \\<le> p \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> b \\<le> p \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "assume \"\\<not> b \\<le> p\""], ["proof (state)\nthis:\n  \\<not> b \\<le> p\n\ngoal (1 subgoal):\n 1. \\<not> b \\<le> p \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "with \\<open>a \\<le> p\\<close> \"2.prems\""], ["proof (chain)\npicking this:\n  a \\<le> p\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  Splay_Heap.partition p \\<langle>l, a, r\\<rangle> = (l', r')\n  \\<not> b \\<le> p", "obtain rll rlr \n          where 0: \"partition p rl = (rll, rlr)\" \"l' = Node l a rll\" \"r' = Node rlr b rr\""], ["proof (prove)\nusing this:\n  a \\<le> p\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  Splay_Heap.partition p \\<langle>l, a, r\\<rangle> = (l', r')\n  \\<not> b \\<le> p\n\ngoal (1 subgoal):\n 1. (\\<And>rll rlr.\n        \\<lbrakk>Splay_Heap.partition p rl = (rll, rlr);\n         l' = \\<langle>l, a, rll\\<rangle>;\n         r' = \\<langle>rlr, b, rr\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto split: tree.splits prod.splits)"], ["proof (state)\nthis:\n  Splay_Heap.partition p rl = (rll, rlr)\n  l' = \\<langle>l, a, rll\\<rangle>\n  r' = \\<langle>rlr, b, rr\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> b \\<le> p \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "from 0 \\<open>a \\<le> p\\<close> \\<open>\\<not> b \\<le> p\\<close> \"2.prems\"(1) \"2.IH\"(2)[OF _ Node, of rll rlr]\n          size_partition[OF 0(1)]\n          zig_zag[where s=l and u=rr and r=rl and r1'=rll and r2'=rlr and p=p, of a b]"], ["proof (chain)\npicking this:\n  Splay_Heap.partition p rl = (rll, rlr)\n  l' = \\<langle>l, a, rll\\<rangle>\n  r' = \\<langle>rlr, b, rr\\<rangle>\n  a \\<le> p\n  \\<not> b \\<le> p\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  \\<lbrakk>a \\<le> p; \\<not> b \\<le> p; bst_wrt (\\<le>) rl;\n   Splay_Heap.partition p rl = (rll, rlr)\\<rbrakk>\n  \\<Longrightarrow> real (T_part p rl) + \\<Phi> rll + \\<Phi> rlr - \\<Phi> rl\n                    \\<le> 2 * \\<phi> rl + 1\n  size rl = size rll + size rlr\n  \\<lbrakk>size rl = size rll + size rlr;\n   real (T_part p rl) + \\<Phi> rll + \\<Phi> rlr - \\<Phi> rl\n   \\<le> 2 * \\<phi> rl + 1\\<rbrakk>\n  \\<Longrightarrow> real (T_part p rl + 1) +\n                    \\<Phi> \\<langle>l, a, rll\\<rangle> +\n                    \\<Phi> \\<langle>rr, b, rlr\\<rangle> -\n                    \\<Phi>\n                     \\<langle>l, a, \\<langle>rl, b, rr\\<rangle>\\<rangle>\n                    \\<le> 2 *\n                          \\<phi>\n                           \\<langle>l, a,\n                            \\<langle>rl, b, rr\\<rangle>\\<rangle> +\n                          1", "show ?thesis"], ["proof (prove)\nusing this:\n  Splay_Heap.partition p rl = (rll, rlr)\n  l' = \\<langle>l, a, rll\\<rangle>\n  r' = \\<langle>rlr, b, rr\\<rangle>\n  a \\<le> p\n  \\<not> b \\<le> p\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  \\<lbrakk>a \\<le> p; \\<not> b \\<le> p; bst_wrt (\\<le>) rl;\n   Splay_Heap.partition p rl = (rll, rlr)\\<rbrakk>\n  \\<Longrightarrow> real (T_part p rl) + \\<Phi> rll + \\<Phi> rlr - \\<Phi> rl\n                    \\<le> 2 * \\<phi> rl + 1\n  size rl = size rll + size rlr\n  \\<lbrakk>size rl = size rll + size rlr;\n   real (T_part p rl) + \\<Phi> rll + \\<Phi> rlr - \\<Phi> rl\n   \\<le> 2 * \\<phi> rl + 1\\<rbrakk>\n  \\<Longrightarrow> real (T_part p rl + 1) +\n                    \\<Phi> \\<langle>l, a, rll\\<rangle> +\n                    \\<Phi> \\<langle>rr, b, rlr\\<rangle> -\n                    \\<Phi>\n                     \\<langle>l, a, \\<langle>rl, b, rr\\<rangle>\\<rangle>\n                    \\<le> 2 *\n                          \\<phi>\n                           \\<langle>l, a,\n                            \\<langle>rl, b, rr\\<rangle>\\<rangle> +\n                          1\n\ngoal (1 subgoal):\n 1. real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n  \\<Phi> \\<langle>l, a, r\\<rangle>\n  \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n  \\<Phi> \\<langle>l, a, r\\<rangle>\n  \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n  \\<Phi> \\<langle>l, a, r\\<rangle>\n  \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> p \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> a \\<le> p \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "assume \"\\<not> a \\<le> p\""], ["proof (state)\nthis:\n  \\<not> a \\<le> p\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> p \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "proof (cases l)"], ["proof (state)\ngoal (2 subgoals):\n 1. l = \\<langle>\\<rangle> \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1\n 2. \\<And>x21 x22 x23.\n       l = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n       \\<Phi> \\<langle>l, a, r\\<rangle>\n       \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "case Leaf"], ["proof (state)\nthis:\n  l = \\<langle>\\<rangle>\n\ngoal (2 subgoals):\n 1. l = \\<langle>\\<rangle> \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1\n 2. \\<And>x21 x22 x23.\n       l = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n       \\<Phi> \\<langle>l, a, r\\<rangle>\n       \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "thus ?thesis"], ["proof (prove)\nusing this:\n  l = \\<langle>\\<rangle>\n\ngoal (1 subgoal):\n 1. real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "using \\<open>\\<not> a \\<le> p\\<close> \"2.prems\""], ["proof (prove)\nusing this:\n  l = \\<langle>\\<rangle>\n  \\<not> a \\<le> p\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  Splay_Heap.partition p \\<langle>l, a, r\\<rangle> = (l', r')\n\ngoal (1 subgoal):\n 1. real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "by fastforce"], ["proof (state)\nthis:\n  real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n  \\<Phi> \\<langle>l, a, r\\<rangle>\n  \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       l = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n       \\<Phi> \\<langle>l, a, r\\<rangle>\n       \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       l = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n       \\<Phi> \\<langle>l, a, r\\<rangle>\n       \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "case [simp]: (Node ll b lr)"], ["proof (state)\nthis:\n  l = \\<langle>ll, b, lr\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       l = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n       \\<Phi> \\<langle>l, a, r\\<rangle>\n       \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "let ?t = \"Node l a r\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       l = \\<langle>x21, x22, x23\\<rangle> \\<Longrightarrow>\n       real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n       \\<Phi> \\<langle>l, a, r\\<rangle>\n       \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1\n 2. \\<not> ?P \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "assume \"b \\<le> p\""], ["proof (state)\nthis:\n  b \\<le> p\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1\n 2. \\<not> ?P \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "with \\<open>\\<not> a \\<le> p\\<close> \"2.prems\""], ["proof (chain)\npicking this:\n  \\<not> a \\<le> p\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  Splay_Heap.partition p \\<langle>l, a, r\\<rangle> = (l', r')\n  b \\<le> p", "obtain lrl lrr \n          where 0: \"partition p lr = (lrl, lrr)\" \"l' = Node ll b lrl\" \"r' = Node lrr a r\""], ["proof (prove)\nusing this:\n  \\<not> a \\<le> p\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  Splay_Heap.partition p \\<langle>l, a, r\\<rangle> = (l', r')\n  b \\<le> p\n\ngoal (1 subgoal):\n 1. (\\<And>lrl lrr.\n        \\<lbrakk>Splay_Heap.partition p lr = (lrl, lrr);\n         l' = \\<langle>ll, b, lrl\\<rangle>;\n         r' = \\<langle>lrr, a, r\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto split: tree.splits prod.splits)"], ["proof (state)\nthis:\n  Splay_Heap.partition p lr = (lrl, lrr)\n  l' = \\<langle>ll, b, lrl\\<rangle>\n  r' = \\<langle>lrr, a, r\\<rangle>\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1\n 2. \\<not> ?P \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "from 0 \\<open>\\<not> a \\<le> p\\<close> \\<open>b \\<le> p\\<close> \"2.prems\"(1) \"2.IH\"(3)[OF _ Node, of lrl lrr]\n          size_partition[OF 0(1)]\n          zig_zag[where s=r and u=ll and r=lr and r1'=lrr and r2'=lrl and p=p, of a b]"], ["proof (chain)\npicking this:\n  Splay_Heap.partition p lr = (lrl, lrr)\n  l' = \\<langle>ll, b, lrl\\<rangle>\n  r' = \\<langle>lrr, a, r\\<rangle>\n  \\<not> a \\<le> p\n  b \\<le> p\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  \\<lbrakk>\\<not> a \\<le> p; b \\<le> p; bst_wrt (\\<le>) lr;\n   Splay_Heap.partition p lr = (lrl, lrr)\\<rbrakk>\n  \\<Longrightarrow> real (T_part p lr) + \\<Phi> lrl + \\<Phi> lrr - \\<Phi> lr\n                    \\<le> 2 * \\<phi> lr + 1\n  size lr = size lrl + size lrr\n  \\<lbrakk>size lr = size lrr + size lrl;\n   real (T_part p lr) + \\<Phi> lrr + \\<Phi> lrl - \\<Phi> lr\n   \\<le> 2 * \\<phi> lr + 1\\<rbrakk>\n  \\<Longrightarrow> real (T_part p lr + 1) +\n                    \\<Phi> \\<langle>r, a, lrr\\<rangle> +\n                    \\<Phi> \\<langle>ll, b, lrl\\<rangle> -\n                    \\<Phi>\n                     \\<langle>r, a, \\<langle>lr, b, ll\\<rangle>\\<rangle>\n                    \\<le> 2 *\n                          \\<phi>\n                           \\<langle>r, a,\n                            \\<langle>lr, b, ll\\<rangle>\\<rangle> +\n                          1", "show ?thesis"], ["proof (prove)\nusing this:\n  Splay_Heap.partition p lr = (lrl, lrr)\n  l' = \\<langle>ll, b, lrl\\<rangle>\n  r' = \\<langle>lrr, a, r\\<rangle>\n  \\<not> a \\<le> p\n  b \\<le> p\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  \\<lbrakk>\\<not> a \\<le> p; b \\<le> p; bst_wrt (\\<le>) lr;\n   Splay_Heap.partition p lr = (lrl, lrr)\\<rbrakk>\n  \\<Longrightarrow> real (T_part p lr) + \\<Phi> lrl + \\<Phi> lrr - \\<Phi> lr\n                    \\<le> 2 * \\<phi> lr + 1\n  size lr = size lrl + size lrr\n  \\<lbrakk>size lr = size lrr + size lrl;\n   real (T_part p lr) + \\<Phi> lrr + \\<Phi> lrl - \\<Phi> lr\n   \\<le> 2 * \\<phi> lr + 1\\<rbrakk>\n  \\<Longrightarrow> real (T_part p lr + 1) +\n                    \\<Phi> \\<langle>r, a, lrr\\<rangle> +\n                    \\<Phi> \\<langle>ll, b, lrl\\<rangle> -\n                    \\<Phi>\n                     \\<langle>r, a, \\<langle>lr, b, ll\\<rangle>\\<rangle>\n                    \\<le> 2 *\n                          \\<phi>\n                           \\<langle>r, a,\n                            \\<langle>lr, b, ll\\<rangle>\\<rangle> +\n                          1\n\ngoal (1 subgoal):\n 1. real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "by (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n  \\<Phi> \\<langle>l, a, r\\<rangle>\n  \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1\n\ngoal (1 subgoal):\n 1. \\<not> b \\<le> p \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> b \\<le> p \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "assume \"\\<not> b \\<le> p\""], ["proof (state)\nthis:\n  \\<not> b \\<le> p\n\ngoal (1 subgoal):\n 1. \\<not> b \\<le> p \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "with \\<open>\\<not> a \\<le> p\\<close> \"2.prems\""], ["proof (chain)\npicking this:\n  \\<not> a \\<le> p\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  Splay_Heap.partition p \\<langle>l, a, r\\<rangle> = (l', r')\n  \\<not> b \\<le> p", "obtain llr\n          where 0: \"partition p ll = (l',llr)\" \"r' = Node llr b (Node lr a r)\""], ["proof (prove)\nusing this:\n  \\<not> a \\<le> p\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  Splay_Heap.partition p \\<langle>l, a, r\\<rangle> = (l', r')\n  \\<not> b \\<le> p\n\ngoal (1 subgoal):\n 1. (\\<And>llr.\n        \\<lbrakk>Splay_Heap.partition p ll = (l', llr);\n         r' = \\<langle>llr, b, \\<langle>lr, a, r\\<rangle>\\<rangle>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto split: tree.splits prod.splits)"], ["proof (state)\nthis:\n  Splay_Heap.partition p ll = (l', llr)\n  r' = \\<langle>llr, b, \\<langle>lr, a, r\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> b \\<le> p \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "have \"size llr \\<le> size ll\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size llr \\<le> size ll", "using size_partition[OF 0(1)]"], ["proof (prove)\nusing this:\n  size ll = size l' + size llr\n\ngoal (1 subgoal):\n 1. size llr \\<le> size ll", "by (simp add: size1_size)"], ["proof (state)\nthis:\n  size llr \\<le> size ll\n\ngoal (1 subgoal):\n 1. \\<not> b \\<le> p \\<Longrightarrow>\n    real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "with 0 \\<open>\\<not> a \\<le> p\\<close> \\<open>\\<not> b \\<le> p\\<close> \"2.prems\"(1) \"2.IH\"(4)[OF _ Node, of l' llr]\n          zig_zig[where s=r and u=lr and r=ll and r1'=llr and r2'=l' and p=p, of a b]"], ["proof (chain)\npicking this:\n  Splay_Heap.partition p ll = (l', llr)\n  r' = \\<langle>llr, b, \\<langle>lr, a, r\\<rangle>\\<rangle>\n  \\<not> a \\<le> p\n  \\<not> b \\<le> p\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  \\<lbrakk>\\<not> a \\<le> p; \\<not> b \\<le> p; bst_wrt (\\<le>) ll;\n   Splay_Heap.partition p ll = (l', llr)\\<rbrakk>\n  \\<Longrightarrow> real (T_part p ll) + \\<Phi> l' + \\<Phi> llr - \\<Phi> ll\n                    \\<le> 2 * \\<phi> ll + 1\n  \\<lbrakk>size llr \\<le> size ll;\n   real (T_part p ll) + \\<Phi> llr + \\<Phi> l' - \\<Phi> ll\n   \\<le> 2 * \\<phi> ll + 1\\<rbrakk>\n  \\<Longrightarrow> real (T_part p ll + 1) +\n                    \\<Phi>\n                     \\<langle>\\<langle>r, a, lr\\<rangle>, b, llr\\<rangle> +\n                    \\<Phi> l' -\n                    \\<Phi>\n                     \\<langle>r, a, \\<langle>lr, b, ll\\<rangle>\\<rangle>\n                    \\<le> 2 *\n                          \\<phi>\n                           \\<langle>r, a,\n                            \\<langle>lr, b, ll\\<rangle>\\<rangle> +\n                          1\n  size llr \\<le> size ll", "show ?thesis"], ["proof (prove)\nusing this:\n  Splay_Heap.partition p ll = (l', llr)\n  r' = \\<langle>llr, b, \\<langle>lr, a, r\\<rangle>\\<rangle>\n  \\<not> a \\<le> p\n  \\<not> b \\<le> p\n  bst_wrt (\\<le>) \\<langle>l, a, r\\<rangle>\n  \\<lbrakk>\\<not> a \\<le> p; \\<not> b \\<le> p; bst_wrt (\\<le>) ll;\n   Splay_Heap.partition p ll = (l', llr)\\<rbrakk>\n  \\<Longrightarrow> real (T_part p ll) + \\<Phi> l' + \\<Phi> llr - \\<Phi> ll\n                    \\<le> 2 * \\<phi> ll + 1\n  \\<lbrakk>size llr \\<le> size ll;\n   real (T_part p ll) + \\<Phi> llr + \\<Phi> l' - \\<Phi> ll\n   \\<le> 2 * \\<phi> ll + 1\\<rbrakk>\n  \\<Longrightarrow> real (T_part p ll + 1) +\n                    \\<Phi>\n                     \\<langle>\\<langle>r, a, lr\\<rangle>, b, llr\\<rangle> +\n                    \\<Phi> l' -\n                    \\<Phi>\n                     \\<langle>r, a, \\<langle>lr, b, ll\\<rangle>\\<rangle>\n                    \\<le> 2 *\n                          \\<phi>\n                           \\<langle>r, a,\n                            \\<langle>lr, b, ll\\<rangle>\\<rangle> +\n                          1\n  size llr \\<le> size ll\n\ngoal (1 subgoal):\n 1. real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n    \\<Phi> \\<langle>l, a, r\\<rangle>\n    \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1", "by (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n  \\<Phi> \\<langle>l, a, r\\<rangle>\n  \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n  \\<Phi> \\<langle>l, a, r\\<rangle>\n  \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n  \\<Phi> \\<langle>l, a, r\\<rangle>\n  \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real (T_part p \\<langle>l, a, r\\<rangle>) + \\<Phi> l' + \\<Phi> r' -\n  \\<Phi> \\<langle>l, a, r\\<rangle>\n  \\<le> 2 * \\<phi> \\<langle>l, a, r\\<rangle> + 1\n\ngoal:\nNo subgoals!", "qed"], ["", "fun exec :: \"'a::linorder op \\<Rightarrow> 'a tree list \\<Rightarrow> 'a tree\" where\n\"exec Empty [] = Leaf\" |\n\"exec (Insert a) [t] = insert a t\" |\n\"exec Del_min [t] = del_min t\""], ["", "fun cost :: \"'a::linorder op \\<Rightarrow> 'a tree list \\<Rightarrow> nat\" where\n\"cost Empty [] = 1\" |\n\"cost (Insert a) [t] = T_in a t\" |\n\"cost Del_min [t] = T_dm t\""], ["", "fun U where\n\"U Empty [] = 1\" |\n\"U (Insert _) [t] = 3 * log 2 (size1 t + 1) + 1\" |\n\"U Del_min [t] = 2 * \\<phi> t + 1\""], ["", "interpretation Amortized\nwhere arity = arity and exec = exec and inv = \"bst_wrt (\\<le>)\"\nand cost = cost and \\<Phi> = \\<Phi> and U = U"], ["proof (prove)\ngoal (1 subgoal):\n 1. Amortized arity exec (bst_wrt (\\<le>)) cost \\<Phi> U", "proof (standard, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. bst_wrt (\\<le>) s;\n        length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> bst_wrt (\\<le>) (exec f ss)\n 2. \\<And>s. bst_wrt (\\<le>) s \\<Longrightarrow> 0 \\<le> \\<Phi> s\n 3. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. bst_wrt (\\<le>) s;\n        length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) + \\<Phi> (exec f ss) -\n                         sum_list (map \\<Phi> ss)\n                         \\<le> U f ss", "case (1 _ f)"], ["proof (state)\nthis:\n  \\<forall>s\\<in>set ss_. bst_wrt (\\<le>) s\n  length ss_ = arity f\n\ngoal (3 subgoals):\n 1. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. bst_wrt (\\<le>) s;\n        length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> bst_wrt (\\<le>) (exec f ss)\n 2. \\<And>s. bst_wrt (\\<le>) s \\<Longrightarrow> 0 \\<le> \\<Phi> s\n 3. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. bst_wrt (\\<le>) s;\n        length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) + \\<Phi> (exec f ss) -\n                         sum_list (map \\<Phi> ss)\n                         \\<le> U f ss", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>set ss_. bst_wrt (\\<le>) s\n  length ss_ = arity f\n\ngoal (1 subgoal):\n 1. bst_wrt (\\<le>) (exec f ss_)", "by(cases f)\n       (auto simp: insert_def bst_del_min dest!: bst_partition split: prod.splits)"], ["proof (state)\nthis:\n  bst_wrt (\\<le>) (exec f ss_)\n\ngoal (2 subgoals):\n 1. \\<And>s. bst_wrt (\\<le>) s \\<Longrightarrow> 0 \\<le> \\<Phi> s\n 2. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. bst_wrt (\\<le>) s;\n        length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) + \\<Phi> (exec f ss) -\n                         sum_list (map \\<Phi> ss)\n                         \\<le> U f ss", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. bst_wrt (\\<le>) s \\<Longrightarrow> 0 \\<le> \\<Phi> s\n 2. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. bst_wrt (\\<le>) s;\n        length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) + \\<Phi> (exec f ss) -\n                         sum_list (map \\<Phi> ss)\n                         \\<le> U f ss", "case (2 h)"], ["proof (state)\nthis:\n  bst_wrt (\\<le>) h\n\ngoal (2 subgoals):\n 1. \\<And>s. bst_wrt (\\<le>) s \\<Longrightarrow> 0 \\<le> \\<Phi> s\n 2. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. bst_wrt (\\<le>) s;\n        length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) + \\<Phi> (exec f ss) -\n                         sum_list (map \\<Phi> ss)\n                         \\<le> U f ss", "thus ?case"], ["proof (prove)\nusing this:\n  bst_wrt (\\<le>) h\n\ngoal (1 subgoal):\n 1. 0 \\<le> \\<Phi> h", "by(induction h) (auto simp: size1_size)"], ["proof (state)\nthis:\n  0 \\<le> \\<Phi> h\n\ngoal (1 subgoal):\n 1. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. bst_wrt (\\<le>) s;\n        length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) + \\<Phi> (exec f ss) -\n                         sum_list (map \\<Phi> ss)\n                         \\<le> U f ss", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. bst_wrt (\\<le>) s;\n        length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) + \\<Phi> (exec f ss) -\n                         sum_list (map \\<Phi> ss)\n                         \\<le> U f ss", "case (3 s f)"], ["proof (state)\nthis:\n  \\<forall>s\\<in>set s. bst_wrt (\\<le>) s\n  length s = arity f\n\ngoal (1 subgoal):\n 1. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. bst_wrt (\\<le>) s;\n        length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) + \\<Phi> (exec f ss) -\n                         sum_list (map \\<Phi> ss)\n                         \\<le> U f ss", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s)\n    \\<le> U f s", "proof (cases f)"], ["proof (state)\ngoal (3 subgoals):\n 1. f = Empty \\<Longrightarrow>\n    real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s)\n    \\<le> U f s\n 2. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s)\n       \\<le> U f s\n 3. f = Del_min \\<Longrightarrow>\n    real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s)\n    \\<le> U f s", "case Empty"], ["proof (state)\nthis:\n  f = Empty\n\ngoal (3 subgoals):\n 1. f = Empty \\<Longrightarrow>\n    real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s)\n    \\<le> U f s\n 2. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s)\n       \\<le> U f s\n 3. f = Del_min \\<Longrightarrow>\n    real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s)\n    \\<le> U f s", "with 3"], ["proof (chain)\npicking this:\n  \\<forall>s\\<in>set s. bst_wrt (\\<le>) s\n  length s = arity f\n  f = Empty", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>set s. bst_wrt (\\<le>) s\n  length s = arity f\n  f = Empty\n\ngoal (1 subgoal):\n 1. real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s)\n    \\<le> U f s", "by(auto)"], ["proof (state)\nthis:\n  real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s) \\<le> U f s\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s)\n       \\<le> U f s\n 2. f = Del_min \\<Longrightarrow>\n    real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s)\n    \\<le> U f s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s)\n       \\<le> U f s\n 2. f = Del_min \\<Longrightarrow>\n    real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s)\n    \\<le> U f s", "case Del_min"], ["proof (state)\nthis:\n  f = Del_min\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s)\n       \\<le> U f s\n 2. f = Del_min \\<Longrightarrow>\n    real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s)\n    \\<le> U f s", "with 3"], ["proof (chain)\npicking this:\n  \\<forall>s\\<in>set s. bst_wrt (\\<le>) s\n  length s = arity f\n  f = Del_min", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>set s. bst_wrt (\\<le>) s\n  length s = arity f\n  f = Del_min\n\ngoal (1 subgoal):\n 1. real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s)\n    \\<le> U f s", "by(auto simp: amor_del_min)"], ["proof (state)\nthis:\n  real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s) \\<le> U f s\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s)\n       \\<le> U f s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s)\n       \\<le> U f s", "case [simp]: (Insert x)"], ["proof (state)\nthis:\n  f = Insert x\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s)\n       \\<le> U f s", "then"], ["proof (chain)\npicking this:\n  f = Insert x", "obtain t where [simp]: \"s = [t]\" \"bst_wrt (\\<le>) t\""], ["proof (prove)\nusing this:\n  f = Insert x\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>s = [t]; bst_wrt (\\<le>) t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 3"], ["proof (prove)\nusing this:\n  f = Insert x\n  \\<forall>s\\<in>set s. bst_wrt (\\<le>) s\n  length s = arity f\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>s = [t]; bst_wrt (\\<le>) t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  s = [t]\n  bst_wrt (\\<le>) t\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s)\n       \\<le> U f s", "{"], ["proof (state)\nthis:\n  s = [t]\n  bst_wrt (\\<le>) t\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s)\n       \\<le> U f s", "fix l r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s)\n       \\<le> U f s", "assume 1: \"partition x t = (l,r)\""], ["proof (state)\nthis:\n  Splay_Heap.partition x t = (l, r)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s)\n       \\<le> U f s", "have \"log 2 (1 + size t) < log 2 (2 + size t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real (1 + size t)) < log 2 (real (2 + size t))", "by simp"], ["proof (state)\nthis:\n  log 2 (real (1 + size t)) < log 2 (real (2 + size t))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s)\n       \\<le> U f s", "with 1 amor_partition[OF \\<open>bst_wrt (\\<le>) t\\<close> 1] size_partition[OF 1]"], ["proof (chain)\npicking this:\n  Splay_Heap.partition x t = (l, r)\n  real (T_part x t) + \\<Phi> l + \\<Phi> r - \\<Phi> t \\<le> 2 * \\<phi> t + 1\n  size t = size l + size r\n  log 2 (real (1 + size t)) < log 2 (real (2 + size t))", "have ?thesis"], ["proof (prove)\nusing this:\n  Splay_Heap.partition x t = (l, r)\n  real (T_part x t) + \\<Phi> l + \\<Phi> r - \\<Phi> t \\<le> 2 * \\<phi> t + 1\n  size t = size l + size r\n  log 2 (real (1 + size t)) < log 2 (real (2 + size t))\n\ngoal (1 subgoal):\n 1. real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s)\n    \\<le> U f s", "by(simp add: T_in_def insert_def algebra_simps size1_size\n             del: log_less_cancel_iff)"], ["proof (state)\nthis:\n  real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s) \\<le> U f s\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s)\n       \\<le> U f s", "}"], ["proof (state)\nthis:\n  Splay_Heap.partition x t = (?l2, ?r2) \\<Longrightarrow>\n  real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s) \\<le> U f s\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s)\n       \\<le> U f s", "thus ?thesis"], ["proof (prove)\nusing this:\n  Splay_Heap.partition x t = (?l2, ?r2) \\<Longrightarrow>\n  real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s) \\<le> U f s\n\ngoal (1 subgoal):\n 1. real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s)\n    \\<le> U f s", "by(simp add: insert_def split: prod.split)"], ["proof (state)\nthis:\n  real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s) \\<le> U f s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real (cost f s) + \\<Phi> (exec f s) - sum_list (map \\<Phi> s) \\<le> U f s\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}