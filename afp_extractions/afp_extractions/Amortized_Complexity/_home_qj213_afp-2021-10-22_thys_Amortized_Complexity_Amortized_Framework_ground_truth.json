{"file_name": "/home/qj213/afp-2021-10-22/thys/Amortized_Complexity/Amortized_Framework.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Amortized_Complexity", "problem_names": ["lemma inv_state: \"wf ot \\<Longrightarrow> inv(state ot)\"", "lemma t_sum_a_sum: \"wf ot \\<Longrightarrow> cost_sum ot = acost_sum ot - \\<Phi>(state ot)\"", "lemma a_le_U: \"\\<lbrakk> \\<forall>s \\<in> set ss. inv s; length ss = arity f \\<rbrakk> \\<Longrightarrow> acost f ss \\<le> U f ss\"", "lemma a_sum_le_U_sum: \"wf ot \\<Longrightarrow> acost_sum ot \\<le> U_sum ot\""], "translations": [["", "lemma inv_state: \"wf ot \\<Longrightarrow> inv(state ot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf ot \\<Longrightarrow> inv (state ot)", "by(induction ot)(simp_all add: inv_exec)"], ["", "definition acost :: \"'op \\<Rightarrow> 's list \\<Rightarrow> real\" where\n\"acost f ss = cost f ss + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\""], ["", "fun acost_sum :: \"'op rose_tree \\<Rightarrow> real\" where\n\"acost_sum (T f ts) = acost f (map state ts) + sum_list (map acost_sum ts)\""], ["", "fun cost_sum :: \"'op rose_tree \\<Rightarrow> real\" where\n\"cost_sum (T f ts) = cost f (map state ts) + sum_list (map cost_sum ts)\""], ["", "fun U_sum :: \"'op rose_tree \\<Rightarrow> real\" where\n\"U_sum (T f ts) = U f (map state ts) + sum_list (map U_sum ts)\""], ["", "lemma t_sum_a_sum: \"wf ot \\<Longrightarrow> cost_sum ot = acost_sum ot - \\<Phi>(state ot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf ot \\<Longrightarrow>\n    cost_sum ot = acost_sum ot - \\<Phi> (state ot)", "by (induction ot) (auto simp: acost_def Let_def sum_list_subtractf cong: map_cong)"], ["", "corollary t_sum_le_a_sum: \"wf ot \\<Longrightarrow> cost_sum ot \\<le> acost_sum ot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf ot \\<Longrightarrow> cost_sum ot \\<le> acost_sum ot", "by (metis add.commute t_sum_a_sum diff_add_cancel le_add_same_cancel2 ppos[OF inv_state])"], ["", "lemma a_le_U: \"\\<lbrakk> \\<forall>s \\<in> set ss. inv s; length ss = arity f \\<rbrakk> \\<Longrightarrow> acost f ss \\<le> U f ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>s\\<in>set ss. inv s; length ss = arity f\\<rbrakk>\n    \\<Longrightarrow> acost f ss \\<le> U f ss", "by(simp add: acost_def U)"], ["", "lemma a_sum_le_U_sum: \"wf ot \\<Longrightarrow> acost_sum ot \\<le> U_sum ot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf ot \\<Longrightarrow> acost_sum ot \\<le> U_sum ot", "proof(induction ot)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2a.\n       \\<lbrakk>\\<And>x2aa.\n                   \\<lbrakk>x2aa \\<in> set x2a; local.wf x2aa\\<rbrakk>\n                   \\<Longrightarrow> acost_sum x2aa \\<le> U_sum x2aa;\n        local.wf (T x1a x2a)\\<rbrakk>\n       \\<Longrightarrow> acost_sum (T x1a x2a) \\<le> U_sum (T x1a x2a)", "case (T f ts)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2aa \\<in> set ts; local.wf ?x2aa\\<rbrakk>\n  \\<Longrightarrow> acost_sum ?x2aa \\<le> U_sum ?x2aa\n  local.wf (T f ts)\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2a.\n       \\<lbrakk>\\<And>x2aa.\n                   \\<lbrakk>x2aa \\<in> set x2a; local.wf x2aa\\<rbrakk>\n                   \\<Longrightarrow> acost_sum x2aa \\<le> U_sum x2aa;\n        local.wf (T x1a x2a)\\<rbrakk>\n       \\<Longrightarrow> acost_sum (T x1a x2a) \\<le> U_sum (T x1a x2a)", "with a_le_U[of \"map state ts\" f] sum_list_mono"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>s\\<in>set (map state ts). inv s;\n   length (map state ts) = arity f\\<rbrakk>\n  \\<Longrightarrow> acost f (map state ts) \\<le> U f (map state ts)\n  (\\<And>x.\n      x \\<in> set ?xs \\<Longrightarrow> ?f x \\<le> ?g x) \\<Longrightarrow>\n  sum_list (map ?f ?xs) \\<le> sum_list (map ?g ?xs)\n  \\<lbrakk>?x2aa \\<in> set ts; local.wf ?x2aa\\<rbrakk>\n  \\<Longrightarrow> acost_sum ?x2aa \\<le> U_sum ?x2aa\n  local.wf (T f ts)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>s\\<in>set (map state ts). inv s;\n   length (map state ts) = arity f\\<rbrakk>\n  \\<Longrightarrow> acost f (map state ts) \\<le> U f (map state ts)\n  (\\<And>x.\n      x \\<in> set ?xs \\<Longrightarrow> ?f x \\<le> ?g x) \\<Longrightarrow>\n  sum_list (map ?f ?xs) \\<le> sum_list (map ?g ?xs)\n  \\<lbrakk>?x2aa \\<in> set ts; local.wf ?x2aa\\<rbrakk>\n  \\<Longrightarrow> acost_sum ?x2aa \\<le> U_sum ?x2aa\n  local.wf (T f ts)\n\ngoal (1 subgoal):\n 1. acost_sum (T f ts) \\<le> U_sum (T f ts)", "by (force simp: inv_state)"], ["proof (state)\nthis:\n  acost_sum (T f ts) \\<le> U_sum (T f ts)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary t_sum_le_U_sum: \"wf ot \\<Longrightarrow> cost_sum ot \\<le> U_sum ot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf ot \\<Longrightarrow> cost_sum ot \\<le> U_sum ot", "by (blast intro: t_sum_le_a_sum a_sum_le_U_sum order.trans)"], ["", "end"], ["", "hide_const T"], ["", "text\n\\<open>\\<open>Amortized2\\<close> supports the transfer of amortized analysis of one datatype\n(\\<open>Amortized arity exec inv cost \\<Phi> U\\<close> on type \\<open>'s\\<close>) to an implementation\n(primed identifiers on type \\<open>'t\\<close>).\nFunction \\<open>hom\\<close> is assumed to be a homomorphism from \\<open>'t\\<close> to \\<open>'s\\<close>,\nnot just w.r.t. \\<open>exec\\<close> but also \\<open>cost\\<close> and \\<open>U\\<close>. The assumptions about\n\\<open>inv'\\<close> are weaker than the obvious \\<open>inv' = inv \\<circ> hom\\<close>: the latter does\nnot allow \\<open>inv\\<close> to be weaker than \\<open>inv'\\<close> (which we need in one application).\\<close>"], ["", "locale Amortized2 = Amortized arity exec inv cost \\<Phi> U\n  for arity :: \"'op \\<Rightarrow> nat\" and exec and inv :: \"'s \\<Rightarrow> bool\" and cost \\<Phi> U +\nfixes exec' :: \"'op \\<Rightarrow> 't list \\<Rightarrow> 't\"\nfixes inv' :: \"'t \\<Rightarrow> bool\"\nfixes cost' :: \"'op \\<Rightarrow> 't list \\<Rightarrow> nat\"\nfixes U' :: \"'op \\<Rightarrow> 't list \\<Rightarrow> real\"\nfixes hom :: \"'t \\<Rightarrow> 's\"\nassumes exec': \"\\<lbrakk>\\<forall>s \\<in> set ts. inv' s; length ts = arity f \\<rbrakk>\n  \\<Longrightarrow> hom(exec' f ts) = exec f (map hom ts)\"\nassumes inv_exec': \"\\<lbrakk>\\<forall>s \\<in> set ss. inv' s; length ss = arity f \\<rbrakk>\n  \\<Longrightarrow> inv'(exec' f ss)\"\nassumes inv_hom: \"inv' t \\<Longrightarrow> inv (hom t)\"\nassumes cost': \"\\<lbrakk>\\<forall>s \\<in> set ts. inv' s; length ts = arity f \\<rbrakk>\n  \\<Longrightarrow> cost' f ts = cost f (map hom ts)\"\nassumes U': \"\\<lbrakk>\\<forall>s \\<in> set ts. inv' s; length ts = arity f \\<rbrakk>\n  \\<Longrightarrow> U' f ts = U f (map hom ts)\"\nbegin"], ["", "sublocale A': Amortized arity exec' inv' cost' \"\\<Phi> o hom\" U'"], ["proof (prove)\ngoal (1 subgoal):\n 1. Amortized arity exec' inv' cost' (\\<Phi> \\<circ> hom) U'", "proof (standard, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. inv' s; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> inv' (exec' f ss)\n 2. \\<And>s. inv' s \\<Longrightarrow> 0 \\<le> (\\<Phi> \\<circ> hom) s\n 3. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. inv' s; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost' f ss) +\n                         (\\<Phi> \\<circ> hom) (exec' f ss) -\n                         sum_list (map (\\<Phi> \\<circ> hom) ss)\n                         \\<le> U' f ss", "case 1"], ["proof (state)\nthis:\n  \\<forall>s\\<in>set ss_. inv' s\n  length ss_ = arity f_\n\ngoal (3 subgoals):\n 1. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. inv' s; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> inv' (exec' f ss)\n 2. \\<And>s. inv' s \\<Longrightarrow> 0 \\<le> (\\<Phi> \\<circ> hom) s\n 3. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. inv' s; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost' f ss) +\n                         (\\<Phi> \\<circ> hom) (exec' f ss) -\n                         sum_list (map (\\<Phi> \\<circ> hom) ss)\n                         \\<le> U' f ss", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>set ss_. inv' s\n  length ss_ = arity f_\n\ngoal (1 subgoal):\n 1. inv' (exec' f_ ss_)", "by(simp add: exec' inv_exec' inv_exec)"], ["proof (state)\nthis:\n  inv' (exec' f_ ss_)\n\ngoal (2 subgoals):\n 1. \\<And>s. inv' s \\<Longrightarrow> 0 \\<le> (\\<Phi> \\<circ> hom) s\n 2. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. inv' s; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost' f ss) +\n                         (\\<Phi> \\<circ> hom) (exec' f ss) -\n                         sum_list (map (\\<Phi> \\<circ> hom) ss)\n                         \\<le> U' f ss", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. inv' s \\<Longrightarrow> 0 \\<le> (\\<Phi> \\<circ> hom) s\n 2. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. inv' s; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost' f ss) +\n                         (\\<Phi> \\<circ> hom) (exec' f ss) -\n                         sum_list (map (\\<Phi> \\<circ> hom) ss)\n                         \\<le> U' f ss", "case 2"], ["proof (state)\nthis:\n  inv' s_\n\ngoal (2 subgoals):\n 1. \\<And>s. inv' s \\<Longrightarrow> 0 \\<le> (\\<Phi> \\<circ> hom) s\n 2. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. inv' s; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost' f ss) +\n                         (\\<Phi> \\<circ> hom) (exec' f ss) -\n                         sum_list (map (\\<Phi> \\<circ> hom) ss)\n                         \\<le> U' f ss", "thus ?case"], ["proof (prove)\nusing this:\n  inv' s_\n\ngoal (1 subgoal):\n 1. 0 \\<le> (\\<Phi> \\<circ> hom) s_", "by(simp add: inv_hom ppos)"], ["proof (state)\nthis:\n  0 \\<le> (\\<Phi> \\<circ> hom) s_\n\ngoal (1 subgoal):\n 1. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. inv' s; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost' f ss) +\n                         (\\<Phi> \\<circ> hom) (exec' f ss) -\n                         sum_list (map (\\<Phi> \\<circ> hom) ss)\n                         \\<le> U' f ss", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. inv' s; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost' f ss) +\n                         (\\<Phi> \\<circ> hom) (exec' f ss) -\n                         sum_list (map (\\<Phi> \\<circ> hom) ss)\n                         \\<le> U' f ss", "case 3"], ["proof (state)\nthis:\n  \\<forall>s\\<in>set ss_. inv' s\n  length ss_ = arity f_\n\ngoal (1 subgoal):\n 1. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. inv' s; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost' f ss) +\n                         (\\<Phi> \\<circ> hom) (exec' f ss) -\n                         sum_list (map (\\<Phi> \\<circ> hom) ss)\n                         \\<le> U' f ss", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>set ss_. inv' s\n  length ss_ = arity f_\n\ngoal (1 subgoal):\n 1. real (cost' f_ ss_) + (\\<Phi> \\<circ> hom) (exec' f_ ss_) -\n    sum_list (map (\\<Phi> \\<circ> hom) ss_)\n    \\<le> U' f_ ss_", "by(simp add: U exec' U' map_map[symmetric] cost' inv_exec inv_hom del: map_map)"], ["proof (state)\nthis:\n  real (cost' f_ ss_) + (\\<Phi> \\<circ> hom) (exec' f_ ss_) -\n  sum_list (map (\\<Phi> \\<circ> hom) ss_)\n  \\<le> U' f_ ss_\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}