{"file_name": "/home/qj213/afp-2021-10-22/thys/Amortized_Complexity/Pairing_Heap_List1_Analysis.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Amortized_Complexity", "problem_names": ["lemma merge_Empty[simp]: \"merge heap.Empty h = h\"", "lemma merge2: \"merge (Hp x lx) h = (case h of heap.Empty \\<Rightarrow> Hp x lx | (Hp y ly) \\<Rightarrow> \n    (if x < y then Hp x (Hp y ly # lx) else Hp y (Hp x lx # ly)))\"", "lemma pass1_Nil_iff: \"pass\\<^sub>1 hs = [] \\<longleftrightarrow> hs = []\"", "lemma is_root_if_no_Empty: \"no_Empty h \\<Longrightarrow> is_root h\"", "lemma no_Emptys_hps: \"no_Empty h \\<Longrightarrow> no_Emptys(hps h)\"", "lemma no_Empty_merge: \"\\<lbrakk> no_Empty h1; no_Empty h2\\<rbrakk> \\<Longrightarrow> no_Empty (merge h1 h2)\"", "lemma is_root_merge: \"\\<lbrakk> is_root h1; is_root h2\\<rbrakk> \\<Longrightarrow> is_root (merge h1 h2)\"", "lemma no_Emptys_pass1:\n  \"no_Emptys hs \\<Longrightarrow> no_Emptys (pass\\<^sub>1 hs)\"", "lemma is_root_pass2: \"no_Emptys hs \\<Longrightarrow> is_root(pass\\<^sub>2 hs)\"", "lemma \\<Phi>_hps_ge0: \"\\<Phi>_hps hs \\<ge> 0\"", "lemma no_Empty_ge0: \"no_Empty h \\<Longrightarrow> size_hp h > 0\"", "lemma \\<Phi>_hps1: \"\\<Phi>_hps [h] = \\<Phi> h\"", "lemma size_hp_merge: \"size_hp(merge h1 h2) = size_hp h1 + size_hp h2\"", "lemma pass\\<^sub>1_size[simp]: \"size_hps (pass\\<^sub>1 hs) = size_hps hs\"", "lemma \\<Delta>\\<Phi>_insert:\n  \"\\<Phi> (Pairing_Heap_List1.insert x h) - \\<Phi> h \\<le> log 2 (size_hp h + 1)\"", "lemma \\<Delta>\\<Phi>_merge:\n  \"\\<Phi> (merge h1 h2) - \\<Phi> h1 - \\<Phi> h2\n  \\<le> log 2 (size_hp h1 + size_hp h2 + 1) + 1\"", "lemma \\<Delta>\\<Phi>_pass1_sum_ub: \"no_Emptys hs \\<Longrightarrow>\n  \\<Phi>_hps (pass\\<^sub>1 hs) - \\<Phi>_hps hs  \\<le> sum_ub hs\" (is \"_ \\<Longrightarrow> ?P hs\")", "lemma \\<Delta>\\<Phi>_pass1: assumes \"hs \\<noteq> []\" \"no_Emptys hs\"\n  shows \"\\<Phi>_hps (pass\\<^sub>1 hs) - \\<Phi>_hps hs \\<le> 2 * log 2 (size_hps hs) - length hs + 2\"", "lemma size_hps_pass2: \"hs \\<noteq> [] \\<Longrightarrow> no_Emptys hs \\<Longrightarrow>\n  no_Empty(pass\\<^sub>2 hs) & size_hps hs = size_hps(hps(pass\\<^sub>2 hs))+1\"", "lemma \\<Delta>\\<Phi>_pass2: \"hs \\<noteq> [] \\<Longrightarrow> no_Emptys hs \\<Longrightarrow>\n  \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs \\<le> log 2 (size_hps hs)\"", "lemma \\<Delta>\\<Phi>_del_min: assumes \"hps h \\<noteq> []\" \"no_Empty h\"\n  shows \"\\<Phi> (del_min h) - \\<Phi> h \n  \\<le> 3 * log 2 (size_hps(hps h)) - length(hps h) + 2\""], "translations": [["", "lemma merge_Empty[simp]: \"merge heap.Empty h = h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge heap.Empty h = h", "by(cases h) auto"], ["", "lemma merge2: \"merge (Hp x lx) h = (case h of heap.Empty \\<Rightarrow> Hp x lx | (Hp y ly) \\<Rightarrow> \n    (if x < y then Hp x (Hp y ly # lx) else Hp y (Hp x lx # ly)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge (Hp x lx) h =\n    (case h of heap.Empty \\<Rightarrow> Hp x lx\n     | Hp y ly \\<Rightarrow>\n         if x < y then Hp x (Hp y ly # lx) else Hp y (Hp x lx # ly))", "by(auto split: heap.split)"], ["", "lemma pass1_Nil_iff: \"pass\\<^sub>1 hs = [] \\<longleftrightarrow> hs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pass\\<^sub>1 hs = []) = (hs = [])", "by(cases hs rule: pass\\<^sub>1.cases) auto"], ["", "subsubsection \\<open>Invariant\\<close>"], ["", "fun no_Empty :: \"'a :: linorder heap \\<Rightarrow> bool\" where\n\"no_Empty heap.Empty = False\" |\n\"no_Empty (Hp x hs) = (\\<forall>h \\<in> set hs. no_Empty h)\""], ["", "abbreviation no_Emptys :: \"'a :: linorder heap list \\<Rightarrow> bool\" where\n\"no_Emptys hs \\<equiv> \\<forall>h \\<in> set hs. no_Empty h\""], ["", "fun is_root :: \"'a :: linorder heap \\<Rightarrow> bool\" where\n\"is_root heap.Empty = True\" |\n\"is_root (Hp x hs) = no_Emptys hs\""], ["", "lemma is_root_if_no_Empty: \"no_Empty h \\<Longrightarrow> is_root h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_Empty h \\<Longrightarrow> is_root h", "by(cases h) auto"], ["", "lemma no_Emptys_hps: \"no_Empty h \\<Longrightarrow> no_Emptys(hps h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_Empty h \\<Longrightarrow> no_Emptys (hps h)", "by(induction h) auto"], ["", "lemma no_Empty_merge: \"\\<lbrakk> no_Empty h1; no_Empty h2\\<rbrakk> \\<Longrightarrow> no_Empty (merge h1 h2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>no_Empty h1; no_Empty h2\\<rbrakk>\n    \\<Longrightarrow> no_Empty (merge h1 h2)", "by (cases \"(h1,h2)\" rule: merge.cases) auto"], ["", "lemma is_root_merge: \"\\<lbrakk> is_root h1; is_root h2\\<rbrakk> \\<Longrightarrow> is_root (merge h1 h2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_root h1; is_root h2\\<rbrakk>\n    \\<Longrightarrow> is_root (merge h1 h2)", "by (cases \"(h1,h2)\" rule: merge.cases) auto"], ["", "lemma no_Emptys_pass1:\n  \"no_Emptys hs \\<Longrightarrow> no_Emptys (pass\\<^sub>1 hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_Emptys hs \\<Longrightarrow> no_Emptys (pass\\<^sub>1 hs)", "by(induction hs rule: pass\\<^sub>1.induct)(auto simp: no_Empty_merge)"], ["", "lemma is_root_pass2: \"no_Emptys hs \\<Longrightarrow> is_root(pass\\<^sub>2 hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_Emptys hs \\<Longrightarrow> is_root (pass\\<^sub>2 hs)", "proof(induction hs)"], ["proof (state)\ngoal (2 subgoals):\n 1. no_Emptys [] \\<Longrightarrow> is_root (pass\\<^sub>2 [])\n 2. \\<And>a hs.\n       \\<lbrakk>no_Emptys hs \\<Longrightarrow> is_root (pass\\<^sub>2 hs);\n        no_Emptys (a # hs)\\<rbrakk>\n       \\<Longrightarrow> is_root (pass\\<^sub>2 (a # hs))", "case (Cons _ hs)"], ["proof (state)\nthis:\n  no_Emptys hs \\<Longrightarrow> is_root (pass\\<^sub>2 hs)\n  no_Emptys (a_ # hs)\n\ngoal (2 subgoals):\n 1. no_Emptys [] \\<Longrightarrow> is_root (pass\\<^sub>2 [])\n 2. \\<And>a hs.\n       \\<lbrakk>no_Emptys hs \\<Longrightarrow> is_root (pass\\<^sub>2 hs);\n        no_Emptys (a # hs)\\<rbrakk>\n       \\<Longrightarrow> is_root (pass\\<^sub>2 (a # hs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_root (pass\\<^sub>2 (a_ # hs))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> is_root (pass\\<^sub>2 (a_ # hs))\n 2. \\<not> ?P \\<Longrightarrow> is_root (pass\\<^sub>2 (a_ # hs))", "assume \"hs = []\""], ["proof (state)\nthis:\n  hs = []\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> is_root (pass\\<^sub>2 (a_ # hs))\n 2. \\<not> ?P \\<Longrightarrow> is_root (pass\\<^sub>2 (a_ # hs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  hs = []\n\ngoal (1 subgoal):\n 1. is_root (pass\\<^sub>2 (a_ # hs))", "using Cons"], ["proof (prove)\nusing this:\n  hs = []\n  no_Emptys hs \\<Longrightarrow> is_root (pass\\<^sub>2 hs)\n  no_Emptys (a_ # hs)\n\ngoal (1 subgoal):\n 1. is_root (pass\\<^sub>2 (a_ # hs))", "by (auto simp: is_root_if_no_Empty)"], ["proof (state)\nthis:\n  is_root (pass\\<^sub>2 (a_ # hs))\n\ngoal (1 subgoal):\n 1. hs \\<noteq> [] \\<Longrightarrow> is_root (pass\\<^sub>2 (a_ # hs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. hs \\<noteq> [] \\<Longrightarrow> is_root (pass\\<^sub>2 (a_ # hs))", "assume \"hs \\<noteq> []\""], ["proof (state)\nthis:\n  hs \\<noteq> []\n\ngoal (1 subgoal):\n 1. hs \\<noteq> [] \\<Longrightarrow> is_root (pass\\<^sub>2 (a_ # hs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  hs \\<noteq> []\n\ngoal (1 subgoal):\n 1. is_root (pass\\<^sub>2 (a_ # hs))", "using Cons"], ["proof (prove)\nusing this:\n  hs \\<noteq> []\n  no_Emptys hs \\<Longrightarrow> is_root (pass\\<^sub>2 hs)\n  no_Emptys (a_ # hs)\n\ngoal (1 subgoal):\n 1. is_root (pass\\<^sub>2 (a_ # hs))", "by(auto simp: is_root_merge is_root_if_no_Empty)"], ["proof (state)\nthis:\n  is_root (pass\\<^sub>2 (a_ # hs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_root (pass\\<^sub>2 (a_ # hs))\n\ngoal (1 subgoal):\n 1. no_Emptys [] \\<Longrightarrow> is_root (pass\\<^sub>2 [])", "qed simp"], ["", "subsubsection \\<open>Complexity\\<close>"], ["", "fun size_hp :: \"'a heap \\<Rightarrow> nat\" where\n\"size_hp heap.Empty = 0\" |\n\"size_hp (Hp x hs) = sum_list(map size_hp hs) + 1\""], ["", "abbreviation size_hps where\n\"size_hps hs \\<equiv> sum_list(map size_hp hs)\""], ["", "fun \\<Phi>_hps :: \"'a heap list \\<Rightarrow> real\" where\n\"\\<Phi>_hps [] = 0\" |\n\"\\<Phi>_hps (heap.Empty # hs) = \\<Phi>_hps hs\" |\n\"\\<Phi>_hps (Hp x hsl # hsr) =\n \\<Phi>_hps hsl + \\<Phi>_hps hsr + log 2 (size_hps hsl + size_hps hsr + 1)\""], ["", "fun \\<Phi> :: \"'a heap \\<Rightarrow> real\" where\n\"\\<Phi> heap.Empty = 0\" |\n\"\\<Phi> (Hp _ hs) = \\<Phi>_hps hs + log 2 (size_hps(hs)+1)\""], ["", "lemma \\<Phi>_hps_ge0: \"\\<Phi>_hps hs \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<Phi>_hps hs", "by (induction hs rule: \\<Phi>_hps.induct) auto"], ["", "lemma no_Empty_ge0: \"no_Empty h \\<Longrightarrow> size_hp h > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_Empty h \\<Longrightarrow> 0 < size_hp h", "by(cases h) auto"], ["", "declare algebra_simps[simp]"], ["", "lemma \\<Phi>_hps1: \"\\<Phi>_hps [h] = \\<Phi> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>_hps [h] = \\<Phi> h", "by(cases h) auto"], ["", "lemma size_hp_merge: \"size_hp(merge h1 h2) = size_hp h1 + size_hp h2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size_hp (merge h1 h2) = size_hp h1 + size_hp h2", "by (induction h1 h2 rule: merge.induct) simp_all"], ["", "lemma pass\\<^sub>1_size[simp]: \"size_hps (pass\\<^sub>1 hs) = size_hps hs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size_hps (pass\\<^sub>1 hs) = size_hps hs", "by (induct hs rule: pass\\<^sub>1.induct) (simp_all add: size_hp_merge)"], ["", "lemma \\<Delta>\\<Phi>_insert:\n  \"\\<Phi> (Pairing_Heap_List1.insert x h) - \\<Phi> h \\<le> log 2 (size_hp h + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> (Pairing_Heap_List1.insert x h) - \\<Phi> h\n    \\<le> log 2 (real (size_hp h + 1))", "by(cases h)(auto simp: size_hp_merge)"], ["", "lemma \\<Delta>\\<Phi>_merge:\n  \"\\<Phi> (merge h1 h2) - \\<Phi> h1 - \\<Phi> h2\n  \\<le> log 2 (size_hp h1 + size_hp h2 + 1) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> (merge h1 h2) - \\<Phi> h1 - \\<Phi> h2\n    \\<le> log 2 (real (size_hp h1 + size_hp h2 + 1)) + 1", "proof(induction h1 h2 rule: merge.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>h.\n       \\<Phi> (merge h heap.Empty) - \\<Phi> h - \\<Phi> heap.Empty\n       \\<le> log 2 (real (size_hp h + size_hp heap.Empty + 1)) + 1\n 2. \\<And>v va.\n       \\<Phi> (merge heap.Empty (Hp v va)) - \\<Phi> heap.Empty -\n       \\<Phi> (Hp v va)\n       \\<le> log 2 (real (size_hp heap.Empty + size_hp (Hp v va) + 1)) + 1\n 3. \\<And>x hsx y hsy.\n       \\<Phi> (merge (Hp x hsx) (Hp y hsy)) - \\<Phi> (Hp x hsx) -\n       \\<Phi> (Hp y hsy)\n       \\<le> log 2 (real (size_hp (Hp x hsx) + size_hp (Hp y hsy) + 1)) + 1", "case (3 x lx y ly)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>h.\n       \\<Phi> (merge h heap.Empty) - \\<Phi> h - \\<Phi> heap.Empty\n       \\<le> log 2 (real (size_hp h + size_hp heap.Empty + 1)) + 1\n 2. \\<And>v va.\n       \\<Phi> (merge heap.Empty (Hp v va)) - \\<Phi> heap.Empty -\n       \\<Phi> (Hp v va)\n       \\<le> log 2 (real (size_hp heap.Empty + size_hp (Hp v va) + 1)) + 1\n 3. \\<And>x hsx y hsy.\n       \\<Phi> (merge (Hp x hsx) (Hp y hsy)) - \\<Phi> (Hp x hsx) -\n       \\<Phi> (Hp y hsy)\n       \\<le> log 2 (real (size_hp (Hp x hsx) + size_hp (Hp y hsy) + 1)) + 1", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> (merge (Hp x lx) (Hp y ly)) - \\<Phi> (Hp x lx) - \\<Phi> (Hp y ly)\n    \\<le> log 2 (real (size_hp (Hp x lx) + size_hp (Hp y ly) + 1)) + 1", "using ld_le_2ld[of \"size_hps lx\" \"size_hps ly\"]\n      log_le_cancel_iff[of 2 \"size_hps lx + size_hps ly + 2\" \"size_hps lx + size_hps ly + 3\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> real (size_hps lx); 0 \\<le> real (size_hps ly)\\<rbrakk>\n  \\<Longrightarrow> log 2 (1 + real (size_hps lx) + real (size_hps ly))\n                    \\<le> 1 + log 2 (1 + real (size_hps lx)) +\n                          log 2 (1 + real (size_hps ly))\n  \\<lbrakk>1 < 2; 0 < real (size_hps lx + size_hps ly + 2);\n   0 < real (size_hps lx + size_hps ly + 3)\\<rbrakk>\n  \\<Longrightarrow> (log 2 (real (size_hps lx + size_hps ly + 2))\n                     \\<le> log 2 (real (size_hps lx + size_hps ly + 3))) =\n                    (real (size_hps lx + size_hps ly + 2)\n                     \\<le> real (size_hps lx + size_hps ly + 3))\n\ngoal (1 subgoal):\n 1. \\<Phi> (merge (Hp x lx) (Hp y ly)) - \\<Phi> (Hp x lx) - \\<Phi> (Hp y ly)\n    \\<le> log 2 (real (size_hp (Hp x lx) + size_hp (Hp y ly) + 1)) + 1", "by (auto simp del: log_le_cancel_iff)"], ["proof (state)\nthis:\n  \\<Phi> (merge (Hp x lx) (Hp y ly)) - \\<Phi> (Hp x lx) - \\<Phi> (Hp y ly)\n  \\<le> log 2 (real (size_hp (Hp x lx) + size_hp (Hp y ly) + 1)) + 1\n\ngoal (2 subgoals):\n 1. \\<And>h.\n       \\<Phi> (merge h heap.Empty) - \\<Phi> h - \\<Phi> heap.Empty\n       \\<le> log 2 (real (size_hp h + size_hp heap.Empty + 1)) + 1\n 2. \\<And>v va.\n       \\<Phi> (merge heap.Empty (Hp v va)) - \\<Phi> heap.Empty -\n       \\<Phi> (Hp v va)\n       \\<le> log 2 (real (size_hp heap.Empty + size_hp (Hp v va) + 1)) + 1", "qed auto"], ["", "fun sum_ub :: \"'a heap list \\<Rightarrow> real\" where\n  \"sum_ub [] = 0\"\n| \"sum_ub [_] = 0\"\n| \"sum_ub [h1, h2] = 2*log 2 (size_hp h1 + size_hp h2)\" \n| \"sum_ub (h1 # h2 # hs) = 2*log 2 (size_hp h1 + size_hp h2 + size_hps hs) \n    - 2*log 2 (size_hps hs) - 2 + sum_ub hs\""], ["", "lemma \\<Delta>\\<Phi>_pass1_sum_ub: \"no_Emptys hs \\<Longrightarrow>\n  \\<Phi>_hps (pass\\<^sub>1 hs) - \\<Phi>_hps hs  \\<le> sum_ub hs\" (is \"_ \\<Longrightarrow> ?P hs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_Emptys hs \\<Longrightarrow>\n    \\<Phi>_hps (pass\\<^sub>1 hs) - \\<Phi>_hps hs \\<le> sum_ub hs", "proof (induction hs rule: sum_ub.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. no_Emptys [] \\<Longrightarrow>\n    \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_.\n       no_Emptys [uu_] \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 [uu_]) - \\<Phi>_hps [uu_] \\<le> sum_ub [uu_]\n 3. \\<And>h1 h2.\n       no_Emptys [h1, h2] \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 [h1, h2]) - \\<Phi>_hps [h1, h2]\n       \\<le> sum_ub [h1, h2]\n 4. \\<And>h1 h2 v va.\n       \\<lbrakk>no_Emptys (v # va) \\<Longrightarrow>\n                \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n                \\<le> sum_ub (v # va);\n        no_Emptys (h1 # h2 # v # va)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi>_hps (pass\\<^sub>1 (h1 # h2 # v # va)) -\n                         \\<Phi>_hps (h1 # h2 # v # va)\n                         \\<le> sum_ub (h1 # h2 # v # va)", "case (3 h1 h2)"], ["proof (state)\nthis:\n  no_Emptys [h1, h2]\n\ngoal (4 subgoals):\n 1. no_Emptys [] \\<Longrightarrow>\n    \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_.\n       no_Emptys [uu_] \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 [uu_]) - \\<Phi>_hps [uu_] \\<le> sum_ub [uu_]\n 3. \\<And>h1 h2.\n       no_Emptys [h1, h2] \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 [h1, h2]) - \\<Phi>_hps [h1, h2]\n       \\<le> sum_ub [h1, h2]\n 4. \\<And>h1 h2 v va.\n       \\<lbrakk>no_Emptys (v # va) \\<Longrightarrow>\n                \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n                \\<le> sum_ub (v # va);\n        no_Emptys (h1 # h2 # v # va)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi>_hps (pass\\<^sub>1 (h1 # h2 # v # va)) -\n                         \\<Phi>_hps (h1 # h2 # v # va)\n                         \\<le> sum_ub (h1 # h2 # v # va)", "then"], ["proof (chain)\npicking this:\n  no_Emptys [h1, h2]", "obtain x hsx y hsy where [simp]: \"h1 = Hp x hsx\" \"h2 = Hp y hsy\""], ["proof (prove)\nusing this:\n  no_Emptys [h1, h2]\n\ngoal (1 subgoal):\n 1. (\\<And>x hsx y hsy.\n        \\<lbrakk>h1 = Hp x hsx; h2 = Hp y hsy\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp (meson no_Empty.elims(2))"], ["proof (state)\nthis:\n  h1 = Hp x hsx\n  h2 = Hp y hsy\n\ngoal (4 subgoals):\n 1. no_Emptys [] \\<Longrightarrow>\n    \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_.\n       no_Emptys [uu_] \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 [uu_]) - \\<Phi>_hps [uu_] \\<le> sum_ub [uu_]\n 3. \\<And>h1 h2.\n       no_Emptys [h1, h2] \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 [h1, h2]) - \\<Phi>_hps [h1, h2]\n       \\<le> sum_ub [h1, h2]\n 4. \\<And>h1 h2 v va.\n       \\<lbrakk>no_Emptys (v # va) \\<Longrightarrow>\n                \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n                \\<le> sum_ub (v # va);\n        no_Emptys (h1 # h2 # v # va)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi>_hps (pass\\<^sub>1 (h1 # h2 # v # va)) -\n                         \\<Phi>_hps (h1 # h2 # v # va)\n                         \\<le> sum_ub (h1 # h2 # v # va)", "have 0: \"\\<And>x y::real. 0 \\<le> x \\<Longrightarrow> x \\<le> y \\<Longrightarrow> x \\<le> 2*y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>0 \\<le> x; x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> x \\<le> 2 * y", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?x; ?x \\<le> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> 2 * ?y\n\ngoal (4 subgoals):\n 1. no_Emptys [] \\<Longrightarrow>\n    \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_.\n       no_Emptys [uu_] \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 [uu_]) - \\<Phi>_hps [uu_] \\<le> sum_ub [uu_]\n 3. \\<And>h1 h2.\n       no_Emptys [h1, h2] \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 [h1, h2]) - \\<Phi>_hps [h1, h2]\n       \\<le> sum_ub [h1, h2]\n 4. \\<And>h1 h2 v va.\n       \\<lbrakk>no_Emptys (v # va) \\<Longrightarrow>\n                \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n                \\<le> sum_ub (v # va);\n        no_Emptys (h1 # h2 # v # va)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi>_hps (pass\\<^sub>1 (h1 # h2 # v # va)) -\n                         \\<Phi>_hps (h1 # h2 # v # va)\n                         \\<le> sum_ub (h1 # h2 # v # va)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>_hps (pass\\<^sub>1 [h1, h2]) - \\<Phi>_hps [h1, h2]\n    \\<le> sum_ub [h1, h2]", "using 3"], ["proof (prove)\nusing this:\n  no_Emptys [h1, h2]\n\ngoal (1 subgoal):\n 1. \\<Phi>_hps (pass\\<^sub>1 [h1, h2]) - \\<Phi>_hps [h1, h2]\n    \\<le> sum_ub [h1, h2]", "by (auto simp add: add_increasing 0)"], ["proof (state)\nthis:\n  \\<Phi>_hps (pass\\<^sub>1 [h1, h2]) - \\<Phi>_hps [h1, h2]\n  \\<le> sum_ub [h1, h2]\n\ngoal (3 subgoals):\n 1. no_Emptys [] \\<Longrightarrow>\n    \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_.\n       no_Emptys [uu_] \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 [uu_]) - \\<Phi>_hps [uu_] \\<le> sum_ub [uu_]\n 3. \\<And>h1 h2 v va.\n       \\<lbrakk>no_Emptys (v # va) \\<Longrightarrow>\n                \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n                \\<le> sum_ub (v # va);\n        no_Emptys (h1 # h2 # v # va)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi>_hps (pass\\<^sub>1 (h1 # h2 # v # va)) -\n                         \\<Phi>_hps (h1 # h2 # v # va)\n                         \\<le> sum_ub (h1 # h2 # v # va)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. no_Emptys [] \\<Longrightarrow>\n    \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_.\n       no_Emptys [uu_] \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 [uu_]) - \\<Phi>_hps [uu_] \\<le> sum_ub [uu_]\n 3. \\<And>h1 h2 v va.\n       \\<lbrakk>no_Emptys (v # va) \\<Longrightarrow>\n                \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n                \\<le> sum_ub (v # va);\n        no_Emptys (h1 # h2 # v # va)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi>_hps (pass\\<^sub>1 (h1 # h2 # v # va)) -\n                         \\<Phi>_hps (h1 # h2 # v # va)\n                         \\<le> sum_ub (h1 # h2 # v # va)", "case (4 h1 h2 h3 hs)"], ["proof (state)\nthis:\n  no_Emptys (h3 # hs) \\<Longrightarrow>\n  \\<Phi>_hps (pass\\<^sub>1 (h3 # hs)) - \\<Phi>_hps (h3 # hs)\n  \\<le> sum_ub (h3 # hs)\n  no_Emptys (h1 # h2 # h3 # hs)\n\ngoal (3 subgoals):\n 1. no_Emptys [] \\<Longrightarrow>\n    \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_.\n       no_Emptys [uu_] \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 [uu_]) - \\<Phi>_hps [uu_] \\<le> sum_ub [uu_]\n 3. \\<And>h1 h2 v va.\n       \\<lbrakk>no_Emptys (v # va) \\<Longrightarrow>\n                \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n                \\<le> sum_ub (v # va);\n        no_Emptys (h1 # h2 # v # va)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi>_hps (pass\\<^sub>1 (h1 # h2 # v # va)) -\n                         \\<Phi>_hps (h1 # h2 # v # va)\n                         \\<le> sum_ub (h1 # h2 # v # va)", "hence IH: \"?P(h3#hs)\""], ["proof (prove)\nusing this:\n  no_Emptys (h3 # hs) \\<Longrightarrow>\n  \\<Phi>_hps (pass\\<^sub>1 (h3 # hs)) - \\<Phi>_hps (h3 # hs)\n  \\<le> sum_ub (h3 # hs)\n  no_Emptys (h1 # h2 # h3 # hs)\n\ngoal (1 subgoal):\n 1. \\<Phi>_hps (pass\\<^sub>1 (h3 # hs)) - \\<Phi>_hps (h3 # hs)\n    \\<le> sum_ub (h3 # hs)", "by auto"], ["proof (state)\nthis:\n  \\<Phi>_hps (pass\\<^sub>1 (h3 # hs)) - \\<Phi>_hps (h3 # hs)\n  \\<le> sum_ub (h3 # hs)\n\ngoal (3 subgoals):\n 1. no_Emptys [] \\<Longrightarrow>\n    \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_.\n       no_Emptys [uu_] \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 [uu_]) - \\<Phi>_hps [uu_] \\<le> sum_ub [uu_]\n 3. \\<And>h1 h2 v va.\n       \\<lbrakk>no_Emptys (v # va) \\<Longrightarrow>\n                \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n                \\<le> sum_ub (v # va);\n        no_Emptys (h1 # h2 # v # va)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi>_hps (pass\\<^sub>1 (h1 # h2 # v # va)) -\n                         \\<Phi>_hps (h1 # h2 # v # va)\n                         \\<le> sum_ub (h1 # h2 # v # va)", "from \"4.prems\""], ["proof (chain)\npicking this:\n  no_Emptys (h1 # h2 # h3 # hs)", "obtain x hsx y hsy where [simp]: \"h1 = Hp x hsx\" \"h2 = Hp y hsy\""], ["proof (prove)\nusing this:\n  no_Emptys (h1 # h2 # h3 # hs)\n\ngoal (1 subgoal):\n 1. (\\<And>x hsx y hsy.\n        \\<lbrakk>h1 = Hp x hsx; h2 = Hp y hsy\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp (meson no_Empty.elims(2))"], ["proof (state)\nthis:\n  h1 = Hp x hsx\n  h2 = Hp y hsy\n\ngoal (3 subgoals):\n 1. no_Emptys [] \\<Longrightarrow>\n    \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_.\n       no_Emptys [uu_] \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 [uu_]) - \\<Phi>_hps [uu_] \\<le> sum_ub [uu_]\n 3. \\<And>h1 h2 v va.\n       \\<lbrakk>no_Emptys (v # va) \\<Longrightarrow>\n                \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n                \\<le> sum_ub (v # va);\n        no_Emptys (h1 # h2 # v # va)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi>_hps (pass\\<^sub>1 (h1 # h2 # v # va)) -\n                         \\<Phi>_hps (h1 # h2 # v # va)\n                         \\<le> sum_ub (h1 # h2 # v # va)", "from \"4.prems\""], ["proof (chain)\npicking this:\n  no_Emptys (h1 # h2 # h3 # hs)", "have s3: \"size_hp h3 > 0\""], ["proof (prove)\nusing this:\n  no_Emptys (h1 # h2 # h3 # hs)\n\ngoal (1 subgoal):\n 1. 0 < size_hp h3", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>no_Emptys hsx; no_Emptys hsy; no_Empty h3;\n     no_Emptys hs\\<rbrakk>\n    \\<Longrightarrow> 0 < size_hp h3", "using size_hp.elims"], ["proof (prove)\nusing this:\n  \\<lbrakk>size_hp ?x = ?y;\n   \\<lbrakk>?x = heap.Empty; ?y = 0\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>x hs.\n      \\<lbrakk>?x = Hp x hs; ?y = size_hps hs + 1\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>no_Emptys hsx; no_Emptys hsy; no_Empty h3;\n     no_Emptys hs\\<rbrakk>\n    \\<Longrightarrow> 0 < size_hp h3", "by force"], ["proof (state)\nthis:\n  0 < size_hp h3\n\ngoal (3 subgoals):\n 1. no_Emptys [] \\<Longrightarrow>\n    \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_.\n       no_Emptys [uu_] \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 [uu_]) - \\<Phi>_hps [uu_] \\<le> sum_ub [uu_]\n 3. \\<And>h1 h2 v va.\n       \\<lbrakk>no_Emptys (v # va) \\<Longrightarrow>\n                \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n                \\<le> sum_ub (v # va);\n        no_Emptys (h1 # h2 # v # va)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi>_hps (pass\\<^sub>1 (h1 # h2 # v # va)) -\n                         \\<Phi>_hps (h1 # h2 # v # va)\n                         \\<le> sum_ub (h1 # h2 # v # va)", "let ?ry = \"h3 # hs\""], ["proof (state)\ngoal (3 subgoals):\n 1. no_Emptys [] \\<Longrightarrow>\n    \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_.\n       no_Emptys [uu_] \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 [uu_]) - \\<Phi>_hps [uu_] \\<le> sum_ub [uu_]\n 3. \\<And>h1 h2 v va.\n       \\<lbrakk>no_Emptys (v # va) \\<Longrightarrow>\n                \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n                \\<le> sum_ub (v # va);\n        no_Emptys (h1 # h2 # v # va)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi>_hps (pass\\<^sub>1 (h1 # h2 # v # va)) -\n                         \\<Phi>_hps (h1 # h2 # v # va)\n                         \\<le> sum_ub (h1 # h2 # v # va)", "let ?rx = \"Hp y hsy # ?ry\""], ["proof (state)\ngoal (3 subgoals):\n 1. no_Emptys [] \\<Longrightarrow>\n    \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_.\n       no_Emptys [uu_] \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 [uu_]) - \\<Phi>_hps [uu_] \\<le> sum_ub [uu_]\n 3. \\<And>h1 h2 v va.\n       \\<lbrakk>no_Emptys (v # va) \\<Longrightarrow>\n                \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n                \\<le> sum_ub (v # va);\n        no_Emptys (h1 # h2 # v # va)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi>_hps (pass\\<^sub>1 (h1 # h2 # v # va)) -\n                         \\<Phi>_hps (h1 # h2 # v # va)\n                         \\<le> sum_ub (h1 # h2 # v # va)", "let ?h = \"Hp x hsx # ?rx\""], ["proof (state)\ngoal (3 subgoals):\n 1. no_Emptys [] \\<Longrightarrow>\n    \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_.\n       no_Emptys [uu_] \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 [uu_]) - \\<Phi>_hps [uu_] \\<le> sum_ub [uu_]\n 3. \\<And>h1 h2 v va.\n       \\<lbrakk>no_Emptys (v # va) \\<Longrightarrow>\n                \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n                \\<le> sum_ub (v # va);\n        no_Emptys (h1 # h2 # v # va)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi>_hps (pass\\<^sub>1 (h1 # h2 # v # va)) -\n                         \\<Phi>_hps (h1 # h2 # v # va)\n                         \\<le> sum_ub (h1 # h2 # v # va)", "have \"\\<Phi>_hps(pass\\<^sub>1 ?h) - \\<Phi>_hps ?h  \n    \\<le> log 2 (1 + size_hps hsx + size_hps hsy) - log 2 (1 + size_hps hsy + size_hps ?ry) + sum_ub ?ry\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>_hps (pass\\<^sub>1 (Hp x hsx # Hp y hsy # h3 # hs)) -\n    \\<Phi>_hps (Hp x hsx # Hp y hsy # h3 # hs)\n    \\<le> log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n          log 2 (real (1 + size_hps hsy + size_hps (h3 # hs))) +\n          sum_ub (h3 # hs)", "using IH"], ["proof (prove)\nusing this:\n  \\<Phi>_hps (pass\\<^sub>1 (h3 # hs)) - \\<Phi>_hps (h3 # hs)\n  \\<le> sum_ub (h3 # hs)\n\ngoal (1 subgoal):\n 1. \\<Phi>_hps (pass\\<^sub>1 (Hp x hsx # Hp y hsy # h3 # hs)) -\n    \\<Phi>_hps (Hp x hsx # Hp y hsy # h3 # hs)\n    \\<le> log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n          log 2 (real (1 + size_hps hsy + size_hps (h3 # hs))) +\n          sum_ub (h3 # hs)", "by simp"], ["proof (state)\nthis:\n  \\<Phi>_hps (pass\\<^sub>1 (Hp x hsx # Hp y hsy # h3 # hs)) -\n  \\<Phi>_hps (Hp x hsx # Hp y hsy # h3 # hs)\n  \\<le> log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n        log 2 (real (1 + size_hps hsy + size_hps (h3 # hs))) +\n        sum_ub (h3 # hs)\n\ngoal (3 subgoals):\n 1. no_Emptys [] \\<Longrightarrow>\n    \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_.\n       no_Emptys [uu_] \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 [uu_]) - \\<Phi>_hps [uu_] \\<le> sum_ub [uu_]\n 3. \\<And>h1 h2 v va.\n       \\<lbrakk>no_Emptys (v # va) \\<Longrightarrow>\n                \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n                \\<le> sum_ub (v # va);\n        no_Emptys (h1 # h2 # v # va)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi>_hps (pass\\<^sub>1 (h1 # h2 # v # va)) -\n                         \\<Phi>_hps (h1 # h2 # v # va)\n                         \\<le> sum_ub (h1 # h2 # v # va)", "also"], ["proof (state)\nthis:\n  \\<Phi>_hps (pass\\<^sub>1 (Hp x hsx # Hp y hsy # h3 # hs)) -\n  \\<Phi>_hps (Hp x hsx # Hp y hsy # h3 # hs)\n  \\<le> log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n        log 2 (real (1 + size_hps hsy + size_hps (h3 # hs))) +\n        sum_ub (h3 # hs)\n\ngoal (3 subgoals):\n 1. no_Emptys [] \\<Longrightarrow>\n    \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_.\n       no_Emptys [uu_] \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 [uu_]) - \\<Phi>_hps [uu_] \\<le> sum_ub [uu_]\n 3. \\<And>h1 h2 v va.\n       \\<lbrakk>no_Emptys (v # va) \\<Longrightarrow>\n                \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n                \\<le> sum_ub (v # va);\n        no_Emptys (h1 # h2 # v # va)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi>_hps (pass\\<^sub>1 (h1 # h2 # v # va)) -\n                         \\<Phi>_hps (h1 # h2 # v # va)\n                         \\<le> sum_ub (h1 # h2 # v # va)", "have \"log 2 (1 + size_hps hsx + size_hps hsy) - log 2 (1 + size_hps hsy + size_hps ?ry) \n    \\<le> 2*log 2 (size_hps ?h) - 2*log 2 (size_hps ?ry) - 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n    log 2 (real (1 + size_hps hsy + size_hps (h3 # hs)))\n    \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) -\n          2 * log 2 (real (size_hps (h3 # hs))) -\n          2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n    log 2 (real (1 + size_hps hsy + size_hps (h3 # hs)))\n    \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) -\n          2 * log 2 (real (size_hps (h3 # hs))) -\n          2", "have \"log 2 (1 + size_hps hsx + size_hps hsy) + log 2 (size_hps ?ry) - 2*log 2 (size_hps ?h) \n      = log 2 ((1 + size_hps hsx + size_hps hsy)/(size_hps ?h) ) + log 2 (size_hps ?ry / size_hps ?h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real (1 + size_hps hsx + size_hps hsy)) +\n    log 2 (real (size_hps (h3 # hs))) -\n    2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) =\n    log 2\n     (real (1 + size_hps hsx + size_hps hsy) /\n      real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) +\n    log 2\n     (real (size_hps (h3 # hs)) /\n      real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))", "using s3"], ["proof (prove)\nusing this:\n  0 < size_hp h3\n\ngoal (1 subgoal):\n 1. log 2 (real (1 + size_hps hsx + size_hps hsy)) +\n    log 2 (real (size_hps (h3 # hs))) -\n    2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) =\n    log 2\n     (real (1 + size_hps hsx + size_hps hsy) /\n      real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) +\n    log 2\n     (real (size_hps (h3 # hs)) /\n      real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))", "by (simp add: log_divide)"], ["proof (state)\nthis:\n  log 2 (real (1 + size_hps hsx + size_hps hsy)) +\n  log 2 (real (size_hps (h3 # hs))) -\n  2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) =\n  log 2\n   (real (1 + size_hps hsx + size_hps hsy) /\n    real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) +\n  log 2\n   (real (size_hps (h3 # hs)) /\n    real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))\n\ngoal (1 subgoal):\n 1. log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n    log 2 (real (1 + size_hps hsy + size_hps (h3 # hs)))\n    \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) -\n          2 * log 2 (real (size_hps (h3 # hs))) -\n          2", "also"], ["proof (state)\nthis:\n  log 2 (real (1 + size_hps hsx + size_hps hsy)) +\n  log 2 (real (size_hps (h3 # hs))) -\n  2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) =\n  log 2\n   (real (1 + size_hps hsx + size_hps hsy) /\n    real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) +\n  log 2\n   (real (size_hps (h3 # hs)) /\n    real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))\n\ngoal (1 subgoal):\n 1. log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n    log 2 (real (1 + size_hps hsy + size_hps (h3 # hs)))\n    \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) -\n          2 * log 2 (real (size_hps (h3 # hs))) -\n          2", "have \"\\<dots> \\<le> -2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2\n     (real (1 + size_hps hsx + size_hps hsy) /\n      real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) +\n    log 2\n     (real (size_hps (h3 # hs)) /\n      real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))\n    \\<le> - 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. log 2\n     (real (1 + size_hps hsx + size_hps hsy) /\n      real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) +\n    log 2\n     (real (size_hps (h3 # hs)) /\n      real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))\n    \\<le> - 2", "have \"2 + \\<dots>\n        \\<le> 2*log 2 ((1 + size_hps hsx + size_hps hsy) / size_hps ?h +  size_hps ?ry / size_hps ?h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 +\n    (log 2\n      (real (1 + size_hps hsx + size_hps hsy) /\n       real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) +\n     log 2\n      (real (size_hps (h3 # hs)) /\n       real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))))\n    \\<le> 2 *\n          log 2\n           (real (1 + size_hps hsx + size_hps hsy) /\n            real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)) +\n            real (size_hps (h3 # hs)) /\n            real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))", "using ld_sum_inequality [of \"(1 + size_hps hsx + size_hps hsy) / size_hps ?h\" \"(size_hps ?ry / size_hps ?h)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < real (1 + size_hps hsx + size_hps hsy) /\n               real (size_hps (Hp x hsx # Hp y hsy # h3 # hs));\n   0 < real (size_hps (h3 # hs)) /\n       real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))\\<rbrakk>\n  \\<Longrightarrow> log 2\n                     (real (1 + size_hps hsx + size_hps hsy) /\n                      real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) +\n                    log 2\n                     (real (size_hps (h3 # hs)) /\n                      real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) +\n                    2\n                    \\<le> 2 *\n                          log 2\n                           (real (1 + size_hps hsx + size_hps hsy) /\n                            real\n                             (size_hps (Hp x hsx # Hp y hsy # h3 # hs)) +\n                            real (size_hps (h3 # hs)) /\n                            real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))\n\ngoal (1 subgoal):\n 1. 2 +\n    (log 2\n      (real (1 + size_hps hsx + size_hps hsy) /\n       real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) +\n     log 2\n      (real (size_hps (h3 # hs)) /\n       real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))))\n    \\<le> 2 *\n          log 2\n           (real (1 + size_hps hsx + size_hps hsy) /\n            real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)) +\n            real (size_hps (h3 # hs)) /\n            real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))", "using s3"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < real (1 + size_hps hsx + size_hps hsy) /\n               real (size_hps (Hp x hsx # Hp y hsy # h3 # hs));\n   0 < real (size_hps (h3 # hs)) /\n       real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))\\<rbrakk>\n  \\<Longrightarrow> log 2\n                     (real (1 + size_hps hsx + size_hps hsy) /\n                      real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) +\n                    log 2\n                     (real (size_hps (h3 # hs)) /\n                      real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) +\n                    2\n                    \\<le> 2 *\n                          log 2\n                           (real (1 + size_hps hsx + size_hps hsy) /\n                            real\n                             (size_hps (Hp x hsx # Hp y hsy # h3 # hs)) +\n                            real (size_hps (h3 # hs)) /\n                            real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))\n  0 < size_hp h3\n\ngoal (1 subgoal):\n 1. 2 +\n    (log 2\n      (real (1 + size_hps hsx + size_hps hsy) /\n       real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) +\n     log 2\n      (real (size_hps (h3 # hs)) /\n       real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))))\n    \\<le> 2 *\n          log 2\n           (real (1 + size_hps hsx + size_hps hsy) /\n            real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)) +\n            real (size_hps (h3 # hs)) /\n            real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))", "by simp"], ["proof (state)\nthis:\n  2 +\n  (log 2\n    (real (1 + size_hps hsx + size_hps hsy) /\n     real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) +\n   log 2\n    (real (size_hps (h3 # hs)) /\n     real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))))\n  \\<le> 2 *\n        log 2\n         (real (1 + size_hps hsx + size_hps hsy) /\n          real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)) +\n          real (size_hps (h3 # hs)) /\n          real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))\n\ngoal (1 subgoal):\n 1. log 2\n     (real (1 + size_hps hsx + size_hps hsy) /\n      real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) +\n    log 2\n     (real (size_hps (h3 # hs)) /\n      real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))\n    \\<le> - 2", "also"], ["proof (state)\nthis:\n  2 +\n  (log 2\n    (real (1 + size_hps hsx + size_hps hsy) /\n     real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) +\n   log 2\n    (real (size_hps (h3 # hs)) /\n     real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))))\n  \\<le> 2 *\n        log 2\n         (real (1 + size_hps hsx + size_hps hsy) /\n          real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)) +\n          real (size_hps (h3 # hs)) /\n          real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))\n\ngoal (1 subgoal):\n 1. log 2\n     (real (1 + size_hps hsx + size_hps hsy) /\n      real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) +\n    log 2\n     (real (size_hps (h3 # hs)) /\n      real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))\n    \\<le> - 2", "have \"\\<dots> \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 *\n    log 2\n     (real (1 + size_hps hsx + size_hps hsy) /\n      real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)) +\n      real (size_hps (h3 # hs)) /\n      real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))\n    \\<le> 0", "by (simp add: field_simps log_divide add_pos_nonneg)"], ["proof (state)\nthis:\n  2 *\n  log 2\n   (real (1 + size_hps hsx + size_hps hsy) /\n    real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)) +\n    real (size_hps (h3 # hs)) /\n    real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))\n  \\<le> 0\n\ngoal (1 subgoal):\n 1. log 2\n     (real (1 + size_hps hsx + size_hps hsy) /\n      real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) +\n    log 2\n     (real (size_hps (h3 # hs)) /\n      real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))\n    \\<le> - 2", "finally"], ["proof (chain)\npicking this:\n  2 +\n  (log 2\n    (real (1 + size_hps hsx + size_hps hsy) /\n     real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) +\n   log 2\n    (real (size_hps (h3 # hs)) /\n     real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))))\n  \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  2 +\n  (log 2\n    (real (1 + size_hps hsx + size_hps hsy) /\n     real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) +\n   log 2\n    (real (size_hps (h3 # hs)) /\n     real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))))\n  \\<le> 0\n\ngoal (1 subgoal):\n 1. log 2\n     (real (1 + size_hps hsx + size_hps hsy) /\n      real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) +\n    log 2\n     (real (size_hps (h3 # hs)) /\n      real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))\n    \\<le> - 2", "by linarith"], ["proof (state)\nthis:\n  log 2\n   (real (1 + size_hps hsx + size_hps hsy) /\n    real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) +\n  log 2\n   (real (size_hps (h3 # hs)) /\n    real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))\n  \\<le> - 2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  log 2\n   (real (1 + size_hps hsx + size_hps hsy) /\n    real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) +\n  log 2\n   (real (size_hps (h3 # hs)) /\n    real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))\n  \\<le> - 2\n\ngoal (1 subgoal):\n 1. log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n    log 2 (real (1 + size_hps hsy + size_hps (h3 # hs)))\n    \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) -\n          2 * log 2 (real (size_hps (h3 # hs))) -\n          2", "finally"], ["proof (chain)\npicking this:\n  log 2 (real (1 + size_hps hsx + size_hps hsy)) +\n  log 2 (real (size_hps (h3 # hs))) -\n  2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))\n  \\<le> - 2", "have \"log 2 (1 + size_hps hsx + size_hps hsy) + log 2 (size_hps ?ry) + 2\n      \\<le>  2*log 2 (size_hps ?h)\""], ["proof (prove)\nusing this:\n  log 2 (real (1 + size_hps hsx + size_hps hsy)) +\n  log 2 (real (size_hps (h3 # hs))) -\n  2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))\n  \\<le> - 2\n\ngoal (1 subgoal):\n 1. log 2 (real (1 + size_hps hsx + size_hps hsy)) +\n    log 2 (real (size_hps (h3 # hs))) +\n    2\n    \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))", "by simp"], ["proof (state)\nthis:\n  log 2 (real (1 + size_hps hsx + size_hps hsy)) +\n  log 2 (real (size_hps (h3 # hs))) +\n  2\n  \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))\n\ngoal (1 subgoal):\n 1. log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n    log 2 (real (1 + size_hps hsy + size_hps (h3 # hs)))\n    \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) -\n          2 * log 2 (real (size_hps (h3 # hs))) -\n          2", "moreover"], ["proof (state)\nthis:\n  log 2 (real (1 + size_hps hsx + size_hps hsy)) +\n  log 2 (real (size_hps (h3 # hs))) +\n  2\n  \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))\n\ngoal (1 subgoal):\n 1. log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n    log 2 (real (1 + size_hps hsy + size_hps (h3 # hs)))\n    \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) -\n          2 * log 2 (real (size_hps (h3 # hs))) -\n          2", "have \"log 2 (size_hps ?ry) \\<le> log 2 (size_hps ?rx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. log 2 (real (size_hps (h3 # hs)))\n    \\<le> log 2 (real (size_hps (Hp y hsy # h3 # hs)))", "using s3"], ["proof (prove)\nusing this:\n  0 < size_hp h3\n\ngoal (1 subgoal):\n 1. log 2 (real (size_hps (h3 # hs)))\n    \\<le> log 2 (real (size_hps (Hp y hsy # h3 # hs)))", "by simp"], ["proof (state)\nthis:\n  log 2 (real (size_hps (h3 # hs)))\n  \\<le> log 2 (real (size_hps (Hp y hsy # h3 # hs)))\n\ngoal (1 subgoal):\n 1. log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n    log 2 (real (1 + size_hps hsy + size_hps (h3 # hs)))\n    \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) -\n          2 * log 2 (real (size_hps (h3 # hs))) -\n          2", "ultimately"], ["proof (chain)\npicking this:\n  log 2 (real (1 + size_hps hsx + size_hps hsy)) +\n  log 2 (real (size_hps (h3 # hs))) +\n  2\n  \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))\n  log 2 (real (size_hps (h3 # hs)))\n  \\<le> log 2 (real (size_hps (Hp y hsy # h3 # hs)))", "have \"log 2 (1 + size_hps hsx + size_hps hsy) - \\<dots> \n      \\<le>  2*log 2 (size_hps ?h) - 2*log 2 (size_hps ?ry) - 2\""], ["proof (prove)\nusing this:\n  log 2 (real (1 + size_hps hsx + size_hps hsy)) +\n  log 2 (real (size_hps (h3 # hs))) +\n  2\n  \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs)))\n  log 2 (real (size_hps (h3 # hs)))\n  \\<le> log 2 (real (size_hps (Hp y hsy # h3 # hs)))\n\ngoal (1 subgoal):\n 1. log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n    log 2 (real (size_hps (Hp y hsy # h3 # hs)))\n    \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) -\n          2 * log 2 (real (size_hps (h3 # hs))) -\n          2", "by linarith"], ["proof (state)\nthis:\n  log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n  log 2 (real (size_hps (Hp y hsy # h3 # hs)))\n  \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) -\n        2 * log 2 (real (size_hps (h3 # hs))) -\n        2\n\ngoal (1 subgoal):\n 1. log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n    log 2 (real (1 + size_hps hsy + size_hps (h3 # hs)))\n    \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) -\n          2 * log 2 (real (size_hps (h3 # hs))) -\n          2", "thus ?thesis"], ["proof (prove)\nusing this:\n  log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n  log 2 (real (size_hps (Hp y hsy # h3 # hs)))\n  \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) -\n        2 * log 2 (real (size_hps (h3 # hs))) -\n        2\n\ngoal (1 subgoal):\n 1. log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n    log 2 (real (1 + size_hps hsy + size_hps (h3 # hs)))\n    \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) -\n          2 * log 2 (real (size_hps (h3 # hs))) -\n          2", "by simp"], ["proof (state)\nthis:\n  log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n  log 2 (real (1 + size_hps hsy + size_hps (h3 # hs)))\n  \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) -\n        2 * log 2 (real (size_hps (h3 # hs))) -\n        2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  log 2 (real (1 + size_hps hsx + size_hps hsy)) -\n  log 2 (real (1 + size_hps hsy + size_hps (h3 # hs)))\n  \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) -\n        2 * log 2 (real (size_hps (h3 # hs))) -\n        2\n\ngoal (3 subgoals):\n 1. no_Emptys [] \\<Longrightarrow>\n    \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_.\n       no_Emptys [uu_] \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 [uu_]) - \\<Phi>_hps [uu_] \\<le> sum_ub [uu_]\n 3. \\<And>h1 h2 v va.\n       \\<lbrakk>no_Emptys (v # va) \\<Longrightarrow>\n                \\<Phi>_hps (pass\\<^sub>1 (v # va)) - \\<Phi>_hps (v # va)\n                \\<le> sum_ub (v # va);\n        no_Emptys (h1 # h2 # v # va)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi>_hps (pass\\<^sub>1 (h1 # h2 # v # va)) -\n                         \\<Phi>_hps (h1 # h2 # v # va)\n                         \\<le> sum_ub (h1 # h2 # v # va)", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + sum_ub (h3 # hs) \\<le> y + sum_ub (h3 # hs)) \\<Longrightarrow>\n  \\<Phi>_hps (pass\\<^sub>1 (Hp x hsx # Hp y hsy # h3 # hs)) -\n  \\<Phi>_hps (Hp x hsx # Hp y hsy # h3 # hs)\n  \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) -\n        2 * log 2 (real (size_hps (h3 # hs))) -\n        2 +\n        sum_ub (h3 # hs)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      x + sum_ub (h3 # hs) \\<le> y + sum_ub (h3 # hs)) \\<Longrightarrow>\n  \\<Phi>_hps (pass\\<^sub>1 (Hp x hsx # Hp y hsy # h3 # hs)) -\n  \\<Phi>_hps (Hp x hsx # Hp y hsy # h3 # hs)\n  \\<le> 2 * log 2 (real (size_hps (Hp x hsx # Hp y hsy # h3 # hs))) -\n        2 * log 2 (real (size_hps (h3 # hs))) -\n        2 +\n        sum_ub (h3 # hs)\n\ngoal (1 subgoal):\n 1. \\<Phi>_hps (pass\\<^sub>1 (h1 # h2 # h3 # hs)) -\n    \\<Phi>_hps (h1 # h2 # h3 # hs)\n    \\<le> sum_ub (h1 # h2 # h3 # hs)", "by (simp)"], ["proof (state)\nthis:\n  \\<Phi>_hps (pass\\<^sub>1 (h1 # h2 # h3 # hs)) -\n  \\<Phi>_hps (h1 # h2 # h3 # hs)\n  \\<le> sum_ub (h1 # h2 # h3 # hs)\n\ngoal (2 subgoals):\n 1. no_Emptys [] \\<Longrightarrow>\n    \\<Phi>_hps (pass\\<^sub>1 []) - \\<Phi>_hps [] \\<le> sum_ub []\n 2. \\<And>uu_.\n       no_Emptys [uu_] \\<Longrightarrow>\n       \\<Phi>_hps (pass\\<^sub>1 [uu_]) - \\<Phi>_hps [uu_] \\<le> sum_ub [uu_]", "qed simp_all"], ["", "lemma \\<Delta>\\<Phi>_pass1: assumes \"hs \\<noteq> []\" \"no_Emptys hs\"\n  shows \"\\<Phi>_hps (pass\\<^sub>1 hs) - \\<Phi>_hps hs \\<le> 2 * log 2 (size_hps hs) - length hs + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>_hps (pass\\<^sub>1 hs) - \\<Phi>_hps hs\n    \\<le> 2 * log 2 (real (size_hps hs)) - real (length hs) + 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi>_hps (pass\\<^sub>1 hs) - \\<Phi>_hps hs\n    \\<le> 2 * log 2 (real (size_hps hs)) - real (length hs) + 2", "have \"sum_ub hs \\<le> 2 * log 2 (size_hps hs) - length hs + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_ub hs \\<le> 2 * log 2 (real (size_hps hs)) - real (length hs) + 2", "using assms"], ["proof (prove)\nusing this:\n  hs \\<noteq> []\n  no_Emptys hs\n\ngoal (1 subgoal):\n 1. sum_ub hs \\<le> 2 * log 2 (real (size_hps hs)) - real (length hs) + 2", "by (induct hs rule: sum_ub.induct) (auto dest: no_Empty_ge0)"], ["proof (state)\nthis:\n  sum_ub hs \\<le> 2 * log 2 (real (size_hps hs)) - real (length hs) + 2\n\ngoal (1 subgoal):\n 1. \\<Phi>_hps (pass\\<^sub>1 hs) - \\<Phi>_hps hs\n    \\<le> 2 * log 2 (real (size_hps hs)) - real (length hs) + 2", "thus ?thesis"], ["proof (prove)\nusing this:\n  sum_ub hs \\<le> 2 * log 2 (real (size_hps hs)) - real (length hs) + 2\n\ngoal (1 subgoal):\n 1. \\<Phi>_hps (pass\\<^sub>1 hs) - \\<Phi>_hps hs\n    \\<le> 2 * log 2 (real (size_hps hs)) - real (length hs) + 2", "using \\<Delta>\\<Phi>_pass1_sum_ub[OF assms(2)]"], ["proof (prove)\nusing this:\n  sum_ub hs \\<le> 2 * log 2 (real (size_hps hs)) - real (length hs) + 2\n  \\<Phi>_hps (pass\\<^sub>1 hs) - \\<Phi>_hps hs \\<le> sum_ub hs\n\ngoal (1 subgoal):\n 1. \\<Phi>_hps (pass\\<^sub>1 hs) - \\<Phi>_hps hs\n    \\<le> 2 * log 2 (real (size_hps hs)) - real (length hs) + 2", "by linarith"], ["proof (state)\nthis:\n  \\<Phi>_hps (pass\\<^sub>1 hs) - \\<Phi>_hps hs\n  \\<le> 2 * log 2 (real (size_hps hs)) - real (length hs) + 2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma size_hps_pass2: \"hs \\<noteq> [] \\<Longrightarrow> no_Emptys hs \\<Longrightarrow>\n  no_Empty(pass\\<^sub>2 hs) & size_hps hs = size_hps(hps(pass\\<^sub>2 hs))+1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hs \\<noteq> []; no_Emptys hs\\<rbrakk>\n    \\<Longrightarrow> no_Empty (pass\\<^sub>2 hs) \\<and>\n                      size_hps hs = size_hps (hps (pass\\<^sub>2 hs)) + 1", "apply(induction hs rule: \\<Phi>_hps.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; no_Emptys []\\<rbrakk>\n    \\<Longrightarrow> no_Empty (pass\\<^sub>2 []) \\<and>\n                      size_hps [] = size_hps (hps (pass\\<^sub>2 [])) + 1\n 2. \\<And>hs.\n       \\<lbrakk>\\<lbrakk>hs \\<noteq> []; no_Emptys hs\\<rbrakk>\n                \\<Longrightarrow> no_Empty (pass\\<^sub>2 hs) \\<and>\n                                  size_hps hs =\n                                  size_hps (hps (pass\\<^sub>2 hs)) + 1;\n        heap.Empty # hs \\<noteq> []; no_Emptys (heap.Empty # hs)\\<rbrakk>\n       \\<Longrightarrow> no_Empty (pass\\<^sub>2 (heap.Empty # hs)) \\<and>\n                         size_hps (heap.Empty # hs) =\n                         size_hps (hps (pass\\<^sub>2 (heap.Empty # hs))) + 1\n 3. \\<And>x hsl hsr.\n       \\<lbrakk>\\<lbrakk>hsl \\<noteq> []; no_Emptys hsl\\<rbrakk>\n                \\<Longrightarrow> no_Empty (pass\\<^sub>2 hsl) \\<and>\n                                  size_hps hsl =\n                                  size_hps (hps (pass\\<^sub>2 hsl)) + 1;\n        \\<lbrakk>hsr \\<noteq> []; no_Emptys hsr\\<rbrakk>\n        \\<Longrightarrow> no_Empty (pass\\<^sub>2 hsr) \\<and>\n                          size_hps hsr =\n                          size_hps (hps (pass\\<^sub>2 hsr)) + 1;\n        Hp x hsl # hsr \\<noteq> []; no_Emptys (Hp x hsl # hsr)\\<rbrakk>\n       \\<Longrightarrow> no_Empty (pass\\<^sub>2 (Hp x hsl # hsr)) \\<and>\n                         size_hps (Hp x hsl # hsr) =\n                         size_hps (hps (pass\\<^sub>2 (Hp x hsl # hsr))) + 1", "apply (fastforce simp: merge2 split: heap.split)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<Delta>\\<Phi>_pass2: \"hs \\<noteq> [] \\<Longrightarrow> no_Emptys hs \\<Longrightarrow>\n  \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs \\<le> log 2 (size_hps hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>hs \\<noteq> []; no_Emptys hs\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs\n                      \\<le> log 2 (real (size_hps hs))", "proof (induction hs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; no_Emptys []\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 []) - \\<Phi>_hps []\n                      \\<le> log 2 (real (size_hps []))\n 2. \\<And>a hs.\n       \\<lbrakk>\\<lbrakk>hs \\<noteq> []; no_Emptys hs\\<rbrakk>\n                \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs\n                                  \\<le> log 2 (real (size_hps hs));\n        a # hs \\<noteq> []; no_Emptys (a # hs)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 (a # hs)) -\n                         \\<Phi>_hps (a # hs)\n                         \\<le> log 2 (real (size_hps (a # hs)))", "case (Cons h hs)"], ["proof (state)\nthis:\n  \\<lbrakk>hs \\<noteq> []; no_Emptys hs\\<rbrakk>\n  \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs\n                    \\<le> log 2 (real (size_hps hs))\n  h # hs \\<noteq> []\n  no_Emptys (h # hs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; no_Emptys []\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 []) - \\<Phi>_hps []\n                      \\<le> log 2 (real (size_hps []))\n 2. \\<And>a hs.\n       \\<lbrakk>\\<lbrakk>hs \\<noteq> []; no_Emptys hs\\<rbrakk>\n                \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs\n                                  \\<le> log 2 (real (size_hps hs));\n        a # hs \\<noteq> []; no_Emptys (a # hs)\\<rbrakk>\n       \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 (a # hs)) -\n                         \\<Phi>_hps (a # hs)\n                         \\<le> log 2 (real (size_hps (a # hs)))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>hs \\<noteq> []; no_Emptys hs\\<rbrakk>\n  \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs\n                    \\<le> log 2 (real (size_hps hs))\n  h # hs \\<noteq> []\n  no_Emptys (h # hs)\n\ngoal (1 subgoal):\n 1. \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n    \\<le> log 2 (real (size_hps (h # hs)))", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>hs \\<noteq> []; no_Emptys hs\\<rbrakk>\n             \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs\n                               \\<le> log 2 (real (size_hps hs));\n     h # hs \\<noteq> []; no_Emptys (h # hs); ?P3\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n                      \\<le> log 2 (real (size_hps (h # hs)))\n 2. \\<lbrakk>\\<lbrakk>hs \\<noteq> []; no_Emptys hs\\<rbrakk>\n             \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs\n                               \\<le> log 2 (real (size_hps hs));\n     h # hs \\<noteq> []; no_Emptys (h # hs); \\<not> ?P3\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n                      \\<le> log 2 (real (size_hps (h # hs)))", "assume \"hs = []\""], ["proof (state)\nthis:\n  hs = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>hs \\<noteq> []; no_Emptys hs\\<rbrakk>\n             \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs\n                               \\<le> log 2 (real (size_hps hs));\n     h # hs \\<noteq> []; no_Emptys (h # hs); ?P3\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n                      \\<le> log 2 (real (size_hps (h # hs)))\n 2. \\<lbrakk>\\<lbrakk>hs \\<noteq> []; no_Emptys hs\\<rbrakk>\n             \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs\n                               \\<le> log 2 (real (size_hps hs));\n     h # hs \\<noteq> []; no_Emptys (h # hs); \\<not> ?P3\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n                      \\<le> log 2 (real (size_hps (h # hs)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  hs = []\n\ngoal (1 subgoal):\n 1. \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n    \\<le> log 2 (real (size_hps (h # hs)))", "using Cons"], ["proof (prove)\nusing this:\n  hs = []\n  \\<lbrakk>hs \\<noteq> []; no_Emptys hs\\<rbrakk>\n  \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs\n                    \\<le> log 2 (real (size_hps hs))\n  h # hs \\<noteq> []\n  no_Emptys (h # hs)\n\ngoal (1 subgoal):\n 1. \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n    \\<le> log 2 (real (size_hps (h # hs)))", "by (auto simp add: \\<Phi>_hps1 dest: no_Empty_ge0)"], ["proof (state)\nthis:\n  \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n  \\<le> log 2 (real (size_hps (h # hs)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>hs \\<noteq> []; no_Emptys hs\\<rbrakk>\n             \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs\n                               \\<le> log 2 (real (size_hps hs));\n     h # hs \\<noteq> []; no_Emptys (h # hs); hs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n                      \\<le> log 2 (real (size_hps (h # hs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>hs \\<noteq> []; no_Emptys hs\\<rbrakk>\n             \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs\n                               \\<le> log 2 (real (size_hps hs));\n     h # hs \\<noteq> []; no_Emptys (h # hs); hs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n                      \\<le> log 2 (real (size_hps (h # hs)))", "assume *: \"hs \\<noteq> []\""], ["proof (state)\nthis:\n  hs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>hs \\<noteq> []; no_Emptys hs\\<rbrakk>\n             \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs\n                               \\<le> log 2 (real (size_hps hs));\n     h # hs \\<noteq> []; no_Emptys (h # hs); hs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n                      \\<le> log 2 (real (size_hps (h # hs)))", "obtain x hs2 where [simp]: \"h = Hp x hs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x hs2. h = Hp x hs2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons.prems(2)"], ["proof (prove)\nusing this:\n  no_Emptys (h # hs)\n\ngoal (1 subgoal):\n 1. (\\<And>x hs2. h = Hp x hs2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp (meson no_Empty.elims(2))"], ["proof (state)\nthis:\n  h = Hp x hs2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>hs \\<noteq> []; no_Emptys hs\\<rbrakk>\n             \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs\n                               \\<le> log 2 (real (size_hps hs));\n     h # hs \\<noteq> []; no_Emptys (h # hs); hs \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n                      \\<le> log 2 (real (size_hps (h # hs)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n    \\<le> log 2 (real (size_hps (h # hs)))", "proof (cases \"pass\\<^sub>2 hs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. pass\\<^sub>2 hs = heap.Empty \\<Longrightarrow>\n    \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n    \\<le> log 2 (real (size_hps (h # hs)))\n 2. \\<And>x21 x22.\n       pass\\<^sub>2 hs = Hp x21 x22 \\<Longrightarrow>\n       \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n       \\<le> log 2 (real (size_hps (h # hs)))", "case Empty"], ["proof (state)\nthis:\n  pass\\<^sub>2 hs = heap.Empty\n\ngoal (2 subgoals):\n 1. pass\\<^sub>2 hs = heap.Empty \\<Longrightarrow>\n    \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n    \\<le> log 2 (real (size_hps (h # hs)))\n 2. \\<And>x21 x22.\n       pass\\<^sub>2 hs = Hp x21 x22 \\<Longrightarrow>\n       \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n       \\<le> log 2 (real (size_hps (h # hs)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  pass\\<^sub>2 hs = heap.Empty\n\ngoal (1 subgoal):\n 1. \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n    \\<le> log 2 (real (size_hps (h # hs)))", "using \\<Phi>_hps_ge0[of hs]"], ["proof (prove)\nusing this:\n  pass\\<^sub>2 hs = heap.Empty\n  0 \\<le> \\<Phi>_hps hs\n\ngoal (1 subgoal):\n 1. \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n    \\<le> log 2 (real (size_hps (h # hs)))", "by(simp add: add_increasing xt1(3)[OF mult_2, OF add_increasing])"], ["proof (state)\nthis:\n  \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n  \\<le> log 2 (real (size_hps (h # hs)))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       pass\\<^sub>2 hs = Hp x21 x22 \\<Longrightarrow>\n       \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n       \\<le> log 2 (real (size_hps (h # hs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       pass\\<^sub>2 hs = Hp x21 x22 \\<Longrightarrow>\n       \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n       \\<le> log 2 (real (size_hps (h # hs)))", "case (Hp y hs3)"], ["proof (state)\nthis:\n  pass\\<^sub>2 hs = Hp y hs3\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       pass\\<^sub>2 hs = Hp x21 x22 \\<Longrightarrow>\n       \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n       \\<le> log 2 (real (size_hps (h # hs)))", "with Cons * size_hps_pass2[of hs]"], ["proof (chain)\npicking this:\n  \\<lbrakk>hs \\<noteq> []; no_Emptys hs\\<rbrakk>\n  \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs\n                    \\<le> log 2 (real (size_hps hs))\n  h # hs \\<noteq> []\n  no_Emptys (h # hs)\n  hs \\<noteq> []\n  \\<lbrakk>hs \\<noteq> []; no_Emptys hs\\<rbrakk>\n  \\<Longrightarrow> no_Empty (pass\\<^sub>2 hs) \\<and>\n                    size_hps hs = size_hps (hps (pass\\<^sub>2 hs)) + 1\n  pass\\<^sub>2 hs = Hp y hs3", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>hs \\<noteq> []; no_Emptys hs\\<rbrakk>\n  \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 hs) - \\<Phi>_hps hs\n                    \\<le> log 2 (real (size_hps hs))\n  h # hs \\<noteq> []\n  no_Emptys (h # hs)\n  hs \\<noteq> []\n  \\<lbrakk>hs \\<noteq> []; no_Emptys hs\\<rbrakk>\n  \\<Longrightarrow> no_Empty (pass\\<^sub>2 hs) \\<and>\n                    size_hps hs = size_hps (hps (pass\\<^sub>2 hs)) + 1\n  pass\\<^sub>2 hs = Hp y hs3\n\ngoal (1 subgoal):\n 1. \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n    \\<le> log 2 (real (size_hps (h # hs)))", "by(auto simp: add_mono)"], ["proof (state)\nthis:\n  \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n  \\<le> log 2 (real (size_hps (h # hs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n  \\<le> log 2 (real (size_hps (h # hs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi> (pass\\<^sub>2 (h # hs)) - \\<Phi>_hps (h # hs)\n  \\<le> log 2 (real (size_hps (h # hs)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>[] \\<noteq> []; no_Emptys []\\<rbrakk>\n    \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 []) - \\<Phi>_hps []\n                      \\<le> log 2 (real (size_hps []))", "qed simp"], ["", "lemma \\<Delta>\\<Phi>_del_min: assumes \"hps h \\<noteq> []\" \"no_Empty h\"\n  shows \"\\<Phi> (del_min h) - \\<Phi> h \n  \\<le> 3 * log 2 (size_hps(hps h)) - length(hps h) + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "obtain x hs where [simp]: \"h = Hp x hs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x hs. h = Hp x hs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  no_Empty h\n\ngoal (1 subgoal):\n 1. (\\<And>x hs. h = Hp x hs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases h) auto"], ["proof (state)\nthis:\n  h = Hp x hs\n\ngoal (1 subgoal):\n 1. \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "let ?\\<Delta>\\<Phi>\\<^sub>1 = \"\\<Phi>_hps(hps h) - \\<Phi> h\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "let ?\\<Delta>\\<Phi>\\<^sub>2 = \"\\<Phi>(pass\\<^sub>2(pass\\<^sub>1 (hps h))) - \\<Phi>_hps (hps h)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "let ?\\<Delta>\\<Phi> = \"\\<Phi> (del_min h) - \\<Phi> h\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "have \"\\<Phi>(pass\\<^sub>2(pass\\<^sub>1(hps h))) - \\<Phi>_hps (pass\\<^sub>1(hps h)) \\<le> log 2 (size_hps(hps h))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> (pass\\<^sub>2 (pass\\<^sub>1 (hps h))) -\n    \\<Phi>_hps (pass\\<^sub>1 (hps h))\n    \\<le> log 2 (real (size_hps (hps h)))", "using \\<Delta>\\<Phi>_pass2[of \"pass\\<^sub>1(hps h)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>pass\\<^sub>1 (hps h) \\<noteq> [];\n   no_Emptys (pass\\<^sub>1 (hps h))\\<rbrakk>\n  \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 (pass\\<^sub>1 (hps h))) -\n                    \\<Phi>_hps (pass\\<^sub>1 (hps h))\n                    \\<le> log 2 (real (size_hps (pass\\<^sub>1 (hps h))))\n\ngoal (1 subgoal):\n 1. \\<Phi> (pass\\<^sub>2 (pass\\<^sub>1 (hps h))) -\n    \\<Phi>_hps (pass\\<^sub>1 (hps h))\n    \\<le> log 2 (real (size_hps (hps h)))", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>pass\\<^sub>1 (hps h) \\<noteq> [];\n   no_Emptys (pass\\<^sub>1 (hps h))\\<rbrakk>\n  \\<Longrightarrow> \\<Phi> (pass\\<^sub>2 (pass\\<^sub>1 (hps h))) -\n                    \\<Phi>_hps (pass\\<^sub>1 (hps h))\n                    \\<le> log 2 (real (size_hps (pass\\<^sub>1 (hps h))))\n  hps h \\<noteq> []\n  no_Empty h\n\ngoal (1 subgoal):\n 1. \\<Phi> (pass\\<^sub>2 (pass\\<^sub>1 (hps h))) -\n    \\<Phi>_hps (pass\\<^sub>1 (hps h))\n    \\<le> log 2 (real (size_hps (hps h)))", "by (auto simp: pass1_Nil_iff no_Emptys_pass1 dest: no_Emptys_hps)"], ["proof (state)\nthis:\n  \\<Phi> (pass\\<^sub>2 (pass\\<^sub>1 (hps h))) -\n  \\<Phi>_hps (pass\\<^sub>1 (hps h))\n  \\<le> log 2 (real (size_hps (hps h)))\n\ngoal (1 subgoal):\n 1. \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "moreover"], ["proof (state)\nthis:\n  \\<Phi> (pass\\<^sub>2 (pass\\<^sub>1 (hps h))) -\n  \\<Phi>_hps (pass\\<^sub>1 (hps h))\n  \\<le> log 2 (real (size_hps (hps h)))\n\ngoal (1 subgoal):\n 1. \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "have \"\\<Phi>_hps (pass\\<^sub>1 (hps h)) - \\<Phi>_hps (hps h) \\<le>  2*\\<dots> - length (hps h) + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>_hps (pass\\<^sub>1 (hps h)) - \\<Phi>_hps (hps h)\n    \\<le> 2 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "using \\<Delta>\\<Phi>_pass1[OF assms(1) no_Emptys_hps[OF assms(2)]]"], ["proof (prove)\nusing this:\n  \\<Phi>_hps (pass\\<^sub>1 (hps h)) - \\<Phi>_hps (hps h)\n  \\<le> 2 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2\n\ngoal (1 subgoal):\n 1. \\<Phi>_hps (pass\\<^sub>1 (hps h)) - \\<Phi>_hps (hps h)\n    \\<le> 2 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "by blast"], ["proof (state)\nthis:\n  \\<Phi>_hps (pass\\<^sub>1 (hps h)) - \\<Phi>_hps (hps h)\n  \\<le> 2 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2\n\ngoal (1 subgoal):\n 1. \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "moreover"], ["proof (state)\nthis:\n  \\<Phi>_hps (pass\\<^sub>1 (hps h)) - \\<Phi>_hps (hps h)\n  \\<le> 2 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2\n\ngoal (1 subgoal):\n 1. \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "have \"?\\<Delta>\\<Phi>\\<^sub>1 \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>_hps (hps h) - \\<Phi> h \\<le> 0", "by simp"], ["proof (state)\nthis:\n  \\<Phi>_hps (hps h) - \\<Phi> h \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "moreover"], ["proof (state)\nthis:\n  \\<Phi>_hps (hps h) - \\<Phi> h \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "have \"?\\<Delta>\\<Phi> = ?\\<Delta>\\<Phi>\\<^sub>1 + ?\\<Delta>\\<Phi>\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> (del_min h) - \\<Phi> h =\n    \\<Phi>_hps (hps h) - \\<Phi> h +\n    (\\<Phi> (pass\\<^sub>2 (pass\\<^sub>1 (hps h))) - \\<Phi>_hps (hps h))", "by simp"], ["proof (state)\nthis:\n  \\<Phi> (del_min h) - \\<Phi> h =\n  \\<Phi>_hps (hps h) - \\<Phi> h +\n  (\\<Phi> (pass\\<^sub>2 (pass\\<^sub>1 (hps h))) - \\<Phi>_hps (hps h))\n\ngoal (1 subgoal):\n 1. \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "ultimately"], ["proof (chain)\npicking this:\n  \\<Phi> (pass\\<^sub>2 (pass\\<^sub>1 (hps h))) -\n  \\<Phi>_hps (pass\\<^sub>1 (hps h))\n  \\<le> log 2 (real (size_hps (hps h)))\n  \\<Phi>_hps (pass\\<^sub>1 (hps h)) - \\<Phi>_hps (hps h)\n  \\<le> 2 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2\n  \\<Phi>_hps (hps h) - \\<Phi> h \\<le> 0\n  \\<Phi> (del_min h) - \\<Phi> h =\n  \\<Phi>_hps (hps h) - \\<Phi> h +\n  (\\<Phi> (pass\\<^sub>2 (pass\\<^sub>1 (hps h))) - \\<Phi>_hps (hps h))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Phi> (pass\\<^sub>2 (pass\\<^sub>1 (hps h))) -\n  \\<Phi>_hps (pass\\<^sub>1 (hps h))\n  \\<le> log 2 (real (size_hps (hps h)))\n  \\<Phi>_hps (pass\\<^sub>1 (hps h)) - \\<Phi>_hps (hps h)\n  \\<le> 2 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2\n  \\<Phi>_hps (hps h) - \\<Phi> h \\<le> 0\n  \\<Phi> (del_min h) - \\<Phi> h =\n  \\<Phi>_hps (hps h) - \\<Phi> h +\n  (\\<Phi> (pass\\<^sub>2 (pass\\<^sub>1 (hps h))) - \\<Phi>_hps (hps h))\n\ngoal (1 subgoal):\n 1. \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2", "by linarith"], ["proof (state)\nthis:\n  \\<Phi> (del_min h) - \\<Phi> h\n  \\<le> 3 * log 2 (real (size_hps (hps h))) - real (length (hps h)) + 2\n\ngoal:\nNo subgoals!", "qed"], ["", "fun exec :: \"'a :: linorder op \\<Rightarrow> 'a heap list \\<Rightarrow> 'a heap\" where\n\"exec Empty [] = heap.Empty\" | \n\"exec Del_min [h] = del_min h\" |\n\"exec (Insert x) [h] = Pairing_Heap_List1.insert x h\" |\n\"exec Merge [h1,h2] = merge h1 h2\""], ["", "fun T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1 :: \"'a heap list \\<Rightarrow> nat\" where\n  \"T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1 [] = 1\"\n| \"T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1 [_] = 1\"\n| \"T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1 (_ # _ # hs) = 1 + T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1 hs\""], ["", "fun T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>2 :: \"'a heap list \\<Rightarrow> nat\" where\n \"T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>2 [] = 1\"\n| \"T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>2 (_ # hs) = 1 + T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>2 hs\""], ["", "fun cost :: \"'a :: linorder op \\<Rightarrow> 'a heap list \\<Rightarrow> nat\" where\n\"cost Empty _ = 1\" |\n\"cost Del_min [heap.Empty] = 1\" |\n\"cost Del_min [Hp x hs] = T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>2 (pass\\<^sub>1 hs) + T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1 hs\" |\n\"cost (Insert a) _ = 1\" |\n\"cost Merge _ = 1\""], ["", "fun U :: \"'a :: linorder op \\<Rightarrow> 'a heap list \\<Rightarrow> real\" where\n\"U Empty _ = 1\" |\n\"U (Insert a) [h] = log 2 (size_hp h + 1) + 1\" |\n\"U Del_min [h] = 3*log 2 (size_hp h + 1) + 4\" |\n\"U Merge [h1,h2] = log 2 (size_hp h1 + size_hp h2 + 1) + 2\""], ["", "interpretation pairing: Amortized\nwhere arity = arity and exec = exec and cost = cost and inv = \"is_root\"\nand \\<Phi> = \\<Phi> and U = U"], ["proof (prove)\ngoal (1 subgoal):\n 1. Amortized arity exec is_root cost \\<Phi> U", "proof (standard, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. is_root s;\n        length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> is_root (exec f ss)\n 2. \\<And>s. is_root s \\<Longrightarrow> 0 \\<le> \\<Phi> s\n 3. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. is_root s;\n        length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) + \\<Phi> (exec f ss) -\n                         sum_list (map \\<Phi> ss)\n                         \\<le> U f ss", "case (1 ss f)"], ["proof (state)\nthis:\n  \\<forall>s\\<in>set ss. is_root s\n  length ss = arity f\n\ngoal (3 subgoals):\n 1. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. is_root s;\n        length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> is_root (exec f ss)\n 2. \\<And>s. is_root s \\<Longrightarrow> 0 \\<le> \\<Phi> s\n 3. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. is_root s;\n        length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) + \\<Phi> (exec f ss) -\n                         sum_list (map \\<Phi> ss)\n                         \\<le> U f ss", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_root (exec f ss)", "proof (cases f)"], ["proof (state)\ngoal (4 subgoals):\n 1. f = op.Empty \\<Longrightarrow> is_root (exec f ss)\n 2. \\<And>x2. f = Insert x2 \\<Longrightarrow> is_root (exec f ss)\n 3. f = Del_min \\<Longrightarrow> is_root (exec f ss)\n 4. f = Merge \\<Longrightarrow> is_root (exec f ss)", "case Empty"], ["proof (state)\nthis:\n  f = op.Empty\n\ngoal (4 subgoals):\n 1. f = op.Empty \\<Longrightarrow> is_root (exec f ss)\n 2. \\<And>x2. f = Insert x2 \\<Longrightarrow> is_root (exec f ss)\n 3. f = Del_min \\<Longrightarrow> is_root (exec f ss)\n 4. f = Merge \\<Longrightarrow> is_root (exec f ss)", "with 1"], ["proof (chain)\npicking this:\n  \\<forall>s\\<in>set ss. is_root s\n  length ss = arity f\n  f = op.Empty", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>set ss. is_root s\n  length ss = arity f\n  f = op.Empty\n\ngoal (1 subgoal):\n 1. is_root (exec f ss)", "by simp"], ["proof (state)\nthis:\n  is_root (exec f ss)\n\ngoal (3 subgoals):\n 1. \\<And>x2. f = Insert x2 \\<Longrightarrow> is_root (exec f ss)\n 2. f = Del_min \\<Longrightarrow> is_root (exec f ss)\n 3. f = Merge \\<Longrightarrow> is_root (exec f ss)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2. f = Insert x2 \\<Longrightarrow> is_root (exec f ss)\n 2. f = Del_min \\<Longrightarrow> is_root (exec f ss)\n 3. f = Merge \\<Longrightarrow> is_root (exec f ss)", "case Insert"], ["proof (state)\nthis:\n  f = Insert x2_\n\ngoal (3 subgoals):\n 1. \\<And>x2. f = Insert x2 \\<Longrightarrow> is_root (exec f ss)\n 2. f = Del_min \\<Longrightarrow> is_root (exec f ss)\n 3. f = Merge \\<Longrightarrow> is_root (exec f ss)", "thus ?thesis"], ["proof (prove)\nusing this:\n  f = Insert x2_\n\ngoal (1 subgoal):\n 1. is_root (exec f ss)", "using 1"], ["proof (prove)\nusing this:\n  f = Insert x2_\n  \\<forall>s\\<in>set ss. is_root s\n  length ss = arity f\n\ngoal (1 subgoal):\n 1. is_root (exec f ss)", "by(auto simp: is_root_merge)"], ["proof (state)\nthis:\n  is_root (exec f ss)\n\ngoal (2 subgoals):\n 1. f = Del_min \\<Longrightarrow> is_root (exec f ss)\n 2. f = Merge \\<Longrightarrow> is_root (exec f ss)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. f = Del_min \\<Longrightarrow> is_root (exec f ss)\n 2. f = Merge \\<Longrightarrow> is_root (exec f ss)", "case Merge"], ["proof (state)\nthis:\n  f = Merge\n\ngoal (2 subgoals):\n 1. f = Del_min \\<Longrightarrow> is_root (exec f ss)\n 2. f = Merge \\<Longrightarrow> is_root (exec f ss)", "thus ?thesis"], ["proof (prove)\nusing this:\n  f = Merge\n\ngoal (1 subgoal):\n 1. is_root (exec f ss)", "using 1"], ["proof (prove)\nusing this:\n  f = Merge\n  \\<forall>s\\<in>set ss. is_root s\n  length ss = arity f\n\ngoal (1 subgoal):\n 1. is_root (exec f ss)", "by(auto simp: is_root_merge numeral_eq_Suc)"], ["proof (state)\nthis:\n  is_root (exec f ss)\n\ngoal (1 subgoal):\n 1. f = Del_min \\<Longrightarrow> is_root (exec f ss)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f = Del_min \\<Longrightarrow> is_root (exec f ss)", "case [simp]: Del_min"], ["proof (state)\nthis:\n  f = Del_min\n\ngoal (1 subgoal):\n 1. f = Del_min \\<Longrightarrow> is_root (exec f ss)", "then"], ["proof (chain)\npicking this:\n  f = Del_min", "obtain h where [simp]: \"ss = [h]\""], ["proof (prove)\nusing this:\n  f = Del_min\n\ngoal (1 subgoal):\n 1. (\\<And>h. ss = [h] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using 1"], ["proof (prove)\nusing this:\n  f = Del_min\n  \\<forall>s\\<in>set ss. is_root s\n  length ss = arity f\n\ngoal (1 subgoal):\n 1. (\\<And>h. ss = [h] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  ss = [h]\n\ngoal (1 subgoal):\n 1. f = Del_min \\<Longrightarrow> is_root (exec f ss)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_root (exec f ss)", "proof (cases h)"], ["proof (state)\ngoal (2 subgoals):\n 1. h = heap.Empty \\<Longrightarrow> is_root (exec f ss)\n 2. \\<And>x21 x22. h = Hp x21 x22 \\<Longrightarrow> is_root (exec f ss)", "case [simp]: (Hp _ hs)"], ["proof (state)\nthis:\n  h = Hp x21_ hs\n\ngoal (2 subgoals):\n 1. h = heap.Empty \\<Longrightarrow> is_root (exec f ss)\n 2. \\<And>x21 x22. h = Hp x21 x22 \\<Longrightarrow> is_root (exec f ss)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_root (exec f ss)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> is_root (exec f ss)\n 2. \\<not> ?P \\<Longrightarrow> is_root (exec f ss)", "assume \"hs = []\""], ["proof (state)\nthis:\n  hs = []\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> is_root (exec f ss)\n 2. \\<not> ?P \\<Longrightarrow> is_root (exec f ss)", "thus ?thesis"], ["proof (prove)\nusing this:\n  hs = []\n\ngoal (1 subgoal):\n 1. is_root (exec f ss)", "by simp"], ["proof (state)\nthis:\n  is_root (exec f ss)\n\ngoal (1 subgoal):\n 1. hs \\<noteq> [] \\<Longrightarrow> is_root (exec f ss)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. hs \\<noteq> [] \\<Longrightarrow> is_root (exec f ss)", "assume \"hs \\<noteq> []\""], ["proof (state)\nthis:\n  hs \\<noteq> []\n\ngoal (1 subgoal):\n 1. hs \\<noteq> [] \\<Longrightarrow> is_root (exec f ss)", "thus ?thesis"], ["proof (prove)\nusing this:\n  hs \\<noteq> []\n\ngoal (1 subgoal):\n 1. is_root (exec f ss)", "using 1(1) no_Emptys_pass1"], ["proof (prove)\nusing this:\n  hs \\<noteq> []\n  \\<forall>s\\<in>set ss. is_root s\n  no_Emptys ?hs \\<Longrightarrow> no_Emptys (pass\\<^sub>1 ?hs)\n\ngoal (1 subgoal):\n 1. is_root (exec f ss)", "by (auto intro: is_root_pass2)"], ["proof (state)\nthis:\n  is_root (exec f ss)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_root (exec f ss)\n\ngoal (1 subgoal):\n 1. h = heap.Empty \\<Longrightarrow> is_root (exec f ss)", "qed simp"], ["proof (state)\nthis:\n  is_root (exec f ss)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_root (exec f ss)\n\ngoal (2 subgoals):\n 1. \\<And>s. is_root s \\<Longrightarrow> 0 \\<le> \\<Phi> s\n 2. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. is_root s;\n        length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) + \\<Phi> (exec f ss) -\n                         sum_list (map \\<Phi> ss)\n                         \\<le> U f ss", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. is_root s \\<Longrightarrow> 0 \\<le> \\<Phi> s\n 2. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. is_root s;\n        length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) + \\<Phi> (exec f ss) -\n                         sum_list (map \\<Phi> ss)\n                         \\<le> U f ss", "case (2 s)"], ["proof (state)\nthis:\n  is_root s\n\ngoal (2 subgoals):\n 1. \\<And>s. is_root s \\<Longrightarrow> 0 \\<le> \\<Phi> s\n 2. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. is_root s;\n        length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) + \\<Phi> (exec f ss) -\n                         sum_list (map \\<Phi> ss)\n                         \\<le> U f ss", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<Phi> s", "by (cases s) (auto simp: \\<Phi>_hps_ge0)"], ["proof (state)\nthis:\n  0 \\<le> \\<Phi> s\n\ngoal (1 subgoal):\n 1. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. is_root s;\n        length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) + \\<Phi> (exec f ss) -\n                         sum_list (map \\<Phi> ss)\n                         \\<le> U f ss", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. is_root s;\n        length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) + \\<Phi> (exec f ss) -\n                         sum_list (map \\<Phi> ss)\n                         \\<le> U f ss", "case (3 ss f)"], ["proof (state)\nthis:\n  \\<forall>s\\<in>set ss. is_root s\n  length ss = arity f\n\ngoal (1 subgoal):\n 1. \\<And>ss f.\n       \\<lbrakk>\\<forall>s\\<in>set ss. is_root s;\n        length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> real (cost f ss) + \\<Phi> (exec f ss) -\n                         sum_list (map \\<Phi> ss)\n                         \\<le> U f ss", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "proof (cases f)"], ["proof (state)\ngoal (4 subgoals):\n 1. f = op.Empty \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 2. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n       \\<le> U f ss\n 3. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 4. f = Merge \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "case Empty"], ["proof (state)\nthis:\n  f = op.Empty\n\ngoal (4 subgoals):\n 1. f = op.Empty \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 2. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n       \\<le> U f ss\n 3. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 4. f = Merge \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "with 3"], ["proof (chain)\npicking this:\n  \\<forall>s\\<in>set ss. is_root s\n  length ss = arity f\n  f = op.Empty", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>s\\<in>set ss. is_root s\n  length ss = arity f\n  f = op.Empty\n\ngoal (1 subgoal):\n 1. real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "by(auto)"], ["proof (state)\nthis:\n  real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n  \\<le> U f ss\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n       \\<le> U f ss\n 2. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 3. f = Merge \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n       \\<le> U f ss\n 2. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 3. f = Merge \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "case Insert"], ["proof (state)\nthis:\n  f = Insert x2_\n\ngoal (3 subgoals):\n 1. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n       \\<le> U f ss\n 2. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 3. f = Merge \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "thus ?thesis"], ["proof (prove)\nusing this:\n  f = Insert x2_\n\ngoal (1 subgoal):\n 1. real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "using \\<Delta>\\<Phi>_insert 3"], ["proof (prove)\nusing this:\n  f = Insert x2_\n  \\<Phi> (Pairing_Heap_List1.insert ?x ?h) - \\<Phi> ?h\n  \\<le> log 2 (real (size_hp ?h + 1))\n  \\<forall>s\\<in>set ss. is_root s\n  length ss = arity f\n\ngoal (1 subgoal):\n 1. real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "by auto"], ["proof (state)\nthis:\n  real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n  \\<le> U f ss\n\ngoal (2 subgoals):\n 1. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 2. f = Merge \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 2. f = Merge \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "case [simp]: Del_min"], ["proof (state)\nthis:\n  f = Del_min\n\ngoal (2 subgoals):\n 1. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 2. f = Merge \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "then"], ["proof (chain)\npicking this:\n  f = Del_min", "obtain h where [simp]: \"ss = [h]\""], ["proof (prove)\nusing this:\n  f = Del_min\n\ngoal (1 subgoal):\n 1. (\\<And>h. ss = [h] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using 3"], ["proof (prove)\nusing this:\n  f = Del_min\n  \\<forall>s\\<in>set ss. is_root s\n  length ss = arity f\n\ngoal (1 subgoal):\n 1. (\\<And>h. ss = [h] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  ss = [h]\n\ngoal (2 subgoals):\n 1. f = Del_min \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 2. f = Merge \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "proof (cases h)"], ["proof (state)\ngoal (2 subgoals):\n 1. h = heap.Empty \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 2. \\<And>x21 x22.\n       h = Hp x21 x22 \\<Longrightarrow>\n       real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n       \\<le> U f ss", "case [simp]: (Hp x hs)"], ["proof (state)\nthis:\n  h = Hp x hs\n\ngoal (2 subgoals):\n 1. h = heap.Empty \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 2. \\<And>x21 x22.\n       h = Hp x21 x22 \\<Longrightarrow>\n       real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n       \\<le> U f ss", "have \"T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>2 (pass\\<^sub>1 hs) + T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1 hs \\<le> 2 + length hs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>2 (pass\\<^sub>1 hs) +\n    T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1 hs\n    \\<le> 2 + length hs", "by (induct hs rule: pass\\<^sub>1.induct) simp_all"], ["proof (state)\nthis:\n  T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>2 (pass\\<^sub>1 hs) +\n  T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1 hs\n  \\<le> 2 + length hs\n\ngoal (2 subgoals):\n 1. h = heap.Empty \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 2. \\<And>x21 x22.\n       h = Hp x21 x22 \\<Longrightarrow>\n       real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n       \\<le> U f ss", "hence  \"cost f ss \\<le> \\<dots>\""], ["proof (prove)\nusing this:\n  T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>2 (pass\\<^sub>1 hs) +\n  T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1 hs\n  \\<le> 2 + length hs\n\ngoal (1 subgoal):\n 1. cost f ss \\<le> 2 + length hs", "by simp"], ["proof (state)\nthis:\n  cost f ss \\<le> 2 + length hs\n\ngoal (2 subgoals):\n 1. h = heap.Empty \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 2. \\<And>x21 x22.\n       h = Hp x21 x22 \\<Longrightarrow>\n       real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n       \\<le> U f ss", "moreover"], ["proof (state)\nthis:\n  cost f ss \\<le> 2 + length hs\n\ngoal (2 subgoals):\n 1. h = heap.Empty \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 2. \\<And>x21 x22.\n       h = Hp x21 x22 \\<Longrightarrow>\n       real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n       \\<le> U f ss", "have  \"\\<Phi> (del_min h) - \\<Phi> h \\<le> 3*log 2 (size_hp h + 1) - length hs + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hp h + 1)) - real (length hs) + 2", "proof (cases \"hs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. hs = [] \\<Longrightarrow>\n    \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hp h + 1)) - real (length hs) + 2\n 2. hs \\<noteq> [] \\<Longrightarrow>\n    \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hp h + 1)) - real (length hs) + 2", "case False"], ["proof (state)\nthis:\n  hs \\<noteq> []\n\ngoal (2 subgoals):\n 1. hs = [] \\<Longrightarrow>\n    \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hp h + 1)) - real (length hs) + 2\n 2. hs \\<noteq> [] \\<Longrightarrow>\n    \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hp h + 1)) - real (length hs) + 2", "hence \"\\<Phi> (del_min h) - \\<Phi> h \\<le> 3*log 2 (size_hps hs) - length hs + 2\""], ["proof (prove)\nusing this:\n  hs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hps hs)) - real (length hs) + 2", "using  \\<Delta>\\<Phi>_del_min[of h] 3(1)"], ["proof (prove)\nusing this:\n  hs \\<noteq> []\n  \\<lbrakk>hps h \\<noteq> []; no_Empty h\\<rbrakk>\n  \\<Longrightarrow> \\<Phi> (del_min h) - \\<Phi> h\n                    \\<le> 3 * log 2 (real (size_hps (hps h))) -\n                          real (length (hps h)) +\n                          2\n  \\<forall>s\\<in>set ss. is_root s\n\ngoal (1 subgoal):\n 1. \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hps hs)) - real (length hs) + 2", "by simp"], ["proof (state)\nthis:\n  \\<Phi> (del_min h) - \\<Phi> h\n  \\<le> 3 * log 2 (real (size_hps hs)) - real (length hs) + 2\n\ngoal (2 subgoals):\n 1. hs = [] \\<Longrightarrow>\n    \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hp h + 1)) - real (length hs) + 2\n 2. hs \\<noteq> [] \\<Longrightarrow>\n    \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hp h + 1)) - real (length hs) + 2", "also"], ["proof (state)\nthis:\n  \\<Phi> (del_min h) - \\<Phi> h\n  \\<le> 3 * log 2 (real (size_hps hs)) - real (length hs) + 2\n\ngoal (2 subgoals):\n 1. hs = [] \\<Longrightarrow>\n    \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hp h + 1)) - real (length hs) + 2\n 2. hs \\<noteq> [] \\<Longrightarrow>\n    \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hp h + 1)) - real (length hs) + 2", "have \"\\<dots> \\<le> 3*log 2 (size_hp h + 1) - length hs + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 * log 2 (real (size_hps hs)) - real (length hs) + 2\n    \\<le> 3 * log 2 (real (size_hp h + 1)) - real (length hs) + 2", "using False 3(1) size_hps_pass2"], ["proof (prove)\nusing this:\n  hs \\<noteq> []\n  \\<forall>s\\<in>set ss. is_root s\n  \\<lbrakk>?hs \\<noteq> []; no_Emptys ?hs\\<rbrakk>\n  \\<Longrightarrow> no_Empty (pass\\<^sub>2 ?hs) \\<and>\n                    size_hps ?hs = size_hps (hps (pass\\<^sub>2 ?hs)) + 1\n\ngoal (1 subgoal):\n 1. 3 * log 2 (real (size_hps hs)) - real (length hs) + 2\n    \\<le> 3 * log 2 (real (size_hp h + 1)) - real (length hs) + 2", "by fastforce"], ["proof (state)\nthis:\n  3 * log 2 (real (size_hps hs)) - real (length hs) + 2\n  \\<le> 3 * log 2 (real (size_hp h + 1)) - real (length hs) + 2\n\ngoal (2 subgoals):\n 1. hs = [] \\<Longrightarrow>\n    \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hp h + 1)) - real (length hs) + 2\n 2. hs \\<noteq> [] \\<Longrightarrow>\n    \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hp h + 1)) - real (length hs) + 2", "finally"], ["proof (chain)\npicking this:\n  \\<Phi> (del_min h) - \\<Phi> h\n  \\<le> 3 * log 2 (real (size_hp h + 1)) - real (length hs) + 2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Phi> (del_min h) - \\<Phi> h\n  \\<le> 3 * log 2 (real (size_hp h + 1)) - real (length hs) + 2\n\ngoal (1 subgoal):\n 1. \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hp h + 1)) - real (length hs) + 2", "."], ["proof (state)\nthis:\n  \\<Phi> (del_min h) - \\<Phi> h\n  \\<le> 3 * log 2 (real (size_hp h + 1)) - real (length hs) + 2\n\ngoal (1 subgoal):\n 1. hs = [] \\<Longrightarrow>\n    \\<Phi> (del_min h) - \\<Phi> h\n    \\<le> 3 * log 2 (real (size_hp h + 1)) - real (length hs) + 2", "qed simp"], ["proof (state)\nthis:\n  \\<Phi> (del_min h) - \\<Phi> h\n  \\<le> 3 * log 2 (real (size_hp h + 1)) - real (length hs) + 2\n\ngoal (2 subgoals):\n 1. h = heap.Empty \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 2. \\<And>x21 x22.\n       h = Hp x21 x22 \\<Longrightarrow>\n       real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n       \\<le> U f ss", "ultimately"], ["proof (chain)\npicking this:\n  cost f ss \\<le> 2 + length hs\n  \\<Phi> (del_min h) - \\<Phi> h\n  \\<le> 3 * log 2 (real (size_hp h + 1)) - real (length hs) + 2", "show ?thesis"], ["proof (prove)\nusing this:\n  cost f ss \\<le> 2 + length hs\n  \\<Phi> (del_min h) - \\<Phi> h\n  \\<le> 3 * log 2 (real (size_hp h + 1)) - real (length hs) + 2\n\ngoal (1 subgoal):\n 1. real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "by simp"], ["proof (state)\nthis:\n  real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n  \\<le> U f ss\n\ngoal (1 subgoal):\n 1. h = heap.Empty \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "qed simp"], ["proof (state)\nthis:\n  real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n  \\<le> U f ss\n\ngoal (1 subgoal):\n 1. f = Merge \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. f = Merge \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "case [simp]: Merge"], ["proof (state)\nthis:\n  f = Merge\n\ngoal (1 subgoal):\n 1. f = Merge \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "then"], ["proof (chain)\npicking this:\n  f = Merge", "obtain h1 h2 where [simp]: \"ss = [h1, h2]\""], ["proof (prove)\nusing this:\n  f = Merge\n\ngoal (1 subgoal):\n 1. (\\<And>h1 h2. ss = [h1, h2] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 3"], ["proof (prove)\nusing this:\n  f = Merge\n  \\<forall>s\\<in>set ss. is_root s\n  length ss = arity f\n\ngoal (1 subgoal):\n 1. (\\<And>h1 h2. ss = [h1, h2] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp: numeral_eq_Suc)"], ["proof (state)\nthis:\n  ss = [h1, h2]\n\ngoal (1 subgoal):\n 1. f = Merge \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "proof (cases \"h1 = heap.Empty \\<or> h2 = heap.Empty\")"], ["proof (state)\ngoal (2 subgoals):\n 1. h1 = heap.Empty \\<or> h2 = heap.Empty \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 2. \\<not> (h1 = heap.Empty \\<or> h2 = heap.Empty) \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "case True"], ["proof (state)\nthis:\n  h1 = heap.Empty \\<or> h2 = heap.Empty\n\ngoal (2 subgoals):\n 1. h1 = heap.Empty \\<or> h2 = heap.Empty \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss\n 2. \\<not> (h1 = heap.Empty \\<or> h2 = heap.Empty) \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "thus ?thesis"], ["proof (prove)\nusing this:\n  h1 = heap.Empty \\<or> h2 = heap.Empty\n\ngoal (1 subgoal):\n 1. real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "by auto"], ["proof (state)\nthis:\n  real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n  \\<le> U f ss\n\ngoal (1 subgoal):\n 1. \\<not> (h1 = heap.Empty \\<or> h2 = heap.Empty) \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (h1 = heap.Empty \\<or> h2 = heap.Empty) \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "case False"], ["proof (state)\nthis:\n  \\<not> (h1 = heap.Empty \\<or> h2 = heap.Empty)\n\ngoal (1 subgoal):\n 1. \\<not> (h1 = heap.Empty \\<or> h2 = heap.Empty) \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "then"], ["proof (chain)\npicking this:\n  \\<not> (h1 = heap.Empty \\<or> h2 = heap.Empty)", "obtain x1 x2 hs1 hs2 where [simp]: \"h1 = Hp x1 hs1\" \"h2 = Hp x2 hs2\""], ["proof (prove)\nusing this:\n  \\<not> (h1 = heap.Empty \\<or> h2 = heap.Empty)\n\ngoal (1 subgoal):\n 1. (\\<And>x1 hs1 x2 hs2.\n        \\<lbrakk>h1 = Hp x1 hs1; h2 = Hp x2 hs2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson hps.cases)"], ["proof (state)\nthis:\n  h1 = Hp x1 hs1\n  h2 = Hp x2 hs2\n\ngoal (1 subgoal):\n 1. \\<not> (h1 = heap.Empty \\<or> h2 = heap.Empty) \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "have \"\\<Phi> (merge h1 h2) - \\<Phi> h1 - \\<Phi> h2 \\<le> log 2 (size_hp h1 + size_hp h2 + 1) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> (merge h1 h2) - \\<Phi> h1 - \\<Phi> h2\n    \\<le> log 2 (real (size_hp h1 + size_hp h2 + 1)) + 1", "using \\<Delta>\\<Phi>_merge[of h1 h2]"], ["proof (prove)\nusing this:\n  \\<Phi> (merge h1 h2) - \\<Phi> h1 - \\<Phi> h2\n  \\<le> log 2 (real (size_hp h1 + size_hp h2 + 1)) + 1\n\ngoal (1 subgoal):\n 1. \\<Phi> (merge h1 h2) - \\<Phi> h1 - \\<Phi> h2\n    \\<le> log 2 (real (size_hp h1 + size_hp h2 + 1)) + 1", "by simp"], ["proof (state)\nthis:\n  \\<Phi> (merge h1 h2) - \\<Phi> h1 - \\<Phi> h2\n  \\<le> log 2 (real (size_hp h1 + size_hp h2 + 1)) + 1\n\ngoal (1 subgoal):\n 1. \\<not> (h1 = heap.Empty \\<or> h2 = heap.Empty) \\<Longrightarrow>\n    real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<Phi> (merge h1 h2) - \\<Phi> h1 - \\<Phi> h2\n  \\<le> log 2 (real (size_hp h1 + size_hp h2 + 1)) + 1\n\ngoal (1 subgoal):\n 1. real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n    \\<le> U f ss", "by(simp)"], ["proof (state)\nthis:\n  real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n  \\<le> U f ss\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n  \\<le> U f ss\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real (cost f ss) + \\<Phi> (exec f ss) - sum_list (map \\<Phi> ss)\n  \\<le> U f ss\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}