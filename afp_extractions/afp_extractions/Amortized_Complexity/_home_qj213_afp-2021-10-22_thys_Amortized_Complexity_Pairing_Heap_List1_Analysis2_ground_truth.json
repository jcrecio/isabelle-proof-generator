{"file_name": "/home/qj213/afp-2021-10-22/thys/Amortized_Complexity/Pairing_Heap_List1_Analysis2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Amortized_Complexity", "problem_names": ["lemma homs_pass1': \"no_Emptys hs \\<Longrightarrow> homs(pass\\<^sub>1' hs) = pass\\<^sub>1 (homs hs)\"", "lemma hom_merge': \"\\<lbrakk> no_Emptys lhs; Pairing_Heap_List1_Analysis.is_root h\\<rbrakk>\n       \\<Longrightarrow> hom (merge' (Hp x lhs) h) = link \\<langle>homs lhs, x, hom h\\<rangle>\"", "lemma hom_pass2': \"no_Emptys hs \\<Longrightarrow> hom(pass\\<^sub>2' hs) = pass\\<^sub>2 (homs hs)\"", "lemma del_min': \"is_root' h \\<Longrightarrow> hom(del_min' h) = del_min (hom h)\"", "lemma insert': \"is_root' h \\<Longrightarrow> hom(insert' x h) = insert x (hom h)\"", "lemma merge':\n  \"\\<lbrakk> is_root' h1; is_root' h2 \\<rbrakk> \\<Longrightarrow> hom(merge' h1 h2) = merge (hom h1) (hom h2)\"", "lemma T_pass1': \"no_Emptys hs \\<Longrightarrow> T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1' hs = T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1(homs hs)\"", "lemma T_pass2': \"no_Emptys hs \\<Longrightarrow> T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>2' hs = T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>2(homs hs)\"", "lemma size_hp: \"is_root' h \\<Longrightarrow> size_hp h = size (hom h)\""], "translations": [["", "lemma homs_pass1': \"no_Emptys hs \\<Longrightarrow> homs(pass\\<^sub>1' hs) = pass\\<^sub>1 (homs hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_Emptys hs \\<Longrightarrow>\n    homs (pass\\<^sub>1' hs) = Pairing_Heap_Tree.pass\\<^sub>1 (homs hs)", "apply(induction hs rule: Pairing_Heap_List1.pass\\<^sub>1.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>h1 h2 hs.\n       \\<lbrakk>no_Emptys hs \\<Longrightarrow>\n                homs (pass\\<^sub>1' hs) =\n                Pairing_Heap_Tree.pass\\<^sub>1 (homs hs);\n        no_Emptys (h1 # h2 # hs)\\<rbrakk>\n       \\<Longrightarrow> homs (pass\\<^sub>1' (h1 # h2 # hs)) =\n                         Pairing_Heap_Tree.pass\\<^sub>1\n                          (homs (h1 # h2 # hs))\n 2. no_Emptys [] \\<Longrightarrow>\n    homs (pass\\<^sub>1' []) = Pairing_Heap_Tree.pass\\<^sub>1 (homs [])\n 3. \\<And>v.\n       no_Emptys [v] \\<Longrightarrow>\n       homs (pass\\<^sub>1' [v]) = Pairing_Heap_Tree.pass\\<^sub>1 (homs [v])", "subgoal for h1 h2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>no_Emptys hs_ \\<Longrightarrow>\n             homs (pass\\<^sub>1' hs_) =\n             Pairing_Heap_Tree.pass\\<^sub>1 (homs hs_);\n     no_Emptys (h1 # h2 # hs_)\\<rbrakk>\n    \\<Longrightarrow> homs (pass\\<^sub>1' (h1 # h2 # hs_)) =\n                      Pairing_Heap_Tree.pass\\<^sub>1 (homs (h1 # h2 # hs_))", "apply(case_tac h1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>no_Emptys hs_ \\<Longrightarrow>\n             homs (pass\\<^sub>1' hs_) =\n             Pairing_Heap_Tree.pass\\<^sub>1 (homs hs_);\n     no_Emptys (h1 # h2 # hs_); h1 = heap.Empty\\<rbrakk>\n    \\<Longrightarrow> homs (pass\\<^sub>1' (h1 # h2 # hs_)) =\n                      Pairing_Heap_Tree.pass\\<^sub>1 (homs (h1 # h2 # hs_))\n 2. \\<And>x21 x22.\n       \\<lbrakk>no_Emptys hs_ \\<Longrightarrow>\n                homs (pass\\<^sub>1' hs_) =\n                Pairing_Heap_Tree.pass\\<^sub>1 (homs hs_);\n        no_Emptys (h1 # h2 # hs_); h1 = Hp x21 x22\\<rbrakk>\n       \\<Longrightarrow> homs (pass\\<^sub>1' (h1 # h2 # hs_)) =\n                         Pairing_Heap_Tree.pass\\<^sub>1\n                          (homs (h1 # h2 # hs_))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>no_Emptys hs_ \\<Longrightarrow>\n                homs (pass\\<^sub>1' hs_) =\n                Pairing_Heap_Tree.pass\\<^sub>1 (homs hs_);\n        no_Emptys (h1 # h2 # hs_); h1 = Hp x21 x22\\<rbrakk>\n       \\<Longrightarrow> homs (pass\\<^sub>1' (h1 # h2 # hs_)) =\n                         Pairing_Heap_Tree.pass\\<^sub>1\n                          (homs (h1 # h2 # hs_))", "apply(case_tac h2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>no_Emptys hs_ \\<Longrightarrow>\n                homs (pass\\<^sub>1' hs_) =\n                Pairing_Heap_Tree.pass\\<^sub>1 (homs hs_);\n        no_Emptys (h1 # h2 # hs_); h1 = Hp x21 x22; h2 = heap.Empty\\<rbrakk>\n       \\<Longrightarrow> homs (pass\\<^sub>1' (h1 # h2 # hs_)) =\n                         Pairing_Heap_Tree.pass\\<^sub>1\n                          (homs (h1 # h2 # hs_))\n 2. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>no_Emptys hs_ \\<Longrightarrow>\n                homs (pass\\<^sub>1' hs_) =\n                Pairing_Heap_Tree.pass\\<^sub>1 (homs hs_);\n        no_Emptys (h1 # h2 # hs_); h1 = Hp x21 x22;\n        h2 = Hp x21a x22a\\<rbrakk>\n       \\<Longrightarrow> homs (pass\\<^sub>1' (h1 # h2 # hs_)) =\n                         Pairing_Heap_Tree.pass\\<^sub>1\n                          (homs (h1 # h2 # hs_))", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. no_Emptys [] \\<Longrightarrow>\n    homs (pass\\<^sub>1' []) = Pairing_Heap_Tree.pass\\<^sub>1 (homs [])\n 2. \\<And>v.\n       no_Emptys [v] \\<Longrightarrow>\n       homs (pass\\<^sub>1' [v]) = Pairing_Heap_Tree.pass\\<^sub>1 (homs [v])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       no_Emptys [v] \\<Longrightarrow>\n       homs (pass\\<^sub>1' [v]) = Pairing_Heap_Tree.pass\\<^sub>1 (homs [v])", "subgoal for h"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_Emptys [h] \\<Longrightarrow>\n    homs (pass\\<^sub>1' [h]) = Pairing_Heap_Tree.pass\\<^sub>1 (homs [h])", "apply(case_tac h)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>no_Emptys [h]; h = heap.Empty\\<rbrakk>\n    \\<Longrightarrow> homs (pass\\<^sub>1' [h]) =\n                      Pairing_Heap_Tree.pass\\<^sub>1 (homs [h])\n 2. \\<And>x21 x22.\n       \\<lbrakk>no_Emptys [h]; h = Hp x21 x22\\<rbrakk>\n       \\<Longrightarrow> homs (pass\\<^sub>1' [h]) =\n                         Pairing_Heap_Tree.pass\\<^sub>1 (homs [h])", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma hom_merge': \"\\<lbrakk> no_Emptys lhs; Pairing_Heap_List1_Analysis.is_root h\\<rbrakk>\n       \\<Longrightarrow> hom (merge' (Hp x lhs) h) = link \\<langle>homs lhs, x, hom h\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>no_Emptys lhs; is_root' h\\<rbrakk>\n    \\<Longrightarrow> hom (merge' (Hp x lhs) h) =\n                      link \\<langle>homs lhs, x, hom h\\<rangle>", "by(cases h) auto"], ["", "lemma hom_pass2': \"no_Emptys hs \\<Longrightarrow> hom(pass\\<^sub>2' hs) = pass\\<^sub>2 (homs hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_Emptys hs \\<Longrightarrow>\n    hom (pass\\<^sub>2' hs) = Pairing_Heap_Tree.pass\\<^sub>2 (homs hs)", "by(induction hs rule: homs.induct) (auto simp: hom_merge' is_root_pass2)"], ["", "lemma del_min': \"is_root' h \\<Longrightarrow> hom(del_min' h) = del_min (hom h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_root' h \\<Longrightarrow>\n    hom (del_min' h) = Pairing_Heap_Tree.del_min (hom h)", "by(cases h)\n  (auto simp: homs_pass1' hom_pass2' no_Emptys_pass1 is_root_pass2)"], ["", "lemma insert': \"is_root' h \\<Longrightarrow> hom(insert' x h) = insert x (hom h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_root' h \\<Longrightarrow>\n    hom (insert' x h) = Pairing_Heap_Tree.insert x (hom h)", "by(cases h)(auto)"], ["", "lemma merge':\n  \"\\<lbrakk> is_root' h1; is_root' h2 \\<rbrakk> \\<Longrightarrow> hom(merge' h1 h2) = merge (hom h1) (hom h2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_root' h1; is_root' h2\\<rbrakk>\n    \\<Longrightarrow> hom (merge' h1 h2) =\n                      Pairing_Heap_Tree.merge (hom h1) (hom h2)", "apply(cases h1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_root' h1; is_root' h2; h1 = heap.Empty\\<rbrakk>\n    \\<Longrightarrow> hom (merge' h1 h2) =\n                      Pairing_Heap_Tree.merge (hom h1) (hom h2)\n 2. \\<And>x21 x22.\n       \\<lbrakk>is_root' h1; is_root' h2; h1 = Hp x21 x22\\<rbrakk>\n       \\<Longrightarrow> hom (merge' h1 h2) =\n                         Pairing_Heap_Tree.merge (hom h1) (hom h2)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>is_root' h1; is_root' h2; h1 = Hp x21 x22\\<rbrakk>\n       \\<Longrightarrow> hom (merge' h1 h2) =\n                         Pairing_Heap_Tree.merge (hom h1) (hom h2)", "apply(cases h2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>is_root' h1; is_root' h2; h1 = Hp x21 x22;\n        h2 = heap.Empty\\<rbrakk>\n       \\<Longrightarrow> hom (merge' h1 h2) =\n                         Pairing_Heap_Tree.merge (hom h1) (hom h2)\n 2. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>is_root' h1; is_root' h2; h1 = Hp x21 x22;\n        h2 = Hp x21a x22a\\<rbrakk>\n       \\<Longrightarrow> hom (merge' h1 h2) =\n                         Pairing_Heap_Tree.merge (hom h1) (hom h2)", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma T_pass1': \"no_Emptys hs \\<Longrightarrow> T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1' hs = T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1(homs hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_Emptys hs \\<Longrightarrow>\n    T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1' hs =\n    Pairing_Heap_Tree_Analysis.T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1\n     (homs hs)", "apply(induction hs rule: Pairing_Heap_List1.pass\\<^sub>1.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>h1 h2 hs.\n       \\<lbrakk>no_Emptys hs \\<Longrightarrow>\n                T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1' hs =\n                Pairing_Heap_Tree_Analysis.T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1\n                 (homs hs);\n        no_Emptys (h1 # h2 # hs)\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1'\n                          (h1 # h2 # hs) =\n                         Pairing_Heap_Tree_Analysis.T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1\n                          (homs (h1 # h2 # hs))\n 2. no_Emptys [] \\<Longrightarrow>\n    T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1' [] =\n    Pairing_Heap_Tree_Analysis.T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1\n     (homs [])\n 3. \\<And>v.\n       no_Emptys [v] \\<Longrightarrow>\n       T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1' [v] =\n       Pairing_Heap_Tree_Analysis.T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1\n        (homs [v])", "subgoal for h1 h2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>no_Emptys hs_ \\<Longrightarrow>\n             T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1' hs_ =\n             Pairing_Heap_Tree_Analysis.T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1\n              (homs hs_);\n     no_Emptys (h1 # h2 # hs_)\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1'\n                       (h1 # h2 # hs_) =\n                      Pairing_Heap_Tree_Analysis.T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1\n                       (homs (h1 # h2 # hs_))", "apply(case_tac h1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>no_Emptys hs_ \\<Longrightarrow>\n             T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1' hs_ =\n             Pairing_Heap_Tree_Analysis.T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1\n              (homs hs_);\n     no_Emptys (h1 # h2 # hs_); h1 = heap.Empty\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1'\n                       (h1 # h2 # hs_) =\n                      Pairing_Heap_Tree_Analysis.T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1\n                       (homs (h1 # h2 # hs_))\n 2. \\<And>x21 x22.\n       \\<lbrakk>no_Emptys hs_ \\<Longrightarrow>\n                T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1' hs_ =\n                Pairing_Heap_Tree_Analysis.T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1\n                 (homs hs_);\n        no_Emptys (h1 # h2 # hs_); h1 = Hp x21 x22\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1'\n                          (h1 # h2 # hs_) =\n                         Pairing_Heap_Tree_Analysis.T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1\n                          (homs (h1 # h2 # hs_))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>no_Emptys hs_ \\<Longrightarrow>\n                T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1' hs_ =\n                Pairing_Heap_Tree_Analysis.T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1\n                 (homs hs_);\n        no_Emptys (h1 # h2 # hs_); h1 = Hp x21 x22\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1'\n                          (h1 # h2 # hs_) =\n                         Pairing_Heap_Tree_Analysis.T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1\n                          (homs (h1 # h2 # hs_))", "apply(case_tac h2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>no_Emptys hs_ \\<Longrightarrow>\n                T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1' hs_ =\n                Pairing_Heap_Tree_Analysis.T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1\n                 (homs hs_);\n        no_Emptys (h1 # h2 # hs_); h1 = Hp x21 x22; h2 = heap.Empty\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1'\n                          (h1 # h2 # hs_) =\n                         Pairing_Heap_Tree_Analysis.T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1\n                          (homs (h1 # h2 # hs_))\n 2. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>no_Emptys hs_ \\<Longrightarrow>\n                T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1' hs_ =\n                Pairing_Heap_Tree_Analysis.T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1\n                 (homs hs_);\n        no_Emptys (h1 # h2 # hs_); h1 = Hp x21 x22;\n        h2 = Hp x21a x22a\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1'\n                          (h1 # h2 # hs_) =\n                         Pairing_Heap_Tree_Analysis.T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1\n                          (homs (h1 # h2 # hs_))", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. no_Emptys [] \\<Longrightarrow>\n    T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1' [] =\n    Pairing_Heap_Tree_Analysis.T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1\n     (homs [])\n 2. \\<And>v.\n       no_Emptys [v] \\<Longrightarrow>\n       T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1' [v] =\n       Pairing_Heap_Tree_Analysis.T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1\n        (homs [v])", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       no_Emptys [v] \\<Longrightarrow>\n       T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1' [v] =\n       Pairing_Heap_Tree_Analysis.T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1\n        (homs [v])", "subgoal for h"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_Emptys [h] \\<Longrightarrow>\n    T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1' [h] =\n    Pairing_Heap_Tree_Analysis.T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1\n     (homs [h])", "apply(case_tac h)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>no_Emptys [h]; h = heap.Empty\\<rbrakk>\n    \\<Longrightarrow> T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1' [h] =\n                      Pairing_Heap_Tree_Analysis.T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1\n                       (homs [h])\n 2. \\<And>x21 x22.\n       \\<lbrakk>no_Emptys [h]; h = Hp x21 x22\\<rbrakk>\n       \\<Longrightarrow> T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1' [h] =\n                         Pairing_Heap_Tree_Analysis.T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>1\n                          (homs [h])", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma T_pass2': \"no_Emptys hs \\<Longrightarrow> T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>2' hs = T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>2(homs hs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_Emptys hs \\<Longrightarrow>\n    T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>2' hs =\n    Pairing_Heap_Tree_Analysis.T\\<^sub>p\\<^sub>a\\<^sub>s\\<^sub>s\\<^sub>2\n     (homs hs)", "by(induction hs rule: homs.induct) (auto simp: hom_merge' is_root_pass2)"], ["", "lemma size_hp: \"is_root' h \\<Longrightarrow> size_hp h = size (hom h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_root' h \\<Longrightarrow> size_hp h = size (hom h)", "proof(induction h)"], ["proof (state)\ngoal (2 subgoals):\n 1. is_root' heap.Empty \\<Longrightarrow>\n    size_hp heap.Empty = size (hom heap.Empty)\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; is_root' x2a\\<rbrakk>\n                   \\<Longrightarrow> size_hp x2a = size (hom x2a);\n        is_root' (Hp x1 x2)\\<rbrakk>\n       \\<Longrightarrow> size_hp (Hp x1 x2) = size (hom (Hp x1 x2))", "case (Hp _ hs)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2a \\<in> set hs; is_root' ?x2a\\<rbrakk>\n  \\<Longrightarrow> size_hp ?x2a = size (hom ?x2a)\n  is_root' (Hp x1_ hs)\n\ngoal (2 subgoals):\n 1. is_root' heap.Empty \\<Longrightarrow>\n    size_hp heap.Empty = size (hom heap.Empty)\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set x2; is_root' x2a\\<rbrakk>\n                   \\<Longrightarrow> size_hp x2a = size (hom x2a);\n        is_root' (Hp x1 x2)\\<rbrakk>\n       \\<Longrightarrow> size_hp (Hp x1 x2) = size (hom (Hp x1 x2))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2a \\<in> set hs; is_root' ?x2a\\<rbrakk>\n  \\<Longrightarrow> size_hp ?x2a = size (hom ?x2a)\n  is_root' (Hp x1_ hs)\n\ngoal (1 subgoal):\n 1. size_hp (Hp x1_ hs) = size (hom (Hp x1_ hs))", "apply(induction hs rule: homs.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>x2a.\n                \\<lbrakk>x2a \\<in> set []; is_root' x2a\\<rbrakk>\n                \\<Longrightarrow> size_hp x2a = size (hom x2a);\n     is_root' (Hp x1_ [])\\<rbrakk>\n    \\<Longrightarrow> size_hp (Hp x1_ []) = size (hom (Hp x1_ []))\n 2. \\<And>x lhs rhs.\n       \\<lbrakk>\\<lbrakk>\\<And>x2a.\n                            \\<lbrakk>x2a \\<in> set lhs;\n                             is_root' x2a\\<rbrakk>\n                            \\<Longrightarrow> size_hp x2a = size (hom x2a);\n                 is_root' (Hp x1_ lhs)\\<rbrakk>\n                \\<Longrightarrow> size_hp (Hp x1_ lhs) =\n                                  size (hom (Hp x1_ lhs));\n        \\<lbrakk>\\<And>x2a.\n                    \\<lbrakk>x2a \\<in> set rhs; is_root' x2a\\<rbrakk>\n                    \\<Longrightarrow> size_hp x2a = size (hom x2a);\n         is_root' (Hp x1_ rhs)\\<rbrakk>\n        \\<Longrightarrow> size_hp (Hp x1_ rhs) = size (hom (Hp x1_ rhs));\n        \\<And>x2a.\n           \\<lbrakk>x2a \\<in> set (Hp x lhs # rhs); is_root' x2a\\<rbrakk>\n           \\<Longrightarrow> size_hp x2a = size (hom x2a);\n        is_root' (Hp x1_ (Hp x lhs # rhs))\\<rbrakk>\n       \\<Longrightarrow> size_hp (Hp x1_ (Hp x lhs # rhs)) =\n                         size (hom (Hp x1_ (Hp x lhs # rhs)))\n 3. \\<And>va.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set (heap.Empty # va);\n                    is_root' x2a\\<rbrakk>\n                   \\<Longrightarrow> size_hp x2a = size (hom x2a);\n        is_root' (Hp x1_ (heap.Empty # va))\\<rbrakk>\n       \\<Longrightarrow> size_hp (Hp x1_ (heap.Empty # va)) =\n                         size (hom (Hp x1_ (heap.Empty # va)))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x lhs rhs.\n       \\<lbrakk>\\<lbrakk>\\<And>x2a.\n                            \\<lbrakk>x2a \\<in> set lhs;\n                             is_root' x2a\\<rbrakk>\n                            \\<Longrightarrow> size_hp x2a = size (hom x2a);\n                 is_root' (Hp x1_ lhs)\\<rbrakk>\n                \\<Longrightarrow> size_hp (Hp x1_ lhs) =\n                                  size (hom (Hp x1_ lhs));\n        \\<lbrakk>\\<And>x2a.\n                    \\<lbrakk>x2a \\<in> set rhs; is_root' x2a\\<rbrakk>\n                    \\<Longrightarrow> size_hp x2a = size (hom x2a);\n         is_root' (Hp x1_ rhs)\\<rbrakk>\n        \\<Longrightarrow> size_hp (Hp x1_ rhs) = size (hom (Hp x1_ rhs));\n        \\<And>x2a.\n           \\<lbrakk>x2a \\<in> set (Hp x lhs # rhs); is_root' x2a\\<rbrakk>\n           \\<Longrightarrow> size_hp x2a = size (hom x2a);\n        is_root' (Hp x1_ (Hp x lhs # rhs))\\<rbrakk>\n       \\<Longrightarrow> size_hp (Hp x1_ (Hp x lhs # rhs)) =\n                         size (hom (Hp x1_ (Hp x lhs # rhs)))\n 2. \\<And>va.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set (heap.Empty # va);\n                    is_root' x2a\\<rbrakk>\n                   \\<Longrightarrow> size_hp x2a = size (hom x2a);\n        is_root' (Hp x1_ (heap.Empty # va))\\<rbrakk>\n       \\<Longrightarrow> size_hp (Hp x1_ (heap.Empty # va)) =\n                         size (hom (Hp x1_ (heap.Empty # va)))", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>va.\n       \\<lbrakk>\\<And>x2a.\n                   \\<lbrakk>x2a \\<in> set (heap.Empty # va);\n                    is_root' x2a\\<rbrakk>\n                   \\<Longrightarrow> size_hp x2a = size (hom x2a);\n        is_root' (Hp x1_ (heap.Empty # va))\\<rbrakk>\n       \\<Longrightarrow> size_hp (Hp x1_ (heap.Empty # va)) =\n                         size (hom (Hp x1_ (heap.Empty # va)))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  size_hp (Hp x1_ hs) = size (hom (Hp x1_ hs))\n\ngoal (1 subgoal):\n 1. is_root' heap.Empty \\<Longrightarrow>\n    size_hp heap.Empty = size (hom heap.Empty)", "qed simp"], ["", "interpretation Amortized2\nwhere arity = arity and exec = exec and inv = is_root\nand cost = cost and \\<Phi> = \\<Phi> and U = U\nand hom = hom\nand exec' = Pairing_Heap_List1_Analysis.exec\nand cost' = Pairing_Heap_List1_Analysis.cost and inv' = \"is_root'\"\nand U' = Pairing_Heap_List1_Analysis.U"], ["proof (prove)\ngoal (1 subgoal):\n 1. Amortized2 arity Pairing_Heap_Tree_Analysis.exec\n     Pairing_Heap_Tree.is_root Pairing_Heap_Tree_Analysis.cost\n     Pairing_Heap_Tree_Analysis.\\<Phi> Pairing_Heap_Tree_Analysis.U\n     Pairing_Heap_List1_Analysis.exec is_root'\n     Pairing_Heap_List1_Analysis.cost Pairing_Heap_List1_Analysis.U hom", "proof (standard, goal_cases)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>ts f.\n       \\<lbrakk>Ball (set ts) is_root'; length ts = arity f\\<rbrakk>\n       \\<Longrightarrow> hom (Pairing_Heap_List1_Analysis.exec f ts) =\n                         Pairing_Heap_Tree_Analysis.exec f (map hom ts)\n 2. \\<And>ss f.\n       \\<lbrakk>Ball (set ss) is_root'; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> is_root' (Pairing_Heap_List1_Analysis.exec f ss)\n 3. \\<And>t. is_root' t \\<Longrightarrow> Pairing_Heap_Tree.is_root (hom t)\n 4. \\<And>ts f.\n       \\<lbrakk>Ball (set ts) is_root'; length ts = arity f\\<rbrakk>\n       \\<Longrightarrow> Pairing_Heap_List1_Analysis.cost f ts =\n                         Pairing_Heap_Tree_Analysis.cost f (map hom ts)\n 5. \\<And>ts f.\n       \\<lbrakk>Ball (set ts) is_root'; length ts = arity f\\<rbrakk>\n       \\<Longrightarrow> Pairing_Heap_List1_Analysis.U f ts =\n                         Pairing_Heap_Tree_Analysis.U f (map hom ts)", "case (1 _ f)"], ["proof (state)\nthis:\n  Ball (set ts_) is_root'\n  length ts_ = arity f\n\ngoal (5 subgoals):\n 1. \\<And>ts f.\n       \\<lbrakk>Ball (set ts) is_root'; length ts = arity f\\<rbrakk>\n       \\<Longrightarrow> hom (Pairing_Heap_List1_Analysis.exec f ts) =\n                         Pairing_Heap_Tree_Analysis.exec f (map hom ts)\n 2. \\<And>ss f.\n       \\<lbrakk>Ball (set ss) is_root'; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> is_root' (Pairing_Heap_List1_Analysis.exec f ss)\n 3. \\<And>t. is_root' t \\<Longrightarrow> Pairing_Heap_Tree.is_root (hom t)\n 4. \\<And>ts f.\n       \\<lbrakk>Ball (set ts) is_root'; length ts = arity f\\<rbrakk>\n       \\<Longrightarrow> Pairing_Heap_List1_Analysis.cost f ts =\n                         Pairing_Heap_Tree_Analysis.cost f (map hom ts)\n 5. \\<And>ts f.\n       \\<lbrakk>Ball (set ts) is_root'; length ts = arity f\\<rbrakk>\n       \\<Longrightarrow> Pairing_Heap_List1_Analysis.U f ts =\n                         Pairing_Heap_Tree_Analysis.U f (map hom ts)", "thus ?case"], ["proof (prove)\nusing this:\n  Ball (set ts_) is_root'\n  length ts_ = arity f\n\ngoal (1 subgoal):\n 1. hom (Pairing_Heap_List1_Analysis.exec f ts_) =\n    Pairing_Heap_Tree_Analysis.exec f (map hom ts_)", "by (cases f)(auto simp: merge' del_min' numeral_eq_Suc)"], ["proof (state)\nthis:\n  hom (Pairing_Heap_List1_Analysis.exec f ts_) =\n  Pairing_Heap_Tree_Analysis.exec f (map hom ts_)\n\ngoal (4 subgoals):\n 1. \\<And>ss f.\n       \\<lbrakk>Ball (set ss) is_root'; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> is_root' (Pairing_Heap_List1_Analysis.exec f ss)\n 2. \\<And>t. is_root' t \\<Longrightarrow> Pairing_Heap_Tree.is_root (hom t)\n 3. \\<And>ts f.\n       \\<lbrakk>Ball (set ts) is_root'; length ts = arity f\\<rbrakk>\n       \\<Longrightarrow> Pairing_Heap_List1_Analysis.cost f ts =\n                         Pairing_Heap_Tree_Analysis.cost f (map hom ts)\n 4. \\<And>ts f.\n       \\<lbrakk>Ball (set ts) is_root'; length ts = arity f\\<rbrakk>\n       \\<Longrightarrow> Pairing_Heap_List1_Analysis.U f ts =\n                         Pairing_Heap_Tree_Analysis.U f (map hom ts)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ss f.\n       \\<lbrakk>Ball (set ss) is_root'; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> is_root' (Pairing_Heap_List1_Analysis.exec f ss)\n 2. \\<And>t. is_root' t \\<Longrightarrow> Pairing_Heap_Tree.is_root (hom t)\n 3. \\<And>ts f.\n       \\<lbrakk>Ball (set ts) is_root'; length ts = arity f\\<rbrakk>\n       \\<Longrightarrow> Pairing_Heap_List1_Analysis.cost f ts =\n                         Pairing_Heap_Tree_Analysis.cost f (map hom ts)\n 4. \\<And>ts f.\n       \\<lbrakk>Ball (set ts) is_root'; length ts = arity f\\<rbrakk>\n       \\<Longrightarrow> Pairing_Heap_List1_Analysis.U f ts =\n                         Pairing_Heap_Tree_Analysis.U f (map hom ts)", "case (2 ts f)"], ["proof (state)\nthis:\n  Ball (set ts) is_root'\n  length ts = arity f\n\ngoal (4 subgoals):\n 1. \\<And>ss f.\n       \\<lbrakk>Ball (set ss) is_root'; length ss = arity f\\<rbrakk>\n       \\<Longrightarrow> is_root' (Pairing_Heap_List1_Analysis.exec f ss)\n 2. \\<And>t. is_root' t \\<Longrightarrow> Pairing_Heap_Tree.is_root (hom t)\n 3. \\<And>ts f.\n       \\<lbrakk>Ball (set ts) is_root'; length ts = arity f\\<rbrakk>\n       \\<Longrightarrow> Pairing_Heap_List1_Analysis.cost f ts =\n                         Pairing_Heap_Tree_Analysis.cost f (map hom ts)\n 4. \\<And>ts f.\n       \\<lbrakk>Ball (set ts) is_root'; length ts = arity f\\<rbrakk>\n       \\<Longrightarrow> Pairing_Heap_List1_Analysis.U f ts =\n                         Pairing_Heap_Tree_Analysis.U f (map hom ts)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_root' (Pairing_Heap_List1_Analysis.exec f ts)", "proof(cases f)"], ["proof (state)\ngoal (4 subgoals):\n 1. f = op.Empty \\<Longrightarrow>\n    is_root' (Pairing_Heap_List1_Analysis.exec f ts)\n 2. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       is_root' (Pairing_Heap_List1_Analysis.exec f ts)\n 3. f = Del_min \\<Longrightarrow>\n    is_root' (Pairing_Heap_List1_Analysis.exec f ts)\n 4. f = Merge \\<Longrightarrow>\n    is_root' (Pairing_Heap_List1_Analysis.exec f ts)", "case [simp]: Del_min"], ["proof (state)\nthis:\n  f = Del_min\n\ngoal (4 subgoals):\n 1. f = op.Empty \\<Longrightarrow>\n    is_root' (Pairing_Heap_List1_Analysis.exec f ts)\n 2. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       is_root' (Pairing_Heap_List1_Analysis.exec f ts)\n 3. f = Del_min \\<Longrightarrow>\n    is_root' (Pairing_Heap_List1_Analysis.exec f ts)\n 4. f = Merge \\<Longrightarrow>\n    is_root' (Pairing_Heap_List1_Analysis.exec f ts)", "then"], ["proof (chain)\npicking this:\n  f = Del_min", "obtain h where [simp]: \"ts = [h]\""], ["proof (prove)\nusing this:\n  f = Del_min\n\ngoal (1 subgoal):\n 1. (\\<And>h. ts = [h] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using 2"], ["proof (prove)\nusing this:\n  f = Del_min\n  Ball (set ts) is_root'\n  length ts = arity f\n\ngoal (1 subgoal):\n 1. (\\<And>h. ts = [h] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  ts = [h]\n\ngoal (4 subgoals):\n 1. f = op.Empty \\<Longrightarrow>\n    is_root' (Pairing_Heap_List1_Analysis.exec f ts)\n 2. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       is_root' (Pairing_Heap_List1_Analysis.exec f ts)\n 3. f = Del_min \\<Longrightarrow>\n    is_root' (Pairing_Heap_List1_Analysis.exec f ts)\n 4. f = Merge \\<Longrightarrow>\n    is_root' (Pairing_Heap_List1_Analysis.exec f ts)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_root' (Pairing_Heap_List1_Analysis.exec f ts)", "using 2"], ["proof (prove)\nusing this:\n  Ball (set ts) is_root'\n  length ts = arity f\n\ngoal (1 subgoal):\n 1. is_root' (Pairing_Heap_List1_Analysis.exec f ts)", "by(cases h) (auto simp: is_root_pass2 no_Emptys_pass1)"], ["proof (state)\nthis:\n  is_root' (Pairing_Heap_List1_Analysis.exec f ts)\n\ngoal (3 subgoals):\n 1. f = op.Empty \\<Longrightarrow>\n    is_root' (Pairing_Heap_List1_Analysis.exec f ts)\n 2. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       is_root' (Pairing_Heap_List1_Analysis.exec f ts)\n 3. f = Merge \\<Longrightarrow>\n    is_root' (Pairing_Heap_List1_Analysis.exec f ts)", "qed (insert 2,\n      auto simp: Pairing_Heap_List1_Analysis.is_root_merge numeral_eq_Suc)"], ["proof (state)\nthis:\n  is_root' (Pairing_Heap_List1_Analysis.exec f ts)\n\ngoal (3 subgoals):\n 1. \\<And>t. is_root' t \\<Longrightarrow> Pairing_Heap_Tree.is_root (hom t)\n 2. \\<And>ts f.\n       \\<lbrakk>Ball (set ts) is_root'; length ts = arity f\\<rbrakk>\n       \\<Longrightarrow> Pairing_Heap_List1_Analysis.cost f ts =\n                         Pairing_Heap_Tree_Analysis.cost f (map hom ts)\n 3. \\<And>ts f.\n       \\<lbrakk>Ball (set ts) is_root'; length ts = arity f\\<rbrakk>\n       \\<Longrightarrow> Pairing_Heap_List1_Analysis.U f ts =\n                         Pairing_Heap_Tree_Analysis.U f (map hom ts)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>t. is_root' t \\<Longrightarrow> Pairing_Heap_Tree.is_root (hom t)\n 2. \\<And>ts f.\n       \\<lbrakk>Ball (set ts) is_root'; length ts = arity f\\<rbrakk>\n       \\<Longrightarrow> Pairing_Heap_List1_Analysis.cost f ts =\n                         Pairing_Heap_Tree_Analysis.cost f (map hom ts)\n 3. \\<And>ts f.\n       \\<lbrakk>Ball (set ts) is_root'; length ts = arity f\\<rbrakk>\n       \\<Longrightarrow> Pairing_Heap_List1_Analysis.U f ts =\n                         Pairing_Heap_Tree_Analysis.U f (map hom ts)", "case (3 t)"], ["proof (state)\nthis:\n  is_root' t\n\ngoal (3 subgoals):\n 1. \\<And>t. is_root' t \\<Longrightarrow> Pairing_Heap_Tree.is_root (hom t)\n 2. \\<And>ts f.\n       \\<lbrakk>Ball (set ts) is_root'; length ts = arity f\\<rbrakk>\n       \\<Longrightarrow> Pairing_Heap_List1_Analysis.cost f ts =\n                         Pairing_Heap_Tree_Analysis.cost f (map hom ts)\n 3. \\<And>ts f.\n       \\<lbrakk>Ball (set ts) is_root'; length ts = arity f\\<rbrakk>\n       \\<Longrightarrow> Pairing_Heap_List1_Analysis.U f ts =\n                         Pairing_Heap_Tree_Analysis.U f (map hom ts)", "thus ?case"], ["proof (prove)\nusing this:\n  is_root' t\n\ngoal (1 subgoal):\n 1. Pairing_Heap_Tree.is_root (hom t)", "by (cases t) (auto)"], ["proof (state)\nthis:\n  Pairing_Heap_Tree.is_root (hom t)\n\ngoal (2 subgoals):\n 1. \\<And>ts f.\n       \\<lbrakk>Ball (set ts) is_root'; length ts = arity f\\<rbrakk>\n       \\<Longrightarrow> Pairing_Heap_List1_Analysis.cost f ts =\n                         Pairing_Heap_Tree_Analysis.cost f (map hom ts)\n 2. \\<And>ts f.\n       \\<lbrakk>Ball (set ts) is_root'; length ts = arity f\\<rbrakk>\n       \\<Longrightarrow> Pairing_Heap_List1_Analysis.U f ts =\n                         Pairing_Heap_Tree_Analysis.U f (map hom ts)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ts f.\n       \\<lbrakk>Ball (set ts) is_root'; length ts = arity f\\<rbrakk>\n       \\<Longrightarrow> Pairing_Heap_List1_Analysis.cost f ts =\n                         Pairing_Heap_Tree_Analysis.cost f (map hom ts)\n 2. \\<And>ts f.\n       \\<lbrakk>Ball (set ts) is_root'; length ts = arity f\\<rbrakk>\n       \\<Longrightarrow> Pairing_Heap_List1_Analysis.U f ts =\n                         Pairing_Heap_Tree_Analysis.U f (map hom ts)", "case (4 ts f)"], ["proof (state)\nthis:\n  Ball (set ts) is_root'\n  length ts = arity f\n\ngoal (2 subgoals):\n 1. \\<And>ts f.\n       \\<lbrakk>Ball (set ts) is_root'; length ts = arity f\\<rbrakk>\n       \\<Longrightarrow> Pairing_Heap_List1_Analysis.cost f ts =\n                         Pairing_Heap_Tree_Analysis.cost f (map hom ts)\n 2. \\<And>ts f.\n       \\<lbrakk>Ball (set ts) is_root'; length ts = arity f\\<rbrakk>\n       \\<Longrightarrow> Pairing_Heap_List1_Analysis.U f ts =\n                         Pairing_Heap_Tree_Analysis.U f (map hom ts)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Pairing_Heap_List1_Analysis.cost f ts =\n    Pairing_Heap_Tree_Analysis.cost f (map hom ts)", "proof (cases f)"], ["proof (state)\ngoal (4 subgoals):\n 1. f = op.Empty \\<Longrightarrow>\n    Pairing_Heap_List1_Analysis.cost f ts =\n    Pairing_Heap_Tree_Analysis.cost f (map hom ts)\n 2. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       Pairing_Heap_List1_Analysis.cost f ts =\n       Pairing_Heap_Tree_Analysis.cost f (map hom ts)\n 3. f = Del_min \\<Longrightarrow>\n    Pairing_Heap_List1_Analysis.cost f ts =\n    Pairing_Heap_Tree_Analysis.cost f (map hom ts)\n 4. f = Merge \\<Longrightarrow>\n    Pairing_Heap_List1_Analysis.cost f ts =\n    Pairing_Heap_Tree_Analysis.cost f (map hom ts)", "case [simp]: Del_min"], ["proof (state)\nthis:\n  f = Del_min\n\ngoal (4 subgoals):\n 1. f = op.Empty \\<Longrightarrow>\n    Pairing_Heap_List1_Analysis.cost f ts =\n    Pairing_Heap_Tree_Analysis.cost f (map hom ts)\n 2. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       Pairing_Heap_List1_Analysis.cost f ts =\n       Pairing_Heap_Tree_Analysis.cost f (map hom ts)\n 3. f = Del_min \\<Longrightarrow>\n    Pairing_Heap_List1_Analysis.cost f ts =\n    Pairing_Heap_Tree_Analysis.cost f (map hom ts)\n 4. f = Merge \\<Longrightarrow>\n    Pairing_Heap_List1_Analysis.cost f ts =\n    Pairing_Heap_Tree_Analysis.cost f (map hom ts)", "then"], ["proof (chain)\npicking this:\n  f = Del_min", "obtain h where [simp]: \"ts = [h]\""], ["proof (prove)\nusing this:\n  f = Del_min\n\ngoal (1 subgoal):\n 1. (\\<And>h. ts = [h] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using 4"], ["proof (prove)\nusing this:\n  f = Del_min\n  Ball (set ts) is_root'\n  length ts = arity f\n\ngoal (1 subgoal):\n 1. (\\<And>h. ts = [h] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  ts = [h]\n\ngoal (4 subgoals):\n 1. f = op.Empty \\<Longrightarrow>\n    Pairing_Heap_List1_Analysis.cost f ts =\n    Pairing_Heap_Tree_Analysis.cost f (map hom ts)\n 2. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       Pairing_Heap_List1_Analysis.cost f ts =\n       Pairing_Heap_Tree_Analysis.cost f (map hom ts)\n 3. f = Del_min \\<Longrightarrow>\n    Pairing_Heap_List1_Analysis.cost f ts =\n    Pairing_Heap_Tree_Analysis.cost f (map hom ts)\n 4. f = Merge \\<Longrightarrow>\n    Pairing_Heap_List1_Analysis.cost f ts =\n    Pairing_Heap_Tree_Analysis.cost f (map hom ts)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Pairing_Heap_List1_Analysis.cost f ts =\n    Pairing_Heap_Tree_Analysis.cost f (map hom ts)", "using 4"], ["proof (prove)\nusing this:\n  Ball (set ts) is_root'\n  length ts = arity f\n\ngoal (1 subgoal):\n 1. Pairing_Heap_List1_Analysis.cost f ts =\n    Pairing_Heap_Tree_Analysis.cost f (map hom ts)", "by (cases h)(auto simp: T_pass1' T_pass2' no_Emptys_pass1 homs_pass1')"], ["proof (state)\nthis:\n  Pairing_Heap_List1_Analysis.cost f ts =\n  Pairing_Heap_Tree_Analysis.cost f (map hom ts)\n\ngoal (3 subgoals):\n 1. f = op.Empty \\<Longrightarrow>\n    Pairing_Heap_List1_Analysis.cost f ts =\n    Pairing_Heap_Tree_Analysis.cost f (map hom ts)\n 2. \\<And>x2.\n       f = Insert x2 \\<Longrightarrow>\n       Pairing_Heap_List1_Analysis.cost f ts =\n       Pairing_Heap_Tree_Analysis.cost f (map hom ts)\n 3. f = Merge \\<Longrightarrow>\n    Pairing_Heap_List1_Analysis.cost f ts =\n    Pairing_Heap_Tree_Analysis.cost f (map hom ts)", "qed (insert 4, auto)"], ["proof (state)\nthis:\n  Pairing_Heap_List1_Analysis.cost f ts =\n  Pairing_Heap_Tree_Analysis.cost f (map hom ts)\n\ngoal (1 subgoal):\n 1. \\<And>ts f.\n       \\<lbrakk>Ball (set ts) is_root'; length ts = arity f\\<rbrakk>\n       \\<Longrightarrow> Pairing_Heap_List1_Analysis.U f ts =\n                         Pairing_Heap_Tree_Analysis.U f (map hom ts)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ts f.\n       \\<lbrakk>Ball (set ts) is_root'; length ts = arity f\\<rbrakk>\n       \\<Longrightarrow> Pairing_Heap_List1_Analysis.U f ts =\n                         Pairing_Heap_Tree_Analysis.U f (map hom ts)", "case (5 _ f)"], ["proof (state)\nthis:\n  Ball (set ts_) is_root'\n  length ts_ = arity f\n\ngoal (1 subgoal):\n 1. \\<And>ts f.\n       \\<lbrakk>Ball (set ts) is_root'; length ts = arity f\\<rbrakk>\n       \\<Longrightarrow> Pairing_Heap_List1_Analysis.U f ts =\n                         Pairing_Heap_Tree_Analysis.U f (map hom ts)", "thus ?case"], ["proof (prove)\nusing this:\n  Ball (set ts_) is_root'\n  length ts_ = arity f\n\ngoal (1 subgoal):\n 1. Pairing_Heap_List1_Analysis.U f ts_ =\n    Pairing_Heap_Tree_Analysis.U f (map hom ts_)", "by(cases f) (auto simp: size_hp numeral_eq_Suc)"], ["proof (state)\nthis:\n  Pairing_Heap_List1_Analysis.U f ts_ =\n  Pairing_Heap_Tree_Analysis.U f (map hom ts_)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}