{"file_name": "/home/qj213/afp-2021-10-22/thys/FocusStreamsCaseStudies/stream.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/FocusStreamsCaseStudies", "problem_names": ["lemma inf_tm_hint1:\n  assumes \"i2 = Suc i - length a\"\n      and \"\\<not> Suc i \\<le> length a\" \n      and \"a \\<noteq> []\" \n  shows \"i2 < Suc i\"", "lemma length_inf_drop_hint1: \n  assumes \"s k \\<noteq> []\"\n  shows    \"length (inf_drop k s 0) \\<noteq> 0\"", "lemma length_inf_drop_hint2:\n\"(s 0 \\<noteq> [] \\<longrightarrow> length (inf_drop 0 s 0) < Suc i \n  \\<longrightarrow> Suc i - length (inf_drop 0 s 0) < Suc i)\"", "lemma inf_last_ti_nonempty_k:\n  assumes \"inf_last_ti dt t \\<noteq> []\"\n  shows    \"inf_last_ti dt (t + k) \\<noteq> []\"", "lemma inf_last_ti_nonempty:\n  assumes \"s t \\<noteq> []\"\n  shows    \"inf_last_ti s (t + k) \\<noteq> []\"", "lemma arith_sum_t2k:\n\"t + 2 + k = (Suc t) + (Suc k)\"", "lemma inf_last_ti_Suc2:\n  assumes \"dt (Suc t) \\<noteq> [] \\<or> dt (Suc (Suc t)) \\<noteq> []\"\n  shows    \"inf_last_ti dt (t + 2 + k) \\<noteq> []\"", "lemma fin_length_append:\n  \"fin_length (x@y) = (fin_length x) + (fin_length y)\"", "lemma fin_append_Nil:  \"fin_inf_append [] z = z\"", "lemma correct_fin_inf_append1:\n  assumes \"s1 = fin_inf_append [x] s\"\n  shows    \"s1 (Suc i) = s i\"", "lemma correct_fin_inf_append2:\n  \"fin_inf_append [x] s (Suc i) = s i\"", "lemma fin_append_com_Nil1:\n  \"fin_inf_append [] (fin_inf_append y z) \n   = fin_inf_append ([] @ y) z\"", "lemma fin_append_com_Nil2:\n  \"fin_inf_append x (fin_inf_append [] z) \n  = fin_inf_append (x @ []) z\"", "lemma fin_append_com_i:\n  \"fin_inf_append x (fin_inf_append y z) i = fin_inf_append (x @ y) z i \"", "lemma ts_msg1:\n  assumes \"ts p\"\n  shows    \"msg 1 p\"", "lemma ts_inf_tl:\n  assumes \"ts x\"\n  shows    \"ts (inf_tl x)\"", "lemma ts_length_hint1:\n assumes \"ts x\"\n shows    \"x i \\<noteq> []\"", "lemma ts_length_hint2:\n assumes \"ts x\"\n shows    \"length (x i) = Suc (0::nat)\"", "lemma ts_Least_0:\n  assumes \"ts x\"\n  shows    \"(LEAST i. (x i) \\<noteq> [] ) = (0::nat)\"", "lemma inf_tl_Suc: \"inf_tl x i = x (Suc i)\"", "lemma ts_Least_Suc0:\n  assumes \"ts x\"\n  shows    \"(LEAST i. x (Suc i) \\<noteq> []) = 0\"", "lemma ts_inf_make_untimed_inf_tl:\n  assumes \"ts x\"\n  shows     \"inf_make_untimed (inf_tl x) i = inf_make_untimed x (Suc i)\"", "lemma ts_inf_make_untimed1_inf_tl:\n  assumes \"ts x\"\n  shows    \"inf_make_untimed1 (inf_tl x) i = inf_make_untimed1 x (Suc i)\"", "lemma msg_nonempty1:\n  assumes h1:\"msg (Suc 0) a\" \n         and h2:\"a t = aa # l\"\n  shows \"l = []\"", "lemma msg_nonempty2:\n  assumes h1:\"msg (Suc 0) a\" \n         and h2:\"a t  \\<noteq> []\"\n  shows \"length (a t) = (Suc 0)\"", "lemma inf_truncate_nonempty:\n  assumes \"z i \\<noteq> []\"\n  shows    \"inf_truncate z i \\<noteq> []\"", "lemma concat_inf_truncate_nonempty:\n  assumes  \"z i \\<noteq> []\"\n  shows      \"concat (inf_truncate z i) \\<noteq> []\"", "lemma concat_inf_truncate_nonempty_a:\n  assumes \"z i = [a]\" \n  shows    \"concat (inf_truncate z i) \\<noteq> []\"", "lemma concat_inf_truncate_nonempty_el:\n  assumes \"z i \\<noteq> []\" \n  shows    \"concat (inf_truncate z i) \\<noteq> []\"", "lemma inf_truncate_append:\n  \"(inf_truncate z i @ [z (Suc i)]) = inf_truncate z (Suc i)\"", "lemma fin_make_untimed_append:\n  assumes \"fin_make_untimed x \\<noteq> []\"\n  shows    \"fin_make_untimed (x @ y) \\<noteq> []\"", "lemma fin_make_untimed_inf_truncate_Nonempty:\n  assumes \"z k \\<noteq> []\"\n         and \"k \\<le> i\"\n  shows \"fin_make_untimed (inf_truncate z i) \\<noteq> []\"", "lemma last_fin_make_untimed_append:\n  \"last (fin_make_untimed (z @ [[a]])) = a\"", "lemma last_fin_make_untimed_inf_truncate:\n  assumes \"z i = [a]\"\n  shows    \"last (fin_make_untimed (inf_truncate z i)) = a\"", "lemma fin_make_untimed_append_empty:\n  \"fin_make_untimed (z @ [[]]) = fin_make_untimed z\"", "lemma fin_make_untimed_inf_truncate_append_a:\n  \"fin_make_untimed (inf_truncate z i @ [[a]]) ! \n  (length (fin_make_untimed (inf_truncate z i @ [[a]])) - Suc 0) = a\"", "lemma fin_make_untimed_inf_truncate_Nonempty_all:\n  assumes \"z k \\<noteq> []\" \n  shows    \"\\<forall> i. k \\<le> i \\<longrightarrow> fin_make_untimed (inf_truncate z i) \\<noteq> []\"", "lemma fin_make_untimed_inf_truncate_Nonempty_all0:\n  assumes \"z 0 \\<noteq> []\"\n  shows    \"\\<forall> i. fin_make_untimed (inf_truncate z i) \\<noteq> []\"", "lemma fin_make_untimed_inf_truncate_Nonempty_all0a:\n  assumes \"z 0 = [a]\"\n  shows    \"\\<forall> i. fin_make_untimed (inf_truncate z i) \\<noteq> []\"", "lemma fin_make_untimed_inf_truncate_Nonempty_all_app:\n  assumes \"z 0 = [a]\" \n  shows    \"\\<forall> i. fin_make_untimed (inf_truncate z i @ [z (Suc i)]) \\<noteq> []\"", "lemma fin_make_untimed_nth_length:\n  assumes \"z i = [a]\"\n  shows \n  \"fin_make_untimed (inf_truncate z i) ! \n     (length (fin_make_untimed (inf_truncate z i)) - Suc 0)\n    = a\"", "lemma inf_disj_index:\n  assumes h1:\"inf_disj n nS\"\n         and \"nS k t \\<noteq> []\"\n         and \"k < n\"\n  shows  \"(SOME i. i < n \\<and>  nS i t \\<noteq> []) = k\"", "lemma inf_disjS_index:\n  assumes h1:\"inf_disjS IdSet nS\"\n      and \"k:IdSet\"\n      and \"nS k t \\<noteq> []\"\n  shows \"(SOME i. (i:IdSet) \\<and> nSend i t \\<noteq> []) = k\""], "translations": [["", "lemma inf_tm_hint1:\n  assumes \"i2 = Suc i - length a\"\n      and \"\\<not> Suc i \\<le> length a\" \n      and \"a \\<noteq> []\" \n  shows \"i2 < Suc i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i2 < Suc i", "using assms"], ["proof (prove)\nusing this:\n  i2 = Suc i - length a\n  \\<not> Suc i \\<le> length a\n  a \\<noteq> []\n\ngoal (1 subgoal):\n 1. i2 < Suc i", "by auto\n\n\n\\<comment> \\<open>filtering a finite timed stream\\<close>"], ["", "definition\n   finT_filter :: \"'a set => 'a fstream => 'a fstream\"   \nwhere \n  \"finT_filter m s \\<equiv>  map (\\<lambda> s. filter (\\<lambda> y. y \\<in> m) s) s\"\n\n\\<comment> \\<open>filtering an infinite timed stream\\<close>"], ["", "definition\n   infT_filter :: \"'a set => 'a istream => 'a istream\"  \nwhere\n  \"infT_filter m s \\<equiv>  (\\<lambda>i.( filter (\\<lambda> x. x \\<in> m) (s i)))\"\n\n\\<comment> \\<open>removing duplications from a finite timed stream\\<close>"], ["", "definition\n   finT_remdups :: \"'a fstream => 'a fstream\"\nwhere  \n  \"finT_remdups s \\<equiv>  map (\\<lambda> s. remdups s) s\"\n\n\\<comment> \\<open>removing duplications from an infinite timed stream\\<close>"], ["", "definition\n   infT_remdups :: \"'a istream => 'a istream\"  \nwhere\n  \"infT_remdups s \\<equiv>  (\\<lambda>i.( remdups (s i)))\"\n\n\\<comment> \\<open>removing duplications from a time interval of a stream\\<close>"], ["", "primrec\n   fst_remdups :: \"'a list \\<Rightarrow> 'a list\"\nwhere\n \"fst_remdups [] = []\" |\n \"fst_remdups (x#xs) = \n    (if xs = [] \n     then [x]\n     else (if x = (hd xs)\n           then fst_remdups xs\n           else (x#xs)))\"\n\n\\<comment> \\<open>time interval operator\\<close>"], ["", "definition\n  ti :: \"'a fstream \\<Rightarrow> nat \\<Rightarrow> 'a list\"\nwhere\n \"ti s i \\<equiv>  \n    (if s = []\n     then []\n     else (nth s i))\"\n\n\\<comment> \\<open>insuring that a sheaf of channels is correctly defined\\<close>"], ["", "definition\n   CorrectSheaf :: \"nat \\<Rightarrow> bool\"\nwhere\n  \"CorrectSheaf n \\<equiv> 0 < n\"\n \n\\<comment> \\<open>insuring that all channels in a sheaf are disjunct\\<close>\n\\<comment> \\<open>indices in the sheaf are represented using an extra specified set\\<close>"], ["", "definition\n   inf_disjS :: \"'b set \\<Rightarrow> ('b \\<Rightarrow> 'a istream) \\<Rightarrow> bool\"\nwhere\n  \"inf_disjS IdSet nS\n   \\<equiv>\n   \\<forall> (t::nat) i j. (i:IdSet) \\<and> (j:IdSet) \\<and>  \n   ((nS i) t) \\<noteq> []  \\<longrightarrow> ((nS j) t) = []\"  \n\n\\<comment> \\<open>insuring that all channels in a sheaf are disjunct\\<close>\n\\<comment> \\<open>indices in the sheaf are represented using natural numbers\\<close>"], ["", "definition              \n   inf_disj :: \"nat \\<Rightarrow> (nat \\<Rightarrow> 'a istream) \\<Rightarrow> bool\"\nwhere\n  \"inf_disj n nS\n   \\<equiv>\n   \\<forall> (t::nat) (i::nat) (j::nat). \n   i < n  \\<and>  j < n \\<and> i \\<noteq> j \\<and> ((nS i) t) \\<noteq> []  \\<longrightarrow> \n   ((nS j) t) = []\"  \n\n\\<comment> \\<open>taking the prefix of n data elements from a finite timed stream\\<close>\n\\<comment> \\<open>(defined over natural numbers)\\<close>"], ["", "fun fin_get_prefix  :: \"('a fstream \\<times> nat) \\<Rightarrow> 'a fstream\"\nwhere\n  \"fin_get_prefix([], n) = []\" |\n  \"fin_get_prefix(x#xs, i) = \n     ( if (length x) < i \n       then x # fin_get_prefix(xs, (i - (length x)))\n       else [take i x] ) \"\n\n\\<comment> \\<open>taking the prefix of n data elements from a finite timed stream\\<close>\n\\<comment> \\<open>(defined over natural numbers enriched by Infinity)\\<close>"], ["", "definition\n  fin_get_prefix_plus :: \"'a fstream \\<Rightarrow> natInf \\<Rightarrow> 'a fstream\"\nwhere\n \"fin_get_prefix_plus s n \n  \\<equiv> \n  case n of (Fin i) \\<Rightarrow> fin_get_prefix(s, i)\n           | \\<infinity>      \\<Rightarrow> s \"\n\n\\<comment> \\<open>auxiliary lemmas\\<close>"], ["", "lemma length_inf_drop_hint1: \n  assumes \"s k \\<noteq> []\"\n  shows    \"length (inf_drop k s 0) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (inf_drop k s 0) \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  s k \\<noteq> []\n\ngoal (1 subgoal):\n 1. length (inf_drop k s 0) \\<noteq> 0", "by (auto simp: inf_drop_def)"], ["", "lemma length_inf_drop_hint2:\n\"(s 0 \\<noteq> [] \\<longrightarrow> length (inf_drop 0 s 0) < Suc i \n  \\<longrightarrow> Suc i - length (inf_drop 0 s 0) < Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s 0 \\<noteq> [] \\<longrightarrow>\n    length (inf_drop 0 s 0) < Suc i \\<longrightarrow>\n    Suc i - length (inf_drop 0 s 0) < Suc i", "by (simp add: inf_drop_def list_length_hint1)\n\n\\<comment> \\<open>taking the prefix of n data elements from an infinite timed stream\\<close>\n\\<comment> \\<open>(defined over natural numbers)\\<close>"], ["", "fun infT_get_prefix  :: \"('a istream \\<times> nat) \\<Rightarrow> 'a fstream\"\nwhere   \n  \"infT_get_prefix(s, 0) = []\"\n|\n  \"infT_get_prefix(s, Suc i) = \n    ( if (s 0) = []\n      then ( if (\\<forall> i. s i = [])\n             then []\n             else (let \n                     k = (LEAST k. s k \\<noteq> [] \\<and> (\\<forall>i. i < k \\<longrightarrow> s i = []));\n                     s2 = inf_drop (k+1) s\n                   in (if (length (s k)=0) \n                       then [] \n                       else (if (length (s k) < (Suc i)) \n                             then s k # infT_get_prefix (s2,Suc i - length (s k))\n                             else [take (Suc i) (s k)] )))\n           )\n      else \n        (if ((length (s 0)) < (Suc i)) \n         then (s 0) # infT_get_prefix( inf_drop 1 s, (Suc i) - (length (s 0)))\n         else [take (Suc i) (s 0)] \n         )\n     )\"\n\n\\<comment> \\<open>taking the prefix of n data elements from an infinite untimed stream\\<close>\n\\<comment> \\<open>(defined over natural numbers)\\<close>"], ["", "primrec\n  infU_get_prefix  :: \"(nat \\<Rightarrow> 'a) \\<Rightarrow> nat \\<Rightarrow> 'a list\"\nwhere\n  \"infU_get_prefix s 0 = []\" |\n  \"infU_get_prefix s (Suc i) \n         = (infU_get_prefix s i) @ [s i]\"\n\n\\<comment> \\<open>taking the prefix of n data elements from an infinite timed stream\\<close>\n\\<comment> \\<open>(defined over natural numbers enriched by Infinity)\\<close>"], ["", "definition\n  infT_get_prefix_plus :: \"'a istream \\<Rightarrow> natInf \\<Rightarrow> 'a stream\"\nwhere\n\"infT_get_prefix_plus s n \n  \\<equiv> \n  case n of (Fin i) \\<Rightarrow> FinT (infT_get_prefix(s, i)) \n           | \\<infinity>     \\<Rightarrow> InfT s\"\n\n\\<comment> \\<open>taking the prefix of n data elements from an infinite untimed stream\\<close>\n\\<comment> \\<open>(defined over natural numbers enriched by Infinity)\\<close>"], ["", "definition\n  infU_get_prefix_plus :: \"(nat \\<Rightarrow> 'a) \\<Rightarrow> natInf \\<Rightarrow> 'a stream\"\nwhere\n \"infU_get_prefix_plus s n \n  \\<equiv> \n  case n of (Fin i) \\<Rightarrow> FinU (infU_get_prefix s i) \n           | \\<infinity>     \\<Rightarrow> InfU s\"\n\n\\<comment> \\<open>taking the prefix of n data elements from an infinite stream\\<close>\n\\<comment> \\<open>(defined over natural numbers enriched by Infinity)\\<close>"], ["", "definition\n  take_plus :: \"natInf \\<Rightarrow> 'a list \\<Rightarrow> 'a list\"\nwhere\n \"take_plus n s \n  \\<equiv> \n  case n of (Fin i) \\<Rightarrow> (take i s) \n           | \\<infinity>      \\<Rightarrow> s\"\n\n\\<comment> \\<open>taking the prefix of n data elements from a (general) stream\\<close>\n\\<comment> \\<open>(defined over natural numbers enriched by Infinity)\\<close>"], ["", "definition \n   get_prefix :: \"'a stream \\<Rightarrow> natInf \\<Rightarrow> 'a stream\"\nwhere\n   \"get_prefix s k \\<equiv> \n        case s of  (FinT x) \\<Rightarrow> FinT (fin_get_prefix_plus x k)\n                 | (FinU x) \\<Rightarrow> FinU (take_plus k x)\n                 | (InfT x) \\<Rightarrow> infT_get_prefix_plus x k\n                 | (InfU x) \\<Rightarrow> infU_get_prefix_plus x k\"\n\n\\<comment> \\<open>merging time intervals of two finite timed streams\\<close>"], ["", "primrec\n   fin_merge_ti :: \"'a fstream \\<Rightarrow> 'a fstream \\<Rightarrow> 'a fstream\"\nwhere\n \"fin_merge_ti [] y = y\" |\n \"fin_merge_ti (x#xs) y = \n    ( case y of [] \\<Rightarrow> (x#xs)\n         | (z#zs) \\<Rightarrow> (x@z) # (fin_merge_ti xs zs))\"\n\n\\<comment> \\<open>merging time intervals of two infinite timed streams\\<close>"], ["", "definition\n inf_merge_ti :: \"'a istream \\<Rightarrow> 'a istream \\<Rightarrow> 'a istream\"\nwhere\n \"inf_merge_ti x y \n  \\<equiv> \n  \\<lambda> i. (x i)@(y i)\"\n\n\\<comment> \\<open>the last time interval of a finite timed stream\\<close>"], ["", "primrec\n  fin_last_ti :: \"('a list) list \\<Rightarrow> nat \\<Rightarrow> 'a list\"\nwhere   \n \"fin_last_ti s 0 = hd s\" |\n \"fin_last_ti s (Suc i) = \n     ( if s!(Suc i) \\<noteq> []\n       then s!(Suc i) \n       else fin_last_ti s i)\"\n\n\\<comment> \\<open>the last nonempty time interval of a finite timed stream\\<close>\n\\<comment> \\<open>(can be applied to the streams which time intervals are empty from some moment)\\<close>"], ["", "primrec\n  inf_last_ti :: \"'a istream \\<Rightarrow> nat \\<Rightarrow> 'a list\"\nwhere  \n \"inf_last_ti s 0 = s 0\" |\n \"inf_last_ti s (Suc i) = \n     ( if s (Suc i) \\<noteq> []\n       then s (Suc i) \n       else inf_last_ti s i)\""], ["", "subsection \\<open>Properties of operators\\<close>"], ["", "lemma inf_last_ti_nonempty_k:\n  assumes \"inf_last_ti dt t \\<noteq> []\"\n  shows    \"inf_last_ti dt (t + k) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_last_ti dt (t + k) \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  inf_last_ti dt t \\<noteq> []\n\ngoal (1 subgoal):\n 1. inf_last_ti dt (t + k) \\<noteq> []", "by (induct k, auto)"], ["", "lemma inf_last_ti_nonempty:\n  assumes \"s t \\<noteq> []\"\n  shows    \"inf_last_ti s (t + k) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_last_ti s (t + k) \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  s t \\<noteq> []\n\ngoal (1 subgoal):\n 1. inf_last_ti s (t + k) \\<noteq> []", "by (induct k, auto, induct t, auto)"], ["", "lemma arith_sum_t2k:\n\"t + 2 + k = (Suc t) + (Suc k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t + 2 + k = Suc t + Suc k", "by arith"], ["", "lemma inf_last_ti_Suc2:\n  assumes \"dt (Suc t) \\<noteq> [] \\<or> dt (Suc (Suc t)) \\<noteq> []\"\n  shows    \"inf_last_ti dt (t + 2 + k) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_last_ti dt (t + 2 + k) \\<noteq> []", "proof (cases \"dt (Suc t) \\<noteq> []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. dt (Suc t) \\<noteq> [] \\<Longrightarrow>\n    inf_last_ti dt (t + 2 + k) \\<noteq> []\n 2. \\<not> dt (Suc t) \\<noteq> [] \\<Longrightarrow>\n    inf_last_ti dt (t + 2 + k) \\<noteq> []", "assume a1:\"dt (Suc t) \\<noteq> []\""], ["proof (state)\nthis:\n  dt (Suc t) \\<noteq> []\n\ngoal (2 subgoals):\n 1. dt (Suc t) \\<noteq> [] \\<Longrightarrow>\n    inf_last_ti dt (t + 2 + k) \\<noteq> []\n 2. \\<not> dt (Suc t) \\<noteq> [] \\<Longrightarrow>\n    inf_last_ti dt (t + 2 + k) \\<noteq> []", "from a1"], ["proof (chain)\npicking this:\n  dt (Suc t) \\<noteq> []", "have sg2:\"inf_last_ti dt ((Suc t) + (Suc k)) \\<noteq> []\""], ["proof (prove)\nusing this:\n  dt (Suc t) \\<noteq> []\n\ngoal (1 subgoal):\n 1. inf_last_ti dt (Suc t + Suc k) \\<noteq> []", "by (rule inf_last_ti_nonempty)"], ["proof (state)\nthis:\n  inf_last_ti dt (Suc t + Suc k) \\<noteq> []\n\ngoal (2 subgoals):\n 1. dt (Suc t) \\<noteq> [] \\<Longrightarrow>\n    inf_last_ti dt (t + 2 + k) \\<noteq> []\n 2. \\<not> dt (Suc t) \\<noteq> [] \\<Longrightarrow>\n    inf_last_ti dt (t + 2 + k) \\<noteq> []", "from sg2"], ["proof (chain)\npicking this:\n  inf_last_ti dt (Suc t + Suc k) \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  inf_last_ti dt (Suc t + Suc k) \\<noteq> []\n\ngoal (1 subgoal):\n 1. inf_last_ti dt (t + 2 + k) \\<noteq> []", "by (simp add: arith_sum_t2k)"], ["proof (state)\nthis:\n  inf_last_ti dt (t + 2 + k) \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> dt (Suc t) \\<noteq> [] \\<Longrightarrow>\n    inf_last_ti dt (t + 2 + k) \\<noteq> []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> dt (Suc t) \\<noteq> [] \\<Longrightarrow>\n    inf_last_ti dt (t + 2 + k) \\<noteq> []", "assume a2:\"\\<not> dt (Suc t) \\<noteq> []\""], ["proof (state)\nthis:\n  \\<not> dt (Suc t) \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> dt (Suc t) \\<noteq> [] \\<Longrightarrow>\n    inf_last_ti dt (t + 2 + k) \\<noteq> []", "from a2 and assms"], ["proof (chain)\npicking this:\n  \\<not> dt (Suc t) \\<noteq> []\n  dt (Suc t) \\<noteq> [] \\<or> dt (Suc (Suc t)) \\<noteq> []", "have sg1:\"dt (Suc (Suc t)) \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<not> dt (Suc t) \\<noteq> []\n  dt (Suc t) \\<noteq> [] \\<or> dt (Suc (Suc t)) \\<noteq> []\n\ngoal (1 subgoal):\n 1. dt (Suc (Suc t)) \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  dt (Suc (Suc t)) \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> dt (Suc t) \\<noteq> [] \\<Longrightarrow>\n    inf_last_ti dt (t + 2 + k) \\<noteq> []", "from sg1"], ["proof (chain)\npicking this:\n  dt (Suc (Suc t)) \\<noteq> []", "have sg2:\"inf_last_ti dt (Suc (Suc t) + k) \\<noteq> []\""], ["proof (prove)\nusing this:\n  dt (Suc (Suc t)) \\<noteq> []\n\ngoal (1 subgoal):\n 1. inf_last_ti dt (Suc (Suc t) + k) \\<noteq> []", "by (rule inf_last_ti_nonempty)"], ["proof (state)\nthis:\n  inf_last_ti dt (Suc (Suc t) + k) \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> dt (Suc t) \\<noteq> [] \\<Longrightarrow>\n    inf_last_ti dt (t + 2 + k) \\<noteq> []", "from sg2"], ["proof (chain)\npicking this:\n  inf_last_ti dt (Suc (Suc t) + k) \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  inf_last_ti dt (Suc (Suc t) + k) \\<noteq> []\n\ngoal (1 subgoal):\n 1. inf_last_ti dt (t + 2 + k) \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  inf_last_ti dt (t + 2 + k) \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Lemmas for concatenation operator\\<close>"], ["", "lemma fin_length_append:\n  \"fin_length (x@y) = (fin_length x) + (fin_length y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fin_length (x @ y) = fin_length x + fin_length y", "by (induct x, auto)"], ["", "lemma fin_append_Nil:  \"fin_inf_append [] z = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fin_inf_append [] z = z", "by (simp add: fin_inf_append_def)"], ["", "lemma correct_fin_inf_append1:\n  assumes \"s1 = fin_inf_append [x] s\"\n  shows    \"s1 (Suc i) = s i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s1 (Suc i) = s i", "using assms"], ["proof (prove)\nusing this:\n  s1 = fin_inf_append [x] s\n\ngoal (1 subgoal):\n 1. s1 (Suc i) = s i", "by (simp add: fin_inf_append_def)"], ["", "lemma correct_fin_inf_append2:\n  \"fin_inf_append [x] s (Suc i) = s i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fin_inf_append [x] s (Suc i) = s i", "by (simp add: fin_inf_append_def)"], ["", "lemma fin_append_com_Nil1:\n  \"fin_inf_append [] (fin_inf_append y z) \n   = fin_inf_append ([] @ y) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fin_inf_append [] (fin_inf_append y z) = fin_inf_append ([] @ y) z", "by (simp add: fin_append_Nil)"], ["", "lemma fin_append_com_Nil2:\n  \"fin_inf_append x (fin_inf_append [] z) \n  = fin_inf_append (x @ []) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fin_inf_append x (fin_inf_append [] z) = fin_inf_append (x @ []) z", "by (simp add: fin_append_Nil)"], ["", "lemma fin_append_com_i:\n  \"fin_inf_append x (fin_inf_append y z) i = fin_inf_append (x @ y) z i \""], ["proof (prove)\ngoal (1 subgoal):\n 1. fin_inf_append x (fin_inf_append y z) i = fin_inf_append (x @ y) z i", "proof (cases x)"], ["proof (state)\ngoal (2 subgoals):\n 1. x = [] \\<Longrightarrow>\n    fin_inf_append x (fin_inf_append y z) i = fin_inf_append (x @ y) z i\n 2. \\<And>a list.\n       x = a # list \\<Longrightarrow>\n       fin_inf_append x (fin_inf_append y z) i = fin_inf_append (x @ y) z i", "assume Nil:\"x = []\""], ["proof (state)\nthis:\n  x = []\n\ngoal (2 subgoals):\n 1. x = [] \\<Longrightarrow>\n    fin_inf_append x (fin_inf_append y z) i = fin_inf_append (x @ y) z i\n 2. \\<And>a list.\n       x = a # list \\<Longrightarrow>\n       fin_inf_append x (fin_inf_append y z) i = fin_inf_append (x @ y) z i", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = []\n\ngoal (1 subgoal):\n 1. fin_inf_append x (fin_inf_append y z) i = fin_inf_append (x @ y) z i", "by (simp add: fin_append_com_Nil1)"], ["proof (state)\nthis:\n  fin_inf_append x (fin_inf_append y z) i = fin_inf_append (x @ y) z i\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       x = a # list \\<Longrightarrow>\n       fin_inf_append x (fin_inf_append y z) i = fin_inf_append (x @ y) z i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       x = a # list \\<Longrightarrow>\n       fin_inf_append x (fin_inf_append y z) i = fin_inf_append (x @ y) z i", "fix a l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       x = a # list \\<Longrightarrow>\n       fin_inf_append x (fin_inf_append y z) i = fin_inf_append (x @ y) z i", "assume Cons:\"x = a # l\""], ["proof (state)\nthis:\n  x = a # l\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       x = a # list \\<Longrightarrow>\n       fin_inf_append x (fin_inf_append y z) i = fin_inf_append (x @ y) z i", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = a # l\n\ngoal (1 subgoal):\n 1. fin_inf_append x (fin_inf_append y z) i = fin_inf_append (x @ y) z i", "proof (cases y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = a # l; y = []\\<rbrakk>\n    \\<Longrightarrow> fin_inf_append x (fin_inf_append y z) i =\n                      fin_inf_append (x @ y) z i\n 2. \\<And>aa list.\n       \\<lbrakk>x = a # l; y = aa # list\\<rbrakk>\n       \\<Longrightarrow> fin_inf_append x (fin_inf_append y z) i =\n                         fin_inf_append (x @ y) z i", "assume \"y = []\""], ["proof (state)\nthis:\n  y = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = a # l; y = []\\<rbrakk>\n    \\<Longrightarrow> fin_inf_append x (fin_inf_append y z) i =\n                      fin_inf_append (x @ y) z i\n 2. \\<And>aa list.\n       \\<lbrakk>x = a # l; y = aa # list\\<rbrakk>\n       \\<Longrightarrow> fin_inf_append x (fin_inf_append y z) i =\n                         fin_inf_append (x @ y) z i", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = []\n\ngoal (1 subgoal):\n 1. fin_inf_append x (fin_inf_append y z) i = fin_inf_append (x @ y) z i", "by (simp add: fin_append_com_Nil2)"], ["proof (state)\nthis:\n  fin_inf_append x (fin_inf_append y z) i = fin_inf_append (x @ y) z i\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>x = a # l; y = aa # list\\<rbrakk>\n       \\<Longrightarrow> fin_inf_append x (fin_inf_append y z) i =\n                         fin_inf_append (x @ y) z i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>x = a # l; y = aa # list\\<rbrakk>\n       \\<Longrightarrow> fin_inf_append x (fin_inf_append y z) i =\n                         fin_inf_append (x @ y) z i", "fix aa la"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>x = a # l; y = aa # list\\<rbrakk>\n       \\<Longrightarrow> fin_inf_append x (fin_inf_append y z) i =\n                         fin_inf_append (x @ y) z i", "assume Cons2:\"y = aa # la\""], ["proof (state)\nthis:\n  y = aa # la\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       \\<lbrakk>x = a # l; y = aa # list\\<rbrakk>\n       \\<Longrightarrow> fin_inf_append x (fin_inf_append y z) i =\n                         fin_inf_append (x @ y) z i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fin_inf_append x (fin_inf_append y z) i = fin_inf_append (x @ y) z i", "apply (simp add: fin_inf_append_def, auto, simp add: list_nth_append0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> i < length x; i - length x < length y;\n     i < length x + length y\\<rbrakk>\n    \\<Longrightarrow> y ! (i - length x) = (x @ y) ! i", "by (simp add: nth_append)"], ["proof (state)\nthis:\n  fin_inf_append x (fin_inf_append y z) i = fin_inf_append (x @ y) z i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fin_inf_append x (fin_inf_append y z) i = fin_inf_append (x @ y) z i\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Lemmas for operators $ts$ and $msg$\\<close>"], ["", "lemma ts_msg1:\n  assumes \"ts p\"\n  shows    \"msg 1 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msg 1 p", "using assms"], ["proof (prove)\nusing this:\n  ts p\n\ngoal (1 subgoal):\n 1. msg 1 p", "by (simp add: ts_def msg_def)"], ["", "lemma ts_inf_tl:\n  assumes \"ts x\"\n  shows    \"ts (inf_tl x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts (inf_tl x)", "using assms"], ["proof (prove)\nusing this:\n  ts x\n\ngoal (1 subgoal):\n 1. ts (inf_tl x)", "by (simp add: ts_def inf_tl_def)"], ["", "lemma ts_length_hint1:\n assumes \"ts x\"\n shows    \"x i \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x i \\<noteq> []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x i \\<noteq> []", "from assms"], ["proof (chain)\npicking this:\n  ts x", "have sg1:\"length (x i) = Suc 0\""], ["proof (prove)\nusing this:\n  ts x\n\ngoal (1 subgoal):\n 1. length (x i) = Suc 0", "by (simp add: ts_def)"], ["proof (state)\nthis:\n  length (x i) = Suc 0\n\ngoal (1 subgoal):\n 1. x i \\<noteq> []", "thus ?thesis"], ["proof (prove)\nusing this:\n  length (x i) = Suc 0\n\ngoal (1 subgoal):\n 1. x i \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  x i \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ts_length_hint2:\n assumes \"ts x\"\n shows    \"length (x i) = Suc (0::nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (x i) = Suc 0", "using assms"], ["proof (prove)\nusing this:\n  ts x\n\ngoal (1 subgoal):\n 1. length (x i) = Suc 0", "by (simp add: ts_def)"], ["", "lemma ts_Least_0:\n  assumes \"ts x\"\n  shows    \"(LEAST i. (x i) \\<noteq> [] ) = (0::nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST i. x i \\<noteq> []) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST i. x i \\<noteq> []) = 0", "from assms"], ["proof (chain)\npicking this:\n  ts x", "have sg1:\"x 0 \\<noteq> []\""], ["proof (prove)\nusing this:\n  ts x\n\ngoal (1 subgoal):\n 1. x 0 \\<noteq> []", "by (rule ts_length_hint1)"], ["proof (state)\nthis:\n  x 0 \\<noteq> []\n\ngoal (1 subgoal):\n 1. (LEAST i. x i \\<noteq> []) = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  x 0 \\<noteq> []\n\ngoal (1 subgoal):\n 1. (LEAST i. x i \\<noteq> []) = 0", "apply (simp add: Least_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x 0 \\<noteq> [] \\<Longrightarrow>\n    (THE xa.\n        x xa \\<noteq> [] \\<and>\n        (\\<forall>y. x y \\<noteq> [] \\<longrightarrow> xa \\<le> y)) =\n    0", "by auto"], ["proof (state)\nthis:\n  (LEAST i. x i \\<noteq> []) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inf_tl_Suc: \"inf_tl x i = x (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_tl x i = x (Suc i)", "by (simp add: inf_tl_def)"], ["", "lemma ts_Least_Suc0:\n  assumes \"ts x\"\n  shows    \"(LEAST i. x (Suc i) \\<noteq> []) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST i. x (Suc i) \\<noteq> []) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST i. x (Suc i) \\<noteq> []) = 0", "from assms"], ["proof (chain)\npicking this:\n  ts x", "have \"x (Suc 0) \\<noteq> []\""], ["proof (prove)\nusing this:\n  ts x\n\ngoal (1 subgoal):\n 1. x (Suc 0) \\<noteq> []", "by (simp add: ts_length_hint1)"], ["proof (state)\nthis:\n  x (Suc 0) \\<noteq> []\n\ngoal (1 subgoal):\n 1. (LEAST i. x (Suc i) \\<noteq> []) = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  x (Suc 0) \\<noteq> []\n\ngoal (1 subgoal):\n 1. (LEAST i. x (Suc i) \\<noteq> []) = 0", "by (simp add: Least_def, auto)"], ["proof (state)\nthis:\n  (LEAST i. x (Suc i) \\<noteq> []) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ts_inf_make_untimed_inf_tl:\n  assumes \"ts x\"\n  shows     \"inf_make_untimed (inf_tl x) i = inf_make_untimed x (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_make_untimed (inf_tl x) i = inf_make_untimed x (Suc i)", "using assms"], ["proof (prove)\nusing this:\n  ts x\n\ngoal (1 subgoal):\n 1. inf_make_untimed (inf_tl x) i = inf_make_untimed x (Suc i)", "apply (simp add: inf_make_untimed_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ts x \\<Longrightarrow>\n    (x 0 = [] \\<longrightarrow>\n     inf_make_untimed1 (inf_tl x) i =\n     inf_make_untimed1 (inf_tl (inf_drop 0 x)) i) \\<and>\n    (x 0 \\<noteq> [] \\<longrightarrow>\n     Suc i < length (x 0) \\<longrightarrow>\n     inf_make_untimed1 (inf_tl x) i = x 0 ! Suc i)", "by (metis Suc_less_eq gr_implies_not0 ts_length_hint1 ts_length_hint2)"], ["", "lemma ts_inf_make_untimed1_inf_tl:\n  assumes \"ts x\"\n  shows    \"inf_make_untimed1 (inf_tl x) i = inf_make_untimed1 x (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_make_untimed1 (inf_tl x) i = inf_make_untimed1 x (Suc i)", "using assms"], ["proof (prove)\nusing this:\n  ts x\n\ngoal (1 subgoal):\n 1. inf_make_untimed1 (inf_tl x) i = inf_make_untimed1 x (Suc i)", "by (metis inf_make_untimed_def ts_inf_make_untimed_inf_tl)"], ["", "lemma msg_nonempty1:\n  assumes h1:\"msg (Suc 0) a\" \n         and h2:\"a t = aa # l\"\n  shows \"l = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. l = []", "from h1"], ["proof (chain)\npicking this:\n  msg (Suc 0) a", "have \"length (a t) \\<le> Suc 0\""], ["proof (prove)\nusing this:\n  msg (Suc 0) a\n\ngoal (1 subgoal):\n 1. length (a t) \\<le> Suc 0", "by (simp add: msg_def)"], ["proof (state)\nthis:\n  length (a t) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. l = []", "from h2 and this"], ["proof (chain)\npicking this:\n  a t = aa # l\n  length (a t) \\<le> Suc 0", "show ?thesis"], ["proof (prove)\nusing this:\n  a t = aa # l\n  length (a t) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. l = []", "by auto"], ["proof (state)\nthis:\n  l = []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma msg_nonempty2:\n  assumes h1:\"msg (Suc 0) a\" \n         and h2:\"a t  \\<noteq> []\"\n  shows \"length (a t) = (Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (a t) = Suc 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (a t) = Suc 0", "from h1"], ["proof (chain)\npicking this:\n  msg (Suc 0) a", "have sg1:\"length (a t) \\<le> Suc 0\""], ["proof (prove)\nusing this:\n  msg (Suc 0) a\n\ngoal (1 subgoal):\n 1. length (a t) \\<le> Suc 0", "by (simp add: msg_def)"], ["proof (state)\nthis:\n  length (a t) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. length (a t) = Suc 0", "from h2"], ["proof (chain)\npicking this:\n  a t \\<noteq> []", "have sg2:\"length (a t) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  a t \\<noteq> []\n\ngoal (1 subgoal):\n 1. length (a t) \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  length (a t) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. length (a t) = Suc 0", "from sg1 and sg2"], ["proof (chain)\npicking this:\n  length (a t) \\<le> Suc 0\n  length (a t) \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  length (a t) \\<le> Suc 0\n  length (a t) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. length (a t) = Suc 0", "by arith"], ["proof (state)\nthis:\n  length (a t) = Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Lemmas for $inf\\_truncate$\\<close>"], ["", "lemma inf_truncate_nonempty:\n  assumes \"z i \\<noteq> []\"\n  shows    \"inf_truncate z i \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_truncate z i \\<noteq> []", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. inf_truncate z 0 \\<noteq> []\n 2. \\<And>i.\n       inf_truncate z i \\<noteq> [] \\<Longrightarrow>\n       inf_truncate z (Suc i) \\<noteq> []", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. inf_truncate z 0 \\<noteq> []\n 2. \\<And>i.\n       inf_truncate z i \\<noteq> [] \\<Longrightarrow>\n       inf_truncate z (Suc i) \\<noteq> []", "from assms"], ["proof (chain)\npicking this:\n  z i \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  z i \\<noteq> []\n\ngoal (1 subgoal):\n 1. inf_truncate z 0 \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  inf_truncate z 0 \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       inf_truncate z i \\<noteq> [] \\<Longrightarrow>\n       inf_truncate z (Suc i) \\<noteq> []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       inf_truncate z i \\<noteq> [] \\<Longrightarrow>\n       inf_truncate z (Suc i) \\<noteq> []", "case (Suc i)"], ["proof (state)\nthis:\n  inf_truncate z i \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       inf_truncate z i \\<noteq> [] \\<Longrightarrow>\n       inf_truncate z (Suc i) \\<noteq> []", "from assms"], ["proof (chain)\npicking this:\n  z i \\<noteq> []", "show ?case"], ["proof (prove)\nusing this:\n  z i \\<noteq> []\n\ngoal (1 subgoal):\n 1. inf_truncate z (Suc i) \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  inf_truncate z (Suc i) \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma concat_inf_truncate_nonempty:\n  assumes  \"z i \\<noteq> []\"\n  shows      \"concat (inf_truncate z i) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (inf_truncate z i) \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  z i \\<noteq> []\n\ngoal (1 subgoal):\n 1. concat (inf_truncate z i) \\<noteq> []", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. z 0 \\<noteq> [] \\<Longrightarrow> concat (inf_truncate z 0) \\<noteq> []\n 2. \\<And>i.\n       \\<lbrakk>z i \\<noteq> [] \\<Longrightarrow>\n                concat (inf_truncate z i) \\<noteq> [];\n        z (Suc i) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> concat (inf_truncate z (Suc i)) \\<noteq> []", "case 0"], ["proof (state)\nthis:\n  z 0 \\<noteq> []\n\ngoal (2 subgoals):\n 1. z 0 \\<noteq> [] \\<Longrightarrow> concat (inf_truncate z 0) \\<noteq> []\n 2. \\<And>i.\n       \\<lbrakk>z i \\<noteq> [] \\<Longrightarrow>\n                concat (inf_truncate z i) \\<noteq> [];\n        z (Suc i) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> concat (inf_truncate z (Suc i)) \\<noteq> []", "thus ?case"], ["proof (prove)\nusing this:\n  z 0 \\<noteq> []\n\ngoal (1 subgoal):\n 1. concat (inf_truncate z 0) \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  concat (inf_truncate z 0) \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>z i \\<noteq> [] \\<Longrightarrow>\n                concat (inf_truncate z i) \\<noteq> [];\n        z (Suc i) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> concat (inf_truncate z (Suc i)) \\<noteq> []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>z i \\<noteq> [] \\<Longrightarrow>\n                concat (inf_truncate z i) \\<noteq> [];\n        z (Suc i) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> concat (inf_truncate z (Suc i)) \\<noteq> []", "case (Suc i)"], ["proof (state)\nthis:\n  z i \\<noteq> [] \\<Longrightarrow> concat (inf_truncate z i) \\<noteq> []\n  z (Suc i) \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>z i \\<noteq> [] \\<Longrightarrow>\n                concat (inf_truncate z i) \\<noteq> [];\n        z (Suc i) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> concat (inf_truncate z (Suc i)) \\<noteq> []", "thus ?case"], ["proof (prove)\nusing this:\n  z i \\<noteq> [] \\<Longrightarrow> concat (inf_truncate z i) \\<noteq> []\n  z (Suc i) \\<noteq> []\n\ngoal (1 subgoal):\n 1. concat (inf_truncate z (Suc i)) \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  concat (inf_truncate z (Suc i)) \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma concat_inf_truncate_nonempty_a:\n  assumes \"z i = [a]\" \n  shows    \"concat (inf_truncate z i) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (inf_truncate z i) \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  z i = [a]\n\ngoal (1 subgoal):\n 1. concat (inf_truncate z i) \\<noteq> []", "by (metis concat_inf_truncate_nonempty list.distinct(1))"], ["", "lemma concat_inf_truncate_nonempty_el:\n  assumes \"z i \\<noteq> []\" \n  shows    \"concat (inf_truncate z i) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (inf_truncate z i) \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  z i \\<noteq> []\n\ngoal (1 subgoal):\n 1. concat (inf_truncate z i) \\<noteq> []", "by (metis concat_inf_truncate_nonempty)"], ["", "lemma inf_truncate_append:\n  \"(inf_truncate z i @ [z (Suc i)]) = inf_truncate z (Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_truncate z i @ [z (Suc i)] = inf_truncate z (Suc i)", "by (metis inf_truncate.simps(2))"], ["", "subsubsection \\<open>Lemmas for $fin\\_make\\_untimed$\\<close>"], ["", "lemma fin_make_untimed_append:\n  assumes \"fin_make_untimed x \\<noteq> []\"\n  shows    \"fin_make_untimed (x @ y) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fin_make_untimed (x @ y) \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  fin_make_untimed x \\<noteq> []\n\ngoal (1 subgoal):\n 1. fin_make_untimed (x @ y) \\<noteq> []", "by (simp add: fin_make_untimed_def)"], ["", "lemma fin_make_untimed_inf_truncate_Nonempty:\n  assumes \"z k \\<noteq> []\"\n         and \"k \\<le> i\"\n  shows \"fin_make_untimed (inf_truncate z i) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fin_make_untimed (inf_truncate z i) \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  z k \\<noteq> []\n  k \\<le> i\n\ngoal (1 subgoal):\n 1. fin_make_untimed (inf_truncate z i) \\<noteq> []", "apply (simp add: fin_make_untimed_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z k \\<noteq> []; k \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z i). xs \\<noteq> []", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>z k \\<noteq> []; k \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z 0). xs \\<noteq> []\n 2. \\<And>i.\n       \\<lbrakk>\\<lbrakk>z k \\<noteq> []; k \\<le> i\\<rbrakk>\n                \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z i).\n                                     xs \\<noteq> [];\n        z k \\<noteq> []; k \\<le> Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z (Suc i)).\n                            xs \\<noteq> []", "case 0"], ["proof (state)\nthis:\n  z k \\<noteq> []\n  k \\<le> 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>z k \\<noteq> []; k \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z 0). xs \\<noteq> []\n 2. \\<And>i.\n       \\<lbrakk>\\<lbrakk>z k \\<noteq> []; k \\<le> i\\<rbrakk>\n                \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z i).\n                                     xs \\<noteq> [];\n        z k \\<noteq> []; k \\<le> Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z (Suc i)).\n                            xs \\<noteq> []", "thus ?case"], ["proof (prove)\nusing this:\n  z k \\<noteq> []\n  k \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<exists>xs\\<in>set (inf_truncate z 0). xs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs\\<in>set (inf_truncate z 0). xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>z k \\<noteq> []; k \\<le> i\\<rbrakk>\n                \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z i).\n                                     xs \\<noteq> [];\n        z k \\<noteq> []; k \\<le> Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z (Suc i)).\n                            xs \\<noteq> []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>z k \\<noteq> []; k \\<le> i\\<rbrakk>\n                \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z i).\n                                     xs \\<noteq> [];\n        z k \\<noteq> []; k \\<le> Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z (Suc i)).\n                            xs \\<noteq> []", "case (Suc i)"], ["proof (state)\nthis:\n  \\<lbrakk>z k \\<noteq> []; k \\<le> i\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z i). xs \\<noteq> []\n  z k \\<noteq> []\n  k \\<le> Suc i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<lbrakk>z k \\<noteq> []; k \\<le> i\\<rbrakk>\n                \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z i).\n                                     xs \\<noteq> [];\n        z k \\<noteq> []; k \\<le> Suc i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z (Suc i)).\n                            xs \\<noteq> []", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>z k \\<noteq> []; k \\<le> i\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z i). xs \\<noteq> []\n  z k \\<noteq> []\n  k \\<le> Suc i\n\ngoal (1 subgoal):\n 1. \\<exists>xs\\<in>set (inf_truncate z (Suc i)). xs \\<noteq> []", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>z k \\<noteq> []; k \\<le> i\\<rbrakk>\n             \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z i).\n                                  xs \\<noteq> [];\n     z k \\<noteq> []; k \\<le> Suc i; ?P3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z (Suc i)).\n                         xs \\<noteq> []\n 2. \\<lbrakk>\\<lbrakk>z k \\<noteq> []; k \\<le> i\\<rbrakk>\n             \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z i).\n                                  xs \\<noteq> [];\n     z k \\<noteq> []; k \\<le> Suc i; \\<not> ?P3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z (Suc i)).\n                         xs \\<noteq> []", "assume \"k \\<le> i\""], ["proof (state)\nthis:\n  k \\<le> i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<lbrakk>z k \\<noteq> []; k \\<le> i\\<rbrakk>\n             \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z i).\n                                  xs \\<noteq> [];\n     z k \\<noteq> []; k \\<le> Suc i; ?P3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z (Suc i)).\n                         xs \\<noteq> []\n 2. \\<lbrakk>\\<lbrakk>z k \\<noteq> []; k \\<le> i\\<rbrakk>\n             \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z i).\n                                  xs \\<noteq> [];\n     z k \\<noteq> []; k \\<le> Suc i; \\<not> ?P3\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z (Suc i)).\n                         xs \\<noteq> []", "from Suc and this"], ["proof (chain)\npicking this:\n  \\<lbrakk>z k \\<noteq> []; k \\<le> i\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z i). xs \\<noteq> []\n  z k \\<noteq> []\n  k \\<le> Suc i\n  k \\<le> i", "show \"\\<exists>xs\\<in>set (inf_truncate z (Suc i)). xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<lbrakk>z k \\<noteq> []; k \\<le> i\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z i). xs \\<noteq> []\n  z k \\<noteq> []\n  k \\<le> Suc i\n  k \\<le> i\n\ngoal (1 subgoal):\n 1. \\<exists>xs\\<in>set (inf_truncate z (Suc i)). xs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs\\<in>set (inf_truncate z (Suc i)). xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>z k \\<noteq> []; k \\<le> i\\<rbrakk>\n             \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z i).\n                                  xs \\<noteq> [];\n     z k \\<noteq> []; k \\<le> Suc i; \\<not> k \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z (Suc i)).\n                         xs \\<noteq> []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>z k \\<noteq> []; k \\<le> i\\<rbrakk>\n             \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z i).\n                                  xs \\<noteq> [];\n     z k \\<noteq> []; k \\<le> Suc i; \\<not> k \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z (Suc i)).\n                         xs \\<noteq> []", "assume \"\\<not> k \\<le> i\""], ["proof (state)\nthis:\n  \\<not> k \\<le> i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>z k \\<noteq> []; k \\<le> i\\<rbrakk>\n             \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z i).\n                                  xs \\<noteq> [];\n     z k \\<noteq> []; k \\<le> Suc i; \\<not> k \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z (Suc i)).\n                         xs \\<noteq> []", "from Suc and this"], ["proof (chain)\npicking this:\n  \\<lbrakk>z k \\<noteq> []; k \\<le> i\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z i). xs \\<noteq> []\n  z k \\<noteq> []\n  k \\<le> Suc i\n  \\<not> k \\<le> i", "have \"k = Suc i\""], ["proof (prove)\nusing this:\n  \\<lbrakk>z k \\<noteq> []; k \\<le> i\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z i). xs \\<noteq> []\n  z k \\<noteq> []\n  k \\<le> Suc i\n  \\<not> k \\<le> i\n\ngoal (1 subgoal):\n 1. k = Suc i", "by arith"], ["proof (state)\nthis:\n  k = Suc i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>z k \\<noteq> []; k \\<le> i\\<rbrakk>\n             \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z i).\n                                  xs \\<noteq> [];\n     z k \\<noteq> []; k \\<le> Suc i; \\<not> k \\<le> i\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z (Suc i)).\n                         xs \\<noteq> []", "from Suc and this"], ["proof (chain)\npicking this:\n  \\<lbrakk>z k \\<noteq> []; k \\<le> i\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z i). xs \\<noteq> []\n  z k \\<noteq> []\n  k \\<le> Suc i\n  k = Suc i", "show \"\\<exists>xs\\<in>set (inf_truncate z (Suc i)). xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<lbrakk>z k \\<noteq> []; k \\<le> i\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs\\<in>set (inf_truncate z i). xs \\<noteq> []\n  z k \\<noteq> []\n  k \\<le> Suc i\n  k = Suc i\n\ngoal (1 subgoal):\n 1. \\<exists>xs\\<in>set (inf_truncate z (Suc i)). xs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs\\<in>set (inf_truncate z (Suc i)). xs \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs\\<in>set (inf_truncate z (Suc i)). xs \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma last_fin_make_untimed_append:\n  \"last (fin_make_untimed (z @ [[a]])) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (fin_make_untimed (z @ [[a]])) = a", "by (simp add: fin_make_untimed_def)"], ["", "lemma last_fin_make_untimed_inf_truncate:\n  assumes \"z i = [a]\"\n  shows    \"last (fin_make_untimed (inf_truncate z i)) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (fin_make_untimed (inf_truncate z i)) = a", "using assms"], ["proof (prove)\nusing this:\n  z i = [a]\n\ngoal (1 subgoal):\n 1. last (fin_make_untimed (inf_truncate z i)) = a", "proof (induction i)"], ["proof (state)\ngoal (2 subgoals):\n 1. z 0 = [a] \\<Longrightarrow>\n    last (fin_make_untimed (inf_truncate z 0)) = a\n 2. \\<And>i.\n       \\<lbrakk>z i = [a] \\<Longrightarrow>\n                last (fin_make_untimed (inf_truncate z i)) = a;\n        z (Suc i) = [a]\\<rbrakk>\n       \\<Longrightarrow> last (fin_make_untimed (inf_truncate z (Suc i))) =\n                         a", "case 0"], ["proof (state)\nthis:\n  z 0 = [a]\n\ngoal (2 subgoals):\n 1. z 0 = [a] \\<Longrightarrow>\n    last (fin_make_untimed (inf_truncate z 0)) = a\n 2. \\<And>i.\n       \\<lbrakk>z i = [a] \\<Longrightarrow>\n                last (fin_make_untimed (inf_truncate z i)) = a;\n        z (Suc i) = [a]\\<rbrakk>\n       \\<Longrightarrow> last (fin_make_untimed (inf_truncate z (Suc i))) =\n                         a", "thus ?case"], ["proof (prove)\nusing this:\n  z 0 = [a]\n\ngoal (1 subgoal):\n 1. last (fin_make_untimed (inf_truncate z 0)) = a", "by (simp add: fin_make_untimed_def)"], ["proof (state)\nthis:\n  last (fin_make_untimed (inf_truncate z 0)) = a\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>z i = [a] \\<Longrightarrow>\n                last (fin_make_untimed (inf_truncate z i)) = a;\n        z (Suc i) = [a]\\<rbrakk>\n       \\<Longrightarrow> last (fin_make_untimed (inf_truncate z (Suc i))) =\n                         a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>z i = [a] \\<Longrightarrow>\n                last (fin_make_untimed (inf_truncate z i)) = a;\n        z (Suc i) = [a]\\<rbrakk>\n       \\<Longrightarrow> last (fin_make_untimed (inf_truncate z (Suc i))) =\n                         a", "case (Suc i)"], ["proof (state)\nthis:\n  z i = [a] \\<Longrightarrow> last (fin_make_untimed (inf_truncate z i)) = a\n  z (Suc i) = [a]\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>z i = [a] \\<Longrightarrow>\n                last (fin_make_untimed (inf_truncate z i)) = a;\n        z (Suc i) = [a]\\<rbrakk>\n       \\<Longrightarrow> last (fin_make_untimed (inf_truncate z (Suc i))) =\n                         a", "thus ?case"], ["proof (prove)\nusing this:\n  z i = [a] \\<Longrightarrow> last (fin_make_untimed (inf_truncate z i)) = a\n  z (Suc i) = [a]\n\ngoal (1 subgoal):\n 1. last (fin_make_untimed (inf_truncate z (Suc i))) = a", "by (simp add: fin_make_untimed_def)"], ["proof (state)\nthis:\n  last (fin_make_untimed (inf_truncate z (Suc i))) = a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fin_make_untimed_append_empty:\n  \"fin_make_untimed (z @ [[]]) = fin_make_untimed z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fin_make_untimed (z @ [[]]) = fin_make_untimed z", "by (simp add: fin_make_untimed_def)"], ["", "lemma fin_make_untimed_inf_truncate_append_a:\n  \"fin_make_untimed (inf_truncate z i @ [[a]]) ! \n  (length (fin_make_untimed (inf_truncate z i @ [[a]])) - Suc 0) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fin_make_untimed (inf_truncate z i @ [[a]]) !\n    (length (fin_make_untimed (inf_truncate z i @ [[a]])) - Suc 0) =\n    a", "by (simp add: fin_make_untimed_def)"], ["", "lemma fin_make_untimed_inf_truncate_Nonempty_all:\n  assumes \"z k \\<noteq> []\" \n  shows    \"\\<forall> i. k \\<le> i \\<longrightarrow> fin_make_untimed (inf_truncate z i) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<ge>k. fin_make_untimed (inf_truncate z i) \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  z k \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<ge>k. fin_make_untimed (inf_truncate z i) \\<noteq> []", "by (simp add:  fin_make_untimed_inf_truncate_Nonempty)"], ["", "lemma fin_make_untimed_inf_truncate_Nonempty_all0:\n  assumes \"z 0 \\<noteq> []\"\n  shows    \"\\<forall> i. fin_make_untimed (inf_truncate z i) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. fin_make_untimed (inf_truncate z i) \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  z 0 \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<forall>i. fin_make_untimed (inf_truncate z i) \\<noteq> []", "by (simp add: fin_make_untimed_inf_truncate_Nonempty)"], ["", "lemma fin_make_untimed_inf_truncate_Nonempty_all0a:\n  assumes \"z 0 = [a]\"\n  shows    \"\\<forall> i. fin_make_untimed (inf_truncate z i) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. fin_make_untimed (inf_truncate z i) \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  z 0 = [a]\n\ngoal (1 subgoal):\n 1. \\<forall>i. fin_make_untimed (inf_truncate z i) \\<noteq> []", "by (simp add: fin_make_untimed_inf_truncate_Nonempty_all0)"], ["", "lemma fin_make_untimed_inf_truncate_Nonempty_all_app:\n  assumes \"z 0 = [a]\" \n  shows    \"\\<forall> i. fin_make_untimed (inf_truncate z i @ [z (Suc i)]) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       fin_make_untimed (inf_truncate z i @ [z (Suc i)]) \\<noteq> []", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. fin_make_untimed (inf_truncate z i @ [z (Suc i)]) \\<noteq> []", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. fin_make_untimed (inf_truncate z i @ [z (Suc i)]) \\<noteq> []", "from assms"], ["proof (chain)\npicking this:\n  z 0 = [a]", "have \"fin_make_untimed (inf_truncate z i) \\<noteq> []\""], ["proof (prove)\nusing this:\n  z 0 = [a]\n\ngoal (1 subgoal):\n 1. fin_make_untimed (inf_truncate z i) \\<noteq> []", "by (simp add: fin_make_untimed_inf_truncate_Nonempty_all0a)"], ["proof (state)\nthis:\n  fin_make_untimed (inf_truncate z i) \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>i. fin_make_untimed (inf_truncate z i @ [z (Suc i)]) \\<noteq> []", "from assms and this"], ["proof (chain)\npicking this:\n  z 0 = [a]\n  fin_make_untimed (inf_truncate z i) \\<noteq> []", "show \n    \"fin_make_untimed (inf_truncate z i @ [z (Suc i)]) \\<noteq> []\""], ["proof (prove)\nusing this:\n  z 0 = [a]\n  fin_make_untimed (inf_truncate z i) \\<noteq> []\n\ngoal (1 subgoal):\n 1. fin_make_untimed (inf_truncate z i @ [z (Suc i)]) \\<noteq> []", "by (simp add: fin_make_untimed_append)"], ["proof (state)\nthis:\n  fin_make_untimed (inf_truncate z i @ [z (Suc i)]) \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fin_make_untimed_nth_length:\n  assumes \"z i = [a]\"\n  shows \n  \"fin_make_untimed (inf_truncate z i) ! \n     (length (fin_make_untimed (inf_truncate z i)) - Suc 0)\n    = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fin_make_untimed (inf_truncate z i) !\n    (length (fin_make_untimed (inf_truncate z i)) - Suc 0) =\n    a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fin_make_untimed (inf_truncate z i) !\n    (length (fin_make_untimed (inf_truncate z i)) - Suc 0) =\n    a", "from assms"], ["proof (chain)\npicking this:\n  z i = [a]", "have sg1:\"last (fin_make_untimed (inf_truncate z i)) = a\""], ["proof (prove)\nusing this:\n  z i = [a]\n\ngoal (1 subgoal):\n 1. last (fin_make_untimed (inf_truncate z i)) = a", "by (simp add: last_fin_make_untimed_inf_truncate)"], ["proof (state)\nthis:\n  last (fin_make_untimed (inf_truncate z i)) = a\n\ngoal (1 subgoal):\n 1. fin_make_untimed (inf_truncate z i) !\n    (length (fin_make_untimed (inf_truncate z i)) - Suc 0) =\n    a", "from assms"], ["proof (chain)\npicking this:\n  z i = [a]", "have sg2:\"concat (inf_truncate z i) \\<noteq> []\""], ["proof (prove)\nusing this:\n  z i = [a]\n\ngoal (1 subgoal):\n 1. concat (inf_truncate z i) \\<noteq> []", "by (rule concat_inf_truncate_nonempty_a)"], ["proof (state)\nthis:\n  concat (inf_truncate z i) \\<noteq> []\n\ngoal (1 subgoal):\n 1. fin_make_untimed (inf_truncate z i) !\n    (length (fin_make_untimed (inf_truncate z i)) - Suc 0) =\n    a", "from assms and sg1 and sg2"], ["proof (chain)\npicking this:\n  z i = [a]\n  last (fin_make_untimed (inf_truncate z i)) = a\n  concat (inf_truncate z i) \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  z i = [a]\n  last (fin_make_untimed (inf_truncate z i)) = a\n  concat (inf_truncate z i) \\<noteq> []\n\ngoal (1 subgoal):\n 1. fin_make_untimed (inf_truncate z i) !\n    (length (fin_make_untimed (inf_truncate z i)) - Suc 0) =\n    a", "by (simp add: fin_make_untimed_def last_nth_length)"], ["proof (state)\nthis:\n  fin_make_untimed (inf_truncate z i) !\n  (length (fin_make_untimed (inf_truncate z i)) - Suc 0) =\n  a\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Lemmas for $inf\\_disj$ and $inf\\_disjS$\\<close>"], ["", "lemma inf_disj_index:\n  assumes h1:\"inf_disj n nS\"\n         and \"nS k t \\<noteq> []\"\n         and \"k < n\"\n  shows  \"(SOME i. i < n \\<and>  nS i t \\<noteq> []) = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME i. i < n \\<and> nS i t \\<noteq> []) = k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (SOME i. i < n \\<and> nS i t \\<noteq> []) = k", "from h1"], ["proof (chain)\npicking this:\n  inf_disj n nS", "have \"\\<forall> j. k < n \\<and> j < n \\<and> k \\<noteq> j \\<and> nS k t \\<noteq> [] \\<longrightarrow> nS j t = []\""], ["proof (prove)\nusing this:\n  inf_disj n nS\n\ngoal (1 subgoal):\n 1. \\<forall>j.\n       k < n \\<and>\n       j < n \\<and> k \\<noteq> j \\<and> nS k t \\<noteq> [] \\<longrightarrow>\n       nS j t = []", "by (simp add: inf_disj_def, auto)"], ["proof (state)\nthis:\n  \\<forall>j.\n     k < n \\<and>\n     j < n \\<and> k \\<noteq> j \\<and> nS k t \\<noteq> [] \\<longrightarrow>\n     nS j t = []\n\ngoal (1 subgoal):\n 1. (SOME i. i < n \\<and> nS i t \\<noteq> []) = k", "from this and assms"], ["proof (chain)\npicking this:\n  \\<forall>j.\n     k < n \\<and>\n     j < n \\<and> k \\<noteq> j \\<and> nS k t \\<noteq> [] \\<longrightarrow>\n     nS j t = []\n  inf_disj n nS\n  nS k t \\<noteq> []\n  k < n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     k < n \\<and>\n     j < n \\<and> k \\<noteq> j \\<and> nS k t \\<noteq> [] \\<longrightarrow>\n     nS j t = []\n  inf_disj n nS\n  nS k t \\<noteq> []\n  k < n\n\ngoal (1 subgoal):\n 1. (SOME i. i < n \\<and> nS i t \\<noteq> []) = k", "by auto"], ["proof (state)\nthis:\n  (SOME i. i < n \\<and> nS i t \\<noteq> []) = k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inf_disjS_index:\n  assumes h1:\"inf_disjS IdSet nS\"\n      and \"k:IdSet\"\n      and \"nS k t \\<noteq> []\"\n  shows \"(SOME i. (i:IdSet) \\<and> nSend i t \\<noteq> []) = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME i. i \\<in> IdSet \\<and> nSend i t \\<noteq> []) = k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (SOME i. i \\<in> IdSet \\<and> nSend i t \\<noteq> []) = k", "from h1"], ["proof (chain)\npicking this:\n  inf_disjS IdSet nS", "have \"\\<forall> j. k \\<in> IdSet \\<and> j \\<in> IdSet \\<and> nS k t \\<noteq> [] \\<longrightarrow> nS j t = []\""], ["proof (prove)\nusing this:\n  inf_disjS IdSet nS\n\ngoal (1 subgoal):\n 1. \\<forall>j.\n       k \\<in> IdSet \\<and>\n       j \\<in> IdSet \\<and> nS k t \\<noteq> [] \\<longrightarrow>\n       nS j t = []", "by (simp add: inf_disjS_def, auto)"], ["proof (state)\nthis:\n  \\<forall>j.\n     k \\<in> IdSet \\<and>\n     j \\<in> IdSet \\<and> nS k t \\<noteq> [] \\<longrightarrow>\n     nS j t = []\n\ngoal (1 subgoal):\n 1. (SOME i. i \\<in> IdSet \\<and> nSend i t \\<noteq> []) = k", "from this and assms"], ["proof (chain)\npicking this:\n  \\<forall>j.\n     k \\<in> IdSet \\<and>\n     j \\<in> IdSet \\<and> nS k t \\<noteq> [] \\<longrightarrow>\n     nS j t = []\n  inf_disjS IdSet nS\n  k \\<in> IdSet\n  nS k t \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     k \\<in> IdSet \\<and>\n     j \\<in> IdSet \\<and> nS k t \\<noteq> [] \\<longrightarrow>\n     nS j t = []\n  inf_disjS IdSet nS\n  k \\<in> IdSet\n  nS k t \\<noteq> []\n\ngoal (1 subgoal):\n 1. (SOME i. i \\<in> IdSet \\<and> nSend i t \\<noteq> []) = k", "by auto"], ["proof (state)\nthis:\n  (SOME i. i \\<in> IdSet \\<and> nSend i t \\<noteq> []) = k\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}