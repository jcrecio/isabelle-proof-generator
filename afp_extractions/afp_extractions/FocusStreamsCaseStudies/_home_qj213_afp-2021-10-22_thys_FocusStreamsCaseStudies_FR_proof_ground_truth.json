{"file_name": "/home/qj213/afp-2021-10-22/thys/FocusStreamsCaseStudies/FR_proof.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/FocusStreamsCaseStudies", "problem_names": ["lemma Send_L1:\nassumes \"Send return send get activation\"\n       and \"send t  \\<noteq> []\"\nshows  \"(activation t) \\<noteq> []\"", "lemma Send_L2:\nassumes \"Send return send get activation\"\n       and \"(activation t)  \\<noteq> []\"\n       and \"return t \\<noteq> []\"\nshows  \"(send t) \\<noteq> []\"", "lemma Scheduler_L1:\nassumes h1:\"Scheduler C activation\"\n        and h2:\"(activation t) \\<noteq> []\"\nshows \"(t mod (cycleLength C)) mem (schedule C)\"", "lemma Scheduler_L2:\nassumes \"Scheduler C activation\"\n       and \"\\<not> (t mod cycleLength C) mem (schedule C)\"\nshows \"activation t = []\"", "lemma Scheduler_L3:\nassumes \"Scheduler C activation\"\n       and \"(t mod cycleLength C) mem (schedule C)\"\nshows \"activation t \\<noteq> []\"", "lemma Scheduler_L4:\nassumes \"Scheduler C activation\"\n       and \"(t mod cycleLength C) mem (schedule C)\"\nshows \"activation t = [t mod cycleLength C]\"", "lemma correct_DisjointSchedules1:\nassumes h1:\"DisjointSchedules n nC\"\n       and h2:\"IdenticCycleLength n nC\"\n       and h3:\"(t mod cycleLength (nC i)) mem schedule (nC i)\" \n       and h4:\"i < n\"\n       and h5:\"j < n\"\n       and h6:\"i \\<noteq> j\"\nshows \"\\<not> (t mod cycleLength (nC j) mem schedule (nC j))\"", "lemma disjointFrame_L1:\nassumes h1:\"DisjointSchedules n nC\"  \n       and h2:\"IdenticCycleLength n nC\"\n       and h3:\"\\<forall> i < n. FlexRayController (nReturn i) rcv \n                      (nC i) (nStore i) (nSend i) (nGet i)\"\n       and h4:\"nSend i t \\<noteq> []\"\n       and h5:\"i < n\"\n       and h6:\"j < n\"\n       and h7:\"i \\<noteq> j\"\nshows \"nSend j t = []\"", "lemma disjointFrame_L2:\nassumes \"DisjointSchedules n nC\"  \n       and \"IdenticCycleLength n nC\"\n       and \"\\<forall> i < n. FlexRayController (nReturn i) rcv \n                      (nC i) (nStore i) (nSend i) (nGet i)\"\nshows \"inf_disj n nSend\"", "lemma disjointFrame_L3:\nassumes h1:\"DisjointSchedules n nC\"  \n     and h2:\"IdenticCycleLength n nC\"\n     and h3:\"\\<forall> i < n. FlexRayController (nReturn i) rcv \n                      (nC i) (nStore i) (nSend i) (nGet i)\"\n    and h4:\"t mod cycleLength (nC i) mem schedule (nC i)\"\n    and h5:\"i < n\"\n    and h6:\"j < n\"\n    and h7:\"i \\<noteq> j\"\nshows \"nSend j t = []\"", "lemma fr_Send1:\nassumes frc:\"FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\"\n        and h1:\"\\<not> (t mod cycleLength (nC i) mem schedule (nC i))\"\n shows      \"(nSend i) t = []\"", "lemma fr_Send2:\n assumes h1:\"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\"\n     and h2:\"DisjointSchedules n nC\"\n     and h3:\"IdenticCycleLength n nC\"\n     and h4:\"t mod cycleLength (nC k) mem schedule (nC k)\"\n     and h5:\"k < n\"\n shows \"nSend k t = nReturn k t\"", "lemma fr_Send3:\n assumes \"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\"\n     and \"DisjointSchedules n nC\"\n     and \"IdenticCycleLength n nC\"\n     and \"t mod cycleLength (nC k) mem schedule (nC k)\"\n     and \"k < n\"\n     and \"nReturn k t \\<noteq> []\"\n shows \"nSend k t \\<noteq> []\"", "lemma fr_Send4:\n assumes \"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\"\n     and \"DisjointSchedules n nC\"\n     and \"IdenticCycleLength n nC\"\n     and \"t mod cycleLength (nC k) mem schedule (nC k)\"\n     and \"k < n\"\n     and \"nReturn k t \\<noteq> []\"\n shows \"\\<exists>k. k < n \\<longrightarrow> nSend k t \\<noteq> []\"", "lemma fr_Send5:\n assumes h1:\"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\"\n     and h2:\"DisjointSchedules n nC\"\n     and h3:\"IdenticCycleLength n nC\"\n     and h4:\"t mod cycleLength (nC k) mem schedule (nC k)\"\n     and h5:\"k < n\"\n     and h6:\"nReturn k t \\<noteq> []\"\n     and h7:\"\\<forall>k<n. nSend k t = []\"\n shows \"False\"", "lemma fr_Send6:\nassumes \"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\"\n       and \"DisjointSchedules n nC\"\n       and \"IdenticCycleLength n nC\"\n       and \"t mod cycleLength (nC k) mem schedule (nC k)\"\n       and \"k < n\"\n       and \"nReturn k t \\<noteq> []\"\nshows \"\\<exists>k<n. nSend k t \\<noteq> []\"", "lemma fr_Send7:\nassumes \"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\"\n       and \"DisjointSchedules n nC\"\n       and \"IdenticCycleLength n nC\"\n       and \"t mod cycleLength (nC k) mem schedule (nC k)\"\n       and \"k < n\"\n       and \"j < n\"\n       and \"nReturn k t = []\"\nshows \"nSend j t = []\"", "lemma fr_Send8:\nassumes \"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\"\n       and \"DisjointSchedules n nC\"\n       and \"IdenticCycleLength n nC\"\n       and \"t mod cycleLength (nC k) mem schedule (nC k)\"\n       and \"k < n\"\n       and \"nReturn k t = []\"\nshows \"\\<not> (\\<exists>k<n. nSend k t \\<noteq> [])\"", "lemma fr_nC_Send:\nassumes \"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\"\n       and \"k < n\"\n       and \"DisjointSchedules n nC\"\n       and \"IdenticCycleLength n nC\"\n       and \"t mod cycleLength (nC k) mem schedule (nC k)\"\nshows \"\\<forall>j. j < n \\<and> j \\<noteq> k \\<longrightarrow> (nSend j) t = []\"", "lemma length_nSend:\nassumes h1:\"BusInterface activation (nReturn i) recv (nStore i) (nSend i) (nGet i)\"\n       and h2:\"\\<forall>t. length (nReturn i t) \\<le> Suc 0\"\nshows   \"length (nSend i t) \\<le> Suc 0\"", "lemma msg_nSend:\nassumes \"BusInterface activation (nReturn i) recv (nStore i) (nSend i) (nGet i)\"\n       and \"msg (Suc 0) (nReturn i)\"\nshows \"msg (Suc 0) (nSend i)\"", "lemma Broadcast_nSend_empty1:\nassumes h1:\"Broadcast n nSend recv\"\n       and h2:\"\\<forall>k<n. nSend k t = []\"\nshows      \"recv t = []\"", "lemma fr_nGet1a:\nassumes h1:\"FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\" \n       and h2:\"t mod cycleLength (nC k) mem schedule (nC k)\"\nshows \"nGet k t = [t mod cycleLength (nC k)]\"", "lemma fr_nGet1:\nassumes \"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\" \n       and \"t mod cycleLength (nC k) mem schedule (nC k)\"\n       and \"k < n\"\nshows \"nGet k t = [t mod cycleLength (nC k)]\"", "lemma fr_nGet2a:\nassumes h1:\"FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\" \n       and h2:\"\\<not> (t mod cycleLength (nC k) mem schedule (nC k))\"\nshows \"nGet k t = []\"", "lemma fr_nGet2:\nassumes h1:\"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\" \n     and h2:\"\\<not> (t mod cycleLength (nC k) mem schedule (nC k))\"\n     and h3:\"k < n\"\n shows \"nGet k t = []\"", "lemma length_nGet1:\n assumes \"FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\"\n shows    \"length (nGet k t) \\<le> Suc 0\"", "lemma msg_nGet1:\n assumes \"FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\"\n shows    \"msg (Suc 0) (nGet k)\"", "lemma msg_nGet2:\nassumes \"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\"\n       and \"k < n\"\nshows \"msg (Suc 0) (nGet k)\"", "lemma fr_nStore_nReturn1:\n assumes h0:\"Broadcast n nSend recv\"\n     and h1:\"inf_disj n nSend\"\n     and h2:\"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\" \n     and h3:\"DisjointSchedules n nC\"\n     and h4:\"IdenticCycleLength n nC\"\n     and h5:\"t mod cycleLength (nC k) mem schedule (nC k)\"\n     and h6:\"k < n\"\n     and h7:\"j < n\"\n     and h8:\"j \\<noteq> k\"\n shows  \"nStore j t = nReturn k t\"", "lemma fr_nStore_nReturn2:\n assumes h1:\"Cable n nSend recv\"\n     and h2:\"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\" \n     and h3:\"DisjointSchedules n nC\"\n     and h4:\"IdenticCycleLength n nC\"\n     and h5:\"t mod cycleLength (nC k) mem schedule (nC k)\"\n     and h6:\"k < n\"\n     and h7:\"j < n\"\n     and h8:\"j \\<noteq> k\"\n shows  \"nStore j t = nReturn k t\"", "lemma fr_nStore_empty1:\n assumes h1:\"Cable n nSend recv\"\n     and h2:\"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\" \n     and h3:\"DisjointSchedules n nC\"\n     and h4:\"IdenticCycleLength n nC\"\n     and h5:\"(t mod cycleLength (nC k) mem schedule (nC k))\"\n     and h6:\"k < n\"\n shows  \"nStore k t = []\"", "lemma fr_nStore_nReturn3:\n assumes \"Cable n nSend recv\"\n     and \"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\" \n     and \"DisjointSchedules n nC\"\n     and \"IdenticCycleLength n nC\"\n     and \"t mod cycleLength (nC k) mem schedule (nC k)\"\n     and \"k < n\"\n shows  \"\\<forall>j. j < n \\<and> j \\<noteq> k \\<longrightarrow> nStore j t = nReturn k t\"", "lemma length_nStore:\n assumes h1:\"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\"\n     and h2:\"DisjointSchedules n nC\"\n     and h3:\"IdenticCycleLength n nC\"\n     and h4:\"inf_disj n nSend\"\n     and h5:\"i < n\"  \n     and h6:\"\\<forall> i<n. msg (Suc 0) (nReturn i)\"\n     and h7:\"Broadcast n nSend recv\"\n shows \"length (nStore i t) \\<le> Suc 0\"", "lemma msg_nStore:\nassumes \" \\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\"\n       and \"DisjointSchedules n nC\"\n       and \"IdenticCycleLength n nC\"\n       and \"inf_disj n nSend\"\n       and \"i < n\"  \n       and \"\\<forall> i<n. msg (Suc 0) (nReturn i)\"\n       and \"Cable n nSend recv\"\nshows \"msg (Suc 0) (nStore i)\"", "lemma fr_refinement_FrameTransmission:\nassumes \"Cable n nSend recv\"\n       and \"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\" \n       and \"DisjointSchedules n nC\"\n       and \"IdenticCycleLength n nC\" \nshows \"FrameTransmission n nStore nReturn nGet nC\"", "lemma FlexRayArch_CorrectSheaf:\n assumes \"FlexRayArch n nReturn nC nStore nGet\"\n shows    \"CorrectSheaf n\"", "lemma FlexRayArch_FrameTransmission:\n assumes h1:\"FlexRayArch n nReturn nC nStore nGet\"\n     and h2:\"\\<forall>i<n. msg (Suc 0) (nReturn i)\"\n     and h3:\"DisjointSchedules n nC\"\n     and h4:\"IdenticCycleLength n nC\"\n shows      \"FrameTransmission n nStore nReturn nGet nC\"", "lemma FlexRayArch_nGet:\n assumes h1:\"FlexRayArch n nReturn nC nStore nGet\"\n     and h2:\"\\<forall>i<n. msg (Suc 0) (nReturn i)\"\n     and h3:\"DisjointSchedules n nC\"\n     and h4:\"IdenticCycleLength n nC\"\n     and h5:\"i < n\"\n shows      \"msg (Suc 0) (nGet i)\"", "lemma FlexRayArch_nStore:\n assumes h1:\"FlexRayArch n nReturn nC nStore nGet\"\n     and h2:\"\\<forall>i<n. msg (Suc 0) (nReturn i)\"\n     and h3:\"DisjointSchedules n nC\"\n     and h4:\"IdenticCycleLength n nC\"\n     and h5:\"i < n\"\n shows      \"msg (Suc 0) (nStore i)\"", "theorem main_fr_refinement:\n assumes \"FlexRayArch n nReturn nC nStore nGet\"\n shows     \"FlexRay n nReturn nC nStore nGet\""], "translations": [["", "lemma Send_L1:\nassumes \"Send return send get activation\"\n       and \"send t  \\<noteq> []\"\nshows  \"(activation t) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. activation t \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  Send return send get activation\n  send t \\<noteq> []\n\ngoal (1 subgoal):\n 1. activation t \\<noteq> []", "by (simp add: Send_def, auto)"], ["", "lemma Send_L2:\nassumes \"Send return send get activation\"\n       and \"(activation t)  \\<noteq> []\"\n       and \"return t \\<noteq> []\"\nshows  \"(send t) \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. send t \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  Send return send get activation\n  activation t \\<noteq> []\n  return t \\<noteq> []\n\ngoal (1 subgoal):\n 1. send t \\<noteq> []", "by (simp add: Send_def)"], ["", "subsection \\<open>Properties of the component Scheduler\\<close>"], ["", "lemma Scheduler_L1:\nassumes h1:\"Scheduler C activation\"\n        and h2:\"(activation t) \\<noteq> []\"\nshows \"(t mod (cycleLength C)) mem (schedule C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t mod cycleLength C mem schedule C", "using assms"], ["proof (prove)\nusing this:\n  Scheduler C activation\n  activation t \\<noteq> []\n\ngoal (1 subgoal):\n 1. t mod cycleLength C mem schedule C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Scheduler C activation; activation t \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> t mod cycleLength C mem schedule C", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Scheduler C activation; activation t \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> t mod cycleLength C mem schedule C", "assume  a1:\"\\<not> t mod cycleLength C mem schedule C\""], ["proof (state)\nthis:\n  \\<not> t mod cycleLength C mem schedule C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Scheduler C activation; activation t \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> t mod cycleLength C mem schedule C", "from h1"], ["proof (chain)\npicking this:\n  Scheduler C activation", "have \n      \"if t mod cycleLength C mem schedule C \n       then activation t = [t mod cycleLength C]\n       else activation t = []\""], ["proof (prove)\nusing this:\n  Scheduler C activation\n\ngoal (1 subgoal):\n 1. if t mod cycleLength C mem schedule C\n    then activation t = [t mod cycleLength C] else activation t = []", "by (simp add: Scheduler_def Let_def)"], ["proof (state)\nthis:\n  if t mod cycleLength C mem schedule C\n  then activation t = [t mod cycleLength C] else activation t = []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Scheduler C activation; activation t \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> t mod cycleLength C mem schedule C", "from a1 and this"], ["proof (chain)\npicking this:\n  \\<not> t mod cycleLength C mem schedule C\n  if t mod cycleLength C mem schedule C\n  then activation t = [t mod cycleLength C] else activation t = []", "have \"activation t = []\""], ["proof (prove)\nusing this:\n  \\<not> t mod cycleLength C mem schedule C\n  if t mod cycleLength C mem schedule C\n  then activation t = [t mod cycleLength C] else activation t = []\n\ngoal (1 subgoal):\n 1. activation t = []", "by simp"], ["proof (state)\nthis:\n  activation t = []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Scheduler C activation; activation t \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> t mod cycleLength C mem schedule C", "from this and h2"], ["proof (chain)\npicking this:\n  activation t = []\n  activation t \\<noteq> []", "have sg3:\"False\""], ["proof (prove)\nusing this:\n  activation t = []\n  activation t \\<noteq> []\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Scheduler C activation; activation t \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> t mod cycleLength C mem schedule C", "}"], ["proof (state)\nthis:\n  \\<not> t mod cycleLength C mem schedule C \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Scheduler C activation; activation t \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> t mod cycleLength C mem schedule C", "from this"], ["proof (chain)\npicking this:\n  \\<not> t mod cycleLength C mem schedule C \\<Longrightarrow> False", "have  sg4:\"(t mod (cycleLength C)) mem (schedule C)\""], ["proof (prove)\nusing this:\n  \\<not> t mod cycleLength C mem schedule C \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. t mod cycleLength C mem schedule C", "by blast"], ["proof (state)\nthis:\n  t mod cycleLength C mem schedule C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Scheduler C activation; activation t \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> t mod cycleLength C mem schedule C", "from this"], ["proof (chain)\npicking this:\n  t mod cycleLength C mem schedule C", "show ?thesis"], ["proof (prove)\nusing this:\n  t mod cycleLength C mem schedule C\n\ngoal (1 subgoal):\n 1. t mod cycleLength C mem schedule C", "by simp"], ["proof (state)\nthis:\n  t mod cycleLength C mem schedule C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Scheduler_L2:\nassumes \"Scheduler C activation\"\n       and \"\\<not> (t mod cycleLength C) mem (schedule C)\"\nshows \"activation t = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. activation t = []", "using assms"], ["proof (prove)\nusing this:\n  Scheduler C activation\n  \\<not> t mod cycleLength C mem schedule C\n\ngoal (1 subgoal):\n 1. activation t = []", "by (simp add: Scheduler_def Let_def)"], ["", "lemma Scheduler_L3:\nassumes \"Scheduler C activation\"\n       and \"(t mod cycleLength C) mem (schedule C)\"\nshows \"activation t \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. activation t \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  Scheduler C activation\n  t mod cycleLength C mem schedule C\n\ngoal (1 subgoal):\n 1. activation t \\<noteq> []", "by (simp add: Scheduler_def Let_def)"], ["", "lemma Scheduler_L4:\nassumes \"Scheduler C activation\"\n       and \"(t mod cycleLength C) mem (schedule C)\"\nshows \"activation t = [t mod cycleLength C]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. activation t = [t mod cycleLength C]", "using assms"], ["proof (prove)\nusing this:\n  Scheduler C activation\n  t mod cycleLength C mem schedule C\n\ngoal (1 subgoal):\n 1. activation t = [t mod cycleLength C]", "by (simp add: Scheduler_def Let_def)"], ["", "lemma correct_DisjointSchedules1:\nassumes h1:\"DisjointSchedules n nC\"\n       and h2:\"IdenticCycleLength n nC\"\n       and h3:\"(t mod cycleLength (nC i)) mem schedule (nC i)\" \n       and h4:\"i < n\"\n       and h5:\"j < n\"\n       and h6:\"i \\<noteq> j\"\nshows \"\\<not> (t mod cycleLength (nC j) mem schedule (nC j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> t mod cycleLength (nC j) mem schedule (nC j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> t mod cycleLength (nC j) mem schedule (nC j)", "from h1 and h4 and h5 and h6"], ["proof (chain)\npicking this:\n  DisjointSchedules n nC\n  i < n\n  j < n\n  i \\<noteq> j", "have sg1:\"disjoint (schedule (nC i)) (schedule (nC j))\""], ["proof (prove)\nusing this:\n  DisjointSchedules n nC\n  i < n\n  j < n\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. disjoint (schedule (nC i)) (schedule (nC j))", "by (simp add: DisjointSchedules_def)"], ["proof (state)\nthis:\n  disjoint (schedule (nC i)) (schedule (nC j))\n\ngoal (1 subgoal):\n 1. \\<not> t mod cycleLength (nC j) mem schedule (nC j)", "from h2 and h4 and h5"], ["proof (chain)\npicking this:\n  IdenticCycleLength n nC\n  i < n\n  j < n", "have sg2:\"cycleLength (nC i) = cycleLength (nC j)\""], ["proof (prove)\nusing this:\n  IdenticCycleLength n nC\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. cycleLength (nC i) = cycleLength (nC j)", "by (metis IdenticCycleLength_def)"], ["proof (state)\nthis:\n  cycleLength (nC i) = cycleLength (nC j)\n\ngoal (1 subgoal):\n 1. \\<not> t mod cycleLength (nC j) mem schedule (nC j)", "from sg1 and h3"], ["proof (chain)\npicking this:\n  disjoint (schedule (nC i)) (schedule (nC j))\n  t mod cycleLength (nC i) mem schedule (nC i)", "have sg3:\"\\<not> (t mod (cycleLength (nC i))) mem (schedule (nC j))\""], ["proof (prove)\nusing this:\n  disjoint (schedule (nC i)) (schedule (nC j))\n  t mod cycleLength (nC i) mem schedule (nC i)\n\ngoal (1 subgoal):\n 1. \\<not> t mod cycleLength (nC i) mem schedule (nC j)", "by (simp add: mem_notdisjoint2)"], ["proof (state)\nthis:\n  \\<not> t mod cycleLength (nC i) mem schedule (nC j)\n\ngoal (1 subgoal):\n 1. \\<not> t mod cycleLength (nC j) mem schedule (nC j)", "from sg2 and sg3"], ["proof (chain)\npicking this:\n  cycleLength (nC i) = cycleLength (nC j)\n  \\<not> t mod cycleLength (nC i) mem schedule (nC j)", "show ?thesis"], ["proof (prove)\nusing this:\n  cycleLength (nC i) = cycleLength (nC j)\n  \\<not> t mod cycleLength (nC i) mem schedule (nC j)\n\ngoal (1 subgoal):\n 1. \\<not> t mod cycleLength (nC j) mem schedule (nC j)", "by simp"], ["proof (state)\nthis:\n  \\<not> t mod cycleLength (nC j) mem schedule (nC j)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Disjoint Frames\\<close>"], ["", "lemma disjointFrame_L1:\nassumes h1:\"DisjointSchedules n nC\"  \n       and h2:\"IdenticCycleLength n nC\"\n       and h3:\"\\<forall> i < n. FlexRayController (nReturn i) rcv \n                      (nC i) (nStore i) (nSend i) (nGet i)\"\n       and h4:\"nSend i t \\<noteq> []\"\n       and h5:\"i < n\"\n       and h6:\"j < n\"\n       and h7:\"i \\<noteq> j\"\nshows \"nSend j t = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nSend j t = []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nSend j t = []", "from h3 and h5"], ["proof (chain)\npicking this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) rcv (nC i) (nStore i) (nSend i) (nGet i)\n  i < n", "have sg1:\n   \"FlexRayController (nReturn i) rcv (nC i) (nStore i) (nSend i) (nGet i)\""], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) rcv (nC i) (nStore i) (nSend i) (nGet i)\n  i < n\n\ngoal (1 subgoal):\n 1. FlexRayController (nReturn i) rcv (nC i) (nStore i) (nSend i) (nGet i)", "by auto"], ["proof (state)\nthis:\n  FlexRayController (nReturn i) rcv (nC i) (nStore i) (nSend i) (nGet i)\n\ngoal (1 subgoal):\n 1. nSend j t = []", "from h3 and h6"], ["proof (chain)\npicking this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) rcv (nC i) (nStore i) (nSend i) (nGet i)\n  j < n", "have sg2:\n   \"FlexRayController (nReturn j) rcv (nC j) (nStore j) (nSend j) (nGet j)\""], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) rcv (nC i) (nStore i) (nSend i) (nGet i)\n  j < n\n\ngoal (1 subgoal):\n 1. FlexRayController (nReturn j) rcv (nC j) (nStore j) (nSend j) (nGet j)", "by auto"], ["proof (state)\nthis:\n  FlexRayController (nReturn j) rcv (nC j) (nStore j) (nSend j) (nGet j)\n\ngoal (1 subgoal):\n 1. nSend j t = []", "from sg1"], ["proof (chain)\npicking this:\n  FlexRayController (nReturn i) rcv (nC i) (nStore i) (nSend i) (nGet i)", "obtain activation1 where\n     a1:\"Scheduler (nC i) activation1\" and \n     a2:\"BusInterface activation1 (nReturn i) rcv (nStore i) (nSend i) (nGet i)\""], ["proof (prove)\nusing this:\n  FlexRayController (nReturn i) rcv (nC i) (nStore i) (nSend i) (nGet i)\n\ngoal (1 subgoal):\n 1. (\\<And>activation1.\n        \\<lbrakk>Scheduler (nC i) activation1;\n         BusInterface activation1 (nReturn i) rcv (nStore i) (nSend i)\n          (nGet i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: FlexRayController_def, auto)"], ["proof (state)\nthis:\n  Scheduler (nC i) activation1\n  BusInterface activation1 (nReturn i) rcv (nStore i) (nSend i) (nGet i)\n\ngoal (1 subgoal):\n 1. nSend j t = []", "from sg2"], ["proof (chain)\npicking this:\n  FlexRayController (nReturn j) rcv (nC j) (nStore j) (nSend j) (nGet j)", "obtain activation2 where\n     a3:\"Scheduler (nC j) activation2\" and \n     a4:\"BusInterface activation2 (nReturn j) rcv (nStore j) (nSend j) (nGet j)\""], ["proof (prove)\nusing this:\n  FlexRayController (nReturn j) rcv (nC j) (nStore j) (nSend j) (nGet j)\n\ngoal (1 subgoal):\n 1. (\\<And>activation2.\n        \\<lbrakk>Scheduler (nC j) activation2;\n         BusInterface activation2 (nReturn j) rcv (nStore j) (nSend j)\n          (nGet j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: FlexRayController_def, auto)"], ["proof (state)\nthis:\n  Scheduler (nC j) activation2\n  BusInterface activation2 (nReturn j) rcv (nStore j) (nSend j) (nGet j)\n\ngoal (1 subgoal):\n 1. nSend j t = []", "from h1 and h5 and h6 and h7"], ["proof (chain)\npicking this:\n  DisjointSchedules n nC\n  i < n\n  j < n\n  i \\<noteq> j", "have sg3:\"disjoint (schedule (nC i)) (schedule (nC j))\""], ["proof (prove)\nusing this:\n  DisjointSchedules n nC\n  i < n\n  j < n\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. disjoint (schedule (nC i)) (schedule (nC j))", "by (simp add: DisjointSchedules_def)"], ["proof (state)\nthis:\n  disjoint (schedule (nC i)) (schedule (nC j))\n\ngoal (1 subgoal):\n 1. nSend j t = []", "from a2"], ["proof (chain)\npicking this:\n  BusInterface activation1 (nReturn i) rcv (nStore i) (nSend i) (nGet i)", "have  sg4a:\"Send (nReturn i) (nSend i) (nGet i) activation1\""], ["proof (prove)\nusing this:\n  BusInterface activation1 (nReturn i) rcv (nStore i) (nSend i) (nGet i)\n\ngoal (1 subgoal):\n 1. Send (nReturn i) (nSend i) (nGet i) activation1", "by (simp add:  BusInterface_def)"], ["proof (state)\nthis:\n  Send (nReturn i) (nSend i) (nGet i) activation1\n\ngoal (1 subgoal):\n 1. nSend j t = []", "from sg4a and h4"], ["proof (chain)\npicking this:\n  Send (nReturn i) (nSend i) (nGet i) activation1\n  nSend i t \\<noteq> []", "have sg5:\"activation1 t  \\<noteq> []\""], ["proof (prove)\nusing this:\n  Send (nReturn i) (nSend i) (nGet i) activation1\n  nSend i t \\<noteq> []\n\ngoal (1 subgoal):\n 1. activation1 t \\<noteq> []", "by (simp add: Send_L1)"], ["proof (state)\nthis:\n  activation1 t \\<noteq> []\n\ngoal (1 subgoal):\n 1. nSend j t = []", "from a1 and sg5"], ["proof (chain)\npicking this:\n  Scheduler (nC i) activation1\n  activation1 t \\<noteq> []", "have sg6:\"(t mod (cycleLength (nC i))) mem (schedule (nC i))\""], ["proof (prove)\nusing this:\n  Scheduler (nC i) activation1\n  activation1 t \\<noteq> []\n\ngoal (1 subgoal):\n 1. t mod cycleLength (nC i) mem schedule (nC i)", "by (simp add: Scheduler_L1)"], ["proof (state)\nthis:\n  t mod cycleLength (nC i) mem schedule (nC i)\n\ngoal (1 subgoal):\n 1. nSend j t = []", "from h2 and h5 and h6"], ["proof (chain)\npicking this:\n  IdenticCycleLength n nC\n  i < n\n  j < n", "have sg7:\"cycleLength (nC i) = cycleLength (nC j)\""], ["proof (prove)\nusing this:\n  IdenticCycleLength n nC\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. cycleLength (nC i) = cycleLength (nC j)", "by (metis IdenticCycleLength_def)"], ["proof (state)\nthis:\n  cycleLength (nC i) = cycleLength (nC j)\n\ngoal (1 subgoal):\n 1. nSend j t = []", "from sg3 and sg6"], ["proof (chain)\npicking this:\n  disjoint (schedule (nC i)) (schedule (nC j))\n  t mod cycleLength (nC i) mem schedule (nC i)", "have sg8:\"\\<not> (t mod (cycleLength (nC i))) mem (schedule (nC j))\""], ["proof (prove)\nusing this:\n  disjoint (schedule (nC i)) (schedule (nC j))\n  t mod cycleLength (nC i) mem schedule (nC i)\n\ngoal (1 subgoal):\n 1. \\<not> t mod cycleLength (nC i) mem schedule (nC j)", "by (simp add: mem_notdisjoint2)"], ["proof (state)\nthis:\n  \\<not> t mod cycleLength (nC i) mem schedule (nC j)\n\ngoal (1 subgoal):\n 1. nSend j t = []", "from sg8 and sg7"], ["proof (chain)\npicking this:\n  \\<not> t mod cycleLength (nC i) mem schedule (nC j)\n  cycleLength (nC i) = cycleLength (nC j)", "have sg9:\"\\<not> (t mod (cycleLength (nC j))) mem (schedule (nC j))\""], ["proof (prove)\nusing this:\n  \\<not> t mod cycleLength (nC i) mem schedule (nC j)\n  cycleLength (nC i) = cycleLength (nC j)\n\ngoal (1 subgoal):\n 1. \\<not> t mod cycleLength (nC j) mem schedule (nC j)", "by simp"], ["proof (state)\nthis:\n  \\<not> t mod cycleLength (nC j) mem schedule (nC j)\n\ngoal (1 subgoal):\n 1. nSend j t = []", "from sg9 and a3"], ["proof (chain)\npicking this:\n  \\<not> t mod cycleLength (nC j) mem schedule (nC j)\n  Scheduler (nC j) activation2", "have sg10:\"activation2 t = []\""], ["proof (prove)\nusing this:\n  \\<not> t mod cycleLength (nC j) mem schedule (nC j)\n  Scheduler (nC j) activation2\n\ngoal (1 subgoal):\n 1. activation2 t = []", "by (simp add: Scheduler_L2)"], ["proof (state)\nthis:\n  activation2 t = []\n\ngoal (1 subgoal):\n 1. nSend j t = []", "from a4"], ["proof (chain)\npicking this:\n  BusInterface activation2 (nReturn j) rcv (nStore j) (nSend j) (nGet j)", "have sg11:\"Send (nReturn j) (nSend j) (nGet j) activation2\""], ["proof (prove)\nusing this:\n  BusInterface activation2 (nReturn j) rcv (nStore j) (nSend j) (nGet j)\n\ngoal (1 subgoal):\n 1. Send (nReturn j) (nSend j) (nGet j) activation2", "by (simp add:  BusInterface_def)"], ["proof (state)\nthis:\n  Send (nReturn j) (nSend j) (nGet j) activation2\n\ngoal (1 subgoal):\n 1. nSend j t = []", "from sg11 and sg10"], ["proof (chain)\npicking this:\n  Send (nReturn j) (nSend j) (nGet j) activation2\n  activation2 t = []", "show ?thesis"], ["proof (prove)\nusing this:\n  Send (nReturn j) (nSend j) (nGet j) activation2\n  activation2 t = []\n\ngoal (1 subgoal):\n 1. nSend j t = []", "by (simp add: Send_def)"], ["proof (state)\nthis:\n  nSend j t = []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma disjointFrame_L2:\nassumes \"DisjointSchedules n nC\"  \n       and \"IdenticCycleLength n nC\"\n       and \"\\<forall> i < n. FlexRayController (nReturn i) rcv \n                      (nC i) (nStore i) (nSend i) (nGet i)\"\nshows \"inf_disj n nSend\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_disj n nSend", "using assms"], ["proof (prove)\nusing this:\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  \\<forall>i<n.\n     FlexRayController (nReturn i) rcv (nC i) (nStore i) (nSend i) (nGet i)\n\ngoal (1 subgoal):\n 1. inf_disj n nSend", "apply (simp add: inf_disj_def, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t i j.\n       \\<lbrakk>DisjointSchedules n nC; IdenticCycleLength n nC;\n        \\<forall>i<n.\n           FlexRayController (nReturn i) rcv (nC i) (nStore i) (nSend i)\n            (nGet i);\n        DisjointSchedules n nC; IdenticCycleLength n nC;\n        \\<forall>i<n.\n           FlexRayController (nReturn i) rcv (nC i) (nStore i) (nSend i)\n            (nGet i);\n        i < n; j < n; i \\<noteq> j; nSend i t \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> nSend j t = []", "by (rule disjointFrame_L1, auto)"], ["", "lemma disjointFrame_L3:\nassumes h1:\"DisjointSchedules n nC\"  \n     and h2:\"IdenticCycleLength n nC\"\n     and h3:\"\\<forall> i < n. FlexRayController (nReturn i) rcv \n                      (nC i) (nStore i) (nSend i) (nGet i)\"\n    and h4:\"t mod cycleLength (nC i) mem schedule (nC i)\"\n    and h5:\"i < n\"\n    and h6:\"j < n\"\n    and h7:\"i \\<noteq> j\"\nshows \"nSend j t = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nSend j t = []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nSend j t = []", "from h2 and h5 and h6"], ["proof (chain)\npicking this:\n  IdenticCycleLength n nC\n  i < n\n  j < n", "have sg1:\"cycleLength (nC i) = cycleLength (nC j)\""], ["proof (prove)\nusing this:\n  IdenticCycleLength n nC\n  i < n\n  j < n\n\ngoal (1 subgoal):\n 1. cycleLength (nC i) = cycleLength (nC j)", "by (metis IdenticCycleLength_def)"], ["proof (state)\nthis:\n  cycleLength (nC i) = cycleLength (nC j)\n\ngoal (1 subgoal):\n 1. nSend j t = []", "from h1 and h5 and h6 and h7"], ["proof (chain)\npicking this:\n  DisjointSchedules n nC\n  i < n\n  j < n\n  i \\<noteq> j", "have sg2:\"disjoint (schedule (nC i)) (schedule (nC j))\""], ["proof (prove)\nusing this:\n  DisjointSchedules n nC\n  i < n\n  j < n\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. disjoint (schedule (nC i)) (schedule (nC j))", "by (simp add: DisjointSchedules_def)"], ["proof (state)\nthis:\n  disjoint (schedule (nC i)) (schedule (nC j))\n\ngoal (1 subgoal):\n 1. nSend j t = []", "from sg2 and h4"], ["proof (chain)\npicking this:\n  disjoint (schedule (nC i)) (schedule (nC j))\n  t mod cycleLength (nC i) mem schedule (nC i)", "have sg3:\"\\<not> (t mod (cycleLength (nC i))) mem (schedule (nC j))\""], ["proof (prove)\nusing this:\n  disjoint (schedule (nC i)) (schedule (nC j))\n  t mod cycleLength (nC i) mem schedule (nC i)\n\ngoal (1 subgoal):\n 1. \\<not> t mod cycleLength (nC i) mem schedule (nC j)", "by (simp add: mem_notdisjoint2)"], ["proof (state)\nthis:\n  \\<not> t mod cycleLength (nC i) mem schedule (nC j)\n\ngoal (1 subgoal):\n 1. nSend j t = []", "from sg1 and sg3"], ["proof (chain)\npicking this:\n  cycleLength (nC i) = cycleLength (nC j)\n  \\<not> t mod cycleLength (nC i) mem schedule (nC j)", "have sg4:\"\\<not> (t mod (cycleLength (nC j))) mem (schedule (nC j))\""], ["proof (prove)\nusing this:\n  cycleLength (nC i) = cycleLength (nC j)\n  \\<not> t mod cycleLength (nC i) mem schedule (nC j)\n\ngoal (1 subgoal):\n 1. \\<not> t mod cycleLength (nC j) mem schedule (nC j)", "by simp"], ["proof (state)\nthis:\n  \\<not> t mod cycleLength (nC j) mem schedule (nC j)\n\ngoal (1 subgoal):\n 1. nSend j t = []", "from h3 and h6"], ["proof (chain)\npicking this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) rcv (nC i) (nStore i) (nSend i) (nGet i)\n  j < n", "have sg5:\n   \"FlexRayController (nReturn j) rcv (nC j) (nStore j) (nSend j) (nGet j)\""], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) rcv (nC i) (nStore i) (nSend i) (nGet i)\n  j < n\n\ngoal (1 subgoal):\n 1. FlexRayController (nReturn j) rcv (nC j) (nStore j) (nSend j) (nGet j)", "by auto"], ["proof (state)\nthis:\n  FlexRayController (nReturn j) rcv (nC j) (nStore j) (nSend j) (nGet j)\n\ngoal (1 subgoal):\n 1. nSend j t = []", "from sg5"], ["proof (chain)\npicking this:\n  FlexRayController (nReturn j) rcv (nC j) (nStore j) (nSend j) (nGet j)", "obtain activation2 where\n     a1:\"Scheduler (nC j) activation2\" and \n     a2:\"BusInterface activation2 (nReturn j) rcv (nStore j) (nSend j) (nGet j)\""], ["proof (prove)\nusing this:\n  FlexRayController (nReturn j) rcv (nC j) (nStore j) (nSend j) (nGet j)\n\ngoal (1 subgoal):\n 1. (\\<And>activation2.\n        \\<lbrakk>Scheduler (nC j) activation2;\n         BusInterface activation2 (nReturn j) rcv (nStore j) (nSend j)\n          (nGet j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: FlexRayController_def, auto)"], ["proof (state)\nthis:\n  Scheduler (nC j) activation2\n  BusInterface activation2 (nReturn j) rcv (nStore j) (nSend j) (nGet j)\n\ngoal (1 subgoal):\n 1. nSend j t = []", "from sg4 and a1"], ["proof (chain)\npicking this:\n  \\<not> t mod cycleLength (nC j) mem schedule (nC j)\n  Scheduler (nC j) activation2", "have sg6:\"activation2 t = []\""], ["proof (prove)\nusing this:\n  \\<not> t mod cycleLength (nC j) mem schedule (nC j)\n  Scheduler (nC j) activation2\n\ngoal (1 subgoal):\n 1. activation2 t = []", "by (simp add: Scheduler_L2)"], ["proof (state)\nthis:\n  activation2 t = []\n\ngoal (1 subgoal):\n 1. nSend j t = []", "from a2"], ["proof (chain)\npicking this:\n  BusInterface activation2 (nReturn j) rcv (nStore j) (nSend j) (nGet j)", "have sg7:\"Send (nReturn j) (nSend j) (nGet j) activation2\""], ["proof (prove)\nusing this:\n  BusInterface activation2 (nReturn j) rcv (nStore j) (nSend j) (nGet j)\n\ngoal (1 subgoal):\n 1. Send (nReturn j) (nSend j) (nGet j) activation2", "by (simp add:  BusInterface_def)"], ["proof (state)\nthis:\n  Send (nReturn j) (nSend j) (nGet j) activation2\n\ngoal (1 subgoal):\n 1. nSend j t = []", "from sg7 and sg6"], ["proof (chain)\npicking this:\n  Send (nReturn j) (nSend j) (nGet j) activation2\n  activation2 t = []", "show ?thesis"], ["proof (prove)\nusing this:\n  Send (nReturn j) (nSend j) (nGet j) activation2\n  activation2 t = []\n\ngoal (1 subgoal):\n 1. nSend j t = []", "by (simp add: Send_def)"], ["proof (state)\nthis:\n  nSend j t = []\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Properties of the sheaf of channels nSend\\<close>"], ["", "lemma fr_Send1:\nassumes frc:\"FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\"\n        and h1:\"\\<not> (t mod cycleLength (nC i) mem schedule (nC i))\"\n shows      \"(nSend i) t = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nSend i t = []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nSend i t = []", "from frc"], ["proof (chain)\npicking this:\n  FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)", "obtain activation where \n    a1:\"Scheduler (nC i) activation\"  and\n    a2:\"BusInterface activation (nReturn i) recv (nStore i) (nSend i) (nGet i)\""], ["proof (prove)\nusing this:\n  FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n\ngoal (1 subgoal):\n 1. (\\<And>activation.\n        \\<lbrakk>Scheduler (nC i) activation;\n         BusInterface activation (nReturn i) recv (nStore i) (nSend i)\n          (nGet i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: FlexRayController_def, auto)"], ["proof (state)\nthis:\n  Scheduler (nC i) activation\n  BusInterface activation (nReturn i) recv (nStore i) (nSend i) (nGet i)\n\ngoal (1 subgoal):\n 1. nSend i t = []", "from a1 and h1"], ["proof (chain)\npicking this:\n  Scheduler (nC i) activation\n  \\<not> t mod cycleLength (nC i) mem schedule (nC i)", "have sg1:\"activation t = []\""], ["proof (prove)\nusing this:\n  Scheduler (nC i) activation\n  \\<not> t mod cycleLength (nC i) mem schedule (nC i)\n\ngoal (1 subgoal):\n 1. activation t = []", "by (simp add: Scheduler_L2)"], ["proof (state)\nthis:\n  activation t = []\n\ngoal (1 subgoal):\n 1. nSend i t = []", "from a2"], ["proof (chain)\npicking this:\n  BusInterface activation (nReturn i) recv (nStore i) (nSend i) (nGet i)", "have sg2:\"Send (nReturn i) (nSend i) (nGet i) activation\""], ["proof (prove)\nusing this:\n  BusInterface activation (nReturn i) recv (nStore i) (nSend i) (nGet i)\n\ngoal (1 subgoal):\n 1. Send (nReturn i) (nSend i) (nGet i) activation", "by (simp add: BusInterface_def)"], ["proof (state)\nthis:\n  Send (nReturn i) (nSend i) (nGet i) activation\n\ngoal (1 subgoal):\n 1. nSend i t = []", "from sg2 and sg1"], ["proof (chain)\npicking this:\n  Send (nReturn i) (nSend i) (nGet i) activation\n  activation t = []", "show ?thesis"], ["proof (prove)\nusing this:\n  Send (nReturn i) (nSend i) (nGet i) activation\n  activation t = []\n\ngoal (1 subgoal):\n 1. nSend i t = []", "by (simp add: Send_def)"], ["proof (state)\nthis:\n  nSend i t = []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fr_Send2:\n assumes h1:\"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\"\n     and h2:\"DisjointSchedules n nC\"\n     and h3:\"IdenticCycleLength n nC\"\n     and h4:\"t mod cycleLength (nC k) mem schedule (nC k)\"\n     and h5:\"k < n\"\n shows \"nSend k t = nReturn k t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nSend k t = nReturn k t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nSend k t = nReturn k t", "from h1 and h5"], ["proof (chain)\npicking this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  k < n", "have sg1:\n   \"FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\""], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  k < n\n\ngoal (1 subgoal):\n 1. FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)", "by auto"], ["proof (state)\nthis:\n  FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\n\ngoal (1 subgoal):\n 1. nSend k t = nReturn k t", "from sg1"], ["proof (chain)\npicking this:\n  FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)", "obtain activation where\n     a1:\"Scheduler (nC k) activation\" and \n     a2:\"BusInterface activation (nReturn k) recv (nStore k) (nSend k) (nGet k)\""], ["proof (prove)\nusing this:\n  FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\n\ngoal (1 subgoal):\n 1. (\\<And>activation.\n        \\<lbrakk>Scheduler (nC k) activation;\n         BusInterface activation (nReturn k) recv (nStore k) (nSend k)\n          (nGet k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: FlexRayController_def, auto)"], ["proof (state)\nthis:\n  Scheduler (nC k) activation\n  BusInterface activation (nReturn k) recv (nStore k) (nSend k) (nGet k)\n\ngoal (1 subgoal):\n 1. nSend k t = nReturn k t", "from a1 and h4"], ["proof (chain)\npicking this:\n  Scheduler (nC k) activation\n  t mod cycleLength (nC k) mem schedule (nC k)", "have sg3:\"activation t \\<noteq> []\""], ["proof (prove)\nusing this:\n  Scheduler (nC k) activation\n  t mod cycleLength (nC k) mem schedule (nC k)\n\ngoal (1 subgoal):\n 1. activation t \\<noteq> []", "by (simp add: Scheduler_L3)"], ["proof (state)\nthis:\n  activation t \\<noteq> []\n\ngoal (1 subgoal):\n 1. nSend k t = nReturn k t", "from a2"], ["proof (chain)\npicking this:\n  BusInterface activation (nReturn k) recv (nStore k) (nSend k) (nGet k)", "have  sg4:\"Send (nReturn k) (nSend k) (nGet k) activation\""], ["proof (prove)\nusing this:\n  BusInterface activation (nReturn k) recv (nStore k) (nSend k) (nGet k)\n\ngoal (1 subgoal):\n 1. Send (nReturn k) (nSend k) (nGet k) activation", "by (simp add:  BusInterface_def)"], ["proof (state)\nthis:\n  Send (nReturn k) (nSend k) (nGet k) activation\n\ngoal (1 subgoal):\n 1. nSend k t = nReturn k t", "from sg4 and sg3"], ["proof (chain)\npicking this:\n  Send (nReturn k) (nSend k) (nGet k) activation\n  activation t \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  Send (nReturn k) (nSend k) (nGet k) activation\n  activation t \\<noteq> []\n\ngoal (1 subgoal):\n 1. nSend k t = nReturn k t", "by (simp add: Send_def)"], ["proof (state)\nthis:\n  nSend k t = nReturn k t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fr_Send3:\n assumes \"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\"\n     and \"DisjointSchedules n nC\"\n     and \"IdenticCycleLength n nC\"\n     and \"t mod cycleLength (nC k) mem schedule (nC k)\"\n     and \"k < n\"\n     and \"nReturn k t \\<noteq> []\"\n shows \"nSend k t \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nSend k t \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  t mod cycleLength (nC k) mem schedule (nC k)\n  k < n\n  nReturn k t \\<noteq> []\n\ngoal (1 subgoal):\n 1. nSend k t \\<noteq> []", "by (simp add: fr_Send2)"], ["", "lemma fr_Send4:\n assumes \"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\"\n     and \"DisjointSchedules n nC\"\n     and \"IdenticCycleLength n nC\"\n     and \"t mod cycleLength (nC k) mem schedule (nC k)\"\n     and \"k < n\"\n     and \"nReturn k t \\<noteq> []\"\n shows \"\\<exists>k. k < n \\<longrightarrow> nSend k t \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. k < n \\<longrightarrow> nSend k t \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  t mod cycleLength (nC k) mem schedule (nC k)\n  k < n\n  nReturn k t \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>k. k < n \\<longrightarrow> nSend k t \\<noteq> []", "by (metis  fr_Send3)"], ["", "lemma fr_Send5:\n assumes h1:\"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\"\n     and h2:\"DisjointSchedules n nC\"\n     and h3:\"IdenticCycleLength n nC\"\n     and h4:\"t mod cycleLength (nC k) mem schedule (nC k)\"\n     and h5:\"k < n\"\n     and h6:\"nReturn k t \\<noteq> []\"\n     and h7:\"\\<forall>k<n. nSend k t = []\"\n shows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from h1 and h2 and h3 and h4 and h5 and h6"], ["proof (chain)\npicking this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  t mod cycleLength (nC k) mem schedule (nC k)\n  k < n\n  nReturn k t \\<noteq> []", "have sg1:\"nSend k t \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  t mod cycleLength (nC k) mem schedule (nC k)\n  k < n\n  nReturn k t \\<noteq> []\n\ngoal (1 subgoal):\n 1. nSend k t \\<noteq> []", "by (simp add: fr_Send2)"], ["proof (state)\nthis:\n  nSend k t \\<noteq> []\n\ngoal (1 subgoal):\n 1. False", "from h7 and h5"], ["proof (chain)\npicking this:\n  \\<forall>k<n. nSend k t = []\n  k < n", "have sg2:\"nSend k t = []\""], ["proof (prove)\nusing this:\n  \\<forall>k<n. nSend k t = []\n  k < n\n\ngoal (1 subgoal):\n 1. nSend k t = []", "by blast"], ["proof (state)\nthis:\n  nSend k t = []\n\ngoal (1 subgoal):\n 1. False", "from sg1 and sg2"], ["proof (chain)\npicking this:\n  nSend k t \\<noteq> []\n  nSend k t = []", "show ?thesis"], ["proof (prove)\nusing this:\n  nSend k t \\<noteq> []\n  nSend k t = []\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fr_Send6:\nassumes \"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\"\n       and \"DisjointSchedules n nC\"\n       and \"IdenticCycleLength n nC\"\n       and \"t mod cycleLength (nC k) mem schedule (nC k)\"\n       and \"k < n\"\n       and \"nReturn k t \\<noteq> []\"\nshows \"\\<exists>k<n. nSend k t \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k<n. nSend k t \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  t mod cycleLength (nC k) mem schedule (nC k)\n  k < n\n  nReturn k t \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>k<n. nSend k t \\<noteq> []", "by (metis fr_Send3)"], ["", "lemma fr_Send7:\nassumes \"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\"\n       and \"DisjointSchedules n nC\"\n       and \"IdenticCycleLength n nC\"\n       and \"t mod cycleLength (nC k) mem schedule (nC k)\"\n       and \"k < n\"\n       and \"j < n\"\n       and \"nReturn k t = []\"\nshows \"nSend j t = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nSend j t = []", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  t mod cycleLength (nC k) mem schedule (nC k)\n  k < n\n  j < n\n  nReturn k t = []\n\ngoal (1 subgoal):\n 1. nSend j t = []", "by (metis (full_types) disjointFrame_L3 fr_Send2)"], ["", "lemma fr_Send8:\nassumes \"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\"\n       and \"DisjointSchedules n nC\"\n       and \"IdenticCycleLength n nC\"\n       and \"t mod cycleLength (nC k) mem schedule (nC k)\"\n       and \"k < n\"\n       and \"nReturn k t = []\"\nshows \"\\<not> (\\<exists>k<n. nSend k t \\<noteq> [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>k<n. nSend k t \\<noteq> [])", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  t mod cycleLength (nC k) mem schedule (nC k)\n  k < n\n  nReturn k t = []\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>k<n. nSend k t \\<noteq> [])", "by (auto, simp add: fr_Send7)"], ["", "lemma fr_nC_Send:\nassumes \"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\"\n       and \"k < n\"\n       and \"DisjointSchedules n nC\"\n       and \"IdenticCycleLength n nC\"\n       and \"t mod cycleLength (nC k) mem schedule (nC k)\"\nshows \"\\<forall>j. j < n \\<and> j \\<noteq> k \\<longrightarrow> (nSend j) t = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j. j < n \\<and> j \\<noteq> k \\<longrightarrow> nSend j t = []", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  k < n\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  t mod cycleLength (nC k) mem schedule (nC k)\n\ngoal (1 subgoal):\n 1. \\<forall>j. j < n \\<and> j \\<noteq> k \\<longrightarrow> nSend j t = []", "by (clarify, simp add: disjointFrame_L3)"], ["", "lemma length_nSend:\nassumes h1:\"BusInterface activation (nReturn i) recv (nStore i) (nSend i) (nGet i)\"\n       and h2:\"\\<forall>t. length (nReturn i t) \\<le> Suc 0\"\nshows   \"length (nSend i t) \\<le> Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (nSend i t) \\<le> Suc 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (nSend i t) \\<le> Suc 0", "from h1"], ["proof (chain)\npicking this:\n  BusInterface activation (nReturn i) recv (nStore i) (nSend i) (nGet i)", "have sg1:\"Send (nReturn i) (nSend i) (nGet i) activation\""], ["proof (prove)\nusing this:\n  BusInterface activation (nReturn i) recv (nStore i) (nSend i) (nGet i)\n\ngoal (1 subgoal):\n 1. Send (nReturn i) (nSend i) (nGet i) activation", "by (simp add: BusInterface_def)"], ["proof (state)\nthis:\n  Send (nReturn i) (nSend i) (nGet i) activation\n\ngoal (1 subgoal):\n 1. length (nSend i t) \\<le> Suc 0", "from sg1"], ["proof (chain)\npicking this:\n  Send (nReturn i) (nSend i) (nGet i) activation", "have sg2:\n   \"if activation t = [] then nGet i t = [] \\<and> nSend i t = []\n    else nGet i t = activation t \\<and> nSend i t = nReturn i t\""], ["proof (prove)\nusing this:\n  Send (nReturn i) (nSend i) (nGet i) activation\n\ngoal (1 subgoal):\n 1. if activation t = [] then nGet i t = [] \\<and> nSend i t = []\n    else nGet i t = activation t \\<and> nSend i t = nReturn i t", "by (simp add: Send_def)"], ["proof (state)\nthis:\n  if activation t = [] then nGet i t = [] \\<and> nSend i t = []\n  else nGet i t = activation t \\<and> nSend i t = nReturn i t\n\ngoal (1 subgoal):\n 1. length (nSend i t) \\<le> Suc 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (nSend i t) \\<le> Suc 0", "proof (cases \"activation t = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. activation t = [] \\<Longrightarrow> length (nSend i t) \\<le> Suc 0\n 2. activation t \\<noteq> [] \\<Longrightarrow>\n    length (nSend i t) \\<le> Suc 0", "assume a1:\"activation t = []\""], ["proof (state)\nthis:\n  activation t = []\n\ngoal (2 subgoals):\n 1. activation t = [] \\<Longrightarrow> length (nSend i t) \\<le> Suc 0\n 2. activation t \\<noteq> [] \\<Longrightarrow>\n    length (nSend i t) \\<le> Suc 0", "from sg2 and a1"], ["proof (chain)\npicking this:\n  if activation t = [] then nGet i t = [] \\<and> nSend i t = []\n  else nGet i t = activation t \\<and> nSend i t = nReturn i t\n  activation t = []", "show ?thesis"], ["proof (prove)\nusing this:\n  if activation t = [] then nGet i t = [] \\<and> nSend i t = []\n  else nGet i t = activation t \\<and> nSend i t = nReturn i t\n  activation t = []\n\ngoal (1 subgoal):\n 1. length (nSend i t) \\<le> Suc 0", "by simp"], ["proof (state)\nthis:\n  length (nSend i t) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. activation t \\<noteq> [] \\<Longrightarrow>\n    length (nSend i t) \\<le> Suc 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. activation t \\<noteq> [] \\<Longrightarrow>\n    length (nSend i t) \\<le> Suc 0", "assume a2:\"activation t \\<noteq> []\""], ["proof (state)\nthis:\n  activation t \\<noteq> []\n\ngoal (1 subgoal):\n 1. activation t \\<noteq> [] \\<Longrightarrow>\n    length (nSend i t) \\<le> Suc 0", "from h2"], ["proof (chain)\npicking this:\n  \\<forall>t. length (nReturn i t) \\<le> Suc 0", "have sg3:\"length (nReturn i t) \\<le> Suc 0\""], ["proof (prove)\nusing this:\n  \\<forall>t. length (nReturn i t) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. length (nReturn i t) \\<le> Suc 0", "by auto"], ["proof (state)\nthis:\n  length (nReturn i t) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. activation t \\<noteq> [] \\<Longrightarrow>\n    length (nSend i t) \\<le> Suc 0", "from sg2 and a2 and sg3"], ["proof (chain)\npicking this:\n  if activation t = [] then nGet i t = [] \\<and> nSend i t = []\n  else nGet i t = activation t \\<and> nSend i t = nReturn i t\n  activation t \\<noteq> []\n  length (nReturn i t) \\<le> Suc 0", "show ?thesis"], ["proof (prove)\nusing this:\n  if activation t = [] then nGet i t = [] \\<and> nSend i t = []\n  else nGet i t = activation t \\<and> nSend i t = nReturn i t\n  activation t \\<noteq> []\n  length (nReturn i t) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. length (nSend i t) \\<le> Suc 0", "by simp"], ["proof (state)\nthis:\n  length (nSend i t) \\<le> Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (nSend i t) \\<le> Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma msg_nSend:\nassumes \"BusInterface activation (nReturn i) recv (nStore i) (nSend i) (nGet i)\"\n       and \"msg (Suc 0) (nReturn i)\"\nshows \"msg (Suc 0) (nSend i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msg (Suc 0) (nSend i)", "using assms"], ["proof (prove)\nusing this:\n  BusInterface activation (nReturn i) recv (nStore i) (nSend i) (nGet i)\n  msg (Suc 0) (nReturn i)\n\ngoal (1 subgoal):\n 1. msg (Suc 0) (nSend i)", "by (simp add: msg_def, clarify, simp add: length_nSend)"], ["", "lemma Broadcast_nSend_empty1:\nassumes h1:\"Broadcast n nSend recv\"\n       and h2:\"\\<forall>k<n. nSend k t = []\"\nshows      \"recv t = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recv t = []", "using assms"], ["proof (prove)\nusing this:\n  Broadcast n nSend recv\n  \\<forall>k<n. nSend k t = []\n\ngoal (1 subgoal):\n 1. recv t = []", "by (metis Broadcast_def)"], ["", "subsection \\<open>Properties of the sheaf of channels  nGet\\<close>"], ["", "lemma fr_nGet1a:\nassumes h1:\"FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\" \n       and h2:\"t mod cycleLength (nC k) mem schedule (nC k)\"\nshows \"nGet k t = [t mod cycleLength (nC k)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nGet k t = [t mod cycleLength (nC k)]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nGet k t = [t mod cycleLength (nC k)]", "from h1"], ["proof (chain)\npicking this:\n  FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)", "obtain activation1 where\n     a1:\"Scheduler (nC k) activation1\" and \n     a2:\"BusInterface activation1 (nReturn k) recv (nStore k) (nSend k) (nGet k)\""], ["proof (prove)\nusing this:\n  FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\n\ngoal (1 subgoal):\n 1. (\\<And>activation1.\n        \\<lbrakk>Scheduler (nC k) activation1;\n         BusInterface activation1 (nReturn k) recv (nStore k) (nSend k)\n          (nGet k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: FlexRayController_def, auto)"], ["proof (state)\nthis:\n  Scheduler (nC k) activation1\n  BusInterface activation1 (nReturn k) recv (nStore k) (nSend k) (nGet k)\n\ngoal (1 subgoal):\n 1. nGet k t = [t mod cycleLength (nC k)]", "from a2"], ["proof (chain)\npicking this:\n  BusInterface activation1 (nReturn k) recv (nStore k) (nSend k) (nGet k)", "have sg1:\"Send (nReturn k) (nSend k) (nGet k) activation1\""], ["proof (prove)\nusing this:\n  BusInterface activation1 (nReturn k) recv (nStore k) (nSend k) (nGet k)\n\ngoal (1 subgoal):\n 1. Send (nReturn k) (nSend k) (nGet k) activation1", "by (simp add: BusInterface_def)"], ["proof (state)\nthis:\n  Send (nReturn k) (nSend k) (nGet k) activation1\n\ngoal (1 subgoal):\n 1. nGet k t = [t mod cycleLength (nC k)]", "from sg1"], ["proof (chain)\npicking this:\n  Send (nReturn k) (nSend k) (nGet k) activation1", "have sg2:\n    \"if activation1 t = [] then nGet k t = [] \\<and> nSend k t = []\n     else nGet k t = activation1 t \\<and> nSend k t = nReturn k t\""], ["proof (prove)\nusing this:\n  Send (nReturn k) (nSend k) (nGet k) activation1\n\ngoal (1 subgoal):\n 1. if activation1 t = [] then nGet k t = [] \\<and> nSend k t = []\n    else nGet k t = activation1 t \\<and> nSend k t = nReturn k t", "by (simp add: Send_def)"], ["proof (state)\nthis:\n  if activation1 t = [] then nGet k t = [] \\<and> nSend k t = []\n  else nGet k t = activation1 t \\<and> nSend k t = nReturn k t\n\ngoal (1 subgoal):\n 1. nGet k t = [t mod cycleLength (nC k)]", "from a1 and h2"], ["proof (chain)\npicking this:\n  Scheduler (nC k) activation1\n  t mod cycleLength (nC k) mem schedule (nC k)", "have sg3:\"activation1 t = [t mod cycleLength (nC k)]\""], ["proof (prove)\nusing this:\n  Scheduler (nC k) activation1\n  t mod cycleLength (nC k) mem schedule (nC k)\n\ngoal (1 subgoal):\n 1. activation1 t = [t mod cycleLength (nC k)]", "by (simp add: Scheduler_L4)"], ["proof (state)\nthis:\n  activation1 t = [t mod cycleLength (nC k)]\n\ngoal (1 subgoal):\n 1. nGet k t = [t mod cycleLength (nC k)]", "from sg2 and sg3"], ["proof (chain)\npicking this:\n  if activation1 t = [] then nGet k t = [] \\<and> nSend k t = []\n  else nGet k t = activation1 t \\<and> nSend k t = nReturn k t\n  activation1 t = [t mod cycleLength (nC k)]", "show ?thesis"], ["proof (prove)\nusing this:\n  if activation1 t = [] then nGet k t = [] \\<and> nSend k t = []\n  else nGet k t = activation1 t \\<and> nSend k t = nReturn k t\n  activation1 t = [t mod cycleLength (nC k)]\n\ngoal (1 subgoal):\n 1. nGet k t = [t mod cycleLength (nC k)]", "by simp"], ["proof (state)\nthis:\n  nGet k t = [t mod cycleLength (nC k)]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fr_nGet1:\nassumes \"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\" \n       and \"t mod cycleLength (nC k) mem schedule (nC k)\"\n       and \"k < n\"\nshows \"nGet k t = [t mod cycleLength (nC k)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nGet k t = [t mod cycleLength (nC k)]", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  t mod cycleLength (nC k) mem schedule (nC k)\n  k < n\n\ngoal (1 subgoal):\n 1. nGet k t = [t mod cycleLength (nC k)]", "by (metis  fr_nGet1a)"], ["", "lemma fr_nGet2a:\nassumes h1:\"FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\" \n       and h2:\"\\<not> (t mod cycleLength (nC k) mem schedule (nC k))\"\nshows \"nGet k t = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nGet k t = []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nGet k t = []", "from h1"], ["proof (chain)\npicking this:\n  FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)", "obtain activation1 where\n     a1:\"Scheduler (nC k) activation1\" and \n     a2:\"BusInterface activation1 (nReturn k) recv (nStore k) (nSend k) (nGet k)\""], ["proof (prove)\nusing this:\n  FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\n\ngoal (1 subgoal):\n 1. (\\<And>activation1.\n        \\<lbrakk>Scheduler (nC k) activation1;\n         BusInterface activation1 (nReturn k) recv (nStore k) (nSend k)\n          (nGet k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: FlexRayController_def, auto)"], ["proof (state)\nthis:\n  Scheduler (nC k) activation1\n  BusInterface activation1 (nReturn k) recv (nStore k) (nSend k) (nGet k)\n\ngoal (1 subgoal):\n 1. nGet k t = []", "from a2"], ["proof (chain)\npicking this:\n  BusInterface activation1 (nReturn k) recv (nStore k) (nSend k) (nGet k)", "have sg2:\"Send (nReturn k) (nSend k) (nGet k) activation1\""], ["proof (prove)\nusing this:\n  BusInterface activation1 (nReturn k) recv (nStore k) (nSend k) (nGet k)\n\ngoal (1 subgoal):\n 1. Send (nReturn k) (nSend k) (nGet k) activation1", "by (simp add: BusInterface_def)"], ["proof (state)\nthis:\n  Send (nReturn k) (nSend k) (nGet k) activation1\n\ngoal (1 subgoal):\n 1. nGet k t = []", "from sg2"], ["proof (chain)\npicking this:\n  Send (nReturn k) (nSend k) (nGet k) activation1", "have sg3:\n    \"if activation1 t = [] then nGet k t = [] \\<and> nSend k t = []\n     else nGet k t = activation1 t \\<and> nSend k t = nReturn k t\""], ["proof (prove)\nusing this:\n  Send (nReturn k) (nSend k) (nGet k) activation1\n\ngoal (1 subgoal):\n 1. if activation1 t = [] then nGet k t = [] \\<and> nSend k t = []\n    else nGet k t = activation1 t \\<and> nSend k t = nReturn k t", "by (simp add: Send_def)"], ["proof (state)\nthis:\n  if activation1 t = [] then nGet k t = [] \\<and> nSend k t = []\n  else nGet k t = activation1 t \\<and> nSend k t = nReturn k t\n\ngoal (1 subgoal):\n 1. nGet k t = []", "from a1 and h2"], ["proof (chain)\npicking this:\n  Scheduler (nC k) activation1\n  \\<not> t mod cycleLength (nC k) mem schedule (nC k)", "have sg4:\"activation1 t = []\""], ["proof (prove)\nusing this:\n  Scheduler (nC k) activation1\n  \\<not> t mod cycleLength (nC k) mem schedule (nC k)\n\ngoal (1 subgoal):\n 1. activation1 t = []", "by (simp add: Scheduler_L2)"], ["proof (state)\nthis:\n  activation1 t = []\n\ngoal (1 subgoal):\n 1. nGet k t = []", "from sg3 and sg4"], ["proof (chain)\npicking this:\n  if activation1 t = [] then nGet k t = [] \\<and> nSend k t = []\n  else nGet k t = activation1 t \\<and> nSend k t = nReturn k t\n  activation1 t = []", "show ?thesis"], ["proof (prove)\nusing this:\n  if activation1 t = [] then nGet k t = [] \\<and> nSend k t = []\n  else nGet k t = activation1 t \\<and> nSend k t = nReturn k t\n  activation1 t = []\n\ngoal (1 subgoal):\n 1. nGet k t = []", "by simp"], ["proof (state)\nthis:\n  nGet k t = []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fr_nGet2:\nassumes h1:\"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\" \n     and h2:\"\\<not> (t mod cycleLength (nC k) mem schedule (nC k))\"\n     and h3:\"k < n\"\n shows \"nGet k t = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nGet k t = []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nGet k t = []", "from h1 and h3"], ["proof (chain)\npicking this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  k < n", "have sg1:\n    \"FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\""], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  k < n\n\ngoal (1 subgoal):\n 1. FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)", "by auto"], ["proof (state)\nthis:\n  FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\n\ngoal (1 subgoal):\n 1. nGet k t = []", "from sg1 and h2"], ["proof (chain)\npicking this:\n  FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\n  \\<not> t mod cycleLength (nC k) mem schedule (nC k)", "show ?thesis"], ["proof (prove)\nusing this:\n  FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\n  \\<not> t mod cycleLength (nC k) mem schedule (nC k)\n\ngoal (1 subgoal):\n 1. nGet k t = []", "by (rule fr_nGet2a)"], ["proof (state)\nthis:\n  nGet k t = []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_nGet1:\n assumes \"FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\"\n shows    \"length (nGet k t) \\<le> Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (nGet k t) \\<le> Suc 0", "proof (cases \"t mod cycleLength (nC k) mem schedule (nC k)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t mod cycleLength (nC k) mem schedule (nC k) \\<Longrightarrow>\n    length (nGet k t) \\<le> Suc 0\n 2. \\<not> t mod cycleLength (nC k) mem schedule (nC k) \\<Longrightarrow>\n    length (nGet k t) \\<le> Suc 0", "assume \"t mod cycleLength (nC k) mem schedule (nC k)\""], ["proof (state)\nthis:\n  t mod cycleLength (nC k) mem schedule (nC k)\n\ngoal (2 subgoals):\n 1. t mod cycleLength (nC k) mem schedule (nC k) \\<Longrightarrow>\n    length (nGet k t) \\<le> Suc 0\n 2. \\<not> t mod cycleLength (nC k) mem schedule (nC k) \\<Longrightarrow>\n    length (nGet k t) \\<le> Suc 0", "from assms and this"], ["proof (chain)\npicking this:\n  FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\n  t mod cycleLength (nC k) mem schedule (nC k)", "have \"nGet k t = [t mod cycleLength (nC k)]\""], ["proof (prove)\nusing this:\n  FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\n  t mod cycleLength (nC k) mem schedule (nC k)\n\ngoal (1 subgoal):\n 1. nGet k t = [t mod cycleLength (nC k)]", "by (rule fr_nGet1a)"], ["proof (state)\nthis:\n  nGet k t = [t mod cycleLength (nC k)]\n\ngoal (2 subgoals):\n 1. t mod cycleLength (nC k) mem schedule (nC k) \\<Longrightarrow>\n    length (nGet k t) \\<le> Suc 0\n 2. \\<not> t mod cycleLength (nC k) mem schedule (nC k) \\<Longrightarrow>\n    length (nGet k t) \\<le> Suc 0", "then"], ["proof (chain)\npicking this:\n  nGet k t = [t mod cycleLength (nC k)]", "show ?thesis"], ["proof (prove)\nusing this:\n  nGet k t = [t mod cycleLength (nC k)]\n\ngoal (1 subgoal):\n 1. length (nGet k t) \\<le> Suc 0", "by auto"], ["proof (state)\nthis:\n  length (nGet k t) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. \\<not> t mod cycleLength (nC k) mem schedule (nC k) \\<Longrightarrow>\n    length (nGet k t) \\<le> Suc 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> t mod cycleLength (nC k) mem schedule (nC k) \\<Longrightarrow>\n    length (nGet k t) \\<le> Suc 0", "assume \"\\<not> (t mod cycleLength (nC k) mem schedule (nC k))\""], ["proof (state)\nthis:\n  \\<not> t mod cycleLength (nC k) mem schedule (nC k)\n\ngoal (1 subgoal):\n 1. \\<not> t mod cycleLength (nC k) mem schedule (nC k) \\<Longrightarrow>\n    length (nGet k t) \\<le> Suc 0", "from assms and this"], ["proof (chain)\npicking this:\n  FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\n  \\<not> t mod cycleLength (nC k) mem schedule (nC k)", "have \"nGet k t = []\""], ["proof (prove)\nusing this:\n  FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\n  \\<not> t mod cycleLength (nC k) mem schedule (nC k)\n\ngoal (1 subgoal):\n 1. nGet k t = []", "by (rule fr_nGet2a)"], ["proof (state)\nthis:\n  nGet k t = []\n\ngoal (1 subgoal):\n 1. \\<not> t mod cycleLength (nC k) mem schedule (nC k) \\<Longrightarrow>\n    length (nGet k t) \\<le> Suc 0", "then"], ["proof (chain)\npicking this:\n  nGet k t = []", "show ?thesis"], ["proof (prove)\nusing this:\n  nGet k t = []\n\ngoal (1 subgoal):\n 1. length (nGet k t) \\<le> Suc 0", "by auto"], ["proof (state)\nthis:\n  length (nGet k t) \\<le> Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma msg_nGet1:\n assumes \"FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\"\n shows    \"msg (Suc 0) (nGet k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msg (Suc 0) (nGet k)", "using assms"], ["proof (prove)\nusing this:\n  FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\n\ngoal (1 subgoal):\n 1. msg (Suc 0) (nGet k)", "by (simp add: msg_def, auto, rule length_nGet1)"], ["", "lemma msg_nGet2:\nassumes \"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\"\n       and \"k < n\"\nshows \"msg (Suc 0) (nGet k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msg (Suc 0) (nGet k)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  k < n\n\ngoal (1 subgoal):\n 1. msg (Suc 0) (nGet k)", "by (metis msg_nGet1)"], ["", "subsection \\<open>Properties of the sheaf of channels nStore\\<close>"], ["", "lemma fr_nStore_nReturn1:\n assumes h0:\"Broadcast n nSend recv\"\n     and h1:\"inf_disj n nSend\"\n     and h2:\"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\" \n     and h3:\"DisjointSchedules n nC\"\n     and h4:\"IdenticCycleLength n nC\"\n     and h5:\"t mod cycleLength (nC k) mem schedule (nC k)\"\n     and h6:\"k < n\"\n     and h7:\"j < n\"\n     and h8:\"j \\<noteq> k\"\n shows  \"nStore j t = nReturn k t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nStore j t = nReturn k t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nStore j t = nReturn k t", "from h2 and h6"], ["proof (chain)\npicking this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  k < n", "have sg1:\n    \"FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\""], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  k < n\n\ngoal (1 subgoal):\n 1. FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)", "by auto"], ["proof (state)\nthis:\n  FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\n\ngoal (1 subgoal):\n 1. nStore j t = nReturn k t", "from h2 and h7"], ["proof (chain)\npicking this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  j < n", "have sg2:\n    \"FlexRayController (nReturn j) recv (nC j) (nStore j) (nSend j) (nGet j)\""], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  j < n\n\ngoal (1 subgoal):\n 1. FlexRayController (nReturn j) recv (nC j) (nStore j) (nSend j) (nGet j)", "by auto"], ["proof (state)\nthis:\n  FlexRayController (nReturn j) recv (nC j) (nStore j) (nSend j) (nGet j)\n\ngoal (1 subgoal):\n 1. nStore j t = nReturn k t", "from sg1"], ["proof (chain)\npicking this:\n  FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)", "obtain activation1 where\n     a1:\"Scheduler (nC k) activation1\" and \n     a2:\"BusInterface activation1 (nReturn k) recv (nStore k) (nSend k) (nGet k)\""], ["proof (prove)\nusing this:\n  FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\n\ngoal (1 subgoal):\n 1. (\\<And>activation1.\n        \\<lbrakk>Scheduler (nC k) activation1;\n         BusInterface activation1 (nReturn k) recv (nStore k) (nSend k)\n          (nGet k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: FlexRayController_def, auto)"], ["proof (state)\nthis:\n  Scheduler (nC k) activation1\n  BusInterface activation1 (nReturn k) recv (nStore k) (nSend k) (nGet k)\n\ngoal (1 subgoal):\n 1. nStore j t = nReturn k t", "from sg2"], ["proof (chain)\npicking this:\n  FlexRayController (nReturn j) recv (nC j) (nStore j) (nSend j) (nGet j)", "obtain activation2 where\n     a3:\"Scheduler (nC j) activation2\" and \n     a4:\"BusInterface activation2 (nReturn j) recv (nStore j) (nSend j) (nGet j)\""], ["proof (prove)\nusing this:\n  FlexRayController (nReturn j) recv (nC j) (nStore j) (nSend j) (nGet j)\n\ngoal (1 subgoal):\n 1. (\\<And>activation2.\n        \\<lbrakk>Scheduler (nC j) activation2;\n         BusInterface activation2 (nReturn j) recv (nStore j) (nSend j)\n          (nGet j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: FlexRayController_def, auto)"], ["proof (state)\nthis:\n  Scheduler (nC j) activation2\n  BusInterface activation2 (nReturn j) recv (nStore j) (nSend j) (nGet j)\n\ngoal (1 subgoal):\n 1. nStore j t = nReturn k t", "from a4"], ["proof (chain)\npicking this:\n  BusInterface activation2 (nReturn j) recv (nStore j) (nSend j) (nGet j)", "have sg3:\"Receive recv (nStore j) activation2\""], ["proof (prove)\nusing this:\n  BusInterface activation2 (nReturn j) recv (nStore j) (nSend j) (nGet j)\n\ngoal (1 subgoal):\n 1. Receive recv (nStore j) activation2", "by (simp add: BusInterface_def)"], ["proof (state)\nthis:\n  Receive recv (nStore j) activation2\n\ngoal (1 subgoal):\n 1. nStore j t = nReturn k t", "from this"], ["proof (chain)\npicking this:\n  Receive recv (nStore j) activation2", "have sg4:\n   \"if activation2 t = [] then nStore j t = recv t else nStore j t = []\""], ["proof (prove)\nusing this:\n  Receive recv (nStore j) activation2\n\ngoal (1 subgoal):\n 1. if activation2 t = [] then nStore j t = recv t else nStore j t = []", "by (simp add: Receive_def)"], ["proof (state)\nthis:\n  if activation2 t = [] then nStore j t = recv t else nStore j t = []\n\ngoal (1 subgoal):\n 1. nStore j t = nReturn k t", "from a1 and h5"], ["proof (chain)\npicking this:\n  Scheduler (nC k) activation1\n  t mod cycleLength (nC k) mem schedule (nC k)", "have sg5:\"activation1 t \\<noteq> []\""], ["proof (prove)\nusing this:\n  Scheduler (nC k) activation1\n  t mod cycleLength (nC k) mem schedule (nC k)\n\ngoal (1 subgoal):\n 1. activation1 t \\<noteq> []", "by (simp add: Scheduler_L3)"], ["proof (state)\nthis:\n  activation1 t \\<noteq> []\n\ngoal (1 subgoal):\n 1. nStore j t = nReturn k t", "from h4 and h6 and h7"], ["proof (chain)\npicking this:\n  IdenticCycleLength n nC\n  k < n\n  j < n", "have sg6:\"cycleLength (nC k) = cycleLength (nC j)\""], ["proof (prove)\nusing this:\n  IdenticCycleLength n nC\n  k < n\n  j < n\n\ngoal (1 subgoal):\n 1. cycleLength (nC k) = cycleLength (nC j)", "by (metis IdenticCycleLength_def)"], ["proof (state)\nthis:\n  cycleLength (nC k) = cycleLength (nC j)\n\ngoal (1 subgoal):\n 1. nStore j t = nReturn k t", "from h3 and h6 and h7 and h8"], ["proof (chain)\npicking this:\n  DisjointSchedules n nC\n  k < n\n  j < n\n  j \\<noteq> k", "have sg7:\"disjoint (schedule (nC k)) (schedule (nC j))\""], ["proof (prove)\nusing this:\n  DisjointSchedules n nC\n  k < n\n  j < n\n  j \\<noteq> k\n\ngoal (1 subgoal):\n 1. disjoint (schedule (nC k)) (schedule (nC j))", "by (simp add: DisjointSchedules_def)"], ["proof (state)\nthis:\n  disjoint (schedule (nC k)) (schedule (nC j))\n\ngoal (1 subgoal):\n 1. nStore j t = nReturn k t", "from sg7 and h5"], ["proof (chain)\npicking this:\n  disjoint (schedule (nC k)) (schedule (nC j))\n  t mod cycleLength (nC k) mem schedule (nC k)", "have sg8:\"\\<not> (t mod (cycleLength (nC k))) mem (schedule (nC j))\""], ["proof (prove)\nusing this:\n  disjoint (schedule (nC k)) (schedule (nC j))\n  t mod cycleLength (nC k) mem schedule (nC k)\n\ngoal (1 subgoal):\n 1. \\<not> t mod cycleLength (nC k) mem schedule (nC j)", "by (simp add: mem_notdisjoint2)"], ["proof (state)\nthis:\n  \\<not> t mod cycleLength (nC k) mem schedule (nC j)\n\ngoal (1 subgoal):\n 1. nStore j t = nReturn k t", "from sg6 and sg8"], ["proof (chain)\npicking this:\n  cycleLength (nC k) = cycleLength (nC j)\n  \\<not> t mod cycleLength (nC k) mem schedule (nC j)", "have sg9:\"\\<not> (t mod (cycleLength (nC j))) mem (schedule (nC j))\""], ["proof (prove)\nusing this:\n  cycleLength (nC k) = cycleLength (nC j)\n  \\<not> t mod cycleLength (nC k) mem schedule (nC j)\n\ngoal (1 subgoal):\n 1. \\<not> t mod cycleLength (nC j) mem schedule (nC j)", "by simp"], ["proof (state)\nthis:\n  \\<not> t mod cycleLength (nC j) mem schedule (nC j)\n\ngoal (1 subgoal):\n 1. nStore j t = nReturn k t", "from sg9 and a3"], ["proof (chain)\npicking this:\n  \\<not> t mod cycleLength (nC j) mem schedule (nC j)\n  Scheduler (nC j) activation2", "have sg10:\"activation2 t = []\""], ["proof (prove)\nusing this:\n  \\<not> t mod cycleLength (nC j) mem schedule (nC j)\n  Scheduler (nC j) activation2\n\ngoal (1 subgoal):\n 1. activation2 t = []", "by (simp add: Scheduler_L2)"], ["proof (state)\nthis:\n  activation2 t = []\n\ngoal (1 subgoal):\n 1. nStore j t = nReturn k t", "from sg10 and sg4"], ["proof (chain)\npicking this:\n  activation2 t = []\n  if activation2 t = [] then nStore j t = recv t else nStore j t = []", "have sg11:\"nStore j t = recv t\""], ["proof (prove)\nusing this:\n  activation2 t = []\n  if activation2 t = [] then nStore j t = recv t else nStore j t = []\n\ngoal (1 subgoal):\n 1. nStore j t = recv t", "by simp"], ["proof (state)\nthis:\n  nStore j t = recv t\n\ngoal (1 subgoal):\n 1. nStore j t = nReturn k t", "from h0"], ["proof (chain)\npicking this:\n  Broadcast n nSend recv", "have sg15:\n   \"if \\<exists>k<n. nSend k t \\<noteq> [] \n    then recv t = nSend (SOME k. k < n \\<and> nSend k t \\<noteq> []) t\n    else recv t = []\""], ["proof (prove)\nusing this:\n  Broadcast n nSend recv\n\ngoal (1 subgoal):\n 1. if \\<exists>k<n. nSend k t \\<noteq> []\n    then recv t = nSend (SOME k. k < n \\<and> nSend k t \\<noteq> []) t\n    else recv t = []", "by (simp add: Broadcast_def)"], ["proof (state)\nthis:\n  if \\<exists>k<n. nSend k t \\<noteq> []\n  then recv t = nSend (SOME k. k < n \\<and> nSend k t \\<noteq> []) t\n  else recv t = []\n\ngoal (1 subgoal):\n 1. nStore j t = nReturn k t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. nStore j t = nReturn k t", "proof (cases \"nReturn k t = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. nReturn k t = [] \\<Longrightarrow> nStore j t = nReturn k t\n 2. nReturn k t \\<noteq> [] \\<Longrightarrow> nStore j t = nReturn k t", "assume a5: \"nReturn k t = []\""], ["proof (state)\nthis:\n  nReturn k t = []\n\ngoal (2 subgoals):\n 1. nReturn k t = [] \\<Longrightarrow> nStore j t = nReturn k t\n 2. nReturn k t \\<noteq> [] \\<Longrightarrow> nStore j t = nReturn k t", "from h2 and h3 and h4 and h5 and h6 and a5"], ["proof (chain)\npicking this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  t mod cycleLength (nC k) mem schedule (nC k)\n  k < n\n  nReturn k t = []", "have sg16:\"\\<not> (\\<exists>k<n. nSend k t \\<noteq> [])\""], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  t mod cycleLength (nC k) mem schedule (nC k)\n  k < n\n  nReturn k t = []\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>k<n. nSend k t \\<noteq> [])", "by (simp add: fr_Send8)"], ["proof (state)\nthis:\n  \\<not> (\\<exists>k<n. nSend k t \\<noteq> [])\n\ngoal (2 subgoals):\n 1. nReturn k t = [] \\<Longrightarrow> nStore j t = nReturn k t\n 2. nReturn k t \\<noteq> [] \\<Longrightarrow> nStore j t = nReturn k t", "from sg16 and sg15"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>k<n. nSend k t \\<noteq> [])\n  if \\<exists>k<n. nSend k t \\<noteq> []\n  then recv t = nSend (SOME k. k < n \\<and> nSend k t \\<noteq> []) t\n  else recv t = []", "have sg17:\"recv t = []\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>k<n. nSend k t \\<noteq> [])\n  if \\<exists>k<n. nSend k t \\<noteq> []\n  then recv t = nSend (SOME k. k < n \\<and> nSend k t \\<noteq> []) t\n  else recv t = []\n\ngoal (1 subgoal):\n 1. recv t = []", "by simp"], ["proof (state)\nthis:\n  recv t = []\n\ngoal (2 subgoals):\n 1. nReturn k t = [] \\<Longrightarrow> nStore j t = nReturn k t\n 2. nReturn k t \\<noteq> [] \\<Longrightarrow> nStore j t = nReturn k t", "from sg11 and sg17"], ["proof (chain)\npicking this:\n  nStore j t = recv t\n  recv t = []", "have sg18:\"nStore j t = []\""], ["proof (prove)\nusing this:\n  nStore j t = recv t\n  recv t = []\n\ngoal (1 subgoal):\n 1. nStore j t = []", "by simp"], ["proof (state)\nthis:\n  nStore j t = []\n\ngoal (2 subgoals):\n 1. nReturn k t = [] \\<Longrightarrow> nStore j t = nReturn k t\n 2. nReturn k t \\<noteq> [] \\<Longrightarrow> nStore j t = nReturn k t", "from this and a5"], ["proof (chain)\npicking this:\n  nStore j t = []\n  nReturn k t = []", "show ?thesis"], ["proof (prove)\nusing this:\n  nStore j t = []\n  nReturn k t = []\n\ngoal (1 subgoal):\n 1. nStore j t = nReturn k t", "by simp"], ["proof (state)\nthis:\n  nStore j t = nReturn k t\n\ngoal (1 subgoal):\n 1. nReturn k t \\<noteq> [] \\<Longrightarrow> nStore j t = nReturn k t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. nReturn k t \\<noteq> [] \\<Longrightarrow> nStore j t = nReturn k t", "assume a6:\"nReturn k t \\<noteq> []\""], ["proof (state)\nthis:\n  nReturn k t \\<noteq> []\n\ngoal (1 subgoal):\n 1. nReturn k t \\<noteq> [] \\<Longrightarrow> nStore j t = nReturn k t", "from h2 and h3 and h4 and h5 and h6 and a6"], ["proof (chain)\npicking this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  t mod cycleLength (nC k) mem schedule (nC k)\n  k < n\n  nReturn k t \\<noteq> []", "have sg19:\"\\<exists>k<n. nSend k t \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  t mod cycleLength (nC k) mem schedule (nC k)\n  k < n\n  nReturn k t \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>k<n. nSend k t \\<noteq> []", "by (simp add: fr_Send6)"], ["proof (state)\nthis:\n  \\<exists>k<n. nSend k t \\<noteq> []\n\ngoal (1 subgoal):\n 1. nReturn k t \\<noteq> [] \\<Longrightarrow> nStore j t = nReturn k t", "from h2 and h3 and h4 and h5 and h6 and a6"], ["proof (chain)\npicking this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  t mod cycleLength (nC k) mem schedule (nC k)\n  k < n\n  nReturn k t \\<noteq> []", "have sg20:\"nSend k t \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  t mod cycleLength (nC k) mem schedule (nC k)\n  k < n\n  nReturn k t \\<noteq> []\n\ngoal (1 subgoal):\n 1. nSend k t \\<noteq> []", "by (simp add: fr_Send3)"], ["proof (state)\nthis:\n  nSend k t \\<noteq> []\n\ngoal (1 subgoal):\n 1. nReturn k t \\<noteq> [] \\<Longrightarrow> nStore j t = nReturn k t", "from h1 and sg20 and h6"], ["proof (chain)\npicking this:\n  inf_disj n nSend\n  nSend k t \\<noteq> []\n  k < n", "have sg21:\"(SOME k. k < n \\<and> nSend k t \\<noteq> []) = k\""], ["proof (prove)\nusing this:\n  inf_disj n nSend\n  nSend k t \\<noteq> []\n  k < n\n\ngoal (1 subgoal):\n 1. (SOME k. k < n \\<and> nSend k t \\<noteq> []) = k", "by (simp add: inf_disj_index)"], ["proof (state)\nthis:\n  (SOME k. k < n \\<and> nSend k t \\<noteq> []) = k\n\ngoal (1 subgoal):\n 1. nReturn k t \\<noteq> [] \\<Longrightarrow> nStore j t = nReturn k t", "from sg15 and sg19"], ["proof (chain)\npicking this:\n  if \\<exists>k<n. nSend k t \\<noteq> []\n  then recv t = nSend (SOME k. k < n \\<and> nSend k t \\<noteq> []) t\n  else recv t = []\n  \\<exists>k<n. nSend k t \\<noteq> []", "have sg22:\"recv t = nSend (SOME k. k < n \\<and> nSend k t \\<noteq> []) t\""], ["proof (prove)\nusing this:\n  if \\<exists>k<n. nSend k t \\<noteq> []\n  then recv t = nSend (SOME k. k < n \\<and> nSend k t \\<noteq> []) t\n  else recv t = []\n  \\<exists>k<n. nSend k t \\<noteq> []\n\ngoal (1 subgoal):\n 1. recv t = nSend (SOME k. k < n \\<and> nSend k t \\<noteq> []) t", "by simp"], ["proof (state)\nthis:\n  recv t = nSend (SOME k. k < n \\<and> nSend k t \\<noteq> []) t\n\ngoal (1 subgoal):\n 1. nReturn k t \\<noteq> [] \\<Longrightarrow> nStore j t = nReturn k t", "from sg22 and sg21"], ["proof (chain)\npicking this:\n  recv t = nSend (SOME k. k < n \\<and> nSend k t \\<noteq> []) t\n  (SOME k. k < n \\<and> nSend k t \\<noteq> []) = k", "have sg23:\"recv t = nSend k t\""], ["proof (prove)\nusing this:\n  recv t = nSend (SOME k. k < n \\<and> nSend k t \\<noteq> []) t\n  (SOME k. k < n \\<and> nSend k t \\<noteq> []) = k\n\ngoal (1 subgoal):\n 1. recv t = nSend k t", "by simp"], ["proof (state)\nthis:\n  recv t = nSend k t\n\ngoal (1 subgoal):\n 1. nReturn k t \\<noteq> [] \\<Longrightarrow> nStore j t = nReturn k t", "from h2 and h3 and h4 and h5 and h6"], ["proof (chain)\npicking this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  t mod cycleLength (nC k) mem schedule (nC k)\n  k < n", "have sg24:\"nSend k t =  nReturn k t\""], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  t mod cycleLength (nC k) mem schedule (nC k)\n  k < n\n\ngoal (1 subgoal):\n 1. nSend k t = nReturn k t", "by (simp add: fr_Send2)"], ["proof (state)\nthis:\n  nSend k t = nReturn k t\n\ngoal (1 subgoal):\n 1. nReturn k t \\<noteq> [] \\<Longrightarrow> nStore j t = nReturn k t", "from sg11 and sg23 and sg24"], ["proof (chain)\npicking this:\n  nStore j t = recv t\n  recv t = nSend k t\n  nSend k t = nReturn k t", "show ?thesis"], ["proof (prove)\nusing this:\n  nStore j t = recv t\n  recv t = nSend k t\n  nSend k t = nReturn k t\n\ngoal (1 subgoal):\n 1. nStore j t = nReturn k t", "by simp"], ["proof (state)\nthis:\n  nStore j t = nReturn k t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nStore j t = nReturn k t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fr_nStore_nReturn2:\n assumes h1:\"Cable n nSend recv\"\n     and h2:\"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\" \n     and h3:\"DisjointSchedules n nC\"\n     and h4:\"IdenticCycleLength n nC\"\n     and h5:\"t mod cycleLength (nC k) mem schedule (nC k)\"\n     and h6:\"k < n\"\n     and h7:\"j < n\"\n     and h8:\"j \\<noteq> k\"\n shows  \"nStore j t = nReturn k t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nStore j t = nReturn k t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nStore j t = nReturn k t", "from h1"], ["proof (chain)\npicking this:\n  Cable n nSend recv", "have sg1:\"inf_disj n nSend \\<longrightarrow> Broadcast n nSend recv\""], ["proof (prove)\nusing this:\n  Cable n nSend recv\n\ngoal (1 subgoal):\n 1. inf_disj n nSend \\<longrightarrow> Broadcast n nSend recv", "by (simp add: Cable_def)"], ["proof (state)\nthis:\n  inf_disj n nSend \\<longrightarrow> Broadcast n nSend recv\n\ngoal (1 subgoal):\n 1. nStore j t = nReturn k t", "from  h3 and h4 and h2"], ["proof (chain)\npicking this:\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)", "have sg2:\"inf_disj n nSend\""], ["proof (prove)\nusing this:\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n\ngoal (1 subgoal):\n 1. inf_disj n nSend", "by (simp add: disjointFrame_L2)"], ["proof (state)\nthis:\n  inf_disj n nSend\n\ngoal (1 subgoal):\n 1. nStore j t = nReturn k t", "from sg1 and sg2"], ["proof (chain)\npicking this:\n  inf_disj n nSend \\<longrightarrow> Broadcast n nSend recv\n  inf_disj n nSend", "have sg3:\"Broadcast n nSend recv\""], ["proof (prove)\nusing this:\n  inf_disj n nSend \\<longrightarrow> Broadcast n nSend recv\n  inf_disj n nSend\n\ngoal (1 subgoal):\n 1. Broadcast n nSend recv", "by simp"], ["proof (state)\nthis:\n  Broadcast n nSend recv\n\ngoal (1 subgoal):\n 1. nStore j t = nReturn k t", "from sg3 and sg2 and assms"], ["proof (chain)\npicking this:\n  Broadcast n nSend recv\n  inf_disj n nSend\n  Cable n nSend recv\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  t mod cycleLength (nC k) mem schedule (nC k)\n  k < n\n  j < n\n  j \\<noteq> k", "show ?thesis"], ["proof (prove)\nusing this:\n  Broadcast n nSend recv\n  inf_disj n nSend\n  Cable n nSend recv\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  t mod cycleLength (nC k) mem schedule (nC k)\n  k < n\n  j < n\n  j \\<noteq> k\n\ngoal (1 subgoal):\n 1. nStore j t = nReturn k t", "by (simp add: fr_nStore_nReturn1)"], ["proof (state)\nthis:\n  nStore j t = nReturn k t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fr_nStore_empty1:\n assumes h1:\"Cable n nSend recv\"\n     and h2:\"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\" \n     and h3:\"DisjointSchedules n nC\"\n     and h4:\"IdenticCycleLength n nC\"\n     and h5:\"(t mod cycleLength (nC k) mem schedule (nC k))\"\n     and h6:\"k < n\"\n shows  \"nStore k t = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nStore k t = []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nStore k t = []", "from h2 and h6"], ["proof (chain)\npicking this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  k < n", "have sg1:\n    \"FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\""], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  k < n\n\ngoal (1 subgoal):\n 1. FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)", "by auto"], ["proof (state)\nthis:\n  FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\n\ngoal (1 subgoal):\n 1. nStore k t = []", "from sg1"], ["proof (chain)\npicking this:\n  FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)", "obtain activation1 where\n     a1:\"Scheduler (nC k) activation1\" and \n     a2:\"BusInterface activation1 (nReturn k) recv (nStore k) (nSend k) (nGet k)\""], ["proof (prove)\nusing this:\n  FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\n\ngoal (1 subgoal):\n 1. (\\<And>activation1.\n        \\<lbrakk>Scheduler (nC k) activation1;\n         BusInterface activation1 (nReturn k) recv (nStore k) (nSend k)\n          (nGet k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: FlexRayController_def, auto)"], ["proof (state)\nthis:\n  Scheduler (nC k) activation1\n  BusInterface activation1 (nReturn k) recv (nStore k) (nSend k) (nGet k)\n\ngoal (1 subgoal):\n 1. nStore k t = []", "from a2"], ["proof (chain)\npicking this:\n  BusInterface activation1 (nReturn k) recv (nStore k) (nSend k) (nGet k)", "have sg2:\"Receive recv (nStore k) activation1\""], ["proof (prove)\nusing this:\n  BusInterface activation1 (nReturn k) recv (nStore k) (nSend k) (nGet k)\n\ngoal (1 subgoal):\n 1. Receive recv (nStore k) activation1", "by (simp add: BusInterface_def)"], ["proof (state)\nthis:\n  Receive recv (nStore k) activation1\n\ngoal (1 subgoal):\n 1. nStore k t = []", "from this"], ["proof (chain)\npicking this:\n  Receive recv (nStore k) activation1", "have sg3:\n   \"if activation1 t = [] then nStore k t = recv t else nStore k t = []\""], ["proof (prove)\nusing this:\n  Receive recv (nStore k) activation1\n\ngoal (1 subgoal):\n 1. if activation1 t = [] then nStore k t = recv t else nStore k t = []", "by (simp add: Receive_def)"], ["proof (state)\nthis:\n  if activation1 t = [] then nStore k t = recv t else nStore k t = []\n\ngoal (1 subgoal):\n 1. nStore k t = []", "from a1 and h5"], ["proof (chain)\npicking this:\n  Scheduler (nC k) activation1\n  t mod cycleLength (nC k) mem schedule (nC k)", "have sg4:\"activation1 t \\<noteq> []\""], ["proof (prove)\nusing this:\n  Scheduler (nC k) activation1\n  t mod cycleLength (nC k) mem schedule (nC k)\n\ngoal (1 subgoal):\n 1. activation1 t \\<noteq> []", "by (simp add: Scheduler_L3)"], ["proof (state)\nthis:\n  activation1 t \\<noteq> []\n\ngoal (1 subgoal):\n 1. nStore k t = []", "from sg3 and sg4"], ["proof (chain)\npicking this:\n  if activation1 t = [] then nStore k t = recv t else nStore k t = []\n  activation1 t \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  if activation1 t = [] then nStore k t = recv t else nStore k t = []\n  activation1 t \\<noteq> []\n\ngoal (1 subgoal):\n 1. nStore k t = []", "by simp"], ["proof (state)\nthis:\n  nStore k t = []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fr_nStore_nReturn3:\n assumes \"Cable n nSend recv\"\n     and \"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\" \n     and \"DisjointSchedules n nC\"\n     and \"IdenticCycleLength n nC\"\n     and \"t mod cycleLength (nC k) mem schedule (nC k)\"\n     and \"k < n\"\n shows  \"\\<forall>j. j < n \\<and> j \\<noteq> k \\<longrightarrow> nStore j t = nReturn k t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j.\n       j < n \\<and> j \\<noteq> k \\<longrightarrow> nStore j t = nReturn k t", "using assms"], ["proof (prove)\nusing this:\n  Cable n nSend recv\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  t mod cycleLength (nC k) mem schedule (nC k)\n  k < n\n\ngoal (1 subgoal):\n 1. \\<forall>j.\n       j < n \\<and> j \\<noteq> k \\<longrightarrow> nStore j t = nReturn k t", "by (clarify, simp add: fr_nStore_nReturn2)"], ["", "lemma length_nStore:\n assumes h1:\"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\"\n     and h2:\"DisjointSchedules n nC\"\n     and h3:\"IdenticCycleLength n nC\"\n     and h4:\"inf_disj n nSend\"\n     and h5:\"i < n\"  \n     and h6:\"\\<forall> i<n. msg (Suc 0) (nReturn i)\"\n     and h7:\"Broadcast n nSend recv\"\n shows \"length (nStore i t) \\<le> Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (nStore i t) \\<le> Suc 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (nStore i t) \\<le> Suc 0", "from h7"], ["proof (chain)\npicking this:\n  Broadcast n nSend recv", "have sg1:\n   \"if \\<exists>k<n. nSend k t \\<noteq> [] \n    then recv t = nSend (SOME k. k < n \\<and> nSend k t \\<noteq> []) t \n    else recv t = []\""], ["proof (prove)\nusing this:\n  Broadcast n nSend recv\n\ngoal (1 subgoal):\n 1. if \\<exists>k<n. nSend k t \\<noteq> []\n    then recv t = nSend (SOME k. k < n \\<and> nSend k t \\<noteq> []) t\n    else recv t = []", "by (simp add: Broadcast_def)"], ["proof (state)\nthis:\n  if \\<exists>k<n. nSend k t \\<noteq> []\n  then recv t = nSend (SOME k. k < n \\<and> nSend k t \\<noteq> []) t\n  else recv t = []\n\ngoal (1 subgoal):\n 1. length (nStore i t) \\<le> Suc 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (nStore i t) \\<le> Suc 0", "proof (cases \"\\<exists>k<n. nSend k t \\<noteq> []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>k<n. nSend k t \\<noteq> [] \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0\n 2. \\<not> (\\<exists>k<n. nSend k t \\<noteq> []) \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0", "assume \"\\<exists>k<n. nSend k t \\<noteq> []\""], ["proof (state)\nthis:\n  \\<exists>k<n. nSend k t \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<exists>k<n. nSend k t \\<noteq> [] \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0\n 2. \\<not> (\\<exists>k<n. nSend k t \\<noteq> []) \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0", "from this"], ["proof (chain)\npicking this:\n  \\<exists>k<n. nSend k t \\<noteq> []", "obtain k where a2:\"k<n\" and a3:\"nSend k t \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<exists>k<n. nSend k t \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        \\<lbrakk>k < n; nSend k t \\<noteq> []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  k < n\n  nSend k t \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<exists>k<n. nSend k t \\<noteq> [] \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0\n 2. \\<not> (\\<exists>k<n. nSend k t \\<noteq> []) \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0", "from h1 and a2"], ["proof (chain)\npicking this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  k < n", "have \n      \"FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\""], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  k < n\n\ngoal (1 subgoal):\n 1. FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)", "by auto"], ["proof (state)\nthis:\n  FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\n\ngoal (2 subgoals):\n 1. \\<exists>k<n. nSend k t \\<noteq> [] \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0\n 2. \\<not> (\\<exists>k<n. nSend k t \\<noteq> []) \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0", "then"], ["proof (chain)\npicking this:\n  FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)", "obtain activation1 where\n      a4:\"Scheduler (nC k) activation1\" and \n      a5:\"BusInterface activation1 (nReturn k) recv (nStore k) (nSend k) (nGet k)\""], ["proof (prove)\nusing this:\n  FlexRayController (nReturn k) recv (nC k) (nStore k) (nSend k) (nGet k)\n\ngoal (1 subgoal):\n 1. (\\<And>activation1.\n        \\<lbrakk>Scheduler (nC k) activation1;\n         BusInterface activation1 (nReturn k) recv (nStore k) (nSend k)\n          (nGet k)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: FlexRayController_def, auto)"], ["proof (state)\nthis:\n  Scheduler (nC k) activation1\n  BusInterface activation1 (nReturn k) recv (nStore k) (nSend k) (nGet k)\n\ngoal (2 subgoals):\n 1. \\<exists>k<n. nSend k t \\<noteq> [] \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0\n 2. \\<not> (\\<exists>k<n. nSend k t \\<noteq> []) \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0", "from a5"], ["proof (chain)\npicking this:\n  BusInterface activation1 (nReturn k) recv (nStore k) (nSend k) (nGet k)", "have sg5:\"Send (nReturn k) (nSend k) (nGet k) activation1\""], ["proof (prove)\nusing this:\n  BusInterface activation1 (nReturn k) recv (nStore k) (nSend k) (nGet k)\n\ngoal (1 subgoal):\n 1. Send (nReturn k) (nSend k) (nGet k) activation1", "by (simp add:  BusInterface_def)"], ["proof (state)\nthis:\n  Send (nReturn k) (nSend k) (nGet k) activation1\n\ngoal (2 subgoals):\n 1. \\<exists>k<n. nSend k t \\<noteq> [] \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0\n 2. \\<not> (\\<exists>k<n. nSend k t \\<noteq> []) \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0", "from a5"], ["proof (chain)\npicking this:\n  BusInterface activation1 (nReturn k) recv (nStore k) (nSend k) (nGet k)", "have sg6:\"Receive recv (nStore k) activation1\""], ["proof (prove)\nusing this:\n  BusInterface activation1 (nReturn k) recv (nStore k) (nSend k) (nGet k)\n\ngoal (1 subgoal):\n 1. Receive recv (nStore k) activation1", "by (simp add: BusInterface_def)"], ["proof (state)\nthis:\n  Receive recv (nStore k) activation1\n\ngoal (2 subgoals):\n 1. \\<exists>k<n. nSend k t \\<noteq> [] \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0\n 2. \\<not> (\\<exists>k<n. nSend k t \\<noteq> []) \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0", "from sg5 and a3"], ["proof (chain)\npicking this:\n  Send (nReturn k) (nSend k) (nGet k) activation1\n  nSend k t \\<noteq> []", "have sg7:\"(activation1 t) \\<noteq> []\""], ["proof (prove)\nusing this:\n  Send (nReturn k) (nSend k) (nGet k) activation1\n  nSend k t \\<noteq> []\n\ngoal (1 subgoal):\n 1. activation1 t \\<noteq> []", "by (simp add: Send_L1)"], ["proof (state)\nthis:\n  activation1 t \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<exists>k<n. nSend k t \\<noteq> [] \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0\n 2. \\<not> (\\<exists>k<n. nSend k t \\<noteq> []) \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0", "from sg6"], ["proof (chain)\npicking this:\n  Receive recv (nStore k) activation1", "have sg8:\n     \"if activation1 t = [] \n      then nStore k t = recv t else nStore k t = []\""], ["proof (prove)\nusing this:\n  Receive recv (nStore k) activation1\n\ngoal (1 subgoal):\n 1. if activation1 t = [] then nStore k t = recv t else nStore k t = []", "by (simp add: Receive_def)"], ["proof (state)\nthis:\n  if activation1 t = [] then nStore k t = recv t else nStore k t = []\n\ngoal (2 subgoals):\n 1. \\<exists>k<n. nSend k t \\<noteq> [] \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0\n 2. \\<not> (\\<exists>k<n. nSend k t \\<noteq> []) \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0", "from sg8 and sg7"], ["proof (chain)\npicking this:\n  if activation1 t = [] then nStore k t = recv t else nStore k t = []\n  activation1 t \\<noteq> []", "have sg9:\"nStore k t = []\""], ["proof (prove)\nusing this:\n  if activation1 t = [] then nStore k t = recv t else nStore k t = []\n  activation1 t \\<noteq> []\n\ngoal (1 subgoal):\n 1. nStore k t = []", "by simp"], ["proof (state)\nthis:\n  nStore k t = []\n\ngoal (2 subgoals):\n 1. \\<exists>k<n. nSend k t \\<noteq> [] \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0\n 2. \\<not> (\\<exists>k<n. nSend k t \\<noteq> []) \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0", "from a4 and sg7"], ["proof (chain)\npicking this:\n  Scheduler (nC k) activation1\n  activation1 t \\<noteq> []", "have sg10:\"(t mod (cycleLength (nC k))) mem (schedule (nC k))\""], ["proof (prove)\nusing this:\n  Scheduler (nC k) activation1\n  activation1 t \\<noteq> []\n\ngoal (1 subgoal):\n 1. t mod cycleLength (nC k) mem schedule (nC k)", "by (simp add: Scheduler_L1)"], ["proof (state)\nthis:\n  t mod cycleLength (nC k) mem schedule (nC k)\n\ngoal (2 subgoals):\n 1. \\<exists>k<n. nSend k t \\<noteq> [] \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0\n 2. \\<not> (\\<exists>k<n. nSend k t \\<noteq> []) \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (nStore i t) \\<le> Suc 0", "proof (cases \"i = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow> length (nStore i t) \\<le> Suc 0\n 2. i \\<noteq> k \\<Longrightarrow> length (nStore i t) \\<le> Suc 0", "assume  \"i = k\""], ["proof (state)\nthis:\n  i = k\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow> length (nStore i t) \\<le> Suc 0\n 2. i \\<noteq> k \\<Longrightarrow> length (nStore i t) \\<le> Suc 0", "from sg9 and this"], ["proof (chain)\npicking this:\n  nStore k t = []\n  i = k", "show ?thesis"], ["proof (prove)\nusing this:\n  nStore k t = []\n  i = k\n\ngoal (1 subgoal):\n 1. length (nStore i t) \\<le> Suc 0", "by simp"], ["proof (state)\nthis:\n  length (nStore i t) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow> length (nStore i t) \\<le> Suc 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow> length (nStore i t) \\<le> Suc 0", "assume \"i \\<noteq> k\""], ["proof (state)\nthis:\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow> length (nStore i t) \\<le> Suc 0", "from h7 and h4 and h1 and h2 and h3 and sg10 and a2 and h5 and this"], ["proof (chain)\npicking this:\n  Broadcast n nSend recv\n  inf_disj n nSend\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  t mod cycleLength (nC k) mem schedule (nC k)\n  k < n\n  i < n\n  i \\<noteq> k", "have sg11:\n       \"nStore i t = nReturn k t\""], ["proof (prove)\nusing this:\n  Broadcast n nSend recv\n  inf_disj n nSend\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  t mod cycleLength (nC k) mem schedule (nC k)\n  k < n\n  i < n\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. nStore i t = nReturn k t", "by (simp add: fr_nStore_nReturn1)"], ["proof (state)\nthis:\n  nStore i t = nReturn k t\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow> length (nStore i t) \\<le> Suc 0", "from h6 and a2"], ["proof (chain)\npicking this:\n  \\<forall>i<n. msg (Suc 0) (nReturn i)\n  k < n", "have sg12:\"msg (Suc 0) (nReturn k)\""], ["proof (prove)\nusing this:\n  \\<forall>i<n. msg (Suc 0) (nReturn i)\n  k < n\n\ngoal (1 subgoal):\n 1. msg (Suc 0) (nReturn k)", "by auto"], ["proof (state)\nthis:\n  msg (Suc 0) (nReturn k)\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow> length (nStore i t) \\<le> Suc 0", "from a2 and h6"], ["proof (chain)\npicking this:\n  k < n\n  \\<forall>i<n. msg (Suc 0) (nReturn i)", "have sg13:\"length (nReturn k t) \\<le> Suc 0\""], ["proof (prove)\nusing this:\n  k < n\n  \\<forall>i<n. msg (Suc 0) (nReturn i)\n\ngoal (1 subgoal):\n 1. length (nReturn k t) \\<le> Suc 0", "by (simp add: msg_def)"], ["proof (state)\nthis:\n  length (nReturn k t) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow> length (nStore i t) \\<le> Suc 0", "from sg11 and sg13"], ["proof (chain)\npicking this:\n  nStore i t = nReturn k t\n  length (nReturn k t) \\<le> Suc 0", "show ?thesis"], ["proof (prove)\nusing this:\n  nStore i t = nReturn k t\n  length (nReturn k t) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. length (nStore i t) \\<le> Suc 0", "by simp"], ["proof (state)\nthis:\n  length (nStore i t) \\<le> Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (nStore i t) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>k<n. nSend k t \\<noteq> []) \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>k<n. nSend k t \\<noteq> []) \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0", "assume \"\\<not> (\\<exists>k<n. nSend k t \\<noteq> [])\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>k<n. nSend k t \\<noteq> [])\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>k<n. nSend k t \\<noteq> []) \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0", "from h7 and this"], ["proof (chain)\npicking this:\n  Broadcast n nSend recv\n  \\<not> (\\<exists>k<n. nSend k t \\<noteq> [])", "have sg14:\"recv t = []\""], ["proof (prove)\nusing this:\n  Broadcast n nSend recv\n  \\<not> (\\<exists>k<n. nSend k t \\<noteq> [])\n\ngoal (1 subgoal):\n 1. recv t = []", "by (simp add: Broadcast_nSend_empty1)"], ["proof (state)\nthis:\n  recv t = []\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>k<n. nSend k t \\<noteq> []) \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0", "from h1 and h5"], ["proof (chain)\npicking this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  i < n", "have \n      \"FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\""], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  i < n\n\ngoal (1 subgoal):\n 1. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)", "by auto"], ["proof (state)\nthis:\n  FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>k<n. nSend k t \\<noteq> []) \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0", "then"], ["proof (chain)\npicking this:\n  FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)", "obtain activation2 where\n      a11:\"Scheduler (nC i) activation2\" and \n      a12:\"BusInterface activation2 (nReturn i) recv (nStore i) (nSend i) (nGet i)\""], ["proof (prove)\nusing this:\n  FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n\ngoal (1 subgoal):\n 1. (\\<And>activation2.\n        \\<lbrakk>Scheduler (nC i) activation2;\n         BusInterface activation2 (nReturn i) recv (nStore i) (nSend i)\n          (nGet i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: FlexRayController_def, auto)"], ["proof (state)\nthis:\n  Scheduler (nC i) activation2\n  BusInterface activation2 (nReturn i) recv (nStore i) (nSend i) (nGet i)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>k<n. nSend k t \\<noteq> []) \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0", "from a12"], ["proof (chain)\npicking this:\n  BusInterface activation2 (nReturn i) recv (nStore i) (nSend i) (nGet i)", "have \"Receive recv (nStore i) activation2\""], ["proof (prove)\nusing this:\n  BusInterface activation2 (nReturn i) recv (nStore i) (nSend i) (nGet i)\n\ngoal (1 subgoal):\n 1. Receive recv (nStore i) activation2", "by (simp add: BusInterface_def)"], ["proof (state)\nthis:\n  Receive recv (nStore i) activation2\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>k<n. nSend k t \\<noteq> []) \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0", "then"], ["proof (chain)\npicking this:\n  Receive recv (nStore i) activation2", "have sg17:\n     \"if activation2 t = [] \n      then nStore i t = recv t else nStore i t = []\""], ["proof (prove)\nusing this:\n  Receive recv (nStore i) activation2\n\ngoal (1 subgoal):\n 1. if activation2 t = [] then nStore i t = recv t else nStore i t = []", "by (simp add: Receive_def)"], ["proof (state)\nthis:\n  if activation2 t = [] then nStore i t = recv t else nStore i t = []\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>k<n. nSend k t \\<noteq> []) \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (nStore i t) \\<le> Suc 0", "proof (cases \"activation2 t = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. activation2 t = [] \\<Longrightarrow> length (nStore i t) \\<le> Suc 0\n 2. activation2 t \\<noteq> [] \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0", "assume aa3:\"activation2 t = []\""], ["proof (state)\nthis:\n  activation2 t = []\n\ngoal (2 subgoals):\n 1. activation2 t = [] \\<Longrightarrow> length (nStore i t) \\<le> Suc 0\n 2. activation2 t \\<noteq> [] \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0", "from sg17 and aa3 and sg14"], ["proof (chain)\npicking this:\n  if activation2 t = [] then nStore i t = recv t else nStore i t = []\n  activation2 t = []\n  recv t = []", "have \"nStore i t = []\""], ["proof (prove)\nusing this:\n  if activation2 t = [] then nStore i t = recv t else nStore i t = []\n  activation2 t = []\n  recv t = []\n\ngoal (1 subgoal):\n 1. nStore i t = []", "by simp"], ["proof (state)\nthis:\n  nStore i t = []\n\ngoal (2 subgoals):\n 1. activation2 t = [] \\<Longrightarrow> length (nStore i t) \\<le> Suc 0\n 2. activation2 t \\<noteq> [] \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0", "then"], ["proof (chain)\npicking this:\n  nStore i t = []", "show ?thesis"], ["proof (prove)\nusing this:\n  nStore i t = []\n\ngoal (1 subgoal):\n 1. length (nStore i t) \\<le> Suc 0", "by simp"], ["proof (state)\nthis:\n  length (nStore i t) \\<le> Suc 0\n\ngoal (1 subgoal):\n 1. activation2 t \\<noteq> [] \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. activation2 t \\<noteq> [] \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0", "assume aa4:\"activation2 t \\<noteq> []\""], ["proof (state)\nthis:\n  activation2 t \\<noteq> []\n\ngoal (1 subgoal):\n 1. activation2 t \\<noteq> [] \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0", "from sg17 and aa4"], ["proof (chain)\npicking this:\n  if activation2 t = [] then nStore i t = recv t else nStore i t = []\n  activation2 t \\<noteq> []", "have \"nStore i t = []\""], ["proof (prove)\nusing this:\n  if activation2 t = [] then nStore i t = recv t else nStore i t = []\n  activation2 t \\<noteq> []\n\ngoal (1 subgoal):\n 1. nStore i t = []", "by simp"], ["proof (state)\nthis:\n  nStore i t = []\n\ngoal (1 subgoal):\n 1. activation2 t \\<noteq> [] \\<Longrightarrow>\n    length (nStore i t) \\<le> Suc 0", "then"], ["proof (chain)\npicking this:\n  nStore i t = []", "show ?thesis"], ["proof (prove)\nusing this:\n  nStore i t = []\n\ngoal (1 subgoal):\n 1. length (nStore i t) \\<le> Suc 0", "by simp"], ["proof (state)\nthis:\n  length (nStore i t) \\<le> Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (nStore i t) \\<le> Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length (nStore i t) \\<le> Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma msg_nStore:\nassumes \" \\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\"\n       and \"DisjointSchedules n nC\"\n       and \"IdenticCycleLength n nC\"\n       and \"inf_disj n nSend\"\n       and \"i < n\"  \n       and \"\\<forall> i<n. msg (Suc 0) (nReturn i)\"\n       and \"Cable n nSend recv\"\nshows \"msg (Suc 0) (nStore i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msg (Suc 0) (nStore i)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  inf_disj n nSend\n  i < n\n  \\<forall>i<n. msg (Suc 0) (nReturn i)\n  Cable n nSend recv\n\ngoal (1 subgoal):\n 1. msg (Suc 0) (nStore i)", "apply (simp (no_asm) add: msg_def, simp add: Cable_def, clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>\\<forall>i<n.\n                   FlexRayController (nReturn i) recv (nC i) (nStore i)\n                    (nSend i) (nGet i);\n        DisjointSchedules n nC; IdenticCycleLength n nC; inf_disj n nSend;\n        i < n; \\<forall>i<n. msg (Suc 0) (nReturn i);\n        \\<forall>i<n.\n           FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i)\n            (nGet i);\n        DisjointSchedules n nC; IdenticCycleLength n nC; inf_disj n nSend;\n        i < n; \\<forall>i<n. msg (Suc 0) (nReturn i); Cable n nSend recv;\n        CorrectSheaf n; Broadcast n nSend recv\\<rbrakk>\n       \\<Longrightarrow> length (nStore i t) \\<le> Suc 0", "by (simp add: length_nStore)"], ["", "subsection \\<open>Refinement Properties\\<close>"], ["", "lemma fr_refinement_FrameTransmission:\nassumes \"Cable n nSend recv\"\n       and \"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\" \n       and \"DisjointSchedules n nC\"\n       and \"IdenticCycleLength n nC\" \nshows \"FrameTransmission n nStore nReturn nGet nC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FrameTransmission n nStore nReturn nGet nC", "using assms"], ["proof (prove)\nusing this:\n  Cable n nSend recv\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n\ngoal (1 subgoal):\n 1. FrameTransmission n nStore nReturn nGet nC", "apply (simp add: FrameTransmission_def Let_def, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>t k.\n       \\<lbrakk>Cable n nSend recv;\n        \\<forall>i<n.\n           FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i)\n            (nGet i);\n        DisjointSchedules n nC; IdenticCycleLength n nC; k < n;\n        t mod cycleLength (nC k) mem schedule (nC k)\\<rbrakk>\n       \\<Longrightarrow> nGet k t = [t mod cycleLength (nC k)]\n 2. \\<And>t k j.\n       \\<lbrakk>Cable n nSend recv;\n        \\<forall>i<n.\n           FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i)\n            (nGet i);\n        DisjointSchedules n nC; IdenticCycleLength n nC; k < n;\n        t mod cycleLength (nC k) mem schedule (nC k); j < n;\n        j \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> nStore j t = nReturn k t", "apply (simp add: fr_nGet1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t k j.\n       \\<lbrakk>Cable n nSend recv;\n        \\<forall>i<n.\n           FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i)\n            (nGet i);\n        DisjointSchedules n nC; IdenticCycleLength n nC; k < n;\n        t mod cycleLength (nC k) mem schedule (nC k); j < n;\n        j \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> nStore j t = nReturn k t", "by (simp add: fr_nStore_nReturn3)"], ["", "lemma FlexRayArch_CorrectSheaf:\n assumes \"FlexRayArch n nReturn nC nStore nGet\"\n shows    \"CorrectSheaf n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CorrectSheaf n", "using assms"], ["proof (prove)\nusing this:\n  FlexRayArch n nReturn nC nStore nGet\n\ngoal (1 subgoal):\n 1. CorrectSheaf n", "by (simp add: FlexRayArch_def)"], ["", "lemma FlexRayArch_FrameTransmission:\n assumes h1:\"FlexRayArch n nReturn nC nStore nGet\"\n     and h2:\"\\<forall>i<n. msg (Suc 0) (nReturn i)\"\n     and h3:\"DisjointSchedules n nC\"\n     and h4:\"IdenticCycleLength n nC\"\n shows      \"FrameTransmission n nStore nReturn nGet nC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FrameTransmission n nStore nReturn nGet nC", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. FrameTransmission n nStore nReturn nGet nC", "from assms"], ["proof (chain)\npicking this:\n  FlexRayArch n nReturn nC nStore nGet\n  \\<forall>i<n. msg (Suc 0) (nReturn i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC", "obtain nSend recv where\n    a1:\"Cable n nSend recv\" and \n    a2:\"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\""], ["proof (prove)\nusing this:\n  FlexRayArch n nReturn nC nStore nGet\n  \\<forall>i<n. msg (Suc 0) (nReturn i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n\ngoal (1 subgoal):\n 1. (\\<And>nSend recv.\n        \\<lbrakk>Cable n nSend recv;\n         \\<forall>i<n.\n            FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i)\n             (nGet i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: FlexRayArch_def  FlexRayArchitecture_def, auto)"], ["proof (state)\nthis:\n  Cable n nSend recv\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n\ngoal (1 subgoal):\n 1. FrameTransmission n nStore nReturn nGet nC", "from a1 and a2 and h3 and h4"], ["proof (chain)\npicking this:\n  Cable n nSend recv\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC", "show ?thesis"], ["proof (prove)\nusing this:\n  Cable n nSend recv\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n\ngoal (1 subgoal):\n 1. FrameTransmission n nStore nReturn nGet nC", "by (rule fr_refinement_FrameTransmission)"], ["proof (state)\nthis:\n  FrameTransmission n nStore nReturn nGet nC\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma FlexRayArch_nGet:\n assumes h1:\"FlexRayArch n nReturn nC nStore nGet\"\n     and h2:\"\\<forall>i<n. msg (Suc 0) (nReturn i)\"\n     and h3:\"DisjointSchedules n nC\"\n     and h4:\"IdenticCycleLength n nC\"\n     and h5:\"i < n\"\n shows      \"msg (Suc 0) (nGet i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msg (Suc 0) (nGet i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. msg (Suc 0) (nGet i)", "from assms"], ["proof (chain)\npicking this:\n  FlexRayArch n nReturn nC nStore nGet\n  \\<forall>i<n. msg (Suc 0) (nReturn i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  i < n", "obtain nSend recv where\n    a1:\"Cable n nSend recv\" and \n    a2:\"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\""], ["proof (prove)\nusing this:\n  FlexRayArch n nReturn nC nStore nGet\n  \\<forall>i<n. msg (Suc 0) (nReturn i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  i < n\n\ngoal (1 subgoal):\n 1. (\\<And>nSend recv.\n        \\<lbrakk>Cable n nSend recv;\n         \\<forall>i<n.\n            FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i)\n             (nGet i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: FlexRayArch_def  FlexRayArchitecture_def, auto)"], ["proof (state)\nthis:\n  Cable n nSend recv\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n\ngoal (1 subgoal):\n 1. msg (Suc 0) (nGet i)", "from a2 and h5"], ["proof (chain)\npicking this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  i < n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  i < n\n\ngoal (1 subgoal):\n 1. msg (Suc 0) (nGet i)", "by (rule msg_nGet2)"], ["proof (state)\nthis:\n  msg (Suc 0) (nGet i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma FlexRayArch_nStore:\n assumes h1:\"FlexRayArch n nReturn nC nStore nGet\"\n     and h2:\"\\<forall>i<n. msg (Suc 0) (nReturn i)\"\n     and h3:\"DisjointSchedules n nC\"\n     and h4:\"IdenticCycleLength n nC\"\n     and h5:\"i < n\"\n shows      \"msg (Suc 0) (nStore i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msg (Suc 0) (nStore i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. msg (Suc 0) (nStore i)", "from assms"], ["proof (chain)\npicking this:\n  FlexRayArch n nReturn nC nStore nGet\n  \\<forall>i<n. msg (Suc 0) (nReturn i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  i < n", "obtain nSend recv where\n    a1:\"Cable n nSend recv\" and \n    a2:\"\\<forall>i<n. FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\""], ["proof (prove)\nusing this:\n  FlexRayArch n nReturn nC nStore nGet\n  \\<forall>i<n. msg (Suc 0) (nReturn i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  i < n\n\ngoal (1 subgoal):\n 1. (\\<And>nSend recv.\n        \\<lbrakk>Cable n nSend recv;\n         \\<forall>i<n.\n            FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i)\n             (nGet i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: FlexRayArch_def  FlexRayArchitecture_def, auto)"], ["proof (state)\nthis:\n  Cable n nSend recv\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n\ngoal (1 subgoal):\n 1. msg (Suc 0) (nStore i)", "from h3 and h4 and a2"], ["proof (chain)\npicking this:\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)", "have sg1:\"inf_disj n nSend\""], ["proof (prove)\nusing this:\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n\ngoal (1 subgoal):\n 1. inf_disj n nSend", "by (simp add: disjointFrame_L2)"], ["proof (state)\nthis:\n  inf_disj n nSend\n\ngoal (1 subgoal):\n 1. msg (Suc 0) (nStore i)", "from a2 and h3 and h4 and sg1 and h5 and h2 and a1"], ["proof (chain)\npicking this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  inf_disj n nSend\n  i < n\n  \\<forall>i<n. msg (Suc 0) (nReturn i)\n  Cable n nSend recv", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i<n.\n     FlexRayController (nReturn i) recv (nC i) (nStore i) (nSend i) (nGet i)\n  DisjointSchedules n nC\n  IdenticCycleLength n nC\n  inf_disj n nSend\n  i < n\n  \\<forall>i<n. msg (Suc 0) (nReturn i)\n  Cable n nSend recv\n\ngoal (1 subgoal):\n 1. msg (Suc 0) (nStore i)", "by (rule msg_nStore)"], ["proof (state)\nthis:\n  msg (Suc 0) (nStore i)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem main_fr_refinement:\n assumes \"FlexRayArch n nReturn nC nStore nGet\"\n shows     \"FlexRay n nReturn nC nStore nGet\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FlexRay n nReturn nC nStore nGet", "using assms"], ["proof (prove)\nusing this:\n  FlexRayArch n nReturn nC nStore nGet\n\ngoal (1 subgoal):\n 1. FlexRay n nReturn nC nStore nGet", "by (simp add: FlexRay_def\n                FlexRayArch_CorrectSheaf \n                FlexRayArch_FrameTransmission \n                FlexRayArch_nGet \n                FlexRayArch_nStore)"], ["", "end"]]}