{"file_name": "/home/qj213/afp-2021-10-22/thys/Gabow_SCC/Gabow_Skeleton.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Gabow_SCC", "problem_names": ["lemma [autoref_rules]: \n  \"(stat_newnode,stat_newnode) \\<in> unit_rel \\<rightarrow> unit_rel\"\n  \"(stat_start,stat_start) \\<in> unit_rel \\<rightarrow> unit_rel\"\n  \"(stat_stop,stat_stop) \\<in> unit_rel \\<rightarrow> unit_rel\"", "lemma discard_stat_refine[refine]:\n  \"m1\\<le>m2 \\<Longrightarrow> stat_newnode_nres \\<then> m1 \\<le> m2\"\n  \"m1\\<le>m2 \\<Longrightarrow> stat_start_nres \\<then> m1 \\<le> m2\"\n  \"m1\\<le>m2 \\<Longrightarrow> stat_stop_nres \\<then> m1 \\<le> m2\"", "lemma path_seg_simps[simp]: \n  \"j\\<le>i \\<Longrightarrow> path_seg p i j = {}\"\n  \"path_seg p i (Suc i) = p!i\"", "lemma path_seg_drop:\n  \"\\<Union>(set (drop i p)) = path_seg p i (length p)\"", "lemma path_seg_butlast: \n  \"p\\<noteq>[] \\<Longrightarrow> path_seg p 0 (length p - Suc 0) = \\<Union>(set (butlast p))\"", "lemma idx_of_props:\n  assumes \n    p_disjoint_sym: \"\\<forall>i j v. i<length p \\<and> j<length p \\<and> v\\<in>p!i \\<and> v\\<in>p!j \\<longrightarrow> i=j\"\n  assumes ON_STACK: \"v\\<in>\\<Union>(set p)\"\n  shows \n    \"idx_of p v < length p\" and\n    \"v \\<in> p ! idx_of p v\"", "lemma idx_of_uniq:\n  assumes \n    p_disjoint_sym: \"\\<forall>i j v. i<length p \\<and> j<length p \\<and> v\\<in>p!i \\<and> v\\<in>p!j \\<longrightarrow> i=j\"\n  assumes A: \"i<length p\" \"v\\<in>p!i\"\n  shows \"idx_of p v = i\"", "lemma vE_ss_E: \"vE p D pE \\<subseteq> E\" \\<comment> \\<open>Visited edges are edges\\<close>", "lemma locale_this: \"outer_invar_loc G it D\"", "lemma outer_invar_this[simp, intro!]: \"outer_invar it D\"", "lemma locale_this: \"invar_loc G v0 D0 p D pE\"", "lemma invar_this[simp, intro!]: \"invar v0 D0 (p,D,pE)\"", "lemma finite_reachableE_v0[simp, intro!]: \"finite (E\\<^sup>*``{v0})\"", "lemma D_vis: \"E\\<inter>D\\<times>UNIV \\<subseteq> lvE\" \\<comment> \\<open>All edges from done nodes are visited\\<close>", "lemma vE_touched: \"lvE \\<subseteq> ltouched \\<times> ltouched\" \n    \\<comment> \\<open>Visited edges only between touched nodes\\<close>", "lemma lvE_ss_E: \"lvE \\<subseteq> E\" \\<comment> \\<open>Visited edges are edges\\<close>", "lemma path_touched: \"\\<Union>(set p) \\<subseteq> ltouched\"", "lemma D_touched: \"D \\<subseteq> ltouched\"", "lemma pE_by_vE: \"pE = (E \\<inter> \\<Union>(set p) \\<times> UNIV) - lvE\"\n    \\<comment> \\<open>Pending edges are edges from path not yet visited\\<close>", "lemma pick_pending: \"p\\<noteq>[] \\<Longrightarrow> pE \\<inter> last p \\<times> UNIV = (E-lvE) \\<inter> last p \\<times> UNIV\"\n    \\<comment> \\<open>Pending edges from end of path are non-visited edges from end of path\\<close>", "lemma p_connected': \n    assumes A: \"Suc i<length p\" \n    shows \"p!i \\<times> p!Suc i \\<inter> lvE \\<noteq> {}\"", "lemma abs_wf_rel_wf[simp, intro!]: \"wf (abs_wf_rel v0)\"", "lemma \"select_edge (p,D,pE) \\<equiv> do {\n      e \\<leftarrow> SELECT (\\<lambda>e. e \\<in> pE \\<inter> last p \\<times> UNIV);\n      case e of\n        None \\<Rightarrow> RETURN (None,(p,D,pE))\n      | Some (u,v) \\<Rightarrow> RETURN (Some v, (p,D,pE - {(u,v)}))\n    }\"", "lemma \"collapse v (p,D,pE) \n    \\<equiv> let i=idx_of p v in (take i p @ [\\<Union>(set (drop i p))],D,pE)\"", "lemma \"push v (p, D, pE) \\<equiv> (p @ [{v}], D, pE \\<union> E \\<inter> {v} \\<times> UNIV)\"", "lemma \"pop (p, D, pE) \\<equiv> (butlast p, last p \\<union> D, pE)\"", "lemma set_collapse_aux[simp]: \"\\<Union>(set (collapse_aux p i)) = \\<Union>(set p)\"", "lemma touched_collapse[simp]: \"touched (collapse_aux p i) D = touched p D\"", "lemma vE_collapse_aux[simp]: \"vE (collapse_aux p i) D pE = vE p D pE\"", "lemma touched_push[simp]: \"touched (p @ [V]) D = touched p D \\<union> V\"", "lemma cnode_connectedI: \n    \"\\<lbrakk>i<length p; u\\<in>p!i; v\\<in>p!i\\<rbrakk> \\<Longrightarrow> (u,v)\\<in>(lvE \\<inter> p!i\\<times>p!i)\\<^sup>*\"", "lemma cnode_connectedI': \"\\<lbrakk>i<length p; u\\<in>p!i; v\\<in>p!i\\<rbrakk> \\<Longrightarrow> (u,v)\\<in>(lvE)\\<^sup>*\"", "lemma p_no_empty: \"{} \\<notin> set p\"", "lemma p_disjoint_sym: \"\\<lbrakk>i<length p; j<length p; v\\<in>p!i; v\\<in>p!j\\<rbrakk> \\<Longrightarrow> i=j\"", "lemma pi_ss_path_seg_eq[simp]:\n    assumes A: \"i<length p\" \"u\\<le>length p\"\n    shows \"p!i\\<subseteq>path_seg p l u \\<longleftrightarrow> l\\<le>i \\<and> i<u\"", "lemma path_seg_ss_eq[simp]:\n    assumes A: \"l1<u1\" \"u1\\<le>length p\" \"l2<u2\" \"u2\\<le>length p\"\n    shows \"path_seg p l1 u1 \\<subseteq> path_seg p l2 u2 \\<longleftrightarrow> l2\\<le>l1 \\<and> u1\\<le>u2\"", "lemma pathI: \n    assumes \"x\\<in>p!i\" \"y\\<in>p!j\"\n    assumes \"i\\<le>j\" \"j<length p\"\n    defines \"seg \\<equiv> path_seg p i (Suc j)\"\n    shows \"(x,y)\\<in>(lvE \\<inter> seg\\<times>seg)\\<^sup>*\"\n    \\<comment> \\<open>We can obtain a path between cnodes on path\\<close>", "lemma p_reachable: \"\\<Union>(set p) \\<subseteq> E\\<^sup>*``{v0}\" \\<comment> \\<open>Nodes on path are reachable\\<close>", "lemma touched_reachable: \"ltouched \\<subseteq> E\\<^sup>*``V0\" \\<comment> \\<open>Touched nodes are reachable\\<close>", "lemma vE_reachable: \"lvE \\<subseteq> E\\<^sup>*``V0 \\<times> E\\<^sup>*``V0\"", "lemma pE_reachable: \"pE \\<subseteq> E\\<^sup>*``{v0} \\<times> E\\<^sup>*``{v0}\"", "lemma D_closed_vE_rtrancl: \"lvE\\<^sup>*``D \\<subseteq> D\"", "lemma D_closed_path: \"\\<lbrakk>path E u q w; u\\<in>D\\<rbrakk> \\<Longrightarrow> set q \\<subseteq> D\"", "lemma D_closed_path_vE: \"\\<lbrakk>path lvE u q w; u\\<in>D\\<rbrakk> \\<Longrightarrow> set q \\<subseteq> D\"", "lemma path_in_lastnode:\n    assumes P: \"path lvE u q v\"\n    assumes [simp]: \"p\\<noteq>[]\"\n    assumes ND: \"u\\<in>last p\" \"v\\<in>last p\"\n    shows \"set q \\<subseteq> last p\"\n    \\<comment> \\<open>A path from the last Cnode to the last Cnode remains in the last Cnode\\<close>", "lemma loop_in_lastnode:\n    assumes P: \"path lvE u q u\"\n    assumes [simp]: \"p\\<noteq>[]\"\n    assumes ND: \"set q \\<inter> last p \\<noteq> {}\"\n    shows \"u\\<in>last p\" and \"set q \\<subseteq> last p\"\n    \\<comment> \\<open>A loop that touches the last node is completely inside the last node\\<close>", "lemma no_D_p_edges: \"E \\<inter> D \\<times> \\<Union>(set p) = {}\"", "lemma idx_of_props:\n    assumes ON_STACK: \"v\\<in>\\<Union>(set p)\"\n    shows \n      \"idx_of p v < length p\" and\n      \"v \\<in> p ! idx_of p v\"", "lemma (in fr_graph) vE_initial[simp]: \"vE [{v0}] {} (E \\<inter> {v0} \\<times> UNIV) = {}\"", "lemma vE_push: \"\\<lbrakk> (u,v)\\<in>pE; u\\<in>last p; v\\<notin>\\<Union>(set p); v\\<notin>D \\<rbrakk> \n    \\<Longrightarrow> vE (p @ [{v}]) D ((pE - {(u,v)}) \\<union> E\\<inter>{v}\\<times>UNIV) = insert (u,v) lvE\"", "lemma vE_remove[simp]: \n    \"\\<lbrakk>p\\<noteq>[]; (u,v)\\<in>pE\\<rbrakk> \\<Longrightarrow> vE p D (pE - {(u,v)}) = insert (u,v) lvE\"", "lemma vE_pop[simp]: \"p\\<noteq>[] \\<Longrightarrow> vE (butlast p) (last p \\<union> D) pE = lvE\"", "lemma pE_fin: \"p=[] \\<Longrightarrow> pE={}\"", "lemma (in invar_loc) lastp_un_D_closed:\n    assumes NE: \"p \\<noteq> []\"\n    assumes NO': \"pE \\<inter> (last p \\<times> UNIV) = {}\"\n    shows \"E``(last p \\<union> D) \\<subseteq> (last p \\<union> D)\"\n    \\<comment> \\<open>On pop, the popped CNode and D are closed under transitions\\<close>", "lemma (in outer_invar_loc) invar_initial_aux: \n    assumes \"v0\\<in>it - D\"\n    shows \"invar v0 D (initial v0 D)\"", "lemma invar_initial: \n    \"\\<lbrakk>outer_invar it D0; v0\\<in>it; v0\\<notin>D0\\<rbrakk> \\<Longrightarrow> invar v0 D0 (initial v0 D0)\"", "lemma outer_invar_initial[simp, intro!]: \"outer_invar V0 {}\"", "lemma invar_pop:\n    assumes INV: \"invar v0 D0 (p,D,pE)\"\n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes NO': \"pE \\<inter> (last p \\<times> UNIV) = {}\"\n    shows \"invar v0 D0 (pop (p,D,pE))\"", "lemma invar_collapse:\n    assumes INV: \"invar v0 D0 (p,D,pE)\"\n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes E: \"(u,v)\\<in>pE\" and \"u\\<in>last p\"\n    assumes BACK: \"v\\<in>\\<Union>(set p)\"\n    defines \"i \\<equiv> idx_of p v\"\n    defines \"p' \\<equiv> collapse_aux p i\"\n    shows \"invar v0 D0 (collapse v (p,D,pE - {(u,v)}))\"", "lemma invar_push:\n    assumes INV: \"invar v0 D0 (p,D,pE)\"\n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes E: \"(u,v)\\<in>pE\" and UIL: \"u\\<in>last p\"\n    assumes VNE: \"v\\<notin>\\<Union>(set p)\" \"v\\<notin>D\"\n    shows \"invar v0 D0 (push v (p,D,pE - {(u,v)}))\"", "lemma invar_skip:\n    assumes INV: \"invar v0 D0 (p,D,pE)\"\n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes E: \"(u,v)\\<in>pE\" and UIL: \"u\\<in>last p\"\n    assumes VNP: \"v\\<notin>\\<Union>(set p)\" and VD: \"v\\<in>D\"\n    shows \"invar v0 D0 (p,D,pE - {(u, v)})\"", "lemma fin_D_is_reachable: \n    \\<comment> \\<open>When inner loop terminates, all nodes reachable from start node are\n      finished\\<close>\n    assumes INV: \"invar v0 D0 ([], D, pE)\"\n    shows \"D \\<supseteq> E\\<^sup>*``{v0}\"", "lemma fin_reachable_path: \n    \\<comment> \\<open>When inner loop terminates, nodes reachable from start node are\n      reachable over visited edges\\<close>\n    assumes INV: \"invar v0 D0 ([], D, pE)\"\n    assumes UR: \"u\\<in>E\\<^sup>*``{v0}\"\n    shows \"path (vE [] D pE) u q v \\<longleftrightarrow> path E u q v\"", "lemma invar_outer_newnode: \n    assumes A: \"v0\\<notin>D0\" \"v0\\<in>it\" \n    assumes OINV: \"outer_invar it D0\"\n    assumes INV: \"invar v0 D0 ([],D',pE)\"\n    shows \"outer_invar (it-{v0}) D'\"", "lemma invar_outer_Dnode:\n    assumes A: \"v0\\<in>D0\" \"v0\\<in>it\" \n    assumes OINV: \"outer_invar it D0\"\n    shows \"outer_invar (it-{v0}) D0\"", "lemma pE_fin': \"invar x \\<sigma> ([], D, pE) \\<Longrightarrow> pE={}\"", "lemma unproc_finite[simp, intro!]: \"finite (unproc_edges v0 p D pE)\"\n    \\<comment> \\<open>The set of unprocessed edges is finite\\<close>", "lemma unproc_decreasing: \n    \\<comment> \\<open>As effect of selecting a pending edge, the set of unprocessed edges\n      decreases\\<close>\n    assumes [simp]: \"p\\<noteq>[]\" and A: \"(u,v)\\<in>pE\" \"u\\<in>last p\"\n    shows \"unproc_edges v0 p D (pE-{(u,v)}) \\<subset> unproc_edges v0 p D pE\"", "lemma abs_wf_pop:\n    assumes INV: \"invar v0 D0 (p,D,pE)\"\n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes NO: \"pE \\<inter> last aba \\<times> UNIV = {}\"\n    shows \"(pop (p,D,pE), (p, D, pE)) \\<in> abs_wf_rel v0\"", "lemma abs_wf_collapse:\n    assumes INV: \"invar v0 D0 (p,D,pE)\"\n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes E: \"(u,v)\\<in>pE\" \"u\\<in>last p\"\n    shows \"(collapse v (p,D,pE-{(u,v)}), (p, D, pE))\\<in> abs_wf_rel v0\"", "lemma abs_wf_push:\n    assumes INV: \"invar v0 D0 (p,D,pE)\"\n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes E: \"(u,v)\\<in>pE\" \"u\\<in>last p\" and A: \"v\\<notin>D\" \"v\\<notin>\\<Union>(set p)\"\n    shows \"(push v (p,D,pE-{(u,v)}), (p, D, pE)) \\<in> abs_wf_rel v0\"", "lemma abs_wf_skip:\n    assumes INV: \"invar v0 D0 (p,D,pE)\"\n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes E: \"(u,v)\\<in>pE\" \"u\\<in>last p\"\n    shows \"((p, D, pE-{(u,v)}), (p, D, pE)) \\<in> abs_wf_rel v0\"", "lemmas invar_preserve = \n    invar_initial\n    invar_pop invar_push invar_skip invar_collapse \n    abs_wf_pop abs_wf_collapse abs_wf_push abs_wf_skip \n    outer_invar_initial invar_outer_newnode invar_outer_Dnode", "theorem skeleton_spec: \"skeleton \\<le> SPEC (\\<lambda>D. outer_invar {} D)\"", "theorem \"skeleton \\<le> SPEC (\\<lambda>D. outer_invar {} D)\"", "lemma fin_outer_D_is_reachable:\n    \\<comment> \\<open>When outer loop terminates, exactly the reachable nodes are finished\\<close>\n    assumes INV: \"outer_invar {} D\"\n    shows \"D = E\\<^sup>*``V0\"", "lemma find_max_nat_correct: \n  \"\\<lbrakk>P 0; 0<u\\<rbrakk> \\<Longrightarrow> find_max_nat u P = Max {i. i<u \\<and> P i}\"", "lemma find_max_nat_param[param]:\n  assumes \"(n,n')\\<in>nat_rel\"\n  assumes \"\\<And>j j'. \\<lbrakk>(j,j')\\<in>nat_rel; j'<n'\\<rbrakk> \\<Longrightarrow> (P j,P' j')\\<in>bool_rel\"\n  shows \"(find_max_nat n P,find_max_nat n' P') \\<in> nat_rel\"", "lemma find_max_nat_autoref[autoref_rules]:\n    assumes \"(n,n')\\<in>nat_rel\"\n    assumes \"\\<And>j j'. \\<lbrakk>(j,j')\\<in>nat_rel; j'<n'\\<rbrakk> \\<Longrightarrow> (P j,P'$j')\\<in>bool_rel\"\n    shows \"(find_max_nat n P,\n        (OP find_max_nat ::: nat_rel \\<rightarrow> (nat_rel\\<rightarrow>bool_rel) \\<rightarrow> nat_rel) $n'$P'\n      ) \\<in> nat_rel\"", "lemma GS_sel_simps[simp]:\n  \"GS.S (S,B,I,P) = S\"\n  \"GS.B (S,B,I,P) = B\"\n  \"GS.I (S,B,I,P) = I\"\n  \"GS.P (S,B,I,P) = P\"", "lemma seg_start_indep[simp]: \"GS.seg_start (S',B,I',P') = seg_start\"", "lemma seg_end_indep[simp]: \"GS.seg_end (S,B,I',P') = seg_end\"", "lemma seg_indep[simp]: \"GS.seg (S,B,I',P') = seg\"", "lemma p_\\<alpha>_indep[simp]: \"GS.p_\\<alpha> (S,B,I',P') = p_\\<alpha>\"", "lemma D_\\<alpha>_indep[simp]: \"GS.D_\\<alpha> (S',B',I,P') = D_\\<alpha>\"", "lemma pE_\\<alpha>_indep[simp]: \"GS.pE_\\<alpha> (S,B',I',P) = pE_\\<alpha>\"", "lemma locale_this: \"GS_invar SBIP\"", "lemma oGS_rel_sv[intro!,simp,relator_props]: \"single_valued oGS_rel\"", "lemma GS_rel_sv[intro!,simp,relator_props]: \"single_valued GS_rel\"", "lemma empty_eq: \"S=[] \\<longleftrightarrow> B=[]\"", "lemma B_in_bound': \"i<length B \\<Longrightarrow> B!i < length S\"", "lemma seg_start_bound:\n    assumes A: \"i<length B\" shows \"seg_start i < length S\"", "lemma seg_end_bound:\n    assumes A: \"i<length B\" shows \"seg_end i \\<le> length S\"", "lemma seg_start_less_end: \"i<length B \\<Longrightarrow> seg_start i < seg_end i\"", "lemma seg_end_less_start: \"\\<lbrakk>i<j; j<length B\\<rbrakk> \\<Longrightarrow> seg_end i \\<le> seg_start j\"", "lemma find_seg_bounds:\n    assumes A: \"j<length S\"\n    shows \"seg_start (find_seg j) \\<le> j\" \n    and \"j < seg_end (find_seg j)\" \n    and \"find_seg j < length B\"", "lemma find_seg_correct:\n    assumes A: \"j<length S\"\n    shows \"S!j \\<in> seg (find_seg j)\" and \"find_seg j < length B\"", "lemma set_p_\\<alpha>_is_set_S:\n    \"\\<Union>(set p_\\<alpha>) = set S\"", "lemma S_idx_uniq: \n    \"\\<lbrakk>i<length S; j<length S\\<rbrakk> \\<Longrightarrow> S!i=S!j \\<longleftrightarrow> i=j\"", "lemma S_idx_of_correct: \n    assumes A: \"v\\<in>\\<Union>(set p_\\<alpha>)\"\n    shows \"S_idx_of v < length S\" and \"S!S_idx_of v = v\"", "lemma p_\\<alpha>_disjoint_sym: \n    shows \"\\<forall>i j v. i<length p_\\<alpha> \\<and> j<length p_\\<alpha> \\<and> v\\<in>p_\\<alpha>!i \\<and> v\\<in>p_\\<alpha>!j \\<longrightarrow> i=j\"", "lemma mark_as_done_aux:\n    fixes l u I\n    shows \"\\<lbrakk>l<u; u\\<le>length S\\<rbrakk> \\<Longrightarrow> mark_as_done l u I \n    \\<le> SPEC (\\<lambda>r. r = mark_as_done_abs l u I)\"", "lemma (in GS_invar) find_seg_impl:\n    \"j<length S \\<Longrightarrow> find_seg_impl j = find_seg j\"", "lemma (in -) GS_initial_correct: \n  assumes REL: \"(I,D)\\<in>oGS_rel\"\n  assumes A: \"v0\\<notin>D\"\n  shows \"GS.\\<alpha> (GS_initial_impl I v0 succs) = ([{v0}],D,{v0}\\<times>succs)\" (is ?G1)\n  and \"GS_invar (GS_initial_impl I v0 succs)\" (is ?G2)", "lemma push_correct:\n    assumes A: \"v\\<notin>\\<Union>(set p_\\<alpha>)\" and B: \"v\\<notin>D_\\<alpha>\"\n    shows \"GS.\\<alpha> (push_impl v succs) = (p_\\<alpha>@[{v}],D_\\<alpha>,pE_\\<alpha> \\<union> {v}\\<times>succs)\" \n      (is ?G1)\n    and \"GS_invar (push_impl v succs)\" (is ?G2)", "lemma no_last_out_P_aux:\n    assumes NE: \"p_\\<alpha>\\<noteq>[]\" and NS: \"pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {}\"\n    shows \"set P \\<subseteq> {0..<last B} \\<times> UNIV\"", "lemma pop_correct:\n    assumes NE: \"p_\\<alpha>\\<noteq>[]\" and NS: \"pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {}\"\n    shows \"pop_impl \n      \\<le> \\<Down>GS_rel (SPEC (\\<lambda>r. r=(butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>, pE_\\<alpha>)))\"", "lemma sel_rem_last_correct:\n    assumes NE: \"p_\\<alpha>\\<noteq>[]\"\n    shows\n    \"sel_rem_last \\<le> \\<Down>(Id \\<times>\\<^sub>r GS_rel) (select_edge (p_\\<alpha>,D_\\<alpha>,pE_\\<alpha>))\"", "lemma find_seg_idx_of_correct:\n    assumes A: \"v\\<in>\\<Union>(set p_\\<alpha>)\"\n    shows \"(find_seg (S_idx_of v)) = idx_of p_\\<alpha> v\"", "lemma idx_of_correct:\n    assumes A: \"v\\<in>\\<Union>(set p_\\<alpha>)\"\n    shows \"idx_of_impl v \\<le> SPEC (\\<lambda>x. x=idx_of p_\\<alpha> v \\<and> x<length B)\"", "lemma collapse_correct:\n    assumes A: \"v\\<in>\\<Union>(set p_\\<alpha>)\"\n    shows \"collapse_impl v \\<le>\\<Down>GS_rel (SPEC (\\<lambda>r. r=collapse v \\<alpha>))\"", "lemma opt_GSdef: \"f \\<equiv> g \\<Longrightarrow> f s \\<equiv> case s of (S,B,I,P) \\<Rightarrow> g (S,B,I,P)\"", "lemma ext_def: \"f\\<equiv>g \\<Longrightarrow> f x \\<equiv> g x\"", "lemmas push_impl_def_opt = \n    push_impl_def[abs_def, \n    THEN ext_def, THEN opt_GSdef, unfolded GS.push_impl_def GS_sel_simps]", "lemma \"push_impl v (S,B,I,P) \\<equiv> (S@[v], B@[length S], I(v\\<mapsto>STACK (length S)),\n    if E``{v}={} then P else P@[(length S,E``{v})])\"", "lemma GS_\\<alpha>_split: \n    \"GS.\\<alpha> s = (p,D,pE) \\<longleftrightarrow> (p=GS.p_\\<alpha> s \\<and> D=GS.D_\\<alpha> s \\<and> pE=GS.pE_\\<alpha> s)\"\n    \"(p,D,pE) = GS.\\<alpha> s \\<longleftrightarrow> (p=GS.p_\\<alpha> s \\<and> D=GS.D_\\<alpha> s \\<and> pE=GS.pE_\\<alpha> s)\"", "lemma push_refine:\n    assumes A: \"(s,(p,D,pE))\\<in>GS_rel\" \"(v,v')\\<in>Id\"\n    assumes B: \"v\\<notin>\\<Union>(set p)\" \"v\\<notin>D\"\n    shows \"(push_impl v s, push v' (p,D,pE))\\<in>GS_rel\"", "lemmas pop_impl_def_opt = \n    pop_impl_def[abs_def, THEN opt_GSdef, unfolded GS.pop_impl_def\n    GS.mark_as_done_def GS.seg_start_def GS.seg_end_def \n    GS_sel_simps]", "lemma pop_refine:\n    assumes A: \"(s,(p,D,pE))\\<in>GS_rel\"\n    assumes B: \"p \\<noteq> []\" \"pE \\<inter> last p \\<times> UNIV = {}\"\n    shows \"pop_impl s \\<le> \\<Down>GS_rel (RETURN (pop (p,D,pE)))\"", "lemmas collapse_impl_def_opt = \n    collapse_impl_def[abs_def, \n    THEN ext_def, THEN opt_GSdef, unfolded GS.collapse_impl_def GS_sel_simps]", "lemma collapse_refine:\n    assumes A: \"(s,(p,D,pE))\\<in>GS_rel\" \"(v,v')\\<in>Id\"\n    assumes B: \"v'\\<in>\\<Union>(set p)\"\n    shows \"collapse_impl v s \\<le>\\<Down>GS_rel (RETURN (collapse v' (p,D,pE)))\"", "lemmas select_edge_impl_def_opt = \n    select_edge_impl_def[abs_def, \n      THEN opt_GSdef, \n      unfolded GS.sel_rem_last_def GS.seg_start_def GS_sel_simps]", "lemma select_edge_refine: \n    assumes A: \"(s,(p,D,pE))\\<in>GS_rel\"\n    assumes NE: \"p \\<noteq> []\"\n    shows \"select_edge_impl s \\<le> \\<Down>(Id \\<times>\\<^sub>r GS_rel) (select_edge (p,D,pE))\"", "lemma initial_refine:\n    \"\\<lbrakk>v0\\<notin>D0; (I,D0)\\<in>oGS_rel; (v0i,v0)\\<in>Id\\<rbrakk> \n    \\<Longrightarrow> (initial_impl v0i I,initial v0 D0)\\<in>GS_rel\"", "lemma path_is_empty_refine: \n    \"GS_invar s \\<Longrightarrow> path_is_empty_impl s \\<longleftrightarrow> GS.p_\\<alpha> s=[]\"", "lemma (in GS_invar) is_on_stack_impl_correct:\n    shows \"is_on_stack_impl v \\<longleftrightarrow> v\\<in>\\<Union>(set p_\\<alpha>)\"", "lemmas is_on_stack_impl_def_opt = \n    is_on_stack_impl_def[abs_def, THEN ext_def, THEN opt_GSdef, \n      unfolded GS.is_on_stack_impl_def GS_sel_simps]", "lemma is_on_stack_refine:\n    \"\\<lbrakk> GS_invar s \\<rbrakk> \\<Longrightarrow> is_on_stack_impl v s \\<longleftrightarrow> v\\<in>\\<Union>(set (GS.p_\\<alpha> s))\"", "lemma (in GS_invar) is_done_impl_correct:\n    shows \"is_done_impl v \\<longleftrightarrow> v\\<in>D_\\<alpha>\"", "lemma is_done_orefine:\n    \"\\<lbrakk> oGS_invar s \\<rbrakk> \\<Longrightarrow> is_done_oimpl v s \\<longleftrightarrow> v\\<in>oGS_\\<alpha> s\"", "lemma is_done_refine:\n    \"\\<lbrakk> GS_invar s \\<rbrakk> \\<Longrightarrow> is_done_impl v s \\<longleftrightarrow> v\\<in>GS.D_\\<alpha> s\"", "lemma oinitial_refine: \"(Map.empty, {}) \\<in> oGS_rel\"", "lemma I_to_outer:\n    assumes \"((S, B, I, P), ([], D, {})) \\<in> GS_rel\"\n    shows \"(I,D)\\<in>oGS_rel\"", "lemma \"skeleton_impl \\<le> \\<Down>oGS_rel skeleton\"", "lemmas skeleton_refines \n    = select_edge_refine push_refine pop_refine collapse_refine \n      initial_refine oinitial_refine", "lemmas skeleton_refine_simps \n    = GS_rel_def br_def GS.\\<alpha>_def oGS_rel_def oGS_\\<alpha>_def \n      is_on_stack_refine path_is_empty_refine is_done_refine is_done_orefine", "lemma \"skeleton_impl \\<le> \\<Down>oGS_rel skeleton\""], "translations": [["", "lemma [autoref_rules]: \n  \"(stat_newnode,stat_newnode) \\<in> unit_rel \\<rightarrow> unit_rel\"\n  \"(stat_start,stat_start) \\<in> unit_rel \\<rightarrow> unit_rel\"\n  \"(stat_stop,stat_stop) \\<in> unit_rel \\<rightarrow> unit_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (stat_newnode, stat_newnode) \\<in> unit_rel \\<rightarrow> unit_rel &&&\n    (stat_start, stat_start) \\<in> unit_rel \\<rightarrow> unit_rel &&&\n    (stat_stop, stat_stop) \\<in> unit_rel \\<rightarrow> unit_rel", "by auto"], ["", "abbreviation \"stat_newnode_nres \\<equiv> RETURN (stat_newnode ())\""], ["", "abbreviation \"stat_start_nres \\<equiv> RETURN (stat_start ())\""], ["", "abbreviation \"stat_stop_nres \\<equiv> RETURN (stat_stop ())\""], ["", "lemma discard_stat_refine[refine]:\n  \"m1\\<le>m2 \\<Longrightarrow> stat_newnode_nres \\<then> m1 \\<le> m2\"\n  \"m1\\<le>m2 \\<Longrightarrow> stat_start_nres \\<then> m1 \\<le> m2\"\n  \"m1\\<le>m2 \\<Longrightarrow> stat_stop_nres \\<then> m1 \\<le> m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m1 \\<le> m2 \\<Longrightarrow>\n     stat_newnode_nres \\<bind> (\\<lambda>_. m1) \\<le> m2) &&&\n    (m1 \\<le> m2 \\<Longrightarrow>\n     stat_start_nres \\<bind> (\\<lambda>_. m1) \\<le> m2) &&&\n    (m1 \\<le> m2 \\<Longrightarrow>\n     stat_stop_nres \\<bind> (\\<lambda>_. m1) \\<le> m2)", "by simp_all"], ["", "section \\<open>Abstract Algorithm\\<close>"], ["", "text \\<open>\n  In this section, we formalize an abstract version of a path-based SCC algorithm.\n  Later, this algorithm will be refined to use Gabow's data structure.\n\\<close>"], ["", "subsection \\<open>Preliminaries\\<close>"], ["", "definition path_seg :: \"'a set list \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> 'a set\"\n  \\<comment> \\<open>Set of nodes in a segment of the path\\<close>\n  where \"path_seg p i j \\<equiv> \\<Union>{p!k|k. i\\<le>k \\<and> k<j}\""], ["", "lemma path_seg_simps[simp]: \n  \"j\\<le>i \\<Longrightarrow> path_seg p i j = {}\"\n  \"path_seg p i (Suc i) = p!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (j \\<le> i \\<Longrightarrow> path_seg p i j = {}) &&&\n    path_seg p i (Suc i) = p ! i", "unfolding path_seg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (j \\<le> i \\<Longrightarrow>\n     \\<Union> {p ! k |k. i \\<le> k \\<and> k < j} = {}) &&&\n    \\<Union> {p ! k |k. i \\<le> k \\<and> k < Suc i} = p ! i", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> {p ! k |k. i \\<le> k \\<and> k < Suc i} = p ! i", "apply (auto simp: le_less_Suc_eq) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma path_seg_drop:\n  \"\\<Union>(set (drop i p)) = path_seg p i (length p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set (drop i p)) = path_seg p i (length p)", "unfolding path_seg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set (drop i p)) =\n    \\<Union> {p ! k |k. i \\<le> k \\<and> k < length p}", "by (fastforce simp: in_set_drop_conv_nth Bex_def)"], ["", "lemma path_seg_butlast: \n  \"p\\<noteq>[] \\<Longrightarrow> path_seg p 0 (length p - Suc 0) = \\<Union>(set (butlast p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    path_seg p 0 (length p - Suc 0) = \\<Union> (set (butlast p))", "apply (cases p rule: rev_cases, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>p \\<noteq> []; p = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> path_seg p 0 (length p - Suc 0) =\n                         \\<Union> (set (butlast p))", "apply (fastforce simp: path_seg_def nth_append in_set_conv_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition idx_of :: \"'a set list \\<Rightarrow> 'a \\<Rightarrow> nat\"\n  \\<comment> \\<open>Index of path segment that contains a node\\<close>\n  where \"idx_of p v \\<equiv> THE i. i<length p \\<and> v\\<in>p!i\""], ["", "lemma idx_of_props:\n  assumes \n    p_disjoint_sym: \"\\<forall>i j v. i<length p \\<and> j<length p \\<and> v\\<in>p!i \\<and> v\\<in>p!j \\<longrightarrow> i=j\"\n  assumes ON_STACK: \"v\\<in>\\<Union>(set p)\"\n  shows \n    \"idx_of p v < length p\" and\n    \"v \\<in> p ! idx_of p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idx_of p v < length p &&& v \\<in> p ! idx_of p v", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. idx_of p v < length p\n 2. v \\<in> p ! idx_of p v", "from ON_STACK"], ["proof (chain)\npicking this:\n  v \\<in> \\<Union> (set p)", "obtain i where \"i<length p\" \"v \\<in> p ! i\""], ["proof (prove)\nusing this:\n  v \\<in> \\<Union> (set p)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length p; v \\<in> p ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length p\n  v \\<in> p ! i\n\ngoal (2 subgoals):\n 1. idx_of p v < length p\n 2. v \\<in> p ! idx_of p v", "moreover"], ["proof (state)\nthis:\n  i < length p\n  v \\<in> p ! i\n\ngoal (2 subgoals):\n 1. idx_of p v < length p\n 2. v \\<in> p ! idx_of p v", "hence \"\\<forall>j<length p. v\\<in>p ! j \\<longrightarrow> i=j\""], ["proof (prove)\nusing this:\n  i < length p\n  v \\<in> p ! i\n\ngoal (1 subgoal):\n 1. \\<forall>j<length p. v \\<in> p ! j \\<longrightarrow> i = j", "using p_disjoint_sym"], ["proof (prove)\nusing this:\n  i < length p\n  v \\<in> p ! i\n  \\<forall>i j v.\n     i < length p \\<and>\n     j < length p \\<and>\n     v \\<in> p ! i \\<and> v \\<in> p ! j \\<longrightarrow>\n     i = j\n\ngoal (1 subgoal):\n 1. \\<forall>j<length p. v \\<in> p ! j \\<longrightarrow> i = j", "by auto"], ["proof (state)\nthis:\n  \\<forall>j<length p. v \\<in> p ! j \\<longrightarrow> i = j\n\ngoal (2 subgoals):\n 1. idx_of p v < length p\n 2. v \\<in> p ! idx_of p v", "ultimately"], ["proof (chain)\npicking this:\n  i < length p\n  v \\<in> p ! i\n  \\<forall>j<length p. v \\<in> p ! j \\<longrightarrow> i = j", "show \"idx_of p v < length p\" \n    and \"v \\<in> p ! idx_of p v\""], ["proof (prove)\nusing this:\n  i < length p\n  v \\<in> p ! i\n  \\<forall>j<length p. v \\<in> p ! j \\<longrightarrow> i = j\n\ngoal (1 subgoal):\n 1. idx_of p v < length p &&& v \\<in> p ! idx_of p v", "unfolding idx_of_def"], ["proof (prove)\nusing this:\n  i < length p\n  v \\<in> p ! i\n  \\<forall>j<length p. v \\<in> p ! j \\<longrightarrow> i = j\n\ngoal (1 subgoal):\n 1. (THE i. i < length p \\<and> v \\<in> p ! i) < length p &&&\n    v \\<in> p ! (THE i. i < length p \\<and> v \\<in> p ! i)", "by (metis (lifting) theI')+"], ["proof (state)\nthis:\n  idx_of p v < length p\n  v \\<in> p ! idx_of p v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma idx_of_uniq:\n  assumes \n    p_disjoint_sym: \"\\<forall>i j v. i<length p \\<and> j<length p \\<and> v\\<in>p!i \\<and> v\\<in>p!j \\<longrightarrow> i=j\"\n  assumes A: \"i<length p\" \"v\\<in>p!i\"\n  shows \"idx_of p v = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idx_of p v = i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. idx_of p v = i", "from A p_disjoint_sym"], ["proof (chain)\npicking this:\n  i < length p\n  v \\<in> p ! i\n  \\<forall>i j v.\n     i < length p \\<and>\n     j < length p \\<and>\n     v \\<in> p ! i \\<and> v \\<in> p ! j \\<longrightarrow>\n     i = j", "have \"\\<forall>j<length p. v\\<in>p ! j \\<longrightarrow> i=j\""], ["proof (prove)\nusing this:\n  i < length p\n  v \\<in> p ! i\n  \\<forall>i j v.\n     i < length p \\<and>\n     j < length p \\<and>\n     v \\<in> p ! i \\<and> v \\<in> p ! j \\<longrightarrow>\n     i = j\n\ngoal (1 subgoal):\n 1. \\<forall>j<length p. v \\<in> p ! j \\<longrightarrow> i = j", "by auto"], ["proof (state)\nthis:\n  \\<forall>j<length p. v \\<in> p ! j \\<longrightarrow> i = j\n\ngoal (1 subgoal):\n 1. idx_of p v = i", "with A"], ["proof (chain)\npicking this:\n  i < length p\n  v \\<in> p ! i\n  \\<forall>j<length p. v \\<in> p ! j \\<longrightarrow> i = j", "show ?thesis"], ["proof (prove)\nusing this:\n  i < length p\n  v \\<in> p ! i\n  \\<forall>j<length p. v \\<in> p ! j \\<longrightarrow> i = j\n\ngoal (1 subgoal):\n 1. idx_of p v = i", "unfolding idx_of_def"], ["proof (prove)\nusing this:\n  i < length p\n  v \\<in> p ! i\n  \\<forall>j<length p. v \\<in> p ! j \\<longrightarrow> i = j\n\ngoal (1 subgoal):\n 1. (THE i. i < length p \\<and> v \\<in> p ! i) = i", "by (metis (lifting) the_equality)"], ["proof (state)\nthis:\n  idx_of p v = i\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Invariants\\<close>"], ["", "text \\<open>The state of the inner loop consists of the path \\<open>p\\<close> of\n  collapsed nodes, the set \\<open>D\\<close> of finished (done) nodes, and the set\n  \\<open>pE\\<close> of pending edges.\\<close>"], ["", "type_synonym 'v abs_state = \"'v set list \\<times> 'v set \\<times> ('v\\<times>'v) set\""], ["", "context fr_graph\nbegin"], ["", "definition touched :: \"'v set list \\<Rightarrow> 'v set \\<Rightarrow> 'v set\" \n    \\<comment> \\<open>Touched: Nodes that are done or on path\\<close>\n    where \"touched p D \\<equiv> D \\<union> \\<Union>(set p)\""], ["", "definition vE :: \"'v set list \\<Rightarrow> 'v set \\<Rightarrow> ('v \\<times> 'v) set \\<Rightarrow> ('v \\<times> 'v) set\"\n    \\<comment> \\<open>Visited edges: No longer pending edges from touched nodes\\<close>\n    where \"vE p D pE \\<equiv> (E \\<inter> (touched p D \\<times> UNIV)) - pE\""], ["", "lemma vE_ss_E: \"vE p D pE \\<subseteq> E\" \\<comment> \\<open>Visited edges are edges\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vE p D pE \\<subseteq> E", "unfolding vE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<inter> touched p D \\<times> UNIV - pE \\<subseteq> E", "by auto"], ["", "end"], ["", "locale outer_invar_loc \\<comment> \\<open>Invariant of the outer loop\\<close>\n  = fr_graph G for G :: \"('v,'more) graph_rec_scheme\" +\n  fixes it :: \"'v set\" \\<comment> \\<open>Remaining nodes to iterate over\\<close>\n  fixes D :: \"'v set\" \\<comment> \\<open>Finished nodes\\<close>\n\n  assumes it_initial: \"it\\<subseteq>V0\"  \\<comment> \\<open>Only start nodes to iterate over\\<close>\n\n  assumes it_done: \"V0 - it \\<subseteq> D\"  \\<comment> \\<open>Nodes already iterated over are visited\\<close>\n  assumes D_reachable: \"D\\<subseteq>E\\<^sup>*``V0\" \\<comment> \\<open>Done nodes are reachable\\<close>\n  assumes D_closed: \"E``D \\<subseteq> D\" \\<comment> \\<open>Done is closed under transitions\\<close>\nbegin"], ["", "lemma locale_this: \"outer_invar_loc G it D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_invar_loc G it D", "by unfold_locales"], ["", "definition (in fr_graph) \"outer_invar \\<equiv> \\<lambda>it D. outer_invar_loc G it D\""], ["", "lemma outer_invar_this[simp, intro!]: \"outer_invar it D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_invar it D", "unfolding outer_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_invar_loc G it D", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_invar_loc G it D", "by unfold_locales"], ["", "end"], ["", "locale invar_loc \\<comment> \\<open>Invariant of the inner loop\\<close>\n  = fr_graph G\n  for G :: \"('v, 'more) graph_rec_scheme\" +\n  fixes v0 :: \"'v\"\n  fixes D0 :: \"'v set\"\n  fixes p :: \"'v set list\"\n  fixes D :: \"'v set\"\n  fixes pE :: \"('v\\<times>'v) set\"\n\n  assumes v0_initial[simp, intro!]: \"v0\\<in>V0\"\n  assumes D_incr: \"D0 \\<subseteq> D\"\n\n  assumes pE_E_from_p: \"pE \\<subseteq> E \\<inter> (\\<Union>(set p)) \\<times> UNIV\" \n    \\<comment> \\<open>Pending edges are edges from path\\<close>\n  assumes E_from_p_touched: \"E \\<inter> (\\<Union>(set p) \\<times> UNIV) \\<subseteq> pE \\<union> UNIV \\<times> touched p D\" \n    \\<comment> \\<open>Edges from path are pending or touched\\<close>\n  assumes D_reachable: \"D\\<subseteq>E\\<^sup>*``V0\" \\<comment> \\<open>Done nodes are reachable\\<close>\n  assumes p_connected: \"Suc i<length p \\<Longrightarrow> p!i \\<times> p!Suc i \\<inter> (E-pE) \\<noteq> {}\"\n    \\<comment> \\<open>CNodes on path are connected by non-pending edges\\<close>\n\n  assumes p_disjoint: \"\\<lbrakk>i<j; j<length p\\<rbrakk> \\<Longrightarrow> p!i \\<inter> p!j = {}\" \n    \\<comment> \\<open>CNodes on path are disjoint\\<close>\n  assumes p_sc: \"U\\<in>set p \\<Longrightarrow> U\\<times>U \\<subseteq> (vE p D pE \\<inter> U\\<times>U)\\<^sup>*\" \n    \\<comment> \\<open>Nodes in CNodes are mutually reachable by visited edges\\<close>\n\n  assumes root_v0: \"p\\<noteq>[] \\<Longrightarrow> v0\\<in>hd p\" \\<comment> \\<open>Root CNode contains start node\\<close>\n  assumes p_empty_v0: \"p=[] \\<Longrightarrow> v0\\<in>D\" \\<comment> \\<open>Start node is done if path empty\\<close>\n  \n  assumes D_closed: \"E``D \\<subseteq> D\" \\<comment> \\<open>Done is closed under transitions\\<close>\n  (*assumes D_vis: \"E\\<inter>D\\<times>D \\<subseteq> vE\" -- \"All edges from done nodes are visited\"*)\n\n  assumes vE_no_back: \"\\<lbrakk>i<j; j<length p\\<rbrakk> \\<Longrightarrow> vE p D pE \\<inter> p!j \\<times> p!i = {}\" \n  \\<comment> \\<open>Visited edges do not go back on path\\<close>\n  assumes p_not_D: \"\\<Union>(set p) \\<inter> D = {}\" \\<comment> \\<open>Path does not contain done nodes\\<close>\nbegin"], ["", "abbreviation ltouched where \"ltouched \\<equiv> touched p D\""], ["", "abbreviation lvE where \"lvE \\<equiv> vE p D pE\""], ["", "lemma locale_this: \"invar_loc G v0 D0 p D pE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D pE", "by unfold_locales"], ["", "definition (in fr_graph) \n    \"invar \\<equiv> \\<lambda>v0 D0 (p,D,pE). invar_loc G v0 D0 p D pE\""], ["", "lemma invar_this[simp, intro!]: \"invar v0 D0 (p,D,pE)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar v0 D0 (p, D, pE)", "unfolding invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case (p, D, pE) of (p, xa, xb) \\<Rightarrow> invar_loc G v0 D0 p xa xb", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D pE", "by unfold_locales"], ["", "lemma finite_reachableE_v0[simp, intro!]: \"finite (E\\<^sup>*``{v0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (E\\<^sup>* `` {v0})", "apply (rule finite_subset[OF _ finite_reachableE_V0])"], ["proof (prove)\ngoal (1 subgoal):\n 1. E\\<^sup>* `` {v0} \\<subseteq> reachable", "using v0_initial"], ["proof (prove)\nusing this:\n  v0 \\<in> V0\n\ngoal (1 subgoal):\n 1. E\\<^sup>* `` {v0} \\<subseteq> reachable", "by auto"], ["", "lemma D_vis: \"E\\<inter>D\\<times>UNIV \\<subseteq> lvE\" \\<comment> \\<open>All edges from done nodes are visited\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<inter> D \\<times> UNIV \\<subseteq> lvE", "unfolding vE_def touched_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<inter> D \\<times> UNIV\n    \\<subseteq> E \\<inter> (D \\<union> \\<Union> (set p)) \\<times> UNIV - pE", "using pE_E_from_p p_not_D"], ["proof (prove)\nusing this:\n  pE \\<subseteq> E \\<inter> \\<Union> (set p) \\<times> UNIV\n  \\<Union> (set p) \\<inter> D = {}\n\ngoal (1 subgoal):\n 1. E \\<inter> D \\<times> UNIV\n    \\<subseteq> E \\<inter> (D \\<union> \\<Union> (set p)) \\<times> UNIV - pE", "by blast"], ["", "lemma vE_touched: \"lvE \\<subseteq> ltouched \\<times> ltouched\" \n    \\<comment> \\<open>Visited edges only between touched nodes\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. lvE \\<subseteq> ltouched \\<times> ltouched", "using E_from_p_touched D_closed"], ["proof (prove)\nusing this:\n  E \\<inter> \\<Union> (set p) \\<times> UNIV\n  \\<subseteq> pE \\<union> UNIV \\<times> ltouched\n  E `` D \\<subseteq> D\n\ngoal (1 subgoal):\n 1. lvE \\<subseteq> ltouched \\<times> ltouched", "unfolding vE_def touched_def"], ["proof (prove)\nusing this:\n  E \\<inter> \\<Union> (set p) \\<times> UNIV\n  \\<subseteq> pE \\<union> UNIV \\<times> (D \\<union> \\<Union> (set p))\n  E `` D \\<subseteq> D\n\ngoal (1 subgoal):\n 1. E \\<inter> (D \\<union> \\<Union> (set p)) \\<times> UNIV - pE\n    \\<subseteq> (D \\<union> \\<Union> (set p)) \\<times>\n                (D \\<union> \\<Union> (set p))", "by blast"], ["", "lemma lvE_ss_E: \"lvE \\<subseteq> E\" \\<comment> \\<open>Visited edges are edges\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. lvE \\<subseteq> E", "unfolding vE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<inter> ltouched \\<times> UNIV - pE \\<subseteq> E", "by auto"], ["", "lemma path_touched: \"\\<Union>(set p) \\<subseteq> ltouched\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set p) \\<subseteq> ltouched", "by (auto simp: touched_def)"], ["", "lemma D_touched: \"D \\<subseteq> ltouched\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<subseteq> ltouched", "by (auto simp: touched_def)"], ["", "lemma pE_by_vE: \"pE = (E \\<inter> \\<Union>(set p) \\<times> UNIV) - lvE\"\n    \\<comment> \\<open>Pending edges are edges from path not yet visited\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. pE = E \\<inter> \\<Union> (set p) \\<times> UNIV - lvE", "unfolding vE_def touched_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pE =\n    E \\<inter> \\<Union> (set p) \\<times> UNIV -\n    (E \\<inter> (D \\<union> \\<Union> (set p)) \\<times> UNIV - pE)", "using pE_E_from_p"], ["proof (prove)\nusing this:\n  pE \\<subseteq> E \\<inter> \\<Union> (set p) \\<times> UNIV\n\ngoal (1 subgoal):\n 1. pE =\n    E \\<inter> \\<Union> (set p) \\<times> UNIV -\n    (E \\<inter> (D \\<union> \\<Union> (set p)) \\<times> UNIV - pE)", "by auto"], ["", "lemma pick_pending: \"p\\<noteq>[] \\<Longrightarrow> pE \\<inter> last p \\<times> UNIV = (E-lvE) \\<inter> last p \\<times> UNIV\"\n    \\<comment> \\<open>Pending edges from end of path are non-visited edges from end of path\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    pE \\<inter> last p \\<times> UNIV =\n    (E - lvE) \\<inter> last p \\<times> UNIV", "apply (subst pE_by_vE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    (E \\<inter> \\<Union> (set p) \\<times> UNIV - lvE) \\<inter>\n    last p \\<times> UNIV =\n    (E - lvE) \\<inter> last p \\<times> UNIV", "by auto"], ["", "lemma p_connected': \n    assumes A: \"Suc i<length p\" \n    shows \"p!i \\<times> p!Suc i \\<inter> lvE \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ! i \\<times> p ! Suc i \\<inter> lvE \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p ! i \\<times> p ! Suc i \\<inter> lvE \\<noteq> {}", "from A p_not_D"], ["proof (chain)\npicking this:\n  Suc i < length p\n  \\<Union> (set p) \\<inter> D = {}", "have \"p!i \\<in> set p\" \"p!Suc i \\<in> set p\""], ["proof (prove)\nusing this:\n  Suc i < length p\n  \\<Union> (set p) \\<inter> D = {}\n\ngoal (1 subgoal):\n 1. p ! i \\<in> set p &&& p ! Suc i \\<in> set p", "by auto"], ["proof (state)\nthis:\n  p ! i \\<in> set p\n  p ! Suc i \\<in> set p\n\ngoal (1 subgoal):\n 1. p ! i \\<times> p ! Suc i \\<inter> lvE \\<noteq> {}", "with p_connected[OF A]"], ["proof (chain)\npicking this:\n  p ! i \\<times> p ! Suc i \\<inter> (E - pE) \\<noteq> {}\n  p ! i \\<in> set p\n  p ! Suc i \\<in> set p", "show ?thesis"], ["proof (prove)\nusing this:\n  p ! i \\<times> p ! Suc i \\<inter> (E - pE) \\<noteq> {}\n  p ! i \\<in> set p\n  p ! Suc i \\<in> set p\n\ngoal (1 subgoal):\n 1. p ! i \\<times> p ! Suc i \\<inter> lvE \\<noteq> {}", "unfolding vE_def touched_def"], ["proof (prove)\nusing this:\n  p ! i \\<times> p ! Suc i \\<inter> (E - pE) \\<noteq> {}\n  p ! i \\<in> set p\n  p ! Suc i \\<in> set p\n\ngoal (1 subgoal):\n 1. p ! i \\<times> p ! Suc i \\<inter>\n    (E \\<inter> (D \\<union> \\<Union> (set p)) \\<times> UNIV - pE) \\<noteq>\n    {}", "by blast"], ["proof (state)\nthis:\n  p ! i \\<times> p ! Suc i \\<inter> lvE \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Termination\\<close>"], ["", "context fr_graph \nbegin"], ["", "text \\<open>The termination argument is based on unprocessed edges: \n    Reachable edges from untouched nodes and pending edges.\\<close>"], ["", "definition \"unproc_edges v0 p D pE \\<equiv> (E \\<inter> (E\\<^sup>*``{v0} - (D \\<union> \\<Union>(set p))) \\<times> UNIV) \\<union> pE\""], ["", "text \\<open>\n    In each iteration of the loop, either the number of unprocessed edges\n    decreases, or the path length decreases.\\<close>"], ["", "definition \"abs_wf_rel v0 \\<equiv> inv_image (finite_psubset <*lex*> measure length)\n    (\\<lambda>(p,D,pE). (unproc_edges v0 p D pE, p))\""], ["", "lemma abs_wf_rel_wf[simp, intro!]: \"wf (abs_wf_rel v0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (abs_wf_rel v0)", "unfolding abs_wf_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (inv_image (finite_psubset <*lex*> measure length)\n         (\\<lambda>(p, D, pE). (unproc_edges v0 p D pE, p)))", "by auto"], ["", "end"], ["", "subsection \\<open>Abstract Skeleton Algorithm\\<close>"], ["", "context fr_graph\nbegin"], ["", "definition (in fr_graph) initial :: \"'v \\<Rightarrow> 'v set \\<Rightarrow> 'v abs_state\"\n    where \"initial v0 D \\<equiv> ([{v0}], D, (E \\<inter> {v0}\\<times>UNIV))\""], ["", "definition (in -) collapse_aux :: \"'a set list \\<Rightarrow> nat \\<Rightarrow> 'a set list\"\n    where \"collapse_aux p i \\<equiv> take i p @ [\\<Union>(set (drop i p))]\""], ["", "definition (in -) collapse :: \"'a \\<Rightarrow> 'a abs_state \\<Rightarrow> 'a abs_state\" \n    where \"collapse v PDPE \\<equiv> \n    let \n      (p,D,pE)=PDPE; \n      i=idx_of p v;\n      p = collapse_aux p i\n    in (p,D,pE)\""], ["", "definition (in -) \n    select_edge :: \"'a abs_state \\<Rightarrow> ('a option \\<times> 'a abs_state) nres\"\n    where\n    \"select_edge PDPE \\<equiv> do {\n      let (p,D,pE) = PDPE;\n      e \\<leftarrow> SELECT (\\<lambda>e. e \\<in> pE \\<inter> last p \\<times> UNIV);\n      case e of\n        None \\<Rightarrow> RETURN (None,(p,D,pE))\n      | Some (u,v) \\<Rightarrow> RETURN (Some v, (p,D,pE - {(u,v)}))\n    }\""], ["", "definition (in fr_graph) push :: \"'v \\<Rightarrow> 'v abs_state \\<Rightarrow> 'v abs_state\" \n    where \"push v PDPE \\<equiv> \n    let\n      (p,D,pE) = PDPE;\n      p = p@[{v}];\n      pE = pE \\<union> (E\\<inter>{v}\\<times>UNIV)\n    in\n      (p,D,pE)\""], ["", "definition (in -) pop :: \"'v abs_state \\<Rightarrow> 'v abs_state\"\n    where \"pop PDPE \\<equiv> let\n      (p,D,pE) = PDPE;\n      (p,V) = (butlast p, last p);\n      D = V \\<union> D\n    in\n      (p,D,pE)\""], ["", "text \\<open>The following lemmas match the definitions presented in the paper:\\<close>"], ["", "lemma \"select_edge (p,D,pE) \\<equiv> do {\n      e \\<leftarrow> SELECT (\\<lambda>e. e \\<in> pE \\<inter> last p \\<times> UNIV);\n      case e of\n        None \\<Rightarrow> RETURN (None,(p,D,pE))\n      | Some (u,v) \\<Rightarrow> RETURN (Some v, (p,D,pE - {(u,v)}))\n    }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. select_edge (p, D, pE) \\<equiv>\n    SELECT (\\<lambda>e. e \\<in> pE \\<inter> last p \\<times> UNIV) \\<bind>\n    (\\<lambda>e.\n        case e of None \\<Rightarrow> RETURN (None, p, D, pE)\n        | Some (u, v) \\<Rightarrow> RETURN (Some v, p, D, pE - {(u, v)}))", "unfolding select_edge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. let (p, D, pE) = (p, D, pE)\n    in SELECT (\\<lambda>e. e \\<in> pE \\<inter> last p \\<times> UNIV) \\<bind>\n       (\\<lambda>e.\n           case e of None \\<Rightarrow> RETURN (None, p, D, pE)\n           | Some (u, v) \\<Rightarrow>\n               RETURN (Some v, p, D, pE - {(u, v)})) \\<equiv>\n    SELECT (\\<lambda>e. e \\<in> pE \\<inter> last p \\<times> UNIV) \\<bind>\n    (\\<lambda>e.\n        case e of None \\<Rightarrow> RETURN (None, p, D, pE)\n        | Some (u, v) \\<Rightarrow> RETURN (Some v, p, D, pE - {(u, v)}))", "by simp"], ["", "lemma \"collapse v (p,D,pE) \n    \\<equiv> let i=idx_of p v in (take i p @ [\\<Union>(set (drop i p))],D,pE)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collapse v (p, D, pE) \\<equiv>\n    let i = idx_of p v in (take i p @ [\\<Union> (set (drop i p))], D, pE)", "unfolding collapse_def collapse_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. let (p, D, pE) = (p, D, pE); i = idx_of p v;\n        p = take i p @ [\\<Union> (set (drop i p))]\n    in (p, D, pE) \\<equiv>\n    let i = idx_of p v in (take i p @ [\\<Union> (set (drop i p))], D, pE)", "by simp"], ["", "lemma \"push v (p, D, pE) \\<equiv> (p @ [{v}], D, pE \\<union> E \\<inter> {v} \\<times> UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. push v (p, D, pE) \\<equiv>\n    (p @ [{v}], D, pE \\<union> E \\<inter> {v} \\<times> UNIV)", "unfolding push_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. let (p, D, pE) = (p, D, pE); p = p @ [{v}];\n        pE = pE \\<union> E \\<inter> {v} \\<times> UNIV\n    in (p, D, pE) \\<equiv>\n    (p @ [{v}], D, pE \\<union> E \\<inter> {v} \\<times> UNIV)", "by simp"], ["", "lemma \"pop (p, D, pE) \\<equiv> (butlast p, last p \\<union> D, pE)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pop (p, D, pE) \\<equiv> (butlast p, last p \\<union> D, pE)", "unfolding pop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. let (p, D, pE) = (p, D, pE); (p, V) = (butlast p, last p);\n        D = V \\<union> D\n    in (p, D, pE) \\<equiv>\n    (butlast p, last p \\<union> D, pE)", "by auto"], ["", "thm pop_def[unfolded Let_def, no_vars]"], ["", "thm select_edge_def[unfolded Let_def]"], ["", "definition skeleton :: \"'v set nres\" \n    \\<comment> \\<open>Abstract Skeleton Algorithm\\<close>\n    where\n    \"skeleton \\<equiv> do {\n      let D = {};\n      r \\<leftarrow> FOREACHi outer_invar V0 (\\<lambda>v0 D0. do {\n        if v0\\<notin>D0 then do {\n          let s = initial v0 D0;\n\n          (p,D,pE) \\<leftarrow> WHILEIT (invar v0 D0)\n            (\\<lambda>(p,D,pE). p \\<noteq> []) (\\<lambda>(p,D,pE). \n          do {\n            \\<comment> \\<open>Select edge from end of path\\<close>\n            (vo,(p,D,pE)) \\<leftarrow> select_edge (p,D,pE);\n\n            ASSERT (p\\<noteq>[]);\n            case vo of \n              Some v \\<Rightarrow> do { \\<comment> \\<open>Found outgoing edge to node \\<open>v\\<close>\\<close>\n                if v \\<in> \\<Union>(set p) then do {\n                  \\<comment> \\<open>Back edge: Collapse path\\<close>\n                  RETURN (collapse v (p,D,pE))\n                } else if v\\<notin>D then do {\n                  \\<comment> \\<open>Edge to new node. Append to path\\<close>\n                  RETURN (push v (p,D,pE))\n                } else do {\n                  \\<comment> \\<open>Edge to done node. Skip\\<close>\n                  RETURN (p,D,pE)\n                }\n              }\n            | None \\<Rightarrow> do {\n                ASSERT (pE \\<inter> last p \\<times> UNIV = {});\n                \\<comment> \\<open>No more outgoing edges from current node on path\\<close>\n                RETURN (pop (p,D,pE))\n              }\n          }) s;\n          ASSERT (p=[] \\<and> pE={});\n          RETURN D\n        } else\n          RETURN D0\n      }) D;\n      RETURN r\n    }\""], ["", "end"], ["", "subsection \\<open>Invariant Preservation\\<close>"], ["", "context fr_graph begin"], ["", "lemma set_collapse_aux[simp]: \"\\<Union>(set (collapse_aux p i)) = \\<Union>(set p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set (collapse_aux p i)) = \\<Union> (set p)", "apply (subst (2) append_take_drop_id[of _ p,symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set (collapse_aux p i)) =\n    \\<Union> (set (take ?n p @ drop ?n p))", "apply (simp del: append_take_drop_id)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set (collapse_aux p i)) =\n    \\<Union> (set (take ?n p)) \\<union> \\<Union> (set (drop ?n p))", "unfolding collapse_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set (take i p @ [\\<Union> (set (drop i p))])) =\n    \\<Union> (set (take ?n p)) \\<union> \\<Union> (set (drop ?n p))", "by auto"], ["", "lemma touched_collapse[simp]: \"touched (collapse_aux p i) D = touched p D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. touched (collapse_aux p i) D = touched p D", "unfolding touched_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<union> \\<Union> (set (collapse_aux p i)) =\n    D \\<union> \\<Union> (set p)", "by simp"], ["", "lemma vE_collapse_aux[simp]: \"vE (collapse_aux p i) D pE = vE p D pE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vE (collapse_aux p i) D pE = vE p D pE", "unfolding vE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<inter> touched (collapse_aux p i) D \\<times> UNIV - pE =\n    E \\<inter> touched p D \\<times> UNIV - pE", "by simp"], ["", "lemma touched_push[simp]: \"touched (p @ [V]) D = touched p D \\<union> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. touched (p @ [V]) D = touched p D \\<union> V", "unfolding touched_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<union> \\<Union> (set (p @ [V])) =\n    D \\<union> \\<Union> (set p) \\<union> V", "by auto"], ["", "end"], ["", "subsubsection \\<open>Corollaries of the invariant\\<close>"], ["", "text \\<open>In this section, we prove some more corollaries of the invariant,\n  which are helpful to show invariant preservation\\<close>"], ["", "context invar_loc\nbegin"], ["", "lemma cnode_connectedI: \n    \"\\<lbrakk>i<length p; u\\<in>p!i; v\\<in>p!i\\<rbrakk> \\<Longrightarrow> (u,v)\\<in>(lvE \\<inter> p!i\\<times>p!i)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length p; u \\<in> p ! i; v \\<in> p ! i\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> (Restr lvE (p ! i))\\<^sup>*", "using p_sc[of \"p!i\"]"], ["proof (prove)\nusing this:\n  p ! i \\<in> set p \\<Longrightarrow>\n  p ! i \\<times> p ! i \\<subseteq> (Restr lvE (p ! i))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length p; u \\<in> p ! i; v \\<in> p ! i\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> (Restr lvE (p ! i))\\<^sup>*", "by (auto simp: in_set_conv_nth)"], ["", "lemma cnode_connectedI': \"\\<lbrakk>i<length p; u\\<in>p!i; v\\<in>p!i\\<rbrakk> \\<Longrightarrow> (u,v)\\<in>(lvE)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length p; u \\<in> p ! i; v \\<in> p ! i\\<rbrakk>\n    \\<Longrightarrow> (u, v) \\<in> lvE\\<^sup>*", "by (metis inf.cobounded1 rtrancl_mono_mp cnode_connectedI)"], ["", "lemma p_no_empty: \"{} \\<notin> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<notin> set p", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. {} \\<in> set p \\<Longrightarrow> False", "assume \"{}\\<in>set p\""], ["proof (state)\nthis:\n  {} \\<in> set p\n\ngoal (1 subgoal):\n 1. {} \\<in> set p \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  {} \\<in> set p", "obtain i where IDX: \"i<length p\" \"p!i={}\""], ["proof (prove)\nusing this:\n  {} \\<in> set p\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length p; p ! i = {}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length p\n  p ! i = {}\n\ngoal (1 subgoal):\n 1. {} \\<in> set p \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> False\n 2. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> False\n 2. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "with root_v0 IDX"], ["proof (chain)\npicking this:\n  p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p\n  i < length p\n  p ! i = {}\n  i = 0", "show False"], ["proof (prove)\nusing this:\n  p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p\n  i < length p\n  p ! i = {}\n  i = 0\n\ngoal (1 subgoal):\n 1. False", "by (cases p) auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "case [simp]: (Suc j)"], ["proof (state)\nthis:\n  i = Suc j\n\ngoal (1 subgoal):\n 1. \\<And>nat. i = Suc nat \\<Longrightarrow> False", "from p_connected'[of j] IDX"], ["proof (chain)\npicking this:\n  Suc j < length p \\<Longrightarrow>\n  p ! j \\<times> p ! Suc j \\<inter> lvE \\<noteq> {}\n  i < length p\n  p ! i = {}", "show False"], ["proof (prove)\nusing this:\n  Suc j < length p \\<Longrightarrow>\n  p ! j \\<times> p ! Suc j \\<inter> lvE \\<noteq> {}\n  i < length p\n  p ! i = {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary p_no_empty_idx: \"i<length p \\<Longrightarrow> p!i\\<noteq>{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length p \\<Longrightarrow> p ! i \\<noteq> {}", "using p_no_empty"], ["proof (prove)\nusing this:\n  {} \\<notin> set p\n\ngoal (1 subgoal):\n 1. i < length p \\<Longrightarrow> p ! i \\<noteq> {}", "by (metis nth_mem)"], ["", "lemma p_disjoint_sym: \"\\<lbrakk>i<length p; j<length p; v\\<in>p!i; v\\<in>p!j\\<rbrakk> \\<Longrightarrow> i=j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length p; j < length p; v \\<in> p ! i;\n     v \\<in> p ! j\\<rbrakk>\n    \\<Longrightarrow> i = j", "by (metis disjoint_iff_not_equal linorder_neqE_nat p_disjoint)"], ["", "lemma pi_ss_path_seg_eq[simp]:\n    assumes A: \"i<length p\" \"u\\<le>length p\"\n    shows \"p!i\\<subseteq>path_seg p l u \\<longleftrightarrow> l\\<le>i \\<and> i<u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p ! i \\<subseteq> path_seg p l u) = (l \\<le> i \\<and> i < u)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p ! i \\<subseteq> path_seg p l u \\<Longrightarrow>\n    l \\<le> i \\<and> i < u\n 2. l \\<le> i \\<and> i < u \\<Longrightarrow>\n    p ! i \\<subseteq> path_seg p l u", "assume B: \"p!i\\<subseteq>path_seg p l u\""], ["proof (state)\nthis:\n  p ! i \\<subseteq> path_seg p l u\n\ngoal (2 subgoals):\n 1. p ! i \\<subseteq> path_seg p l u \\<Longrightarrow>\n    l \\<le> i \\<and> i < u\n 2. l \\<le> i \\<and> i < u \\<Longrightarrow>\n    p ! i \\<subseteq> path_seg p l u", "from A"], ["proof (chain)\npicking this:\n  i < length p\n  u \\<le> length p", "obtain x where \"x\\<in>p!i\""], ["proof (prove)\nusing this:\n  i < length p\n  u \\<le> length p\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> p ! i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast dest: p_no_empty_idx)"], ["proof (state)\nthis:\n  x \\<in> p ! i\n\ngoal (2 subgoals):\n 1. p ! i \\<subseteq> path_seg p l u \\<Longrightarrow>\n    l \\<le> i \\<and> i < u\n 2. l \\<le> i \\<and> i < u \\<Longrightarrow>\n    p ! i \\<subseteq> path_seg p l u", "with B"], ["proof (chain)\npicking this:\n  p ! i \\<subseteq> path_seg p l u\n  x \\<in> p ! i", "obtain i' where C: \"x\\<in>p!i'\" \"l\\<le>i'\" \"i'<u\""], ["proof (prove)\nusing this:\n  p ! i \\<subseteq> path_seg p l u\n  x \\<in> p ! i\n\ngoal (1 subgoal):\n 1. (\\<And>i'.\n        \\<lbrakk>x \\<in> p ! i'; l \\<le> i'; i' < u\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: path_seg_def)"], ["proof (state)\nthis:\n  x \\<in> p ! i'\n  l \\<le> i'\n  i' < u\n\ngoal (2 subgoals):\n 1. p ! i \\<subseteq> path_seg p l u \\<Longrightarrow>\n    l \\<le> i \\<and> i < u\n 2. l \\<le> i \\<and> i < u \\<Longrightarrow>\n    p ! i \\<subseteq> path_seg p l u", "from p_disjoint_sym[OF \\<open>i<length p\\<close> _ \\<open>x\\<in>p!i\\<close> \\<open>x\\<in>p!i'\\<close>] \\<open>i'<u\\<close> \\<open>u\\<le>length p\\<close>"], ["proof (chain)\npicking this:\n  i' < length p \\<Longrightarrow> i = i'\n  i' < u\n  u \\<le> length p", "have \"i=i'\""], ["proof (prove)\nusing this:\n  i' < length p \\<Longrightarrow> i = i'\n  i' < u\n  u \\<le> length p\n\ngoal (1 subgoal):\n 1. i = i'", "by simp"], ["proof (state)\nthis:\n  i = i'\n\ngoal (2 subgoals):\n 1. p ! i \\<subseteq> path_seg p l u \\<Longrightarrow>\n    l \\<le> i \\<and> i < u\n 2. l \\<le> i \\<and> i < u \\<Longrightarrow>\n    p ! i \\<subseteq> path_seg p l u", "with C"], ["proof (chain)\npicking this:\n  x \\<in> p ! i'\n  l \\<le> i'\n  i' < u\n  i = i'", "show \"l\\<le>i \\<and> i<u\""], ["proof (prove)\nusing this:\n  x \\<in> p ! i'\n  l \\<le> i'\n  i' < u\n  i = i'\n\ngoal (1 subgoal):\n 1. l \\<le> i \\<and> i < u", "by auto"], ["proof (state)\nthis:\n  l \\<le> i \\<and> i < u\n\ngoal (1 subgoal):\n 1. l \\<le> i \\<and> i < u \\<Longrightarrow>\n    p ! i \\<subseteq> path_seg p l u", "qed (auto simp: path_seg_def)"], ["", "lemma path_seg_ss_eq[simp]:\n    assumes A: \"l1<u1\" \"u1\\<le>length p\" \"l2<u2\" \"u2\\<le>length p\"\n    shows \"path_seg p l1 u1 \\<subseteq> path_seg p l2 u2 \\<longleftrightarrow> l2\\<le>l1 \\<and> u1\\<le>u2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (path_seg p l1 u1 \\<subseteq> path_seg p l2 u2) =\n    (l2 \\<le> l1 \\<and> u1 \\<le> u2)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. path_seg p l1 u1 \\<subseteq> path_seg p l2 u2 \\<Longrightarrow>\n    l2 \\<le> l1 \\<and> u1 \\<le> u2\n 2. l2 \\<le> l1 \\<and> u1 \\<le> u2 \\<Longrightarrow>\n    path_seg p l1 u1 \\<subseteq> path_seg p l2 u2", "assume S: \"path_seg p l1 u1 \\<subseteq> path_seg p l2 u2\""], ["proof (state)\nthis:\n  path_seg p l1 u1 \\<subseteq> path_seg p l2 u2\n\ngoal (2 subgoals):\n 1. path_seg p l1 u1 \\<subseteq> path_seg p l2 u2 \\<Longrightarrow>\n    l2 \\<le> l1 \\<and> u1 \\<le> u2\n 2. l2 \\<le> l1 \\<and> u1 \\<le> u2 \\<Longrightarrow>\n    path_seg p l1 u1 \\<subseteq> path_seg p l2 u2", "have \"p!l1 \\<subseteq> path_seg p l1 u1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ! l1 \\<subseteq> path_seg p l1 u1", "using A"], ["proof (prove)\nusing this:\n  l1 < u1\n  u1 \\<le> length p\n  l2 < u2\n  u2 \\<le> length p\n\ngoal (1 subgoal):\n 1. p ! l1 \\<subseteq> path_seg p l1 u1", "by simp"], ["proof (state)\nthis:\n  p ! l1 \\<subseteq> path_seg p l1 u1\n\ngoal (2 subgoals):\n 1. path_seg p l1 u1 \\<subseteq> path_seg p l2 u2 \\<Longrightarrow>\n    l2 \\<le> l1 \\<and> u1 \\<le> u2\n 2. l2 \\<le> l1 \\<and> u1 \\<le> u2 \\<Longrightarrow>\n    path_seg p l1 u1 \\<subseteq> path_seg p l2 u2", "also"], ["proof (state)\nthis:\n  p ! l1 \\<subseteq> path_seg p l1 u1\n\ngoal (2 subgoals):\n 1. path_seg p l1 u1 \\<subseteq> path_seg p l2 u2 \\<Longrightarrow>\n    l2 \\<le> l1 \\<and> u1 \\<le> u2\n 2. l2 \\<le> l1 \\<and> u1 \\<le> u2 \\<Longrightarrow>\n    path_seg p l1 u1 \\<subseteq> path_seg p l2 u2", "note S"], ["proof (state)\nthis:\n  path_seg p l1 u1 \\<subseteq> path_seg p l2 u2\n\ngoal (2 subgoals):\n 1. path_seg p l1 u1 \\<subseteq> path_seg p l2 u2 \\<Longrightarrow>\n    l2 \\<le> l1 \\<and> u1 \\<le> u2\n 2. l2 \\<le> l1 \\<and> u1 \\<le> u2 \\<Longrightarrow>\n    path_seg p l1 u1 \\<subseteq> path_seg p l2 u2", "finally"], ["proof (chain)\npicking this:\n  p ! l1 \\<subseteq> path_seg p l2 u2", "have 1: \"l2\\<le>l1\""], ["proof (prove)\nusing this:\n  p ! l1 \\<subseteq> path_seg p l2 u2\n\ngoal (1 subgoal):\n 1. l2 \\<le> l1", "using A"], ["proof (prove)\nusing this:\n  p ! l1 \\<subseteq> path_seg p l2 u2\n  l1 < u1\n  u1 \\<le> length p\n  l2 < u2\n  u2 \\<le> length p\n\ngoal (1 subgoal):\n 1. l2 \\<le> l1", "by simp"], ["proof (state)\nthis:\n  l2 \\<le> l1\n\ngoal (2 subgoals):\n 1. path_seg p l1 u1 \\<subseteq> path_seg p l2 u2 \\<Longrightarrow>\n    l2 \\<le> l1 \\<and> u1 \\<le> u2\n 2. l2 \\<le> l1 \\<and> u1 \\<le> u2 \\<Longrightarrow>\n    path_seg p l1 u1 \\<subseteq> path_seg p l2 u2", "have \"p!(u1 - 1) \\<subseteq> path_seg p l1 u1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ! (u1 - 1) \\<subseteq> path_seg p l1 u1", "using A"], ["proof (prove)\nusing this:\n  l1 < u1\n  u1 \\<le> length p\n  l2 < u2\n  u2 \\<le> length p\n\ngoal (1 subgoal):\n 1. p ! (u1 - 1) \\<subseteq> path_seg p l1 u1", "by simp"], ["proof (state)\nthis:\n  p ! (u1 - 1) \\<subseteq> path_seg p l1 u1\n\ngoal (2 subgoals):\n 1. path_seg p l1 u1 \\<subseteq> path_seg p l2 u2 \\<Longrightarrow>\n    l2 \\<le> l1 \\<and> u1 \\<le> u2\n 2. l2 \\<le> l1 \\<and> u1 \\<le> u2 \\<Longrightarrow>\n    path_seg p l1 u1 \\<subseteq> path_seg p l2 u2", "also"], ["proof (state)\nthis:\n  p ! (u1 - 1) \\<subseteq> path_seg p l1 u1\n\ngoal (2 subgoals):\n 1. path_seg p l1 u1 \\<subseteq> path_seg p l2 u2 \\<Longrightarrow>\n    l2 \\<le> l1 \\<and> u1 \\<le> u2\n 2. l2 \\<le> l1 \\<and> u1 \\<le> u2 \\<Longrightarrow>\n    path_seg p l1 u1 \\<subseteq> path_seg p l2 u2", "note S"], ["proof (state)\nthis:\n  path_seg p l1 u1 \\<subseteq> path_seg p l2 u2\n\ngoal (2 subgoals):\n 1. path_seg p l1 u1 \\<subseteq> path_seg p l2 u2 \\<Longrightarrow>\n    l2 \\<le> l1 \\<and> u1 \\<le> u2\n 2. l2 \\<le> l1 \\<and> u1 \\<le> u2 \\<Longrightarrow>\n    path_seg p l1 u1 \\<subseteq> path_seg p l2 u2", "finally"], ["proof (chain)\npicking this:\n  p ! (u1 - 1) \\<subseteq> path_seg p l2 u2", "have 2: \"u1\\<le>u2\""], ["proof (prove)\nusing this:\n  p ! (u1 - 1) \\<subseteq> path_seg p l2 u2\n\ngoal (1 subgoal):\n 1. u1 \\<le> u2", "using A"], ["proof (prove)\nusing this:\n  p ! (u1 - 1) \\<subseteq> path_seg p l2 u2\n  l1 < u1\n  u1 \\<le> length p\n  l2 < u2\n  u2 \\<le> length p\n\ngoal (1 subgoal):\n 1. u1 \\<le> u2", "by auto"], ["proof (state)\nthis:\n  u1 \\<le> u2\n\ngoal (2 subgoals):\n 1. path_seg p l1 u1 \\<subseteq> path_seg p l2 u2 \\<Longrightarrow>\n    l2 \\<le> l1 \\<and> u1 \\<le> u2\n 2. l2 \\<le> l1 \\<and> u1 \\<le> u2 \\<Longrightarrow>\n    path_seg p l1 u1 \\<subseteq> path_seg p l2 u2", "from 1 2"], ["proof (chain)\npicking this:\n  l2 \\<le> l1\n  u1 \\<le> u2", "show \"l2\\<le>l1 \\<and> u1\\<le>u2\""], ["proof (prove)\nusing this:\n  l2 \\<le> l1\n  u1 \\<le> u2\n\ngoal (1 subgoal):\n 1. l2 \\<le> l1 \\<and> u1 \\<le> u2", ".."], ["proof (state)\nthis:\n  l2 \\<le> l1 \\<and> u1 \\<le> u2\n\ngoal (1 subgoal):\n 1. l2 \\<le> l1 \\<and> u1 \\<le> u2 \\<Longrightarrow>\n    path_seg p l1 u1 \\<subseteq> path_seg p l2 u2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. l2 \\<le> l1 \\<and> u1 \\<le> u2 \\<Longrightarrow>\n    path_seg p l1 u1 \\<subseteq> path_seg p l2 u2", "assume \"l2\\<le>l1 \\<and> u1\\<le>u2\""], ["proof (state)\nthis:\n  l2 \\<le> l1 \\<and> u1 \\<le> u2\n\ngoal (1 subgoal):\n 1. l2 \\<le> l1 \\<and> u1 \\<le> u2 \\<Longrightarrow>\n    path_seg p l1 u1 \\<subseteq> path_seg p l2 u2", "thus \"path_seg p l1 u1 \\<subseteq> path_seg p l2 u2\""], ["proof (prove)\nusing this:\n  l2 \\<le> l1 \\<and> u1 \\<le> u2\n\ngoal (1 subgoal):\n 1. path_seg p l1 u1 \\<subseteq> path_seg p l2 u2", "using A"], ["proof (prove)\nusing this:\n  l2 \\<le> l1 \\<and> u1 \\<le> u2\n  l1 < u1\n  u1 \\<le> length p\n  l2 < u2\n  u2 \\<le> length p\n\ngoal (1 subgoal):\n 1. path_seg p l1 u1 \\<subseteq> path_seg p l2 u2", "apply (clarsimp simp: path_seg_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x k.\n       \\<lbrakk>u2 \\<le> length p; x \\<in> p ! k; l2 \\<le> l1; u1 \\<le> u2;\n        l1 \\<le> k; k < u1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>k.\n                                xa = p ! k \\<and>\n                                l2 \\<le> k \\<and> k < u2) \\<and>\n                            x \\<in> xa", "apply (metis dual_order.strict_trans1 dual_order.trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  path_seg p l1 u1 \\<subseteq> path_seg p l2 u2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pathI: \n    assumes \"x\\<in>p!i\" \"y\\<in>p!j\"\n    assumes \"i\\<le>j\" \"j<length p\"\n    defines \"seg \\<equiv> path_seg p i (Suc j)\"\n    shows \"(x,y)\\<in>(lvE \\<inter> seg\\<times>seg)\\<^sup>*\"\n    \\<comment> \\<open>We can obtain a path between cnodes on path\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> (Restr lvE seg)\\<^sup>*", "using assms(3,1,2,4)"], ["proof (prove)\nusing this:\n  i \\<le> j\n  x \\<in> p ! i\n  y \\<in> p ! j\n  j < length p\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (Restr lvE seg)\\<^sup>*", "unfolding seg_def"], ["proof (prove)\nusing this:\n  i \\<le> j\n  x \\<in> p ! i\n  y \\<in> p ! j\n  j < length p\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (Restr lvE (path_seg p i (Suc j)))\\<^sup>*", "proof (induction arbitrary: y rule: dec_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>x \\<in> p ! i; y \\<in> p ! i; i < length p\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> (Restr lvE (path_seg p i (Suc i)))\\<^sup>*\n 2. \\<And>n y.\n       \\<lbrakk>i \\<le> n; n < j;\n        \\<And>y.\n           \\<lbrakk>x \\<in> p ! i; y \\<in> p ! n; n < length p\\<rbrakk>\n           \\<Longrightarrow> (x, y)\n                             \\<in> (Restr lvE\n                                     (path_seg p i (Suc n)))\\<^sup>*;\n        x \\<in> p ! i; y \\<in> p ! Suc n; Suc n < length p\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> (Restr lvE\n                                 (path_seg p i (Suc (Suc n))))\\<^sup>*", "case base"], ["proof (state)\nthis:\n  x \\<in> p ! i\n  y \\<in> p ! i\n  i < length p\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>x \\<in> p ! i; y \\<in> p ! i; i < length p\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> (Restr lvE (path_seg p i (Suc i)))\\<^sup>*\n 2. \\<And>n y.\n       \\<lbrakk>i \\<le> n; n < j;\n        \\<And>y.\n           \\<lbrakk>x \\<in> p ! i; y \\<in> p ! n; n < length p\\<rbrakk>\n           \\<Longrightarrow> (x, y)\n                             \\<in> (Restr lvE\n                                     (path_seg p i (Suc n)))\\<^sup>*;\n        x \\<in> p ! i; y \\<in> p ! Suc n; Suc n < length p\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> (Restr lvE\n                                 (path_seg p i (Suc (Suc n))))\\<^sup>*", "thus ?case"], ["proof (prove)\nusing this:\n  x \\<in> p ! i\n  y \\<in> p ! i\n  i < length p\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (Restr lvE (path_seg p i (Suc i)))\\<^sup>*", "by (auto intro!: cnode_connectedI)"], ["proof (state)\nthis:\n  (x, y) \\<in> (Restr lvE (path_seg p i (Suc i)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>n y.\n       \\<lbrakk>i \\<le> n; n < j;\n        \\<And>y.\n           \\<lbrakk>x \\<in> p ! i; y \\<in> p ! n; n < length p\\<rbrakk>\n           \\<Longrightarrow> (x, y)\n                             \\<in> (Restr lvE\n                                     (path_seg p i (Suc n)))\\<^sup>*;\n        x \\<in> p ! i; y \\<in> p ! Suc n; Suc n < length p\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> (Restr lvE\n                                 (path_seg p i (Suc (Suc n))))\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n y.\n       \\<lbrakk>i \\<le> n; n < j;\n        \\<And>y.\n           \\<lbrakk>x \\<in> p ! i; y \\<in> p ! n; n < length p\\<rbrakk>\n           \\<Longrightarrow> (x, y)\n                             \\<in> (Restr lvE\n                                     (path_seg p i (Suc n)))\\<^sup>*;\n        x \\<in> p ! i; y \\<in> p ! Suc n; Suc n < length p\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> (Restr lvE\n                                 (path_seg p i (Suc (Suc n))))\\<^sup>*", "case (step j)"], ["proof (state)\nthis:\n  i \\<le> j\n  j < j\n  \\<lbrakk>x \\<in> p ! i; ?y \\<in> p ! j; j < length p\\<rbrakk>\n  \\<Longrightarrow> (x, ?y) \\<in> (Restr lvE (path_seg p i (Suc j)))\\<^sup>*\n  x \\<in> p ! i\n  y \\<in> p ! Suc j\n  Suc j < length p\n\ngoal (1 subgoal):\n 1. \\<And>n y.\n       \\<lbrakk>i \\<le> n; n < j;\n        \\<And>y.\n           \\<lbrakk>x \\<in> p ! i; y \\<in> p ! n; n < length p\\<rbrakk>\n           \\<Longrightarrow> (x, y)\n                             \\<in> (Restr lvE\n                                     (path_seg p i (Suc n)))\\<^sup>*;\n        x \\<in> p ! i; y \\<in> p ! Suc n; Suc n < length p\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> (Restr lvE\n                                 (path_seg p i (Suc (Suc n))))\\<^sup>*", "let ?seg = \"path_seg p i (Suc j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n y.\n       \\<lbrakk>i \\<le> n; n < j;\n        \\<And>y.\n           \\<lbrakk>x \\<in> p ! i; y \\<in> p ! n; n < length p\\<rbrakk>\n           \\<Longrightarrow> (x, y)\n                             \\<in> (Restr lvE\n                                     (path_seg p i (Suc n)))\\<^sup>*;\n        x \\<in> p ! i; y \\<in> p ! Suc n; Suc n < length p\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> (Restr lvE\n                                 (path_seg p i (Suc (Suc n))))\\<^sup>*", "let ?seg' = \"path_seg p i (Suc (Suc j))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n y.\n       \\<lbrakk>i \\<le> n; n < j;\n        \\<And>y.\n           \\<lbrakk>x \\<in> p ! i; y \\<in> p ! n; n < length p\\<rbrakk>\n           \\<Longrightarrow> (x, y)\n                             \\<in> (Restr lvE\n                                     (path_seg p i (Suc n)))\\<^sup>*;\n        x \\<in> p ! i; y \\<in> p ! Suc n; Suc n < length p\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> (Restr lvE\n                                 (path_seg p i (Suc (Suc n))))\\<^sup>*", "have SSS: \"?seg \\<subseteq> ?seg'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_seg p i (Suc j) \\<subseteq> path_seg p i (Suc (Suc j))", "apply (subst path_seg_ss_eq)"], ["proof (prove)\ngoal (5 subgoals):\n 1. i < Suc j\n 2. Suc j \\<le> length p\n 3. i < Suc (Suc j)\n 4. Suc (Suc j) \\<le> length p\n 5. i \\<le> i \\<and> Suc j \\<le> Suc (Suc j)", "using step.hyps step.prems"], ["proof (prove)\nusing this:\n  i \\<le> j\n  j < j\n  x \\<in> p ! i\n  y \\<in> p ! Suc j\n  Suc j < length p\n\ngoal (5 subgoals):\n 1. i < Suc j\n 2. Suc j \\<le> length p\n 3. i < Suc (Suc j)\n 4. Suc (Suc j) \\<le> length p\n 5. i \\<le> i \\<and> Suc j \\<le> Suc (Suc j)", "by auto"], ["proof (state)\nthis:\n  path_seg p i (Suc j) \\<subseteq> path_seg p i (Suc (Suc j))\n\ngoal (1 subgoal):\n 1. \\<And>n y.\n       \\<lbrakk>i \\<le> n; n < j;\n        \\<And>y.\n           \\<lbrakk>x \\<in> p ! i; y \\<in> p ! n; n < length p\\<rbrakk>\n           \\<Longrightarrow> (x, y)\n                             \\<in> (Restr lvE\n                                     (path_seg p i (Suc n)))\\<^sup>*;\n        x \\<in> p ! i; y \\<in> p ! Suc n; Suc n < length p\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> (Restr lvE\n                                 (path_seg p i (Suc (Suc n))))\\<^sup>*", "from p_connected'[OF \\<open>Suc j < length p\\<close>]"], ["proof (chain)\npicking this:\n  p ! j \\<times> p ! Suc j \\<inter> lvE \\<noteq> {}", "obtain u v where \n      UV: \"(u,v)\\<in>lvE\" \"u\\<in>p!j\" \"v\\<in>p!Suc j\""], ["proof (prove)\nusing this:\n  p ! j \\<times> p ! Suc j \\<inter> lvE \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>(u, v) \\<in> lvE; u \\<in> p ! j; v \\<in> p ! Suc j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (u, v) \\<in> lvE\n  u \\<in> p ! j\n  v \\<in> p ! Suc j\n\ngoal (1 subgoal):\n 1. \\<And>n y.\n       \\<lbrakk>i \\<le> n; n < j;\n        \\<And>y.\n           \\<lbrakk>x \\<in> p ! i; y \\<in> p ! n; n < length p\\<rbrakk>\n           \\<Longrightarrow> (x, y)\n                             \\<in> (Restr lvE\n                                     (path_seg p i (Suc n)))\\<^sup>*;\n        x \\<in> p ! i; y \\<in> p ! Suc n; Suc n < length p\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> (Restr lvE\n                                 (path_seg p i (Suc (Suc n))))\\<^sup>*", "have ISS: \"p!j \\<subseteq> ?seg'\" \"p!Suc j \\<subseteq> ?seg'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ! j \\<subseteq> path_seg p i (Suc (Suc j)) &&&\n    p ! Suc j \\<subseteq> path_seg p i (Suc (Suc j))", "using step.hyps step.prems"], ["proof (prove)\nusing this:\n  i \\<le> j\n  j < j\n  x \\<in> p ! i\n  y \\<in> p ! Suc j\n  Suc j < length p\n\ngoal (1 subgoal):\n 1. p ! j \\<subseteq> path_seg p i (Suc (Suc j)) &&&\n    p ! Suc j \\<subseteq> path_seg p i (Suc (Suc j))", "by simp_all"], ["proof (state)\nthis:\n  p ! j \\<subseteq> path_seg p i (Suc (Suc j))\n  p ! Suc j \\<subseteq> path_seg p i (Suc (Suc j))\n\ngoal (1 subgoal):\n 1. \\<And>n y.\n       \\<lbrakk>i \\<le> n; n < j;\n        \\<And>y.\n           \\<lbrakk>x \\<in> p ! i; y \\<in> p ! n; n < length p\\<rbrakk>\n           \\<Longrightarrow> (x, y)\n                             \\<in> (Restr lvE\n                                     (path_seg p i (Suc n)))\\<^sup>*;\n        x \\<in> p ! i; y \\<in> p ! Suc n; Suc n < length p\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> (Restr lvE\n                                 (path_seg p i (Suc (Suc n))))\\<^sup>*", "from p_no_empty_idx[of j] \\<open>Suc j < length p\\<close>"], ["proof (chain)\npicking this:\n  j < length p \\<Longrightarrow> p ! j \\<noteq> {}\n  Suc j < length p", "obtain x' where \"x'\\<in>p!j\""], ["proof (prove)\nusing this:\n  j < length p \\<Longrightarrow> p ! j \\<noteq> {}\n  Suc j < length p\n\ngoal (1 subgoal):\n 1. (\\<And>x'. x' \\<in> p ! j \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x' \\<in> p ! j\n\ngoal (1 subgoal):\n 1. \\<And>n y.\n       \\<lbrakk>i \\<le> n; n < j;\n        \\<And>y.\n           \\<lbrakk>x \\<in> p ! i; y \\<in> p ! n; n < length p\\<rbrakk>\n           \\<Longrightarrow> (x, y)\n                             \\<in> (Restr lvE\n                                     (path_seg p i (Suc n)))\\<^sup>*;\n        x \\<in> p ! i; y \\<in> p ! Suc n; Suc n < length p\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> (Restr lvE\n                                 (path_seg p i (Suc (Suc n))))\\<^sup>*", "with step.IH[of x'] \\<open>x\\<in>p!i\\<close> \\<open>Suc j < length p\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>x \\<in> p ! i; x' \\<in> p ! j; j < length p\\<rbrakk>\n  \\<Longrightarrow> (x, x') \\<in> (Restr lvE (path_seg p i (Suc j)))\\<^sup>*\n  x \\<in> p ! i\n  Suc j < length p\n  x' \\<in> p ! j", "have t: \"(x,x')\\<in>(lvE\\<inter>?seg\\<times>?seg)\\<^sup>*\""], ["proof (prove)\nusing this:\n  \\<lbrakk>x \\<in> p ! i; x' \\<in> p ! j; j < length p\\<rbrakk>\n  \\<Longrightarrow> (x, x') \\<in> (Restr lvE (path_seg p i (Suc j)))\\<^sup>*\n  x \\<in> p ! i\n  Suc j < length p\n  x' \\<in> p ! j\n\ngoal (1 subgoal):\n 1. (x, x') \\<in> (Restr lvE (path_seg p i (Suc j)))\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (x, x') \\<in> (Restr lvE (path_seg p i (Suc j)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>n y.\n       \\<lbrakk>i \\<le> n; n < j;\n        \\<And>y.\n           \\<lbrakk>x \\<in> p ! i; y \\<in> p ! n; n < length p\\<rbrakk>\n           \\<Longrightarrow> (x, y)\n                             \\<in> (Restr lvE\n                                     (path_seg p i (Suc n)))\\<^sup>*;\n        x \\<in> p ! i; y \\<in> p ! Suc n; Suc n < length p\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> (Restr lvE\n                                 (path_seg p i (Suc (Suc n))))\\<^sup>*", "have \"(x,x')\\<in>(lvE\\<inter>?seg'\\<times>?seg')\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, x') \\<in> (Restr lvE (path_seg p i (Suc (Suc j))))\\<^sup>*", "using SSS"], ["proof (prove)\nusing this:\n  path_seg p i (Suc j) \\<subseteq> path_seg p i (Suc (Suc j))\n\ngoal (1 subgoal):\n 1. (x, x') \\<in> (Restr lvE (path_seg p i (Suc (Suc j))))\\<^sup>*", "by (auto intro: rtrancl_mono_mp[OF _ t])"], ["proof (state)\nthis:\n  (x, x') \\<in> (Restr lvE (path_seg p i (Suc (Suc j))))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>n y.\n       \\<lbrakk>i \\<le> n; n < j;\n        \\<And>y.\n           \\<lbrakk>x \\<in> p ! i; y \\<in> p ! n; n < length p\\<rbrakk>\n           \\<Longrightarrow> (x, y)\n                             \\<in> (Restr lvE\n                                     (path_seg p i (Suc n)))\\<^sup>*;\n        x \\<in> p ! i; y \\<in> p ! Suc n; Suc n < length p\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> (Restr lvE\n                                 (path_seg p i (Suc (Suc n))))\\<^sup>*", "also"], ["proof (state)\nthis:\n  (x, x') \\<in> (Restr lvE (path_seg p i (Suc (Suc j))))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>n y.\n       \\<lbrakk>i \\<le> n; n < j;\n        \\<And>y.\n           \\<lbrakk>x \\<in> p ! i; y \\<in> p ! n; n < length p\\<rbrakk>\n           \\<Longrightarrow> (x, y)\n                             \\<in> (Restr lvE\n                                     (path_seg p i (Suc n)))\\<^sup>*;\n        x \\<in> p ! i; y \\<in> p ! Suc n; Suc n < length p\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> (Restr lvE\n                                 (path_seg p i (Suc (Suc n))))\\<^sup>*", "from cnode_connectedI[OF _ \\<open>x'\\<in>p!j\\<close> \\<open>u\\<in>p!j\\<close>] \\<open>Suc j < length p\\<close>"], ["proof (chain)\npicking this:\n  j < length p \\<Longrightarrow> (x', u) \\<in> (Restr lvE (p ! j))\\<^sup>*\n  Suc j < length p", "have\n      t: \"(x', u) \\<in> (lvE \\<inter> p ! j \\<times> p ! j)\\<^sup>*\""], ["proof (prove)\nusing this:\n  j < length p \\<Longrightarrow> (x', u) \\<in> (Restr lvE (p ! j))\\<^sup>*\n  Suc j < length p\n\ngoal (1 subgoal):\n 1. (x', u) \\<in> (Restr lvE (p ! j))\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (x', u) \\<in> (Restr lvE (p ! j))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>n y.\n       \\<lbrakk>i \\<le> n; n < j;\n        \\<And>y.\n           \\<lbrakk>x \\<in> p ! i; y \\<in> p ! n; n < length p\\<rbrakk>\n           \\<Longrightarrow> (x, y)\n                             \\<in> (Restr lvE\n                                     (path_seg p i (Suc n)))\\<^sup>*;\n        x \\<in> p ! i; y \\<in> p ! Suc n; Suc n < length p\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> (Restr lvE\n                                 (path_seg p i (Suc (Suc n))))\\<^sup>*", "have \"(x', u) \\<in> (lvE\\<inter>?seg'\\<times>?seg')\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x', u) \\<in> (Restr lvE (path_seg p i (Suc (Suc j))))\\<^sup>*", "using ISS"], ["proof (prove)\nusing this:\n  p ! j \\<subseteq> path_seg p i (Suc (Suc j))\n  p ! Suc j \\<subseteq> path_seg p i (Suc (Suc j))\n\ngoal (1 subgoal):\n 1. (x', u) \\<in> (Restr lvE (path_seg p i (Suc (Suc j))))\\<^sup>*", "by (auto intro: rtrancl_mono_mp[OF _ t])"], ["proof (state)\nthis:\n  (x', u) \\<in> (Restr lvE (path_seg p i (Suc (Suc j))))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>n y.\n       \\<lbrakk>i \\<le> n; n < j;\n        \\<And>y.\n           \\<lbrakk>x \\<in> p ! i; y \\<in> p ! n; n < length p\\<rbrakk>\n           \\<Longrightarrow> (x, y)\n                             \\<in> (Restr lvE\n                                     (path_seg p i (Suc n)))\\<^sup>*;\n        x \\<in> p ! i; y \\<in> p ! Suc n; Suc n < length p\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> (Restr lvE\n                                 (path_seg p i (Suc (Suc n))))\\<^sup>*", "also"], ["proof (state)\nthis:\n  (x', u) \\<in> (Restr lvE (path_seg p i (Suc (Suc j))))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>n y.\n       \\<lbrakk>i \\<le> n; n < j;\n        \\<And>y.\n           \\<lbrakk>x \\<in> p ! i; y \\<in> p ! n; n < length p\\<rbrakk>\n           \\<Longrightarrow> (x, y)\n                             \\<in> (Restr lvE\n                                     (path_seg p i (Suc n)))\\<^sup>*;\n        x \\<in> p ! i; y \\<in> p ! Suc n; Suc n < length p\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> (Restr lvE\n                                 (path_seg p i (Suc (Suc n))))\\<^sup>*", "have \"(u,v)\\<in>lvE\\<inter>?seg'\\<times>?seg'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> Restr lvE (path_seg p i (Suc (Suc j)))", "using UV ISS"], ["proof (prove)\nusing this:\n  (u, v) \\<in> lvE\n  u \\<in> p ! j\n  v \\<in> p ! Suc j\n  p ! j \\<subseteq> path_seg p i (Suc (Suc j))\n  p ! Suc j \\<subseteq> path_seg p i (Suc (Suc j))\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> Restr lvE (path_seg p i (Suc (Suc j)))", "by auto"], ["proof (state)\nthis:\n  (u, v) \\<in> Restr lvE (path_seg p i (Suc (Suc j)))\n\ngoal (1 subgoal):\n 1. \\<And>n y.\n       \\<lbrakk>i \\<le> n; n < j;\n        \\<And>y.\n           \\<lbrakk>x \\<in> p ! i; y \\<in> p ! n; n < length p\\<rbrakk>\n           \\<Longrightarrow> (x, y)\n                             \\<in> (Restr lvE\n                                     (path_seg p i (Suc n)))\\<^sup>*;\n        x \\<in> p ! i; y \\<in> p ! Suc n; Suc n < length p\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> (Restr lvE\n                                 (path_seg p i (Suc (Suc n))))\\<^sup>*", "also"], ["proof (state)\nthis:\n  (u, v) \\<in> Restr lvE (path_seg p i (Suc (Suc j)))\n\ngoal (1 subgoal):\n 1. \\<And>n y.\n       \\<lbrakk>i \\<le> n; n < j;\n        \\<And>y.\n           \\<lbrakk>x \\<in> p ! i; y \\<in> p ! n; n < length p\\<rbrakk>\n           \\<Longrightarrow> (x, y)\n                             \\<in> (Restr lvE\n                                     (path_seg p i (Suc n)))\\<^sup>*;\n        x \\<in> p ! i; y \\<in> p ! Suc n; Suc n < length p\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> (Restr lvE\n                                 (path_seg p i (Suc (Suc n))))\\<^sup>*", "from cnode_connectedI[OF \\<open>Suc j < length p\\<close> \\<open>v\\<in>p!Suc j\\<close> \\<open>y\\<in>p!Suc j\\<close>]"], ["proof (chain)\npicking this:\n  (v, y) \\<in> (Restr lvE (p ! Suc j))\\<^sup>*", "have t: \"(v, y) \\<in> (lvE \\<inter> p ! Suc j \\<times> p ! Suc j)\\<^sup>*\""], ["proof (prove)\nusing this:\n  (v, y) \\<in> (Restr lvE (p ! Suc j))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (v, y) \\<in> (Restr lvE (p ! Suc j))\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (v, y) \\<in> (Restr lvE (p ! Suc j))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>n y.\n       \\<lbrakk>i \\<le> n; n < j;\n        \\<And>y.\n           \\<lbrakk>x \\<in> p ! i; y \\<in> p ! n; n < length p\\<rbrakk>\n           \\<Longrightarrow> (x, y)\n                             \\<in> (Restr lvE\n                                     (path_seg p i (Suc n)))\\<^sup>*;\n        x \\<in> p ! i; y \\<in> p ! Suc n; Suc n < length p\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> (Restr lvE\n                                 (path_seg p i (Suc (Suc n))))\\<^sup>*", "have \"(v, y) \\<in> (lvE\\<inter>?seg'\\<times>?seg')\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, y) \\<in> (Restr lvE (path_seg p i (Suc (Suc j))))\\<^sup>*", "using ISS"], ["proof (prove)\nusing this:\n  p ! j \\<subseteq> path_seg p i (Suc (Suc j))\n  p ! Suc j \\<subseteq> path_seg p i (Suc (Suc j))\n\ngoal (1 subgoal):\n 1. (v, y) \\<in> (Restr lvE (path_seg p i (Suc (Suc j))))\\<^sup>*", "by (auto intro: rtrancl_mono_mp[OF _ t])"], ["proof (state)\nthis:\n  (v, y) \\<in> (Restr lvE (path_seg p i (Suc (Suc j))))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>n y.\n       \\<lbrakk>i \\<le> n; n < j;\n        \\<And>y.\n           \\<lbrakk>x \\<in> p ! i; y \\<in> p ! n; n < length p\\<rbrakk>\n           \\<Longrightarrow> (x, y)\n                             \\<in> (Restr lvE\n                                     (path_seg p i (Suc n)))\\<^sup>*;\n        x \\<in> p ! i; y \\<in> p ! Suc n; Suc n < length p\\<rbrakk>\n       \\<Longrightarrow> (x, y)\n                         \\<in> (Restr lvE\n                                 (path_seg p i (Suc (Suc n))))\\<^sup>*", "finally"], ["proof (chain)\npicking this:\n  (x, y) \\<in> (Restr lvE (path_seg p i (Suc (Suc j))))\\<^sup>*", "show \"(x,y)\\<in>(lvE\\<inter>?seg'\\<times>?seg')\\<^sup>*\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> (Restr lvE (path_seg p i (Suc (Suc j))))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (x, y) \\<in> (Restr lvE (path_seg p i (Suc (Suc j))))\\<^sup>*", "."], ["proof (state)\nthis:\n  (x, y) \\<in> (Restr lvE (path_seg p i (Suc (Suc j))))\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma p_reachable: \"\\<Union>(set p) \\<subseteq> E\\<^sup>*``{v0}\" \\<comment> \\<open>Nodes on path are reachable\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set p) \\<subseteq> E\\<^sup>* `` {v0}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set p) \\<Longrightarrow> x \\<in> E\\<^sup>* `` {v0}", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set p) \\<Longrightarrow> x \\<in> E\\<^sup>* `` {v0}", "assume A: \"v\\<in>\\<Union>(set p)\""], ["proof (state)\nthis:\n  v \\<in> \\<Union> (set p)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set p) \\<Longrightarrow> x \\<in> E\\<^sup>* `` {v0}", "then"], ["proof (chain)\npicking this:\n  v \\<in> \\<Union> (set p)", "obtain i where \"i<length p\" and \"v\\<in>p!i\""], ["proof (prove)\nusing this:\n  v \\<in> \\<Union> (set p)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length p; v \\<in> p ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis UnionE in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length p\n  v \\<in> p ! i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set p) \\<Longrightarrow> x \\<in> E\\<^sup>* `` {v0}", "moreover"], ["proof (state)\nthis:\n  i < length p\n  v \\<in> p ! i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set p) \\<Longrightarrow> x \\<in> E\\<^sup>* `` {v0}", "from A root_v0"], ["proof (chain)\npicking this:\n  v \\<in> \\<Union> (set p)\n  p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p", "have \"v0\\<in>p!0\""], ["proof (prove)\nusing this:\n  v \\<in> \\<Union> (set p)\n  p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p\n\ngoal (1 subgoal):\n 1. v0 \\<in> p ! 0", "by (cases p) auto"], ["proof (state)\nthis:\n  v0 \\<in> p ! 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set p) \\<Longrightarrow> x \\<in> E\\<^sup>* `` {v0}", "ultimately"], ["proof (chain)\npicking this:\n  i < length p\n  v \\<in> p ! i\n  v0 \\<in> p ! 0", "have \n      t: \"(v0,v)\\<in>(lvE \\<inter> path_seg p 0 (Suc i) \\<times> path_seg p 0 (Suc i))\\<^sup>*\""], ["proof (prove)\nusing this:\n  i < length p\n  v \\<in> p ! i\n  v0 \\<in> p ! 0\n\ngoal (1 subgoal):\n 1. (v0, v) \\<in> (Restr lvE (path_seg p 0 (Suc i)))\\<^sup>*", "by (auto intro: pathI)"], ["proof (state)\nthis:\n  (v0, v) \\<in> (Restr lvE (path_seg p 0 (Suc i)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set p) \\<Longrightarrow> x \\<in> E\\<^sup>* `` {v0}", "from lvE_ss_E"], ["proof (chain)\npicking this:\n  lvE \\<subseteq> E", "have \"(v0,v)\\<in>E\\<^sup>*\""], ["proof (prove)\nusing this:\n  lvE \\<subseteq> E\n\ngoal (1 subgoal):\n 1. (v0, v) \\<in> E\\<^sup>*", "by (auto intro: rtrancl_mono_mp[OF _ t])"], ["proof (state)\nthis:\n  (v0, v) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set p) \\<Longrightarrow> x \\<in> E\\<^sup>* `` {v0}", "thus \"v\\<in>E\\<^sup>*``{v0}\""], ["proof (prove)\nusing this:\n  (v0, v) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. v \\<in> E\\<^sup>* `` {v0}", "by auto"], ["proof (state)\nthis:\n  v \\<in> E\\<^sup>* `` {v0}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma touched_reachable: \"ltouched \\<subseteq> E\\<^sup>*``V0\" \\<comment> \\<open>Touched nodes are reachable\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ltouched \\<subseteq> reachable", "unfolding touched_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. D \\<union> \\<Union> (set p) \\<subseteq> reachable", "using p_reachable D_reachable"], ["proof (prove)\nusing this:\n  \\<Union> (set p) \\<subseteq> E\\<^sup>* `` {v0}\n  D \\<subseteq> reachable\n\ngoal (1 subgoal):\n 1. D \\<union> \\<Union> (set p) \\<subseteq> reachable", "by blast"], ["", "lemma vE_reachable: \"lvE \\<subseteq> E\\<^sup>*``V0 \\<times> E\\<^sup>*``V0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lvE \\<subseteq> reachable \\<times> reachable", "apply (rule order_trans[OF vE_touched])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ltouched \\<times> ltouched \\<subseteq> reachable \\<times> reachable", "using touched_reachable"], ["proof (prove)\nusing this:\n  ltouched \\<subseteq> reachable\n\ngoal (1 subgoal):\n 1. ltouched \\<times> ltouched \\<subseteq> reachable \\<times> reachable", "by blast"], ["", "lemma pE_reachable: \"pE \\<subseteq> E\\<^sup>*``{v0} \\<times> E\\<^sup>*``{v0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pE \\<subseteq> E\\<^sup>* `` {v0} \\<times> E\\<^sup>* `` {v0}", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b. (a, b) \\<in> pE \\<Longrightarrow> (v0, a) \\<in> E\\<^sup>*\n 2. \\<And>a b. (a, b) \\<in> pE \\<Longrightarrow> (v0, b) \\<in> E\\<^sup>*", "fix u v"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b. (a, b) \\<in> pE \\<Longrightarrow> (v0, a) \\<in> E\\<^sup>*\n 2. \\<And>a b. (a, b) \\<in> pE \\<Longrightarrow> (v0, b) \\<in> E\\<^sup>*", "assume E: \"(u,v)\\<in>pE\""], ["proof (state)\nthis:\n  (u, v) \\<in> pE\n\ngoal (2 subgoals):\n 1. \\<And>a b. (a, b) \\<in> pE \\<Longrightarrow> (v0, a) \\<in> E\\<^sup>*\n 2. \\<And>a b. (a, b) \\<in> pE \\<Longrightarrow> (v0, b) \\<in> E\\<^sup>*", "with pE_E_from_p p_reachable"], ["proof (chain)\npicking this:\n  pE \\<subseteq> E \\<inter> \\<Union> (set p) \\<times> UNIV\n  \\<Union> (set p) \\<subseteq> E\\<^sup>* `` {v0}\n  (u, v) \\<in> pE", "have \"(v0,u)\\<in>E\\<^sup>*\" \"(u,v)\\<in>E\""], ["proof (prove)\nusing this:\n  pE \\<subseteq> E \\<inter> \\<Union> (set p) \\<times> UNIV\n  \\<Union> (set p) \\<subseteq> E\\<^sup>* `` {v0}\n  (u, v) \\<in> pE\n\ngoal (1 subgoal):\n 1. (v0, u) \\<in> E\\<^sup>* &&& (u, v) \\<in> E", "by blast+"], ["proof (state)\nthis:\n  (v0, u) \\<in> E\\<^sup>*\n  (u, v) \\<in> E\n\ngoal (2 subgoals):\n 1. \\<And>a b. (a, b) \\<in> pE \\<Longrightarrow> (v0, a) \\<in> E\\<^sup>*\n 2. \\<And>a b. (a, b) \\<in> pE \\<Longrightarrow> (v0, b) \\<in> E\\<^sup>*", "thus \"(v0,u)\\<in>E\\<^sup>*\" \"(v0,v)\\<in>E\\<^sup>*\""], ["proof (prove)\nusing this:\n  (v0, u) \\<in> E\\<^sup>*\n  (u, v) \\<in> E\n\ngoal (1 subgoal):\n 1. (v0, u) \\<in> E\\<^sup>* &&& (v0, v) \\<in> E\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (v0, u) \\<in> E\\<^sup>*\n  (v0, v) \\<in> E\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma D_closed_vE_rtrancl: \"lvE\\<^sup>*``D \\<subseteq> D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lvE\\<^sup>* `` D \\<subseteq> D", "by (metis D_closed Image_closed_trancl eq_iff reachable_mono lvE_ss_E)"], ["", "lemma D_closed_path: \"\\<lbrakk>path E u q w; u\\<in>D\\<rbrakk> \\<Longrightarrow> set q \\<subseteq> D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path E u q w; u \\<in> D\\<rbrakk>\n    \\<Longrightarrow> set q \\<subseteq> D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>path E u q w; u \\<in> D\\<rbrakk>\n    \\<Longrightarrow> set q \\<subseteq> D", "assume a1: \"path E u q w\""], ["proof (state)\nthis:\n  path E u q w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path E u q w; u \\<in> D\\<rbrakk>\n    \\<Longrightarrow> set q \\<subseteq> D", "assume \"u \\<in> D\""], ["proof (state)\nthis:\n  u \\<in> D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path E u q w; u \\<in> D\\<rbrakk>\n    \\<Longrightarrow> set q \\<subseteq> D", "hence f1: \"{u} \\<subseteq> D\""], ["proof (prove)\nusing this:\n  u \\<in> D\n\ngoal (1 subgoal):\n 1. {u} \\<subseteq> D", "using bot.extremum"], ["proof (prove)\nusing this:\n  u \\<in> D\n  bot \\<le> ?a\n\ngoal (1 subgoal):\n 1. {u} \\<subseteq> D", "by force"], ["proof (state)\nthis:\n  {u} \\<subseteq> D\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path E u q w; u \\<in> D\\<rbrakk>\n    \\<Longrightarrow> set q \\<subseteq> D", "have \"set q \\<subseteq> E\\<^sup>* `` {u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set q \\<subseteq> E\\<^sup>* `` {u}", "using a1"], ["proof (prove)\nusing this:\n  path E u q w\n\ngoal (1 subgoal):\n 1. set q \\<subseteq> E\\<^sup>* `` {u}", "by (metis insert_subset path_nodes_reachable)"], ["proof (state)\nthis:\n  set q \\<subseteq> E\\<^sup>* `` {u}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>path E u q w; u \\<in> D\\<rbrakk>\n    \\<Longrightarrow> set q \\<subseteq> D", "thus \"set q \\<subseteq> D\""], ["proof (prove)\nusing this:\n  set q \\<subseteq> E\\<^sup>* `` {u}\n\ngoal (1 subgoal):\n 1. set q \\<subseteq> D", "using f1"], ["proof (prove)\nusing this:\n  set q \\<subseteq> E\\<^sup>* `` {u}\n  {u} \\<subseteq> D\n\ngoal (1 subgoal):\n 1. set q \\<subseteq> D", "by (metis D_closed rtrancl_reachable_induct subset_trans)"], ["proof (state)\nthis:\n  set q \\<subseteq> D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma D_closed_path_vE: \"\\<lbrakk>path lvE u q w; u\\<in>D\\<rbrakk> \\<Longrightarrow> set q \\<subseteq> D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path lvE u q w; u \\<in> D\\<rbrakk>\n    \\<Longrightarrow> set q \\<subseteq> D", "by (metis D_closed_path path_mono lvE_ss_E)"], ["", "lemma path_in_lastnode:\n    assumes P: \"path lvE u q v\"\n    assumes [simp]: \"p\\<noteq>[]\"\n    assumes ND: \"u\\<in>last p\" \"v\\<in>last p\"\n    shows \"set q \\<subseteq> last p\"\n    \\<comment> \\<open>A path from the last Cnode to the last Cnode remains in the last Cnode\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. set q \\<subseteq> last p", "(* TODO: This can be generalized in two directions: \n      either 1) The path end anywhere. Due to vE_touched we can infer \n        that it ends in last cnode  \n      or 2) We may use any cnode, not only the last one\n    *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set q \\<subseteq> last p", "using P ND"], ["proof (prove)\nusing this:\n  path lvE u q v\n  u \\<in> last p\n  v \\<in> last p\n\ngoal (1 subgoal):\n 1. set q \\<subseteq> last p", "proof (induction)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>u \\<in> last p; u \\<in> last p\\<rbrakk>\n       \\<Longrightarrow> set [] \\<subseteq> last p\n 2. \\<And>u v l w.\n       \\<lbrakk>(u, v) \\<in> lvE; path lvE v l w;\n        \\<lbrakk>v \\<in> last p; w \\<in> last p\\<rbrakk>\n        \\<Longrightarrow> set l \\<subseteq> last p;\n        u \\<in> last p; w \\<in> last p\\<rbrakk>\n       \\<Longrightarrow> set (u # l) \\<subseteq> last p", "case (path_prepend u v l w)"], ["proof (state)\nthis:\n  (u, v) \\<in> lvE\n  path lvE v l w\n  \\<lbrakk>v \\<in> last p; w \\<in> last p\\<rbrakk>\n  \\<Longrightarrow> set l \\<subseteq> last p\n  u \\<in> last p\n  w \\<in> last p\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>u \\<in> last p; u \\<in> last p\\<rbrakk>\n       \\<Longrightarrow> set [] \\<subseteq> last p\n 2. \\<And>u v l w.\n       \\<lbrakk>(u, v) \\<in> lvE; path lvE v l w;\n        \\<lbrakk>v \\<in> last p; w \\<in> last p\\<rbrakk>\n        \\<Longrightarrow> set l \\<subseteq> last p;\n        u \\<in> last p; w \\<in> last p\\<rbrakk>\n       \\<Longrightarrow> set (u # l) \\<subseteq> last p", "from \\<open>(u,v)\\<in>lvE\\<close> vE_touched"], ["proof (chain)\npicking this:\n  (u, v) \\<in> lvE\n  lvE \\<subseteq> ltouched \\<times> ltouched", "have \"v\\<in>ltouched\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> lvE\n  lvE \\<subseteq> ltouched \\<times> ltouched\n\ngoal (1 subgoal):\n 1. v \\<in> ltouched", "by auto"], ["proof (state)\nthis:\n  v \\<in> ltouched\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>u \\<in> last p; u \\<in> last p\\<rbrakk>\n       \\<Longrightarrow> set [] \\<subseteq> last p\n 2. \\<And>u v l w.\n       \\<lbrakk>(u, v) \\<in> lvE; path lvE v l w;\n        \\<lbrakk>v \\<in> last p; w \\<in> last p\\<rbrakk>\n        \\<Longrightarrow> set l \\<subseteq> last p;\n        u \\<in> last p; w \\<in> last p\\<rbrakk>\n       \\<Longrightarrow> set (u # l) \\<subseteq> last p", "hence \"v\\<in>\\<Union>(set p)\""], ["proof (prove)\nusing this:\n  v \\<in> ltouched\n\ngoal (1 subgoal):\n 1. v \\<in> \\<Union> (set p)", "unfolding touched_def"], ["proof (prove)\nusing this:\n  v \\<in> D \\<union> \\<Union> (set p)\n\ngoal (1 subgoal):\n 1. v \\<in> \\<Union> (set p)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. v \\<in> D \\<Longrightarrow> v \\<in> \\<Union> (set p)\n 2. v \\<in> \\<Union> (set p) \\<Longrightarrow> v \\<in> \\<Union> (set p)", "assume \"v\\<in>D\""], ["proof (state)\nthis:\n  v \\<in> D\n\ngoal (2 subgoals):\n 1. v \\<in> D \\<Longrightarrow> v \\<in> \\<Union> (set p)\n 2. v \\<in> \\<Union> (set p) \\<Longrightarrow> v \\<in> \\<Union> (set p)", "moreover"], ["proof (state)\nthis:\n  v \\<in> D\n\ngoal (2 subgoals):\n 1. v \\<in> D \\<Longrightarrow> v \\<in> \\<Union> (set p)\n 2. v \\<in> \\<Union> (set p) \\<Longrightarrow> v \\<in> \\<Union> (set p)", "from \\<open>path lvE v l w\\<close>"], ["proof (chain)\npicking this:\n  path lvE v l w", "have \"(v,w)\\<in>lvE\\<^sup>*\""], ["proof (prove)\nusing this:\n  path lvE v l w\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> lvE\\<^sup>*", "by (rule path_is_rtrancl)"], ["proof (state)\nthis:\n  (v, w) \\<in> lvE\\<^sup>*\n\ngoal (2 subgoals):\n 1. v \\<in> D \\<Longrightarrow> v \\<in> \\<Union> (set p)\n 2. v \\<in> \\<Union> (set p) \\<Longrightarrow> v \\<in> \\<Union> (set p)", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> D\n  (v, w) \\<in> lvE\\<^sup>*", "have \"w\\<in>D\""], ["proof (prove)\nusing this:\n  v \\<in> D\n  (v, w) \\<in> lvE\\<^sup>*\n\ngoal (1 subgoal):\n 1. w \\<in> D", "using D_closed_vE_rtrancl"], ["proof (prove)\nusing this:\n  v \\<in> D\n  (v, w) \\<in> lvE\\<^sup>*\n  lvE\\<^sup>* `` D \\<subseteq> D\n\ngoal (1 subgoal):\n 1. w \\<in> D", "by auto"], ["proof (state)\nthis:\n  w \\<in> D\n\ngoal (2 subgoals):\n 1. v \\<in> D \\<Longrightarrow> v \\<in> \\<Union> (set p)\n 2. v \\<in> \\<Union> (set p) \\<Longrightarrow> v \\<in> \\<Union> (set p)", "with \\<open>w\\<in>last p\\<close> p_not_D"], ["proof (chain)\npicking this:\n  w \\<in> last p\n  \\<Union> (set p) \\<inter> D = {}\n  w \\<in> D", "have False"], ["proof (prove)\nusing this:\n  w \\<in> last p\n  \\<Union> (set p) \\<inter> D = {}\n  w \\<in> D\n\ngoal (1 subgoal):\n 1. False", "by (metis IntI Misc.last_in_set Sup_inf_eq_bot_iff assms(2) \n          bex_empty path_prepend.hyps(2))"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. v \\<in> D \\<Longrightarrow> v \\<in> \\<Union> (set p)\n 2. v \\<in> \\<Union> (set p) \\<Longrightarrow> v \\<in> \\<Union> (set p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. v \\<in> \\<Union> (set p)", ".."], ["proof (state)\nthis:\n  v \\<in> \\<Union> (set p)\n\ngoal (1 subgoal):\n 1. v \\<in> \\<Union> (set p) \\<Longrightarrow> v \\<in> \\<Union> (set p)", "qed"], ["proof (state)\nthis:\n  v \\<in> \\<Union> (set p)\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>u \\<in> last p; u \\<in> last p\\<rbrakk>\n       \\<Longrightarrow> set [] \\<subseteq> last p\n 2. \\<And>u v l w.\n       \\<lbrakk>(u, v) \\<in> lvE; path lvE v l w;\n        \\<lbrakk>v \\<in> last p; w \\<in> last p\\<rbrakk>\n        \\<Longrightarrow> set l \\<subseteq> last p;\n        u \\<in> last p; w \\<in> last p\\<rbrakk>\n       \\<Longrightarrow> set (u # l) \\<subseteq> last p", "then"], ["proof (chain)\npicking this:\n  v \\<in> \\<Union> (set p)", "obtain i where \"i<length p\" \"v\\<in>p!i\""], ["proof (prove)\nusing this:\n  v \\<in> \\<Union> (set p)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length p; v \\<in> p ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis UnionE in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length p\n  v \\<in> p ! i\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>u \\<in> last p; u \\<in> last p\\<rbrakk>\n       \\<Longrightarrow> set [] \\<subseteq> last p\n 2. \\<And>u v l w.\n       \\<lbrakk>(u, v) \\<in> lvE; path lvE v l w;\n        \\<lbrakk>v \\<in> last p; w \\<in> last p\\<rbrakk>\n        \\<Longrightarrow> set l \\<subseteq> last p;\n        u \\<in> last p; w \\<in> last p\\<rbrakk>\n       \\<Longrightarrow> set (u # l) \\<subseteq> last p", "have \"i=length p - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = length p - 1", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> length p - 1 \\<Longrightarrow> False", "assume \"i\\<noteq>length p - 1\""], ["proof (state)\nthis:\n  i \\<noteq> length p - 1\n\ngoal (1 subgoal):\n 1. i \\<noteq> length p - 1 \\<Longrightarrow> False", "with \\<open>i<length p\\<close>"], ["proof (chain)\npicking this:\n  i < length p\n  i \\<noteq> length p - 1", "have \"i < length p - 1\""], ["proof (prove)\nusing this:\n  i < length p\n  i \\<noteq> length p - 1\n\ngoal (1 subgoal):\n 1. i < length p - 1", "by simp"], ["proof (state)\nthis:\n  i < length p - 1\n\ngoal (1 subgoal):\n 1. i \\<noteq> length p - 1 \\<Longrightarrow> False", "with vE_no_back[of i \"length p - 1\"] \\<open>i<length p\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>i < length p - 1; length p - 1 < length p\\<rbrakk>\n  \\<Longrightarrow> lvE \\<inter> p ! (length p - 1) \\<times> p ! i = {}\n  i < length p\n  i < length p - 1", "have \"lvE \\<inter> last p \\<times> p!i = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i < length p - 1; length p - 1 < length p\\<rbrakk>\n  \\<Longrightarrow> lvE \\<inter> p ! (length p - 1) \\<times> p ! i = {}\n  i < length p\n  i < length p - 1\n\ngoal (1 subgoal):\n 1. lvE \\<inter> last p \\<times> p ! i = {}", "by (simp add: last_conv_nth)"], ["proof (state)\nthis:\n  lvE \\<inter> last p \\<times> p ! i = {}\n\ngoal (1 subgoal):\n 1. i \\<noteq> length p - 1 \\<Longrightarrow> False", "with \\<open>(u,v)\\<in>lvE\\<close> \\<open>u\\<in>last p\\<close> \\<open>v\\<in>p!i\\<close>"], ["proof (chain)\npicking this:\n  (u, v) \\<in> lvE\n  u \\<in> last p\n  v \\<in> p ! i\n  lvE \\<inter> last p \\<times> p ! i = {}", "show False"], ["proof (prove)\nusing this:\n  (u, v) \\<in> lvE\n  u \\<in> last p\n  v \\<in> p ! i\n  lvE \\<inter> last p \\<times> p ! i = {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i = length p - 1\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>u \\<in> last p; u \\<in> last p\\<rbrakk>\n       \\<Longrightarrow> set [] \\<subseteq> last p\n 2. \\<And>u v l w.\n       \\<lbrakk>(u, v) \\<in> lvE; path lvE v l w;\n        \\<lbrakk>v \\<in> last p; w \\<in> last p\\<rbrakk>\n        \\<Longrightarrow> set l \\<subseteq> last p;\n        u \\<in> last p; w \\<in> last p\\<rbrakk>\n       \\<Longrightarrow> set (u # l) \\<subseteq> last p", "with \\<open>v\\<in>p!i\\<close>"], ["proof (chain)\npicking this:\n  v \\<in> p ! i\n  i = length p - 1", "have \"v\\<in>last p\""], ["proof (prove)\nusing this:\n  v \\<in> p ! i\n  i = length p - 1\n\ngoal (1 subgoal):\n 1. v \\<in> last p", "by (simp add: last_conv_nth)"], ["proof (state)\nthis:\n  v \\<in> last p\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>u \\<in> last p; u \\<in> last p\\<rbrakk>\n       \\<Longrightarrow> set [] \\<subseteq> last p\n 2. \\<And>u v l w.\n       \\<lbrakk>(u, v) \\<in> lvE; path lvE v l w;\n        \\<lbrakk>v \\<in> last p; w \\<in> last p\\<rbrakk>\n        \\<Longrightarrow> set l \\<subseteq> last p;\n        u \\<in> last p; w \\<in> last p\\<rbrakk>\n       \\<Longrightarrow> set (u # l) \\<subseteq> last p", "with path_prepend.IH \\<open>w\\<in>last p\\<close> \\<open>u\\<in>last p\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>v \\<in> last p; w \\<in> last p\\<rbrakk>\n  \\<Longrightarrow> set l \\<subseteq> last p\n  w \\<in> last p\n  u \\<in> last p\n  v \\<in> last p", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>v \\<in> last p; w \\<in> last p\\<rbrakk>\n  \\<Longrightarrow> set l \\<subseteq> last p\n  w \\<in> last p\n  u \\<in> last p\n  v \\<in> last p\n\ngoal (1 subgoal):\n 1. set (u # l) \\<subseteq> last p", "by auto"], ["proof (state)\nthis:\n  set (u # l) \\<subseteq> last p\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>u \\<in> last p; u \\<in> last p\\<rbrakk>\n       \\<Longrightarrow> set [] \\<subseteq> last p", "qed simp"], ["", "lemma loop_in_lastnode:\n    assumes P: \"path lvE u q u\"\n    assumes [simp]: \"p\\<noteq>[]\"\n    assumes ND: \"set q \\<inter> last p \\<noteq> {}\"\n    shows \"u\\<in>last p\" and \"set q \\<subseteq> last p\"\n    \\<comment> \\<open>A loop that touches the last node is completely inside the last node\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> last p &&& set q \\<subseteq> last p", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<in> last p\n 2. set q \\<subseteq> last p", "from ND"], ["proof (chain)\npicking this:\n  set q \\<inter> last p \\<noteq> {}", "obtain v where \"v\\<in>set q\" \"v\\<in>last p\""], ["proof (prove)\nusing this:\n  set q \\<inter> last p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> set q; v \\<in> last p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> set q\n  v \\<in> last p\n\ngoal (2 subgoals):\n 1. u \\<in> last p\n 2. set q \\<subseteq> last p", "then"], ["proof (chain)\npicking this:\n  v \\<in> set q\n  v \\<in> last p", "obtain q1 q2 where [simp]: \"q=q1@v#q2\""], ["proof (prove)\nusing this:\n  v \\<in> set q\n  v \\<in> last p\n\ngoal (1 subgoal):\n 1. (\\<And>q1 q2.\n        q = q1 @ v # q2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_decomp)"], ["proof (state)\nthis:\n  q = q1 @ v # q2\n\ngoal (2 subgoals):\n 1. u \\<in> last p\n 2. set q \\<subseteq> last p", "from P"], ["proof (chain)\npicking this:\n  path lvE u q u", "have \"path lvE v (v#q2@q1) v\""], ["proof (prove)\nusing this:\n  path lvE u q u\n\ngoal (1 subgoal):\n 1. path lvE v (v # q2 @ q1) v", "by (auto simp: path_conc_conv path_cons_conv)"], ["proof (state)\nthis:\n  path lvE v (v # q2 @ q1) v\n\ngoal (2 subgoals):\n 1. u \\<in> last p\n 2. set q \\<subseteq> last p", "from path_in_lastnode[OF this \\<open>p\\<noteq>[]\\<close> \\<open>v\\<in>last p\\<close> \\<open>v\\<in>last p\\<close>]"], ["proof (chain)\npicking this:\n  set (v # q2 @ q1) \\<subseteq> last p", "show \"set q \\<subseteq> last p\""], ["proof (prove)\nusing this:\n  set (v # q2 @ q1) \\<subseteq> last p\n\ngoal (1 subgoal):\n 1. set q \\<subseteq> last p", "by simp"], ["proof (state)\nthis:\n  set q \\<subseteq> last p\n\ngoal (1 subgoal):\n 1. u \\<in> last p", "from P"], ["proof (chain)\npicking this:\n  path lvE u q u", "show \"u\\<in>last p\""], ["proof (prove)\nusing this:\n  path lvE u q u\n\ngoal (1 subgoal):\n 1. u \\<in> last p", "apply (cases q, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>path lvE u q u; q = a # list\\<rbrakk>\n       \\<Longrightarrow> u \\<in> last p", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>path lvE u (a # list) u; q1 @ v # q2 = a # list\\<rbrakk>\n       \\<Longrightarrow> u \\<in> last p", "using \\<open>set q \\<subseteq> last p\\<close>"], ["proof (prove)\nusing this:\n  set q \\<subseteq> last p\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>path lvE u (a # list) u; q1 @ v # q2 = a # list\\<rbrakk>\n       \\<Longrightarrow> u \\<in> last p", "apply (auto simp: path_cons_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  u \\<in> last p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_D_p_edges: \"E \\<inter> D \\<times> \\<Union>(set p) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<inter> D \\<times> \\<Union> (set p) = {}", "using D_closed p_not_D"], ["proof (prove)\nusing this:\n  E `` D \\<subseteq> D\n  \\<Union> (set p) \\<inter> D = {}\n\ngoal (1 subgoal):\n 1. E \\<inter> D \\<times> \\<Union> (set p) = {}", "by auto"], ["", "lemma idx_of_props:\n    assumes ON_STACK: \"v\\<in>\\<Union>(set p)\"\n    shows \n      \"idx_of p v < length p\" and\n      \"v \\<in> p ! idx_of p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idx_of p v < length p &&& v \\<in> p ! idx_of p v", "using idx_of_props[OF _ assms] p_disjoint_sym"], ["proof (prove)\nusing this:\n  \\<forall>i j v.\n     i < length p \\<and>\n     j < length p \\<and>\n     v \\<in> p ! i \\<and> v \\<in> p ! j \\<longrightarrow>\n     i = j \\<Longrightarrow>\n  idx_of p v < length p\n  \\<forall>i j v.\n     i < length p \\<and>\n     j < length p \\<and>\n     v \\<in> p ! i \\<and> v \\<in> p ! j \\<longrightarrow>\n     i = j \\<Longrightarrow>\n  v \\<in> p ! idx_of p v\n  \\<lbrakk>?i < length p; ?j < length p; ?v \\<in> p ! ?i;\n   ?v \\<in> p ! ?j\\<rbrakk>\n  \\<Longrightarrow> ?i = ?j\n\ngoal (1 subgoal):\n 1. idx_of p v < length p &&& v \\<in> p ! idx_of p v", "by blast+"], ["", "end"], ["", "subsubsection \\<open>Auxiliary Lemmas Regarding the Operations\\<close>"], ["", "lemma (in fr_graph) vE_initial[simp]: \"vE [{v0}] {} (E \\<inter> {v0} \\<times> UNIV) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vE [{v0}] {} (E \\<inter> {v0} \\<times> UNIV) = {}", "unfolding vE_def touched_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<inter> ({} \\<union> \\<Union> (set [{v0}])) \\<times> UNIV -\n    E \\<inter> {v0} \\<times> UNIV =\n    {}", "by auto"], ["", "context invar_loc\nbegin"], ["", "lemma vE_push: \"\\<lbrakk> (u,v)\\<in>pE; u\\<in>last p; v\\<notin>\\<Union>(set p); v\\<notin>D \\<rbrakk> \n    \\<Longrightarrow> vE (p @ [{v}]) D ((pE - {(u,v)}) \\<union> E\\<inter>{v}\\<times>UNIV) = insert (u,v) lvE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, v) \\<in> pE; u \\<in> last p; v \\<notin> \\<Union> (set p);\n     v \\<notin> D\\<rbrakk>\n    \\<Longrightarrow> vE (p @ [{v}]) D\n                       (pE - {(u, v)} \\<union>\n                        E \\<inter> {v} \\<times> UNIV) =\n                      insert (u, v) lvE", "unfolding vE_def touched_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, v) \\<in> pE; u \\<in> last p; v \\<notin> \\<Union> (set p);\n     v \\<notin> D\\<rbrakk>\n    \\<Longrightarrow> E \\<inter>\n                      (D \\<union> \\<Union> (set (p @ [{v}]))) \\<times>\n                      UNIV -\n                      (pE - {(u, v)} \\<union>\n                       E \\<inter> {v} \\<times> UNIV) =\n                      insert (u, v)\n                       (E \\<inter>\n                        (D \\<union> \\<Union> (set p)) \\<times> UNIV -\n                        pE)", "using pE_E_from_p"], ["proof (prove)\nusing this:\n  pE \\<subseteq> E \\<inter> \\<Union> (set p) \\<times> UNIV\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, v) \\<in> pE; u \\<in> last p; v \\<notin> \\<Union> (set p);\n     v \\<notin> D\\<rbrakk>\n    \\<Longrightarrow> E \\<inter>\n                      (D \\<union> \\<Union> (set (p @ [{v}]))) \\<times>\n                      UNIV -\n                      (pE - {(u, v)} \\<union>\n                       E \\<inter> {v} \\<times> UNIV) =\n                      insert (u, v)\n                       (E \\<inter>\n                        (D \\<union> \\<Union> (set p)) \\<times> UNIV -\n                        pE)", "by auto"], ["", "lemma vE_remove[simp]: \n    \"\\<lbrakk>p\\<noteq>[]; (u,v)\\<in>pE\\<rbrakk> \\<Longrightarrow> vE p D (pE - {(u,v)}) = insert (u,v) lvE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> []; (u, v) \\<in> pE\\<rbrakk>\n    \\<Longrightarrow> vE p D (pE - {(u, v)}) = insert (u, v) lvE", "unfolding vE_def touched_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> []; (u, v) \\<in> pE\\<rbrakk>\n    \\<Longrightarrow> E \\<inter>\n                      (D \\<union> \\<Union> (set p)) \\<times> UNIV -\n                      (pE - {(u, v)}) =\n                      insert (u, v)\n                       (E \\<inter>\n                        (D \\<union> \\<Union> (set p)) \\<times> UNIV -\n                        pE)", "using pE_E_from_p"], ["proof (prove)\nusing this:\n  pE \\<subseteq> E \\<inter> \\<Union> (set p) \\<times> UNIV\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> []; (u, v) \\<in> pE\\<rbrakk>\n    \\<Longrightarrow> E \\<inter>\n                      (D \\<union> \\<Union> (set p)) \\<times> UNIV -\n                      (pE - {(u, v)}) =\n                      insert (u, v)\n                       (E \\<inter>\n                        (D \\<union> \\<Union> (set p)) \\<times> UNIV -\n                        pE)", "by blast"], ["", "lemma vE_pop[simp]: \"p\\<noteq>[] \\<Longrightarrow> vE (butlast p) (last p \\<union> D) pE = lvE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    vE (butlast p) (last p \\<union> D) pE = lvE", "unfolding vE_def touched_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    E \\<inter>\n    (last p \\<union> D \\<union> \\<Union> (set (butlast p))) \\<times> UNIV -\n    pE =\n    E \\<inter> (D \\<union> \\<Union> (set p)) \\<times> UNIV - pE", "by (cases p rule: rev_cases) auto"], ["", "lemma pE_fin: \"p=[] \\<Longrightarrow> pE={}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = [] \\<Longrightarrow> pE = {}", "using pE_by_vE"], ["proof (prove)\nusing this:\n  pE = E \\<inter> \\<Union> (set p) \\<times> UNIV - lvE\n\ngoal (1 subgoal):\n 1. p = [] \\<Longrightarrow> pE = {}", "by auto"], ["", "lemma (in invar_loc) lastp_un_D_closed:\n    assumes NE: \"p \\<noteq> []\"\n    assumes NO': \"pE \\<inter> (last p \\<times> UNIV) = {}\"\n    shows \"E``(last p \\<union> D) \\<subseteq> (last p \\<union> D)\"\n    \\<comment> \\<open>On pop, the popped CNode and D are closed under transitions\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. E `` (last p \\<union> D) \\<subseteq> last p \\<union> D", "proof (intro subsetI, elim ImageE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x) \\<in> E; xa \\<in> last p \\<union> D\\<rbrakk>\n       \\<Longrightarrow> x \\<in> last p \\<union> D", "from NO'"], ["proof (chain)\npicking this:\n  pE \\<inter> last p \\<times> UNIV = {}", "have NO: \"(E - lvE) \\<inter> (last p \\<times> UNIV) = {}\""], ["proof (prove)\nusing this:\n  pE \\<inter> last p \\<times> UNIV = {}\n\ngoal (1 subgoal):\n 1. (E - lvE) \\<inter> last p \\<times> UNIV = {}", "by (simp add: pick_pending[OF NE])"], ["proof (state)\nthis:\n  (E - lvE) \\<inter> last p \\<times> UNIV = {}\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x) \\<in> E; xa \\<in> last p \\<union> D\\<rbrakk>\n       \\<Longrightarrow> x \\<in> last p \\<union> D", "let ?i = \"length p - 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x) \\<in> E; xa \\<in> last p \\<union> D\\<rbrakk>\n       \\<Longrightarrow> x \\<in> last p \\<union> D", "from NE"], ["proof (chain)\npicking this:\n  p \\<noteq> []", "have [simp]: \"last p = p!?i\""], ["proof (prove)\nusing this:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. last p = p ! (length p - 1)", "by (metis last_conv_nth)"], ["proof (state)\nthis:\n  last p = p ! (length p - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x) \\<in> E; xa \\<in> last p \\<union> D\\<rbrakk>\n       \\<Longrightarrow> x \\<in> last p \\<union> D", "fix u v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x) \\<in> E; xa \\<in> last p \\<union> D\\<rbrakk>\n       \\<Longrightarrow> x \\<in> last p \\<union> D", "assume E: \"(u,v)\\<in>E\""], ["proof (state)\nthis:\n  (u, v) \\<in> E\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x) \\<in> E; xa \\<in> last p \\<union> D\\<rbrakk>\n       \\<Longrightarrow> x \\<in> last p \\<union> D", "assume UI: \"u\\<in>last p \\<union> D\""], ["proof (state)\nthis:\n  u \\<in> last p \\<union> D\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x) \\<in> E; xa \\<in> last p \\<union> D\\<rbrakk>\n       \\<Longrightarrow> x \\<in> last p \\<union> D", "hence \"u\\<in>p!?i \\<union> D\""], ["proof (prove)\nusing this:\n  u \\<in> last p \\<union> D\n\ngoal (1 subgoal):\n 1. u \\<in> p ! (length p - 1) \\<union> D", "by simp"], ["proof (state)\nthis:\n  u \\<in> p ! (length p - 1) \\<union> D\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x) \\<in> E; xa \\<in> last p \\<union> D\\<rbrakk>\n       \\<Longrightarrow> x \\<in> last p \\<union> D", "{"], ["proof (state)\nthis:\n  u \\<in> p ! (length p - 1) \\<union> D\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x) \\<in> E; xa \\<in> last p \\<union> D\\<rbrakk>\n       \\<Longrightarrow> x \\<in> last p \\<union> D", "assume \"u\\<in>last p\" \"v\\<notin>last p\""], ["proof (state)\nthis:\n  u \\<in> last p\n  v \\<notin> last p\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x) \\<in> E; xa \\<in> last p \\<union> D\\<rbrakk>\n       \\<Longrightarrow> x \\<in> last p \\<union> D", "moreover"], ["proof (state)\nthis:\n  u \\<in> last p\n  v \\<notin> last p\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x) \\<in> E; xa \\<in> last p \\<union> D\\<rbrakk>\n       \\<Longrightarrow> x \\<in> last p \\<union> D", "from E NO \\<open>u\\<in>last p\\<close>"], ["proof (chain)\npicking this:\n  (u, v) \\<in> E\n  (E - lvE) \\<inter> last p \\<times> UNIV = {}\n  u \\<in> last p", "have \"(u,v)\\<in>lvE\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> E\n  (E - lvE) \\<inter> last p \\<times> UNIV = {}\n  u \\<in> last p\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> lvE", "by auto"], ["proof (state)\nthis:\n  (u, v) \\<in> lvE\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x) \\<in> E; xa \\<in> last p \\<union> D\\<rbrakk>\n       \\<Longrightarrow> x \\<in> last p \\<union> D", "ultimately"], ["proof (chain)\npicking this:\n  u \\<in> last p\n  v \\<notin> last p\n  (u, v) \\<in> lvE", "have \"v\\<in>D \\<or> v\\<in>\\<Union>(set p)\""], ["proof (prove)\nusing this:\n  u \\<in> last p\n  v \\<notin> last p\n  (u, v) \\<in> lvE\n\ngoal (1 subgoal):\n 1. v \\<in> D \\<or> v \\<in> \\<Union> (set p)", "using vE_touched"], ["proof (prove)\nusing this:\n  u \\<in> last p\n  v \\<notin> last p\n  (u, v) \\<in> lvE\n  lvE \\<subseteq> ltouched \\<times> ltouched\n\ngoal (1 subgoal):\n 1. v \\<in> D \\<or> v \\<in> \\<Union> (set p)", "unfolding touched_def"], ["proof (prove)\nusing this:\n  u \\<in> last p\n  v \\<notin> last p\n  (u, v) \\<in> lvE\n  lvE\n  \\<subseteq> (D \\<union> \\<Union> (set p)) \\<times>\n              (D \\<union> \\<Union> (set p))\n\ngoal (1 subgoal):\n 1. v \\<in> D \\<or> v \\<in> \\<Union> (set p)", "by auto"], ["proof (state)\nthis:\n  v \\<in> D \\<or> v \\<in> \\<Union> (set p)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x) \\<in> E; xa \\<in> last p \\<union> D\\<rbrakk>\n       \\<Longrightarrow> x \\<in> last p \\<union> D", "moreover"], ["proof (state)\nthis:\n  v \\<in> D \\<or> v \\<in> \\<Union> (set p)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x) \\<in> E; xa \\<in> last p \\<union> D\\<rbrakk>\n       \\<Longrightarrow> x \\<in> last p \\<union> D", "{"], ["proof (state)\nthis:\n  v \\<in> D \\<or> v \\<in> \\<Union> (set p)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x) \\<in> E; xa \\<in> last p \\<union> D\\<rbrakk>\n       \\<Longrightarrow> x \\<in> last p \\<union> D", "assume \"v\\<in>\\<Union>(set p)\""], ["proof (state)\nthis:\n  v \\<in> \\<Union> (set p)\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x) \\<in> E; xa \\<in> last p \\<union> D\\<rbrakk>\n       \\<Longrightarrow> x \\<in> last p \\<union> D", "then"], ["proof (chain)\npicking this:\n  v \\<in> \\<Union> (set p)", "obtain j where V: \"j<length p\" \"v\\<in>p!j\""], ["proof (prove)\nusing this:\n  v \\<in> \\<Union> (set p)\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j < length p; v \\<in> p ! j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis UnionE in_set_conv_nth)"], ["proof (state)\nthis:\n  j < length p\n  v \\<in> p ! j\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x) \\<in> E; xa \\<in> last p \\<union> D\\<rbrakk>\n       \\<Longrightarrow> x \\<in> last p \\<union> D", "with \\<open>v\\<notin>last p\\<close>"], ["proof (chain)\npicking this:\n  v \\<notin> last p\n  j < length p\n  v \\<in> p ! j", "have \"j<?i\""], ["proof (prove)\nusing this:\n  v \\<notin> last p\n  j < length p\n  v \\<in> p ! j\n\ngoal (1 subgoal):\n 1. j < length p - 1", "by (cases \"j=?i\") auto"], ["proof (state)\nthis:\n  j < length p - 1\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x) \\<in> E; xa \\<in> last p \\<union> D\\<rbrakk>\n       \\<Longrightarrow> x \\<in> last p \\<union> D", "from vE_no_back[OF \\<open>j<?i\\<close> _] \\<open>(u,v)\\<in>lvE\\<close> V \\<open>u\\<in>last p\\<close>"], ["proof (chain)\npicking this:\n  length p - 1 < length p \\<Longrightarrow>\n  lvE \\<inter> p ! (length p - 1) \\<times> p ! j = {}\n  (u, v) \\<in> lvE\n  j < length p\n  v \\<in> p ! j\n  u \\<in> last p", "have False"], ["proof (prove)\nusing this:\n  length p - 1 < length p \\<Longrightarrow>\n  lvE \\<inter> p ! (length p - 1) \\<times> p ! j = {}\n  (u, v) \\<in> lvE\n  j < length p\n  v \\<in> p ! j\n  u \\<in> last p\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x) \\<in> E; xa \\<in> last p \\<union> D\\<rbrakk>\n       \\<Longrightarrow> x \\<in> last p \\<union> D", "}"], ["proof (state)\nthis:\n  v \\<in> \\<Union> (set p) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x) \\<in> E; xa \\<in> last p \\<union> D\\<rbrakk>\n       \\<Longrightarrow> x \\<in> last p \\<union> D", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> D \\<or> v \\<in> \\<Union> (set p)\n  v \\<in> \\<Union> (set p) \\<Longrightarrow> False", "have \"v\\<in>D\""], ["proof (prove)\nusing this:\n  v \\<in> D \\<or> v \\<in> \\<Union> (set p)\n  v \\<in> \\<Union> (set p) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. v \\<in> D", "by blast"], ["proof (state)\nthis:\n  v \\<in> D\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x) \\<in> E; xa \\<in> last p \\<union> D\\<rbrakk>\n       \\<Longrightarrow> x \\<in> last p \\<union> D", "}"], ["proof (state)\nthis:\n  \\<lbrakk>u \\<in> last p; v \\<notin> last p\\<rbrakk>\n  \\<Longrightarrow> v \\<in> D\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(xa, x) \\<in> E; xa \\<in> last p \\<union> D\\<rbrakk>\n       \\<Longrightarrow> x \\<in> last p \\<union> D", "with E UI D_closed"], ["proof (chain)\npicking this:\n  (u, v) \\<in> E\n  u \\<in> last p \\<union> D\n  E `` D \\<subseteq> D\n  \\<lbrakk>u \\<in> last p; v \\<notin> last p\\<rbrakk>\n  \\<Longrightarrow> v \\<in> D", "show \"v\\<in>last p \\<union> D\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> E\n  u \\<in> last p \\<union> D\n  E `` D \\<subseteq> D\n  \\<lbrakk>u \\<in> last p; v \\<notin> last p\\<rbrakk>\n  \\<Longrightarrow> v \\<in> D\n\ngoal (1 subgoal):\n 1. v \\<in> last p \\<union> D", "by auto"], ["proof (state)\nthis:\n  v \\<in> last p \\<union> D\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Preservation of Invariant by Operations\\<close>"], ["", "context fr_graph\nbegin"], ["", "lemma (in outer_invar_loc) invar_initial_aux: \n    assumes \"v0\\<in>it - D\"\n    shows \"invar v0 D (initial v0 D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar v0 D (initial v0 D)", "unfolding invar_def initial_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case ([{v0}], D, E \\<inter> {v0} \\<times> UNIV) of\n    (p, xa, xb) \\<Rightarrow> invar_loc G v0 D p xa xb", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_loc G v0 D [{v0}] D (E \\<inter> {v0} \\<times> UNIV)", "apply unfold_locales"], ["proof (prove)\ngoal (13 subgoals):\n 1. v0 \\<in> V0\n 2. D \\<subseteq> D\n 3. E \\<inter> {v0} \\<times> UNIV\n    \\<subseteq> E \\<inter> \\<Union> (set [{v0}]) \\<times> UNIV\n 4. E \\<inter> \\<Union> (set [{v0}]) \\<times> UNIV\n    \\<subseteq> E \\<inter> {v0} \\<times> UNIV \\<union>\n                UNIV \\<times> touched [{v0}] D\n 5. D \\<subseteq> reachable\n 6. \\<And>i.\n       Suc i < length [{v0}] \\<Longrightarrow>\n       [{v0}] ! i \\<times> [{v0}] ! Suc i \\<inter>\n       (E - E \\<inter> {v0} \\<times> UNIV) \\<noteq>\n       {}\n 7. \\<And>i j.\n       \\<lbrakk>i < j; j < length [{v0}]\\<rbrakk>\n       \\<Longrightarrow> [{v0}] ! i \\<inter> [{v0}] ! j = {}\n 8. \\<And>U.\n       U \\<in> set [{v0}] \\<Longrightarrow>\n       U \\<times> U\n       \\<subseteq> (Restr (vE [{v0}] D (E \\<inter> {v0} \\<times> UNIV))\n                     U)\\<^sup>*\n 9. [{v0}] \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd [{v0}]\n 10. [{v0}] = [] \\<Longrightarrow> v0 \\<in> D\nA total of 13 subgoals...", "apply simp_all"], ["proof (prove)\ngoal (4 subgoals):\n 1. v0 \\<in> V0\n 2. D \\<subseteq> reachable\n 3. E `` D \\<subseteq> D\n 4. v0 \\<notin> D", "using assms it_initial"], ["proof (prove)\nusing this:\n  v0 \\<in> it - D\n  it \\<subseteq> V0\n\ngoal (4 subgoals):\n 1. v0 \\<in> V0\n 2. D \\<subseteq> reachable\n 3. E `` D \\<subseteq> D\n 4. v0 \\<notin> D", "apply auto []"], ["proof (prove)\ngoal (3 subgoals):\n 1. D \\<subseteq> reachable\n 2. E `` D \\<subseteq> D\n 3. v0 \\<notin> D", "using D_reachable it_initial assms"], ["proof (prove)\nusing this:\n  D \\<subseteq> reachable\n  it \\<subseteq> V0\n  v0 \\<in> it - D\n\ngoal (3 subgoals):\n 1. D \\<subseteq> reachable\n 2. E `` D \\<subseteq> D\n 3. v0 \\<notin> D", "apply auto []"], ["proof (prove)\ngoal (2 subgoals):\n 1. E `` D \\<subseteq> D\n 2. v0 \\<notin> D", "using D_closed"], ["proof (prove)\nusing this:\n  E `` D \\<subseteq> D\n\ngoal (2 subgoals):\n 1. E `` D \\<subseteq> D\n 2. v0 \\<notin> D", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. v0 \\<notin> D", "using assms"], ["proof (prove)\nusing this:\n  v0 \\<in> it - D\n\ngoal (1 subgoal):\n 1. v0 \\<notin> D", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma invar_initial: \n    \"\\<lbrakk>outer_invar it D0; v0\\<in>it; v0\\<notin>D0\\<rbrakk> \\<Longrightarrow> invar v0 D0 (initial v0 D0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>outer_invar it D0; v0 \\<in> it; v0 \\<notin> D0\\<rbrakk>\n    \\<Longrightarrow> invar v0 D0 (initial v0 D0)", "unfolding outer_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>outer_invar_loc G it D0; v0 \\<in> it; v0 \\<notin> D0\\<rbrakk>\n    \\<Longrightarrow> invar v0 D0 (initial v0 D0)", "apply (drule outer_invar_loc.invar_initial_aux)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>v0 \\<in> it; v0 \\<notin> D0\\<rbrakk>\n    \\<Longrightarrow> ?v0.0 \\<in> it - D0\n 2. \\<lbrakk>v0 \\<in> it; v0 \\<notin> D0;\n     invar ?v0.0 D0 (initial ?v0.0 D0)\\<rbrakk>\n    \\<Longrightarrow> invar v0 D0 (initial v0 D0)", "by auto"], ["", "lemma outer_invar_initial[simp, intro!]: \"outer_invar V0 {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_invar V0 {}", "unfolding outer_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_invar_loc G V0 {}", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. V0 \\<subseteq> V0\n 2. V0 - V0 \\<subseteq> {}\n 3. {} \\<subseteq> reachable\n 4. E `` {} \\<subseteq> {}", "by auto"], ["", "lemma invar_pop:\n    assumes INV: \"invar v0 D0 (p,D,pE)\"\n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes NO': \"pE \\<inter> (last p \\<times> UNIV) = {}\"\n    shows \"invar v0 D0 (pop (p,D,pE))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar v0 D0 (pop (p, D, pE))", "unfolding invar_def pop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case let (p, D, pE) = (p, D, pE); (p, V) = (butlast p, last p);\n             D = V \\<union> D\n         in (p, D, pE) of\n    (p, xa, xb) \\<Rightarrow> invar_loc G v0 D0 p xa xb", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (butlast p) (last p \\<union> D) pE", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (butlast p) (last p \\<union> D) pE", "from INV"], ["proof (chain)\npicking this:\n  invar v0 D0 (p, D, pE)", "interpret invar_loc G v0 D0 p D pE"], ["proof (prove)\nusing this:\n  invar v0 D0 (p, D, pE)\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D pE", "unfolding invar_def"], ["proof (prove)\nusing this:\n  case (p, D, pE) of (p, xa, xb) \\<Rightarrow> invar_loc G v0 D0 p xa xb\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D pE", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (butlast p) (last p \\<union> D) pE", "have [simp]: \"set p = insert (last p) (set (butlast p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set p = insert (last p) (set (butlast p))", "using NE"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. set p = insert (last p) (set (butlast p))", "by (cases p rule: rev_cases) auto"], ["proof (state)\nthis:\n  set p = insert (last p) (set (butlast p))\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (butlast p) (last p \\<union> D) pE", "from p_disjoint"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i < ?j; ?j < length p\\<rbrakk>\n  \\<Longrightarrow> p ! ?i \\<inter> p ! ?j = {}", "have lp_dj_blp: \"last p \\<inter> \\<Union>(set (butlast p)) = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < ?j; ?j < length p\\<rbrakk>\n  \\<Longrightarrow> p ! ?i \\<inter> p ! ?j = {}\n\ngoal (1 subgoal):\n 1. last p \\<inter> \\<Union> (set (butlast p)) = {}", "apply (cases p rule: rev_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>i j.\n                \\<lbrakk>i < j; j < length p\\<rbrakk>\n                \\<Longrightarrow> p ! i \\<inter> p ! j = {};\n     p = []\\<rbrakk>\n    \\<Longrightarrow> last p \\<inter> \\<Union> (set (butlast p)) = {}\n 2. \\<And>ys y.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>i < j; j < length p\\<rbrakk>\n                   \\<Longrightarrow> p ! i \\<inter> p ! j = {};\n        p = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> last p \\<inter> \\<Union> (set (butlast p)) = {}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>i < j; j < length p\\<rbrakk>\n                   \\<Longrightarrow> p ! i \\<inter> p ! j = {};\n        p = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> last p \\<inter> \\<Union> (set (butlast p)) = {}", "apply (fastforce simp: in_set_conv_nth nth_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  last p \\<inter> \\<Union> (set (butlast p)) = {}\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (butlast p) (last p \\<union> D) pE", "{"], ["proof (state)\nthis:\n  last p \\<inter> \\<Union> (set (butlast p)) = {}\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (butlast p) (last p \\<union> D) pE", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (butlast p) (last p \\<union> D) pE", "assume A: \"Suc i < length (butlast p)\""], ["proof (state)\nthis:\n  Suc i < length (butlast p)\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (butlast p) (last p \\<union> D) pE", "hence A': \"Suc i < length p\""], ["proof (prove)\nusing this:\n  Suc i < length (butlast p)\n\ngoal (1 subgoal):\n 1. Suc i < length p", "by auto"], ["proof (state)\nthis:\n  Suc i < length p\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (butlast p) (last p \\<union> D) pE", "from nth_butlast[of i p] A"], ["proof (chain)\npicking this:\n  i < length (butlast p) \\<Longrightarrow> butlast p ! i = p ! i\n  Suc i < length (butlast p)", "have [simp]: \"butlast p ! i = p ! i\""], ["proof (prove)\nusing this:\n  i < length (butlast p) \\<Longrightarrow> butlast p ! i = p ! i\n  Suc i < length (butlast p)\n\ngoal (1 subgoal):\n 1. butlast p ! i = p ! i", "by auto"], ["proof (state)\nthis:\n  butlast p ! i = p ! i\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (butlast p) (last p \\<union> D) pE", "from nth_butlast[of \"Suc i\" p] A"], ["proof (chain)\npicking this:\n  Suc i < length (butlast p) \\<Longrightarrow> butlast p ! Suc i = p ! Suc i\n  Suc i < length (butlast p)", "have [simp]: \"butlast p ! Suc i = p ! Suc i\""], ["proof (prove)\nusing this:\n  Suc i < length (butlast p) \\<Longrightarrow> butlast p ! Suc i = p ! Suc i\n  Suc i < length (butlast p)\n\ngoal (1 subgoal):\n 1. butlast p ! Suc i = p ! Suc i", "by auto"], ["proof (state)\nthis:\n  butlast p ! Suc i = p ! Suc i\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (butlast p) (last p \\<union> D) pE", "from p_connected[OF A']"], ["proof (chain)\npicking this:\n  p ! i \\<times> p ! Suc i \\<inter> (E - pE) \\<noteq> {}", "have \"butlast p ! i \\<times> butlast p ! Suc i \\<inter> (E - pE) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  p ! i \\<times> p ! Suc i \\<inter> (E - pE) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. butlast p ! i \\<times> butlast p ! Suc i \\<inter> (E - pE) \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  butlast p ! i \\<times> butlast p ! Suc i \\<inter> (E - pE) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (butlast p) (last p \\<union> D) pE", "}"], ["proof (state)\nthis:\n  Suc ?i2 < length (butlast p) \\<Longrightarrow>\n  butlast p ! ?i2 \\<times> butlast p ! Suc ?i2 \\<inter> (E - pE) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (butlast p) (last p \\<union> D) pE", "note AUX_p_connected = this"], ["proof (state)\nthis:\n  Suc ?i2 < length (butlast p) \\<Longrightarrow>\n  butlast p ! ?i2 \\<times> butlast p ! Suc ?i2 \\<inter> (E - pE) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (butlast p) (last p \\<union> D) pE", "(*have [simp]: \"(E \\<inter> (last p \\<union> D \\<union> \\<Union>set (butlast p)) \\<times> UNIV - pE) = vE\"\n      unfolding vE_def touched_def by auto*)"], ["proof (state)\nthis:\n  Suc ?i2 < length (butlast p) \\<Longrightarrow>\n  butlast p ! ?i2 \\<times> butlast p ! Suc ?i2 \\<inter> (E - pE) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (butlast p) (last p \\<union> D) pE", "show \"invar_loc G v0 D0 (butlast p) (last p \\<union> D) pE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (butlast p) (last p \\<union> D) pE", "apply unfold_locales"], ["proof (prove)\ngoal (13 subgoals):\n 1. v0 \\<in> V0\n 2. D0 \\<subseteq> last p \\<union> D\n 3. pE \\<subseteq> E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV\n 4. E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV\n    \\<subseteq> pE \\<union>\n                UNIV \\<times> touched (butlast p) (last p \\<union> D)\n 5. last p \\<union> D \\<subseteq> reachable\n 6. \\<And>i.\n       Suc i < length (butlast p) \\<Longrightarrow>\n       butlast p ! i \\<times> butlast p ! Suc i \\<inter> (E - pE) \\<noteq>\n       {}\n 7. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> butlast p ! i \\<inter> butlast p ! j = {}\n 8. \\<And>U.\n       U \\<in> set (butlast p) \\<Longrightarrow>\n       U \\<times> U\n       \\<subseteq> (Restr (vE (butlast p) (last p \\<union> D) pE) U)\\<^sup>*\n 9. butlast p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (butlast p)\n 10. butlast p = [] \\<Longrightarrow> v0 \\<in> last p \\<union> D\nA total of 13 subgoals...", "unfolding vE_pop[OF NE]"], ["proof (prove)\ngoal (13 subgoals):\n 1. v0 \\<in> V0\n 2. D0 \\<subseteq> last p \\<union> D\n 3. pE \\<subseteq> E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV\n 4. E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV\n    \\<subseteq> pE \\<union>\n                UNIV \\<times> touched (butlast p) (last p \\<union> D)\n 5. last p \\<union> D \\<subseteq> reachable\n 6. \\<And>i.\n       Suc i < length (butlast p) \\<Longrightarrow>\n       butlast p ! i \\<times> butlast p ! Suc i \\<inter> (E - pE) \\<noteq>\n       {}\n 7. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> butlast p ! i \\<inter> butlast p ! j = {}\n 8. \\<And>U.\n       U \\<in> set (butlast p) \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr lvE U)\\<^sup>*\n 9. butlast p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (butlast p)\n 10. butlast p = [] \\<Longrightarrow> v0 \\<in> last p \\<union> D\nA total of 13 subgoals...", "apply simp"], ["proof (prove)\ngoal (12 subgoals):\n 1. D0 \\<subseteq> last p \\<union> D\n 2. pE \\<subseteq> E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV\n 3. E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV\n    \\<subseteq> pE \\<union>\n                UNIV \\<times> touched (butlast p) (last p \\<union> D)\n 4. last p \\<union> D \\<subseteq> reachable\n 5. \\<And>i.\n       Suc i < length (butlast p) \\<Longrightarrow>\n       butlast p ! i \\<times> butlast p ! Suc i \\<inter> (E - pE) \\<noteq>\n       {}\n 6. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> butlast p ! i \\<inter> butlast p ! j = {}\n 7. \\<And>U.\n       U \\<in> set (butlast p) \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr lvE U)\\<^sup>*\n 8. butlast p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (butlast p)\n 9. butlast p = [] \\<Longrightarrow> v0 \\<in> last p \\<union> D\n 10. E `` (last p \\<union> D) \\<subseteq> last p \\<union> D\nA total of 12 subgoals...", "using D_incr"], ["proof (prove)\nusing this:\n  D0 \\<subseteq> D\n\ngoal (12 subgoals):\n 1. D0 \\<subseteq> last p \\<union> D\n 2. pE \\<subseteq> E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV\n 3. E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV\n    \\<subseteq> pE \\<union>\n                UNIV \\<times> touched (butlast p) (last p \\<union> D)\n 4. last p \\<union> D \\<subseteq> reachable\n 5. \\<And>i.\n       Suc i < length (butlast p) \\<Longrightarrow>\n       butlast p ! i \\<times> butlast p ! Suc i \\<inter> (E - pE) \\<noteq>\n       {}\n 6. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> butlast p ! i \\<inter> butlast p ! j = {}\n 7. \\<And>U.\n       U \\<in> set (butlast p) \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr lvE U)\\<^sup>*\n 8. butlast p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (butlast p)\n 9. butlast p = [] \\<Longrightarrow> v0 \\<in> last p \\<union> D\n 10. E `` (last p \\<union> D) \\<subseteq> last p \\<union> D\nA total of 12 subgoals...", "apply auto []"], ["proof (prove)\ngoal (11 subgoals):\n 1. pE \\<subseteq> E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV\n 2. E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV\n    \\<subseteq> pE \\<union>\n                UNIV \\<times> touched (butlast p) (last p \\<union> D)\n 3. last p \\<union> D \\<subseteq> reachable\n 4. \\<And>i.\n       Suc i < length (butlast p) \\<Longrightarrow>\n       butlast p ! i \\<times> butlast p ! Suc i \\<inter> (E - pE) \\<noteq>\n       {}\n 5. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> butlast p ! i \\<inter> butlast p ! j = {}\n 6. \\<And>U.\n       U \\<in> set (butlast p) \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr lvE U)\\<^sup>*\n 7. butlast p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (butlast p)\n 8. butlast p = [] \\<Longrightarrow> v0 \\<in> last p \\<union> D\n 9. E `` (last p \\<union> D) \\<subseteq> last p \\<union> D\n 10. \\<And>i j.\n        \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n        \\<Longrightarrow> lvE \\<inter>\n                          butlast p ! j \\<times> butlast p ! i =\n                          {}\nA total of 11 subgoals...", "using pE_E_from_p NO'"], ["proof (prove)\nusing this:\n  pE \\<subseteq> E \\<inter> \\<Union> (set p) \\<times> UNIV\n  pE \\<inter> last p \\<times> UNIV = {}\n\ngoal (11 subgoals):\n 1. pE \\<subseteq> E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV\n 2. E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV\n    \\<subseteq> pE \\<union>\n                UNIV \\<times> touched (butlast p) (last p \\<union> D)\n 3. last p \\<union> D \\<subseteq> reachable\n 4. \\<And>i.\n       Suc i < length (butlast p) \\<Longrightarrow>\n       butlast p ! i \\<times> butlast p ! Suc i \\<inter> (E - pE) \\<noteq>\n       {}\n 5. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> butlast p ! i \\<inter> butlast p ! j = {}\n 6. \\<And>U.\n       U \\<in> set (butlast p) \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr lvE U)\\<^sup>*\n 7. butlast p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (butlast p)\n 8. butlast p = [] \\<Longrightarrow> v0 \\<in> last p \\<union> D\n 9. E `` (last p \\<union> D) \\<subseteq> last p \\<union> D\n 10. \\<And>i j.\n        \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n        \\<Longrightarrow> lvE \\<inter>\n                          butlast p ! j \\<times> butlast p ! i =\n                          {}\nA total of 11 subgoals...", "apply auto []"], ["proof (prove)\ngoal (10 subgoals):\n 1. E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV\n    \\<subseteq> pE \\<union>\n                UNIV \\<times> touched (butlast p) (last p \\<union> D)\n 2. last p \\<union> D \\<subseteq> reachable\n 3. \\<And>i.\n       Suc i < length (butlast p) \\<Longrightarrow>\n       butlast p ! i \\<times> butlast p ! Suc i \\<inter> (E - pE) \\<noteq>\n       {}\n 4. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> butlast p ! i \\<inter> butlast p ! j = {}\n 5. \\<And>U.\n       U \\<in> set (butlast p) \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr lvE U)\\<^sup>*\n 6. butlast p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (butlast p)\n 7. butlast p = [] \\<Longrightarrow> v0 \\<in> last p \\<union> D\n 8. E `` (last p \\<union> D) \\<subseteq> last p \\<union> D\n 9. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> lvE \\<inter> butlast p ! j \\<times> butlast p ! i =\n                         {}\n 10. \\<Union> (set (butlast p)) \\<inter> (last p \\<union> D) = {}", "using E_from_p_touched"], ["proof (prove)\nusing this:\n  E \\<inter> \\<Union> (set p) \\<times> UNIV\n  \\<subseteq> pE \\<union> UNIV \\<times> ltouched\n\ngoal (10 subgoals):\n 1. E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV\n    \\<subseteq> pE \\<union>\n                UNIV \\<times> touched (butlast p) (last p \\<union> D)\n 2. last p \\<union> D \\<subseteq> reachable\n 3. \\<And>i.\n       Suc i < length (butlast p) \\<Longrightarrow>\n       butlast p ! i \\<times> butlast p ! Suc i \\<inter> (E - pE) \\<noteq>\n       {}\n 4. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> butlast p ! i \\<inter> butlast p ! j = {}\n 5. \\<And>U.\n       U \\<in> set (butlast p) \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr lvE U)\\<^sup>*\n 6. butlast p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (butlast p)\n 7. butlast p = [] \\<Longrightarrow> v0 \\<in> last p \\<union> D\n 8. E `` (last p \\<union> D) \\<subseteq> last p \\<union> D\n 9. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> lvE \\<inter> butlast p ! j \\<times> butlast p ! i =\n                         {}\n 10. \\<Union> (set (butlast p)) \\<inter> (last p \\<union> D) = {}", "apply (auto simp: touched_def) []"], ["proof (prove)\ngoal (9 subgoals):\n 1. last p \\<union> D \\<subseteq> reachable\n 2. \\<And>i.\n       Suc i < length (butlast p) \\<Longrightarrow>\n       butlast p ! i \\<times> butlast p ! Suc i \\<inter> (E - pE) \\<noteq>\n       {}\n 3. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> butlast p ! i \\<inter> butlast p ! j = {}\n 4. \\<And>U.\n       U \\<in> set (butlast p) \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr lvE U)\\<^sup>*\n 5. butlast p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (butlast p)\n 6. butlast p = [] \\<Longrightarrow> v0 \\<in> last p \\<union> D\n 7. E `` (last p \\<union> D) \\<subseteq> last p \\<union> D\n 8. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> lvE \\<inter> butlast p ! j \\<times> butlast p ! i =\n                         {}\n 9. \\<Union> (set (butlast p)) \\<inter> (last p \\<union> D) = {}", "using D_reachable p_reachable NE"], ["proof (prove)\nusing this:\n  D \\<subseteq> reachable\n  \\<Union> (set p) \\<subseteq> E\\<^sup>* `` {v0}\n  p \\<noteq> []\n\ngoal (9 subgoals):\n 1. last p \\<union> D \\<subseteq> reachable\n 2. \\<And>i.\n       Suc i < length (butlast p) \\<Longrightarrow>\n       butlast p ! i \\<times> butlast p ! Suc i \\<inter> (E - pE) \\<noteq>\n       {}\n 3. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> butlast p ! i \\<inter> butlast p ! j = {}\n 4. \\<And>U.\n       U \\<in> set (butlast p) \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr lvE U)\\<^sup>*\n 5. butlast p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (butlast p)\n 6. butlast p = [] \\<Longrightarrow> v0 \\<in> last p \\<union> D\n 7. E `` (last p \\<union> D) \\<subseteq> last p \\<union> D\n 8. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> lvE \\<inter> butlast p ! j \\<times> butlast p ! i =\n                         {}\n 9. \\<Union> (set (butlast p)) \\<inter> (last p \\<union> D) = {}", "apply auto []"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>i.\n       Suc i < length (butlast p) \\<Longrightarrow>\n       butlast p ! i \\<times> butlast p ! Suc i \\<inter> (E - pE) \\<noteq>\n       {}\n 2. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> butlast p ! i \\<inter> butlast p ! j = {}\n 3. \\<And>U.\n       U \\<in> set (butlast p) \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr lvE U)\\<^sup>*\n 4. butlast p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (butlast p)\n 5. butlast p = [] \\<Longrightarrow> v0 \\<in> last p \\<union> D\n 6. E `` (last p \\<union> D) \\<subseteq> last p \\<union> D\n 7. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> lvE \\<inter> butlast p ! j \\<times> butlast p ! i =\n                         {}\n 8. \\<Union> (set (butlast p)) \\<inter> (last p \\<union> D) = {}", "apply (rule AUX_p_connected, assumption+) []"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> butlast p ! i \\<inter> butlast p ! j = {}\n 2. \\<And>U.\n       U \\<in> set (butlast p) \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr lvE U)\\<^sup>*\n 3. butlast p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (butlast p)\n 4. butlast p = [] \\<Longrightarrow> v0 \\<in> last p \\<union> D\n 5. E `` (last p \\<union> D) \\<subseteq> last p \\<union> D\n 6. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> lvE \\<inter> butlast p ! j \\<times> butlast p ! i =\n                         {}\n 7. \\<Union> (set (butlast p)) \\<inter> (last p \\<union> D) = {}", "using p_disjoint"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < ?j; ?j < length p\\<rbrakk>\n  \\<Longrightarrow> p ! ?i \\<inter> p ! ?j = {}\n\ngoal (7 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> butlast p ! i \\<inter> butlast p ! j = {}\n 2. \\<And>U.\n       U \\<in> set (butlast p) \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr lvE U)\\<^sup>*\n 3. butlast p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (butlast p)\n 4. butlast p = [] \\<Longrightarrow> v0 \\<in> last p \\<union> D\n 5. E `` (last p \\<union> D) \\<subseteq> last p \\<union> D\n 6. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> lvE \\<inter> butlast p ! j \\<times> butlast p ! i =\n                         {}\n 7. \\<Union> (set (butlast p)) \\<inter> (last p \\<union> D) = {}", "apply (simp add: nth_butlast)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>U.\n       U \\<in> set (butlast p) \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr lvE U)\\<^sup>*\n 2. butlast p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (butlast p)\n 3. butlast p = [] \\<Longrightarrow> v0 \\<in> last p \\<union> D\n 4. E `` (last p \\<union> D) \\<subseteq> last p \\<union> D\n 5. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> lvE \\<inter> butlast p ! j \\<times> butlast p ! i =\n                         {}\n 6. \\<Union> (set (butlast p)) \\<inter> (last p \\<union> D) = {}", "using p_sc"], ["proof (prove)\nusing this:\n  ?U \\<in> set p \\<Longrightarrow>\n  ?U \\<times> ?U \\<subseteq> (Restr lvE ?U)\\<^sup>*\n\ngoal (6 subgoals):\n 1. \\<And>U.\n       U \\<in> set (butlast p) \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr lvE U)\\<^sup>*\n 2. butlast p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (butlast p)\n 3. butlast p = [] \\<Longrightarrow> v0 \\<in> last p \\<union> D\n 4. E `` (last p \\<union> D) \\<subseteq> last p \\<union> D\n 5. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> lvE \\<inter> butlast p ! j \\<times> butlast p ! i =\n                         {}\n 6. \\<Union> (set (butlast p)) \\<inter> (last p \\<union> D) = {}", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. butlast p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (butlast p)\n 2. butlast p = [] \\<Longrightarrow> v0 \\<in> last p \\<union> D\n 3. E `` (last p \\<union> D) \\<subseteq> last p \\<union> D\n 4. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> lvE \\<inter> butlast p ! j \\<times> butlast p ! i =\n                         {}\n 5. \\<Union> (set (butlast p)) \\<inter> (last p \\<union> D) = {}", "using root_v0"], ["proof (prove)\nusing this:\n  p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p\n\ngoal (5 subgoals):\n 1. butlast p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (butlast p)\n 2. butlast p = [] \\<Longrightarrow> v0 \\<in> last p \\<union> D\n 3. E `` (last p \\<union> D) \\<subseteq> last p \\<union> D\n 4. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> lvE \\<inter> butlast p ! j \\<times> butlast p ! i =\n                         {}\n 5. \\<Union> (set (butlast p)) \\<inter> (last p \\<union> D) = {}", "apply (cases p rule: rev_cases)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>butlast p \\<noteq> [];\n     p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p; p = []\\<rbrakk>\n    \\<Longrightarrow> v0 \\<in> hd (butlast p)\n 2. \\<And>ys y.\n       \\<lbrakk>butlast p \\<noteq> [];\n        p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p; p = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> v0 \\<in> hd (butlast p)\n 3. butlast p = [] \\<Longrightarrow> v0 \\<in> last p \\<union> D\n 4. E `` (last p \\<union> D) \\<subseteq> last p \\<union> D\n 5. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> lvE \\<inter> butlast p ! j \\<times> butlast p ! i =\n                         {}\n 6. \\<Union> (set (butlast p)) \\<inter> (last p \\<union> D) = {}", "apply auto [2]"], ["proof (prove)\ngoal (4 subgoals):\n 1. butlast p = [] \\<Longrightarrow> v0 \\<in> last p \\<union> D\n 2. E `` (last p \\<union> D) \\<subseteq> last p \\<union> D\n 3. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> lvE \\<inter> butlast p ! j \\<times> butlast p ! i =\n                         {}\n 4. \\<Union> (set (butlast p)) \\<inter> (last p \\<union> D) = {}", "using root_v0 p_empty_v0"], ["proof (prove)\nusing this:\n  p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p\n  p = [] \\<Longrightarrow> v0 \\<in> D\n\ngoal (4 subgoals):\n 1. butlast p = [] \\<Longrightarrow> v0 \\<in> last p \\<union> D\n 2. E `` (last p \\<union> D) \\<subseteq> last p \\<union> D\n 3. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> lvE \\<inter> butlast p ! j \\<times> butlast p ! i =\n                         {}\n 4. \\<Union> (set (butlast p)) \\<inter> (last p \\<union> D) = {}", "apply (cases p rule: rev_cases)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>butlast p = []; p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p;\n     p = [] \\<Longrightarrow> v0 \\<in> D; p = []\\<rbrakk>\n    \\<Longrightarrow> v0 \\<in> last p \\<union> D\n 2. \\<And>ys y.\n       \\<lbrakk>butlast p = [];\n        p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p;\n        p = [] \\<Longrightarrow> v0 \\<in> D; p = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> v0 \\<in> last p \\<union> D\n 3. E `` (last p \\<union> D) \\<subseteq> last p \\<union> D\n 4. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> lvE \\<inter> butlast p ! j \\<times> butlast p ! i =\n                         {}\n 5. \\<Union> (set (butlast p)) \\<inter> (last p \\<union> D) = {}", "apply auto [2]"], ["proof (prove)\ngoal (3 subgoals):\n 1. E `` (last p \\<union> D) \\<subseteq> last p \\<union> D\n 2. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> lvE \\<inter> butlast p ! j \\<times> butlast p ! i =\n                         {}\n 3. \\<Union> (set (butlast p)) \\<inter> (last p \\<union> D) = {}", "apply (rule lastp_un_D_closed, insert NO', auto) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> lvE \\<inter> butlast p ! j \\<times> butlast p ! i =\n                         {}\n 2. \\<Union> (set (butlast p)) \\<inter> (last p \\<union> D) = {}", "using vE_no_back"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < ?j; ?j < length p\\<rbrakk>\n  \\<Longrightarrow> lvE \\<inter> p ! ?j \\<times> p ! ?i = {}\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < length (butlast p)\\<rbrakk>\n       \\<Longrightarrow> lvE \\<inter> butlast p ! j \\<times> butlast p ! i =\n                         {}\n 2. \\<Union> (set (butlast p)) \\<inter> (last p \\<union> D) = {}", "apply (auto simp: nth_butlast) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set (butlast p)) \\<inter> (last p \\<union> D) = {}", "using p_not_D lp_dj_blp"], ["proof (prove)\nusing this:\n  \\<Union> (set p) \\<inter> D = {}\n  last p \\<inter> \\<Union> (set (butlast p)) = {}\n\ngoal (1 subgoal):\n 1. \\<Union> (set (butlast p)) \\<inter> (last p \\<union> D) = {}", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  invar_loc G v0 D0 (butlast p) (last p \\<union> D) pE\n\ngoal:\nNo subgoals!", "qed"], ["", "thm invar_pop[of v_0 D_0, no_vars]"], ["", "lemma invar_collapse:\n    assumes INV: \"invar v0 D0 (p,D,pE)\"\n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes E: \"(u,v)\\<in>pE\" and \"u\\<in>last p\"\n    assumes BACK: \"v\\<in>\\<Union>(set p)\"\n    defines \"i \\<equiv> idx_of p v\"\n    defines \"p' \\<equiv> collapse_aux p i\"\n    shows \"invar v0 D0 (collapse v (p,D,pE - {(u,v)}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar v0 D0 (collapse v (p, D, pE - {(u, v)}))", "unfolding invar_def collapse_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case let (p, D, pE) = (p, D, pE - {(u, v)}); i = idx_of p v;\n             p = collapse_aux p i\n         in (p, D, pE) of\n    (p, xa, xb) \\<Rightarrow> invar_loc G v0 D0 p xa xb", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (collapse_aux p (idx_of p v)) D (pE - {(u, v)})", "unfolding i_def[symmetric] p'_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "from INV"], ["proof (chain)\npicking this:\n  invar v0 D0 (p, D, pE)", "interpret invar_loc G v0 D0 p D pE"], ["proof (prove)\nusing this:\n  invar v0 D0 (p, D, pE)\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D pE", "unfolding invar_def"], ["proof (prove)\nusing this:\n  case (p, D, pE) of (p, xa, xb) \\<Rightarrow> invar_loc G v0 D0 p xa xb\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D pE", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "let ?thesis=\"invar_loc G v0 D0 p' D (pE - {(u,v)})\""], ["proof (state)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "have SETP'[simp]: \"\\<Union>(set p') = \\<Union>(set p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set p') = \\<Union> (set p)", "unfolding p'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set (collapse_aux p i)) = \\<Union> (set p)", "by simp"], ["proof (state)\nthis:\n  \\<Union> (set p') = \\<Union> (set p)\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "have IL: \"i < length p\" and VMEM: \"v\\<in>p!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length p &&& v \\<in> p ! i", "using idx_of_props[OF BACK]"], ["proof (prove)\nusing this:\n  idx_of p v < length p\n  v \\<in> p ! idx_of p v\n\ngoal (1 subgoal):\n 1. i < length p &&& v \\<in> p ! i", "unfolding i_def"], ["proof (prove)\nusing this:\n  idx_of p v < length p\n  v \\<in> p ! idx_of p v\n\ngoal (1 subgoal):\n 1. idx_of p v < length p &&& v \\<in> p ! idx_of p v", "by auto"], ["proof (state)\nthis:\n  i < length p\n  v \\<in> p ! i\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "have [simp]: \"length p' = Suc i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length p' = Suc i", "unfolding p'_def collapse_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take i p @ [\\<Union> (set (drop i p))]) = Suc i", "using IL"], ["proof (prove)\nusing this:\n  i < length p\n\ngoal (1 subgoal):\n 1. length (take i p @ [\\<Union> (set (drop i p))]) = Suc i", "by auto"], ["proof (state)\nthis:\n  length p' = Suc i\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "have P'_IDX_SS: \"\\<forall>j<Suc i. p!j \\<subseteq> p'!j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j<Suc i. p ! j \\<subseteq> p' ! j", "unfolding p'_def collapse_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j<Suc i.\n       p ! j \\<subseteq> (take i p @ [\\<Union> (set (drop i p))]) ! j", "using IL"], ["proof (prove)\nusing this:\n  i < length p\n\ngoal (1 subgoal):\n 1. \\<forall>j<Suc i.\n       p ! j \\<subseteq> (take i p @ [\\<Union> (set (drop i p))]) ! j", "by (auto simp add: nth_append path_seg_drop)"], ["proof (state)\nthis:\n  \\<forall>j<Suc i. p ! j \\<subseteq> p' ! j\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "from \\<open>u\\<in>last p\\<close>"], ["proof (chain)\npicking this:\n  u \\<in> last p", "have \"u\\<in>p!(length p - 1)\""], ["proof (prove)\nusing this:\n  u \\<in> last p\n\ngoal (1 subgoal):\n 1. u \\<in> p ! (length p - 1)", "by (auto simp: last_conv_nth)"], ["proof (state)\nthis:\n  u \\<in> p ! (length p - 1)\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "have defs_fold: \n      \"vE p' D (pE - {(u,v)}) = insert (u,v) lvE\" \n      \"touched p' D = ltouched\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vE p' D (pE - {(u, v)}) = insert (u, v) lvE &&& touched p' D = ltouched", "by (simp_all add: p'_def E)"], ["proof (state)\nthis:\n  vE p' D (pE - {(u, v)}) = insert (u, v) lvE\n  touched p' D = ltouched\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "{"], ["proof (state)\nthis:\n  vE p' D (pE - {(u, v)}) = insert (u, v) lvE\n  touched p' D = ltouched\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "assume A: \"Suc j < length p'\""], ["proof (state)\nthis:\n  Suc j < length p'\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "hence \"Suc j < length p\""], ["proof (prove)\nusing this:\n  Suc j < length p'\n\ngoal (1 subgoal):\n 1. Suc j < length p", "using IL"], ["proof (prove)\nusing this:\n  Suc j < length p'\n  i < length p\n\ngoal (1 subgoal):\n 1. Suc j < length p", "by simp"], ["proof (state)\nthis:\n  Suc j < length p\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "from p_connected[OF this]"], ["proof (chain)\npicking this:\n  p ! j \\<times> p ! Suc j \\<inter> (E - pE) \\<noteq> {}", "have \"p!j \\<times> p!Suc j \\<inter> (E-pE) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  p ! j \\<times> p ! Suc j \\<inter> (E - pE) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. p ! j \\<times> p ! Suc j \\<inter> (E - pE) \\<noteq> {}", "."], ["proof (state)\nthis:\n  p ! j \\<times> p ! Suc j \\<inter> (E - pE) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "moreover"], ["proof (state)\nthis:\n  p ! j \\<times> p ! Suc j \\<inter> (E - pE) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "from P'_IDX_SS A"], ["proof (chain)\npicking this:\n  \\<forall>j<Suc i. p ! j \\<subseteq> p' ! j\n  Suc j < length p'", "have \"p!j\\<subseteq>p'!j\" and \"p!Suc j \\<subseteq> p'!Suc j\""], ["proof (prove)\nusing this:\n  \\<forall>j<Suc i. p ! j \\<subseteq> p' ! j\n  Suc j < length p'\n\ngoal (1 subgoal):\n 1. p ! j \\<subseteq> p' ! j &&& p ! Suc j \\<subseteq> p' ! Suc j", "by auto"], ["proof (state)\nthis:\n  p ! j \\<subseteq> p' ! j\n  p ! Suc j \\<subseteq> p' ! Suc j\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "ultimately"], ["proof (chain)\npicking this:\n  p ! j \\<times> p ! Suc j \\<inter> (E - pE) \\<noteq> {}\n  p ! j \\<subseteq> p' ! j\n  p ! Suc j \\<subseteq> p' ! Suc j", "have \"p' ! j \\<times> p' ! Suc j \\<inter> (E - (pE - {(u, v)})) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  p ! j \\<times> p ! Suc j \\<inter> (E - pE) \\<noteq> {}\n  p ! j \\<subseteq> p' ! j\n  p ! Suc j \\<subseteq> p' ! Suc j\n\ngoal (1 subgoal):\n 1. p' ! j \\<times> p' ! Suc j \\<inter> (E - (pE - {(u, v)})) \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  p' ! j \\<times> p' ! Suc j \\<inter> (E - (pE - {(u, v)})) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "}"], ["proof (state)\nthis:\n  Suc ?j2 < length p' \\<Longrightarrow>\n  p' ! ?j2 \\<times> p' ! Suc ?j2 \\<inter> (E - (pE - {(u, v)})) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "note AUX_p_connected = this"], ["proof (state)\nthis:\n  Suc ?j2 < length p' \\<Longrightarrow>\n  p' ! ?j2 \\<times> p' ! Suc ?j2 \\<inter> (E - (pE - {(u, v)})) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "have P_IDX_EQ[simp]: \"\\<forall>j. j < i \\<longrightarrow> p'!j = p!j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j<i. p' ! j = p ! j", "unfolding p'_def collapse_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j<i. (take i p @ [\\<Union> (set (drop i p))]) ! j = p ! j", "using IL"], ["proof (prove)\nusing this:\n  i < length p\n\ngoal (1 subgoal):\n 1. \\<forall>j<i. (take i p @ [\\<Union> (set (drop i p))]) ! j = p ! j", "by (auto simp: nth_append)"], ["proof (state)\nthis:\n  \\<forall>j<i. p' ! j = p ! j\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "have P'_LAST[simp]: \"p'!i = path_seg p i (length p)\" (is \"_ = ?last_cnode\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. p' ! i = path_seg p i (length p)", "unfolding p'_def collapse_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (take i p @ [\\<Union> (set (drop i p))]) ! i = path_seg p i (length p)", "using IL"], ["proof (prove)\nusing this:\n  i < length p\n\ngoal (1 subgoal):\n 1. (take i p @ [\\<Union> (set (drop i p))]) ! i = path_seg p i (length p)", "by (auto simp: nth_append path_seg_drop)"], ["proof (state)\nthis:\n  p' ! i = path_seg p i (length p)\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "{"], ["proof (state)\nthis:\n  p' ! i = path_seg p i (length p)\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "fix j k"], ["proof (state)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "assume A: \"j < k\" \"k < length p'\""], ["proof (state)\nthis:\n  j < k\n  k < length p'\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "have \"p' ! j \\<inter> p' ! k = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p' ! j \\<inter> p' ! k = {}", "proof (safe, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> p' ! j; x \\<in> p' ! k\\<rbrakk>\n       \\<Longrightarrow> False", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> p' ! j; x \\<in> p' ! k\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"v\\<in>p'!j\" and \"v\\<in>p'!k\""], ["proof (state)\nthis:\n  v \\<in> p' ! j\n  v \\<in> p' ! k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> p' ! j; x \\<in> p' ! k\\<rbrakk>\n       \\<Longrightarrow> False", "with A"], ["proof (chain)\npicking this:\n  j < k\n  k < length p'\n  v \\<in> p' ! j\n  v \\<in> p' ! k", "have \"v\\<in>p!j\""], ["proof (prove)\nusing this:\n  j < k\n  k < length p'\n  v \\<in> p' ! j\n  v \\<in> p' ! k\n\ngoal (1 subgoal):\n 1. v \\<in> p ! j", "by simp"], ["proof (state)\nthis:\n  v \\<in> p ! j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> p' ! j; x \\<in> p' ! k\\<rbrakk>\n       \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "assume \"k=i\""], ["proof (state)\nthis:\n  k = i\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "with \\<open>v\\<in>p'!k\\<close>"], ["proof (chain)\npicking this:\n  v \\<in> p' ! k\n  k = i", "obtain k' where \"v\\<in>p!k'\" \"i\\<le>k'\" \"k'<length p\""], ["proof (prove)\nusing this:\n  v \\<in> p' ! k\n  k = i\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        \\<lbrakk>v \\<in> p ! k'; i \\<le> k'; k' < length p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: path_seg_def)"], ["proof (state)\nthis:\n  v \\<in> p ! k'\n  i \\<le> k'\n  k' < length p\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "hence \"p ! j \\<inter> p ! k' = {}\""], ["proof (prove)\nusing this:\n  v \\<in> p ! k'\n  i \\<le> k'\n  k' < length p\n\ngoal (1 subgoal):\n 1. p ! j \\<inter> p ! k' = {}", "using A"], ["proof (prove)\nusing this:\n  v \\<in> p ! k'\n  i \\<le> k'\n  k' < length p\n  j < k\n  k < length p'\n\ngoal (1 subgoal):\n 1. p ! j \\<inter> p ! k' = {}", "by (auto intro!: p_disjoint)"], ["proof (state)\nthis:\n  p ! j \\<inter> p ! k' = {}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "with \\<open>v\\<in>p!j\\<close> \\<open>v\\<in>p!k'\\<close>"], ["proof (chain)\npicking this:\n  v \\<in> p ! j\n  v \\<in> p ! k'\n  p ! j \\<inter> p ! k' = {}", "show False"], ["proof (prove)\nusing this:\n  v \\<in> p ! j\n  v \\<in> p ! k'\n  p ! j \\<inter> p ! k' = {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow> False", "assume \"k\\<noteq>i\""], ["proof (state)\nthis:\n  k \\<noteq> i\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow> False", "with A"], ["proof (chain)\npicking this:\n  j < k\n  k < length p'\n  k \\<noteq> i", "have \"k<i\""], ["proof (prove)\nusing this:\n  j < k\n  k < length p'\n  k \\<noteq> i\n\ngoal (1 subgoal):\n 1. k < i", "by simp"], ["proof (state)\nthis:\n  k < i\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow> False", "hence \"k<length p\""], ["proof (prove)\nusing this:\n  k < i\n\ngoal (1 subgoal):\n 1. k < length p", "using IL"], ["proof (prove)\nusing this:\n  k < i\n  i < length p\n\ngoal (1 subgoal):\n 1. k < length p", "by simp"], ["proof (state)\nthis:\n  k < length p\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow> False", "note p_disjoint[OF \\<open>j<k\\<close> this]"], ["proof (state)\nthis:\n  p ! j \\<inter> p ! k = {}\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  p ! j \\<inter> p ! k = {}\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow> False", "have \"p!j = p'!j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ! j = p' ! j", "using \\<open>j<k\\<close> \\<open>k<i\\<close>"], ["proof (prove)\nusing this:\n  j < k\n  k < i\n\ngoal (1 subgoal):\n 1. p ! j = p' ! j", "by simp"], ["proof (state)\nthis:\n  p ! j = p' ! j\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  p ! j = p' ! j\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow> False", "have \"p!k = p'!k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ! k = p' ! k", "using \\<open>k<i\\<close>"], ["proof (prove)\nusing this:\n  k < i\n\ngoal (1 subgoal):\n 1. p ! k = p' ! k", "by simp"], ["proof (state)\nthis:\n  p ! k = p' ! k\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  p' ! j \\<inter> p' ! k = {}", "show False"], ["proof (prove)\nusing this:\n  p' ! j \\<inter> p' ! k = {}\n\ngoal (1 subgoal):\n 1. False", "using \\<open>v\\<in>p'!j\\<close> \\<open>v\\<in>p'!k\\<close>"], ["proof (prove)\nusing this:\n  p' ! j \\<inter> p' ! k = {}\n  v \\<in> p' ! j\n  v \\<in> p' ! k\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p' ! j \\<inter> p' ! k = {}\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?j2 < ?k2; ?k2 < length p'\\<rbrakk>\n  \\<Longrightarrow> p' ! ?j2 \\<inter> p' ! ?k2 = {}\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "note AUX_p_disjoint = this"], ["proof (state)\nthis:\n  \\<lbrakk>?j2 < ?k2; ?k2 < length p'\\<rbrakk>\n  \\<Longrightarrow> p' ! ?j2 \\<inter> p' ! ?k2 = {}\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?j2 < ?k2; ?k2 < length p'\\<rbrakk>\n  \\<Longrightarrow> p' ! ?j2 \\<inter> p' ! ?k2 = {}\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "fix U"], ["proof (state)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "assume A: \"U\\<in>set p'\""], ["proof (state)\nthis:\n  U \\<in> set p'\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "then"], ["proof (chain)\npicking this:\n  U \\<in> set p'", "obtain j where \"j<Suc i\" and [simp]: \"U=p'!j\""], ["proof (prove)\nusing this:\n  U \\<in> set p'\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j < Suc i; U = p' ! j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_nth)"], ["proof (state)\nthis:\n  j < Suc i\n  U = p' ! j\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "hence \"U \\<times> U \\<subseteq> (insert (u, v) lvE \\<inter> U \\<times> U)\\<^sup>*\""], ["proof (prove)\nusing this:\n  j < Suc i\n  U = p' ! j\n\ngoal (1 subgoal):\n 1. U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>j < Suc i; U = p' ! j; ?P2\\<rbrakk>\n    \\<Longrightarrow> U \\<times> U\n                      \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 2. \\<lbrakk>j < Suc i; U = p' ! j; \\<not> ?P2\\<rbrakk>\n    \\<Longrightarrow> U \\<times> U\n                      \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*", "assume [simp]: \"j=i\""], ["proof (state)\nthis:\n  j = i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j < Suc i; U = p' ! j; ?P2\\<rbrakk>\n    \\<Longrightarrow> U \\<times> U\n                      \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 2. \\<lbrakk>j < Suc i; U = p' ! j; \\<not> ?P2\\<rbrakk>\n    \\<Longrightarrow> U \\<times> U\n                      \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*", "proof (clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> path_seg p i (length p);\n        b \\<in> path_seg p i (length p)\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (Restr (insert (u, v) lvE)\n                                 (path_seg p i (length p)))\\<^sup>*", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> path_seg p i (length p);\n        b \\<in> path_seg p i (length p)\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (Restr (insert (u, v) lvE)\n                                 (path_seg p i (length p)))\\<^sup>*", "assume \"x\\<in>path_seg p i (length p)\" \"y\\<in>path_seg p i (length p)\""], ["proof (state)\nthis:\n  x \\<in> path_seg p i (length p)\n  y \\<in> path_seg p i (length p)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> path_seg p i (length p);\n        b \\<in> path_seg p i (length p)\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (Restr (insert (u, v) lvE)\n                                 (path_seg p i (length p)))\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  x \\<in> path_seg p i (length p)\n  y \\<in> path_seg p i (length p)", "obtain ix iy where \n            IX: \"x\\<in>p!ix\" \"i\\<le>ix\" \"ix<length p\" and\n            IY: \"y\\<in>p!iy\" \"i\\<le>iy\" \"iy<length p\""], ["proof (prove)\nusing this:\n  x \\<in> path_seg p i (length p)\n  y \\<in> path_seg p i (length p)\n\ngoal (1 subgoal):\n 1. (\\<And>ix iy.\n        \\<lbrakk>x \\<in> p ! ix; i \\<le> ix; ix < length p; y \\<in> p ! iy;\n         i \\<le> iy; iy < length p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: path_seg_def)"], ["proof (state)\nthis:\n  x \\<in> p ! ix\n  i \\<le> ix\n  ix < length p\n  y \\<in> p ! iy\n  i \\<le> iy\n  iy < length p\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> path_seg p i (length p);\n        b \\<in> path_seg p i (length p)\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (Restr (insert (u, v) lvE)\n                                 (path_seg p i (length p)))\\<^sup>*", "from IX"], ["proof (chain)\npicking this:\n  x \\<in> p ! ix\n  i \\<le> ix\n  ix < length p", "have SS1: \"path_seg p ix (length p) \\<subseteq> ?last_cnode\""], ["proof (prove)\nusing this:\n  x \\<in> p ! ix\n  i \\<le> ix\n  ix < length p\n\ngoal (1 subgoal):\n 1. path_seg p ix (length p) \\<subseteq> path_seg p i (length p)", "by (subst path_seg_ss_eq) auto"], ["proof (state)\nthis:\n  path_seg p ix (length p) \\<subseteq> path_seg p i (length p)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> path_seg p i (length p);\n        b \\<in> path_seg p i (length p)\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (Restr (insert (u, v) lvE)\n                                 (path_seg p i (length p)))\\<^sup>*", "from IY"], ["proof (chain)\npicking this:\n  y \\<in> p ! iy\n  i \\<le> iy\n  iy < length p", "have SS2: \"path_seg p i (Suc iy) \\<subseteq> ?last_cnode\""], ["proof (prove)\nusing this:\n  y \\<in> p ! iy\n  i \\<le> iy\n  iy < length p\n\ngoal (1 subgoal):\n 1. path_seg p i (Suc iy) \\<subseteq> path_seg p i (length p)", "by (subst path_seg_ss_eq) auto"], ["proof (state)\nthis:\n  path_seg p i (Suc iy) \\<subseteq> path_seg p i (length p)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> path_seg p i (length p);\n        b \\<in> path_seg p i (length p)\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (Restr (insert (u, v) lvE)\n                                 (path_seg p i (length p)))\\<^sup>*", "let ?rE = \"\\<lambda>R. (lvE \\<inter> R\\<times>R)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> path_seg p i (length p);\n        b \\<in> path_seg p i (length p)\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (Restr (insert (u, v) lvE)\n                                 (path_seg p i (length p)))\\<^sup>*", "let ?E = \"(insert (u,v) lvE \\<inter> ?last_cnode \\<times> ?last_cnode)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> path_seg p i (length p);\n        b \\<in> path_seg p i (length p)\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (Restr (insert (u, v) lvE)\n                                 (path_seg p i (length p)))\\<^sup>*", "from pathI[OF \\<open>x\\<in>p!ix\\<close> \\<open>u\\<in>p!(length p - 1)\\<close>]"], ["proof (chain)\npicking this:\n  \\<lbrakk>ix \\<le> length p - 1; length p - 1 < length p\\<rbrakk>\n  \\<Longrightarrow> (x, u)\n                    \\<in> (Restr lvE\n                            (path_seg p ix (Suc (length p - 1))))\\<^sup>*", "have\n            \"(x,u)\\<in>(?rE (path_seg p ix (Suc (length p - 1))))\\<^sup>*\""], ["proof (prove)\nusing this:\n  \\<lbrakk>ix \\<le> length p - 1; length p - 1 < length p\\<rbrakk>\n  \\<Longrightarrow> (x, u)\n                    \\<in> (Restr lvE\n                            (path_seg p ix (Suc (length p - 1))))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (x, u) \\<in> (Restr lvE (path_seg p ix (Suc (length p - 1))))\\<^sup>*", "using IX"], ["proof (prove)\nusing this:\n  \\<lbrakk>ix \\<le> length p - 1; length p - 1 < length p\\<rbrakk>\n  \\<Longrightarrow> (x, u)\n                    \\<in> (Restr lvE\n                            (path_seg p ix (Suc (length p - 1))))\\<^sup>*\n  x \\<in> p ! ix\n  i \\<le> ix\n  ix < length p\n\ngoal (1 subgoal):\n 1. (x, u) \\<in> (Restr lvE (path_seg p ix (Suc (length p - 1))))\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (x, u) \\<in> (Restr lvE (path_seg p ix (Suc (length p - 1))))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> path_seg p i (length p);\n        b \\<in> path_seg p i (length p)\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (Restr (insert (u, v) lvE)\n                                 (path_seg p i (length p)))\\<^sup>*", "hence \"(x,u)\\<in>?E\\<^sup>*\""], ["proof (prove)\nusing this:\n  (x, u) \\<in> (Restr lvE (path_seg p ix (Suc (length p - 1))))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (x, u)\n    \\<in> (Restr (insert (u, v) lvE) (path_seg p i (length p)))\\<^sup>*", "apply (rule rtrancl_mono_mp[rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Restr lvE (path_seg p ix (Suc (length p - 1)))\n    \\<subseteq> Restr (insert (u, v) lvE) (path_seg p i (length p))", "using SS1"], ["proof (prove)\nusing this:\n  path_seg p ix (length p) \\<subseteq> path_seg p i (length p)\n\ngoal (1 subgoal):\n 1. Restr lvE (path_seg p ix (Suc (length p - 1)))\n    \\<subseteq> Restr (insert (u, v) lvE) (path_seg p i (length p))", "by auto"], ["proof (state)\nthis:\n  (x, u) \\<in> (Restr (insert (u, v) lvE) (path_seg p i (length p)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> path_seg p i (length p);\n        b \\<in> path_seg p i (length p)\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (Restr (insert (u, v) lvE)\n                                 (path_seg p i (length p)))\\<^sup>*", "also"], ["proof (state)\nthis:\n  (x, u) \\<in> (Restr (insert (u, v) lvE) (path_seg p i (length p)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> path_seg p i (length p);\n        b \\<in> path_seg p i (length p)\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (Restr (insert (u, v) lvE)\n                                 (path_seg p i (length p)))\\<^sup>*", "have \"(u,v)\\<in>?E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> Restr (insert (u, v) lvE) (path_seg p i (length p))", "using \\<open>i<length p\\<close>"], ["proof (prove)\nusing this:\n  i < length p\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> Restr (insert (u, v) lvE) (path_seg p i (length p))", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length p \\<Longrightarrow>\n    u \\<in> path_seg p i (length p) \\<and> v \\<in> path_seg p i (length p)", "apply (intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. i < length p \\<Longrightarrow> u \\<in> path_seg p i (length p)\n 2. i < length p \\<Longrightarrow> v \\<in> path_seg p i (length p)", "apply (rule rev_subsetD[OF \\<open>u\\<in>p!(length p - 1)\\<close>])"], ["proof (prove)\ngoal (2 subgoals):\n 1. i < length p \\<Longrightarrow>\n    p ! (length p - 1) \\<subseteq> path_seg p i (length p)\n 2. i < length p \\<Longrightarrow> v \\<in> path_seg p i (length p)", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length p \\<Longrightarrow> v \\<in> path_seg p i (length p)", "apply (rule rev_subsetD[OF VMEM])"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length p \\<Longrightarrow> p ! i \\<subseteq> path_seg p i (length p)", "apply (simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (u, v) \\<in> Restr (insert (u, v) lvE) (path_seg p i (length p))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> path_seg p i (length p);\n        b \\<in> path_seg p i (length p)\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (Restr (insert (u, v) lvE)\n                                 (path_seg p i (length p)))\\<^sup>*", "also"], ["proof (state)\nthis:\n  (u, v) \\<in> Restr (insert (u, v) lvE) (path_seg p i (length p))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> path_seg p i (length p);\n        b \\<in> path_seg p i (length p)\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (Restr (insert (u, v) lvE)\n                                 (path_seg p i (length p)))\\<^sup>*", "from pathI[OF \\<open>v\\<in>p!i\\<close> \\<open>y\\<in>p!iy\\<close>]"], ["proof (chain)\npicking this:\n  \\<lbrakk>i \\<le> iy; iy < length p\\<rbrakk>\n  \\<Longrightarrow> (v, y) \\<in> (Restr lvE (path_seg p i (Suc iy)))\\<^sup>*", "have\n            \"(v,y)\\<in>(?rE (path_seg p i (Suc iy)))\\<^sup>*\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i \\<le> iy; iy < length p\\<rbrakk>\n  \\<Longrightarrow> (v, y) \\<in> (Restr lvE (path_seg p i (Suc iy)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (v, y) \\<in> (Restr lvE (path_seg p i (Suc iy)))\\<^sup>*", "using IY"], ["proof (prove)\nusing this:\n  \\<lbrakk>i \\<le> iy; iy < length p\\<rbrakk>\n  \\<Longrightarrow> (v, y) \\<in> (Restr lvE (path_seg p i (Suc iy)))\\<^sup>*\n  y \\<in> p ! iy\n  i \\<le> iy\n  iy < length p\n\ngoal (1 subgoal):\n 1. (v, y) \\<in> (Restr lvE (path_seg p i (Suc iy)))\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (v, y) \\<in> (Restr lvE (path_seg p i (Suc iy)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> path_seg p i (length p);\n        b \\<in> path_seg p i (length p)\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (Restr (insert (u, v) lvE)\n                                 (path_seg p i (length p)))\\<^sup>*", "hence \"(v,y)\\<in>?E\\<^sup>*\""], ["proof (prove)\nusing this:\n  (v, y) \\<in> (Restr lvE (path_seg p i (Suc iy)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (v, y)\n    \\<in> (Restr (insert (u, v) lvE) (path_seg p i (length p)))\\<^sup>*", "apply (rule rtrancl_mono_mp[rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Restr lvE (path_seg p i (Suc iy))\n    \\<subseteq> Restr (insert (u, v) lvE) (path_seg p i (length p))", "using SS2"], ["proof (prove)\nusing this:\n  path_seg p i (Suc iy) \\<subseteq> path_seg p i (length p)\n\ngoal (1 subgoal):\n 1. Restr lvE (path_seg p i (Suc iy))\n    \\<subseteq> Restr (insert (u, v) lvE) (path_seg p i (length p))", "by auto"], ["proof (state)\nthis:\n  (v, y) \\<in> (Restr (insert (u, v) lvE) (path_seg p i (length p)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> path_seg p i (length p);\n        b \\<in> path_seg p i (length p)\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (Restr (insert (u, v) lvE)\n                                 (path_seg p i (length p)))\\<^sup>*", "finally"], ["proof (chain)\npicking this:\n  (x, y) \\<in> (Restr (insert (u, v) lvE) (path_seg p i (length p)))\\<^sup>*", "show \"(x,y)\\<in>?E\\<^sup>*\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> (Restr (insert (u, v) lvE) (path_seg p i (length p)))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (x, y)\n    \\<in> (Restr (insert (u, v) lvE) (path_seg p i (length p)))\\<^sup>*", "."], ["proof (state)\nthis:\n  (x, y) \\<in> (Restr (insert (u, v) lvE) (path_seg p i (length p)))\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < Suc i; U = p' ! j; j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> U \\<times> U\n                      \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>j < Suc i; U = p' ! j; j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> U \\<times> U\n                      \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*", "assume \"j\\<noteq>i\""], ["proof (state)\nthis:\n  j \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < Suc i; U = p' ! j; j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> U \\<times> U\n                      \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*", "with \\<open>j<Suc i\\<close>"], ["proof (chain)\npicking this:\n  j < Suc i\n  j \\<noteq> i", "have [simp]: \"j<i\""], ["proof (prove)\nusing this:\n  j < Suc i\n  j \\<noteq> i\n\ngoal (1 subgoal):\n 1. j < i", "by simp"], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < Suc i; U = p' ! j; j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> U \\<times> U\n                      \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*", "with \\<open>i<length p\\<close>"], ["proof (chain)\npicking this:\n  i < length p\n  j < i", "have \"p!j\\<in>set p\""], ["proof (prove)\nusing this:\n  i < length p\n  j < i\n\ngoal (1 subgoal):\n 1. p ! j \\<in> set p", "by (metis Suc_lessD in_set_conv_nth less_trans_Suc)"], ["proof (state)\nthis:\n  p ! j \\<in> set p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < Suc i; U = p' ! j; j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> U \\<times> U\n                      \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*", "thus ?thesis"], ["proof (prove)\nusing this:\n  p ! j \\<in> set p\n\ngoal (1 subgoal):\n 1. U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*", "using p_sc[of U] \\<open>p!j\\<in>set p\\<close>"], ["proof (prove)\nusing this:\n  p ! j \\<in> set p\n  U \\<in> set p \\<Longrightarrow>\n  U \\<times> U \\<subseteq> (Restr lvE U)\\<^sup>*\n  p ! j \\<in> set p\n\ngoal (1 subgoal):\n 1. U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>p ! j \\<times> p ! j\n                \\<subseteq> (Restr lvE (p ! j))\\<^sup>*;\n        p ! j \\<in> set p; a \\<in> p ! j; b \\<in> p ! j\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (Restr (insert (u, v) lvE) (p ! j))\\<^sup>*", "apply (subgoal_tac \"(a,b)\\<in>(lvE \\<inter> p ! j \\<times> p ! j)\\<^sup>*\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>p ! j \\<times> p ! j\n                \\<subseteq> (Restr lvE (p ! j))\\<^sup>*;\n        p ! j \\<in> set p; a \\<in> p ! j; b \\<in> p ! j;\n        (a, b) \\<in> (Restr lvE (p ! j))\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                         \\<in> (Restr (insert (u, v) lvE) (p ! j))\\<^sup>*\n 2. \\<And>a b.\n       \\<lbrakk>p ! j \\<times> p ! j\n                \\<subseteq> (Restr lvE (p ! j))\\<^sup>*;\n        p ! j \\<in> set p; a \\<in> p ! j; b \\<in> p ! j\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> (Restr lvE (p ! j))\\<^sup>*", "apply (erule rtrancl_mono_mp[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>p ! j \\<times> p ! j\n                \\<subseteq> (Restr lvE (p ! j))\\<^sup>*;\n        p ! j \\<in> set p; a \\<in> p ! j; b \\<in> p ! j\\<rbrakk>\n       \\<Longrightarrow> Restr lvE (p ! j)\n                         \\<subseteq> Restr (insert (u, v) lvE) (p ! j)\n 2. \\<And>a b.\n       \\<lbrakk>p ! j \\<times> p ! j\n                \\<subseteq> (Restr lvE (p ! j))\\<^sup>*;\n        p ! j \\<in> set p; a \\<in> p ! j; b \\<in> p ! j\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> (Restr lvE (p ! j))\\<^sup>*", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "}"], ["proof (state)\nthis:\n  ?U2 \\<in> set p' \\<Longrightarrow>\n  ?U2 \\<times> ?U2 \\<subseteq> (Restr (insert (u, v) lvE) ?U2)\\<^sup>*\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "note AUX_p_sc = this"], ["proof (state)\nthis:\n  ?U2 \\<in> set p' \\<Longrightarrow>\n  ?U2 \\<times> ?U2 \\<subseteq> (Restr (insert (u, v) lvE) ?U2)\\<^sup>*\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "{"], ["proof (state)\nthis:\n  ?U2 \\<in> set p' \\<Longrightarrow>\n  ?U2 \\<times> ?U2 \\<subseteq> (Restr (insert (u, v) lvE) ?U2)\\<^sup>*\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "fix j k"], ["proof (state)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "assume A: \"j<k\" \"k<length p'\""], ["proof (state)\nthis:\n  j < k\n  k < length p'\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "hence \"j<i\""], ["proof (prove)\nusing this:\n  j < k\n  k < length p'\n\ngoal (1 subgoal):\n 1. j < i", "by simp"], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "have \"insert (u, v) lvE \\<inter> p' ! k \\<times> p' ! j = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (u, v) lvE \\<inter> p' ! k \\<times> p' ! j = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. insert (u, v) lvE \\<inter> p' ! k \\<times> p' ! j = {}", "have \"{(u,v)} \\<inter> p' ! k \\<times> p' ! j = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(u, v)} \\<inter> p' ! k \\<times> p' ! j = {}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> p' ! k; v \\<in> p' ! j\\<rbrakk> \\<Longrightarrow> False", "by (metis IL P_IDX_EQ Suc_lessD VMEM \\<open>j < i\\<close> \n            less_irrefl_nat less_trans_Suc p_disjoint_sym)"], ["proof (state)\nthis:\n  {(u, v)} \\<inter> p' ! k \\<times> p' ! j = {}\n\ngoal (1 subgoal):\n 1. insert (u, v) lvE \\<inter> p' ! k \\<times> p' ! j = {}", "moreover"], ["proof (state)\nthis:\n  {(u, v)} \\<inter> p' ! k \\<times> p' ! j = {}\n\ngoal (1 subgoal):\n 1. insert (u, v) lvE \\<inter> p' ! k \\<times> p' ! j = {}", "have \"lvE \\<inter> p' ! k \\<times> p' ! j = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lvE \\<inter> p' ! k \\<times> p' ! j = {}", "proof (cases \"k<i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k < i \\<Longrightarrow> lvE \\<inter> p' ! k \\<times> p' ! j = {}\n 2. \\<not> k < i \\<Longrightarrow> lvE \\<inter> p' ! k \\<times> p' ! j = {}", "case True"], ["proof (state)\nthis:\n  k < i\n\ngoal (2 subgoals):\n 1. k < i \\<Longrightarrow> lvE \\<inter> p' ! k \\<times> p' ! j = {}\n 2. \\<not> k < i \\<Longrightarrow> lvE \\<inter> p' ! k \\<times> p' ! j = {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  k < i\n\ngoal (1 subgoal):\n 1. lvE \\<inter> p' ! k \\<times> p' ! j = {}", "using vE_no_back[of j k] A \\<open>i<length p\\<close>"], ["proof (prove)\nusing this:\n  k < i\n  \\<lbrakk>j < k; k < length p\\<rbrakk>\n  \\<Longrightarrow> lvE \\<inter> p ! k \\<times> p ! j = {}\n  j < k\n  k < length p'\n  i < length p\n\ngoal (1 subgoal):\n 1. lvE \\<inter> p' ! k \\<times> p' ! j = {}", "by auto"], ["proof (state)\nthis:\n  lvE \\<inter> p' ! k \\<times> p' ! j = {}\n\ngoal (1 subgoal):\n 1. \\<not> k < i \\<Longrightarrow> lvE \\<inter> p' ! k \\<times> p' ! j = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k < i \\<Longrightarrow> lvE \\<inter> p' ! k \\<times> p' ! j = {}", "case False"], ["proof (state)\nthis:\n  \\<not> k < i\n\ngoal (1 subgoal):\n 1. \\<not> k < i \\<Longrightarrow> lvE \\<inter> p' ! k \\<times> p' ! j = {}", "with A"], ["proof (chain)\npicking this:\n  j < k\n  k < length p'\n  \\<not> k < i", "have [simp]: \"k=i\""], ["proof (prove)\nusing this:\n  j < k\n  k < length p'\n  \\<not> k < i\n\ngoal (1 subgoal):\n 1. k = i", "by simp"], ["proof (state)\nthis:\n  k = i\n\ngoal (1 subgoal):\n 1. \\<not> k < i \\<Longrightarrow> lvE \\<inter> p' ! k \\<times> p' ! j = {}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. lvE \\<inter> p' ! k \\<times> p' ! j = {}", "proof (rule disjointI, clarsimp simp: \\<open>j<i\\<close>)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> lvE; a \\<in> path_seg p i (length p);\n        b \\<in> p ! j\\<rbrakk>\n       \\<Longrightarrow> False", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> lvE; a \\<in> path_seg p i (length p);\n        b \\<in> p ! j\\<rbrakk>\n       \\<Longrightarrow> False", "assume B: \"(x,y)\\<in>lvE\" \"x\\<in>path_seg p i (length p)\" \"y\\<in>p!j\""], ["proof (state)\nthis:\n  (x, y) \\<in> lvE\n  x \\<in> path_seg p i (length p)\n  y \\<in> p ! j\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> lvE; a \\<in> path_seg p i (length p);\n        b \\<in> p ! j\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (x, y) \\<in> lvE\n  x \\<in> path_seg p i (length p)\n  y \\<in> p ! j", "obtain ix where \"x\\<in>p!ix\" \"i\\<le>ix\" \"ix<length p\""], ["proof (prove)\nusing this:\n  (x, y) \\<in> lvE\n  x \\<in> path_seg p i (length p)\n  y \\<in> p ! j\n\ngoal (1 subgoal):\n 1. (\\<And>ix.\n        \\<lbrakk>x \\<in> p ! ix; i \\<le> ix; ix < length p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: path_seg_def)"], ["proof (state)\nthis:\n  x \\<in> p ! ix\n  i \\<le> ix\n  ix < length p\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> lvE; a \\<in> path_seg p i (length p);\n        b \\<in> p ! j\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  x \\<in> p ! ix\n  i \\<le> ix\n  ix < length p\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> lvE; a \\<in> path_seg p i (length p);\n        b \\<in> p ! j\\<rbrakk>\n       \\<Longrightarrow> False", "with A"], ["proof (chain)\npicking this:\n  j < k\n  k < length p'\n  x \\<in> p ! ix\n  i \\<le> ix\n  ix < length p", "have \"j<ix\""], ["proof (prove)\nusing this:\n  j < k\n  k < length p'\n  x \\<in> p ! ix\n  i \\<le> ix\n  ix < length p\n\ngoal (1 subgoal):\n 1. j < ix", "by simp"], ["proof (state)\nthis:\n  j < ix\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> lvE; a \\<in> path_seg p i (length p);\n        b \\<in> p ! j\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> p ! ix\n  i \\<le> ix\n  ix < length p\n  j < ix", "show False"], ["proof (prove)\nusing this:\n  x \\<in> p ! ix\n  i \\<le> ix\n  ix < length p\n  j < ix\n\ngoal (1 subgoal):\n 1. False", "using vE_no_back[of j ix] B"], ["proof (prove)\nusing this:\n  x \\<in> p ! ix\n  i \\<le> ix\n  ix < length p\n  j < ix\n  \\<lbrakk>j < ix; ix < length p\\<rbrakk>\n  \\<Longrightarrow> lvE \\<inter> p ! ix \\<times> p ! j = {}\n  (x, y) \\<in> lvE\n  x \\<in> path_seg p i (length p)\n  y \\<in> p ! j\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lvE \\<inter> p' ! k \\<times> p' ! j = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lvE \\<inter> p' ! k \\<times> p' ! j = {}\n\ngoal (1 subgoal):\n 1. insert (u, v) lvE \\<inter> p' ! k \\<times> p' ! j = {}", "ultimately"], ["proof (chain)\npicking this:\n  {(u, v)} \\<inter> p' ! k \\<times> p' ! j = {}\n  lvE \\<inter> p' ! k \\<times> p' ! j = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  {(u, v)} \\<inter> p' ! k \\<times> p' ! j = {}\n  lvE \\<inter> p' ! k \\<times> p' ! j = {}\n\ngoal (1 subgoal):\n 1. insert (u, v) lvE \\<inter> p' ! k \\<times> p' ! j = {}", "by blast"], ["proof (state)\nthis:\n  insert (u, v) lvE \\<inter> p' ! k \\<times> p' ! j = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  insert (u, v) lvE \\<inter> p' ! k \\<times> p' ! j = {}\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?j2 < ?k2; ?k2 < length p'\\<rbrakk>\n  \\<Longrightarrow> insert (u, v) lvE \\<inter> p' ! ?k2 \\<times> p' ! ?j2 =\n                    {}\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "note AUX_vE_no_back = this"], ["proof (state)\nthis:\n  \\<lbrakk>?j2 < ?k2; ?k2 < length p'\\<rbrakk>\n  \\<Longrightarrow> insert (u, v) lvE \\<inter> p' ! ?k2 \\<times> p' ! ?j2 =\n                    {}\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D (pE - {(u, v)})", "apply unfold_locales"], ["proof (prove)\ngoal (13 subgoals):\n 1. v0 \\<in> V0\n 2. D0 \\<subseteq> D\n 3. pE - {(u, v)} \\<subseteq> E \\<inter> \\<Union> (set p') \\<times> UNIV\n 4. E \\<inter> \\<Union> (set p') \\<times> UNIV\n    \\<subseteq> pE - {(u, v)} \\<union> UNIV \\<times> touched p' D\n 5. D \\<subseteq> reachable\n 6. \\<And>i.\n       Suc i < length p' \\<Longrightarrow>\n       p' ! i \\<times> p' ! Suc i \\<inter> (E - (pE - {(u, v)})) \\<noteq> {}\n 7. \\<And>i j.\n       \\<lbrakk>i < j; j < length p'\\<rbrakk>\n       \\<Longrightarrow> p' ! i \\<inter> p' ! j = {}\n 8. \\<And>U.\n       U \\<in> set p' \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (vE p' D (pE - {(u, v)})) U)\\<^sup>*\n 9. p' \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p'\n 10. p' = [] \\<Longrightarrow> v0 \\<in> D\nA total of 13 subgoals...", "unfolding defs_fold"], ["proof (prove)\ngoal (13 subgoals):\n 1. v0 \\<in> V0\n 2. D0 \\<subseteq> D\n 3. pE - {(u, v)} \\<subseteq> E \\<inter> \\<Union> (set p') \\<times> UNIV\n 4. E \\<inter> \\<Union> (set p') \\<times> UNIV\n    \\<subseteq> pE - {(u, v)} \\<union> UNIV \\<times> ltouched\n 5. D \\<subseteq> reachable\n 6. \\<And>i.\n       Suc i < length p' \\<Longrightarrow>\n       p' ! i \\<times> p' ! Suc i \\<inter> (E - (pE - {(u, v)})) \\<noteq> {}\n 7. \\<And>i j.\n       \\<lbrakk>i < j; j < length p'\\<rbrakk>\n       \\<Longrightarrow> p' ! i \\<inter> p' ! j = {}\n 8. \\<And>U.\n       U \\<in> set p' \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 9. p' \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p'\n 10. p' = [] \\<Longrightarrow> v0 \\<in> D\nA total of 13 subgoals...", "apply simp"], ["proof (prove)\ngoal (12 subgoals):\n 1. D0 \\<subseteq> D\n 2. pE - {(u, v)} \\<subseteq> E \\<inter> \\<Union> (set p') \\<times> UNIV\n 3. E \\<inter> \\<Union> (set p') \\<times> UNIV\n    \\<subseteq> pE - {(u, v)} \\<union> UNIV \\<times> ltouched\n 4. D \\<subseteq> reachable\n 5. \\<And>i.\n       Suc i < length p' \\<Longrightarrow>\n       p' ! i \\<times> p' ! Suc i \\<inter> (E - (pE - {(u, v)})) \\<noteq> {}\n 6. \\<And>i j.\n       \\<lbrakk>i < j; j < length p'\\<rbrakk>\n       \\<Longrightarrow> p' ! i \\<inter> p' ! j = {}\n 7. \\<And>U.\n       U \\<in> set p' \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 8. p' \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p'\n 9. p' = [] \\<Longrightarrow> v0 \\<in> D\n 10. E `` D \\<subseteq> D\nA total of 12 subgoals...", "using D_incr"], ["proof (prove)\nusing this:\n  D0 \\<subseteq> D\n\ngoal (12 subgoals):\n 1. D0 \\<subseteq> D\n 2. pE - {(u, v)} \\<subseteq> E \\<inter> \\<Union> (set p') \\<times> UNIV\n 3. E \\<inter> \\<Union> (set p') \\<times> UNIV\n    \\<subseteq> pE - {(u, v)} \\<union> UNIV \\<times> ltouched\n 4. D \\<subseteq> reachable\n 5. \\<And>i.\n       Suc i < length p' \\<Longrightarrow>\n       p' ! i \\<times> p' ! Suc i \\<inter> (E - (pE - {(u, v)})) \\<noteq> {}\n 6. \\<And>i j.\n       \\<lbrakk>i < j; j < length p'\\<rbrakk>\n       \\<Longrightarrow> p' ! i \\<inter> p' ! j = {}\n 7. \\<And>U.\n       U \\<in> set p' \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 8. p' \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p'\n 9. p' = [] \\<Longrightarrow> v0 \\<in> D\n 10. E `` D \\<subseteq> D\nA total of 12 subgoals...", "apply auto []"], ["proof (prove)\ngoal (11 subgoals):\n 1. pE - {(u, v)} \\<subseteq> E \\<inter> \\<Union> (set p') \\<times> UNIV\n 2. E \\<inter> \\<Union> (set p') \\<times> UNIV\n    \\<subseteq> pE - {(u, v)} \\<union> UNIV \\<times> ltouched\n 3. D \\<subseteq> reachable\n 4. \\<And>i.\n       Suc i < length p' \\<Longrightarrow>\n       p' ! i \\<times> p' ! Suc i \\<inter> (E - (pE - {(u, v)})) \\<noteq> {}\n 5. \\<And>i j.\n       \\<lbrakk>i < j; j < length p'\\<rbrakk>\n       \\<Longrightarrow> p' ! i \\<inter> p' ! j = {}\n 6. \\<And>U.\n       U \\<in> set p' \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 7. p' \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p'\n 8. p' = [] \\<Longrightarrow> v0 \\<in> D\n 9. E `` D \\<subseteq> D\n 10. \\<And>i j.\n        \\<lbrakk>i < j; j < length p'\\<rbrakk>\n        \\<Longrightarrow> insert (u, v) lvE \\<inter>\n                          p' ! j \\<times> p' ! i =\n                          {}\nA total of 11 subgoals...", "using pE_E_from_p"], ["proof (prove)\nusing this:\n  pE \\<subseteq> E \\<inter> \\<Union> (set p) \\<times> UNIV\n\ngoal (11 subgoals):\n 1. pE - {(u, v)} \\<subseteq> E \\<inter> \\<Union> (set p') \\<times> UNIV\n 2. E \\<inter> \\<Union> (set p') \\<times> UNIV\n    \\<subseteq> pE - {(u, v)} \\<union> UNIV \\<times> ltouched\n 3. D \\<subseteq> reachable\n 4. \\<And>i.\n       Suc i < length p' \\<Longrightarrow>\n       p' ! i \\<times> p' ! Suc i \\<inter> (E - (pE - {(u, v)})) \\<noteq> {}\n 5. \\<And>i j.\n       \\<lbrakk>i < j; j < length p'\\<rbrakk>\n       \\<Longrightarrow> p' ! i \\<inter> p' ! j = {}\n 6. \\<And>U.\n       U \\<in> set p' \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 7. p' \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p'\n 8. p' = [] \\<Longrightarrow> v0 \\<in> D\n 9. E `` D \\<subseteq> D\n 10. \\<And>i j.\n        \\<lbrakk>i < j; j < length p'\\<rbrakk>\n        \\<Longrightarrow> insert (u, v) lvE \\<inter>\n                          p' ! j \\<times> p' ! i =\n                          {}\nA total of 11 subgoals...", "apply auto []"], ["proof (prove)\ngoal (10 subgoals):\n 1. E \\<inter> \\<Union> (set p') \\<times> UNIV\n    \\<subseteq> pE - {(u, v)} \\<union> UNIV \\<times> ltouched\n 2. D \\<subseteq> reachable\n 3. \\<And>i.\n       Suc i < length p' \\<Longrightarrow>\n       p' ! i \\<times> p' ! Suc i \\<inter> (E - (pE - {(u, v)})) \\<noteq> {}\n 4. \\<And>i j.\n       \\<lbrakk>i < j; j < length p'\\<rbrakk>\n       \\<Longrightarrow> p' ! i \\<inter> p' ! j = {}\n 5. \\<And>U.\n       U \\<in> set p' \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 6. p' \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p'\n 7. p' = [] \\<Longrightarrow> v0 \\<in> D\n 8. E `` D \\<subseteq> D\n 9. \\<And>i j.\n       \\<lbrakk>i < j; j < length p'\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p' ! j \\<times> p' ! i =\n                         {}\n 10. \\<Union> (set p') \\<inter> D = {}", "using E_from_p_touched BACK"], ["proof (prove)\nusing this:\n  E \\<inter> \\<Union> (set p) \\<times> UNIV\n  \\<subseteq> pE \\<union> UNIV \\<times> ltouched\n  v \\<in> \\<Union> (set p)\n\ngoal (10 subgoals):\n 1. E \\<inter> \\<Union> (set p') \\<times> UNIV\n    \\<subseteq> pE - {(u, v)} \\<union> UNIV \\<times> ltouched\n 2. D \\<subseteq> reachable\n 3. \\<And>i.\n       Suc i < length p' \\<Longrightarrow>\n       p' ! i \\<times> p' ! Suc i \\<inter> (E - (pE - {(u, v)})) \\<noteq> {}\n 4. \\<And>i j.\n       \\<lbrakk>i < j; j < length p'\\<rbrakk>\n       \\<Longrightarrow> p' ! i \\<inter> p' ! j = {}\n 5. \\<And>U.\n       U \\<in> set p' \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 6. p' \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p'\n 7. p' = [] \\<Longrightarrow> v0 \\<in> D\n 8. E `` D \\<subseteq> D\n 9. \\<And>i j.\n       \\<lbrakk>i < j; j < length p'\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p' ! j \\<times> p' ! i =\n                         {}\n 10. \\<Union> (set p') \\<inter> D = {}", "apply (simp add: touched_def)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>E \\<inter> \\<Union> (set p) \\<times> UNIV\n             \\<subseteq> pE \\<union>\n                         UNIV \\<times> (D \\<union> \\<Union> (set p));\n     \\<exists>X\\<in>set p. v \\<in> X\\<rbrakk>\n    \\<Longrightarrow> E \\<inter> \\<Union> (set p) \\<times> UNIV\n                      \\<subseteq> pE - {(u, v)} \\<union>\n                                  UNIV \\<times>\n                                  (D \\<union> \\<Union> (set p))\n 2. D \\<subseteq> reachable\n 3. \\<And>i.\n       Suc i < length p' \\<Longrightarrow>\n       p' ! i \\<times> p' ! Suc i \\<inter> (E - (pE - {(u, v)})) \\<noteq> {}\n 4. \\<And>i j.\n       \\<lbrakk>i < j; j < length p'\\<rbrakk>\n       \\<Longrightarrow> p' ! i \\<inter> p' ! j = {}\n 5. \\<And>U.\n       U \\<in> set p' \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 6. p' \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p'\n 7. p' = [] \\<Longrightarrow> v0 \\<in> D\n 8. E `` D \\<subseteq> D\n 9. \\<And>i j.\n       \\<lbrakk>i < j; j < length p'\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p' ! j \\<times> p' ! i =\n                         {}\n 10. \\<Union> (set p') \\<inter> D = {}", "apply blast"], ["proof (prove)\ngoal (9 subgoals):\n 1. D \\<subseteq> reachable\n 2. \\<And>i.\n       Suc i < length p' \\<Longrightarrow>\n       p' ! i \\<times> p' ! Suc i \\<inter> (E - (pE - {(u, v)})) \\<noteq> {}\n 3. \\<And>i j.\n       \\<lbrakk>i < j; j < length p'\\<rbrakk>\n       \\<Longrightarrow> p' ! i \\<inter> p' ! j = {}\n 4. \\<And>U.\n       U \\<in> set p' \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 5. p' \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p'\n 6. p' = [] \\<Longrightarrow> v0 \\<in> D\n 7. E `` D \\<subseteq> D\n 8. \\<And>i j.\n       \\<lbrakk>i < j; j < length p'\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p' ! j \\<times> p' ! i =\n                         {}\n 9. \\<Union> (set p') \\<inter> D = {}", "apply (rule D_reachable)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>i.\n       Suc i < length p' \\<Longrightarrow>\n       p' ! i \\<times> p' ! Suc i \\<inter> (E - (pE - {(u, v)})) \\<noteq> {}\n 2. \\<And>i j.\n       \\<lbrakk>i < j; j < length p'\\<rbrakk>\n       \\<Longrightarrow> p' ! i \\<inter> p' ! j = {}\n 3. \\<And>U.\n       U \\<in> set p' \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 4. p' \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p'\n 5. p' = [] \\<Longrightarrow> v0 \\<in> D\n 6. E `` D \\<subseteq> D\n 7. \\<And>i j.\n       \\<lbrakk>i < j; j < length p'\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p' ! j \\<times> p' ! i =\n                         {}\n 8. \\<Union> (set p') \\<inter> D = {}", "apply (rule AUX_p_connected, assumption+) []"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < length p'\\<rbrakk>\n       \\<Longrightarrow> p' ! i \\<inter> p' ! j = {}\n 2. \\<And>U.\n       U \\<in> set p' \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 3. p' \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p'\n 4. p' = [] \\<Longrightarrow> v0 \\<in> D\n 5. E `` D \\<subseteq> D\n 6. \\<And>i j.\n       \\<lbrakk>i < j; j < length p'\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p' ! j \\<times> p' ! i =\n                         {}\n 7. \\<Union> (set p') \\<inter> D = {}", "apply (rule AUX_p_disjoint, assumption+) []"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>U.\n       U \\<in> set p' \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 2. p' \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p'\n 3. p' = [] \\<Longrightarrow> v0 \\<in> D\n 4. E `` D \\<subseteq> D\n 5. \\<And>i j.\n       \\<lbrakk>i < j; j < length p'\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p' ! j \\<times> p' ! i =\n                         {}\n 6. \\<Union> (set p') \\<inter> D = {}", "apply (rule AUX_p_sc, assumption+) []"], ["proof (prove)\ngoal (5 subgoals):\n 1. p' \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p'\n 2. p' = [] \\<Longrightarrow> v0 \\<in> D\n 3. E `` D \\<subseteq> D\n 4. \\<And>i j.\n       \\<lbrakk>i < j; j < length p'\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p' ! j \\<times> p' ! i =\n                         {}\n 5. \\<Union> (set p') \\<inter> D = {}", "using root_v0"], ["proof (prove)\nusing this:\n  p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p\n\ngoal (5 subgoals):\n 1. p' \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p'\n 2. p' = [] \\<Longrightarrow> v0 \\<in> D\n 3. E `` D \\<subseteq> D\n 4. \\<And>i j.\n       \\<lbrakk>i < j; j < length p'\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p' ! j \\<times> p' ! i =\n                         {}\n 5. \\<Union> (set p') \\<inter> D = {}", "apply (cases i)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>p' \\<noteq> []; p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p;\n     i = 0\\<rbrakk>\n    \\<Longrightarrow> v0 \\<in> hd p'\n 2. \\<And>nat.\n       \\<lbrakk>p' \\<noteq> [];\n        p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> v0 \\<in> hd p'\n 3. p' = [] \\<Longrightarrow> v0 \\<in> D\n 4. E `` D \\<subseteq> D\n 5. \\<And>i j.\n       \\<lbrakk>i < j; j < length p'\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p' ! j \\<times> p' ! i =\n                         {}\n 6. \\<Union> (set p') \\<inter> D = {}", "apply (simp add: p'_def collapse_aux_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>v0 \\<in> hd p; i = 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>set p. v0 \\<in> x\n 2. \\<And>nat.\n       \\<lbrakk>p' \\<noteq> [];\n        p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> v0 \\<in> hd p'\n 3. p' = [] \\<Longrightarrow> v0 \\<in> D\n 4. E `` D \\<subseteq> D\n 5. \\<And>i j.\n       \\<lbrakk>i < j; j < length p'\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p' ! j \\<times> p' ! i =\n                         {}\n 6. \\<Union> (set p') \\<inter> D = {}", "apply (metis NE hd_in_set)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>nat.\n       \\<lbrakk>p' \\<noteq> [];\n        p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p; i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> v0 \\<in> hd p'\n 2. p' = [] \\<Longrightarrow> v0 \\<in> D\n 3. E `` D \\<subseteq> D\n 4. \\<And>i j.\n       \\<lbrakk>i < j; j < length p'\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p' ! j \\<times> p' ! i =\n                         {}\n 5. \\<Union> (set p') \\<inter> D = {}", "apply (cases p, simp_all add: p'_def collapse_aux_def) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. p' = [] \\<Longrightarrow> v0 \\<in> D\n 2. E `` D \\<subseteq> D\n 3. \\<And>i j.\n       \\<lbrakk>i < j; j < length p'\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p' ! j \\<times> p' ! i =\n                         {}\n 4. \\<Union> (set p') \\<inter> D = {}", "apply (simp add: p'_def collapse_aux_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. E `` D \\<subseteq> D\n 2. \\<And>i j.\n       \\<lbrakk>i < j; j < length p'\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p' ! j \\<times> p' ! i =\n                         {}\n 3. \\<Union> (set p') \\<inter> D = {}", "apply (rule D_closed)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < length p'\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p' ! j \\<times> p' ! i =\n                         {}\n 2. \\<Union> (set p') \\<inter> D = {}", "apply (drule (1) AUX_vE_no_back, auto) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set p') \\<inter> D = {}", "using p_not_D"], ["proof (prove)\nusing this:\n  \\<Union> (set p) \\<inter> D = {}\n\ngoal (1 subgoal):\n 1. \\<Union> (set p') \\<inter> D = {}", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  invar_loc G v0 D0 p' D (pE - {(u, v)})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invar_push:\n    assumes INV: \"invar v0 D0 (p,D,pE)\"\n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes E: \"(u,v)\\<in>pE\" and UIL: \"u\\<in>last p\"\n    assumes VNE: \"v\\<notin>\\<Union>(set p)\" \"v\\<notin>D\"\n    shows \"invar v0 D0 (push v (p,D,pE - {(u,v)}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar v0 D0 (push v (p, D, pE - {(u, v)}))", "unfolding invar_def push_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case let (p, D, pE) = (p, D, pE - {(u, v)}); p = p @ [{v}];\n             pE = pE \\<union> E \\<inter> {v} \\<times> UNIV\n         in (p, D, pE) of\n    (p, xa, xb) \\<Rightarrow> invar_loc G v0 D0 p xa xb", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (p @ [{v}]) D\n     (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (p @ [{v}]) D\n     (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)", "from INV"], ["proof (chain)\npicking this:\n  invar v0 D0 (p, D, pE)", "interpret invar_loc G v0 D0 p D pE"], ["proof (prove)\nusing this:\n  invar v0 D0 (p, D, pE)\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D pE", "unfolding invar_def"], ["proof (prove)\nusing this:\n  case (p, D, pE) of (p, xa, xb) \\<Rightarrow> invar_loc G v0 D0 p xa xb\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D pE", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (p @ [{v}]) D\n     (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)", "let ?thesis \n      = \"invar_loc G v0 D0 (p @ [{v}]) D (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)\""], ["proof (state)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (p @ [{v}]) D\n     (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)", "note defs_fold = vE_push[OF E UIL VNE] touched_push"], ["proof (state)\nthis:\n  vE (p @ [{v}]) D (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV) =\n  insert (u, v) lvE\n  touched (?p @ [V]) ?D = touched ?p ?D \\<union> V\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (p @ [{v}]) D\n     (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)", "{"], ["proof (state)\nthis:\n  vE (p @ [{v}]) D (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV) =\n  insert (u, v) lvE\n  touched (?p @ [V]) ?D = touched ?p ?D \\<union> V\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (p @ [{v}]) D\n     (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (p @ [{v}]) D\n     (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)", "assume SILL: \"Suc i < length (p @ [{v}])\""], ["proof (state)\nthis:\n  Suc i < length (p @ [{v}])\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (p @ [{v}]) D\n     (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)", "have \"(p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \n             \\<inter> (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n    (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n    {}", "proof (cases \"i = length p - 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = length p - 1 \\<Longrightarrow>\n    (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n    (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n    {}\n 2. i \\<noteq> length p - 1 \\<Longrightarrow>\n    (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n    (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n    {}", "case True"], ["proof (state)\nthis:\n  i = length p - 1\n\ngoal (2 subgoals):\n 1. i = length p - 1 \\<Longrightarrow>\n    (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n    (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n    {}\n 2. i \\<noteq> length p - 1 \\<Longrightarrow>\n    (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n    (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n    {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = length p - 1\n\ngoal (1 subgoal):\n 1. (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n    (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n    {}", "using SILL E pE_E_from_p UIL VNE"], ["proof (prove)\nusing this:\n  i = length p - 1\n  Suc i < length (p @ [{v}])\n  (u, v) \\<in> pE\n  pE \\<subseteq> E \\<inter> \\<Union> (set p) \\<times> UNIV\n  u \\<in> last p\n  v \\<notin> \\<Union> (set p)\n  v \\<notin> D\n\ngoal (1 subgoal):\n 1. (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n    (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n    {}", "by (simp add: nth_append last_conv_nth) fast"], ["proof (state)\nthis:\n  (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n  (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. i \\<noteq> length p - 1 \\<Longrightarrow>\n    (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n    (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n    {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> length p - 1 \\<Longrightarrow>\n    (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n    (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n    {}", "case False"], ["proof (state)\nthis:\n  i \\<noteq> length p - 1\n\ngoal (1 subgoal):\n 1. i \\<noteq> length p - 1 \\<Longrightarrow>\n    (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n    (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n    {}", "with SILL"], ["proof (chain)\npicking this:\n  Suc i < length (p @ [{v}])\n  i \\<noteq> length p - 1", "have SILL': \"Suc i < length p\""], ["proof (prove)\nusing this:\n  Suc i < length (p @ [{v}])\n  i \\<noteq> length p - 1\n\ngoal (1 subgoal):\n 1. Suc i < length p", "by simp"], ["proof (state)\nthis:\n  Suc i < length p\n\ngoal (1 subgoal):\n 1. i \\<noteq> length p - 1 \\<Longrightarrow>\n    (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n    (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n    {}", "with SILL' VNE"], ["proof (chain)\npicking this:\n  Suc i < length p\n  v \\<notin> \\<Union> (set p)\n  v \\<notin> D\n  Suc i < length p", "have X1: \"v\\<notin>p!i\" \"v\\<notin>p!Suc i\""], ["proof (prove)\nusing this:\n  Suc i < length p\n  v \\<notin> \\<Union> (set p)\n  v \\<notin> D\n  Suc i < length p\n\ngoal (1 subgoal):\n 1. v \\<notin> p ! i &&& v \\<notin> p ! Suc i", "by auto"], ["proof (state)\nthis:\n  v \\<notin> p ! i\n  v \\<notin> p ! Suc i\n\ngoal (1 subgoal):\n 1. i \\<noteq> length p - 1 \\<Longrightarrow>\n    (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n    (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n    {}", "from p_connected[OF SILL']"], ["proof (chain)\npicking this:\n  p ! i \\<times> p ! Suc i \\<inter> (E - pE) \\<noteq> {}", "obtain a b where \n          \"a\\<in>p!i\" \"b\\<in>p!Suc i\" \"(a,b)\\<in>E\" \"(a,b)\\<notin>pE\""], ["proof (prove)\nusing this:\n  p ! i \\<times> p ! Suc i \\<inter> (E - pE) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>a \\<in> p ! i; b \\<in> p ! Suc i; (a, b) \\<in> E;\n         (a, b) \\<notin> pE\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a \\<in> p ! i\n  b \\<in> p ! Suc i\n  (a, b) \\<in> E\n  (a, b) \\<notin> pE\n\ngoal (1 subgoal):\n 1. i \\<noteq> length p - 1 \\<Longrightarrow>\n    (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n    (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n    {}", "with X1"], ["proof (chain)\npicking this:\n  v \\<notin> p ! i\n  v \\<notin> p ! Suc i\n  a \\<in> p ! i\n  b \\<in> p ! Suc i\n  (a, b) \\<in> E\n  (a, b) \\<notin> pE", "have \"a\\<noteq>v\" \"b\\<noteq>v\""], ["proof (prove)\nusing this:\n  v \\<notin> p ! i\n  v \\<notin> p ! Suc i\n  a \\<in> p ! i\n  b \\<in> p ! Suc i\n  (a, b) \\<in> E\n  (a, b) \\<notin> pE\n\ngoal (1 subgoal):\n 1. a \\<noteq> v &&& b \\<noteq> v", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> v\n  b \\<noteq> v\n\ngoal (1 subgoal):\n 1. i \\<noteq> length p - 1 \\<Longrightarrow>\n    (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n    (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n    {}", "with \\<open>(a,b)\\<in>E\\<close> \\<open>(a,b)\\<notin>pE\\<close>"], ["proof (chain)\npicking this:\n  (a, b) \\<in> E\n  (a, b) \\<notin> pE\n  a \\<noteq> v\n  b \\<noteq> v", "have \"(a,b)\\<in>(E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV))\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> E\n  (a, b) \\<notin> pE\n  a \\<noteq> v\n  b \\<noteq> v\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)", "by auto"], ["proof (state)\nthis:\n  (a, b) \\<in> E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. i \\<noteq> length p - 1 \\<Longrightarrow>\n    (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n    (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n    {}", "with \\<open>a\\<in>p!i\\<close> \\<open>b\\<in>p!Suc i\\<close>"], ["proof (chain)\npicking this:\n  a \\<in> p ! i\n  b \\<in> p ! Suc i\n  (a, b) \\<in> E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> p ! i\n  b \\<in> p ! Suc i\n  (a, b) \\<in> E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)\n\ngoal (1 subgoal):\n 1. (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n    (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n    {}", "using  SILL'"], ["proof (prove)\nusing this:\n  a \\<in> p ! i\n  b \\<in> p ! Suc i\n  (a, b) \\<in> E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)\n  Suc i < length p\n\ngoal (1 subgoal):\n 1. (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n    (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n    {}", "by (simp add: nth_append; blast)"], ["proof (state)\nthis:\n  (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n  (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n  {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n  (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (p @ [{v}]) D\n     (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)", "}"], ["proof (state)\nthis:\n  Suc ?i2 < length (p @ [{v}]) \\<Longrightarrow>\n  (p @ [{v}]) ! ?i2 \\<times> (p @ [{v}]) ! Suc ?i2 \\<inter>\n  (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (p @ [{v}]) D\n     (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)", "note AUX_p_connected = this"], ["proof (state)\nthis:\n  Suc ?i2 < length (p @ [{v}]) \\<Longrightarrow>\n  (p @ [{v}]) ! ?i2 \\<times> (p @ [{v}]) ! Suc ?i2 \\<inter>\n  (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (p @ [{v}]) D\n     (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)", "{"], ["proof (state)\nthis:\n  Suc ?i2 < length (p @ [{v}]) \\<Longrightarrow>\n  (p @ [{v}]) ! ?i2 \\<times> (p @ [{v}]) ! Suc ?i2 \\<inter>\n  (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (p @ [{v}]) D\n     (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)", "fix U"], ["proof (state)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (p @ [{v}]) D\n     (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)", "assume A: \"U \\<in> set (p @ [{v}])\""], ["proof (state)\nthis:\n  U \\<in> set (p @ [{v}])\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (p @ [{v}]) D\n     (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)", "have \"U \\<times> U \\<subseteq> (insert (u, v) lvE \\<inter> U \\<times> U)\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 2. \\<not> ?P \\<Longrightarrow>\n    U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*", "assume \"U\\<in>set p\""], ["proof (state)\nthis:\n  U \\<in> set p\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 2. \\<not> ?P \\<Longrightarrow>\n    U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*", "with p_sc"], ["proof (chain)\npicking this:\n  ?U \\<in> set p \\<Longrightarrow>\n  ?U \\<times> ?U \\<subseteq> (Restr lvE ?U)\\<^sup>*\n  U \\<in> set p", "have \"U\\<times>U \\<subseteq> (lvE \\<inter> U\\<times>U)\\<^sup>*\""], ["proof (prove)\nusing this:\n  ?U \\<in> set p \\<Longrightarrow>\n  ?U \\<times> ?U \\<subseteq> (Restr lvE ?U)\\<^sup>*\n  U \\<in> set p\n\ngoal (1 subgoal):\n 1. U \\<times> U \\<subseteq> (Restr lvE U)\\<^sup>*", "."], ["proof (state)\nthis:\n  U \\<times> U \\<subseteq> (Restr lvE U)\\<^sup>*\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 2. \\<not> ?P \\<Longrightarrow>\n    U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*", "thus ?thesis"], ["proof (prove)\nusing this:\n  U \\<times> U \\<subseteq> (Restr lvE U)\\<^sup>*\n\ngoal (1 subgoal):\n 1. U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*", "by (metis (lifting, no_types) Int_insert_left_if0 Int_insert_left_if1 \n            in_mono insert_subset rtrancl_mono_mp subsetI)"], ["proof (state)\nthis:\n  U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n\ngoal (1 subgoal):\n 1. U \\<notin> set p \\<Longrightarrow>\n    U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. U \\<notin> set p \\<Longrightarrow>\n    U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*", "assume \"U\\<notin>set p\""], ["proof (state)\nthis:\n  U \\<notin> set p\n\ngoal (1 subgoal):\n 1. U \\<notin> set p \\<Longrightarrow>\n    U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*", "with A"], ["proof (chain)\npicking this:\n  U \\<in> set (p @ [{v}])\n  U \\<notin> set p", "have \"U={v}\""], ["proof (prove)\nusing this:\n  U \\<in> set (p @ [{v}])\n  U \\<notin> set p\n\ngoal (1 subgoal):\n 1. U = {v}", "by simp"], ["proof (state)\nthis:\n  U = {v}\n\ngoal (1 subgoal):\n 1. U \\<notin> set p \\<Longrightarrow>\n    U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*", "thus ?thesis"], ["proof (prove)\nusing this:\n  U = {v}\n\ngoal (1 subgoal):\n 1. U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (p @ [{v}]) D\n     (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)", "}"], ["proof (state)\nthis:\n  ?U2 \\<in> set (p @ [{v}]) \\<Longrightarrow>\n  ?U2 \\<times> ?U2 \\<subseteq> (Restr (insert (u, v) lvE) ?U2)\\<^sup>*\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (p @ [{v}]) D\n     (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)", "note AUX_p_sc = this"], ["proof (state)\nthis:\n  ?U2 \\<in> set (p @ [{v}]) \\<Longrightarrow>\n  ?U2 \\<times> ?U2 \\<subseteq> (Restr (insert (u, v) lvE) ?U2)\\<^sup>*\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (p @ [{v}]) D\n     (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)", "{"], ["proof (state)\nthis:\n  ?U2 \\<in> set (p @ [{v}]) \\<Longrightarrow>\n  ?U2 \\<times> ?U2 \\<subseteq> (Restr (insert (u, v) lvE) ?U2)\\<^sup>*\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (p @ [{v}]) D\n     (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (p @ [{v}]) D\n     (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)", "assume A: \"i < j\" \"j < length (p @ [{v}])\""], ["proof (state)\nthis:\n  i < j\n  j < length (p @ [{v}])\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (p @ [{v}]) D\n     (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)", "have \"insert (u, v) lvE \\<inter> (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (u, v) lvE \\<inter> (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i = {}", "proof (cases \"j=length p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j = length p \\<Longrightarrow>\n    insert (u, v) lvE \\<inter> (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i = {}\n 2. j \\<noteq> length p \\<Longrightarrow>\n    insert (u, v) lvE \\<inter> (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i = {}", "case False"], ["proof (state)\nthis:\n  j \\<noteq> length p\n\ngoal (2 subgoals):\n 1. j = length p \\<Longrightarrow>\n    insert (u, v) lvE \\<inter> (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i = {}\n 2. j \\<noteq> length p \\<Longrightarrow>\n    insert (u, v) lvE \\<inter> (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i = {}", "with A"], ["proof (chain)\npicking this:\n  i < j\n  j < length (p @ [{v}])\n  j \\<noteq> length p", "have \"j<length p\""], ["proof (prove)\nusing this:\n  i < j\n  j < length (p @ [{v}])\n  j \\<noteq> length p\n\ngoal (1 subgoal):\n 1. j < length p", "by simp"], ["proof (state)\nthis:\n  j < length p\n\ngoal (2 subgoals):\n 1. j = length p \\<Longrightarrow>\n    insert (u, v) lvE \\<inter> (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i = {}\n 2. j \\<noteq> length p \\<Longrightarrow>\n    insert (u, v) lvE \\<inter> (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i = {}", "from vE_no_back \\<open>i<j\\<close> this VNE"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i < ?j; ?j < length p\\<rbrakk>\n  \\<Longrightarrow> lvE \\<inter> p ! ?j \\<times> p ! ?i = {}\n  i < j\n  j < length p\n  v \\<notin> \\<Union> (set p)\n  v \\<notin> D", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < ?j; ?j < length p\\<rbrakk>\n  \\<Longrightarrow> lvE \\<inter> p ! ?j \\<times> p ! ?i = {}\n  i < j\n  j < length p\n  v \\<notin> \\<Union> (set p)\n  v \\<notin> D\n\ngoal (1 subgoal):\n 1. insert (u, v) lvE \\<inter> (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i = {}", "by (auto simp add: nth_append)"], ["proof (state)\nthis:\n  insert (u, v) lvE \\<inter> (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i = {}\n\ngoal (1 subgoal):\n 1. j = length p \\<Longrightarrow>\n    insert (u, v) lvE \\<inter> (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j = length p \\<Longrightarrow>\n    insert (u, v) lvE \\<inter> (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i = {}", "from p_not_D A"], ["proof (chain)\npicking this:\n  \\<Union> (set p) \\<inter> D = {}\n  i < j\n  j < length (p @ [{v}])", "have PDDJ: \"p!i \\<inter> D = {}\""], ["proof (prove)\nusing this:\n  \\<Union> (set p) \\<inter> D = {}\n  i < j\n  j < length (p @ [{v}])\n\ngoal (1 subgoal):\n 1. p ! i \\<inter> D = {}", "by (auto simp: Sup_inf_eq_bot_iff)"], ["proof (state)\nthis:\n  p ! i \\<inter> D = {}\n\ngoal (1 subgoal):\n 1. j = length p \\<Longrightarrow>\n    insert (u, v) lvE \\<inter> (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i = {}", "case True"], ["proof (state)\nthis:\n  j = length p\n\ngoal (1 subgoal):\n 1. j = length p \\<Longrightarrow>\n    insert (u, v) lvE \\<inter> (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i = {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  j = length p\n\ngoal (1 subgoal):\n 1. insert (u, v) lvE \\<inter> (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i = {}", "using A"], ["proof (prove)\nusing this:\n  j = length p\n  i < j\n  j < length (p @ [{v}])\n\ngoal (1 subgoal):\n 1. insert (u, v) lvE \\<inter> (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i = {}", "apply (simp add: nth_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j = length p; i < length p\\<rbrakk>\n    \\<Longrightarrow> (u = v \\<longrightarrow> v \\<notin> p ! i) \\<and>\n                      lvE \\<inter> {v} \\<times> p ! i = {}", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>j = length p; i < length p\\<rbrakk>\n    \\<Longrightarrow> u = v \\<longrightarrow> v \\<notin> p ! i\n 2. \\<lbrakk>j = length p; i < length p\\<rbrakk>\n    \\<Longrightarrow> lvE \\<inter> {v} \\<times> p ! i = {}", "using UIL A p_disjoint_sym"], ["proof (prove)\nusing this:\n  u \\<in> last p\n  i < j\n  j < length (p @ [{v}])\n  \\<lbrakk>?i < length p; ?j < length p; ?v \\<in> p ! ?i;\n   ?v \\<in> p ! ?j\\<rbrakk>\n  \\<Longrightarrow> ?i = ?j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j = length p; i < length p\\<rbrakk>\n    \\<Longrightarrow> u = v \\<longrightarrow> v \\<notin> p ! i\n 2. \\<lbrakk>j = length p; i < length p\\<rbrakk>\n    \\<Longrightarrow> lvE \\<inter> {v} \\<times> p ! i = {}", "apply (metis Misc.last_in_set NE UnionI VNE(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j = length p; i < length p\\<rbrakk>\n    \\<Longrightarrow> lvE \\<inter> {v} \\<times> p ! i = {}", "using vE_touched VNE PDDJ"], ["proof (prove)\nusing this:\n  lvE \\<subseteq> ltouched \\<times> ltouched\n  v \\<notin> \\<Union> (set p)\n  v \\<notin> D\n  p ! i \\<inter> D = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j = length p; i < length p\\<rbrakk>\n    \\<Longrightarrow> lvE \\<inter> {v} \\<times> p ! i = {}", "apply (auto simp: touched_def) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  insert (u, v) lvE \\<inter> (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  insert (u, v) lvE \\<inter> (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i = {}\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (p @ [{v}]) D\n     (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < ?j2; ?j2 < length (p @ [{v}])\\<rbrakk>\n  \\<Longrightarrow> insert (u, v) lvE \\<inter>\n                    (p @ [{v}]) ! ?j2 \\<times> (p @ [{v}]) ! ?i2 =\n                    {}\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (p @ [{v}]) D\n     (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)", "note AUX_vE_no_back = this"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < ?j2; ?j2 < length (p @ [{v}])\\<rbrakk>\n  \\<Longrightarrow> insert (u, v) lvE \\<inter>\n                    (p @ [{v}]) ! ?j2 \\<times> (p @ [{v}]) ! ?i2 =\n                    {}\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (p @ [{v}]) D\n     (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (p @ [{v}]) D\n     (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)", "apply unfold_locales"], ["proof (prove)\ngoal (13 subgoals):\n 1. v0 \\<in> V0\n 2. D0 \\<subseteq> D\n 3. pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV\n    \\<subseteq> E \\<inter> \\<Union> (set (p @ [{v}])) \\<times> UNIV\n 4. E \\<inter> \\<Union> (set (p @ [{v}])) \\<times> UNIV\n    \\<subseteq> pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV \\<union>\n                UNIV \\<times> touched (p @ [{v}]) D\n 5. D \\<subseteq> reachable\n 6. \\<And>i.\n       Suc i < length (p @ [{v}]) \\<Longrightarrow>\n       (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n       (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n       {}\n 7. \\<And>i j.\n       \\<lbrakk>i < j; j < length (p @ [{v}])\\<rbrakk>\n       \\<Longrightarrow> (p @ [{v}]) ! i \\<inter> (p @ [{v}]) ! j = {}\n 8. \\<And>U.\n       U \\<in> set (p @ [{v}]) \\<Longrightarrow>\n       U \\<times> U\n       \\<subseteq> (Restr\n                     (vE (p @ [{v}]) D\n                       (pE - {(u, v)} \\<union>\n                        E \\<inter> {v} \\<times> UNIV))\n                     U)\\<^sup>*\n 9. p @ [{v}] \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (p @ [{v}])\n 10. p @ [{v}] = [] \\<Longrightarrow> v0 \\<in> D\nA total of 13 subgoals...", "unfolding defs_fold"], ["proof (prove)\ngoal (13 subgoals):\n 1. v0 \\<in> V0\n 2. D0 \\<subseteq> D\n 3. pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV\n    \\<subseteq> E \\<inter> \\<Union> (set (p @ [{v}])) \\<times> UNIV\n 4. E \\<inter> \\<Union> (set (p @ [{v}])) \\<times> UNIV\n    \\<subseteq> pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV \\<union>\n                UNIV \\<times> touched (p @ [{v}]) D\n 5. D \\<subseteq> reachable\n 6. \\<And>i.\n       Suc i < length (p @ [{v}]) \\<Longrightarrow>\n       (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n       (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n       {}\n 7. \\<And>i j.\n       \\<lbrakk>i < j; j < length (p @ [{v}])\\<rbrakk>\n       \\<Longrightarrow> (p @ [{v}]) ! i \\<inter> (p @ [{v}]) ! j = {}\n 8. \\<And>U.\n       U \\<in> set (p @ [{v}]) \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 9. p @ [{v}] \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (p @ [{v}])\n 10. p @ [{v}] = [] \\<Longrightarrow> v0 \\<in> D\nA total of 13 subgoals...", "apply simp"], ["proof (prove)\ngoal (12 subgoals):\n 1. D0 \\<subseteq> D\n 2. pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV\n    \\<subseteq> E \\<inter> \\<Union> (set (p @ [{v}])) \\<times> UNIV\n 3. E \\<inter> \\<Union> (set (p @ [{v}])) \\<times> UNIV\n    \\<subseteq> pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV \\<union>\n                UNIV \\<times> touched (p @ [{v}]) D\n 4. D \\<subseteq> reachable\n 5. \\<And>i.\n       Suc i < length (p @ [{v}]) \\<Longrightarrow>\n       (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n       (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n       {}\n 6. \\<And>i j.\n       \\<lbrakk>i < j; j < length (p @ [{v}])\\<rbrakk>\n       \\<Longrightarrow> (p @ [{v}]) ! i \\<inter> (p @ [{v}]) ! j = {}\n 7. \\<And>U.\n       U \\<in> set (p @ [{v}]) \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 8. p @ [{v}] \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (p @ [{v}])\n 9. p @ [{v}] = [] \\<Longrightarrow> v0 \\<in> D\n 10. E `` D \\<subseteq> D\nA total of 12 subgoals...", "using D_incr"], ["proof (prove)\nusing this:\n  D0 \\<subseteq> D\n\ngoal (12 subgoals):\n 1. D0 \\<subseteq> D\n 2. pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV\n    \\<subseteq> E \\<inter> \\<Union> (set (p @ [{v}])) \\<times> UNIV\n 3. E \\<inter> \\<Union> (set (p @ [{v}])) \\<times> UNIV\n    \\<subseteq> pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV \\<union>\n                UNIV \\<times> touched (p @ [{v}]) D\n 4. D \\<subseteq> reachable\n 5. \\<And>i.\n       Suc i < length (p @ [{v}]) \\<Longrightarrow>\n       (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n       (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n       {}\n 6. \\<And>i j.\n       \\<lbrakk>i < j; j < length (p @ [{v}])\\<rbrakk>\n       \\<Longrightarrow> (p @ [{v}]) ! i \\<inter> (p @ [{v}]) ! j = {}\n 7. \\<And>U.\n       U \\<in> set (p @ [{v}]) \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 8. p @ [{v}] \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (p @ [{v}])\n 9. p @ [{v}] = [] \\<Longrightarrow> v0 \\<in> D\n 10. E `` D \\<subseteq> D\nA total of 12 subgoals...", "apply auto []"], ["proof (prove)\ngoal (11 subgoals):\n 1. pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV\n    \\<subseteq> E \\<inter> \\<Union> (set (p @ [{v}])) \\<times> UNIV\n 2. E \\<inter> \\<Union> (set (p @ [{v}])) \\<times> UNIV\n    \\<subseteq> pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV \\<union>\n                UNIV \\<times> touched (p @ [{v}]) D\n 3. D \\<subseteq> reachable\n 4. \\<And>i.\n       Suc i < length (p @ [{v}]) \\<Longrightarrow>\n       (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n       (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n       {}\n 5. \\<And>i j.\n       \\<lbrakk>i < j; j < length (p @ [{v}])\\<rbrakk>\n       \\<Longrightarrow> (p @ [{v}]) ! i \\<inter> (p @ [{v}]) ! j = {}\n 6. \\<And>U.\n       U \\<in> set (p @ [{v}]) \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 7. p @ [{v}] \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (p @ [{v}])\n 8. p @ [{v}] = [] \\<Longrightarrow> v0 \\<in> D\n 9. E `` D \\<subseteq> D\n 10. \\<And>i j.\n        \\<lbrakk>i < j; j < length (p @ [{v}])\\<rbrakk>\n        \\<Longrightarrow> insert (u, v) lvE \\<inter>\n                          (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i =\n                          {}\nA total of 11 subgoals...", "using pE_E_from_p"], ["proof (prove)\nusing this:\n  pE \\<subseteq> E \\<inter> \\<Union> (set p) \\<times> UNIV\n\ngoal (11 subgoals):\n 1. pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV\n    \\<subseteq> E \\<inter> \\<Union> (set (p @ [{v}])) \\<times> UNIV\n 2. E \\<inter> \\<Union> (set (p @ [{v}])) \\<times> UNIV\n    \\<subseteq> pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV \\<union>\n                UNIV \\<times> touched (p @ [{v}]) D\n 3. D \\<subseteq> reachable\n 4. \\<And>i.\n       Suc i < length (p @ [{v}]) \\<Longrightarrow>\n       (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n       (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n       {}\n 5. \\<And>i j.\n       \\<lbrakk>i < j; j < length (p @ [{v}])\\<rbrakk>\n       \\<Longrightarrow> (p @ [{v}]) ! i \\<inter> (p @ [{v}]) ! j = {}\n 6. \\<And>U.\n       U \\<in> set (p @ [{v}]) \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 7. p @ [{v}] \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (p @ [{v}])\n 8. p @ [{v}] = [] \\<Longrightarrow> v0 \\<in> D\n 9. E `` D \\<subseteq> D\n 10. \\<And>i j.\n        \\<lbrakk>i < j; j < length (p @ [{v}])\\<rbrakk>\n        \\<Longrightarrow> insert (u, v) lvE \\<inter>\n                          (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i =\n                          {}\nA total of 11 subgoals...", "apply auto []"], ["proof (prove)\ngoal (10 subgoals):\n 1. E \\<inter> \\<Union> (set (p @ [{v}])) \\<times> UNIV\n    \\<subseteq> pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV \\<union>\n                UNIV \\<times> touched (p @ [{v}]) D\n 2. D \\<subseteq> reachable\n 3. \\<And>i.\n       Suc i < length (p @ [{v}]) \\<Longrightarrow>\n       (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n       (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n       {}\n 4. \\<And>i j.\n       \\<lbrakk>i < j; j < length (p @ [{v}])\\<rbrakk>\n       \\<Longrightarrow> (p @ [{v}]) ! i \\<inter> (p @ [{v}]) ! j = {}\n 5. \\<And>U.\n       U \\<in> set (p @ [{v}]) \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 6. p @ [{v}] \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (p @ [{v}])\n 7. p @ [{v}] = [] \\<Longrightarrow> v0 \\<in> D\n 8. E `` D \\<subseteq> D\n 9. \\<And>i j.\n       \\<lbrakk>i < j; j < length (p @ [{v}])\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter>\n                         (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i =\n                         {}\n 10. \\<Union> (set (p @ [{v}])) \\<inter> D = {}", "using E_from_p_touched VNE"], ["proof (prove)\nusing this:\n  E \\<inter> \\<Union> (set p) \\<times> UNIV\n  \\<subseteq> pE \\<union> UNIV \\<times> ltouched\n  v \\<notin> \\<Union> (set p)\n  v \\<notin> D\n\ngoal (10 subgoals):\n 1. E \\<inter> \\<Union> (set (p @ [{v}])) \\<times> UNIV\n    \\<subseteq> pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV \\<union>\n                UNIV \\<times> touched (p @ [{v}]) D\n 2. D \\<subseteq> reachable\n 3. \\<And>i.\n       Suc i < length (p @ [{v}]) \\<Longrightarrow>\n       (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n       (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n       {}\n 4. \\<And>i j.\n       \\<lbrakk>i < j; j < length (p @ [{v}])\\<rbrakk>\n       \\<Longrightarrow> (p @ [{v}]) ! i \\<inter> (p @ [{v}]) ! j = {}\n 5. \\<And>U.\n       U \\<in> set (p @ [{v}]) \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 6. p @ [{v}] \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (p @ [{v}])\n 7. p @ [{v}] = [] \\<Longrightarrow> v0 \\<in> D\n 8. E `` D \\<subseteq> D\n 9. \\<And>i j.\n       \\<lbrakk>i < j; j < length (p @ [{v}])\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter>\n                         (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i =\n                         {}\n 10. \\<Union> (set (p @ [{v}])) \\<inter> D = {}", "apply (auto simp: touched_def) []"], ["proof (prove)\ngoal (9 subgoals):\n 1. D \\<subseteq> reachable\n 2. \\<And>i.\n       Suc i < length (p @ [{v}]) \\<Longrightarrow>\n       (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n       (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n       {}\n 3. \\<And>i j.\n       \\<lbrakk>i < j; j < length (p @ [{v}])\\<rbrakk>\n       \\<Longrightarrow> (p @ [{v}]) ! i \\<inter> (p @ [{v}]) ! j = {}\n 4. \\<And>U.\n       U \\<in> set (p @ [{v}]) \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 5. p @ [{v}] \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (p @ [{v}])\n 6. p @ [{v}] = [] \\<Longrightarrow> v0 \\<in> D\n 7. E `` D \\<subseteq> D\n 8. \\<And>i j.\n       \\<lbrakk>i < j; j < length (p @ [{v}])\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter>\n                         (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i =\n                         {}\n 9. \\<Union> (set (p @ [{v}])) \\<inter> D = {}", "apply (rule D_reachable)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>i.\n       Suc i < length (p @ [{v}]) \\<Longrightarrow>\n       (p @ [{v}]) ! i \\<times> (p @ [{v}]) ! Suc i \\<inter>\n       (E - (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)) \\<noteq>\n       {}\n 2. \\<And>i j.\n       \\<lbrakk>i < j; j < length (p @ [{v}])\\<rbrakk>\n       \\<Longrightarrow> (p @ [{v}]) ! i \\<inter> (p @ [{v}]) ! j = {}\n 3. \\<And>U.\n       U \\<in> set (p @ [{v}]) \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 4. p @ [{v}] \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (p @ [{v}])\n 5. p @ [{v}] = [] \\<Longrightarrow> v0 \\<in> D\n 6. E `` D \\<subseteq> D\n 7. \\<And>i j.\n       \\<lbrakk>i < j; j < length (p @ [{v}])\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter>\n                         (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i =\n                         {}\n 8. \\<Union> (set (p @ [{v}])) \\<inter> D = {}", "apply (rule AUX_p_connected, assumption+) []"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < length (p @ [{v}])\\<rbrakk>\n       \\<Longrightarrow> (p @ [{v}]) ! i \\<inter> (p @ [{v}]) ! j = {}\n 2. \\<And>U.\n       U \\<in> set (p @ [{v}]) \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 3. p @ [{v}] \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (p @ [{v}])\n 4. p @ [{v}] = [] \\<Longrightarrow> v0 \\<in> D\n 5. E `` D \\<subseteq> D\n 6. \\<And>i j.\n       \\<lbrakk>i < j; j < length (p @ [{v}])\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter>\n                         (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i =\n                         {}\n 7. \\<Union> (set (p @ [{v}])) \\<inter> D = {}", "using p_disjoint \\<open>v\\<notin>\\<Union>(set p)\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < ?j; ?j < length p\\<rbrakk>\n  \\<Longrightarrow> p ! ?i \\<inter> p ! ?j = {}\n  v \\<notin> \\<Union> (set p)\n\ngoal (7 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < length (p @ [{v}])\\<rbrakk>\n       \\<Longrightarrow> (p @ [{v}]) ! i \\<inter> (p @ [{v}]) ! j = {}\n 2. \\<And>U.\n       U \\<in> set (p @ [{v}]) \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 3. p @ [{v}] \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (p @ [{v}])\n 4. p @ [{v}] = [] \\<Longrightarrow> v0 \\<in> D\n 5. E `` D \\<subseteq> D\n 6. \\<And>i j.\n       \\<lbrakk>i < j; j < length (p @ [{v}])\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter>\n                         (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i =\n                         {}\n 7. \\<Union> (set (p @ [{v}])) \\<inter> D = {}", "apply (auto simp: nth_append) []"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>U.\n       U \\<in> set (p @ [{v}]) \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 2. p @ [{v}] \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (p @ [{v}])\n 3. p @ [{v}] = [] \\<Longrightarrow> v0 \\<in> D\n 4. E `` D \\<subseteq> D\n 5. \\<And>i j.\n       \\<lbrakk>i < j; j < length (p @ [{v}])\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter>\n                         (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i =\n                         {}\n 6. \\<Union> (set (p @ [{v}])) \\<inter> D = {}", "apply (rule AUX_p_sc, assumption+) []"], ["proof (prove)\ngoal (5 subgoals):\n 1. p @ [{v}] \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (p @ [{v}])\n 2. p @ [{v}] = [] \\<Longrightarrow> v0 \\<in> D\n 3. E `` D \\<subseteq> D\n 4. \\<And>i j.\n       \\<lbrakk>i < j; j < length (p @ [{v}])\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter>\n                         (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i =\n                         {}\n 5. \\<Union> (set (p @ [{v}])) \\<inter> D = {}", "using root_v0"], ["proof (prove)\nusing this:\n  p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p\n\ngoal (5 subgoals):\n 1. p @ [{v}] \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd (p @ [{v}])\n 2. p @ [{v}] = [] \\<Longrightarrow> v0 \\<in> D\n 3. E `` D \\<subseteq> D\n 4. \\<And>i j.\n       \\<lbrakk>i < j; j < length (p @ [{v}])\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter>\n                         (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i =\n                         {}\n 5. \\<Union> (set (p @ [{v}])) \\<inter> D = {}", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. p @ [{v}] = [] \\<Longrightarrow> v0 \\<in> D\n 2. E `` D \\<subseteq> D\n 3. \\<And>i j.\n       \\<lbrakk>i < j; j < length (p @ [{v}])\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter>\n                         (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i =\n                         {}\n 4. \\<Union> (set (p @ [{v}])) \\<inter> D = {}", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. E `` D \\<subseteq> D\n 2. \\<And>i j.\n       \\<lbrakk>i < j; j < length (p @ [{v}])\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter>\n                         (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i =\n                         {}\n 3. \\<Union> (set (p @ [{v}])) \\<inter> D = {}", "apply (rule D_closed)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < length (p @ [{v}])\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter>\n                         (p @ [{v}]) ! j \\<times> (p @ [{v}]) ! i =\n                         {}\n 2. \\<Union> (set (p @ [{v}])) \\<inter> D = {}", "apply (rule AUX_vE_no_back, assumption+) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set (p @ [{v}])) \\<inter> D = {}", "using p_not_D VNE"], ["proof (prove)\nusing this:\n  \\<Union> (set p) \\<inter> D = {}\n  v \\<notin> \\<Union> (set p)\n  v \\<notin> D\n\ngoal (1 subgoal):\n 1. \\<Union> (set (p @ [{v}])) \\<inter> D = {}", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  invar_loc G v0 D0 (p @ [{v}]) D\n   (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invar_skip:\n    assumes INV: \"invar v0 D0 (p,D,pE)\"\n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes E: \"(u,v)\\<in>pE\" and UIL: \"u\\<in>last p\"\n    assumes VNP: \"v\\<notin>\\<Union>(set p)\" and VD: \"v\\<in>D\"\n    shows \"invar v0 D0 (p,D,pE - {(u, v)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar v0 D0 (p, D, pE - {(u, v)})", "unfolding invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case (p, D, pE - {(u, v)}) of\n    (p, xa, xb) \\<Rightarrow> invar_loc G v0 D0 p xa xb", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D (pE - {(u, v)})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D (pE - {(u, v)})", "from INV"], ["proof (chain)\npicking this:\n  invar v0 D0 (p, D, pE)", "interpret invar_loc G v0 D0 p D pE"], ["proof (prove)\nusing this:\n  invar v0 D0 (p, D, pE)\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D pE", "unfolding invar_def"], ["proof (prove)\nusing this:\n  case (p, D, pE) of (p, xa, xb) \\<Rightarrow> invar_loc G v0 D0 p xa xb\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D pE", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D (pE - {(u, v)})", "let ?thesis = \"invar_loc G v0 D0 p D (pE - {(u, v)})\""], ["proof (state)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D (pE - {(u, v)})", "note defs_fold = vE_remove[OF NE E]"], ["proof (state)\nthis:\n  vE p D (pE - {(u, v)}) = insert (u, v) lvE\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D (pE - {(u, v)})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D (pE - {(u, v)})", "apply unfold_locales"], ["proof (prove)\ngoal (13 subgoals):\n 1. v0 \\<in> V0\n 2. D0 \\<subseteq> D\n 3. pE - {(u, v)} \\<subseteq> E \\<inter> \\<Union> (set p) \\<times> UNIV\n 4. E \\<inter> \\<Union> (set p) \\<times> UNIV\n    \\<subseteq> pE - {(u, v)} \\<union> UNIV \\<times> ltouched\n 5. D \\<subseteq> reachable\n 6. \\<And>i.\n       Suc i < length p \\<Longrightarrow>\n       p ! i \\<times> p ! Suc i \\<inter> (E - (pE - {(u, v)})) \\<noteq> {}\n 7. \\<And>i j.\n       \\<lbrakk>i < j; j < length p\\<rbrakk>\n       \\<Longrightarrow> p ! i \\<inter> p ! j = {}\n 8. \\<And>U.\n       U \\<in> set p \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (vE p D (pE - {(u, v)})) U)\\<^sup>*\n 9. p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p\n 10. p = [] \\<Longrightarrow> v0 \\<in> D\nA total of 13 subgoals...", "unfolding defs_fold"], ["proof (prove)\ngoal (13 subgoals):\n 1. v0 \\<in> V0\n 2. D0 \\<subseteq> D\n 3. pE - {(u, v)} \\<subseteq> E \\<inter> \\<Union> (set p) \\<times> UNIV\n 4. E \\<inter> \\<Union> (set p) \\<times> UNIV\n    \\<subseteq> pE - {(u, v)} \\<union> UNIV \\<times> ltouched\n 5. D \\<subseteq> reachable\n 6. \\<And>i.\n       Suc i < length p \\<Longrightarrow>\n       p ! i \\<times> p ! Suc i \\<inter> (E - (pE - {(u, v)})) \\<noteq> {}\n 7. \\<And>i j.\n       \\<lbrakk>i < j; j < length p\\<rbrakk>\n       \\<Longrightarrow> p ! i \\<inter> p ! j = {}\n 8. \\<And>U.\n       U \\<in> set p \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 9. p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p\n 10. p = [] \\<Longrightarrow> v0 \\<in> D\nA total of 13 subgoals...", "apply simp"], ["proof (prove)\ngoal (12 subgoals):\n 1. D0 \\<subseteq> D\n 2. pE - {(u, v)} \\<subseteq> E \\<inter> \\<Union> (set p) \\<times> UNIV\n 3. E \\<inter> \\<Union> (set p) \\<times> UNIV\n    \\<subseteq> pE - {(u, v)} \\<union> UNIV \\<times> ltouched\n 4. D \\<subseteq> reachable\n 5. \\<And>i.\n       Suc i < length p \\<Longrightarrow>\n       p ! i \\<times> p ! Suc i \\<inter> (E - (pE - {(u, v)})) \\<noteq> {}\n 6. \\<And>i j.\n       \\<lbrakk>i < j; j < length p\\<rbrakk>\n       \\<Longrightarrow> p ! i \\<inter> p ! j = {}\n 7. \\<And>U.\n       U \\<in> set p \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 8. p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p\n 9. p = [] \\<Longrightarrow> v0 \\<in> D\n 10. E `` D \\<subseteq> D\nA total of 12 subgoals...", "using D_incr"], ["proof (prove)\nusing this:\n  D0 \\<subseteq> D\n\ngoal (12 subgoals):\n 1. D0 \\<subseteq> D\n 2. pE - {(u, v)} \\<subseteq> E \\<inter> \\<Union> (set p) \\<times> UNIV\n 3. E \\<inter> \\<Union> (set p) \\<times> UNIV\n    \\<subseteq> pE - {(u, v)} \\<union> UNIV \\<times> ltouched\n 4. D \\<subseteq> reachable\n 5. \\<And>i.\n       Suc i < length p \\<Longrightarrow>\n       p ! i \\<times> p ! Suc i \\<inter> (E - (pE - {(u, v)})) \\<noteq> {}\n 6. \\<And>i j.\n       \\<lbrakk>i < j; j < length p\\<rbrakk>\n       \\<Longrightarrow> p ! i \\<inter> p ! j = {}\n 7. \\<And>U.\n       U \\<in> set p \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 8. p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p\n 9. p = [] \\<Longrightarrow> v0 \\<in> D\n 10. E `` D \\<subseteq> D\nA total of 12 subgoals...", "apply auto []"], ["proof (prove)\ngoal (11 subgoals):\n 1. pE - {(u, v)} \\<subseteq> E \\<inter> \\<Union> (set p) \\<times> UNIV\n 2. E \\<inter> \\<Union> (set p) \\<times> UNIV\n    \\<subseteq> pE - {(u, v)} \\<union> UNIV \\<times> ltouched\n 3. D \\<subseteq> reachable\n 4. \\<And>i.\n       Suc i < length p \\<Longrightarrow>\n       p ! i \\<times> p ! Suc i \\<inter> (E - (pE - {(u, v)})) \\<noteq> {}\n 5. \\<And>i j.\n       \\<lbrakk>i < j; j < length p\\<rbrakk>\n       \\<Longrightarrow> p ! i \\<inter> p ! j = {}\n 6. \\<And>U.\n       U \\<in> set p \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 7. p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p\n 8. p = [] \\<Longrightarrow> v0 \\<in> D\n 9. E `` D \\<subseteq> D\n 10. \\<And>i j.\n        \\<lbrakk>i < j; j < length p\\<rbrakk>\n        \\<Longrightarrow> insert (u, v) lvE \\<inter> p ! j \\<times> p ! i =\n                          {}\nA total of 11 subgoals...", "using pE_E_from_p"], ["proof (prove)\nusing this:\n  pE \\<subseteq> E \\<inter> \\<Union> (set p) \\<times> UNIV\n\ngoal (11 subgoals):\n 1. pE - {(u, v)} \\<subseteq> E \\<inter> \\<Union> (set p) \\<times> UNIV\n 2. E \\<inter> \\<Union> (set p) \\<times> UNIV\n    \\<subseteq> pE - {(u, v)} \\<union> UNIV \\<times> ltouched\n 3. D \\<subseteq> reachable\n 4. \\<And>i.\n       Suc i < length p \\<Longrightarrow>\n       p ! i \\<times> p ! Suc i \\<inter> (E - (pE - {(u, v)})) \\<noteq> {}\n 5. \\<And>i j.\n       \\<lbrakk>i < j; j < length p\\<rbrakk>\n       \\<Longrightarrow> p ! i \\<inter> p ! j = {}\n 6. \\<And>U.\n       U \\<in> set p \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 7. p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p\n 8. p = [] \\<Longrightarrow> v0 \\<in> D\n 9. E `` D \\<subseteq> D\n 10. \\<And>i j.\n        \\<lbrakk>i < j; j < length p\\<rbrakk>\n        \\<Longrightarrow> insert (u, v) lvE \\<inter> p ! j \\<times> p ! i =\n                          {}\nA total of 11 subgoals...", "apply auto []"], ["proof (prove)\ngoal (10 subgoals):\n 1. E \\<inter> \\<Union> (set p) \\<times> UNIV\n    \\<subseteq> pE - {(u, v)} \\<union> UNIV \\<times> ltouched\n 2. D \\<subseteq> reachable\n 3. \\<And>i.\n       Suc i < length p \\<Longrightarrow>\n       p ! i \\<times> p ! Suc i \\<inter> (E - (pE - {(u, v)})) \\<noteq> {}\n 4. \\<And>i j.\n       \\<lbrakk>i < j; j < length p\\<rbrakk>\n       \\<Longrightarrow> p ! i \\<inter> p ! j = {}\n 5. \\<And>U.\n       U \\<in> set p \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 6. p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p\n 7. p = [] \\<Longrightarrow> v0 \\<in> D\n 8. E `` D \\<subseteq> D\n 9. \\<And>i j.\n       \\<lbrakk>i < j; j < length p\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p ! j \\<times> p ! i =\n                         {}\n 10. \\<Union> (set p) \\<inter> D = {}", "using E_from_p_touched VD"], ["proof (prove)\nusing this:\n  E \\<inter> \\<Union> (set p) \\<times> UNIV\n  \\<subseteq> pE \\<union> UNIV \\<times> ltouched\n  v \\<in> D\n\ngoal (10 subgoals):\n 1. E \\<inter> \\<Union> (set p) \\<times> UNIV\n    \\<subseteq> pE - {(u, v)} \\<union> UNIV \\<times> ltouched\n 2. D \\<subseteq> reachable\n 3. \\<And>i.\n       Suc i < length p \\<Longrightarrow>\n       p ! i \\<times> p ! Suc i \\<inter> (E - (pE - {(u, v)})) \\<noteq> {}\n 4. \\<And>i j.\n       \\<lbrakk>i < j; j < length p\\<rbrakk>\n       \\<Longrightarrow> p ! i \\<inter> p ! j = {}\n 5. \\<And>U.\n       U \\<in> set p \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 6. p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p\n 7. p = [] \\<Longrightarrow> v0 \\<in> D\n 8. E `` D \\<subseteq> D\n 9. \\<And>i j.\n       \\<lbrakk>i < j; j < length p\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p ! j \\<times> p ! i =\n                         {}\n 10. \\<Union> (set p) \\<inter> D = {}", "apply (auto simp: touched_def) []"], ["proof (prove)\ngoal (9 subgoals):\n 1. D \\<subseteq> reachable\n 2. \\<And>i.\n       Suc i < length p \\<Longrightarrow>\n       p ! i \\<times> p ! Suc i \\<inter> (E - (pE - {(u, v)})) \\<noteq> {}\n 3. \\<And>i j.\n       \\<lbrakk>i < j; j < length p\\<rbrakk>\n       \\<Longrightarrow> p ! i \\<inter> p ! j = {}\n 4. \\<And>U.\n       U \\<in> set p \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 5. p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p\n 6. p = [] \\<Longrightarrow> v0 \\<in> D\n 7. E `` D \\<subseteq> D\n 8. \\<And>i j.\n       \\<lbrakk>i < j; j < length p\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p ! j \\<times> p ! i =\n                         {}\n 9. \\<Union> (set p) \\<inter> D = {}", "apply (rule D_reachable)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>i.\n       Suc i < length p \\<Longrightarrow>\n       p ! i \\<times> p ! Suc i \\<inter> (E - (pE - {(u, v)})) \\<noteq> {}\n 2. \\<And>i j.\n       \\<lbrakk>i < j; j < length p\\<rbrakk>\n       \\<Longrightarrow> p ! i \\<inter> p ! j = {}\n 3. \\<And>U.\n       U \\<in> set p \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 4. p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p\n 5. p = [] \\<Longrightarrow> v0 \\<in> D\n 6. E `` D \\<subseteq> D\n 7. \\<And>i j.\n       \\<lbrakk>i < j; j < length p\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p ! j \\<times> p ! i =\n                         {}\n 8. \\<Union> (set p) \\<inter> D = {}", "using p_connected"], ["proof (prove)\nusing this:\n  Suc ?i < length p \\<Longrightarrow>\n  p ! ?i \\<times> p ! Suc ?i \\<inter> (E - pE) \\<noteq> {}\n\ngoal (8 subgoals):\n 1. \\<And>i.\n       Suc i < length p \\<Longrightarrow>\n       p ! i \\<times> p ! Suc i \\<inter> (E - (pE - {(u, v)})) \\<noteq> {}\n 2. \\<And>i j.\n       \\<lbrakk>i < j; j < length p\\<rbrakk>\n       \\<Longrightarrow> p ! i \\<inter> p ! j = {}\n 3. \\<And>U.\n       U \\<in> set p \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 4. p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p\n 5. p = [] \\<Longrightarrow> v0 \\<in> D\n 6. E `` D \\<subseteq> D\n 7. \\<And>i j.\n       \\<lbrakk>i < j; j < length p\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p ! j \\<times> p ! i =\n                         {}\n 8. \\<Union> (set p) \\<inter> D = {}", "apply auto []"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < length p\\<rbrakk>\n       \\<Longrightarrow> p ! i \\<inter> p ! j = {}\n 2. \\<And>U.\n       U \\<in> set p \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 3. p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p\n 4. p = [] \\<Longrightarrow> v0 \\<in> D\n 5. E `` D \\<subseteq> D\n 6. \\<And>i j.\n       \\<lbrakk>i < j; j < length p\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p ! j \\<times> p ! i =\n                         {}\n 7. \\<Union> (set p) \\<inter> D = {}", "apply (rule p_disjoint, assumption+) []"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>U.\n       U \\<in> set p \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 2. p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p\n 3. p = [] \\<Longrightarrow> v0 \\<in> D\n 4. E `` D \\<subseteq> D\n 5. \\<And>i j.\n       \\<lbrakk>i < j; j < length p\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p ! j \\<times> p ! i =\n                         {}\n 6. \\<Union> (set p) \\<inter> D = {}", "apply (drule p_sc)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>U.\n       U \\<times> U \\<subseteq> (Restr lvE U)\\<^sup>* \\<Longrightarrow>\n       U \\<times> U \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 2. p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p\n 3. p = [] \\<Longrightarrow> v0 \\<in> D\n 4. E `` D \\<subseteq> D\n 5. \\<And>i j.\n       \\<lbrakk>i < j; j < length p\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p ! j \\<times> p ! i =\n                         {}\n 6. \\<Union> (set p) \\<inter> D = {}", "apply (erule order_trans)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>U.\n       (Restr lvE U)\\<^sup>*\n       \\<subseteq> (Restr (insert (u, v) lvE) U)\\<^sup>*\n 2. p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p\n 3. p = [] \\<Longrightarrow> v0 \\<in> D\n 4. E `` D \\<subseteq> D\n 5. \\<And>i j.\n       \\<lbrakk>i < j; j < length p\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p ! j \\<times> p ! i =\n                         {}\n 6. \\<Union> (set p) \\<inter> D = {}", "apply (rule rtrancl_mono)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>U. Restr lvE U \\<subseteq> Restr (insert (u, v) lvE) U\n 2. p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p\n 3. p = [] \\<Longrightarrow> v0 \\<in> D\n 4. E `` D \\<subseteq> D\n 5. \\<And>i j.\n       \\<lbrakk>i < j; j < length p\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p ! j \\<times> p ! i =\n                         {}\n 6. \\<Union> (set p) \\<inter> D = {}", "apply blast []"], ["proof (prove)\ngoal (5 subgoals):\n 1. p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p\n 2. p = [] \\<Longrightarrow> v0 \\<in> D\n 3. E `` D \\<subseteq> D\n 4. \\<And>i j.\n       \\<lbrakk>i < j; j < length p\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p ! j \\<times> p ! i =\n                         {}\n 5. \\<Union> (set p) \\<inter> D = {}", "apply (rule root_v0, assumption+) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. p = [] \\<Longrightarrow> v0 \\<in> D\n 2. E `` D \\<subseteq> D\n 3. \\<And>i j.\n       \\<lbrakk>i < j; j < length p\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p ! j \\<times> p ! i =\n                         {}\n 4. \\<Union> (set p) \\<inter> D = {}", "apply (rule p_empty_v0, assumption+) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. E `` D \\<subseteq> D\n 2. \\<And>i j.\n       \\<lbrakk>i < j; j < length p\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p ! j \\<times> p ! i =\n                         {}\n 3. \\<Union> (set p) \\<inter> D = {}", "apply (rule D_closed)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < length p\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p ! j \\<times> p ! i =\n                         {}\n 2. \\<Union> (set p) \\<inter> D = {}", "using vE_no_back VD p_not_D"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < ?j; ?j < length p\\<rbrakk>\n  \\<Longrightarrow> lvE \\<inter> p ! ?j \\<times> p ! ?i = {}\n  v \\<in> D\n  \\<Union> (set p) \\<inter> D = {}\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < length p\\<rbrakk>\n       \\<Longrightarrow> insert (u, v) lvE \\<inter> p ! j \\<times> p ! i =\n                         {}\n 2. \\<Union> (set p) \\<inter> D = {}", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < length p;\n        \\<And>i j.\n           \\<lbrakk>i < j; j < length p\\<rbrakk>\n           \\<Longrightarrow> lvE \\<inter> p ! j \\<times> p ! i = {};\n        v \\<in> D; \\<Union> (set p) \\<inter> D = {}; u \\<in> p ! j;\n        v \\<in> p ! i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<Union> (set p) \\<inter> D = {}", "apply (metis Suc_lessD UnionI VNP less_trans_Suc nth_mem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set p) \\<inter> D = {}", "apply (rule p_not_D)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  invar_loc G v0 D0 p D (pE - {(u, v)})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fin_D_is_reachable: \n    \\<comment> \\<open>When inner loop terminates, all nodes reachable from start node are\n      finished\\<close>\n    assumes INV: \"invar v0 D0 ([], D, pE)\"\n    shows \"D \\<supseteq> E\\<^sup>*``{v0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E\\<^sup>* `` {v0} \\<subseteq> D", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. E\\<^sup>* `` {v0} \\<subseteq> D", "from INV"], ["proof (chain)\npicking this:\n  invar v0 D0 ([], D, pE)", "interpret invar_loc G v0 D0 \"[]\" D pE"], ["proof (prove)\nusing this:\n  invar v0 D0 ([], D, pE)\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 [] D pE", "unfolding invar_def"], ["proof (prove)\nusing this:\n  case ([], D, pE) of (p, xa, xb) \\<Rightarrow> invar_loc G v0 D0 p xa xb\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 [] D pE", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. E\\<^sup>* `` {v0} \\<subseteq> D", "from p_empty_v0 rtrancl_reachable_induct[OF order_refl D_closed] D_reachable"], ["proof (chain)\npicking this:\n  [] = [] \\<Longrightarrow> v0 \\<in> D\n  E\\<^sup>* `` D \\<subseteq> D\n  D \\<subseteq> reachable", "show ?thesis"], ["proof (prove)\nusing this:\n  [] = [] \\<Longrightarrow> v0 \\<in> D\n  E\\<^sup>* `` D \\<subseteq> D\n  D \\<subseteq> reachable\n\ngoal (1 subgoal):\n 1. E\\<^sup>* `` {v0} \\<subseteq> D", "by auto"], ["proof (state)\nthis:\n  E\\<^sup>* `` {v0} \\<subseteq> D\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fin_reachable_path: \n    \\<comment> \\<open>When inner loop terminates, nodes reachable from start node are\n      reachable over visited edges\\<close>\n    assumes INV: \"invar v0 D0 ([], D, pE)\"\n    assumes UR: \"u\\<in>E\\<^sup>*``{v0}\"\n    shows \"path (vE [] D pE) u q v \\<longleftrightarrow> path E u q v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (vE [] D pE) u q v = path E u q v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. path (vE [] D pE) u q v = path E u q v", "from INV"], ["proof (chain)\npicking this:\n  invar v0 D0 ([], D, pE)", "interpret invar_loc G v0 D0 \"[]\" D pE"], ["proof (prove)\nusing this:\n  invar v0 D0 ([], D, pE)\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 [] D pE", "unfolding invar_def"], ["proof (prove)\nusing this:\n  case ([], D, pE) of (p, xa, xb) \\<Rightarrow> invar_loc G v0 D0 p xa xb\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 [] D pE", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. path lvE u q v = path E u q v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. path lvE u q v = path E u q v", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. path lvE u q v \\<Longrightarrow> path E u q v\n 2. path E u q v \\<Longrightarrow> path lvE u q v", "assume \"path lvE u q v\""], ["proof (state)\nthis:\n  path lvE u q v\n\ngoal (2 subgoals):\n 1. path lvE u q v \\<Longrightarrow> path E u q v\n 2. path E u q v \\<Longrightarrow> path lvE u q v", "thus \"path E u q v\""], ["proof (prove)\nusing this:\n  path lvE u q v\n\ngoal (1 subgoal):\n 1. path E u q v", "using path_mono[OF lvE_ss_E]"], ["proof (prove)\nusing this:\n  path lvE u q v\n  path lvE ?u ?p ?v \\<Longrightarrow> path E ?u ?p ?v\n\ngoal (1 subgoal):\n 1. path E u q v", "by blast"], ["proof (state)\nthis:\n  path E u q v\n\ngoal (1 subgoal):\n 1. path E u q v \\<Longrightarrow> path lvE u q v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. path E u q v \\<Longrightarrow> path lvE u q v", "assume \"path E u q v\""], ["proof (state)\nthis:\n  path E u q v\n\ngoal (1 subgoal):\n 1. path E u q v \\<Longrightarrow> path lvE u q v", "thus \"path lvE u q v\""], ["proof (prove)\nusing this:\n  path E u q v\n\ngoal (1 subgoal):\n 1. path lvE u q v", "using UR"], ["proof (prove)\nusing this:\n  path E u q v\n  u \\<in> E\\<^sup>* `` {v0}\n\ngoal (1 subgoal):\n 1. path lvE u q v", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u. u \\<in> E\\<^sup>* `` {v0} \\<Longrightarrow> path lvE u [] u\n 2. \\<And>u v l w.\n       \\<lbrakk>(u, v) \\<in> E; path E v l w;\n        v \\<in> E\\<^sup>* `` {v0} \\<Longrightarrow> path lvE v l w;\n        u \\<in> E\\<^sup>* `` {v0}\\<rbrakk>\n       \\<Longrightarrow> path lvE u (u # l) w", "case (path_prepend u v p w)"], ["proof (state)\nthis:\n  (u, v) \\<in> E\n  path E v p w\n  v \\<in> E\\<^sup>* `` {v0} \\<Longrightarrow> path lvE v p w\n  u \\<in> E\\<^sup>* `` {v0}\n\ngoal (2 subgoals):\n 1. \\<And>u. u \\<in> E\\<^sup>* `` {v0} \\<Longrightarrow> path lvE u [] u\n 2. \\<And>u v l w.\n       \\<lbrakk>(u, v) \\<in> E; path E v l w;\n        v \\<in> E\\<^sup>* `` {v0} \\<Longrightarrow> path lvE v l w;\n        u \\<in> E\\<^sup>* `` {v0}\\<rbrakk>\n       \\<Longrightarrow> path lvE u (u # l) w", "with fin_D_is_reachable[OF INV]"], ["proof (chain)\npicking this:\n  E\\<^sup>* `` {v0} \\<subseteq> D\n  (u, v) \\<in> E\n  path E v p w\n  v \\<in> E\\<^sup>* `` {v0} \\<Longrightarrow> path lvE v p w\n  u \\<in> E\\<^sup>* `` {v0}", "have \"u\\<in>D\""], ["proof (prove)\nusing this:\n  E\\<^sup>* `` {v0} \\<subseteq> D\n  (u, v) \\<in> E\n  path E v p w\n  v \\<in> E\\<^sup>* `` {v0} \\<Longrightarrow> path lvE v p w\n  u \\<in> E\\<^sup>* `` {v0}\n\ngoal (1 subgoal):\n 1. u \\<in> D", "by auto"], ["proof (state)\nthis:\n  u \\<in> D\n\ngoal (2 subgoals):\n 1. \\<And>u. u \\<in> E\\<^sup>* `` {v0} \\<Longrightarrow> path lvE u [] u\n 2. \\<And>u v l w.\n       \\<lbrakk>(u, v) \\<in> E; path E v l w;\n        v \\<in> E\\<^sup>* `` {v0} \\<Longrightarrow> path lvE v l w;\n        u \\<in> E\\<^sup>* `` {v0}\\<rbrakk>\n       \\<Longrightarrow> path lvE u (u # l) w", "with D_closed \\<open>(u,v)\\<in>E\\<close>"], ["proof (chain)\npicking this:\n  E `` D \\<subseteq> D\n  (u, v) \\<in> E\n  u \\<in> D", "have \"v\\<in>D\""], ["proof (prove)\nusing this:\n  E `` D \\<subseteq> D\n  (u, v) \\<in> E\n  u \\<in> D\n\ngoal (1 subgoal):\n 1. v \\<in> D", "by auto"], ["proof (state)\nthis:\n  v \\<in> D\n\ngoal (2 subgoals):\n 1. \\<And>u. u \\<in> E\\<^sup>* `` {v0} \\<Longrightarrow> path lvE u [] u\n 2. \\<And>u v l w.\n       \\<lbrakk>(u, v) \\<in> E; path E v l w;\n        v \\<in> E\\<^sup>* `` {v0} \\<Longrightarrow> path lvE v l w;\n        u \\<in> E\\<^sup>* `` {v0}\\<rbrakk>\n       \\<Longrightarrow> path lvE u (u # l) w", "from path_prepend.prems path_prepend.hyps"], ["proof (chain)\npicking this:\n  u \\<in> E\\<^sup>* `` {v0}\n  (u, v) \\<in> E\n  path E v p w", "have \"v\\<in>E\\<^sup>*``{v0}\""], ["proof (prove)\nusing this:\n  u \\<in> E\\<^sup>* `` {v0}\n  (u, v) \\<in> E\n  path E v p w\n\ngoal (1 subgoal):\n 1. v \\<in> E\\<^sup>* `` {v0}", "by auto"], ["proof (state)\nthis:\n  v \\<in> E\\<^sup>* `` {v0}\n\ngoal (2 subgoals):\n 1. \\<And>u. u \\<in> E\\<^sup>* `` {v0} \\<Longrightarrow> path lvE u [] u\n 2. \\<And>u v l w.\n       \\<lbrakk>(u, v) \\<in> E; path E v l w;\n        v \\<in> E\\<^sup>* `` {v0} \\<Longrightarrow> path lvE v l w;\n        u \\<in> E\\<^sup>* `` {v0}\\<rbrakk>\n       \\<Longrightarrow> path lvE u (u # l) w", "with path_prepend.IH fin_D_is_reachable[OF INV]"], ["proof (chain)\npicking this:\n  v \\<in> E\\<^sup>* `` {v0} \\<Longrightarrow> path lvE v p w\n  E\\<^sup>* `` {v0} \\<subseteq> D\n  v \\<in> E\\<^sup>* `` {v0}", "have \"path lvE v p w\""], ["proof (prove)\nusing this:\n  v \\<in> E\\<^sup>* `` {v0} \\<Longrightarrow> path lvE v p w\n  E\\<^sup>* `` {v0} \\<subseteq> D\n  v \\<in> E\\<^sup>* `` {v0}\n\ngoal (1 subgoal):\n 1. path lvE v p w", "by simp"], ["proof (state)\nthis:\n  path lvE v p w\n\ngoal (2 subgoals):\n 1. \\<And>u. u \\<in> E\\<^sup>* `` {v0} \\<Longrightarrow> path lvE u [] u\n 2. \\<And>u v l w.\n       \\<lbrakk>(u, v) \\<in> E; path E v l w;\n        v \\<in> E\\<^sup>* `` {v0} \\<Longrightarrow> path lvE v l w;\n        u \\<in> E\\<^sup>* `` {v0}\\<rbrakk>\n       \\<Longrightarrow> path lvE u (u # l) w", "moreover"], ["proof (state)\nthis:\n  path lvE v p w\n\ngoal (2 subgoals):\n 1. \\<And>u. u \\<in> E\\<^sup>* `` {v0} \\<Longrightarrow> path lvE u [] u\n 2. \\<And>u v l w.\n       \\<lbrakk>(u, v) \\<in> E; path E v l w;\n        v \\<in> E\\<^sup>* `` {v0} \\<Longrightarrow> path lvE v l w;\n        u \\<in> E\\<^sup>* `` {v0}\\<rbrakk>\n       \\<Longrightarrow> path lvE u (u # l) w", "from \\<open>u\\<in>D\\<close> \\<open>v\\<in>D\\<close> \\<open>(u,v)\\<in>E\\<close> D_vis"], ["proof (chain)\npicking this:\n  u \\<in> D\n  v \\<in> D\n  (u, v) \\<in> E\n  E \\<inter> D \\<times> UNIV \\<subseteq> lvE", "have \"(u,v)\\<in>lvE\""], ["proof (prove)\nusing this:\n  u \\<in> D\n  v \\<in> D\n  (u, v) \\<in> E\n  E \\<inter> D \\<times> UNIV \\<subseteq> lvE\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> lvE", "by auto"], ["proof (state)\nthis:\n  (u, v) \\<in> lvE\n\ngoal (2 subgoals):\n 1. \\<And>u. u \\<in> E\\<^sup>* `` {v0} \\<Longrightarrow> path lvE u [] u\n 2. \\<And>u v l w.\n       \\<lbrakk>(u, v) \\<in> E; path E v l w;\n        v \\<in> E\\<^sup>* `` {v0} \\<Longrightarrow> path lvE v l w;\n        u \\<in> E\\<^sup>* `` {v0}\\<rbrakk>\n       \\<Longrightarrow> path lvE u (u # l) w", "ultimately"], ["proof (chain)\npicking this:\n  path lvE v p w\n  (u, v) \\<in> lvE", "show ?case"], ["proof (prove)\nusing this:\n  path lvE v p w\n  (u, v) \\<in> lvE\n\ngoal (1 subgoal):\n 1. path lvE u (u # p) w", "by (auto simp: path_cons_conv)"], ["proof (state)\nthis:\n  path lvE u (u # p) w\n\ngoal (1 subgoal):\n 1. \\<And>u. u \\<in> E\\<^sup>* `` {v0} \\<Longrightarrow> path lvE u [] u", "qed simp"], ["proof (state)\nthis:\n  path lvE u q v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path lvE u q v = path E u q v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invar_outer_newnode: \n    assumes A: \"v0\\<notin>D0\" \"v0\\<in>it\" \n    assumes OINV: \"outer_invar it D0\"\n    assumes INV: \"invar v0 D0 ([],D',pE)\"\n    shows \"outer_invar (it-{v0}) D'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_invar (it - {v0}) D'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. outer_invar (it - {v0}) D'", "from OINV"], ["proof (chain)\npicking this:\n  outer_invar it D0", "interpret outer_invar_loc G it D0"], ["proof (prove)\nusing this:\n  outer_invar it D0\n\ngoal (1 subgoal):\n 1. outer_invar_loc G it D0", "unfolding outer_invar_def"], ["proof (prove)\nusing this:\n  outer_invar_loc G it D0\n\ngoal (1 subgoal):\n 1. outer_invar_loc G it D0", "."], ["proof (state)\ngoal (1 subgoal):\n 1. outer_invar (it - {v0}) D'", "from INV"], ["proof (chain)\npicking this:\n  invar v0 D0 ([], D', pE)", "interpret inv: invar_loc G v0 D0 \"[]\" D' pE"], ["proof (prove)\nusing this:\n  invar v0 D0 ([], D', pE)\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 [] D' pE", "unfolding invar_def"], ["proof (prove)\nusing this:\n  case ([], D', pE) of (p, xa, xb) \\<Rightarrow> invar_loc G v0 D0 p xa xb\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 [] D' pE", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. outer_invar (it - {v0}) D'", "from fin_D_is_reachable[OF INV]"], ["proof (chain)\npicking this:\n  E\\<^sup>* `` {v0} \\<subseteq> D'", "have [simp]: \"v0\\<in>D'\""], ["proof (prove)\nusing this:\n  E\\<^sup>* `` {v0} \\<subseteq> D'\n\ngoal (1 subgoal):\n 1. v0 \\<in> D'", "by auto"], ["proof (state)\nthis:\n  v0 \\<in> D'\n\ngoal (1 subgoal):\n 1. outer_invar (it - {v0}) D'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_invar (it - {v0}) D'", "unfolding outer_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_invar_loc G (it - {v0}) D'", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. it - {v0} \\<subseteq> V0\n 2. V0 - (it - {v0}) \\<subseteq> D'\n 3. D' \\<subseteq> reachable\n 4. E `` D' \\<subseteq> D'", "using it_initial"], ["proof (prove)\nusing this:\n  it \\<subseteq> V0\n\ngoal (4 subgoals):\n 1. it - {v0} \\<subseteq> V0\n 2. V0 - (it - {v0}) \\<subseteq> D'\n 3. D' \\<subseteq> reachable\n 4. E `` D' \\<subseteq> D'", "apply auto []"], ["proof (prove)\ngoal (3 subgoals):\n 1. V0 - (it - {v0}) \\<subseteq> D'\n 2. D' \\<subseteq> reachable\n 3. E `` D' \\<subseteq> D'", "using it_done inv.D_incr"], ["proof (prove)\nusing this:\n  V0 - it \\<subseteq> D0\n  D0 \\<subseteq> D'\n\ngoal (3 subgoals):\n 1. V0 - (it - {v0}) \\<subseteq> D'\n 2. D' \\<subseteq> reachable\n 3. E `` D' \\<subseteq> D'", "apply auto []"], ["proof (prove)\ngoal (2 subgoals):\n 1. D' \\<subseteq> reachable\n 2. E `` D' \\<subseteq> D'", "using inv.D_reachable"], ["proof (prove)\nusing this:\n  D' \\<subseteq> reachable\n\ngoal (2 subgoals):\n 1. D' \\<subseteq> reachable\n 2. E `` D' \\<subseteq> D'", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. E `` D' \\<subseteq> D'", "using inv.D_closed"], ["proof (prove)\nusing this:\n  E `` D' \\<subseteq> D'\n\ngoal (1 subgoal):\n 1. E `` D' \\<subseteq> D'", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  outer_invar (it - {v0}) D'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invar_outer_Dnode:\n    assumes A: \"v0\\<in>D0\" \"v0\\<in>it\" \n    assumes OINV: \"outer_invar it D0\"\n    shows \"outer_invar (it-{v0}) D0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_invar (it - {v0}) D0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. outer_invar (it - {v0}) D0", "from OINV"], ["proof (chain)\npicking this:\n  outer_invar it D0", "interpret outer_invar_loc G it D0"], ["proof (prove)\nusing this:\n  outer_invar it D0\n\ngoal (1 subgoal):\n 1. outer_invar_loc G it D0", "unfolding outer_invar_def"], ["proof (prove)\nusing this:\n  outer_invar_loc G it D0\n\ngoal (1 subgoal):\n 1. outer_invar_loc G it D0", "."], ["proof (state)\ngoal (1 subgoal):\n 1. outer_invar (it - {v0}) D0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_invar (it - {v0}) D0", "unfolding outer_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_invar_loc G (it - {v0}) D0", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. it - {v0} \\<subseteq> V0\n 2. V0 - (it - {v0}) \\<subseteq> D0\n 3. D0 \\<subseteq> reachable\n 4. E `` D0 \\<subseteq> D0", "using it_initial"], ["proof (prove)\nusing this:\n  it \\<subseteq> V0\n\ngoal (4 subgoals):\n 1. it - {v0} \\<subseteq> V0\n 2. V0 - (it - {v0}) \\<subseteq> D0\n 3. D0 \\<subseteq> reachable\n 4. E `` D0 \\<subseteq> D0", "apply auto []"], ["proof (prove)\ngoal (3 subgoals):\n 1. V0 - (it - {v0}) \\<subseteq> D0\n 2. D0 \\<subseteq> reachable\n 3. E `` D0 \\<subseteq> D0", "using it_done A"], ["proof (prove)\nusing this:\n  V0 - it \\<subseteq> D0\n  v0 \\<in> D0\n  v0 \\<in> it\n\ngoal (3 subgoals):\n 1. V0 - (it - {v0}) \\<subseteq> D0\n 2. D0 \\<subseteq> reachable\n 3. E `` D0 \\<subseteq> D0", "apply auto []"], ["proof (prove)\ngoal (2 subgoals):\n 1. D0 \\<subseteq> reachable\n 2. E `` D0 \\<subseteq> D0", "using D_reachable"], ["proof (prove)\nusing this:\n  D0 \\<subseteq> reachable\n\ngoal (2 subgoals):\n 1. D0 \\<subseteq> reachable\n 2. E `` D0 \\<subseteq> D0", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. E `` D0 \\<subseteq> D0", "using D_closed"], ["proof (prove)\nusing this:\n  E `` D0 \\<subseteq> D0\n\ngoal (1 subgoal):\n 1. E `` D0 \\<subseteq> D0", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  outer_invar (it - {v0}) D0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pE_fin': \"invar x \\<sigma> ([], D, pE) \\<Longrightarrow> pE={}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar x \\<sigma> ([], D, pE) \\<Longrightarrow> pE = {}", "unfolding invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case ([], D, pE) of\n    (p, xb, xc) \\<Rightarrow>\n      invar_loc G x \\<sigma> p xb xc \\<Longrightarrow>\n    pE = {}", "by (simp add: invar_loc.pE_fin)"], ["", "end"], ["", "subsubsection \\<open>Termination\\<close>"], ["", "context invar_loc \nbegin"], ["", "lemma unproc_finite[simp, intro!]: \"finite (unproc_edges v0 p D pE)\"\n    \\<comment> \\<open>The set of unprocessed edges is finite\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (unproc_edges v0 p D pE)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (unproc_edges v0 p D pE)", "have \"unproc_edges v0 p D pE \\<subseteq> E\\<^sup>*``{v0} \\<times> E\\<^sup>*``{v0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unproc_edges v0 p D pE\n    \\<subseteq> E\\<^sup>* `` {v0} \\<times> E\\<^sup>* `` {v0}", "unfolding unproc_edges_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<inter>\n    (E\\<^sup>* `` {v0} - (D \\<union> \\<Union> (set p))) \\<times>\n    UNIV \\<union>\n    pE\n    \\<subseteq> E\\<^sup>* `` {v0} \\<times> E\\<^sup>* `` {v0}", "using pE_reachable"], ["proof (prove)\nusing this:\n  pE \\<subseteq> E\\<^sup>* `` {v0} \\<times> E\\<^sup>* `` {v0}\n\ngoal (1 subgoal):\n 1. E \\<inter>\n    (E\\<^sup>* `` {v0} - (D \\<union> \\<Union> (set p))) \\<times>\n    UNIV \\<union>\n    pE\n    \\<subseteq> E\\<^sup>* `` {v0} \\<times> E\\<^sup>* `` {v0}", "by auto"], ["proof (state)\nthis:\n  unproc_edges v0 p D pE\n  \\<subseteq> E\\<^sup>* `` {v0} \\<times> E\\<^sup>* `` {v0}\n\ngoal (1 subgoal):\n 1. finite (unproc_edges v0 p D pE)", "thus ?thesis"], ["proof (prove)\nusing this:\n  unproc_edges v0 p D pE\n  \\<subseteq> E\\<^sup>* `` {v0} \\<times> E\\<^sup>* `` {v0}\n\ngoal (1 subgoal):\n 1. finite (unproc_edges v0 p D pE)", "by (rule finite_subset) simp"], ["proof (state)\nthis:\n  finite (unproc_edges v0 p D pE)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unproc_decreasing: \n    \\<comment> \\<open>As effect of selecting a pending edge, the set of unprocessed edges\n      decreases\\<close>\n    assumes [simp]: \"p\\<noteq>[]\" and A: \"(u,v)\\<in>pE\" \"u\\<in>last p\"\n    shows \"unproc_edges v0 p D (pE-{(u,v)}) \\<subset> unproc_edges v0 p D pE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unproc_edges v0 p D (pE - {(u, v)}) \\<subset> unproc_edges v0 p D pE", "using A"], ["proof (prove)\nusing this:\n  (u, v) \\<in> pE\n  u \\<in> last p\n\ngoal (1 subgoal):\n 1. unproc_edges v0 p D (pE - {(u, v)}) \\<subset> unproc_edges v0 p D pE", "unfolding unproc_edges_def"], ["proof (prove)\nusing this:\n  (u, v) \\<in> pE\n  u \\<in> last p\n\ngoal (1 subgoal):\n 1. E \\<inter>\n    (E\\<^sup>* `` {v0} - (D \\<union> \\<Union> (set p))) \\<times>\n    UNIV \\<union>\n    (pE - {(u, v)})\n    \\<subset> E \\<inter>\n              (E\\<^sup>* `` {v0} - (D \\<union> \\<Union> (set p))) \\<times>\n              UNIV \\<union>\n              pE", "by fastforce"], ["", "end"], ["", "context fr_graph \nbegin"], ["", "lemma abs_wf_pop:\n    assumes INV: \"invar v0 D0 (p,D,pE)\"\n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes NO: \"pE \\<inter> last aba \\<times> UNIV = {}\"\n    shows \"(pop (p,D,pE), (p, D, pE)) \\<in> abs_wf_rel v0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pop (p, D, pE), p, D, pE) \\<in> abs_wf_rel v0", "unfolding pop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (p, D, pE) = (p, D, pE); (p, V) = (butlast p, last p);\n         D = V \\<union> D\n     in (p, D, pE),\n     p, D, pE)\n    \\<in> abs_wf_rel v0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((butlast p, last p \\<union> D, pE), p, D, pE) \\<in> abs_wf_rel v0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((butlast p, last p \\<union> D, pE), p, D, pE) \\<in> abs_wf_rel v0", "from INV"], ["proof (chain)\npicking this:\n  invar v0 D0 (p, D, pE)", "interpret invar_loc G v0 D0 p D pE"], ["proof (prove)\nusing this:\n  invar v0 D0 (p, D, pE)\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D pE", "unfolding invar_def"], ["proof (prove)\nusing this:\n  case (p, D, pE) of (p, xa, xb) \\<Rightarrow> invar_loc G v0 D0 p xa xb\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D pE", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. ((butlast p, last p \\<union> D, pE), p, D, pE) \\<in> abs_wf_rel v0", "let ?thesis = \"((butlast p, last p \\<union> D, pE), p, D, pE) \\<in> abs_wf_rel v0\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((butlast p, last p \\<union> D, pE), p, D, pE) \\<in> abs_wf_rel v0", "have \"unproc_edges v0 (butlast p) (last p \\<union> D) pE = unproc_edges v0 p D pE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unproc_edges v0 (butlast p) (last p \\<union> D) pE =\n    unproc_edges v0 p D pE", "unfolding unproc_edges_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<inter>\n    (E\\<^sup>* `` {v0} -\n     (last p \\<union> D \\<union> \\<Union> (set (butlast p)))) \\<times>\n    UNIV \\<union>\n    pE =\n    E \\<inter>\n    (E\\<^sup>* `` {v0} - (D \\<union> \\<Union> (set p))) \\<times>\n    UNIV \\<union>\n    pE", "apply (cases p rule: rev_cases, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       p = ys @ [y] \\<Longrightarrow>\n       E \\<inter>\n       (E\\<^sup>* `` {v0} -\n        (last p \\<union> D \\<union> \\<Union> (set (butlast p)))) \\<times>\n       UNIV \\<union>\n       pE =\n       E \\<inter>\n       (E\\<^sup>* `` {v0} - (D \\<union> \\<Union> (set p))) \\<times>\n       UNIV \\<union>\n       pE", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  unproc_edges v0 (butlast p) (last p \\<union> D) pE =\n  unproc_edges v0 p D pE\n\ngoal (1 subgoal):\n 1. ((butlast p, last p \\<union> D, pE), p, D, pE) \\<in> abs_wf_rel v0", "thus ?thesis"], ["proof (prove)\nusing this:\n  unproc_edges v0 (butlast p) (last p \\<union> D) pE =\n  unproc_edges v0 p D pE\n\ngoal (1 subgoal):\n 1. ((butlast p, last p \\<union> D, pE), p, D, pE) \\<in> abs_wf_rel v0", "by (auto simp: abs_wf_rel_def)"], ["proof (state)\nthis:\n  ((butlast p, last p \\<union> D, pE), p, D, pE) \\<in> abs_wf_rel v0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma abs_wf_collapse:\n    assumes INV: \"invar v0 D0 (p,D,pE)\"\n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes E: \"(u,v)\\<in>pE\" \"u\\<in>last p\"\n    shows \"(collapse v (p,D,pE-{(u,v)}), (p, D, pE))\\<in> abs_wf_rel v0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (collapse v (p, D, pE - {(u, v)}), p, D, pE) \\<in> abs_wf_rel v0", "unfolding collapse_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (p, D, pE) = (p, D, pE - {(u, v)}); i = idx_of p v;\n         p = collapse_aux p i\n     in (p, D, pE),\n     p, D, pE)\n    \\<in> abs_wf_rel v0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((collapse_aux p (idx_of p v), D, pE - {(u, v)}), p, D, pE)\n    \\<in> abs_wf_rel v0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((collapse_aux p (idx_of p v), D, pE - {(u, v)}), p, D, pE)\n    \\<in> abs_wf_rel v0", "from INV"], ["proof (chain)\npicking this:\n  invar v0 D0 (p, D, pE)", "interpret invar_loc G v0 D0 p D pE"], ["proof (prove)\nusing this:\n  invar v0 D0 (p, D, pE)\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D pE", "unfolding invar_def"], ["proof (prove)\nusing this:\n  case (p, D, pE) of (p, xa, xb) \\<Rightarrow> invar_loc G v0 D0 p xa xb\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D pE", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. ((collapse_aux p (idx_of p v), D, pE - {(u, v)}), p, D, pE)\n    \\<in> abs_wf_rel v0", "define i where \"i = idx_of p v\""], ["proof (state)\nthis:\n  i = idx_of p v\n\ngoal (1 subgoal):\n 1. ((collapse_aux p (idx_of p v), D, pE - {(u, v)}), p, D, pE)\n    \\<in> abs_wf_rel v0", "let ?thesis \n      = \"((collapse_aux p i, D, pE-{(u,v)}), (p, D, pE)) \\<in> abs_wf_rel v0\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((collapse_aux p (idx_of p v), D, pE - {(u, v)}), p, D, pE)\n    \\<in> abs_wf_rel v0", "have \"unproc_edges v0 (collapse_aux p i) D (pE-{(u,v)}) \n      = unproc_edges v0 p D (pE-{(u,v)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unproc_edges v0 (collapse_aux p i) D (pE - {(u, v)}) =\n    unproc_edges v0 p D (pE - {(u, v)})", "unfolding unproc_edges_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<inter>\n    (E\\<^sup>* `` {v0} -\n     (D \\<union> \\<Union> (set (collapse_aux p i)))) \\<times>\n    UNIV \\<union>\n    (pE - {(u, v)}) =\n    E \\<inter>\n    (E\\<^sup>* `` {v0} - (D \\<union> \\<Union> (set p))) \\<times>\n    UNIV \\<union>\n    (pE - {(u, v)})", "by (auto)"], ["proof (state)\nthis:\n  unproc_edges v0 (collapse_aux p i) D (pE - {(u, v)}) =\n  unproc_edges v0 p D (pE - {(u, v)})\n\ngoal (1 subgoal):\n 1. ((collapse_aux p (idx_of p v), D, pE - {(u, v)}), p, D, pE)\n    \\<in> abs_wf_rel v0", "also"], ["proof (state)\nthis:\n  unproc_edges v0 (collapse_aux p i) D (pE - {(u, v)}) =\n  unproc_edges v0 p D (pE - {(u, v)})\n\ngoal (1 subgoal):\n 1. ((collapse_aux p (idx_of p v), D, pE - {(u, v)}), p, D, pE)\n    \\<in> abs_wf_rel v0", "note unproc_decreasing[OF NE E]"], ["proof (state)\nthis:\n  unproc_edges v0 p D (pE - {(u, v)}) \\<subset> unproc_edges v0 p D pE\n\ngoal (1 subgoal):\n 1. ((collapse_aux p (idx_of p v), D, pE - {(u, v)}), p, D, pE)\n    \\<in> abs_wf_rel v0", "finally"], ["proof (chain)\npicking this:\n  unproc_edges v0 (collapse_aux p i) D (pE - {(u, v)})\n  \\<subset> unproc_edges v0 p D pE", "show ?thesis"], ["proof (prove)\nusing this:\n  unproc_edges v0 (collapse_aux p i) D (pE - {(u, v)})\n  \\<subset> unproc_edges v0 p D pE\n\ngoal (1 subgoal):\n 1. ((collapse_aux p i, D, pE - {(u, v)}), p, D, pE) \\<in> abs_wf_rel v0", "by (auto simp: abs_wf_rel_def)"], ["proof (state)\nthis:\n  ((collapse_aux p i, D, pE - {(u, v)}), p, D, pE) \\<in> abs_wf_rel v0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma abs_wf_push:\n    assumes INV: \"invar v0 D0 (p,D,pE)\"\n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes E: \"(u,v)\\<in>pE\" \"u\\<in>last p\" and A: \"v\\<notin>D\" \"v\\<notin>\\<Union>(set p)\"\n    shows \"(push v (p,D,pE-{(u,v)}), (p, D, pE)) \\<in> abs_wf_rel v0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (push v (p, D, pE - {(u, v)}), p, D, pE) \\<in> abs_wf_rel v0", "unfolding push_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (p, D, pE) = (p, D, pE - {(u, v)}); p = p @ [{v}];\n         pE = pE \\<union> E \\<inter> {v} \\<times> UNIV\n     in (p, D, pE),\n     p, D, pE)\n    \\<in> abs_wf_rel v0", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((p @ [{v}], D, pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV), p,\n     D, pE)\n    \\<in> abs_wf_rel v0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((p @ [{v}], D, pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV), p,\n     D, pE)\n    \\<in> abs_wf_rel v0", "from INV"], ["proof (chain)\npicking this:\n  invar v0 D0 (p, D, pE)", "interpret invar_loc G v0 D0 p D pE"], ["proof (prove)\nusing this:\n  invar v0 D0 (p, D, pE)\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D pE", "unfolding invar_def"], ["proof (prove)\nusing this:\n  case (p, D, pE) of (p, xa, xb) \\<Rightarrow> invar_loc G v0 D0 p xa xb\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D pE", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. ((p @ [{v}], D, pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV), p,\n     D, pE)\n    \\<in> abs_wf_rel v0", "let ?thesis \n      = \"((p@[{v}], D, pE-{(u,v)} \\<union> E\\<inter>{v}\\<times>UNIV), (p, D, pE)) \\<in> abs_wf_rel v0\""], ["proof (state)\ngoal (1 subgoal):\n 1. ((p @ [{v}], D, pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV), p,\n     D, pE)\n    \\<in> abs_wf_rel v0", "have \"unproc_edges v0 (p@[{v}]) D (pE-{(u,v)} \\<union> E\\<inter>{v}\\<times>UNIV) \n      = unproc_edges v0 p D (pE-{(u,v)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unproc_edges v0 (p @ [{v}]) D\n     (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV) =\n    unproc_edges v0 p D (pE - {(u, v)})", "unfolding unproc_edges_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<inter>\n    (E\\<^sup>* `` {v0} - (D \\<union> \\<Union> (set (p @ [{v}])))) \\<times>\n    UNIV \\<union>\n    (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV) =\n    E \\<inter>\n    (E\\<^sup>* `` {v0} - (D \\<union> \\<Union> (set p))) \\<times>\n    UNIV \\<union>\n    (pE - {(u, v)})", "using E A pE_reachable"], ["proof (prove)\nusing this:\n  (u, v) \\<in> pE\n  u \\<in> last p\n  v \\<notin> D\n  v \\<notin> \\<Union> (set p)\n  pE \\<subseteq> E\\<^sup>* `` {v0} \\<times> E\\<^sup>* `` {v0}\n\ngoal (1 subgoal):\n 1. E \\<inter>\n    (E\\<^sup>* `` {v0} - (D \\<union> \\<Union> (set (p @ [{v}])))) \\<times>\n    UNIV \\<union>\n    (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV) =\n    E \\<inter>\n    (E\\<^sup>* `` {v0} - (D \\<union> \\<Union> (set p))) \\<times>\n    UNIV \\<union>\n    (pE - {(u, v)})", "by auto"], ["proof (state)\nthis:\n  unproc_edges v0 (p @ [{v}]) D\n   (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV) =\n  unproc_edges v0 p D (pE - {(u, v)})\n\ngoal (1 subgoal):\n 1. ((p @ [{v}], D, pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV), p,\n     D, pE)\n    \\<in> abs_wf_rel v0", "also"], ["proof (state)\nthis:\n  unproc_edges v0 (p @ [{v}]) D\n   (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV) =\n  unproc_edges v0 p D (pE - {(u, v)})\n\ngoal (1 subgoal):\n 1. ((p @ [{v}], D, pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV), p,\n     D, pE)\n    \\<in> abs_wf_rel v0", "note unproc_decreasing[OF NE E]"], ["proof (state)\nthis:\n  unproc_edges v0 p D (pE - {(u, v)}) \\<subset> unproc_edges v0 p D pE\n\ngoal (1 subgoal):\n 1. ((p @ [{v}], D, pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV), p,\n     D, pE)\n    \\<in> abs_wf_rel v0", "finally"], ["proof (chain)\npicking this:\n  unproc_edges v0 (p @ [{v}]) D\n   (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)\n  \\<subset> unproc_edges v0 p D pE", "show ?thesis"], ["proof (prove)\nusing this:\n  unproc_edges v0 (p @ [{v}]) D\n   (pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV)\n  \\<subset> unproc_edges v0 p D pE\n\ngoal (1 subgoal):\n 1. ((p @ [{v}], D, pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV), p,\n     D, pE)\n    \\<in> abs_wf_rel v0", "by (auto simp: abs_wf_rel_def)"], ["proof (state)\nthis:\n  ((p @ [{v}], D, pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV), p,\n   D, pE)\n  \\<in> abs_wf_rel v0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma abs_wf_skip:\n    assumes INV: \"invar v0 D0 (p,D,pE)\"\n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes E: \"(u,v)\\<in>pE\" \"u\\<in>last p\"\n    shows \"((p, D, pE-{(u,v)}), (p, D, pE)) \\<in> abs_wf_rel v0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((p, D, pE - {(u, v)}), p, D, pE) \\<in> abs_wf_rel v0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((p, D, pE - {(u, v)}), p, D, pE) \\<in> abs_wf_rel v0", "from INV"], ["proof (chain)\npicking this:\n  invar v0 D0 (p, D, pE)", "interpret invar_loc G v0 D0 p D pE"], ["proof (prove)\nusing this:\n  invar v0 D0 (p, D, pE)\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D pE", "unfolding invar_def"], ["proof (prove)\nusing this:\n  case (p, D, pE) of (p, xa, xb) \\<Rightarrow> invar_loc G v0 D0 p xa xb\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D pE", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. ((p, D, pE - {(u, v)}), p, D, pE) \\<in> abs_wf_rel v0", "from unproc_decreasing[OF NE E]"], ["proof (chain)\npicking this:\n  unproc_edges v0 p D (pE - {(u, v)}) \\<subset> unproc_edges v0 p D pE", "show ?thesis"], ["proof (prove)\nusing this:\n  unproc_edges v0 p D (pE - {(u, v)}) \\<subset> unproc_edges v0 p D pE\n\ngoal (1 subgoal):\n 1. ((p, D, pE - {(u, v)}), p, D, pE) \\<in> abs_wf_rel v0", "by (auto simp: abs_wf_rel_def)"], ["proof (state)\nthis:\n  ((p, D, pE - {(u, v)}), p, D, pE) \\<in> abs_wf_rel v0\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Main Correctness Theorem\\<close>"], ["", "context fr_graph \nbegin"], ["", "lemmas invar_preserve = \n    invar_initial\n    invar_pop invar_push invar_skip invar_collapse \n    abs_wf_pop abs_wf_collapse abs_wf_push abs_wf_skip \n    outer_invar_initial invar_outer_newnode invar_outer_Dnode"], ["", "text \\<open>The main correctness theorem for the dummy-algorithm just states that\n    it satisfies the invariant when finished, and the path is empty.\n\\<close>"], ["", "theorem skeleton_spec: \"skeleton \\<le> SPEC (\\<lambda>D. outer_invar {} D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. skeleton \\<le> SPEC (outer_invar {})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. skeleton \\<le> SPEC (outer_invar {})", "note [simp del] = Union_iff"], ["proof (state)\nthis:\n  (?A \\<in> \\<Union> ?C) = (\\<exists>X\\<in>?C. ?A \\<in> X)\n\ngoal (1 subgoal):\n 1. skeleton \\<le> SPEC (outer_invar {})", "note [[goals_limit = 4]]"], ["proof (state)\nthis:\n  TERM _\n\ngoal (1 subgoal):\n 1. skeleton \\<le> SPEC (outer_invar {})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. skeleton \\<le> SPEC (outer_invar {})", "unfolding skeleton_def select_edge_def select_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let D = {}\n     in FOREACH\\<^bsup>outer_invar\\<^esup> V0\n         (\\<lambda>v0 D0.\n             if v0 \\<notin> D0\n             then let s = initial v0 D0\n                  in WHILE\\<^sub>T\\<^bsup>invar v0 D0\\<^esup>\n                      (\\<lambda>(p, D, pE). p \\<noteq> [])\n                      (\\<lambda>(p, D, pE).\n                          (let (p, D, pE) = (p, D, pE)\n                           in SELECT\n                               (\\<lambda>e.\n                                   e \\<in> pE \\<inter>\n     last p \\<times> UNIV) \\<bind>\n                              (\\<lambda>e.\n                                  case e of\n                                  None \\<Rightarrow> RETURN (None, p, D, pE)\n                                  | Some (u, v) \\<Rightarrow>\nRETURN (Some v, p, D, pE - {(u, v)}))) \\<bind>\n                          (\\<lambda>(vo, p, D, pE).\n                              ASSERT (p \\<noteq> []) \\<bind>\n                              (\\<lambda>_.\n                                  case vo of\n                                  None \\<Rightarrow>\n                                    ASSERT\n                                     (pE \\<inter> last p \\<times> UNIV =\n{}) \\<bind>\n                                    (\\<lambda>_. RETURN (pop (p, D, pE)))\n                                  | Some v \\<Rightarrow>\nif v \\<in> \\<Union> (set p) then RETURN (collapse v (p, D, pE))\nelse if v \\<notin> D then RETURN (push v (p, D, pE))\n     else RETURN (p, D, pE))))\n                      s \\<bind>\n                     (\\<lambda>(p, D, pE).\n                         ASSERT (p = [] \\<and> pE = {}) \\<bind>\n                         (\\<lambda>_. RETURN D))\n             else RETURN D0)\n         D \\<bind>\n        RETURN)\n    \\<le> SPEC (outer_invar {})", "apply (refine_vcg WHILEIT_rule[OF abs_wf_rel_wf])"], ["proof (prove)\ngoal (47 subgoals):\n 1. finite V0\n 2. outer_invar V0 {}\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> V0; outer_invar it \\<sigma>;\n        x \\<notin> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> invar x \\<sigma> (initial x \\<sigma>)\n 4. \\<And>x it \\<sigma> s a b aa ba ab bb ac bc xa ad bd ae be af bf.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> V0; outer_invar it \\<sigma>;\n        x \\<notin> \\<sigma>; invar x \\<sigma> s;\n        case s of (p, D, pE) \\<Rightarrow> p \\<noteq> []; s = (a, b);\n        b = (aa, ba); (a, aa, ba) = (ab, bb); bb = (ac, bc);\n        xa \\<in> bc \\<inter> last ab \\<times> UNIV; Some xa = None;\n        (None, ab, ac, bc) = (ad, bd); bd = (ae, be); be = (af, bf)\\<rbrakk>\n       \\<Longrightarrow> ae \\<noteq> []\nA total of 47 subgoals...", "apply (vc_solve solve: invar_preserve simp: pE_fin' finite_V0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> aaa baa aba.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> V0; outer_invar it \\<sigma>;\n        x \\<notin> \\<sigma>; invar x \\<sigma> (aba, aaa, baa);\n        \\<forall>a.\n           (\\<exists>b. (a, b) \\<in> baa) \\<longrightarrow>\n           a \\<notin> last aba;\n        aba \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> baa \\<inter> last aba \\<times> UNIV = {}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  skeleton \\<le> SPEC (outer_invar {})\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Short proof, as presented in the paper\\<close>"], ["", "context \n    notes [refine] = refine_vcg \n  begin"], ["", "theorem \"skeleton \\<le> SPEC (\\<lambda>D. outer_invar {} D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. skeleton \\<le> SPEC (outer_invar {})", "unfolding skeleton_def select_edge_def select_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let D = {}\n     in FOREACH\\<^bsup>outer_invar\\<^esup> V0\n         (\\<lambda>v0 D0.\n             if v0 \\<notin> D0\n             then let s = initial v0 D0\n                  in WHILE\\<^sub>T\\<^bsup>invar v0 D0\\<^esup>\n                      (\\<lambda>(p, D, pE). p \\<noteq> [])\n                      (\\<lambda>(p, D, pE).\n                          (let (p, D, pE) = (p, D, pE)\n                           in SELECT\n                               (\\<lambda>e.\n                                   e \\<in> pE \\<inter>\n     last p \\<times> UNIV) \\<bind>\n                              (\\<lambda>e.\n                                  case e of\n                                  None \\<Rightarrow> RETURN (None, p, D, pE)\n                                  | Some (u, v) \\<Rightarrow>\nRETURN (Some v, p, D, pE - {(u, v)}))) \\<bind>\n                          (\\<lambda>(vo, p, D, pE).\n                              ASSERT (p \\<noteq> []) \\<bind>\n                              (\\<lambda>_.\n                                  case vo of\n                                  None \\<Rightarrow>\n                                    ASSERT\n                                     (pE \\<inter> last p \\<times> UNIV =\n{}) \\<bind>\n                                    (\\<lambda>_. RETURN (pop (p, D, pE)))\n                                  | Some v \\<Rightarrow>\nif v \\<in> \\<Union> (set p) then RETURN (collapse v (p, D, pE))\nelse if v \\<notin> D then RETURN (push v (p, D, pE))\n     else RETURN (p, D, pE))))\n                      s \\<bind>\n                     (\\<lambda>(p, D, pE).\n                         ASSERT (p = [] \\<and> pE = {}) \\<bind>\n                         (\\<lambda>_. RETURN D))\n             else RETURN D0)\n         D \\<bind>\n        RETURN)\n    \\<le> SPEC (outer_invar {})", "by (refine_vcg WHILEIT_rule[OF abs_wf_rel_wf])\n         (auto intro: invar_preserve simp: pE_fin' finite_V0)"], ["", "end"], ["", "end"], ["", "subsection \"Consequences of Invariant when Finished\""], ["", "context fr_graph\nbegin"], ["", "lemma fin_outer_D_is_reachable:\n    \\<comment> \\<open>When outer loop terminates, exactly the reachable nodes are finished\\<close>\n    assumes INV: \"outer_invar {} D\"\n    shows \"D = E\\<^sup>*``V0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D = reachable", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. D = reachable", "from INV"], ["proof (chain)\npicking this:\n  outer_invar {} D", "interpret outer_invar_loc G \"{}\" D"], ["proof (prove)\nusing this:\n  outer_invar {} D\n\ngoal (1 subgoal):\n 1. outer_invar_loc G {} D", "unfolding outer_invar_def"], ["proof (prove)\nusing this:\n  outer_invar_loc G {} D\n\ngoal (1 subgoal):\n 1. outer_invar_loc G {} D", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. D = reachable", "from it_done rtrancl_reachable_induct[OF order_refl D_closed] D_reachable"], ["proof (chain)\npicking this:\n  V0 - {} \\<subseteq> D\n  E\\<^sup>* `` D \\<subseteq> D\n  D \\<subseteq> reachable", "show ?thesis"], ["proof (prove)\nusing this:\n  V0 - {} \\<subseteq> D\n  E\\<^sup>* `` D \\<subseteq> D\n  D \\<subseteq> reachable\n\ngoal (1 subgoal):\n 1. D = reachable", "by auto"], ["proof (state)\nthis:\n  D = reachable\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "section \\<open>Refinement to Gabow's Data Structure\\<close>"], ["", "text_raw\\<open>\\label{sec:algo-ds}\\<close>"], ["", "text \\<open>\n  The implementation due to Gabow \\cite{Gabow2000} represents a path as\n  a stack \\<open>S\\<close> of single nodes, and a stack \\<open>B\\<close> that contains the\n  boundaries of the collapsed segments. Moreover, a map \\<open>I\\<close> maps nodes\n  to their stack indices.\n\n  As we use a tail-recursive formulation, we use another stack \n  \\<open>P :: (nat \\<times> 'v set) list\\<close> to represent the pending edges. The\n  entries in \\<open>P\\<close> are sorted by ascending first component,\n  and \\<open>P\\<close> only contains entries with non-empty second component. \n  An entry \\<open>(i,l)\\<close> means that the edges from the node at \n  \\<open>S[i]\\<close> to the nodes stored in \\<open>l\\<close> are pending.\n\\<close>"], ["", "subsection \\<open>Preliminaries\\<close>"], ["", "primrec find_max_nat :: \"nat \\<Rightarrow> (nat\\<Rightarrow>bool) \\<Rightarrow> nat\" \n  \\<comment> \\<open>Find the maximum number below an upper bound for which a predicate holds\\<close>\n  where\n  \"find_max_nat 0 _ = 0\"\n| \"find_max_nat (Suc n) P = (if (P n) then n else find_max_nat n P)\""], ["", "lemma find_max_nat_correct: \n  \"\\<lbrakk>P 0; 0<u\\<rbrakk> \\<Longrightarrow> find_max_nat u P = Max {i. i<u \\<and> P i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P 0; 0 < u\\<rbrakk>\n    \\<Longrightarrow> find_max_nat u P = Max {i. i < u \\<and> P i}", "apply (induction u)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>P 0; 0 < 0\\<rbrakk>\n    \\<Longrightarrow> find_max_nat 0 P = Max {i. i < 0 \\<and> P i}\n 2. \\<And>u.\n       \\<lbrakk>\\<lbrakk>P 0; 0 < u\\<rbrakk>\n                \\<Longrightarrow> find_max_nat u P =\n                                  Max {i. i < u \\<and> P i};\n        P 0; 0 < Suc u\\<rbrakk>\n       \\<Longrightarrow> find_max_nat (Suc u) P =\n                         Max {i. i < Suc u \\<and> P i}", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>0 < u \\<Longrightarrow>\n                find_max_nat u P = Max {i. i < u \\<and> P i};\n        P 0; P u\\<rbrakk>\n       \\<Longrightarrow> u = Max {i. i < Suc u \\<and> P i}\n 2. \\<And>u.\n       \\<lbrakk>0 < u \\<Longrightarrow>\n                find_max_nat u P = Max {i. i < u \\<and> P i};\n        P 0; \\<not> P u\\<rbrakk>\n       \\<Longrightarrow> find_max_nat u P = Max {i. i < Suc u \\<and> P i}", "apply (rule Max_eqI[THEN sym])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>0 < u \\<Longrightarrow>\n                find_max_nat u P = Max {i. i < u \\<and> P i};\n        P 0; P u\\<rbrakk>\n       \\<Longrightarrow> finite {i. i < Suc u \\<and> P i}\n 2. \\<And>u y.\n       \\<lbrakk>0 < u \\<Longrightarrow>\n                find_max_nat u P = Max {i. i < u \\<and> P i};\n        P 0; P u; y \\<in> {i. i < Suc u \\<and> P i}\\<rbrakk>\n       \\<Longrightarrow> y \\<le> u\n 3. \\<And>u.\n       \\<lbrakk>0 < u \\<Longrightarrow>\n                find_max_nat u P = Max {i. i < u \\<and> P i};\n        P 0; P u\\<rbrakk>\n       \\<Longrightarrow> u \\<in> {i. i < Suc u \\<and> P i}\n 4. \\<And>u.\n       \\<lbrakk>0 < u \\<Longrightarrow>\n                find_max_nat u P = Max {i. i < u \\<and> P i};\n        P 0; \\<not> P u\\<rbrakk>\n       \\<Longrightarrow> find_max_nat u P = Max {i. i < Suc u \\<and> P i}", "apply auto [3]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       \\<lbrakk>0 < u \\<Longrightarrow>\n                find_max_nat u P = Max {i. i < u \\<and> P i};\n        P 0; \\<not> P u\\<rbrakk>\n       \\<Longrightarrow> find_max_nat u P = Max {i. i < Suc u \\<and> P i}", "apply (case_tac u)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u.\n       \\<lbrakk>0 < u \\<Longrightarrow>\n                find_max_nat u P = Max {i. i < u \\<and> P i};\n        P 0; \\<not> P u; u = 0\\<rbrakk>\n       \\<Longrightarrow> find_max_nat u P = Max {i. i < Suc u \\<and> P i}\n 2. \\<And>u nat.\n       \\<lbrakk>0 < u \\<Longrightarrow>\n                find_max_nat u P = Max {i. i < u \\<and> P i};\n        P 0; \\<not> P u; u = Suc nat\\<rbrakk>\n       \\<Longrightarrow> find_max_nat u P = Max {i. i < Suc u \\<and> P i}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u nat.\n       \\<lbrakk>0 < u \\<Longrightarrow>\n                find_max_nat u P = Max {i. i < u \\<and> P i};\n        P 0; \\<not> P u; u = Suc nat\\<rbrakk>\n       \\<Longrightarrow> find_max_nat u P = Max {i. i < Suc u \\<and> P i}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>(if P nat then nat else find_max_nat nat P) =\n                Max {i. i < Suc nat \\<and> P i};\n        P 0; \\<not> P (Suc nat)\\<rbrakk>\n       \\<Longrightarrow> Max {i. i < Suc nat \\<and> P i} =\n                         Max {i. i < Suc (Suc nat) \\<and> P i}", "by (metis less_SucI less_antisym)"], ["", "lemma find_max_nat_param[param]:\n  assumes \"(n,n')\\<in>nat_rel\"\n  assumes \"\\<And>j j'. \\<lbrakk>(j,j')\\<in>nat_rel; j'<n'\\<rbrakk> \\<Longrightarrow> (P j,P' j')\\<in>bool_rel\"\n  shows \"(find_max_nat n P,find_max_nat n' P') \\<in> nat_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (find_max_nat n P, find_max_nat n' P') \\<in> nat_rel", "using assms"], ["proof (prove)\nusing this:\n  (n, n') \\<in> nat_rel\n  \\<lbrakk>(?j, ?j') \\<in> nat_rel; ?j' < n'\\<rbrakk>\n  \\<Longrightarrow> (P ?j, P' ?j') \\<in> bool_rel\n\ngoal (1 subgoal):\n 1. (find_max_nat n P, find_max_nat n' P') \\<in> nat_rel", "by (induction n arbitrary: n') auto"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma find_max_nat_autoref[autoref_rules]:\n    assumes \"(n,n')\\<in>nat_rel\"\n    assumes \"\\<And>j j'. \\<lbrakk>(j,j')\\<in>nat_rel; j'<n'\\<rbrakk> \\<Longrightarrow> (P j,P'$j')\\<in>bool_rel\"\n    shows \"(find_max_nat n P,\n        (OP find_max_nat ::: nat_rel \\<rightarrow> (nat_rel\\<rightarrow>bool_rel) \\<rightarrow> nat_rel) $n'$P'\n      ) \\<in> nat_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (find_max_nat n P,\n     (OP find_max_nat :::\n      nat_rel \\<rightarrow>\n      (nat_rel \\<rightarrow> bool_rel) \\<rightarrow> nat_rel) $\n     n' $\n     P')\n    \\<in> nat_rel", "using find_max_nat_param[OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>j j'.\n              \\<lbrakk>(j, j') \\<in> nat_rel; j' < n'\\<rbrakk>\n              \\<Longrightarrow> (?j2 j, ?j'3 j') \\<in> nat_rel;\n   \\<And>j j'.\n      \\<lbrakk>(j, j') \\<in> nat_rel; j' < n'\\<rbrakk>\n      \\<Longrightarrow> ?j'3 j' < n'\\<rbrakk>\n  \\<Longrightarrow> (find_max_nat n (\\<lambda>j. P (?j2 j)),\n                     find_max_nat n' (\\<lambda>j'. P' $ ?j'3 j'))\n                    \\<in> nat_rel\n\ngoal (1 subgoal):\n 1. (find_max_nat n P,\n     (OP find_max_nat :::\n      nat_rel \\<rightarrow>\n      (nat_rel \\<rightarrow> bool_rel) \\<rightarrow> nat_rel) $\n     n' $\n     P')\n    \\<in> nat_rel", "by simp"], ["", "end"], ["", "subsection \\<open>Gabow's Datastructure\\<close>"], ["", "subsubsection \\<open>Definition and Invariant\\<close>"], ["", "datatype node_state = STACK nat | DONE"], ["", "type_synonym 'v oGS = \"'v \\<rightharpoonup> node_state\""], ["", "definition oGS_\\<alpha> :: \"'v oGS \\<Rightarrow> 'v set\" where \"oGS_\\<alpha> I \\<equiv> {v. I v = Some DONE}\""], ["", "locale oGS_invar = \n  fixes I :: \"'v oGS\"\n  assumes I_no_stack: \"I v \\<noteq> Some (STACK j)\""], ["", "type_synonym 'a GS \n  = \"'a list \\<times> nat list \\<times> ('a \\<rightharpoonup> node_state) \\<times> (nat \\<times> 'a set) list\""], ["", "locale GS =  \n  fixes SBIP :: \"'a GS\"\nbegin"], ["", "definition \"S \\<equiv> (\\<lambda>(S,B,I,P). S) SBIP\""], ["", "definition \"B \\<equiv> (\\<lambda>(S,B,I,P). B) SBIP\""], ["", "definition \"I \\<equiv> (\\<lambda>(S,B,I,P). I) SBIP\""], ["", "definition \"P \\<equiv> (\\<lambda>(S,B,I,P). P) SBIP\""], ["", "definition seg_start :: \"nat \\<Rightarrow> nat\" \\<comment> \\<open>Start index of segment, inclusive\\<close>\n    where \"seg_start i \\<equiv> B!i\""], ["", "definition seg_end :: \"nat \\<Rightarrow> nat\"  \\<comment> \\<open>End index of segment, exclusive\\<close>\n    where \"seg_end i \\<equiv> if i+1 = length B then length S else B!(i+1)\""], ["", "definition seg :: \"nat \\<Rightarrow> 'a set\" \\<comment> \\<open>Collapsed set at index\\<close>\n    where \"seg i \\<equiv> {S!j | j. seg_start i \\<le> j \\<and> j < seg_end i }\""], ["", "definition \"p_\\<alpha> \\<equiv> map seg [0..<length B]\" \\<comment> \\<open>Collapsed path\\<close>"], ["", "definition \"D_\\<alpha> \\<equiv> {v. I v = Some DONE}\" \\<comment> \\<open>Done nodes\\<close>"], ["", "definition \"pE_\\<alpha> \\<equiv> { (u,v) . \\<exists>j I. (j,I)\\<in>set P \\<and> u = S!j \\<and> v\\<in>I }\" \n    \\<comment> \\<open>Pending edges\\<close>"], ["", "definition \"\\<alpha> \\<equiv> (p_\\<alpha>,D_\\<alpha>,pE_\\<alpha>)\" \\<comment> \\<open>Abstract state\\<close>"], ["", "end"], ["", "lemma GS_sel_simps[simp]:\n  \"GS.S (S,B,I,P) = S\"\n  \"GS.B (S,B,I,P) = B\"\n  \"GS.I (S,B,I,P) = I\"\n  \"GS.P (S,B,I,P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GS.S (S, B, I, P) = S &&& GS.B (S, B, I, P) = B) &&&\n    GS.I (S, B, I, P) = I &&& GS.P (S, B, I, P) = P", "unfolding GS.S_def GS.B_def GS.I_def GS.P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((case (S, B, I, P) of (S, B, I, P) \\<Rightarrow> S) = S &&&\n     (case (S, B, I, P) of (S, B, I, P) \\<Rightarrow> B) = B) &&&\n    (case (S, B, I, P) of (S, B, I, P) \\<Rightarrow> I) = I &&&\n    (case (S, B, I, P) of (S, B, I, P) \\<Rightarrow> P) = P", "by auto"], ["", "context GS begin"], ["", "lemma seg_start_indep[simp]: \"GS.seg_start (S',B,I',P') = seg_start\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GS.seg_start (S', B, I', P') = seg_start", "unfolding GS.seg_start_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (!) (GS.B (S', B, I', P')) = (!) B", "by (auto)"], ["", "lemma seg_end_indep[simp]: \"GS.seg_end (S,B,I',P') = seg_end\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GS.seg_end (S, B, I', P') = seg_end", "unfolding GS.seg_end_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        if i + 1 = length (GS.B (S, B, I', P'))\n        then length (GS.S (S, B, I', P'))\n        else GS.B (S, B, I', P') ! (i + 1)) =\n    (\\<lambda>i. if i + 1 = length B then length S else B ! (i + 1))", "by auto"], ["", "lemma seg_indep[simp]: \"GS.seg (S,B,I',P') = seg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GS.seg (S, B, I', P') = seg", "unfolding GS.seg_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i.\n        {GS.S (S, B, I', P') ! j |j.\n         GS.seg_start (S, B, I', P') i \\<le> j \\<and>\n         j < GS.seg_end (S, B, I', P') i}) =\n    (\\<lambda>i. {S ! j |j. seg_start i \\<le> j \\<and> j < seg_end i})", "by auto"], ["", "lemma p_\\<alpha>_indep[simp]: \"GS.p_\\<alpha> (S,B,I',P') = p_\\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GS.p_\\<alpha> (S, B, I', P') = p_\\<alpha>", "unfolding GS.p_\\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (GS.seg (S, B, I', P')) [0..<length (GS.B (S, B, I', P'))] =\n    map seg [0..<length B]", "by auto"], ["", "lemma D_\\<alpha>_indep[simp]: \"GS.D_\\<alpha> (S',B',I,P') = D_\\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GS.D_\\<alpha> (S', B', I, P') = D_\\<alpha>", "unfolding GS.D_\\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {v. GS.I (S', B', I, P') v = Some DONE} = {v. I v = Some DONE}", "by auto"], ["", "lemma pE_\\<alpha>_indep[simp]: \"GS.pE_\\<alpha> (S,B',I',P) = pE_\\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GS.pE_\\<alpha> (S, B', I', P) = pE_\\<alpha>", "unfolding GS.pE_\\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(u, v).\n     \\<exists>j I.\n        (j, I) \\<in> set (GS.P (S, B', I', P)) \\<and>\n        u = GS.S (S, B', I', P) ! j \\<and> v \\<in> I} =\n    {(u, v).\n     \\<exists>j I. (j, I) \\<in> set P \\<and> u = S ! j \\<and> v \\<in> I}", "by auto"], ["", "definition find_seg \\<comment> \\<open>Abs-path index for stack index\\<close>\n    where \"find_seg j \\<equiv> Max {i. i<length B \\<and> B!i\\<le>j}\""], ["", "definition S_idx_of \\<comment> \\<open>Stack index for node\\<close>\n    where \"S_idx_of v \\<equiv> case I v of Some (STACK i) \\<Rightarrow> i\""], ["", "end"], ["", "locale GS_invar = GS +\n  assumes B_in_bound: \"set B \\<subseteq> {0..<length S}\"\n  assumes B_sorted: \"sorted B\"\n  assumes B_distinct: \"distinct B\"\n  assumes B0: \"S\\<noteq>[] \\<Longrightarrow> B\\<noteq>[] \\<and> B!0=0\"\n  assumes S_distinct: \"distinct S\"\n\n  assumes I_consistent: \"(I v = Some (STACK j)) \\<longleftrightarrow> (j<length S \\<and> v = S!j)\"\n  \n  assumes P_sorted: \"sorted (map fst P)\"\n  assumes P_distinct: \"distinct (map fst P)\"\n  assumes P_bound: \"set P \\<subseteq> {0..<length S}\\<times>Collect ((\\<noteq>) {})\"\nbegin"], ["", "lemma locale_this: \"GS_invar SBIP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GS_invar SBIP", "by unfold_locales"], ["", "end"], ["", "definition \"oGS_rel \\<equiv> br oGS_\\<alpha> oGS_invar\""], ["", "lemma oGS_rel_sv[intro!,simp,relator_props]: \"single_valued oGS_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued oGS_rel", "unfolding oGS_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (br oGS_\\<alpha> oGS_invar)", "by auto"], ["", "definition \"GS_rel \\<equiv> br GS.\\<alpha> GS_invar\""], ["", "lemma GS_rel_sv[intro!,simp,relator_props]: \"single_valued GS_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued GS_rel", "unfolding GS_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (br GS.\\<alpha> GS_invar)", "by auto"], ["", "context GS_invar\nbegin"], ["", "lemma empty_eq: \"S=[] \\<longleftrightarrow> B=[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S = []) = (B = [])", "using B_in_bound B0"], ["proof (prove)\nusing this:\n  set B \\<subseteq> {0..<length S}\n  S \\<noteq> [] \\<Longrightarrow> B \\<noteq> [] \\<and> B ! 0 = 0\n\ngoal (1 subgoal):\n 1. (S = []) = (B = [])", "by auto"], ["", "lemma B_in_bound': \"i<length B \\<Longrightarrow> B!i < length S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length B \\<Longrightarrow> B ! i < length S", "using B_in_bound nth_mem"], ["proof (prove)\nusing this:\n  set B \\<subseteq> {0..<length S}\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. i < length B \\<Longrightarrow> B ! i < length S", "by fastforce"], ["", "lemma seg_start_bound:\n    assumes A: \"i<length B\" shows \"seg_start i < length S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seg_start i < length S", "using B_in_bound nth_mem[OF A]"], ["proof (prove)\nusing this:\n  set B \\<subseteq> {0..<length S}\n  B ! i \\<in> set B\n\ngoal (1 subgoal):\n 1. seg_start i < length S", "unfolding seg_start_def"], ["proof (prove)\nusing this:\n  set B \\<subseteq> {0..<length S}\n  B ! i \\<in> set B\n\ngoal (1 subgoal):\n 1. B ! i < length S", "by auto"], ["", "lemma seg_end_bound:\n    assumes A: \"i<length B\" shows \"seg_end i \\<le> length S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seg_end i \\<le> length S", "proof (cases \"i+1=length B\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i + 1 = length B \\<Longrightarrow> seg_end i \\<le> length S\n 2. i + 1 \\<noteq> length B \\<Longrightarrow> seg_end i \\<le> length S", "case True"], ["proof (state)\nthis:\n  i + 1 = length B\n\ngoal (2 subgoals):\n 1. i + 1 = length B \\<Longrightarrow> seg_end i \\<le> length S\n 2. i + 1 \\<noteq> length B \\<Longrightarrow> seg_end i \\<le> length S", "thus ?thesis"], ["proof (prove)\nusing this:\n  i + 1 = length B\n\ngoal (1 subgoal):\n 1. seg_end i \\<le> length S", "by (simp add: seg_end_def)"], ["proof (state)\nthis:\n  seg_end i \\<le> length S\n\ngoal (1 subgoal):\n 1. i + 1 \\<noteq> length B \\<Longrightarrow> seg_end i \\<le> length S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i + 1 \\<noteq> length B \\<Longrightarrow> seg_end i \\<le> length S", "case False"], ["proof (state)\nthis:\n  i + 1 \\<noteq> length B\n\ngoal (1 subgoal):\n 1. i + 1 \\<noteq> length B \\<Longrightarrow> seg_end i \\<le> length S", "with A"], ["proof (chain)\npicking this:\n  i < length B\n  i + 1 \\<noteq> length B", "have \"i+1<length B\""], ["proof (prove)\nusing this:\n  i < length B\n  i + 1 \\<noteq> length B\n\ngoal (1 subgoal):\n 1. i + 1 < length B", "by simp"], ["proof (state)\nthis:\n  i + 1 < length B\n\ngoal (1 subgoal):\n 1. i + 1 \\<noteq> length B \\<Longrightarrow> seg_end i \\<le> length S", "from nth_mem[OF this] B_in_bound"], ["proof (chain)\npicking this:\n  B ! (i + 1) \\<in> set B\n  set B \\<subseteq> {0..<length S}", "have \" B ! (i + 1) < length S\""], ["proof (prove)\nusing this:\n  B ! (i + 1) \\<in> set B\n  set B \\<subseteq> {0..<length S}\n\ngoal (1 subgoal):\n 1. B ! (i + 1) < length S", "by auto"], ["proof (state)\nthis:\n  B ! (i + 1) < length S\n\ngoal (1 subgoal):\n 1. i + 1 \\<noteq> length B \\<Longrightarrow> seg_end i \\<le> length S", "thus ?thesis"], ["proof (prove)\nusing this:\n  B ! (i + 1) < length S\n\ngoal (1 subgoal):\n 1. seg_end i \\<le> length S", "using False"], ["proof (prove)\nusing this:\n  B ! (i + 1) < length S\n  i + 1 \\<noteq> length B\n\ngoal (1 subgoal):\n 1. seg_end i \\<le> length S", "by (simp add: seg_end_def)"], ["proof (state)\nthis:\n  seg_end i \\<le> length S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma seg_start_less_end: \"i<length B \\<Longrightarrow> seg_start i < seg_end i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length B \\<Longrightarrow> seg_start i < seg_end i", "unfolding seg_start_def seg_end_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length B \\<Longrightarrow>\n    B ! i < (if i + 1 = length B then length S else B ! (i + 1))", "using B_in_bound' distinct_sorted_mono[OF B_sorted B_distinct]"], ["proof (prove)\nusing this:\n  ?i < length B \\<Longrightarrow> B ! ?i < length S\n  \\<lbrakk>?i < ?j; ?j < length B\\<rbrakk> \\<Longrightarrow> B ! ?i < B ! ?j\n\ngoal (1 subgoal):\n 1. i < length B \\<Longrightarrow>\n    B ! i < (if i + 1 = length B then length S else B ! (i + 1))", "by auto"], ["", "lemma seg_end_less_start: \"\\<lbrakk>i<j; j<length B\\<rbrakk> \\<Longrightarrow> seg_end i \\<le> seg_start j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < j; j < length B\\<rbrakk>\n    \\<Longrightarrow> seg_end i \\<le> seg_start j", "unfolding seg_start_def seg_end_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < j; j < length B\\<rbrakk>\n    \\<Longrightarrow> (if i + 1 = length B then length S else B ! (i + 1))\n                      \\<le> B ! j", "by (auto simp: distinct_sorted_mono_iff[OF B_distinct B_sorted])"], ["", "lemma find_seg_bounds:\n    assumes A: \"j<length S\"\n    shows \"seg_start (find_seg j) \\<le> j\" \n    and \"j < seg_end (find_seg j)\" \n    and \"find_seg j < length B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seg_start (find_seg j) \\<le> j &&&\n    j < seg_end (find_seg j) &&& find_seg j < length B", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. seg_start (find_seg j) \\<le> j\n 2. j < seg_end (find_seg j)\n 3. find_seg j < length B", "let ?M = \"{i. i<length B \\<and> B!i\\<le>j}\""], ["proof (state)\ngoal (3 subgoals):\n 1. seg_start (find_seg j) \\<le> j\n 2. j < seg_end (find_seg j)\n 3. find_seg j < length B", "from A"], ["proof (chain)\npicking this:\n  j < length S", "have [simp]: \"B\\<noteq>[]\""], ["proof (prove)\nusing this:\n  j < length S\n\ngoal (1 subgoal):\n 1. B \\<noteq> []", "using empty_eq"], ["proof (prove)\nusing this:\n  j < length S\n  (S = []) = (B = [])\n\ngoal (1 subgoal):\n 1. B \\<noteq> []", "by (cases S) auto"], ["proof (state)\nthis:\n  B \\<noteq> []\n\ngoal (3 subgoals):\n 1. seg_start (find_seg j) \\<le> j\n 2. j < seg_end (find_seg j)\n 3. find_seg j < length B", "have NE: \"?M\\<noteq>{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {i. i < length B \\<and> B ! i \\<le> j} \\<noteq> {}", "using A B0"], ["proof (prove)\nusing this:\n  j < length S\n  S \\<noteq> [] \\<Longrightarrow> B \\<noteq> [] \\<and> B ! 0 = 0\n\ngoal (1 subgoal):\n 1. {i. i < length B \\<and> B ! i \\<le> j} \\<noteq> {}", "by (cases B) auto"], ["proof (state)\nthis:\n  {i. i < length B \\<and> B ! i \\<le> j} \\<noteq> {}\n\ngoal (3 subgoals):\n 1. seg_start (find_seg j) \\<le> j\n 2. j < seg_end (find_seg j)\n 3. find_seg j < length B", "have F: \"finite ?M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {i. i < length B \\<and> B ! i \\<le> j}", "by auto"], ["proof (state)\nthis:\n  finite {i. i < length B \\<and> B ! i \\<le> j}\n\ngoal (3 subgoals):\n 1. seg_start (find_seg j) \\<le> j\n 2. j < seg_end (find_seg j)\n 3. find_seg j < length B", "from Max_in[OF F NE]"], ["proof (chain)\npicking this:\n  Max {i. i < length B \\<and> B ! i \\<le> j}\n  \\<in> {i. i < length B \\<and> B ! i \\<le> j}", "have LEN: \"find_seg j < length B\" and LB: \"B!find_seg j \\<le> j\""], ["proof (prove)\nusing this:\n  Max {i. i < length B \\<and> B ! i \\<le> j}\n  \\<in> {i. i < length B \\<and> B ! i \\<le> j}\n\ngoal (1 subgoal):\n 1. find_seg j < length B &&& B ! find_seg j \\<le> j", "unfolding find_seg_def"], ["proof (prove)\nusing this:\n  Max {i. i < length B \\<and> B ! i \\<le> j}\n  \\<in> {i. i < length B \\<and> B ! i \\<le> j}\n\ngoal (1 subgoal):\n 1. Max {i. i < length B \\<and> B ! i \\<le> j} < length B &&&\n    B ! Max {i. i < length B \\<and> B ! i \\<le> j} \\<le> j", "by auto"], ["proof (state)\nthis:\n  find_seg j < length B\n  B ! find_seg j \\<le> j\n\ngoal (3 subgoals):\n 1. seg_start (find_seg j) \\<le> j\n 2. j < seg_end (find_seg j)\n 3. find_seg j < length B", "thus \"find_seg j < length B\""], ["proof (prove)\nusing this:\n  find_seg j < length B\n  B ! find_seg j \\<le> j\n\ngoal (1 subgoal):\n 1. find_seg j < length B", "by -"], ["proof (state)\nthis:\n  find_seg j < length B\n\ngoal (2 subgoals):\n 1. seg_start (find_seg j) \\<le> j\n 2. j < seg_end (find_seg j)", "from LB"], ["proof (chain)\npicking this:\n  B ! find_seg j \\<le> j", "show LB': \"seg_start (find_seg j) \\<le> j\""], ["proof (prove)\nusing this:\n  B ! find_seg j \\<le> j\n\ngoal (1 subgoal):\n 1. seg_start (find_seg j) \\<le> j", "unfolding seg_start_def"], ["proof (prove)\nusing this:\n  B ! find_seg j \\<le> j\n\ngoal (1 subgoal):\n 1. B ! find_seg j \\<le> j", "by simp"], ["proof (state)\nthis:\n  seg_start (find_seg j) \\<le> j\n\ngoal (1 subgoal):\n 1. j < seg_end (find_seg j)", "moreover"], ["proof (state)\nthis:\n  seg_start (find_seg j) \\<le> j\n\ngoal (1 subgoal):\n 1. j < seg_end (find_seg j)", "show UB': \"j < seg_end (find_seg j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < seg_end (find_seg j)", "unfolding seg_end_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < (if find_seg j + 1 = length B then length S\n         else B ! (find_seg j + 1))", "proof (split if_split, intro impI conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. find_seg j + 1 = length B \\<Longrightarrow> j < length S\n 2. find_seg j + 1 \\<noteq> length B \\<Longrightarrow>\n    j < B ! (find_seg j + 1)", "show \"j<length S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length S", "using A"], ["proof (prove)\nusing this:\n  j < length S\n\ngoal (1 subgoal):\n 1. j < length S", "."], ["proof (state)\nthis:\n  j < length S\n\ngoal (1 subgoal):\n 1. find_seg j + 1 \\<noteq> length B \\<Longrightarrow>\n    j < B ! (find_seg j + 1)", "assume \"find_seg j + 1 \\<noteq> length B\""], ["proof (state)\nthis:\n  find_seg j + 1 \\<noteq> length B\n\ngoal (1 subgoal):\n 1. find_seg j + 1 \\<noteq> length B \\<Longrightarrow>\n    j < B ! (find_seg j + 1)", "with LEN"], ["proof (chain)\npicking this:\n  find_seg j < length B\n  find_seg j + 1 \\<noteq> length B", "have P1: \"find_seg j + 1 < length B\""], ["proof (prove)\nusing this:\n  find_seg j < length B\n  find_seg j + 1 \\<noteq> length B\n\ngoal (1 subgoal):\n 1. find_seg j + 1 < length B", "by simp"], ["proof (state)\nthis:\n  find_seg j + 1 < length B\n\ngoal (1 subgoal):\n 1. find_seg j + 1 \\<noteq> length B \\<Longrightarrow>\n    j < B ! (find_seg j + 1)", "show \"j < B ! (find_seg j + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < B ! (find_seg j + 1)", "proof (rule ccontr, simp only: linorder_not_less)"], ["proof (state)\ngoal (1 subgoal):\n 1. B ! (find_seg j + 1) \\<le> j \\<Longrightarrow> False", "assume P2: \"B ! (find_seg j + 1) \\<le> j\""], ["proof (state)\nthis:\n  B ! (find_seg j + 1) \\<le> j\n\ngoal (1 subgoal):\n 1. B ! (find_seg j + 1) \\<le> j \\<Longrightarrow> False", "with P1 Max_ge[OF F, of \"find_seg j + 1\", folded find_seg_def]"], ["proof (chain)\npicking this:\n  find_seg j + 1 < length B\n  find_seg j + 1\n  \\<in> {i. i < length B \\<and> B ! i \\<le> j} \\<Longrightarrow>\n  find_seg j + 1 \\<le> find_seg j\n  B ! (find_seg j + 1) \\<le> j", "show False"], ["proof (prove)\nusing this:\n  find_seg j + 1 < length B\n  find_seg j + 1\n  \\<in> {i. i < length B \\<and> B ! i \\<le> j} \\<Longrightarrow>\n  find_seg j + 1 \\<le> find_seg j\n  B ! (find_seg j + 1) \\<le> j\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j < B ! (find_seg j + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j < seg_end (find_seg j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_seg_correct:\n    assumes A: \"j<length S\"\n    shows \"S!j \\<in> seg (find_seg j)\" and \"find_seg j < length B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S ! j \\<in> seg (find_seg j) &&& find_seg j < length B", "using find_seg_bounds[OF A]"], ["proof (prove)\nusing this:\n  seg_start (find_seg j) \\<le> j\n  j < seg_end (find_seg j)\n  find_seg j < length B\n\ngoal (1 subgoal):\n 1. S ! j \\<in> seg (find_seg j) &&& find_seg j < length B", "unfolding seg_def"], ["proof (prove)\nusing this:\n  seg_start (find_seg j) \\<le> j\n  j < seg_end (find_seg j)\n  find_seg j < length B\n\ngoal (1 subgoal):\n 1. S ! j\n    \\<in> {S ! ja |ja.\n           seg_start (find_seg j) \\<le> ja \\<and>\n           ja < seg_end (find_seg j)} &&&\n    find_seg j < length B", "by auto"], ["", "lemma set_p_\\<alpha>_is_set_S:\n    \"\\<Union>(set p_\\<alpha>) = set S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set p_\\<alpha>) = set S", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Union> (set p_\\<alpha>) \\<subseteq> set S\n 2. set S \\<subseteq> \\<Union> (set p_\\<alpha>)", "unfolding p_\\<alpha>_def seg_def[abs_def]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Union>\n     (set (map (\\<lambda>i.\n                   {S ! j |j. seg_start i \\<le> j \\<and> j < seg_end i})\n            [0..<length B]))\n    \\<subseteq> set S\n 2. set S\n    \\<subseteq> \\<Union>\n                 (set (map (\\<lambda>i.\n                               {S ! j |j.\n                                seg_start i \\<le> j \\<and> j < seg_end i})\n                        [0..<length B]))", "using seg_end_bound"], ["proof (prove)\nusing this:\n  ?i < length B \\<Longrightarrow> seg_end ?i \\<le> length S\n\ngoal (2 subgoals):\n 1. \\<Union>\n     (set (map (\\<lambda>i.\n                   {S ! j |j. seg_start i \\<le> j \\<and> j < seg_end i})\n            [0..<length B]))\n    \\<subseteq> set S\n 2. set S\n    \\<subseteq> \\<Union>\n                 (set (map (\\<lambda>i.\n                               {S ! j |j.\n                                seg_start i \\<le> j \\<and> j < seg_end i})\n                        [0..<length B]))", "apply fastforce []"], ["proof (prove)\ngoal (1 subgoal):\n 1. set S\n    \\<subseteq> \\<Union>\n                 (set (map (\\<lambda>i.\n                               {S ! j |j.\n                                seg_start i \\<le> j \\<and> j < seg_end i})\n                        [0..<length B]))", "apply (auto simp: in_set_conv_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length S \\<Longrightarrow>\n       \\<exists>x\\<in>{0..<length B}.\n          \\<exists>j.\n             S ! i = S ! j \\<and> seg_start x \\<le> j \\<and> j < seg_end x", "using find_seg_bounds"], ["proof (prove)\nusing this:\n  ?j < length S \\<Longrightarrow> seg_start (find_seg ?j) \\<le> ?j\n  ?j < length S \\<Longrightarrow> ?j < seg_end (find_seg ?j)\n  ?j < length S \\<Longrightarrow> find_seg ?j < length B\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length S \\<Longrightarrow>\n       \\<exists>x\\<in>{0..<length B}.\n          \\<exists>j.\n             S ! i = S ! j \\<and> seg_start x \\<le> j \\<and> j < seg_end x", "apply (fastforce simp: in_set_conv_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma S_idx_uniq: \n    \"\\<lbrakk>i<length S; j<length S\\<rbrakk> \\<Longrightarrow> S!i=S!j \\<longleftrightarrow> i=j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length S; j < length S\\<rbrakk>\n    \\<Longrightarrow> (S ! i = S ! j) = (i = j)", "using S_distinct"], ["proof (prove)\nusing this:\n  distinct S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length S; j < length S\\<rbrakk>\n    \\<Longrightarrow> (S ! i = S ! j) = (i = j)", "by (simp add: nth_eq_iff_index_eq)"], ["", "lemma S_idx_of_correct: \n    assumes A: \"v\\<in>\\<Union>(set p_\\<alpha>)\"\n    shows \"S_idx_of v < length S\" and \"S!S_idx_of v = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S_idx_of v < length S &&& S ! S_idx_of v = v", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. S_idx_of v < length S\n 2. S ! S_idx_of v = v", "from A"], ["proof (chain)\npicking this:\n  v \\<in> \\<Union> (set p_\\<alpha>)", "have \"v\\<in>set S\""], ["proof (prove)\nusing this:\n  v \\<in> \\<Union> (set p_\\<alpha>)\n\ngoal (1 subgoal):\n 1. v \\<in> set S", "by (simp add: set_p_\\<alpha>_is_set_S)"], ["proof (state)\nthis:\n  v \\<in> set S\n\ngoal (2 subgoals):\n 1. S_idx_of v < length S\n 2. S ! S_idx_of v = v", "then"], ["proof (chain)\npicking this:\n  v \\<in> set S", "obtain j where G1: \"j<length S\" \"v=S!j\""], ["proof (prove)\nusing this:\n  v \\<in> set S\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j < length S; v = S ! j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_nth)"], ["proof (state)\nthis:\n  j < length S\n  v = S ! j\n\ngoal (2 subgoals):\n 1. S_idx_of v < length S\n 2. S ! S_idx_of v = v", "with I_consistent"], ["proof (chain)\npicking this:\n  (I ?v = Some (STACK ?j)) = (?j < length S \\<and> ?v = S ! ?j)\n  j < length S\n  v = S ! j", "have \"I v = Some (STACK j)\""], ["proof (prove)\nusing this:\n  (I ?v = Some (STACK ?j)) = (?j < length S \\<and> ?v = S ! ?j)\n  j < length S\n  v = S ! j\n\ngoal (1 subgoal):\n 1. I v = Some (STACK j)", "by simp"], ["proof (state)\nthis:\n  I v = Some (STACK j)\n\ngoal (2 subgoals):\n 1. S_idx_of v < length S\n 2. S ! S_idx_of v = v", "hence \"S_idx_of v = j\""], ["proof (prove)\nusing this:\n  I v = Some (STACK j)\n\ngoal (1 subgoal):\n 1. S_idx_of v = j", "by (simp add: S_idx_of_def)"], ["proof (state)\nthis:\n  S_idx_of v = j\n\ngoal (2 subgoals):\n 1. S_idx_of v < length S\n 2. S ! S_idx_of v = v", "with G1"], ["proof (chain)\npicking this:\n  j < length S\n  v = S ! j\n  S_idx_of v = j", "show \"S_idx_of v < length S\" and \"S!S_idx_of v = v\""], ["proof (prove)\nusing this:\n  j < length S\n  v = S ! j\n  S_idx_of v = j\n\ngoal (1 subgoal):\n 1. S_idx_of v < length S &&& S ! S_idx_of v = v", "by simp_all"], ["proof (state)\nthis:\n  S_idx_of v < length S\n  S ! S_idx_of v = v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma p_\\<alpha>_disjoint_sym: \n    shows \"\\<forall>i j v. i<length p_\\<alpha> \\<and> j<length p_\\<alpha> \\<and> v\\<in>p_\\<alpha>!i \\<and> v\\<in>p_\\<alpha>!j \\<longrightarrow> i=j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j v.\n       i < length p_\\<alpha> \\<and>\n       j < length p_\\<alpha> \\<and>\n       v \\<in> p_\\<alpha> ! i \\<and>\n       v \\<in> p_\\<alpha> ! j \\<longrightarrow>\n       i = j", "proof (intro allI impI, elim conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j v.\n       \\<lbrakk>i < length p_\\<alpha>; j < length p_\\<alpha>;\n        v \\<in> p_\\<alpha> ! i; v \\<in> p_\\<alpha> ! j\\<rbrakk>\n       \\<Longrightarrow> i = j", "fix i j v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j v.\n       \\<lbrakk>i < length p_\\<alpha>; j < length p_\\<alpha>;\n        v \\<in> p_\\<alpha> ! i; v \\<in> p_\\<alpha> ! j\\<rbrakk>\n       \\<Longrightarrow> i = j", "assume A: \"i < length p_\\<alpha>\" \"j < length p_\\<alpha>\" \"v \\<in> p_\\<alpha> ! i\" \"v \\<in> p_\\<alpha> ! j\""], ["proof (state)\nthis:\n  i < length p_\\<alpha>\n  j < length p_\\<alpha>\n  v \\<in> p_\\<alpha> ! i\n  v \\<in> p_\\<alpha> ! j\n\ngoal (1 subgoal):\n 1. \\<And>i j v.\n       \\<lbrakk>i < length p_\\<alpha>; j < length p_\\<alpha>;\n        v \\<in> p_\\<alpha> ! i; v \\<in> p_\\<alpha> ! j\\<rbrakk>\n       \\<Longrightarrow> i = j", "from A"], ["proof (chain)\npicking this:\n  i < length p_\\<alpha>\n  j < length p_\\<alpha>\n  v \\<in> p_\\<alpha> ! i\n  v \\<in> p_\\<alpha> ! j", "have LI: \"i<length B\" and LJ: \"j<length B\""], ["proof (prove)\nusing this:\n  i < length p_\\<alpha>\n  j < length p_\\<alpha>\n  v \\<in> p_\\<alpha> ! i\n  v \\<in> p_\\<alpha> ! j\n\ngoal (1 subgoal):\n 1. i < length B &&& j < length B", "by (simp_all add: p_\\<alpha>_def)"], ["proof (state)\nthis:\n  i < length B\n  j < length B\n\ngoal (1 subgoal):\n 1. \\<And>i j v.\n       \\<lbrakk>i < length p_\\<alpha>; j < length p_\\<alpha>;\n        v \\<in> p_\\<alpha> ! i; v \\<in> p_\\<alpha> ! j\\<rbrakk>\n       \\<Longrightarrow> i = j", "from A"], ["proof (chain)\npicking this:\n  i < length p_\\<alpha>\n  j < length p_\\<alpha>\n  v \\<in> p_\\<alpha> ! i\n  v \\<in> p_\\<alpha> ! j", "have B1: \"seg_start j < seg_end i\" and B2: \"seg_start i < seg_end j\""], ["proof (prove)\nusing this:\n  i < length p_\\<alpha>\n  j < length p_\\<alpha>\n  v \\<in> p_\\<alpha> ! i\n  v \\<in> p_\\<alpha> ! j\n\ngoal (1 subgoal):\n 1. seg_start j < seg_end i &&& seg_start i < seg_end j", "unfolding p_\\<alpha>_def seg_def[abs_def]"], ["proof (prove)\nusing this:\n  i < length\n       (map (\\<lambda>i.\n                {S ! j |j. seg_start i \\<le> j \\<and> j < seg_end i})\n         [0..<length B])\n  j < length\n       (map (\\<lambda>i.\n                {S ! j |j. seg_start i \\<le> j \\<and> j < seg_end i})\n         [0..<length B])\n  v \\<in> map (\\<lambda>i.\n                  {S ! j |j. seg_start i \\<le> j \\<and> j < seg_end i})\n           [0..<length B] !\n          i\n  v \\<in> map (\\<lambda>i.\n                  {S ! j |j. seg_start i \\<le> j \\<and> j < seg_end i})\n           [0..<length B] !\n          j\n\ngoal (1 subgoal):\n 1. seg_start j < seg_end i &&& seg_start i < seg_end j", "apply clarsimp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ja jaa.\n       \\<lbrakk>i < length B; j < length B; v = S ! jaa; S ! ja = S ! jaa;\n        seg_start i \\<le> ja; ja < seg_end i; seg_start j \\<le> jaa;\n        jaa < seg_end j\\<rbrakk>\n       \\<Longrightarrow> seg_start j < seg_end i\n 2. \\<And>ja jaa.\n       \\<lbrakk>i < length B; j < length B; v = S ! jaa; S ! ja = S ! jaa;\n        seg_start i \\<le> ja; ja < seg_end i; seg_start j \\<le> jaa;\n        jaa < seg_end j\\<rbrakk>\n       \\<Longrightarrow> seg_start i < seg_end j", "apply (subst (asm) S_idx_uniq)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ja jaa.\n       \\<lbrakk>seg_start i \\<le> ja; ja < seg_end i; seg_start j \\<le> jaa;\n        jaa < seg_end j; i < length B; j < length B; v = S ! jaa\\<rbrakk>\n       \\<Longrightarrow> ja < length S\n 2. \\<And>ja jaa.\n       \\<lbrakk>seg_start i \\<le> ja; ja < seg_end i; seg_start j \\<le> jaa;\n        jaa < seg_end j; i < length B; j < length B; v = S ! jaa\\<rbrakk>\n       \\<Longrightarrow> jaa < length S\n 3. \\<And>ja jaa.\n       \\<lbrakk>i < length B; j < length B; v = S ! jaa; ja = jaa;\n        seg_start i \\<le> ja; ja < seg_end i; seg_start j \\<le> jaa;\n        jaa < seg_end j\\<rbrakk>\n       \\<Longrightarrow> seg_start j < seg_end i\n 4. \\<And>ja jaa.\n       \\<lbrakk>i < length B; j < length B; v = S ! jaa; S ! ja = S ! jaa;\n        seg_start i \\<le> ja; ja < seg_end i; seg_start j \\<le> jaa;\n        jaa < seg_end j\\<rbrakk>\n       \\<Longrightarrow> seg_start i < seg_end j", "apply (metis dual_order.strict_trans1 seg_end_bound)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ja jaa.\n       \\<lbrakk>seg_start i \\<le> ja; ja < seg_end i; seg_start j \\<le> jaa;\n        jaa < seg_end j; i < length B; j < length B; v = S ! jaa\\<rbrakk>\n       \\<Longrightarrow> jaa < length S\n 2. \\<And>ja jaa.\n       \\<lbrakk>i < length B; j < length B; v = S ! jaa; ja = jaa;\n        seg_start i \\<le> ja; ja < seg_end i; seg_start j \\<le> jaa;\n        jaa < seg_end j\\<rbrakk>\n       \\<Longrightarrow> seg_start j < seg_end i\n 3. \\<And>ja jaa.\n       \\<lbrakk>i < length B; j < length B; v = S ! jaa; S ! ja = S ! jaa;\n        seg_start i \\<le> ja; ja < seg_end i; seg_start j \\<le> jaa;\n        jaa < seg_end j\\<rbrakk>\n       \\<Longrightarrow> seg_start i < seg_end j", "apply (metis dual_order.strict_trans1 seg_end_bound)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ja jaa.\n       \\<lbrakk>i < length B; j < length B; v = S ! jaa; ja = jaa;\n        seg_start i \\<le> ja; ja < seg_end i; seg_start j \\<le> jaa;\n        jaa < seg_end j\\<rbrakk>\n       \\<Longrightarrow> seg_start j < seg_end i\n 2. \\<And>ja jaa.\n       \\<lbrakk>i < length B; j < length B; v = S ! jaa; S ! ja = S ! jaa;\n        seg_start i \\<le> ja; ja < seg_end i; seg_start j \\<le> jaa;\n        jaa < seg_end j\\<rbrakk>\n       \\<Longrightarrow> seg_start i < seg_end j", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ja jaa.\n       \\<lbrakk>i < length B; j < length B; v = S ! jaa; S ! ja = S ! jaa;\n        seg_start i \\<le> ja; ja < seg_end i; seg_start j \\<le> jaa;\n        jaa < seg_end j\\<rbrakk>\n       \\<Longrightarrow> seg_start i < seg_end j", "apply (subst (asm) S_idx_uniq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ja jaa.\n       \\<lbrakk>seg_start i \\<le> ja; ja < seg_end i; seg_start j \\<le> jaa;\n        jaa < seg_end j; i < length B; j < length B; v = S ! jaa\\<rbrakk>\n       \\<Longrightarrow> ja < length S\n 2. \\<And>ja jaa.\n       \\<lbrakk>seg_start i \\<le> ja; ja < seg_end i; seg_start j \\<le> jaa;\n        jaa < seg_end j; i < length B; j < length B; v = S ! jaa\\<rbrakk>\n       \\<Longrightarrow> jaa < length S\n 3. \\<And>ja jaa.\n       \\<lbrakk>i < length B; j < length B; v = S ! jaa; ja = jaa;\n        seg_start i \\<le> ja; ja < seg_end i; seg_start j \\<le> jaa;\n        jaa < seg_end j\\<rbrakk>\n       \\<Longrightarrow> seg_start i < seg_end j", "apply (metis dual_order.strict_trans1 seg_end_bound)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ja jaa.\n       \\<lbrakk>seg_start i \\<le> ja; ja < seg_end i; seg_start j \\<le> jaa;\n        jaa < seg_end j; i < length B; j < length B; v = S ! jaa\\<rbrakk>\n       \\<Longrightarrow> jaa < length S\n 2. \\<And>ja jaa.\n       \\<lbrakk>i < length B; j < length B; v = S ! jaa; ja = jaa;\n        seg_start i \\<le> ja; ja < seg_end i; seg_start j \\<le> jaa;\n        jaa < seg_end j\\<rbrakk>\n       \\<Longrightarrow> seg_start i < seg_end j", "apply (metis dual_order.strict_trans1 seg_end_bound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ja jaa.\n       \\<lbrakk>i < length B; j < length B; v = S ! jaa; ja = jaa;\n        seg_start i \\<le> ja; ja < seg_end i; seg_start j \\<le> jaa;\n        jaa < seg_end j\\<rbrakk>\n       \\<Longrightarrow> seg_start i < seg_end j", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  seg_start j < seg_end i\n  seg_start i < seg_end j\n\ngoal (1 subgoal):\n 1. \\<And>i j v.\n       \\<lbrakk>i < length p_\\<alpha>; j < length p_\\<alpha>;\n        v \\<in> p_\\<alpha> ! i; v \\<in> p_\\<alpha> ! j\\<rbrakk>\n       \\<Longrightarrow> i = j", "from B1"], ["proof (chain)\npicking this:\n  seg_start j < seg_end i", "have B1: \"(B!j < B!Suc i \\<and> Suc i < length B) \\<or> i=length B - 1\""], ["proof (prove)\nusing this:\n  seg_start j < seg_end i\n\ngoal (1 subgoal):\n 1. B ! j < B ! Suc i \\<and> Suc i < length B \\<or> i = length B - 1", "using LI"], ["proof (prove)\nusing this:\n  seg_start j < seg_end i\n  i < length B\n\ngoal (1 subgoal):\n 1. B ! j < B ! Suc i \\<and> Suc i < length B \\<or> i = length B - 1", "unfolding seg_start_def seg_end_def"], ["proof (prove)\nusing this:\n  B ! j < (if i + 1 = length B then length S else B ! (i + 1))\n  i < length B\n\ngoal (1 subgoal):\n 1. B ! j < B ! Suc i \\<and> Suc i < length B \\<or> i = length B - 1", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  B ! j < B ! Suc i \\<and> Suc i < length B \\<or> i = length B - 1\n\ngoal (1 subgoal):\n 1. \\<And>i j v.\n       \\<lbrakk>i < length p_\\<alpha>; j < length p_\\<alpha>;\n        v \\<in> p_\\<alpha> ! i; v \\<in> p_\\<alpha> ! j\\<rbrakk>\n       \\<Longrightarrow> i = j", "from B2"], ["proof (chain)\npicking this:\n  seg_start i < seg_end j", "have B2: \"(B!i < B!Suc j \\<and> Suc j < length B) \\<or> j=length B - 1\""], ["proof (prove)\nusing this:\n  seg_start i < seg_end j\n\ngoal (1 subgoal):\n 1. B ! i < B ! Suc j \\<and> Suc j < length B \\<or> j = length B - 1", "using LJ"], ["proof (prove)\nusing this:\n  seg_start i < seg_end j\n  j < length B\n\ngoal (1 subgoal):\n 1. B ! i < B ! Suc j \\<and> Suc j < length B \\<or> j = length B - 1", "unfolding seg_start_def seg_end_def"], ["proof (prove)\nusing this:\n  B ! i < (if j + 1 = length B then length S else B ! (j + 1))\n  j < length B\n\ngoal (1 subgoal):\n 1. B ! i < B ! Suc j \\<and> Suc j < length B \\<or> j = length B - 1", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  B ! i < B ! Suc j \\<and> Suc j < length B \\<or> j = length B - 1\n\ngoal (1 subgoal):\n 1. \\<And>i j v.\n       \\<lbrakk>i < length p_\\<alpha>; j < length p_\\<alpha>;\n        v \\<in> p_\\<alpha> ! i; v \\<in> p_\\<alpha> ! j\\<rbrakk>\n       \\<Longrightarrow> i = j", "from B1"], ["proof (chain)\npicking this:\n  B ! j < B ! Suc i \\<and> Suc i < length B \\<or> i = length B - 1", "have B1: \"j<Suc i \\<or> i=length B - 1\""], ["proof (prove)\nusing this:\n  B ! j < B ! Suc i \\<and> Suc i < length B \\<or> i = length B - 1\n\ngoal (1 subgoal):\n 1. j < Suc i \\<or> i = length B - 1", "using LI LJ distinct_sorted_strict_mono_iff[OF B_distinct B_sorted]"], ["proof (prove)\nusing this:\n  B ! j < B ! Suc i \\<and> Suc i < length B \\<or> i = length B - 1\n  i < length B\n  j < length B\n  \\<lbrakk>?i < length B; ?j < length B\\<rbrakk>\n  \\<Longrightarrow> (B ! ?i < B ! ?j) = (?i < ?j)\n\ngoal (1 subgoal):\n 1. j < Suc i \\<or> i = length B - 1", "by auto"], ["proof (state)\nthis:\n  j < Suc i \\<or> i = length B - 1\n\ngoal (1 subgoal):\n 1. \\<And>i j v.\n       \\<lbrakk>i < length p_\\<alpha>; j < length p_\\<alpha>;\n        v \\<in> p_\\<alpha> ! i; v \\<in> p_\\<alpha> ! j\\<rbrakk>\n       \\<Longrightarrow> i = j", "from B2"], ["proof (chain)\npicking this:\n  B ! i < B ! Suc j \\<and> Suc j < length B \\<or> j = length B - 1", "have B2: \"i<Suc j \\<or> j=length B - 1\""], ["proof (prove)\nusing this:\n  B ! i < B ! Suc j \\<and> Suc j < length B \\<or> j = length B - 1\n\ngoal (1 subgoal):\n 1. i < Suc j \\<or> j = length B - 1", "using LI LJ distinct_sorted_strict_mono_iff[OF B_distinct B_sorted]"], ["proof (prove)\nusing this:\n  B ! i < B ! Suc j \\<and> Suc j < length B \\<or> j = length B - 1\n  i < length B\n  j < length B\n  \\<lbrakk>?i < length B; ?j < length B\\<rbrakk>\n  \\<Longrightarrow> (B ! ?i < B ! ?j) = (?i < ?j)\n\ngoal (1 subgoal):\n 1. i < Suc j \\<or> j = length B - 1", "by auto"], ["proof (state)\nthis:\n  i < Suc j \\<or> j = length B - 1\n\ngoal (1 subgoal):\n 1. \\<And>i j v.\n       \\<lbrakk>i < length p_\\<alpha>; j < length p_\\<alpha>;\n        v \\<in> p_\\<alpha> ! i; v \\<in> p_\\<alpha> ! j\\<rbrakk>\n       \\<Longrightarrow> i = j", "from B1 B2"], ["proof (chain)\npicking this:\n  j < Suc i \\<or> i = length B - 1\n  i < Suc j \\<or> j = length B - 1", "show \"i=j\""], ["proof (prove)\nusing this:\n  j < Suc i \\<or> i = length B - 1\n  i < Suc j \\<or> j = length B - 1\n\ngoal (1 subgoal):\n 1. i = j", "using LI LJ"], ["proof (prove)\nusing this:\n  j < Suc i \\<or> i = length B - 1\n  i < Suc j \\<or> j = length B - 1\n  i < length B\n  j < length B\n\ngoal (1 subgoal):\n 1. i = j", "by auto"], ["proof (state)\nthis:\n  i = j\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Refinement of the Operations\\<close>"], ["", "definition GS_initial_impl :: \"'a oGS \\<Rightarrow> 'a \\<Rightarrow> 'a set \\<Rightarrow> 'a GS\" where\n  \"GS_initial_impl I v0 succs \\<equiv> (\n    [v0],\n    [0],\n    I(v0\\<mapsto>(STACK 0)),\n    if succs={} then [] else [(0,succs)])\""], ["", "context GS\nbegin"], ["", "definition \"push_impl v succs \\<equiv> \n    let\n      _ = stat_newnode ();\n      j = length S;\n      S = S@[v];\n      B = B@[j];\n      I = I(v \\<mapsto> STACK j);\n      P = if succs={} then P else P@[(j,succs)]\n    in\n      (S,B,I,P)\""], ["", "definition mark_as_done \n    where \"\\<And>l u I. mark_as_done l u I \\<equiv> do {\n    (_,I)\\<leftarrow>WHILET \n      (\\<lambda>(l,I). l<u) \n      (\\<lambda>(l,I). do { ASSERT (l<length S); RETURN (Suc l,I(S!l \\<mapsto> DONE))}) \n      (l,I);\n    RETURN I\n  }\""], ["", "definition mark_as_done_abs where\n    \"\\<And>l u I. mark_as_done_abs l u I \n    \\<equiv> (\\<lambda>v. if v\\<in>{S!j | j. l\\<le>j \\<and> j<u} then Some DONE else I v)\""], ["", "lemma mark_as_done_aux:\n    fixes l u I\n    shows \"\\<lbrakk>l<u; u\\<le>length S\\<rbrakk> \\<Longrightarrow> mark_as_done l u I \n    \\<le> SPEC (\\<lambda>r. r = mark_as_done_abs l u I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l < u; u \\<le> length S\\<rbrakk>\n    \\<Longrightarrow> mark_as_done l u I\n                      \\<le> SPEC (\\<lambda>r. r = mark_as_done_abs l u I)", "unfolding mark_as_done_def mark_as_done_abs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l < u; u \\<le> length S\\<rbrakk>\n    \\<Longrightarrow> WHILE\\<^sub>T (\\<lambda>(l, I). l < u)\n                       (\\<lambda>(l, I).\n                           ASSERT (l < length S) \\<bind>\n                           (\\<lambda>_.\n                               RETURN (Suc l, I(S ! l \\<mapsto> DONE))))\n                       (l, I) \\<bind>\n                      (\\<lambda>(uu_, I). RETURN I)\n                      \\<le> SPEC\n                             (\\<lambda>r.\n                                 r =\n                                 (\\<lambda>v.\n                                     if v\n  \\<in> {S ! j |j. l \\<le> j \\<and> j < u}\n                                     then Some DONE else I v))", "apply (refine_rcg \n      WHILET_rule[where \n        I=\"\\<lambda>(l',I'). \n          I' = (\\<lambda>v. if v\\<in>{S!j | j. l\\<le>j \\<and> j<l'} then Some DONE else I v)\n          \\<and> l\\<le>l' \\<and> l'\\<le>u\"\n        and R=\"measure (\\<lambda>(l',_). u-l')\" \n      ]\n      refine_vcg)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>l < u; u \\<le> length S\\<rbrakk>\n    \\<Longrightarrow> wf (measure (\\<lambda>(l', uu_). u - l'))\n 2. \\<And>x1 x2.\n       \\<lbrakk>l < u; u \\<le> length S; (l, I) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2 =\n                         (\\<lambda>v.\n                             if v \\<in> {S ! j |j. l \\<le> j \\<and> j < x1}\n                             then Some DONE else I v)\n 3. \\<And>x1 x2.\n       \\<lbrakk>l < u; u \\<le> length S; (l, I) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> l \\<le> x1\n 4. \\<And>x1 x2.\n       \\<lbrakk>l < u; u \\<le> length S; (l, I) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 \\<le> u\n 5. \\<And>s a b.\n       \\<lbrakk>l < u; u \\<le> length S;\n        case s of\n        (l', I') \\<Rightarrow>\n          I' =\n          (\\<lambda>v.\n              if v \\<in> {S ! j |j. l \\<le> j \\<and> j < l'} then Some DONE\n              else I v) \\<and>\n          l \\<le> l' \\<and> l' \\<le> u;\n        case s of (l, I) \\<Rightarrow> l < u; s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> a < length S\n 6. \\<And>s a b x1 x2.\n       \\<lbrakk>l < u; u \\<le> length S;\n        case s of\n        (l', I') \\<Rightarrow>\n          I' =\n          (\\<lambda>v.\n              if v \\<in> {S ! j |j. l \\<le> j \\<and> j < l'} then Some DONE\n              else I v) \\<and>\n          l \\<le> l' \\<and> l' \\<le> u;\n        case s of (l, I) \\<Rightarrow> l < u; s = (a, b); a < length S;\n        (Suc a, b(S ! a \\<mapsto> DONE)) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2 =\n                         (\\<lambda>v.\n                             if v \\<in> {S ! j |j. l \\<le> j \\<and> j < x1}\n                             then Some DONE else I v)\n 7. \\<And>s a b x1 x2.\n       \\<lbrakk>l < u; u \\<le> length S;\n        case s of\n        (l', I') \\<Rightarrow>\n          I' =\n          (\\<lambda>v.\n              if v \\<in> {S ! j |j. l \\<le> j \\<and> j < l'} then Some DONE\n              else I v) \\<and>\n          l \\<le> l' \\<and> l' \\<le> u;\n        case s of (l, I) \\<Rightarrow> l < u; s = (a, b); a < length S;\n        (Suc a, b(S ! a \\<mapsto> DONE)) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> l \\<le> x1\n 8. \\<And>s a b x1 x2.\n       \\<lbrakk>l < u; u \\<le> length S;\n        case s of\n        (l', I') \\<Rightarrow>\n          I' =\n          (\\<lambda>v.\n              if v \\<in> {S ! j |j. l \\<le> j \\<and> j < l'} then Some DONE\n              else I v) \\<and>\n          l \\<le> l' \\<and> l' \\<le> u;\n        case s of (l, I) \\<Rightarrow> l < u; s = (a, b); a < length S;\n        (Suc a, b(S ! a \\<mapsto> DONE)) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 \\<le> u\n 9. \\<And>s a b.\n       \\<lbrakk>l < u; u \\<le> length S;\n        case s of\n        (l', I') \\<Rightarrow>\n          I' =\n          (\\<lambda>v.\n              if v \\<in> {S ! j |j. l \\<le> j \\<and> j < l'} then Some DONE\n              else I v) \\<and>\n          l \\<le> l' \\<and> l' \\<le> u;\n        case s of (l, I) \\<Rightarrow> l < u; s = (a, b);\n        a < length S\\<rbrakk>\n       \\<Longrightarrow> ((Suc a, b(S ! a \\<mapsto> DONE)), s)\n                         \\<in> measure (\\<lambda>(l', uu_). u - l')\n 10. \\<And>s a b.\n        \\<lbrakk>l < u; u \\<le> length S;\n         case s of\n         (l', I') \\<Rightarrow>\n           I' =\n           (\\<lambda>v.\n               if v \\<in> {S ! j |j. l \\<le> j \\<and> j < l'} then Some DONE\n               else I v) \\<and>\n           l \\<le> l' \\<and> l' \\<le> u;\n         \\<not> (case s of (l, I) \\<Rightarrow> l < u); s = (a, b)\\<rbrakk>\n        \\<Longrightarrow> b =\n                          (\\<lambda>v.\n                              if v \\<in> {S ! j |j. l \\<le> j \\<and> j < u}\n                              then Some DONE else I v)", "apply (auto intro!: ext simp: less_Suc_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"pop_impl \\<equiv> \n    do {\n      let lsi = length B - 1;\n      ASSERT (lsi<length B);\n      I \\<leftarrow> mark_as_done (seg_start lsi) (seg_end lsi) I;\n      ASSERT (B\\<noteq>[]);\n      let S = take (last B) S;\n      ASSERT (B\\<noteq>[]);\n      let B = butlast B;\n      RETURN (S,B,I,P)\n    }\""], ["", "definition \"sel_rem_last \\<equiv> \n    if P=[] then \n      RETURN (None,(S,B,I,P))\n    else do {\n      let (j,succs) = last P;\n      ASSERT (length B - 1 < length B);\n      if j \\<ge> seg_start (length B - 1) then do {\n        ASSERT (succs\\<noteq>{});\n        v \\<leftarrow> SPEC (\\<lambda>x. x\\<in>succs);\n        let succs = succs - {v};\n        ASSERT (P\\<noteq>[] \\<and> length P - 1 < length P);\n        let P = (if succs={} then butlast P else P[length P - 1 := (j,succs)]);\n        RETURN (Some v,(S,B,I,P))\n      } else RETURN (None,(S,B,I,P))\n    }\""], ["", "definition \"find_seg_impl j \\<equiv> find_max_nat (length B) (\\<lambda>i. B!i\\<le>j)\""], ["", "lemma (in GS_invar) find_seg_impl:\n    \"j<length S \\<Longrightarrow> find_seg_impl j = find_seg j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length S \\<Longrightarrow> find_seg_impl j = find_seg j", "unfolding find_seg_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length S \\<Longrightarrow>\n    find_max_nat (length B) (\\<lambda>i. B ! i \\<le> j) = find_seg j", "thm find_max_nat_correct"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length S \\<Longrightarrow>\n    find_max_nat (length B) (\\<lambda>i. B ! i \\<le> j) = find_seg j", "apply (subst find_max_nat_correct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. j < length S \\<Longrightarrow> B ! 0 \\<le> j\n 2. j < length S \\<Longrightarrow> 0 < length B\n 3. j < length S \\<Longrightarrow>\n    Max {i. i < length B \\<and> B ! i \\<le> j} = find_seg j", "apply (simp add: B0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. j < length S \\<Longrightarrow> 0 < length B\n 2. j < length S \\<Longrightarrow>\n    Max {i. i < length B \\<and> B ! i \\<le> j} = find_seg j", "apply (simp add: B0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length S \\<Longrightarrow>\n    Max {i. i < length B \\<and> B ! i \\<le> j} = find_seg j", "apply (simp add: find_seg_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"idx_of_impl v \\<equiv> do {\n      ASSERT (\\<exists>i. I v = Some (STACK i));\n      let j = S_idx_of v;\n      ASSERT (j<length S);\n      let i = find_seg_impl j;\n      RETURN i\n    }\""], ["", "definition \"collapse_impl v \\<equiv> \n    do { \n      i\\<leftarrow>idx_of_impl v;\n      ASSERT (i+1 \\<le> length B);\n      let B = take (i+1) B;\n      RETURN (S,B,I,P)\n    }\""], ["", "end"], ["", "lemma (in -) GS_initial_correct: \n  assumes REL: \"(I,D)\\<in>oGS_rel\"\n  assumes A: \"v0\\<notin>D\"\n  shows \"GS.\\<alpha> (GS_initial_impl I v0 succs) = ([{v0}],D,{v0}\\<times>succs)\" (is ?G1)\n  and \"GS_invar (GS_initial_impl I v0 succs)\" (is ?G2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. GS.\\<alpha> (GS_initial_impl I v0 succs) =\n    ([{v0}], D, {v0} \\<times> succs) &&&\n    GS_invar (GS_initial_impl I v0 succs)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. GS.\\<alpha> (GS_initial_impl I v0 succs) =\n    ([{v0}], D, {v0} \\<times> succs)\n 2. GS_invar (GS_initial_impl I v0 succs)", "from REL"], ["proof (chain)\npicking this:\n  (I, D) \\<in> oGS_rel", "have [simp]: \"D = oGS_\\<alpha> I\" and I: \"oGS_invar I\""], ["proof (prove)\nusing this:\n  (I, D) \\<in> oGS_rel\n\ngoal (1 subgoal):\n 1. D = oGS_\\<alpha> I &&& oGS_invar I", "by (simp_all add: oGS_rel_def br_def)"], ["proof (state)\nthis:\n  D = oGS_\\<alpha> I\n  oGS_invar I\n\ngoal (2 subgoals):\n 1. GS.\\<alpha> (GS_initial_impl I v0 succs) =\n    ([{v0}], D, {v0} \\<times> succs)\n 2. GS_invar (GS_initial_impl I v0 succs)", "from I"], ["proof (chain)\npicking this:\n  oGS_invar I", "have [simp]: \"\\<And>j v. I v \\<noteq> Some (STACK j)\""], ["proof (prove)\nusing this:\n  oGS_invar I\n\ngoal (1 subgoal):\n 1. \\<And>j v. I v \\<noteq> Some (STACK j)", "by (simp add: oGS_invar_def)"], ["proof (state)\nthis:\n  I ?v \\<noteq> Some (STACK ?j)\n\ngoal (2 subgoals):\n 1. GS.\\<alpha> (GS_initial_impl I v0 succs) =\n    ([{v0}], D, {v0} \\<times> succs)\n 2. GS_invar (GS_initial_impl I v0 succs)", "show ?G1"], ["proof (prove)\ngoal (1 subgoal):\n 1. GS.\\<alpha> (GS_initial_impl I v0 succs) =\n    ([{v0}], D, {v0} \\<times> succs)", "unfolding GS.\\<alpha>_def GS_initial_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (GS.p_\\<alpha>\n      ([v0], [0], I(v0 \\<mapsto> STACK 0),\n       if succs = {} then [] else [(0, succs)]),\n     GS.D_\\<alpha>\n      ([v0], [0], I(v0 \\<mapsto> STACK 0),\n       if succs = {} then [] else [(0, succs)]),\n     GS.pE_\\<alpha>\n      ([v0], [0], I(v0 \\<mapsto> STACK 0),\n       if succs = {} then [] else [(0, succs)])) =\n    ([{v0}], D, {v0} \\<times> succs)", "apply (simp split del: if_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. GS.p_\\<alpha>\n     ([v0], [0], I(v0 \\<mapsto> STACK 0),\n      if succs = {} then [] else [(0, succs)]) =\n    [{v0}] \\<and>\n    GS.D_\\<alpha>\n     ([v0], [0], I(v0 \\<mapsto> STACK 0),\n      if succs = {} then [] else [(0, succs)]) =\n    oGS_\\<alpha> I \\<and>\n    GS.pE_\\<alpha>\n     ([v0], [0], I(v0 \\<mapsto> STACK 0),\n      if succs = {} then [] else [(0, succs)]) =\n    {v0} \\<times> succs", "apply (intro conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. GS.p_\\<alpha>\n     ([v0], [0], I(v0 \\<mapsto> STACK 0),\n      if succs = {} then [] else [(0, succs)]) =\n    [{v0}]\n 2. GS.D_\\<alpha>\n     ([v0], [0], I(v0 \\<mapsto> STACK 0),\n      if succs = {} then [] else [(0, succs)]) =\n    oGS_\\<alpha> I\n 3. GS.pE_\\<alpha>\n     ([v0], [0], I(v0 \\<mapsto> STACK 0),\n      if succs = {} then [] else [(0, succs)]) =\n    {v0} \\<times> succs", "unfolding GS.p_\\<alpha>_def GS.seg_def[abs_def] GS.seg_start_def GS.seg_end_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. map (\\<lambda>i.\n            {GS.S\n              ([v0], [0], I(v0 \\<mapsto> STACK 0),\n               if succs = {} then [] else [(0, succs)]) !\n             j |\n             j. GS.B\n                 ([v0], [0], I(v0 \\<mapsto> STACK 0),\n                  if succs = {} then [] else [(0, succs)]) !\n                i\n                \\<le> j \\<and>\n                j < (if i + 1 =\n                        length\n                         (GS.B\n                           ([v0], [0], I(v0 \\<mapsto> STACK 0),\n                            if succs = {} then [] else [(0, succs)]))\n                     then length\n                           (GS.S\n                             ([v0], [0], I(v0 \\<mapsto> STACK 0),\n                              if succs = {} then [] else [(0, succs)]))\n                     else GS.B\n                           ([v0], [0], I(v0 \\<mapsto> STACK 0),\n                            if succs = {} then [] else [(0, succs)]) !\n                          (i + 1))})\n     [0..<\n      length\n       (GS.B\n         ([v0], [0], I(v0 \\<mapsto> STACK 0),\n          if succs = {} then [] else [(0, succs)]))] =\n    [{v0}]\n 2. GS.D_\\<alpha>\n     ([v0], [0], I(v0 \\<mapsto> STACK 0),\n      if succs = {} then [] else [(0, succs)]) =\n    oGS_\\<alpha> I\n 3. GS.pE_\\<alpha>\n     ([v0], [0], I(v0 \\<mapsto> STACK 0),\n      if succs = {} then [] else [(0, succs)]) =\n    {v0} \\<times> succs", "apply (auto) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. GS.D_\\<alpha>\n     ([v0], [0], I(v0 \\<mapsto> STACK 0),\n      if succs = {} then [] else [(0, succs)]) =\n    oGS_\\<alpha> I\n 2. GS.pE_\\<alpha>\n     ([v0], [0], I(v0 \\<mapsto> STACK 0),\n      if succs = {} then [] else [(0, succs)]) =\n    {v0} \\<times> succs", "using A"], ["proof (prove)\nusing this:\n  v0 \\<notin> D\n\ngoal (2 subgoals):\n 1. GS.D_\\<alpha>\n     ([v0], [0], I(v0 \\<mapsto> STACK 0),\n      if succs = {} then [] else [(0, succs)]) =\n    oGS_\\<alpha> I\n 2. GS.pE_\\<alpha>\n     ([v0], [0], I(v0 \\<mapsto> STACK 0),\n      if succs = {} then [] else [(0, succs)]) =\n    {v0} \\<times> succs", "unfolding GS.D_\\<alpha>_def"], ["proof (prove)\nusing this:\n  v0 \\<notin> D\n\ngoal (2 subgoals):\n 1. {v. GS.I\n         ([v0], [0], I(v0 \\<mapsto> STACK 0),\n          if succs = {} then [] else [(0, succs)])\n         v =\n        Some DONE} =\n    oGS_\\<alpha> I\n 2. GS.pE_\\<alpha>\n     ([v0], [0], I(v0 \\<mapsto> STACK 0),\n      if succs = {} then [] else [(0, succs)]) =\n    {v0} \\<times> succs", "apply (auto simp: oGS_\\<alpha>_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. GS.pE_\\<alpha>\n     ([v0], [0], I(v0 \\<mapsto> STACK 0),\n      if succs = {} then [] else [(0, succs)]) =\n    {v0} \\<times> succs", "unfolding GS.pE_\\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(u, v).\n     \\<exists>j Ia.\n        (j, Ia)\n        \\<in> set (GS.P\n                    ([v0], [0], I(v0 \\<mapsto> STACK 0),\n                     if succs = {} then [] else [(0, succs)])) \\<and>\n        u =\n        GS.S\n         ([v0], [0], I(v0 \\<mapsto> STACK 0),\n          if succs = {} then [] else [(0, succs)]) !\n        j \\<and>\n        v \\<in> Ia} =\n    {v0} \\<times> succs", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  GS.\\<alpha> (GS_initial_impl I v0 succs) =\n  ([{v0}], D, {v0} \\<times> succs)\n\ngoal (1 subgoal):\n 1. GS_invar (GS_initial_impl I v0 succs)", "show ?G2"], ["proof (prove)\ngoal (1 subgoal):\n 1. GS_invar (GS_initial_impl I v0 succs)", "unfolding GS_initial_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. GS_invar\n     ([v0], [0], I(v0 \\<mapsto> STACK 0),\n      if succs = {} then [] else [(0, succs)])", "apply unfold_locales"], ["proof (prove)\ngoal (9 subgoals):\n 1. set (GS.B\n          ([v0], [0], I(v0 \\<mapsto> STACK 0),\n           if succs = {} then [] else [(0, succs)]))\n    \\<subseteq> {0..<length\n                      (GS.S\n                        ([v0], [0], I(v0 \\<mapsto> STACK 0),\n                         if succs = {} then [] else [(0, succs)]))}\n 2. sorted\n     (GS.B\n       ([v0], [0], I(v0 \\<mapsto> STACK 0),\n        if succs = {} then [] else [(0, succs)]))\n 3. distinct\n     (GS.B\n       ([v0], [0], I(v0 \\<mapsto> STACK 0),\n        if succs = {} then [] else [(0, succs)]))\n 4. GS.S\n     ([v0], [0], I(v0 \\<mapsto> STACK 0),\n      if succs = {} then [] else [(0, succs)]) \\<noteq>\n    [] \\<Longrightarrow>\n    GS.B\n     ([v0], [0], I(v0 \\<mapsto> STACK 0),\n      if succs = {} then [] else [(0, succs)]) \\<noteq>\n    [] \\<and>\n    GS.B\n     ([v0], [0], I(v0 \\<mapsto> STACK 0),\n      if succs = {} then [] else [(0, succs)]) !\n    0 =\n    0\n 5. distinct\n     (GS.S\n       ([v0], [0], I(v0 \\<mapsto> STACK 0),\n        if succs = {} then [] else [(0, succs)]))\n 6. \\<And>v j.\n       (GS.I\n         ([v0], [0], I(v0 \\<mapsto> STACK 0),\n          if succs = {} then [] else [(0, succs)])\n         v =\n        Some (STACK j)) =\n       (j < length\n             (GS.S\n               ([v0], [0], I(v0 \\<mapsto> STACK 0),\n                if succs = {} then [] else [(0, succs)])) \\<and>\n        v =\n        GS.S\n         ([v0], [0], I(v0 \\<mapsto> STACK 0),\n          if succs = {} then [] else [(0, succs)]) !\n        j)\n 7. sorted\n     (map fst\n       (GS.P\n         ([v0], [0], I(v0 \\<mapsto> STACK 0),\n          if succs = {} then [] else [(0, succs)])))\n 8. distinct\n     (map fst\n       (GS.P\n         ([v0], [0], I(v0 \\<mapsto> STACK 0),\n          if succs = {} then [] else [(0, succs)])))\n 9. set (GS.P\n          ([v0], [0], I(v0 \\<mapsto> STACK 0),\n           if succs = {} then [] else [(0, succs)]))\n    \\<subseteq> {0..<length\n                      (GS.S\n                        ([v0], [0], I(v0 \\<mapsto> STACK 0),\n                         if succs = {} then [] else [(0, succs)]))} \\<times>\n                {y. {} \\<noteq> y}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  GS_invar (GS_initial_impl I v0 succs)\n\ngoal:\nNo subgoals!", "qed"], ["", "context GS_invar\nbegin"], ["", "lemma push_correct:\n    assumes A: \"v\\<notin>\\<Union>(set p_\\<alpha>)\" and B: \"v\\<notin>D_\\<alpha>\"\n    shows \"GS.\\<alpha> (push_impl v succs) = (p_\\<alpha>@[{v}],D_\\<alpha>,pE_\\<alpha> \\<union> {v}\\<times>succs)\" \n      (is ?G1)\n    and \"GS_invar (push_impl v succs)\" (is ?G2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. GS.\\<alpha> (push_impl v succs) =\n    (p_\\<alpha> @ [{v}], D_\\<alpha>,\n     pE_\\<alpha> \\<union> {v} \\<times> succs) &&&\n    GS_invar (push_impl v succs)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. GS.\\<alpha> (push_impl v succs) =\n    (p_\\<alpha> @ [{v}], D_\\<alpha>,\n     pE_\\<alpha> \\<union> {v} \\<times> succs)\n 2. GS_invar (push_impl v succs)", "note [simp] = Let_def"], ["proof (state)\nthis:\n  Let ?s ?f \\<equiv> ?f ?s\n\ngoal (2 subgoals):\n 1. GS.\\<alpha> (push_impl v succs) =\n    (p_\\<alpha> @ [{v}], D_\\<alpha>,\n     pE_\\<alpha> \\<union> {v} \\<times> succs)\n 2. GS_invar (push_impl v succs)", "have A1: \"GS.D_\\<alpha> (push_impl v succs) = D_\\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GS.D_\\<alpha> (push_impl v succs) = D_\\<alpha>", "using B"], ["proof (prove)\nusing this:\n  v \\<notin> D_\\<alpha>\n\ngoal (1 subgoal):\n 1. GS.D_\\<alpha> (push_impl v succs) = D_\\<alpha>", "by (auto simp: push_impl_def GS.D_\\<alpha>_def)"], ["proof (state)\nthis:\n  GS.D_\\<alpha> (push_impl v succs) = D_\\<alpha>\n\ngoal (2 subgoals):\n 1. GS.\\<alpha> (push_impl v succs) =\n    (p_\\<alpha> @ [{v}], D_\\<alpha>,\n     pE_\\<alpha> \\<union> {v} \\<times> succs)\n 2. GS_invar (push_impl v succs)", "have iexI: \"\\<And>a b j P. \\<lbrakk>a!j = b!j; P j\\<rbrakk> \\<Longrightarrow> \\<exists>j'. a!j = b!j' \\<and> P j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b j P.\n       \\<lbrakk>a ! j = b ! j; P j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j'. a ! j = b ! j' \\<and> P j'", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?a ! ?j = ?b ! ?j; ?P ?j\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j'. ?a ! ?j = ?b ! j' \\<and> ?P j'\n\ngoal (2 subgoals):\n 1. GS.\\<alpha> (push_impl v succs) =\n    (p_\\<alpha> @ [{v}], D_\\<alpha>,\n     pE_\\<alpha> \\<union> {v} \\<times> succs)\n 2. GS_invar (push_impl v succs)", "have A2: \"GS.p_\\<alpha> (push_impl v succs) = p_\\<alpha> @ [{v}]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GS.p_\\<alpha> (push_impl v succs) = p_\\<alpha> @ [{v}]", "unfolding push_impl_def GS.p_\\<alpha>_def GS.seg_def[abs_def] \n        GS.seg_start_def GS.seg_end_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i.\n            {GS.S\n              (let _ = stat_newnode (); j = length S; S = S @ [v];\n                   B = B @ [j]; I = I(v \\<mapsto> STACK j);\n                   P = if succs = {} then P else P @ [(j, succs)]\n               in (S, B, I, P)) !\n             j |\n             j. GS.B\n                 (let _ = stat_newnode (); j = length S; S = S @ [v];\n                      B = B @ [j]; I = I(v \\<mapsto> STACK j);\n                      P = if succs = {} then P else P @ [(j, succs)]\n                  in (S, B, I, P)) !\n                i\n                \\<le> j \\<and>\n                j < (if i + 1 =\n                        length\n                         (GS.B\n                           (let _ = stat_newnode (); j = length S;\n                                S = S @ [v]; B = B @ [j];\n                                I = I(v \\<mapsto> STACK j);\n                                P = if succs = {} then P\n                                    else P @ [(j, succs)]\n                            in (S, B, I, P)))\n                     then length\n                           (GS.S\n                             (let _ = stat_newnode (); j = length S;\n                                  S = S @ [v]; B = B @ [j];\n                                  I = I(v \\<mapsto> STACK j);\n                                  P = if succs = {} then P\nelse P @ [(j, succs)]\n                              in (S, B, I, P)))\n                     else GS.B\n                           (let _ = stat_newnode (); j = length S;\n                                S = S @ [v]; B = B @ [j];\n                                I = I(v \\<mapsto> STACK j);\n                                P = if succs = {} then P\n                                    else P @ [(j, succs)]\n                            in (S, B, I, P)) !\n                          (i + 1))})\n     [0..<\n      length\n       (GS.B\n         (let _ = stat_newnode (); j = length S; S = S @ [v]; B = B @ [j];\n              I = I(v \\<mapsto> STACK j);\n              P = if succs = {} then P else P @ [(j, succs)]\n          in (S, B, I, P)))] =\n    map (\\<lambda>i.\n            {S ! j |j.\n             B ! i \\<le> j \\<and>\n             j < (if i + 1 = length B then length S else B ! (i + 1))})\n     [0..<length B] @\n    [{v}]", "apply (clarsimp split del: if_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>{0..<length B}.\n        {(S @ [v]) ! j |j.\n         B ! x \\<le> j \\<and> j < (B @ [length S]) ! Suc x} =\n        {S ! j |j.\n         B ! x \\<le> j \\<and>\n         j < (if Suc x = length B then length S else B ! (x + 1))}) \\<and>\n    {(S @ [v]) ! j |j. length S \\<le> j \\<and> j < Suc (length S)} = {v}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>{0..<length B}.\n        (Suc x = length B \\<longrightarrow>\n         {(S @ [v]) ! j |j. B ! x \\<le> j \\<and> j < length S} =\n         {S ! j |j. B ! x \\<le> j \\<and> j < length S}) \\<and>\n        (Suc x \\<noteq> length B \\<longrightarrow>\n         {(S @ [v]) ! j |j. B ! x \\<le> j \\<and> j < B ! Suc x} =\n         {S ! j |j. B ! x \\<le> j \\<and> j < B ! Suc x})) \\<and>\n    {(S @ [v]) ! j |j. length S \\<le> j \\<and> j < Suc (length S)} = {v}", "apply safe"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x xa j.\n       \\<lbrakk>x \\<in> {0..<length B}; Suc x = length B; B ! x \\<le> j;\n        j < length S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ja.\n                            (S @ [v]) ! j = S ! ja \\<and>\n                            B ! x \\<le> ja \\<and> ja < length S\n 2. \\<And>x xa j.\n       \\<lbrakk>x \\<in> {0..<length B}; Suc x = length B; B ! x \\<le> j;\n        j < length S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ja.\n                            S ! j = (S @ [v]) ! ja \\<and>\n                            B ! x \\<le> ja \\<and> ja < length S\n 3. \\<And>x xa j.\n       \\<lbrakk>x \\<in> {0..<length B}; Suc x \\<noteq> length B;\n        B ! x \\<le> j; j < B ! Suc x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ja.\n                            (S @ [v]) ! j = S ! ja \\<and>\n                            B ! x \\<le> ja \\<and> ja < B ! Suc x\n 4. \\<And>x xa j.\n       \\<lbrakk>x \\<in> {0..<length B}; Suc x \\<noteq> length B;\n        B ! x \\<le> j; j < B ! Suc x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ja.\n                            S ! j = (S @ [v]) ! ja \\<and>\n                            B ! x \\<le> ja \\<and> ja < B ! Suc x\n 5. \\<And>x j.\n       \\<lbrakk>(S @ [v]) ! j \\<notin> {}; length S \\<le> j;\n        j < Suc (length S)\\<rbrakk>\n       \\<Longrightarrow> (S @ [v]) ! j = v\n 6. \\<And>x.\n       \\<exists>j.\n          v = (S @ [v]) ! j \\<and>\n          length S \\<le> j \\<and> j < Suc (length S)", "apply (((rule iexI)?, \n        (auto  \n          simp: nth_append nat_in_between_eq \n          dest: order.strict_trans[OF _ B_in_bound']\n        )) []\n      ) +"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  GS.p_\\<alpha> (push_impl v succs) = p_\\<alpha> @ [{v}]\n\ngoal (2 subgoals):\n 1. GS.\\<alpha> (push_impl v succs) =\n    (p_\\<alpha> @ [{v}], D_\\<alpha>,\n     pE_\\<alpha> \\<union> {v} \\<times> succs)\n 2. GS_invar (push_impl v succs)", "have iexI2: \"\\<And>j I Q. \\<lbrakk>(j,I)\\<in>set P; (j,I)\\<in>set P \\<Longrightarrow> Q j\\<rbrakk> \\<Longrightarrow> \\<exists>j. Q j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j I Q.\n       \\<lbrakk>(j, I) \\<in> set P;\n        (j, I) \\<in> set P \\<Longrightarrow> Q j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j. Q j", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>(?j1, ?I1) \\<in> set P;\n   (?j1, ?I1) \\<in> set P \\<Longrightarrow> ?Q1 ?j1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j. ?Q1 j\n\ngoal (2 subgoals):\n 1. GS.\\<alpha> (push_impl v succs) =\n    (p_\\<alpha> @ [{v}], D_\\<alpha>,\n     pE_\\<alpha> \\<union> {v} \\<times> succs)\n 2. GS_invar (push_impl v succs)", "have A3: \"GS.pE_\\<alpha> (push_impl v succs) = pE_\\<alpha> \\<union> {v} \\<times> succs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GS.pE_\\<alpha> (push_impl v succs) =\n    pE_\\<alpha> \\<union> {v} \\<times> succs", "unfolding push_impl_def GS.pE_\\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(u, va).\n     \\<exists>j Ia.\n        (j, Ia)\n        \\<in> set (GS.P\n                    (let _ = stat_newnode (); j = length S; S = S @ [v];\n                         B = B @ [j]; I = I(v \\<mapsto> STACK j);\n                         P = if succs = {} then P else P @ [(j, succs)]\n                     in (S, B, I, P))) \\<and>\n        u =\n        GS.S\n         (let _ = stat_newnode (); j = length S; S = S @ [v]; B = B @ [j];\n              I = I(v \\<mapsto> STACK j);\n              P = if succs = {} then P else P @ [(j, succs)]\n          in (S, B, I, P)) !\n        j \\<and>\n        va \\<in> Ia} =\n    {(u, v).\n     \\<exists>j I.\n        (j, I) \\<in> set P \\<and> u = S ! j \\<and> v \\<in> I} \\<union>\n    {v} \\<times> succs", "using P_bound"], ["proof (prove)\nusing this:\n  set P \\<subseteq> {0..<length S} \\<times> {y. {} \\<noteq> y}\n\ngoal (1 subgoal):\n 1. {(u, va).\n     \\<exists>j Ia.\n        (j, Ia)\n        \\<in> set (GS.P\n                    (let _ = stat_newnode (); j = length S; S = S @ [v];\n                         B = B @ [j]; I = I(v \\<mapsto> STACK j);\n                         P = if succs = {} then P else P @ [(j, succs)]\n                     in (S, B, I, P))) \\<and>\n        u =\n        GS.S\n         (let _ = stat_newnode (); j = length S; S = S @ [v]; B = B @ [j];\n              I = I(v \\<mapsto> STACK j);\n              P = if succs = {} then P else P @ [(j, succs)]\n          in (S, B, I, P)) !\n        j \\<and>\n        va \\<in> Ia} =\n    {(u, v).\n     \\<exists>j I.\n        (j, I) \\<in> set P \\<and> u = S ! j \\<and> v \\<in> I} \\<union>\n    {v} \\<times> succs", "apply (force simp: nth_append elim!: iexI2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  GS.pE_\\<alpha> (push_impl v succs) =\n  pE_\\<alpha> \\<union> {v} \\<times> succs\n\ngoal (2 subgoals):\n 1. GS.\\<alpha> (push_impl v succs) =\n    (p_\\<alpha> @ [{v}], D_\\<alpha>,\n     pE_\\<alpha> \\<union> {v} \\<times> succs)\n 2. GS_invar (push_impl v succs)", "show ?G1"], ["proof (prove)\ngoal (1 subgoal):\n 1. GS.\\<alpha> (push_impl v succs) =\n    (p_\\<alpha> @ [{v}], D_\\<alpha>,\n     pE_\\<alpha> \\<union> {v} \\<times> succs)", "unfolding GS.\\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (GS.p_\\<alpha> (push_impl v succs), GS.D_\\<alpha> (push_impl v succs),\n     GS.pE_\\<alpha> (push_impl v succs)) =\n    (p_\\<alpha> @ [{v}], D_\\<alpha>,\n     pE_\\<alpha> \\<union> {v} \\<times> succs)", "by (simp add: A1 A2 A3)"], ["proof (state)\nthis:\n  GS.\\<alpha> (push_impl v succs) =\n  (p_\\<alpha> @ [{v}], D_\\<alpha>, pE_\\<alpha> \\<union> {v} \\<times> succs)\n\ngoal (1 subgoal):\n 1. GS_invar (push_impl v succs)", "show ?G2"], ["proof (prove)\ngoal (1 subgoal):\n 1. GS_invar (push_impl v succs)", "apply unfold_locales"], ["proof (prove)\ngoal (9 subgoals):\n 1. set (GS.B (push_impl v succs))\n    \\<subseteq> {0..<length (GS.S (push_impl v succs))}\n 2. sorted (GS.B (push_impl v succs))\n 3. distinct (GS.B (push_impl v succs))\n 4. GS.S (push_impl v succs) \\<noteq> [] \\<Longrightarrow>\n    GS.B (push_impl v succs) \\<noteq> [] \\<and>\n    GS.B (push_impl v succs) ! 0 = 0\n 5. distinct (GS.S (push_impl v succs))\n 6. \\<And>va j.\n       (GS.I (push_impl v succs) va = Some (STACK j)) =\n       (j < length (GS.S (push_impl v succs)) \\<and>\n        va = GS.S (push_impl v succs) ! j)\n 7. sorted (map fst (GS.P (push_impl v succs)))\n 8. distinct (map fst (GS.P (push_impl v succs)))\n 9. set (GS.P (push_impl v succs))\n    \\<subseteq> {0..<length (GS.S (push_impl v succs))} \\<times>\n                {y. {} \\<noteq> y}", "unfolding push_impl_def"], ["proof (prove)\ngoal (9 subgoals):\n 1. set (GS.B\n          (let _ = stat_newnode (); j = length S; S = S @ [v]; B = B @ [j];\n               I = I(v \\<mapsto> STACK j);\n               P = if succs = {} then P else P @ [(j, succs)]\n           in (S, B, I, P)))\n    \\<subseteq> {0..<length\n                      (GS.S\n                        (let _ = stat_newnode (); j = length S; S = S @ [v];\n                             B = B @ [j]; I = I(v \\<mapsto> STACK j);\n                             P = if succs = {} then P else P @ [(j, succs)]\n                         in (S, B, I, P)))}\n 2. sorted\n     (GS.B\n       (let _ = stat_newnode (); j = length S; S = S @ [v]; B = B @ [j];\n            I = I(v \\<mapsto> STACK j);\n            P = if succs = {} then P else P @ [(j, succs)]\n        in (S, B, I, P)))\n 3. distinct\n     (GS.B\n       (let _ = stat_newnode (); j = length S; S = S @ [v]; B = B @ [j];\n            I = I(v \\<mapsto> STACK j);\n            P = if succs = {} then P else P @ [(j, succs)]\n        in (S, B, I, P)))\n 4. GS.S\n     (let _ = stat_newnode (); j = length S; S = S @ [v]; B = B @ [j];\n          I = I(v \\<mapsto> STACK j);\n          P = if succs = {} then P else P @ [(j, succs)]\n      in (S, B, I, P)) \\<noteq>\n    [] \\<Longrightarrow>\n    GS.B\n     (let _ = stat_newnode (); j = length S; S = S @ [v]; B = B @ [j];\n          I = I(v \\<mapsto> STACK j);\n          P = if succs = {} then P else P @ [(j, succs)]\n      in (S, B, I, P)) \\<noteq>\n    [] \\<and>\n    GS.B\n     (let _ = stat_newnode (); j = length S; S = S @ [v]; B = B @ [j];\n          I = I(v \\<mapsto> STACK j);\n          P = if succs = {} then P else P @ [(j, succs)]\n      in (S, B, I, P)) !\n    0 =\n    0\n 5. distinct\n     (GS.S\n       (let _ = stat_newnode (); j = length S; S = S @ [v]; B = B @ [j];\n            I = I(v \\<mapsto> STACK j);\n            P = if succs = {} then P else P @ [(j, succs)]\n        in (S, B, I, P)))\n 6. \\<And>va j.\n       (GS.I\n         (let _ = stat_newnode (); j = length S; S = S @ [v]; B = B @ [j];\n              I = I(v \\<mapsto> STACK j);\n              P = if succs = {} then P else P @ [(j, succs)]\n          in (S, B, I, P))\n         va =\n        Some (STACK j)) =\n       (j < length\n             (GS.S\n               (let _ = stat_newnode (); j = length S; S = S @ [v];\n                    B = B @ [j]; I = I(v \\<mapsto> STACK j);\n                    P = if succs = {} then P else P @ [(j, succs)]\n                in (S, B, I, P))) \\<and>\n        va =\n        GS.S\n         (let _ = stat_newnode (); j = length S; S = S @ [v]; B = B @ [j];\n              I = I(v \\<mapsto> STACK j);\n              P = if succs = {} then P else P @ [(j, succs)]\n          in (S, B, I, P)) !\n        j)\n 7. sorted\n     (map fst\n       (GS.P\n         (let _ = stat_newnode (); j = length S; S = S @ [v]; B = B @ [j];\n              I = I(v \\<mapsto> STACK j);\n              P = if succs = {} then P else P @ [(j, succs)]\n          in (S, B, I, P))))\n 8. distinct\n     (map fst\n       (GS.P\n         (let _ = stat_newnode (); j = length S; S = S @ [v]; B = B @ [j];\n              I = I(v \\<mapsto> STACK j);\n              P = if succs = {} then P else P @ [(j, succs)]\n          in (S, B, I, P))))\n 9. set (GS.P\n          (let _ = stat_newnode (); j = length S; S = S @ [v]; B = B @ [j];\n               I = I(v \\<mapsto> STACK j);\n               P = if succs = {} then P else P @ [(j, succs)]\n           in (S, B, I, P)))\n    \\<subseteq> {0..<length\n                      (GS.S\n                        (let _ = stat_newnode (); j = length S; S = S @ [v];\n                             B = B @ [j]; I = I(v \\<mapsto> STACK j);\n                             P = if succs = {} then P else P @ [(j, succs)]\n                         in (S, B, I, P)))} \\<times>\n                {y. {} \\<noteq> y}", "apply simp_all"], ["proof (prove)\ngoal (9 subgoals):\n 1. set B \\<subseteq> {0..<Suc (length S)}\n 2. sorted (B @ [length S])\n 3. distinct B \\<and> length S \\<notin> set B\n 4. (B @ [length S]) ! 0 = 0\n 5. distinct S \\<and> v \\<notin> set S\n 6. \\<And>va j.\n       (va = v \\<longrightarrow>\n        (length S = j) =\n        (j < Suc (length S) \\<and> v = (S @ [v]) ! j)) \\<and>\n       (va \\<noteq> v \\<longrightarrow>\n        (I va = Some (STACK j)) =\n        (j < Suc (length S) \\<and> va = (S @ [v]) ! j))\n 7. (succs = {} \\<longrightarrow> sorted (map fst P)) \\<and>\n    (succs \\<noteq> {} \\<longrightarrow> sorted (map fst P @ [length S]))\n 8. (succs = {} \\<longrightarrow> distinct (map fst P)) \\<and>\n    (succs \\<noteq> {} \\<longrightarrow>\n     distinct (map fst P) \\<and> length S \\<notin> fst ` set P)\n 9. set P \\<subseteq> {0..<Suc (length S)} \\<times> {y. {} \\<noteq> y}", "using B_in_bound B_sorted B_distinct"], ["proof (prove)\nusing this:\n  set B \\<subseteq> {0..<length S}\n  sorted B\n  distinct B\n\ngoal (9 subgoals):\n 1. set B \\<subseteq> {0..<Suc (length S)}\n 2. sorted (B @ [length S])\n 3. distinct B \\<and> length S \\<notin> set B\n 4. (B @ [length S]) ! 0 = 0\n 5. distinct S \\<and> v \\<notin> set S\n 6. \\<And>va j.\n       (va = v \\<longrightarrow>\n        (length S = j) =\n        (j < Suc (length S) \\<and> v = (S @ [v]) ! j)) \\<and>\n       (va \\<noteq> v \\<longrightarrow>\n        (I va = Some (STACK j)) =\n        (j < Suc (length S) \\<and> va = (S @ [v]) ! j))\n 7. (succs = {} \\<longrightarrow> sorted (map fst P)) \\<and>\n    (succs \\<noteq> {} \\<longrightarrow> sorted (map fst P @ [length S]))\n 8. (succs = {} \\<longrightarrow> distinct (map fst P)) \\<and>\n    (succs \\<noteq> {} \\<longrightarrow>\n     distinct (map fst P) \\<and> length S \\<notin> fst ` set P)\n 9. set P \\<subseteq> {0..<Suc (length S)} \\<times> {y. {} \\<noteq> y}", "apply (auto simp: sorted_append) [3]"], ["proof (prove)\ngoal (6 subgoals):\n 1. (B @ [length S]) ! 0 = 0\n 2. distinct S \\<and> v \\<notin> set S\n 3. \\<And>va j.\n       (va = v \\<longrightarrow>\n        (length S = j) =\n        (j < Suc (length S) \\<and> v = (S @ [v]) ! j)) \\<and>\n       (va \\<noteq> v \\<longrightarrow>\n        (I va = Some (STACK j)) =\n        (j < Suc (length S) \\<and> va = (S @ [v]) ! j))\n 4. (succs = {} \\<longrightarrow> sorted (map fst P)) \\<and>\n    (succs \\<noteq> {} \\<longrightarrow> sorted (map fst P @ [length S]))\n 5. (succs = {} \\<longrightarrow> distinct (map fst P)) \\<and>\n    (succs \\<noteq> {} \\<longrightarrow>\n     distinct (map fst P) \\<and> length S \\<notin> fst ` set P)\n 6. set P \\<subseteq> {0..<Suc (length S)} \\<times> {y. {} \\<noteq> y}", "using B_in_bound B0"], ["proof (prove)\nusing this:\n  set B \\<subseteq> {0..<length S}\n  S \\<noteq> [] \\<Longrightarrow> B \\<noteq> [] \\<and> B ! 0 = 0\n\ngoal (6 subgoals):\n 1. (B @ [length S]) ! 0 = 0\n 2. distinct S \\<and> v \\<notin> set S\n 3. \\<And>va j.\n       (va = v \\<longrightarrow>\n        (length S = j) =\n        (j < Suc (length S) \\<and> v = (S @ [v]) ! j)) \\<and>\n       (va \\<noteq> v \\<longrightarrow>\n        (I va = Some (STACK j)) =\n        (j < Suc (length S) \\<and> va = (S @ [v]) ! j))\n 4. (succs = {} \\<longrightarrow> sorted (map fst P)) \\<and>\n    (succs \\<noteq> {} \\<longrightarrow> sorted (map fst P @ [length S]))\n 5. (succs = {} \\<longrightarrow> distinct (map fst P)) \\<and>\n    (succs \\<noteq> {} \\<longrightarrow>\n     distinct (map fst P) \\<and> length S \\<notin> fst ` set P)\n 6. set P \\<subseteq> {0..<Suc (length S)} \\<times> {y. {} \\<noteq> y}", "apply (cases S)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>set B \\<subseteq> {0..<length S};\n     S \\<noteq> [] \\<Longrightarrow> B \\<noteq> [] \\<and> B ! 0 = 0;\n     S = []\\<rbrakk>\n    \\<Longrightarrow> (B @ [length S]) ! 0 = 0\n 2. \\<And>a list.\n       \\<lbrakk>set B \\<subseteq> {0..<length S};\n        S \\<noteq> [] \\<Longrightarrow> B \\<noteq> [] \\<and> B ! 0 = 0;\n        S = a # list\\<rbrakk>\n       \\<Longrightarrow> (B @ [length S]) ! 0 = 0\n 3. distinct S \\<and> v \\<notin> set S\n 4. \\<And>va j.\n       (va = v \\<longrightarrow>\n        (length S = j) =\n        (j < Suc (length S) \\<and> v = (S @ [v]) ! j)) \\<and>\n       (va \\<noteq> v \\<longrightarrow>\n        (I va = Some (STACK j)) =\n        (j < Suc (length S) \\<and> va = (S @ [v]) ! j))\n 5. (succs = {} \\<longrightarrow> sorted (map fst P)) \\<and>\n    (succs \\<noteq> {} \\<longrightarrow> sorted (map fst P @ [length S]))\n 6. (succs = {} \\<longrightarrow> distinct (map fst P)) \\<and>\n    (succs \\<noteq> {} \\<longrightarrow>\n     distinct (map fst P) \\<and> length S \\<notin> fst ` set P)\n 7. set P \\<subseteq> {0..<Suc (length S)} \\<times> {y. {} \\<noteq> y}", "apply (auto simp: nth_append) [2]"], ["proof (prove)\ngoal (5 subgoals):\n 1. distinct S \\<and> v \\<notin> set S\n 2. \\<And>va j.\n       (va = v \\<longrightarrow>\n        (length S = j) =\n        (j < Suc (length S) \\<and> v = (S @ [v]) ! j)) \\<and>\n       (va \\<noteq> v \\<longrightarrow>\n        (I va = Some (STACK j)) =\n        (j < Suc (length S) \\<and> va = (S @ [v]) ! j))\n 3. (succs = {} \\<longrightarrow> sorted (map fst P)) \\<and>\n    (succs \\<noteq> {} \\<longrightarrow> sorted (map fst P @ [length S]))\n 4. (succs = {} \\<longrightarrow> distinct (map fst P)) \\<and>\n    (succs \\<noteq> {} \\<longrightarrow>\n     distinct (map fst P) \\<and> length S \\<notin> fst ` set P)\n 5. set P \\<subseteq> {0..<Suc (length S)} \\<times> {y. {} \\<noteq> y}", "using S_distinct A"], ["proof (prove)\nusing this:\n  distinct S\n  v \\<notin> \\<Union> (set p_\\<alpha>)\n\ngoal (5 subgoals):\n 1. distinct S \\<and> v \\<notin> set S\n 2. \\<And>va j.\n       (va = v \\<longrightarrow>\n        (length S = j) =\n        (j < Suc (length S) \\<and> v = (S @ [v]) ! j)) \\<and>\n       (va \\<noteq> v \\<longrightarrow>\n        (I va = Some (STACK j)) =\n        (j < Suc (length S) \\<and> va = (S @ [v]) ! j))\n 3. (succs = {} \\<longrightarrow> sorted (map fst P)) \\<and>\n    (succs \\<noteq> {} \\<longrightarrow> sorted (map fst P @ [length S]))\n 4. (succs = {} \\<longrightarrow> distinct (map fst P)) \\<and>\n    (succs \\<noteq> {} \\<longrightarrow>\n     distinct (map fst P) \\<and> length S \\<notin> fst ` set P)\n 5. set P \\<subseteq> {0..<Suc (length S)} \\<times> {y. {} \\<noteq> y}", "apply (simp add: set_p_\\<alpha>_is_set_S)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>va j.\n       (va = v \\<longrightarrow>\n        (length S = j) =\n        (j < Suc (length S) \\<and> v = (S @ [v]) ! j)) \\<and>\n       (va \\<noteq> v \\<longrightarrow>\n        (I va = Some (STACK j)) =\n        (j < Suc (length S) \\<and> va = (S @ [v]) ! j))\n 2. (succs = {} \\<longrightarrow> sorted (map fst P)) \\<and>\n    (succs \\<noteq> {} \\<longrightarrow> sorted (map fst P @ [length S]))\n 3. (succs = {} \\<longrightarrow> distinct (map fst P)) \\<and>\n    (succs \\<noteq> {} \\<longrightarrow>\n     distinct (map fst P) \\<and> length S \\<notin> fst ` set P)\n 4. set P \\<subseteq> {0..<Suc (length S)} \\<times> {y. {} \\<noteq> y}", "using A I_consistent"], ["proof (prove)\nusing this:\n  v \\<notin> \\<Union> (set p_\\<alpha>)\n  (I ?v = Some (STACK ?j)) = (?j < length S \\<and> ?v = S ! ?j)\n\ngoal (4 subgoals):\n 1. \\<And>va j.\n       (va = v \\<longrightarrow>\n        (length S = j) =\n        (j < Suc (length S) \\<and> v = (S @ [v]) ! j)) \\<and>\n       (va \\<noteq> v \\<longrightarrow>\n        (I va = Some (STACK j)) =\n        (j < Suc (length S) \\<and> va = (S @ [v]) ! j))\n 2. (succs = {} \\<longrightarrow> sorted (map fst P)) \\<and>\n    (succs \\<noteq> {} \\<longrightarrow> sorted (map fst P @ [length S]))\n 3. (succs = {} \\<longrightarrow> distinct (map fst P)) \\<and>\n    (succs \\<noteq> {} \\<longrightarrow>\n     distinct (map fst P) \\<and> length S \\<notin> fst ` set P)\n 4. set P \\<subseteq> {0..<Suc (length S)} \\<times> {y. {} \\<noteq> y}", "apply (auto simp: nth_append set_p_\\<alpha>_is_set_S split: if_split_asm) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. (succs = {} \\<longrightarrow> sorted (map fst P)) \\<and>\n    (succs \\<noteq> {} \\<longrightarrow> sorted (map fst P @ [length S]))\n 2. (succs = {} \\<longrightarrow> distinct (map fst P)) \\<and>\n    (succs \\<noteq> {} \\<longrightarrow>\n     distinct (map fst P) \\<and> length S \\<notin> fst ` set P)\n 3. set P \\<subseteq> {0..<Suc (length S)} \\<times> {y. {} \\<noteq> y}", "using P_sorted P_distinct P_bound"], ["proof (prove)\nusing this:\n  sorted (map fst P)\n  distinct (map fst P)\n  set P \\<subseteq> {0..<length S} \\<times> {y. {} \\<noteq> y}\n\ngoal (3 subgoals):\n 1. (succs = {} \\<longrightarrow> sorted (map fst P)) \\<and>\n    (succs \\<noteq> {} \\<longrightarrow> sorted (map fst P @ [length S]))\n 2. (succs = {} \\<longrightarrow> distinct (map fst P)) \\<and>\n    (succs \\<noteq> {} \\<longrightarrow>\n     distinct (map fst P) \\<and> length S \\<notin> fst ` set P)\n 3. set P \\<subseteq> {0..<Suc (length S)} \\<times> {y. {} \\<noteq> y}", "apply (auto simp: sorted_append) [3]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  GS_invar (push_impl v succs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_last_out_P_aux:\n    assumes NE: \"p_\\<alpha>\\<noteq>[]\" and NS: \"pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {}\"\n    shows \"set P \\<subseteq> {0..<last B} \\<times> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set P \\<subseteq> {0..<last B} \\<times> UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set P \\<subseteq> {0..<last B} \\<times> UNIV", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. set P \\<subseteq> {0..<last B} \\<times> UNIV", "fix j I"], ["proof (state)\ngoal (1 subgoal):\n 1. set P \\<subseteq> {0..<last B} \\<times> UNIV", "assume jII: \"(j,I)\\<in>set P\"\n        and JL: \"last B\\<le>j\""], ["proof (state)\nthis:\n  (j, I) \\<in> set P\n  last B \\<le> j\n\ngoal (1 subgoal):\n 1. set P \\<subseteq> {0..<last B} \\<times> UNIV", "with P_bound"], ["proof (chain)\npicking this:\n  set P \\<subseteq> {0..<length S} \\<times> {y. {} \\<noteq> y}\n  (j, I) \\<in> set P\n  last B \\<le> j", "have JU: \"j<length S\" and INE: \"I\\<noteq>{}\""], ["proof (prove)\nusing this:\n  set P \\<subseteq> {0..<length S} \\<times> {y. {} \\<noteq> y}\n  (j, I) \\<in> set P\n  last B \\<le> j\n\ngoal (1 subgoal):\n 1. j < length S &&& I \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  j < length S\n  I \\<noteq> {}\n\ngoal (1 subgoal):\n 1. set P \\<subseteq> {0..<last B} \\<times> UNIV", "with JL JU"], ["proof (chain)\npicking this:\n  last B \\<le> j\n  j < length S\n  j < length S\n  I \\<noteq> {}", "have \"S!j \\<in> last p_\\<alpha>\""], ["proof (prove)\nusing this:\n  last B \\<le> j\n  j < length S\n  j < length S\n  I \\<noteq> {}\n\ngoal (1 subgoal):\n 1. S ! j \\<in> last p_\\<alpha>", "using NE"], ["proof (prove)\nusing this:\n  last B \\<le> j\n  j < length S\n  j < length S\n  I \\<noteq> {}\n  p_\\<alpha> \\<noteq> []\n\ngoal (1 subgoal):\n 1. S ! j \\<in> last p_\\<alpha>", "unfolding p_\\<alpha>_def"], ["proof (prove)\nusing this:\n  last B \\<le> j\n  j < length S\n  j < length S\n  I \\<noteq> {}\n  map seg [0..<length B] \\<noteq> []\n\ngoal (1 subgoal):\n 1. S ! j \\<in> last (map seg [0..<length B])", "apply (auto \n          simp: last_map seg_def seg_start_def seg_end_def last_conv_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  S ! j \\<in> last p_\\<alpha>\n\ngoal (1 subgoal):\n 1. set P \\<subseteq> {0..<last B} \\<times> UNIV", "moreover"], ["proof (state)\nthis:\n  S ! j \\<in> last p_\\<alpha>\n\ngoal (1 subgoal):\n 1. set P \\<subseteq> {0..<last B} \\<times> UNIV", "from jII"], ["proof (chain)\npicking this:\n  (j, I) \\<in> set P", "have \"{S!j} \\<times> I \\<subseteq> pE_\\<alpha>\""], ["proof (prove)\nusing this:\n  (j, I) \\<in> set P\n\ngoal (1 subgoal):\n 1. {S ! j} \\<times> I \\<subseteq> pE_\\<alpha>", "unfolding pE_\\<alpha>_def"], ["proof (prove)\nusing this:\n  (j, I) \\<in> set P\n\ngoal (1 subgoal):\n 1. {S ! j} \\<times> I\n    \\<subseteq> {(u, v).\n                 \\<exists>j I.\n                    (j, I) \\<in> set P \\<and> u = S ! j \\<and> v \\<in> I}", "by auto"], ["proof (state)\nthis:\n  {S ! j} \\<times> I \\<subseteq> pE_\\<alpha>\n\ngoal (1 subgoal):\n 1. set P \\<subseteq> {0..<last B} \\<times> UNIV", "moreover"], ["proof (state)\nthis:\n  {S ! j} \\<times> I \\<subseteq> pE_\\<alpha>\n\ngoal (1 subgoal):\n 1. set P \\<subseteq> {0..<last B} \\<times> UNIV", "note INE NS"], ["proof (state)\nthis:\n  I \\<noteq> {}\n  pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {}\n\ngoal (1 subgoal):\n 1. set P \\<subseteq> {0..<last B} \\<times> UNIV", "ultimately"], ["proof (chain)\npicking this:\n  S ! j \\<in> last p_\\<alpha>\n  {S ! j} \\<times> I \\<subseteq> pE_\\<alpha>\n  I \\<noteq> {}\n  pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {}", "have False"], ["proof (prove)\nusing this:\n  S ! j \\<in> last p_\\<alpha>\n  {S ! j} \\<times> I \\<subseteq> pE_\\<alpha>\n  I \\<noteq> {}\n  pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {}\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. set P \\<subseteq> {0..<last B} \\<times> UNIV", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?j2, ?I2) \\<in> set P; last B \\<le> ?j2\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. set P \\<subseteq> {0..<last B} \\<times> UNIV", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?j2, ?I2) \\<in> set P; last B \\<le> ?j2\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. set P \\<subseteq> {0..<last B} \\<times> UNIV", "by fastforce"], ["proof (state)\nthis:\n  set P \\<subseteq> {0..<last B} \\<times> UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pop_correct:\n    assumes NE: \"p_\\<alpha>\\<noteq>[]\" and NS: \"pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {}\"\n    shows \"pop_impl \n      \\<le> \\<Down>GS_rel (SPEC (\\<lambda>r. r=(butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>, pE_\\<alpha>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pop_impl\n    \\<le> \\<Down> GS_rel\n           (SPEC\n             (\\<lambda>r.\n                 r =\n                 (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n                  pE_\\<alpha>)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pop_impl\n    \\<le> \\<Down> GS_rel\n           (SPEC\n             (\\<lambda>r.\n                 r =\n                 (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n                  pE_\\<alpha>)))", "have iexI: \"\\<And>a b j P. \\<lbrakk>a!j = b!j; P j\\<rbrakk> \\<Longrightarrow> \\<exists>j'. a!j = b!j' \\<and> P j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b j P.\n       \\<lbrakk>a ! j = b ! j; P j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>j'. a ! j = b ! j' \\<and> P j'", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>?a ! ?j = ?b ! ?j; ?P ?j\\<rbrakk>\n  \\<Longrightarrow> \\<exists>j'. ?a ! ?j = ?b ! j' \\<and> ?P j'\n\ngoal (1 subgoal):\n 1. pop_impl\n    \\<le> \\<Down> GS_rel\n           (SPEC\n             (\\<lambda>r.\n                 r =\n                 (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n                  pE_\\<alpha>)))", "have [simp]: \"\\<And>n. n - Suc 0 \\<noteq> n \\<longleftrightarrow> n\\<noteq>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n. (n - Suc 0 \\<noteq> n) = (n \\<noteq> 0)", "by auto"], ["proof (state)\nthis:\n  (?n1 - Suc 0 \\<noteq> ?n1) = (?n1 \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. pop_impl\n    \\<le> \\<Down> GS_rel\n           (SPEC\n             (\\<lambda>r.\n                 r =\n                 (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n                  pE_\\<alpha>)))", "from NE"], ["proof (chain)\npicking this:\n  p_\\<alpha> \\<noteq> []", "have BNE: \"B\\<noteq>[]\""], ["proof (prove)\nusing this:\n  p_\\<alpha> \\<noteq> []\n\ngoal (1 subgoal):\n 1. B \\<noteq> []", "unfolding p_\\<alpha>_def"], ["proof (prove)\nusing this:\n  map seg [0..<length B] \\<noteq> []\n\ngoal (1 subgoal):\n 1. B \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  B \\<noteq> []\n\ngoal (1 subgoal):\n 1. pop_impl\n    \\<le> \\<Down> GS_rel\n           (SPEC\n             (\\<lambda>r.\n                 r =\n                 (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n                  pE_\\<alpha>)))", "{"], ["proof (state)\nthis:\n  B \\<noteq> []\n\ngoal (1 subgoal):\n 1. pop_impl\n    \\<le> \\<Down> GS_rel\n           (SPEC\n             (\\<lambda>r.\n                 r =\n                 (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n                  pE_\\<alpha>)))", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. pop_impl\n    \\<le> \\<Down> GS_rel\n           (SPEC\n             (\\<lambda>r.\n                 r =\n                 (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n                  pE_\\<alpha>)))", "assume B: \"j<B!i\" and A: \"i<length B\""], ["proof (state)\nthis:\n  j < B ! i\n  i < length B\n\ngoal (1 subgoal):\n 1. pop_impl\n    \\<le> \\<Down> GS_rel\n           (SPEC\n             (\\<lambda>r.\n                 r =\n                 (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n                  pE_\\<alpha>)))", "note B"], ["proof (state)\nthis:\n  j < B ! i\n\ngoal (1 subgoal):\n 1. pop_impl\n    \\<le> \\<Down> GS_rel\n           (SPEC\n             (\\<lambda>r.\n                 r =\n                 (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n                  pE_\\<alpha>)))", "also"], ["proof (state)\nthis:\n  j < B ! i\n\ngoal (1 subgoal):\n 1. pop_impl\n    \\<le> \\<Down> GS_rel\n           (SPEC\n             (\\<lambda>r.\n                 r =\n                 (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n                  pE_\\<alpha>)))", "from sorted_nth_mono[OF B_sorted, of i \"length B - 1\"] A"], ["proof (chain)\npicking this:\n  \\<lbrakk>i \\<le> length B - 1; length B - 1 < length B\\<rbrakk>\n  \\<Longrightarrow> B ! i \\<le> B ! (length B - 1)\n  i < length B", "have \"B!i \\<le> last B\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i \\<le> length B - 1; length B - 1 < length B\\<rbrakk>\n  \\<Longrightarrow> B ! i \\<le> B ! (length B - 1)\n  i < length B\n\ngoal (1 subgoal):\n 1. B ! i \\<le> last B", "by (simp add: last_conv_nth)"], ["proof (state)\nthis:\n  B ! i \\<le> last B\n\ngoal (1 subgoal):\n 1. pop_impl\n    \\<le> \\<Down> GS_rel\n           (SPEC\n             (\\<lambda>r.\n                 r =\n                 (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n                  pE_\\<alpha>)))", "finally"], ["proof (chain)\npicking this:\n  j < last B", "have \"j < last B\""], ["proof (prove)\nusing this:\n  j < last B\n\ngoal (1 subgoal):\n 1. j < last B", "."], ["proof (state)\nthis:\n  j < last B\n\ngoal (1 subgoal):\n 1. pop_impl\n    \\<le> \\<Down> GS_rel\n           (SPEC\n             (\\<lambda>r.\n                 r =\n                 (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n                  pE_\\<alpha>)))", "hence \"take (last B) S ! j = S ! j\" \n        and \"take (B!(length B - Suc 0)) S !j = S!j\""], ["proof (prove)\nusing this:\n  j < last B\n\ngoal (1 subgoal):\n 1. take (last B) S ! j = S ! j &&&\n    take (B ! (length B - Suc 0)) S ! j = S ! j", "by (simp_all add: last_conv_nth BNE)"], ["proof (state)\nthis:\n  take (last B) S ! j = S ! j\n  take (B ! (length B - Suc 0)) S ! j = S ! j\n\ngoal (1 subgoal):\n 1. pop_impl\n    \\<le> \\<Down> GS_rel\n           (SPEC\n             (\\<lambda>r.\n                 r =\n                 (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n                  pE_\\<alpha>)))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?j3 < B ! ?i3; ?i3 < length B\\<rbrakk>\n  \\<Longrightarrow> take (last B) S ! ?j3 = S ! ?j3\n  \\<lbrakk>?j3 < B ! ?i3; ?i3 < length B\\<rbrakk>\n  \\<Longrightarrow> take (B ! (length B - Suc 0)) S ! ?j3 = S ! ?j3\n\ngoal (1 subgoal):\n 1. pop_impl\n    \\<le> \\<Down> GS_rel\n           (SPEC\n             (\\<lambda>r.\n                 r =\n                 (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n                  pE_\\<alpha>)))", "note AUX1=this"], ["proof (state)\nthis:\n  \\<lbrakk>?j3 < B ! ?i3; ?i3 < length B\\<rbrakk>\n  \\<Longrightarrow> take (last B) S ! ?j3 = S ! ?j3\n  \\<lbrakk>?j3 < B ! ?i3; ?i3 < length B\\<rbrakk>\n  \\<Longrightarrow> take (B ! (length B - Suc 0)) S ! ?j3 = S ! ?j3\n\ngoal (1 subgoal):\n 1. pop_impl\n    \\<le> \\<Down> GS_rel\n           (SPEC\n             (\\<lambda>r.\n                 r =\n                 (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n                  pE_\\<alpha>)))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?j3 < B ! ?i3; ?i3 < length B\\<rbrakk>\n  \\<Longrightarrow> take (last B) S ! ?j3 = S ! ?j3\n  \\<lbrakk>?j3 < B ! ?i3; ?i3 < length B\\<rbrakk>\n  \\<Longrightarrow> take (B ! (length B - Suc 0)) S ! ?j3 = S ! ?j3\n\ngoal (1 subgoal):\n 1. pop_impl\n    \\<le> \\<Down> GS_rel\n           (SPEC\n             (\\<lambda>r.\n                 r =\n                 (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n                  pE_\\<alpha>)))", "fix v j"], ["proof (state)\ngoal (1 subgoal):\n 1. pop_impl\n    \\<le> \\<Down> GS_rel\n           (SPEC\n             (\\<lambda>r.\n                 r =\n                 (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n                  pE_\\<alpha>)))", "have \"(mark_as_done_abs \n              (seg_start (length B - Suc 0))\n              (seg_end (length B - Suc 0)) I v = Some (STACK j)) \n        \\<longleftrightarrow> (j < length S \\<and> j < last B \\<and> v = take (last B) S ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mark_as_done_abs (seg_start (length B - Suc 0))\n      (seg_end (length B - Suc 0)) I v =\n     Some (STACK j)) =\n    (j < length S \\<and> j < last B \\<and> v = take (last B) S ! j)", "apply (simp add: mark_as_done_abs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>j.\n         v = S ! j \\<and>\n         seg_start (length B - Suc 0) \\<le> j \\<and>\n         j < seg_end (length B - Suc 0)) \\<longrightarrow>\n     j < last B \\<longrightarrow>\n     j < length S \\<longrightarrow> v \\<noteq> S ! j) \\<and>\n    ((\\<forall>j\\<ge>seg_start (length B - Suc 0).\n         v = S ! j \\<longrightarrow>\n         \\<not> j < seg_end (length B - Suc 0)) \\<longrightarrow>\n     (I v = Some (STACK j)) =\n     (j < length S \\<and> j < last B \\<and> v = take (last B) S ! j))", "apply safe []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>ja.\n       \\<lbrakk>v = S ! ja; seg_start (length B - Suc 0) \\<le> ja;\n        ja < seg_end (length B - Suc 0); j < last B; j < length S;\n        S ! ja = S ! j\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>\\<forall>j\\<ge>seg_start (length B - Suc 0).\n                v = S ! j \\<longrightarrow>\n                \\<not> j < seg_end (length B - Suc 0);\n     I v = Some (STACK j)\\<rbrakk>\n    \\<Longrightarrow> j < length S\n 3. \\<lbrakk>\\<forall>j\\<ge>seg_start (length B - Suc 0).\n                v = S ! j \\<longrightarrow>\n                \\<not> j < seg_end (length B - Suc 0);\n     I v = Some (STACK j)\\<rbrakk>\n    \\<Longrightarrow> j < last B\n 4. \\<lbrakk>\\<forall>j\\<ge>seg_start (length B - Suc 0).\n                v = S ! j \\<longrightarrow>\n                \\<not> j < seg_end (length B - Suc 0);\n     I v = Some (STACK j)\\<rbrakk>\n    \\<Longrightarrow> v = take (last B) S ! j\n 5. \\<lbrakk>\\<forall>ja\\<ge>seg_start (length B - Suc 0).\n                take (last B) S ! j = S ! ja \\<longrightarrow>\n                \\<not> ja < seg_end (length B - Suc 0);\n     j < length S; j < last B; v = take (last B) S ! j\\<rbrakk>\n    \\<Longrightarrow> I (take (last B) S ! j) = Some (STACK j)", "using I_consistent"], ["proof (prove)\nusing this:\n  (I ?v = Some (STACK ?j)) = (?j < length S \\<and> ?v = S ! ?j)\n\ngoal (5 subgoals):\n 1. \\<And>ja.\n       \\<lbrakk>v = S ! ja; seg_start (length B - Suc 0) \\<le> ja;\n        ja < seg_end (length B - Suc 0); j < last B; j < length S;\n        S ! ja = S ! j\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>\\<forall>j\\<ge>seg_start (length B - Suc 0).\n                v = S ! j \\<longrightarrow>\n                \\<not> j < seg_end (length B - Suc 0);\n     I v = Some (STACK j)\\<rbrakk>\n    \\<Longrightarrow> j < length S\n 3. \\<lbrakk>\\<forall>j\\<ge>seg_start (length B - Suc 0).\n                v = S ! j \\<longrightarrow>\n                \\<not> j < seg_end (length B - Suc 0);\n     I v = Some (STACK j)\\<rbrakk>\n    \\<Longrightarrow> j < last B\n 4. \\<lbrakk>\\<forall>j\\<ge>seg_start (length B - Suc 0).\n                v = S ! j \\<longrightarrow>\n                \\<not> j < seg_end (length B - Suc 0);\n     I v = Some (STACK j)\\<rbrakk>\n    \\<Longrightarrow> v = take (last B) S ! j\n 5. \\<lbrakk>\\<forall>ja\\<ge>seg_start (length B - Suc 0).\n                take (last B) S ! j = S ! ja \\<longrightarrow>\n                \\<not> ja < seg_end (length B - Suc 0);\n     j < length S; j < last B; v = take (last B) S ! j\\<rbrakk>\n    \\<Longrightarrow> I (take (last B) S ! j) = Some (STACK j)", "apply (clarsimp_all\n          simp: seg_start_def seg_end_def last_conv_nth BNE\n          simp: S_idx_uniq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>ja\\<ge>B ! (length B - Suc 0).\n                S ! j = S ! ja \\<longrightarrow> \\<not> ja < length S;\n     \\<And>v j. (I v = Some (STACK j)) = (j < length S \\<and> v = S ! j);\n     j < length S; v = S ! j\\<rbrakk>\n    \\<Longrightarrow> j < B ! (length B - Suc 0)\n 2. \\<lbrakk>\\<forall>ja\\<ge>B ! (length B - Suc 0).\n                S ! j = S ! ja \\<longrightarrow> \\<not> ja < length S;\n     \\<And>v j. (I v = Some (STACK j)) = (j < length S \\<and> v = S ! j);\n     j < length S; v = S ! j\\<rbrakk>\n    \\<Longrightarrow> S ! j = take (B ! (length B - Suc 0)) S ! j", "apply (force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ja\\<ge>B ! (length B - Suc 0).\n                S ! j = S ! ja \\<longrightarrow> \\<not> ja < length S;\n     \\<And>v j. (I v = Some (STACK j)) = (j < length S \\<and> v = S ! j);\n     j < length S; v = S ! j\\<rbrakk>\n    \\<Longrightarrow> S ! j = take (B ! (length B - Suc 0)) S ! j", "apply (subst nth_take)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>ja\\<ge>B ! (length B - Suc 0).\n                S ! j = S ! ja \\<longrightarrow> \\<not> ja < length S;\n     \\<And>v j. (I v = Some (STACK j)) = (j < length S \\<and> v = S ! j);\n     j < length S; v = S ! j\\<rbrakk>\n    \\<Longrightarrow> j < B ! (length B - Suc 0)\n 2. \\<lbrakk>\\<forall>ja\\<ge>B ! (length B - Suc 0).\n                S ! j = S ! ja \\<longrightarrow> \\<not> ja < length S;\n     \\<And>v j. (I v = Some (STACK j)) = (j < length S \\<and> v = S ! j);\n     j < length S; v = S ! j\\<rbrakk>\n    \\<Longrightarrow> S ! j = S ! j", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ja\\<ge>B ! (length B - Suc 0).\n                S ! j = S ! ja \\<longrightarrow> \\<not> ja < length S;\n     \\<And>v j. (I v = Some (STACK j)) = (j < length S \\<and> v = S ! j);\n     j < length S; v = S ! j\\<rbrakk>\n    \\<Longrightarrow> S ! j = S ! j", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (mark_as_done_abs (seg_start (length B - Suc 0))\n    (seg_end (length B - Suc 0)) I v =\n   Some (STACK j)) =\n  (j < length S \\<and> j < last B \\<and> v = take (last B) S ! j)\n\ngoal (1 subgoal):\n 1. pop_impl\n    \\<le> \\<Down> GS_rel\n           (SPEC\n             (\\<lambda>r.\n                 r =\n                 (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n                  pE_\\<alpha>)))", "}"], ["proof (state)\nthis:\n  (mark_as_done_abs (seg_start (length B - Suc 0))\n    (seg_end (length B - Suc 0)) I ?v3 =\n   Some (STACK ?j3)) =\n  (?j3 < length S \\<and> ?j3 < last B \\<and> ?v3 = take (last B) S ! ?j3)\n\ngoal (1 subgoal):\n 1. pop_impl\n    \\<le> \\<Down> GS_rel\n           (SPEC\n             (\\<lambda>r.\n                 r =\n                 (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n                  pE_\\<alpha>)))", "note AUX2 = this"], ["proof (state)\nthis:\n  (mark_as_done_abs (seg_start (length B - Suc 0))\n    (seg_end (length B - Suc 0)) I ?v3 =\n   Some (STACK ?j3)) =\n  (?j3 < length S \\<and> ?j3 < last B \\<and> ?v3 = take (last B) S ! ?j3)\n\ngoal (1 subgoal):\n 1. pop_impl\n    \\<le> \\<Down> GS_rel\n           (SPEC\n             (\\<lambda>r.\n                 r =\n                 (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n                  pE_\\<alpha>)))", "define ci where \"ci = ( \n      take (last B) S, \n      butlast B,\n      mark_as_done_abs \n        (seg_start (length B - Suc 0)) (seg_end (length B - Suc 0)) I,\n      P)\""], ["proof (state)\nthis:\n  ci =\n  (take (last B) S, butlast B,\n   mark_as_done_abs (seg_start (length B - Suc 0))\n    (seg_end (length B - Suc 0)) I,\n   P)\n\ngoal (1 subgoal):\n 1. pop_impl\n    \\<le> \\<Down> GS_rel\n           (SPEC\n             (\\<lambda>r.\n                 r =\n                 (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n                  pE_\\<alpha>)))", "have ABS: \"GS.\\<alpha> ci = (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>, pE_\\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GS.\\<alpha> ci =\n    (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>, pE_\\<alpha>)", "apply (simp add: GS.\\<alpha>_def ci_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. GS.p_\\<alpha>\n     (take (last B) S, butlast B,\n      mark_as_done_abs (seg_start (length B - Suc 0))\n       (seg_end (length B - Suc 0)) I,\n      P) =\n    butlast p_\\<alpha> \\<and>\n    GS.D_\\<alpha>\n     (take (last B) S, butlast B,\n      mark_as_done_abs (seg_start (length B - Suc 0))\n       (seg_end (length B - Suc 0)) I,\n      P) =\n    D_\\<alpha> \\<union> last p_\\<alpha> \\<and>\n    GS.pE_\\<alpha>\n     (take (last B) S, butlast B,\n      mark_as_done_abs (seg_start (length B - Suc 0))\n       (seg_end (length B - Suc 0)) I,\n      P) =\n    pE_\\<alpha>", "apply (intro conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. GS.p_\\<alpha>\n     (take (last B) S, butlast B,\n      mark_as_done_abs (seg_start (length B - Suc 0))\n       (seg_end (length B - Suc 0)) I,\n      P) =\n    butlast p_\\<alpha>\n 2. GS.D_\\<alpha>\n     (take (last B) S, butlast B,\n      mark_as_done_abs (seg_start (length B - Suc 0))\n       (seg_end (length B - Suc 0)) I,\n      P) =\n    D_\\<alpha> \\<union> last p_\\<alpha>\n 3. GS.pE_\\<alpha>\n     (take (last B) S, butlast B,\n      mark_as_done_abs (seg_start (length B - Suc 0))\n       (seg_end (length B - Suc 0)) I,\n      P) =\n    pE_\\<alpha>", "apply (auto  \n        simp del: map_butlast\n        simp add: map_butlast[symmetric] butlast_upt\n        simp add: GS.p_\\<alpha>_def GS.seg_def[abs_def] GS.seg_start_def GS.seg_end_def\n        simp: nth_butlast last_conv_nth nth_take AUX1\n        cong: if_cong\n        intro!: iexI\n        dest: order.strict_trans[OF _ B_in_bound']\n      ) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. GS.D_\\<alpha>\n     (take (last B) S, butlast B,\n      mark_as_done_abs (seg_start (length B - Suc 0))\n       (seg_end (length B - Suc 0)) I,\n      P) =\n    D_\\<alpha> \\<union> last p_\\<alpha>\n 2. GS.pE_\\<alpha>\n     (take (last B) S, butlast B,\n      mark_as_done_abs (seg_start (length B - Suc 0))\n       (seg_end (length B - Suc 0)) I,\n      P) =\n    pE_\\<alpha>", "apply (auto \n        simp: GS.D_\\<alpha>_def p_\\<alpha>_def last_map BNE seg_def mark_as_done_abs_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. GS.pE_\\<alpha>\n     (take (last B) S, butlast B,\n      mark_as_done_abs (seg_start (length B - Suc 0))\n       (seg_end (length B - Suc 0)) I,\n      P) =\n    pE_\\<alpha>", "using AUX1 no_last_out_P_aux[OF NE NS]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?j3 < B ! ?i3; ?i3 < length B\\<rbrakk>\n  \\<Longrightarrow> take (last B) S ! ?j3 = S ! ?j3\n  \\<lbrakk>?j3 < B ! ?i3; ?i3 < length B\\<rbrakk>\n  \\<Longrightarrow> take (B ! (length B - Suc 0)) S ! ?j3 = S ! ?j3\n  set P \\<subseteq> {0..<last B} \\<times> UNIV\n\ngoal (1 subgoal):\n 1. GS.pE_\\<alpha>\n     (take (last B) S, butlast B,\n      mark_as_done_abs (seg_start (length B - Suc 0))\n       (seg_end (length B - Suc 0)) I,\n      P) =\n    pE_\\<alpha>", "apply (auto simp: GS.pE_\\<alpha>_def mark_as_done_abs_def elim!: bex2I) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  GS.\\<alpha> ci =\n  (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>, pE_\\<alpha>)\n\ngoal (1 subgoal):\n 1. pop_impl\n    \\<le> \\<Down> GS_rel\n           (SPEC\n             (\\<lambda>r.\n                 r =\n                 (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n                  pE_\\<alpha>)))", "have INV: \"GS_invar ci\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GS_invar ci", "apply unfold_locales"], ["proof (prove)\ngoal (9 subgoals):\n 1. set (GS.B ci) \\<subseteq> {0..<length (GS.S ci)}\n 2. sorted (GS.B ci)\n 3. distinct (GS.B ci)\n 4. GS.S ci \\<noteq> [] \\<Longrightarrow>\n    GS.B ci \\<noteq> [] \\<and> GS.B ci ! 0 = 0\n 5. distinct (GS.S ci)\n 6. \\<And>v j.\n       (GS.I ci v = Some (STACK j)) =\n       (j < length (GS.S ci) \\<and> v = GS.S ci ! j)\n 7. sorted (map fst (GS.P ci))\n 8. distinct (map fst (GS.P ci))\n 9. set (GS.P ci)\n    \\<subseteq> {0..<length (GS.S ci)} \\<times> {y. {} \\<noteq> y}", "apply (simp_all add: ci_def)"], ["proof (prove)\ngoal (9 subgoals):\n 1. set (butlast B) \\<subseteq> {0..<min (length S) (last B)}\n 2. sorted (butlast B)\n 3. distinct (butlast B)\n 4. 0 < last B \\<and> S \\<noteq> [] \\<Longrightarrow>\n    butlast B \\<noteq> [] \\<and> butlast B ! 0 = 0\n 5. distinct (take (last B) S)\n 6. \\<And>v j.\n       (mark_as_done_abs (seg_start (length B - Suc 0))\n         (seg_end (length B - Suc 0)) I v =\n        Some (STACK j)) =\n       (j < length S \\<and> j < last B \\<and> v = take (last B) S ! j)\n 7. sorted (map fst P)\n 8. distinct (map fst P)\n 9. set P\n    \\<subseteq> {0..<min (length S) (last B)} \\<times> {y. {} \\<noteq> y}", "using B_in_bound B_sorted B_distinct"], ["proof (prove)\nusing this:\n  set B \\<subseteq> {0..<length S}\n  sorted B\n  distinct B\n\ngoal (9 subgoals):\n 1. set (butlast B) \\<subseteq> {0..<min (length S) (last B)}\n 2. sorted (butlast B)\n 3. distinct (butlast B)\n 4. 0 < last B \\<and> S \\<noteq> [] \\<Longrightarrow>\n    butlast B \\<noteq> [] \\<and> butlast B ! 0 = 0\n 5. distinct (take (last B) S)\n 6. \\<And>v j.\n       (mark_as_done_abs (seg_start (length B - Suc 0))\n         (seg_end (length B - Suc 0)) I v =\n        Some (STACK j)) =\n       (j < length S \\<and> j < last B \\<and> v = take (last B) S ! j)\n 7. sorted (map fst P)\n 8. distinct (map fst P)\n 9. set P\n    \\<subseteq> {0..<min (length S) (last B)} \\<times> {y. {} \\<noteq> y}", "apply (cases B rule: rev_cases, simp)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>ys y.\n       \\<lbrakk>set B \\<subseteq> {0..<length S}; sorted B; distinct B;\n        B = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> set (butlast B)\n                         \\<subseteq> {0..<min (length S) (last B)}\n 2. sorted (butlast B)\n 3. distinct (butlast B)\n 4. 0 < last B \\<and> S \\<noteq> [] \\<Longrightarrow>\n    butlast B \\<noteq> [] \\<and> butlast B ! 0 = 0\n 5. distinct (take (last B) S)\n 6. \\<And>v j.\n       (mark_as_done_abs (seg_start (length B - Suc 0))\n         (seg_end (length B - Suc 0)) I v =\n        Some (STACK j)) =\n       (j < length S \\<and> j < last B \\<and> v = take (last B) S ! j)\n 7. sorted (map fst P)\n 8. distinct (map fst P)\n 9. set P\n    \\<subseteq> {0..<min (length S) (last B)} \\<times> {y. {} \\<noteq> y}", "apply (auto simp: sorted_append order.strict_iff_order) []"], ["proof (prove)\ngoal (8 subgoals):\n 1. sorted (butlast B)\n 2. distinct (butlast B)\n 3. 0 < last B \\<and> S \\<noteq> [] \\<Longrightarrow>\n    butlast B \\<noteq> [] \\<and> butlast B ! 0 = 0\n 4. distinct (take (last B) S)\n 5. \\<And>v j.\n       (mark_as_done_abs (seg_start (length B - Suc 0))\n         (seg_end (length B - Suc 0)) I v =\n        Some (STACK j)) =\n       (j < length S \\<and> j < last B \\<and> v = take (last B) S ! j)\n 6. sorted (map fst P)\n 7. distinct (map fst P)\n 8. set P\n    \\<subseteq> {0..<min (length S) (last B)} \\<times> {y. {} \\<noteq> y}", "using B_sorted BNE"], ["proof (prove)\nusing this:\n  sorted B\n  B \\<noteq> []\n\ngoal (8 subgoals):\n 1. sorted (butlast B)\n 2. distinct (butlast B)\n 3. 0 < last B \\<and> S \\<noteq> [] \\<Longrightarrow>\n    butlast B \\<noteq> [] \\<and> butlast B ! 0 = 0\n 4. distinct (take (last B) S)\n 5. \\<And>v j.\n       (mark_as_done_abs (seg_start (length B - Suc 0))\n         (seg_end (length B - Suc 0)) I v =\n        Some (STACK j)) =\n       (j < length S \\<and> j < last B \\<and> v = take (last B) S ! j)\n 6. sorted (map fst P)\n 7. distinct (map fst P)\n 8. set P\n    \\<subseteq> {0..<min (length S) (last B)} \\<times> {y. {} \\<noteq> y}", "apply (auto simp: sorted_butlast) []"], ["proof (prove)\ngoal (7 subgoals):\n 1. distinct (butlast B)\n 2. 0 < last B \\<and> S \\<noteq> [] \\<Longrightarrow>\n    butlast B \\<noteq> [] \\<and> butlast B ! 0 = 0\n 3. distinct (take (last B) S)\n 4. \\<And>v j.\n       (mark_as_done_abs (seg_start (length B - Suc 0))\n         (seg_end (length B - Suc 0)) I v =\n        Some (STACK j)) =\n       (j < length S \\<and> j < last B \\<and> v = take (last B) S ! j)\n 5. sorted (map fst P)\n 6. distinct (map fst P)\n 7. set P\n    \\<subseteq> {0..<min (length S) (last B)} \\<times> {y. {} \\<noteq> y}", "using B_distinct BNE"], ["proof (prove)\nusing this:\n  distinct B\n  B \\<noteq> []\n\ngoal (7 subgoals):\n 1. distinct (butlast B)\n 2. 0 < last B \\<and> S \\<noteq> [] \\<Longrightarrow>\n    butlast B \\<noteq> [] \\<and> butlast B ! 0 = 0\n 3. distinct (take (last B) S)\n 4. \\<And>v j.\n       (mark_as_done_abs (seg_start (length B - Suc 0))\n         (seg_end (length B - Suc 0)) I v =\n        Some (STACK j)) =\n       (j < length S \\<and> j < last B \\<and> v = take (last B) S ! j)\n 5. sorted (map fst P)\n 6. distinct (map fst P)\n 7. set P\n    \\<subseteq> {0..<min (length S) (last B)} \\<times> {y. {} \\<noteq> y}", "apply (auto simp: distinct_butlast) []"], ["proof (prove)\ngoal (6 subgoals):\n 1. 0 < last B \\<and> S \\<noteq> [] \\<Longrightarrow>\n    butlast B \\<noteq> [] \\<and> butlast B ! 0 = 0\n 2. distinct (take (last B) S)\n 3. \\<And>v j.\n       (mark_as_done_abs (seg_start (length B - Suc 0))\n         (seg_end (length B - Suc 0)) I v =\n        Some (STACK j)) =\n       (j < length S \\<and> j < last B \\<and> v = take (last B) S ! j)\n 4. sorted (map fst P)\n 5. distinct (map fst P)\n 6. set P\n    \\<subseteq> {0..<min (length S) (last B)} \\<times> {y. {} \\<noteq> y}", "using B0"], ["proof (prove)\nusing this:\n  S \\<noteq> [] \\<Longrightarrow> B \\<noteq> [] \\<and> B ! 0 = 0\n\ngoal (6 subgoals):\n 1. 0 < last B \\<and> S \\<noteq> [] \\<Longrightarrow>\n    butlast B \\<noteq> [] \\<and> butlast B ! 0 = 0\n 2. distinct (take (last B) S)\n 3. \\<And>v j.\n       (mark_as_done_abs (seg_start (length B - Suc 0))\n         (seg_end (length B - Suc 0)) I v =\n        Some (STACK j)) =\n       (j < length S \\<and> j < last B \\<and> v = take (last B) S ! j)\n 4. sorted (map fst P)\n 5. distinct (map fst P)\n 6. set P\n    \\<subseteq> {0..<min (length S) (last B)} \\<times> {y. {} \\<noteq> y}", "apply (cases B rule: rev_cases, simp add: BNE)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>ys y.\n       \\<lbrakk>0 < last B \\<and> S \\<noteq> [];\n        S \\<noteq> [] \\<Longrightarrow> B \\<noteq> [] \\<and> B ! 0 = 0;\n        B = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> butlast B \\<noteq> [] \\<and> butlast B ! 0 = 0\n 2. distinct (take (last B) S)\n 3. \\<And>v j.\n       (mark_as_done_abs (seg_start (length B - Suc 0))\n         (seg_end (length B - Suc 0)) I v =\n        Some (STACK j)) =\n       (j < length S \\<and> j < last B \\<and> v = take (last B) S ! j)\n 4. sorted (map fst P)\n 5. distinct (map fst P)\n 6. set P\n    \\<subseteq> {0..<min (length S) (last B)} \\<times> {y. {} \\<noteq> y}", "apply (auto simp: nth_append split: if_split_asm) []"], ["proof (prove)\ngoal (5 subgoals):\n 1. distinct (take (last B) S)\n 2. \\<And>v j.\n       (mark_as_done_abs (seg_start (length B - Suc 0))\n         (seg_end (length B - Suc 0)) I v =\n        Some (STACK j)) =\n       (j < length S \\<and> j < last B \\<and> v = take (last B) S ! j)\n 3. sorted (map fst P)\n 4. distinct (map fst P)\n 5. set P\n    \\<subseteq> {0..<min (length S) (last B)} \\<times> {y. {} \\<noteq> y}", "using S_distinct"], ["proof (prove)\nusing this:\n  distinct S\n\ngoal (5 subgoals):\n 1. distinct (take (last B) S)\n 2. \\<And>v j.\n       (mark_as_done_abs (seg_start (length B - Suc 0))\n         (seg_end (length B - Suc 0)) I v =\n        Some (STACK j)) =\n       (j < length S \\<and> j < last B \\<and> v = take (last B) S ! j)\n 3. sorted (map fst P)\n 4. distinct (map fst P)\n 5. set P\n    \\<subseteq> {0..<min (length S) (last B)} \\<times> {y. {} \\<noteq> y}", "apply (auto) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v j.\n       (mark_as_done_abs (seg_start (length B - Suc 0))\n         (seg_end (length B - Suc 0)) I v =\n        Some (STACK j)) =\n       (j < length S \\<and> j < last B \\<and> v = take (last B) S ! j)\n 2. sorted (map fst P)\n 3. distinct (map fst P)\n 4. set P\n    \\<subseteq> {0..<min (length S) (last B)} \\<times> {y. {} \\<noteq> y}", "apply (rule AUX2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. sorted (map fst P)\n 2. distinct (map fst P)\n 3. set P\n    \\<subseteq> {0..<min (length S) (last B)} \\<times> {y. {} \\<noteq> y}", "using P_sorted P_distinct"], ["proof (prove)\nusing this:\n  sorted (map fst P)\n  distinct (map fst P)\n\ngoal (3 subgoals):\n 1. sorted (map fst P)\n 2. distinct (map fst P)\n 3. set P\n    \\<subseteq> {0..<min (length S) (last B)} \\<times> {y. {} \\<noteq> y}", "apply (auto) [2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. set P\n    \\<subseteq> {0..<min (length S) (last B)} \\<times> {y. {} \\<noteq> y}", "using P_bound no_last_out_P_aux[OF NE NS]"], ["proof (prove)\nusing this:\n  set P \\<subseteq> {0..<length S} \\<times> {y. {} \\<noteq> y}\n  set P \\<subseteq> {0..<last B} \\<times> UNIV\n\ngoal (1 subgoal):\n 1. set P\n    \\<subseteq> {0..<min (length S) (last B)} \\<times> {y. {} \\<noteq> y}", "apply (auto simp: in_set_conv_decomp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  GS_invar ci\n\ngoal (1 subgoal):\n 1. pop_impl\n    \\<le> \\<Down> GS_rel\n           (SPEC\n             (\\<lambda>r.\n                 r =\n                 (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n                  pE_\\<alpha>)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. pop_impl\n    \\<le> \\<Down> GS_rel\n           (SPEC\n             (\\<lambda>r.\n                 r =\n                 (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n                  pE_\\<alpha>)))", "unfolding pop_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let lsi = length B - 1\n     in ASSERT (lsi < length B) \\<bind>\n        (\\<lambda>_.\n            mark_as_done (seg_start lsi) (seg_end lsi) I \\<bind>\n            (\\<lambda>I.\n                ASSERT (B \\<noteq> []) \\<bind>\n                (\\<lambda>_.\n                    let S = take (last B) S\n                    in ASSERT (B \\<noteq> []) \\<bind>\n                       (\\<lambda>_.\n                           let B = butlast B in RETURN (S, B, I, P))))))\n    \\<le> \\<Down> GS_rel\n           (SPEC\n             (\\<lambda>r.\n                 r =\n                 (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n                  pE_\\<alpha>)))", "apply (refine_rcg \n        SPEC_refine refine_vcg order_trans[OF mark_as_done_aux])"], ["proof (prove)\ngoal (5 subgoals):\n 1. length B - 1 < length B\n 2. length B - 1 < length B \\<Longrightarrow>\n    seg_start (length B - 1) < seg_end (length B - 1)\n 3. length B - 1 < length B \\<Longrightarrow>\n    seg_end (length B - 1) \\<le> length S\n 4. \\<And>x.\n       \\<lbrakk>length B - 1 < length B;\n        x =\n        mark_as_done_abs (seg_start (length B - 1)) (seg_end (length B - 1))\n         I\\<rbrakk>\n       \\<Longrightarrow> B \\<noteq> []\n 5. \\<And>x.\n       \\<lbrakk>length B - 1 < length B;\n        x =\n        mark_as_done_abs (seg_start (length B - 1)) (seg_end (length B - 1))\n         I;\n        B \\<noteq> []; B \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x'.\n                            ((take (last B) S, butlast B, x, P), x')\n                            \\<in> GS_rel \\<and>\n                            x' =\n                            (butlast p_\\<alpha>,\n                             D_\\<alpha> \\<union> last p_\\<alpha>,\n                             pE_\\<alpha>)", "apply (simp_all add: BNE seg_start_less_end seg_end_bound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((take (last B) S, butlast B,\n      mark_as_done_abs (seg_start (length B - Suc 0))\n       (seg_end (length B - Suc 0)) I,\n      P),\n     butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>, pE_\\<alpha>)\n    \\<in> GS_rel", "apply (fold ci_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ci, butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n     pE_\\<alpha>)\n    \\<in> GS_rel", "unfolding GS_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ci, butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n     pE_\\<alpha>)\n    \\<in> br GS.\\<alpha> GS_invar", "apply (rule brI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>, pE_\\<alpha>) =\n    GS.\\<alpha> ci\n 2. GS_invar ci", "apply (simp_all add: ABS INV)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pop_impl\n  \\<le> \\<Down> GS_rel\n         (SPEC\n           (\\<lambda>r.\n               r =\n               (butlast p_\\<alpha>, D_\\<alpha> \\<union> last p_\\<alpha>,\n                pE_\\<alpha>)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sel_rem_last_correct:\n    assumes NE: \"p_\\<alpha>\\<noteq>[]\"\n    shows\n    \"sel_rem_last \\<le> \\<Down>(Id \\<times>\\<^sub>r GS_rel) (select_edge (p_\\<alpha>,D_\\<alpha>,pE_\\<alpha>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "fix l i a b b'"], ["proof (state)\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "have \"\\<lbrakk>i<length l; l!i=(a,b)\\<rbrakk> \\<Longrightarrow> map fst (l[i:=(a,b')]) = map fst l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length l; l ! i = (a, b)\\<rbrakk>\n    \\<Longrightarrow> map fst (l[i := (a, b')]) = map fst l", "by (induct l arbitrary: i) (auto split: nat.split)"], ["proof (state)\nthis:\n  \\<lbrakk>i < length l; l ! i = (a, b)\\<rbrakk>\n  \\<Longrightarrow> map fst (l[i := (a, b')]) = map fst l\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < length ?l2; ?l2 ! ?i2 = (?a2, ?b2)\\<rbrakk>\n  \\<Longrightarrow> map fst (?l2[?i2 := (?a2, ?b'2)]) = map fst ?l2\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "note map_fst_upd_snd_eq = this"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 < length ?l2; ?l2 ! ?i2 = (?a2, ?b2)\\<rbrakk>\n  \\<Longrightarrow> map fst (?l2[?i2 := (?a2, ?b'2)]) = map fst ?l2\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "from NE"], ["proof (chain)\npicking this:\n  p_\\<alpha> \\<noteq> []", "have BNE[simp]: \"B\\<noteq>[]\""], ["proof (prove)\nusing this:\n  p_\\<alpha> \\<noteq> []\n\ngoal (1 subgoal):\n 1. B \\<noteq> []", "unfolding p_\\<alpha>_def"], ["proof (prove)\nusing this:\n  map seg [0..<length B] \\<noteq> []\n\ngoal (1 subgoal):\n 1. B \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  B \\<noteq> []\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "have INVAR: \"sel_rem_last \\<le> SPEC (GS_invar o snd)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sel_rem_last \\<le> SPEC (GS_invar \\<circ> snd)", "unfolding sel_rem_last_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if P = [] then RETURN (None, S, B, I, P)\n     else let (j, succs) = last P\n          in ASSERT (length B - 1 < length B) \\<bind>\n             (\\<lambda>_.\n                 if seg_start (length B - 1) \\<le> j\n                 then ASSERT (succs \\<noteq> {}) \\<bind>\n                      (\\<lambda>_.\n                          SPEC (\\<lambda>x. x \\<in> succs) \\<bind>\n                          (\\<lambda>v.\n                              let succs = succs - {v}\n                              in ASSERT\n                                  (P \\<noteq> [] \\<and>\n                                   length P - 1 < length P) \\<bind>\n                                 (\\<lambda>_.\n                                     let P =\n     if succs = {} then butlast P else P[length P - 1 := (j, succs)]\n                                     in RETURN (Some v, S, B, I, P))))\n                 else RETURN (None, S, B, I, P)))\n    \\<le> SPEC (GS_invar \\<circ> snd)", "apply (refine_rcg refine_vcg)"], ["proof (prove)\ngoal (6 subgoals):\n 1. P = [] \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)\n 2. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b)\\<rbrakk>\n       \\<Longrightarrow> length B - 1 < length B\n 3. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq> {}\n 4. \\<And>a b x.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b\\<rbrakk>\n       \\<Longrightarrow> length P - 1 < length P\n 5. \\<And>a b x.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - 1 < length P\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd)\n                          (Some x, S, B, I,\n                           if b - {x} = {} then butlast P\n                           else P[length P - 1 := (a, b - {x})])\n 6. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)", "using locale_this"], ["proof (prove)\nusing this:\n  GS_invar SBIP\n\ngoal (6 subgoals):\n 1. P = [] \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)\n 2. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b)\\<rbrakk>\n       \\<Longrightarrow> length B - 1 < length B\n 3. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq> {}\n 4. \\<And>a b x.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b\\<rbrakk>\n       \\<Longrightarrow> length P - 1 < length P\n 5. \\<And>a b x.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - 1 < length P\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd)\n                          (Some x, S, B, I,\n                           if b - {x} = {} then butlast P\n                           else P[length P - 1 := (a, b - {x})])\n 6. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)", "apply (cases SBIP)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b c d.\n       \\<lbrakk>P = []; GS_invar SBIP; SBIP = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)\n 2. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b)\\<rbrakk>\n       \\<Longrightarrow> length B - 1 < length B\n 3. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq> {}\n 4. \\<And>a b x.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b\\<rbrakk>\n       \\<Longrightarrow> length P - 1 < length P\n 5. \\<And>a b x.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - 1 < length P\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd)\n                          (Some x, S, B, I,\n                           if b - {x} = {} then butlast P\n                           else P[length P - 1 := (a, b - {x})])\n 6. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b)\\<rbrakk>\n       \\<Longrightarrow> length B - 1 < length B\n 2. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq> {}\n 3. \\<And>a b x.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b\\<rbrakk>\n       \\<Longrightarrow> length P - 1 < length P\n 4. \\<And>a b x.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - 1 < length P\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd)\n                          (Some x, S, B, I,\n                           if b - {x} = {} then butlast P\n                           else P[length P - 1 := (a, b - {x})])\n 5. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq> {}\n 2. \\<And>a b x.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b\\<rbrakk>\n       \\<Longrightarrow> length P - 1 < length P\n 3. \\<And>a b x.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - 1 < length P\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd)\n                          (Some x, S, B, I,\n                           if b - {x} = {} then butlast P\n                           else P[length P - 1 := (a, b - {x})])\n 4. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)", "using P_bound"], ["proof (prove)\nusing this:\n  set P \\<subseteq> {0..<length S} \\<times> {y. {} \\<noteq> y}\n\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq> {}\n 2. \\<And>a b x.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b\\<rbrakk>\n       \\<Longrightarrow> length P - 1 < length P\n 3. \\<And>a b x.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - 1 < length P\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd)\n                          (Some x, S, B, I,\n                           if b - {x} = {} then butlast P\n                           else P[length P - 1 := (a, b - {x})])\n 4. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)", "apply (cases P rule: rev_cases, auto) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b\\<rbrakk>\n       \\<Longrightarrow> length P - 1 < length P\n 2. \\<And>a b x.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - 1 < length P\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd)\n                          (Some x, S, B, I,\n                           if b - {x} = {} then butlast P\n                           else P[length P - 1 := (a, b - {x})])\n 3. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - 1 < length P\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd)\n                          (Some x, S, B, I,\n                           if b - {x} = {} then butlast P\n                           else P[length P - 1 := (a, b - {x})])\n 2. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P\\<rbrakk>\n       \\<Longrightarrow> (b \\<subseteq> {x} \\<longrightarrow>\n                          GS_invar (S, B, I, butlast P)) \\<and>\n                         (\\<not> b \\<subseteq> {x} \\<longrightarrow>\n                          GS_invar\n                           (S, B, I, P[length P - Suc 0 := (a, b - {x})]))\n 2. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)", "apply (intro impI conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> GS_invar (S, B, I, butlast P)\n 2. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> GS_invar\n                          (S, B, I, P[length P - Suc 0 := (a, b - {x})])\n 3. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)", "apply (unfold_locales, simp_all) []"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> set B \\<subseteq> {0..<length S}\n 2. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> sorted B\n 3. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> distinct B\n 4. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P; b \\<subseteq> {x};\n        S \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> B ! 0 = 0\n 5. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> distinct S\n 6. \\<And>a b x v j.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> (I v = Some (STACK j)) =\n                         (j < length S \\<and> v = S ! j)\n 7. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> sorted (map fst (butlast P))\n 8. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (butlast P))\n 9. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> set (butlast P)\n                         \\<subseteq> {0..<length S} \\<times>\n                                     {y. {} \\<noteq> y}\n 10. \\<And>a b x.\n        \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n         b \\<noteq> {}; x \\<in> b;\n         P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n         \\<not> b \\<subseteq> {x}\\<rbrakk>\n        \\<Longrightarrow> GS_invar\n                           (S, B, I, P[length P - Suc 0 := (a, b - {x})])\nA total of 11 subgoals...", "using B_in_bound B_sorted B_distinct B0 S_distinct I_consistent"], ["proof (prove)\nusing this:\n  set B \\<subseteq> {0..<length S}\n  sorted B\n  distinct B\n  S \\<noteq> [] \\<Longrightarrow> B \\<noteq> [] \\<and> B ! 0 = 0\n  distinct S\n  (I ?v = Some (STACK ?j)) = (?j < length S \\<and> ?v = S ! ?j)\n\ngoal (11 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> set B \\<subseteq> {0..<length S}\n 2. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> sorted B\n 3. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> distinct B\n 4. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P; b \\<subseteq> {x};\n        S \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> B ! 0 = 0\n 5. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> distinct S\n 6. \\<And>a b x v j.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> (I v = Some (STACK j)) =\n                         (j < length S \\<and> v = S ! j)\n 7. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> sorted (map fst (butlast P))\n 8. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (butlast P))\n 9. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> set (butlast P)\n                         \\<subseteq> {0..<length S} \\<times>\n                                     {y. {} \\<noteq> y}\n 10. \\<And>a b x.\n        \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n         b \\<noteq> {}; x \\<in> b;\n         P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n         \\<not> b \\<subseteq> {x}\\<rbrakk>\n        \\<Longrightarrow> GS_invar\n                           (S, B, I, P[length P - Suc 0 := (a, b - {x})])\nA total of 11 subgoals...", "apply auto [6]"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> sorted (map fst (butlast P))\n 2. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (butlast P))\n 3. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> set (butlast P)\n                         \\<subseteq> {0..<length S} \\<times>\n                                     {y. {} \\<noteq> y}\n 4. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> GS_invar\n                          (S, B, I, P[length P - Suc 0 := (a, b - {x})])\n 5. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)", "using P_sorted P_distinct"], ["proof (prove)\nusing this:\n  sorted (map fst P)\n  distinct (map fst P)\n\ngoal (5 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> sorted (map fst (butlast P))\n 2. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (butlast P))\n 3. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> set (butlast P)\n                         \\<subseteq> {0..<length S} \\<times>\n                                     {y. {} \\<noteq> y}\n 4. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> GS_invar\n                          (S, B, I, P[length P - Suc 0 := (a, b - {x})])\n 5. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)", "apply (auto simp: map_butlast sorted_butlast distinct_butlast) [2]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> set (butlast P)\n                         \\<subseteq> {0..<length S} \\<times>\n                                     {y. {} \\<noteq> y}\n 2. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> GS_invar\n                          (S, B, I, P[length P - Suc 0 := (a, b - {x})])\n 3. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)", "using P_bound"], ["proof (prove)\nusing this:\n  set P \\<subseteq> {0..<length S} \\<times> {y. {} \\<noteq> y}\n\ngoal (3 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> set (butlast P)\n                         \\<subseteq> {0..<length S} \\<times>\n                                     {y. {} \\<noteq> y}\n 2. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> GS_invar\n                          (S, B, I, P[length P - Suc 0 := (a, b - {x})])\n 3. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)", "apply (auto dest: in_set_butlastD) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> GS_invar\n                          (S, B, I, P[length P - Suc 0 := (a, b - {x})])\n 2. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)", "apply (unfold_locales, simp_all) []"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> set B \\<subseteq> {0..<length S}\n 2. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> sorted B\n 3. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> distinct B\n 4. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}; S \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> B ! 0 = 0\n 5. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> distinct S\n 6. \\<And>a b x v j.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> (I v = Some (STACK j)) =\n                         (j < length S \\<and> v = S ! j)\n 7. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> sorted\n                          (map fst (P[length P - Suc 0 := (a, b - {x})]))\n 8. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (P[length P - Suc 0 := (a, b - {x})]))\n 9. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> set (P[length P - Suc 0 := (a, b - {x})])\n                         \\<subseteq> {0..<length S} \\<times>\n                                     {y. {} \\<noteq> y}\n 10. \\<And>a b.\n        \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n         \\<not> seg_start (length B - 1) \\<le> a\\<rbrakk>\n        \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)", "using B_in_bound B_sorted B_distinct B0 S_distinct I_consistent"], ["proof (prove)\nusing this:\n  set B \\<subseteq> {0..<length S}\n  sorted B\n  distinct B\n  S \\<noteq> [] \\<Longrightarrow> B \\<noteq> [] \\<and> B ! 0 = 0\n  distinct S\n  (I ?v = Some (STACK ?j)) = (?j < length S \\<and> ?v = S ! ?j)\n\ngoal (10 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> set B \\<subseteq> {0..<length S}\n 2. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> sorted B\n 3. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> distinct B\n 4. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}; S \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> B ! 0 = 0\n 5. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> distinct S\n 6. \\<And>a b x v j.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> (I v = Some (STACK j)) =\n                         (j < length S \\<and> v = S ! j)\n 7. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> sorted\n                          (map fst (P[length P - Suc 0 := (a, b - {x})]))\n 8. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (P[length P - Suc 0 := (a, b - {x})]))\n 9. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> set (P[length P - Suc 0 := (a, b - {x})])\n                         \\<subseteq> {0..<length S} \\<times>\n                                     {y. {} \\<noteq> y}\n 10. \\<And>a b.\n        \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n         \\<not> seg_start (length B - 1) \\<le> a\\<rbrakk>\n        \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)", "apply auto [6]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> sorted\n                          (map fst (P[length P - Suc 0 := (a, b - {x})]))\n 2. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (P[length P - Suc 0 := (a, b - {x})]))\n 3. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> set (P[length P - Suc 0 := (a, b - {x})])\n                         \\<subseteq> {0..<length S} \\<times>\n                                     {y. {} \\<noteq> y}\n 4. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)", "using P_sorted P_distinct"], ["proof (prove)\nusing this:\n  sorted (map fst P)\n  distinct (map fst P)\n\ngoal (4 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> sorted\n                          (map fst (P[length P - Suc 0 := (a, b - {x})]))\n 2. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst (P[length P - Suc 0 := (a, b - {x})]))\n 3. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> set (P[length P - Suc 0 := (a, b - {x})])\n                         \\<subseteq> {0..<length S} \\<times>\n                                     {y. {} \\<noteq> y}\n 4. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)", "apply (auto simp: last_conv_nth map_fst_upd_snd_eq) [2]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> set (P[length P - Suc 0 := (a, b - {x})])\n                         \\<subseteq> {0..<length S} \\<times>\n                                     {y. {} \\<noteq> y}\n 2. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)", "using P_bound"], ["proof (prove)\nusing this:\n  set P \\<subseteq> {0..<length S} \\<times> {y. {} \\<noteq> y}\n\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> set (P[length P - Suc 0 := (a, b - {x})])\n                         \\<subseteq> {0..<length S} \\<times>\n                                     {y. {} \\<noteq> y}\n 2. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)", "apply (cases P rule: rev_cases, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x ys y.\n       \\<lbrakk>last P = (a, b); seg_start (length B - Suc 0) \\<le> a;\n        b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - Suc 0 < length P;\n        \\<not> b \\<subseteq> {x};\n        set P \\<subseteq> {0..<length S} \\<times> {y. {} \\<noteq> y};\n        P = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> set (P[length P - Suc 0 := (a, b - {x})])\n                         \\<subseteq> {0..<length S} \\<times>\n                                     {y. {} \\<noteq> y}\n 2. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)", "apply (auto) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)", "using locale_this"], ["proof (prove)\nusing this:\n  GS_invar SBIP\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)", "apply (cases SBIP)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba c d.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a; GS_invar SBIP;\n        SBIP = (aa, ba, c, d)\\<rbrakk>\n       \\<Longrightarrow> (GS_invar \\<circ> snd) (None, S, B, I, P)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sel_rem_last \\<le> SPEC (GS_invar \\<circ> snd)\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "{"], ["proof (state)\nthis:\n  sel_rem_last \\<le> SPEC (GS_invar \\<circ> snd)\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "assume NS: \"pE_\\<alpha>\\<inter>last p_\\<alpha>\\<times>UNIV = {}\""], ["proof (state)\nthis:\n  pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {}\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "hence \"sel_rem_last \n        \\<le> SPEC (\\<lambda>r. case r of (None,SBIP') \\<Rightarrow> SBIP'=SBIP | _ \\<Rightarrow> False)\""], ["proof (prove)\nusing this:\n  pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {}\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> SPEC\n           (\\<lambda>r.\n               case r of (None, SBIP') \\<Rightarrow> SBIP' = SBIP\n               | (Some aa, SBIP') \\<Rightarrow> False)", "unfolding sel_rem_last_def"], ["proof (prove)\nusing this:\n  pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {}\n\ngoal (1 subgoal):\n 1. (if P = [] then RETURN (None, S, B, I, P)\n     else let (j, succs) = last P\n          in ASSERT (length B - 1 < length B) \\<bind>\n             (\\<lambda>_.\n                 if seg_start (length B - 1) \\<le> j\n                 then ASSERT (succs \\<noteq> {}) \\<bind>\n                      (\\<lambda>_.\n                          SPEC (\\<lambda>x. x \\<in> succs) \\<bind>\n                          (\\<lambda>v.\n                              let succs = succs - {v}\n                              in ASSERT\n                                  (P \\<noteq> [] \\<and>\n                                   length P - 1 < length P) \\<bind>\n                                 (\\<lambda>_.\n                                     let P =\n     if succs = {} then butlast P else P[length P - 1 := (j, succs)]\n                                     in RETURN (Some v, S, B, I, P))))\n                 else RETURN (None, S, B, I, P)))\n    \\<le> SPEC\n           (\\<lambda>r.\n               case r of (None, SBIP') \\<Rightarrow> SBIP' = SBIP\n               | (Some aa, SBIP') \\<Rightarrow> False)", "apply (refine_rcg refine_vcg)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P = []; (None, S, B, I, P) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of None \\<Rightarrow> x2 = SBIP\n                         | Some aa \\<Rightarrow> False\n 2. \\<And>a b.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b)\\<rbrakk>\n       \\<Longrightarrow> length B - 1 < length B\n 3. \\<And>a b.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq> {}\n 4. \\<And>a b x.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b\\<rbrakk>\n       \\<Longrightarrow> length P - 1 < length P\n 5. \\<And>a b x x1 x2.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - 1 < length P;\n        (Some x, S, B, I,\n         if b - {x} = {} then butlast P\n         else P[length P - 1 := (a, b - {x})]) =\n        (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of None \\<Rightarrow> x2 = SBIP\n                         | Some aa \\<Rightarrow> False\n 6. \\<And>a b x1 x2.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a;\n        (None, S, B, I, P) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of None \\<Rightarrow> x2 = SBIP\n                         | Some aa \\<Rightarrow> False", "apply (cases SBIP)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x1 x2 a b c d.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P = []; (None, S, B, I, P) = (x1, x2); SBIP = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> case x1 of None \\<Rightarrow> x2 = SBIP\n                         | Some aa \\<Rightarrow> False\n 2. \\<And>a b.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b)\\<rbrakk>\n       \\<Longrightarrow> length B - 1 < length B\n 3. \\<And>a b.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq> {}\n 4. \\<And>a b x.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b\\<rbrakk>\n       \\<Longrightarrow> length P - 1 < length P\n 5. \\<And>a b x x1 x2.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - 1 < length P;\n        (Some x, S, B, I,\n         if b - {x} = {} then butlast P\n         else P[length P - 1 := (a, b - {x})]) =\n        (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of None \\<Rightarrow> x2 = SBIP\n                         | Some aa \\<Rightarrow> False\n 6. \\<And>a b x1 x2.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a;\n        (None, S, B, I, P) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of None \\<Rightarrow> x2 = SBIP\n                         | Some aa \\<Rightarrow> False", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b)\\<rbrakk>\n       \\<Longrightarrow> length B - 1 < length B\n 2. \\<And>a b.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq> {}\n 3. \\<And>a b x.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b\\<rbrakk>\n       \\<Longrightarrow> length P - 1 < length P\n 4. \\<And>a b x x1 x2.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - 1 < length P;\n        (Some x, S, B, I,\n         if b - {x} = {} then butlast P\n         else P[length P - 1 := (a, b - {x})]) =\n        (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of None \\<Rightarrow> x2 = SBIP\n                         | Some aa \\<Rightarrow> False\n 5. \\<And>a b x1 x2.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a;\n        (None, S, B, I, P) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of None \\<Rightarrow> x2 = SBIP\n                         | Some aa \\<Rightarrow> False", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq> {}\n 2. \\<And>a b x.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b\\<rbrakk>\n       \\<Longrightarrow> length P - 1 < length P\n 3. \\<And>a b x x1 x2.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - 1 < length P;\n        (Some x, S, B, I,\n         if b - {x} = {} then butlast P\n         else P[length P - 1 := (a, b - {x})]) =\n        (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of None \\<Rightarrow> x2 = SBIP\n                         | Some aa \\<Rightarrow> False\n 4. \\<And>a b x1 x2.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a;\n        (None, S, B, I, P) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of None \\<Rightarrow> x2 = SBIP\n                         | Some aa \\<Rightarrow> False", "using P_bound"], ["proof (prove)\nusing this:\n  set P \\<subseteq> {0..<length S} \\<times> {y. {} \\<noteq> y}\n\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq> {}\n 2. \\<And>a b x.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b\\<rbrakk>\n       \\<Longrightarrow> length P - 1 < length P\n 3. \\<And>a b x x1 x2.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - 1 < length P;\n        (Some x, S, B, I,\n         if b - {x} = {} then butlast P\n         else P[length P - 1 := (a, b - {x})]) =\n        (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of None \\<Rightarrow> x2 = SBIP\n                         | Some aa \\<Rightarrow> False\n 4. \\<And>a b x1 x2.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a;\n        (None, S, B, I, P) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of None \\<Rightarrow> x2 = SBIP\n                         | Some aa \\<Rightarrow> False", "apply (cases P rule: rev_cases, auto) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b\\<rbrakk>\n       \\<Longrightarrow> length P - 1 < length P\n 2. \\<And>a b x x1 x2.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - 1 < length P;\n        (Some x, S, B, I,\n         if b - {x} = {} then butlast P\n         else P[length P - 1 := (a, b - {x})]) =\n        (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of None \\<Rightarrow> x2 = SBIP\n                         | Some aa \\<Rightarrow> False\n 3. \\<And>a b x1 x2.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a;\n        (None, S, B, I, P) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of None \\<Rightarrow> x2 = SBIP\n                         | Some aa \\<Rightarrow> False", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x x1 x2.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - 1 < length P;\n        (Some x, S, B, I,\n         if b - {x} = {} then butlast P\n         else P[length P - 1 := (a, b - {x})]) =\n        (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of None \\<Rightarrow> x2 = SBIP\n                         | Some aa \\<Rightarrow> False\n 2. \\<And>a b x1 x2.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a;\n        (None, S, B, I, P) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of None \\<Rightarrow> x2 = SBIP\n                         | Some aa \\<Rightarrow> False", "using no_last_out_P_aux[OF NE NS]"], ["proof (prove)\nusing this:\n  set P \\<subseteq> {0..<last B} \\<times> UNIV\n\ngoal (2 subgoals):\n 1. \\<And>a b x x1 x2.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - 1 < length P;\n        (Some x, S, B, I,\n         if b - {x} = {} then butlast P\n         else P[length P - 1 := (a, b - {x})]) =\n        (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of None \\<Rightarrow> x2 = SBIP\n                         | Some aa \\<Rightarrow> False\n 2. \\<And>a b x1 x2.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a;\n        (None, S, B, I, P) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of None \\<Rightarrow> x2 = SBIP\n                         | Some aa \\<Rightarrow> False", "apply (auto simp: seg_start_def last_conv_nth) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x1 x2.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a;\n        (None, S, B, I, P) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of None \\<Rightarrow> x2 = SBIP\n                         | Some aa \\<Rightarrow> False", "apply (cases SBIP)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x1 x2 aa ba c d.\n       \\<lbrakk>pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n        P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a;\n        (None, S, B, I, P) = (x1, x2); SBIP = (aa, ba, c, d)\\<rbrakk>\n       \\<Longrightarrow> case x1 of None \\<Rightarrow> x2 = SBIP\n                         | Some aa \\<Rightarrow> False", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sel_rem_last\n  \\<le> SPEC\n         (\\<lambda>r.\n             case r of (None, SBIP') \\<Rightarrow> SBIP' = SBIP\n             | (Some aa, SBIP') \\<Rightarrow> False)\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "}"], ["proof (state)\nthis:\n  pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {} \\<Longrightarrow>\n  sel_rem_last\n  \\<le> SPEC\n         (\\<lambda>r.\n             case r of (None, SBIP') \\<Rightarrow> SBIP' = SBIP\n             | (Some aa, SBIP') \\<Rightarrow> False)\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "note SPEC_E = this"], ["proof (state)\nthis:\n  pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {} \\<Longrightarrow>\n  sel_rem_last\n  \\<le> SPEC\n         (\\<lambda>r.\n             case r of (None, SBIP') \\<Rightarrow> SBIP' = SBIP\n             | (Some aa, SBIP') \\<Rightarrow> False)\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "{"], ["proof (state)\nthis:\n  pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {} \\<Longrightarrow>\n  sel_rem_last\n  \\<le> SPEC\n         (\\<lambda>r.\n             case r of (None, SBIP') \\<Rightarrow> SBIP' = SBIP\n             | (Some aa, SBIP') \\<Rightarrow> False)\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "assume NON_EMPTY: \"pE_\\<alpha>\\<inter>last p_\\<alpha>\\<times>UNIV \\<noteq> {}\""], ["proof (state)\nthis:\n  pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV \\<noteq> {}\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "then"], ["proof (chain)\npicking this:\n  pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV \\<noteq> {}", "obtain j succs P' where \n        EFMT: \"P = P'@[(j,succs)]\""], ["proof (prove)\nusing this:\n  pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>P' j succs.\n        P = P' @ [(j, succs)] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding pE_\\<alpha>_def"], ["proof (prove)\nusing this:\n  {(u, v).\n   \\<exists>j I.\n      (j, I) \\<in> set P \\<and> u = S ! j \\<and> v \\<in> I} \\<inter>\n  last p_\\<alpha> \\<times> UNIV \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (\\<And>P' j succs.\n        P = P' @ [(j, succs)] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases P rule: rev_cases) auto"], ["proof (state)\nthis:\n  P = P' @ [(j, succs)]\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "with P_bound"], ["proof (chain)\npicking this:\n  set P \\<subseteq> {0..<length S} \\<times> {y. {} \\<noteq> y}\n  P = P' @ [(j, succs)]", "have J_UPPER: \"j<length S\" and SNE: \"succs\\<noteq>{}\""], ["proof (prove)\nusing this:\n  set P \\<subseteq> {0..<length S} \\<times> {y. {} \\<noteq> y}\n  P = P' @ [(j, succs)]\n\ngoal (1 subgoal):\n 1. j < length S &&& succs \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  j < length S\n  succs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "have J_LOWER: \"seg_start (length B - Suc 0) \\<le> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seg_start (length B - Suc 0) \\<le> j", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> seg_start (length B - Suc 0) \\<le> j \\<Longrightarrow> False", "assume \"\\<not>(seg_start (length B - Suc 0) \\<le> j)\""], ["proof (state)\nthis:\n  \\<not> seg_start (length B - Suc 0) \\<le> j\n\ngoal (1 subgoal):\n 1. \\<not> seg_start (length B - Suc 0) \\<le> j \\<Longrightarrow> False", "hence \"j < seg_start (length B - 1)\""], ["proof (prove)\nusing this:\n  \\<not> seg_start (length B - Suc 0) \\<le> j\n\ngoal (1 subgoal):\n 1. j < seg_start (length B - 1)", "by simp"], ["proof (state)\nthis:\n  j < seg_start (length B - 1)\n\ngoal (1 subgoal):\n 1. \\<not> seg_start (length B - Suc 0) \\<le> j \\<Longrightarrow> False", "with P_sorted EFMT"], ["proof (chain)\npicking this:\n  sorted (map fst P)\n  P = P' @ [(j, succs)]\n  j < seg_start (length B - 1)", "have P_bound': \"set P \\<subseteq> {0..<seg_start (length B - 1)} \\<times> UNIV\""], ["proof (prove)\nusing this:\n  sorted (map fst P)\n  P = P' @ [(j, succs)]\n  j < seg_start (length B - 1)\n\ngoal (1 subgoal):\n 1. set P \\<subseteq> {0..<seg_start (length B - 1)} \\<times> UNIV", "by (auto simp: sorted_append)"], ["proof (state)\nthis:\n  set P \\<subseteq> {0..<seg_start (length B - 1)} \\<times> UNIV\n\ngoal (1 subgoal):\n 1. \\<not> seg_start (length B - Suc 0) \\<le> j \\<Longrightarrow> False", "hence \"pE_\\<alpha> \\<inter> last p_\\<alpha>\\<times>UNIV = {}\""], ["proof (prove)\nusing this:\n  set P \\<subseteq> {0..<seg_start (length B - 1)} \\<times> UNIV\n\ngoal (1 subgoal):\n 1. pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {}", "by (auto \n            simp: p_\\<alpha>_def last_conv_nth seg_def pE_\\<alpha>_def S_idx_uniq seg_end_def)"], ["proof (state)\nthis:\n  pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {}\n\ngoal (1 subgoal):\n 1. \\<not> seg_start (length B - Suc 0) \\<le> j \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {}\n\ngoal (1 subgoal):\n 1. False", "using NON_EMPTY"], ["proof (prove)\nusing this:\n  pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {}\n  pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  seg_start (length B - Suc 0) \\<le> j\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "from J_UPPER J_LOWER"], ["proof (chain)\npicking this:\n  j < length S\n  seg_start (length B - Suc 0) \\<le> j", "have SJL: \"S!j\\<in>last p_\\<alpha>\""], ["proof (prove)\nusing this:\n  j < length S\n  seg_start (length B - Suc 0) \\<le> j\n\ngoal (1 subgoal):\n 1. S ! j \\<in> last p_\\<alpha>", "unfolding p_\\<alpha>_def seg_def[abs_def] seg_end_def"], ["proof (prove)\nusing this:\n  j < length S\n  seg_start (length B - Suc 0) \\<le> j\n\ngoal (1 subgoal):\n 1. S ! j\n    \\<in> last\n           (map (\\<lambda>i.\n                    {S ! j |j.\n                     seg_start i \\<le> j \\<and>\n                     j < (if i + 1 = length B then length S\n                          else B ! (i + 1))})\n             [0..<length B])", "by (auto simp: last_map)"], ["proof (state)\nthis:\n  S ! j \\<in> last p_\\<alpha>\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "from EFMT"], ["proof (chain)\npicking this:\n  P = P' @ [(j, succs)]", "have SSS: \"{S!j}\\<times>succs\\<subseteq>pE_\\<alpha>\""], ["proof (prove)\nusing this:\n  P = P' @ [(j, succs)]\n\ngoal (1 subgoal):\n 1. {S ! j} \\<times> succs \\<subseteq> pE_\\<alpha>", "unfolding pE_\\<alpha>_def"], ["proof (prove)\nusing this:\n  P = P' @ [(j, succs)]\n\ngoal (1 subgoal):\n 1. {S ! j} \\<times> succs\n    \\<subseteq> {(u, v).\n                 \\<exists>j I.\n                    (j, I) \\<in> set P \\<and> u = S ! j \\<and> v \\<in> I}", "by auto"], ["proof (state)\nthis:\n  {S ! j} \\<times> succs \\<subseteq> pE_\\<alpha>\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "{"], ["proof (state)\nthis:\n  {S ! j} \\<times> succs \\<subseteq> pE_\\<alpha>\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "assume \"v\\<in>succs\""], ["proof (state)\nthis:\n  v \\<in> succs\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "with SJL SSS"], ["proof (chain)\npicking this:\n  S ! j \\<in> last p_\\<alpha>\n  {S ! j} \\<times> succs \\<subseteq> pE_\\<alpha>\n  v \\<in> succs", "have G: \"(S!j,v)\\<in>pE_\\<alpha> \\<inter> last p_\\<alpha>\\<times>UNIV\""], ["proof (prove)\nusing this:\n  S ! j \\<in> last p_\\<alpha>\n  {S ! j} \\<times> succs \\<subseteq> pE_\\<alpha>\n  v \\<in> succs\n\ngoal (1 subgoal):\n 1. (S ! j, v) \\<in> pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV", "by auto"], ["proof (state)\nthis:\n  (S ! j, v) \\<in> pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "{"], ["proof (state)\nthis:\n  (S ! j, v) \\<in> pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "fix j' succs'"], ["proof (state)\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "assume \"S ! j' = S ! j\" \"(j', succs') \\<in> set P'\""], ["proof (state)\nthis:\n  S ! j' = S ! j\n  (j', succs') \\<in> set P'\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "with J_UPPER P_bound S_idx_uniq EFMT"], ["proof (chain)\npicking this:\n  j < length S\n  set P \\<subseteq> {0..<length S} \\<times> {y. {} \\<noteq> y}\n  \\<lbrakk>?i < length S; ?j < length S\\<rbrakk>\n  \\<Longrightarrow> (S ! ?i = S ! ?j) = (?i = ?j)\n  P = P' @ [(j, succs)]\n  S ! j' = S ! j\n  (j', succs') \\<in> set P'", "have \"j'=j\""], ["proof (prove)\nusing this:\n  j < length S\n  set P \\<subseteq> {0..<length S} \\<times> {y. {} \\<noteq> y}\n  \\<lbrakk>?i < length S; ?j < length S\\<rbrakk>\n  \\<Longrightarrow> (S ! ?i = S ! ?j) = (?i = ?j)\n  P = P' @ [(j, succs)]\n  S ! j' = S ! j\n  (j', succs') \\<in> set P'\n\ngoal (1 subgoal):\n 1. j' = j", "by auto"], ["proof (state)\nthis:\n  j' = j\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "with P_distinct \\<open>(j', succs') \\<in> set P'\\<close> EFMT"], ["proof (chain)\npicking this:\n  distinct (map fst P)\n  (j', succs') \\<in> set P'\n  P = P' @ [(j, succs)]\n  j' = j", "have False"], ["proof (prove)\nusing this:\n  distinct (map fst P)\n  (j', succs') \\<in> set P'\n  P = P' @ [(j, succs)]\n  j' = j\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>S ! ?j'2 = S ! j; (?j'2, ?succs'2) \\<in> set P'\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "note AUX3=this"], ["proof (state)\nthis:\n  \\<lbrakk>S ! ?j'2 = S ! j; (?j'2, ?succs'2) \\<in> set P'\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "have G1: \"GS.pE_\\<alpha> (S,B,I,P' @ [(j, succs - {v})]) = pE_\\<alpha> - {(S!j, v)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GS.pE_\\<alpha> (S, B, I, P' @ [(j, succs - {v})]) =\n    pE_\\<alpha> - {(S ! j, v)}", "unfolding GS.pE_\\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(u, va).\n     \\<exists>ja Ia.\n        (ja, Ia) \\<in> set (GS.P (S, B, I, P' @ [(j, succs - {v})])) \\<and>\n        u = GS.S (S, B, I, P' @ [(j, succs - {v})]) ! ja \\<and>\n        va \\<in> Ia} =\n    {(u, v).\n     \\<exists>j I. (j, I) \\<in> set P \\<and> u = S ! j \\<and> v \\<in> I} -\n    {(S ! j, v)}", "using AUX3"], ["proof (prove)\nusing this:\n  \\<lbrakk>S ! ?j'2 = S ! j; (?j'2, ?succs'2) \\<in> set P'\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. {(u, va).\n     \\<exists>ja Ia.\n        (ja, Ia) \\<in> set (GS.P (S, B, I, P' @ [(j, succs - {v})])) \\<and>\n        u = GS.S (S, B, I, P' @ [(j, succs - {v})]) ! ja \\<and>\n        va \\<in> Ia} =\n    {(u, v).\n     \\<exists>j I. (j, I) \\<in> set P \\<and> u = S ! j \\<and> v \\<in> I} -\n    {(S ! j, v)}", "by (auto simp: EFMT)"], ["proof (state)\nthis:\n  GS.pE_\\<alpha> (S, B, I, P' @ [(j, succs - {v})]) =\n  pE_\\<alpha> - {(S ! j, v)}\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "{"], ["proof (state)\nthis:\n  GS.pE_\\<alpha> (S, B, I, P' @ [(j, succs - {v})]) =\n  pE_\\<alpha> - {(S ! j, v)}\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "assume \"succs\\<subseteq>{v}\""], ["proof (state)\nthis:\n  succs \\<subseteq> {v}\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "hence \"GS.pE_\\<alpha> (S,B,I,P' @ [(j, succs - {v})]) = GS.pE_\\<alpha> (S,B,I,P')\""], ["proof (prove)\nusing this:\n  succs \\<subseteq> {v}\n\ngoal (1 subgoal):\n 1. GS.pE_\\<alpha> (S, B, I, P' @ [(j, succs - {v})]) =\n    GS.pE_\\<alpha> (S, B, I, P')", "unfolding GS.pE_\\<alpha>_def"], ["proof (prove)\nusing this:\n  succs \\<subseteq> {v}\n\ngoal (1 subgoal):\n 1. {(u, va).\n     \\<exists>ja Ia.\n        (ja, Ia) \\<in> set (GS.P (S, B, I, P' @ [(j, succs - {v})])) \\<and>\n        u = GS.S (S, B, I, P' @ [(j, succs - {v})]) ! ja \\<and>\n        va \\<in> Ia} =\n    {(u, v).\n     \\<exists>j Ia.\n        (j, Ia) \\<in> set (GS.P (S, B, I, P')) \\<and>\n        u = GS.S (S, B, I, P') ! j \\<and> v \\<in> Ia}", "by auto"], ["proof (state)\nthis:\n  GS.pE_\\<alpha> (S, B, I, P' @ [(j, succs - {v})]) =\n  GS.pE_\\<alpha> (S, B, I, P')\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "with G1"], ["proof (chain)\npicking this:\n  GS.pE_\\<alpha> (S, B, I, P' @ [(j, succs - {v})]) =\n  pE_\\<alpha> - {(S ! j, v)}\n  GS.pE_\\<alpha> (S, B, I, P' @ [(j, succs - {v})]) =\n  GS.pE_\\<alpha> (S, B, I, P')", "have \"GS.pE_\\<alpha> (S,B,I,P') = pE_\\<alpha> - {(S!j, v)}\""], ["proof (prove)\nusing this:\n  GS.pE_\\<alpha> (S, B, I, P' @ [(j, succs - {v})]) =\n  pE_\\<alpha> - {(S ! j, v)}\n  GS.pE_\\<alpha> (S, B, I, P' @ [(j, succs - {v})]) =\n  GS.pE_\\<alpha> (S, B, I, P')\n\ngoal (1 subgoal):\n 1. GS.pE_\\<alpha> (S, B, I, P') = pE_\\<alpha> - {(S ! j, v)}", "by simp"], ["proof (state)\nthis:\n  GS.pE_\\<alpha> (S, B, I, P') = pE_\\<alpha> - {(S ! j, v)}\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "}"], ["proof (state)\nthis:\n  succs \\<subseteq> {v} \\<Longrightarrow>\n  GS.pE_\\<alpha> (S, B, I, P') = pE_\\<alpha> - {(S ! j, v)}\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "note G2 = this"], ["proof (state)\nthis:\n  succs \\<subseteq> {v} \\<Longrightarrow>\n  GS.pE_\\<alpha> (S, B, I, P') = pE_\\<alpha> - {(S ! j, v)}\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "note G G1 G2"], ["proof (state)\nthis:\n  (S ! j, v) \\<in> pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV\n  GS.pE_\\<alpha> (S, B, I, P' @ [(j, succs - {v})]) =\n  pE_\\<alpha> - {(S ! j, v)}\n  succs \\<subseteq> {v} \\<Longrightarrow>\n  GS.pE_\\<alpha> (S, B, I, P') = pE_\\<alpha> - {(S ! j, v)}\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> succs \\<Longrightarrow>\n  (S ! j, ?v2) \\<in> pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV\n  ?v2 \\<in> succs \\<Longrightarrow>\n  GS.pE_\\<alpha> (S, B, I, P' @ [(j, succs - {?v2})]) =\n  pE_\\<alpha> - {(S ! j, ?v2)}\n  \\<lbrakk>?v2 \\<in> succs; succs \\<subseteq> {?v2}\\<rbrakk>\n  \\<Longrightarrow> GS.pE_\\<alpha> (S, B, I, P') =\n                    pE_\\<alpha> - {(S ! j, ?v2)}\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "note AUX3 = this"], ["proof (state)\nthis:\n  ?v2 \\<in> succs \\<Longrightarrow>\n  (S ! j, ?v2) \\<in> pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV\n  ?v2 \\<in> succs \\<Longrightarrow>\n  GS.pE_\\<alpha> (S, B, I, P' @ [(j, succs - {?v2})]) =\n  pE_\\<alpha> - {(S ! j, ?v2)}\n  \\<lbrakk>?v2 \\<in> succs; succs \\<subseteq> {?v2}\\<rbrakk>\n  \\<Longrightarrow> GS.pE_\\<alpha> (S, B, I, P') =\n                    pE_\\<alpha> - {(S ! j, ?v2)}\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "have \"sel_rem_last \\<le> SPEC (\\<lambda>r. case r of \n        (Some v,SBIP') \\<Rightarrow> \\<exists>u. \n            (u,v)\\<in>(pE_\\<alpha>\\<inter>last p_\\<alpha>\\<times>UNIV) \n          \\<and> GS.\\<alpha> SBIP' = (p_\\<alpha>,D_\\<alpha>,pE_\\<alpha>-{(u,v)})\n      | _ \\<Rightarrow> False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> SPEC\n           (\\<lambda>r.\n               case r of (None, SBIP') \\<Rightarrow> False\n               | (Some v, SBIP') \\<Rightarrow>\n                   \\<exists>u.\n                      (u, v)\n                      \\<in> pE_\\<alpha> \\<inter>\n                            last p_\\<alpha> \\<times> UNIV \\<and>\n                      GS.\\<alpha> SBIP' =\n                      (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha> - {(u, v)}))", "unfolding sel_rem_last_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if P = [] then RETURN (None, S, B, I, P)\n     else let (j, succs) = last P\n          in ASSERT (length B - 1 < length B) \\<bind>\n             (\\<lambda>_.\n                 if seg_start (length B - 1) \\<le> j\n                 then ASSERT (succs \\<noteq> {}) \\<bind>\n                      (\\<lambda>_.\n                          SPEC (\\<lambda>x. x \\<in> succs) \\<bind>\n                          (\\<lambda>v.\n                              let succs = succs - {v}\n                              in ASSERT\n                                  (P \\<noteq> [] \\<and>\n                                   length P - 1 < length P) \\<bind>\n                                 (\\<lambda>_.\n                                     let P =\n     if succs = {} then butlast P else P[length P - 1 := (j, succs)]\n                                     in RETURN (Some v, S, B, I, P))))\n                 else RETURN (None, S, B, I, P)))\n    \\<le> SPEC\n           (\\<lambda>r.\n               case r of (None, SBIP') \\<Rightarrow> False\n               | (Some v, SBIP') \\<Rightarrow>\n                   \\<exists>u.\n                      (u, v)\n                      \\<in> pE_\\<alpha> \\<inter>\n                            last p_\\<alpha> \\<times> UNIV \\<and>\n                      GS.\\<alpha> SBIP' =\n                      (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha> - {(u, v)}))", "apply (refine_rcg refine_vcg)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>P = []; (None, S, B, I, P) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of None \\<Rightarrow> False\n                         | Some v \\<Rightarrow>\n                             \\<exists>u.\n                                (u, v)\n                                \\<in> pE_\\<alpha> \\<inter>\nlast p_\\<alpha> \\<times> UNIV \\<and>\n                                GS.\\<alpha> x2 =\n                                (p_\\<alpha>, D_\\<alpha>,\n                                 pE_\\<alpha> - {(u, v)})\n 2. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b)\\<rbrakk>\n       \\<Longrightarrow> length B - 1 < length B\n 3. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq> {}\n 4. \\<And>a b x.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b\\<rbrakk>\n       \\<Longrightarrow> length P - 1 < length P\n 5. \\<And>a b x x1 x2.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - 1 < length P;\n        (Some x, S, B, I,\n         if b - {x} = {} then butlast P\n         else P[length P - 1 := (a, b - {x})]) =\n        (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of None \\<Rightarrow> False\n                         | Some v \\<Rightarrow>\n                             \\<exists>u.\n                                (u, v)\n                                \\<in> pE_\\<alpha> \\<inter>\nlast p_\\<alpha> \\<times> UNIV \\<and>\n                                GS.\\<alpha> x2 =\n                                (p_\\<alpha>, D_\\<alpha>,\n                                 pE_\\<alpha> - {(u, v)})\n 6. \\<And>a b x1 x2.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a;\n        (None, S, B, I, P) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of None \\<Rightarrow> False\n                         | Some v \\<Rightarrow>\n                             \\<exists>u.\n                                (u, v)\n                                \\<in> pE_\\<alpha> \\<inter>\nlast p_\\<alpha> \\<times> UNIV \\<and>\n                                GS.\\<alpha> x2 =\n                                (p_\\<alpha>, D_\\<alpha>,\n                                 pE_\\<alpha> - {(u, v)})", "using SNE"], ["proof (prove)\nusing this:\n  succs \\<noteq> {}\n\ngoal (6 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>P = []; (None, S, B, I, P) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of None \\<Rightarrow> False\n                         | Some v \\<Rightarrow>\n                             \\<exists>u.\n                                (u, v)\n                                \\<in> pE_\\<alpha> \\<inter>\nlast p_\\<alpha> \\<times> UNIV \\<and>\n                                GS.\\<alpha> x2 =\n                                (p_\\<alpha>, D_\\<alpha>,\n                                 pE_\\<alpha> - {(u, v)})\n 2. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b)\\<rbrakk>\n       \\<Longrightarrow> length B - 1 < length B\n 3. \\<And>a b.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a\\<rbrakk>\n       \\<Longrightarrow> b \\<noteq> {}\n 4. \\<And>a b x.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b\\<rbrakk>\n       \\<Longrightarrow> length P - 1 < length P\n 5. \\<And>a b x x1 x2.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        seg_start (length B - 1) \\<le> a; b \\<noteq> {}; x \\<in> b;\n        P \\<noteq> [] \\<and> length P - 1 < length P;\n        (Some x, S, B, I,\n         if b - {x} = {} then butlast P\n         else P[length P - 1 := (a, b - {x})]) =\n        (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of None \\<Rightarrow> False\n                         | Some v \\<Rightarrow>\n                             \\<exists>u.\n                                (u, v)\n                                \\<in> pE_\\<alpha> \\<inter>\nlast p_\\<alpha> \\<times> UNIV \\<and>\n                                GS.\\<alpha> x2 =\n                                (p_\\<alpha>, D_\\<alpha>,\n                                 pE_\\<alpha> - {(u, v)})\n 6. \\<And>a b x1 x2.\n       \\<lbrakk>P \\<noteq> []; last P = (a, b); length B - 1 < length B;\n        \\<not> seg_start (length B - 1) \\<le> a;\n        (None, S, B, I, P) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> case x1 of None \\<Rightarrow> False\n                         | Some v \\<Rightarrow>\n                             \\<exists>u.\n                                (u, v)\n                                \\<in> pE_\\<alpha> \\<inter>\nlast p_\\<alpha> \\<times> UNIV \\<and>\n                                GS.\\<alpha> x2 =\n                                (p_\\<alpha>, D_\\<alpha>,\n                                 pE_\\<alpha> - {(u, v)})", "apply (vc_solve simp: J_LOWER EFMT)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>succs \\<noteq> {}; x \\<in> succs\\<rbrakk>\n       \\<Longrightarrow> (succs \\<subseteq> {x} \\<longrightarrow>\n                          (\\<exists>u.\n                              (u, x) \\<in> pE_\\<alpha> \\<and>\n                              u \\<in> last p_\\<alpha> \\<and>\n                              GS.\\<alpha> (S, B, I, P') =\n                              (p_\\<alpha>, D_\\<alpha>,\n                               pE_\\<alpha> - {(u, x)}))) \\<and>\n                         (\\<not> succs \\<subseteq> {x} \\<longrightarrow>\n                          (\\<exists>u.\n                              (u, x) \\<in> pE_\\<alpha> \\<and>\n                              u \\<in> last p_\\<alpha> \\<and>\n                              GS.\\<alpha>\n                               (S, B, I, P' @ [(j, succs - {x})]) =\n                              (p_\\<alpha>, D_\\<alpha>,\n                               pE_\\<alpha> - {(u, x)})))", "apply (frule AUX3(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>succs \\<noteq> {}; x \\<in> succs;\n        (S ! j, x)\n        \\<in> pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV\\<rbrakk>\n       \\<Longrightarrow> (succs \\<subseteq> {x} \\<longrightarrow>\n                          (\\<exists>u.\n                              (u, x) \\<in> pE_\\<alpha> \\<and>\n                              u \\<in> last p_\\<alpha> \\<and>\n                              GS.\\<alpha> (S, B, I, P') =\n                              (p_\\<alpha>, D_\\<alpha>,\n                               pE_\\<alpha> - {(u, x)}))) \\<and>\n                         (\\<not> succs \\<subseteq> {x} \\<longrightarrow>\n                          (\\<exists>u.\n                              (u, x) \\<in> pE_\\<alpha> \\<and>\n                              u \\<in> last p_\\<alpha> \\<and>\n                              GS.\\<alpha>\n                               (S, B, I, P' @ [(j, succs - {x})]) =\n                              (p_\\<alpha>, D_\\<alpha>,\n                               pE_\\<alpha> - {(u, x)})))", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<in> succs; (S ! j, x) \\<in> pE_\\<alpha>;\n        S ! j \\<in> last p_\\<alpha>; x \\<in> UNIV; xa \\<in> succs;\n        xa \\<notin> {}; succs \\<subseteq> {x}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u.\n                            (u, x) \\<in> pE_\\<alpha> \\<and>\n                            u \\<in> last p_\\<alpha> \\<and>\n                            GS.\\<alpha> (S, B, I, P') =\n                            (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha> - {(u, x)})\n 2. \\<And>x xa xb.\n       \\<lbrakk>x \\<in> succs; (S ! j, x) \\<in> pE_\\<alpha>;\n        S ! j \\<in> last p_\\<alpha>; x \\<in> UNIV; xa \\<in> succs;\n        xa \\<notin> {};\n        \\<nexists>u.\n           (u, x) \\<in> pE_\\<alpha> \\<and>\n           u \\<in> last p_\\<alpha> \\<and>\n           GS.\\<alpha> (S, B, I, P' @ [(j, succs - {x})]) =\n           (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha> - {(u, x)});\n        xb \\<in> succs; xb \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> xb = x", "apply (drule (1) AUX3(3))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>(S ! j, x) \\<in> pE_\\<alpha>; S ! j \\<in> last p_\\<alpha>;\n        x \\<in> UNIV; xa \\<in> succs; xa \\<notin> {}; succs \\<subseteq> {x};\n        GS.pE_\\<alpha> (S, B, I, P') = pE_\\<alpha> - {(S ! j, x)}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u.\n                            (u, x) \\<in> pE_\\<alpha> \\<and>\n                            u \\<in> last p_\\<alpha> \\<and>\n                            GS.\\<alpha> (S, B, I, P') =\n                            (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha> - {(u, x)})\n 2. \\<And>x xa xb.\n       \\<lbrakk>x \\<in> succs; (S ! j, x) \\<in> pE_\\<alpha>;\n        S ! j \\<in> last p_\\<alpha>; x \\<in> UNIV; xa \\<in> succs;\n        xa \\<notin> {};\n        \\<nexists>u.\n           (u, x) \\<in> pE_\\<alpha> \\<and>\n           u \\<in> last p_\\<alpha> \\<and>\n           GS.\\<alpha> (S, B, I, P' @ [(j, succs - {x})]) =\n           (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha> - {(u, x)});\n        xb \\<in> succs; xb \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> xb = x", "apply (auto simp: EFMT GS.\\<alpha>_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>x \\<in> succs; (S ! j, x) \\<in> pE_\\<alpha>;\n        S ! j \\<in> last p_\\<alpha>; x \\<in> UNIV; xa \\<in> succs;\n        xa \\<notin> {};\n        \\<nexists>u.\n           (u, x) \\<in> pE_\\<alpha> \\<and>\n           u \\<in> last p_\\<alpha> \\<and>\n           GS.\\<alpha> (S, B, I, P' @ [(j, succs - {x})]) =\n           (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha> - {(u, x)});\n        xb \\<in> succs; xb \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> xb = x", "apply (drule AUX3(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>(S ! j, x) \\<in> pE_\\<alpha>; S ! j \\<in> last p_\\<alpha>;\n        x \\<in> UNIV; xa \\<in> succs; xa \\<notin> {};\n        \\<nexists>u.\n           (u, x) \\<in> pE_\\<alpha> \\<and>\n           u \\<in> last p_\\<alpha> \\<and>\n           GS.\\<alpha> (S, B, I, P' @ [(j, succs - {x})]) =\n           (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha> - {(u, x)});\n        xb \\<in> succs; xb \\<notin> {};\n        GS.pE_\\<alpha> (S, B, I, P' @ [(j, succs - {x})]) =\n        pE_\\<alpha> - {(S ! j, x)}\\<rbrakk>\n       \\<Longrightarrow> xb = x", "apply (auto simp: GS.\\<alpha>_def) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sel_rem_last\n  \\<le> SPEC\n         (\\<lambda>r.\n             case r of (None, SBIP') \\<Rightarrow> False\n             | (Some v, SBIP') \\<Rightarrow>\n                 \\<exists>u.\n                    (u, v)\n                    \\<in> pE_\\<alpha> \\<inter>\n                          last p_\\<alpha> \\<times> UNIV \\<and>\n                    GS.\\<alpha> SBIP' =\n                    (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha> - {(u, v)}))\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "}"], ["proof (state)\nthis:\n  pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV \\<noteq>\n  {} \\<Longrightarrow>\n  sel_rem_last\n  \\<le> SPEC\n         (\\<lambda>r.\n             case r of (None, SBIP') \\<Rightarrow> False\n             | (Some v, SBIP') \\<Rightarrow>\n                 \\<exists>u.\n                    (u, v)\n                    \\<in> pE_\\<alpha> \\<inter>\n                          last p_\\<alpha> \\<times> UNIV \\<and>\n                    GS.\\<alpha> SBIP' =\n                    (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha> - {(u, v)}))\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "note SPEC_NE=this"], ["proof (state)\nthis:\n  pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV \\<noteq>\n  {} \\<Longrightarrow>\n  sel_rem_last\n  \\<le> SPEC\n         (\\<lambda>r.\n             case r of (None, SBIP') \\<Rightarrow> False\n             | (Some v, SBIP') \\<Rightarrow>\n                 \\<exists>u.\n                    (u, v)\n                    \\<in> pE_\\<alpha> \\<inter>\n                          last p_\\<alpha> \\<times> UNIV \\<and>\n                    GS.\\<alpha> SBIP' =\n                    (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha> - {(u, v)}))\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "have SPEC: \"sel_rem_last \\<le> SPEC (\\<lambda>r. case r of \n        (None, SBIP') \\<Rightarrow> SBIP' = SBIP \\<and> pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {} \\<and> GS_invar SBIP\n      | (Some v, SBIP') \\<Rightarrow> \\<exists>u. (u, v) \\<in> pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV \n                        \\<and> GS.\\<alpha> SBIP' = (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha> - {(u, v)})\n                        \\<and> GS_invar SBIP'\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> SPEC\n           (\\<lambda>r.\n               case r of\n               (None, SBIP') \\<Rightarrow>\n                 SBIP' = SBIP \\<and>\n                 pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV =\n                 {} \\<and>\n                 GS_invar SBIP\n               | (Some v, SBIP') \\<Rightarrow>\n                   \\<exists>u.\n                      (u, v)\n                      \\<in> pE_\\<alpha> \\<inter>\n                            last p_\\<alpha> \\<times> UNIV \\<and>\n                      GS.\\<alpha> SBIP' =\n                      (p_\\<alpha>, D_\\<alpha>,\n                       pE_\\<alpha> - {(u, v)}) \\<and>\n                      GS_invar SBIP')", "using INVAR"], ["proof (prove)\nusing this:\n  sel_rem_last \\<le> SPEC (GS_invar \\<circ> snd)\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> SPEC\n           (\\<lambda>r.\n               case r of\n               (None, SBIP') \\<Rightarrow>\n                 SBIP' = SBIP \\<and>\n                 pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV =\n                 {} \\<and>\n                 GS_invar SBIP\n               | (Some v, SBIP') \\<Rightarrow>\n                   \\<exists>u.\n                      (u, v)\n                      \\<in> pE_\\<alpha> \\<inter>\n                            last p_\\<alpha> \\<times> UNIV \\<and>\n                      GS.\\<alpha> SBIP' =\n                      (p_\\<alpha>, D_\\<alpha>,\n                       pE_\\<alpha> - {(u, v)}) \\<and>\n                      GS_invar SBIP')", "apply (cases \"pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sel_rem_last \\<le> SPEC (GS_invar \\<circ> snd);\n     pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {}\\<rbrakk>\n    \\<Longrightarrow> sel_rem_last\n                      \\<le> SPEC\n                             (\\<lambda>r.\n                                 case r of\n                                 (None, SBIP') \\<Rightarrow>\n                                   SBIP' = SBIP \\<and>\n                                   pE_\\<alpha> \\<inter>\n                                   last p_\\<alpha> \\<times> UNIV =\n                                   {} \\<and>\n                                   GS_invar SBIP\n                                 | (Some v, SBIP') \\<Rightarrow>\n                                     \\<exists>u.\n  (u, v) \\<in> pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV \\<and>\n  GS.\\<alpha> SBIP' =\n  (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha> - {(u, v)}) \\<and>\n  GS_invar SBIP')\n 2. \\<lbrakk>sel_rem_last \\<le> SPEC (GS_invar \\<circ> snd);\n     pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> sel_rem_last\n                      \\<le> SPEC\n                             (\\<lambda>r.\n                                 case r of\n                                 (None, SBIP') \\<Rightarrow>\n                                   SBIP' = SBIP \\<and>\n                                   pE_\\<alpha> \\<inter>\n                                   last p_\\<alpha> \\<times> UNIV =\n                                   {} \\<and>\n                                   GS_invar SBIP\n                                 | (Some v, SBIP') \\<Rightarrow>\n                                     \\<exists>u.\n  (u, v) \\<in> pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV \\<and>\n  GS.\\<alpha> SBIP' =\n  (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha> - {(u, v)}) \\<and>\n  GS_invar SBIP')", "apply (frule SPEC_E)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sel_rem_last \\<le> SPEC (GS_invar \\<circ> snd);\n     pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {};\n     sel_rem_last\n     \\<le> SPEC\n            (\\<lambda>r.\n                case r of (None, SBIP') \\<Rightarrow> SBIP' = SBIP\n                | (Some aa, SBIP') \\<Rightarrow> False)\\<rbrakk>\n    \\<Longrightarrow> sel_rem_last\n                      \\<le> SPEC\n                             (\\<lambda>r.\n                                 case r of\n                                 (None, SBIP') \\<Rightarrow>\n                                   SBIP' = SBIP \\<and>\n                                   pE_\\<alpha> \\<inter>\n                                   last p_\\<alpha> \\<times> UNIV =\n                                   {} \\<and>\n                                   GS_invar SBIP\n                                 | (Some v, SBIP') \\<Rightarrow>\n                                     \\<exists>u.\n  (u, v) \\<in> pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV \\<and>\n  GS.\\<alpha> SBIP' =\n  (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha> - {(u, v)}) \\<and>\n  GS_invar SBIP')\n 2. \\<lbrakk>sel_rem_last \\<le> SPEC (GS_invar \\<circ> snd);\n     pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> sel_rem_last\n                      \\<le> SPEC\n                             (\\<lambda>r.\n                                 case r of\n                                 (None, SBIP') \\<Rightarrow>\n                                   SBIP' = SBIP \\<and>\n                                   pE_\\<alpha> \\<inter>\n                                   last p_\\<alpha> \\<times> UNIV =\n                                   {} \\<and>\n                                   GS_invar SBIP\n                                 | (Some v, SBIP') \\<Rightarrow>\n                                     \\<exists>u.\n  (u, v) \\<in> pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV \\<and>\n  GS.\\<alpha> SBIP' =\n  (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha> - {(u, v)}) \\<and>\n  GS_invar SBIP')", "apply (auto split: option.splits simp: pw_le_iff; blast; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sel_rem_last \\<le> SPEC (GS_invar \\<circ> snd);\n     pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> sel_rem_last\n                      \\<le> SPEC\n                             (\\<lambda>r.\n                                 case r of\n                                 (None, SBIP') \\<Rightarrow>\n                                   SBIP' = SBIP \\<and>\n                                   pE_\\<alpha> \\<inter>\n                                   last p_\\<alpha> \\<times> UNIV =\n                                   {} \\<and>\n                                   GS_invar SBIP\n                                 | (Some v, SBIP') \\<Rightarrow>\n                                     \\<exists>u.\n  (u, v) \\<in> pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV \\<and>\n  GS.\\<alpha> SBIP' =\n  (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha> - {(u, v)}) \\<and>\n  GS_invar SBIP')", "apply (frule SPEC_NE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sel_rem_last \\<le> SPEC (GS_invar \\<circ> snd);\n     pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV \\<noteq> {};\n     sel_rem_last\n     \\<le> SPEC\n            (\\<lambda>r.\n                case r of (None, SBIP') \\<Rightarrow> False\n                | (Some v, SBIP') \\<Rightarrow>\n                    \\<exists>u.\n                       (u, v)\n                       \\<in> pE_\\<alpha> \\<inter>\n                             last p_\\<alpha> \\<times> UNIV \\<and>\n                       GS.\\<alpha> SBIP' =\n                       (p_\\<alpha>, D_\\<alpha>,\n                        pE_\\<alpha> - {(u, v)}))\\<rbrakk>\n    \\<Longrightarrow> sel_rem_last\n                      \\<le> SPEC\n                             (\\<lambda>r.\n                                 case r of\n                                 (None, SBIP') \\<Rightarrow>\n                                   SBIP' = SBIP \\<and>\n                                   pE_\\<alpha> \\<inter>\n                                   last p_\\<alpha> \\<times> UNIV =\n                                   {} \\<and>\n                                   GS_invar SBIP\n                                 | (Some v, SBIP') \\<Rightarrow>\n                                     \\<exists>u.\n  (u, v) \\<in> pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV \\<and>\n  GS.\\<alpha> SBIP' =\n  (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha> - {(u, v)}) \\<and>\n  GS_invar SBIP')", "apply (auto split: option.splits simp: pw_le_iff; blast; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sel_rem_last\n  \\<le> SPEC\n         (\\<lambda>r.\n             case r of\n             (None, SBIP') \\<Rightarrow>\n               SBIP' = SBIP \\<and>\n               pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV =\n               {} \\<and>\n               GS_invar SBIP\n             | (Some v, SBIP') \\<Rightarrow>\n                 \\<exists>u.\n                    (u, v)\n                    \\<in> pE_\\<alpha> \\<inter>\n                          last p_\\<alpha> \\<times> UNIV \\<and>\n                    GS.\\<alpha> SBIP' =\n                    (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha> - {(u, v)}) \\<and>\n                    GS_invar SBIP')\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "have X1: \"(\\<exists>y. (y=None \\<longrightarrow> \\<Phi> y) \\<and> (\\<forall>a b. y=Some (a,b) \\<longrightarrow> \\<Psi> y a b)) \\<longleftrightarrow>\n      (\\<Phi> None \\<or> (\\<exists>a b. \\<Psi> (Some (a,b)) a b))\" for \\<Phi> \\<Psi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>y.\n        (y = None \\<longrightarrow> \\<Phi> y) \\<and>\n        (\\<forall>a b. y = Some (a, b) \\<longrightarrow> \\<Psi> y a b)) =\n    (\\<Phi> None \\<or> (\\<exists>a b. \\<Psi> (Some (a, b)) a b))", "by auto"], ["proof (state)\nthis:\n  (\\<exists>y.\n      (y = None \\<longrightarrow> ?\\<Phi>1 y) \\<and>\n      (\\<forall>a b. y = Some (a, b) \\<longrightarrow> ?\\<Psi>1 y a b)) =\n  (?\\<Phi>1 None \\<or> (\\<exists>a b. ?\\<Psi>1 (Some (a, b)) a b))\n\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. sel_rem_last\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "apply (rule order_trans[OF SPEC])"], ["proof (prove)\ngoal (1 subgoal):\n 1. SPEC\n     (\\<lambda>r.\n         case r of\n         (None, SBIP') \\<Rightarrow>\n           SBIP' = SBIP \\<and>\n           pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {} \\<and>\n           GS_invar SBIP\n         | (Some v, SBIP') \\<Rightarrow>\n             \\<exists>u.\n                (u, v)\n                \\<in> pE_\\<alpha> \\<inter>\n                      last p_\\<alpha> \\<times> UNIV \\<and>\n                GS.\\<alpha> SBIP' =\n                (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha> - {(u, v)}) \\<and>\n                GS_invar SBIP')\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))", "unfolding select_edge_def select_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. SPEC\n     (\\<lambda>r.\n         case r of\n         (None, SBIP') \\<Rightarrow>\n           SBIP' = SBIP \\<and>\n           pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {} \\<and>\n           GS_invar SBIP\n         | (Some v, SBIP') \\<Rightarrow>\n             \\<exists>u.\n                (u, v)\n                \\<in> pE_\\<alpha> \\<inter>\n                      last p_\\<alpha> \\<times> UNIV \\<and>\n                GS.\\<alpha> SBIP' =\n                (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha> - {(u, v)}) \\<and>\n                GS_invar SBIP')\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n           (let (p, D, pE) = (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>)\n            in SELECT\n                (\\<lambda>e.\n                    e \\<in> pE \\<inter> last p \\<times> UNIV) \\<bind>\n               (\\<lambda>e.\n                   case e of None \\<Rightarrow> RETURN (None, p, D, pE)\n                   | Some (u, v) \\<Rightarrow>\n                       RETURN (Some v, p, D, pE - {(u, v)})))", "apply (simp \n        add: pw_le_iff refine_pw_simps prod_rel_sv \n        del: SELECT_pw\n        split: option.splits prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail\n     (SELECT\n       (\\<lambda>e.\n           e \\<in> pE_\\<alpha> \\<and>\n           e \\<in> last p_\\<alpha> \\<times> UNIV)) \\<longrightarrow>\n    (\\<forall>a aa ab ac b.\n        (a = None \\<longrightarrow>\n         (aa, ab, ac, b) = SBIP \\<and>\n         pE_\\<alpha> \\<inter> last p_\\<alpha> \\<times> UNIV = {} \\<and>\n         GS_invar SBIP \\<longrightarrow>\n         (SBIP, p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>) \\<in> GS_rel \\<and>\n         (\\<forall>a.\n             (\\<exists>b. (a, b) \\<in> pE_\\<alpha>) \\<longrightarrow>\n             a \\<notin> last p_\\<alpha>)) \\<and>\n        (\\<forall>x2.\n            a = Some x2 \\<longrightarrow>\n            (\\<exists>u.\n                (u, x2) \\<in> pE_\\<alpha> \\<and>\n                u \\<in> last p_\\<alpha> \\<and>\n                GS.\\<alpha> (aa, ab, ac, b) =\n                (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha> - {(u, x2)}) \\<and>\n                GS_invar (aa, ab, ac, b)) \\<longrightarrow>\n            (\\<exists>a ad ba.\n                ((aa, ab, ac, b), a, ad, ba) \\<in> GS_rel \\<and>\n                (\\<exists>y.\n                    (\\<exists>a b. y = Some (a, b)) \\<and>\n                    (\\<forall>aa b.\n                        y = Some (aa, b) \\<longrightarrow>\n                        (aa, b) \\<in> pE_\\<alpha> \\<and>\n                        aa \\<in> last p_\\<alpha> \\<and>\n                        b = x2 \\<and>\n                        p_\\<alpha> = a \\<and>\n                        D_\\<alpha> = ad \\<and>\n                        pE_\\<alpha> - {(aa, b)} = ba)))))", "apply (fastforce simp: br_def GS_rel_def GS.\\<alpha>_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sel_rem_last\n  \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n         (select_edge (p_\\<alpha>, D_\\<alpha>, pE_\\<alpha>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma find_seg_idx_of_correct:\n    assumes A: \"v\\<in>\\<Union>(set p_\\<alpha>)\"\n    shows \"(find_seg (S_idx_of v)) = idx_of p_\\<alpha> v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_seg (S_idx_of v) = idx_of p_\\<alpha> v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. find_seg (S_idx_of v) = idx_of p_\\<alpha> v", "note S_idx_of_correct[OF A] idx_of_props[OF p_\\<alpha>_disjoint_sym A]"], ["proof (state)\nthis:\n  S_idx_of v < length S\n  S ! S_idx_of v = v\n  idx_of p_\\<alpha> v < length p_\\<alpha>\n  v \\<in> p_\\<alpha> ! idx_of p_\\<alpha> v\n\ngoal (1 subgoal):\n 1. find_seg (S_idx_of v) = idx_of p_\\<alpha> v", "from find_seg_correct[OF \\<open>S_idx_of v < length S\\<close>]"], ["proof (chain)\npicking this:\n  S ! S_idx_of v \\<in> seg (find_seg (S_idx_of v))\n  find_seg (S_idx_of v) < length B", "have \n      \"find_seg (S_idx_of v) < length p_\\<alpha>\" \n      and \"S!S_idx_of v \\<in> p_\\<alpha>!find_seg (S_idx_of v)\""], ["proof (prove)\nusing this:\n  S ! S_idx_of v \\<in> seg (find_seg (S_idx_of v))\n  find_seg (S_idx_of v) < length B\n\ngoal (1 subgoal):\n 1. find_seg (S_idx_of v) < length p_\\<alpha> &&&\n    S ! S_idx_of v \\<in> p_\\<alpha> ! find_seg (S_idx_of v)", "unfolding p_\\<alpha>_def"], ["proof (prove)\nusing this:\n  S ! S_idx_of v \\<in> seg (find_seg (S_idx_of v))\n  find_seg (S_idx_of v) < length B\n\ngoal (1 subgoal):\n 1. find_seg (S_idx_of v) < length (map seg [0..<length B]) &&&\n    S ! S_idx_of v \\<in> map seg [0..<length B] ! find_seg (S_idx_of v)", "by auto"], ["proof (state)\nthis:\n  find_seg (S_idx_of v) < length p_\\<alpha>\n  S ! S_idx_of v \\<in> p_\\<alpha> ! find_seg (S_idx_of v)\n\ngoal (1 subgoal):\n 1. find_seg (S_idx_of v) = idx_of p_\\<alpha> v", "from idx_of_uniq[OF p_\\<alpha>_disjoint_sym this] \\<open>S ! S_idx_of v = v\\<close>"], ["proof (chain)\npicking this:\n  idx_of p_\\<alpha> (S ! S_idx_of v) = find_seg (S_idx_of v)\n  S ! S_idx_of v = v", "show ?thesis"], ["proof (prove)\nusing this:\n  idx_of p_\\<alpha> (S ! S_idx_of v) = find_seg (S_idx_of v)\n  S ! S_idx_of v = v\n\ngoal (1 subgoal):\n 1. find_seg (S_idx_of v) = idx_of p_\\<alpha> v", "by auto"], ["proof (state)\nthis:\n  find_seg (S_idx_of v) = idx_of p_\\<alpha> v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma idx_of_correct:\n    assumes A: \"v\\<in>\\<Union>(set p_\\<alpha>)\"\n    shows \"idx_of_impl v \\<le> SPEC (\\<lambda>x. x=idx_of p_\\<alpha> v \\<and> x<length B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idx_of_impl v\n    \\<le> SPEC (\\<lambda>x. x = idx_of p_\\<alpha> v \\<and> x < length B)", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> \\<Union> (set p_\\<alpha>)\n\ngoal (1 subgoal):\n 1. idx_of_impl v\n    \\<le> SPEC (\\<lambda>x. x = idx_of p_\\<alpha> v \\<and> x < length B)", "unfolding idx_of_impl_def"], ["proof (prove)\nusing this:\n  v \\<in> \\<Union> (set p_\\<alpha>)\n\ngoal (1 subgoal):\n 1. ASSERT (\\<exists>i. I v = Some (STACK i)) \\<bind>\n    (\\<lambda>_.\n        let j = S_idx_of v\n        in ASSERT (j < length S) \\<bind>\n           (\\<lambda>_. Let (find_seg_impl j) RETURN))\n    \\<le> SPEC (\\<lambda>x. x = idx_of p_\\<alpha> v \\<and> x < length B)", "apply (refine_rcg refine_vcg)"], ["proof (prove)\ngoal (4 subgoals):\n 1. v \\<in> \\<Union> (set p_\\<alpha>) \\<Longrightarrow>\n    \\<exists>i. I v = Some (STACK i)\n 2. \\<lbrakk>v \\<in> \\<Union> (set p_\\<alpha>);\n     \\<exists>i. I v = Some (STACK i)\\<rbrakk>\n    \\<Longrightarrow> S_idx_of v < length S\n 3. \\<lbrakk>v \\<in> \\<Union> (set p_\\<alpha>);\n     \\<exists>i. I v = Some (STACK i); S_idx_of v < length S\\<rbrakk>\n    \\<Longrightarrow> find_seg_impl (S_idx_of v) = idx_of p_\\<alpha> v\n 4. \\<lbrakk>v \\<in> \\<Union> (set p_\\<alpha>);\n     \\<exists>i. I v = Some (STACK i); S_idx_of v < length S\\<rbrakk>\n    \\<Longrightarrow> find_seg_impl (S_idx_of v) < length B", "apply (metis I_consistent in_set_conv_nth set_p_\\<alpha>_is_set_S)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>v \\<in> \\<Union> (set p_\\<alpha>);\n     \\<exists>i. I v = Some (STACK i)\\<rbrakk>\n    \\<Longrightarrow> S_idx_of v < length S\n 2. \\<lbrakk>v \\<in> \\<Union> (set p_\\<alpha>);\n     \\<exists>i. I v = Some (STACK i); S_idx_of v < length S\\<rbrakk>\n    \\<Longrightarrow> find_seg_impl (S_idx_of v) = idx_of p_\\<alpha> v\n 3. \\<lbrakk>v \\<in> \\<Union> (set p_\\<alpha>);\n     \\<exists>i. I v = Some (STACK i); S_idx_of v < length S\\<rbrakk>\n    \\<Longrightarrow> find_seg_impl (S_idx_of v) < length B", "apply (erule S_idx_of_correct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> \\<Union> (set p_\\<alpha>);\n     \\<exists>i. I v = Some (STACK i); S_idx_of v < length S\\<rbrakk>\n    \\<Longrightarrow> find_seg_impl (S_idx_of v) = idx_of p_\\<alpha> v\n 2. \\<lbrakk>v \\<in> \\<Union> (set p_\\<alpha>);\n     \\<exists>i. I v = Some (STACK i); S_idx_of v < length S\\<rbrakk>\n    \\<Longrightarrow> find_seg_impl (S_idx_of v) < length B", "apply (simp add: find_seg_impl find_seg_idx_of_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> \\<Union> (set p_\\<alpha>);\n     \\<exists>i. I v = Some (STACK i); S_idx_of v < length S\\<rbrakk>\n    \\<Longrightarrow> find_seg_impl (S_idx_of v) < length B", "by (metis find_seg_correct(2) find_seg_impl)"], ["", "lemma collapse_correct:\n    assumes A: \"v\\<in>\\<Union>(set p_\\<alpha>)\"\n    shows \"collapse_impl v \\<le>\\<Down>GS_rel (SPEC (\\<lambda>r. r=collapse v \\<alpha>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "assume \"i<length p_\\<alpha>\""], ["proof (state)\nthis:\n  i < length p_\\<alpha>\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "hence ILEN: \"i<length B\""], ["proof (prove)\nusing this:\n  i < length p_\\<alpha>\n\ngoal (1 subgoal):\n 1. i < length B", "by (simp add: p_\\<alpha>_def)"], ["proof (state)\nthis:\n  i < length B\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "let ?SBIP' = \"(S, take (Suc i) B, I, P)\""], ["proof (state)\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "have [simp]: \"GS.seg_start ?SBIP' i = seg_start i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GS.seg_start (S, take (Suc i) B, I, P) i = seg_start i", "by (simp add: GS.seg_start_def)"], ["proof (state)\nthis:\n  GS.seg_start (S, take (Suc i) B, I, P) i = seg_start i\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "have [simp]: \"GS.seg_end ?SBIP' i = seg_end (length B - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GS.seg_end (S, take (Suc i) B, I, P) i = seg_end (length B - 1)", "using ILEN"], ["proof (prove)\nusing this:\n  i < length B\n\ngoal (1 subgoal):\n 1. GS.seg_end (S, take (Suc i) B, I, P) i = seg_end (length B - 1)", "by (simp add: GS.seg_end_def min_absorb2)"], ["proof (state)\nthis:\n  GS.seg_end (S, take (Suc i) B, I, P) i = seg_end (length B - 1)\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "{"], ["proof (state)\nthis:\n  GS.seg_end (S, take (Suc i) B, I, P) i = seg_end (length B - 1)\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "assume B: \"seg_start i \\<le> j\" \"j < seg_end (length B - Suc 0)\""], ["proof (state)\nthis:\n  seg_start i \\<le> j\n  j < seg_end (length B - Suc 0)\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "hence \"j<length S\""], ["proof (prove)\nusing this:\n  seg_start i \\<le> j\n  j < seg_end (length B - Suc 0)\n\ngoal (1 subgoal):\n 1. j < length S", "using ILEN seg_end_bound"], ["proof (prove)\nusing this:\n  seg_start i \\<le> j\n  j < seg_end (length B - Suc 0)\n  i < length B\n  ?i < length B \\<Longrightarrow> seg_end ?i \\<le> length S\n\ngoal (1 subgoal):\n 1. j < length S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>seg_start i \\<le> j; j < seg_end (length B - Suc 0);\n     i < length B;\n     \\<And>i.\n        i < length B \\<Longrightarrow> seg_end i \\<le> length S\\<rbrakk>\n    \\<Longrightarrow> j < length S", "note B(2)"], ["proof (state)\nthis:\n  j < seg_end (length B - Suc 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>seg_start i \\<le> j; j < seg_end (length B - Suc 0);\n     i < length B;\n     \\<And>i.\n        i < length B \\<Longrightarrow> seg_end i \\<le> length S\\<rbrakk>\n    \\<Longrightarrow> j < length S", "also"], ["proof (state)\nthis:\n  j < seg_end (length B - Suc 0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>seg_start i \\<le> j; j < seg_end (length B - Suc 0);\n     i < length B;\n     \\<And>i.\n        i < length B \\<Longrightarrow> seg_end i \\<le> length S\\<rbrakk>\n    \\<Longrightarrow> j < length S", "from \\<open>i<length B\\<close>"], ["proof (chain)\npicking this:\n  i < length B", "have \"(length B - Suc 0) < length B\""], ["proof (prove)\nusing this:\n  i < length B\n\ngoal (1 subgoal):\n 1. length B - Suc 0 < length B", "by auto"], ["proof (state)\nthis:\n  length B - Suc 0 < length B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>seg_start i \\<le> j; j < seg_end (length B - Suc 0);\n     i < length B;\n     \\<And>i.\n        i < length B \\<Longrightarrow> seg_end i \\<le> length S\\<rbrakk>\n    \\<Longrightarrow> j < length S", "from seg_end_bound[OF this]"], ["proof (chain)\npicking this:\n  seg_end (length B - Suc 0) \\<le> length S", "have \"seg_end (length B - Suc 0) \\<le> length S\""], ["proof (prove)\nusing this:\n  seg_end (length B - Suc 0) \\<le> length S\n\ngoal (1 subgoal):\n 1. seg_end (length B - Suc 0) \\<le> length S", "."], ["proof (state)\nthis:\n  seg_end (length B - Suc 0) \\<le> length S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>seg_start i \\<le> j; j < seg_end (length B - Suc 0);\n     i < length B;\n     \\<And>i.\n        i < length B \\<Longrightarrow> seg_end i \\<le> length S\\<rbrakk>\n    \\<Longrightarrow> j < length S", "finally"], ["proof (chain)\npicking this:\n  j < length S", "show ?thesis"], ["proof (prove)\nusing this:\n  j < length S\n\ngoal (1 subgoal):\n 1. j < length S", "."], ["proof (state)\nthis:\n  j < length S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j < length S\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "have \"i \\<le> find_seg j \\<and> find_seg j < length B \n            \\<and> seg_start (find_seg j) \\<le> j \\<and> j < seg_end (find_seg j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> find_seg j \\<and>\n    find_seg j < length B \\<and>\n    seg_start (find_seg j) \\<le> j \\<and> j < seg_end (find_seg j)", "proof (intro conjI)"], ["proof (state)\ngoal (4 subgoals):\n 1. i \\<le> find_seg j\n 2. find_seg j < length B\n 3. seg_start (find_seg j) \\<le> j\n 4. j < seg_end (find_seg j)", "show \"i\\<le>find_seg j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> find_seg j", "by (metis le_trans not_less B(1) find_seg_bounds(2) \n                seg_end_less_start ILEN \\<open>j < length S\\<close>)"], ["proof (state)\nthis:\n  i \\<le> find_seg j\n\ngoal (3 subgoals):\n 1. find_seg j < length B\n 2. seg_start (find_seg j) \\<le> j\n 3. j < seg_end (find_seg j)", "qed (simp_all add: find_seg_bounds[OF \\<open>j<length S\\<close>])"], ["proof (state)\nthis:\n  i \\<le> find_seg j \\<and>\n  find_seg j < length B \\<and>\n  seg_start (find_seg j) \\<le> j \\<and> j < seg_end (find_seg j)\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>seg_start i \\<le> ?j2; ?j2 < seg_end (length B - Suc 0)\\<rbrakk>\n  \\<Longrightarrow> i \\<le> find_seg ?j2 \\<and>\n                    find_seg ?j2 < length B \\<and>\n                    seg_start (find_seg ?j2) \\<le> ?j2 \\<and>\n                    ?j2 < seg_end (find_seg ?j2)\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "note AUX1 = this"], ["proof (state)\nthis:\n  \\<lbrakk>seg_start i \\<le> ?j2; ?j2 < seg_end (length B - Suc 0)\\<rbrakk>\n  \\<Longrightarrow> i \\<le> find_seg ?j2 \\<and>\n                    find_seg ?j2 < length B \\<and>\n                    seg_start (find_seg ?j2) \\<le> ?j2 \\<and>\n                    ?j2 < seg_end (find_seg ?j2)\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>seg_start i \\<le> ?j2; ?j2 < seg_end (length B - Suc 0)\\<rbrakk>\n  \\<Longrightarrow> i \\<le> find_seg ?j2 \\<and>\n                    find_seg ?j2 < length B \\<and>\n                    seg_start (find_seg ?j2) \\<le> ?j2 \\<and>\n                    ?j2 < seg_end (find_seg ?j2)\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "fix Q and j::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "assume \"Q j\""], ["proof (state)\nthis:\n  Q j\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "hence \"\\<exists>i. S!j = S!i \\<and> Q i\""], ["proof (prove)\nusing this:\n  Q j\n\ngoal (1 subgoal):\n 1. \\<exists>i. S ! j = S ! i \\<and> Q i", "by blast"], ["proof (state)\nthis:\n  \\<exists>i. S ! j = S ! i \\<and> Q i\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "}"], ["proof (state)\nthis:\n  ?Q2 ?j2 \\<Longrightarrow> \\<exists>i. S ! ?j2 = S ! i \\<and> ?Q2 i\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "note AUX_ex_conj_SeqSI = this"], ["proof (state)\nthis:\n  ?Q2 ?j2 \\<Longrightarrow> \\<exists>i. S ! ?j2 = S ! i \\<and> ?Q2 i\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "have \"GS.seg ?SBIP' i = \\<Union> (seg ` {i..<length B})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GS.seg (S, take (Suc i) B, I, P) i = \\<Union> (seg ` {i..<length B})", "unfolding GS.seg_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. {GS.S (S, take (Suc i) B, I, P) ! j |j.\n     GS.seg_start (S, take (Suc i) B, I, P) i \\<le> j \\<and>\n     j < GS.seg_end (S, take (Suc i) B, I, P) i} =\n    (\\<Union>i\\<in>{i..<length B}.\n        {S ! j |j. seg_start i \\<le> j \\<and> j < seg_end i})", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. {S ! j |j. seg_start i \\<le> j \\<and> j < seg_end (length B - Suc 0)} =\n    (\\<Union>i\\<in>{i..<length B}.\n        {S ! j |j. seg_start i \\<le> j \\<and> j < seg_end i})", "apply (rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {S ! j |j. seg_start i \\<le> j \\<and> j < seg_end (length B - Suc 0)}\n    \\<subseteq> (\\<Union>i\\<in>{i..<length B}.\n                    {S ! j |j. seg_start i \\<le> j \\<and> j < seg_end i})\n 2. (\\<Union>i\\<in>{i..<length B}.\n        {S ! j |j. seg_start i \\<le> j \\<and> j < seg_end i})\n    \\<subseteq> {S ! j |j.\n                 seg_start i \\<le> j \\<and> j < seg_end (length B - Suc 0)}", "apply (auto dest!: AUX1) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>i\\<in>{i..<length B}.\n        {S ! j |j. seg_start i \\<le> j \\<and> j < seg_end i})\n    \\<subseteq> {S ! j |j.\n                 seg_start i \\<le> j \\<and> j < seg_end (length B - Suc 0)}", "(* The following three lines complete the proof. AUX_ex_conj_SeqSI\n            and all stuff \n            below would be unnecessary, if smt would be allowed for AFP.\n          apply (auto simp: seg_start_def seg_end_def split: if_split_asm)\n          apply (smt distinct_sorted_mono[OF B_sorted B_distinct])\n          apply (smt distinct_sorted_mono[OF B_sorted B_distinct] B_in_bound')\n          *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>i\\<in>{i..<length B}.\n        {S ! j |j. seg_start i \\<le> j \\<and> j < seg_end i})\n    \\<subseteq> {S ! j |j.\n                 seg_start i \\<le> j \\<and> j < seg_end (length B - Suc 0)}", "apply (auto \n            simp: seg_start_def seg_end_def \n            split: if_split_asm\n            intro!: AUX_ex_conj_SeqSI\n          )"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa j.\n       \\<lbrakk>B ! xa \\<le> j; Suc xa = length B; i \\<le> xa;\n        j < length S\\<rbrakk>\n       \\<Longrightarrow> B ! i \\<le> j\n 2. \\<And>xa j.\n       \\<lbrakk>B ! xa \\<le> j; Suc xa \\<noteq> length B; i \\<le> xa;\n        xa < length B; j < B ! Suc xa\\<rbrakk>\n       \\<Longrightarrow> B ! i \\<le> j\n 3. \\<And>xa j.\n       \\<lbrakk>B ! xa \\<le> j; Suc xa \\<noteq> length B; i \\<le> xa;\n        xa < length B; j < B ! Suc xa\\<rbrakk>\n       \\<Longrightarrow> j < length S", "apply (metis diff_diff_cancel le_diff_conv le_eq_less_or_eq \n           lessI trans_le_add1 \n           distinct_sorted_mono[OF B_sorted B_distinct, of i])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa j.\n       \\<lbrakk>B ! xa \\<le> j; Suc xa \\<noteq> length B; i \\<le> xa;\n        xa < length B; j < B ! Suc xa\\<rbrakk>\n       \\<Longrightarrow> B ! i \\<le> j\n 2. \\<And>xa j.\n       \\<lbrakk>B ! xa \\<le> j; Suc xa \\<noteq> length B; i \\<le> xa;\n        xa < length B; j < B ! Suc xa\\<rbrakk>\n       \\<Longrightarrow> j < length S", "apply (metis diff_diff_cancel le_diff_conv le_eq_less_or_eq \n           trans_le_add1 distinct_sorted_mono[OF B_sorted B_distinct, of i])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa j.\n       \\<lbrakk>B ! xa \\<le> j; Suc xa \\<noteq> length B; i \\<le> xa;\n        xa < length B; j < B ! Suc xa\\<rbrakk>\n       \\<Longrightarrow> j < length S", "apply (metis (hide_lams, no_types) Suc_lessD Suc_lessI less_trans_Suc\n           B_in_bound')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  GS.seg (S, take (Suc i) B, I, P) i = \\<Union> (seg ` {i..<length B})\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "}"], ["proof (state)\nthis:\n  GS.seg (S, take (Suc i) B, I, P) i = \\<Union> (seg ` {i..<length B})\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "note AUX2 = this"], ["proof (state)\nthis:\n  GS.seg (S, take (Suc i) B, I, P) i = \\<Union> (seg ` {i..<length B})\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "from ILEN"], ["proof (chain)\npicking this:\n  i < length B", "have \"GS.p_\\<alpha> (S, take (Suc i) B, I, P) = collapse_aux p_\\<alpha> i\""], ["proof (prove)\nusing this:\n  i < length B\n\ngoal (1 subgoal):\n 1. GS.p_\\<alpha> (S, take (Suc i) B, I, P) = collapse_aux p_\\<alpha> i", "unfolding GS.p_\\<alpha>_def collapse_aux_def"], ["proof (prove)\nusing this:\n  i < length B\n\ngoal (1 subgoal):\n 1. map (GS.seg (S, take (Suc i) B, I, P))\n     [0..<length (GS.B (S, take (Suc i) B, I, P))] =\n    take i (map seg [0..<length B]) @\n    [\\<Union> (set (drop i (map seg [0..<length B])))]", "apply (simp add: min_absorb2 drop_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length B \\<Longrightarrow>\n    map (GS.seg (S, take (Suc i) B, I, P)) [0..<i] =\n    take i (map seg [0..<length B]) \\<and>\n    GS.seg (S, take (Suc i) B, I, P) i = \\<Union> (seg ` {i..<length B})", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. i < length B \\<Longrightarrow>\n    map (GS.seg (S, take (Suc i) B, I, P)) [0..<i] =\n    take i (map seg [0..<length B])\n 2. i < length B \\<Longrightarrow>\n    GS.seg (S, take (Suc i) B, I, P) i = \\<Union> (seg ` {i..<length B})", "apply (auto \n          simp: GS.seg_def[abs_def] GS.seg_start_def GS.seg_end_def take_map) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length B \\<Longrightarrow>\n    GS.seg (S, take (Suc i) B, I, P) i = \\<Union> (seg ` {i..<length B})", "apply (simp add: AUX2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  GS.p_\\<alpha> (S, take (Suc i) B, I, P) = collapse_aux p_\\<alpha> i\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "}"], ["proof (state)\nthis:\n  ?i2 < length p_\\<alpha> \\<Longrightarrow>\n  GS.p_\\<alpha> (S, take (Suc ?i2) B, I, P) = collapse_aux p_\\<alpha> ?i2\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "note AUX1 = this"], ["proof (state)\nthis:\n  ?i2 < length p_\\<alpha> \\<Longrightarrow>\n  GS.p_\\<alpha> (S, take (Suc ?i2) B, I, P) = collapse_aux p_\\<alpha> ?i2\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "from A"], ["proof (chain)\npicking this:\n  v \\<in> \\<Union> (set p_\\<alpha>)", "obtain i where [simp]: \"I v = Some (STACK i)\""], ["proof (prove)\nusing this:\n  v \\<in> \\<Union> (set p_\\<alpha>)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        I v = Some (STACK i) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using I_consistent set_p_\\<alpha>_is_set_S"], ["proof (prove)\nusing this:\n  v \\<in> \\<Union> (set p_\\<alpha>)\n  (I ?v = Some (STACK ?j)) = (?j < length S \\<and> ?v = S ! ?j)\n  \\<Union> (set p_\\<alpha>) = set S\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        I v = Some (STACK i) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_nth)"], ["proof (state)\nthis:\n  I v = Some (STACK i)\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "{"], ["proof (state)\nthis:\n  I v = Some (STACK i)\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "have \"(collapse_aux p_\\<alpha> (idx_of p_\\<alpha> v), D_\\<alpha>, pE_\\<alpha>) =\n        GS.\\<alpha> (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (collapse_aux p_\\<alpha> (idx_of p_\\<alpha> v), D_\\<alpha>,\n     pE_\\<alpha>) =\n    GS.\\<alpha> (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P)", "unfolding GS.\\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (collapse_aux p_\\<alpha> (idx_of p_\\<alpha> v), D_\\<alpha>,\n     pE_\\<alpha>) =\n    (GS.p_\\<alpha> (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P),\n     GS.D_\\<alpha> (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P),\n     GS.pE_\\<alpha> (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P))", "using idx_of_props[OF p_\\<alpha>_disjoint_sym A]"], ["proof (prove)\nusing this:\n  idx_of p_\\<alpha> v < length p_\\<alpha>\n  v \\<in> p_\\<alpha> ! idx_of p_\\<alpha> v\n\ngoal (1 subgoal):\n 1. (collapse_aux p_\\<alpha> (idx_of p_\\<alpha> v), D_\\<alpha>,\n     pE_\\<alpha>) =\n    (GS.p_\\<alpha> (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P),\n     GS.D_\\<alpha> (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P),\n     GS.pE_\\<alpha> (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P))", "by (simp add: AUX1)"], ["proof (state)\nthis:\n  (collapse_aux p_\\<alpha> (idx_of p_\\<alpha> v), D_\\<alpha>, pE_\\<alpha>) =\n  GS.\\<alpha> (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P)\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "}"], ["proof (state)\nthis:\n  (collapse_aux p_\\<alpha> (idx_of p_\\<alpha> v), D_\\<alpha>, pE_\\<alpha>) =\n  GS.\\<alpha> (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P)\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "note ABS=this"], ["proof (state)\nthis:\n  (collapse_aux p_\\<alpha> (idx_of p_\\<alpha> v), D_\\<alpha>, pE_\\<alpha>) =\n  GS.\\<alpha> (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P)\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "{"], ["proof (state)\nthis:\n  (collapse_aux p_\\<alpha> (idx_of p_\\<alpha> v), D_\\<alpha>, pE_\\<alpha>) =\n  GS.\\<alpha> (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P)\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "have \"GS_invar (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GS_invar (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P)", "apply unfold_locales"], ["proof (prove)\ngoal (9 subgoals):\n 1. set (GS.B (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P))\n    \\<subseteq> {0..<length\n                      (GS.S (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P))}\n 2. sorted (GS.B (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P))\n 3. distinct (GS.B (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P))\n 4. GS.S (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P) \\<noteq>\n    [] \\<Longrightarrow>\n    GS.B (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P) \\<noteq> [] \\<and>\n    GS.B (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P) ! 0 = 0\n 5. distinct (GS.S (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P))\n 6. \\<And>va j.\n       (GS.I (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P) va =\n        Some (STACK j)) =\n       (j < length\n             (GS.S (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P)) \\<and>\n        va = GS.S (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P) ! j)\n 7. sorted (map fst (GS.P (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P)))\n 8. distinct (map fst (GS.P (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P)))\n 9. set (GS.P (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P))\n    \\<subseteq> {0..<length\n                      (GS.S\n                        (S, take (Suc (idx_of p_\\<alpha> v)) B, I,\n                         P))} \\<times>\n                {y. {} \\<noteq> y}", "apply simp_all"], ["proof (prove)\ngoal (9 subgoals):\n 1. set (take (Suc (idx_of p_\\<alpha> v)) B) \\<subseteq> {0..<length S}\n 2. sorted (take (Suc (idx_of p_\\<alpha> v)) B)\n 3. distinct (take (Suc (idx_of p_\\<alpha> v)) B)\n 4. S \\<noteq> [] \\<Longrightarrow> B \\<noteq> [] \\<and> B ! 0 = 0\n 5. distinct S\n 6. \\<And>v j. (I v = Some (STACK j)) = (j < length S \\<and> v = S ! j)\n 7. sorted (map fst P)\n 8. distinct (map fst P)\n 9. set P \\<subseteq> {0..<length S} \\<times> {y. {} \\<noteq> y}", "using B_in_bound B_sorted B_distinct"], ["proof (prove)\nusing this:\n  set B \\<subseteq> {0..<length S}\n  sorted B\n  distinct B\n\ngoal (9 subgoals):\n 1. set (take (Suc (idx_of p_\\<alpha> v)) B) \\<subseteq> {0..<length S}\n 2. sorted (take (Suc (idx_of p_\\<alpha> v)) B)\n 3. distinct (take (Suc (idx_of p_\\<alpha> v)) B)\n 4. S \\<noteq> [] \\<Longrightarrow> B \\<noteq> [] \\<and> B ! 0 = 0\n 5. distinct S\n 6. \\<And>v j. (I v = Some (STACK j)) = (j < length S \\<and> v = S ! j)\n 7. sorted (map fst P)\n 8. distinct (map fst P)\n 9. set P \\<subseteq> {0..<length S} \\<times> {y. {} \\<noteq> y}", "apply (auto simp: sorted_take dest: in_set_takeD) [3]"], ["proof (prove)\ngoal (6 subgoals):\n 1. S \\<noteq> [] \\<Longrightarrow> B \\<noteq> [] \\<and> B ! 0 = 0\n 2. distinct S\n 3. \\<And>v j. (I v = Some (STACK j)) = (j < length S \\<and> v = S ! j)\n 4. sorted (map fst P)\n 5. distinct (map fst P)\n 6. set P \\<subseteq> {0..<length S} \\<times> {y. {} \\<noteq> y}", "using B0 S_distinct"], ["proof (prove)\nusing this:\n  S \\<noteq> [] \\<Longrightarrow> B \\<noteq> [] \\<and> B ! 0 = 0\n  distinct S\n\ngoal (6 subgoals):\n 1. S \\<noteq> [] \\<Longrightarrow> B \\<noteq> [] \\<and> B ! 0 = 0\n 2. distinct S\n 3. \\<And>v j. (I v = Some (STACK j)) = (j < length S \\<and> v = S ! j)\n 4. sorted (map fst P)\n 5. distinct (map fst P)\n 6. set P \\<subseteq> {0..<length S} \\<times> {y. {} \\<noteq> y}", "apply auto [2]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>v j. (I v = Some (STACK j)) = (j < length S \\<and> v = S ! j)\n 2. sorted (map fst P)\n 3. distinct (map fst P)\n 4. set P \\<subseteq> {0..<length S} \\<times> {y. {} \\<noteq> y}", "using I_consistent"], ["proof (prove)\nusing this:\n  (I ?v = Some (STACK ?j)) = (?j < length S \\<and> ?v = S ! ?j)\n\ngoal (4 subgoals):\n 1. \\<And>v j. (I v = Some (STACK j)) = (j < length S \\<and> v = S ! j)\n 2. sorted (map fst P)\n 3. distinct (map fst P)\n 4. set P \\<subseteq> {0..<length S} \\<times> {y. {} \\<noteq> y}", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. sorted (map fst P)\n 2. distinct (map fst P)\n 3. set P \\<subseteq> {0..<length S} \\<times> {y. {} \\<noteq> y}", "using P_sorted P_distinct P_bound"], ["proof (prove)\nusing this:\n  sorted (map fst P)\n  distinct (map fst P)\n  set P \\<subseteq> {0..<length S} \\<times> {y. {} \\<noteq> y}\n\ngoal (3 subgoals):\n 1. sorted (map fst P)\n 2. distinct (map fst P)\n 3. set P \\<subseteq> {0..<length S} \\<times> {y. {} \\<noteq> y}", "apply auto [3]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  GS_invar (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P)\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "}"], ["proof (state)\nthis:\n  GS_invar (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P)\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "note INV=this"], ["proof (state)\nthis:\n  GS_invar (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P)\n\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. collapse_impl v\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "unfolding collapse_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. idx_of_impl v \\<bind>\n    (\\<lambda>i.\n        ASSERT (i + 1 \\<le> length B) \\<bind>\n        (\\<lambda>_. let B = take (i + 1) B in RETURN (S, B, I, P)))\n    \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))", "apply (refine_rcg SPEC_refine refine_vcg order_trans[OF idx_of_correct])"], ["proof (prove)\ngoal (3 subgoals):\n 1. v \\<in> \\<Union> (set p_\\<alpha>)\n 2. \\<And>x.\n       x = idx_of p_\\<alpha> v \\<and> x < length B \\<Longrightarrow>\n       x + 1 \\<le> length B\n 3. \\<And>x.\n       \\<lbrakk>x = idx_of p_\\<alpha> v \\<and> x < length B;\n        x + 1 \\<le> length B\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x'.\n                            ((S, take (x + 1) B, I, P), x')\n                            \\<in> GS_rel \\<and>\n                            x' = collapse v \\<alpha>", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x = idx_of p_\\<alpha> v \\<and> x < length B \\<Longrightarrow>\n       x + 1 \\<le> length B\n 2. \\<And>x.\n       \\<lbrakk>x = idx_of p_\\<alpha> v \\<and> x < length B;\n        x + 1 \\<le> length B\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x'.\n                            ((S, take (x + 1) B, I, P), x')\n                            \\<in> GS_rel \\<and>\n                            x' = collapse v \\<alpha>", "apply (metis discrete)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x = idx_of p_\\<alpha> v \\<and> x < length B;\n        x + 1 \\<le> length B\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x'.\n                            ((S, take (x + 1) B, I, P), x')\n                            \\<in> GS_rel \\<and>\n                            x' = collapse v \\<alpha>", "apply (simp add: collapse_def \\<alpha>_def find_seg_impl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (idx_of p_\\<alpha> v) \\<le> length B \\<Longrightarrow>\n    ((S, take (Suc (idx_of p_\\<alpha> v)) B, I, P),\n     collapse_aux p_\\<alpha> (idx_of p_\\<alpha> v), D_\\<alpha>, pE_\\<alpha>)\n    \\<in> GS_rel", "unfolding GS_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (idx_of p_\\<alpha> v) \\<le> length B \\<Longrightarrow>\n    ((S, take (Suc (idx_of p_\\<alpha> v)) B, I, P),\n     collapse_aux p_\\<alpha> (idx_of p_\\<alpha> v), D_\\<alpha>, pE_\\<alpha>)\n    \\<in> br GS.\\<alpha> GS_invar", "apply (rule brI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Suc (idx_of p_\\<alpha> v) \\<le> length B \\<Longrightarrow>\n    (collapse_aux p_\\<alpha> (idx_of p_\\<alpha> v), D_\\<alpha>,\n     pE_\\<alpha>) =\n    GS.\\<alpha> (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P)\n 2. Suc (idx_of p_\\<alpha> v) \\<le> length B \\<Longrightarrow>\n    GS_invar (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P)", "apply (rule ABS)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (idx_of p_\\<alpha> v) \\<le> length B \\<Longrightarrow>\n    GS_invar (S, take (Suc (idx_of p_\\<alpha> v)) B, I, P)", "apply (rule INV)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  collapse_impl v\n  \\<le> \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v \\<alpha>))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>Technical adjustment for avoiding case-splits for definitions\n  extracted from GS-locale\\<close>"], ["", "lemma opt_GSdef: \"f \\<equiv> g \\<Longrightarrow> f s \\<equiv> case s of (S,B,I,P) \\<Rightarrow> g (S,B,I,P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<equiv> g \\<Longrightarrow>\n    f s \\<equiv> case s of (S, B, I, P) \\<Rightarrow> g (S, B, I, P)", "by auto"], ["", "lemma ext_def: \"f\\<equiv>g \\<Longrightarrow> f x \\<equiv> g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<equiv> g \\<Longrightarrow> f x \\<equiv> g x", "by auto"], ["", "context fr_graph begin"], ["", "definition \"push_impl v s \\<equiv> GS.push_impl s v (E``{v})\""], ["", "lemmas push_impl_def_opt = \n    push_impl_def[abs_def, \n    THEN ext_def, THEN opt_GSdef, unfolded GS.push_impl_def GS_sel_simps]"], ["", "text \\<open>Definition for presentation\\<close>"], ["", "lemma \"push_impl v (S,B,I,P) \\<equiv> (S@[v], B@[length S], I(v\\<mapsto>STACK (length S)),\n    if E``{v}={} then P else P@[(length S,E``{v})])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. push_impl v (S, B, I, P) \\<equiv>\n    (S @ [v], B @ [length S], I(v \\<mapsto> STACK (length S)),\n     if E `` {v} = {} then P else P @ [(length S, E `` {v})])", "unfolding push_impl_def GS.push_impl_def GS.P_def GS.S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. let _ = stat_newnode ();\n        j = length (case (S, B, I, P) of (S, B, I, P) \\<Rightarrow> S);\n        Sa = (case (S, B, I, P) of (S, B, I, P) \\<Rightarrow> S) @ [v];\n        Ba = GS.B (S, B, I, P) @ [j];\n        Ia = GS.I (S, B, I, P)(v \\<mapsto> STACK j);\n        P = if E `` {v} = {}\n            then case (S, B, I, P) of (S, B, I, P) \\<Rightarrow> P\n            else (case (S, B, I, P) of (S, B, I, P) \\<Rightarrow> P) @\n                 [(j, E `` {v})]\n    in (Sa, Ba, Ia, P) \\<equiv>\n    (S @ [v], B @ [length S], I(v \\<mapsto> STACK (length S)),\n     if E `` {v} = {} then P else P @ [(length S, E `` {v})])", "by (auto simp: Let_def)"], ["", "lemma GS_\\<alpha>_split: \n    \"GS.\\<alpha> s = (p,D,pE) \\<longleftrightarrow> (p=GS.p_\\<alpha> s \\<and> D=GS.D_\\<alpha> s \\<and> pE=GS.pE_\\<alpha> s)\"\n    \"(p,D,pE) = GS.\\<alpha> s \\<longleftrightarrow> (p=GS.p_\\<alpha> s \\<and> D=GS.D_\\<alpha> s \\<and> pE=GS.pE_\\<alpha> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GS.\\<alpha> s = (p, D, pE)) =\n    (p = GS.p_\\<alpha> s \\<and>\n     D = GS.D_\\<alpha> s \\<and> pE = GS.pE_\\<alpha> s) &&&\n    ((p, D, pE) = GS.\\<alpha> s) =\n    (p = GS.p_\\<alpha> s \\<and>\n     D = GS.D_\\<alpha> s \\<and> pE = GS.pE_\\<alpha> s)", "by (auto simp add: GS.\\<alpha>_def)"], ["", "lemma push_refine:\n    assumes A: \"(s,(p,D,pE))\\<in>GS_rel\" \"(v,v')\\<in>Id\"\n    assumes B: \"v\\<notin>\\<Union>(set p)\" \"v\\<notin>D\"\n    shows \"(push_impl v s, push v' (p,D,pE))\\<in>GS_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (push_impl v s, push v' (p, D, pE)) \\<in> GS_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (push_impl v s, push v' (p, D, pE)) \\<in> GS_rel", "from A"], ["proof (chain)\npicking this:\n  (s, p, D, pE) \\<in> GS_rel\n  (v, v') \\<in> Id", "have [simp]: \"p=GS.p_\\<alpha> s \\<and> D=GS.D_\\<alpha> s \\<and> pE=GS.pE_\\<alpha> s\" \"v'=v\" \n      and INV: \"GS_invar s\""], ["proof (prove)\nusing this:\n  (s, p, D, pE) \\<in> GS_rel\n  (v, v') \\<in> Id\n\ngoal (1 subgoal):\n 1. (p = GS.p_\\<alpha> s \\<and>\n     D = GS.D_\\<alpha> s \\<and> pE = GS.pE_\\<alpha> s &&&\n     v' = v) &&&\n    GS_invar s", "by (auto simp add: GS_rel_def br_def GS_\\<alpha>_split)"], ["proof (state)\nthis:\n  p = GS.p_\\<alpha> s \\<and>\n  D = GS.D_\\<alpha> s \\<and> pE = GS.pE_\\<alpha> s\n  v' = v\n  GS_invar s\n\ngoal (1 subgoal):\n 1. (push_impl v s, push v' (p, D, pE)) \\<in> GS_rel", "from INV B"], ["proof (chain)\npicking this:\n  GS_invar s\n  v \\<notin> \\<Union> (set p)\n  v \\<notin> D", "show ?thesis"], ["proof (prove)\nusing this:\n  GS_invar s\n  v \\<notin> \\<Union> (set p)\n  v \\<notin> D\n\ngoal (1 subgoal):\n 1. (push_impl v s, push v' (p, D, pE)) \\<in> GS_rel", "by (auto \n        simp: GS_rel_def br_def GS_invar.push_correct push_impl_def push_def)"], ["proof (state)\nthis:\n  (push_impl v s, push v' (p, D, pE)) \\<in> GS_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"pop_impl s \\<equiv> GS.pop_impl s\""], ["", "lemmas pop_impl_def_opt = \n    pop_impl_def[abs_def, THEN opt_GSdef, unfolded GS.pop_impl_def\n    GS.mark_as_done_def GS.seg_start_def GS.seg_end_def \n    GS_sel_simps]"], ["", "lemma pop_refine:\n    assumes A: \"(s,(p,D,pE))\\<in>GS_rel\"\n    assumes B: \"p \\<noteq> []\" \"pE \\<inter> last p \\<times> UNIV = {}\"\n    shows \"pop_impl s \\<le> \\<Down>GS_rel (RETURN (pop (p,D,pE)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pop_impl s \\<le> \\<Down> GS_rel (RETURN (pop (p, D, pE)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. pop_impl s \\<le> \\<Down> GS_rel (RETURN (pop (p, D, pE)))", "from A"], ["proof (chain)\npicking this:\n  (s, p, D, pE) \\<in> GS_rel", "have [simp]: \"p=GS.p_\\<alpha> s \\<and> D=GS.D_\\<alpha> s \\<and> pE=GS.pE_\\<alpha> s\" \n      and INV: \"GS_invar s\""], ["proof (prove)\nusing this:\n  (s, p, D, pE) \\<in> GS_rel\n\ngoal (1 subgoal):\n 1. p = GS.p_\\<alpha> s \\<and>\n    D = GS.D_\\<alpha> s \\<and> pE = GS.pE_\\<alpha> s &&&\n    GS_invar s", "by (auto simp add: GS_rel_def br_def GS_\\<alpha>_split)"], ["proof (state)\nthis:\n  p = GS.p_\\<alpha> s \\<and>\n  D = GS.D_\\<alpha> s \\<and> pE = GS.pE_\\<alpha> s\n  GS_invar s\n\ngoal (1 subgoal):\n 1. pop_impl s \\<le> \\<Down> GS_rel (RETURN (pop (p, D, pE)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. pop_impl s \\<le> \\<Down> GS_rel (RETURN (pop (p, D, pE)))", "unfolding pop_impl_def[abs_def] pop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. GS.pop_impl s\n    \\<le> \\<Down> GS_rel\n           (RETURN\n             (let (p, D, pE) = (p, D, pE); (p, V) = (butlast p, last p);\n                  D = V \\<union> D\n              in (p, D, pE)))", "apply (rule order_trans[OF GS_invar.pop_correct])"], ["proof (prove)\ngoal (4 subgoals):\n 1. GS_invar s\n 2. GS.p_\\<alpha> s \\<noteq> []\n 3. GS.pE_\\<alpha> s \\<inter> last (GS.p_\\<alpha> s) \\<times> UNIV = {}\n 4. \\<Down> GS_rel\n     (SPEC\n       (\\<lambda>r.\n           r =\n           (butlast (GS.p_\\<alpha> s),\n            GS.D_\\<alpha> s \\<union> last (GS.p_\\<alpha> s),\n            GS.pE_\\<alpha> s)))\n    \\<le> \\<Down> GS_rel\n           (RETURN\n             (let (p, D, pE) = (p, D, pE); (p, V) = (butlast p, last p);\n                  D = V \\<union> D\n              in (p, D, pE)))", "using INV B"], ["proof (prove)\nusing this:\n  GS_invar s\n  p \\<noteq> []\n  pE \\<inter> last p \\<times> UNIV = {}\n\ngoal (4 subgoals):\n 1. GS_invar s\n 2. GS.p_\\<alpha> s \\<noteq> []\n 3. GS.pE_\\<alpha> s \\<inter> last (GS.p_\\<alpha> s) \\<times> UNIV = {}\n 4. \\<Down> GS_rel\n     (SPEC\n       (\\<lambda>r.\n           r =\n           (butlast (GS.p_\\<alpha> s),\n            GS.D_\\<alpha> s \\<union> last (GS.p_\\<alpha> s),\n            GS.pE_\\<alpha> s)))\n    \\<le> \\<Down> GS_rel\n           (RETURN\n             (let (p, D, pE) = (p, D, pE); (p, V) = (butlast p, last p);\n                  D = V \\<union> D\n              in (p, D, pE)))", "apply (simp_all add: Un_commute RETURN_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  pop_impl s \\<le> \\<Down> GS_rel (RETURN (pop (p, D, pE)))\n\ngoal:\nNo subgoals!", "qed"], ["", "thm pop_refine[no_vars]"], ["", "definition \"collapse_impl v s \\<equiv> GS.collapse_impl s v\""], ["", "lemmas collapse_impl_def_opt = \n    collapse_impl_def[abs_def, \n    THEN ext_def, THEN opt_GSdef, unfolded GS.collapse_impl_def GS_sel_simps]"], ["", "lemma collapse_refine:\n    assumes A: \"(s,(p,D,pE))\\<in>GS_rel\" \"(v,v')\\<in>Id\"\n    assumes B: \"v'\\<in>\\<Union>(set p)\"\n    shows \"collapse_impl v s \\<le>\\<Down>GS_rel (RETURN (collapse v' (p,D,pE)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collapse_impl v s \\<le> \\<Down> GS_rel (RETURN (collapse v' (p, D, pE)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. collapse_impl v s \\<le> \\<Down> GS_rel (RETURN (collapse v' (p, D, pE)))", "from A"], ["proof (chain)\npicking this:\n  (s, p, D, pE) \\<in> GS_rel\n  (v, v') \\<in> Id", "have [simp]: \"p=GS.p_\\<alpha> s \\<and> D=GS.D_\\<alpha> s \\<and> pE=GS.pE_\\<alpha> s\" \"v'=v\" \n      and INV: \"GS_invar s\""], ["proof (prove)\nusing this:\n  (s, p, D, pE) \\<in> GS_rel\n  (v, v') \\<in> Id\n\ngoal (1 subgoal):\n 1. (p = GS.p_\\<alpha> s \\<and>\n     D = GS.D_\\<alpha> s \\<and> pE = GS.pE_\\<alpha> s &&&\n     v' = v) &&&\n    GS_invar s", "by (auto simp add: GS_rel_def br_def GS_\\<alpha>_split)"], ["proof (state)\nthis:\n  p = GS.p_\\<alpha> s \\<and>\n  D = GS.D_\\<alpha> s \\<and> pE = GS.pE_\\<alpha> s\n  v' = v\n  GS_invar s\n\ngoal (1 subgoal):\n 1. collapse_impl v s \\<le> \\<Down> GS_rel (RETURN (collapse v' (p, D, pE)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. collapse_impl v s \\<le> \\<Down> GS_rel (RETURN (collapse v' (p, D, pE)))", "unfolding collapse_impl_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. GS.collapse_impl s v\n    \\<le> \\<Down> GS_rel (RETURN (collapse v' (p, D, pE)))", "apply (rule order_trans[OF GS_invar.collapse_correct])"], ["proof (prove)\ngoal (3 subgoals):\n 1. GS_invar s\n 2. v \\<in> \\<Union> (set (GS.p_\\<alpha> s))\n 3. \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v (GS.\\<alpha> s)))\n    \\<le> \\<Down> GS_rel (RETURN (collapse v' (p, D, pE)))", "using INV B"], ["proof (prove)\nusing this:\n  GS_invar s\n  v' \\<in> \\<Union> (set p)\n\ngoal (3 subgoals):\n 1. GS_invar s\n 2. v \\<in> \\<Union> (set (GS.p_\\<alpha> s))\n 3. \\<Down> GS_rel (SPEC (\\<lambda>r. r = collapse v (GS.\\<alpha> s)))\n    \\<le> \\<Down> GS_rel (RETURN (collapse v' (p, D, pE)))", "by (simp_all add: GS.\\<alpha>_def RETURN_def)"], ["proof (state)\nthis:\n  collapse_impl v s \\<le> \\<Down> GS_rel (RETURN (collapse v' (p, D, pE)))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"select_edge_impl s \\<equiv> GS.sel_rem_last s\""], ["", "lemmas select_edge_impl_def_opt = \n    select_edge_impl_def[abs_def, \n      THEN opt_GSdef, \n      unfolded GS.sel_rem_last_def GS.seg_start_def GS_sel_simps]"], ["", "lemma select_edge_refine: \n    assumes A: \"(s,(p,D,pE))\\<in>GS_rel\"\n    assumes NE: \"p \\<noteq> []\"\n    shows \"select_edge_impl s \\<le> \\<Down>(Id \\<times>\\<^sub>r GS_rel) (select_edge (p,D,pE))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. select_edge_impl s\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel) (select_edge (p, D, pE))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. select_edge_impl s\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel) (select_edge (p, D, pE))", "from A"], ["proof (chain)\npicking this:\n  (s, p, D, pE) \\<in> GS_rel", "have [simp]: \"p=GS.p_\\<alpha> s \\<and> D=GS.D_\\<alpha> s \\<and> pE=GS.pE_\\<alpha> s\" \n      and INV: \"GS_invar s\""], ["proof (prove)\nusing this:\n  (s, p, D, pE) \\<in> GS_rel\n\ngoal (1 subgoal):\n 1. p = GS.p_\\<alpha> s \\<and>\n    D = GS.D_\\<alpha> s \\<and> pE = GS.pE_\\<alpha> s &&&\n    GS_invar s", "by (auto simp add: GS_rel_def br_def GS_\\<alpha>_split)"], ["proof (state)\nthis:\n  p = GS.p_\\<alpha> s \\<and>\n  D = GS.D_\\<alpha> s \\<and> pE = GS.pE_\\<alpha> s\n  GS_invar s\n\ngoal (1 subgoal):\n 1. select_edge_impl s\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel) (select_edge (p, D, pE))", "from INV NE"], ["proof (chain)\npicking this:\n  GS_invar s\n  p \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  GS_invar s\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. select_edge_impl s\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel) (select_edge (p, D, pE))", "unfolding select_edge_impl_def"], ["proof (prove)\nusing this:\n  GS_invar s\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. GS.sel_rem_last s\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel) (select_edge (p, D, pE))", "using GS_invar.sel_rem_last_correct[OF INV] NE"], ["proof (prove)\nusing this:\n  GS_invar s\n  p \\<noteq> []\n  GS.p_\\<alpha> s \\<noteq> [] \\<Longrightarrow>\n  GS.sel_rem_last s\n  \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n         (select_edge (GS.p_\\<alpha> s, GS.D_\\<alpha> s, GS.pE_\\<alpha> s))\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. GS.sel_rem_last s\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel) (select_edge (p, D, pE))", "by (simp)"], ["proof (state)\nthis:\n  select_edge_impl s\n  \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel) (select_edge (p, D, pE))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"initial_impl v0 I \\<equiv> GS_initial_impl I v0 (E``{v0})\""], ["", "lemma initial_refine:\n    \"\\<lbrakk>v0\\<notin>D0; (I,D0)\\<in>oGS_rel; (v0i,v0)\\<in>Id\\<rbrakk> \n    \\<Longrightarrow> (initial_impl v0i I,initial v0 D0)\\<in>GS_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v0 \\<notin> D0; (I, D0) \\<in> oGS_rel;\n     (v0i, v0) \\<in> Id\\<rbrakk>\n    \\<Longrightarrow> (initial_impl v0i I, initial v0 D0) \\<in> GS_rel", "unfolding initial_impl_def GS_rel_def br_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v0 \\<notin> D0; (I, D0) \\<in> oGS_rel;\n     (v0i, v0) \\<in> Id\\<rbrakk>\n    \\<Longrightarrow> (GS_initial_impl I v0i (E `` {v0i}), initial v0 D0)\n                      \\<in> {(c, a). a = GS.\\<alpha> c \\<and> GS_invar c}", "apply (simp_all add: GS_initial_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v0 \\<notin> D0; (I, D0) \\<in> oGS_rel; v0i = v0\\<rbrakk>\n    \\<Longrightarrow> initial v0 D0 = ([{v0}], D0, {v0} \\<times> E `` {v0})", "apply (auto simp: initial_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"path_is_empty_impl s \\<equiv> GS.S s = []\""], ["", "lemma path_is_empty_refine: \n    \"GS_invar s \\<Longrightarrow> path_is_empty_impl s \\<longleftrightarrow> GS.p_\\<alpha> s=[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GS_invar s \\<Longrightarrow>\n    path_is_empty_impl s = (GS.p_\\<alpha> s = [])", "unfolding path_is_empty_impl_def GS.p_\\<alpha>_def GS_invar.empty_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. GS_invar s \\<Longrightarrow>\n    (GS.B s = []) = (map (GS.seg s) [0..<length (GS.B s)] = [])", "by auto"], ["", "definition (in GS) \"is_on_stack_impl v \n    \\<equiv> case I v of Some (STACK _) \\<Rightarrow> True | _ \\<Rightarrow> False\""], ["", "lemma (in GS_invar) is_on_stack_impl_correct:\n    shows \"is_on_stack_impl v \\<longleftrightarrow> v\\<in>\\<Union>(set p_\\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_on_stack_impl v = (v \\<in> \\<Union> (set p_\\<alpha>))", "unfolding is_on_stack_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case I v of None \\<Rightarrow> False\n     | Some (STACK x) \\<Rightarrow> True | Some DONE \\<Rightarrow> False) =\n    (v \\<in> \\<Union> (set p_\\<alpha>))", "using I_consistent[of v]"], ["proof (prove)\nusing this:\n  (I v = Some (STACK ?j)) = (?j < length S \\<and> v = S ! ?j)\n\ngoal (1 subgoal):\n 1. (case I v of None \\<Rightarrow> False\n     | Some (STACK x) \\<Rightarrow> True | Some DONE \\<Rightarrow> False) =\n    (v \\<in> \\<Union> (set p_\\<alpha>))", "apply (force \n      simp: set_p_\\<alpha>_is_set_S in_set_conv_nth \n      split: option.split node_state.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"is_on_stack_impl v s \\<equiv> GS.is_on_stack_impl s v\""], ["", "lemmas is_on_stack_impl_def_opt = \n    is_on_stack_impl_def[abs_def, THEN ext_def, THEN opt_GSdef, \n      unfolded GS.is_on_stack_impl_def GS_sel_simps]"], ["", "lemma is_on_stack_refine:\n    \"\\<lbrakk> GS_invar s \\<rbrakk> \\<Longrightarrow> is_on_stack_impl v s \\<longleftrightarrow> v\\<in>\\<Union>(set (GS.p_\\<alpha> s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GS_invar s \\<Longrightarrow>\n    is_on_stack_impl v s = (v \\<in> \\<Union> (set (GS.p_\\<alpha> s)))", "unfolding is_on_stack_impl_def GS_rel_def br_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. GS_invar s \\<Longrightarrow>\n    GS.is_on_stack_impl s v = (v \\<in> \\<Union> (set (GS.p_\\<alpha> s)))", "by (simp add: GS_invar.is_on_stack_impl_correct)"], ["", "definition (in GS) \"is_done_impl v \n    \\<equiv> case I v of Some DONE \\<Rightarrow> True | _ \\<Rightarrow> False\""], ["", "lemma (in GS_invar) is_done_impl_correct:\n    shows \"is_done_impl v \\<longleftrightarrow> v\\<in>D_\\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_done_impl v = (v \\<in> D_\\<alpha>)", "unfolding is_done_impl_def D_\\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case I v of None \\<Rightarrow> False\n     | Some (STACK nat) \\<Rightarrow> False\n     | Some DONE \\<Rightarrow> True) =\n    (v \\<in> {v. I v = Some DONE})", "apply (auto split: option.split node_state.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"is_done_oimpl v I \\<equiv> case I v of Some DONE \\<Rightarrow> True | _ \\<Rightarrow> False\""], ["", "definition \"is_done_impl v s \\<equiv> GS.is_done_impl s v\""], ["", "lemma is_done_orefine:\n    \"\\<lbrakk> oGS_invar s \\<rbrakk> \\<Longrightarrow> is_done_oimpl v s \\<longleftrightarrow> v\\<in>oGS_\\<alpha> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oGS_invar s \\<Longrightarrow>\n    is_done_oimpl v s = (v \\<in> oGS_\\<alpha> s)", "unfolding is_done_oimpl_def oGS_rel_def br_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. oGS_invar s \\<Longrightarrow>\n    (case s v of None \\<Rightarrow> False\n     | Some (STACK nat) \\<Rightarrow> False\n     | Some DONE \\<Rightarrow> True) =\n    (v \\<in> oGS_\\<alpha> s)", "by (auto \n      simp: oGS_invar_def oGS_\\<alpha>_def \n      split: option.splits node_state.split)"], ["", "lemma is_done_refine:\n    \"\\<lbrakk> GS_invar s \\<rbrakk> \\<Longrightarrow> is_done_impl v s \\<longleftrightarrow> v\\<in>GS.D_\\<alpha> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. GS_invar s \\<Longrightarrow>\n    is_done_impl v s = (v \\<in> GS.D_\\<alpha> s)", "unfolding is_done_impl_def GS_rel_def br_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. GS_invar s \\<Longrightarrow>\n    GS.is_done_impl s v = (v \\<in> GS.D_\\<alpha> s)", "by (simp add: GS_invar.is_done_impl_correct)"], ["", "lemma oinitial_refine: \"(Map.empty, {}) \\<in> oGS_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Map.empty, {}) \\<in> oGS_rel", "by (auto simp: oGS_rel_def br_def oGS_\\<alpha>_def oGS_invar_def)"], ["", "end"], ["", "subsection \\<open>Refined Skeleton Algorithm\\<close>"], ["", "context fr_graph begin"], ["", "lemma I_to_outer:\n    assumes \"((S, B, I, P), ([], D, {})) \\<in> GS_rel\"\n    shows \"(I,D)\\<in>oGS_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (I, D) \\<in> oGS_rel", "using assms"], ["proof (prove)\nusing this:\n  ((S, B, I, P), [], D, {}) \\<in> GS_rel\n\ngoal (1 subgoal):\n 1. (I, D) \\<in> oGS_rel", "unfolding GS_rel_def oGS_rel_def br_def oGS_\\<alpha>_def GS.\\<alpha>_def GS.D_\\<alpha>_def GS_invar_def oGS_invar_def"], ["proof (prove)\nusing this:\n  ((S, B, I, P), [], D, {})\n  \\<in> {(c, a).\n         a =\n         (GS.p_\\<alpha> c, {v. GS.I c v = Some DONE},\n          GS.pE_\\<alpha> c) \\<and>\n         ((set (GS.B c) \\<subseteq> {0..<length (GS.S c)} \\<and>\n           sorted (GS.B c)) \\<and>\n          distinct (GS.B c) \\<and>\n          (GS.S c \\<noteq> [] \\<longrightarrow>\n           GS.B c \\<noteq> [] \\<and> GS.B c ! 0 = 0)) \\<and>\n         (distinct (GS.S c) \\<and>\n          (\\<forall>v j.\n              (GS.I c v = Some (STACK j)) =\n              (j < length (GS.S c) \\<and> v = GS.S c ! j))) \\<and>\n         sorted (map fst (GS.P c)) \\<and>\n         distinct (map fst (GS.P c)) \\<and>\n         set (GS.P c)\n         \\<subseteq> {0..<length (GS.S c)} \\<times> {y. {} \\<noteq> y}}\n\ngoal (1 subgoal):\n 1. (I, D)\n    \\<in> {(c, a).\n           a = {v. c v = Some DONE} \\<and>\n           (\\<forall>v j. c v \\<noteq> Some (STACK j))}", "apply (auto simp: GS.p_\\<alpha>_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition skeleton_impl :: \"'v oGS nres\" where\n    \"skeleton_impl \\<equiv> do {\n      stat_start_nres;\n      let I=Map.empty;\n      r \\<leftarrow> FOREACHi (\\<lambda>it I. outer_invar it (oGS_\\<alpha> I)) V0 (\\<lambda>v0 I0. do {\n        if \\<not>is_done_oimpl v0 I0 then do {\n          let s = initial_impl v0 I0;\n\n          (S,B,I,P)\\<leftarrow>WHILEIT (invar v0 (oGS_\\<alpha> I0) o GS.\\<alpha>)\n            (\\<lambda>s. \\<not>path_is_empty_impl s) (\\<lambda>s.\n          do {\n            \\<comment> \\<open>Select edge from end of path\\<close>\n            (vo,s) \\<leftarrow> select_edge_impl s;\n\n            case vo of \n              Some v \\<Rightarrow> do {\n                if is_on_stack_impl v s then do {\n                  collapse_impl v s\n                } else if \\<not>is_done_impl v s then do {\n                  \\<comment> \\<open>Edge to new node. Append to path\\<close>\n                  RETURN (push_impl v s)\n                } else do {\n                  \\<comment> \\<open>Edge to done node. Skip\\<close>\n                  RETURN s\n                }\n              }\n            | None \\<Rightarrow> do {\n                \\<comment> \\<open>No more outgoing edges from current node on path\\<close>\n                pop_impl s\n              }\n          }) s;\n          RETURN I\n        } else\n          RETURN I0\n      }) I;\n      stat_stop_nres;\n      RETURN r\n    }\""], ["", "subsubsection \\<open>Correctness Theorem\\<close>"], ["", "lemma \"skeleton_impl \\<le> \\<Down>oGS_rel skeleton\""], ["proof (prove)\ngoal (1 subgoal):\n 1. skeleton_impl \\<le> \\<Down> oGS_rel skeleton", "using [[goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. skeleton_impl \\<le> \\<Down> oGS_rel skeleton", "unfolding skeleton_impl_def skeleton_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. stat_start_nres \\<bind>\n    (\\<lambda>_.\n        let I = Map.empty\n        in FOREACH\\<^bsup>\\<lambda>it I.\n                             outer_invar it (oGS_\\<alpha> I)\\<^esup>\n            V0 (\\<lambda>v0 I0.\n                   if \\<not> is_done_oimpl v0 I0\n                   then let s = initial_impl v0 I0\n                        in WHILE\\<^sub>T\\<^bsup>invar v0\n           (oGS_\\<alpha> I0) \\<circ>\n          GS.\\<alpha>\\<^esup>\n                            (\\<lambda>s. \\<not> path_is_empty_impl s)\n                            (\\<lambda>s.\n                                select_edge_impl s \\<bind>\n                                (\\<lambda>(vo, s).\n                                    case vo of None \\<Rightarrow> pop_impl s\n                                    | Some v \\<Rightarrow>\n  if is_on_stack_impl v s then collapse_impl v s\n  else if \\<not> is_done_impl v s then RETURN (push_impl v s)\n       else RETURN s))\n                            s \\<bind>\n                           (\\<lambda>(S, B, I, P). RETURN I)\n                   else RETURN I0)\n            I \\<bind>\n           (\\<lambda>r. stat_stop_nres \\<bind> (\\<lambda>_. RETURN r)))\n    \\<le> \\<Down> oGS_rel\n           (let D = {}\n            in FOREACH\\<^bsup>outer_invar\\<^esup> V0\n                (\\<lambda>v0 D0.\n                    if v0 \\<notin> D0\n                    then let s = initial v0 D0\n                         in WHILE\\<^sub>T\\<^bsup>invar v0 D0\\<^esup>\n                             (\\<lambda>(p, D, pE). p \\<noteq> [])\n                             (\\<lambda>(p, D, pE).\n                                 select_edge (p, D, pE) \\<bind>\n                                 (\\<lambda>(vo, p, D, pE).\n                                     ASSERT (p \\<noteq> []) \\<bind>\n                                     (\\<lambda>_.\n   case vo of\n   None \\<Rightarrow>\n     ASSERT (pE \\<inter> last p \\<times> UNIV = {}) \\<bind>\n     (\\<lambda>_. RETURN (pop (p, D, pE)))\n   | Some v \\<Rightarrow>\n       if v \\<in> \\<Union> (set p) then RETURN (collapse v (p, D, pE))\n       else if v \\<notin> D then RETURN (push v (p, D, pE))\n            else RETURN (p, D, pE))))\n                             s \\<bind>\n                            (\\<lambda>(p, D, pE).\n                                ASSERT (p = [] \\<and> pE = {}) \\<bind>\n                                (\\<lambda>_. RETURN D))\n                    else RETURN D0)\n                D \\<bind>\n               RETURN)", "apply (refine_rcg\n      bind_refine'\n      select_edge_refine push_refine \n      pop_refine\n      collapse_refine \n      initial_refine\n      oinitial_refine\n      inj_on_id\n    )"], ["proof (prove)\ngoal (20 subgoals):\n 1. V0 = id ` V0\nA total of 20 subgoals...", "using [[goals_limit = 5]]"], ["proof (prove)\ngoal (20 subgoals):\n 1. V0 = id ` V0\n 2. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = id ` it; it \\<subseteq> V0; it' \\<subseteq> V0;\n        outer_invar it' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> oGS_rel\\<rbrakk>\n       \\<Longrightarrow> outer_invar it (oGS_\\<alpha> \\<sigma>)\n 3. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = id x; x \\<in> it; x' \\<in> it'; it' = id ` it;\n        it \\<subseteq> V0; it' \\<subseteq> V0;\n        outer_invar it (oGS_\\<alpha> \\<sigma>); outer_invar it' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> oGS_rel\\<rbrakk>\n       \\<Longrightarrow> (\\<not> is_done_oimpl x \\<sigma>) =\n                         (x' \\<notin> \\<sigma>')\n 4. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = id x; x \\<in> it; x' \\<in> it'; it' = id ` it;\n        it \\<subseteq> V0; it' \\<subseteq> V0;\n        outer_invar it (oGS_\\<alpha> \\<sigma>); outer_invar it' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> oGS_rel;\n        \\<not> is_done_oimpl x \\<sigma>; x' \\<notin> \\<sigma>';\n        invar x' \\<sigma>' (initial x' \\<sigma>')\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> Id\n 5. \\<And>x it \\<sigma> x' it' \\<sigma>' xa x'a.\n       \\<lbrakk>x' = id x; x \\<in> it; x' \\<in> it'; it' = id ` it;\n        it \\<subseteq> V0; it' \\<subseteq> V0;\n        outer_invar it (oGS_\\<alpha> \\<sigma>); outer_invar it' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> oGS_rel;\n        \\<not> is_done_oimpl x \\<sigma>; x' \\<notin> \\<sigma>';\n        (xa, x'a) \\<in> GS_rel; invar x' \\<sigma>' x'a\\<rbrakk>\n       \\<Longrightarrow> (invar x (oGS_\\<alpha> \\<sigma>) \\<circ>\n                          GS.\\<alpha>)\n                          xa\nA total of 20 subgoals...", "apply refine_dref_type"], ["proof (prove)\ngoal (18 subgoals):\n 1. V0 = id ` V0\n 2. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = id ` it; it \\<subseteq> V0; it' \\<subseteq> V0;\n        outer_invar it' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> oGS_rel\\<rbrakk>\n       \\<Longrightarrow> outer_invar it (oGS_\\<alpha> \\<sigma>)\n 3. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = id x; x \\<in> it; x' \\<in> it'; it' = id ` it;\n        it \\<subseteq> V0; it' \\<subseteq> V0;\n        outer_invar it (oGS_\\<alpha> \\<sigma>); outer_invar it' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> oGS_rel\\<rbrakk>\n       \\<Longrightarrow> (\\<not> is_done_oimpl x \\<sigma>) =\n                         (x' \\<notin> \\<sigma>')\n 4. \\<And>x it \\<sigma> x' it' \\<sigma>'.\n       \\<lbrakk>x' = id x; x \\<in> it; x' \\<in> it'; it' = id ` it;\n        it \\<subseteq> V0; it' \\<subseteq> V0;\n        outer_invar it (oGS_\\<alpha> \\<sigma>); outer_invar it' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> oGS_rel;\n        \\<not> is_done_oimpl x \\<sigma>; x' \\<notin> \\<sigma>';\n        invar x' \\<sigma>' (initial x' \\<sigma>')\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> Id\n 5. \\<And>x it \\<sigma> x' it' \\<sigma>' xa x'a.\n       \\<lbrakk>x' = id x; x \\<in> it; x' \\<in> it'; it' = id ` it;\n        it \\<subseteq> V0; it' \\<subseteq> V0;\n        outer_invar it (oGS_\\<alpha> \\<sigma>); outer_invar it' \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> oGS_rel;\n        \\<not> is_done_oimpl x \\<sigma>; x' \\<notin> \\<sigma>';\n        (xa, x'a) \\<in> GS_rel; invar x' \\<sigma>' x'a\\<rbrakk>\n       \\<Longrightarrow> (invar x (oGS_\\<alpha> \\<sigma>) \\<circ>\n                          GS.\\<alpha>)\n                          xa\nA total of 18 subgoals...", "apply (vc_solve (nopre) solve: asm_rl I_to_outer\n      simp: GS_rel_def br_def GS.\\<alpha>_def oGS_rel_def oGS_\\<alpha>_def \n      is_on_stack_refine path_is_empty_refine is_done_refine is_done_orefine\n    )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas skeleton_refines \n    = select_edge_refine push_refine pop_refine collapse_refine \n      initial_refine oinitial_refine"], ["", "lemmas skeleton_refine_simps \n    = GS_rel_def br_def GS.\\<alpha>_def oGS_rel_def oGS_\\<alpha>_def \n      is_on_stack_refine path_is_empty_refine is_done_refine is_done_orefine"], ["", "text \\<open>Short proof, for presentation\\<close>"], ["", "context\n    notes [[goals_limit = 1]]\n    notes [refine] = inj_on_id bind_refine'\n  begin"], ["", "lemma \"skeleton_impl \\<le> \\<Down>oGS_rel skeleton\""], ["proof (prove)\ngoal (1 subgoal):\n 1. skeleton_impl \\<le> \\<Down> oGS_rel skeleton", "unfolding skeleton_impl_def skeleton_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. stat_start_nres \\<bind>\n    (\\<lambda>_.\n        let I = Map.empty\n        in FOREACH\\<^bsup>\\<lambda>it I.\n                             outer_invar it (oGS_\\<alpha> I)\\<^esup>\n            V0 (\\<lambda>v0 I0.\n                   if \\<not> is_done_oimpl v0 I0\n                   then let s = initial_impl v0 I0\n                        in WHILE\\<^sub>T\\<^bsup>invar v0\n           (oGS_\\<alpha> I0) \\<circ>\n          GS.\\<alpha>\\<^esup>\n                            (\\<lambda>s. \\<not> path_is_empty_impl s)\n                            (\\<lambda>s.\n                                select_edge_impl s \\<bind>\n                                (\\<lambda>(vo, s).\n                                    case vo of None \\<Rightarrow> pop_impl s\n                                    | Some v \\<Rightarrow>\n  if is_on_stack_impl v s then collapse_impl v s\n  else if \\<not> is_done_impl v s then RETURN (push_impl v s)\n       else RETURN s))\n                            s \\<bind>\n                           (\\<lambda>(S, B, I, P). RETURN I)\n                   else RETURN I0)\n            I \\<bind>\n           (\\<lambda>r. stat_stop_nres \\<bind> (\\<lambda>_. RETURN r)))\n    \\<le> \\<Down> oGS_rel\n           (let D = {}\n            in FOREACH\\<^bsup>outer_invar\\<^esup> V0\n                (\\<lambda>v0 D0.\n                    if v0 \\<notin> D0\n                    then let s = initial v0 D0\n                         in WHILE\\<^sub>T\\<^bsup>invar v0 D0\\<^esup>\n                             (\\<lambda>(p, D, pE). p \\<noteq> [])\n                             (\\<lambda>(p, D, pE).\n                                 select_edge (p, D, pE) \\<bind>\n                                 (\\<lambda>(vo, p, D, pE).\n                                     ASSERT (p \\<noteq> []) \\<bind>\n                                     (\\<lambda>_.\n   case vo of\n   None \\<Rightarrow>\n     ASSERT (pE \\<inter> last p \\<times> UNIV = {}) \\<bind>\n     (\\<lambda>_. RETURN (pop (p, D, pE)))\n   | Some v \\<Rightarrow>\n       if v \\<in> \\<Union> (set p) then RETURN (collapse v (p, D, pE))\n       else if v \\<notin> D then RETURN (push v (p, D, pE))\n            else RETURN (p, D, pE))))\n                             s \\<bind>\n                            (\\<lambda>(p, D, pE).\n                                ASSERT (p = [] \\<and> pE = {}) \\<bind>\n                                (\\<lambda>_. RETURN D))\n                    else RETURN D0)\n                D \\<bind>\n               RETURN)", "by (refine_rcg skeleton_refines, refine_dref_type)\n       (vc_solve (nopre) solve: asm_rl I_to_outer simp: skeleton_refine_simps)"], ["", "end"], ["", "end"], ["", "end"]]}