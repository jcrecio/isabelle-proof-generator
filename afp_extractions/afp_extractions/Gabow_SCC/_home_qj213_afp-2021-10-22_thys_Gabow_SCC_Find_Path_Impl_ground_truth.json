{"file_name": "/home/qj213/afp-2021-10-22/thys/Gabow_SCC/Find_Path_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Gabow_SCC", "problem_names": ["lemma wset_find_path_correct:\n    fixes E :: \"('v\\<times>'v) set\"\n    shows \"wset_find_path E U0 P \\<le> find_path E U0 P\"", "lemma ws_update_foreach_refine[refine]:\n    assumes FIN: \"finite (E``{u})\"\n    assumes WSS: \"dom ws \\<subseteq> V\"\n    assumes ID: \"(E',E)\\<in>Id\" \"(u',u)\\<in>Id\" \"(p',p)\\<in>Id\" \"(V',V)\\<in>Id\" \"(ws',ws)\\<in>Id\"\n    shows \"ws_update_foreach E' u' p' V' ws' \\<le> \\<Down>Id (ws_update E u p V ws)\"", "lemma s_init_foreach_refine[refine]:\n    assumes FIN: \"finite U0\"\n    assumes ID: \"(U0',U0)\\<in>Id\"\n    shows \"s_init_foreach U0' \\<le>\\<Down>Id (s_init U0)\"", "lemma wset_find_path'_refine: \n    \"wset_find_path' E U0 P \\<le> \\<Down>Id (wset_find_path E U0 P)\"", "lemma [autoref_itype]: \n      \"find_path ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_slg \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i (I\\<rightarrow>\\<^sub>ii_bool) \n        \\<rightarrow>\\<^sub>i \\<langle>\\<langle>\\<langle>\\<langle>I\\<rangle>\\<^sub>ii_list, I\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_option\\<rangle>\\<^sub>ii_nres\"", "lemma wset_find_path_autoref[autoref_rules]:\n      fixes node_rel :: \"('ai \\<times> 'a) set\"\n      assumes eq: \"GEN_OP node_eq_impl (=) (node_rel\\<rightarrow>node_rel\\<rightarrow>bool_rel)\"\n      assumes hash: \"SIDE_GEN_ALGO (is_bounded_hashcode node_rel node_eq_impl node_hash_impl)\"\n      assumes hash_dsz: \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('ai) node_def_hash_size)\"\n      shows \"(\n        wset_find_path_impl node_hash_impl node_def_hash_size node_eq_impl, \n        find_path)\n        \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow> \\<langle>node_rel\\<rangle>list_set_rel \\<rightarrow> (node_rel\\<rightarrow>bool_rel) \n          \\<rightarrow> \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel\\<times>\\<^sub>rnode_rel\\<rangle>option_rel\\<rangle>nres_rel\"", "lemmas [refine_transfer] = wset_find_path_code.refine", "lemma find_path1_gen_correct: \"find_path1_gen E u0 P \\<le> find_path1 E u0 P\"", "lemma [autoref_itype]: \n  \"find_path1 ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_slg \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i (I\\<rightarrow>\\<^sub>ii_bool) \n    \\<rightarrow>\\<^sub>i \\<langle>\\<langle>\\<langle>\\<langle>I\\<rangle>\\<^sub>ii_list, I\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_option\\<rangle>\\<^sub>ii_nres\"", "lemma find_path1_autoref[autoref_rules]: \n  fixes node_rel :: \"('ai \\<times> 'a) set\"\n  assumes eq: \"GEN_OP node_eq_impl (=) (node_rel\\<rightarrow>node_rel\\<rightarrow>bool_rel)\"\n  assumes hash: \"SIDE_GEN_ALGO (is_bounded_hashcode node_rel node_eq_impl node_hash_impl)\"\n  assumes hash_dsz: \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('ai) node_def_hash_size)\"\n  \n  shows \"(find_path1_impl node_eq_impl node_hash_impl node_def_hash_size,find_path1) \n    \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow>node_rel \\<rightarrow> (node_rel \\<rightarrow> bool_rel) \\<rightarrow> \n      \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r node_rel\\<rangle>Relators.option_rel\\<rangle>nres_rel\"", "lemmas [refine_transfer] = find_path1_code.refine"], "translations": [["", "lemma wset_find_path_correct:\n    fixes E :: \"('v\\<times>'v) set\"\n    shows \"wset_find_path E U0 P \\<le> find_path E U0 P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "define inv where \"inv = (\\<lambda>(res,V,ws). case res of\n        None \\<Rightarrow> \n          dom ws\\<subseteq>V \n        \\<and> finite (dom ws)  \\<comment> \\<open>Derived\\<close>\n        \\<and> V\\<subseteq>E\\<^sup>*``U0 \n        \\<and> E``(V-dom ws) \\<subseteq> V \n        \\<and> (\\<forall>v\\<in>V-dom ws. \\<not> P v)\n        \\<and> U0 \\<subseteq> V\n        \\<and> (\\<forall>v p. ws v = Some p \n          \\<longrightarrow> ((\\<forall>v\\<in>set p. \\<not>P v) \\<and> (\\<exists>u0\\<in>U0. path E u0 (rev p) v)))\n      | Some (p,v) \\<Rightarrow> (\\<exists>u0\\<in>U0. path E u0 p v \\<and> P v \\<and> (\\<forall>v\\<in>set p. \\<not>P v)))\""], ["proof (state)\nthis:\n  inv =\n  (\\<lambda>(res, V, ws).\n      case res of\n      None \\<Rightarrow>\n        dom ws \\<subseteq> V \\<and>\n        finite (dom ws) \\<and>\n        V \\<subseteq> E\\<^sup>* `` U0 \\<and>\n        E `` (V - dom ws) \\<subseteq> V \\<and>\n        (\\<forall>v\\<in>V - dom ws. \\<not> P v) \\<and>\n        U0 \\<subseteq> V \\<and>\n        (\\<forall>v p.\n            ws v = Some p \\<longrightarrow>\n            (\\<forall>v\\<in>set p. \\<not> P v) \\<and>\n            (\\<exists>u0\\<in>U0. path E u0 (rev p) v))\n      | Some (p, v) \\<Rightarrow>\n          \\<exists>u0\\<in>U0.\n             path E u0 p v \\<and>\n             P v \\<and> (\\<forall>v\\<in>set p. \\<not> P v))\n\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "define var where \"var = inv_image \n        (brk_rel (finite_psupset (E\\<^sup>*``U0) <*lex*> measure (card o dom)))\n        (\\<lambda>(res::('v list \\<times> 'v) option,V::'v set,ws::'v\\<rightharpoonup>'v list). \n            (res\\<noteq>None,V,ws))\""], ["proof (state)\nthis:\n  var =\n  inv_image\n   (brk_rel\n     (finite_psupset (E\\<^sup>* `` U0) <*lex*> measure (card \\<circ> dom)))\n   (\\<lambda>(res, V, ws). (res \\<noteq> None, V, ws))\n\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "(*have [simp, intro!]: \"wf var\"\n      unfolding var_def\n      by (auto intro: FIN)*)"], ["proof (state)\nthis:\n  var =\n  inv_image\n   (brk_rel\n     (finite_psupset (E\\<^sup>* `` U0) <*lex*> measure (card \\<circ> dom)))\n   (\\<lambda>(res, V, ws). (res \\<noteq> None, V, ws))\n\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "have [simp]: \"\\<And>u p V. dom (\\<lambda>v. if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n                     else None) = E``{u} - V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u p V.\n       dom (\\<lambda>v.\n               if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n               else None) =\n       E `` {u} - V", "by (auto split: if_split_asm)"], ["proof (state)\nthis:\n  dom (\\<lambda>v.\n          if (?u, v) \\<in> E \\<and> v \\<notin> ?V then Some (?u # ?p)\n          else None) =\n  E `` {?u} - ?V\n\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "{"], ["proof (state)\nthis:\n  dom (\\<lambda>v.\n          if (?u, v) \\<in> E \\<and> v \\<notin> ?V then Some (?u # ?p)\n          else None) =\n  E `` {?u} - ?V\n\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "fix V ws u p"], ["proof (state)\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "assume INV: \"inv (None,V,ws)\""], ["proof (state)\nthis:\n  inv (None, V, ws)\n\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "assume WSU: \"ws u = Some p\""], ["proof (state)\nthis:\n  ws u = Some p\n\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "from INV WSU"], ["proof (chain)\npicking this:\n  inv (None, V, ws)\n  ws u = Some p", "have \n        [simp]: \"V \\<subseteq> E\\<^sup>*``U0\"\n        and [simp]: \"u \\<in> V\"\n        and UREACH: \"\\<exists>u0\\<in>U0. (u0,u)\\<in>E\\<^sup>*\"\n        and [simp]: \"finite (dom ws)\""], ["proof (prove)\nusing this:\n  inv (None, V, ws)\n  ws u = Some p\n\ngoal (1 subgoal):\n 1. (V \\<subseteq> E\\<^sup>* `` U0 &&& u \\<in> V) &&&\n    \\<exists>u0\\<in>U0. (u0, u) \\<in> E\\<^sup>* &&& finite (dom ws)", "unfolding inv_def"], ["proof (prove)\nusing this:\n  case (None, V, ws) of\n  (None, V, ws) \\<Rightarrow>\n    dom ws \\<subseteq> V \\<and>\n    finite (dom ws) \\<and>\n    V \\<subseteq> E\\<^sup>* `` U0 \\<and>\n    E `` (V - dom ws) \\<subseteq> V \\<and>\n    (\\<forall>v\\<in>V - dom ws. \\<not> P v) \\<and>\n    U0 \\<subseteq> V \\<and>\n    (\\<forall>v p.\n        ws v = Some p \\<longrightarrow>\n        (\\<forall>v\\<in>set p. \\<not> P v) \\<and>\n        (\\<exists>u0\\<in>U0. path E u0 (rev p) v))\n  | (Some (p, v), V, ws) \\<Rightarrow>\n      \\<exists>u0\\<in>U0.\n         path E u0 p v \\<and> P v \\<and> (\\<forall>v\\<in>set p. \\<not> P v)\n  ws u = Some p\n\ngoal (1 subgoal):\n 1. (V \\<subseteq> E\\<^sup>* `` U0 &&& u \\<in> V) &&&\n    \\<exists>u0\\<in>U0. (u0, u) \\<in> E\\<^sup>* &&& finite (dom ws)", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>dom ws \\<subseteq> V \\<and>\n             finite (dom ws) \\<and>\n             V \\<subseteq> E\\<^sup>* `` U0 \\<and>\n             E `` (V - dom ws) \\<subseteq> V \\<and>\n             (\\<forall>v\\<in>V - dom ws. \\<not> P v) \\<and>\n             U0 \\<subseteq> V \\<and>\n             (\\<forall>v p.\n                 ws v = Some p \\<longrightarrow>\n                 (\\<forall>v\\<in>set p. \\<not> P v) \\<and>\n                 (\\<exists>u0\\<in>U0. path E u0 (rev p) v));\n     ws u = Some p\\<rbrakk>\n    \\<Longrightarrow> u \\<in> V\n 2. \\<lbrakk>dom ws \\<subseteq> V \\<and>\n             finite (dom ws) \\<and>\n             V \\<subseteq> E\\<^sup>* `` U0 \\<and>\n             E `` (V - dom ws) \\<subseteq> V \\<and>\n             (\\<forall>v\\<in>V - dom ws. \\<not> P v) \\<and>\n             U0 \\<subseteq> V \\<and>\n             (\\<forall>v p.\n                 ws v = Some p \\<longrightarrow>\n                 (\\<forall>v\\<in>set p. \\<not> P v) \\<and>\n                 (\\<exists>u0\\<in>U0. path E u0 (rev p) v));\n     ws u = Some p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u0\\<in>U0. (u0, u) \\<in> E\\<^sup>*", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dom ws \\<subseteq> V \\<and>\n             finite (dom ws) \\<and>\n             V \\<subseteq> E\\<^sup>* `` U0 \\<and>\n             E `` (V - dom ws) \\<subseteq> V \\<and>\n             (\\<forall>v\\<in>V - dom ws. \\<not> P v) \\<and>\n             U0 \\<subseteq> V \\<and>\n             (\\<forall>v p.\n                 ws v = Some p \\<longrightarrow>\n                 (\\<forall>v\\<in>set p. \\<not> P v) \\<and>\n                 (\\<exists>u0\\<in>U0. path E u0 (rev p) v));\n     ws u = Some p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u0\\<in>U0. (u0, u) \\<in> E\\<^sup>*", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ws u = Some p; dom ws \\<subseteq> V; finite (dom ws);\n     V \\<subseteq> E\\<^sup>* `` U0; E `` (V - dom ws) \\<subseteq> V;\n     \\<forall>v\\<in>V - dom ws. \\<not> P v; U0 \\<subseteq> V;\n     \\<forall>v p.\n        ws v = Some p \\<longrightarrow>\n        (\\<forall>v\\<in>set p. \\<not> P v) \\<and>\n        (\\<exists>u0\\<in>U0. path E u0 (rev p) v)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u0\\<in>U0. (u0, u) \\<in> E\\<^sup>*", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  V \\<subseteq> E\\<^sup>* `` U0\n  u \\<in> V\n  \\<exists>u0\\<in>U0. (u0, u) \\<in> E\\<^sup>*\n  finite (dom ws)\n\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "have \"(V \\<union> E `` {u}, V) \\<in> finite_psupset (E\\<^sup>* `` U0) \\<or>\n          V \\<union> E `` {u} = V \\<and>\n          card (E `` {u} - V \\<union> (dom ws - {u})) < card (dom ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (V \\<union> E `` {u}, V) \\<in> finite_psupset (E\\<^sup>* `` U0) \\<or>\n    V \\<union> E `` {u} = V \\<and>\n    card (E `` {u} - V \\<union> (dom ws - {u})) < card (dom ws)", "proof (subst disj_commute, intro disjCI conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. (V \\<union> E `` {u}, V)\n    \\<notin> finite_psupset (E\\<^sup>* `` U0) \\<Longrightarrow>\n    V \\<union> E `` {u} = V\n 2. (V \\<union> E `` {u}, V)\n    \\<notin> finite_psupset (E\\<^sup>* `` U0) \\<Longrightarrow>\n    card (E `` {u} - V \\<union> (dom ws - {u})) < card (dom ws)", "assume \"(V \\<union> E `` {u}, V) \\<notin> finite_psupset (E\\<^sup>* `` U0)\""], ["proof (state)\nthis:\n  (V \\<union> E `` {u}, V) \\<notin> finite_psupset (E\\<^sup>* `` U0)\n\ngoal (2 subgoals):\n 1. (V \\<union> E `` {u}, V)\n    \\<notin> finite_psupset (E\\<^sup>* `` U0) \\<Longrightarrow>\n    V \\<union> E `` {u} = V\n 2. (V \\<union> E `` {u}, V)\n    \\<notin> finite_psupset (E\\<^sup>* `` U0) \\<Longrightarrow>\n    card (E `` {u} - V \\<union> (dom ws - {u})) < card (dom ws)", "thus \"V \\<union> E `` {u} = V\""], ["proof (prove)\nusing this:\n  (V \\<union> E `` {u}, V) \\<notin> finite_psupset (E\\<^sup>* `` U0)\n\ngoal (1 subgoal):\n 1. V \\<union> E `` {u} = V", "using UREACH"], ["proof (prove)\nusing this:\n  (V \\<union> E `` {u}, V) \\<notin> finite_psupset (E\\<^sup>* `` U0)\n  \\<exists>u0\\<in>U0. (u0, u) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. V \\<union> E `` {u} = V", "by (auto simp: finite_psupset_def intro: rev_ImageI)"], ["proof (state)\nthis:\n  V \\<union> E `` {u} = V\n\ngoal (1 subgoal):\n 1. (V \\<union> E `` {u}, V)\n    \\<notin> finite_psupset (E\\<^sup>* `` U0) \\<Longrightarrow>\n    card (E `` {u} - V \\<union> (dom ws - {u})) < card (dom ws)", "hence [simp]: \"E``{u} - V = {}\""], ["proof (prove)\nusing this:\n  V \\<union> E `` {u} = V\n\ngoal (1 subgoal):\n 1. E `` {u} - V = {}", "by force"], ["proof (state)\nthis:\n  E `` {u} - V = {}\n\ngoal (1 subgoal):\n 1. (V \\<union> E `` {u}, V)\n    \\<notin> finite_psupset (E\\<^sup>* `` U0) \\<Longrightarrow>\n    card (E `` {u} - V \\<union> (dom ws - {u})) < card (dom ws)", "show \"card (E `` {u} - V \\<union> (dom ws - {u})) < card (dom ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (E `` {u} - V \\<union> (dom ws - {u})) < card (dom ws)", "using WSU"], ["proof (prove)\nusing this:\n  ws u = Some p\n\ngoal (1 subgoal):\n 1. card (E `` {u} - V \\<union> (dom ws - {u})) < card (dom ws)", "by (auto intro: card_Diff1_less)"], ["proof (state)\nthis:\n  card (E `` {u} - V \\<union> (dom ws - {u})) < card (dom ws)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (V \\<union> E `` {u}, V) \\<in> finite_psupset (E\\<^sup>* `` U0) \\<or>\n  V \\<union> E `` {u} = V \\<and>\n  card (E `` {u} - V \\<union> (dom ws - {u})) < card (dom ws)\n\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "}"], ["proof (state)\nthis:\n  \\<lbrakk>inv (None, ?V2, ?ws2); ?ws2 ?u2 = Some ?p2\\<rbrakk>\n  \\<Longrightarrow> (?V2 \\<union> E `` {?u2}, ?V2)\n                    \\<in> finite_psupset (E\\<^sup>* `` U0) \\<or>\n                    ?V2 \\<union> E `` {?u2} = ?V2 \\<and>\n                    card (E `` {?u2} - ?V2 \\<union> (dom ?ws2 - {?u2}))\n                    < card (dom ?ws2)\n\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "note wf_aux=this"], ["proof (state)\nthis:\n  \\<lbrakk>inv (None, ?V2, ?ws2); ?ws2 ?u2 = Some ?p2\\<rbrakk>\n  \\<Longrightarrow> (?V2 \\<union> E `` {?u2}, ?V2)\n                    \\<in> finite_psupset (E\\<^sup>* `` U0) \\<or>\n                    ?V2 \\<union> E `` {?u2} = ?V2 \\<and>\n                    card (E `` {?u2} - ?V2 \\<union> (dom ?ws2 - {?u2}))\n                    < card (dom ?ws2)\n\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "{"], ["proof (state)\nthis:\n  \\<lbrakk>inv (None, ?V2, ?ws2); ?ws2 ?u2 = Some ?p2\\<rbrakk>\n  \\<Longrightarrow> (?V2 \\<union> E `` {?u2}, ?V2)\n                    \\<in> finite_psupset (E\\<^sup>* `` U0) \\<or>\n                    ?V2 \\<union> E `` {?u2} = ?V2 \\<and>\n                    card (E `` {?u2} - ?V2 \\<union> (dom ?ws2 - {?u2}))\n                    < card (dom ?ws2)\n\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "fix V ws u p"], ["proof (state)\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "assume FIN: \"finite (E\\<^sup>*``U0)\""], ["proof (state)\nthis:\n  finite (E\\<^sup>* `` U0)\n\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "assume \"inv (None,V,ws)\" \"ws u = Some p\""], ["proof (state)\nthis:\n  inv (None, V, ws)\n  ws u = Some p\n\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "then"], ["proof (chain)\npicking this:\n  inv (None, V, ws)\n  ws u = Some p", "obtain u0 where \"u0\\<in>U0\" \"(u0,u)\\<in>E\\<^sup>*\""], ["proof (prove)\nusing this:\n  inv (None, V, ws)\n  ws u = Some p\n\ngoal (1 subgoal):\n 1. (\\<And>u0.\n        \\<lbrakk>u0 \\<in> U0; (u0, u) \\<in> E\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding inv_def"], ["proof (prove)\nusing this:\n  case (None, V, ws) of\n  (None, V, ws) \\<Rightarrow>\n    dom ws \\<subseteq> V \\<and>\n    finite (dom ws) \\<and>\n    V \\<subseteq> E\\<^sup>* `` U0 \\<and>\n    E `` (V - dom ws) \\<subseteq> V \\<and>\n    (\\<forall>v\\<in>V - dom ws. \\<not> P v) \\<and>\n    U0 \\<subseteq> V \\<and>\n    (\\<forall>v p.\n        ws v = Some p \\<longrightarrow>\n        (\\<forall>v\\<in>set p. \\<not> P v) \\<and>\n        (\\<exists>u0\\<in>U0. path E u0 (rev p) v))\n  | (Some (p, v), V, ws) \\<Rightarrow>\n      \\<exists>u0\\<in>U0.\n         path E u0 p v \\<and> P v \\<and> (\\<forall>v\\<in>set p. \\<not> P v)\n  ws u = Some p\n\ngoal (1 subgoal):\n 1. (\\<And>u0.\n        \\<lbrakk>u0 \\<in> U0; (u0, u) \\<in> E\\<^sup>*\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarsimp blast"], ["proof (state)\nthis:\n  u0 \\<in> U0\n  (u0, u) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "hence \"E``{u} \\<subseteq> E\\<^sup>*``U0\""], ["proof (prove)\nusing this:\n  u0 \\<in> U0\n  (u0, u) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. E `` {u} \\<subseteq> E\\<^sup>* `` U0", "by (auto intro: rev_ImageI)"], ["proof (state)\nthis:\n  E `` {u} \\<subseteq> E\\<^sup>* `` U0\n\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "hence \"finite (E``{u})\""], ["proof (prove)\nusing this:\n  E `` {u} \\<subseteq> E\\<^sup>* `` U0\n\ngoal (1 subgoal):\n 1. finite (E `` {u})", "using FIN(1)"], ["proof (prove)\nusing this:\n  E `` {u} \\<subseteq> E\\<^sup>* `` U0\n  finite (E\\<^sup>* `` U0)\n\ngoal (1 subgoal):\n 1. finite (E `` {u})", "by (rule finite_subset)"], ["proof (state)\nthis:\n  finite (E `` {u})\n\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "}"], ["proof (state)\nthis:\n  \\<lbrakk>finite (E\\<^sup>* `` U0); inv (None, ?V2, ?ws2);\n   ?ws2 ?u2 = Some ?p2\\<rbrakk>\n  \\<Longrightarrow> finite (E `` {?u2})\n\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "note succs_finite=this"], ["proof (state)\nthis:\n  \\<lbrakk>finite (E\\<^sup>* `` U0); inv (None, ?V2, ?ws2);\n   ?ws2 ?u2 = Some ?p2\\<rbrakk>\n  \\<Longrightarrow> finite (E `` {?u2})\n\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "{"], ["proof (state)\nthis:\n  \\<lbrakk>finite (E\\<^sup>* `` U0); inv (None, ?V2, ?ws2);\n   ?ws2 ?u2 = Some ?p2\\<rbrakk>\n  \\<Longrightarrow> finite (E `` {?u2})\n\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "fix V ws u p"], ["proof (state)\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "assume FIN: \"finite (E\\<^sup>*``U0)\""], ["proof (state)\nthis:\n  finite (E\\<^sup>* `` U0)\n\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "assume INV: \"inv (None,V,ws)\""], ["proof (state)\nthis:\n  inv (None, V, ws)\n\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "assume WSU: \"ws u = Some p\""], ["proof (state)\nthis:\n  ws u = Some p\n\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "assume NVD: \"\\<not> P u\""], ["proof (state)\nthis:\n  \\<not> P u\n\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "have \"inv (None, V \\<union> E `` {u},\n               ws |` (- {u}) ++\n               (\\<lambda>v. if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n                    else None))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv (None, V \\<union> E `` {u},\n         ws |` (- {u}) ++\n         (\\<lambda>v.\n             if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n             else None))", "unfolding inv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case (None, V \\<union> E `` {u},\n          ws |` (- {u}) ++\n          (\\<lambda>v.\n              if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n              else None)) of\n    (None, V, ws) \\<Rightarrow>\n      dom ws \\<subseteq> V \\<and>\n      finite (dom ws) \\<and>\n      V \\<subseteq> E\\<^sup>* `` U0 \\<and>\n      E `` (V - dom ws) \\<subseteq> V \\<and>\n      (\\<forall>v\\<in>V - dom ws. \\<not> P v) \\<and>\n      U0 \\<subseteq> V \\<and>\n      (\\<forall>v p.\n          ws v = Some p \\<longrightarrow>\n          (\\<forall>v\\<in>set p. \\<not> P v) \\<and>\n          (\\<exists>u0\\<in>U0. path E u0 (rev p) v))\n    | (Some (p, v), V, ws) \\<Rightarrow>\n        \\<exists>u0\\<in>U0.\n           path E u0 p v \\<and>\n           P v \\<and> (\\<forall>v\\<in>set p. \\<not> P v)", "apply (simp, intro conjI)"], ["proof (prove)\ngoal (10 subgoals):\n 1. E `` {u} - V \\<subseteq> V \\<union> E `` {u}\n 2. dom ws - {u} \\<subseteq> V \\<union> E `` {u}\n 3. finite (E `` {u} - V)\n 4. finite (dom ws)\n 5. V \\<subseteq> E\\<^sup>* `` U0\n 6. E `` {u} \\<subseteq> E\\<^sup>* `` U0\n 7. E `` (V \\<union> E `` {u} - (E `` {u} - V \\<union> (dom ws - {u})))\n    \\<subseteq> V \\<union> E `` {u}\n 8. \\<forall>v\\<in>V \\<union> E `` {u} -\n                   (E `` {u} - V \\<union> (dom ws - {u})).\n       \\<not> P v\n 9. U0 \\<subseteq> V \\<union> E `` {u}\n 10. \\<forall>v pa.\n        (ws |` (- {u}) ++\n         (\\<lambda>v.\n             if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n             else None))\n         v =\n        Some pa \\<longrightarrow>\n        (\\<forall>v\\<in>set pa. \\<not> P v) \\<and>\n        (\\<exists>u0\\<in>U0. path E u0 (rev pa) v)", "using INV WSU"], ["proof (prove)\nusing this:\n  inv (None, V, ws)\n  ws u = Some p\n\ngoal (10 subgoals):\n 1. E `` {u} - V \\<subseteq> V \\<union> E `` {u}\n 2. dom ws - {u} \\<subseteq> V \\<union> E `` {u}\n 3. finite (E `` {u} - V)\n 4. finite (dom ws)\n 5. V \\<subseteq> E\\<^sup>* `` U0\n 6. E `` {u} \\<subseteq> E\\<^sup>* `` U0\n 7. E `` (V \\<union> E `` {u} - (E `` {u} - V \\<union> (dom ws - {u})))\n    \\<subseteq> V \\<union> E `` {u}\n 8. \\<forall>v\\<in>V \\<union> E `` {u} -\n                   (E `` {u} - V \\<union> (dom ws - {u})).\n       \\<not> P v\n 9. U0 \\<subseteq> V \\<union> E `` {u}\n 10. \\<forall>v pa.\n        (ws |` (- {u}) ++\n         (\\<lambda>v.\n             if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n             else None))\n         v =\n        Some pa \\<longrightarrow>\n        (\\<forall>v\\<in>set pa. \\<not> P v) \\<and>\n        (\\<exists>u0\\<in>U0. path E u0 (rev pa) v)", "apply (auto simp: inv_def) []"], ["proof (prove)\ngoal (9 subgoals):\n 1. dom ws - {u} \\<subseteq> V \\<union> E `` {u}\n 2. finite (E `` {u} - V)\n 3. finite (dom ws)\n 4. V \\<subseteq> E\\<^sup>* `` U0\n 5. E `` {u} \\<subseteq> E\\<^sup>* `` U0\n 6. E `` (V \\<union> E `` {u} - (E `` {u} - V \\<union> (dom ws - {u})))\n    \\<subseteq> V \\<union> E `` {u}\n 7. \\<forall>v\\<in>V \\<union> E `` {u} -\n                   (E `` {u} - V \\<union> (dom ws - {u})).\n       \\<not> P v\n 8. U0 \\<subseteq> V \\<union> E `` {u}\n 9. \\<forall>v pa.\n       (ws |` (- {u}) ++\n        (\\<lambda>v.\n            if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n            else None))\n        v =\n       Some pa \\<longrightarrow>\n       (\\<forall>v\\<in>set pa. \\<not> P v) \\<and>\n       (\\<exists>u0\\<in>U0. path E u0 (rev pa) v)", "using INV WSU"], ["proof (prove)\nusing this:\n  inv (None, V, ws)\n  ws u = Some p\n\ngoal (9 subgoals):\n 1. dom ws - {u} \\<subseteq> V \\<union> E `` {u}\n 2. finite (E `` {u} - V)\n 3. finite (dom ws)\n 4. V \\<subseteq> E\\<^sup>* `` U0\n 5. E `` {u} \\<subseteq> E\\<^sup>* `` U0\n 6. E `` (V \\<union> E `` {u} - (E `` {u} - V \\<union> (dom ws - {u})))\n    \\<subseteq> V \\<union> E `` {u}\n 7. \\<forall>v\\<in>V \\<union> E `` {u} -\n                   (E `` {u} - V \\<union> (dom ws - {u})).\n       \\<not> P v\n 8. U0 \\<subseteq> V \\<union> E `` {u}\n 9. \\<forall>v pa.\n       (ws |` (- {u}) ++\n        (\\<lambda>v.\n            if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n            else None))\n        v =\n       Some pa \\<longrightarrow>\n       (\\<forall>v\\<in>set pa. \\<not> P v) \\<and>\n       (\\<exists>u0\\<in>U0. path E u0 (rev pa) v)", "apply (auto simp: inv_def) []"], ["proof (prove)\ngoal (8 subgoals):\n 1. finite (E `` {u} - V)\n 2. finite (dom ws)\n 3. V \\<subseteq> E\\<^sup>* `` U0\n 4. E `` {u} \\<subseteq> E\\<^sup>* `` U0\n 5. E `` (V \\<union> E `` {u} - (E `` {u} - V \\<union> (dom ws - {u})))\n    \\<subseteq> V \\<union> E `` {u}\n 6. \\<forall>v\\<in>V \\<union> E `` {u} -\n                   (E `` {u} - V \\<union> (dom ws - {u})).\n       \\<not> P v\n 7. U0 \\<subseteq> V \\<union> E `` {u}\n 8. \\<forall>v pa.\n       (ws |` (- {u}) ++\n        (\\<lambda>v.\n            if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n            else None))\n        v =\n       Some pa \\<longrightarrow>\n       (\\<forall>v\\<in>set pa. \\<not> P v) \\<and>\n       (\\<exists>u0\\<in>U0. path E u0 (rev pa) v)", "using INV WSU"], ["proof (prove)\nusing this:\n  inv (None, V, ws)\n  ws u = Some p\n\ngoal (8 subgoals):\n 1. finite (E `` {u} - V)\n 2. finite (dom ws)\n 3. V \\<subseteq> E\\<^sup>* `` U0\n 4. E `` {u} \\<subseteq> E\\<^sup>* `` U0\n 5. E `` (V \\<union> E `` {u} - (E `` {u} - V \\<union> (dom ws - {u})))\n    \\<subseteq> V \\<union> E `` {u}\n 6. \\<forall>v\\<in>V \\<union> E `` {u} -\n                   (E `` {u} - V \\<union> (dom ws - {u})).\n       \\<not> P v\n 7. U0 \\<subseteq> V \\<union> E `` {u}\n 8. \\<forall>v pa.\n       (ws |` (- {u}) ++\n        (\\<lambda>v.\n            if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n            else None))\n        v =\n       Some pa \\<longrightarrow>\n       (\\<forall>v\\<in>set pa. \\<not> P v) \\<and>\n       (\\<exists>u0\\<in>U0. path E u0 (rev pa) v)", "apply (auto simp: succs_finite FIN) []"], ["proof (prove)\ngoal (7 subgoals):\n 1. finite (dom ws)\n 2. V \\<subseteq> E\\<^sup>* `` U0\n 3. E `` {u} \\<subseteq> E\\<^sup>* `` U0\n 4. E `` (V \\<union> E `` {u} - (E `` {u} - V \\<union> (dom ws - {u})))\n    \\<subseteq> V \\<union> E `` {u}\n 5. \\<forall>v\\<in>V \\<union> E `` {u} -\n                   (E `` {u} - V \\<union> (dom ws - {u})).\n       \\<not> P v\n 6. U0 \\<subseteq> V \\<union> E `` {u}\n 7. \\<forall>v pa.\n       (ws |` (- {u}) ++\n        (\\<lambda>v.\n            if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n            else None))\n        v =\n       Some pa \\<longrightarrow>\n       (\\<forall>v\\<in>set pa. \\<not> P v) \\<and>\n       (\\<exists>u0\\<in>U0. path E u0 (rev pa) v)", "using INV"], ["proof (prove)\nusing this:\n  inv (None, V, ws)\n\ngoal (7 subgoals):\n 1. finite (dom ws)\n 2. V \\<subseteq> E\\<^sup>* `` U0\n 3. E `` {u} \\<subseteq> E\\<^sup>* `` U0\n 4. E `` (V \\<union> E `` {u} - (E `` {u} - V \\<union> (dom ws - {u})))\n    \\<subseteq> V \\<union> E `` {u}\n 5. \\<forall>v\\<in>V \\<union> E `` {u} -\n                   (E `` {u} - V \\<union> (dom ws - {u})).\n       \\<not> P v\n 6. U0 \\<subseteq> V \\<union> E `` {u}\n 7. \\<forall>v pa.\n       (ws |` (- {u}) ++\n        (\\<lambda>v.\n            if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n            else None))\n        v =\n       Some pa \\<longrightarrow>\n       (\\<forall>v\\<in>set pa. \\<not> P v) \\<and>\n       (\\<exists>u0\\<in>U0. path E u0 (rev pa) v)", "apply (auto simp: inv_def) []"], ["proof (prove)\ngoal (6 subgoals):\n 1. V \\<subseteq> E\\<^sup>* `` U0\n 2. E `` {u} \\<subseteq> E\\<^sup>* `` U0\n 3. E `` (V \\<union> E `` {u} - (E `` {u} - V \\<union> (dom ws - {u})))\n    \\<subseteq> V \\<union> E `` {u}\n 4. \\<forall>v\\<in>V \\<union> E `` {u} -\n                   (E `` {u} - V \\<union> (dom ws - {u})).\n       \\<not> P v\n 5. U0 \\<subseteq> V \\<union> E `` {u}\n 6. \\<forall>v pa.\n       (ws |` (- {u}) ++\n        (\\<lambda>v.\n            if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n            else None))\n        v =\n       Some pa \\<longrightarrow>\n       (\\<forall>v\\<in>set pa. \\<not> P v) \\<and>\n       (\\<exists>u0\\<in>U0. path E u0 (rev pa) v)", "using INV"], ["proof (prove)\nusing this:\n  inv (None, V, ws)\n\ngoal (6 subgoals):\n 1. V \\<subseteq> E\\<^sup>* `` U0\n 2. E `` {u} \\<subseteq> E\\<^sup>* `` U0\n 3. E `` (V \\<union> E `` {u} - (E `` {u} - V \\<union> (dom ws - {u})))\n    \\<subseteq> V \\<union> E `` {u}\n 4. \\<forall>v\\<in>V \\<union> E `` {u} -\n                   (E `` {u} - V \\<union> (dom ws - {u})).\n       \\<not> P v\n 5. U0 \\<subseteq> V \\<union> E `` {u}\n 6. \\<forall>v pa.\n       (ws |` (- {u}) ++\n        (\\<lambda>v.\n            if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n            else None))\n        v =\n       Some pa \\<longrightarrow>\n       (\\<forall>v\\<in>set pa. \\<not> P v) \\<and>\n       (\\<exists>u0\\<in>U0. path E u0 (rev pa) v)", "apply (auto simp: inv_def) []"], ["proof (prove)\ngoal (5 subgoals):\n 1. E `` {u} \\<subseteq> E\\<^sup>* `` U0\n 2. E `` (V \\<union> E `` {u} - (E `` {u} - V \\<union> (dom ws - {u})))\n    \\<subseteq> V \\<union> E `` {u}\n 3. \\<forall>v\\<in>V \\<union> E `` {u} -\n                   (E `` {u} - V \\<union> (dom ws - {u})).\n       \\<not> P v\n 4. U0 \\<subseteq> V \\<union> E `` {u}\n 5. \\<forall>v pa.\n       (ws |` (- {u}) ++\n        (\\<lambda>v.\n            if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n            else None))\n        v =\n       Some pa \\<longrightarrow>\n       (\\<forall>v\\<in>set pa. \\<not> P v) \\<and>\n       (\\<exists>u0\\<in>U0. path E u0 (rev pa) v)", "using INV WSU"], ["proof (prove)\nusing this:\n  inv (None, V, ws)\n  ws u = Some p\n\ngoal (5 subgoals):\n 1. E `` {u} \\<subseteq> E\\<^sup>* `` U0\n 2. E `` (V \\<union> E `` {u} - (E `` {u} - V \\<union> (dom ws - {u})))\n    \\<subseteq> V \\<union> E `` {u}\n 3. \\<forall>v\\<in>V \\<union> E `` {u} -\n                   (E `` {u} - V \\<union> (dom ws - {u})).\n       \\<not> P v\n 4. U0 \\<subseteq> V \\<union> E `` {u}\n 5. \\<forall>v pa.\n       (ws |` (- {u}) ++\n        (\\<lambda>v.\n            if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n            else None))\n        v =\n       Some pa \\<longrightarrow>\n       (\\<forall>v\\<in>set pa. \\<not> P v) \\<and>\n       (\\<exists>u0\\<in>U0. path E u0 (rev pa) v)", "apply (auto \n          simp: inv_def \n          intro: rtrancl_image_advance\n        ) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. E `` (V \\<union> E `` {u} - (E `` {u} - V \\<union> (dom ws - {u})))\n    \\<subseteq> V \\<union> E `` {u}\n 2. \\<forall>v\\<in>V \\<union> E `` {u} -\n                   (E `` {u} - V \\<union> (dom ws - {u})).\n       \\<not> P v\n 3. U0 \\<subseteq> V \\<union> E `` {u}\n 4. \\<forall>v pa.\n       (ws |` (- {u}) ++\n        (\\<lambda>v.\n            if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n            else None))\n        v =\n       Some pa \\<longrightarrow>\n       (\\<forall>v\\<in>set pa. \\<not> P v) \\<and>\n       (\\<exists>u0\\<in>U0. path E u0 (rev pa) v)", "using INV WSU"], ["proof (prove)\nusing this:\n  inv (None, V, ws)\n  ws u = Some p\n\ngoal (4 subgoals):\n 1. E `` (V \\<union> E `` {u} - (E `` {u} - V \\<union> (dom ws - {u})))\n    \\<subseteq> V \\<union> E `` {u}\n 2. \\<forall>v\\<in>V \\<union> E `` {u} -\n                   (E `` {u} - V \\<union> (dom ws - {u})).\n       \\<not> P v\n 3. U0 \\<subseteq> V \\<union> E `` {u}\n 4. \\<forall>v pa.\n       (ws |` (- {u}) ++\n        (\\<lambda>v.\n            if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n            else None))\n        v =\n       Some pa \\<longrightarrow>\n       (\\<forall>v\\<in>set pa. \\<not> P v) \\<and>\n       (\\<exists>u0\\<in>U0. path E u0 (rev pa) v)", "apply (auto simp: inv_def) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>v\\<in>V \\<union> E `` {u} -\n                   (E `` {u} - V \\<union> (dom ws - {u})).\n       \\<not> P v\n 2. U0 \\<subseteq> V \\<union> E `` {u}\n 3. \\<forall>v pa.\n       (ws |` (- {u}) ++\n        (\\<lambda>v.\n            if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n            else None))\n        v =\n       Some pa \\<longrightarrow>\n       (\\<forall>v\\<in>set pa. \\<not> P v) \\<and>\n       (\\<exists>u0\\<in>U0. path E u0 (rev pa) v)", "using INV NVD"], ["proof (prove)\nusing this:\n  inv (None, V, ws)\n  \\<not> P u\n\ngoal (3 subgoals):\n 1. \\<forall>v\\<in>V \\<union> E `` {u} -\n                   (E `` {u} - V \\<union> (dom ws - {u})).\n       \\<not> P v\n 2. U0 \\<subseteq> V \\<union> E `` {u}\n 3. \\<forall>v pa.\n       (ws |` (- {u}) ++\n        (\\<lambda>v.\n            if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n            else None))\n        v =\n       Some pa \\<longrightarrow>\n       (\\<forall>v\\<in>set pa. \\<not> P v) \\<and>\n       (\\<exists>u0\\<in>U0. path E u0 (rev pa) v)", "apply (auto simp: inv_def) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. U0 \\<subseteq> V \\<union> E `` {u}\n 2. \\<forall>v pa.\n       (ws |` (- {u}) ++\n        (\\<lambda>v.\n            if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n            else None))\n        v =\n       Some pa \\<longrightarrow>\n       (\\<forall>v\\<in>set pa. \\<not> P v) \\<and>\n       (\\<exists>u0\\<in>U0. path E u0 (rev pa) v)", "using INV NVD"], ["proof (prove)\nusing this:\n  inv (None, V, ws)\n  \\<not> P u\n\ngoal (2 subgoals):\n 1. U0 \\<subseteq> V \\<union> E `` {u}\n 2. \\<forall>v pa.\n       (ws |` (- {u}) ++\n        (\\<lambda>v.\n            if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n            else None))\n        v =\n       Some pa \\<longrightarrow>\n       (\\<forall>v\\<in>set pa. \\<not> P v) \\<and>\n       (\\<exists>u0\\<in>U0. path E u0 (rev pa) v)", "apply (auto simp: inv_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v pa.\n       (ws |` (- {u}) ++\n        (\\<lambda>v.\n            if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n            else None))\n        v =\n       Some pa \\<longrightarrow>\n       (\\<forall>v\\<in>set pa. \\<not> P v) \\<and>\n       (\\<exists>u0\\<in>U0. path E u0 (rev pa) v)", "using INV WSU NVD"], ["proof (prove)\nusing this:\n  inv (None, V, ws)\n  ws u = Some p\n  \\<not> P u\n\ngoal (1 subgoal):\n 1. \\<forall>v pa.\n       (ws |` (- {u}) ++\n        (\\<lambda>v.\n            if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n            else None))\n        v =\n       Some pa \\<longrightarrow>\n       (\\<forall>v\\<in>set pa. \\<not> P v) \\<and>\n       (\\<exists>u0\\<in>U0. path E u0 (rev pa) v)", "apply (fastforce\n          simp: inv_def restrict_map_def \n          intro!: path_conc path1\n          split: if_split_asm\n        ) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inv (None, V \\<union> E `` {u},\n       ws |` (- {u}) ++\n       (\\<lambda>v.\n           if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n           else None))\n\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "}"], ["proof (state)\nthis:\n  \\<lbrakk>finite (E\\<^sup>* `` U0); inv (None, ?V2, ?ws2);\n   ?ws2 ?u2 = Some ?p2; \\<not> P ?u2\\<rbrakk>\n  \\<Longrightarrow> inv (None, ?V2 \\<union> E `` {?u2},\n                         ?ws2 |` (- {?u2}) ++\n                         (\\<lambda>v.\n                             if (?u2, v) \\<in> E \\<and> v \\<notin> ?V2\n                             then Some (?u2 # ?p2) else None))\n\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "note ip_aux=this"], ["proof (state)\nthis:\n  \\<lbrakk>finite (E\\<^sup>* `` U0); inv (None, ?V2, ?ws2);\n   ?ws2 ?u2 = Some ?p2; \\<not> P ?u2\\<rbrakk>\n  \\<Longrightarrow> inv (None, ?V2 \\<union> E `` {?u2},\n                         ?ws2 |` (- {?u2}) ++\n                         (\\<lambda>v.\n                             if (?u2, v) \\<in> E \\<and> v \\<notin> ?V2\n                             then Some (?u2 # ?p2) else None))\n\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wset_find_path E U0 P \\<le> find_path E U0 P", "unfolding wset_find_path_def find_path_def ws_update_def s_init_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (finite U0) \\<bind>\n    (\\<lambda>_.\n        RETURN\n         (None, U0,\n          \\<lambda>u. if u \\<in> U0 then Some [] else None) \\<bind>\n        (\\<lambda>s0.\n            WHILE\\<^sub>T\n             (\\<lambda>(res, V, ws).\n                 res = None \\<and> ws \\<noteq> Map.empty)\n             (\\<lambda>(res, V, ws).\n                 ASSERT (ws \\<noteq> Map.empty) \\<bind>\n                 (\\<lambda>_.\n                     SPEC (\\<lambda>(u, p). ws u = Some p) \\<bind>\n                     (\\<lambda>(u, p).\n                         let ws = ws |` (- {u})\n                         in if P u then RETURN (Some (rev p, u), V, ws)\n                            else ASSERT (finite (E `` {u})) \\<bind>\n                                 (\\<lambda>_.\n                                     ASSERT (dom ws \\<subseteq> V) \\<bind>\n                                     (\\<lambda>_.\n   RETURN\n    (V \\<union> E `` {u},\n     ws ++\n     (\\<lambda>v.\n         if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n         else None)) \\<bind>\n   (\\<lambda>(V, ws). RETURN (None, V, ws)))))))\n             s0 \\<bind>\n            (\\<lambda>(res, uu_, uu_). RETURN res)))\n    \\<le> ASSERT (finite U0) \\<bind>\n          (\\<lambda>_.\n              ASSERT (finite (E\\<^sup>* `` U0)) \\<bind>\n              (\\<lambda>_.\n                  SPEC\n                   (\\<lambda>p.\n                       case p of\n                       None \\<Rightarrow>\n                         \\<forall>u0\\<in>U0.\n                            \\<forall>v\\<in>E\\<^sup>* `` {u0}. \\<not> P v\n                       | Some (p, v) \\<Rightarrow>\n                           \\<exists>u0\\<in>U0.\n                              path E u0 p v \\<and>\n                              P v \\<and>\n                              (\\<forall>v\\<in>set p. \\<not> P v))))", "apply (refine_rcg refine_vcg le_ASSERTI\n        WHILET_rule[where \n          R = var and I = inv]\n      )"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>finite U0; finite (E\\<^sup>* `` U0); finite U0\\<rbrakk>\n    \\<Longrightarrow> wf var\n 2. \\<lbrakk>finite U0; finite (E\\<^sup>* `` U0); finite U0\\<rbrakk>\n    \\<Longrightarrow> inv (None, U0,\n                           \\<lambda>u. if u \\<in> U0 then Some [] else None)\n 3. \\<And>s a b aa ba.\n       \\<lbrakk>finite U0; finite (E\\<^sup>* `` U0); finite U0; inv s;\n        case s of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ba \\<noteq> Map.empty\n 4. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>finite U0; finite (E\\<^sup>* `` U0); finite U0; inv s;\n        case s of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        s = (a, b); b = (aa, ba); ba \\<noteq> Map.empty;\n        case x of (u, p) \\<Rightarrow> ba u = Some p; x = (ab, bb);\n        P ab\\<rbrakk>\n       \\<Longrightarrow> inv (Some (rev bb, ab), aa, ba |` (- {ab}))\n 5. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>finite U0; finite (E\\<^sup>* `` U0); finite U0; inv s;\n        case s of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        s = (a, b); b = (aa, ba); ba \\<noteq> Map.empty;\n        case x of (u, p) \\<Rightarrow> ba u = Some p; x = (ab, bb);\n        P ab\\<rbrakk>\n       \\<Longrightarrow> ((Some (rev bb, ab), aa, ba |` (- {ab})), s)\n                         \\<in> var\n 6. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>finite U0; finite (E\\<^sup>* `` U0); finite U0; inv s;\n        case s of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        s = (a, b); b = (aa, ba); ba \\<noteq> Map.empty;\n        case x of (u, p) \\<Rightarrow> ba u = Some p; x = (ab, bb);\n        \\<not> P ab\\<rbrakk>\n       \\<Longrightarrow> finite (E `` {ab})\n 7. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>finite U0; finite (E\\<^sup>* `` U0); finite U0; inv s;\n        case s of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        s = (a, b); b = (aa, ba); ba \\<noteq> Map.empty;\n        case x of (u, p) \\<Rightarrow> ba u = Some p; x = (ab, bb);\n        \\<not> P ab; finite (E `` {ab})\\<rbrakk>\n       \\<Longrightarrow> dom (ba |` (- {ab})) \\<subseteq> aa\n 8. \\<And>s a b aa ba x ab bb ac bc.\n       \\<lbrakk>finite U0; finite (E\\<^sup>* `` U0); finite U0; inv s;\n        case s of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        s = (a, b); b = (aa, ba); ba \\<noteq> Map.empty;\n        case x of (u, p) \\<Rightarrow> ba u = Some p; x = (ab, bb);\n        \\<not> P ab; finite (E `` {ab});\n        dom (ba |` (- {ab})) \\<subseteq> aa;\n        (aa \\<union> E `` {ab},\n         ba |` (- {ab}) ++\n         (\\<lambda>v.\n             if (ab, v) \\<in> E \\<and> v \\<notin> aa then Some (ab # bb)\n             else None)) =\n        (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> inv (None, ac, bc)\n 9. \\<And>s a b aa ba x ab bb ac bc.\n       \\<lbrakk>finite U0; finite (E\\<^sup>* `` U0); finite U0; inv s;\n        case s of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        s = (a, b); b = (aa, ba); ba \\<noteq> Map.empty;\n        case x of (u, p) \\<Rightarrow> ba u = Some p; x = (ab, bb);\n        \\<not> P ab; finite (E `` {ab});\n        dom (ba |` (- {ab})) \\<subseteq> aa;\n        (aa \\<union> E `` {ab},\n         ba |` (- {ab}) ++\n         (\\<lambda>v.\n             if (ab, v) \\<in> E \\<and> v \\<notin> aa then Some (ab # bb)\n             else None)) =\n        (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> ((None, ac, bc), s) \\<in> var\n 10. \\<And>s a b aa ba.\n        \\<lbrakk>finite U0; finite (E\\<^sup>* `` U0); finite U0; inv s;\n         \\<not> (case s of\n                 (res, V, ws) \\<Rightarrow>\n                   res = None \\<and> ws \\<noteq> Map.empty);\n         s = (a, b); b = (aa, ba)\\<rbrakk>\n        \\<Longrightarrow> case a of\n                          None \\<Rightarrow>\n                            \\<forall>u0\\<in>U0.\n                               \\<forall>v\\<in>E\\<^sup>* `` {u0}. \\<not> P v\n                          | Some (p, v) \\<Rightarrow>\n                              \\<exists>u0\\<in>U0.\n                                 path E u0 p v \\<and>\n                                 P v \\<and>\n                                 (\\<forall>v\\<in>set p. \\<not> P v)", "using [[goals_limit = 1]]"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>finite U0; finite (E\\<^sup>* `` U0); finite U0\\<rbrakk>\n    \\<Longrightarrow> wf var\nA total of 10 subgoals...", "apply (auto simp: var_def) []"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>finite U0; finite (E\\<^sup>* `` U0); finite U0\\<rbrakk>\n    \\<Longrightarrow> inv (None, U0,\n                           \\<lambda>u. if u \\<in> U0 then Some [] else None)\nA total of 9 subgoals...", "apply (auto \n        simp: inv_def dom_def\n        split: if_split_asm) []"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>s a b aa ba.\n       \\<lbrakk>finite U0; finite (E\\<^sup>* `` U0); finite U0; inv s;\n        case s of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> ba \\<noteq> Map.empty\nA total of 8 subgoals...", "apply simp"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>finite U0; finite (E\\<^sup>* `` U0); finite U0; inv s;\n        case s of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        s = (a, b); b = (aa, ba); ba \\<noteq> Map.empty;\n        case x of (u, p) \\<Rightarrow> ba u = Some p; x = (ab, bb);\n        P ab\\<rbrakk>\n       \\<Longrightarrow> inv (Some (rev bb, ab), aa, ba |` (- {ab}))\nA total of 7 subgoals...", "apply (auto simp: inv_def) []"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>finite U0; finite (E\\<^sup>* `` U0); finite U0; inv s;\n        case s of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        s = (a, b); b = (aa, ba); ba \\<noteq> Map.empty;\n        case x of (u, p) \\<Rightarrow> ba u = Some p; x = (ab, bb);\n        P ab\\<rbrakk>\n       \\<Longrightarrow> ((Some (rev bb, ab), aa, ba |` (- {ab})), s)\n                         \\<in> var\nA total of 6 subgoals...", "apply (auto simp: var_def brk_rel_def) []"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>finite U0; finite (E\\<^sup>* `` U0); finite U0; inv s;\n        case s of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        s = (a, b); b = (aa, ba); ba \\<noteq> Map.empty;\n        case x of (u, p) \\<Rightarrow> ba u = Some p; x = (ab, bb);\n        \\<not> P ab\\<rbrakk>\n       \\<Longrightarrow> finite (E `` {ab})\nA total of 5 subgoals...", "apply (simp add: succs_finite)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s a b aa ba x ab bb.\n       \\<lbrakk>finite U0; finite (E\\<^sup>* `` U0); finite U0; inv s;\n        case s of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        s = (a, b); b = (aa, ba); ba \\<noteq> Map.empty;\n        case x of (u, p) \\<Rightarrow> ba u = Some p; x = (ab, bb);\n        \\<not> P ab; finite (E `` {ab})\\<rbrakk>\n       \\<Longrightarrow> dom (ba |` (- {ab})) \\<subseteq> aa\nA total of 4 subgoals...", "apply (auto simp: inv_def) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s a b aa ba x ab bb ac bc.\n       \\<lbrakk>finite U0; finite (E\\<^sup>* `` U0); finite U0; inv s;\n        case s of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        s = (a, b); b = (aa, ba); ba \\<noteq> Map.empty;\n        case x of (u, p) \\<Rightarrow> ba u = Some p; x = (ab, bb);\n        \\<not> P ab; finite (E `` {ab});\n        dom (ba |` (- {ab})) \\<subseteq> aa;\n        (aa \\<union> E `` {ab},\n         ba |` (- {ab}) ++\n         (\\<lambda>v.\n             if (ab, v) \\<in> E \\<and> v \\<notin> aa then Some (ab # bb)\n             else None)) =\n        (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> inv (None, ac, bc)\nA total of 3 subgoals...", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aaa baa aba bba.\n       \\<lbrakk>finite (E\\<^sup>* `` U0); finite U0; inv (None, aaa, baa);\n        baa \\<noteq> Map.empty; baa aba = Some bba; \\<not> P aba;\n        finite (E `` {aba}); dom baa - {aba} \\<subseteq> aaa\\<rbrakk>\n       \\<Longrightarrow> inv (None, aaa \\<union> E `` {aba},\n                              baa |` (- {aba}) ++\n                              (\\<lambda>v.\n                                  if (aba, v) \\<in> E \\<and> v \\<notin> aaa\n                                  then Some (aba # bba) else None))\nA total of 3 subgoals...", "apply (simp add: ip_aux)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s a b aa ba x ab bb ac bc.\n       \\<lbrakk>finite U0; finite (E\\<^sup>* `` U0); finite U0; inv s;\n        case s of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        s = (a, b); b = (aa, ba); ba \\<noteq> Map.empty;\n        case x of (u, p) \\<Rightarrow> ba u = Some p; x = (ab, bb);\n        \\<not> P ab; finite (E `` {ab});\n        dom (ba |` (- {ab})) \\<subseteq> aa;\n        (aa \\<union> E `` {ab},\n         ba |` (- {ab}) ++\n         (\\<lambda>v.\n             if (ab, v) \\<in> E \\<and> v \\<notin> aa then Some (ab # bb)\n             else None)) =\n        (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> ((None, ac, bc), s) \\<in> var\nA total of 2 subgoals...", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aaa baa aba bba.\n       \\<lbrakk>finite (E\\<^sup>* `` U0); finite U0; inv (None, aaa, baa);\n        baa \\<noteq> Map.empty; baa aba = Some bba; \\<not> P aba;\n        finite (E `` {aba}); dom baa - {aba} \\<subseteq> aaa\\<rbrakk>\n       \\<Longrightarrow> ((None, aaa \\<union> E `` {aba},\n                           baa |` (- {aba}) ++\n                           (\\<lambda>v.\n                               if (aba, v) \\<in> E \\<and> v \\<notin> aaa\n                               then Some (aba # bba) else None)),\n                          None, aaa, baa)\n                         \\<in> var\nA total of 2 subgoals...", "apply (simp add: var_def brk_rel_def wf_aux) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s a b aa ba.\n       \\<lbrakk>finite U0; finite (E\\<^sup>* `` U0); finite U0; inv s;\n        \\<not> (case s of\n                (res, V, ws) \\<Rightarrow>\n                  res = None \\<and> ws \\<noteq> Map.empty);\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> case a of\n                         None \\<Rightarrow>\n                           \\<forall>u0\\<in>U0.\n                              \\<forall>v\\<in>E\\<^sup>* `` {u0}. \\<not> P v\n                         | Some (p, v) \\<Rightarrow>\n                             \\<exists>u0\\<in>U0.\n                                path E u0 p v \\<and>\n                                P v \\<and>\n                                (\\<forall>v\\<in>set p. \\<not> P v)", "apply (fastforce\n        simp: inv_def \n        split: option.splits \n        intro: rev_ImageI\n        dest: Image_closed_trancl) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wset_find_path E U0 P \\<le> find_path E U0 P\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We refine the algorithm to use a foreach-loop\\<close>"], ["", "definition \"ws_update_foreach E u p V ws \\<equiv> \n    FOREACH (LIST_SET_REV_TAG (E``{u})) (\\<lambda>v (V,ws). \n      if v\\<in>V then \n        RETURN (V,ws) \n      else do {\n        ASSERT (v\\<notin>dom ws);\n        RETURN (insert v V,ws( v \\<mapsto> u#p))\n      }\n    ) (V,ws)\""], ["", "lemma ws_update_foreach_refine[refine]:\n    assumes FIN: \"finite (E``{u})\"\n    assumes WSS: \"dom ws \\<subseteq> V\"\n    assumes ID: \"(E',E)\\<in>Id\" \"(u',u)\\<in>Id\" \"(p',p)\\<in>Id\" \"(V',V)\\<in>Id\" \"(ws',ws)\\<in>Id\"\n    shows \"ws_update_foreach E' u' p' V' ws' \\<le> \\<Down>Id (ws_update E u p V ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ws_update_foreach E' u' p' V' ws'\n    \\<le> \\<Down> Id (ws_update E u p V ws)", "unfolding ID[simplified]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ws_update_foreach E u p V ws \\<le> \\<Down> Id (ws_update E u p V ws)", "unfolding ws_update_foreach_def ws_update_def LIST_SET_REV_TAG_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH (E `` {u})\n     (\\<lambda>v (V, ws).\n         if v \\<in> V then RETURN (V, ws)\n         else ASSERT (v \\<notin> dom ws) \\<bind>\n              (\\<lambda>_. RETURN (insert v V, ws(v \\<mapsto> u # p))))\n     (V, ws)\n    \\<le> \\<Down> Id\n           (RETURN\n             (V \\<union> E `` {u},\n              ws ++\n              (\\<lambda>v.\n                  if (u, v) \\<in> E \\<and> v \\<notin> V then Some (u # p)\n                  else None)))", "apply (refine_rcg refine_vcg FIN\n      FOREACH_rule[where I=\"\\<lambda>it (V',ws'). \n        V'=V \\<union> (E``{u}-it)\n      \\<and> dom ws' \\<subseteq> V'\n      \\<and> ws' = ws ++ (\\<lambda>v. if (u,v)\\<in>E \\<and> v\\<notin>it \\<and> v\\<notin>V then Some (u#p) else None)\"]\n    )"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x1 x2.\n       (V, ws) = (x1, x2) \\<Longrightarrow>\n       x1 = V \\<union> (E `` {u} - E `` {u})\n 2. \\<And>x1 x2. (V, ws) = (x1, x2) \\<Longrightarrow> dom x2 \\<subseteq> x1\n 3. \\<And>x1 x2.\n       (V, ws) = (x1, x2) \\<Longrightarrow>\n       x2 =\n       ws ++\n       (\\<lambda>v.\n           if (u, v) \\<in> E \\<and> v \\<notin> E `` {u} \\<and> v \\<notin> V\n           then Some (u # p) else None)\n 4. \\<And>x it \\<sigma> a b x1 x2.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> E `` {u};\n        case \\<sigma> of\n        (V', ws') \\<Rightarrow>\n          V' = V \\<union> (E `` {u} - it) \\<and>\n          dom ws' \\<subseteq> V' \\<and>\n          ws' =\n          ws ++\n          (\\<lambda>v.\n              if (u, v) \\<in> E \\<and> v \\<notin> it \\<and> v \\<notin> V\n              then Some (u # p) else None);\n        \\<sigma> = (a, b); x \\<in> a; (a, b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 = V \\<union> (E `` {u} - (it - {x}))\n 5. \\<And>x it \\<sigma> a b x1 x2.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> E `` {u};\n        case \\<sigma> of\n        (V', ws') \\<Rightarrow>\n          V' = V \\<union> (E `` {u} - it) \\<and>\n          dom ws' \\<subseteq> V' \\<and>\n          ws' =\n          ws ++\n          (\\<lambda>v.\n              if (u, v) \\<in> E \\<and> v \\<notin> it \\<and> v \\<notin> V\n              then Some (u # p) else None);\n        \\<sigma> = (a, b); x \\<in> a; (a, b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> dom x2 \\<subseteq> x1\n 6. \\<And>x it \\<sigma> a b x1 x2.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> E `` {u};\n        case \\<sigma> of\n        (V', ws') \\<Rightarrow>\n          V' = V \\<union> (E `` {u} - it) \\<and>\n          dom ws' \\<subseteq> V' \\<and>\n          ws' =\n          ws ++\n          (\\<lambda>v.\n              if (u, v) \\<in> E \\<and> v \\<notin> it \\<and> v \\<notin> V\n              then Some (u # p) else None);\n        \\<sigma> = (a, b); x \\<in> a; (a, b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2 =\n                         ws ++\n                         (\\<lambda>v.\n                             if (u, v) \\<in> E \\<and>\n                                v \\<notin> it - {x} \\<and> v \\<notin> V\n                             then Some (u # p) else None)\n 7. \\<And>x it \\<sigma> a b.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> E `` {u};\n        case \\<sigma> of\n        (V', ws') \\<Rightarrow>\n          V' = V \\<union> (E `` {u} - it) \\<and>\n          dom ws' \\<subseteq> V' \\<and>\n          ws' =\n          ws ++\n          (\\<lambda>v.\n              if (u, v) \\<in> E \\<and> v \\<notin> it \\<and> v \\<notin> V\n              then Some (u # p) else None);\n        \\<sigma> = (a, b); x \\<notin> a\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> dom b\n 8. \\<And>x it \\<sigma> a b x1 x2.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> E `` {u};\n        case \\<sigma> of\n        (V', ws') \\<Rightarrow>\n          V' = V \\<union> (E `` {u} - it) \\<and>\n          dom ws' \\<subseteq> V' \\<and>\n          ws' =\n          ws ++\n          (\\<lambda>v.\n              if (u, v) \\<in> E \\<and> v \\<notin> it \\<and> v \\<notin> V\n              then Some (u # p) else None);\n        \\<sigma> = (a, b); x \\<notin> a; x \\<notin> dom b;\n        (insert x a, b(x \\<mapsto> u # p)) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 = V \\<union> (E `` {u} - (it - {x}))\n 9. \\<And>x it \\<sigma> a b x1 x2.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> E `` {u};\n        case \\<sigma> of\n        (V', ws') \\<Rightarrow>\n          V' = V \\<union> (E `` {u} - it) \\<and>\n          dom ws' \\<subseteq> V' \\<and>\n          ws' =\n          ws ++\n          (\\<lambda>v.\n              if (u, v) \\<in> E \\<and> v \\<notin> it \\<and> v \\<notin> V\n              then Some (u # p) else None);\n        \\<sigma> = (a, b); x \\<notin> a; x \\<notin> dom b;\n        (insert x a, b(x \\<mapsto> u # p)) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> dom x2 \\<subseteq> x1\n 10. \\<And>x it \\<sigma> a b x1 x2.\n        \\<lbrakk>x \\<in> it; it \\<subseteq> E `` {u};\n         case \\<sigma> of\n         (V', ws') \\<Rightarrow>\n           V' = V \\<union> (E `` {u} - it) \\<and>\n           dom ws' \\<subseteq> V' \\<and>\n           ws' =\n           ws ++\n           (\\<lambda>v.\n               if (u, v) \\<in> E \\<and> v \\<notin> it \\<and> v \\<notin> V\n               then Some (u # p) else None);\n         \\<sigma> = (a, b); x \\<notin> a; x \\<notin> dom b;\n         (insert x a, b(x \\<mapsto> u # p)) = (x1, x2)\\<rbrakk>\n        \\<Longrightarrow> x2 =\n                          ws ++\n                          (\\<lambda>v.\n                              if (u, v) \\<in> E \\<and>\n                                 v \\<notin> it - {x} \\<and> v \\<notin> V\n                              then Some (u # p) else None)\nA total of 11 subgoals...", "using WSS"], ["proof (prove)\nusing this:\n  dom ws \\<subseteq> V\n\ngoal (11 subgoals):\n 1. \\<And>x1 x2.\n       (V, ws) = (x1, x2) \\<Longrightarrow>\n       x1 = V \\<union> (E `` {u} - E `` {u})\n 2. \\<And>x1 x2. (V, ws) = (x1, x2) \\<Longrightarrow> dom x2 \\<subseteq> x1\n 3. \\<And>x1 x2.\n       (V, ws) = (x1, x2) \\<Longrightarrow>\n       x2 =\n       ws ++\n       (\\<lambda>v.\n           if (u, v) \\<in> E \\<and> v \\<notin> E `` {u} \\<and> v \\<notin> V\n           then Some (u # p) else None)\n 4. \\<And>x it \\<sigma> a b x1 x2.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> E `` {u};\n        case \\<sigma> of\n        (V', ws') \\<Rightarrow>\n          V' = V \\<union> (E `` {u} - it) \\<and>\n          dom ws' \\<subseteq> V' \\<and>\n          ws' =\n          ws ++\n          (\\<lambda>v.\n              if (u, v) \\<in> E \\<and> v \\<notin> it \\<and> v \\<notin> V\n              then Some (u # p) else None);\n        \\<sigma> = (a, b); x \\<in> a; (a, b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 = V \\<union> (E `` {u} - (it - {x}))\n 5. \\<And>x it \\<sigma> a b x1 x2.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> E `` {u};\n        case \\<sigma> of\n        (V', ws') \\<Rightarrow>\n          V' = V \\<union> (E `` {u} - it) \\<and>\n          dom ws' \\<subseteq> V' \\<and>\n          ws' =\n          ws ++\n          (\\<lambda>v.\n              if (u, v) \\<in> E \\<and> v \\<notin> it \\<and> v \\<notin> V\n              then Some (u # p) else None);\n        \\<sigma> = (a, b); x \\<in> a; (a, b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> dom x2 \\<subseteq> x1\n 6. \\<And>x it \\<sigma> a b x1 x2.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> E `` {u};\n        case \\<sigma> of\n        (V', ws') \\<Rightarrow>\n          V' = V \\<union> (E `` {u} - it) \\<and>\n          dom ws' \\<subseteq> V' \\<and>\n          ws' =\n          ws ++\n          (\\<lambda>v.\n              if (u, v) \\<in> E \\<and> v \\<notin> it \\<and> v \\<notin> V\n              then Some (u # p) else None);\n        \\<sigma> = (a, b); x \\<in> a; (a, b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2 =\n                         ws ++\n                         (\\<lambda>v.\n                             if (u, v) \\<in> E \\<and>\n                                v \\<notin> it - {x} \\<and> v \\<notin> V\n                             then Some (u # p) else None)\n 7. \\<And>x it \\<sigma> a b.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> E `` {u};\n        case \\<sigma> of\n        (V', ws') \\<Rightarrow>\n          V' = V \\<union> (E `` {u} - it) \\<and>\n          dom ws' \\<subseteq> V' \\<and>\n          ws' =\n          ws ++\n          (\\<lambda>v.\n              if (u, v) \\<in> E \\<and> v \\<notin> it \\<and> v \\<notin> V\n              then Some (u # p) else None);\n        \\<sigma> = (a, b); x \\<notin> a\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> dom b\n 8. \\<And>x it \\<sigma> a b x1 x2.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> E `` {u};\n        case \\<sigma> of\n        (V', ws') \\<Rightarrow>\n          V' = V \\<union> (E `` {u} - it) \\<and>\n          dom ws' \\<subseteq> V' \\<and>\n          ws' =\n          ws ++\n          (\\<lambda>v.\n              if (u, v) \\<in> E \\<and> v \\<notin> it \\<and> v \\<notin> V\n              then Some (u # p) else None);\n        \\<sigma> = (a, b); x \\<notin> a; x \\<notin> dom b;\n        (insert x a, b(x \\<mapsto> u # p)) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 = V \\<union> (E `` {u} - (it - {x}))\n 9. \\<And>x it \\<sigma> a b x1 x2.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> E `` {u};\n        case \\<sigma> of\n        (V', ws') \\<Rightarrow>\n          V' = V \\<union> (E `` {u} - it) \\<and>\n          dom ws' \\<subseteq> V' \\<and>\n          ws' =\n          ws ++\n          (\\<lambda>v.\n              if (u, v) \\<in> E \\<and> v \\<notin> it \\<and> v \\<notin> V\n              then Some (u # p) else None);\n        \\<sigma> = (a, b); x \\<notin> a; x \\<notin> dom b;\n        (insert x a, b(x \\<mapsto> u # p)) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> dom x2 \\<subseteq> x1\n 10. \\<And>x it \\<sigma> a b x1 x2.\n        \\<lbrakk>x \\<in> it; it \\<subseteq> E `` {u};\n         case \\<sigma> of\n         (V', ws') \\<Rightarrow>\n           V' = V \\<union> (E `` {u} - it) \\<and>\n           dom ws' \\<subseteq> V' \\<and>\n           ws' =\n           ws ++\n           (\\<lambda>v.\n               if (u, v) \\<in> E \\<and> v \\<notin> it \\<and> v \\<notin> V\n               then Some (u # p) else None);\n         \\<sigma> = (a, b); x \\<notin> a; x \\<notin> dom b;\n         (insert x a, b(x \\<mapsto> u # p)) = (x1, x2)\\<rbrakk>\n        \\<Longrightarrow> x2 =\n                          ws ++\n                          (\\<lambda>v.\n                              if (u, v) \\<in> E \\<and>\n                                 v \\<notin> it - {x} \\<and> v \\<notin> V\n                              then Some (u # p) else None)\nA total of 11 subgoals...", "apply (auto \n      simp: Map.map_add_def\n      split: option.splits if_split_asm\n      intro!: ext[where 'a='a and 'b=\"'b list option\"])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"s_init_foreach U0 \\<equiv> do {\n      (U0,ws) \\<leftarrow> FOREACH U0 (\\<lambda>x (U0,ws). \n        RETURN (insert x U0,ws(x\\<mapsto>[]))) ({},Map.empty);\n      RETURN (None,U0,ws)\n    }\""], ["", "lemma s_init_foreach_refine[refine]:\n    assumes FIN: \"finite U0\"\n    assumes ID: \"(U0',U0)\\<in>Id\"\n    shows \"s_init_foreach U0' \\<le>\\<Down>Id (s_init U0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s_init_foreach U0' \\<le> \\<Down> Id (s_init U0)", "unfolding s_init_foreach_def s_init_def ID[simplified]"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH U0\n     (\\<lambda>x (U0, ws). RETURN (insert x U0, ws(x \\<mapsto> [])))\n     ({}, Map.empty) \\<bind>\n    (\\<lambda>(U0, ws). RETURN (None, U0, ws))\n    \\<le> \\<Down> Id\n           (RETURN\n             (None, U0, \\<lambda>u. if u \\<in> U0 then Some [] else None))", "apply (refine_rcg refine_vcg\n      FOREACH_rule[where \n        I = \"\\<lambda>it (U,ws). \n          U = U0-it \n        \\<and> ws = (\\<lambda>x. if x\\<in>U0-it then Some [] else None)\"]\n    )"], ["proof (prove)\ngoal (6 subgoals):\n 1. finite U0\n 2. \\<And>x1 x2. ({}, Map.empty) = (x1, x2) \\<Longrightarrow> x1 = U0 - U0\n 3. \\<And>x1 x2.\n       ({}, Map.empty) = (x1, x2) \\<Longrightarrow>\n       x2 = (\\<lambda>x. if x \\<in> U0 - U0 then Some [] else None)\n 4. \\<And>x it \\<sigma> a b x1 x2.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> U0;\n        case \\<sigma> of\n        (U, ws) \\<Rightarrow>\n          U = U0 - it \\<and>\n          ws = (\\<lambda>x. if x \\<in> U0 - it then Some [] else None);\n        \\<sigma> = (a, b);\n        (insert x a, b(x \\<mapsto> [])) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 = U0 - (it - {x})\n 5. \\<And>x it \\<sigma> a b x1 x2.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> U0;\n        case \\<sigma> of\n        (U, ws) \\<Rightarrow>\n          U = U0 - it \\<and>\n          ws = (\\<lambda>x. if x \\<in> U0 - it then Some [] else None);\n        \\<sigma> = (a, b);\n        (insert x a, b(x \\<mapsto> [])) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2 =\n                         (\\<lambda>xa.\n                             if xa \\<in> U0 - (it - {x}) then Some []\n                             else None)\n 6. \\<And>\\<sigma> a b.\n       \\<lbrakk>case \\<sigma> of\n                (U, ws) \\<Rightarrow>\n                  U = U0 - {} \\<and>\n                  ws =\n                  (\\<lambda>x. if x \\<in> U0 - {} then Some [] else None);\n        \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> ((None, a, b), None, U0,\n                          \\<lambda>u. if u \\<in> U0 then Some [] else None)\n                         \\<in> Id", "apply (auto\n      simp: FIN\n      intro!: ext\n    )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"wset_find_path' E U0 P \\<equiv> do {\n    ASSERT (finite U0);\n    s0\\<leftarrow>s_init_foreach U0;\n    (res,_,_) \\<leftarrow> WHILET \n      (\\<lambda>(res,V,ws). res=None \\<and> ws\\<noteq>Map.empty)\n      (\\<lambda>(res,V,ws). do {\n        ASSERT (ws\\<noteq>Map.empty);\n        ((u,p),ws) \\<leftarrow> op_map_pick_remove ws;\n        \n        if P u then\n          RETURN (Some (rev p,u),V,ws)\n        else do {\n          (V,ws) \\<leftarrow> ws_update_foreach E u p V ws;\n          RETURN (None,V,ws)\n        }\n      })\n      s0;\n      RETURN res\n    }\""], ["", "lemma wset_find_path'_refine: \n    \"wset_find_path' E U0 P \\<le> \\<Down>Id (wset_find_path E U0 P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wset_find_path' E U0 P \\<le> \\<Down> Id (wset_find_path E U0 P)", "unfolding wset_find_path'_def wset_find_path_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (finite U0) \\<bind>\n    (\\<lambda>_.\n        s_init_foreach U0 \\<bind>\n        (\\<lambda>s0.\n            WHILE\\<^sub>T\n             (\\<lambda>(res, V, ws).\n                 res = None \\<and> ws \\<noteq> Map.empty)\n             (\\<lambda>(res, V, ws).\n                 ASSERT (ws \\<noteq> Map.empty) \\<bind>\n                 (\\<lambda>_.\n                     op_map_pick_remove ws \\<bind>\n                     (\\<lambda>((u, p), ws).\n                         if P u then RETURN (Some (rev p, u), V, ws)\n                         else ws_update_foreach E u p V ws \\<bind>\n                              (\\<lambda>(V, ws). RETURN (None, V, ws)))))\n             s0 \\<bind>\n            (\\<lambda>(res, uu_, uu_). RETURN res)))\n    \\<le> \\<Down> Id\n           (ASSERT (finite U0) \\<bind>\n            (\\<lambda>_.\n                s_init U0 \\<bind>\n                (\\<lambda>s0.\n                    WHILE\\<^sub>T\n                     (\\<lambda>(res, V, ws).\n                         res = None \\<and> ws \\<noteq> Map.empty)\n                     (\\<lambda>(res, V, ws).\n                         ASSERT (ws \\<noteq> Map.empty) \\<bind>\n                         (\\<lambda>_.\n                             SPEC (\\<lambda>(u, p). ws u = Some p) \\<bind>\n                             (\\<lambda>(u, p).\n                                 let ws = ws |` (- {u})\n                                 in if P u\n                                    then RETURN (Some (rev p, u), V, ws)\n                                    else ASSERT (finite (E `` {u})) \\<bind>\n   (\\<lambda>_.\n       ASSERT (dom ws \\<subseteq> V) \\<bind>\n       (\\<lambda>_.\n           ws_update E u p V ws \\<bind>\n           (\\<lambda>(V, ws). RETURN (None, V, ws)))))))\n                     s0 \\<bind>\n                    (\\<lambda>(res, uu_, uu_). RETURN res))))", "unfolding op_map_pick_remove_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (finite U0) \\<bind>\n    (\\<lambda>_.\n        s_init_foreach U0 \\<bind>\n        (\\<lambda>s0.\n            WHILE\\<^sub>T\n             (\\<lambda>(res, V, ws).\n                 res = None \\<and> ws \\<noteq> Map.empty)\n             (\\<lambda>(res, V, ws).\n                 ASSERT (ws \\<noteq> Map.empty) \\<bind>\n                 (\\<lambda>_.\n                     SPEC (\\<lambda>(k, v). ws k = Some v) \\<bind>\n                     (\\<lambda>(k, v).\n                         let ws = ws |` (- {k})\n                         in if P k then RETURN (Some (rev v, k), V, ws)\n                            else ws_update_foreach E k v V ws \\<bind>\n                                 (\\<lambda>(V, ws). RETURN (None, V, ws)))))\n             s0 \\<bind>\n            (\\<lambda>(res, uu_, uu_). RETURN res)))\n    \\<le> \\<Down> Id\n           (ASSERT (finite U0) \\<bind>\n            (\\<lambda>_.\n                s_init U0 \\<bind>\n                (\\<lambda>s0.\n                    WHILE\\<^sub>T\n                     (\\<lambda>(res, V, ws).\n                         res = None \\<and> ws \\<noteq> Map.empty)\n                     (\\<lambda>(res, V, ws).\n                         ASSERT (ws \\<noteq> Map.empty) \\<bind>\n                         (\\<lambda>_.\n                             SPEC (\\<lambda>(u, p). ws u = Some p) \\<bind>\n                             (\\<lambda>(u, p).\n                                 let ws = ws |` (- {u})\n                                 in if P u\n                                    then RETURN (Some (rev p, u), V, ws)\n                                    else ASSERT (finite (E `` {u})) \\<bind>\n   (\\<lambda>_.\n       ASSERT (dom ws \\<subseteq> V) \\<bind>\n       (\\<lambda>_.\n           ws_update E u p V ws \\<bind>\n           (\\<lambda>(V, ws). RETURN (None, V, ws)))))))\n                     s0 \\<bind>\n                    (\\<lambda>(res, uu_, uu_). RETURN res))))", "apply (refine_rcg IdI)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>s0 s0a.\n       \\<lbrakk>finite U0; finite U0; (s0, s0a) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> (s0, s0a) \\<in> ?R'5 s0 s0a\n 2. \\<And>s0 s0a x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>finite U0; finite U0; (s0, s0a) \\<in> Id;\n        (x, x') \\<in> ?R'5 s0 s0a; x2 = (x1a, x2a); x = (x1, x2);\n        x2b = (x1c, x2c); x' = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (x1 = None \\<and> x2a \\<noteq> Map.empty) =\n                         (x1b = None \\<and> x2c \\<noteq> Map.empty)\n 3. \\<And>s0 s0a x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>finite U0; finite U0; (s0, s0a) \\<in> Id;\n        (x, x') \\<in> ?R'5 s0 s0a;\n        case x of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        case x' of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x2a \\<noteq> Map.empty\\<rbrakk>\n       \\<Longrightarrow> x2c \\<noteq> Map.empty\n 4. \\<And>s0 s0a x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>finite U0; finite U0; (s0, s0a) \\<in> Id;\n        (x, x') \\<in> ?R'5 s0 s0a;\n        case x of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        case x' of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x2a \\<noteq> Map.empty; x2c \\<noteq> Map.empty\\<rbrakk>\n       \\<Longrightarrow> SPEC (\\<lambda>(k, v). x2c k = Some v)\n                         \\<le> SPEC (\\<lambda>(u, p). x2a u = Some p)\n 5. \\<And>s0 s0a x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>finite U0; finite U0; (s0, s0a) \\<in> Id;\n        (x, x') \\<in> ?R'5 s0 s0a;\n        case x of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        case x' of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x2a \\<noteq> Map.empty; x2c \\<noteq> Map.empty; (xa, x'a) \\<in> Id;\n        xa \\<in> {(k, v). x2c k = Some v};\n        x'a \\<in> {(u, p). x2a u = Some p}; x'a = (x1d, x2d);\n        xa = (x1e, x2e)\\<rbrakk>\n       \\<Longrightarrow> P x1e = P x1d\n 6. \\<And>s0 s0a x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>finite U0; finite U0; (s0, s0a) \\<in> Id;\n        (x, x') \\<in> ?R'5 s0 s0a;\n        case x of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        case x' of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x2a \\<noteq> Map.empty; x2c \\<noteq> Map.empty; (xa, x'a) \\<in> Id;\n        xa \\<in> {(k, v). x2c k = Some v};\n        x'a \\<in> {(u, p). x2a u = Some p}; x'a = (x1d, x2d);\n        xa = (x1e, x2e); P x1e; P x1d\\<rbrakk>\n       \\<Longrightarrow> ((Some (rev x2e, x1e), x1c, x2c |` (- {x1e})),\n                          Some (rev x2d, x1d), x1a, x2a |` (- {x1d}))\n                         \\<in> ?R'5 s0 s0a\n 7. \\<And>s0 s0a x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>finite U0; finite U0; (s0, s0a) \\<in> Id;\n        (x, x') \\<in> ?R'5 s0 s0a;\n        case x of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        case x' of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x2a \\<noteq> Map.empty; x2c \\<noteq> Map.empty; (xa, x'a) \\<in> Id;\n        xa \\<in> {(k, v). x2c k = Some v};\n        x'a \\<in> {(u, p). x2a u = Some p}; x'a = (x1d, x2d);\n        xa = (x1e, x2e); \\<not> P x1e; \\<not> P x1d; finite (E `` {x1d});\n        dom (x2a |` (- {x1d})) \\<subseteq> x1a\\<rbrakk>\n       \\<Longrightarrow> (x1e, x1d) \\<in> Id\n 8. \\<And>s0 s0a x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>finite U0; finite U0; (s0, s0a) \\<in> Id;\n        (x, x') \\<in> ?R'5 s0 s0a;\n        case x of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        case x' of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x2a \\<noteq> Map.empty; x2c \\<noteq> Map.empty; (xa, x'a) \\<in> Id;\n        xa \\<in> {(k, v). x2c k = Some v};\n        x'a \\<in> {(u, p). x2a u = Some p}; x'a = (x1d, x2d);\n        xa = (x1e, x2e); \\<not> P x1e; \\<not> P x1d; finite (E `` {x1d});\n        dom (x2a |` (- {x1d})) \\<subseteq> x1a\\<rbrakk>\n       \\<Longrightarrow> (x2e, x2d) \\<in> Id\n 9. \\<And>s0 s0a x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>finite U0; finite U0; (s0, s0a) \\<in> Id;\n        (x, x') \\<in> ?R'5 s0 s0a;\n        case x of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        case x' of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x2a \\<noteq> Map.empty; x2c \\<noteq> Map.empty; (xa, x'a) \\<in> Id;\n        xa \\<in> {(k, v). x2c k = Some v};\n        x'a \\<in> {(u, p). x2a u = Some p}; x'a = (x1d, x2d);\n        xa = (x1e, x2e); \\<not> P x1e; \\<not> P x1d; finite (E `` {x1d});\n        dom (x2a |` (- {x1d})) \\<subseteq> x1a\\<rbrakk>\n       \\<Longrightarrow> (x1c, x1a) \\<in> Id\n 10. \\<And>s0 s0a x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n        \\<lbrakk>finite U0; finite U0; (s0, s0a) \\<in> Id;\n         (x, x') \\<in> ?R'5 s0 s0a;\n         case x of\n         (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n         case x' of\n         (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n         x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n         x2a \\<noteq> Map.empty; x2c \\<noteq> Map.empty; (xa, x'a) \\<in> Id;\n         xa \\<in> {(k, v). x2c k = Some v};\n         x'a \\<in> {(u, p). x2a u = Some p}; x'a = (x1d, x2d);\n         xa = (x1e, x2e); \\<not> P x1e; \\<not> P x1d; finite (E `` {x1d});\n         dom (x2a |` (- {x1d})) \\<subseteq> x1a\\<rbrakk>\n        \\<Longrightarrow> (x2c |` (- {x1e}), x2a |` (- {x1d})) \\<in> Id\nA total of 12 subgoals...", "apply assumption"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>s0 s0a x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>finite U0; finite U0; (s0, s0a) \\<in> Id; (x, x') \\<in> Id;\n        x2 = (x1a, x2a); x = (x1, x2); x2b = (x1c, x2c);\n        x' = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (x1 = None \\<and> x2a \\<noteq> Map.empty) =\n                         (x1b = None \\<and> x2c \\<noteq> Map.empty)\n 2. \\<And>s0 s0a x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>finite U0; finite U0; (s0, s0a) \\<in> Id; (x, x') \\<in> Id;\n        case x of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        case x' of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x2a \\<noteq> Map.empty\\<rbrakk>\n       \\<Longrightarrow> x2c \\<noteq> Map.empty\n 3. \\<And>s0 s0a x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>finite U0; finite U0; (s0, s0a) \\<in> Id; (x, x') \\<in> Id;\n        case x of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        case x' of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x2a \\<noteq> Map.empty; x2c \\<noteq> Map.empty\\<rbrakk>\n       \\<Longrightarrow> SPEC (\\<lambda>(k, v). x2c k = Some v)\n                         \\<le> SPEC (\\<lambda>(u, p). x2a u = Some p)\n 4. \\<And>s0 s0a x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>finite U0; finite U0; (s0, s0a) \\<in> Id; (x, x') \\<in> Id;\n        case x of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        case x' of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x2a \\<noteq> Map.empty; x2c \\<noteq> Map.empty; (xa, x'a) \\<in> Id;\n        xa \\<in> {(k, v). x2c k = Some v};\n        x'a \\<in> {(u, p). x2a u = Some p}; x'a = (x1d, x2d);\n        xa = (x1e, x2e)\\<rbrakk>\n       \\<Longrightarrow> P x1e = P x1d\n 5. \\<And>s0 s0a x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>finite U0; finite U0; (s0, s0a) \\<in> Id; (x, x') \\<in> Id;\n        case x of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        case x' of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x2a \\<noteq> Map.empty; x2c \\<noteq> Map.empty; (xa, x'a) \\<in> Id;\n        xa \\<in> {(k, v). x2c k = Some v};\n        x'a \\<in> {(u, p). x2a u = Some p}; x'a = (x1d, x2d);\n        xa = (x1e, x2e); P x1e; P x1d\\<rbrakk>\n       \\<Longrightarrow> ((Some (rev x2e, x1e), x1c, x2c |` (- {x1e})),\n                          Some (rev x2d, x1d), x1a, x2a |` (- {x1d}))\n                         \\<in> Id\n 6. \\<And>s0 s0a x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>finite U0; finite U0; (s0, s0a) \\<in> Id; (x, x') \\<in> Id;\n        case x of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        case x' of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x2a \\<noteq> Map.empty; x2c \\<noteq> Map.empty; (xa, x'a) \\<in> Id;\n        xa \\<in> {(k, v). x2c k = Some v};\n        x'a \\<in> {(u, p). x2a u = Some p}; x'a = (x1d, x2d);\n        xa = (x1e, x2e); \\<not> P x1e; \\<not> P x1d; finite (E `` {x1d});\n        dom (x2a |` (- {x1d})) \\<subseteq> x1a\\<rbrakk>\n       \\<Longrightarrow> (x1e, x1d) \\<in> Id\n 7. \\<And>s0 s0a x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>finite U0; finite U0; (s0, s0a) \\<in> Id; (x, x') \\<in> Id;\n        case x of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        case x' of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x2a \\<noteq> Map.empty; x2c \\<noteq> Map.empty; (xa, x'a) \\<in> Id;\n        xa \\<in> {(k, v). x2c k = Some v};\n        x'a \\<in> {(u, p). x2a u = Some p}; x'a = (x1d, x2d);\n        xa = (x1e, x2e); \\<not> P x1e; \\<not> P x1d; finite (E `` {x1d});\n        dom (x2a |` (- {x1d})) \\<subseteq> x1a\\<rbrakk>\n       \\<Longrightarrow> (x2e, x2d) \\<in> Id\n 8. \\<And>s0 s0a x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>finite U0; finite U0; (s0, s0a) \\<in> Id; (x, x') \\<in> Id;\n        case x of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        case x' of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x2a \\<noteq> Map.empty; x2c \\<noteq> Map.empty; (xa, x'a) \\<in> Id;\n        xa \\<in> {(k, v). x2c k = Some v};\n        x'a \\<in> {(u, p). x2a u = Some p}; x'a = (x1d, x2d);\n        xa = (x1e, x2e); \\<not> P x1e; \\<not> P x1d; finite (E `` {x1d});\n        dom (x2a |` (- {x1d})) \\<subseteq> x1a\\<rbrakk>\n       \\<Longrightarrow> (x1c, x1a) \\<in> Id\n 9. \\<And>s0 s0a x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e.\n       \\<lbrakk>finite U0; finite U0; (s0, s0a) \\<in> Id; (x, x') \\<in> Id;\n        case x of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        case x' of\n        (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        x2a \\<noteq> Map.empty; x2c \\<noteq> Map.empty; (xa, x'a) \\<in> Id;\n        xa \\<in> {(k, v). x2c k = Some v};\n        x'a \\<in> {(u, p). x2a u = Some p}; x'a = (x1d, x2d);\n        xa = (x1e, x2e); \\<not> P x1e; \\<not> P x1d; finite (E `` {x1d});\n        dom (x2a |` (- {x1d})) \\<subseteq> x1a\\<rbrakk>\n       \\<Longrightarrow> (x2c |` (- {x1e}), x2a |` (- {x1d})) \\<in> Id\n 10. \\<And>s0 s0a x x' x1 x2 x1a x2a x1b x2b x1c x2c xa x'a x1d x2d x1e x2e\n        xb x'b x1f x2f x1g x2g.\n        \\<lbrakk>finite U0; finite U0; (s0, s0a) \\<in> Id; (x, x') \\<in> Id;\n         case x of\n         (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n         case x' of\n         (res, V, ws) \\<Rightarrow> res = None \\<and> ws \\<noteq> Map.empty;\n         x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n         x2a \\<noteq> Map.empty; x2c \\<noteq> Map.empty; (xa, x'a) \\<in> Id;\n         xa \\<in> {(k, v). x2c k = Some v};\n         x'a \\<in> {(u, p). x2a u = Some p}; x'a = (x1d, x2d);\n         xa = (x1e, x2e); \\<not> P x1e; \\<not> P x1d; finite (E `` {x1d});\n         dom (x2a |` (- {x1d})) \\<subseteq> x1a; (xb, x'b) \\<in> Id;\n         x'b = (x1f, x2f); xb = (x1g, x2g)\\<rbrakk>\n        \\<Longrightarrow> ((None, x1g, x2g), None, x1f, x2f) \\<in> Id\nA total of 11 subgoals...", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "section \\<open>Refinement to efficient data structures\\<close>"], ["", "schematic_goal wset_find_path'_refine_aux:\n    fixes U0::\"'a set\" and P::\"'a \\<Rightarrow> bool\" and E::\"('a\\<times>'a) set\"\n      and Pimpl :: \"'ai \\<Rightarrow> bool\"\n      and node_rel :: \"('ai \\<times> 'a) set\"\n      and node_eq_impl :: \"'ai \\<Rightarrow> 'ai \\<Rightarrow> bool\"\n      and node_hash_impl\n      and node_def_hash_size\n    \n    assumes [autoref_rules]: \n      \"(succi,E)\\<in>\\<langle>node_rel\\<rangle>slg_rel\"\n      \"(Pimpl,P)\\<in>node_rel \\<rightarrow> bool_rel\"\n      \"(node_eq_impl, (=)) \\<in> node_rel \\<rightarrow> node_rel \\<rightarrow> bool_rel\"\n      \"(U0',U0)\\<in>\\<langle>node_rel\\<rangle>list_set_rel\"\n    assumes [autoref_ga_rules]: \n      \"is_bounded_hashcode node_rel node_eq_impl node_hash_impl\"  \n      \"is_valid_def_hm_size TYPE('ai) node_def_hash_size\"\n    notes [autoref_tyrel] = \n      TYRELI[where \n        R=\"\\<langle>node_rel,\\<langle>node_rel\\<rangle>list_rel\\<rangle>list_map_rel\"]\n      TYRELI[where R=\"\\<langle>node_rel\\<rangle>map2set_rel (ahm_rel node_hash_impl)\"]\n\n    (*notes [autoref_rules] = \n      IdI[of P, unfolded fun_rel_id_simp[symmetric]]*)\n\n    shows \"(?c::?'c,wset_find_path' E U0 P) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, wset_find_path' E U0 P) \\<in> ?R", "unfolding wset_find_path'_def ws_update_foreach_def s_init_foreach_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     ASSERT (finite U0) \\<bind>\n     (\\<lambda>_.\n         FOREACH U0\n          (\\<lambda>x (U0, ws). RETURN (insert x U0, ws(x \\<mapsto> [])))\n          ({}, Map.empty) \\<bind>\n         (\\<lambda>(U0, ws). RETURN (None, U0, ws)) \\<bind>\n         (\\<lambda>s0.\n             WHILE\\<^sub>T\n              (\\<lambda>(res, V, ws).\n                  res = None \\<and> ws \\<noteq> Map.empty)\n              (\\<lambda>(res, V, ws).\n                  ASSERT (ws \\<noteq> Map.empty) \\<bind>\n                  (\\<lambda>_.\n                      op_map_pick_remove ws \\<bind>\n                      (\\<lambda>((u, p), ws).\n                          if P u then RETURN (Some (rev p, u), V, ws)\n                          else FOREACH (LIST_SET_REV_TAG (E `` {u}))\n                                (\\<lambda>v (V, ws).\n                                    if v \\<in> V then RETURN (V, ws)\n                                    else ASSERT (v \\<notin> dom ws) \\<bind>\n   (\\<lambda>_. RETURN (insert v V, ws(v \\<mapsto> u # p))))\n                                (V, ws) \\<bind>\n                               (\\<lambda>(V, ws). RETURN (None, V, ws)))))\n              s0 \\<bind>\n             (\\<lambda>(res, uu_, uu_). RETURN res))))\n    \\<in> ?R", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     ASSERT (finite U0) \\<bind>\n     (\\<lambda>_.\n         FOREACH U0\n          (\\<lambda>x (U0, ws). RETURN (insert x U0, ws(x \\<mapsto> [])))\n          ({}, Map.empty) \\<bind>\n         (\\<lambda>(U0, ws). RETURN (None, U0, ws)) \\<bind>\n         (\\<lambda>s0.\n             WHILE\\<^sub>T\n              (\\<lambda>(res, V, ws).\n                  res = None \\<and> ws \\<noteq> Map.empty)\n              (\\<lambda>(res, V, ws).\n                  ASSERT (ws \\<noteq> Map.empty) \\<bind>\n                  (\\<lambda>_.\n                      op_map_pick_remove ws \\<bind>\n                      (\\<lambda>((u, p), ws).\n                          if P u then RETURN (Some (rev p, u), V, ws)\n                          else FOREACH (LIST_SET_REV_TAG (E `` {u}))\n                                (\\<lambda>v (V, ws).\n                                    if v \\<in> V then RETURN (V, ws)\n                                    else ASSERT (v \\<notin> dom ws) \\<bind>\n   (\\<lambda>_. RETURN (insert v V, ws(v \\<mapsto> u # p))))\n                                (V, ws) \\<bind>\n                               (\\<lambda>(V, ws). RETURN (None, V, ws)))))\n              s0 \\<bind>\n             (\\<lambda>(res, uu_, uu_). RETURN res))))\n    \\<in> ?R", "using [[autoref_trace_intf_unif]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     ASSERT (finite U0) \\<bind>\n     (\\<lambda>_.\n         FOREACH U0\n          (\\<lambda>x (U0, ws). RETURN (insert x U0, ws(x \\<mapsto> [])))\n          ({}, Map.empty) \\<bind>\n         (\\<lambda>(U0, ws). RETURN (None, U0, ws)) \\<bind>\n         (\\<lambda>s0.\n             WHILE\\<^sub>T\n              (\\<lambda>(res, V, ws).\n                  res = None \\<and> ws \\<noteq> Map.empty)\n              (\\<lambda>(res, V, ws).\n                  ASSERT (ws \\<noteq> Map.empty) \\<bind>\n                  (\\<lambda>_.\n                      op_map_pick_remove ws \\<bind>\n                      (\\<lambda>((u, p), ws).\n                          if P u then RETURN (Some (rev p, u), V, ws)\n                          else FOREACH (LIST_SET_REV_TAG (E `` {u}))\n                                (\\<lambda>v (V, ws).\n                                    if v \\<in> V then RETURN (V, ws)\n                                    else ASSERT (v \\<notin> dom ws) \\<bind>\n   (\\<lambda>_. RETURN (insert v V, ws(v \\<mapsto> u # p))))\n                                (V, ws) \\<bind>\n                               (\\<lambda>(V, ws). RETURN (None, V, ws)))))\n              s0 \\<bind>\n             (\\<lambda>(res, uu_, uu_). RETURN res))))\n    \\<in> ?R", "using [[autoref_trace_pat]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     ASSERT (finite U0) \\<bind>\n     (\\<lambda>_.\n         FOREACH U0\n          (\\<lambda>x (U0, ws). RETURN (insert x U0, ws(x \\<mapsto> [])))\n          ({}, Map.empty) \\<bind>\n         (\\<lambda>(U0, ws). RETURN (None, U0, ws)) \\<bind>\n         (\\<lambda>s0.\n             WHILE\\<^sub>T\n              (\\<lambda>(res, V, ws).\n                  res = None \\<and> ws \\<noteq> Map.empty)\n              (\\<lambda>(res, V, ws).\n                  ASSERT (ws \\<noteq> Map.empty) \\<bind>\n                  (\\<lambda>_.\n                      op_map_pick_remove ws \\<bind>\n                      (\\<lambda>((u, p), ws).\n                          if P u then RETURN (Some (rev p, u), V, ws)\n                          else FOREACH (LIST_SET_REV_TAG (E `` {u}))\n                                (\\<lambda>v (V, ws).\n                                    if v \\<in> V then RETURN (V, ws)\n                                    else ASSERT (v \\<notin> dom ws) \\<bind>\n   (\\<lambda>_. RETURN (insert v V, ws(v \\<mapsto> u # p))))\n                                (V, ws) \\<bind>\n                               (\\<lambda>(V, ws). RETURN (None, V, ws)))))\n              s0 \\<bind>\n             (\\<lambda>(res, uu_, uu_). RETURN res))))\n    \\<in> ?R", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition wset_find_path_impl for node_eq_impl succi U0' Pimpl \n    uses wset_find_path'_refine_aux"], ["", "section \\<open>Autoref Setup\\<close>"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma [autoref_itype]: \n      \"find_path ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_slg \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i (I\\<rightarrow>\\<^sub>ii_bool) \n        \\<rightarrow>\\<^sub>i \\<langle>\\<langle>\\<langle>\\<langle>I\\<rangle>\\<^sub>ii_list, I\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_option\\<rangle>\\<^sub>ii_nres\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_path ::\\<^sub>i\n    \\<langle>I\\<rangle>\\<^sub>ii_slg \\<rightarrow>\\<^sub>i\n    \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n    (I \\<rightarrow>\\<^sub>i i_bool) \\<rightarrow>\\<^sub>i\n    \\<langle>\\<langle>\\<langle>\\<langle>I\\<rangle>\\<^sub>ii_list,\n    I\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_option\\<rangle>\\<^sub>ii_nres", "by simp"], ["", "lemma wset_find_path_autoref[autoref_rules]:\n      fixes node_rel :: \"('ai \\<times> 'a) set\"\n      assumes eq: \"GEN_OP node_eq_impl (=) (node_rel\\<rightarrow>node_rel\\<rightarrow>bool_rel)\"\n      assumes hash: \"SIDE_GEN_ALGO (is_bounded_hashcode node_rel node_eq_impl node_hash_impl)\"\n      assumes hash_dsz: \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('ai) node_def_hash_size)\"\n      shows \"(\n        wset_find_path_impl node_hash_impl node_def_hash_size node_eq_impl, \n        find_path)\n        \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow> \\<langle>node_rel\\<rangle>list_set_rel \\<rightarrow> (node_rel\\<rightarrow>bool_rel) \n          \\<rightarrow> \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel\\<times>\\<^sub>rnode_rel\\<rangle>option_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (wset_find_path_impl node_hash_impl node_def_hash_size node_eq_impl,\n     find_path)\n    \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow>\n          \\<langle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          (node_rel \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                            node_rel\\<rangle>option_rel\\<rangle>nres_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (wset_find_path_impl node_hash_impl node_def_hash_size node_eq_impl,\n     find_path)\n    \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow>\n          \\<langle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          (node_rel \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                            node_rel\\<rangle>option_rel\\<rangle>nres_rel", "note EQI = GEN_OP_D[OF eq]"], ["proof (state)\nthis:\n  (node_eq_impl, (=))\n  \\<in> node_rel \\<rightarrow> node_rel \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. (wset_find_path_impl node_hash_impl node_def_hash_size node_eq_impl,\n     find_path)\n    \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow>\n          \\<langle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          (node_rel \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                            node_rel\\<rangle>option_rel\\<rangle>nres_rel", "note HASHI = SIDE_GEN_ALGO_D[OF hash]"], ["proof (state)\nthis:\n  is_bounded_hashcode node_rel node_eq_impl node_hash_impl\n\ngoal (1 subgoal):\n 1. (wset_find_path_impl node_hash_impl node_def_hash_size node_eq_impl,\n     find_path)\n    \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow>\n          \\<langle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          (node_rel \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                            node_rel\\<rangle>option_rel\\<rangle>nres_rel", "note DSZI = SIDE_GEN_ALGO_D[OF hash_dsz]"], ["proof (state)\nthis:\n  is_valid_def_hm_size TYPE('ai) node_def_hash_size\n\ngoal (1 subgoal):\n 1. (wset_find_path_impl node_hash_impl node_def_hash_size node_eq_impl,\n     find_path)\n    \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow>\n          \\<langle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          (node_rel \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                            node_rel\\<rangle>option_rel\\<rangle>nres_rel", "note wset_find_path_impl.refine[THEN nres_relD, OF _ _ EQI _ HASHI DSZI]"], ["proof (state)\nthis:\n  \\<lbrakk>(?succi1, ?E1) \\<in> \\<langle>node_rel\\<rangle>slg_rel;\n   (?Pimpl1, ?P1) \\<in> node_rel \\<rightarrow> bool_rel;\n   (?U0'1, ?U0.1) \\<in> \\<langle>node_rel\\<rangle>list_set_rel\\<rbrakk>\n  \\<Longrightarrow> wset_find_path_impl node_hash_impl node_def_hash_size\n                     node_eq_impl ?succi1 ?U0'1 ?Pimpl1\n                    \\<le> \\<Down>\n                           (\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                                     node_rel\\<rangle>option_rel)\n                           (wset_find_path' ?E1 ?U0.1 ?P1)\n\ngoal (1 subgoal):\n 1. (wset_find_path_impl node_hash_impl node_def_hash_size node_eq_impl,\n     find_path)\n    \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow>\n          \\<langle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          (node_rel \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                            node_rel\\<rangle>option_rel\\<rangle>nres_rel", "also"], ["proof (state)\nthis:\n  \\<lbrakk>(?succi1, ?E1) \\<in> \\<langle>node_rel\\<rangle>slg_rel;\n   (?Pimpl1, ?P1) \\<in> node_rel \\<rightarrow> bool_rel;\n   (?U0'1, ?U0.1) \\<in> \\<langle>node_rel\\<rangle>list_set_rel\\<rbrakk>\n  \\<Longrightarrow> wset_find_path_impl node_hash_impl node_def_hash_size\n                     node_eq_impl ?succi1 ?U0'1 ?Pimpl1\n                    \\<le> \\<Down>\n                           (\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                                     node_rel\\<rangle>option_rel)\n                           (wset_find_path' ?E1 ?U0.1 ?P1)\n\ngoal (1 subgoal):\n 1. (wset_find_path_impl node_hash_impl node_def_hash_size node_eq_impl,\n     find_path)\n    \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow>\n          \\<langle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          (node_rel \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                            node_rel\\<rangle>option_rel\\<rangle>nres_rel", "note wset_find_path'_refine"], ["proof (state)\nthis:\n  wset_find_path' ?E ?U0.0 ?P \\<le> \\<Down> Id (wset_find_path ?E ?U0.0 ?P)\n\ngoal (1 subgoal):\n 1. (wset_find_path_impl node_hash_impl node_def_hash_size node_eq_impl,\n     find_path)\n    \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow>\n          \\<langle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          (node_rel \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                            node_rel\\<rangle>option_rel\\<rangle>nres_rel", "also"], ["proof (state)\nthis:\n  wset_find_path' ?E ?U0.0 ?P \\<le> \\<Down> Id (wset_find_path ?E ?U0.0 ?P)\n\ngoal (1 subgoal):\n 1. (wset_find_path_impl node_hash_impl node_def_hash_size node_eq_impl,\n     find_path)\n    \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow>\n          \\<langle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          (node_rel \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                            node_rel\\<rangle>option_rel\\<rangle>nres_rel", "note wset_find_path_correct"], ["proof (state)\nthis:\n  wset_find_path ?E ?U0.0 ?P \\<le> find_path ?E ?U0.0 ?P\n\ngoal (1 subgoal):\n 1. (wset_find_path_impl node_hash_impl node_def_hash_size node_eq_impl,\n     find_path)\n    \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow>\n          \\<langle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          (node_rel \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                            node_rel\\<rangle>option_rel\\<rangle>nres_rel", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?succi5, ?E1) \\<in> \\<langle>node_rel\\<rangle>slg_rel;\n   (?Pimpl5, ?P1) \\<in> node_rel \\<rightarrow> bool_rel;\n   (?U0'5, ?U0.1) \\<in> \\<langle>node_rel\\<rangle>list_set_rel\\<rbrakk>\n  \\<Longrightarrow> wset_find_path_impl node_hash_impl node_def_hash_size\n                     node_eq_impl ?succi5 ?U0'5 ?Pimpl5\n                    \\<le> \\<Down>\n                           (\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                                     node_rel\\<rangle>option_rel)\n                           (find_path ?E1 ?U0.1 ?P1)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?succi5, ?E1) \\<in> \\<langle>node_rel\\<rangle>slg_rel;\n   (?Pimpl5, ?P1) \\<in> node_rel \\<rightarrow> bool_rel;\n   (?U0'5, ?U0.1) \\<in> \\<langle>node_rel\\<rangle>list_set_rel\\<rbrakk>\n  \\<Longrightarrow> wset_find_path_impl node_hash_impl node_def_hash_size\n                     node_eq_impl ?succi5 ?U0'5 ?Pimpl5\n                    \\<le> \\<Down>\n                           (\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                                     node_rel\\<rangle>option_rel)\n                           (find_path ?E1 ?U0.1 ?P1)\n\ngoal (1 subgoal):\n 1. (wset_find_path_impl node_hash_impl node_def_hash_size node_eq_impl,\n     find_path)\n    \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow>\n          \\<langle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n          (node_rel \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                            node_rel\\<rangle>option_rel\\<rangle>nres_rel", "by (fastforce intro!: nres_relI)"], ["proof (state)\nthis:\n  (wset_find_path_impl node_hash_impl node_def_hash_size node_eq_impl,\n   find_path)\n  \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow>\n        \\<langle>node_rel\\<rangle>list_set_rel \\<rightarrow>\n        (node_rel \\<rightarrow> bool_rel) \\<rightarrow>\n        \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                          node_rel\\<rangle>option_rel\\<rangle>nres_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "schematic_goal wset_find_path_transfer_aux: \n    \"RETURN ?c \\<le> wset_find_path_impl hashi dszi eqi E U0 P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c \\<le> wset_find_path_impl hashi dszi eqi E U0 P", "unfolding wset_find_path_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> LIST_FOREACH' (RETURN (id U0)) (\\<lambda>x. True)\n           (\\<lambda>x (xa, xb).\n               RETURN\n                (map2set_insert (Impl_Array_Hash_Map.ahm_update eqi hashi) x\n                  xa,\n                 list_map_update eqi x [] xb))\n           (Impl_Array_Hash_Map.ahm_empty dszi, []) \\<bind>\n          (\\<lambda>(x, xa). RETURN (None, x, xa)) \\<bind>\n          (\\<lambda>x.\n              WHILE\\<^sub>T\n               (\\<lambda>(xb, xc, xd).\n                   is_None xb \\<and> \\<not> list_map_isEmpty xd)\n               (\\<lambda>(xb, xc, xd).\n                   RETURN (list_map_pick_remove xd) \\<bind>\n                   (\\<lambda>((xe, xf), xg).\n                       if P xe then RETURN (Some (rev xf, xe), xc, xg)\n                       else LIST_FOREACH' (RETURN (id (rev (E xe))))\n                             (\\<lambda>xh. True)\n                             (\\<lambda>xh (xi, xj).\n                                 if map2set_memb\n                                     (Impl_Array_Hash_Map.ahm_lookup eqi\n hashi)\n                                     xh xi\n                                 then RETURN (xi, xj)\n                                 else RETURN\n (map2set_insert (Impl_Array_Hash_Map.ahm_update eqi hashi) xh xi,\n  (xh, xe # xf) # xj))\n                             (xc, xg) \\<bind>\n                            (\\<lambda>(xh, xi). RETURN (None, xh, xi))))\n               x \\<bind>\n              (\\<lambda>(xa, xb, xc). RETURN xa))", "by (refine_transfer (post))"], ["", "concrete_definition wset_find_path_code \n    for E ?U0.0 P uses wset_find_path_transfer_aux"], ["", "lemmas [refine_transfer] = wset_find_path_code.refine"], ["", "export_code wset_find_path_code checking SML"], ["", "section \\<open>Nontrivial paths\\<close>"], ["", "definition \"find_path1_gen E u0 P \\<equiv> do {\n  res \\<leftarrow> find_path E (E``{u0}) P;\n  case res of None \\<Rightarrow> RETURN None\n    | Some (p,v) \\<Rightarrow> RETURN (Some (u0#p,v))\n  }\""], ["", "lemma find_path1_gen_correct: \"find_path1_gen E u0 P \\<le> find_path1 E u0 P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_path1_gen E u0 P \\<le> find_path1 E u0 P", "unfolding find_path1_gen_def find_path_def find_path1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (finite (E `` {u0})) \\<bind>\n    (\\<lambda>_.\n        ASSERT (finite (E\\<^sup>* `` E `` {u0})) \\<bind>\n        (\\<lambda>_.\n            SPEC\n             (\\<lambda>p.\n                 case p of\n                 None \\<Rightarrow>\n                   \\<forall>u0\\<in>E `` {u0}.\n                      \\<forall>v\\<in>E\\<^sup>* `` {u0}. \\<not> P v\n                 | Some (p, v) \\<Rightarrow>\n                     \\<exists>u0\\<in>E `` {u0}.\n                        path E u0 p v \\<and>\n                        P v \\<and>\n                        (\\<forall>v\\<in>set p. \\<not> P v)))) \\<bind>\n    (\\<lambda>res.\n        case res of None \\<Rightarrow> RETURN None\n        | Some (p, v) \\<Rightarrow> RETURN (Some (u0 # p, v)))\n    \\<le> ASSERT (finite (E\\<^sup>* `` {u0})) \\<bind>\n          (\\<lambda>_.\n              SPEC\n               (\\<lambda>p.\n                   case p of\n                   None \\<Rightarrow>\n                     \\<forall>v\\<in>E\\<^sup>+ `` {u0}. \\<not> P v\n                   | Some (p, v) \\<Rightarrow>\n                       path E u0 p v \\<and> P v \\<and> p \\<noteq> []))", "apply (refine_rcg refine_vcg le_ASSERTI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. finite (E\\<^sup>* `` {u0}) \\<Longrightarrow> finite (E `` {u0})\n 2. \\<lbrakk>finite (E\\<^sup>* `` {u0}); finite (E `` {u0})\\<rbrakk>\n    \\<Longrightarrow> finite (E\\<^sup>* `` E `` {u0})\n 3. \\<And>x.\n       \\<lbrakk>finite (E\\<^sup>* `` {u0}); finite (E `` {u0});\n        finite (E\\<^sup>* `` E `` {u0});\n        case x of\n        None \\<Rightarrow>\n          \\<forall>u0\\<in>E `` {u0}.\n             \\<forall>v\\<in>E\\<^sup>* `` {u0}. \\<not> P v\n        | Some (p, v) \\<Rightarrow>\n            \\<exists>u0\\<in>E `` {u0}.\n               path E u0 p v \\<and>\n               P v \\<and> (\\<forall>v\\<in>set p. \\<not> P v);\n        x = None\\<rbrakk>\n       \\<Longrightarrow> case None of\n                         None \\<Rightarrow>\n                           \\<forall>v\\<in>E\\<^sup>+ `` {u0}. \\<not> P v\n                         | Some (p, v) \\<Rightarrow>\n                             path E u0 p v \\<and> P v \\<and> p \\<noteq> []\n 4. \\<And>x xa a b.\n       \\<lbrakk>finite (E\\<^sup>* `` {u0}); finite (E `` {u0});\n        finite (E\\<^sup>* `` E `` {u0});\n        case x of\n        None \\<Rightarrow>\n          \\<forall>u0\\<in>E `` {u0}.\n             \\<forall>v\\<in>E\\<^sup>* `` {u0}. \\<not> P v\n        | Some (p, v) \\<Rightarrow>\n            \\<exists>u0\\<in>E `` {u0}.\n               path E u0 p v \\<and>\n               P v \\<and> (\\<forall>v\\<in>set p. \\<not> P v);\n        x = Some xa; xa = (a, b)\\<rbrakk>\n       \\<Longrightarrow> case Some (u0 # a, b) of\n                         None \\<Rightarrow>\n                           \\<forall>v\\<in>E\\<^sup>+ `` {u0}. \\<not> P v\n                         | Some (p, v) \\<Rightarrow>\n                             path E u0 p v \\<and> P v \\<and> p \\<noteq> []", "apply (auto \n    intro: path_prepend \n    dest: tranclD\n    elim: finite_subset[rotated]\n  )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal find_path1_impl_aux:\n  fixes node_rel :: \"('ai \\<times> 'a) set\"\n  assumes [autoref_rules]: \"(node_eq_impl, (=)) \\<in> node_rel \\<rightarrow> node_rel \\<rightarrow> bool_rel\"\n  assumes [autoref_ga_rules]: \n    \"is_bounded_hashcode node_rel node_eq_impl node_hash_impl\"  \n    \"is_valid_def_hm_size TYPE('ai) node_def_hash_size\"\n\n  shows \"(?c,find_path1_gen::(_\\<times>_) set \\<Rightarrow> _) \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow> node_rel \\<rightarrow> (node_rel \\<rightarrow> bool_rel) \\<rightarrow> \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r node_rel\\<rangle>option_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, find_path1_gen)\n    \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow>\n          node_rel \\<rightarrow>\n          (node_rel \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                            node_rel\\<rangle>option_rel\\<rangle>nres_rel", "unfolding find_path1_gen_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>E u0 P.\n        find_path E (E `` {u0}) P \\<bind>\n        (\\<lambda>res.\n            case res of None \\<Rightarrow> RETURN None\n            | Some (p, v) \\<Rightarrow> RETURN (Some (u0 # p, v))))\n    \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow>\n          node_rel \\<rightarrow>\n          (node_rel \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                            node_rel\\<rangle>option_rel\\<rangle>nres_rel", "apply (autoref (trace,keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [autoref_itype]: \n  \"find_path1 ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_slg \\<rightarrow>\\<^sub>i I \\<rightarrow>\\<^sub>i (I\\<rightarrow>\\<^sub>ii_bool) \n    \\<rightarrow>\\<^sub>i \\<langle>\\<langle>\\<langle>\\<langle>I\\<rangle>\\<^sub>ii_list, I\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_option\\<rangle>\\<^sub>ii_nres\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_path1 ::\\<^sub>i\n    \\<langle>I\\<rangle>\\<^sub>ii_slg \\<rightarrow>\\<^sub>i\n    I \\<rightarrow>\\<^sub>i\n    (I \\<rightarrow>\\<^sub>i i_bool) \\<rightarrow>\\<^sub>i\n    \\<langle>\\<langle>\\<langle>\\<langle>I\\<rangle>\\<^sub>ii_list,\n    I\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_option\\<rangle>\\<^sub>ii_nres", "by simp"], ["", "concrete_definition find_path1_impl uses find_path1_impl_aux"], ["", "lemma find_path1_autoref[autoref_rules]: \n  fixes node_rel :: \"('ai \\<times> 'a) set\"\n  assumes eq: \"GEN_OP node_eq_impl (=) (node_rel\\<rightarrow>node_rel\\<rightarrow>bool_rel)\"\n  assumes hash: \"SIDE_GEN_ALGO (is_bounded_hashcode node_rel node_eq_impl node_hash_impl)\"\n  assumes hash_dsz: \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('ai) node_def_hash_size)\"\n  \n  shows \"(find_path1_impl node_eq_impl node_hash_impl node_def_hash_size,find_path1) \n    \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow>node_rel \\<rightarrow> (node_rel \\<rightarrow> bool_rel) \\<rightarrow> \n      \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r node_rel\\<rangle>Relators.option_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (find_path1_impl node_eq_impl node_hash_impl node_def_hash_size,\n     find_path1)\n    \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow>\n          node_rel \\<rightarrow>\n          (node_rel \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                            node_rel\\<rangle>option_rel\\<rangle>nres_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (find_path1_impl node_eq_impl node_hash_impl node_def_hash_size,\n     find_path1)\n    \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow>\n          node_rel \\<rightarrow>\n          (node_rel \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                            node_rel\\<rangle>option_rel\\<rangle>nres_rel", "note EQI = GEN_OP_D[OF eq]"], ["proof (state)\nthis:\n  (node_eq_impl, (=))\n  \\<in> node_rel \\<rightarrow> node_rel \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. (find_path1_impl node_eq_impl node_hash_impl node_def_hash_size,\n     find_path1)\n    \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow>\n          node_rel \\<rightarrow>\n          (node_rel \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                            node_rel\\<rangle>option_rel\\<rangle>nres_rel", "note HASHI = SIDE_GEN_ALGO_D[OF hash]"], ["proof (state)\nthis:\n  is_bounded_hashcode node_rel node_eq_impl node_hash_impl\n\ngoal (1 subgoal):\n 1. (find_path1_impl node_eq_impl node_hash_impl node_def_hash_size,\n     find_path1)\n    \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow>\n          node_rel \\<rightarrow>\n          (node_rel \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                            node_rel\\<rangle>option_rel\\<rangle>nres_rel", "note DSZI = SIDE_GEN_ALGO_D[OF hash_dsz]"], ["proof (state)\nthis:\n  is_valid_def_hm_size TYPE('ai) node_def_hash_size\n\ngoal (1 subgoal):\n 1. (find_path1_impl node_eq_impl node_hash_impl node_def_hash_size,\n     find_path1)\n    \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow>\n          node_rel \\<rightarrow>\n          (node_rel \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                            node_rel\\<rangle>option_rel\\<rangle>nres_rel", "note R = find_path1_impl.refine[param_fo, THEN nres_relD, OF EQI HASHI DSZI]"], ["proof (state)\nthis:\n  \\<lbrakk>(?x3, ?x'3) \\<in> \\<langle>node_rel\\<rangle>slg_rel;\n   (?x2, ?x'2) \\<in> node_rel;\n   (?x1, ?x'1) \\<in> node_rel \\<rightarrow> bool_rel\\<rbrakk>\n  \\<Longrightarrow> find_path1_impl node_eq_impl node_hash_impl\n                     node_def_hash_size ?x3 ?x2 ?x1\n                    \\<le> \\<Down>\n                           (\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                                     node_rel\\<rangle>option_rel)\n                           (find_path1_gen ?x'3 ?x'2 ?x'1)\n\ngoal (1 subgoal):\n 1. (find_path1_impl node_eq_impl node_hash_impl node_def_hash_size,\n     find_path1)\n    \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow>\n          node_rel \\<rightarrow>\n          (node_rel \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                            node_rel\\<rangle>option_rel\\<rangle>nres_rel", "note R"], ["proof (state)\nthis:\n  \\<lbrakk>(?x3, ?x'3) \\<in> \\<langle>node_rel\\<rangle>slg_rel;\n   (?x2, ?x'2) \\<in> node_rel;\n   (?x1, ?x'1) \\<in> node_rel \\<rightarrow> bool_rel\\<rbrakk>\n  \\<Longrightarrow> find_path1_impl node_eq_impl node_hash_impl\n                     node_def_hash_size ?x3 ?x2 ?x1\n                    \\<le> \\<Down>\n                           (\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                                     node_rel\\<rangle>option_rel)\n                           (find_path1_gen ?x'3 ?x'2 ?x'1)\n\ngoal (1 subgoal):\n 1. (find_path1_impl node_eq_impl node_hash_impl node_def_hash_size,\n     find_path1)\n    \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow>\n          node_rel \\<rightarrow>\n          (node_rel \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                            node_rel\\<rangle>option_rel\\<rangle>nres_rel", "also"], ["proof (state)\nthis:\n  \\<lbrakk>(?x3, ?x'3) \\<in> \\<langle>node_rel\\<rangle>slg_rel;\n   (?x2, ?x'2) \\<in> node_rel;\n   (?x1, ?x'1) \\<in> node_rel \\<rightarrow> bool_rel\\<rbrakk>\n  \\<Longrightarrow> find_path1_impl node_eq_impl node_hash_impl\n                     node_def_hash_size ?x3 ?x2 ?x1\n                    \\<le> \\<Down>\n                           (\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                                     node_rel\\<rangle>option_rel)\n                           (find_path1_gen ?x'3 ?x'2 ?x'1)\n\ngoal (1 subgoal):\n 1. (find_path1_impl node_eq_impl node_hash_impl node_def_hash_size,\n     find_path1)\n    \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow>\n          node_rel \\<rightarrow>\n          (node_rel \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                            node_rel\\<rangle>option_rel\\<rangle>nres_rel", "note find_path1_gen_correct"], ["proof (state)\nthis:\n  find_path1_gen ?E ?u0.0 ?P \\<le> find_path1 ?E ?u0.0 ?P\n\ngoal (1 subgoal):\n 1. (find_path1_impl node_eq_impl node_hash_impl node_def_hash_size,\n     find_path1)\n    \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow>\n          node_rel \\<rightarrow>\n          (node_rel \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                            node_rel\\<rangle>option_rel\\<rangle>nres_rel", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?x5, ?E1) \\<in> \\<langle>node_rel\\<rangle>slg_rel;\n   (?x4, ?u0.1) \\<in> node_rel;\n   (?x3, ?P1) \\<in> node_rel \\<rightarrow> bool_rel\\<rbrakk>\n  \\<Longrightarrow> find_path1_impl node_eq_impl node_hash_impl\n                     node_def_hash_size ?x5 ?x4 ?x3\n                    \\<le> \\<Down>\n                           (\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                                     node_rel\\<rangle>option_rel)\n                           (find_path1 ?E1 ?u0.1 ?P1)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x5, ?E1) \\<in> \\<langle>node_rel\\<rangle>slg_rel;\n   (?x4, ?u0.1) \\<in> node_rel;\n   (?x3, ?P1) \\<in> node_rel \\<rightarrow> bool_rel\\<rbrakk>\n  \\<Longrightarrow> find_path1_impl node_eq_impl node_hash_impl\n                     node_def_hash_size ?x5 ?x4 ?x3\n                    \\<le> \\<Down>\n                           (\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                                     node_rel\\<rangle>option_rel)\n                           (find_path1 ?E1 ?u0.1 ?P1)\n\ngoal (1 subgoal):\n 1. (find_path1_impl node_eq_impl node_hash_impl node_def_hash_size,\n     find_path1)\n    \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow>\n          node_rel \\<rightarrow>\n          (node_rel \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                            node_rel\\<rangle>option_rel\\<rangle>nres_rel", "by (blast intro: nres_relI)"], ["proof (state)\nthis:\n  (find_path1_impl node_eq_impl node_hash_impl node_def_hash_size,\n   find_path1)\n  \\<in> \\<langle>node_rel\\<rangle>slg_rel \\<rightarrow>\n        node_rel \\<rightarrow>\n        (node_rel \\<rightarrow> bool_rel) \\<rightarrow>\n        \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                          node_rel\\<rangle>option_rel\\<rangle>nres_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "schematic_goal find_path1_transfer_aux: \n  \"RETURN ?c \\<le> find_path1_impl eqi hashi dszi E u P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c \\<le> find_path1_impl eqi hashi dszi E u P", "unfolding find_path1_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> wset_find_path_impl hashi dszi eqi E (E u) P \\<bind>\n          case_option (RETURN None)\n           (\\<lambda>(xc, xd). RETURN (Some (u # xc, xd)))", "by refine_transfer"], ["", "concrete_definition find_path1_code for E u P uses find_path1_transfer_aux"], ["", "lemmas [refine_transfer] = find_path1_code.refine"], ["", "end"]]}