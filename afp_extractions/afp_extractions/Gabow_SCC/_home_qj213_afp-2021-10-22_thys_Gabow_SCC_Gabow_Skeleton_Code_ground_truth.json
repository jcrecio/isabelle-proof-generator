{"file_name": "/home/qj213/afp-2021-10-22/thys/Gabow_SCC/Gabow_Skeleton_Code.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Gabow_SCC", "problem_names": ["lemma node_state_rel_simps[simp]:\n  \"(i,DONE)\\<in>node_state_rel \\<longleftrightarrow> i=-1\"\n  \"(i,STACK n)\\<in>node_state_rel \\<longleftrightarrow> i = int n\"", "lemma node_state_rel_sv[simp,intro!,relator_props]:\n  \"single_valued node_state_rel\"", "lemmas [autoref_rel_intf] = REL_INTFI[of node_state_rel i_node_state]", "lemma node_state_rel_refine[autoref_rules]:\n  \"(-1,DONE)\\<in>node_state_rel\"\n  \"(int,STACK)\\<in>nat_rel\\<rightarrow>node_state_rel\"\n  \"(\\<lambda>i. i<0,is_DONE)\\<in>node_state_rel\\<rightarrow>bool_rel\"\n  \"((\\<lambda>f g i. if i\\<ge>0 then f (nat i) else g),case_node_state)\n    \\<in>(nat_rel \\<rightarrow> R) \\<rightarrow> R \\<rightarrow> node_state_rel \\<rightarrow> R\"", "lemma [autoref_op_pat]: \n  \"(x=DONE) \\<equiv> is_DONE x\"\n  \"(DONE=x) \\<equiv> is_DONE x\"", "lemmas [autoref_rel_intf] = REL_INTFI[of node_rel i_node]", "lemmas [autoref_rules] = G_refine node_eq_refine", "lemmas [autoref_ga_rules] = node_hash node_hash_def_size", "lemma locale_this: \"fr_graph_impl_loc mrel node_rel node_eq_impl node_hash_impl node_def_hash_size G_impl G\"", "lemmas [autoref_op_pat] = GS.S_def GS.B_def GS.I_def GS.P_def", "lemmas [autoref_rules] = push_code.refine[OF locale_this]", "lemmas [autoref_rules] = pop_code.refine[OF locale_this]", "lemmas [autoref_rules] = S_idx_of_code.refine[OF locale_this]", "lemmas [autoref_rules] = idx_of_code.refine[OF locale_this]", "lemmas [autoref_rules] = collapse_code.refine[OF locale_this]", "lemmas [autoref_rules] = select_edge_code.refine[OF locale_this]", "lemma [autoref_op_pat]: \n      \"push_impl \\<equiv> OP push_impl\"\n      \"collapse_impl \\<equiv> OP collapse_impl\"\n      \"select_edge_impl \\<equiv> OP select_edge_impl\"\n      \"pop_impl \\<equiv> OP pop_impl\"", "lemmas [autoref_rules] = skeleton_code.refine[OF locale_this]", "lemmas [refine_transfer] = pop_tr.refine[OF locale_this]", "lemmas [refine_transfer] = select_edge_tr.refine[OF locale_this]", "lemmas [refine_transfer] = idx_of_tr.refine[OF locale_this]", "lemmas [refine_transfer] = collapse_tr.refine[OF locale_this]", "lemmas [refine_transfer] = skeleton_tr.refine[OF locale_this]"], "translations": [["", "lemma node_state_rel_simps[simp]:\n  \"(i,DONE)\\<in>node_state_rel \\<longleftrightarrow> i=-1\"\n  \"(i,STACK n)\\<in>node_state_rel \\<longleftrightarrow> i = int n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((i, DONE) \\<in> node_state_rel) = (i = - 1) &&&\n    ((i, STACK n) \\<in> node_state_rel) = (i = int n)", "unfolding node_state_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((i, DONE) \\<in> {(- 1, DONE)} \\<union> {(int k, STACK k) |k. True}) =\n    (i = - 1) &&&\n    ((i, STACK n)\n     \\<in> {(- 1, DONE)} \\<union> {(int k, STACK k) |k. True}) =\n    (i = int n)", "by auto"], ["", "lemma node_state_rel_sv[simp,intro!,relator_props]:\n  \"single_valued node_state_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued node_state_rel", "unfolding node_state_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued ({(- 1, DONE)} \\<union> {(int k, STACK k) |k. True})", "by (auto intro: single_valuedI)"], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of node_state_rel i_node_state]"], ["", "primrec is_DONE where\n  \"is_DONE DONE = True\"\n| \"is_DONE (STACK _) = False\""], ["", "lemma node_state_rel_refine[autoref_rules]:\n  \"(-1,DONE)\\<in>node_state_rel\"\n  \"(int,STACK)\\<in>nat_rel\\<rightarrow>node_state_rel\"\n  \"(\\<lambda>i. i<0,is_DONE)\\<in>node_state_rel\\<rightarrow>bool_rel\"\n  \"((\\<lambda>f g i. if i\\<ge>0 then f (nat i) else g),case_node_state)\n    \\<in>(nat_rel \\<rightarrow> R) \\<rightarrow> R \\<rightarrow> node_state_rel \\<rightarrow> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((- 1, DONE) \\<in> node_state_rel &&&\n     (int, STACK) \\<in> nat_rel \\<rightarrow> node_state_rel) &&&\n    (\\<lambda>i. i < 0, is_DONE)\n    \\<in> node_state_rel \\<rightarrow> bool_rel &&&\n    (\\<lambda>f g i. if 0 \\<le> i then f (nat i) else g, case_node_state)\n    \\<in> (nat_rel \\<rightarrow> R) \\<rightarrow>\n          R \\<rightarrow> node_state_rel \\<rightarrow> R", "unfolding node_state_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((- 1, DONE)\n     \\<in> {(- 1, DONE)} \\<union> {(int k, STACK k) |k. True} &&&\n     (int, STACK)\n     \\<in> nat_rel \\<rightarrow>\n           {(- 1, DONE)} \\<union> {(int k, STACK k) |k. True}) &&&\n    (\\<lambda>i. i < 0, is_DONE)\n    \\<in> {(- 1, DONE)} \\<union> {(int k, STACK k) |k. True} \\<rightarrow>\n          bool_rel &&&\n    (\\<lambda>f g i. if 0 \\<le> i then f (nat i) else g, case_node_state)\n    \\<in> (nat_rel \\<rightarrow> R) \\<rightarrow>\n          R \\<rightarrow>\n          {(- 1, DONE)} \\<union> {(int k, STACK k) |k. True} \\<rightarrow> R", "apply auto [3]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f g i. if 0 \\<le> i then f (nat i) else g, case_node_state)\n    \\<in> (nat_rel \\<rightarrow> R) \\<rightarrow>\n          R \\<rightarrow>\n          {(- 1, DONE)} \\<union> {(int k, STACK k) |k. True} \\<rightarrow> R", "apply (fastforce dest: fun_relD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [autoref_op_pat]: \n  \"(x=DONE) \\<equiv> is_DONE x\"\n  \"(DONE=x) \\<equiv> is_DONE x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x = DONE \\<equiv> is_DONE x) &&& DONE = x \\<equiv> is_DONE x", "apply (auto intro!: eq_reflection)"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_DONE x \\<Longrightarrow> x = DONE\n 2. is_DONE x \\<Longrightarrow> DONE = x", "apply ((cases x, simp_all) [])+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* TODO: Make changing the Autoref-config simpler, by concentrating\n    everything here *)"], ["", "consts i_node :: interface"], ["", "(* TODO: Move generic part of this locale to Digraph_impl *)"], ["", "locale fr_graph_impl_loc = fr_graph G\n  for mrel and node_rel :: \"('vi \\<times> 'v) set\" \n    and node_eq_impl :: \"'vi \\<Rightarrow> 'vi \\<Rightarrow> bool\"\n    and node_hash_impl :: \"nat \\<Rightarrow> 'vi \\<Rightarrow> nat\"\n    and node_def_hash_size :: nat\n    and G_impl and G :: \"('v,'more) graph_rec_scheme\"\n     \n  +\n  assumes G_refine: \"(G_impl,G)\\<in>\\<langle>mrel,node_rel\\<rangle>g_impl_rel_ext\"\n      and node_eq_refine: \"(node_eq_impl, (=)) \\<in> node_rel \\<rightarrow> node_rel \\<rightarrow> bool_rel\"\n      and node_hash: \"is_bounded_hashcode node_rel node_eq_impl node_hash_impl\"\n      and node_hash_def_size: \"(is_valid_def_hm_size TYPE('vi) node_def_hash_size)\"\nbegin"], ["", "(*abbreviation \"node_rel \\<equiv> Id :: ('v \\<times> _) set\"*)"], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of node_rel i_node]"], ["", "lemmas [autoref_rules] = G_refine node_eq_refine"], ["", "lemmas [autoref_ga_rules] = node_hash node_hash_def_size"], ["", "lemma locale_this: \"fr_graph_impl_loc mrel node_rel node_eq_impl node_hash_impl node_def_hash_size G_impl G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fr_graph_impl_loc mrel node_rel node_eq_impl node_hash_impl\n     node_def_hash_size G_impl G", "by unfold_locales"], ["", "abbreviation \"oGSi_rel \\<equiv> \\<langle>node_rel,node_state_rel\\<rangle>(ahm_rel node_hash_impl)\""], ["", "abbreviation \"GSi_rel \\<equiv> \n    \\<langle>node_rel\\<rangle>as_rel \n    \\<times>\\<^sub>r \\<langle>nat_rel\\<rangle>as_rel \n    \\<times>\\<^sub>r oGSi_rel\n    \\<times>\\<^sub>r \\<langle>nat_rel \\<times>\\<^sub>r \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel\""], ["", "lemmas [autoref_op_pat] = GS.S_def GS.B_def GS.I_def GS.P_def"], ["", "end"], ["", "section \\<open>Generating the Code\\<close>"], ["", "thm autoref_ga_rules"], ["", "context fr_graph_impl_loc\nbegin"], ["", "schematic_goal push_code_aux: \"(?c,push_impl)\\<in>node_rel \\<rightarrow> GSi_rel \\<rightarrow> GSi_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, push_impl)\n    \\<in> node_rel \\<rightarrow>\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel", "unfolding push_impl_def_opt[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>x s.\n        case s of\n        (S, B, I, P) \\<Rightarrow>\n          let _ = stat_newnode (); j = length S; S = S @ [x]; B = B @ [j];\n              I = I(x \\<mapsto> STACK j);\n              P = if E `` {x} = {} then P else P @ [(j, E `` {x})]\n          in (S, B, I, P))\n    \\<in> node_rel \\<rightarrow>\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>x s.\n        case s of\n        (S, B, I, P) \\<Rightarrow>\n          let _ = stat_newnode (); j = length S; S = S @ [x]; B = B @ [j];\n              I = I(x \\<mapsto> STACK j);\n              P = if E `` {x} = {} then P else P @ [(j, E `` {x})]\n          in (S, B, I, P))\n    \\<in> node_rel \\<rightarrow>\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition (in -) push_code uses fr_graph_impl_loc.push_code_aux"], ["", "lemmas [autoref_rules] = push_code.refine[OF locale_this]"], ["", "schematic_goal pop_code_aux: \"(?c,pop_impl)\\<in>GSi_rel \\<rightarrow> \\<langle>GSi_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, pop_impl)\n    \\<in> \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>\\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   oGSi_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel \\<times>\\<^sub>r\n                            \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel\\<rangle>nres_rel", "unfolding pop_impl_def_opt[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>s.\n        case s of\n        (S, B, I, P) \\<Rightarrow>\n          let lsi = length B - 1\n          in ASSERT (lsi < length B) \\<bind>\n             (\\<lambda>_.\n                 WHILE\\<^sub>T\n                  (\\<lambda>(l, I).\n                      l < (if lsi + 1 = length B then length S\n                           else B ! (lsi + 1)))\n                  (\\<lambda>(l, I).\n                      ASSERT (l < length S) \\<bind>\n                      (\\<lambda>_. RETURN (Suc l, I(S ! l \\<mapsto> DONE))))\n                  (B ! lsi, I) \\<bind>\n                 (\\<lambda>(uu_, I). RETURN I) \\<bind>\n                 (\\<lambda>I.\n                     ASSERT (B \\<noteq> []) \\<bind>\n                     (\\<lambda>_.\n                         let S = take (last B) S\n                         in ASSERT (B \\<noteq> []) \\<bind>\n                            (\\<lambda>_.\n                                let B = butlast B\n                                in RETURN (S, B, I, P))))))\n    \\<in> \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>\\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   oGSi_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel \\<times>\\<^sub>r\n                            \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel\\<rangle>nres_rel", "unfolding GS.mark_as_done_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>s.\n        case s of\n        (S, B, I, P) \\<Rightarrow>\n          let lsi = length B - 1\n          in ASSERT (lsi < length B) \\<bind>\n             (\\<lambda>_.\n                 WHILE\\<^sub>T\n                  (\\<lambda>(l, I).\n                      l < (if lsi + 1 = length B then length S\n                           else B ! (lsi + 1)))\n                  (\\<lambda>(l, I).\n                      ASSERT (l < length S) \\<bind>\n                      (\\<lambda>_. RETURN (Suc l, I(S ! l \\<mapsto> DONE))))\n                  (B ! lsi, I) \\<bind>\n                 (\\<lambda>(uu_, I). RETURN I) \\<bind>\n                 (\\<lambda>I.\n                     ASSERT (B \\<noteq> []) \\<bind>\n                     (\\<lambda>_.\n                         let S = take (last B) S\n                         in ASSERT (B \\<noteq> []) \\<bind>\n                            (\\<lambda>_.\n                                let B = butlast B\n                                in RETURN (S, B, I, P))))))\n    \\<in> \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>\\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   oGSi_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel \\<times>\\<^sub>r\n                            \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel\\<rangle>nres_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>s.\n        case s of\n        (S, B, I, P) \\<Rightarrow>\n          let lsi = length B - 1\n          in ASSERT (lsi < length B) \\<bind>\n             (\\<lambda>_.\n                 WHILE\\<^sub>T\n                  (\\<lambda>(l, I).\n                      l < (if lsi + 1 = length B then length S\n                           else B ! (lsi + 1)))\n                  (\\<lambda>(l, I).\n                      ASSERT (l < length S) \\<bind>\n                      (\\<lambda>_. RETURN (Suc l, I(S ! l \\<mapsto> DONE))))\n                  (B ! lsi, I) \\<bind>\n                 (\\<lambda>(uu_, I). RETURN I) \\<bind>\n                 (\\<lambda>I.\n                     ASSERT (B \\<noteq> []) \\<bind>\n                     (\\<lambda>_.\n                         let S = take (last B) S\n                         in ASSERT (B \\<noteq> []) \\<bind>\n                            (\\<lambda>_.\n                                let B = butlast B\n                                in RETURN (S, B, I, P))))))\n    \\<in> \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>\\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   oGSi_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel \\<times>\\<^sub>r\n                            \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel\\<rangle>nres_rel", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition (in -) pop_code uses fr_graph_impl_loc.pop_code_aux"], ["", "lemmas [autoref_rules] = pop_code.refine[OF locale_this]"], ["", "schematic_goal S_idx_of_code_aux: \n    notes [autoref_rules] = IdI[of \"undefined::nat\"] (* TODO: hack!*)\n    shows \"(?c,GS.S_idx_of)\\<in>GSi_rel \\<rightarrow> node_rel \\<rightarrow> nat_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, GS.S_idx_of)\n    \\<in> \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          node_rel \\<rightarrow> nat_rel", "unfolding GS.S_idx_of_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>SBIP v. case GS.I SBIP v of Some (STACK i) \\<Rightarrow> i)\n    \\<in> \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          node_rel \\<rightarrow> nat_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>SBIP v. case GS.I SBIP v of Some (STACK i) \\<Rightarrow> i)\n    \\<in> \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          node_rel \\<rightarrow> nat_rel", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition (in -) S_idx_of_code \n    uses fr_graph_impl_loc.S_idx_of_code_aux"], ["", "lemmas [autoref_rules] = S_idx_of_code.refine[OF locale_this]"], ["", "schematic_goal idx_of_code_aux:\n    notes [autoref_rules] = IdI[of \"undefined::nat\"] (* TODO: hack!*)\n    shows \"(?c,GS.idx_of_impl)\\<in> GSi_rel \\<rightarrow> node_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, GS.idx_of_impl)\n    \\<in> \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          node_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>nres_rel", "unfolding \n      GS.idx_of_impl_def[abs_def, unfolded GS.find_seg_impl_def GS.S_idx_of_def,\n        THEN opt_GSdef, unfolded GS_sel_simps, abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>s.\n        case s of\n        (S, B, I, P) \\<Rightarrow>\n          \\<lambda>v.\n             ASSERT (\\<exists>i. I v = Some (STACK i)) \\<bind>\n             (\\<lambda>_.\n                 let j = case I v of Some (STACK i) \\<Rightarrow> i\n                 in ASSERT (j < length S) \\<bind>\n                    (\\<lambda>_.\n                        Let (find_max_nat (length B)\n                              (\\<lambda>i. B ! i \\<le> j))\n                         RETURN)))\n    \\<in> \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          node_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>nres_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>s.\n        case s of\n        (S, B, I, P) \\<Rightarrow>\n          \\<lambda>v.\n             ASSERT (\\<exists>i. I v = Some (STACK i)) \\<bind>\n             (\\<lambda>_.\n                 let j = case I v of Some (STACK i) \\<Rightarrow> i\n                 in ASSERT (j < length S) \\<bind>\n                    (\\<lambda>_.\n                        Let (find_max_nat (length B)\n                              (\\<lambda>i. B ! i \\<le> j))\n                         RETURN)))\n    \\<in> \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          node_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>nres_rel", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition (in -) idx_of_code uses fr_graph_impl_loc.idx_of_code_aux"], ["", "lemmas [autoref_rules] = idx_of_code.refine[OF locale_this]"], ["", "schematic_goal collapse_code_aux: \n    \"(?c,collapse_impl)\\<in>node_rel \\<rightarrow> GSi_rel \\<rightarrow> \\<langle>GSi_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, collapse_impl)\n    \\<in> node_rel \\<rightarrow>\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>\\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   oGSi_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel \\<times>\\<^sub>r\n                            \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel\\<rangle>nres_rel", "unfolding collapse_impl_def_opt[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>x s.\n        case s of\n        (S, B, I, P) \\<Rightarrow>\n          GS.idx_of_impl (S, B, I, P) x \\<bind>\n          (\\<lambda>i.\n              ASSERT (i + 1 \\<le> length B) \\<bind>\n              (\\<lambda>_. let B = take (i + 1) B in RETURN (S, B, I, P))))\n    \\<in> node_rel \\<rightarrow>\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>\\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   oGSi_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel \\<times>\\<^sub>r\n                            \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel\\<rangle>nres_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>x s.\n        case s of\n        (S, B, I, P) \\<Rightarrow>\n          GS.idx_of_impl (S, B, I, P) x \\<bind>\n          (\\<lambda>i.\n              ASSERT (i + 1 \\<le> length B) \\<bind>\n              (\\<lambda>_. let B = take (i + 1) B in RETURN (S, B, I, P))))\n    \\<in> node_rel \\<rightarrow>\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>\\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   oGSi_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel \\<times>\\<^sub>r\n                            \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel\\<rangle>nres_rel", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition (in -) collapse_code \n    uses fr_graph_impl_loc.collapse_code_aux"], ["", "lemmas [autoref_rules] = collapse_code.refine[OF locale_this]"], ["", "term select_edge_impl"], ["", "schematic_goal select_edge_code_aux:\n    \"(?c,select_edge_impl) \n      \\<in> GSi_rel \\<rightarrow> \\<langle>\\<langle>node_rel\\<rangle>option_rel \\<times>\\<^sub>r GSi_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, select_edge_impl)\n    \\<in> \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>\\<langle>node_rel\\<rangle>option_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   oGSi_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel \\<times>\\<^sub>r\n                            \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel\\<rangle>nres_rel", "unfolding select_edge_impl_def_opt[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>s.\n        case s of\n        (S, B, I, P) \\<Rightarrow>\n          if P = [] then RETURN (None, S, B, I, P)\n          else let (j, succs) = last P\n               in ASSERT (length B - 1 < length B) \\<bind>\n                  (\\<lambda>_.\n                      if B ! (length B - 1) \\<le> j\n                      then ASSERT (succs \\<noteq> {}) \\<bind>\n                           (\\<lambda>_.\n                               SPEC (\\<lambda>x. x \\<in> succs) \\<bind>\n                               (\\<lambda>v.\n                                   let succs = succs - {v}\n                                   in ASSERT\n (P \\<noteq> [] \\<and> length P - 1 < length P) \\<bind>\n(\\<lambda>_.\n    let P = if succs = {} then butlast P else P[length P - 1 := (j, succs)]\n    in RETURN (Some v, S, B, I, P))))\n                      else RETURN (None, S, B, I, P)))\n    \\<in> \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>\\<langle>node_rel\\<rangle>option_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   oGSi_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel \\<times>\\<^sub>r\n                            \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel\\<rangle>nres_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>s.\n        case s of\n        (S, B, I, P) \\<Rightarrow>\n          if P = [] then RETURN (None, S, B, I, P)\n          else let (j, succs) = last P\n               in ASSERT (length B - 1 < length B) \\<bind>\n                  (\\<lambda>_.\n                      if B ! (length B - 1) \\<le> j\n                      then ASSERT (succs \\<noteq> {}) \\<bind>\n                           (\\<lambda>_.\n                               SPEC (\\<lambda>x. x \\<in> succs) \\<bind>\n                               (\\<lambda>v.\n                                   let succs = succs - {v}\n                                   in ASSERT\n (P \\<noteq> [] \\<and> length P - 1 < length P) \\<bind>\n(\\<lambda>_.\n    let P = if succs = {} then butlast P else P[length P - 1 := (j, succs)]\n    in RETURN (Some v, S, B, I, P))))\n                      else RETURN (None, S, B, I, P)))\n    \\<in> \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>\\<langle>node_rel\\<rangle>option_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   oGSi_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel \\<times>\\<^sub>r\n                            \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel\\<rangle>nres_rel", "using [[goals_limit=1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>s.\n        case s of\n        (S, B, I, P) \\<Rightarrow>\n          if P = [] then RETURN (None, S, B, I, P)\n          else let (j, succs) = last P\n               in ASSERT (length B - 1 < length B) \\<bind>\n                  (\\<lambda>_.\n                      if B ! (length B - 1) \\<le> j\n                      then ASSERT (succs \\<noteq> {}) \\<bind>\n                           (\\<lambda>_.\n                               SPEC (\\<lambda>x. x \\<in> succs) \\<bind>\n                               (\\<lambda>v.\n                                   let succs = succs - {v}\n                                   in ASSERT\n (P \\<noteq> [] \\<and> length P - 1 < length P) \\<bind>\n(\\<lambda>_.\n    let P = if succs = {} then butlast P else P[length P - 1 := (j, succs)]\n    in RETURN (Some v, S, B, I, P))))\n                      else RETURN (None, S, B, I, P)))\n    \\<in> \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>\\<langle>node_rel\\<rangle>option_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   oGSi_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel \\<times>\\<^sub>r\n                            \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel\\<rangle>nres_rel", "apply (autoref (keep_goal,trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition (in -) select_edge_code \n    uses fr_graph_impl_loc.select_edge_code_aux"], ["", "lemmas [autoref_rules] = select_edge_code.refine[OF locale_this]"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "term fr_graph.pop_impl"], ["", "lemma [autoref_op_pat]: \n      \"push_impl \\<equiv> OP push_impl\"\n      \"collapse_impl \\<equiv> OP collapse_impl\"\n      \"select_edge_impl \\<equiv> OP select_edge_impl\"\n      \"pop_impl \\<equiv> OP pop_impl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((push_impl \\<equiv> OP push_impl) &&&\n     collapse_impl \\<equiv> OP collapse_impl) &&&\n    (select_edge_impl \\<equiv> OP select_edge_impl) &&&\n    pop_impl \\<equiv> OP pop_impl", "by simp_all"], ["", "end"], ["", "schematic_goal skeleton_code_aux:\n    \"(?c,skeleton_impl) \\<in> \\<langle>oGSi_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, skeleton_impl) \\<in> \\<langle>oGSi_rel\\<rangle>nres_rel", "unfolding skeleton_impl_def[abs_def] initial_impl_def GS_initial_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     stat_start_nres \\<bind>\n     (\\<lambda>_.\n         let I = Map.empty\n         in FOREACH\\<^bsup>\\<lambda>it I.\n                              outer_invar it (oGS_\\<alpha> I)\\<^esup>\n             V0 (\\<lambda>v0 I0.\n                    if \\<not> is_done_oimpl v0 I0\n                    then let s = ([v0], [0], I0(v0 \\<mapsto> STACK 0),\n                                  if E `` {v0} = {} then []\n                                  else [(0, E `` {v0})])\n                         in WHILE\\<^sub>T\\<^bsup>invar v0\n            (oGS_\\<alpha> I0) \\<circ>\n           GS.\\<alpha>\\<^esup>\n                             (\\<lambda>s. \\<not> path_is_empty_impl s)\n                             (\\<lambda>s.\n                                 select_edge_impl s \\<bind>\n                                 (\\<lambda>(vo, s).\n                                     case vo of\n                                     None \\<Rightarrow> pop_impl s\n                                     | Some v \\<Rightarrow>\n   if is_on_stack_impl v s then collapse_impl v s\n   else if \\<not> is_done_impl v s then RETURN (push_impl v s)\n        else RETURN s))\n                             s \\<bind>\n                            (\\<lambda>(S, B, I, P). RETURN I)\n                    else RETURN I0)\n             I \\<bind>\n            (\\<lambda>r. stat_stop_nres \\<bind> (\\<lambda>_. RETURN r))))\n    \\<in> \\<langle>oGSi_rel\\<rangle>nres_rel", "unfolding path_is_empty_impl_def is_on_stack_impl_def is_done_impl_def \n      is_done_oimpl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     stat_start_nres \\<bind>\n     (\\<lambda>_.\n         let I = Map.empty\n         in FOREACH\\<^bsup>\\<lambda>it I.\n                              outer_invar it (oGS_\\<alpha> I)\\<^esup>\n             V0 (\\<lambda>v0 I0.\n                    if \\<not> (case I0 v0 of None \\<Rightarrow> False\n                               | Some (STACK nat) \\<Rightarrow> False\n                               | Some DONE \\<Rightarrow> True)\n                    then let s = ([v0], [0], I0(v0 \\<mapsto> STACK 0),\n                                  if E `` {v0} = {} then []\n                                  else [(0, E `` {v0})])\n                         in WHILE\\<^sub>T\\<^bsup>invar v0\n            (oGS_\\<alpha> I0) \\<circ>\n           GS.\\<alpha>\\<^esup>\n                             (\\<lambda>s. GS.S s \\<noteq> [])\n                             (\\<lambda>s.\n                                 select_edge_impl s \\<bind>\n                                 (\\<lambda>(vo, s).\n                                     case vo of\n                                     None \\<Rightarrow> pop_impl s\n                                     | Some v \\<Rightarrow>\n   if GS.is_on_stack_impl s v then collapse_impl v s\n   else if \\<not> GS.is_done_impl s v then RETURN (push_impl v s)\n        else RETURN s))\n                             s \\<bind>\n                            (\\<lambda>(S, B, I, P). RETURN I)\n                    else RETURN I0)\n             I \\<bind>\n            (\\<lambda>r. stat_stop_nres \\<bind> (\\<lambda>_. RETURN r))))\n    \\<in> \\<langle>oGSi_rel\\<rangle>nres_rel", "unfolding GS.is_on_stack_impl_def GS.is_done_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     stat_start_nres \\<bind>\n     (\\<lambda>_.\n         let Ia = Map.empty\n         in FOREACH\\<^bsup>\\<lambda>it I.\n                              outer_invar it (oGS_\\<alpha> I)\\<^esup>\n             V0 (\\<lambda>v0 I0.\n                    if \\<not> (case I0 v0 of None \\<Rightarrow> False\n                               | Some (STACK nat) \\<Rightarrow> False\n                               | Some DONE \\<Rightarrow> True)\n                    then let s = ([v0], [0], I0(v0 \\<mapsto> STACK 0),\n                                  if E `` {v0} = {} then []\n                                  else [(0, E `` {v0})])\n                         in WHILE\\<^sub>T\\<^bsup>invar v0\n            (oGS_\\<alpha> I0) \\<circ>\n           GS.\\<alpha>\\<^esup>\n                             (\\<lambda>s. GS.S s \\<noteq> [])\n                             (\\<lambda>s.\n                                 select_edge_impl s \\<bind>\n                                 (\\<lambda>(vo, s).\n                                     case vo of\n                                     None \\<Rightarrow> pop_impl s\n                                     | Some v \\<Rightarrow>\n   if case GS.I s v of None \\<Rightarrow> False\n      | Some (STACK x) \\<Rightarrow> True | Some DONE \\<Rightarrow> False\n   then collapse_impl v s\n   else if \\<not> (case GS.I s v of None \\<Rightarrow> False\n                   | Some (STACK nat) \\<Rightarrow> False\n                   | Some DONE \\<Rightarrow> True)\n        then RETURN (push_impl v s) else RETURN s))\n                             s \\<bind>\n                            (\\<lambda>(S, B, I, P). RETURN I)\n                    else RETURN I0)\n             Ia \\<bind>\n            (\\<lambda>r. stat_stop_nres \\<bind> (\\<lambda>_. RETURN r))))\n    \\<in> \\<langle>oGSi_rel\\<rangle>nres_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     stat_start_nres \\<bind>\n     (\\<lambda>_.\n         let Ia = Map.empty\n         in FOREACH\\<^bsup>\\<lambda>it I.\n                              outer_invar it (oGS_\\<alpha> I)\\<^esup>\n             V0 (\\<lambda>v0 I0.\n                    if \\<not> (case I0 v0 of None \\<Rightarrow> False\n                               | Some (STACK nat) \\<Rightarrow> False\n                               | Some DONE \\<Rightarrow> True)\n                    then let s = ([v0], [0], I0(v0 \\<mapsto> STACK 0),\n                                  if E `` {v0} = {} then []\n                                  else [(0, E `` {v0})])\n                         in WHILE\\<^sub>T\\<^bsup>invar v0\n            (oGS_\\<alpha> I0) \\<circ>\n           GS.\\<alpha>\\<^esup>\n                             (\\<lambda>s. GS.S s \\<noteq> [])\n                             (\\<lambda>s.\n                                 select_edge_impl s \\<bind>\n                                 (\\<lambda>(vo, s).\n                                     case vo of\n                                     None \\<Rightarrow> pop_impl s\n                                     | Some v \\<Rightarrow>\n   if case GS.I s v of None \\<Rightarrow> False\n      | Some (STACK x) \\<Rightarrow> True | Some DONE \\<Rightarrow> False\n   then collapse_impl v s\n   else if \\<not> (case GS.I s v of None \\<Rightarrow> False\n                   | Some (STACK nat) \\<Rightarrow> False\n                   | Some DONE \\<Rightarrow> True)\n        then RETURN (push_impl v s) else RETURN s))\n                             s \\<bind>\n                            (\\<lambda>(S, B, I, P). RETURN I)\n                    else RETURN I0)\n             Ia \\<bind>\n            (\\<lambda>r. stat_stop_nres \\<bind> (\\<lambda>_. RETURN r))))\n    \\<in> \\<langle>oGSi_rel\\<rangle>nres_rel", "apply (autoref (keep_goal,trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition (in -) skeleton_code \n    for node_eq_impl G_impl\n    uses fr_graph_impl_loc.skeleton_code_aux"], ["", "thm   skeleton_code.refine"], ["", "lemmas [autoref_rules] = skeleton_code.refine[OF locale_this]"], ["", "schematic_goal pop_tr_aux: \"RETURN ?c \\<le> pop_code node_eq_impl node_hash_impl s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c \\<le> pop_code node_eq_impl node_hash_impl s", "unfolding pop_code_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> (case s of\n           (x, xaa, xba, xc) \\<Rightarrow>\n             let y' = as_length xaa - 1\n             in WHILE\\<^sub>T\n                 (\\<lambda>(xe, xf).\n                     xe < (if y' + 1 = as_length xaa then as_length x\n                           else as_get xaa (y' + 1)))\n                 (\\<lambda>(xe, xf).\n                     RETURN\n                      (Suc xe,\n                       Impl_Array_Hash_Map.ahm_update node_eq_impl\n                        node_hash_impl (as_get x xe) (- 1) xf))\n                 (as_get xaa y', xba) \\<bind>\n                (\\<lambda>(xd, y). RETURN y) \\<bind>\n                (\\<lambda>xd.\n                    let y'a = as_take (as_top xaa) x; y'b = as_pop xaa\n                    in RETURN (y'a, y'b, xd, xc)))", "by refine_transfer"], ["", "concrete_definition (in -) pop_tr uses fr_graph_impl_loc.pop_tr_aux"], ["", "lemmas [refine_transfer] = pop_tr.refine[OF locale_this]"], ["", "schematic_goal select_edge_tr_aux: \"RETURN ?c \\<le> select_edge_code node_eq_impl s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c \\<le> select_edge_code node_eq_impl s", "unfolding select_edge_code_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> (case s of\n           (x, xaa, xba, xc) \\<Rightarrow>\n             if as_is_empty xc then RETURN (None, x, xaa, xba, xc)\n             else let (xd, xe) = as_top xc\n                  in if as_get xaa (as_length xaa - 1) \\<le> xd\n                     then RETURN\n                           (Gen_Set.gen_pick (\\<lambda>x. foldli (id x))\n                             xe) \\<bind>\n                          (\\<lambda>xf.\n                              let y'a = glist_delete node_eq_impl xf xe;\n                                  y'b =\n                                    if is_Nil y'a then as_pop xc\n                                    else as_set xc (as_length xc - 1)\n    (xd, y'a)\n                              in RETURN (Some xf, x, xaa, xba, y'b))\n                     else RETURN (None, x, xaa, xba, xc))", "by refine_transfer"], ["", "concrete_definition (in -) select_edge_tr \n    uses fr_graph_impl_loc.select_edge_tr_aux"], ["", "lemmas [refine_transfer] = select_edge_tr.refine[OF locale_this]"], ["", "schematic_goal idx_of_tr_aux: \"RETURN ?c \\<le> idx_of_code node_eq_impl node_hash_impl v s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c \\<le> idx_of_code node_eq_impl node_hash_impl v s", "unfolding idx_of_code_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> (case v of\n           (x, xaa, xba, xc) \\<Rightarrow>\n             \\<lambda>xd.\n                let y' = case Impl_Array_Hash_Map.ahm_lookup node_eq_impl\n                               node_hash_impl xd xba of\n                         Some i \\<Rightarrow>\n                           if 0 \\<le> i then nat i else undefined\n                in Let (find_max_nat (as_length xaa)\n                         (\\<lambda>j. as_get xaa j \\<le> y'))\n                    RETURN)\n           s", "by refine_transfer"], ["", "concrete_definition (in -) idx_of_tr uses fr_graph_impl_loc.idx_of_tr_aux"], ["", "lemmas [refine_transfer] = idx_of_tr.refine[OF locale_this]"], ["", "schematic_goal collapse_tr_aux: \"RETURN ?c \\<le> collapse_code node_eq_impl node_hash_impl v s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c \\<le> collapse_code node_eq_impl node_hash_impl v s", "unfolding collapse_code_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> (case s of\n           (xa, xb, xca, xd) \\<Rightarrow>\n             idx_of_code node_eq_impl node_hash_impl (xa, xb, xca, xd)\n              v \\<bind>\n             (\\<lambda>xe.\n                 let y' = as_take (xe + 1) xb in RETURN (xa, y', xca, xd)))", "by refine_transfer"], ["", "concrete_definition (in -) collapse_tr uses fr_graph_impl_loc.collapse_tr_aux"], ["", "lemmas [refine_transfer] = collapse_tr.refine[OF locale_this]"], ["", "schematic_goal skeleton_tr_aux: \"RETURN ?c \\<le> skeleton_code node_hash_impl node_def_hash_size node_eq_impl g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> skeleton_code node_hash_impl node_def_hash_size node_eq_impl g", "unfolding skeleton_code_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> stat_start_nres \\<bind>\n          (\\<lambda>x.\n              let y' = Impl_Array_Hash_Map.ahm_empty node_def_hash_size\n              in LIST_FOREACH' (RETURN (id (gi_V0 g))) (\\<lambda>xa. True)\n                  (\\<lambda>xa xb.\n                      if \\<not> (case Impl_Array_Hash_Map.ahm_lookup\n node_eq_impl node_hash_impl xa xb of\n                                 None \\<Rightarrow> False\n                                 | Some i \\<Rightarrow>\n                                     if 0 \\<le> i then False else True)\n                      then let y'a =\n                                 (as_singleton xa, as_singleton 0,\n                                  Impl_Array_Hash_Map.ahm_update\n                                   node_eq_impl node_hash_impl xa (int 0)\n                                   xb,\n                                  if is_Nil (gi_E g xa) then as_empty ()\n                                  else as_singleton (0, gi_E g xa))\n                           in WHILE\\<^sub>T\n                               (\\<lambda>xc.\n                                   \\<not> as_is_empty\n     (case xc of (xd, xe, xf, xg) \\<Rightarrow> xd))\n                               (\\<lambda>xc.\n                                   select_edge_code node_eq_impl xc \\<bind>\n                                   (\\<lambda>(xd, xe).\n case xd of None \\<Rightarrow> pop_code node_eq_impl node_hash_impl xe\n | Some xf \\<Rightarrow>\n     if case Impl_Array_Hash_Map.ahm_lookup node_eq_impl node_hash_impl xf\n              (case xe of (xg, xh, xi, xj) \\<Rightarrow> xi) of\n        None \\<Rightarrow> False\n        | Some i \\<Rightarrow> if 0 \\<le> i then True else False\n     then collapse_code node_eq_impl node_hash_impl xf xe\n     else if \\<not> (case Impl_Array_Hash_Map.ahm_lookup node_eq_impl\n                           node_hash_impl xf\n                           (case xe of (xg, xh, xi, xj) \\<Rightarrow> xi) of\n                     None \\<Rightarrow> False\n                     | Some i \\<Rightarrow>\n                         if 0 \\<le> i then False else True)\n          then RETURN (push_code node_eq_impl node_hash_impl g xf xe)\n          else RETURN xe))\n                               y'a \\<bind>\n                              (\\<lambda>(xc, xd, xe, xf). RETURN xe)\n                      else RETURN xb)\n                  y' \\<bind>\n                 (\\<lambda>xa.\n                     stat_stop_nres \\<bind> (\\<lambda>xb. RETURN xa)))", "by refine_transfer"], ["", "concrete_definition (in -) skeleton_tr uses fr_graph_impl_loc.skeleton_tr_aux"], ["", "lemmas [refine_transfer] = skeleton_tr.refine[OF locale_this]"], ["", "end"], ["", "term skeleton_tr"], ["", "export_code skeleton_tr checking SML"], ["", "end"]]}