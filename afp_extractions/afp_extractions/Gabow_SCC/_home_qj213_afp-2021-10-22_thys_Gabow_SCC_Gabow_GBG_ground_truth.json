{"file_name": "/home/qj213/afp-2021-10-22/thys/Gabow_SCC/Gabow_GBG.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Gabow_SCC", "problem_names": ["lemma igb_fr_graphI:\n  assumes \"igb_graph G\"\n  assumes \"finite ((g_E G)\\<^sup>* `` g_V0 G)\"\n  shows \"igb_fr_graph G\"", "lemma locale_this: \"fgl_invar_loc G v0 D0 brk p D pE\"", "lemma invar_loc_this: \"invar_loc G v0 D0 p D pE\"", "lemma eas_gba_graph_this: \"igb_graph G\"", "lemma fgl_outer_invarI[intro?]:\n    \"\\<lbrakk>\n      brk=None \\<Longrightarrow> outer_invar it D; \n      \\<lbrakk>brk=None \\<Longrightarrow> outer_invar it D\\<rbrakk> \\<Longrightarrow> fgl_outer_invar_ext it (brk,D)\\<rbrakk> \n      \\<Longrightarrow> fgl_outer_invar it (brk,D)\"", "lemma fgl_invarI[intro?]:\n    \"\\<lbrakk> invar v0 D0 PDPE; \n       invar v0 D0 PDPE \\<Longrightarrow> fgl_invar_part (B,PDPE)\\<rbrakk> \n     \\<Longrightarrow> fgl_invar v0 D0 (B,PDPE)\"", "lemma fgl_invar_initial: \n    assumes OINV: \"fgl_outer_invar it (None,D0)\"\n    assumes A: \"v0\\<in>it\" \"v0\\<notin>D0\"\n    shows \"fgl_invar_part (None, initial v0 D0)\"", "lemma fgl_invar_pop:\n    assumes INV: \"fgl_invar v0 D0 (None,p,D,pE)\"\n    assumes INV': \"invar v0 D0 (pop (p,D,pE))\"\n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes NO': \"pE \\<inter> last p \\<times> UNIV = {}\"\n    shows \"fgl_invar_part (None, pop (p,D,pE))\"", "lemma fgl_invar_collapse_ce_aux:\n    assumes INV: \"invar v0 D0 (p, D, pE)\"\n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes NONTRIV: \"vE p D pE \\<inter> (last p \\<times> last p) \\<noteq> {}\"\n    assumes ACC: \"\\<forall>i<num_acc. \\<exists>q\\<in>last p. i\\<in>acc q\"\n    shows \"fgl_invar_part (Some (\\<Union>(set (butlast p)), last p), p, D, pE)\"", "lemma fgl_invar_collapse_ce:\n    fixes u v\n    assumes INV: \"fgl_invar v0 D0 (None,p,D,pE)\"\n    defines \"pE' \\<equiv> pE - {(u,v)}\"\n    assumes CFMT: \"(p',D',pE'') = collapse v (p,D,pE')\"\n    assumes INV': \"invar v0 D0 (p',D',pE'')\"\n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes E: \"(u,v)\\<in>pE\" and \"u\\<in>last p\"\n    assumes BACK: \"v\\<in>\\<Union>(set p)\"\n    assumes ACC: \"\\<forall>i<num_acc. \\<exists>q\\<in>last p'. i\\<in>acc q\"\n    defines i_def: \"i \\<equiv> idx_of p v\"\n    shows \"fgl_invar_part (\n      Some (\\<Union>(set (butlast p')), last p'), \n      collapse v (p,D,pE'))\"", "lemma fgl_invar_collapse_nce:\n    fixes u v\n    assumes INV: \"fgl_invar v0 D0 (None,p,D,pE)\"\n    defines \"pE' \\<equiv> pE - {(u,v)}\"\n    assumes CFMT: \"(p',D',pE'') = collapse v (p,D,pE')\"\n    assumes INV': \"invar v0 D0 (p',D',pE'')\"\n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes E: \"(u,v)\\<in>pE\" and \"u\\<in>last p\"\n    assumes BACK: \"v\\<in>\\<Union>(set p)\"\n    assumes NACC: \"j<num_acc\" \"\\<forall>q\\<in>last p'. j\\<notin>acc q\"\n    defines \"i \\<equiv> idx_of p v\"\n    shows \"fgl_invar_part (None, collapse v (p,D,pE'))\"", "lemma collapse_ne: \"([],D',pE') \\<noteq> collapse v (p,D,pE)\"", "lemma fgl_invar_push:\n    assumes INV: \"fgl_invar v0 D0 (None,p,D,pE)\"\n    assumes BRK[simp]: \"brk=None\" \n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes E: \"(u,v)\\<in>pE\" and UIL: \"u\\<in>last p\"\n    assumes VNE: \"v\\<notin>\\<Union>(set p)\" \"v\\<notin>D\"\n    assumes INV': \"invar v0 D0 (push v (p,D,pE - {(u,v)}))\"\n    shows \"fgl_invar_part (None, push v (p,D,pE - {(u,v)}))\"", "lemma fgl_invar_skip:\n    assumes INV: \"fgl_invar v0 D0 (None,p,D,pE)\"\n    assumes BRK[simp]: \"brk=None\" \n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes E: \"(u,v)\\<in>pE\" and UIL: \"u\\<in>last p\"\n    assumes VID: \"v\\<in>D\"\n    assumes INV': \"invar v0 D0 (p, D, (pE - {(u,v)}))\"\n    shows \"fgl_invar_part (None, p, D, (pE - {(u,v)}))\"", "lemma fgl_outer_invar_initial: \n    \"outer_invar V0 {} \\<Longrightarrow> fgl_outer_invar_ext V0 (None, {})\"", "lemma fgl_outer_invar_brk:\n    assumes INV: \"fgl_invar v0 D0 (Some (Vr,Vl),p,D,pE)\"\n    shows \"fgl_outer_invar_ext anyIt (Some (Vr,Vl), anyD)\"", "lemma fgl_outer_invar_newnode_nobrk:\n    assumes A: \"v0\\<notin>D0\" \"v0\\<in>it\" \n    assumes OINV: \"fgl_outer_invar it (None,D0)\"\n    assumes INV: \"fgl_invar v0 D0 (None,[],D',pE)\"\n    shows \"fgl_outer_invar_ext (it-{v0}) (None,D')\"", "lemma fgl_outer_invar_newnode:\n    assumes A: \"v0\\<notin>D0\" \"v0\\<in>it\" \n    assumes OINV: \"fgl_outer_invar it (None,D0)\"\n    assumes INV: \"fgl_invar v0 D0 (brk,p,D',pE)\"\n    assumes CASES: \"(\\<exists>Vr Vl. brk = Some (Vr, Vl)) \\<or> p = []\"\n    shows \"fgl_outer_invar_ext (it-{v0}) (brk,D')\"", "lemma fgl_outer_invar_Dnode:\n    assumes \"fgl_outer_invar it (None, D)\" \"v\\<in>D\"\n    shows \"fgl_outer_invar_ext (it - {v}) (None, D)\"", "lemma fgl_fin_no_lasso:\n    assumes A: \"fgl_outer_invar {} (None, D)\"\n    assumes B: \"is_lasso_prpl prpl\"\n    shows \"False\"", "lemma fgl_fin_lasso:\n    assumes A: \"fgl_outer_invar it (Some (Vr,Vl), D)\"\n    shows \"ce_correct Vr Vl\"", "lemmas fgl_invar_preserve = \n    fgl_invar_initial fgl_invar_push fgl_invar_pop \n    fgl_invar_collapse_ce fgl_invar_collapse_nce fgl_invar_skip\n    fgl_outer_invar_newnode fgl_outer_invar_Dnode\n    invar_initial outer_invar_initial fgl_invar_initial fgl_outer_invar_initial\n    fgl_fin_no_lasso fgl_fin_lasso", "lemma outer_invar_from_fgl_invarI: \n    \"fgl_outer_invar it (None,D) \\<Longrightarrow> outer_invar it D\"", "lemma invar_from_fgl_invarI: \"fgl_invar v0 D0 (B,PDPE) \\<Longrightarrow> invar v0 D0 PDPE\"", "theorem find_ce_correct: \"find_ce \\<le> find_ce_spec\"", "theorem abs_is_empty_correct: \n    \"abs_is_empty \\<le> SPEC (\\<lambda>res. res \\<longleftrightarrow> (\\<forall>r. \\<not>is_acc_run r))\"", "theorem abs_is_empty_ce_correct: \"abs_is_empty_ce \\<le> SPEC (\\<lambda>res. case res of\n      None \\<Rightarrow> (\\<forall>r. \\<not>is_acc_run r)\n    | Some (pr,pl) \\<Rightarrow> is_acc_run (pr\\<frown>pl\\<^sup>\\<omega>)\n    )\"", "lemma gstate_rel_sv[relator_props,simp,intro!]: \"single_valued gstate_rel\"", "lemma gcollapse_refine:\n    \"\\<lbrakk>(v',v)\\<in>Id; (s',s)\\<in>gstate_rel\\<rbrakk> \n      \\<Longrightarrow> (gcollapse v' s',collapse v s)\\<in>gstate_rel\"", "lemma gpush_refine:\n    \"\\<lbrakk>(v',v)\\<in>Id; (s',s)\\<in>gstate_rel\\<rbrakk> \\<Longrightarrow> (gpush v' s',push v s)\\<in>gstate_rel\"", "lemma gpop_refine:\n    \"\\<lbrakk>(s',s)\\<in>gstate_rel\\<rbrakk> \\<Longrightarrow> (gpop s',pop s)\\<in>gstate_rel\"", "lemma ginitial_refine:\n    \"(ginitial x (None, b), initial x b) \\<in> gstate_rel\"", "lemma oinitial_b_refine: \"((None,{}),(None,{}))\\<in>Id\\<times>\\<^sub>rId\"", "lemma gselect_edge_refine: \"\\<lbrakk>(s',s)\\<in>gstate_rel\\<rbrakk> \\<Longrightarrow> gselect_edge s' \n    \\<le>\\<Down>(\\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r gstate_rel) (select_edge s)\"", "lemma last_acc_impl:\n    assumes \"p\\<noteq>[]\"\n    assumes \"((a',p',D',pE'),(p,D,pE))\\<in>gstate_rel\"\n    shows \"(last a' = {0..<num_acc}) = (\\<forall>i<num_acc. \\<exists>q\\<in>last p. i\\<in>acc q)\"", "lemma fglr_aux1:\n    assumes V: \"(v',v)\\<in>Id\" and S: \"(s',s)\\<in>gstate_rel\" \n      and P: \"\\<And>a' p' D' pE' p D pE. ((a',p',D',pE'),(p,D,pE))\\<in>gstate_rel \n      \\<Longrightarrow> f' a' p' D' pE' \\<le>\\<Down>R (f p D pE)\"\n    shows \"(let (a',p',D',pE') = gcollapse v' s' in f' a' p' D' pE') \n      \\<le> \\<Down>R (let (p,D,pE) = collapse v s in f p D pE)\"", "lemma gstate_invar_empty: \n    \"gstate_invar (a,[],D,pE) \\<Longrightarrow> a=[]\"\n    \"gstate_invar ([],p,D,pE) \\<Longrightarrow> p=[]\"", "lemma find_ce_refine: \"gfind_ce \\<le>\\<Down>Id find_ce\"", "lemma Un_set_drop_impl_correct: \n  \"Un_set_drop_impl i A \\<le> SPEC (\\<lambda>r. r=\\<Union>(set (drop i A)))\"", "lemma Un_set_drop_autoref[autoref_rules]: \n  assumes \"GEN_OP es_impl {} (\\<langle>R\\<rangle>Rs)\"\n  assumes \"GEN_OP un_impl (\\<union>) (\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs)\"\n  shows \"(\\<lambda>i A. RETURN (Un_set_drop_tr es_impl un_impl i A),Un_set_drop_impl)\n    \\<in>nat_rel \\<rightarrow> \\<langle>\\<langle>R\\<rangle>Rs\\<rangle>as_rel \\<rightarrow> \\<langle>\\<langle>R\\<rangle>Rs\\<rangle>nres_rel\"", "lemma gGS_rel_sv[relator_props,intro!,simp]: \"single_valued gGS_rel\"", "lemma goGS_rel_sv[relator_props,intro!,simp]: \"single_valued goGS_rel\"", "lemma gGS_relE:\n    assumes \"(s',(a,p,D,pE))\\<in>gGS_rel\"\n    obtains S' B' I' P' where \"s'=(a,S',B',I',P')\" \n      and \"((S',B',I',P'),(p,D,pE))\\<in>GS_rel\" \n      and \"length a = length B'\"\n      and \"\\<Union>(set a) \\<subseteq> {0..<num_acc}\"", "lemma goinitial_impl_refine: \"(goinitial_impl,goinitial)\\<in>goGS_rel\"", "lemma gto_outer_refine:\n    assumes A: \"brk = None \\<longrightarrow> (p=[] \\<and> pE={})\"\n    assumes B: \"(s, (A,p, D, pE)) \\<in> gGS_rel\"\n    assumes C: \"(brk',brk)\\<in>Id\"\n    shows \"(gto_outer_impl brk' s,gto_outer brk (A,p,D,pE))\\<in>goGS_rel\"", "lemma gpush_impl_refine:\n    assumes B: \"(s',(a,p,D,pE))\\<in>gGS_rel\"\n    assumes A: \"(v',v)\\<in>Id\" \n    assumes PRE: \"v' \\<notin> \\<Union>(set p)\" \"v' \\<notin> D\"\n    shows \"(gpush_impl v' s', gpush v (a,p,D,pE))\\<in>gGS_rel\"", "lemma gpop_impl_refine:\n    assumes A: \"(s',(a,p,D,pE))\\<in>gGS_rel\"\n    assumes PRE: \"p \\<noteq> []\" \"pE \\<inter> last p \\<times> UNIV = {}\"\n    shows \"gpop_impl s' \\<le> \\<Down>gGS_rel (RETURN (gpop (a,p,D,pE)))\"", "lemma gselect_edge_impl_refine:\n    assumes A: \"(s', a, p, D, pE) \\<in> gGS_rel\" \n    assumes PRE: \"p \\<noteq> []\"\n    shows \"gselect_edge_impl s' \\<le> \\<Down>(Id \\<times>\\<^sub>r gGS_rel) (gselect_edge (a, p, D, pE))\"", "lemma gcollapse_alt:\n    \"gcollapse v APDPE = ( \n      let \n        (a,p,D,pE)=APDPE; \n        i=idx_of p v;\n        s=collapse v (p,D,pE);\n        us=\\<Union>(set (drop i a));\n        a = take i a @ [us]\n      in (a,s))\"", "lemma gcollapse_impl_aux_refine:\n    assumes A: \"(s', a, p, D, pE) \\<in> gGS_rel\" \n    assumes B: \"(v',v)\\<in>Id\"\n    assumes PRE: \"v\\<in>\\<Union>(set p)\"\n    shows \"gcollapse_impl_aux v' s' \n      \\<le> \\<Down> gGS_rel (RETURN (gcollapse v (a, p, D, pE)))\"", "lemma gcollapse_impl_aux_opt_refine: \n    \"gcollapse_impl v s \\<le> gcollapse_impl_aux v s\"", "lemma gcollapse_impl_refine:\n    assumes A: \"(s', a, p, D, pE) \\<in> gGS_rel\" \n    assumes B: \"(v',v)\\<in>Id\"\n    assumes PRE: \"v\\<in>\\<Union>(set p)\"\n    shows \"gcollapse_impl v' s' \n    \\<le> \\<Down> gGS_rel (RETURN (gcollapse v (a, p, D, pE)))\"", "lemma ginitial_impl_refine: \n    assumes A: \"v0\\<notin>goD s0\" \"go_is_no_brk s0\"\n    assumes REL: \"(s0i,s0)\\<in>goGS_rel\" \"(v0i,v0)\\<in>Id\" \n    shows \"(ginitial_impl v0i s0i,ginitial v0 s0)\\<in>gGS_rel\"", "lemma gpath_is_empty_refine: \n    \"(s,(a,p,D,pE))\\<in>gGS_rel \\<Longrightarrow> gpath_is_empty_impl s \\<longleftrightarrow> p=[]\"", "lemma gis_on_stack_refine: \n    \"\\<lbrakk>(s,(a,p,D,pE))\\<in>gGS_rel\\<rbrakk> \\<Longrightarrow> gis_on_stack_impl v s \\<longleftrightarrow> v\\<in>\\<Union>(set p)\"", "lemma gis_done_refine: \"(s,(a,p,D,pE))\\<in>gGS_rel \n    \\<Longrightarrow> gis_done_impl v s \\<longleftrightarrow> (v \\<in> D)\"", "lemma (in GS_invar) set_butlast_p_refine:\n    assumes PRE: \"p_\\<alpha>\\<noteq>[]\"\n    shows \"Collect (on_stack_less I (last B)) = \\<Union>(set (butlast p_\\<alpha>))\" (is \"?L=?R\")", "lemma (in GS_invar) set_last_p_refine:\n    assumes PRE: \"p_\\<alpha>\\<noteq>[]\"\n    shows \"Collect (on_stack_ge I (last B)) = last p_\\<alpha>\" (is \"?L=?R\")", "lemma ce_impl_refine:\n    assumes A: \"(s,(a,p,D,pE))\\<in>gGS_rel\"\n    assumes PRE: \"p\\<noteq>[]\"\n    shows \"ce_impl s \\<le> \\<Down>(Id\\<times>\\<^sub>rgGS_rel) \n      (RETURN (Some (\\<Union>(set (butlast p)),last p),a,p,D,pE))\"", "lemma last_is_acc_impl_refine:\n    assumes A: \"(s,(a,p,D,pE))\\<in>gGS_rel\"\n    assumes PRE: \"a\\<noteq>[]\"\n    shows \"last_is_acc_impl s \\<le> RETURN (last a = {0..<num_acc})\"", "lemma go_is_no_brk_refine: \n    \"(s,s')\\<in>goGS_rel \\<Longrightarrow> go_is_no_brk_impl s \\<longleftrightarrow> go_is_no_brk s'\"", "lemma goD_refine: \n    \"go_is_no_brk s' \\<Longrightarrow> (s,s')\\<in>goGS_rel \\<Longrightarrow> (goD_impl s, goD s')\\<in>oGS_rel\"", "lemma go_is_done_impl_refine: \"\\<lbrakk>go_is_no_brk s'; (s,s')\\<in>goGS_rel; (v,v')\\<in>Id\\<rbrakk> \n    \\<Longrightarrow> go_is_done_impl v s \\<longleftrightarrow> (v'\\<in>goD s')\"", "lemma goBrk_refine: \"(s,s')\\<in>goGS_rel \\<Longrightarrow> (goBrk_impl s, goBrk s')\\<in>Id\"", "lemma find_ce_impl_refine: \"find_ce_impl \\<le> \\<Down>Id gfind_ce\"", "lemma reconstruct_reach_correct:\n    assumes CEC: \"ce_correct Vr Vl\"\n    shows \"reconstruct_reach Vr Vl \n      \\<le> SPEC (\\<lambda>(pr,va). \\<exists>v0\\<in>V0. path E v0 pr va \\<and> va\\<in>Vl)\"", "lemma (in igb_fr_graph) reconstruct_lasso_correct:\n  assumes CEC: \"ce_correct Vr Vl\"\n  shows \"reconstruct_lasso Vr Vl \\<le> SPEC (is_lasso_prpl)\"", "lemma (in igb_fr_graph) find_lasso_correct: \"find_lasso \\<le> find_lasso_spec\""], "translations": [["", "lemma igb_fr_graphI:\n  assumes \"igb_graph G\"\n  assumes \"finite ((g_E G)\\<^sup>* `` g_V0 G)\"\n  shows \"igb_fr_graph G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igb_fr_graph G", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. igb_fr_graph G", "interpret igb_graph G"], ["proof (prove)\ngoal (1 subgoal):\n 1. igb_graph G", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. igb_fr_graph G", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. igb_fr_graph G", "using assms(2)"], ["proof (prove)\nusing this:\n  finite reachable\n\ngoal (1 subgoal):\n 1. igb_fr_graph G", "by unfold_locales"], ["proof (state)\nthis:\n  igb_fr_graph G\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We implement an algorithm that computes witnesses for the \n  non-emptiness of Generalized B\\\"uchi Graphs (GBG).\n\\<close>"], ["", "section \\<open>Specification\\<close>"], ["", "context igb_graph\nbegin"], ["", "definition ce_correct \n    \\<comment> \\<open>Specifies a correct counter-example\\<close>\n    where\n    \"ce_correct Vr Vl \\<equiv> (\\<exists>pr pl. \n        Vr \\<subseteq> E\\<^sup>*``V0 \\<and> Vl \\<subseteq> E\\<^sup>*``V0 \\<comment> \\<open>Only reachable nodes are covered\\<close>\n      \\<and> set pr\\<subseteq>Vr \\<and> set pl\\<subseteq>Vl     \\<comment> \\<open>The paths are inside the specified sets\\<close>\n      \\<and> Vl\\<times>Vl \\<subseteq> (E \\<inter> Vl\\<times>Vl)\\<^sup>*      \\<comment> \\<open>\\<open>Vl\\<close> is mutually connected\\<close>\n      \\<and> Vl\\<times>Vl \\<inter> E \\<noteq> {}            \\<comment> \\<open>\\<open>Vl\\<close> is non-trivial\\<close>\n      \\<and> is_lasso_prpl (pr,pl))    \\<comment> \\<open>Paths form a lasso\\<close>\n    \""], ["", "definition find_ce_spec :: \"('Q set \\<times> 'Q set) option nres\" where\n    \"find_ce_spec \\<equiv> SPEC (\\<lambda>r. case r of\n      None \\<Rightarrow> (\\<forall>prpl. \\<not>is_lasso_prpl prpl)\n    | Some (Vr,Vl) \\<Rightarrow> ce_correct Vr Vl\n    )\""], ["", "definition find_lasso_spec :: \"('Q list \\<times> 'Q list) option nres\" where\n    \"find_lasso_spec \\<equiv> SPEC (\\<lambda>r. case r of\n      None \\<Rightarrow> (\\<forall>prpl. \\<not>is_lasso_prpl prpl)\n    | Some prpl \\<Rightarrow> is_lasso_prpl prpl\n    )\""], ["", "end"], ["", "section \\<open>Invariant Extension\\<close>"], ["", "text \\<open>Extension of the outer invariant:\\<close>"], ["", "context igb_fr_graph\nbegin"], ["", "definition no_acc_over\n    \\<comment> \\<open>Specifies that there is no accepting cycle touching a set of nodes\\<close>\n    where\n    \"no_acc_over D \\<equiv> \\<not>(\\<exists>v\\<in>D. \\<exists>pl. pl\\<noteq>[] \\<and> path E v pl v \\<and> \n    (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i\\<in>acc q))\""], ["", "definition \"fgl_outer_invar_ext \\<equiv> \\<lambda>it (brk,D). \n    case brk of None \\<Rightarrow> no_acc_over D | Some (Vr,Vl) \\<Rightarrow> ce_correct Vr Vl\""], ["", "definition \"fgl_outer_invar \\<equiv> \\<lambda>it (brk,D). case brk of \n    None \\<Rightarrow> outer_invar it D \\<and> no_acc_over D\n  | Some (Vr,Vl) \\<Rightarrow> ce_correct Vr Vl\""], ["", "end"], ["", "text \\<open>Extension of the inner invariant:\\<close>"], ["", "locale fgl_invar_loc = \n  invar_loc G v0 D0 p D pE \n  + igb_graph G\n  for G :: \"('Q, 'more) igb_graph_rec_scheme\"\n  and v0 D0 and brk :: \"('Q set \\<times> 'Q set) option\" and p D pE +\n  assumes no_acc: \"brk=None \\<Longrightarrow> \\<not>(\\<exists>v pl. pl\\<noteq>[] \\<and> path lvE v pl v \\<and> \n    (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i\\<in>acc q))\" \\<comment> \\<open>No accepting cycle over \n      visited edges\\<close>\n  assumes acc: \"brk=Some (Vr,Vl) \\<Longrightarrow> ce_correct Vr Vl\"\nbegin"], ["", "lemma locale_this: \"fgl_invar_loc G v0 D0 brk p D pE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_invar_loc G v0 D0 brk p D pE", "by unfold_locales"], ["", "lemma invar_loc_this: \"invar_loc G v0 D0 p D pE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D pE", "by unfold_locales"], ["", "lemma eas_gba_graph_this: \"igb_graph G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igb_graph G", "by unfold_locales"], ["", "end"], ["", "definition (in igb_graph) \"fgl_invar v0 D0 \\<equiv> \n  \\<lambda>(brk, p, D, pE). fgl_invar_loc G v0 D0 brk p D pE\""], ["", "section \\<open>Definition of the Lasso-Finding Algorithm\\<close>"], ["", "context igb_fr_graph\nbegin"], ["", "definition find_ce :: \"('Q set \\<times> 'Q set) option nres\" where\n    \"find_ce \\<equiv> do {\n      let D = {};\n      (brk,_)\\<leftarrow>FOREACHci fgl_outer_invar V0 \n        (\\<lambda>(brk,_). brk=None) \n        (\\<lambda>v0 (brk,D0). do {\n          if v0\\<notin>D0 then do {\n            let s = (None,initial v0 D0);\n\n            (brk,p,D,pE) \\<leftarrow> WHILEIT (fgl_invar v0 D0)\n              (\\<lambda>(brk,p,D,pE). brk=None \\<and> p \\<noteq> []) (\\<lambda>(_,p,D,pE). \n            do {\n              \\<comment> \\<open>Select edge from end of path\\<close>\n              (vo,(p,D,pE)) \\<leftarrow> select_edge (p,D,pE);\n\n              ASSERT (p\\<noteq>[]);\n              case vo of \n                Some v \\<Rightarrow> do {\n                  if v \\<in> \\<Union>(set p) then do {\n                    \\<comment> \\<open>Collapse\\<close>\n                    let (p,D,pE) = collapse v (p,D,pE);\n\n                    ASSERT (p\\<noteq>[]);\n\n                    if \\<forall>i<num_acc. \\<exists>q\\<in>last p. i\\<in>acc q then\n                      RETURN (Some (\\<Union>(set (butlast p)),last p),p,D,pE)\n                    else\n                      RETURN (None,p,D,pE)\n                  } else if v\\<notin>D then do {\n                    \\<comment> \\<open>Edge to new node. Append to path\\<close>\n                    RETURN (None,push v (p,D,pE))\n                  } else RETURN (None,p,D,pE)\n                }\n              | None \\<Rightarrow> do {\n                  \\<comment> \\<open>No more outgoing edges from current node on path\\<close>\n                  ASSERT (pE \\<inter> last p \\<times> UNIV = {});\n                  RETURN (None,pop (p,D,pE))\n                }\n            }) s;\n            ASSERT (brk=None \\<longrightarrow> (p=[] \\<and> pE={}));\n            RETURN (brk,D)\n          } else \n            RETURN (brk,D0)\n      }) (None,D);\n      RETURN brk\n    }\""], ["", "end"], ["", "section \\<open>Invariant Preservation\\<close>"], ["", "context igb_fr_graph\nbegin"], ["", "definition \"fgl_invar_part \\<equiv> \\<lambda>(brk, p, D, pE). \n    fgl_invar_loc_axioms G brk p D pE\""], ["", "lemma fgl_outer_invarI[intro?]:\n    \"\\<lbrakk>\n      brk=None \\<Longrightarrow> outer_invar it D; \n      \\<lbrakk>brk=None \\<Longrightarrow> outer_invar it D\\<rbrakk> \\<Longrightarrow> fgl_outer_invar_ext it (brk,D)\\<rbrakk> \n      \\<Longrightarrow> fgl_outer_invar it (brk,D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>brk = None \\<Longrightarrow> outer_invar it D;\n     (brk = None \\<Longrightarrow> outer_invar it D) \\<Longrightarrow>\n     fgl_outer_invar_ext it (brk, D)\\<rbrakk>\n    \\<Longrightarrow> fgl_outer_invar it (brk, D)", "unfolding outer_invar_def fgl_outer_invar_ext_def fgl_outer_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>brk = None \\<Longrightarrow> outer_invar_loc G it D;\n     (brk = None \\<Longrightarrow> outer_invar_loc G it D) \\<Longrightarrow>\n     case (brk, D) of (None, D) \\<Rightarrow> no_acc_over D\n     | (Some (xa, xb), D) \\<Rightarrow> ce_correct xa xb\\<rbrakk>\n    \\<Longrightarrow> case (brk, D) of\n                      (None, D) \\<Rightarrow>\n                        outer_invar_loc G it D \\<and> no_acc_over D\n                      | (Some (xa, xb), D) \\<Rightarrow> ce_correct xa xb", "apply (auto split: prod.splits option.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fgl_invarI[intro?]:\n    \"\\<lbrakk> invar v0 D0 PDPE; \n       invar v0 D0 PDPE \\<Longrightarrow> fgl_invar_part (B,PDPE)\\<rbrakk> \n     \\<Longrightarrow> fgl_invar v0 D0 (B,PDPE)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar v0 D0 PDPE;\n     invar v0 D0 PDPE \\<Longrightarrow> fgl_invar_part (B, PDPE)\\<rbrakk>\n    \\<Longrightarrow> fgl_invar v0 D0 (B, PDPE)", "unfolding invar_def fgl_invar_part_def fgl_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>case PDPE of\n             (p, xa, xb) \\<Rightarrow> invar_loc G v0 D0 p xa xb;\n     case PDPE of\n     (p, xa, xb) \\<Rightarrow> invar_loc G v0 D0 p xa xb \\<Longrightarrow>\n     case (B, PDPE) of\n     (brk, p, D, pE) \\<Rightarrow>\n       fgl_invar_loc_axioms G brk p D pE\\<rbrakk>\n    \\<Longrightarrow> case (B, PDPE) of\n                      (brk, p, D, pE) \\<Rightarrow>\n                        fgl_invar_loc G v0 D0 brk p D pE", "apply (simp split: prod.split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>PDPE = (x1, x1a, x2a); invar_loc G v0 D0 x1 x1a x2a;\n        x2 = (x1a, x2a); fgl_invar_loc_axioms G B x1 x1a x2a\\<rbrakk>\n       \\<Longrightarrow> fgl_invar_loc G v0 D0 B x1 x1a x2a", "apply intro_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>PDPE = (x1, x1a, x2a); invar_loc G v0 D0 x1 x1a x2a;\n        x2 = (x1a, x2a); fgl_invar_loc_axioms G B x1 x1a x2a\\<rbrakk>\n       \\<Longrightarrow> invar_loc_axioms G v0 D0 x1 x1a x2a\n 2. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>PDPE = (x1, x1a, x2a); invar_loc G v0 D0 x1 x1a x2a;\n        x2 = (x1a, x2a); fgl_invar_loc_axioms G B x1 x1a x2a\\<rbrakk>\n       \\<Longrightarrow> fgl_invar_loc_axioms G B x1 x1a x2a", "apply (simp add: invar_loc_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>PDPE = (x1, x1a, x2a); invar_loc G v0 D0 x1 x1a x2a;\n        x2 = (x1a, x2a); fgl_invar_loc_axioms G B x1 x1a x2a\\<rbrakk>\n       \\<Longrightarrow> fgl_invar_loc_axioms G B x1 x1a x2a", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fgl_invar_initial: \n    assumes OINV: \"fgl_outer_invar it (None,D0)\"\n    assumes A: \"v0\\<in>it\" \"v0\\<notin>D0\"\n    shows \"fgl_invar_part (None, initial v0 D0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, initial v0 D0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, initial v0 D0)", "from OINV"], ["proof (chain)\npicking this:\n  fgl_outer_invar it (None, D0)", "interpret outer_invar_loc G it D0"], ["proof (prove)\nusing this:\n  fgl_outer_invar it (None, D0)\n\ngoal (1 subgoal):\n 1. outer_invar_loc G it D0", "by (simp add: fgl_outer_invar_def outer_invar_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, initial v0 D0)", "from OINV"], ["proof (chain)\npicking this:\n  fgl_outer_invar it (None, D0)", "have no_acc: \"no_acc_over D0\""], ["proof (prove)\nusing this:\n  fgl_outer_invar it (None, D0)\n\ngoal (1 subgoal):\n 1. no_acc_over D0", "by (simp add: fgl_outer_invar_def fgl_outer_invar_ext_def)"], ["proof (state)\nthis:\n  no_acc_over D0\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, initial v0 D0)", "{"], ["proof (state)\nthis:\n  no_acc_over D0\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, initial v0 D0)", "fix v pl"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, initial v0 D0)", "assume \"pl \\<noteq> []\" and P: \"path (vE [{v0}] D0 (E \\<inter> {v0} \\<times> UNIV)) v pl v\""], ["proof (state)\nthis:\n  pl \\<noteq> []\n  path (vE [{v0}] D0 (E \\<inter> {v0} \\<times> UNIV)) v pl v\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, initial v0 D0)", "hence 1: \"v\\<in>D0\""], ["proof (prove)\nusing this:\n  pl \\<noteq> []\n  path (vE [{v0}] D0 (E \\<inter> {v0} \\<times> UNIV)) v pl v\n\ngoal (1 subgoal):\n 1. v \\<in> D0", "by (cases pl) (auto simp: path_cons_conv vE_def touched_def)"], ["proof (state)\nthis:\n  v \\<in> D0\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, initial v0 D0)", "have 2: \"path E v pl v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path E v pl v", "using path_mono[OF vE_ss_E P]"], ["proof (prove)\nusing this:\n  path E v pl v\n\ngoal (1 subgoal):\n 1. path E v pl v", "."], ["proof (state)\nthis:\n  path E v pl v\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, initial v0 D0)", "note 1 2"], ["proof (state)\nthis:\n  v \\<in> D0\n  path E v pl v\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, initial v0 D0)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?pl5 \\<noteq> [];\n   path (vE [{v0}] D0 (E \\<inter> {v0} \\<times> UNIV)) ?v5 ?pl5 ?v5\\<rbrakk>\n  \\<Longrightarrow> ?v5 \\<in> D0\n  \\<lbrakk>?pl5 \\<noteq> [];\n   path (vE [{v0}] D0 (E \\<inter> {v0} \\<times> UNIV)) ?v5 ?pl5 ?v5\\<rbrakk>\n  \\<Longrightarrow> path E ?v5 ?pl5 ?v5\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, initial v0 D0)", "note AUX1=this"], ["proof (state)\nthis:\n  \\<lbrakk>?pl5 \\<noteq> [];\n   path (vE [{v0}] D0 (E \\<inter> {v0} \\<times> UNIV)) ?v5 ?pl5 ?v5\\<rbrakk>\n  \\<Longrightarrow> ?v5 \\<in> D0\n  \\<lbrakk>?pl5 \\<noteq> [];\n   path (vE [{v0}] D0 (E \\<inter> {v0} \\<times> UNIV)) ?v5 ?pl5 ?v5\\<rbrakk>\n  \\<Longrightarrow> path E ?v5 ?pl5 ?v5\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, initial v0 D0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, initial v0 D0)", "unfolding fgl_invar_part_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case (None, initial v0 D0) of\n    (brk, p, D, pE) \\<Rightarrow> fgl_invar_loc_axioms G brk p D pE", "apply (simp split: prod.splits add: initial_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_invar_loc_axioms G None [{v0}] D0 (E \\<inter> {v0} \\<times> UNIV)", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. None = None \\<Longrightarrow>\n    \\<nexists>v pl.\n       pl \\<noteq> [] \\<and>\n       path (vE [{v0}] D0 (E \\<inter> {v0} \\<times> UNIV)) v pl v \\<and>\n       (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\n 2. \\<And>Vr Vl. None = Some (Vr, Vl) \\<Longrightarrow> ce_correct Vr Vl", "using \\<open>v0\\<notin>D0\\<close>"], ["proof (prove)\nusing this:\n  v0 \\<notin> D0\n\ngoal (2 subgoals):\n 1. None = None \\<Longrightarrow>\n    \\<nexists>v pl.\n       pl \\<noteq> [] \\<and>\n       path (vE [{v0}] D0 (E \\<inter> {v0} \\<times> UNIV)) v pl v \\<and>\n       (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\n 2. \\<And>Vr Vl. None = Some (Vr, Vl) \\<Longrightarrow> ce_correct Vr Vl", "using AUX1 no_acc"], ["proof (prove)\nusing this:\n  v0 \\<notin> D0\n  \\<lbrakk>?pl5 \\<noteq> [];\n   path (vE [{v0}] D0 (E \\<inter> {v0} \\<times> UNIV)) ?v5 ?pl5 ?v5\\<rbrakk>\n  \\<Longrightarrow> ?v5 \\<in> D0\n  \\<lbrakk>?pl5 \\<noteq> [];\n   path (vE [{v0}] D0 (E \\<inter> {v0} \\<times> UNIV)) ?v5 ?pl5 ?v5\\<rbrakk>\n  \\<Longrightarrow> path E ?v5 ?pl5 ?v5\n  no_acc_over D0\n\ngoal (2 subgoals):\n 1. None = None \\<Longrightarrow>\n    \\<nexists>v pl.\n       pl \\<noteq> [] \\<and>\n       path (vE [{v0}] D0 (E \\<inter> {v0} \\<times> UNIV)) v pl v \\<and>\n       (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\n 2. \\<And>Vr Vl. None = Some (Vr, Vl) \\<Longrightarrow> ce_correct Vr Vl", "unfolding no_acc_over_def"], ["proof (prove)\nusing this:\n  v0 \\<notin> D0\n  \\<lbrakk>?pl5 \\<noteq> [];\n   path (vE [{v0}] D0 (E \\<inter> {v0} \\<times> UNIV)) ?v5 ?pl5 ?v5\\<rbrakk>\n  \\<Longrightarrow> ?v5 \\<in> D0\n  \\<lbrakk>?pl5 \\<noteq> [];\n   path (vE [{v0}] D0 (E \\<inter> {v0} \\<times> UNIV)) ?v5 ?pl5 ?v5\\<rbrakk>\n  \\<Longrightarrow> path E ?v5 ?pl5 ?v5\n  \\<not> (\\<exists>v\\<in>D0.\n             \\<exists>pl.\n                pl \\<noteq> [] \\<and>\n                path E v pl v \\<and>\n                (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q))\n\ngoal (2 subgoals):\n 1. None = None \\<Longrightarrow>\n    \\<nexists>v pl.\n       pl \\<noteq> [] \\<and>\n       path (vE [{v0}] D0 (E \\<inter> {v0} \\<times> UNIV)) v pl v \\<and>\n       (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\n 2. \\<And>Vr Vl. None = Some (Vr, Vl) \\<Longrightarrow> ce_correct Vr Vl", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Vr Vl. None = Some (Vr, Vl) \\<Longrightarrow> ce_correct Vr Vl", "by simp"], ["proof (state)\nthis:\n  fgl_invar_part (None, initial v0 D0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fgl_invar_pop:\n    assumes INV: \"fgl_invar v0 D0 (None,p,D,pE)\"\n    assumes INV': \"invar v0 D0 (pop (p,D,pE))\"\n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes NO': \"pE \\<inter> last p \\<times> UNIV = {}\"\n    shows \"fgl_invar_part (None, pop (p,D,pE))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, pop (p, D, pE))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, pop (p, D, pE))", "from INV"], ["proof (chain)\npicking this:\n  fgl_invar v0 D0 (None, p, D, pE)", "interpret fgl_invar_loc G v0 D0 None p D pE"], ["proof (prove)\nusing this:\n  fgl_invar v0 D0 (None, p, D, pE)\n\ngoal (1 subgoal):\n 1. fgl_invar_loc G v0 D0 None p D pE", "by (simp add: fgl_invar_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, pop (p, D, pE))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, pop (p, D, pE))", "apply (unfold fgl_invar_part_def pop_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. case (None,\n          let (p, D, pE) = (p, D, pE); (p, V) = (butlast p, last p);\n              D = V \\<union> D\n          in (p, D, pE)) of\n    (brk, p, D, pE) \\<Rightarrow> fgl_invar_loc_axioms G brk p D pE", "apply (simp split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_invar_loc_axioms G None (butlast p) (last p \\<union> D) pE", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. None = None \\<Longrightarrow>\n    \\<nexists>v pl.\n       pl \\<noteq> [] \\<and>\n       path (vE (butlast p) (last p \\<union> D) pE) v pl v \\<and>\n       (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\n 2. \\<And>Vr Vl. None = Some (Vr, Vl) \\<Longrightarrow> ce_correct Vr Vl", "unfolding vE_pop[OF NE]"], ["proof (prove)\ngoal (2 subgoals):\n 1. None = None \\<Longrightarrow>\n    \\<nexists>v pl.\n       pl \\<noteq> [] \\<and>\n       path lvE v pl v \\<and>\n       (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\n 2. \\<And>Vr Vl. None = Some (Vr, Vl) \\<Longrightarrow> ce_correct Vr Vl", "using no_acc"], ["proof (prove)\nusing this:\n  None = None \\<Longrightarrow>\n  \\<nexists>v pl.\n     pl \\<noteq> [] \\<and>\n     path lvE v pl v \\<and>\n     (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\n\ngoal (2 subgoals):\n 1. None = None \\<Longrightarrow>\n    \\<nexists>v pl.\n       pl \\<noteq> [] \\<and>\n       path lvE v pl v \\<and>\n       (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\n 2. \\<And>Vr Vl. None = Some (Vr, Vl) \\<Longrightarrow> ce_correct Vr Vl", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Vr Vl. None = Some (Vr, Vl) \\<Longrightarrow> ce_correct Vr Vl", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fgl_invar_part (None, pop (p, D, pE))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fgl_invar_collapse_ce_aux:\n    assumes INV: \"invar v0 D0 (p, D, pE)\"\n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes NONTRIV: \"vE p D pE \\<inter> (last p \\<times> last p) \\<noteq> {}\"\n    assumes ACC: \"\\<forall>i<num_acc. \\<exists>q\\<in>last p. i\\<in>acc q\"\n    shows \"fgl_invar_part (Some (\\<Union>(set (butlast p)), last p), p, D, pE)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_invar_part (Some (\\<Union> (set (butlast p)), last p), p, D, pE)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part (Some (\\<Union> (set (butlast p)), last p), p, D, pE)", "from INV"], ["proof (chain)\npicking this:\n  invar v0 D0 (p, D, pE)", "interpret invar_loc G v0 D0 p D pE"], ["proof (prove)\nusing this:\n  invar v0 D0 (p, D, pE)\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D pE", "by (simp add: invar_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part (Some (\\<Union> (set (butlast p)), last p), p, D, pE)", "txt \\<open>The last collapsed node on the path contains states from all \n      accepting sets.\n      As it is strongly connected and reachable, we get a counter-example. \n      Here, we explicitely construct the lasso.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part (Some (\\<Union> (set (butlast p)), last p), p, D, pE)", "let ?Er = \"E \\<inter> (\\<Union>(set (butlast p)) \\<times> UNIV)\""], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part (Some (\\<Union> (set (butlast p)), last p), p, D, pE)", "txt \\<open>We choose a node in the last Cnode, that is reachable only using\n      former Cnodes.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part (Some (\\<Union> (set (butlast p)), last p), p, D, pE)", "obtain w where \"(v0,w)\\<in>?Er\\<^sup>*\" \"w\\<in>last p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>(v0, w)\n                 \\<in> (E \\<inter>\n                        \\<Union> (set (butlast p)) \\<times> UNIV)\\<^sup>*;\n         w \\<in> last p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>w.\n                \\<lbrakk>(v0, w)\n                         \\<in> (E \\<inter>\n                                \\<Union> (set (butlast p)) \\<times>\n                                UNIV)\\<^sup>*;\n                 w \\<in> last p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     ?P5\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>w.\n                \\<lbrakk>(v0, w)\n                         \\<in> (E \\<inter>\n                                \\<Union> (set (butlast p)) \\<times>\n                                UNIV)\\<^sup>*;\n                 w \\<in> last p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> ?P5\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume \"length p = 1\""], ["proof (state)\nthis:\n  length p = 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>w.\n                \\<lbrakk>(v0, w)\n                         \\<in> (E \\<inter>\n                                \\<Union> (set (butlast p)) \\<times>\n                                UNIV)\\<^sup>*;\n                 w \\<in> last p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     ?P5\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>w.\n                \\<lbrakk>(v0, w)\n                         \\<in> (E \\<inter>\n                                \\<Union> (set (butlast p)) \\<times>\n                                UNIV)\\<^sup>*;\n                 w \\<in> last p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> ?P5\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"v0\\<in>last p\""], ["proof (prove)\nusing this:\n  length p = 1\n\ngoal (1 subgoal):\n 1. v0 \\<in> last p", "using root_v0"], ["proof (prove)\nusing this:\n  length p = 1\n  p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p\n\ngoal (1 subgoal):\n 1. v0 \\<in> last p", "by (cases p) auto"], ["proof (state)\nthis:\n  v0 \\<in> last p\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>w.\n                \\<lbrakk>(v0, w)\n                         \\<in> (E \\<inter>\n                                \\<Union> (set (butlast p)) \\<times>\n                                UNIV)\\<^sup>*;\n                 w \\<in> last p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     ?P5\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>w.\n                \\<lbrakk>(v0, w)\n                         \\<in> (E \\<inter>\n                                \\<Union> (set (butlast p)) \\<times>\n                                UNIV)\\<^sup>*;\n                 w \\<in> last p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<not> ?P5\\<rbrakk>\n    \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  v0 \\<in> last p\n\ngoal (1 subgoal):\n 1. thesis", "by (auto intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>w.\n                \\<lbrakk>(v0, w)\n                         \\<in> (E \\<inter>\n                                \\<Union> (set (butlast p)) \\<times>\n                                UNIV)\\<^sup>*;\n                 w \\<in> last p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     length p \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>w.\n                \\<lbrakk>(v0, w)\n                         \\<in> (E \\<inter>\n                                \\<Union> (set (butlast p)) \\<times>\n                                UNIV)\\<^sup>*;\n                 w \\<in> last p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     length p \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume \"length p\\<noteq>1\""], ["proof (state)\nthis:\n  length p \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>w.\n                \\<lbrakk>(v0, w)\n                         \\<in> (E \\<inter>\n                                \\<Union> (set (butlast p)) \\<times>\n                                UNIV)\\<^sup>*;\n                 w \\<in> last p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     length p \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"length p > 1\""], ["proof (prove)\nusing this:\n  length p \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 1 < length p", "by (cases p) auto"], ["proof (state)\nthis:\n  1 < length p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>w.\n                \\<lbrakk>(v0, w)\n                         \\<in> (E \\<inter>\n                                \\<Union> (set (butlast p)) \\<times>\n                                UNIV)\\<^sup>*;\n                 w \\<in> last p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     length p \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"Suc (length p - 2) < length p\""], ["proof (prove)\nusing this:\n  1 < length p\n\ngoal (1 subgoal):\n 1. Suc (length p - 2) < length p", "by auto"], ["proof (state)\nthis:\n  Suc (length p - 2) < length p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>w.\n                \\<lbrakk>(v0, w)\n                         \\<in> (E \\<inter>\n                                \\<Union> (set (butlast p)) \\<times>\n                                UNIV)\\<^sup>*;\n                 w \\<in> last p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     length p \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "from p_connected'[OF this]"], ["proof (chain)\npicking this:\n  p ! (length p - 2) \\<times> p ! Suc (length p - 2) \\<inter> lvE \\<noteq>\n  {}", "obtain u v where\n        UIP: \"u\\<in>p!(length p - 2)\" and VIP: \"v\\<in>p!(length p - 1)\" and \"(u,v)\\<in>lvE\""], ["proof (prove)\nusing this:\n  p ! (length p - 2) \\<times> p ! Suc (length p - 2) \\<inter> lvE \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> p ! (length p - 2); v \\<in> p ! (length p - 1);\n         (u, v) \\<in> lvE\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>length p > 1\\<close>"], ["proof (prove)\nusing this:\n  p ! (length p - 2) \\<times> p ! Suc (length p - 2) \\<inter> lvE \\<noteq>\n  {}\n  1 < length p\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>u \\<in> p ! (length p - 2); v \\<in> p ! (length p - 1);\n         (u, v) \\<in> lvE\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u \\<in> p ! (length p - 2)\n  v \\<in> p ! (length p - 1)\n  (u, v) \\<in> lvE\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>w.\n                \\<lbrakk>(v0, w)\n                         \\<in> (E \\<inter>\n                                \\<Union> (set (butlast p)) \\<times>\n                                UNIV)\\<^sup>*;\n                 w \\<in> last p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     length p \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "from root_v0"], ["proof (chain)\npicking this:\n  p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p", "have V0IP: \"v0\\<in>p!0\""], ["proof (prove)\nusing this:\n  p \\<noteq> [] \\<Longrightarrow> v0 \\<in> hd p\n\ngoal (1 subgoal):\n 1. v0 \\<in> p ! 0", "by (cases p) auto"], ["proof (state)\nthis:\n  v0 \\<in> p ! 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>w.\n                \\<lbrakk>(v0, w)\n                         \\<in> (E \\<inter>\n                                \\<Union> (set (butlast p)) \\<times>\n                                UNIV)\\<^sup>*;\n                 w \\<in> last p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     length p \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "from VIP"], ["proof (chain)\npicking this:\n  v \\<in> p ! (length p - 1)", "have \"v\\<in>last p\""], ["proof (prove)\nusing this:\n  v \\<in> p ! (length p - 1)\n\ngoal (1 subgoal):\n 1. v \\<in> last p", "by (cases p rule: rev_cases) auto"], ["proof (state)\nthis:\n  v \\<in> last p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>w.\n                \\<lbrakk>(v0, w)\n                         \\<in> (E \\<inter>\n                                \\<Union> (set (butlast p)) \\<times>\n                                UNIV)\\<^sup>*;\n                 w \\<in> last p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     length p \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "from pathI[OF V0IP UIP] \\<open>length p > 1\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> length p - 2; length p - 2 < length p\\<rbrakk>\n  \\<Longrightarrow> (v0, u)\n                    \\<in> (Restr lvE\n                            (path_seg p 0 (Suc (length p - 2))))\\<^sup>*\n  1 < length p", "have \n        \"(v0,u)\\<in>(lvE \\<inter> \\<Union>(set (butlast p)) \\<times> \\<Union>(set (butlast p)))\\<^sup>*\"\n        (is \"_ \\<in> \\<dots>\\<^sup>*\")"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> length p - 2; length p - 2 < length p\\<rbrakk>\n  \\<Longrightarrow> (v0, u)\n                    \\<in> (Restr lvE\n                            (path_seg p 0 (Suc (length p - 2))))\\<^sup>*\n  1 < length p\n\ngoal (1 subgoal):\n 1. (v0, u) \\<in> (Restr lvE (\\<Union> (set (butlast p))))\\<^sup>*", "by (simp add: path_seg_butlast)"], ["proof (state)\nthis:\n  (v0, u) \\<in> (Restr lvE (\\<Union> (set (butlast p))))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>w.\n                \\<lbrakk>(v0, w)\n                         \\<in> (E \\<inter>\n                                \\<Union> (set (butlast p)) \\<times>\n                                UNIV)\\<^sup>*;\n                 w \\<in> last p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     length p \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  (v0, u) \\<in> (Restr lvE (\\<Union> (set (butlast p))))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>w.\n                \\<lbrakk>(v0, w)\n                         \\<in> (E \\<inter>\n                                \\<Union> (set (butlast p)) \\<times>\n                                UNIV)\\<^sup>*;\n                 w \\<in> last p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     length p \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"\\<dots> \\<subseteq> ?Er\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Restr lvE (\\<Union> (set (butlast p)))\n    \\<subseteq> E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV", "using lvE_ss_E"], ["proof (prove)\nusing this:\n  lvE \\<subseteq> E\n\ngoal (1 subgoal):\n 1. Restr lvE (\\<Union> (set (butlast p)))\n    \\<subseteq> E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV", "by auto"], ["proof (state)\nthis:\n  Restr lvE (\\<Union> (set (butlast p)))\n  \\<subseteq> E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>w.\n                \\<lbrakk>(v0, w)\n                         \\<in> (E \\<inter>\n                                \\<Union> (set (butlast p)) \\<times>\n                                UNIV)\\<^sup>*;\n                 w \\<in> last p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     length p \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "finally (rtrancl_mono_mp[rotated])"], ["proof (chain)\npicking this:\n  (v0, u)\n  \\<in> (E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV)\\<^sup>*", "have \"(v0,u)\\<in>?Er\\<^sup>*\""], ["proof (prove)\nusing this:\n  (v0, u)\n  \\<in> (E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (v0, u)\n    \\<in> (E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV)\\<^sup>*", "."], ["proof (state)\nthis:\n  (v0, u)\n  \\<in> (E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>w.\n                \\<lbrakk>(v0, w)\n                         \\<in> (E \\<inter>\n                                \\<Union> (set (butlast p)) \\<times>\n                                UNIV)\\<^sup>*;\n                 w \\<in> last p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     length p \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "also"], ["proof (state)\nthis:\n  (v0, u)\n  \\<in> (E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>w.\n                \\<lbrakk>(v0, w)\n                         \\<in> (E \\<inter>\n                                \\<Union> (set (butlast p)) \\<times>\n                                UNIV)\\<^sup>*;\n                 w \\<in> last p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     length p \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "note \\<open>(u,v)\\<in>lvE\\<close> UIP"], ["proof (state)\nthis:\n  (u, v) \\<in> lvE\n  u \\<in> p ! (length p - 2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>w.\n                \\<lbrakk>(v0, w)\n                         \\<in> (E \\<inter>\n                                \\<Union> (set (butlast p)) \\<times>\n                                UNIV)\\<^sup>*;\n                 w \\<in> last p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     length p \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"(u,v)\\<in>?Er\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> lvE\n  u \\<in> p ! (length p - 2)\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV", "using lvE_ss_E \\<open>length p > 1\\<close>"], ["proof (prove)\nusing this:\n  (u, v) \\<in> lvE\n  u \\<in> p ! (length p - 2)\n  lvE \\<subseteq> E\n  1 < length p\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV", "apply (auto simp: Bex_def in_set_conv_nth)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(u, v) \\<in> lvE; u \\<in> p ! (length p - 2);\n     lvE \\<subseteq> E; Suc 0 < length p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         (\\<exists>i<length p - Suc 0.\n                             butlast p ! i = x) \\<and>\n                         u \\<in> x", "by (metis One_nat_def Suc_lessE \\<open>Suc (length p - 2) < length p\\<close> \n          diff_Suc_1 length_butlast nth_butlast)"], ["proof (state)\nthis:\n  (u, v) \\<in> E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>w.\n                \\<lbrakk>(v0, w)\n                         \\<in> (E \\<inter>\n                                \\<Union> (set (butlast p)) \\<times>\n                                UNIV)\\<^sup>*;\n                 w \\<in> last p\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     length p \\<noteq> 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "finally"], ["proof (chain)\npicking this:\n  (v0, v)\n  \\<in> (E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV)\\<^sup>*", "show ?thesis"], ["proof (prove)\nusing this:\n  (v0, v)\n  \\<in> (E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV)\\<^sup>*\n\ngoal (1 subgoal):\n 1. thesis", "by (rule that) fact"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (v0, w)\n  \\<in> (E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV)\\<^sup>*\n  w \\<in> last p\n\ngoal (1 subgoal):\n 1. fgl_invar_part (Some (\\<Union> (set (butlast p)), last p), p, D, pE)", "then"], ["proof (chain)\npicking this:\n  (v0, w)\n  \\<in> (E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV)\\<^sup>*\n  w \\<in> last p", "obtain \"pr\" where \n      P_REACH: \"path E v0 pr w\" and \n      R_SS: \"set pr \\<subseteq> \\<Union>(set (butlast p))\""], ["proof (prove)\nusing this:\n  (v0, w)\n  \\<in> (E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV)\\<^sup>*\n  w \\<in> last p\n\ngoal (1 subgoal):\n 1. (\\<And>pr.\n        \\<lbrakk>path E v0 pr w;\n         set pr \\<subseteq> \\<Union> (set (butlast p))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>pr.\n                \\<lbrakk>path E v0 pr w;\n                 set pr \\<subseteq> \\<Union> (set (butlast p))\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (v0, w)\n     \\<in> (E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV)\\<^sup>*;\n     w \\<in> last p\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (erule rtrancl_is_path)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<And>pr.\n                   \\<lbrakk>path E v0 pr w;\n                    set pr \\<subseteq> \\<Union> (set (butlast p))\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        w \\<in> last p;\n        path (E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV) v0 l\n         w\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (frule path_nodes_edges)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>\\<And>pr.\n                   \\<lbrakk>path E v0 pr w;\n                    set pr \\<subseteq> \\<Union> (set (butlast p))\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        w \\<in> last p;\n        path (E \\<inter> \\<Union> (set (butlast p)) \\<times> UNIV) v0 l w;\n        set l\n        \\<subseteq> fst `\n                    (E \\<inter>\n                     \\<Union> (set (butlast p)) \\<times> UNIV)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (auto \n        dest!: order_trans[OF _ image_Int_subset] \n        dest: path_mono[of _ E, rotated])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  path E v0 pr w\n  set pr \\<subseteq> \\<Union> (set (butlast p))\n\ngoal (1 subgoal):\n 1. fgl_invar_part (Some (\\<Union> (set (butlast p)), last p), p, D, pE)", "have [simp]: \"last p = p!(length p - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last p = p ! (length p - 1)", "by (cases p rule: rev_cases) auto"], ["proof (state)\nthis:\n  last p = p ! (length p - 1)\n\ngoal (1 subgoal):\n 1. fgl_invar_part (Some (\\<Union> (set (butlast p)), last p), p, D, pE)", "txt \\<open>From that node, we construct a lasso by inductively appending a path\n      for each accepting set\\<close>"], ["proof (state)\nthis:\n  last p = p ! (length p - 1)\n\ngoal (1 subgoal):\n 1. fgl_invar_part (Some (\\<Union> (set (butlast p)), last p), p, D, pE)", "{"], ["proof (state)\nthis:\n  last p = p ! (length p - 1)\n\ngoal (1 subgoal):\n 1. fgl_invar_part (Some (\\<Union> (set (butlast p)), last p), p, D, pE)", "fix na"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part (Some (\\<Union> (set (butlast p)), last p), p, D, pE)", "assume na_def: \"na = num_acc\""], ["proof (state)\nthis:\n  na = num_acc\n\ngoal (1 subgoal):\n 1. fgl_invar_part (Some (\\<Union> (set (butlast p)), last p), p, D, pE)", "have \"\\<exists>pl. pl\\<noteq>[] \n        \\<and> path (lvE \\<inter> last p\\<times>last p) w pl w \n        \\<and> (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i\\<in>acc q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>pl.\n       pl \\<noteq> [] \\<and>\n       path (Restr lvE (last p)) w pl w \\<and>\n       (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)", "using ACC"], ["proof (prove)\nusing this:\n  \\<forall>i<num_acc. \\<exists>q\\<in>last p. i \\<in> acc q\n\ngoal (1 subgoal):\n 1. \\<exists>pl.\n       pl \\<noteq> [] \\<and>\n       path (Restr lvE (last p)) w pl w \\<and>\n       (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)", "unfolding na_def[symmetric]"], ["proof (prove)\nusing this:\n  \\<forall>i<na. \\<exists>q\\<in>last p. i \\<in> acc q\n\ngoal (1 subgoal):\n 1. \\<exists>pl.\n       pl \\<noteq> [] \\<and>\n       path (Restr lvE (last p)) w pl w \\<and>\n       (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q)", "proof (induction na)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i<0. \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n    \\<exists>pl.\n       pl \\<noteq> [] \\<and>\n       path (Restr lvE (last p)) w pl w \\<and>\n       (\\<forall>i<0. \\<exists>q\\<in>set pl. i \\<in> acc q)\n 2. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "case 0"], ["proof (state)\nthis:\n  \\<forall>i<0. \\<exists>q\\<in>last p. i \\<in> acc q\n\ngoal (2 subgoals):\n 1. \\<forall>i<0. \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n    \\<exists>pl.\n       pl \\<noteq> [] \\<and>\n       path (Restr lvE (last p)) w pl w \\<and>\n       (\\<forall>i<0. \\<exists>q\\<in>set pl. i \\<in> acc q)\n 2. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "from NONTRIV"], ["proof (chain)\npicking this:\n  Restr lvE (last p) \\<noteq> {}", "obtain u v \n          where \"(u,v)\\<in>lvE \\<inter> last p \\<times> last p\" \"u\\<in>last p\" \"v\\<in>last p\""], ["proof (prove)\nusing this:\n  Restr lvE (last p) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        \\<lbrakk>(u, v) \\<in> Restr lvE (last p); u \\<in> last p;\n         v \\<in> last p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (u, v) \\<in> Restr lvE (last p)\n  u \\<in> last p\n  v \\<in> last p\n\ngoal (2 subgoals):\n 1. \\<forall>i<0. \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n    \\<exists>pl.\n       pl \\<noteq> [] \\<and>\n       path (Restr lvE (last p)) w pl w \\<and>\n       (\\<forall>i<0. \\<exists>q\\<in>set pl. i \\<in> acc q)\n 2. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "from cnode_connectedI \\<open>w\\<in>last p\\<close> \\<open>u\\<in>last p\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i < length p; ?u \\<in> p ! ?i; ?v \\<in> p ! ?i\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> (Restr lvE (p ! ?i))\\<^sup>*\n  w \\<in> last p\n  u \\<in> last p", "have \"(w,u)\\<in>(lvE \\<inter> last p \\<times> last p)\\<^sup>*\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length p; ?u \\<in> p ! ?i; ?v \\<in> p ! ?i\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> (Restr lvE (p ! ?i))\\<^sup>*\n  w \\<in> last p\n  u \\<in> last p\n\ngoal (1 subgoal):\n 1. (w, u) \\<in> (Restr lvE (last p))\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (w, u) \\<in> (Restr lvE (last p))\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<forall>i<0. \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n    \\<exists>pl.\n       pl \\<noteq> [] \\<and>\n       path (Restr lvE (last p)) w pl w \\<and>\n       (\\<forall>i<0. \\<exists>q\\<in>set pl. i \\<in> acc q)\n 2. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "also"], ["proof (state)\nthis:\n  (w, u) \\<in> (Restr lvE (last p))\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<forall>i<0. \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n    \\<exists>pl.\n       pl \\<noteq> [] \\<and>\n       path (Restr lvE (last p)) w pl w \\<and>\n       (\\<forall>i<0. \\<exists>q\\<in>set pl. i \\<in> acc q)\n 2. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "note \\<open>(u,v)\\<in>lvE \\<inter> last p \\<times> last p\\<close>"], ["proof (state)\nthis:\n  (u, v) \\<in> Restr lvE (last p)\n\ngoal (2 subgoals):\n 1. \\<forall>i<0. \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n    \\<exists>pl.\n       pl \\<noteq> [] \\<and>\n       path (Restr lvE (last p)) w pl w \\<and>\n       (\\<forall>i<0. \\<exists>q\\<in>set pl. i \\<in> acc q)\n 2. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "also (rtrancl_into_trancl1)"], ["proof (state)\nthis:\n  (u, v) \\<in> Restr lvE (last p)\n\ngoal (2 subgoals):\n 1. \\<forall>i<0. \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n    \\<exists>pl.\n       pl \\<noteq> [] \\<and>\n       path (Restr lvE (last p)) w pl w \\<and>\n       (\\<forall>i<0. \\<exists>q\\<in>set pl. i \\<in> acc q)\n 2. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "from cnode_connectedI \\<open>v\\<in>last p\\<close> \\<open>w\\<in>last p\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i < length p; ?u \\<in> p ! ?i; ?v \\<in> p ! ?i\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> (Restr lvE (p ! ?i))\\<^sup>*\n  v \\<in> last p\n  w \\<in> last p", "have \"(v,w)\\<in>(lvE \\<inter> last p \\<times> last p)\\<^sup>*\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length p; ?u \\<in> p ! ?i; ?v \\<in> p ! ?i\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> (Restr lvE (p ! ?i))\\<^sup>*\n  v \\<in> last p\n  w \\<in> last p\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> (Restr lvE (last p))\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (v, w) \\<in> (Restr lvE (last p))\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<forall>i<0. \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n    \\<exists>pl.\n       pl \\<noteq> [] \\<and>\n       path (Restr lvE (last p)) w pl w \\<and>\n       (\\<forall>i<0. \\<exists>q\\<in>set pl. i \\<in> acc q)\n 2. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "finally"], ["proof (chain)\npicking this:\n  (w, w) \\<in> (Restr lvE (last p))\\<^sup>+", "obtain pl where \"pl\\<noteq>[]\" \"path (lvE \\<inter> last p \\<times> last p) w pl w\""], ["proof (prove)\nusing this:\n  (w, w) \\<in> (Restr lvE (last p))\\<^sup>+\n\ngoal (1 subgoal):\n 1. (\\<And>pl.\n        \\<lbrakk>pl \\<noteq> []; path (Restr lvE (last p)) w pl w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule trancl_is_path)"], ["proof (state)\nthis:\n  pl \\<noteq> []\n  path (Restr lvE (last p)) w pl w\n\ngoal (2 subgoals):\n 1. \\<forall>i<0. \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n    \\<exists>pl.\n       pl \\<noteq> [] \\<and>\n       path (Restr lvE (last p)) w pl w \\<and>\n       (\\<forall>i<0. \\<exists>q\\<in>set pl. i \\<in> acc q)\n 2. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "thus ?case"], ["proof (prove)\nusing this:\n  pl \\<noteq> []\n  path (Restr lvE (last p)) w pl w\n\ngoal (1 subgoal):\n 1. \\<exists>pl.\n       pl \\<noteq> [] \\<and>\n       path (Restr lvE (last p)) w pl w \\<and>\n       (\\<forall>i<0. \\<exists>q\\<in>set pl. i \\<in> acc q)", "by auto"], ["proof (state)\nthis:\n  \\<exists>pl.\n     pl \\<noteq> [] \\<and>\n     path (Restr lvE (last p)) w pl w \\<and>\n     (\\<forall>i<0. \\<exists>q\\<in>set pl. i \\<in> acc q)\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "case (Suc n)"], ["proof (state)\nthis:\n  \\<forall>i<n. \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n  \\<exists>pl.\n     pl \\<noteq> [] \\<and>\n     path (Restr lvE (last p)) w pl w \\<and>\n     (\\<forall>i<n. \\<exists>q\\<in>set pl. i \\<in> acc q)\n  \\<forall>i<Suc n. \\<exists>q\\<in>last p. i \\<in> acc q\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "from Suc.prems"], ["proof (chain)\npicking this:\n  \\<forall>i<Suc n. \\<exists>q\\<in>last p. i \\<in> acc q", "have \"\\<forall>i<n. \\<exists>q\\<in>last p. i\\<in>acc q\""], ["proof (prove)\nusing this:\n  \\<forall>i<Suc n. \\<exists>q\\<in>last p. i \\<in> acc q\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. \\<exists>q\\<in>last p. i \\<in> acc q", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<n. \\<exists>q\\<in>last p. i \\<in> acc q\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "with Suc.IH"], ["proof (chain)\npicking this:\n  \\<forall>i<n. \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n  \\<exists>pl.\n     pl \\<noteq> [] \\<and>\n     path (Restr lvE (last p)) w pl w \\<and>\n     (\\<forall>i<n. \\<exists>q\\<in>set pl. i \\<in> acc q)\n  \\<forall>i<n. \\<exists>q\\<in>last p. i \\<in> acc q", "obtain pl where IH: \n          \"pl\\<noteq>[]\" \n          \"path (lvE \\<inter> last p \\<times> last p) w pl w\" \n          \"\\<forall>i<n. \\<exists>q\\<in>set pl. i\\<in>acc q\""], ["proof (prove)\nusing this:\n  \\<forall>i<n. \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n  \\<exists>pl.\n     pl \\<noteq> [] \\<and>\n     path (Restr lvE (last p)) w pl w \\<and>\n     (\\<forall>i<n. \\<exists>q\\<in>set pl. i \\<in> acc q)\n  \\<forall>i<n. \\<exists>q\\<in>last p. i \\<in> acc q\n\ngoal (1 subgoal):\n 1. (\\<And>pl.\n        \\<lbrakk>pl \\<noteq> []; path (Restr lvE (last p)) w pl w;\n         \\<forall>i<n. \\<exists>q\\<in>set pl. i \\<in> acc q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  pl \\<noteq> []\n  path (Restr lvE (last p)) w pl w\n  \\<forall>i<n. \\<exists>q\\<in>set pl. i \\<in> acc q\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "from Suc.prems"], ["proof (chain)\npicking this:\n  \\<forall>i<Suc n. \\<exists>q\\<in>last p. i \\<in> acc q", "obtain v where \"v\\<in>last p\" and \"n\\<in>acc v\""], ["proof (prove)\nusing this:\n  \\<forall>i<Suc n. \\<exists>q\\<in>last p. i \\<in> acc q\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> last p; n \\<in> acc v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<in> last p\n  n \\<in> acc v\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "from cnode_connectedI \\<open>w\\<in>last p\\<close> \\<open>v\\<in>last p\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i < length p; ?u \\<in> p ! ?i; ?v \\<in> p ! ?i\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> (Restr lvE (p ! ?i))\\<^sup>*\n  w \\<in> last p\n  v \\<in> last p", "have \"(w,v)\\<in>(lvE \\<inter> last p \\<times> last p)\\<^sup>*\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length p; ?u \\<in> p ! ?i; ?v \\<in> p ! ?i\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> (Restr lvE (p ! ?i))\\<^sup>*\n  w \\<in> last p\n  v \\<in> last p\n\ngoal (1 subgoal):\n 1. (w, v) \\<in> (Restr lvE (last p))\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (w, v) \\<in> (Restr lvE (last p))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "then"], ["proof (chain)\npicking this:\n  (w, v) \\<in> (Restr lvE (last p))\\<^sup>*", "obtain pl1 where P1: \"path (lvE \\<inter> last p \\<times> last p) w pl1 v\""], ["proof (prove)\nusing this:\n  (w, v) \\<in> (Restr lvE (last p))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>pl1.\n        path (Restr lvE (last p)) w pl1 v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule rtrancl_is_path)"], ["proof (state)\nthis:\n  path (Restr lvE (last p)) w pl1 v\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "also"], ["proof (state)\nthis:\n  path (Restr lvE (last p)) w pl1 v\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "from cnode_connectedI \\<open>w\\<in>last p\\<close> \\<open>v\\<in>last p\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i < length p; ?u \\<in> p ! ?i; ?v \\<in> p ! ?i\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> (Restr lvE (p ! ?i))\\<^sup>*\n  w \\<in> last p\n  v \\<in> last p", "have \"(v,w)\\<in>(lvE \\<inter> last p \\<times> last p)\\<^sup>*\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < length p; ?u \\<in> p ! ?i; ?v \\<in> p ! ?i\\<rbrakk>\n  \\<Longrightarrow> (?u, ?v) \\<in> (Restr lvE (p ! ?i))\\<^sup>*\n  w \\<in> last p\n  v \\<in> last p\n\ngoal (1 subgoal):\n 1. (v, w) \\<in> (Restr lvE (last p))\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (v, w) \\<in> (Restr lvE (last p))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "then"], ["proof (chain)\npicking this:\n  (v, w) \\<in> (Restr lvE (last p))\\<^sup>*", "obtain pl2 where P2: \"path (lvE \\<inter> last p \\<times> last p) v pl2 w\""], ["proof (prove)\nusing this:\n  (v, w) \\<in> (Restr lvE (last p))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<And>pl2.\n        path (Restr lvE (last p)) v pl2 w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule rtrancl_is_path)"], ["proof (state)\nthis:\n  path (Restr lvE (last p)) v pl2 w\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "also (path_conc)"], ["proof (state)\nthis:\n  path (Restr lvE (last p)) v pl2 w\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "note IH(2)"], ["proof (state)\nthis:\n  path (Restr lvE (last p)) w pl w\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "finally (path_conc)"], ["proof (chain)\npicking this:\n  path (Restr lvE (last p)) w ((pl1 @ pl2) @ pl) w", "have \n          P: \"path (lvE \\<inter> last p \\<times> last p) w (pl1@pl2@pl) w\""], ["proof (prove)\nusing this:\n  path (Restr lvE (last p)) w ((pl1 @ pl2) @ pl) w\n\ngoal (1 subgoal):\n 1. path (Restr lvE (last p)) w (pl1 @ pl2 @ pl) w", "by simp"], ["proof (state)\nthis:\n  path (Restr lvE (last p)) w (pl1 @ pl2 @ pl) w\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "moreover"], ["proof (state)\nthis:\n  path (Restr lvE (last p)) w (pl1 @ pl2 @ pl) w\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "from IH(1)"], ["proof (chain)\npicking this:\n  pl \\<noteq> []", "have \"pl1@pl2@pl \\<noteq> []\""], ["proof (prove)\nusing this:\n  pl \\<noteq> []\n\ngoal (1 subgoal):\n 1. pl1 @ pl2 @ pl \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  pl1 @ pl2 @ pl \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "moreover"], ["proof (state)\nthis:\n  pl1 @ pl2 @ pl \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "have \"\\<forall>i'<n. \\<exists>q\\<in>set (pl1@pl2@pl). i'\\<in>acc q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i'<n. \\<exists>q\\<in>set (pl1 @ pl2 @ pl). i' \\<in> acc q", "using IH(3)"], ["proof (prove)\nusing this:\n  \\<forall>i<n. \\<exists>q\\<in>set pl. i \\<in> acc q\n\ngoal (1 subgoal):\n 1. \\<forall>i'<n. \\<exists>q\\<in>set (pl1 @ pl2 @ pl). i' \\<in> acc q", "by auto"], ["proof (state)\nthis:\n  \\<forall>i'<n. \\<exists>q\\<in>set (pl1 @ pl2 @ pl). i' \\<in> acc q\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "moreover"], ["proof (state)\nthis:\n  \\<forall>i'<n. \\<exists>q\\<in>set (pl1 @ pl2 @ pl). i' \\<in> acc q\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "have \"v\\<in>set (pl1@pl2@pl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (pl1 @ pl2 @ pl)", "using P1 P2 P IH(1)"], ["proof (prove)\nusing this:\n  path (Restr lvE (last p)) w pl1 v\n  path (Restr lvE (last p)) v pl2 w\n  path (Restr lvE (last p)) w (pl1 @ pl2 @ pl) w\n  pl \\<noteq> []\n\ngoal (1 subgoal):\n 1. v \\<in> set (pl1 @ pl2 @ pl)", "apply (cases pl2, simp_all add: path_cons_conv path_conc_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v = w;\n     \\<exists>v.\n        path (Restr lvE (p ! (length p - Suc 0))) w pl1 v \\<and>\n        path (Restr lvE (p ! (length p - Suc 0))) v pl w;\n     pl2 = []; path (Restr lvE (p ! (length p - Suc 0))) w pl1 w;\n     pl \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> w \\<in> set pl1 \\<or> w \\<in> set pl", "apply (cases pl, simp_all add: path_cons_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>v = w;\n        path (Restr lvE (p ! (length p - Suc 0))) w pl1 a \\<and>\n        (\\<exists>v.\n            (a, v) \\<in> lvE \\<and>\n            a \\<in> p ! (length p - Suc 0) \\<and>\n            v \\<in> p ! (length p - Suc 0) \\<and>\n            path (Restr lvE (p ! (length p - Suc 0))) v list w);\n        pl2 = []; path (Restr lvE (p ! (length p - Suc 0))) w pl1 w;\n        pl = a # list\\<rbrakk>\n       \\<Longrightarrow> w \\<in> set pl1 \\<or> w = a \\<or> w \\<in> set list", "apply (cases pl1, simp_all add: path_cons_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  v \\<in> set (pl1 @ pl2 @ pl)\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "with \\<open>n\\<in>acc v\\<close>"], ["proof (chain)\npicking this:\n  n \\<in> acc v\n  v \\<in> set (pl1 @ pl2 @ pl)", "have \"\\<exists>q\\<in>set (pl1@pl2@pl). n\\<in>acc q\""], ["proof (prove)\nusing this:\n  n \\<in> acc v\n  v \\<in> set (pl1 @ pl2 @ pl)\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>set (pl1 @ pl2 @ pl). n \\<in> acc q", "by auto"], ["proof (state)\nthis:\n  \\<exists>q\\<in>set (pl1 @ pl2 @ pl). n \\<in> acc q\n\ngoal (1 subgoal):\n 1. \\<And>na.\n       \\<lbrakk>\\<forall>i<na.\n                   \\<exists>q\\<in>last p. i \\<in> acc q \\<Longrightarrow>\n                \\<exists>pl.\n                   pl \\<noteq> [] \\<and>\n                   path (Restr lvE (last p)) w pl w \\<and>\n                   (\\<forall>i<na. \\<exists>q\\<in>set pl. i \\<in> acc q);\n        \\<forall>i<Suc na. \\<exists>q\\<in>last p. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pl.\n                            pl \\<noteq> [] \\<and>\n                            path (Restr lvE (last p)) w pl w \\<and>\n                            (\\<forall>i<Suc na.\n                                \\<exists>q\\<in>set pl. i \\<in> acc q)", "ultimately"], ["proof (chain)\npicking this:\n  path (Restr lvE (last p)) w (pl1 @ pl2 @ pl) w\n  pl1 @ pl2 @ pl \\<noteq> []\n  \\<forall>i'<n. \\<exists>q\\<in>set (pl1 @ pl2 @ pl). i' \\<in> acc q\n  \\<exists>q\\<in>set (pl1 @ pl2 @ pl). n \\<in> acc q", "show ?case"], ["proof (prove)\nusing this:\n  path (Restr lvE (last p)) w (pl1 @ pl2 @ pl) w\n  pl1 @ pl2 @ pl \\<noteq> []\n  \\<forall>i'<n. \\<exists>q\\<in>set (pl1 @ pl2 @ pl). i' \\<in> acc q\n  \\<exists>q\\<in>set (pl1 @ pl2 @ pl). n \\<in> acc q\n\ngoal (1 subgoal):\n 1. \\<exists>pl.\n       pl \\<noteq> [] \\<and>\n       path (Restr lvE (last p)) w pl w \\<and>\n       (\\<forall>i<Suc n. \\<exists>q\\<in>set pl. i \\<in> acc q)", "apply (intro exI conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>path (Restr lvE (last p)) w (pl1 @ pl2 @ pl) w;\n     pl1 @ pl2 @ pl \\<noteq> [];\n     \\<forall>i'<n. \\<exists>q\\<in>set (pl1 @ pl2 @ pl). i' \\<in> acc q;\n     \\<exists>q\\<in>set (pl1 @ pl2 @ pl). n \\<in> acc q\\<rbrakk>\n    \\<Longrightarrow> ?pl4 \\<noteq> []\n 2. \\<lbrakk>path (Restr lvE (last p)) w (pl1 @ pl2 @ pl) w;\n     pl1 @ pl2 @ pl \\<noteq> [];\n     \\<forall>i'<n. \\<exists>q\\<in>set (pl1 @ pl2 @ pl). i' \\<in> acc q;\n     \\<exists>q\\<in>set (pl1 @ pl2 @ pl). n \\<in> acc q\\<rbrakk>\n    \\<Longrightarrow> path (Restr lvE (last p)) w ?pl4 w\n 3. \\<lbrakk>path (Restr lvE (last p)) w (pl1 @ pl2 @ pl) w;\n     pl1 @ pl2 @ pl \\<noteq> [];\n     \\<forall>i'<n. \\<exists>q\\<in>set (pl1 @ pl2 @ pl). i' \\<in> acc q;\n     \\<exists>q\\<in>set (pl1 @ pl2 @ pl). n \\<in> acc q\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<Suc n.\n                         \\<exists>q\\<in>set ?pl4. i \\<in> acc q", "apply assumption+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path (Restr lvE (last p)) w (pl1 @ pl2 @ pl) w;\n     pl1 @ pl2 @ pl \\<noteq> [];\n     \\<forall>i'<n. \\<exists>q\\<in>set (pl1 @ pl2 @ pl). i' \\<in> acc q;\n     \\<exists>q\\<in>set (pl1 @ pl2 @ pl). n \\<in> acc q\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<Suc n.\n                         \\<exists>q\\<in>set (pl1 @ pl2 @ pl). i \\<in> acc q", "apply (auto elim: less_SucE)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>pl.\n     pl \\<noteq> [] \\<and>\n     path (Restr lvE (last p)) w pl w \\<and>\n     (\\<forall>i<Suc n. \\<exists>q\\<in>set pl. i \\<in> acc q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>pl.\n     pl \\<noteq> [] \\<and>\n     path (Restr lvE (last p)) w pl w \\<and>\n     (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\n\ngoal (1 subgoal):\n 1. fgl_invar_part (Some (\\<Union> (set (butlast p)), last p), p, D, pE)", "}"], ["proof (state)\nthis:\n  ?na5 = num_acc \\<Longrightarrow>\n  \\<exists>pl.\n     pl \\<noteq> [] \\<and>\n     path (Restr lvE (last p)) w pl w \\<and>\n     (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\n\ngoal (1 subgoal):\n 1. fgl_invar_part (Some (\\<Union> (set (butlast p)), last p), p, D, pE)", "then"], ["proof (chain)\npicking this:\n  ?na5 = num_acc \\<Longrightarrow>\n  \\<exists>pl.\n     pl \\<noteq> [] \\<and>\n     path (Restr lvE (last p)) w pl w \\<and>\n     (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)", "obtain pl where pl: \"pl\\<noteq>[]\" \"path (lvE \\<inter> last p\\<times>last p) w pl w\" \n      \"\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i\\<in>acc q\""], ["proof (prove)\nusing this:\n  ?na5 = num_acc \\<Longrightarrow>\n  \\<exists>pl.\n     pl \\<noteq> [] \\<and>\n     path (Restr lvE (last p)) w pl w \\<and>\n     (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\n\ngoal (1 subgoal):\n 1. (\\<And>pl.\n        \\<lbrakk>pl \\<noteq> []; path (Restr lvE (last p)) w pl w;\n         \\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  pl \\<noteq> []\n  path (Restr lvE (last p)) w pl w\n  \\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q\n\ngoal (1 subgoal):\n 1. fgl_invar_part (Some (\\<Union> (set (butlast p)), last p), p, D, pE)", "hence \"path E w pl w\" and L_SS: \"set pl \\<subseteq> last p\""], ["proof (prove)\nusing this:\n  pl \\<noteq> []\n  path (Restr lvE (last p)) w pl w\n  \\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q\n\ngoal (1 subgoal):\n 1. path E w pl w &&& set pl \\<subseteq> last p", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>pl \\<noteq> []; path (Restr lvE (last p)) w pl w;\n     \\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q\\<rbrakk>\n    \\<Longrightarrow> path E w pl w\n 2. \\<lbrakk>pl \\<noteq> []; path (Restr lvE (last p)) w pl w;\n     \\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q\\<rbrakk>\n    \\<Longrightarrow> set pl \\<subseteq> last p", "apply (frule path_mono[of _ E, rotated])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>pl \\<noteq> []; path (Restr lvE (last p)) w pl w;\n     \\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q\\<rbrakk>\n    \\<Longrightarrow> Restr lvE (last p) \\<subseteq> E\n 2. \\<lbrakk>pl \\<noteq> []; path (Restr lvE (last p)) w pl w;\n     \\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q;\n     path E w pl w\\<rbrakk>\n    \\<Longrightarrow> path E w pl w\n 3. \\<lbrakk>pl \\<noteq> []; path (Restr lvE (last p)) w pl w;\n     \\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q\\<rbrakk>\n    \\<Longrightarrow> set pl \\<subseteq> last p", "using lvE_ss_E"], ["proof (prove)\nusing this:\n  lvE \\<subseteq> E\n\ngoal (3 subgoals):\n 1. \\<lbrakk>pl \\<noteq> []; path (Restr lvE (last p)) w pl w;\n     \\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q\\<rbrakk>\n    \\<Longrightarrow> Restr lvE (last p) \\<subseteq> E\n 2. \\<lbrakk>pl \\<noteq> []; path (Restr lvE (last p)) w pl w;\n     \\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q;\n     path E w pl w\\<rbrakk>\n    \\<Longrightarrow> path E w pl w\n 3. \\<lbrakk>pl \\<noteq> []; path (Restr lvE (last p)) w pl w;\n     \\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q\\<rbrakk>\n    \\<Longrightarrow> set pl \\<subseteq> last p", "apply auto [2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pl \\<noteq> []; path (Restr lvE (last p)) w pl w;\n     \\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q\\<rbrakk>\n    \\<Longrightarrow> set pl \\<subseteq> last p", "apply (drule path_nodes_edges)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pl \\<noteq> [];\n     \\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q;\n     set pl \\<subseteq> fst ` Restr lvE (last p)\\<rbrakk>\n    \\<Longrightarrow> set pl \\<subseteq> last p", "apply (drule order_trans[OF _ image_Int_subset])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pl \\<noteq> [];\n     \\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q;\n     set pl\n     \\<subseteq> fst ` lvE \\<inter> fst ` (last p \\<times> last p)\\<rbrakk>\n    \\<Longrightarrow> set pl \\<subseteq> last p", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  path E w pl w\n  set pl \\<subseteq> last p\n\ngoal (1 subgoal):\n 1. fgl_invar_part (Some (\\<Union> (set (butlast p)), last p), p, D, pE)", "have LASSO: \"is_lasso_prpl (pr,pl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_lasso_prpl (pr, pl)", "unfolding is_lasso_prpl_def is_lasso_prpl_pre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (pr, pl) of\n     (pr, pl) \\<Rightarrow>\n       \\<exists>v0 va.\n          v0 \\<in> V0 \\<and>\n          pl \\<noteq> [] \\<and>\n          path E v0 pr va \\<and> path E va pl va) \\<and>\n    (\\<forall>i<num_acc. \\<exists>q\\<in>set (snd (pr, pl)). i \\<in> acc q)", "using \\<open>path E w pl w\\<close> P_REACH pl"], ["proof (prove)\nusing this:\n  path E w pl w\n  path E v0 pr w\n  pl \\<noteq> []\n  path (Restr lvE (last p)) w pl w\n  \\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q\n\ngoal (1 subgoal):\n 1. (case (pr, pl) of\n     (pr, pl) \\<Rightarrow>\n       \\<exists>v0 va.\n          v0 \\<in> V0 \\<and>\n          pl \\<noteq> [] \\<and>\n          path E v0 pr va \\<and> path E va pl va) \\<and>\n    (\\<forall>i<num_acc. \\<exists>q\\<in>set (snd (pr, pl)). i \\<in> acc q)", "by auto"], ["proof (state)\nthis:\n  is_lasso_prpl (pr, pl)\n\ngoal (1 subgoal):\n 1. fgl_invar_part (Some (\\<Union> (set (butlast p)), last p), p, D, pE)", "from p_sc"], ["proof (chain)\npicking this:\n  ?U \\<in> set p \\<Longrightarrow>\n  ?U \\<times> ?U \\<subseteq> (Restr lvE ?U)\\<^sup>*", "have \"last p \\<times> last p \\<subseteq> (lvE \\<inter> last p \\<times> last p)\\<^sup>*\""], ["proof (prove)\nusing this:\n  ?U \\<in> set p \\<Longrightarrow>\n  ?U \\<times> ?U \\<subseteq> (Restr lvE ?U)\\<^sup>*\n\ngoal (1 subgoal):\n 1. last p \\<times> last p \\<subseteq> (Restr lvE (last p))\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  last p \\<times> last p \\<subseteq> (Restr lvE (last p))\\<^sup>*\n\ngoal (1 subgoal):\n 1. fgl_invar_part (Some (\\<Union> (set (butlast p)), last p), p, D, pE)", "with lvE_ss_E"], ["proof (chain)\npicking this:\n  lvE \\<subseteq> E\n  last p \\<times> last p \\<subseteq> (Restr lvE (last p))\\<^sup>*", "have VL_CLOSED: \"last p \\<times> last p \\<subseteq> (E \\<inter> last p \\<times> last p)\\<^sup>*\""], ["proof (prove)\nusing this:\n  lvE \\<subseteq> E\n  last p \\<times> last p \\<subseteq> (Restr lvE (last p))\\<^sup>*\n\ngoal (1 subgoal):\n 1. last p \\<times> last p \\<subseteq> (Restr E (last p))\\<^sup>*", "apply (erule_tac order_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. lvE \\<subseteq> E \\<Longrightarrow>\n    (Restr lvE (last p))\\<^sup>* \\<subseteq> (Restr E (last p))\\<^sup>*", "apply (rule rtrancl_mono)"], ["proof (prove)\ngoal (1 subgoal):\n 1. lvE \\<subseteq> E \\<Longrightarrow>\n    Restr lvE (last p) \\<subseteq> Restr E (last p)", "by blast"], ["proof (state)\nthis:\n  last p \\<times> last p \\<subseteq> (Restr E (last p))\\<^sup>*\n\ngoal (1 subgoal):\n 1. fgl_invar_part (Some (\\<Union> (set (butlast p)), last p), p, D, pE)", "have NONTRIV': \"last p \\<times> last p \\<inter> E \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last p \\<times> last p \\<inter> E \\<noteq> {}", "by (metis Int_commute NONTRIV disjoint_mono lvE_ss_E subset_refl)"], ["proof (state)\nthis:\n  last p \\<times> last p \\<inter> E \\<noteq> {}\n\ngoal (1 subgoal):\n 1. fgl_invar_part (Some (\\<Union> (set (butlast p)), last p), p, D, pE)", "from order_trans[OF path_touched touched_reachable]"], ["proof (chain)\npicking this:\n  \\<Union> (set p) \\<subseteq> reachable", "have LP_REACH: \"last p \\<subseteq> E\\<^sup>*``V0\" \n      and BLP_REACH: \"\\<Union>(set (butlast p)) \\<subseteq> E\\<^sup>*``V0\""], ["proof (prove)\nusing this:\n  \\<Union> (set p) \\<subseteq> reachable\n\ngoal (1 subgoal):\n 1. last p \\<subseteq> reachable &&&\n    \\<Union> (set (butlast p)) \\<subseteq> reachable", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<Union> (set p) \\<subseteq> reachable \\<Longrightarrow>\n    last p \\<subseteq> reachable\n 2. \\<Union> (set p) \\<subseteq> reachable \\<Longrightarrow>\n    \\<Union> (set (butlast p)) \\<subseteq> reachable", "apply (cases p rule: rev_cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Union> (set p) \\<subseteq> reachable; p = []\\<rbrakk>\n    \\<Longrightarrow> last p \\<subseteq> reachable\n 2. \\<And>ys y.\n       \\<lbrakk>\\<Union> (set p) \\<subseteq> reachable;\n        p = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> last p \\<subseteq> reachable\n 3. \\<Union> (set p) \\<subseteq> reachable \\<Longrightarrow>\n    \\<Union> (set (butlast p)) \\<subseteq> reachable", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys y.\n       \\<lbrakk>\\<Union> (set p) \\<subseteq> reachable;\n        p = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> last p \\<subseteq> reachable\n 2. \\<Union> (set p) \\<subseteq> reachable \\<Longrightarrow>\n    \\<Union> (set (butlast p)) \\<subseteq> reachable", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set p) \\<subseteq> reachable \\<Longrightarrow>\n    \\<Union> (set (butlast p)) \\<subseteq> reachable", "apply (cases p rule: rev_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Union> (set p) \\<subseteq> reachable; p = []\\<rbrakk>\n    \\<Longrightarrow> \\<Union> (set (butlast p)) \\<subseteq> reachable\n 2. \\<And>ys y.\n       \\<lbrakk>\\<Union> (set p) \\<subseteq> reachable;\n        p = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (set (butlast p)) \\<subseteq> reachable", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>\\<Union> (set p) \\<subseteq> reachable;\n        p = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (set (butlast p)) \\<subseteq> reachable", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  last p \\<subseteq> reachable\n  \\<Union> (set (butlast p)) \\<subseteq> reachable\n\ngoal (1 subgoal):\n 1. fgl_invar_part (Some (\\<Union> (set (butlast p)), last p), p, D, pE)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_invar_part (Some (\\<Union> (set (butlast p)), last p), p, D, pE)", "apply (simp add: fgl_invar_part_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_invar_loc_axioms G\n     (Some (\\<Union> (set (butlast p)), p ! (length p - Suc 0))) p D pE", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. Some (\\<Union> (set (butlast p)), p ! (length p - Suc 0)) =\n    None \\<Longrightarrow>\n    \\<nexists>v pl.\n       pl \\<noteq> [] \\<and>\n       path lvE v pl v \\<and>\n       (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\n 2. \\<And>Vr Vl.\n       Some (\\<Union> (set (butlast p)), p ! (length p - Suc 0)) =\n       Some (Vr, Vl) \\<Longrightarrow>\n       ce_correct Vr Vl", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Vr Vl.\n       Some (\\<Union> (set (butlast p)), p ! (length p - Suc 0)) =\n       Some (Vr, Vl) \\<Longrightarrow>\n       ce_correct Vr Vl", "using LASSO R_SS L_SS VL_CLOSED NONTRIV' LP_REACH BLP_REACH"], ["proof (prove)\nusing this:\n  is_lasso_prpl (pr, pl)\n  set pr \\<subseteq> \\<Union> (set (butlast p))\n  set pl \\<subseteq> last p\n  last p \\<times> last p \\<subseteq> (Restr E (last p))\\<^sup>*\n  last p \\<times> last p \\<inter> E \\<noteq> {}\n  last p \\<subseteq> reachable\n  \\<Union> (set (butlast p)) \\<subseteq> reachable\n\ngoal (1 subgoal):\n 1. \\<And>Vr Vl.\n       Some (\\<Union> (set (butlast p)), p ! (length p - Suc 0)) =\n       Some (Vr, Vl) \\<Longrightarrow>\n       ce_correct Vr Vl", "unfolding ce_correct_def"], ["proof (prove)\nusing this:\n  is_lasso_prpl (pr, pl)\n  set pr \\<subseteq> \\<Union> (set (butlast p))\n  set pl \\<subseteq> last p\n  last p \\<times> last p \\<subseteq> (Restr E (last p))\\<^sup>*\n  last p \\<times> last p \\<inter> E \\<noteq> {}\n  last p \\<subseteq> reachable\n  \\<Union> (set (butlast p)) \\<subseteq> reachable\n\ngoal (1 subgoal):\n 1. \\<And>Vr Vl.\n       Some (\\<Union> (set (butlast p)), p ! (length p - Suc 0)) =\n       Some (Vr, Vl) \\<Longrightarrow>\n       \\<exists>pr pl.\n          Vr \\<subseteq> reachable \\<and>\n          Vl \\<subseteq> reachable \\<and>\n          set pr \\<subseteq> Vr \\<and>\n          set pl \\<subseteq> Vl \\<and>\n          Vl \\<times> Vl \\<subseteq> (Restr E Vl)\\<^sup>* \\<and>\n          Vl \\<times> Vl \\<inter> E \\<noteq> {} \\<and>\n          is_lasso_prpl (pr, pl)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_lasso_prpl (pr, pl);\n     set pr \\<subseteq> \\<Union> (set (butlast p));\n     set pl \\<subseteq> p ! (length p - Suc 0);\n     p ! (length p - Suc 0) \\<times> p ! (length p - Suc 0)\n     \\<subseteq> (Restr E (p ! (length p - Suc 0)))\\<^sup>*;\n     p ! (length p - Suc 0) \\<times> p ! (length p - Suc 0) \\<inter>\n     E \\<noteq>\n     {};\n     p ! (length p - Suc 0) \\<subseteq> reachable;\n     \\<Union> (set (butlast p)) \\<subseteq> reachable\\<rbrakk>\n    \\<Longrightarrow> \\<exists>pr.\n                         set pr\n                         \\<subseteq> \\<Union> (set (butlast p)) \\<and>\n                         (\\<exists>pl.\n                             set pl\n                             \\<subseteq> p ! (length p - Suc 0) \\<and>\n                             is_lasso_prpl (pr, pl))", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fgl_invar_part (Some (\\<Union> (set (butlast p)), last p), p, D, pE)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fgl_invar_collapse_ce:\n    fixes u v\n    assumes INV: \"fgl_invar v0 D0 (None,p,D,pE)\"\n    defines \"pE' \\<equiv> pE - {(u,v)}\"\n    assumes CFMT: \"(p',D',pE'') = collapse v (p,D,pE')\"\n    assumes INV': \"invar v0 D0 (p',D',pE'')\"\n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes E: \"(u,v)\\<in>pE\" and \"u\\<in>last p\"\n    assumes BACK: \"v\\<in>\\<Union>(set p)\"\n    assumes ACC: \"\\<forall>i<num_acc. \\<exists>q\\<in>last p'. i\\<in>acc q\"\n    defines i_def: \"i \\<equiv> idx_of p v\"\n    shows \"fgl_invar_part (\n      Some (\\<Union>(set (butlast p')), last p'), \n      collapse v (p,D,pE'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_invar_part\n     (Some (\\<Union> (set (butlast p')), last p'), collapse v (p, D, pE'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part\n     (Some (\\<Union> (set (butlast p')), last p'), collapse v (p, D, pE'))", "from CFMT"], ["proof (chain)\npicking this:\n  (p', D', pE'') = collapse v (p, D, pE')", "have p'_def: \"p' = collapse_aux p i\" and [simp]: \"D'=D\" \"pE''=pE'\""], ["proof (prove)\nusing this:\n  (p', D', pE'') = collapse v (p, D, pE')\n\ngoal (1 subgoal):\n 1. p' = collapse_aux p i &&& D' = D &&& pE'' = pE'", "by (simp_all add: collapse_def i_def)"], ["proof (state)\nthis:\n  p' = collapse_aux p i\n  D' = D\n  pE'' = pE'\n\ngoal (1 subgoal):\n 1. fgl_invar_part\n     (Some (\\<Union> (set (butlast p')), last p'), collapse v (p, D, pE'))", "from INV"], ["proof (chain)\npicking this:\n  fgl_invar v0 D0 (None, p, D, pE)", "interpret fgl_invar_loc G v0 D0 None p D pE"], ["proof (prove)\nusing this:\n  fgl_invar v0 D0 (None, p, D, pE)\n\ngoal (1 subgoal):\n 1. fgl_invar_loc G v0 D0 None p D pE", "by (simp add: fgl_invar_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part\n     (Some (\\<Union> (set (butlast p')), last p'), collapse v (p, D, pE'))", "from idx_of_props[OF BACK]"], ["proof (chain)\npicking this:\n  idx_of p v < length p\n  v \\<in> p ! idx_of p v", "have \"i<length p\" and \"v\\<in>p!i\""], ["proof (prove)\nusing this:\n  idx_of p v < length p\n  v \\<in> p ! idx_of p v\n\ngoal (1 subgoal):\n 1. i < length p &&& v \\<in> p ! i", "by (simp_all add: i_def)"], ["proof (state)\nthis:\n  i < length p\n  v \\<in> p ! i\n\ngoal (1 subgoal):\n 1. fgl_invar_part\n     (Some (\\<Union> (set (butlast p')), last p'), collapse v (p, D, pE'))", "have \"u\\<in>last p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> last p'", "using \\<open>u\\<in>last p\\<close> \\<open>i<length p\\<close>"], ["proof (prove)\nusing this:\n  u \\<in> last p\n  i < length p\n\ngoal (1 subgoal):\n 1. u \\<in> last p'", "unfolding p'_def collapse_aux_def"], ["proof (prove)\nusing this:\n  u \\<in> last p\n  i < length p\n\ngoal (1 subgoal):\n 1. u \\<in> last (take i p @ [\\<Union> (set (drop i p))])", "apply (simp add: last_drop last_snoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> last p; i < length p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>X\\<in>set (drop i p). u \\<in> X", "by (metis Misc.last_in_set drop_eq_Nil last_drop not_le)"], ["proof (state)\nthis:\n  u \\<in> last p'\n\ngoal (1 subgoal):\n 1. fgl_invar_part\n     (Some (\\<Union> (set (butlast p')), last p'), collapse v (p, D, pE'))", "moreover"], ["proof (state)\nthis:\n  u \\<in> last p'\n\ngoal (1 subgoal):\n 1. fgl_invar_part\n     (Some (\\<Union> (set (butlast p')), last p'), collapse v (p, D, pE'))", "have \"v\\<in>last p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> last p'", "using \\<open>v\\<in>p!i\\<close> \\<open>i<length p\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> p ! i\n  i < length p\n\ngoal (1 subgoal):\n 1. v \\<in> last p'", "unfolding p'_def collapse_aux_def"], ["proof (prove)\nusing this:\n  v \\<in> p ! i\n  i < length p\n\ngoal (1 subgoal):\n 1. v \\<in> last (take i p @ [\\<Union> (set (drop i p))])", "by (metis UnionI append_Nil Cons_nth_drop_Suc in_set_conv_decomp last_snoc)"], ["proof (state)\nthis:\n  v \\<in> last p'\n\ngoal (1 subgoal):\n 1. fgl_invar_part\n     (Some (\\<Union> (set (butlast p')), last p'), collapse v (p, D, pE'))", "ultimately"], ["proof (chain)\npicking this:\n  u \\<in> last p'\n  v \\<in> last p'", "have \"vE p' D pE' \\<inter> last p' \\<times> last p' \\<noteq> {}\""], ["proof (prove)\nusing this:\n  u \\<in> last p'\n  v \\<in> last p'\n\ngoal (1 subgoal):\n 1. Restr (vE p' D pE') (last p') \\<noteq> {}", "unfolding p'_def pE'_def"], ["proof (prove)\nusing this:\n  u \\<in> last (collapse_aux p i)\n  v \\<in> last (collapse_aux p i)\n\ngoal (1 subgoal):\n 1. Restr (vE (collapse_aux p i) D (pE - {(u, v)}))\n     (last (collapse_aux p i)) \\<noteq>\n    {}", "by (auto simp: E)"], ["proof (state)\nthis:\n  Restr (vE p' D pE') (last p') \\<noteq> {}\n\ngoal (1 subgoal):\n 1. fgl_invar_part\n     (Some (\\<Union> (set (butlast p')), last p'), collapse v (p, D, pE'))", "have \"p'\\<noteq>[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p' \\<noteq> []", "by (simp add: p'_def collapse_aux_def)"], ["proof (state)\nthis:\n  p' \\<noteq> []\n\ngoal (1 subgoal):\n 1. fgl_invar_part\n     (Some (\\<Union> (set (butlast p')), last p'), collapse v (p, D, pE'))", "have [simp]: \"collapse v (p,D,pE') = (p',D,pE')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collapse v (p, D, pE') = (p', D, pE')", "unfolding collapse_def p'_def i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (p, D, pE) = (p, D, pE'); i = idx_of p v; p = collapse_aux p i\n     in (p, D, pE)) =\n    (collapse_aux p (idx_of p v), D, pE')", "by simp"], ["proof (state)\nthis:\n  collapse v (p, D, pE') = (p', D, pE')\n\ngoal (1 subgoal):\n 1. fgl_invar_part\n     (Some (\\<Union> (set (butlast p')), last p'), collapse v (p, D, pE'))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_invar_part\n     (Some (\\<Union> (set (butlast p')), last p'), collapse v (p, D, pE'))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_invar_part (Some (\\<Union> (set (butlast p')), last p'), p', D, pE')", "apply (rule fgl_invar_collapse_ce_aux)"], ["proof (prove)\ngoal (4 subgoals):\n 1. invar ?v0.1 ?D0.1 (p', D, pE')\n 2. p' \\<noteq> []\n 3. Restr (vE p' D pE') (last p') \\<noteq> {}\n 4. \\<forall>i<num_acc. \\<exists>q\\<in>last p'. i \\<in> acc q", "using INV'"], ["proof (prove)\nusing this:\n  invar v0 D0 (p', D', pE'')\n\ngoal (4 subgoals):\n 1. invar ?v0.1 ?D0.1 (p', D, pE')\n 2. p' \\<noteq> []\n 3. Restr (vE p' D pE') (last p') \\<noteq> {}\n 4. \\<forall>i<num_acc. \\<exists>q\\<in>last p'. i \\<in> acc q", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. p' \\<noteq> []\n 2. Restr (vE p' D pE') (last p') \\<noteq> {}\n 3. \\<forall>i<num_acc. \\<exists>q\\<in>last p'. i \\<in> acc q", "apply fact+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fgl_invar_part\n   (Some (\\<Union> (set (butlast p')), last p'), collapse v (p, D, pE'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fgl_invar_collapse_nce:\n    fixes u v\n    assumes INV: \"fgl_invar v0 D0 (None,p,D,pE)\"\n    defines \"pE' \\<equiv> pE - {(u,v)}\"\n    assumes CFMT: \"(p',D',pE'') = collapse v (p,D,pE')\"\n    assumes INV': \"invar v0 D0 (p',D',pE'')\"\n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes E: \"(u,v)\\<in>pE\" and \"u\\<in>last p\"\n    assumes BACK: \"v\\<in>\\<Union>(set p)\"\n    assumes NACC: \"j<num_acc\" \"\\<forall>q\\<in>last p'. j\\<notin>acc q\"\n    defines \"i \\<equiv> idx_of p v\"\n    shows \"fgl_invar_part (None, collapse v (p,D,pE'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, collapse v (p, D, pE'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, collapse v (p, D, pE'))", "from CFMT"], ["proof (chain)\npicking this:\n  (p', D', pE'') = collapse v (p, D, pE')", "have p'_def: \"p' = collapse_aux p i\" and [simp]: \"D'=D\" \"pE''=pE'\""], ["proof (prove)\nusing this:\n  (p', D', pE'') = collapse v (p, D, pE')\n\ngoal (1 subgoal):\n 1. p' = collapse_aux p i &&& D' = D &&& pE'' = pE'", "by (simp_all add: collapse_def i_def)"], ["proof (state)\nthis:\n  p' = collapse_aux p i\n  D' = D\n  pE'' = pE'\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, collapse v (p, D, pE'))", "have [simp]: \"collapse v (p,D,pE') = (p',D,pE')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. collapse v (p, D, pE') = (p', D, pE')", "by (simp add: collapse_def p'_def i_def)"], ["proof (state)\nthis:\n  collapse v (p, D, pE') = (p', D, pE')\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, collapse v (p, D, pE'))", "from INV"], ["proof (chain)\npicking this:\n  fgl_invar v0 D0 (None, p, D, pE)", "interpret fgl_invar_loc G v0 D0 None p D pE"], ["proof (prove)\nusing this:\n  fgl_invar v0 D0 (None, p, D, pE)\n\ngoal (1 subgoal):\n 1. fgl_invar_loc G v0 D0 None p D pE", "by (simp add: fgl_invar_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, collapse v (p, D, pE'))", "from INV'"], ["proof (chain)\npicking this:\n  invar v0 D0 (p', D', pE'')", "interpret inv': invar_loc G v0 D0 p' D pE'"], ["proof (prove)\nusing this:\n  invar v0 D0 (p', D', pE'')\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p' D pE'", "by (simp add: invar_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, collapse v (p, D, pE'))", "define vE' where \"vE' = vE p' D pE'\""], ["proof (state)\nthis:\n  vE' = inv'.lvE\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, collapse v (p, D, pE'))", "have vE'_alt: \"vE' = insert (u,v) lvE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vE' = insert (u, v) lvE", "by (simp add: vE'_def p'_def pE'_def E)"], ["proof (state)\nthis:\n  vE' = insert (u, v) lvE\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, collapse v (p, D, pE'))", "from idx_of_props[OF BACK]"], ["proof (chain)\npicking this:\n  idx_of p v < length p\n  v \\<in> p ! idx_of p v", "have \"i<length p\" and \"v\\<in>p!i\""], ["proof (prove)\nusing this:\n  idx_of p v < length p\n  v \\<in> p ! idx_of p v\n\ngoal (1 subgoal):\n 1. i < length p &&& v \\<in> p ! i", "by (simp_all add: i_def)"], ["proof (state)\nthis:\n  i < length p\n  v \\<in> p ! i\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, collapse v (p, D, pE'))", "have \"u\\<in>last p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> last p'", "using \\<open>u\\<in>last p\\<close> \\<open>i<length p\\<close>"], ["proof (prove)\nusing this:\n  u \\<in> last p\n  i < length p\n\ngoal (1 subgoal):\n 1. u \\<in> last p'", "unfolding p'_def collapse_aux_def"], ["proof (prove)\nusing this:\n  u \\<in> last p\n  i < length p\n\ngoal (1 subgoal):\n 1. u \\<in> last (take i p @ [\\<Union> (set (drop i p))])", "apply (simp add: last_drop last_snoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> last p; i < length p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>X\\<in>set (drop i p). u \\<in> X", "by (metis Misc.last_in_set drop_eq_Nil last_drop leD)"], ["proof (state)\nthis:\n  u \\<in> last p'\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, collapse v (p, D, pE'))", "moreover"], ["proof (state)\nthis:\n  u \\<in> last p'\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, collapse v (p, D, pE'))", "have \"v\\<in>last p'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> last p'", "using \\<open>v\\<in>p!i\\<close> \\<open>i<length p\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> p ! i\n  i < length p\n\ngoal (1 subgoal):\n 1. v \\<in> last p'", "unfolding p'_def collapse_aux_def"], ["proof (prove)\nusing this:\n  v \\<in> p ! i\n  i < length p\n\ngoal (1 subgoal):\n 1. v \\<in> last (take i p @ [\\<Union> (set (drop i p))])", "by (metis UnionI append_Nil Cons_nth_drop_Suc in_set_conv_decomp last_snoc)"], ["proof (state)\nthis:\n  v \\<in> last p'\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, collapse v (p, D, pE'))", "ultimately"], ["proof (chain)\npicking this:\n  u \\<in> last p'\n  v \\<in> last p'", "have \"vE' \\<inter> last p' \\<times> last p' \\<noteq> {}\""], ["proof (prove)\nusing this:\n  u \\<in> last p'\n  v \\<in> last p'\n\ngoal (1 subgoal):\n 1. Restr vE' (last p') \\<noteq> {}", "unfolding vE'_alt"], ["proof (prove)\nusing this:\n  u \\<in> last p'\n  v \\<in> last p'\n\ngoal (1 subgoal):\n 1. Restr (insert (u, v) lvE) (last p') \\<noteq> {}", "by (auto)"], ["proof (state)\nthis:\n  Restr vE' (last p') \\<noteq> {}\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, collapse v (p, D, pE'))", "have \"p'\\<noteq>[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p' \\<noteq> []", "by (simp add: p'_def collapse_aux_def)"], ["proof (state)\nthis:\n  p' \\<noteq> []\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, collapse v (p, D, pE'))", "{"], ["proof (state)\nthis:\n  p' \\<noteq> []\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, collapse v (p, D, pE'))", "txt \\<open>\n        We show that no visited strongly connected component contains states\n        from all acceptance sets.\\<close>"], ["proof (state)\nthis:\n  p' \\<noteq> []\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, collapse v (p, D, pE'))", "fix w pl"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, collapse v (p, D, pE'))", "txt \\<open>For this, we chose a non-trivial loop inside the visited edges\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, collapse v (p, D, pE'))", "assume P: \"path vE' w pl w\" and NT: \"pl\\<noteq>[]\""], ["proof (state)\nthis:\n  path vE' w pl w\n  pl \\<noteq> []\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, collapse v (p, D, pE'))", "txt \\<open>And show that there is one acceptance set disjoint with the nodes\n        of the loop\\<close>"], ["proof (state)\nthis:\n  path vE' w pl w\n  pl \\<noteq> []\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, collapse v (p, D, pE'))", "have \"\\<exists>i<num_acc. \\<forall>q\\<in>set pl. i\\<notin>acc q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "assume \"set pl \\<inter> last p' = {}\" \n          \\<comment> \\<open>Case: The loop is outside the last Cnode\\<close>"], ["proof (state)\nthis:\n  set pl \\<inter> last p' = {}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "with path_restrict[OF P] \\<open>u\\<in>last p'\\<close> \\<open>v\\<in>last p'\\<close>"], ["proof (chain)\npicking this:\n  path (vE' \\<inter> set pl \\<times> insert w (set (tl pl))) w pl w\n  u \\<in> last p'\n  v \\<in> last p'\n  set pl \\<inter> last p' = {}", "have \"path lvE w pl w\""], ["proof (prove)\nusing this:\n  path (vE' \\<inter> set pl \\<times> insert w (set (tl pl))) w pl w\n  u \\<in> last p'\n  v \\<in> last p'\n  set pl \\<inter> last p' = {}\n\ngoal (1 subgoal):\n 1. path lvE w pl w", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>path (vE' \\<inter> set pl \\<times> insert w (set (tl pl))) w pl\n              w;\n     u \\<in> last p'; v \\<in> last p'; set pl \\<inter> last p' = {}\\<rbrakk>\n    \\<Longrightarrow> path lvE w pl w", "apply (drule path_mono[of _ lvE, rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>u \\<in> last p'; v \\<in> last p';\n     set pl \\<inter> last p' = {}\\<rbrakk>\n    \\<Longrightarrow> vE' \\<inter> set pl \\<times> insert w (set (tl pl))\n                      \\<subseteq> lvE\n 2. \\<lbrakk>u \\<in> last p'; v \\<in> last p'; set pl \\<inter> last p' = {};\n     path lvE w pl w\\<rbrakk>\n    \\<Longrightarrow> path lvE w pl w", "unfolding vE'_alt"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>u \\<in> last p'; v \\<in> last p';\n     set pl \\<inter> last p' = {}\\<rbrakk>\n    \\<Longrightarrow> insert (u, v) lvE \\<inter>\n                      set pl \\<times> insert w (set (tl pl))\n                      \\<subseteq> lvE\n 2. \\<lbrakk>u \\<in> last p'; v \\<in> last p'; set pl \\<inter> last p' = {};\n     path lvE w pl w\\<rbrakk>\n    \\<Longrightarrow> path lvE w pl w", "by auto"], ["proof (state)\nthis:\n  path lvE w pl w\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "with no_acc NT"], ["proof (chain)\npicking this:\n  None = None \\<Longrightarrow>\n  \\<nexists>v pl.\n     pl \\<noteq> [] \\<and>\n     path lvE v pl v \\<and>\n     (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\n  pl \\<noteq> []\n  path lvE w pl w", "show ?thesis"], ["proof (prove)\nusing this:\n  None = None \\<Longrightarrow>\n  \\<nexists>v pl.\n     pl \\<noteq> [] \\<and>\n     path lvE v pl v \\<and>\n     (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\n  pl \\<noteq> []\n  path lvE w pl w\n\ngoal (1 subgoal):\n 1. \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "by auto"], ["proof (state)\nthis:\n  \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q\n\ngoal (1 subgoal):\n 1. set pl \\<inter> last p' \\<noteq> {} \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. set pl \\<inter> last p' \\<noteq> {} \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "assume \"set pl \\<inter> last p' \\<noteq> {}\" \n          \\<comment> \\<open>Case: The loop touches the last Cnode\\<close>"], ["proof (state)\nthis:\n  set pl \\<inter> last p' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. set pl \\<inter> last p' \\<noteq> {} \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "txt \\<open>Then, the loop must be completely inside the last CNode\\<close>"], ["proof (state)\nthis:\n  set pl \\<inter> last p' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. set pl \\<inter> last p' \\<noteq> {} \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "from inv'.loop_in_lastnode[folded vE'_def, OF P \\<open>p'\\<noteq>[]\\<close> this]"], ["proof (chain)\npicking this:\n  w \\<in> last p'\n  set pl \\<subseteq> last p'", "have \"w\\<in>last p'\" \"set pl \\<subseteq> last p'\""], ["proof (prove)\nusing this:\n  w \\<in> last p'\n  set pl \\<subseteq> last p'\n\ngoal (1 subgoal):\n 1. w \\<in> last p' &&& set pl \\<subseteq> last p'", "."], ["proof (state)\nthis:\n  w \\<in> last p'\n  set pl \\<subseteq> last p'\n\ngoal (1 subgoal):\n 1. set pl \\<inter> last p' \\<noteq> {} \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "with NACC"], ["proof (chain)\npicking this:\n  j < num_acc\n  \\<forall>q\\<in>last p'. j \\<notin> acc q\n  w \\<in> last p'\n  set pl \\<subseteq> last p'", "show ?thesis"], ["proof (prove)\nusing this:\n  j < num_acc\n  \\<forall>q\\<in>last p'. j \\<notin> acc q\n  w \\<in> last p'\n  set pl \\<subseteq> last p'\n\ngoal (1 subgoal):\n 1. \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "by blast"], ["proof (state)\nthis:\n  \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, collapse v (p, D, pE'))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>path vE' ?w5 ?pl5 ?w5; ?pl5 \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i<num_acc.\n                       \\<forall>q\\<in>set ?pl5. i \\<notin> acc q\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, collapse v (p, D, pE'))", "note AUX_no_acc = this"], ["proof (state)\nthis:\n  \\<lbrakk>path vE' ?w5 ?pl5 ?w5; ?pl5 \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i<num_acc.\n                       \\<forall>q\\<in>set ?pl5. i \\<notin> acc q\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, collapse v (p, D, pE'))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, collapse v (p, D, pE'))", "apply (simp add: fgl_invar_part_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_invar_loc_axioms G None p' D pE'", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. None = None \\<Longrightarrow>\n    \\<nexists>v pl.\n       pl \\<noteq> [] \\<and>\n       path inv'.lvE v pl v \\<and>\n       (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\n 2. \\<And>Vr Vl. None = Some (Vr, Vl) \\<Longrightarrow> ce_correct Vr Vl", "using AUX_no_acc[unfolded vE'_def]"], ["proof (prove)\nusing this:\n  \\<lbrakk>path inv'.lvE ?w5 ?pl5 ?w5; ?pl5 \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i<num_acc.\n                       \\<forall>q\\<in>set ?pl5. i \\<notin> acc q\n\ngoal (2 subgoals):\n 1. None = None \\<Longrightarrow>\n    \\<nexists>v pl.\n       pl \\<noteq> [] \\<and>\n       path inv'.lvE v pl v \\<and>\n       (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\n 2. \\<And>Vr Vl. None = Some (Vr, Vl) \\<Longrightarrow> ce_correct Vr Vl", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Vr Vl. None = Some (Vr, Vl) \\<Longrightarrow> ce_correct Vr Vl", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fgl_invar_part (None, collapse v (p, D, pE'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma collapse_ne: \"([],D',pE') \\<noteq> collapse v (p,D,pE)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([], D', pE') \\<noteq> collapse v (p, D, pE)", "by (simp add: collapse_def collapse_aux_def Let_def)"], ["", "lemma fgl_invar_push:\n    assumes INV: \"fgl_invar v0 D0 (None,p,D,pE)\"\n    assumes BRK[simp]: \"brk=None\" \n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes E: \"(u,v)\\<in>pE\" and UIL: \"u\\<in>last p\"\n    assumes VNE: \"v\\<notin>\\<Union>(set p)\" \"v\\<notin>D\"\n    assumes INV': \"invar v0 D0 (push v (p,D,pE - {(u,v)}))\"\n    shows \"fgl_invar_part (None, push v (p,D,pE - {(u,v)}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, push v (p, D, pE - {(u, v)}))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, push v (p, D, pE - {(u, v)}))", "from INV"], ["proof (chain)\npicking this:\n  fgl_invar v0 D0 (None, p, D, pE)", "interpret fgl_invar_loc G v0 D0 None p D pE"], ["proof (prove)\nusing this:\n  fgl_invar v0 D0 (None, p, D, pE)\n\ngoal (1 subgoal):\n 1. fgl_invar_loc G v0 D0 None p D pE", "by (simp add: fgl_invar_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, push v (p, D, pE - {(u, v)}))", "define pE' where \"pE' = (pE - {(u,v)} \\<union> E\\<inter>{v}\\<times>UNIV)\""], ["proof (state)\nthis:\n  pE' = pE - {(u, v)} \\<union> E \\<inter> {v} \\<times> UNIV\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, push v (p, D, pE - {(u, v)}))", "have [simp]: \"push v (p,D,pE - {(u,v)}) = (p@[{v}],D,pE')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. push v (p, D, pE - {(u, v)}) = (p @ [{v}], D, pE')", "by (simp add: push_def pE'_def)"], ["proof (state)\nthis:\n  push v (p, D, pE - {(u, v)}) = (p @ [{v}], D, pE')\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, push v (p, D, pE - {(u, v)}))", "from INV'"], ["proof (chain)\npicking this:\n  invar v0 D0 (push v (p, D, pE - {(u, v)}))", "interpret inv': invar_loc G v0 D0 \"(p@[{v}])\" D \"pE'\""], ["proof (prove)\nusing this:\n  invar v0 D0 (push v (p, D, pE - {(u, v)}))\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 (p @ [{v}]) D pE'", "by (simp add: invar_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, push v (p, D, pE - {(u, v)}))", "note defs_fold = vE_push[OF E UIL VNE, folded pE'_def]"], ["proof (state)\nthis:\n  inv'.lvE = insert (u, v) lvE\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, push v (p, D, pE - {(u, v)}))", "{"], ["proof (state)\nthis:\n  inv'.lvE = insert (u, v) lvE\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, push v (p, D, pE - {(u, v)}))", "txt \\<open>We show that there still is no loop that contains all accepting\n        nodes. For this, we choose some loop.\\<close>"], ["proof (state)\nthis:\n  inv'.lvE = insert (u, v) lvE\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, push v (p, D, pE - {(u, v)}))", "fix w pl"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, push v (p, D, pE - {(u, v)}))", "assume P: \"path (insert (u,v) lvE) w pl w\" and [simp]: \"pl\\<noteq>[]\""], ["proof (state)\nthis:\n  path (insert (u, v) lvE) w pl w\n  pl \\<noteq> []\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, push v (p, D, pE - {(u, v)}))", "have \"\\<exists>i<num_acc. \\<forall>q\\<in>set pl. i\\<notin>acc q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "assume \"v\\<in>set pl\" \\<comment> \\<open>Case: The newly pushed last cnode is on the loop\\<close>"], ["proof (state)\nthis:\n  v \\<in> set pl\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "txt \\<open>Then the loop is entirely on the last cnode\\<close>"], ["proof (state)\nthis:\n  v \\<in> set pl\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "with inv'.loop_in_lastnode[unfolded defs_fold, OF P]"], ["proof (chain)\npicking this:\n  \\<lbrakk>p @ [{v}] \\<noteq> [];\n   set pl \\<inter> last (p @ [{v}]) \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> w \\<in> last (p @ [{v}])\n  \\<lbrakk>p @ [{v}] \\<noteq> [];\n   set pl \\<inter> last (p @ [{v}]) \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> set pl \\<subseteq> last (p @ [{v}])\n  v \\<in> set pl", "have [simp]: \"w=v\" and SPL: \"set pl = {v}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>p @ [{v}] \\<noteq> [];\n   set pl \\<inter> last (p @ [{v}]) \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> w \\<in> last (p @ [{v}])\n  \\<lbrakk>p @ [{v}] \\<noteq> [];\n   set pl \\<inter> last (p @ [{v}]) \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> set pl \\<subseteq> last (p @ [{v}])\n  v \\<in> set pl\n\ngoal (1 subgoal):\n 1. w = v &&& set pl = {v}", "by auto"], ["proof (state)\nthis:\n  w = v\n  set pl = {v}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "txt \\<open>However, we then either have that the last cnode is contained in\n          the last but one cnode, or that there is a visited edge inside the\n          last cnode.\\<close>"], ["proof (state)\nthis:\n  w = v\n  set pl = {v}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "from P SPL"], ["proof (chain)\npicking this:\n  path (insert (u, v) lvE) w pl w\n  set pl = {v}", "have \"u=v \\<or> (v,v)\\<in>lvE\""], ["proof (prove)\nusing this:\n  path (insert (u, v) lvE) w pl w\n  set pl = {v}\n\ngoal (1 subgoal):\n 1. u = v \\<or> (v, v) \\<in> lvE", "apply (cases pl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>path (insert (u, v) lvE) w pl w; set pl = {v}; pl = []\\<rbrakk>\n    \\<Longrightarrow> u = v \\<or> (v, v) \\<in> lvE\n 2. \\<And>a list.\n       \\<lbrakk>path (insert (u, v) lvE) w pl w; set pl = {v};\n        pl = a # list\\<rbrakk>\n       \\<Longrightarrow> u = v \\<or> (v, v) \\<in> lvE", "apply (auto simp: path_cons_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list va.\n       \\<lbrakk>set list \\<subseteq> {v}; pl = v # list;\n        path (insert (u, v) lvE) va list v; (v, v) \\<notin> lvE;\n        (v, va) \\<in> lvE\\<rbrakk>\n       \\<Longrightarrow> u = v", "apply (case_tac list)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>list va.\n       \\<lbrakk>set list \\<subseteq> {v}; pl = v # list;\n        path (insert (u, v) lvE) va list v; (v, v) \\<notin> lvE;\n        (v, va) \\<in> lvE; list = []\\<rbrakk>\n       \\<Longrightarrow> u = v\n 2. \\<And>list va a lista.\n       \\<lbrakk>set list \\<subseteq> {v}; pl = v # list;\n        path (insert (u, v) lvE) va list v; (v, v) \\<notin> lvE;\n        (v, va) \\<in> lvE; list = a # lista\\<rbrakk>\n       \\<Longrightarrow> u = v", "apply (auto simp: path_cons_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  u = v \\<or> (v, v) \\<in> lvE\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "txt \\<open>Both leads to a contradiction\\<close>"], ["proof (state)\nthis:\n  u = v \\<or> (v, v) \\<in> lvE\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "hence False"], ["proof (prove)\nusing this:\n  u = v \\<or> (v, v) \\<in> lvE\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow> False\n 2. (v, v) \\<in> lvE \\<Longrightarrow> False", "assume \"u=v\" \\<comment> \\<open>This is impossible, as @{text \"u\"} was on the \n            original path, but @{text \"v\"} was not\\<close>"], ["proof (state)\nthis:\n  u = v\n\ngoal (2 subgoals):\n 1. u = v \\<Longrightarrow> False\n 2. (v, v) \\<in> lvE \\<Longrightarrow> False", "with UIL VNE"], ["proof (chain)\npicking this:\n  u \\<in> last p\n  v \\<notin> \\<Union> (set p)\n  v \\<notin> D\n  u = v", "show False"], ["proof (prove)\nusing this:\n  u \\<in> last p\n  v \\<notin> \\<Union> (set p)\n  v \\<notin> D\n  u = v\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. (v, v) \\<in> lvE \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (v, v) \\<in> lvE \\<Longrightarrow> False", "assume \"(v,v)\\<in>lvE\" \\<comment> \\<open>This is impossible, as all visited edges are\n            from touched nodes, but @{text \"v\"} was untouched\\<close>"], ["proof (state)\nthis:\n  (v, v) \\<in> lvE\n\ngoal (1 subgoal):\n 1. (v, v) \\<in> lvE \\<Longrightarrow> False", "with vE_touched VNE"], ["proof (chain)\npicking this:\n  lvE \\<subseteq> ltouched \\<times> ltouched\n  v \\<notin> \\<Union> (set p)\n  v \\<notin> D\n  (v, v) \\<in> lvE", "show False"], ["proof (prove)\nusing this:\n  lvE \\<subseteq> ltouched \\<times> ltouched\n  v \\<notin> \\<Union> (set p)\n  v \\<notin> D\n  (v, v) \\<in> lvE\n\ngoal (1 subgoal):\n 1. False", "unfolding touched_def"], ["proof (prove)\nusing this:\n  lvE\n  \\<subseteq> (D \\<union> \\<Union> (set p)) \\<times>\n              (D \\<union> \\<Union> (set p))\n  v \\<notin> \\<Union> (set p)\n  v \\<notin> D\n  (v, v) \\<in> lvE\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q\n 2. \\<not> ?P \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", ".."], ["proof (state)\nthis:\n  \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q\n\ngoal (1 subgoal):\n 1. v \\<notin> set pl \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> set pl \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "assume A: \"v\\<notin>set pl\" \n          \\<comment> \\<open>Case: The newly pushed last cnode is not on the loop\\<close>"], ["proof (state)\nthis:\n  v \\<notin> set pl\n\ngoal (1 subgoal):\n 1. v \\<notin> set pl \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "txt \\<open>Then, the path lays inside the old visited edges\\<close>"], ["proof (state)\nthis:\n  v \\<notin> set pl\n\ngoal (1 subgoal):\n 1. v \\<notin> set pl \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "have \"path lvE w pl w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path lvE w pl w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. path lvE w pl w", "have \"w\\<in>set pl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> set pl", "using P"], ["proof (prove)\nusing this:\n  path (insert (u, v) lvE) w pl w\n\ngoal (1 subgoal):\n 1. w \\<in> set pl", "by (cases pl) (auto simp: path_cons_conv)"], ["proof (state)\nthis:\n  w \\<in> set pl\n\ngoal (1 subgoal):\n 1. path lvE w pl w", "with A"], ["proof (chain)\npicking this:\n  v \\<notin> set pl\n  w \\<in> set pl", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<notin> set pl\n  w \\<in> set pl\n\ngoal (1 subgoal):\n 1. path lvE w pl w", "using path_restrict[OF P]"], ["proof (prove)\nusing this:\n  v \\<notin> set pl\n  w \\<in> set pl\n  path (insert (u, v) lvE \\<inter> set pl \\<times> insert w (set (tl pl))) w\n   pl w\n\ngoal (1 subgoal):\n 1. path lvE w pl w", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<notin> set pl; w \\<in> set pl;\n     path\n      (insert (u, v) lvE \\<inter> set pl \\<times> insert w (set (tl pl))) w\n      pl w\\<rbrakk>\n    \\<Longrightarrow> path lvE w pl w", "apply (drule path_mono[of _ lvE, rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<notin> set pl; w \\<in> set pl\\<rbrakk>\n    \\<Longrightarrow> insert (u, v) lvE \\<inter>\n                      set pl \\<times> insert w (set (tl pl))\n                      \\<subseteq> lvE\n 2. \\<lbrakk>v \\<notin> set pl; w \\<in> set pl; path lvE w pl w\\<rbrakk>\n    \\<Longrightarrow> path lvE w pl w", "apply (cases pl, auto) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<notin> set pl; w \\<in> set pl; path lvE w pl w\\<rbrakk>\n    \\<Longrightarrow> path lvE w pl w", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  path lvE w pl w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path lvE w pl w\n\ngoal (1 subgoal):\n 1. v \\<notin> set pl \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "txt \\<open>And thus, the proposition follows from the invariant on the old\n          state\\<close>"], ["proof (state)\nthis:\n  path lvE w pl w\n\ngoal (1 subgoal):\n 1. v \\<notin> set pl \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "with no_acc"], ["proof (chain)\npicking this:\n  None = None \\<Longrightarrow>\n  \\<nexists>v pl.\n     pl \\<noteq> [] \\<and>\n     path lvE v pl v \\<and>\n     (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\n  path lvE w pl w", "show ?thesis"], ["proof (prove)\nusing this:\n  None = None \\<Longrightarrow>\n  \\<nexists>v pl.\n     pl \\<noteq> [] \\<and>\n     path lvE v pl v \\<and>\n     (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\n  path lvE w pl w\n\ngoal (1 subgoal):\n 1. \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v pl.\n                path lvE v pl v \\<longrightarrow>\n                pl = [] \\<or>\n                (\\<exists>i<num_acc.\n                    \\<forall>q\\<in>set pl. i \\<notin> acc q);\n     path lvE w pl w\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<num_acc.\n                         \\<forall>q\\<in>set pl. i \\<notin> acc q", "using \\<open>pl\\<noteq>[]\\<close>"], ["proof (prove)\nusing this:\n  pl \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v pl.\n                path lvE v pl v \\<longrightarrow>\n                pl = [] \\<or>\n                (\\<exists>i<num_acc.\n                    \\<forall>q\\<in>set pl. i \\<notin> acc q);\n     path lvE w pl w\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<num_acc.\n                         \\<forall>q\\<in>set pl. i \\<notin> acc q", "by blast"], ["proof (state)\nthis:\n  \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, push v (p, D, pE - {(u, v)}))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>path (insert (u, v) lvE) ?w5 ?pl5 ?w5; ?pl5 \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i<num_acc.\n                       \\<forall>q\\<in>set ?pl5. i \\<notin> acc q\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, push v (p, D, pE - {(u, v)}))", "note AUX_no_acc = this"], ["proof (state)\nthis:\n  \\<lbrakk>path (insert (u, v) lvE) ?w5 ?pl5 ?w5; ?pl5 \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i<num_acc.\n                       \\<forall>q\\<in>set ?pl5. i \\<notin> acc q\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, push v (p, D, pE - {(u, v)}))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, push v (p, D, pE - {(u, v)}))", "unfolding fgl_invar_part_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case (None, push v (p, D, pE - {(u, v)})) of\n    (brk, p, D, pE) \\<Rightarrow> fgl_invar_loc_axioms G brk p D pE", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_invar_loc_axioms G None (p @ [{v}]) D pE'", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. None = None \\<Longrightarrow>\n    \\<nexists>v pl.\n       pl \\<noteq> [] \\<and>\n       path inv'.lvE v pl v \\<and>\n       (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\n 2. \\<And>Vr Vl. None = Some (Vr, Vl) \\<Longrightarrow> ce_correct Vr Vl", "unfolding defs_fold"], ["proof (prove)\ngoal (2 subgoals):\n 1. None = None \\<Longrightarrow>\n    \\<nexists>va pl.\n       pl \\<noteq> [] \\<and>\n       path (insert (u, v) lvE) va pl va \\<and>\n       (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\n 2. \\<And>Vr Vl. None = Some (Vr, Vl) \\<Longrightarrow> ce_correct Vr Vl", "using AUX_no_acc"], ["proof (prove)\nusing this:\n  \\<lbrakk>path (insert (u, v) lvE) ?w5 ?pl5 ?w5; ?pl5 \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i<num_acc.\n                       \\<forall>q\\<in>set ?pl5. i \\<notin> acc q\n\ngoal (2 subgoals):\n 1. None = None \\<Longrightarrow>\n    \\<nexists>va pl.\n       pl \\<noteq> [] \\<and>\n       path (insert (u, v) lvE) va pl va \\<and>\n       (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\n 2. \\<And>Vr Vl. None = Some (Vr, Vl) \\<Longrightarrow> ce_correct Vr Vl", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Vr Vl. None = Some (Vr, Vl) \\<Longrightarrow> ce_correct Vr Vl", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fgl_invar_part (None, push v (p, D, pE - {(u, v)}))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fgl_invar_skip:\n    assumes INV: \"fgl_invar v0 D0 (None,p,D,pE)\"\n    assumes BRK[simp]: \"brk=None\" \n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes E: \"(u,v)\\<in>pE\" and UIL: \"u\\<in>last p\"\n    assumes VID: \"v\\<in>D\"\n    assumes INV': \"invar v0 D0 (p, D, (pE - {(u,v)}))\"\n    shows \"fgl_invar_part (None, p, D, (pE - {(u,v)}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, p, D, pE - {(u, v)})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, p, D, pE - {(u, v)})", "from INV"], ["proof (chain)\npicking this:\n  fgl_invar v0 D0 (None, p, D, pE)", "interpret fgl_invar_loc G v0 D0 None p D pE"], ["proof (prove)\nusing this:\n  fgl_invar v0 D0 (None, p, D, pE)\n\ngoal (1 subgoal):\n 1. fgl_invar_loc G v0 D0 None p D pE", "by (simp add: fgl_invar_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, p, D, pE - {(u, v)})", "from INV'"], ["proof (chain)\npicking this:\n  invar v0 D0 (p, D, pE - {(u, v)})", "interpret inv': invar_loc G v0 D0 p D \"(pE - {(u,v)})\""], ["proof (prove)\nusing this:\n  invar v0 D0 (p, D, pE - {(u, v)})\n\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D (pE - {(u, v)})", "by (simp add: invar_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, p, D, pE - {(u, v)})", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, p, D, pE - {(u, v)})", "txt \\<open>We show that there still is no loop that contains all accepting\n        nodes. For this, we choose some loop.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, p, D, pE - {(u, v)})", "fix w pl"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, p, D, pE - {(u, v)})", "assume P: \"path (insert (u,v) lvE) w pl w\" and [simp]: \"pl\\<noteq>[]\""], ["proof (state)\nthis:\n  path (insert (u, v) lvE) w pl w\n  pl \\<noteq> []\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, p, D, pE - {(u, v)})", "from P"], ["proof (chain)\npicking this:\n  path (insert (u, v) lvE) w pl w", "have \"\\<exists>i<num_acc. \\<forall>q\\<in>set pl. i\\<notin>acc q\""], ["proof (prove)\nusing this:\n  path (insert (u, v) lvE) w pl w\n\ngoal (1 subgoal):\n 1. \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "proof (cases rule: path_edge_rev_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. path lvE w pl w \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q\n 2. \\<And>p1 p2.\n       \\<lbrakk>path (insert (u, v) lvE) w p1 u; path lvE v p2 w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<num_acc.\n                            \\<forall>q\\<in>set pl. i \\<notin> acc q", "case no_use \\<comment> \\<open>Case: The loop does not use the new edge\\<close>"], ["proof (state)\nthis:\n  path lvE w pl w\n\ngoal (2 subgoals):\n 1. path lvE w pl w \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q\n 2. \\<And>p1 p2.\n       \\<lbrakk>path (insert (u, v) lvE) w p1 u; path lvE v p2 w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<num_acc.\n                            \\<forall>q\\<in>set pl. i \\<notin> acc q", "txt \\<open>The proposition follows from the invariant for the old state\\<close>"], ["proof (state)\nthis:\n  path lvE w pl w\n\ngoal (2 subgoals):\n 1. path lvE w pl w \\<Longrightarrow>\n    \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q\n 2. \\<And>p1 p2.\n       \\<lbrakk>path (insert (u, v) lvE) w p1 u; path lvE v p2 w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<num_acc.\n                            \\<forall>q\\<in>set pl. i \\<notin> acc q", "with no_acc"], ["proof (chain)\npicking this:\n  None = None \\<Longrightarrow>\n  \\<nexists>v pl.\n     pl \\<noteq> [] \\<and>\n     path lvE v pl v \\<and>\n     (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\n  path lvE w pl w", "show ?thesis"], ["proof (prove)\nusing this:\n  None = None \\<Longrightarrow>\n  \\<nexists>v pl.\n     pl \\<noteq> [] \\<and>\n     path lvE v pl v \\<and>\n     (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\n  path lvE w pl w\n\ngoal (1 subgoal):\n 1. \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v pl.\n                path lvE v pl v \\<longrightarrow>\n                pl = [] \\<or>\n                (\\<exists>i<num_acc.\n                    \\<forall>q\\<in>set pl. i \\<notin> acc q);\n     path lvE w pl w\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<num_acc.\n                         \\<forall>q\\<in>set pl. i \\<notin> acc q", "using \\<open>pl\\<noteq>[]\\<close>"], ["proof (prove)\nusing this:\n  pl \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v pl.\n                path lvE v pl v \\<longrightarrow>\n                pl = [] \\<or>\n                (\\<exists>i<num_acc.\n                    \\<forall>q\\<in>set pl. i \\<notin> acc q);\n     path lvE w pl w\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i<num_acc.\n                         \\<forall>q\\<in>set pl. i \\<notin> acc q", "by blast"], ["proof (state)\nthis:\n  \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<lbrakk>path (insert (u, v) lvE) w p1 u; path lvE v p2 w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<num_acc.\n                            \\<forall>q\\<in>set pl. i \\<notin> acc q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<lbrakk>path (insert (u, v) lvE) w p1 u; path lvE v p2 w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<num_acc.\n                            \\<forall>q\\<in>set pl. i \\<notin> acc q", "case (split p1 p2) \\<comment> \\<open>Case: The loop uses the new edge\\<close>"], ["proof (state)\nthis:\n  path (insert (u, v) lvE) w p1 u\n  path lvE v p2 w\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<lbrakk>path (insert (u, v) lvE) w p1 u; path lvE v p2 w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<num_acc.\n                            \\<forall>q\\<in>set pl. i \\<notin> acc q", "txt \\<open>As done is closed under transitions, the nodes of the edge have\n          already been visited\\<close>"], ["proof (state)\nthis:\n  path (insert (u, v) lvE) w p1 u\n  path lvE v p2 w\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<lbrakk>path (insert (u, v) lvE) w p1 u; path lvE v p2 w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<num_acc.\n                            \\<forall>q\\<in>set pl. i \\<notin> acc q", "from split(2) D_closed_vE_rtrancl"], ["proof (chain)\npicking this:\n  path lvE v p2 w\n  lvE\\<^sup>* `` D \\<subseteq> D", "have WID: \"w\\<in>D\""], ["proof (prove)\nusing this:\n  path lvE v p2 w\n  lvE\\<^sup>* `` D \\<subseteq> D\n\ngoal (1 subgoal):\n 1. w \\<in> D", "using VID"], ["proof (prove)\nusing this:\n  path lvE v p2 w\n  lvE\\<^sup>* `` D \\<subseteq> D\n  v \\<in> D\n\ngoal (1 subgoal):\n 1. w \\<in> D", "by (auto dest!: path_is_rtrancl)"], ["proof (state)\nthis:\n  w \\<in> D\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<lbrakk>path (insert (u, v) lvE) w p1 u; path lvE v p2 w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<num_acc.\n                            \\<forall>q\\<in>set pl. i \\<notin> acc q", "from split(1) WID D_closed_vE_rtrancl"], ["proof (chain)\npicking this:\n  path (insert (u, v) lvE) w p1 u\n  w \\<in> D\n  lvE\\<^sup>* `` D \\<subseteq> D", "have \"u\\<in>D\""], ["proof (prove)\nusing this:\n  path (insert (u, v) lvE) w p1 u\n  w \\<in> D\n  lvE\\<^sup>* `` D \\<subseteq> D\n\ngoal (1 subgoal):\n 1. u \\<in> D", "apply (cases rule: path_edge_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>w \\<in> D; lvE\\<^sup>* `` D \\<subseteq> D;\n     path lvE w p1 u\\<rbrakk>\n    \\<Longrightarrow> u \\<in> D\n 2. \\<And>p1 p2.\n       \\<lbrakk>w \\<in> D; lvE\\<^sup>* `` D \\<subseteq> D; path lvE w p1 u;\n        path (insert (u, v) lvE) v p2 u\\<rbrakk>\n       \\<Longrightarrow> u \\<in> D", "apply (auto dest!: path_is_rtrancl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  u \\<in> D\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<lbrakk>path (insert (u, v) lvE) w p1 u; path lvE v p2 w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<num_acc.\n                            \\<forall>q\\<in>set pl. i \\<notin> acc q", "txt \\<open>Which is a contradition to the assumptions\\<close>"], ["proof (state)\nthis:\n  u \\<in> D\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<lbrakk>path (insert (u, v) lvE) w p1 u; path lvE v p2 w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<num_acc.\n                            \\<forall>q\\<in>set pl. i \\<notin> acc q", "with UIL p_not_D"], ["proof (chain)\npicking this:\n  u \\<in> last p\n  \\<Union> (set p) \\<inter> D = {}\n  u \\<in> D", "have False"], ["proof (prove)\nusing this:\n  u \\<in> last p\n  \\<Union> (set p) \\<inter> D = {}\n  u \\<in> D\n\ngoal (1 subgoal):\n 1. False", "by (cases p rule: rev_cases) auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<lbrakk>path (insert (u, v) lvE) w p1 u; path lvE v p2 w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<num_acc.\n                            \\<forall>q\\<in>set pl. i \\<notin> acc q", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q", ".."], ["proof (state)\nthis:\n  \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i<num_acc. \\<forall>q\\<in>set pl. i \\<notin> acc q\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, p, D, pE - {(u, v)})", "}"], ["proof (state)\nthis:\n  \\<lbrakk>path (insert (u, v) lvE) ?w5 ?pl5 ?w5; ?pl5 \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i<num_acc.\n                       \\<forall>q\\<in>set ?pl5. i \\<notin> acc q\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, p, D, pE - {(u, v)})", "note AUX_no_acc = this"], ["proof (state)\nthis:\n  \\<lbrakk>path (insert (u, v) lvE) ?w5 ?pl5 ?w5; ?pl5 \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i<num_acc.\n                       \\<forall>q\\<in>set ?pl5. i \\<notin> acc q\n\ngoal (1 subgoal):\n 1. fgl_invar_part (None, p, D, pE - {(u, v)})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_invar_part (None, p, D, pE - {(u, v)})", "apply (simp add: fgl_invar_part_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_invar_loc_axioms G None p D (pE - {(u, v)})", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. None = None \\<Longrightarrow>\n    \\<nexists>v pl.\n       pl \\<noteq> [] \\<and>\n       path inv'.lvE v pl v \\<and>\n       (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\n 2. \\<And>Vr Vl. None = Some (Vr, Vl) \\<Longrightarrow> ce_correct Vr Vl", "unfolding vE_remove[OF NE E]"], ["proof (prove)\ngoal (2 subgoals):\n 1. None = None \\<Longrightarrow>\n    \\<nexists>va pl.\n       pl \\<noteq> [] \\<and>\n       path (insert (u, v) lvE) va pl va \\<and>\n       (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\n 2. \\<And>Vr Vl. None = Some (Vr, Vl) \\<Longrightarrow> ce_correct Vr Vl", "using AUX_no_acc"], ["proof (prove)\nusing this:\n  \\<lbrakk>path (insert (u, v) lvE) ?w5 ?pl5 ?w5; ?pl5 \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i<num_acc.\n                       \\<forall>q\\<in>set ?pl5. i \\<notin> acc q\n\ngoal (2 subgoals):\n 1. None = None \\<Longrightarrow>\n    \\<nexists>va pl.\n       pl \\<noteq> [] \\<and>\n       path (insert (u, v) lvE) va pl va \\<and>\n       (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\n 2. \\<And>Vr Vl. None = Some (Vr, Vl) \\<Longrightarrow> ce_correct Vr Vl", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Vr Vl. None = Some (Vr, Vl) \\<Longrightarrow> ce_correct Vr Vl", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fgl_invar_part (None, p, D, pE - {(u, v)})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fgl_outer_invar_initial: \n    \"outer_invar V0 {} \\<Longrightarrow> fgl_outer_invar_ext V0 (None, {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_invar V0 {} \\<Longrightarrow> fgl_outer_invar_ext V0 (None, {})", "unfolding fgl_outer_invar_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_invar V0 {} \\<Longrightarrow>\n    case (None, {}) of (None, D) \\<Rightarrow> no_acc_over D\n    | (Some (xa, xb), D) \\<Rightarrow> ce_correct xa xb", "apply (simp add: no_acc_over_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fgl_outer_invar_brk:\n    assumes INV: \"fgl_invar v0 D0 (Some (Vr,Vl),p,D,pE)\"\n    shows \"fgl_outer_invar_ext anyIt (Some (Vr,Vl), anyD)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_outer_invar_ext anyIt (Some (Vr, Vl), anyD)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_outer_invar_ext anyIt (Some (Vr, Vl), anyD)", "from INV"], ["proof (chain)\npicking this:\n  fgl_invar v0 D0 (Some (Vr, Vl), p, D, pE)", "interpret fgl_invar_loc G v0 D0 \"Some (Vr,Vl)\" p D pE"], ["proof (prove)\nusing this:\n  fgl_invar v0 D0 (Some (Vr, Vl), p, D, pE)\n\ngoal (1 subgoal):\n 1. fgl_invar_loc G v0 D0 (Some (Vr, Vl)) p D pE", "by (simp add: fgl_invar_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_outer_invar_ext anyIt (Some (Vr, Vl), anyD)", "from acc"], ["proof (chain)\npicking this:\n  Some (Vr, Vl) = Some (?Vr, ?Vl) \\<Longrightarrow> ce_correct ?Vr ?Vl", "show ?thesis"], ["proof (prove)\nusing this:\n  Some (Vr, Vl) = Some (?Vr, ?Vl) \\<Longrightarrow> ce_correct ?Vr ?Vl\n\ngoal (1 subgoal):\n 1. fgl_outer_invar_ext anyIt (Some (Vr, Vl), anyD)", "by (simp add: fgl_outer_invar_ext_def)"], ["proof (state)\nthis:\n  fgl_outer_invar_ext anyIt (Some (Vr, Vl), anyD)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fgl_outer_invar_newnode_nobrk:\n    assumes A: \"v0\\<notin>D0\" \"v0\\<in>it\" \n    assumes OINV: \"fgl_outer_invar it (None,D0)\"\n    assumes INV: \"fgl_invar v0 D0 (None,[],D',pE)\"\n    shows \"fgl_outer_invar_ext (it-{v0}) (None,D')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_outer_invar_ext (it - {v0}) (None, D')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_outer_invar_ext (it - {v0}) (None, D')", "from OINV"], ["proof (chain)\npicking this:\n  fgl_outer_invar it (None, D0)", "interpret outer_invar_loc G it D0"], ["proof (prove)\nusing this:\n  fgl_outer_invar it (None, D0)\n\ngoal (1 subgoal):\n 1. outer_invar_loc G it D0", "unfolding fgl_outer_invar_def outer_invar_def"], ["proof (prove)\nusing this:\n  case (None, D0) of\n  (None, D) \\<Rightarrow> outer_invar_loc G it D \\<and> no_acc_over D\n  | (Some (xa, xb), D) \\<Rightarrow> ce_correct xa xb\n\ngoal (1 subgoal):\n 1. outer_invar_loc G it D0", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_outer_invar_ext (it - {v0}) (None, D')", "from INV"], ["proof (chain)\npicking this:\n  fgl_invar v0 D0 (None, [], D', pE)", "interpret inv: fgl_invar_loc G v0 D0 None \"[]\" D' pE"], ["proof (prove)\nusing this:\n  fgl_invar v0 D0 (None, [], D', pE)\n\ngoal (1 subgoal):\n 1. fgl_invar_loc G v0 D0 None [] D' pE", "unfolding fgl_invar_def"], ["proof (prove)\nusing this:\n  case (None, [], D', pE) of\n  (brk, p, D, pE) \\<Rightarrow> fgl_invar_loc G v0 D0 brk p D pE\n\ngoal (1 subgoal):\n 1. fgl_invar_loc G v0 D0 None [] D' pE", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_outer_invar_ext (it - {v0}) (None, D')", "from inv.pE_fin"], ["proof (chain)\npicking this:\n  [] = [] \\<Longrightarrow> pE = {}", "have [simp]: \"pE = {}\""], ["proof (prove)\nusing this:\n  [] = [] \\<Longrightarrow> pE = {}\n\ngoal (1 subgoal):\n 1. pE = {}", "by simp"], ["proof (state)\nthis:\n  pE = {}\n\ngoal (1 subgoal):\n 1. fgl_outer_invar_ext (it - {v0}) (None, D')", "{"], ["proof (state)\nthis:\n  pE = {}\n\ngoal (1 subgoal):\n 1. fgl_outer_invar_ext (it - {v0}) (None, D')", "fix v pl"], ["proof (state)\ngoal (1 subgoal):\n 1. fgl_outer_invar_ext (it - {v0}) (None, D')", "assume A: \"v\\<in>D'\" \"path E v pl v\""], ["proof (state)\nthis:\n  v \\<in> D'\n  path E v pl v\n\ngoal (1 subgoal):\n 1. fgl_outer_invar_ext (it - {v0}) (None, D')", "have \"path (E \\<inter> D' \\<times> UNIV) v pl v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (E \\<inter> D' \\<times> UNIV) v pl v", "apply (rule path_mono[OF _ path_restrict_closed[OF inv.D_closed A]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Restr E D' \\<subseteq> E \\<inter> D' \\<times> UNIV", "by auto"], ["proof (state)\nthis:\n  path (E \\<inter> D' \\<times> UNIV) v pl v\n\ngoal (1 subgoal):\n 1. fgl_outer_invar_ext (it - {v0}) (None, D')", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?v5 \\<in> D'; path E ?v5 ?pl5 ?v5\\<rbrakk>\n  \\<Longrightarrow> path (E \\<inter> D' \\<times> UNIV) ?v5 ?pl5 ?v5\n\ngoal (1 subgoal):\n 1. fgl_outer_invar_ext (it - {v0}) (None, D')", "note AUX1=this"], ["proof (state)\nthis:\n  \\<lbrakk>?v5 \\<in> D'; path E ?v5 ?pl5 ?v5\\<rbrakk>\n  \\<Longrightarrow> path (E \\<inter> D' \\<times> UNIV) ?v5 ?pl5 ?v5\n\ngoal (1 subgoal):\n 1. fgl_outer_invar_ext (it - {v0}) (None, D')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_outer_invar_ext (it - {v0}) (None, D')", "unfolding fgl_outer_invar_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case (None, D') of (None, D) \\<Rightarrow> no_acc_over D\n    | (Some (xa, xb), D) \\<Rightarrow> ce_correct xa xb", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. no_acc_over D'", "using inv.no_acc AUX1"], ["proof (prove)\nusing this:\n  None = None \\<Longrightarrow>\n  \\<nexists>v pl.\n     pl \\<noteq> [] \\<and>\n     path inv.lvE v pl v \\<and>\n     (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\n  \\<lbrakk>?v5 \\<in> D'; path E ?v5 ?pl5 ?v5\\<rbrakk>\n  \\<Longrightarrow> path (E \\<inter> D' \\<times> UNIV) ?v5 ?pl5 ?v5\n\ngoal (1 subgoal):\n 1. no_acc_over D'", "apply (auto simp add: vE_def touched_def no_acc_over_def) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fgl_outer_invar_ext (it - {v0}) (None, D')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fgl_outer_invar_newnode:\n    assumes A: \"v0\\<notin>D0\" \"v0\\<in>it\" \n    assumes OINV: \"fgl_outer_invar it (None,D0)\"\n    assumes INV: \"fgl_invar v0 D0 (brk,p,D',pE)\"\n    assumes CASES: \"(\\<exists>Vr Vl. brk = Some (Vr, Vl)) \\<or> p = []\"\n    shows \"fgl_outer_invar_ext (it-{v0}) (brk,D')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_outer_invar_ext (it - {v0}) (brk, D')", "using CASES"], ["proof (prove)\nusing this:\n  (\\<exists>Vr Vl. brk = Some (Vr, Vl)) \\<or> p = []\n\ngoal (1 subgoal):\n 1. fgl_outer_invar_ext (it - {v0}) (brk, D')", "apply (elim disjE1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>Vr Vl. brk = Some (Vr, Vl) \\<Longrightarrow>\n    fgl_outer_invar_ext (it - {v0}) (brk, D')\n 2. \\<lbrakk>\\<nexists>Vr Vl. brk = Some (Vr, Vl); p = []\\<rbrakk>\n    \\<Longrightarrow> fgl_outer_invar_ext (it - {v0}) (brk, D')", "using fgl_outer_invar_brk[of v0 D0 _ _ p D' pE] INV"], ["proof (prove)\nusing this:\n  fgl_invar v0 D0 (Some (?Vr, ?Vl), p, D', pE) \\<Longrightarrow>\n  fgl_outer_invar_ext ?anyIt (Some (?Vr, ?Vl), ?anyD)\n  fgl_invar v0 D0 (brk, p, D', pE)\n\ngoal (2 subgoals):\n 1. \\<exists>Vr Vl. brk = Some (Vr, Vl) \\<Longrightarrow>\n    fgl_outer_invar_ext (it - {v0}) (brk, D')\n 2. \\<lbrakk>\\<nexists>Vr Vl. brk = Some (Vr, Vl); p = []\\<rbrakk>\n    \\<Longrightarrow> fgl_outer_invar_ext (it - {v0}) (brk, D')", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<exists>Vr Vl. brk = Some (Vr, Vl);\n     \\<And>Vr Vl anyIt anyD.\n        fgl_invar v0 D0 (Some (Vr, Vl), p, D', pE) \\<Longrightarrow>\n        fgl_outer_invar_ext anyIt (Some (Vr, Vl), anyD);\n     fgl_invar v0 D0 (brk, p, D', pE)\\<rbrakk>\n    \\<Longrightarrow> fgl_outer_invar_ext (it - {v0}) (brk, D')\n 2. \\<lbrakk>\\<nexists>Vr Vl. brk = Some (Vr, Vl); p = [];\n     \\<And>Vr Vl anyIt anyD.\n        fgl_invar v0 D0 (Some (Vr, Vl), p, D', pE) \\<Longrightarrow>\n        fgl_outer_invar_ext anyIt (Some (Vr, Vl), anyD);\n     fgl_invar v0 D0 (brk, p, D', pE)\\<rbrakk>\n    \\<Longrightarrow> fgl_outer_invar_ext (it - {v0}) (brk, D')", "apply (auto, assumption) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nexists>Vr Vl. brk = Some (Vr, Vl); p = [];\n     \\<And>Vr Vl anyIt anyD.\n        fgl_invar v0 D0 (Some (Vr, Vl), p, D', pE) \\<Longrightarrow>\n        fgl_outer_invar_ext anyIt (Some (Vr, Vl), anyD);\n     fgl_invar v0 D0 (brk, p, D', pE)\\<rbrakk>\n    \\<Longrightarrow> fgl_outer_invar_ext (it - {v0}) (brk, D')", "using fgl_outer_invar_newnode_nobrk[OF A] OINV INV"], ["proof (prove)\nusing this:\n  \\<lbrakk>fgl_outer_invar it (None, D0);\n   fgl_invar v0 D0 (None, [], ?D', ?pE)\\<rbrakk>\n  \\<Longrightarrow> fgl_outer_invar_ext (it - {v0}) (None, ?D')\n  fgl_outer_invar it (None, D0)\n  fgl_invar v0 D0 (brk, p, D', pE)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<nexists>Vr Vl. brk = Some (Vr, Vl); p = [];\n     \\<And>Vr Vl anyIt anyD.\n        fgl_invar v0 D0 (Some (Vr, Vl), p, D', pE) \\<Longrightarrow>\n        fgl_outer_invar_ext anyIt (Some (Vr, Vl), anyD);\n     fgl_invar v0 D0 (brk, p, D', pE)\\<rbrakk>\n    \\<Longrightarrow> fgl_outer_invar_ext (it - {v0}) (brk, D')", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fgl_outer_invar_Dnode:\n    assumes \"fgl_outer_invar it (None, D)\" \"v\\<in>D\"\n    shows \"fgl_outer_invar_ext (it - {v}) (None, D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_outer_invar_ext (it - {v}) (None, D)", "using assms"], ["proof (prove)\nusing this:\n  fgl_outer_invar it (None, D)\n  v \\<in> D\n\ngoal (1 subgoal):\n 1. fgl_outer_invar_ext (it - {v}) (None, D)", "by (auto simp: fgl_outer_invar_def fgl_outer_invar_ext_def)"], ["", "lemma fgl_fin_no_lasso:\n    assumes A: \"fgl_outer_invar {} (None, D)\"\n    assumes B: \"is_lasso_prpl prpl\"\n    shows \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "obtain \"pr\" pl where [simp]: \"prpl = (pr,pl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>pr pl.\n        prpl = (pr, pl) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases prpl)"], ["proof (state)\nthis:\n  prpl = (pr, pl)\n\ngoal (1 subgoal):\n 1. False", "from A"], ["proof (chain)\npicking this:\n  fgl_outer_invar {} (None, D)", "have NA: \"no_acc_over D\""], ["proof (prove)\nusing this:\n  fgl_outer_invar {} (None, D)\n\ngoal (1 subgoal):\n 1. no_acc_over D", "by (simp add: fgl_outer_invar_def fgl_outer_invar_ext_def)"], ["proof (state)\nthis:\n  no_acc_over D\n\ngoal (1 subgoal):\n 1. False", "from A"], ["proof (chain)\npicking this:\n  fgl_outer_invar {} (None, D)", "have \"outer_invar {} D\""], ["proof (prove)\nusing this:\n  fgl_outer_invar {} (None, D)\n\ngoal (1 subgoal):\n 1. outer_invar {} D", "by (simp add: fgl_outer_invar_def)"], ["proof (state)\nthis:\n  outer_invar {} D\n\ngoal (1 subgoal):\n 1. False", "with fin_outer_D_is_reachable"], ["proof (chain)\npicking this:\n  outer_invar {} ?D \\<Longrightarrow> ?D = reachable\n  outer_invar {} D", "have [simp]: \"D=E\\<^sup>*``V0\""], ["proof (prove)\nusing this:\n  outer_invar {} ?D \\<Longrightarrow> ?D = reachable\n  outer_invar {} D\n\ngoal (1 subgoal):\n 1. D = reachable", "by simp"], ["proof (state)\nthis:\n  D = reachable\n\ngoal (1 subgoal):\n 1. False", "from NA B"], ["proof (chain)\npicking this:\n  no_acc_over D\n  is_lasso_prpl prpl", "show False"], ["proof (prove)\nusing this:\n  no_acc_over D\n  is_lasso_prpl prpl\n\ngoal (1 subgoal):\n 1. False", "apply (simp add: no_acc_over_def is_lasso_prpl_def is_lasso_prpl_pre_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v\\<in>reachable.\n                \\<forall>pl.\n                   path E v pl v \\<longrightarrow>\n                   pl = [] \\<or>\n                   (\\<exists>i<num_acc.\n                       \\<forall>q\\<in>set pl. i \\<notin> acc q);\n     (\\<exists>v0.\n         v0 \\<in> V0 \\<and>\n         pl \\<noteq> [] \\<and>\n         (\\<exists>va. path E v0 pr va \\<and> path E va pl va)) \\<and>\n     (\\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q)\\<rbrakk>\n    \\<Longrightarrow> False", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v0 va.\n       \\<lbrakk>\\<forall>v\\<in>reachable.\n                   \\<forall>pl.\n                      path E v pl v \\<longrightarrow>\n                      pl = [] \\<or>\n                      (\\<exists>i<num_acc.\n                          \\<forall>q\\<in>set pl. i \\<notin> acc q);\n        \\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q;\n        v0 \\<in> V0; pl \\<noteq> []; path E v0 pr va;\n        path E va pl va\\<rbrakk>\n       \\<Longrightarrow> False", "apply (blast dest: path_is_rtrancl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fgl_fin_lasso:\n    assumes A: \"fgl_outer_invar it (Some (Vr,Vl), D)\"\n    shows \"ce_correct Vr Vl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ce_correct Vr Vl", "using A"], ["proof (prove)\nusing this:\n  fgl_outer_invar it (Some (Vr, Vl), D)\n\ngoal (1 subgoal):\n 1. ce_correct Vr Vl", "by (simp add: fgl_outer_invar_def fgl_outer_invar_ext_def)"], ["", "lemmas fgl_invar_preserve = \n    fgl_invar_initial fgl_invar_push fgl_invar_pop \n    fgl_invar_collapse_ce fgl_invar_collapse_nce fgl_invar_skip\n    fgl_outer_invar_newnode fgl_outer_invar_Dnode\n    invar_initial outer_invar_initial fgl_invar_initial fgl_outer_invar_initial\n    fgl_fin_no_lasso fgl_fin_lasso"], ["", "end"], ["", "section \\<open>Main Correctness Proof\\<close>"], ["", "context igb_fr_graph\nbegin"], ["", "lemma outer_invar_from_fgl_invarI: \n    \"fgl_outer_invar it (None,D) \\<Longrightarrow> outer_invar it D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_outer_invar it (None, D) \\<Longrightarrow> outer_invar it D", "unfolding fgl_outer_invar_def outer_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case (None, D) of\n    (None, D) \\<Rightarrow> outer_invar_loc G it D \\<and> no_acc_over D\n    | (Some (xa, xb), D) \\<Rightarrow> ce_correct xa xb \\<Longrightarrow>\n    outer_invar_loc G it D", "by (simp split: prod.splits)"], ["", "lemma invar_from_fgl_invarI: \"fgl_invar v0 D0 (B,PDPE) \\<Longrightarrow> invar v0 D0 PDPE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fgl_invar v0 D0 (B, PDPE) \\<Longrightarrow> invar v0 D0 PDPE", "unfolding fgl_invar_def invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case (B, PDPE) of\n    (brk, p, D, pE) \\<Rightarrow>\n      fgl_invar_loc G v0 D0 brk p D pE \\<Longrightarrow>\n    case PDPE of (p, xa, xb) \\<Rightarrow> invar_loc G v0 D0 p xa xb", "apply (simp split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>PDPE = (x1, x1a, x2a); x2 = (x1a, x2a);\n        fgl_invar_loc G v0 D0 B x1 x1a x2a\\<rbrakk>\n       \\<Longrightarrow> invar_loc G v0 D0 x1 x1a x2a", "unfolding fgl_invar_loc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>PDPE = (x1, x1a, x2a); x2 = (x1a, x2a);\n        invar_loc G v0 D0 x1 x1a x2a \\<and>\n        igb_graph G \\<and> fgl_invar_loc_axioms G B x1 x1a x2a\\<rbrakk>\n       \\<Longrightarrow> invar_loc G v0 D0 x1 x1a x2a", "by simp"], ["", "theorem find_ce_correct: \"find_ce \\<le> find_ce_spec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_ce \\<le> find_ce_spec", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. find_ce \\<le> find_ce_spec", "note [simp del] = Union_iff"], ["proof (state)\nthis:\n  (?A \\<in> \\<Union> ?C) = (\\<exists>X\\<in>?C. ?A \\<in> X)\n\ngoal (1 subgoal):\n 1. find_ce \\<le> find_ce_spec", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. find_ce \\<le> find_ce_spec", "unfolding find_ce_def find_ce_spec_def select_edge_def select_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let D = {}\n     in FOREACH\\<^sub>C\\<^bsup>fgl_outer_invar\\<^esup> V0\n         (\\<lambda>(brk, uu_). brk = None)\n         (\\<lambda>v0 (brk, D0).\n             if v0 \\<notin> D0\n             then let s = (None, initial v0 D0)\n                  in WHILE\\<^sub>T\\<^bsup>fgl_invar v0 D0\\<^esup>\n                      (\\<lambda>(brk, p, D, pE).\n                          brk = None \\<and> p \\<noteq> [])\n                      (\\<lambda>(uu_, p, D, pE).\n                          (let (p, D, pE) = (p, D, pE)\n                           in SELECT\n                               (\\<lambda>e.\n                                   e \\<in> pE \\<inter>\n     last p \\<times> UNIV) \\<bind>\n                              (\\<lambda>e.\n                                  case e of\n                                  None \\<Rightarrow> RETURN (None, p, D, pE)\n                                  | Some (u, v) \\<Rightarrow>\nRETURN (Some v, p, D, pE - {(u, v)}))) \\<bind>\n                          (\\<lambda>(vo, p, D, pE).\n                              ASSERT (p \\<noteq> []) \\<bind>\n                              (\\<lambda>_.\n                                  case vo of\n                                  None \\<Rightarrow>\n                                    ASSERT\n                                     (pE \\<inter> last p \\<times> UNIV =\n{}) \\<bind>\n                                    (\\<lambda>_.\n  RETURN (None, pop (p, D, pE)))\n                                  | Some v \\<Rightarrow>\nif v \\<in> \\<Union> (set p)\nthen let (p, D, pE) = collapse v (p, D, pE)\n     in ASSERT (p \\<noteq> []) \\<bind>\n        (\\<lambda>_.\n            if \\<forall>i<num_acc. \\<exists>q\\<in>last p. i \\<in> acc q\n            then RETURN\n                  (Some (\\<Union> (set (butlast p)), last p), p, D, pE)\n            else RETURN (None, p, D, pE))\nelse if v \\<notin> D then RETURN (None, push v (p, D, pE))\n     else RETURN (None, p, D, pE))))\n                      s \\<bind>\n                     (\\<lambda>(brk, p, D, pE).\n                         ASSERT\n                          (brk = None \\<longrightarrow>\n                           p = [] \\<and> pE = {}) \\<bind>\n                         (\\<lambda>_. RETURN (brk, D)))\n             else RETURN (brk, D0))\n         (None, D) \\<bind>\n        (\\<lambda>(brk, uu_). RETURN brk))\n    \\<le> SPEC\n           (\\<lambda>r.\n               case r of\n               None \\<Rightarrow> \\<forall>prpl. \\<not> is_lasso_prpl prpl\n               | Some (x, xa) \\<Rightarrow> ce_correct x xa)", "apply (refine_rcg\n        WHILEIT_rule[where R=\"inv_image (abs_wf_rel v0) snd\" for v0]\n        refine_vcg \n      )"], ["proof (prove)\ngoal (62 subgoals):\n 1. finite V0\n 2. fgl_outer_invar V0 (None, {})\n 3. \\<And>x it \\<sigma> a b.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> V0; fgl_outer_invar it \\<sigma>;\n        case \\<sigma> of (brk, uu_) \\<Rightarrow> brk = None;\n        \\<sigma> = (a, b); x \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> wf (inv_image\n                              (abs_wf_rel (?v0.14 x it \\<sigma> a b)) snd)\n 4. \\<And>x it \\<sigma> a b.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> V0; fgl_outer_invar it \\<sigma>;\n        case \\<sigma> of (brk, uu_) \\<Rightarrow> brk = None;\n        \\<sigma> = (a, b); x \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> fgl_invar x b (None, initial x b)\n 5. \\<And>x it \\<sigma> a b s aa ba ab bb ac bc ad bd ae be xa af bf ag bg\n       ah bh.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> V0; fgl_outer_invar it \\<sigma>;\n        case \\<sigma> of (brk, uu_) \\<Rightarrow> brk = None;\n        \\<sigma> = (a, b); x \\<notin> b; fgl_invar x b s;\n        case s of\n        (brk, p, D, pE) \\<Rightarrow> brk = None \\<and> p \\<noteq> [];\n        s = (aa, ba); ba = (ab, bb); bb = (ac, bc); (ab, ac, bc) = (ad, bd);\n        bd = (ae, be); xa \\<in> be \\<inter> last ad \\<times> UNIV;\n        Some xa = None; (None, ad, ae, be) = (af, bf); bf = (ag, bg);\n        bg = (ah, bh)\\<rbrakk>\n       \\<Longrightarrow> ag \\<noteq> []\n 6. \\<And>x it \\<sigma> a b s aa ba ab bb ac bc ad bd ae be xa af bf ag bg\n       ah bh.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> V0; fgl_outer_invar it \\<sigma>;\n        case \\<sigma> of (brk, uu_) \\<Rightarrow> brk = None;\n        \\<sigma> = (a, b); x \\<notin> b; fgl_invar x b s;\n        case s of\n        (brk, p, D, pE) \\<Rightarrow> brk = None \\<and> p \\<noteq> [];\n        s = (aa, ba); ba = (ab, bb); bb = (ac, bc); (ab, ac, bc) = (ad, bd);\n        bd = (ae, be); xa \\<in> be \\<inter> last ad \\<times> UNIV;\n        Some xa = None; (None, ad, ae, be) = (af, bf); bf = (ag, bg);\n        bg = (ah, bh); ag \\<noteq> []; af = None\\<rbrakk>\n       \\<Longrightarrow> bh \\<inter> last ag \\<times> UNIV = {}\n 7. \\<And>x it \\<sigma> a b s aa ba ab bb ac bc ad bd ae be xa af bf ag bg\n       ah bh.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> V0; fgl_outer_invar it \\<sigma>;\n        case \\<sigma> of (brk, uu_) \\<Rightarrow> brk = None;\n        \\<sigma> = (a, b); x \\<notin> b; fgl_invar x b s;\n        case s of\n        (brk, p, D, pE) \\<Rightarrow> brk = None \\<and> p \\<noteq> [];\n        s = (aa, ba); ba = (ab, bb); bb = (ac, bc); (ab, ac, bc) = (ad, bd);\n        bd = (ae, be); xa \\<in> be \\<inter> last ad \\<times> UNIV;\n        Some xa = None; (None, ad, ae, be) = (af, bf); bf = (ag, bg);\n        bg = (ah, bh); ag \\<noteq> []; af = None;\n        bh \\<inter> last ag \\<times> UNIV = {}\\<rbrakk>\n       \\<Longrightarrow> fgl_invar x b (None, pop (ag, ah, bh))\n 8. \\<And>x it \\<sigma> a b s aa ba ab bb ac bc ad bd ae be xa af bf ag bg\n       ah bh.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> V0; fgl_outer_invar it \\<sigma>;\n        case \\<sigma> of (brk, uu_) \\<Rightarrow> brk = None;\n        \\<sigma> = (a, b); x \\<notin> b; fgl_invar x b s;\n        case s of\n        (brk, p, D, pE) \\<Rightarrow> brk = None \\<and> p \\<noteq> [];\n        s = (aa, ba); ba = (ab, bb); bb = (ac, bc); (ab, ac, bc) = (ad, bd);\n        bd = (ae, be); xa \\<in> be \\<inter> last ad \\<times> UNIV;\n        Some xa = None; (None, ad, ae, be) = (af, bf); bf = (ag, bg);\n        bg = (ah, bh); ag \\<noteq> []; af = None;\n        bh \\<inter> last ag \\<times> UNIV = {}\\<rbrakk>\n       \\<Longrightarrow> ((None, pop (ag, ah, bh)), s)\n                         \\<in> inv_image\n                                (abs_wf_rel (?v0.14 x it \\<sigma> a b)) snd\n 9. \\<And>x it \\<sigma> a b s aa ba ab bb ac bc ad bd ae be xa af bf ag bg\n       ah bh xb ai bi aj bj.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> V0; fgl_outer_invar it \\<sigma>;\n        case \\<sigma> of (brk, uu_) \\<Rightarrow> brk = None;\n        \\<sigma> = (a, b); x \\<notin> b; fgl_invar x b s;\n        case s of\n        (brk, p, D, pE) \\<Rightarrow> brk = None \\<and> p \\<noteq> [];\n        s = (aa, ba); ba = (ab, bb); bb = (ac, bc); (ab, ac, bc) = (ad, bd);\n        bd = (ae, be); xa \\<in> be \\<inter> last ad \\<times> UNIV;\n        Some xa = None; (None, ad, ae, be) = (af, bf); bf = (ag, bg);\n        bg = (ah, bh); ag \\<noteq> []; af = Some xb;\n        xb \\<in> \\<Union> (set ag); collapse xb (ag, ah, bh) = (ai, bi);\n        bi = (aj, bj)\\<rbrakk>\n       \\<Longrightarrow> ai \\<noteq> []\n 10. \\<And>x it \\<sigma> a b s aa ba ab bb ac bc ad bd ae be xa af bf ag bg\n        ah bh xb ai bi aj bj.\n        \\<lbrakk>x \\<in> it; it \\<subseteq> V0; fgl_outer_invar it \\<sigma>;\n         case \\<sigma> of (brk, uu_) \\<Rightarrow> brk = None;\n         \\<sigma> = (a, b); x \\<notin> b; fgl_invar x b s;\n         case s of\n         (brk, p, D, pE) \\<Rightarrow> brk = None \\<and> p \\<noteq> [];\n         s = (aa, ba); ba = (ab, bb); bb = (ac, bc);\n         (ab, ac, bc) = (ad, bd); bd = (ae, be);\n         xa \\<in> be \\<inter> last ad \\<times> UNIV; Some xa = None;\n         (None, ad, ae, be) = (af, bf); bf = (ag, bg); bg = (ah, bh);\n         ag \\<noteq> []; af = Some xb; xb \\<in> \\<Union> (set ag);\n         collapse xb (ag, ah, bh) = (ai, bi); bi = (aj, bj); ai \\<noteq> [];\n         \\<forall>i<num_acc. \\<exists>q\\<in>last ai. i \\<in> acc q\\<rbrakk>\n        \\<Longrightarrow> fgl_invar x b\n                           (Some (\\<Union> (set (butlast ai)), last ai), ai,\n                            aj, bj)\nA total of 62 subgoals...", "using [[goals_limit = 5]]"], ["proof (prove)\ngoal (62 subgoals):\n 1. finite V0\n 2. fgl_outer_invar V0 (None, {})\n 3. \\<And>x it \\<sigma> a b.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> V0; fgl_outer_invar it \\<sigma>;\n        case \\<sigma> of (brk, uu_) \\<Rightarrow> brk = None;\n        \\<sigma> = (a, b); x \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> wf (inv_image\n                              (abs_wf_rel (?v0.14 x it \\<sigma> a b)) snd)\n 4. \\<And>x it \\<sigma> a b.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> V0; fgl_outer_invar it \\<sigma>;\n        case \\<sigma> of (brk, uu_) \\<Rightarrow> brk = None;\n        \\<sigma> = (a, b); x \\<notin> b\\<rbrakk>\n       \\<Longrightarrow> fgl_invar x b (None, initial x b)\n 5. \\<And>x it \\<sigma> a b s aa ba ab bb ac bc ad bd ae be xa af bf ag bg\n       ah bh.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> V0; fgl_outer_invar it \\<sigma>;\n        case \\<sigma> of (brk, uu_) \\<Rightarrow> brk = None;\n        \\<sigma> = (a, b); x \\<notin> b; fgl_invar x b s;\n        case s of\n        (brk, p, D, pE) \\<Rightarrow> brk = None \\<and> p \\<noteq> [];\n        s = (aa, ba); ba = (ab, bb); bb = (ac, bc); (ab, ac, bc) = (ad, bd);\n        bd = (ae, be); xa \\<in> be \\<inter> last ad \\<times> UNIV;\n        Some xa = None; (None, ad, ae, be) = (af, bf); bf = (ag, bg);\n        bg = (ah, bh)\\<rbrakk>\n       \\<Longrightarrow> ag \\<noteq> []\nA total of 62 subgoals...", "apply (vc_solve\n        rec: fgl_invarI fgl_outer_invarI\n        intro: invar_from_fgl_invarI outer_invar_from_fgl_invarI\n        dest!: sym[of \"collapse a b\" for a b]\n        simp: collapse_ne\n        simp: pE_fin'[OF invar_from_fgl_invarI] finite_V0\n        solve: invar_preserve \n        solve: asm_rl[of \"_ \\<inter> _ = {}\"]\n        solve: fgl_invar_preserve)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  find_ce \\<le> find_ce_spec\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "section \"Emptiness Check\""], ["", "text \\<open>Using the lasso-finding algorithm, we can define an emptiness check\\<close>"], ["", "context igb_fr_graph\nbegin"], ["", "definition \"abs_is_empty \\<equiv> do {\n    ce \\<leftarrow> find_ce;\n    RETURN (ce = None)\n    }\""], ["", "theorem abs_is_empty_correct: \n    \"abs_is_empty \\<le> SPEC (\\<lambda>res. res \\<longleftrightarrow> (\\<forall>r. \\<not>is_acc_run r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_is_empty\n    \\<le> SPEC (\\<lambda>res. res = (\\<forall>r. \\<not> is_acc_run r))", "unfolding abs_is_empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. find_ce \\<bind> (\\<lambda>ce. RETURN (ce = None))\n    \\<le> SPEC (\\<lambda>res. res = (\\<forall>r. \\<not> is_acc_run r))", "apply (refine_rcg refine_vcg \n      order_trans[OF find_ce_correct, unfolded find_ce_spec_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       case x of None \\<Rightarrow> \\<forall>prpl. \\<not> is_lasso_prpl prpl\n       | Some (x, xa) \\<Rightarrow> ce_correct x xa \\<Longrightarrow>\n       (x = None) = (\\<forall>r. \\<not> is_acc_run r)", "unfolding ce_correct_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       case x of None \\<Rightarrow> \\<forall>prpl. \\<not> is_lasso_prpl prpl\n       | Some (Vr, Vl) \\<Rightarrow>\n           \\<exists>pr pl.\n              Vr \\<subseteq> reachable \\<and>\n              Vl \\<subseteq> reachable \\<and>\n              set pr \\<subseteq> Vr \\<and>\n              set pl \\<subseteq> Vl \\<and>\n              Vl \\<times> Vl \\<subseteq> (Restr E Vl)\\<^sup>* \\<and>\n              Vl \\<times> Vl \\<inter> E \\<noteq> {} \\<and>\n              is_lasso_prpl (pr, pl) \\<Longrightarrow>\n       (x = None) = (\\<forall>r. \\<not> is_acc_run r)", "using lasso_accepted accepted_lasso"], ["proof (prove)\nusing this:\n  is_lasso ?L \\<Longrightarrow> is_acc_run (run_of_lasso ?L)\n  \\<lbrakk>finite reachable; is_acc_run ?r\\<rbrakk>\n  \\<Longrightarrow> Ex is_lasso\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       case x of None \\<Rightarrow> \\<forall>prpl. \\<not> is_lasso_prpl prpl\n       | Some (Vr, Vl) \\<Rightarrow>\n           \\<exists>pr pl.\n              Vr \\<subseteq> reachable \\<and>\n              Vl \\<subseteq> reachable \\<and>\n              set pr \\<subseteq> Vr \\<and>\n              set pl \\<subseteq> Vl \\<and>\n              Vl \\<times> Vl \\<subseteq> (Restr E Vl)\\<^sup>* \\<and>\n              Vl \\<times> Vl \\<inter> E \\<noteq> {} \\<and>\n              is_lasso_prpl (pr, pl) \\<Longrightarrow>\n       (x = None) = (\\<forall>r. \\<not> is_acc_run r)", "apply (clarsimp split: option.splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>\\<And>L.\n                   is_lasso L \\<Longrightarrow> is_acc_run (run_of_lasso L);\n        \\<And>r. is_acc_run r \\<Longrightarrow> Ex is_lasso;\n        \\<forall>a b. \\<not> is_lasso_prpl (a, b); is_acc_run r\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b pr pl.\n       \\<lbrakk>\\<And>L.\n                   is_lasso L \\<Longrightarrow> is_acc_run (run_of_lasso L);\n        \\<And>r. is_acc_run r \\<Longrightarrow> Ex is_lasso;\n        a \\<subseteq> reachable; b \\<subseteq> reachable;\n        set pr \\<subseteq> a; set pl \\<subseteq> b;\n        b \\<times> b \\<subseteq> (Restr E b)\\<^sup>*;\n        b \\<times> b \\<inter> E \\<noteq> {}; is_lasso_prpl (pr, pl)\\<rbrakk>\n       \\<Longrightarrow> Ex is_acc_run", "apply (metis is_lasso_prpl_of_lasso surj_pair)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b pr pl.\n       \\<lbrakk>\\<And>L.\n                   is_lasso L \\<Longrightarrow> is_acc_run (run_of_lasso L);\n        \\<And>r. is_acc_run r \\<Longrightarrow> Ex is_lasso;\n        a \\<subseteq> reachable; b \\<subseteq> reachable;\n        set pr \\<subseteq> a; set pl \\<subseteq> b;\n        b \\<times> b \\<subseteq> (Restr E b)\\<^sup>*;\n        b \\<times> b \\<inter> E \\<noteq> {}; is_lasso_prpl (pr, pl)\\<rbrakk>\n       \\<Longrightarrow> Ex is_acc_run", "by (metis is_lasso_prpl_conv)"], ["", "definition \"abs_is_empty_ce \\<equiv> do {\n    ce \\<leftarrow> find_ce;\n    case ce of\n      None \\<Rightarrow> RETURN None\n    | Some (Vr,Vl) \\<Rightarrow> do {\n        ASSERT (\\<exists>pr pl. set pr \\<subseteq> Vr \\<and> set pl \\<subseteq> Vl \\<and> Vl \\<times> Vl \\<subseteq> (E \\<inter> Vl\\<times>Vl)\\<^sup>* \n          \\<and> is_lasso_prpl (pr,pl));\n        (pr,pl) \\<leftarrow> SPEC (\\<lambda>(pr,pl). \n           set pr \\<subseteq> Vr \n          \\<and> set pl \\<subseteq> Vl \n          \\<and> Vl \\<times> Vl \\<subseteq> (E \\<inter> Vl\\<times>Vl)\\<^sup>*\n          \\<and> is_lasso_prpl (pr,pl));\n        RETURN (Some (pr,pl))\n      }\n    }\""], ["", "theorem abs_is_empty_ce_correct: \"abs_is_empty_ce \\<le> SPEC (\\<lambda>res. case res of\n      None \\<Rightarrow> (\\<forall>r. \\<not>is_acc_run r)\n    | Some (pr,pl) \\<Rightarrow> is_acc_run (pr\\<frown>pl\\<^sup>\\<omega>)\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abs_is_empty_ce\n    \\<le> SPEC\n           (\\<lambda>res.\n               case res of\n               None \\<Rightarrow> \\<forall>r. \\<not> is_acc_run r\n               | Some (pr, pl) \\<Rightarrow>\n                   is_acc_run (pr \\<frown> pl\\<^sup>\\<omega>))", "unfolding abs_is_empty_ce_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. find_ce \\<bind>\n    (\\<lambda>ce.\n        case ce of None \\<Rightarrow> RETURN None\n        | Some (Vr, Vl) \\<Rightarrow>\n            ASSERT\n             (\\<exists>pr pl.\n                 set pr \\<subseteq> Vr \\<and>\n                 set pl \\<subseteq> Vl \\<and>\n                 Vl \\<times> Vl \\<subseteq> (Restr E Vl)\\<^sup>* \\<and>\n                 is_lasso_prpl (pr, pl)) \\<bind>\n            (\\<lambda>_.\n                SPEC\n                 (\\<lambda>(pr, pl).\n                     set pr \\<subseteq> Vr \\<and>\n                     set pl \\<subseteq> Vl \\<and>\n                     Vl \\<times> Vl \\<subseteq> (Restr E Vl)\\<^sup>* \\<and>\n                     is_lasso_prpl (pr, pl)) \\<bind>\n                (\\<lambda>(pr, pl). RETURN (Some (pr, pl)))))\n    \\<le> SPEC\n           (\\<lambda>res.\n               case res of\n               None \\<Rightarrow> \\<forall>r. \\<not> is_acc_run r\n               | Some (pr, pl) \\<Rightarrow>\n                   is_acc_run (pr \\<frown> pl\\<^sup>\\<omega>))", "apply (refine_rcg refine_vcg \n      order_trans[OF find_ce_correct, unfolded find_ce_spec_def])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>case x of\n                None \\<Rightarrow> \\<forall>prpl. \\<not> is_lasso_prpl prpl\n                | Some (x, xa) \\<Rightarrow> ce_correct x xa;\n        x = None\\<rbrakk>\n       \\<Longrightarrow> case None of\n                         None \\<Rightarrow> \\<forall>r. \\<not> is_acc_run r\n                         | Some (pr, pl) \\<Rightarrow>\n                             is_acc_run (pr \\<frown> pl\\<^sup>\\<omega>)\n 2. \\<And>x xa a b.\n       \\<lbrakk>case x of\n                None \\<Rightarrow> \\<forall>prpl. \\<not> is_lasso_prpl prpl\n                | Some (x, xa) \\<Rightarrow> ce_correct x xa;\n        x = Some xa; xa = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pr pl.\n                            set pr \\<subseteq> a \\<and>\n                            set pl \\<subseteq> b \\<and>\n                            b \\<times> b\n                            \\<subseteq> (Restr E b)\\<^sup>* \\<and>\n                            is_lasso_prpl (pr, pl)\n 3. \\<And>x xa a b xb aa ba.\n       \\<lbrakk>case x of\n                None \\<Rightarrow> \\<forall>prpl. \\<not> is_lasso_prpl prpl\n                | Some (x, xa) \\<Rightarrow> ce_correct x xa;\n        x = Some xa; xa = (a, b);\n        \\<exists>pr pl.\n           set pr \\<subseteq> a \\<and>\n           set pl \\<subseteq> b \\<and>\n           b \\<times> b \\<subseteq> (Restr E b)\\<^sup>* \\<and>\n           is_lasso_prpl (pr, pl);\n        case xb of\n        (pr, pl) \\<Rightarrow>\n          set pr \\<subseteq> a \\<and>\n          set pl \\<subseteq> b \\<and>\n          b \\<times> b \\<subseteq> (Restr E b)\\<^sup>* \\<and>\n          is_lasso_prpl (pr, pl);\n        xb = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> case Some (aa, ba) of\n                         None \\<Rightarrow> \\<forall>r. \\<not> is_acc_run r\n                         | Some (pr, pl) \\<Rightarrow>\n                             is_acc_run (pr \\<frown> pl\\<^sup>\\<omega>)", "apply (clarsimp_all simp: ce_correct_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>\\<forall>a b. \\<not> is_lasso_prpl (a, b);\n        is_acc_run r\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>aa ba pr pl.\n       \\<lbrakk>aa \\<subseteq> reachable; ba \\<subseteq> reachable;\n        set pr \\<subseteq> aa; set pl \\<subseteq> ba;\n        ba \\<times> ba \\<subseteq> (Restr E ba)\\<^sup>*;\n        ba \\<times> ba \\<inter> E \\<noteq> {};\n        is_lasso_prpl (pr, pl)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pr.\n                            set pr \\<subseteq> aa \\<and>\n                            (\\<exists>pl.\n                                set pl \\<subseteq> ba \\<and>\n                                is_lasso_prpl (pr, pl))\n 3. \\<And>aa ba aaa baa pr pl pra pla.\n       \\<lbrakk>aa \\<subseteq> reachable; set aaa \\<subseteq> aa;\n        set pr \\<subseteq> aa; ba \\<subseteq> reachable;\n        set baa \\<subseteq> ba; set pl \\<subseteq> ba;\n        is_lasso_prpl (pr, pl); set pra \\<subseteq> aa;\n        ba \\<times> ba \\<subseteq> (Restr E ba)\\<^sup>*;\n        is_lasso_prpl (aaa, baa); set pla \\<subseteq> ba;\n        ba \\<times> ba \\<inter> E \\<noteq> {};\n        is_lasso_prpl (pra, pla)\\<rbrakk>\n       \\<Longrightarrow> is_acc_run (aaa \\<frown> baa\\<^sup>\\<omega>)", "using accepted_lasso finite_reachableE_V0"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite reachable; is_acc_run ?r\\<rbrakk>\n  \\<Longrightarrow> Ex is_lasso\n  finite reachable\n\ngoal (3 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>\\<forall>a b. \\<not> is_lasso_prpl (a, b);\n        is_acc_run r\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>aa ba pr pl.\n       \\<lbrakk>aa \\<subseteq> reachable; ba \\<subseteq> reachable;\n        set pr \\<subseteq> aa; set pl \\<subseteq> ba;\n        ba \\<times> ba \\<subseteq> (Restr E ba)\\<^sup>*;\n        ba \\<times> ba \\<inter> E \\<noteq> {};\n        is_lasso_prpl (pr, pl)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pr.\n                            set pr \\<subseteq> aa \\<and>\n                            (\\<exists>pl.\n                                set pl \\<subseteq> ba \\<and>\n                                is_lasso_prpl (pr, pl))\n 3. \\<And>aa ba aaa baa pr pl pra pla.\n       \\<lbrakk>aa \\<subseteq> reachable; set aaa \\<subseteq> aa;\n        set pr \\<subseteq> aa; ba \\<subseteq> reachable;\n        set baa \\<subseteq> ba; set pl \\<subseteq> ba;\n        is_lasso_prpl (pr, pl); set pra \\<subseteq> aa;\n        ba \\<times> ba \\<subseteq> (Restr E ba)\\<^sup>*;\n        is_lasso_prpl (aaa, baa); set pla \\<subseteq> ba;\n        ba \\<times> ba \\<inter> E \\<noteq> {};\n        is_lasso_prpl (pra, pla)\\<rbrakk>\n       \\<Longrightarrow> is_acc_run (aaa \\<frown> baa\\<^sup>\\<omega>)", "apply (metis is_lasso_prpl_of_lasso surj_pair)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba pr pl.\n       \\<lbrakk>aa \\<subseteq> reachable; ba \\<subseteq> reachable;\n        set pr \\<subseteq> aa; set pl \\<subseteq> ba;\n        ba \\<times> ba \\<subseteq> (Restr E ba)\\<^sup>*;\n        ba \\<times> ba \\<inter> E \\<noteq> {};\n        is_lasso_prpl (pr, pl)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pr.\n                            set pr \\<subseteq> aa \\<and>\n                            (\\<exists>pl.\n                                set pl \\<subseteq> ba \\<and>\n                                is_lasso_prpl (pr, pl))\n 2. \\<And>aa ba aaa baa pr pl pra pla.\n       \\<lbrakk>aa \\<subseteq> reachable; set aaa \\<subseteq> aa;\n        set pr \\<subseteq> aa; ba \\<subseteq> reachable;\n        set baa \\<subseteq> ba; set pl \\<subseteq> ba;\n        is_lasso_prpl (pr, pl); set pra \\<subseteq> aa;\n        ba \\<times> ba \\<subseteq> (Restr E ba)\\<^sup>*;\n        is_lasso_prpl (aaa, baa); set pla \\<subseteq> ba;\n        ba \\<times> ba \\<inter> E \\<noteq> {};\n        is_lasso_prpl (pra, pla)\\<rbrakk>\n       \\<Longrightarrow> is_acc_run (aaa \\<frown> baa\\<^sup>\\<omega>)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba aaa baa pr pl pra pla.\n       \\<lbrakk>aa \\<subseteq> reachable; set aaa \\<subseteq> aa;\n        set pr \\<subseteq> aa; ba \\<subseteq> reachable;\n        set baa \\<subseteq> ba; set pl \\<subseteq> ba;\n        is_lasso_prpl (pr, pl); set pra \\<subseteq> aa;\n        ba \\<times> ba \\<subseteq> (Restr E ba)\\<^sup>*;\n        is_lasso_prpl (aaa, baa); set pla \\<subseteq> ba;\n        ba \\<times> ba \\<inter> E \\<noteq> {};\n        is_lasso_prpl (pra, pla)\\<rbrakk>\n       \\<Longrightarrow> is_acc_run (aaa \\<frown> baa\\<^sup>\\<omega>)", "apply (simp add: lasso_prpl_acc_run)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "section \\<open>Refinement\\<close>"], ["", "text \\<open>\n  In this section, we refine the lasso finding algorithm to use efficient\n  data structures. First, we explicitely keep track of the set of acceptance\n  classes for every c-node on the path. Second, we use Gabow's data structure\n  to represent the path.\n\\<close>"], ["", "subsection \\<open>Addition of Explicit Accepting Sets\\<close>"], ["", "text \\<open>In a first step, we explicitely keep track of the current set of\n  acceptance classes for every c-node on the path.\\<close>"], ["", "type_synonym 'a abs_gstate = \"nat set list \\<times> 'a abs_state\""], ["", "type_synonym 'a ce = \"('a set \\<times> 'a set) option\""], ["", "type_synonym 'a abs_gostate = \"'a ce \\<times> 'a set\""], ["", "context igb_fr_graph\nbegin"], ["", "definition gstate_invar :: \"'Q abs_gstate \\<Rightarrow> bool\" where \n    \"gstate_invar \\<equiv> \\<lambda>(a,p,D,pE). a = map (\\<lambda>V. \\<Union>(acc`V)) p\""], ["", "definition \"gstate_rel \\<equiv> br snd gstate_invar\""], ["", "lemma gstate_rel_sv[relator_props,simp,intro!]: \"single_valued gstate_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued gstate_rel", "by (simp add: gstate_rel_def)"], ["", "definition (in -) gcollapse_aux \n    :: \"nat set list \\<Rightarrow> 'a set list \\<Rightarrow> nat \\<Rightarrow> nat set list \\<times> 'a set list\"\n    where \"gcollapse_aux a p i \\<equiv> \n      (take i a @ [\\<Union>(set (drop i a))],take i p @ [\\<Union>(set (drop i p))])\""], ["", "definition (in -) gcollapse :: \"'a \\<Rightarrow> 'a abs_gstate \\<Rightarrow> 'a abs_gstate\" \n    where \"gcollapse v APDPE \\<equiv> \n    let \n      (a,p,D,pE)=APDPE; \n      i=idx_of p v;\n      (a,p) = gcollapse_aux a p i\n    in (a,p,D,pE)\""], ["", "definition \"gpush v s \\<equiv> \n    let\n      (a,s) = s\n    in\n      (a@[acc v],push v s)\""], ["", "definition \"gpop s \\<equiv>\n    let (a,s) = s in (butlast a,pop s)\""], ["", "definition ginitial :: \"'Q \\<Rightarrow> 'Q abs_gostate \\<Rightarrow> 'Q abs_gstate\" \n    where \"ginitial v0 s0 \\<equiv> ([acc v0], initial v0 (snd s0))\""], ["", "definition goinitial :: \"'Q abs_gostate\" where \"goinitial \\<equiv> (None,{})\""], ["", "definition go_is_no_brk :: \"'Q abs_gostate \\<Rightarrow> bool\" \n    where \"go_is_no_brk s \\<equiv> fst s = None\""], ["", "definition goD :: \"'Q abs_gostate \\<Rightarrow> 'Q set\" where \"goD s \\<equiv> snd s\""], ["", "definition goBrk :: \"'Q abs_gostate \\<Rightarrow> 'Q ce\" where \"goBrk s \\<equiv> fst s\""], ["", "definition gto_outer :: \"'Q ce \\<Rightarrow> 'Q abs_gstate \\<Rightarrow> 'Q abs_gostate\" \n    where \"gto_outer brk s \\<equiv> let (A,p,D,pE)=s in (brk,D)\""], ["", "definition \"gselect_edge s \\<equiv> do {\n    let (a,s)=s; \n    (r,s)\\<leftarrow>select_edge s;\n    RETURN (r,a,s) \n  }\""], ["", "definition gfind_ce :: \"('Q set \\<times> 'Q set) option nres\" where\n    \"gfind_ce \\<equiv> do {\n      let os = goinitial;\n      os\\<leftarrow>FOREACHci fgl_outer_invar V0 (go_is_no_brk) (\\<lambda>v0 s0. do {\n        if v0\\<notin>goD s0 then do {\n          let s = (None,ginitial v0 s0);\n\n          (brk,a,p,D,pE) \\<leftarrow> WHILEIT (\\<lambda>(brk,a,s). fgl_invar v0 (goD s0) (brk,s))\n            (\\<lambda>(brk,a,p,D,pE). brk=None \\<and> p \\<noteq> []) (\\<lambda>(_,a,p,D,pE). \n          do {\n            \\<comment> \\<open>Select edge from end of path\\<close>\n            (vo,(a,p,D,pE)) \\<leftarrow> gselect_edge (a,p,D,pE);\n\n            ASSERT (p\\<noteq>[]);\n            case vo of \n              Some v \\<Rightarrow> do {\n                if v \\<in> \\<Union>(set p) then do {\n                  \\<comment> \\<open>Collapse\\<close>\n                  let (a,p,D,pE) = gcollapse v (a,p,D,pE);\n\n                  ASSERT (p\\<noteq>[]);\n                  ASSERT (a\\<noteq>[]);\n\n                  if last a = {0..<num_acc} then\n                    RETURN (Some (\\<Union>(set (butlast p)),last p),a,p,D,pE)\n                  else\n                    RETURN (None,a,p,D,pE)\n                } else if v\\<notin>D then do {\n                  \\<comment> \\<open>Edge to new node. Append to path\\<close>\n                  RETURN (None,gpush v (a,p,D,pE))\n                } else RETURN (None,a,p,D,pE)\n              }\n            | None \\<Rightarrow> do {\n                \\<comment> \\<open>No more outgoing edges from current node on path\\<close>\n                ASSERT (pE \\<inter> last p \\<times> UNIV = {});\n                RETURN (None,gpop (a,p,D,pE))\n              }\n          }) s;\n          ASSERT (brk=None \\<longrightarrow> (p=[] \\<and> pE={}));\n          RETURN (gto_outer brk (a,p,D,pE))\n        } else RETURN s0\n    }) os;\n    RETURN (goBrk os)\n  }\""], ["", "lemma gcollapse_refine:\n    \"\\<lbrakk>(v',v)\\<in>Id; (s',s)\\<in>gstate_rel\\<rbrakk> \n      \\<Longrightarrow> (gcollapse v' s',collapse v s)\\<in>gstate_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(v', v) \\<in> Id; (s', s) \\<in> gstate_rel\\<rbrakk>\n    \\<Longrightarrow> (gcollapse v' s', collapse v s) \\<in> gstate_rel", "unfolding gcollapse_def collapse_def collapse_aux_def gcollapse_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(v', v) \\<in> Id; (s', s) \\<in> gstate_rel\\<rbrakk>\n    \\<Longrightarrow> (let (a, p, D, pE) = s'; i = idx_of p v';\n                           (a, p) =\n                             (take i a @ [\\<Union> (set (drop i a))],\n                              take i p @ [\\<Union> (set (drop i p))])\n                       in (a, p, D, pE),\n                       let (p, D, pE) = s; i = idx_of p v;\n                           p = take i p @ [\\<Union> (set (drop i p))]\n                       in (p, D, pE))\n                      \\<in> gstate_rel", "apply (simp add: gstate_rel_def br_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v' = v; s = snd s' \\<and> gstate_invar s'\\<rbrakk>\n    \\<Longrightarrow> (case snd s' of\n                       (p, x) \\<Rightarrow>\n                         (take (idx_of p v) p @\n                          [\\<Union> (set (drop (idx_of p v) p))],\n                          x)) =\n                      snd (case s' of\n                           (a, p, D, pE) \\<Rightarrow>\n                             (take (idx_of p v) a @\n                              [\\<Union> (set (drop (idx_of p v) a))],\n                              take (idx_of p v) p @\n                              [\\<Union> (set (drop (idx_of p v) p))],\n                              D, pE)) \\<and>\n                      gstate_invar\n                       (case s' of\n                        (a, p, D, pE) \\<Rightarrow>\n                          (take (idx_of p v) a @\n                           [\\<Union> (set (drop (idx_of p v) a))],\n                           take (idx_of p v) p @\n                           [\\<Union> (set (drop (idx_of p v) p))],\n                           D, pE))", "unfolding gstate_invar_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v' = v;\n     s = snd s' \\<and>\n     (case s' of\n      (a, p, D, pE) \\<Rightarrow>\n        a = map (\\<lambda>V. \\<Union> (acc ` V)) p)\\<rbrakk>\n    \\<Longrightarrow> (case snd s' of\n                       (p, x) \\<Rightarrow>\n                         (take (idx_of p v) p @\n                          [\\<Union> (set (drop (idx_of p v) p))],\n                          x)) =\n                      snd (case s' of\n                           (a, p, D, pE) \\<Rightarrow>\n                             (take (idx_of p v) a @\n                              [\\<Union> (set (drop (idx_of p v) a))],\n                              take (idx_of p v) p @\n                              [\\<Union> (set (drop (idx_of p v) p))],\n                              D, pE)) \\<and>\n                      (case case s' of\n                            (a, p, D, pE) \\<Rightarrow>\n                              (take (idx_of p v) a @\n                               [\\<Union> (set (drop (idx_of p v) a))],\n                               take (idx_of p v) p @\n                               [\\<Union> (set (drop (idx_of p v) p))],\n                               D, pE) of\n                       (a, p, D, pE) \\<Rightarrow>\n                         a = map (\\<lambda>V. \\<Union> (acc ` V)) p)", "apply (auto split: prod.splits simp: take_map drop_map)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gpush_refine:\n    \"\\<lbrakk>(v',v)\\<in>Id; (s',s)\\<in>gstate_rel\\<rbrakk> \\<Longrightarrow> (gpush v' s',push v s)\\<in>gstate_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(v', v) \\<in> Id; (s', s) \\<in> gstate_rel\\<rbrakk>\n    \\<Longrightarrow> (gpush v' s', push v s) \\<in> gstate_rel", "unfolding gpush_def push_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(v', v) \\<in> Id; (s', s) \\<in> gstate_rel\\<rbrakk>\n    \\<Longrightarrow> (let (a, s) = s'\n                       in (a @ [acc v'],\n                           let (p, D, pE) = s; p = p @ [{v'}];\n                               pE = pE \\<union>\n                                    E \\<inter> {v'} \\<times> UNIV\n                           in (p, D, pE)),\n                       let (p, D, pE) = s; p = p @ [{v}];\n                           pE = pE \\<union> E \\<inter> {v} \\<times> UNIV\n                       in (p, D, pE))\n                      \\<in> gstate_rel", "apply (simp add: gstate_rel_def br_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v' = v; s = snd s' \\<and> gstate_invar s'\\<rbrakk>\n    \\<Longrightarrow> (case snd s' of\n                       (p, D, pE) \\<Rightarrow>\n                         (p @ [{v}], D,\n                          pE \\<union> E \\<inter> {v} \\<times> UNIV)) =\n                      snd (case s' of\n                           (a, s) \\<Rightarrow>\n                             (a @ [acc v],\n                              case s of\n                              (p, D, pE) \\<Rightarrow>\n                                (p @ [{v}], D,\n                                 pE \\<union>\n                                 E \\<inter> {v} \\<times> UNIV))) \\<and>\n                      gstate_invar\n                       (case s' of\n                        (a, s) \\<Rightarrow>\n                          (a @ [acc v],\n                           case s of\n                           (p, D, pE) \\<Rightarrow>\n                             (p @ [{v}], D,\n                              pE \\<union> E \\<inter> {v} \\<times> UNIV)))", "unfolding gstate_invar_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v' = v;\n     s = snd s' \\<and>\n     (case s' of\n      (a, p, D, pE) \\<Rightarrow>\n        a = map (\\<lambda>V. \\<Union> (acc ` V)) p)\\<rbrakk>\n    \\<Longrightarrow> (case snd s' of\n                       (p, D, pE) \\<Rightarrow>\n                         (p @ [{v}], D,\n                          pE \\<union> E \\<inter> {v} \\<times> UNIV)) =\n                      snd (case s' of\n                           (a, s) \\<Rightarrow>\n                             (a @ [acc v],\n                              case s of\n                              (p, D, pE) \\<Rightarrow>\n                                (p @ [{v}], D,\n                                 pE \\<union>\n                                 E \\<inter> {v} \\<times> UNIV))) \\<and>\n                      (case case s' of\n                            (a, s) \\<Rightarrow>\n                              (a @ [acc v],\n                               case s of\n                               (p, D, pE) \\<Rightarrow>\n                                 (p @ [{v}], D,\n                                  pE \\<union>\n                                  E \\<inter> {v} \\<times> UNIV)) of\n                       (a, p, D, pE) \\<Rightarrow>\n                         a = map (\\<lambda>V. \\<Union> (acc ` V)) p)", "apply (auto split: prod.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gpop_refine:\n    \"\\<lbrakk>(s',s)\\<in>gstate_rel\\<rbrakk> \\<Longrightarrow> (gpop s',pop s)\\<in>gstate_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s', s) \\<in> gstate_rel \\<Longrightarrow>\n    (gpop s', pop s) \\<in> gstate_rel", "unfolding gpop_def pop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s', s) \\<in> gstate_rel \\<Longrightarrow>\n    (let (a, s) = s'\n     in (butlast a,\n         let (p, D, pE) = s; (p, V) = (butlast p, last p); D = V \\<union> D\n         in (p, D, pE)),\n     let (p, D, pE) = s; (p, V) = (butlast p, last p); D = V \\<union> D\n     in (p, D, pE))\n    \\<in> gstate_rel", "apply (simp add: gstate_rel_def br_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. s = snd s' \\<and> gstate_invar s' \\<Longrightarrow>\n    (case snd s' of\n     (p, D, pE) \\<Rightarrow> (butlast p, last p \\<union> D, pE)) =\n    snd (case s' of\n         (a, s) \\<Rightarrow>\n           (butlast a,\n            case s of\n            (p, D, pE) \\<Rightarrow>\n              (butlast p, last p \\<union> D, pE))) \\<and>\n    gstate_invar\n     (case s' of\n      (a, s) \\<Rightarrow>\n        (butlast a,\n         case s of\n         (p, D, pE) \\<Rightarrow> (butlast p, last p \\<union> D, pE)))", "unfolding gstate_invar_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. s = snd s' \\<and>\n    (case s' of\n     (a, p, D, pE) \\<Rightarrow>\n       a = map (\\<lambda>V. \\<Union> (acc ` V)) p) \\<Longrightarrow>\n    (case snd s' of\n     (p, D, pE) \\<Rightarrow> (butlast p, last p \\<union> D, pE)) =\n    snd (case s' of\n         (a, s) \\<Rightarrow>\n           (butlast a,\n            case s of\n            (p, D, pE) \\<Rightarrow>\n              (butlast p, last p \\<union> D, pE))) \\<and>\n    (case case s' of\n          (a, s) \\<Rightarrow>\n            (butlast a,\n             case s of\n             (p, D, pE) \\<Rightarrow> (butlast p, last p \\<union> D, pE)) of\n     (a, p, D, pE) \\<Rightarrow> a = map (\\<lambda>V. \\<Union> (acc ` V)) p)", "apply (auto split: prod.splits simp: map_butlast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ginitial_refine:\n    \"(ginitial x (None, b), initial x b) \\<in> gstate_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ginitial x (None, b), initial x b) \\<in> gstate_rel", "unfolding ginitial_def gstate_rel_def br_def gstate_invar_def initial_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (([acc x], [{x}], snd (None, b), E \\<inter> {x} \\<times> UNIV), [{x}],\n     b, E \\<inter> {x} \\<times> UNIV)\n    \\<in> {(c, a).\n           a = snd c \\<and>\n           (case c of\n            (a, p, D, pE) \\<Rightarrow>\n              a = map (\\<lambda>V. \\<Union> (acc ` V)) p)}", "by auto"], ["", "lemma oinitial_b_refine: \"((None,{}),(None,{}))\\<in>Id\\<times>\\<^sub>rId\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((None, {}), None, {}) \\<in> Id \\<times>\\<^sub>r Id", "by simp"], ["", "lemma gselect_edge_refine: \"\\<lbrakk>(s',s)\\<in>gstate_rel\\<rbrakk> \\<Longrightarrow> gselect_edge s' \n    \\<le>\\<Down>(\\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r gstate_rel) (select_edge s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s', s) \\<in> gstate_rel \\<Longrightarrow>\n    gselect_edge s'\n    \\<le> \\<Down>\n           (\\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r gstate_rel)\n           (select_edge s)", "unfolding gselect_edge_def select_edge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s', s) \\<in> gstate_rel \\<Longrightarrow>\n    (let (a, s) = s'\n     in (let (p, D, pE) = s\n         in SELECT\n             (\\<lambda>e. e \\<in> pE \\<inter> last p \\<times> UNIV) \\<bind>\n            (\\<lambda>e.\n                case e of None \\<Rightarrow> RETURN (None, p, D, pE)\n                | Some (u, v) \\<Rightarrow>\n                    RETURN (Some v, p, D, pE - {(u, v)}))) \\<bind>\n        (\\<lambda>(r, s). RETURN (r, a, s)))\n    \\<le> \\<Down>\n           (\\<langle>Id\\<rangle>option_rel \\<times>\\<^sub>r gstate_rel)\n           (let (p, D, pE) = s\n            in SELECT\n                (\\<lambda>e.\n                    e \\<in> pE \\<inter> last p \\<times> UNIV) \\<bind>\n               (\\<lambda>e.\n                   case e of None \\<Rightarrow> RETURN (None, p, D, pE)\n                   | Some (u, v) \\<Rightarrow>\n                       RETURN (Some v, p, D, pE - {(u, v)})))", "apply (simp add: pw_le_iff refine_pw_simps prod_rel_sv\n      split: prod.splits option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s', s) \\<in> gstate_rel \\<Longrightarrow>\n    \\<forall>x1 a aa b.\n       s' = (x1, a, aa, b) \\<longrightarrow>\n       (\\<forall>x1a ab ba.\n           s = (x1a, ab, ba) \\<longrightarrow>\n           (\\<forall>ac ad ae bb.\n               (\\<exists>y.\n                   (y = None \\<longrightarrow>\n                    (\\<forall>aa.\n                        (\\<exists>ba. (aa, ba) \\<in> b) \\<longrightarrow>\n                        aa \\<notin> last a) \\<and>\n                    None = ac \\<and>\n                    a = ad \\<and> aa = ae \\<and> b = bb) \\<and>\n                   (\\<forall>ab ba.\n                       y = Some (ab, ba) \\<longrightarrow>\n                       (ab, ba) \\<in> b \\<and>\n                       ab \\<in> last a \\<and>\n                       Some ba = ac \\<and>\n                       a = ad \\<and>\n                       aa = ae \\<and>\n                       b - {(ab, ba)} = bb)) \\<longrightarrow>\n               (\\<exists>a aa b.\n                   ((x1, ad, ae, bb), a, aa, b) \\<in> gstate_rel \\<and>\n                   (\\<exists>y.\n                       (y = None \\<longrightarrow>\n                        (\\<forall>a.\n                            (\\<exists>b. (a, b) \\<in> ba) \\<longrightarrow>\n                            a \\<notin> last x1a) \\<and>\n                        None = ac \\<and>\n                        x1a = a \\<and> ab = aa \\<and> ba = b) \\<and>\n                       (\\<forall>ad bb.\n                           y = Some (ad, bb) \\<longrightarrow>\n                           (ad, bb) \\<in> ba \\<and>\n                           ad \\<in> last x1a \\<and>\n                           Some bb = ac \\<and>\n                           x1a = a \\<and>\n                           ab = aa \\<and> ba - {(ad, bb)} = b)))))", "apply (auto simp: gstate_rel_def br_def gstate_invar_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma last_acc_impl:\n    assumes \"p\\<noteq>[]\"\n    assumes \"((a',p',D',pE'),(p,D,pE))\\<in>gstate_rel\"\n    shows \"(last a' = {0..<num_acc}) = (\\<forall>i<num_acc. \\<exists>q\\<in>last p. i\\<in>acc q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (last a' = {0..<num_acc}) =\n    (\\<forall>i<num_acc. \\<exists>q\\<in>last p. i \\<in> acc q)", "using assms acc_bound"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  ((a', p', D', pE'), p, D, pE) \\<in> gstate_rel\n  \\<Union> (range acc) \\<subseteq> {0..<num_acc}\n\ngoal (1 subgoal):\n 1. (last a' = {0..<num_acc}) =\n    (\\<forall>i<num_acc. \\<exists>q\\<in>last p. i \\<in> acc q)", "unfolding gstate_rel_def br_def gstate_invar_def"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  ((a', p', D', pE'), p, D, pE)\n  \\<in> {(c, a).\n         a = snd c \\<and>\n         (case c of\n          (a, p, D, pE) \\<Rightarrow>\n            a = map (\\<lambda>V. \\<Union> (acc ` V)) p)}\n  \\<Union> (range acc) \\<subseteq> {0..<num_acc}\n\ngoal (1 subgoal):\n 1. (last a' = {0..<num_acc}) =\n    (\\<forall>i<num_acc. \\<exists>q\\<in>last p. i \\<in> acc q)", "by (auto simp: last_map)"], ["", "lemma fglr_aux1:\n    assumes V: \"(v',v)\\<in>Id\" and S: \"(s',s)\\<in>gstate_rel\" \n      and P: \"\\<And>a' p' D' pE' p D pE. ((a',p',D',pE'),(p,D,pE))\\<in>gstate_rel \n      \\<Longrightarrow> f' a' p' D' pE' \\<le>\\<Down>R (f p D pE)\"\n    shows \"(let (a',p',D',pE') = gcollapse v' s' in f' a' p' D' pE') \n      \\<le> \\<Down>R (let (p,D,pE) = collapse v s in f p D pE)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (a', p', D', pE') = gcollapse v' s' in f' a' p' D' pE')\n    \\<le> \\<Down> R (let (p, D, pE) = collapse v s in f p D pE)", "apply (auto split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 a b x1a aa ab ba.\n       \\<lbrakk>collapse v s = (x1, a, b);\n        gcollapse v' s' = (x1a, aa, ab, ba)\\<rbrakk>\n       \\<Longrightarrow> f' x1a aa ab ba \\<le> \\<Down> R (f x1 a b)", "apply (rule P)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 a b x1a aa ab ba.\n       \\<lbrakk>collapse v s = (x1, a, b);\n        gcollapse v' s' = (x1a, aa, ab, ba)\\<rbrakk>\n       \\<Longrightarrow> ((x1a, aa, ab, ba), x1, a, b) \\<in> gstate_rel", "using gcollapse_refine[OF V S]"], ["proof (prove)\nusing this:\n  (gcollapse v' s', collapse v s) \\<in> gstate_rel\n\ngoal (1 subgoal):\n 1. \\<And>x1 a b x1a aa ab ba.\n       \\<lbrakk>collapse v s = (x1, a, b);\n        gcollapse v' s' = (x1a, aa, ab, ba)\\<rbrakk>\n       \\<Longrightarrow> ((x1a, aa, ab, ba), x1, a, b) \\<in> gstate_rel", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gstate_invar_empty: \n    \"gstate_invar (a,[],D,pE) \\<Longrightarrow> a=[]\"\n    \"gstate_invar ([],p,D,pE) \\<Longrightarrow> p=[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gstate_invar (a, [], D, pE) \\<Longrightarrow> a = []) &&&\n    (gstate_invar ([], p, D, pE) \\<Longrightarrow> p = [])", "by (auto simp add: gstate_invar_def)"], ["", "lemma find_ce_refine: \"gfind_ce \\<le>\\<Down>Id find_ce\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gfind_ce \\<le> \\<Down> Id find_ce", "unfolding gfind_ce_def find_ce_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let os = goinitial\n     in FOREACH\\<^sub>C\\<^bsup>fgl_outer_invar\\<^esup> V0 go_is_no_brk\n         (\\<lambda>v0 s0.\n             if v0 \\<notin> goD s0\n             then let s = (None, ginitial v0 s0)\n                  in WHILE\\<^sub>T\\<^bsup>\\<lambda>(brk, a, s).\n       fgl_invar v0 (goD s0) (brk, s)\\<^esup>\n                      (\\<lambda>(brk, a, p, D, pE).\n                          brk = None \\<and> p \\<noteq> [])\n                      (\\<lambda>(uu_, a, p, D, pE).\n                          gselect_edge (a, p, D, pE) \\<bind>\n                          (\\<lambda>(vo, a, p, D, pE).\n                              ASSERT (p \\<noteq> []) \\<bind>\n                              (\\<lambda>_.\n                                  case vo of\n                                  None \\<Rightarrow>\n                                    ASSERT\n                                     (pE \\<inter> last p \\<times> UNIV =\n{}) \\<bind>\n                                    (\\<lambda>_.\n  RETURN (None, gpop (a, p, D, pE)))\n                                  | Some v \\<Rightarrow>\nif v \\<in> \\<Union> (set p)\nthen let (a, p, D, pE) = gcollapse v (a, p, D, pE)\n     in ASSERT (p \\<noteq> []) \\<bind>\n        (\\<lambda>_.\n            ASSERT (a \\<noteq> []) \\<bind>\n            (\\<lambda>_.\n                if last a = {0..<num_acc}\n                then RETURN\n                      (Some (\\<Union> (set (butlast p)), last p), a, p, D,\n                       pE)\n                else RETURN (None, a, p, D, pE)))\nelse if v \\<notin> D then RETURN (None, gpush v (a, p, D, pE))\n     else RETURN (None, a, p, D, pE))))\n                      s \\<bind>\n                     (\\<lambda>(brk, a, p, D, pE).\n                         ASSERT\n                          (brk = None \\<longrightarrow>\n                           p = [] \\<and> pE = {}) \\<bind>\n                         (\\<lambda>_. RETURN (gto_outer brk (a, p, D, pE))))\n             else RETURN s0)\n         os \\<bind>\n        (\\<lambda>os. RETURN (goBrk os)))\n    \\<le> \\<Down> Id\n           (let D = {}\n            in FOREACH\\<^sub>C\\<^bsup>fgl_outer_invar\\<^esup> V0\n                (\\<lambda>(brk, uu_). brk = None)\n                (\\<lambda>v0 (brk, D0).\n                    if v0 \\<notin> D0\n                    then let s = (None, initial v0 D0)\n                         in WHILE\\<^sub>T\\<^bsup>fgl_invar v0 D0\\<^esup>\n                             (\\<lambda>(brk, p, D, pE).\n                                 brk = None \\<and> p \\<noteq> [])\n                             (\\<lambda>(uu_, p, D, pE).\n                                 select_edge (p, D, pE) \\<bind>\n                                 (\\<lambda>(vo, p, D, pE).\n                                     ASSERT (p \\<noteq> []) \\<bind>\n                                     (\\<lambda>_.\n   case vo of\n   None \\<Rightarrow>\n     ASSERT (pE \\<inter> last p \\<times> UNIV = {}) \\<bind>\n     (\\<lambda>_. RETURN (None, pop (p, D, pE)))\n   | Some v \\<Rightarrow>\n       if v \\<in> \\<Union> (set p)\n       then let (p, D, pE) = collapse v (p, D, pE)\n            in ASSERT (p \\<noteq> []) \\<bind>\n               (\\<lambda>_.\n                   if \\<forall>i<num_acc.\n                         \\<exists>q\\<in>last p. i \\<in> acc q\n                   then RETURN\n                         (Some (\\<Union> (set (butlast p)), last p), p, D,\n                          pE)\n                   else RETURN (None, p, D, pE))\n       else if v \\<notin> D then RETURN (None, push v (p, D, pE))\n            else RETURN (None, p, D, pE))))\n                             s \\<bind>\n                            (\\<lambda>(brk, p, D, pE).\n                                ASSERT\n                                 (brk = None \\<longrightarrow>\n                                  p = [] \\<and> pE = {}) \\<bind>\n                                (\\<lambda>_. RETURN (brk, D)))\n                    else RETURN (brk, D0))\n                (None, D) \\<bind>\n               (\\<lambda>(brk, uu_). RETURN brk))", "unfolding goinitial_def go_is_no_brk_def[abs_def] goD_def goBrk_def \n      gto_outer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let os = (None, {})\n     in FOREACH\\<^sub>C\\<^bsup>fgl_outer_invar\\<^esup> V0\n         (\\<lambda>s. fst s = None)\n         (\\<lambda>v0 s0.\n             if v0 \\<notin> snd s0\n             then let s = (None, ginitial v0 s0)\n                  in WHILE\\<^sub>T\\<^bsup>\\<lambda>(brk, a, s).\n       fgl_invar v0 (snd s0) (brk, s)\\<^esup>\n                      (\\<lambda>(brk, a, p, D, pE).\n                          brk = None \\<and> p \\<noteq> [])\n                      (\\<lambda>(uu_, a, p, D, pE).\n                          gselect_edge (a, p, D, pE) \\<bind>\n                          (\\<lambda>(vo, a, p, D, pE).\n                              ASSERT (p \\<noteq> []) \\<bind>\n                              (\\<lambda>_.\n                                  case vo of\n                                  None \\<Rightarrow>\n                                    ASSERT\n                                     (pE \\<inter> last p \\<times> UNIV =\n{}) \\<bind>\n                                    (\\<lambda>_.\n  RETURN (None, gpop (a, p, D, pE)))\n                                  | Some v \\<Rightarrow>\nif v \\<in> \\<Union> (set p)\nthen let (a, p, D, pE) = gcollapse v (a, p, D, pE)\n     in ASSERT (p \\<noteq> []) \\<bind>\n        (\\<lambda>_.\n            ASSERT (a \\<noteq> []) \\<bind>\n            (\\<lambda>_.\n                if last a = {0..<num_acc}\n                then RETURN\n                      (Some (\\<Union> (set (butlast p)), last p), a, p, D,\n                       pE)\n                else RETURN (None, a, p, D, pE)))\nelse if v \\<notin> D then RETURN (None, gpush v (a, p, D, pE))\n     else RETURN (None, a, p, D, pE))))\n                      s \\<bind>\n                     (\\<lambda>(brk, a, p, D, pE).\n                         ASSERT\n                          (brk = None \\<longrightarrow>\n                           p = [] \\<and> pE = {}) \\<bind>\n                         (\\<lambda>_.\n                             RETURN\n                              (let (A, p, D, pE) = (a, p, D, pE)\n                               in (brk, D))))\n             else RETURN s0)\n         os \\<bind>\n        (\\<lambda>os. RETURN (fst os)))\n    \\<le> \\<Down> Id\n           (let D = {}\n            in FOREACH\\<^sub>C\\<^bsup>fgl_outer_invar\\<^esup> V0\n                (\\<lambda>(brk, uu_). brk = None)\n                (\\<lambda>v0 (brk, D0).\n                    if v0 \\<notin> D0\n                    then let s = (None, initial v0 D0)\n                         in WHILE\\<^sub>T\\<^bsup>fgl_invar v0 D0\\<^esup>\n                             (\\<lambda>(brk, p, D, pE).\n                                 brk = None \\<and> p \\<noteq> [])\n                             (\\<lambda>(uu_, p, D, pE).\n                                 select_edge (p, D, pE) \\<bind>\n                                 (\\<lambda>(vo, p, D, pE).\n                                     ASSERT (p \\<noteq> []) \\<bind>\n                                     (\\<lambda>_.\n   case vo of\n   None \\<Rightarrow>\n     ASSERT (pE \\<inter> last p \\<times> UNIV = {}) \\<bind>\n     (\\<lambda>_. RETURN (None, pop (p, D, pE)))\n   | Some v \\<Rightarrow>\n       if v \\<in> \\<Union> (set p)\n       then let (p, D, pE) = collapse v (p, D, pE)\n            in ASSERT (p \\<noteq> []) \\<bind>\n               (\\<lambda>_.\n                   if \\<forall>i<num_acc.\n                         \\<exists>q\\<in>last p. i \\<in> acc q\n                   then RETURN\n                         (Some (\\<Union> (set (butlast p)), last p), p, D,\n                          pE)\n                   else RETURN (None, p, D, pE))\n       else if v \\<notin> D then RETURN (None, push v (p, D, pE))\n            else RETURN (None, p, D, pE))))\n                             s \\<bind>\n                            (\\<lambda>(brk, p, D, pE).\n                                ASSERT\n                                 (brk = None \\<longrightarrow>\n                                  p = [] \\<and> pE = {}) \\<bind>\n                                (\\<lambda>_. RETURN (brk, D)))\n                    else RETURN (brk, D0))\n                (None, D) \\<bind>\n               (\\<lambda>(brk, uu_). RETURN brk))", "using [[goals_limit = 1]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let os = (None, {})\n     in FOREACH\\<^sub>C\\<^bsup>fgl_outer_invar\\<^esup> V0\n         (\\<lambda>s. fst s = None)\n         (\\<lambda>v0 s0.\n             if v0 \\<notin> snd s0\n             then let s = (None, ginitial v0 s0)\n                  in WHILE\\<^sub>T\\<^bsup>\\<lambda>(brk, a, s).\n       fgl_invar v0 (snd s0) (brk, s)\\<^esup>\n                      (\\<lambda>(brk, a, p, D, pE).\n                          brk = None \\<and> p \\<noteq> [])\n                      (\\<lambda>(uu_, a, p, D, pE).\n                          gselect_edge (a, p, D, pE) \\<bind>\n                          (\\<lambda>(vo, a, p, D, pE).\n                              ASSERT (p \\<noteq> []) \\<bind>\n                              (\\<lambda>_.\n                                  case vo of\n                                  None \\<Rightarrow>\n                                    ASSERT\n                                     (pE \\<inter> last p \\<times> UNIV =\n{}) \\<bind>\n                                    (\\<lambda>_.\n  RETURN (None, gpop (a, p, D, pE)))\n                                  | Some v \\<Rightarrow>\nif v \\<in> \\<Union> (set p)\nthen let (a, p, D, pE) = gcollapse v (a, p, D, pE)\n     in ASSERT (p \\<noteq> []) \\<bind>\n        (\\<lambda>_.\n            ASSERT (a \\<noteq> []) \\<bind>\n            (\\<lambda>_.\n                if last a = {0..<num_acc}\n                then RETURN\n                      (Some (\\<Union> (set (butlast p)), last p), a, p, D,\n                       pE)\n                else RETURN (None, a, p, D, pE)))\nelse if v \\<notin> D then RETURN (None, gpush v (a, p, D, pE))\n     else RETURN (None, a, p, D, pE))))\n                      s \\<bind>\n                     (\\<lambda>(brk, a, p, D, pE).\n                         ASSERT\n                          (brk = None \\<longrightarrow>\n                           p = [] \\<and> pE = {}) \\<bind>\n                         (\\<lambda>_.\n                             RETURN\n                              (let (A, p, D, pE) = (a, p, D, pE)\n                               in (brk, D))))\n             else RETURN s0)\n         os \\<bind>\n        (\\<lambda>os. RETURN (fst os)))\n    \\<le> \\<Down> Id\n           (let D = {}\n            in FOREACH\\<^sub>C\\<^bsup>fgl_outer_invar\\<^esup> V0\n                (\\<lambda>(brk, uu_). brk = None)\n                (\\<lambda>v0 (brk, D0).\n                    if v0 \\<notin> D0\n                    then let s = (None, initial v0 D0)\n                         in WHILE\\<^sub>T\\<^bsup>fgl_invar v0 D0\\<^esup>\n                             (\\<lambda>(brk, p, D, pE).\n                                 brk = None \\<and> p \\<noteq> [])\n                             (\\<lambda>(uu_, p, D, pE).\n                                 select_edge (p, D, pE) \\<bind>\n                                 (\\<lambda>(vo, p, D, pE).\n                                     ASSERT (p \\<noteq> []) \\<bind>\n                                     (\\<lambda>_.\n   case vo of\n   None \\<Rightarrow>\n     ASSERT (pE \\<inter> last p \\<times> UNIV = {}) \\<bind>\n     (\\<lambda>_. RETURN (None, pop (p, D, pE)))\n   | Some v \\<Rightarrow>\n       if v \\<in> \\<Union> (set p)\n       then let (p, D, pE) = collapse v (p, D, pE)\n            in ASSERT (p \\<noteq> []) \\<bind>\n               (\\<lambda>_.\n                   if \\<forall>i<num_acc.\n                         \\<exists>q\\<in>last p. i \\<in> acc q\n                   then RETURN\n                         (Some (\\<Union> (set (butlast p)), last p), p, D,\n                          pE)\n                   else RETURN (None, p, D, pE))\n       else if v \\<notin> D then RETURN (None, push v (p, D, pE))\n            else RETURN (None, p, D, pE))))\n                             s \\<bind>\n                            (\\<lambda>(brk, p, D, pE).\n                                ASSERT\n                                 (brk = None \\<longrightarrow>\n                                  p = [] \\<and> pE = {}) \\<bind>\n                                (\\<lambda>_. RETURN (brk, D)))\n                    else RETURN (brk, D0))\n                (None, D) \\<bind>\n               (\\<lambda>(brk, uu_). RETURN brk))", "apply (refine_rcg \n      gselect_edge_refine prod_relI[OF IdI gpop_refine]\n      prod_relI[OF IdI gpush_refine]\n      fglr_aux1 last_acc_impl oinitial_b_refine\n      inj_on_id\n    )"], ["proof (prove)\ngoal (29 subgoals):\n 1. V0 = id ` V0\nA total of 29 subgoals...", "apply refine_dref_type"], ["proof (prove)\ngoal (27 subgoals):\n 1. V0 = id ` V0\nA total of 27 subgoals...", "apply (simp_all add: ginitial_refine)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x it \\<sigma> x' it' \\<sigma>' x1 x2 xa x'a x1a x2a x1b x2b.\n       \\<lbrakk>x' = x; x \\<in> it; it' = it; it \\<subseteq> V0;\n        fgl_outer_invar it (None, x2); x1 = None; \\<sigma> = (None, x2);\n        \\<sigma>' = (None, x2); x \\<notin> x2;\n        ((x1a, x1b, x2b), x'a) \\<in> Id \\<times>\\<^sub>r gstate_rel;\n        fgl_invar x x2 x'a; x2a = (x1b, x2b); xa = (x1a, x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> fgl_invar x x2 (x1a, x2b)\nA total of 12 subgoals...", "apply (vc_solve (nopre) \n      solve: asm_rl \n      simp: gstate_rel_def br_def gstate_invar_empty)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection \\<open>Refinement to Gabow's Data Structure\\<close>"], ["", "subsubsection \\<open>Preliminaries\\<close>"], ["", "definition Un_set_drop_impl :: \"nat \\<Rightarrow> 'a set list \\<Rightarrow> 'a set nres\"\n  \\<comment> \\<open>Executable version of @{text \"\\<Union>set (drop i A)\"}, using indexing to\n  access @{text \"A\"}\\<close>\n  where \"Un_set_drop_impl i A \\<equiv> \n  do {\n    (_,res) \\<leftarrow> WHILET (\\<lambda>(i,res). i < length A) (\\<lambda>(i,res). do {\n      ASSERT (i<length A);\n      let res = A!i \\<union> res;\n      let i = i + 1;\n      RETURN (i,res)\n    }) (i,{});\n    RETURN res\n  }\""], ["", "lemma Un_set_drop_impl_correct: \n  \"Un_set_drop_impl i A \\<le> SPEC (\\<lambda>r. r=\\<Union>(set (drop i A)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Un_set_drop_impl i A\n    \\<le> SPEC (\\<lambda>r. r = \\<Union> (set (drop i A)))", "unfolding Un_set_drop_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T (\\<lambda>(i, res). i < length A)\n     (\\<lambda>(i, res).\n         ASSERT (i < length A) \\<bind>\n         (\\<lambda>_.\n             let res = A ! i \\<union> res; i = i + 1 in RETURN (i, res)))\n     (i, {}) \\<bind>\n    (\\<lambda>(uu_, res). RETURN res)\n    \\<le> SPEC (\\<lambda>r. r = \\<Union> (set (drop i A)))", "apply (refine_rcg \n    WHILET_rule[where I=\"\\<lambda>(i',res). res=\\<Union>(set ((drop i (take i' A)))) \\<and> i\\<le>i'\" \n    and R=\"measure (\\<lambda>(i',_). length A - i')\"] \n    refine_vcg)"], ["proof (prove)\ngoal (8 subgoals):\n 1. wf (measure (\\<lambda>(i', uu_). length A - i'))\n 2. \\<And>x1 x2.\n       (i, {}) = (x1, x2) \\<Longrightarrow>\n       x2 = \\<Union> (set (drop i (take x1 A)))\n 3. \\<And>x1 x2. (i, {}) = (x1, x2) \\<Longrightarrow> i \\<le> x1\n 4. \\<And>s a b.\n       \\<lbrakk>case s of\n                (i', res) \\<Rightarrow>\n                  res = \\<Union> (set (drop i (take i' A))) \\<and>\n                  i \\<le> i';\n        case s of (i, res) \\<Rightarrow> i < length A; s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> a < length A\n 5. \\<And>s a b x1 x2.\n       \\<lbrakk>case s of\n                (i', res) \\<Rightarrow>\n                  res = \\<Union> (set (drop i (take i' A))) \\<and>\n                  i \\<le> i';\n        case s of (i, res) \\<Rightarrow> i < length A; s = (a, b);\n        a < length A; (a + 1, A ! a \\<union> b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2 = \\<Union> (set (drop i (take x1 A)))\n 6. \\<And>s a b x1 x2.\n       \\<lbrakk>case s of\n                (i', res) \\<Rightarrow>\n                  res = \\<Union> (set (drop i (take i' A))) \\<and>\n                  i \\<le> i';\n        case s of (i, res) \\<Rightarrow> i < length A; s = (a, b);\n        a < length A; (a + 1, A ! a \\<union> b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> i \\<le> x1\n 7. \\<And>s a b.\n       \\<lbrakk>case s of\n                (i', res) \\<Rightarrow>\n                  res = \\<Union> (set (drop i (take i' A))) \\<and>\n                  i \\<le> i';\n        case s of (i, res) \\<Rightarrow> i < length A; s = (a, b);\n        a < length A\\<rbrakk>\n       \\<Longrightarrow> ((a + 1, A ! a \\<union> b), s)\n                         \\<in> measure (\\<lambda>(i', uu_). length A - i')\n 8. \\<And>s a b.\n       \\<lbrakk>case s of\n                (i', res) \\<Rightarrow>\n                  res = \\<Union> (set (drop i (take i' A))) \\<and>\n                  i \\<le> i';\n        \\<not> (case s of (i, res) \\<Rightarrow> i < length A);\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> b = \\<Union> (set (drop i A))", "apply (auto simp: take_Suc_conv_app_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal Un_set_drop_code_aux: \n  assumes [autoref_rules]: \"(es_impl,{})\\<in>\\<langle>R\\<rangle>Rs\"\n  assumes [autoref_rules]: \"(un_impl,(\\<union>))\\<in>\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs\"\n  shows \"(?c,Un_set_drop_impl)\\<in>nat_rel \\<rightarrow> \\<langle>\\<langle>R\\<rangle>Rs\\<rangle>as_rel \\<rightarrow> \\<langle>\\<langle>R\\<rangle>Rs\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, Un_set_drop_impl)\n    \\<in> nat_rel \\<rightarrow>\n          \\<langle>\\<langle>R\\<rangle>Rs\\<rangle>as_rel \\<rightarrow>\n          \\<langle>\\<langle>R\\<rangle>Rs\\<rangle>nres_rel", "unfolding Un_set_drop_impl_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>i A.\n        WHILE\\<^sub>T (\\<lambda>(i, res). i < length A)\n         (\\<lambda>(i, res).\n             ASSERT (i < length A) \\<bind>\n             (\\<lambda>_.\n                 let res = A ! i \\<union> res; i = i + 1\n                 in RETURN (i, res)))\n         (i, {}) \\<bind>\n        (\\<lambda>(uu_, res). RETURN res))\n    \\<in> nat_rel \\<rightarrow>\n          \\<langle>\\<langle>R\\<rangle>Rs\\<rangle>as_rel \\<rightarrow>\n          \\<langle>\\<langle>R\\<rangle>Rs\\<rangle>nres_rel", "apply (autoref (trace, keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition Un_set_drop_code uses Un_set_drop_code_aux"], ["", "schematic_goal Un_set_drop_tr_aux: \n  \"RETURN ?c \\<le> Un_set_drop_code es_impl un_impl i A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c \\<le> Un_set_drop_code es_impl un_impl i A", "unfolding Un_set_drop_code_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> WHILE\\<^sub>T (\\<lambda>(xc, xd). xc < as_length A)\n           (\\<lambda>(xc, xd).\n               let y' = un_impl (as_get A xc) xd; y'a = xc + 1\n               in RETURN (y'a, y'))\n           (i, es_impl) \\<bind>\n          (\\<lambda>(xb, y). RETURN y)", "by refine_transfer"], ["", "concrete_definition Un_set_drop_tr for es_impl un_impl i A \n  uses Un_set_drop_tr_aux"], ["", "lemma Un_set_drop_autoref[autoref_rules]: \n  assumes \"GEN_OP es_impl {} (\\<langle>R\\<rangle>Rs)\"\n  assumes \"GEN_OP un_impl (\\<union>) (\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs)\"\n  shows \"(\\<lambda>i A. RETURN (Un_set_drop_tr es_impl un_impl i A),Un_set_drop_impl)\n    \\<in>nat_rel \\<rightarrow> \\<langle>\\<langle>R\\<rangle>Rs\\<rangle>as_rel \\<rightarrow> \\<langle>\\<langle>R\\<rangle>Rs\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i A. RETURN (Un_set_drop_tr es_impl un_impl i A),\n     Un_set_drop_impl)\n    \\<in> nat_rel \\<rightarrow>\n          \\<langle>\\<langle>R\\<rangle>Rs\\<rangle>as_rel \\<rightarrow>\n          \\<langle>\\<langle>R\\<rangle>Rs\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> nat_rel;\n        (aa, a'a)\n        \\<in> \\<langle>\\<langle>R\\<rangle>Rs\\<rangle>as_rel\\<rbrakk>\n       \\<Longrightarrow> RETURN (Un_set_drop_tr es_impl un_impl a aa)\n                         \\<le> \\<Down> (\\<langle>R\\<rangle>Rs)\n                                (Un_set_drop_impl a' a'a)", "apply (rule order_trans[OF Un_set_drop_tr.refine])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> nat_rel;\n        (aa, a'a)\n        \\<in> \\<langle>\\<langle>R\\<rangle>Rs\\<rangle>as_rel\\<rbrakk>\n       \\<Longrightarrow> Un_set_drop_code es_impl un_impl a aa\n                         \\<le> \\<Down> (\\<langle>R\\<rangle>Rs)\n                                (Un_set_drop_impl a' a'a)", "using Un_set_drop_code.refine[of es_impl Rs R un_impl, \n    param_fo, THEN nres_relD]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(es_impl, {}) \\<in> \\<langle>R\\<rangle>Rs;\n   (un_impl, (\\<union>))\n   \\<in> \\<langle>R\\<rangle>Rs \\<rightarrow>\n         \\<langle>R\\<rangle>Rs \\<rightarrow> \\<langle>R\\<rangle>Rs;\n   (?x2, ?x'2) \\<in> nat_rel;\n   (?x1, ?x'1) \\<in> \\<langle>\\<langle>R\\<rangle>Rs\\<rangle>as_rel\\<rbrakk>\n  \\<Longrightarrow> Un_set_drop_code es_impl un_impl ?x2 ?x1\n                    \\<le> \\<Down> (\\<langle>R\\<rangle>Rs)\n                           (Un_set_drop_impl ?x'2 ?x'1)\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> nat_rel;\n        (aa, a'a)\n        \\<in> \\<langle>\\<langle>R\\<rangle>Rs\\<rangle>as_rel\\<rbrakk>\n       \\<Longrightarrow> Un_set_drop_code es_impl un_impl a aa\n                         \\<le> \\<Down> (\\<langle>R\\<rangle>Rs)\n                                (Un_set_drop_impl a' a'a)", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>(es_impl, {}) \\<in> \\<langle>R\\<rangle>Rs;\n   (un_impl, (\\<union>))\n   \\<in> \\<langle>R\\<rangle>Rs \\<rightarrow>\n         \\<langle>R\\<rangle>Rs \\<rightarrow> \\<langle>R\\<rangle>Rs;\n   (?x2, ?x'2) \\<in> nat_rel;\n   (?x1, ?x'1) \\<in> \\<langle>\\<langle>R\\<rangle>Rs\\<rangle>as_rel\\<rbrakk>\n  \\<Longrightarrow> Un_set_drop_code es_impl un_impl ?x2 ?x1\n                    \\<le> \\<Down> (\\<langle>R\\<rangle>Rs)\n                           (Un_set_drop_impl ?x'2 ?x'1)\n  GEN_OP es_impl {} (\\<langle>R\\<rangle>Rs)\n  GEN_OP un_impl (\\<union>)\n   (\\<langle>R\\<rangle>Rs \\<rightarrow>\n    \\<langle>R\\<rangle>Rs \\<rightarrow> \\<langle>R\\<rangle>Rs)\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> nat_rel;\n        (aa, a'a)\n        \\<in> \\<langle>\\<langle>R\\<rangle>Rs\\<rangle>as_rel\\<rbrakk>\n       \\<Longrightarrow> Un_set_drop_code es_impl un_impl a aa\n                         \\<le> \\<Down> (\\<langle>R\\<rangle>Rs)\n                                (Un_set_drop_impl a' a'a)", "by simp"], ["", "subsubsection \\<open>Actual Refinement\\<close>"], ["", "type_synonym 'Q gGS = \"nat set list \\<times> 'Q GS\""], ["", "type_synonym 'Q goGS = \"'Q ce \\<times> 'Q oGS\""], ["", "context igb_graph\nbegin"], ["", "definition gGS_invar :: \"'Q gGS \\<Rightarrow> bool\"\n  where \"gGS_invar s \\<equiv> \n  let (a,S,B,I,P) = s in \n    GS_invar (S,B,I,P)\n    \\<and> length a = length B\n    \\<and> \\<Union>(set a) \\<subseteq> {0..<num_acc}\n  \""], ["", "definition gGS_\\<alpha> :: \"'Q gGS \\<Rightarrow> 'Q abs_gstate\"\n  where \"gGS_\\<alpha> s \\<equiv> let (a,s)=s in (a,GS.\\<alpha> s)\""], ["", "definition \"gGS_rel \\<equiv> br gGS_\\<alpha> gGS_invar\""], ["", "lemma gGS_rel_sv[relator_props,intro!,simp]: \"single_valued gGS_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued gGS_rel", "unfolding gGS_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (br gGS_\\<alpha> gGS_invar)", "by auto"], ["", "definition goGS_invar :: \"'Q goGS \\<Rightarrow> bool\" where\n  \"goGS_invar s \\<equiv> let (brk,ogs)=s in brk=None \\<longrightarrow> oGS_invar ogs\""], ["", "definition \"goGS_\\<alpha> s \\<equiv> let (brk,ogs)=s in (brk,oGS_\\<alpha> ogs)\""], ["", "definition \"goGS_rel \\<equiv> br goGS_\\<alpha> goGS_invar\""], ["", "lemma goGS_rel_sv[relator_props,intro!,simp]: \"single_valued goGS_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued goGS_rel", "unfolding goGS_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (br goGS_\\<alpha> goGS_invar)", "by auto"], ["", "end"], ["", "context igb_fr_graph\nbegin"], ["", "lemma gGS_relE:\n    assumes \"(s',(a,p,D,pE))\\<in>gGS_rel\"\n    obtains S' B' I' P' where \"s'=(a,S',B',I',P')\" \n      and \"((S',B',I',P'),(p,D,pE))\\<in>GS_rel\" \n      and \"length a = length B'\"\n      and \"\\<Union>(set a) \\<subseteq> {0..<num_acc}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>S' B' I' P'.\n        \\<lbrakk>s' = (a, S', B', I', P');\n         ((S', B', I', P'), p, D, pE) \\<in> GS_rel; length a = length B';\n         \\<Union> (set a) \\<subseteq> {0..<num_acc}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  (s', a, p, D, pE) \\<in> gGS_rel\n\ngoal (1 subgoal):\n 1. (\\<And>S' B' I' P'.\n        \\<lbrakk>s' = (a, S', B', I', P');\n         ((S', B', I', P'), p, D, pE) \\<in> GS_rel; length a = length B';\n         \\<Union> (set a) \\<subseteq> {0..<num_acc}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (cases s')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b c d e.\n       \\<lbrakk>\\<And>S' B' I' P'.\n                   \\<lbrakk>s' = (a, S', B', I', P');\n                    ((S', B', I', P'), p, D, pE) \\<in> GS_rel;\n                    length a = length B';\n                    \\<Union> (set a) \\<subseteq> {0..<num_acc}\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        (s', a, p, D, pE) \\<in> gGS_rel; s' = (aa, b, c, d, e)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (simp add: gGS_rel_def br_def gGS_\\<alpha>_def GS.\\<alpha>_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b c d e.\n       \\<lbrakk>\\<lbrakk>((b, c, d, e), GS.p_\\<alpha> (b, c, d, e),\n                          GS.D_\\<alpha> (b, c, d, e),\n                          GS.pE_\\<alpha> (b, c, d, e))\n                         \\<in> GS_rel;\n                 length a = length c;\n                 \\<Union> (set a) \\<subseteq> {0..<num_acc}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        p = GS.p_\\<alpha> (b, c, d, e) \\<and>\n        D = GS.D_\\<alpha> (b, c, d, e) \\<and>\n        pE = GS.pE_\\<alpha> (b, c, d, e) \\<and> gGS_invar (a, b, c, d, e);\n        s' = (a, b, c, d, e)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (rule that)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>b c d e.\n       \\<lbrakk>\\<lbrakk>((b, c, d, e), GS.p_\\<alpha> (b, c, d, e),\n                          GS.D_\\<alpha> (b, c, d, e),\n                          GS.pE_\\<alpha> (b, c, d, e))\n                         \\<in> GS_rel;\n                 length a = length c;\n                 \\<Union> (set a) \\<subseteq> {0..<num_acc}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        p = GS.p_\\<alpha> (b, c, d, e) \\<and>\n        D = GS.D_\\<alpha> (b, c, d, e) \\<and>\n        pE = GS.pE_\\<alpha> (b, c, d, e) \\<and> gGS_invar (a, b, c, d, e);\n        s' = (a, b, c, d, e)\\<rbrakk>\n       \\<Longrightarrow> s' =\n                         (a, ?S'10 b c d e, ?B'10 b c d e, ?I'10 b c d e,\n                          ?P'10 b c d e)\n 2. \\<And>b c d e.\n       \\<lbrakk>\\<lbrakk>((b, c, d, e), GS.p_\\<alpha> (b, c, d, e),\n                          GS.D_\\<alpha> (b, c, d, e),\n                          GS.pE_\\<alpha> (b, c, d, e))\n                         \\<in> GS_rel;\n                 length a = length c;\n                 \\<Union> (set a) \\<subseteq> {0..<num_acc}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        p = GS.p_\\<alpha> (b, c, d, e) \\<and>\n        D = GS.D_\\<alpha> (b, c, d, e) \\<and>\n        pE = GS.pE_\\<alpha> (b, c, d, e) \\<and> gGS_invar (a, b, c, d, e);\n        s' = (a, b, c, d, e)\\<rbrakk>\n       \\<Longrightarrow> ((?S'10 b c d e, ?B'10 b c d e, ?I'10 b c d e,\n                           ?P'10 b c d e),\n                          p, D, pE)\n                         \\<in> GS_rel\n 3. \\<And>b c d e.\n       \\<lbrakk>\\<lbrakk>((b, c, d, e), GS.p_\\<alpha> (b, c, d, e),\n                          GS.D_\\<alpha> (b, c, d, e),\n                          GS.pE_\\<alpha> (b, c, d, e))\n                         \\<in> GS_rel;\n                 length a = length c;\n                 \\<Union> (set a) \\<subseteq> {0..<num_acc}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        p = GS.p_\\<alpha> (b, c, d, e) \\<and>\n        D = GS.D_\\<alpha> (b, c, d, e) \\<and>\n        pE = GS.pE_\\<alpha> (b, c, d, e) \\<and> gGS_invar (a, b, c, d, e);\n        s' = (a, b, c, d, e)\\<rbrakk>\n       \\<Longrightarrow> length a = length (?B'10 b c d e)\n 4. \\<And>b c d e.\n       \\<lbrakk>\\<lbrakk>((b, c, d, e), GS.p_\\<alpha> (b, c, d, e),\n                          GS.D_\\<alpha> (b, c, d, e),\n                          GS.pE_\\<alpha> (b, c, d, e))\n                         \\<in> GS_rel;\n                 length a = length c;\n                 \\<Union> (set a) \\<subseteq> {0..<num_acc}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        p = GS.p_\\<alpha> (b, c, d, e) \\<and>\n        D = GS.D_\\<alpha> (b, c, d, e) \\<and>\n        pE = GS.pE_\\<alpha> (b, c, d, e) \\<and> gGS_invar (a, b, c, d, e);\n        s' = (a, b, c, d, e)\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (set a) \\<subseteq> {0..<num_acc}", "apply (simp only:)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b c d e.\n       \\<lbrakk>\\<lbrakk>((b, c, d, e), GS.p_\\<alpha> (b, c, d, e),\n                          GS.D_\\<alpha> (b, c, d, e),\n                          GS.pE_\\<alpha> (b, c, d, e))\n                         \\<in> GS_rel;\n                 length a = length c;\n                 \\<Union> (set a) \\<subseteq> {0..<num_acc}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        p = GS.p_\\<alpha> (b, c, d, e) \\<and>\n        D = GS.D_\\<alpha> (b, c, d, e) \\<and>\n        pE = GS.pE_\\<alpha> (b, c, d, e) \\<and> gGS_invar (a, b, c, d, e);\n        s' = (a, b, c, d, e)\\<rbrakk>\n       \\<Longrightarrow> ((b, c, d, e), p, D, pE) \\<in> GS_rel\n 2. \\<And>b c d e.\n       \\<lbrakk>\\<lbrakk>((b, c, d, e), GS.p_\\<alpha> (b, c, d, e),\n                          GS.D_\\<alpha> (b, c, d, e),\n                          GS.pE_\\<alpha> (b, c, d, e))\n                         \\<in> GS_rel;\n                 length a = length c;\n                 \\<Union> (set a) \\<subseteq> {0..<num_acc}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        p = GS.p_\\<alpha> (b, c, d, e) \\<and>\n        D = GS.D_\\<alpha> (b, c, d, e) \\<and>\n        pE = GS.pE_\\<alpha> (b, c, d, e) \\<and> gGS_invar (a, b, c, d, e);\n        s' = (a, b, c, d, e)\\<rbrakk>\n       \\<Longrightarrow> length a = length c\n 3. \\<And>b c d e.\n       \\<lbrakk>\\<lbrakk>((b, c, d, e), GS.p_\\<alpha> (b, c, d, e),\n                          GS.D_\\<alpha> (b, c, d, e),\n                          GS.pE_\\<alpha> (b, c, d, e))\n                         \\<in> GS_rel;\n                 length a = length c;\n                 \\<Union> (set a) \\<subseteq> {0..<num_acc}\\<rbrakk>\n                \\<Longrightarrow> thesis;\n        p = GS.p_\\<alpha> (b, c, d, e) \\<and>\n        D = GS.D_\\<alpha> (b, c, d, e) \\<and>\n        pE = GS.pE_\\<alpha> (b, c, d, e) \\<and> gGS_invar (a, b, c, d, e);\n        s' = (a, b, c, d, e)\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (set a) \\<subseteq> {0..<num_acc}", "apply (auto simp: GS_rel_def br_def gGS_invar_def GS.\\<alpha>_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition goinitial_impl :: \"'Q goGS\" \n    where \"goinitial_impl \\<equiv> (None,Map.empty)\""], ["", "lemma goinitial_impl_refine: \"(goinitial_impl,goinitial)\\<in>goGS_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (goinitial_impl, goinitial) \\<in> goGS_rel", "by (auto \n      simp: goinitial_impl_def goinitial_def goGS_rel_def br_def \n      simp: goGS_\\<alpha>_def goGS_invar_def oGS_\\<alpha>_def oGS_invar_def)"], ["", "definition gto_outer_impl :: \"'Q ce \\<Rightarrow> 'Q gGS \\<Rightarrow> 'Q goGS\"\n    where \"gto_outer_impl brk s \\<equiv> let (A,S,B,I,P)=s in (brk,I)\""], ["", "lemma gto_outer_refine:\n    assumes A: \"brk = None \\<longrightarrow> (p=[] \\<and> pE={})\"\n    assumes B: \"(s, (A,p, D, pE)) \\<in> gGS_rel\"\n    assumes C: \"(brk',brk)\\<in>Id\"\n    shows \"(gto_outer_impl brk' s,gto_outer brk (A,p,D,pE))\\<in>goGS_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gto_outer_impl brk' s, gto_outer brk (A, p, D, pE)) \\<in> goGS_rel", "proof (cases s)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c d e.\n       s = (a, b, c, d, e) \\<Longrightarrow>\n       (gto_outer_impl brk' s, gto_outer brk (A, p, D, pE)) \\<in> goGS_rel", "fix A S B I P"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c d e.\n       s = (a, b, c, d, e) \\<Longrightarrow>\n       (gto_outer_impl brk' s, gto_outer brk (A, p, D, pE)) \\<in> goGS_rel", "assume [simp]: \"s=(A,S,B,I,P)\""], ["proof (state)\nthis:\n  s = (A, S, B, I, P)\n\ngoal (1 subgoal):\n 1. \\<And>a b c d e.\n       s = (a, b, c, d, e) \\<Longrightarrow>\n       (gto_outer_impl brk' s, gto_outer brk (A, p, D, pE)) \\<in> goGS_rel", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (gto_outer_impl brk' s, gto_outer brk (A, p, D, pE)) \\<in> goGS_rel", "using C"], ["proof (prove)\nusing this:\n  (brk', brk) \\<in> Id\n\ngoal (1 subgoal):\n 1. (gto_outer_impl brk' s, gto_outer brk (A, p, D, pE)) \\<in> goGS_rel", "apply (cases brk)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(brk', brk) \\<in> Id; brk = None\\<rbrakk>\n    \\<Longrightarrow> (gto_outer_impl brk' s, gto_outer brk (A, p, D, pE))\n                      \\<in> goGS_rel\n 2. \\<And>a.\n       \\<lbrakk>(brk', brk) \\<in> Id; brk = Some a\\<rbrakk>\n       \\<Longrightarrow> (gto_outer_impl brk' s,\n                          gto_outer brk (A, p, D, pE))\n                         \\<in> goGS_rel", "using assms I_to_outer[of S B I P D]"], ["proof (prove)\nusing this:\n  brk = None \\<longrightarrow> p = [] \\<and> pE = {}\n  (s, A, p, D, pE) \\<in> gGS_rel\n  (brk', brk) \\<in> Id\n  ((S, B, I, P), [], D, {}) \\<in> GS_rel \\<Longrightarrow>\n  (I, D) \\<in> oGS_rel\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(brk', brk) \\<in> Id; brk = None\\<rbrakk>\n    \\<Longrightarrow> (gto_outer_impl brk' s, gto_outer brk (A, p, D, pE))\n                      \\<in> goGS_rel\n 2. \\<And>a.\n       \\<lbrakk>(brk', brk) \\<in> Id; brk = Some a\\<rbrakk>\n       \\<Longrightarrow> (gto_outer_impl brk' s,\n                          gto_outer brk (A, p, D, pE))\n                         \\<in> goGS_rel", "apply (auto \n        simp: goGS_rel_def br_def goGS_\\<alpha>_def gto_outer_def \n              gto_outer_impl_def goGS_invar_def \n        simp: gGS_rel_def oGS_rel_def GS_rel_def gGS_\\<alpha>_def gGS_invar_def \n              GS.\\<alpha>_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>(brk', brk) \\<in> Id; brk = Some a\\<rbrakk>\n       \\<Longrightarrow> (gto_outer_impl brk' s,\n                          gto_outer brk (A, p, D, pE))\n                         \\<in> goGS_rel", "using B"], ["proof (prove)\nusing this:\n  (s, A, p, D, pE) \\<in> gGS_rel\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>(brk', brk) \\<in> Id; brk = Some a\\<rbrakk>\n       \\<Longrightarrow> (gto_outer_impl brk' s,\n                          gto_outer brk (A, p, D, pE))\n                         \\<in> goGS_rel", "apply (auto \n        simp: gto_outer_def gto_outer_impl_def\n        simp: br_def goGS_rel_def goGS_invar_def goGS_\\<alpha>_def oGS_\\<alpha>_def\n        simp: gGS_rel_def gGS_\\<alpha>_def GS.\\<alpha>_def GS.D_\\<alpha>_def\n      )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (gto_outer_impl brk' s, gto_outer brk (A, p, D, pE)) \\<in> goGS_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"gpush_impl v s \\<equiv> let (a,s)=s in (a@[acc v], push_impl v s)\""], ["", "lemma gpush_impl_refine:\n    assumes B: \"(s',(a,p,D,pE))\\<in>gGS_rel\"\n    assumes A: \"(v',v)\\<in>Id\" \n    assumes PRE: \"v' \\<notin> \\<Union>(set p)\" \"v' \\<notin> D\"\n    shows \"(gpush_impl v' s', gpush v (a,p,D,pE))\\<in>gGS_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gpush_impl v' s', gpush v (a, p, D, pE)) \\<in> gGS_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (gpush_impl v' s', gpush v (a, p, D, pE)) \\<in> gGS_rel", "from B"], ["proof (chain)\npicking this:\n  (s', a, p, D, pE) \\<in> gGS_rel", "obtain S' B' I' P' where [simp]: \"s'=(a,S',B',I',P')\" \n      and OSR: \"((S',B',I',P'),(p,D,pE))\\<in>GS_rel\" and L: \"length a = length B'\" \n      and R: \"\\<Union>(set a) \\<subseteq> {0..<num_acc}\""], ["proof (prove)\nusing this:\n  (s', a, p, D, pE) \\<in> gGS_rel\n\ngoal (1 subgoal):\n 1. (\\<And>S' B' I' P'.\n        \\<lbrakk>s' = (a, S', B', I', P');\n         ((S', B', I', P'), p, D, pE) \\<in> GS_rel; length a = length B';\n         \\<Union> (set a) \\<subseteq> {0..<num_acc}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule gGS_relE)"], ["proof (state)\nthis:\n  s' = (a, S', B', I', P')\n  ((S', B', I', P'), p, D, pE) \\<in> GS_rel\n  length a = length B'\n  \\<Union> (set a) \\<subseteq> {0..<num_acc}\n\ngoal (1 subgoal):\n 1. (gpush_impl v' s', gpush v (a, p, D, pE)) \\<in> gGS_rel", "{"], ["proof (state)\nthis:\n  s' = (a, S', B', I', P')\n  ((S', B', I', P'), p, D, pE) \\<in> GS_rel\n  length a = length B'\n  \\<Union> (set a) \\<subseteq> {0..<num_acc}\n\ngoal (1 subgoal):\n 1. (gpush_impl v' s', gpush v (a, p, D, pE)) \\<in> gGS_rel", "fix S B I P S' B' I' P'"], ["proof (state)\ngoal (1 subgoal):\n 1. (gpush_impl v' s', gpush v (a, p, D, pE)) \\<in> gGS_rel", "assume \"push_impl v (S, B, I, P) = (S', B', I', P')\""], ["proof (state)\nthis:\n  push_impl v (S, B, I, P) = (S', B', I', P')\n\ngoal (1 subgoal):\n 1. (gpush_impl v' s', gpush v (a, p, D, pE)) \\<in> gGS_rel", "hence \"length B' = Suc (length B)\""], ["proof (prove)\nusing this:\n  push_impl v (S, B, I, P) = (S', B', I', P')\n\ngoal (1 subgoal):\n 1. length B' = Suc (length B)", "by (auto simp add: push_impl_def GS.push_impl_def Let_def)"], ["proof (state)\nthis:\n  length B' = Suc (length B)\n\ngoal (1 subgoal):\n 1. (gpush_impl v' s', gpush v (a, p, D, pE)) \\<in> gGS_rel", "}"], ["proof (state)\nthis:\n  push_impl v (?S5, ?B5, ?I5, ?P5) =\n  (?S'a5, ?B'a5, ?I'a5, ?P'a5) \\<Longrightarrow>\n  length ?B'a5 = Suc (length ?B5)\n\ngoal (1 subgoal):\n 1. (gpush_impl v' s', gpush v (a, p, D, pE)) \\<in> gGS_rel", "note AUX1=this"], ["proof (state)\nthis:\n  push_impl v (?S5, ?B5, ?I5, ?P5) =\n  (?S'a5, ?B'a5, ?I'a5, ?P'a5) \\<Longrightarrow>\n  length ?B'a5 = Suc (length ?B5)\n\ngoal (1 subgoal):\n 1. (gpush_impl v' s', gpush v (a, p, D, pE)) \\<in> gGS_rel", "from push_refine[OF OSR A PRE] A L acc_bound R"], ["proof (chain)\npicking this:\n  (push_impl v' (S', B', I', P'), push v (p, D, pE)) \\<in> GS_rel\n  (v', v) \\<in> Id\n  length a = length B'\n  \\<Union> (range acc) \\<subseteq> {0..<num_acc}\n  \\<Union> (set a) \\<subseteq> {0..<num_acc}", "show ?thesis"], ["proof (prove)\nusing this:\n  (push_impl v' (S', B', I', P'), push v (p, D, pE)) \\<in> GS_rel\n  (v', v) \\<in> Id\n  length a = length B'\n  \\<Union> (range acc) \\<subseteq> {0..<num_acc}\n  \\<Union> (set a) \\<subseteq> {0..<num_acc}\n\ngoal (1 subgoal):\n 1. (gpush_impl v' s', gpush v (a, p, D, pE)) \\<in> gGS_rel", "unfolding gpush_impl_def gpush_def\n        gGS_rel_def gGS_invar_def gGS_\\<alpha>_def GS_rel_def br_def"], ["proof (prove)\nusing this:\n  (push_impl v' (S', B', I', P'), push v (p, D, pE))\n  \\<in> {(c, a). a = GS.\\<alpha> c \\<and> GS_invar c}\n  (v', v) \\<in> Id\n  length a = length B'\n  \\<Union> (range acc) \\<subseteq> {0..<num_acc}\n  \\<Union> (set a) \\<subseteq> {0..<num_acc}\n\ngoal (1 subgoal):\n 1. (let (a, s) = s' in (a @ [acc v'], push_impl v' s),\n     let (a, s) = (a, p, D, pE) in (a @ [acc v], push v s))\n    \\<in> {(c, a).\n           a = (let (a, s) = c in (a, GS.\\<alpha> s)) \\<and>\n           (let (a, S, B, I, P) = c\n            in GS_invar (S, B, I, P) \\<and>\n               length a = length B \\<and>\n               \\<Union> (set a) \\<subseteq> {0..<num_acc})}", "apply (auto dest: AUX1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (gpush_impl v' s', gpush v (a, p, D, pE)) \\<in> gGS_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "definition gpop_impl :: \"'Q gGS \\<Rightarrow> 'Q gGS nres\" \n    where \"gpop_impl s \\<equiv> do {\n    let (a,s)=s;\n    s\\<leftarrow>pop_impl s;\n    ASSERT (a\\<noteq>[]);\n    let a = butlast a;\n    RETURN (a,s)\n  }\""], ["", "lemma gpop_impl_refine:\n    assumes A: \"(s',(a,p,D,pE))\\<in>gGS_rel\"\n    assumes PRE: \"p \\<noteq> []\" \"pE \\<inter> last p \\<times> UNIV = {}\"\n    shows \"gpop_impl s' \\<le> \\<Down>gGS_rel (RETURN (gpop (a,p,D,pE)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gpop_impl s' \\<le> \\<Down> gGS_rel (RETURN (gpop (a, p, D, pE)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gpop_impl s' \\<le> \\<Down> gGS_rel (RETURN (gpop (a, p, D, pE)))", "from A"], ["proof (chain)\npicking this:\n  (s', a, p, D, pE) \\<in> gGS_rel", "obtain S' B' I' P' where [simp]: \"s'=(a,S',B',I',P')\" \n      and OSR: \"((S',B',I',P'),(p,D,pE))\\<in>GS_rel\" and L: \"length a = length B'\"\n      and R: \"\\<Union>(set a) \\<subseteq> {0..<num_acc}\""], ["proof (prove)\nusing this:\n  (s', a, p, D, pE) \\<in> gGS_rel\n\ngoal (1 subgoal):\n 1. (\\<And>S' B' I' P'.\n        \\<lbrakk>s' = (a, S', B', I', P');\n         ((S', B', I', P'), p, D, pE) \\<in> GS_rel; length a = length B';\n         \\<Union> (set a) \\<subseteq> {0..<num_acc}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule gGS_relE)"], ["proof (state)\nthis:\n  s' = (a, S', B', I', P')\n  ((S', B', I', P'), p, D, pE) \\<in> GS_rel\n  length a = length B'\n  \\<Union> (set a) \\<subseteq> {0..<num_acc}\n\ngoal (1 subgoal):\n 1. gpop_impl s' \\<le> \\<Down> gGS_rel (RETURN (gpop (a, p, D, pE)))", "from PRE OSR"], ["proof (chain)\npicking this:\n  p \\<noteq> []\n  pE \\<inter> last p \\<times> UNIV = {}\n  ((S', B', I', P'), p, D, pE) \\<in> GS_rel", "have [simp]: \"a\\<noteq>[]\""], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  pE \\<inter> last p \\<times> UNIV = {}\n  ((S', B', I', P'), p, D, pE) \\<in> GS_rel\n\ngoal (1 subgoal):\n 1. a \\<noteq> []", "using L"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  pE \\<inter> last p \\<times> UNIV = {}\n  ((S', B', I', P'), p, D, pE) \\<in> GS_rel\n  length a = length B'\n\ngoal (1 subgoal):\n 1. a \\<noteq> []", "by (auto simp add: GS_rel_def br_def GS.\\<alpha>_def GS.p_\\<alpha>_def)"], ["proof (state)\nthis:\n  a \\<noteq> []\n\ngoal (1 subgoal):\n 1. gpop_impl s' \\<le> \\<Down> gGS_rel (RETURN (gpop (a, p, D, pE)))", "{"], ["proof (state)\nthis:\n  a \\<noteq> []\n\ngoal (1 subgoal):\n 1. gpop_impl s' \\<le> \\<Down> gGS_rel (RETURN (gpop (a, p, D, pE)))", "fix S B I P S' B' I' P'"], ["proof (state)\ngoal (1 subgoal):\n 1. gpop_impl s' \\<le> \\<Down> gGS_rel (RETURN (gpop (a, p, D, pE)))", "assume \"nofail (pop_impl ((S, B, I, P)::'a GS))\"\n        \"inres (pop_impl ((S, B, I, P)::'a GS)) (S', B', I', P')\""], ["proof (state)\nthis:\n  nofail (pop_impl (S, B, I, P))\n  inres (pop_impl (S, B, I, P)) (S', B', I', P')\n\ngoal (1 subgoal):\n 1. gpop_impl s' \\<le> \\<Down> gGS_rel (RETURN (gpop (a, p, D, pE)))", "hence \"length B' = length B - Suc 0\""], ["proof (prove)\nusing this:\n  nofail (pop_impl (S, B, I, P))\n  inres (pop_impl (S, B, I, P)) (S', B', I', P')\n\ngoal (1 subgoal):\n 1. length B' = length B - Suc 0", "apply (simp add: pop_impl_def GS.pop_impl_def Let_def\n          refine_pw_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length B - Suc 0 < length B \\<and>\n             nofail\n              (GS.mark_as_done (S, B, I, P)\n                (GS.seg_start (S, B, I, P) (length B - Suc 0))\n                (GS.seg_end (S, B, I, P) (length B - Suc 0)) I) \\<and>\n             (Ex (inres\n                   (GS.mark_as_done (S, B, I, P)\n                     (GS.seg_start (S, B, I, P) (length B - Suc 0))\n                     (GS.seg_end (S, B, I, P) (length B - Suc 0))\n                     I)) \\<longrightarrow>\n              B \\<noteq> []);\n     \\<exists>y.\n        inres\n         (GS.mark_as_done (S, B, I, P)\n           (GS.seg_start (S, B, I, P) (length B - Suc 0))\n           (GS.seg_end (S, B, I, P) (length B - Suc 0)) I)\n         y \\<and>\n        (B \\<noteq> [] \\<longrightarrow>\n         take (last B) S = S' \\<and>\n         butlast B = B' \\<and> y = I' \\<and> P = P')\\<rbrakk>\n    \\<Longrightarrow> length B' = length B - Suc 0", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  length B' = length B - Suc 0\n\ngoal (1 subgoal):\n 1. gpop_impl s' \\<le> \\<Down> gGS_rel (RETURN (gpop (a, p, D, pE)))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>nofail (pop_impl (?S5, ?B5, ?I5, ?P5));\n   inres (pop_impl (?S5, ?B5, ?I5, ?P5))\n    (?S'a5, ?B'a5, ?I'a5, ?P'a5)\\<rbrakk>\n  \\<Longrightarrow> length ?B'a5 = length ?B5 - Suc 0\n\ngoal (1 subgoal):\n 1. gpop_impl s' \\<le> \\<Down> gGS_rel (RETURN (gpop (a, p, D, pE)))", "note AUX1=this"], ["proof (state)\nthis:\n  \\<lbrakk>nofail (pop_impl (?S5, ?B5, ?I5, ?P5));\n   inres (pop_impl (?S5, ?B5, ?I5, ?P5))\n    (?S'a5, ?B'a5, ?I'a5, ?P'a5)\\<rbrakk>\n  \\<Longrightarrow> length ?B'a5 = length ?B5 - Suc 0\n\ngoal (1 subgoal):\n 1. gpop_impl s' \\<le> \\<Down> gGS_rel (RETURN (gpop (a, p, D, pE)))", "from A L"], ["proof (chain)\npicking this:\n  (s', a, p, D, pE) \\<in> gGS_rel\n  length a = length B'", "show ?thesis"], ["proof (prove)\nusing this:\n  (s', a, p, D, pE) \\<in> gGS_rel\n  length a = length B'\n\ngoal (1 subgoal):\n 1. gpop_impl s' \\<le> \\<Down> gGS_rel (RETURN (gpop (a, p, D, pE)))", "unfolding gpop_impl_def gpop_def gGS_rel_def gGS_\\<alpha>_def br_def"], ["proof (prove)\nusing this:\n  (s', a, p, D, pE)\n  \\<in> {(c, a).\n         a = (let (a, s) = c in (a, GS.\\<alpha> s)) \\<and> gGS_invar c}\n  length a = length B'\n\ngoal (1 subgoal):\n 1. (let (a, s) = s'\n     in pop_impl s \\<bind>\n        (\\<lambda>s.\n            ASSERT (a \\<noteq> []) \\<bind>\n            (\\<lambda>_. let a = butlast a in RETURN (a, s))))\n    \\<le> \\<Down>\n           {(c, a).\n            a = (let (a, s) = c in (a, GS.\\<alpha> s)) \\<and> gGS_invar c}\n           (RETURN (let (a, s) = (a, p, D, pE) in (butlast a, pop s)))", "apply (simp add: Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(p, D, pE) = GS.\\<alpha> (S', B', I', P') \\<and>\n             gGS_invar (a, S', B', I', P');\n     length a = length B'\\<rbrakk>\n    \\<Longrightarrow> pop_impl (S', B', I', P') \\<bind>\n                      (\\<lambda>s. RETURN (butlast a, s))\n                      \\<le> \\<Down>\n                             {(c, a).\n                              a =\n                              (case c of\n                               (a, s) \\<Rightarrow>\n                                 (a, GS.\\<alpha> s)) \\<and>\n                              gGS_invar c}\n                             (RETURN\n                               (butlast a,\n                                pop (GS.\\<alpha> (S', B', I', P'))))", "using pop_refine[OF OSR PRE]"], ["proof (prove)\nusing this:\n  pop_impl (S', B', I', P') \\<le> \\<Down> GS_rel (RETURN (pop (p, D, pE)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(p, D, pE) = GS.\\<alpha> (S', B', I', P') \\<and>\n             gGS_invar (a, S', B', I', P');\n     length a = length B'\\<rbrakk>\n    \\<Longrightarrow> pop_impl (S', B', I', P') \\<bind>\n                      (\\<lambda>s. RETURN (butlast a, s))\n                      \\<le> \\<Down>\n                             {(c, a).\n                              a =\n                              (case c of\n                               (a, s) \\<Rightarrow>\n                                 (a, GS.\\<alpha> s)) \\<and>\n                              gGS_invar c}\n                             (RETURN\n                               (butlast a,\n                                pop (GS.\\<alpha> (S', B', I', P'))))", "apply (simp add: pw_le_iff refine_pw_simps split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(p, D, pE) = GS.\\<alpha> (S', B', I', P') \\<and>\n             gGS_invar (a, S', B', I', P');\n     length a = length B';\n     nofail (pop_impl (S', B', I', P')) \\<and>\n     (\\<forall>a aa ab b.\n         inres (pop_impl (S', B', I', P')) (a, aa, ab, b) \\<longrightarrow>\n         (\\<exists>ac ad ba.\n             ((a, aa, ab, b), ac, ad, ba) \\<in> GS_rel \\<and>\n             pop (GS.\\<alpha> (S', B', I', P')) = (ac, ad, ba)))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aa ab ac b.\n                         inres (pop_impl (S', B', I', P'))\n                          (aa, ab, ac, b) \\<longrightarrow>\n                         gGS_invar (butlast a, aa, ab, ac, b) \\<and>\n                         pop (GS.\\<alpha> (S', B', I', P')) =\n                         GS.\\<alpha> (aa, ab, ac, b)", "unfolding gGS_rel_def gGS_invar_def gGS_\\<alpha>_def GS_rel_def GS.\\<alpha>_def br_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(p, D, pE) =\n             (GS.p_\\<alpha> (S', B', I', P'),\n              GS.D_\\<alpha> (S', B', I', P'),\n              GS.pE_\\<alpha> (S', B', I', P')) \\<and>\n             (let (a, S, B, I, P) = (a, S', B', I', P')\n              in GS_invar (S, B, I, P) \\<and>\n                 length a = length B \\<and>\n                 \\<Union> (set a) \\<subseteq> {0..<num_acc});\n     length a = length B';\n     nofail (pop_impl (S', B', I', P')) \\<and>\n     (\\<forall>a aa ab b.\n         inres (pop_impl (S', B', I', P')) (a, aa, ab, b) \\<longrightarrow>\n         (\\<exists>ac ad ba.\n             ((a, aa, ab, b), ac, ad, ba)\n             \\<in> {(c, a).\n                    a =\n                    (GS.p_\\<alpha> c, GS.D_\\<alpha> c,\n                     GS.pE_\\<alpha> c) \\<and>\n                    GS_invar c} \\<and>\n             pop (GS.p_\\<alpha> (S', B', I', P'),\n                  GS.D_\\<alpha> (S', B', I', P'),\n                  GS.pE_\\<alpha> (S', B', I', P')) =\n             (ac, ad, ba)))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aa ab ac b.\n                         inres (pop_impl (S', B', I', P'))\n                          (aa, ab, ac, b) \\<longrightarrow>\n                         (let (a, S, B, I, P) = (butlast a, aa, ab, ac, b)\n                          in GS_invar (S, B, I, P) \\<and>\n                             length a = length B \\<and>\n                             \\<Union> (set a)\n                             \\<subseteq> {0..<num_acc}) \\<and>\n                         pop (GS.p_\\<alpha> (S', B', I', P'),\n                              GS.D_\\<alpha> (S', B', I', P'),\n                              GS.pE_\\<alpha> (S', B', I', P')) =\n                         (GS.p_\\<alpha> (aa, ab, ac, b),\n                          GS.D_\\<alpha> (aa, ab, ac, b),\n                          GS.pE_\\<alpha> (aa, ab, ac, b))", "apply (auto dest!: AUX1 in_set_butlastD iff: Sup_le_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  gpop_impl s' \\<le> \\<Down> gGS_rel (RETURN (gpop (a, p, D, pE)))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition gselect_edge_impl :: \"'Q gGS \\<Rightarrow> ('Q option \\<times> 'Q gGS) nres\" \n    where \"gselect_edge_impl s \\<equiv> \n    do { \n      let (a,s)=s; \n      (vo,s)\\<leftarrow>select_edge_impl s; \n      RETURN (vo,a,s)\n    }\""], ["", "thm select_edge_refine"], ["", "lemma gselect_edge_impl_refine:\n    assumes A: \"(s', a, p, D, pE) \\<in> gGS_rel\" \n    assumes PRE: \"p \\<noteq> []\"\n    shows \"gselect_edge_impl s' \\<le> \\<Down>(Id \\<times>\\<^sub>r gGS_rel) (gselect_edge (a, p, D, pE))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gselect_edge_impl s'\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r gGS_rel) (gselect_edge (a, p, D, pE))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gselect_edge_impl s'\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r gGS_rel) (gselect_edge (a, p, D, pE))", "from A"], ["proof (chain)\npicking this:\n  (s', a, p, D, pE) \\<in> gGS_rel", "obtain S' B' I' P' where [simp]: \"s'=(a,S',B',I',P')\" \n      and OSR: \"((S',B',I',P'),(p,D,pE))\\<in>GS_rel\" and L: \"length a = length B'\"\n      and R: \"\\<Union>(set a) \\<subseteq> {0..<num_acc}\""], ["proof (prove)\nusing this:\n  (s', a, p, D, pE) \\<in> gGS_rel\n\ngoal (1 subgoal):\n 1. (\\<And>S' B' I' P'.\n        \\<lbrakk>s' = (a, S', B', I', P');\n         ((S', B', I', P'), p, D, pE) \\<in> GS_rel; length a = length B';\n         \\<Union> (set a) \\<subseteq> {0..<num_acc}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule gGS_relE)"], ["proof (state)\nthis:\n  s' = (a, S', B', I', P')\n  ((S', B', I', P'), p, D, pE) \\<in> GS_rel\n  length a = length B'\n  \\<Union> (set a) \\<subseteq> {0..<num_acc}\n\ngoal (1 subgoal):\n 1. gselect_edge_impl s'\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r gGS_rel) (gselect_edge (a, p, D, pE))", "{"], ["proof (state)\nthis:\n  s' = (a, S', B', I', P')\n  ((S', B', I', P'), p, D, pE) \\<in> GS_rel\n  length a = length B'\n  \\<Union> (set a) \\<subseteq> {0..<num_acc}\n\ngoal (1 subgoal):\n 1. gselect_edge_impl s'\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r gGS_rel) (gselect_edge (a, p, D, pE))", "fix S B I P S' B' I' P' vo"], ["proof (state)\ngoal (1 subgoal):\n 1. gselect_edge_impl s'\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r gGS_rel) (gselect_edge (a, p, D, pE))", "assume \"nofail (select_edge_impl ((S, B, I, P)::'a GS))\"\n        \"inres (select_edge_impl ((S, B, I, P)::'a GS)) (vo, (S', B', I', P'))\""], ["proof (state)\nthis:\n  nofail (select_edge_impl (S, B, I, P))\n  inres (select_edge_impl (S, B, I, P)) (vo, S', B', I', P')\n\ngoal (1 subgoal):\n 1. gselect_edge_impl s'\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r gGS_rel) (gselect_edge (a, p, D, pE))", "hence \"length B' = length B\""], ["proof (prove)\nusing this:\n  nofail (select_edge_impl (S, B, I, P))\n  inres (select_edge_impl (S, B, I, P)) (vo, S', B', I', P')\n\ngoal (1 subgoal):\n 1. length B' = length B", "apply (simp add: select_edge_impl_def GS.sel_rem_last_def refine_pw_simps\n          split: if_split_asm prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 y.\n       \\<lbrakk>P \\<noteq> [];\n        GS.seg_start (S, B, I, P) (length B - Suc 0) \\<le> x1;\n        last P = (x1, x2); length B - Suc 0 < length B; x2 \\<noteq> {};\n        (x2 \\<subseteq> {y} \\<longrightarrow>\n         I = I' \\<and>\n         B = B' \\<and>\n         S = S' \\<and>\n         Some y = vo \\<and> y \\<in> x2 \\<and> butlast P = P') \\<and>\n        (x2 \\<subseteq> {y} \\<or>\n         I = I' \\<and>\n         B = B' \\<and>\n         S = S' \\<and>\n         Some y = vo \\<and>\n         y \\<in> x2 \\<and>\n         P[length P - Suc 0 := (x1, x2 - {y})] = P')\\<rbrakk>\n       \\<Longrightarrow> length B' = length B", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  length B' = length B\n\ngoal (1 subgoal):\n 1. gselect_edge_impl s'\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r gGS_rel) (gselect_edge (a, p, D, pE))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>nofail (select_edge_impl (?S5, ?B5, ?I5, ?P5));\n   inres (select_edge_impl (?S5, ?B5, ?I5, ?P5))\n    (?vo5, ?S'a5, ?B'a5, ?I'a5, ?P'a5)\\<rbrakk>\n  \\<Longrightarrow> length ?B'a5 = length ?B5\n\ngoal (1 subgoal):\n 1. gselect_edge_impl s'\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r gGS_rel) (gselect_edge (a, p, D, pE))", "note AUX1=this"], ["proof (state)\nthis:\n  \\<lbrakk>nofail (select_edge_impl (?S5, ?B5, ?I5, ?P5));\n   inres (select_edge_impl (?S5, ?B5, ?I5, ?P5))\n    (?vo5, ?S'a5, ?B'a5, ?I'a5, ?P'a5)\\<rbrakk>\n  \\<Longrightarrow> length ?B'a5 = length ?B5\n\ngoal (1 subgoal):\n 1. gselect_edge_impl s'\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r gGS_rel) (gselect_edge (a, p, D, pE))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. gselect_edge_impl s'\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r gGS_rel) (gselect_edge (a, p, D, pE))", "using select_edge_refine[OF OSR PRE]"], ["proof (prove)\nusing this:\n  select_edge_impl (S', B', I', P')\n  \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel) (select_edge (p, D, pE))\n\ngoal (1 subgoal):\n 1. gselect_edge_impl s'\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r gGS_rel) (gselect_edge (a, p, D, pE))", "unfolding gselect_edge_impl_def gselect_edge_def"], ["proof (prove)\nusing this:\n  select_edge_impl (S', B', I', P')\n  \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel) (select_edge (p, D, pE))\n\ngoal (1 subgoal):\n 1. (let (a, s) = s'\n     in select_edge_impl s \\<bind> (\\<lambda>(vo, s). RETURN (vo, a, s)))\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r gGS_rel)\n           (let (a, s) = (a, p, D, pE)\n            in select_edge s \\<bind> (\\<lambda>(r, s). RETURN (r, a, s)))", "apply (simp add: refine_pw_simps pw_le_iff prod_rel_sv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (select_edge (p, D, pE)) \\<longrightarrow>\n    nofail (select_edge_impl (S', B', I', P')) \\<and>\n    (\\<forall>a aa ab ac b.\n        inres (select_edge_impl (S', B', I', P'))\n         (a, aa, ab, ac, b) \\<longrightarrow>\n        (\\<exists>ad ae ba.\n            ((aa, ab, ac, b), ad, ae, ba) \\<in> GS_rel \\<and>\n            inres (select_edge (p, D, pE))\n             (a, ad, ae, ba))) \\<Longrightarrow>\n    nofail (select_edge (p, D, pE)) \\<longrightarrow>\n    (\\<forall>aa ab ac ad b.\n        inres (select_edge_impl (S', B', I', P'))\n         (aa, ab, ac, ad, b) \\<longrightarrow>\n        (\\<exists>ae af ba.\n            ((a, ab, ac, ad, b), a, ae, af, ba) \\<in> gGS_rel \\<and>\n            inres (select_edge (p, D, pE)) (aa, ae, af, ba)))", "unfolding gGS_rel_def br_def gGS_\\<alpha>_def gGS_invar_def GS_rel_def GS.\\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (select_edge (p, D, pE)) \\<longrightarrow>\n    nofail (select_edge_impl (S', B', I', P')) \\<and>\n    (\\<forall>a aa ab ac b.\n        inres (select_edge_impl (S', B', I', P'))\n         (a, aa, ab, ac, b) \\<longrightarrow>\n        (\\<exists>ad ae ba.\n            ((aa, ab, ac, b), ad, ae, ba)\n            \\<in> {(c, a).\n                   a =\n                   (GS.p_\\<alpha> c, GS.D_\\<alpha> c,\n                    GS.pE_\\<alpha> c) \\<and>\n                   GS_invar c} \\<and>\n            inres (select_edge (p, D, pE))\n             (a, ad, ae, ba))) \\<Longrightarrow>\n    nofail (select_edge (p, D, pE)) \\<longrightarrow>\n    (\\<forall>aa ab ac ad b.\n        inres (select_edge_impl (S', B', I', P'))\n         (aa, ab, ac, ad, b) \\<longrightarrow>\n        (\\<exists>ae af ba.\n            ((a, ab, ac, ad, b), a, ae, af, ba)\n            \\<in> {(c, a).\n                   a =\n                   (let (a, s) = c\n                    in (a, GS.p_\\<alpha> s, GS.D_\\<alpha> s,\n                        GS.pE_\\<alpha> s)) \\<and>\n                   (let (a, S, B, I, P) = c\n                    in GS_invar (S, B, I, P) \\<and>\n                       length a = length B \\<and>\n                       \\<Union> (set a) \\<subseteq> {0..<num_acc})} \\<and>\n            inres (select_edge (p, D, pE)) (aa, ae, af, ba)))", "apply (simp split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail (select_edge (p, D, pE)) \\<longrightarrow>\n    nofail (select_edge_impl (S', B', I', P')) \\<and>\n    (\\<forall>a aa ab ac b.\n        inres (select_edge_impl (S', B', I', P'))\n         (a, aa, ab, ac, b) \\<longrightarrow>\n        GS_invar (aa, ab, ac, b) \\<and>\n        inres (select_edge (p, D, pE))\n         (a, GS.p_\\<alpha> (aa, ab, ac, b), GS.D_\\<alpha> (aa, ab, ac, b),\n          GS.pE_\\<alpha> (aa, ab, ac, b))) \\<Longrightarrow>\n    nofail (select_edge (p, D, pE)) \\<longrightarrow>\n    (\\<forall>aa ab ac.\n        (\\<exists>a b.\n            inres (select_edge_impl (S', B', I', P'))\n             (aa, ab, ac, a, b)) \\<longrightarrow>\n        length a = length ac \\<and>\n        \\<Union> (set a) \\<subseteq> {0..<num_acc})", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa aaa ab ac b.\n       \\<lbrakk>nofail (select_edge (p, D, pE));\n        inres (select_edge_impl (S', B', I', P')) (aa, aaa, ab, ac, b);\n        nofail (select_edge_impl (S', B', I', P'));\n        \\<forall>a aa ab ac b.\n           inres (select_edge_impl (S', B', I', P'))\n            (a, aa, ab, ac, b) \\<longrightarrow>\n           GS_invar (aa, ab, ac, b) \\<and>\n           inres (select_edge (p, D, pE))\n            (a, GS.p_\\<alpha> (aa, ab, ac, b),\n             GS.D_\\<alpha> (aa, ab, ac, b),\n             GS.pE_\\<alpha> (aa, ab, ac, b))\\<rbrakk>\n       \\<Longrightarrow> length a = length ab \\<and>\n                         \\<Union> (set a) \\<subseteq> {0..<num_acc}", "using R"], ["proof (prove)\nusing this:\n  \\<Union> (set a) \\<subseteq> {0..<num_acc}\n\ngoal (1 subgoal):\n 1. \\<And>aa aaa ab ac b.\n       \\<lbrakk>nofail (select_edge (p, D, pE));\n        inres (select_edge_impl (S', B', I', P')) (aa, aaa, ab, ac, b);\n        nofail (select_edge_impl (S', B', I', P'));\n        \\<forall>a aa ab ac b.\n           inres (select_edge_impl (S', B', I', P'))\n            (a, aa, ab, ac, b) \\<longrightarrow>\n           GS_invar (aa, ab, ac, b) \\<and>\n           inres (select_edge (p, D, pE))\n            (a, GS.p_\\<alpha> (aa, ab, ac, b),\n             GS.D_\\<alpha> (aa, ab, ac, b),\n             GS.pE_\\<alpha> (aa, ab, ac, b))\\<rbrakk>\n       \\<Longrightarrow> length a = length ab \\<and>\n                         \\<Union> (set a) \\<subseteq> {0..<num_acc}", "apply (auto simp: L dest: AUX1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  gselect_edge_impl s'\n  \\<le> \\<Down> (Id \\<times>\\<^sub>r gGS_rel) (gselect_edge (a, p, D, pE))\n\ngoal:\nNo subgoals!", "qed"], ["", "term GS.idx_of_impl"], ["", "thm GS_invar.idx_of_correct"], ["", "definition gcollapse_impl_aux :: \"'Q \\<Rightarrow> 'Q gGS \\<Rightarrow> 'Q gGS nres\" where \n    \"gcollapse_impl_aux v s \\<equiv> \n    do { \n      let (A,s)=s;\n      \\<^cancel>\\<open>ASSERT (v\\<in>\\<Union>set (GS.p_\\<alpha> s));\\<close>\n      i \\<leftarrow> GS.idx_of_impl s v;\n      s \\<leftarrow> collapse_impl v s;\n      ASSERT (i < length A);\n      us \\<leftarrow> Un_set_drop_impl i A;\n      let A = take i A @ [us];\n      RETURN (A,s)\n    }\""], ["", "term collapse"], ["", "lemma gcollapse_alt:\n    \"gcollapse v APDPE = ( \n      let \n        (a,p,D,pE)=APDPE; \n        i=idx_of p v;\n        s=collapse v (p,D,pE);\n        us=\\<Union>(set (drop i a));\n        a = take i a @ [us]\n      in (a,s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcollapse v APDPE =\n    (let (a, p, D, pE) = APDPE; i = idx_of p v; s = collapse v (p, D, pE);\n         us = \\<Union> (set (drop i a)); a = take i a @ [us]\n     in (a, s))", "unfolding gcollapse_def gcollapse_aux_def collapse_def collapse_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (a, p, D, pE) = APDPE; i = idx_of p v;\n         (a, p) =\n           (take i a @ [\\<Union> (set (drop i a))],\n            take i p @ [\\<Union> (set (drop i p))])\n     in (a, p, D, pE)) =\n    (let (a, p, D, pE) = APDPE; i = idx_of p v;\n         s = let (p, D, pE) = (p, D, pE); i = idx_of p v;\n                 p = take i p @ [\\<Union> (set (drop i p))]\n             in (p, D, pE);\n         us = \\<Union> (set (drop i a)); a = take i a @ [us]\n     in (a, s))", "by auto"], ["", "thm collapse_refine"], ["", "lemma gcollapse_impl_aux_refine:\n    assumes A: \"(s', a, p, D, pE) \\<in> gGS_rel\" \n    assumes B: \"(v',v)\\<in>Id\"\n    assumes PRE: \"v\\<in>\\<Union>(set p)\"\n    shows \"gcollapse_impl_aux v' s' \n      \\<le> \\<Down> gGS_rel (RETURN (gcollapse v (a, p, D, pE)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcollapse_impl_aux v' s'\n    \\<le> \\<Down> gGS_rel (RETURN (gcollapse v (a, p, D, pE)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gcollapse_impl_aux v' s'\n    \\<le> \\<Down> gGS_rel (RETURN (gcollapse v (a, p, D, pE)))", "note [simp] = Let_def"], ["proof (state)\nthis:\n  Let ?s ?f \\<equiv> ?f ?s\n\ngoal (1 subgoal):\n 1. gcollapse_impl_aux v' s'\n    \\<le> \\<Down> gGS_rel (RETURN (gcollapse v (a, p, D, pE)))", "from A"], ["proof (chain)\npicking this:\n  (s', a, p, D, pE) \\<in> gGS_rel", "obtain S' B' I' P' where [simp]: \"s'=(a,S',B',I',P')\" \n      and OSR: \"((S',B',I',P'),(p,D,pE))\\<in>GS_rel\" and L: \"length a = length B'\"\n      and R: \"\\<Union>(set a) \\<subseteq> {0..<num_acc}\""], ["proof (prove)\nusing this:\n  (s', a, p, D, pE) \\<in> gGS_rel\n\ngoal (1 subgoal):\n 1. (\\<And>S' B' I' P'.\n        \\<lbrakk>s' = (a, S', B', I', P');\n         ((S', B', I', P'), p, D, pE) \\<in> GS_rel; length a = length B';\n         \\<Union> (set a) \\<subseteq> {0..<num_acc}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule gGS_relE)"], ["proof (state)\nthis:\n  s' = (a, S', B', I', P')\n  ((S', B', I', P'), p, D, pE) \\<in> GS_rel\n  length a = length B'\n  \\<Union> (set a) \\<subseteq> {0..<num_acc}\n\ngoal (1 subgoal):\n 1. gcollapse_impl_aux v' s'\n    \\<le> \\<Down> gGS_rel (RETURN (gcollapse v (a, p, D, pE)))", "from B"], ["proof (chain)\npicking this:\n  (v', v) \\<in> Id", "have [simp]: \"v'=v\""], ["proof (prove)\nusing this:\n  (v', v) \\<in> Id\n\ngoal (1 subgoal):\n 1. v' = v", "by simp"], ["proof (state)\nthis:\n  v' = v\n\ngoal (1 subgoal):\n 1. gcollapse_impl_aux v' s'\n    \\<le> \\<Down> gGS_rel (RETURN (gcollapse v (a, p, D, pE)))", "from OSR"], ["proof (chain)\npicking this:\n  ((S', B', I', P'), p, D, pE) \\<in> GS_rel", "have [simp]: \"GS.p_\\<alpha> (S',B',I',P') = p\""], ["proof (prove)\nusing this:\n  ((S', B', I', P'), p, D, pE) \\<in> GS_rel\n\ngoal (1 subgoal):\n 1. GS.p_\\<alpha> (S', B', I', P') = p", "by (simp add: GS_rel_def br_def GS.\\<alpha>_def)"], ["proof (state)\nthis:\n  GS.p_\\<alpha> (S', B', I', P') = p\n\ngoal (1 subgoal):\n 1. gcollapse_impl_aux v' s'\n    \\<le> \\<Down> gGS_rel (RETURN (gcollapse v (a, p, D, pE)))", "from OSR PRE"], ["proof (chain)\npicking this:\n  ((S', B', I', P'), p, D, pE) \\<in> GS_rel\n  v \\<in> \\<Union> (set p)", "have PRE': \"v \\<in> \\<Union>(set (GS.p_\\<alpha> (S',B',I',P')))\""], ["proof (prove)\nusing this:\n  ((S', B', I', P'), p, D, pE) \\<in> GS_rel\n  v \\<in> \\<Union> (set p)\n\ngoal (1 subgoal):\n 1. v \\<in> \\<Union> (set (GS.p_\\<alpha> (S', B', I', P')))", "by (simp add: GS_rel_def br_def GS.\\<alpha>_def)"], ["proof (state)\nthis:\n  v \\<in> \\<Union> (set (GS.p_\\<alpha> (S', B', I', P')))\n\ngoal (1 subgoal):\n 1. gcollapse_impl_aux v' s'\n    \\<le> \\<Down> gGS_rel (RETURN (gcollapse v (a, p, D, pE)))", "from OSR"], ["proof (chain)\npicking this:\n  ((S', B', I', P'), p, D, pE) \\<in> GS_rel", "have GS_invar: \"GS_invar (S',B',I',P')\""], ["proof (prove)\nusing this:\n  ((S', B', I', P'), p, D, pE) \\<in> GS_rel\n\ngoal (1 subgoal):\n 1. GS_invar (S', B', I', P')", "by (simp add: GS_rel_def br_def)"], ["proof (state)\nthis:\n  GS_invar (S', B', I', P')\n\ngoal (1 subgoal):\n 1. gcollapse_impl_aux v' s'\n    \\<le> \\<Down> gGS_rel (RETURN (gcollapse v (a, p, D, pE)))", "term GS.B"], ["proof (state)\nthis:\n  GS_invar (S', B', I', P')\n\ngoal (1 subgoal):\n 1. gcollapse_impl_aux v' s'\n    \\<le> \\<Down> gGS_rel (RETURN (gcollapse v (a, p, D, pE)))", "{"], ["proof (state)\nthis:\n  GS_invar (S', B', I', P')\n\ngoal (1 subgoal):\n 1. gcollapse_impl_aux v' s'\n    \\<le> \\<Down> gGS_rel (RETURN (gcollapse v (a, p, D, pE)))", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. gcollapse_impl_aux v' s'\n    \\<le> \\<Down> gGS_rel (RETURN (gcollapse v (a, p, D, pE)))", "assume \"collapse v (p, D, pE) = (GS.p_\\<alpha> s, GS.D_\\<alpha> s, GS.pE_\\<alpha> s)\""], ["proof (state)\nthis:\n  collapse v (p, D, pE) =\n  (GS.p_\\<alpha> s, GS.D_\\<alpha> s, GS.pE_\\<alpha> s)\n\ngoal (1 subgoal):\n 1. gcollapse_impl_aux v' s'\n    \\<le> \\<Down> gGS_rel (RETURN (gcollapse v (a, p, D, pE)))", "hence \"length (GS.B s) = Suc (idx_of p v)\""], ["proof (prove)\nusing this:\n  collapse v (p, D, pE) =\n  (GS.p_\\<alpha> s, GS.D_\\<alpha> s, GS.pE_\\<alpha> s)\n\ngoal (1 subgoal):\n 1. length (GS.B s) = Suc (idx_of p v)", "unfolding collapse_def collapse_aux_def Let_def"], ["proof (prove)\nusing this:\n  (case (p, D, pE) of\n   (p, D, pE) \\<Rightarrow>\n     (take (idx_of p v) p @ [\\<Union> (set (drop (idx_of p v) p))], D,\n      pE)) =\n  (GS.p_\\<alpha> s, GS.D_\\<alpha> s, GS.pE_\\<alpha> s)\n\ngoal (1 subgoal):\n 1. length (GS.B s) = Suc (idx_of p v)", "apply (cases s)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>(case (p, D, pE) of\n                 (p, D, pE) \\<Rightarrow>\n                   (take (idx_of p v) p @\n                    [\\<Union> (set (drop (idx_of p v) p))],\n                    D, pE)) =\n                (GS.p_\\<alpha> s, GS.D_\\<alpha> s, GS.pE_\\<alpha> s);\n        s = (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> length (GS.B s) = Suc (idx_of p v)", "apply (auto simp: GS.p_\\<alpha>_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>s = (a, b, c, d);\n        take (idx_of p v) p @ [\\<Union> (set (drop (idx_of p v) p))] =\n        map (GS.seg (a, b, c, d)) [0..<length b];\n        D = GS.D_\\<alpha> (a, b, c, d);\n        pE = GS.pE_\\<alpha> (a, b, c, d)\\<rbrakk>\n       \\<Longrightarrow> length b = Suc (idx_of p v)", "apply (drule arg_cong[where f=length])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>s = (a, b, c, d); D = GS.D_\\<alpha> (a, b, c, d);\n        pE = GS.pE_\\<alpha> (a, b, c, d);\n        length\n         (take (idx_of p v) p @ [\\<Union> (set (drop (idx_of p v) p))]) =\n        length (map (GS.seg (a, b, c, d)) [0..<length b])\\<rbrakk>\n       \\<Longrightarrow> length b = Suc (idx_of p v)", "using GS_invar.p_\\<alpha>_disjoint_sym[OF GS_invar]\n          and PRE \\<open>GS.p_\\<alpha> (S', B', I', P') = p\\<close> idx_of_props(1)[of p v]"], ["proof (prove)\nusing this:\n  \\<forall>i j v.\n     i < length (GS.p_\\<alpha> (S', B', I', P')) \\<and>\n     j < length (GS.p_\\<alpha> (S', B', I', P')) \\<and>\n     v \\<in> GS.p_\\<alpha> (S', B', I', P') ! i \\<and>\n     v \\<in> GS.p_\\<alpha> (S', B', I', P') ! j \\<longrightarrow>\n     i = j\n  v \\<in> \\<Union> (set p)\n  GS.p_\\<alpha> (S', B', I', P') = p\n  \\<lbrakk>\\<forall>i j v.\n              i < length p \\<and>\n              j < length p \\<and>\n              v \\<in> p ! i \\<and> v \\<in> p ! j \\<longrightarrow>\n              i = j;\n   v \\<in> \\<Union> (set p)\\<rbrakk>\n  \\<Longrightarrow> idx_of p v < length p\n\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<lbrakk>s = (a, b, c, d); D = GS.D_\\<alpha> (a, b, c, d);\n        pE = GS.pE_\\<alpha> (a, b, c, d);\n        length\n         (take (idx_of p v) p @ [\\<Union> (set (drop (idx_of p v) p))]) =\n        length (map (GS.seg (a, b, c, d)) [0..<length b])\\<rbrakk>\n       \\<Longrightarrow> length b = Suc (idx_of p v)", "by simp"], ["proof (state)\nthis:\n  length (GS.B s) = Suc (idx_of p v)\n\ngoal (1 subgoal):\n 1. gcollapse_impl_aux v' s'\n    \\<le> \\<Down> gGS_rel (RETURN (gcollapse v (a, p, D, pE)))", "}"], ["proof (state)\nthis:\n  collapse v (p, D, pE) =\n  (GS.p_\\<alpha> ?s5, GS.D_\\<alpha> ?s5,\n   GS.pE_\\<alpha> ?s5) \\<Longrightarrow>\n  length (GS.B ?s5) = Suc (idx_of p v)\n\ngoal (1 subgoal):\n 1. gcollapse_impl_aux v' s'\n    \\<le> \\<Down> gGS_rel (RETURN (gcollapse v (a, p, D, pE)))", "note AUX1 = this"], ["proof (state)\nthis:\n  collapse v (p, D, pE) =\n  (GS.p_\\<alpha> ?s5, GS.D_\\<alpha> ?s5,\n   GS.pE_\\<alpha> ?s5) \\<Longrightarrow>\n  length (GS.B ?s5) = Suc (idx_of p v)\n\ngoal (1 subgoal):\n 1. gcollapse_impl_aux v' s'\n    \\<le> \\<Down> gGS_rel (RETURN (gcollapse v (a, p, D, pE)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcollapse_impl_aux v' s'\n    \\<le> \\<Down> gGS_rel (RETURN (gcollapse v (a, p, D, pE)))", "unfolding gcollapse_alt gcollapse_impl_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (A, s) = s'\n     in GS.idx_of_impl s v' \\<bind>\n        (\\<lambda>i.\n            collapse_impl v' s \\<bind>\n            (\\<lambda>s.\n                ASSERT (i < length A) \\<bind>\n                (\\<lambda>_.\n                    Un_set_drop_impl i A \\<bind>\n                    (\\<lambda>us.\n                        let A = take i A @ [us] in RETURN (A, s))))))\n    \\<le> \\<Down> gGS_rel\n           (RETURN\n             (let (a, p, D, pE) = (a, p, D, pE); i = idx_of p v;\n                  s = collapse v (p, D, pE); us = \\<Union> (set (drop i a));\n                  a = take i a @ [us]\n              in (a, s)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. GS.idx_of_impl (S', B', I', P') v \\<bind>\n    (\\<lambda>i.\n        collapse_impl v (S', B', I', P') \\<bind>\n        (\\<lambda>s.\n            ASSERT (i < length a) \\<bind>\n            (\\<lambda>_.\n                Un_set_drop_impl i a \\<bind>\n                (\\<lambda>us. RETURN (take i a @ [us], s)))))\n    \\<le> \\<Down> gGS_rel\n           (RETURN\n             (take (idx_of p v) a @ [\\<Union> (set (drop (idx_of p v) a))],\n              collapse v (p, D, pE)))", "apply (rule RETURN_as_SPEC_refine)"], ["proof (prove)\ngoal (1 subgoal):\n 1. GS.idx_of_impl (S', B', I', P') v \\<bind>\n    (\\<lambda>i.\n        collapse_impl v (S', B', I', P') \\<bind>\n        (\\<lambda>s.\n            ASSERT (i < length a) \\<bind>\n            (\\<lambda>_.\n                Un_set_drop_impl i a \\<bind>\n                (\\<lambda>us. RETURN (take i a @ [us], s)))))\n    \\<le> SPEC\n           (\\<lambda>c.\n               (c, take (idx_of p v) a @\n                   [\\<Union> (set (drop (idx_of p v) a))],\n                collapse v (p, D, pE))\n               \\<in> gGS_rel)", "apply (refine_rcg\n        order_trans[OF GS_invar.idx_of_correct[OF GS_invar PRE']] \n        order_trans[OF collapse_refine[OF OSR B PRE, simplified]]\n        refine_vcg\n      )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x = idx_of (GS.p_\\<alpha> (S', B', I', P')) v \\<and>\n       x < length (GS.B (S', B', I', P')) \\<Longrightarrow>\n       \\<Down> GS_rel (RETURN (collapse v (p, D, pE)))\n       \\<le> SPEC\n              (\\<lambda>s.\n                  ASSERT (x < length a) \\<bind>\n                  (\\<lambda>_.\n                      Un_set_drop_impl x a \\<bind>\n                      (\\<lambda>us. RETURN (take x a @ [us], s)))\n                  \\<le> SPEC\n                         (\\<lambda>c.\n                             (c, take (idx_of p v) a @\n                                 [\\<Union> (set (drop (idx_of p v) a))],\n                              collapse v (p, D, pE))\n                             \\<in> gGS_rel))", "using PRE'"], ["proof (prove)\nusing this:\n  v \\<in> \\<Union> (set (GS.p_\\<alpha> (S', B', I', P')))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x = idx_of (GS.p_\\<alpha> (S', B', I', P')) v \\<and>\n       x < length (GS.B (S', B', I', P')) \\<Longrightarrow>\n       \\<Down> GS_rel (RETURN (collapse v (p, D, pE)))\n       \\<le> SPEC\n              (\\<lambda>s.\n                  ASSERT (x < length a) \\<bind>\n                  (\\<lambda>_.\n                      Un_set_drop_impl x a \\<bind>\n                      (\\<lambda>us. RETURN (take x a @ [us], s)))\n                  \\<le> SPEC\n                         (\\<lambda>c.\n                             (c, take (idx_of p v) a @\n                                 [\\<Union> (set (drop (idx_of p v) a))],\n                              collapse v (p, D, pE))\n                             \\<in> gGS_rel))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>idx_of p v < length B';\n     \\<exists>x\\<in>set p. v \\<in> x\\<rbrakk>\n    \\<Longrightarrow> \\<Down> GS_rel (RETURN (collapse v (p, D, pE)))\n                      \\<le> SPEC\n                             (\\<lambda>s.\n                                 ASSERT (idx_of p v < length a) \\<bind>\n                                 (\\<lambda>_.\n                                     Un_set_drop_impl (idx_of p v) a \\<bind>\n                                     (\\<lambda>us.\n   RETURN (take (idx_of p v) a @ [us], s)))\n                                 \\<le> SPEC\n  (\\<lambda>c.\n      (c, take (idx_of p v) a @ [\\<Union> (set (drop (idx_of p v) a))],\n       collapse v (p, D, pE))\n      \\<in> gGS_rel))", "apply (simp add: L)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>idx_of p v < length B';\n     \\<exists>x\\<in>set p. v \\<in> x\\<rbrakk>\n    \\<Longrightarrow> \\<Down> GS_rel (RETURN (collapse v (p, D, pE)))\n                      \\<le> SPEC\n                             (\\<lambda>s.\n                                 Un_set_drop_impl (idx_of p v) a \\<bind>\n                                 (\\<lambda>us.\n                                     RETURN (take (idx_of p v) a @ [us], s))\n                                 \\<le> SPEC\n  (\\<lambda>c.\n      (c, take (idx_of p v) a @ [\\<Union> (set (drop (idx_of p v) a))],\n       collapse v (p, D, pE))\n      \\<in> gGS_rel))", "using Un_set_drop_impl_correct acc_bound R"], ["proof (prove)\nusing this:\n  Un_set_drop_impl ?i ?A\n  \\<le> SPEC (\\<lambda>r. r = \\<Union> (set (drop ?i ?A)))\n  \\<Union> (range acc) \\<subseteq> {0..<num_acc}\n  \\<Union> (set a) \\<subseteq> {0..<num_acc}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>idx_of p v < length B';\n     \\<exists>x\\<in>set p. v \\<in> x\\<rbrakk>\n    \\<Longrightarrow> \\<Down> GS_rel (RETURN (collapse v (p, D, pE)))\n                      \\<le> SPEC\n                             (\\<lambda>s.\n                                 Un_set_drop_impl (idx_of p v) a \\<bind>\n                                 (\\<lambda>us.\n                                     RETURN (take (idx_of p v) a @ [us], s))\n                                 \\<le> SPEC\n  (\\<lambda>c.\n      (c, take (idx_of p v) a @ [\\<Union> (set (drop (idx_of p v) a))],\n       collapse v (p, D, pE))\n      \\<in> gGS_rel))", "apply (simp add: refine_pw_simps pw_le_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>idx_of p v < length B'; \\<exists>x\\<in>set p. v \\<in> x;\n     \\<And>i A.\n        nofail (Un_set_drop_impl i A) \\<and>\n        (\\<forall>x.\n            inres (Un_set_drop_impl i A) x \\<longrightarrow>\n            x = \\<Union> (set (drop i A)));\n     \\<Union> (range acc) \\<subseteq> {0..<num_acc};\n     \\<Union> (set a) \\<subseteq> {0..<num_acc}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aa ab ac b.\n                         (\\<exists>a ad ba.\n                             ((aa, ab, ac, b), a, ad, ba)\n                             \\<in> GS_rel \\<and>\n                             collapse v (p, D, pE) =\n                             (a, ad, ba)) \\<longrightarrow>\n                         nofail (Un_set_drop_impl (idx_of p v) a) \\<and>\n                         (\\<forall>ad ae af ag ba.\n                             (nofail\n                               (Un_set_drop_impl (idx_of p v)\n                                 a) \\<longrightarrow>\n                              (\\<exists>y.\n                                  inres (Un_set_drop_impl (idx_of p v) a)\n                                   y \\<and>\n                                  take (idx_of p v) a @ [y] = ad \\<and>\n                                  aa = ae \\<and>\n                                  ab = af \\<and>\n                                  ac = ag \\<and> b = ba)) \\<longrightarrow>\n                             ((ad, ae, af, ag, ba),\n                              take (idx_of p v) a @\n                              [\\<Union> (set (drop (idx_of p v) a))],\n                              collapse v (p, D, pE))\n                             \\<in> gGS_rel)", "unfolding gGS_rel_def GS_rel_def GS.\\<alpha>_def br_def gGS_\\<alpha>_def gGS_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>idx_of p v < length B'; \\<exists>x\\<in>set p. v \\<in> x;\n     \\<And>i A.\n        nofail (Un_set_drop_impl i A) \\<and>\n        (\\<forall>x.\n            inres (Un_set_drop_impl i A) x \\<longrightarrow>\n            x = \\<Union> (set (drop i A)));\n     \\<Union> (range acc) \\<subseteq> {0..<num_acc};\n     \\<Union> (set a) \\<subseteq> {0..<num_acc}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aa ab ac b.\n                         (\\<exists>a ad ba.\n                             ((aa, ab, ac, b), a, ad, ba)\n                             \\<in> {(c, a).\n                                    a =\n                                    (GS.p_\\<alpha> c, GS.D_\\<alpha> c,\n                                     GS.pE_\\<alpha> c) \\<and>\n                                    GS_invar c} \\<and>\n                             collapse v (p, D, pE) =\n                             (a, ad, ba)) \\<longrightarrow>\n                         nofail (Un_set_drop_impl (idx_of p v) a) \\<and>\n                         (\\<forall>ad ae af ag ba.\n                             (nofail\n                               (Un_set_drop_impl (idx_of p v)\n                                 a) \\<longrightarrow>\n                              (\\<exists>y.\n                                  inres (Un_set_drop_impl (idx_of p v) a)\n                                   y \\<and>\n                                  take (idx_of p v) a @ [y] = ad \\<and>\n                                  aa = ae \\<and>\n                                  ab = af \\<and>\n                                  ac = ag \\<and> b = ba)) \\<longrightarrow>\n                             ((ad, ae, af, ag, ba),\n                              take (idx_of p v) a @\n                              [\\<Union> (set (drop (idx_of p v) a))],\n                              collapse v (p, D, pE))\n                             \\<in> {(c, a).\n                                    a =\n                                    (let (a, s) = c\n                                     in (a, GS.p_\\<alpha> s,\n   GS.D_\\<alpha> s, GS.pE_\\<alpha> s)) \\<and>\n                                    (let (a, S, B, I, P) = c\n                                     in GS_invar (S, B, I, P) \\<and>\n  length a = length B \\<and> \\<Union> (set a) \\<subseteq> {0..<num_acc})})", "apply (clarsimp simp: L dest!: AUX1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x aa aaa ab b.\n       \\<lbrakk>idx_of p v < length B';\n        \\<And>i A.\n           nofail (Un_set_drop_impl i A) \\<and>\n           (\\<forall>x.\n               inres (Un_set_drop_impl i A) x \\<longrightarrow>\n               x = \\<Union> (set (drop i A)));\n        \\<Union> (range acc) \\<subseteq> {0..<num_acc};\n        \\<Union> (set a) \\<subseteq> {0..<num_acc}; x \\<in> set p;\n        v \\<in> x; GS_invar (aa, aaa, ab, b);\n        length aaa = Suc (idx_of p v)\\<rbrakk>\n       \\<Longrightarrow> nofail (Un_set_drop_impl (idx_of p v) a) \\<and>\n                         (\\<forall>ac ad ae af ba.\n                             (nofail\n                               (Un_set_drop_impl (idx_of p v)\n                                 a) \\<longrightarrow>\n                              (\\<exists>y.\n                                  inres (Un_set_drop_impl (idx_of p v) a)\n                                   y \\<and>\n                                  take (idx_of p v) a @ [y] = ac \\<and>\n                                  aa = ad \\<and>\n                                  aaa = ae \\<and>\n                                  ab = af \\<and> b = ba)) \\<longrightarrow>\n                             take (idx_of p v) a @\n                             [\\<Union> (set (drop (idx_of p v) a))] =\n                             ac \\<and>\n                             GS.p_\\<alpha> (aa, aaa, ab, b) =\n                             GS.p_\\<alpha> (ad, ae, af, ba) \\<and>\n                             GS.D_\\<alpha> (aa, aaa, ab, b) =\n                             GS.D_\\<alpha> (ad, ae, af, ba) \\<and>\n                             GS.pE_\\<alpha> (aa, aaa, ab, b) =\n                             GS.pE_\\<alpha> (ad, ae, af, ba) \\<and>\n                             GS_invar (ad, ae, af, ba) \\<and>\n                             length ac = length ae \\<and>\n                             \\<Union> (set ac) \\<subseteq> {0..<num_acc})", "apply (auto dest!: AUX1 simp: L)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x ad ae af ba y xa.\n       \\<lbrakk>idx_of p v < length B';\n        \\<And>i A.\n           nofail (Un_set_drop_impl i A) \\<and>\n           (\\<forall>x.\n               inres (Un_set_drop_impl i A) x \\<longrightarrow>\n               x = \\<Union> (set (drop i A)));\n        \\<Union> (range acc) \\<subseteq> {0..<num_acc};\n        \\<Union> (set a) \\<subseteq> {0..<num_acc}; x \\<in> set p;\n        v \\<in> x; GS_invar (ad, ae, af, ba); length ae = Suc (idx_of p v);\n        inres (Un_set_drop_impl (idx_of p v) a) y; xa \\<in> y\\<rbrakk>\n       \\<Longrightarrow> xa < num_acc\n 2. \\<And>x ad ae af ba y xa X.\n       \\<lbrakk>idx_of p v < length B';\n        \\<And>i A.\n           nofail (Un_set_drop_impl i A) \\<and>\n           (\\<forall>x.\n               inres (Un_set_drop_impl i A) x \\<longrightarrow>\n               x = \\<Union> (set (drop i A)));\n        \\<Union> (range acc) \\<subseteq> {0..<num_acc};\n        \\<Union> (set a) \\<subseteq> {0..<num_acc}; x \\<in> set p;\n        v \\<in> x; GS_invar (ad, ae, af, ba); length ae = Suc (idx_of p v);\n        inres (Un_set_drop_impl (idx_of p v) a) y; xa \\<in> X;\n        X \\<in> set (take (idx_of p v) a)\\<rbrakk>\n       \\<Longrightarrow> xa < num_acc", "apply (force dest!: in_set_dropD) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x ad ae af ba y xa X.\n       \\<lbrakk>idx_of p v < length B';\n        \\<And>i A.\n           nofail (Un_set_drop_impl i A) \\<and>\n           (\\<forall>x.\n               inres (Un_set_drop_impl i A) x \\<longrightarrow>\n               x = \\<Union> (set (drop i A)));\n        \\<Union> (range acc) \\<subseteq> {0..<num_acc};\n        \\<Union> (set a) \\<subseteq> {0..<num_acc}; x \\<in> set p;\n        v \\<in> x; GS_invar (ad, ae, af, ba); length ae = Suc (idx_of p v);\n        inres (Un_set_drop_impl (idx_of p v) a) y; xa \\<in> X;\n        X \\<in> set (take (idx_of p v) a)\\<rbrakk>\n       \\<Longrightarrow> xa < num_acc", "apply (force dest!: in_set_takeD) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  gcollapse_impl_aux v' s'\n  \\<le> \\<Down> gGS_rel (RETURN (gcollapse v (a, p, D, pE)))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition gcollapse_impl :: \"'Q \\<Rightarrow> 'Q gGS \\<Rightarrow> 'Q gGS nres\" \n    where \"gcollapse_impl v s \\<equiv>     \n    do { \n      let (A,S,B,I,P)=s;\n      i \\<leftarrow> GS.idx_of_impl (S,B,I,P) v;\n      ASSERT (i+1 \\<le> length B);\n      let B = take (i+1) B;\n      ASSERT (i < length A);\n      us\\<leftarrow>Un_set_drop_impl i A;\n      let A = take i A @ [us];\n      RETURN (A,S,B,I,P)\n    }\""], ["", "lemma gcollapse_impl_aux_opt_refine: \n    \"gcollapse_impl v s \\<le> gcollapse_impl_aux v s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcollapse_impl v s \\<le> gcollapse_impl_aux v s", "unfolding gcollapse_impl_def gcollapse_impl_aux_def collapse_impl_def \n      GS.collapse_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (A, S, B, I, P) = s\n     in GS.idx_of_impl (S, B, I, P) v \\<bind>\n        (\\<lambda>i.\n            ASSERT (i + 1 \\<le> length B) \\<bind>\n            (\\<lambda>_.\n                let B = take (i + 1) B\n                in ASSERT (i < length A) \\<bind>\n                   (\\<lambda>_.\n                       Un_set_drop_impl i A \\<bind>\n                       (\\<lambda>us.\n                           let A = take i A @ [us]\n                           in RETURN (A, S, B, I, P))))))\n    \\<le> (let (A, s) = s\n           in GS.idx_of_impl s v \\<bind>\n              (\\<lambda>i.\n                  GS.idx_of_impl s v \\<bind>\n                  (\\<lambda>i.\n                      ASSERT (i + 1 \\<le> length (GS.B s)) \\<bind>\n                      (\\<lambda>_.\n                          let B = take (i + 1) (GS.B s)\n                          in RETURN (GS.S s, B, GS.I s, GS.P s))) \\<bind>\n                  (\\<lambda>s.\n                      ASSERT (i < length A) \\<bind>\n                      (\\<lambda>_.\n                          Un_set_drop_impl i A \\<bind>\n                          (\\<lambda>us.\n                              let A = take i A @ [us] in RETURN (A, s))))))", "apply (simp add: refine_pw_simps pw_le_iff split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x1 a aa ab b.\n       s = (x1, a, aa, ab, b) \\<longrightarrow>\n       nofail (GS.idx_of_impl (a, aa, ab, b) v) \\<and>\n       (\\<forall>x.\n           inres (GS.idx_of_impl (a, aa, ab, b) v) x \\<longrightarrow>\n           nofail (GS.idx_of_impl (a, aa, ab, b) v) \\<and>\n           (\\<forall>xa.\n               inres (GS.idx_of_impl (a, aa, ab, b) v) xa \\<longrightarrow>\n               Suc xa \\<le> length aa \\<and>\n               x < length x1 \\<and>\n               nofail (Un_set_drop_impl x x1))) \\<longrightarrow>\n       (\\<forall>ac ad ae af ba.\n           (\\<exists>y.\n               inres (GS.idx_of_impl (a, aa, ab, b) v) y \\<and>\n               (Suc y \\<le> length aa \\<longrightarrow>\n                y < length x1 \\<longrightarrow>\n                nofail (Un_set_drop_impl y x1) \\<longrightarrow>\n                (\\<exists>ya.\n                    inres (Un_set_drop_impl y x1) ya \\<and>\n                    take y x1 @ [ya] = ac \\<and>\n                    a = ad \\<and>\n                    take (Suc y) aa = ae \\<and>\n                    ab = af \\<and> b = ba))) \\<longrightarrow>\n           (\\<exists>y.\n               inres (GS.idx_of_impl (a, aa, ab, b) v) y \\<and>\n               (\\<exists>ya.\n                   inres (GS.idx_of_impl (a, aa, ab, b) v) ya \\<and>\n                   (Suc ya \\<le> length aa \\<longrightarrow>\n                    y < length x1 \\<longrightarrow>\n                    nofail (Un_set_drop_impl y x1) \\<longrightarrow>\n                    (\\<exists>yb.\n                        inres (Un_set_drop_impl y x1) yb \\<and>\n                        take y x1 @ [yb] = ac \\<and>\n                        a = ad \\<and>\n                        take (Suc ya) aa = ae \\<and>\n                        ab = af \\<and> b = ba)))))", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gcollapse_impl_refine:\n    assumes A: \"(s', a, p, D, pE) \\<in> gGS_rel\" \n    assumes B: \"(v',v)\\<in>Id\"\n    assumes PRE: \"v\\<in>\\<Union>(set p)\"\n    shows \"gcollapse_impl v' s' \n    \\<le> \\<Down> gGS_rel (RETURN (gcollapse v (a, p, D, pE)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcollapse_impl v' s'\n    \\<le> \\<Down> gGS_rel (RETURN (gcollapse v (a, p, D, pE)))", "using order_trans[OF \n      gcollapse_impl_aux_opt_refine \n      gcollapse_impl_aux_refine[OF assms]]"], ["proof (prove)\nusing this:\n  gcollapse_impl v' s'\n  \\<le> \\<Down> gGS_rel (RETURN (gcollapse v (a, p, D, pE)))\n\ngoal (1 subgoal):\n 1. gcollapse_impl v' s'\n    \\<le> \\<Down> gGS_rel (RETURN (gcollapse v (a, p, D, pE)))", "."], ["", "definition ginitial_impl :: \"'Q \\<Rightarrow> 'Q goGS \\<Rightarrow> 'Q gGS\" \n    where \"ginitial_impl v0 s0 \\<equiv> ([acc v0],initial_impl v0 (snd s0))\""], ["", "lemma ginitial_impl_refine: \n    assumes A: \"v0\\<notin>goD s0\" \"go_is_no_brk s0\"\n    assumes REL: \"(s0i,s0)\\<in>goGS_rel\" \"(v0i,v0)\\<in>Id\" \n    shows \"(ginitial_impl v0i s0i,ginitial v0 s0)\\<in>gGS_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ginitial_impl v0i s0i, ginitial v0 s0) \\<in> gGS_rel", "unfolding ginitial_impl_def ginitial_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (([acc v0i], initial_impl v0i (snd s0i)), [acc v0], initial v0 (snd s0))\n    \\<in> gGS_rel", "using REL initial_refine[OF A(1) _ REL(2), of \"snd s0i\"] A(2)"], ["proof (prove)\nusing this:\n  (s0i, s0) \\<in> goGS_rel\n  (v0i, v0) \\<in> Id\n  (snd s0i, goD s0) \\<in> oGS_rel \\<Longrightarrow>\n  (initial_impl v0i (snd s0i), initial v0 (goD s0)) \\<in> GS_rel\n  go_is_no_brk s0\n\ngoal (1 subgoal):\n 1. (([acc v0i], initial_impl v0i (snd s0i)), [acc v0], initial v0 (snd s0))\n    \\<in> gGS_rel", "apply (auto \n      simp: gGS_rel_def br_def gGS_\\<alpha>_def gGS_invar_def goGS_rel_def goGS_\\<alpha>_def\n      simp: go_is_no_brk_def goD_def oGS_rel_def GS_rel_def goGS_invar_def\n      split: prod.splits\n\n    )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 x1a a aa b.\n       \\<lbrakk>v0i = v0; s0i = (None, x2);\n        initial v0 (oGS_\\<alpha> x2) = GS.\\<alpha> (x1a, a, aa, b);\n        GS_invar (x1a, a, aa, b); s0 = (None, oGS_\\<alpha> x2);\n        oGS_invar x2; initial_impl v0 x2 = (x1a, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> Suc 0 = length a", "using acc_bound"], ["proof (prove)\nusing this:\n  \\<Union> (range acc) \\<subseteq> {0..<num_acc}\n\ngoal (1 subgoal):\n 1. \\<And>x2 x1a a aa b.\n       \\<lbrakk>v0i = v0; s0i = (None, x2);\n        initial v0 (oGS_\\<alpha> x2) = GS.\\<alpha> (x1a, a, aa, b);\n        GS_invar (x1a, a, aa, b); s0 = (None, oGS_\\<alpha> x2);\n        oGS_invar x2; initial_impl v0 x2 = (x1a, a, aa, b)\\<rbrakk>\n       \\<Longrightarrow> Suc 0 = length a", "apply (fastforce simp: initial_impl_def GS_initial_impl_def)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition gpath_is_empty_impl :: \"'Q gGS \\<Rightarrow> bool\"\n    where \"gpath_is_empty_impl s = path_is_empty_impl (snd s)\""], ["", "lemma gpath_is_empty_refine: \n    \"(s,(a,p,D,pE))\\<in>gGS_rel \\<Longrightarrow> gpath_is_empty_impl s \\<longleftrightarrow> p=[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, a, p, D, pE) \\<in> gGS_rel \\<Longrightarrow>\n    gpath_is_empty_impl s = (p = [])", "unfolding gpath_is_empty_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, a, p, D, pE) \\<in> gGS_rel \\<Longrightarrow>\n    path_is_empty_impl (snd s) = (p = [])", "using path_is_empty_refine"], ["proof (prove)\nusing this:\n  GS_invar ?s \\<Longrightarrow>\n  path_is_empty_impl ?s = (GS.p_\\<alpha> ?s = [])\n\ngoal (1 subgoal):\n 1. (s, a, p, D, pE) \\<in> gGS_rel \\<Longrightarrow>\n    path_is_empty_impl (snd s) = (p = [])", "by (fastforce simp: gGS_rel_def br_def gGS_invar_def gGS_\\<alpha>_def GS.\\<alpha>_def)"], ["", "definition gis_on_stack_impl :: \"'Q \\<Rightarrow> 'Q gGS \\<Rightarrow> bool\" \n    where \"gis_on_stack_impl v s = is_on_stack_impl v (snd s)\""], ["", "lemma gis_on_stack_refine: \n    \"\\<lbrakk>(s,(a,p,D,pE))\\<in>gGS_rel\\<rbrakk> \\<Longrightarrow> gis_on_stack_impl v s \\<longleftrightarrow> v\\<in>\\<Union>(set p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, a, p, D, pE) \\<in> gGS_rel \\<Longrightarrow>\n    gis_on_stack_impl v s = (v \\<in> \\<Union> (set p))", "unfolding gis_on_stack_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, a, p, D, pE) \\<in> gGS_rel \\<Longrightarrow>\n    is_on_stack_impl v (snd s) = (v \\<in> \\<Union> (set p))", "using is_on_stack_refine"], ["proof (prove)\nusing this:\n  GS_invar ?s \\<Longrightarrow>\n  is_on_stack_impl ?v ?s = (?v \\<in> \\<Union> (set (GS.p_\\<alpha> ?s)))\n\ngoal (1 subgoal):\n 1. (s, a, p, D, pE) \\<in> gGS_rel \\<Longrightarrow>\n    is_on_stack_impl v (snd s) = (v \\<in> \\<Union> (set p))", "by (fastforce simp: gGS_rel_def br_def gGS_invar_def gGS_\\<alpha>_def GS.\\<alpha>_def)"], ["", "definition gis_done_impl :: \"'Q \\<Rightarrow> 'Q gGS \\<Rightarrow> bool\"\n    where \"gis_done_impl v s \\<equiv> is_done_impl v (snd s)\""], ["", "thm is_done_refine"], ["", "lemma gis_done_refine: \"(s,(a,p,D,pE))\\<in>gGS_rel \n    \\<Longrightarrow> gis_done_impl v s \\<longleftrightarrow> (v \\<in> D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, a, p, D, pE) \\<in> gGS_rel \\<Longrightarrow>\n    gis_done_impl v s = (v \\<in> D)", "using is_done_refine[of \"(snd s)\" v]"], ["proof (prove)\nusing this:\n  GS_invar (snd s) \\<Longrightarrow>\n  is_done_impl v (snd s) = (v \\<in> GS.D_\\<alpha> (snd s))\n\ngoal (1 subgoal):\n 1. (s, a, p, D, pE) \\<in> gGS_rel \\<Longrightarrow>\n    gis_done_impl v s = (v \\<in> D)", "by (auto \n      simp: gGS_rel_def br_def gGS_\\<alpha>_def gGS_invar_def GS.\\<alpha>_def \n            gis_done_impl_def)"], ["", "definition (in -) \"on_stack_less I u v \\<equiv> \n    case I v of \n      Some (STACK j) \\<Rightarrow> j<u\n    | _ \\<Rightarrow> False\""], ["", "definition (in -) \"on_stack_ge I l v \\<equiv> \n    case I v of \n      Some (STACK j) \\<Rightarrow> l\\<le>j\n    | _ \\<Rightarrow> False\""], ["", "lemma (in GS_invar) set_butlast_p_refine:\n    assumes PRE: \"p_\\<alpha>\\<noteq>[]\"\n    shows \"Collect (on_stack_less I (last B)) = \\<Union>(set (butlast p_\\<alpha>))\" (is \"?L=?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect (on_stack_less I (last B)) = \\<Union> (set (butlast p_\\<alpha>))", "proof (intro equalityI subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Collect (on_stack_less I (last B)) \\<Longrightarrow>\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>))\n 2. \\<And>x.\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>)) \\<Longrightarrow>\n       x \\<in> Collect (on_stack_less I (last B))", "from PRE"], ["proof (chain)\npicking this:\n  p_\\<alpha> \\<noteq> []", "have [simp]: \"B\\<noteq>[]\""], ["proof (prove)\nusing this:\n  p_\\<alpha> \\<noteq> []\n\ngoal (1 subgoal):\n 1. B \\<noteq> []", "by (auto simp: p_\\<alpha>_def)"], ["proof (state)\nthis:\n  B \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Collect (on_stack_less I (last B)) \\<Longrightarrow>\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>))\n 2. \\<And>x.\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>)) \\<Longrightarrow>\n       x \\<in> Collect (on_stack_less I (last B))", "have [simp]: \"S\\<noteq>[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<noteq> []", "by (simp add: empty_eq)"], ["proof (state)\nthis:\n  S \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Collect (on_stack_less I (last B)) \\<Longrightarrow>\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>))\n 2. \\<And>x.\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>)) \\<Longrightarrow>\n       x \\<in> Collect (on_stack_less I (last B))", "{"], ["proof (state)\nthis:\n  S \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Collect (on_stack_less I (last B)) \\<Longrightarrow>\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>))\n 2. \\<And>x.\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>)) \\<Longrightarrow>\n       x \\<in> Collect (on_stack_less I (last B))", "fix v"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Collect (on_stack_less I (last B)) \\<Longrightarrow>\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>))\n 2. \\<And>x.\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>)) \\<Longrightarrow>\n       x \\<in> Collect (on_stack_less I (last B))", "assume \"v\\<in>?L\""], ["proof (state)\nthis:\n  v \\<in> Collect (on_stack_less I (last B))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Collect (on_stack_less I (last B)) \\<Longrightarrow>\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>))\n 2. \\<And>x.\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>)) \\<Longrightarrow>\n       x \\<in> Collect (on_stack_less I (last B))", "then"], ["proof (chain)\npicking this:\n  v \\<in> Collect (on_stack_less I (last B))", "obtain j where [simp]: \"I v = Some (STACK j)\" and \"j<last B\""], ["proof (prove)\nusing this:\n  v \\<in> Collect (on_stack_less I (last B))\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>I v = Some (STACK j); j < last B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: on_stack_less_def split: option.splits node_state.splits)"], ["proof (state)\nthis:\n  I v = Some (STACK j)\n  j < last B\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Collect (on_stack_less I (last B)) \\<Longrightarrow>\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>))\n 2. \\<And>x.\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>)) \\<Longrightarrow>\n       x \\<in> Collect (on_stack_less I (last B))", "from I_consistent[of v j]"], ["proof (chain)\npicking this:\n  (I v = Some (STACK j)) = (j < length S \\<and> v = S ! j)", "have [simp]: \"j<length S\" \"v=S!j\""], ["proof (prove)\nusing this:\n  (I v = Some (STACK j)) = (j < length S \\<and> v = S ! j)\n\ngoal (1 subgoal):\n 1. j < length S &&& v = S ! j", "by auto"], ["proof (state)\nthis:\n  j < length S\n  v = S ! j\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Collect (on_stack_less I (last B)) \\<Longrightarrow>\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>))\n 2. \\<And>x.\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>)) \\<Longrightarrow>\n       x \\<in> Collect (on_stack_less I (last B))", "from B0"], ["proof (chain)\npicking this:\n  S \\<noteq> [] \\<Longrightarrow> B \\<noteq> [] \\<and> B ! 0 = 0", "have \"B!0=0\""], ["proof (prove)\nusing this:\n  S \\<noteq> [] \\<Longrightarrow> B \\<noteq> [] \\<and> B ! 0 = 0\n\ngoal (1 subgoal):\n 1. B ! 0 = 0", "by simp"], ["proof (state)\nthis:\n  B ! 0 = 0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Collect (on_stack_less I (last B)) \\<Longrightarrow>\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>))\n 2. \\<And>x.\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>)) \\<Longrightarrow>\n       x \\<in> Collect (on_stack_less I (last B))", "from \\<open>j<last B\\<close>"], ["proof (chain)\npicking this:\n  j < last B", "have \"j<B!(length B - 1)\""], ["proof (prove)\nusing this:\n  j < last B\n\ngoal (1 subgoal):\n 1. j < B ! (length B - 1)", "by (simp add: last_conv_nth)"], ["proof (state)\nthis:\n  j < B ! (length B - 1)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Collect (on_stack_less I (last B)) \\<Longrightarrow>\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>))\n 2. \\<And>x.\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>)) \\<Longrightarrow>\n       x \\<in> Collect (on_stack_less I (last B))", "from find_seg_bounds[OF \\<open>j<length S\\<close>] find_seg_correct[OF \\<open>j<length S\\<close>]"], ["proof (chain)\npicking this:\n  seg_start (find_seg j) \\<le> j\n  j < seg_end (find_seg j)\n  find_seg j < length B\n  S ! j \\<in> seg (find_seg j)\n  find_seg j < length B", "have \"v\\<in>seg (find_seg j)\" \"find_seg j < length B\""], ["proof (prove)\nusing this:\n  seg_start (find_seg j) \\<le> j\n  j < seg_end (find_seg j)\n  find_seg j < length B\n  S ! j \\<in> seg (find_seg j)\n  find_seg j < length B\n\ngoal (1 subgoal):\n 1. v \\<in> seg (find_seg j) &&& find_seg j < length B", "by auto"], ["proof (state)\nthis:\n  v \\<in> seg (find_seg j)\n  find_seg j < length B\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Collect (on_stack_less I (last B)) \\<Longrightarrow>\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>))\n 2. \\<And>x.\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>)) \\<Longrightarrow>\n       x \\<in> Collect (on_stack_less I (last B))", "moreover"], ["proof (state)\nthis:\n  v \\<in> seg (find_seg j)\n  find_seg j < length B\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Collect (on_stack_less I (last B)) \\<Longrightarrow>\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>))\n 2. \\<And>x.\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>)) \\<Longrightarrow>\n       x \\<in> Collect (on_stack_less I (last B))", "with \\<open>j<B!(length B - 1)\\<close>"], ["proof (chain)\npicking this:\n  j < B ! (length B - 1)\n  v \\<in> seg (find_seg j)\n  find_seg j < length B", "have \"find_seg j < length B - 1\""], ["proof (prove)\nusing this:\n  j < B ! (length B - 1)\n  v \\<in> seg (find_seg j)\n  find_seg j < length B\n\ngoal (1 subgoal):\n 1. find_seg j < length B - 1", "(* What follows is an unreadable, auto-generated structured proof\n          that replaces the following smt-call:\n        by (smt GS.seg_start_def `seg_start (find_seg j) \\<le> j`)*)"], ["proof (prove)\nusing this:\n  j < B ! (length B - 1)\n  v \\<in> seg (find_seg j)\n  find_seg j < length B\n\ngoal (1 subgoal):\n 1. find_seg j < length B - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>j < B ! (length B - 1); v \\<in> seg (find_seg j);\n     find_seg j < length B\\<rbrakk>\n    \\<Longrightarrow> find_seg j < length B - 1", "have f1: \"\\<And>x\\<^sub>1 x. \\<not> (x\\<^sub>1::nat) < x\\<^sub>1 - x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>1 x. \\<not> x\\<^sub>1 < x\\<^sub>1 - x", "using less_imp_diff_less"], ["proof (prove)\nusing this:\n  ?j < ?k \\<Longrightarrow> ?j - ?n < ?k\n\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>1 x. \\<not> x\\<^sub>1 < x\\<^sub>1 - x", "by blast"], ["proof (state)\nthis:\n  \\<not> ?x\\<^sub>1 < ?x\\<^sub>1 - ?x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < B ! (length B - 1); v \\<in> seg (find_seg j);\n     find_seg j < length B\\<rbrakk>\n    \\<Longrightarrow> find_seg j < length B - 1", "have \"j \\<le> last B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<le> last B", "by (metis \\<open>j < last B\\<close> less_le)"], ["proof (state)\nthis:\n  j \\<le> last B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < B ! (length B - 1); v \\<in> seg (find_seg j);\n     find_seg j < length B\\<rbrakk>\n    \\<Longrightarrow> find_seg j < length B - 1", "hence f2: \"\\<And>x\\<^sub>1. \\<not> last B < x\\<^sub>1 \\<or> \\<not> x\\<^sub>1 \\<le> j\""], ["proof (prove)\nusing this:\n  j \\<le> last B\n\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>1.\n       \\<not> last B < x\\<^sub>1 \\<or> \\<not> x\\<^sub>1 \\<le> j", "using f1"], ["proof (prove)\nusing this:\n  j \\<le> last B\n  \\<not> ?x\\<^sub>1 < ?x\\<^sub>1 - ?x\n\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>1.\n       \\<not> last B < x\\<^sub>1 \\<or> \\<not> x\\<^sub>1 \\<le> j", "by (metis diff_diff_cancel le_trans)"], ["proof (state)\nthis:\n  \\<not> last B < ?x\\<^sub>1 \\<or> \\<not> ?x\\<^sub>1 \\<le> j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < B ! (length B - 1); v \\<in> seg (find_seg j);\n     find_seg j < length B\\<rbrakk>\n    \\<Longrightarrow> find_seg j < length B - 1", "have \"\\<And>x\\<^sub>1. seg_end x\\<^sub>1 \\<le> j \\<or> \\<not> x\\<^sub>1 < find_seg j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>1.\n       seg_end x\\<^sub>1 \\<le> j \\<or> \\<not> x\\<^sub>1 < find_seg j", "by (metis \\<open>seg_start (find_seg j) \\<le> j\\<close> calculation(2) \n            le_trans seg_end_less_start)"], ["proof (state)\nthis:\n  seg_end ?x\\<^sub>1 \\<le> j \\<or> \\<not> ?x\\<^sub>1 < find_seg j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < B ! (length B - 1); v \\<in> seg (find_seg j);\n     find_seg j < length B\\<rbrakk>\n    \\<Longrightarrow> find_seg j < length B - 1", "thus \"find_seg j < length B - 1\""], ["proof (prove)\nusing this:\n  seg_end ?x\\<^sub>1 \\<le> j \\<or> \\<not> ?x\\<^sub>1 < find_seg j\n\ngoal (1 subgoal):\n 1. find_seg j < length B - 1", "using f1 f2"], ["proof (prove)\nusing this:\n  seg_end ?x\\<^sub>1 \\<le> j \\<or> \\<not> ?x\\<^sub>1 < find_seg j\n  \\<not> ?x\\<^sub>1 < ?x\\<^sub>1 - ?x\n  \\<not> last B < ?x\\<^sub>1 \\<or> \\<not> ?x\\<^sub>1 \\<le> j\n\ngoal (1 subgoal):\n 1. find_seg j < length B - 1", "by (metis GS.seg_start_def \\<open>B \\<noteq> []\\<close> \\<open>j < B ! (length B - 1)\\<close>\n            \\<open>seg_start (find_seg j) \\<le> j\\<close> calculation(2) diff_diff_cancel \n            last_conv_nth nat_neq_iff seg_start_less_end)"], ["proof (state)\nthis:\n  find_seg j < length B - 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  find_seg j < length B - 1\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Collect (on_stack_less I (last B)) \\<Longrightarrow>\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>))\n 2. \\<And>x.\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>)) \\<Longrightarrow>\n       x \\<in> Collect (on_stack_less I (last B))", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> seg (find_seg j)\n  find_seg j < length B\n  find_seg j < length B - 1", "show \"v\\<in>?R\""], ["proof (prove)\nusing this:\n  v \\<in> seg (find_seg j)\n  find_seg j < length B\n  find_seg j < length B - 1\n\ngoal (1 subgoal):\n 1. v \\<in> \\<Union> (set (butlast p_\\<alpha>))", "by (auto simp: p_\\<alpha>_def map_butlast[symmetric] butlast_upt)"], ["proof (state)\nthis:\n  v \\<in> \\<Union> (set (butlast p_\\<alpha>))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>)) \\<Longrightarrow>\n       x \\<in> Collect (on_stack_less I (last B))", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> Collect (on_stack_less I (last B)) \\<Longrightarrow>\n  ?v2 \\<in> \\<Union> (set (butlast p_\\<alpha>))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>)) \\<Longrightarrow>\n       x \\<in> Collect (on_stack_less I (last B))", "{"], ["proof (state)\nthis:\n  ?v2 \\<in> Collect (on_stack_less I (last B)) \\<Longrightarrow>\n  ?v2 \\<in> \\<Union> (set (butlast p_\\<alpha>))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>)) \\<Longrightarrow>\n       x \\<in> Collect (on_stack_less I (last B))", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>)) \\<Longrightarrow>\n       x \\<in> Collect (on_stack_less I (last B))", "assume \"v\\<in>?R\""], ["proof (state)\nthis:\n  v \\<in> \\<Union> (set (butlast p_\\<alpha>))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>)) \\<Longrightarrow>\n       x \\<in> Collect (on_stack_less I (last B))", "then"], ["proof (chain)\npicking this:\n  v \\<in> \\<Union> (set (butlast p_\\<alpha>))", "obtain i where \"i<length B - 1\" and \"v\\<in>seg i\""], ["proof (prove)\nusing this:\n  v \\<in> \\<Union> (set (butlast p_\\<alpha>))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length B - 1; v \\<in> seg i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: p_\\<alpha>_def map_butlast[symmetric] butlast_upt)"], ["proof (state)\nthis:\n  i < length B - 1\n  v \\<in> seg i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>)) \\<Longrightarrow>\n       x \\<in> Collect (on_stack_less I (last B))", "then"], ["proof (chain)\npicking this:\n  i < length B - 1\n  v \\<in> seg i", "obtain j where \"j < seg_end i\" and \"v=S!j\""], ["proof (prove)\nusing this:\n  i < length B - 1\n  v \\<in> seg i\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j < seg_end i; v = S ! j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: seg_def)"], ["proof (state)\nthis:\n  j < seg_end i\n  v = S ! j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>)) \\<Longrightarrow>\n       x \\<in> Collect (on_stack_less I (last B))", "hence \"j<B!(i+1)\" and \"i+1 \\<le> length B - 1\""], ["proof (prove)\nusing this:\n  j < seg_end i\n  v = S ! j\n\ngoal (1 subgoal):\n 1. j < B ! (i + 1) &&& i + 1 \\<le> length B - 1", "using \\<open>i<length B - 1\\<close>"], ["proof (prove)\nusing this:\n  j < seg_end i\n  v = S ! j\n  i < length B - 1\n\ngoal (1 subgoal):\n 1. j < B ! (i + 1) &&& i + 1 \\<le> length B - 1", "by (auto simp: seg_end_def last_conv_nth split: if_split_asm)"], ["proof (state)\nthis:\n  j < B ! (i + 1)\n  i + 1 \\<le> length B - 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>)) \\<Longrightarrow>\n       x \\<in> Collect (on_stack_less I (last B))", "with sorted_nth_mono[OF B_sorted \\<open>i+1 \\<le> length B - 1\\<close>]"], ["proof (chain)\npicking this:\n  length B - 1 < length B \\<Longrightarrow>\n  B ! (i + 1) \\<le> B ! (length B - 1)\n  j < B ! (i + 1)\n  i + 1 \\<le> length B - 1", "have \"j<last B\""], ["proof (prove)\nusing this:\n  length B - 1 < length B \\<Longrightarrow>\n  B ! (i + 1) \\<le> B ! (length B - 1)\n  j < B ! (i + 1)\n  i + 1 \\<le> length B - 1\n\ngoal (1 subgoal):\n 1. j < last B", "by (auto simp: last_conv_nth)"], ["proof (state)\nthis:\n  j < last B\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>)) \\<Longrightarrow>\n       x \\<in> Collect (on_stack_less I (last B))", "moreover"], ["proof (state)\nthis:\n  j < last B\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>)) \\<Longrightarrow>\n       x \\<in> Collect (on_stack_less I (last B))", "from \\<open>j < seg_end i\\<close>"], ["proof (chain)\npicking this:\n  j < seg_end i", "have \"j<length S\""], ["proof (prove)\nusing this:\n  j < seg_end i\n\ngoal (1 subgoal):\n 1. j < length S", "by (metis GS.seg_end_def add_diff_inverse_nat \\<open>i + 1 \\<le> length B - 1\\<close>\n          add_lessD1 less_imp_diff_less less_le_not_le nat_neq_iff \n          seg_end_bound)"], ["proof (state)\nthis:\n  j < length S\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>)) \\<Longrightarrow>\n       x \\<in> Collect (on_stack_less I (last B))", "(*by (smt `i < length B - 1` seg_end_bound)*)"], ["proof (state)\nthis:\n  j < length S\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>)) \\<Longrightarrow>\n       x \\<in> Collect (on_stack_less I (last B))", "with I_consistent \\<open>v=S!j\\<close>"], ["proof (chain)\npicking this:\n  (I ?v = Some (STACK ?j)) = (?j < length S \\<and> ?v = S ! ?j)\n  v = S ! j\n  j < length S", "have \"I v = Some (STACK j)\""], ["proof (prove)\nusing this:\n  (I ?v = Some (STACK ?j)) = (?j < length S \\<and> ?v = S ! ?j)\n  v = S ! j\n  j < length S\n\ngoal (1 subgoal):\n 1. I v = Some (STACK j)", "by auto"], ["proof (state)\nthis:\n  I v = Some (STACK j)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set (butlast p_\\<alpha>)) \\<Longrightarrow>\n       x \\<in> Collect (on_stack_less I (last B))", "ultimately"], ["proof (chain)\npicking this:\n  j < last B\n  I v = Some (STACK j)", "show \"v\\<in>?L\""], ["proof (prove)\nusing this:\n  j < last B\n  I v = Some (STACK j)\n\ngoal (1 subgoal):\n 1. v \\<in> Collect (on_stack_less I (last B))", "by (auto simp: on_stack_less_def)"], ["proof (state)\nthis:\n  v \\<in> Collect (on_stack_less I (last B))\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> \\<Union> (set (butlast p_\\<alpha>)) \\<Longrightarrow>\n  ?v2 \\<in> Collect (on_stack_less I (last B))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in GS_invar) set_last_p_refine:\n    assumes PRE: \"p_\\<alpha>\\<noteq>[]\"\n    shows \"Collect (on_stack_ge I (last B)) = last p_\\<alpha>\" (is \"?L=?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect (on_stack_ge I (last B)) = last p_\\<alpha>", "proof (intro equalityI subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Collect (on_stack_ge I (last B)) \\<Longrightarrow>\n       x \\<in> last p_\\<alpha>\n 2. \\<And>x.\n       x \\<in> last p_\\<alpha> \\<Longrightarrow>\n       x \\<in> Collect (on_stack_ge I (last B))", "from PRE"], ["proof (chain)\npicking this:\n  p_\\<alpha> \\<noteq> []", "have [simp]: \"B\\<noteq>[]\""], ["proof (prove)\nusing this:\n  p_\\<alpha> \\<noteq> []\n\ngoal (1 subgoal):\n 1. B \\<noteq> []", "by (auto simp: p_\\<alpha>_def)"], ["proof (state)\nthis:\n  B \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Collect (on_stack_ge I (last B)) \\<Longrightarrow>\n       x \\<in> last p_\\<alpha>\n 2. \\<And>x.\n       x \\<in> last p_\\<alpha> \\<Longrightarrow>\n       x \\<in> Collect (on_stack_ge I (last B))", "have [simp]: \"S\\<noteq>[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<noteq> []", "by (simp add: empty_eq)"], ["proof (state)\nthis:\n  S \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Collect (on_stack_ge I (last B)) \\<Longrightarrow>\n       x \\<in> last p_\\<alpha>\n 2. \\<And>x.\n       x \\<in> last p_\\<alpha> \\<Longrightarrow>\n       x \\<in> Collect (on_stack_ge I (last B))", "{"], ["proof (state)\nthis:\n  S \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Collect (on_stack_ge I (last B)) \\<Longrightarrow>\n       x \\<in> last p_\\<alpha>\n 2. \\<And>x.\n       x \\<in> last p_\\<alpha> \\<Longrightarrow>\n       x \\<in> Collect (on_stack_ge I (last B))", "fix v"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Collect (on_stack_ge I (last B)) \\<Longrightarrow>\n       x \\<in> last p_\\<alpha>\n 2. \\<And>x.\n       x \\<in> last p_\\<alpha> \\<Longrightarrow>\n       x \\<in> Collect (on_stack_ge I (last B))", "assume \"v\\<in>?L\""], ["proof (state)\nthis:\n  v \\<in> Collect (on_stack_ge I (last B))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Collect (on_stack_ge I (last B)) \\<Longrightarrow>\n       x \\<in> last p_\\<alpha>\n 2. \\<And>x.\n       x \\<in> last p_\\<alpha> \\<Longrightarrow>\n       x \\<in> Collect (on_stack_ge I (last B))", "then"], ["proof (chain)\npicking this:\n  v \\<in> Collect (on_stack_ge I (last B))", "obtain j where [simp]: \"I v = Some (STACK j)\" and \"j\\<ge>last B\""], ["proof (prove)\nusing this:\n  v \\<in> Collect (on_stack_ge I (last B))\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>I v = Some (STACK j); last B \\<le> j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: on_stack_ge_def split: option.splits node_state.splits)"], ["proof (state)\nthis:\n  I v = Some (STACK j)\n  last B \\<le> j\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Collect (on_stack_ge I (last B)) \\<Longrightarrow>\n       x \\<in> last p_\\<alpha>\n 2. \\<And>x.\n       x \\<in> last p_\\<alpha> \\<Longrightarrow>\n       x \\<in> Collect (on_stack_ge I (last B))", "from I_consistent[of v j]"], ["proof (chain)\npicking this:\n  (I v = Some (STACK j)) = (j < length S \\<and> v = S ! j)", "have [simp]: \"j<length S\" \"v=S!j\""], ["proof (prove)\nusing this:\n  (I v = Some (STACK j)) = (j < length S \\<and> v = S ! j)\n\ngoal (1 subgoal):\n 1. j < length S &&& v = S ! j", "by auto"], ["proof (state)\nthis:\n  j < length S\n  v = S ! j\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Collect (on_stack_ge I (last B)) \\<Longrightarrow>\n       x \\<in> last p_\\<alpha>\n 2. \\<And>x.\n       x \\<in> last p_\\<alpha> \\<Longrightarrow>\n       x \\<in> Collect (on_stack_ge I (last B))", "hence \"v\\<in>seg (length B - 1)\""], ["proof (prove)\nusing this:\n  j < length S\n  v = S ! j\n\ngoal (1 subgoal):\n 1. v \\<in> seg (length B - 1)", "using \\<open>j\\<ge>last B\\<close>"], ["proof (prove)\nusing this:\n  j < length S\n  v = S ! j\n  last B \\<le> j\n\ngoal (1 subgoal):\n 1. v \\<in> seg (length B - 1)", "by (auto simp: seg_def last_conv_nth seg_start_def seg_end_def)"], ["proof (state)\nthis:\n  v \\<in> seg (length B - 1)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Collect (on_stack_ge I (last B)) \\<Longrightarrow>\n       x \\<in> last p_\\<alpha>\n 2. \\<And>x.\n       x \\<in> last p_\\<alpha> \\<Longrightarrow>\n       x \\<in> Collect (on_stack_ge I (last B))", "thus \"v\\<in>last p_\\<alpha>\""], ["proof (prove)\nusing this:\n  v \\<in> seg (length B - 1)\n\ngoal (1 subgoal):\n 1. v \\<in> last p_\\<alpha>", "by (auto simp: p_\\<alpha>_def last_map)"], ["proof (state)\nthis:\n  v \\<in> last p_\\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> last p_\\<alpha> \\<Longrightarrow>\n       x \\<in> Collect (on_stack_ge I (last B))", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> Collect (on_stack_ge I (last B)) \\<Longrightarrow>\n  ?v2 \\<in> last p_\\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> last p_\\<alpha> \\<Longrightarrow>\n       x \\<in> Collect (on_stack_ge I (last B))", "{"], ["proof (state)\nthis:\n  ?v2 \\<in> Collect (on_stack_ge I (last B)) \\<Longrightarrow>\n  ?v2 \\<in> last p_\\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> last p_\\<alpha> \\<Longrightarrow>\n       x \\<in> Collect (on_stack_ge I (last B))", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> last p_\\<alpha> \\<Longrightarrow>\n       x \\<in> Collect (on_stack_ge I (last B))", "assume \"v\\<in>?R\""], ["proof (state)\nthis:\n  v \\<in> last p_\\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> last p_\\<alpha> \\<Longrightarrow>\n       x \\<in> Collect (on_stack_ge I (last B))", "hence \"v\\<in>seg (length B - 1)\""], ["proof (prove)\nusing this:\n  v \\<in> last p_\\<alpha>\n\ngoal (1 subgoal):\n 1. v \\<in> seg (length B - 1)", "by (auto simp: p_\\<alpha>_def last_map)"], ["proof (state)\nthis:\n  v \\<in> seg (length B - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> last p_\\<alpha> \\<Longrightarrow>\n       x \\<in> Collect (on_stack_ge I (last B))", "then"], ["proof (chain)\npicking this:\n  v \\<in> seg (length B - 1)", "obtain j where \"v=S!j\" \"j\\<ge>last B\" \"j<length S\""], ["proof (prove)\nusing this:\n  v \\<in> seg (length B - 1)\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>v = S ! j; last B \\<le> j; j < length S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: seg_def last_conv_nth seg_start_def seg_end_def)"], ["proof (state)\nthis:\n  v = S ! j\n  last B \\<le> j\n  j < length S\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> last p_\\<alpha> \\<Longrightarrow>\n       x \\<in> Collect (on_stack_ge I (last B))", "with I_consistent"], ["proof (chain)\npicking this:\n  (I ?v = Some (STACK ?j)) = (?j < length S \\<and> ?v = S ! ?j)\n  v = S ! j\n  last B \\<le> j\n  j < length S", "have \"I v = Some (STACK j)\""], ["proof (prove)\nusing this:\n  (I ?v = Some (STACK ?j)) = (?j < length S \\<and> ?v = S ! ?j)\n  v = S ! j\n  last B \\<le> j\n  j < length S\n\ngoal (1 subgoal):\n 1. I v = Some (STACK j)", "by simp"], ["proof (state)\nthis:\n  I v = Some (STACK j)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> last p_\\<alpha> \\<Longrightarrow>\n       x \\<in> Collect (on_stack_ge I (last B))", "with \\<open>j\\<ge>last B\\<close>"], ["proof (chain)\npicking this:\n  last B \\<le> j\n  I v = Some (STACK j)", "show \"v\\<in>?L\""], ["proof (prove)\nusing this:\n  last B \\<le> j\n  I v = Some (STACK j)\n\ngoal (1 subgoal):\n 1. v \\<in> Collect (on_stack_ge I (last B))", "by (auto simp: on_stack_ge_def)"], ["proof (state)\nthis:\n  v \\<in> Collect (on_stack_ge I (last B))\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> last p_\\<alpha> \\<Longrightarrow>\n  ?v2 \\<in> Collect (on_stack_ge I (last B))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition ce_impl :: \"'Q gGS \\<Rightarrow> (('Q set \\<times> 'Q set) option \\<times> 'Q gGS) nres\"\n    where \"ce_impl s \\<equiv> \n    do {\n      let (a,S,B,I,P) = s;\n      ASSERT (B\\<noteq>[]);\n      let bls = Collect (on_stack_less I (last B));\n      let ls = Collect (on_stack_ge I (last B));\n      RETURN (Some (bls, ls),a,S,B,I,P)\n    }\""], ["", "lemma ce_impl_refine:\n    assumes A: \"(s,(a,p,D,pE))\\<in>gGS_rel\"\n    assumes PRE: \"p\\<noteq>[]\"\n    shows \"ce_impl s \\<le> \\<Down>(Id\\<times>\\<^sub>rgGS_rel) \n      (RETURN (Some (\\<Union>(set (butlast p)),last p),a,p,D,pE))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ce_impl s\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r gGS_rel)\n           (RETURN (Some (\\<Union> (set (butlast p)), last p), a, p, D, pE))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ce_impl s\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r gGS_rel)\n           (RETURN (Some (\\<Union> (set (butlast p)), last p), a, p, D, pE))", "from A"], ["proof (chain)\npicking this:\n  (s, a, p, D, pE) \\<in> gGS_rel", "obtain S' B' I' P' where [simp]: \"s=(a,S',B',I',P')\" \n      and OSR: \"((S',B',I',P'),(p,D,pE))\\<in>GS_rel\" and L: \"length a = length B'\""], ["proof (prove)\nusing this:\n  (s, a, p, D, pE) \\<in> gGS_rel\n\ngoal (1 subgoal):\n 1. (\\<And>S' B' I' P'.\n        \\<lbrakk>s = (a, S', B', I', P');\n         ((S', B', I', P'), p, D, pE) \\<in> GS_rel;\n         length a = length B'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule gGS_relE)"], ["proof (state)\nthis:\n  s = (a, S', B', I', P')\n  ((S', B', I', P'), p, D, pE) \\<in> GS_rel\n  length a = length B'\n\ngoal (1 subgoal):\n 1. ce_impl s\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r gGS_rel)\n           (RETURN (Some (\\<Union> (set (butlast p)), last p), a, p, D, pE))", "from OSR"], ["proof (chain)\npicking this:\n  ((S', B', I', P'), p, D, pE) \\<in> GS_rel", "have [simp]: \"GS.p_\\<alpha> (S',B',I',P') = p\""], ["proof (prove)\nusing this:\n  ((S', B', I', P'), p, D, pE) \\<in> GS_rel\n\ngoal (1 subgoal):\n 1. GS.p_\\<alpha> (S', B', I', P') = p", "by (simp add: GS_rel_def br_def GS.\\<alpha>_def)"], ["proof (state)\nthis:\n  GS.p_\\<alpha> (S', B', I', P') = p\n\ngoal (1 subgoal):\n 1. ce_impl s\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r gGS_rel)\n           (RETURN (Some (\\<Union> (set (butlast p)), last p), a, p, D, pE))", "from PRE"], ["proof (chain)\npicking this:\n  p \\<noteq> []", "have NE': \"GS.p_\\<alpha> (S', B', I', P') \\<noteq> []\""], ["proof (prove)\nusing this:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. GS.p_\\<alpha> (S', B', I', P') \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  GS.p_\\<alpha> (S', B', I', P') \\<noteq> []\n\ngoal (1 subgoal):\n 1. ce_impl s\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r gGS_rel)\n           (RETURN (Some (\\<Union> (set (butlast p)), last p), a, p, D, pE))", "hence BNE[simp]: \"B'\\<noteq>[]\""], ["proof (prove)\nusing this:\n  GS.p_\\<alpha> (S', B', I', P') \\<noteq> []\n\ngoal (1 subgoal):\n 1. B' \\<noteq> []", "by (simp add: GS.p_\\<alpha>_def)"], ["proof (state)\nthis:\n  B' \\<noteq> []\n\ngoal (1 subgoal):\n 1. ce_impl s\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r gGS_rel)\n           (RETURN (Some (\\<Union> (set (butlast p)), last p), a, p, D, pE))", "from OSR"], ["proof (chain)\npicking this:\n  ((S', B', I', P'), p, D, pE) \\<in> GS_rel", "have GS_invar: \"GS_invar (S',B',I',P')\""], ["proof (prove)\nusing this:\n  ((S', B', I', P'), p, D, pE) \\<in> GS_rel\n\ngoal (1 subgoal):\n 1. GS_invar (S', B', I', P')", "by (simp add: GS_rel_def br_def)"], ["proof (state)\nthis:\n  GS_invar (S', B', I', P')\n\ngoal (1 subgoal):\n 1. ce_impl s\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r gGS_rel)\n           (RETURN (Some (\\<Union> (set (butlast p)), last p), a, p, D, pE))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ce_impl s\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r gGS_rel)\n           (RETURN (Some (\\<Union> (set (butlast p)), last p), a, p, D, pE))", "using GS_invar.set_butlast_p_refine[OF GS_invar NE']"], ["proof (prove)\nusing this:\n  Collect\n   (on_stack_less (GS.I (S', B', I', P')) (last (GS.B (S', B', I', P')))) =\n  \\<Union> (set (butlast (GS.p_\\<alpha> (S', B', I', P'))))\n\ngoal (1 subgoal):\n 1. ce_impl s\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r gGS_rel)\n           (RETURN (Some (\\<Union> (set (butlast p)), last p), a, p, D, pE))", "using GS_invar.set_last_p_refine[OF GS_invar NE']"], ["proof (prove)\nusing this:\n  Collect\n   (on_stack_less (GS.I (S', B', I', P')) (last (GS.B (S', B', I', P')))) =\n  \\<Union> (set (butlast (GS.p_\\<alpha> (S', B', I', P'))))\n  Collect\n   (on_stack_ge (GS.I (S', B', I', P')) (last (GS.B (S', B', I', P')))) =\n  last (GS.p_\\<alpha> (S', B', I', P'))\n\ngoal (1 subgoal):\n 1. ce_impl s\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r gGS_rel)\n           (RETURN (Some (\\<Union> (set (butlast p)), last p), a, p, D, pE))", "unfolding ce_impl_def"], ["proof (prove)\nusing this:\n  Collect\n   (on_stack_less (GS.I (S', B', I', P')) (last (GS.B (S', B', I', P')))) =\n  \\<Union> (set (butlast (GS.p_\\<alpha> (S', B', I', P'))))\n  Collect\n   (on_stack_ge (GS.I (S', B', I', P')) (last (GS.B (S', B', I', P')))) =\n  last (GS.p_\\<alpha> (S', B', I', P'))\n\ngoal (1 subgoal):\n 1. (let (a, S, B, I, P) = s\n     in ASSERT (B \\<noteq> []) \\<bind>\n        (\\<lambda>_.\n            let bls = Collect (on_stack_less I (last B));\n                ls = Collect (on_stack_ge I (last B))\n            in RETURN (Some (bls, ls), a, S, B, I, P)))\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r gGS_rel)\n           (RETURN (Some (\\<Union> (set (butlast p)), last p), a, p, D, pE))", "using A"], ["proof (prove)\nusing this:\n  Collect\n   (on_stack_less (GS.I (S', B', I', P')) (last (GS.B (S', B', I', P')))) =\n  \\<Union> (set (butlast (GS.p_\\<alpha> (S', B', I', P'))))\n  Collect\n   (on_stack_ge (GS.I (S', B', I', P')) (last (GS.B (S', B', I', P')))) =\n  last (GS.p_\\<alpha> (S', B', I', P'))\n  (s, a, p, D, pE) \\<in> gGS_rel\n\ngoal (1 subgoal):\n 1. (let (a, S, B, I, P) = s\n     in ASSERT (B \\<noteq> []) \\<bind>\n        (\\<lambda>_.\n            let bls = Collect (on_stack_less I (last B));\n                ls = Collect (on_stack_ge I (last B))\n            in RETURN (Some (bls, ls), a, S, B, I, P)))\n    \\<le> \\<Down> (Id \\<times>\\<^sub>r gGS_rel)\n           (RETURN (Some (\\<Union> (set (butlast p)), last p), a, p, D, pE))", "by auto"], ["proof (state)\nthis:\n  ce_impl s\n  \\<le> \\<Down> (Id \\<times>\\<^sub>r gGS_rel)\n         (RETURN (Some (\\<Union> (set (butlast p)), last p), a, p, D, pE))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"last_is_acc_impl s \\<equiv> \n    do {\n      let (a,_)=s;\n      ASSERT (a\\<noteq>[]);\n      RETURN (\\<forall>i<num_acc. i\\<in>last a)\n    }\""], ["", "lemma last_is_acc_impl_refine:\n    assumes A: \"(s,(a,p,D,pE))\\<in>gGS_rel\"\n    assumes PRE: \"a\\<noteq>[]\"\n    shows \"last_is_acc_impl s \\<le> RETURN (last a = {0..<num_acc})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last_is_acc_impl s \\<le> RETURN (last a = {0..<num_acc})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. last_is_acc_impl s \\<le> RETURN (last a = {0..<num_acc})", "from A PRE"], ["proof (chain)\npicking this:\n  (s, a, p, D, pE) \\<in> gGS_rel\n  a \\<noteq> []", "have \"last a \\<subseteq> {0..<num_acc}\""], ["proof (prove)\nusing this:\n  (s, a, p, D, pE) \\<in> gGS_rel\n  a \\<noteq> []\n\ngoal (1 subgoal):\n 1. last a \\<subseteq> {0..<num_acc}", "unfolding gGS_rel_def gGS_invar_def br_def gGS_\\<alpha>_def"], ["proof (prove)\nusing this:\n  (s, a, p, D, pE)\n  \\<in> {(c, a).\n         a = (let (a, s) = c in (a, GS.\\<alpha> s)) \\<and>\n         (let (a, S, B, I, P) = c\n          in GS_invar (S, B, I, P) \\<and>\n             length a = length B \\<and>\n             \\<Union> (set a) \\<subseteq> {0..<num_acc})}\n  a \\<noteq> []\n\ngoal (1 subgoal):\n 1. last a \\<subseteq> {0..<num_acc}", "by auto"], ["proof (state)\nthis:\n  last a \\<subseteq> {0..<num_acc}\n\ngoal (1 subgoal):\n 1. last_is_acc_impl s \\<le> RETURN (last a = {0..<num_acc})", "hence C: \"(\\<forall>i<num_acc. i\\<in>last a) \\<longleftrightarrow> (last a = {0..<num_acc})\""], ["proof (prove)\nusing this:\n  last a \\<subseteq> {0..<num_acc}\n\ngoal (1 subgoal):\n 1. (\\<forall>i<num_acc. i \\<in> last a) = (last a = {0..<num_acc})", "by auto"], ["proof (state)\nthis:\n  (\\<forall>i<num_acc. i \\<in> last a) = (last a = {0..<num_acc})\n\ngoal (1 subgoal):\n 1. last_is_acc_impl s \\<le> RETURN (last a = {0..<num_acc})", "from A"], ["proof (chain)\npicking this:\n  (s, a, p, D, pE) \\<in> gGS_rel", "obtain gs where [simp]: \"s=(a,gs)\""], ["proof (prove)\nusing this:\n  (s, a, p, D, pE) \\<in> gGS_rel\n\ngoal (1 subgoal):\n 1. (\\<And>gs. s = (a, gs) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: gGS_rel_def gGS_\\<alpha>_def br_def split: prod.splits)"], ["proof (state)\nthis:\n  s = (a, gs)\n\ngoal (1 subgoal):\n 1. last_is_acc_impl s \\<le> RETURN (last a = {0..<num_acc})", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. last_is_acc_impl s \\<le> RETURN (last a = {0..<num_acc})", "unfolding last_is_acc_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (a, uu_) = s\n     in ASSERT (a \\<noteq> []) \\<bind>\n        (\\<lambda>_. RETURN (\\<forall>i<num_acc. i \\<in> last a)))\n    \\<le> RETURN (last a = {0..<num_acc})", "by (auto simp: gGS_rel_def br_def gGS_\\<alpha>_def C PRE split: prod.splits)"], ["proof (state)\nthis:\n  last_is_acc_impl s \\<le> RETURN (last a = {0..<num_acc})\n\ngoal:\nNo subgoals!", "qed"], ["", "definition go_is_no_brk_impl :: \"'Q goGS \\<Rightarrow> bool\" \n    where \"go_is_no_brk_impl s \\<equiv> fst s = None\""], ["", "lemma go_is_no_brk_refine: \n    \"(s,s')\\<in>goGS_rel \\<Longrightarrow> go_is_no_brk_impl s \\<longleftrightarrow> go_is_no_brk s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, s') \\<in> goGS_rel \\<Longrightarrow>\n    go_is_no_brk_impl s = go_is_no_brk s'", "unfolding go_is_no_brk_def go_is_no_brk_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, s') \\<in> goGS_rel \\<Longrightarrow>\n    (fst s = None) = (fst s' = None)", "by (auto simp: goGS_rel_def br_def goGS_\\<alpha>_def split: prod.splits)"], ["", "definition goD_impl :: \"'Q goGS \\<Rightarrow> 'Q oGS\" where \"goD_impl s \\<equiv> snd s\""], ["", "lemma goD_refine: \n    \"go_is_no_brk s' \\<Longrightarrow> (s,s')\\<in>goGS_rel \\<Longrightarrow> (goD_impl s, goD s')\\<in>oGS_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>go_is_no_brk s'; (s, s') \\<in> goGS_rel\\<rbrakk>\n    \\<Longrightarrow> (goD_impl s, goD s') \\<in> oGS_rel", "unfolding goD_impl_def goD_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>go_is_no_brk s'; (s, s') \\<in> goGS_rel\\<rbrakk>\n    \\<Longrightarrow> (snd s, snd s') \\<in> oGS_rel", "by (auto \n      simp: goGS_rel_def br_def goGS_\\<alpha>_def goGS_invar_def oGS_rel_def \n            go_is_no_brk_def)"], ["", "definition go_is_done_impl :: \"'Q \\<Rightarrow> 'Q goGS \\<Rightarrow> bool\" \n    where \"go_is_done_impl v s \\<equiv> is_done_oimpl v (snd s)\""], ["", "thm is_done_orefine"], ["", "lemma go_is_done_impl_refine: \"\\<lbrakk>go_is_no_brk s'; (s,s')\\<in>goGS_rel; (v,v')\\<in>Id\\<rbrakk> \n    \\<Longrightarrow> go_is_done_impl v s \\<longleftrightarrow> (v'\\<in>goD s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>go_is_no_brk s'; (s, s') \\<in> goGS_rel;\n     (v, v') \\<in> Id\\<rbrakk>\n    \\<Longrightarrow> go_is_done_impl v s = (v' \\<in> goD s')", "using is_done_orefine"], ["proof (prove)\nusing this:\n  oGS_invar ?s \\<Longrightarrow>\n  is_done_oimpl ?v ?s = (?v \\<in> oGS_\\<alpha> ?s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>go_is_no_brk s'; (s, s') \\<in> goGS_rel;\n     (v, v') \\<in> Id\\<rbrakk>\n    \\<Longrightarrow> go_is_done_impl v s = (v' \\<in> goD s')", "unfolding go_is_done_impl_def goD_def go_is_no_brk_def"], ["proof (prove)\nusing this:\n  oGS_invar ?s \\<Longrightarrow>\n  is_done_oimpl ?v ?s = (?v \\<in> oGS_\\<alpha> ?s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst s' = None; (s, s') \\<in> goGS_rel;\n     (v, v') \\<in> Id\\<rbrakk>\n    \\<Longrightarrow> is_done_oimpl v (snd s) = (v' \\<in> snd s')", "apply (fastforce simp: goGS_rel_def br_def goGS_invar_def goGS_\\<alpha>_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition goBrk_impl :: \"'Q goGS \\<Rightarrow> 'Q ce\" where \"goBrk_impl \\<equiv> fst\""], ["", "lemma goBrk_refine: \"(s,s')\\<in>goGS_rel \\<Longrightarrow> (goBrk_impl s, goBrk s')\\<in>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, s') \\<in> goGS_rel \\<Longrightarrow>\n    (goBrk_impl s, goBrk s') \\<in> Id", "unfolding goBrk_impl_def goBrk_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, s') \\<in> goGS_rel \\<Longrightarrow> (fst s, fst s') \\<in> Id", "by (auto simp: goGS_rel_def br_def goGS_\\<alpha>_def split: prod.splits)"], ["", "definition find_ce_impl :: \"('Q set \\<times> 'Q set) option nres\" where\n    \"find_ce_impl \\<equiv> do {\n      stat_start_nres;\n      let os=goinitial_impl;\n      os\\<leftarrow>FOREACHci (\\<lambda>it os. fgl_outer_invar it (goGS_\\<alpha> os)) V0 \n        (go_is_no_brk_impl) (\\<lambda>v0 s0. \n      do {\n        if \\<not>go_is_done_impl v0 s0 then do {\n\n          let s = (None,ginitial_impl v0 s0);\n\n          (brk,s)\\<leftarrow>WHILEIT \n            (\\<lambda>(brk,s). fgl_invar v0 (oGS_\\<alpha> (goD_impl s0)) (brk,snd (gGS_\\<alpha> s)))\n            (\\<lambda>(brk,s). brk=None \\<and> \\<not>gpath_is_empty_impl s) (\\<lambda>(l,s).\n          do {\n            \\<comment> \\<open>Select edge from end of path\\<close>\n            (vo,s) \\<leftarrow> gselect_edge_impl s;\n\n            case vo of \n              Some v \\<Rightarrow> do {\n                if gis_on_stack_impl v s then do {\n                  s\\<leftarrow>gcollapse_impl v s;\n                  b\\<leftarrow>last_is_acc_impl s;\n                  if b then\n                    ce_impl s\n                  else \n                    RETURN (None,s)\n                } else if \\<not>gis_done_impl v s then do {\n                  \\<comment> \\<open>Edge to new node. Append to path\\<close>\n                  RETURN (None,gpush_impl v s)\n                } else do {\n                  \\<comment> \\<open>Edge to done node. Skip\\<close>\n                  RETURN (None,s)\n                }\n              }\n            | None \\<Rightarrow> do {\n                \\<comment> \\<open>No more outgoing edges from current node on path\\<close>\n                s\\<leftarrow>gpop_impl s;\n                RETURN (None,s)\n              }\n          }) (s);\n          RETURN (gto_outer_impl brk s)\n        } else RETURN s0\n      }) os;\n      stat_stop_nres;\n      RETURN (goBrk_impl os)\n    }\""], ["", "lemma find_ce_impl_refine: \"find_ce_impl \\<le> \\<Down>Id gfind_ce\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_ce_impl \\<le> \\<Down> Id gfind_ce", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. find_ce_impl \\<le> \\<Down> Id gfind_ce", "note [refine2] = prod_relI[OF IdI[of None] ginitial_impl_refine]"], ["proof (state)\nthis:\n  \\<lbrakk>?v0.1 \\<notin> goD ?s0.1; go_is_no_brk ?s0.1;\n   (?s0i1, ?s0.1) \\<in> goGS_rel; (?v0i1, ?v0.1) \\<in> Id\\<rbrakk>\n  \\<Longrightarrow> ((None, ginitial_impl ?v0i1 ?s0i1), None,\n                     ginitial ?v0.1 ?s0.1)\n                    \\<in> Id \\<times>\\<^sub>r gGS_rel\n\ngoal (1 subgoal):\n 1. find_ce_impl \\<le> \\<Down> Id gfind_ce", "have [refine]: \"\\<And>s a p D pE. \\<lbrakk>\n      (s,(a,p,D,pE))\\<in>gGS_rel;\n      p \\<noteq> []; pE \\<inter> last p \\<times> UNIV = {}\n      \\<rbrakk> \\<Longrightarrow>\n      gpop_impl s \\<bind> (\\<lambda>s. RETURN (None, s))\n        \\<le> SPEC (\\<lambda>c. (c, None, gpop (a,p,D,pE)) \\<in> Id \\<times>\\<^sub>r gGS_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s a p D pE.\n       \\<lbrakk>(s, a, p, D, pE) \\<in> gGS_rel; p \\<noteq> [];\n        pE \\<inter> last p \\<times> UNIV = {}\\<rbrakk>\n       \\<Longrightarrow> gpop_impl s \\<bind> (\\<lambda>s. RETURN (None, s))\n                         \\<le> SPEC\n                                (\\<lambda>c.\n                                    (c, None, gpop (a, p, D, pE))\n                                    \\<in> Id \\<times>\\<^sub>r gGS_rel)", "apply (drule (2) gpop_impl_refine)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s a p D pE.\n       \\<lbrakk>p \\<noteq> []; pE \\<inter> last p \\<times> UNIV = {};\n        gpop_impl s\n        \\<le> \\<Down> gGS_rel (RETURN (gpop (a, p, D, pE)))\\<rbrakk>\n       \\<Longrightarrow> gpop_impl s \\<bind> (\\<lambda>s. RETURN (None, s))\n                         \\<le> SPEC\n                                (\\<lambda>c.\n                                    (c, None, gpop (a, p, D, pE))\n                                    \\<in> Id \\<times>\\<^sub>r gGS_rel)", "apply (fastforce simp add: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>(?s4, ?a4, ?p4, ?D4, ?pE4) \\<in> gGS_rel; ?p4 \\<noteq> [];\n   ?pE4 \\<inter> last ?p4 \\<times> UNIV = {}\\<rbrakk>\n  \\<Longrightarrow> gpop_impl ?s4 \\<bind> (\\<lambda>s. RETURN (None, s))\n                    \\<le> SPEC\n                           (\\<lambda>c.\n                               (c, None, gpop (?a4, ?p4, ?D4, ?pE4))\n                               \\<in> Id \\<times>\\<^sub>r gGS_rel)\n\ngoal (1 subgoal):\n 1. find_ce_impl \\<le> \\<Down> Id gfind_ce", "note [[goals_limit = 1]]"], ["proof (state)\nthis:\n  TERM _\n\ngoal (1 subgoal):\n 1. find_ce_impl \\<le> \\<Down> Id gfind_ce", "note FOREACHci_refine_rcg'[refine del]"], ["proof (state)\nthis:\n  \\<lbrakk>inj_on ?\\<alpha> ?S; ?S' = ?\\<alpha> ` ?S;\n   (?\\<sigma>0.0, ?\\<sigma>0') \\<in> ?R;\n   \\<And>it \\<sigma> it' \\<sigma>'.\n      \\<lbrakk>it' = ?\\<alpha> ` it; it \\<subseteq> ?S; it' \\<subseteq> ?S';\n       ?\\<Phi>' it' \\<sigma>'; (\\<sigma>, \\<sigma>') \\<in> ?R\\<rbrakk>\n      \\<Longrightarrow> ?c \\<sigma> = ?c' \\<sigma>';\n   \\<And>x it \\<sigma> x' it' \\<sigma>'.\n      \\<lbrakk>x' = ?\\<alpha> x; x \\<in> it; x' \\<in> it';\n       it' = ?\\<alpha> ` it; it \\<subseteq> ?S; it' \\<subseteq> ?S';\n       ?\\<Phi>' it' \\<sigma>'; ?c \\<sigma>; ?c' \\<sigma>';\n       (\\<sigma>, \\<sigma>') \\<in> ?R\\<rbrakk>\n      \\<Longrightarrow> ?f x \\<sigma>\n                        \\<le> \\<Down> ?R (?f' x' \\<sigma>')\\<rbrakk>\n  \\<Longrightarrow> FOREACH\\<^sub>C ?S ?c ?f ?\\<sigma>0.0\n                    \\<le> \\<Down> ?R\n                           (FOREACH\\<^sub>C\\<^bsup>?\\<Phi>'\\<^esup> ?S' ?c'\n                             ?f' ?\\<sigma>0')\n\ngoal (1 subgoal):\n 1. find_ce_impl \\<le> \\<Down> Id gfind_ce", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. find_ce_impl \\<le> \\<Down> Id gfind_ce", "unfolding find_ce_impl_def gfind_ce_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. stat_start_nres \\<bind>\n    (\\<lambda>_.\n        let os = goinitial_impl\n        in FOREACH\\<^sub>C\\<^bsup>\\<lambda>it os.\n                                     fgl_outer_invar it\n(goGS_\\<alpha> os)\\<^esup>\n            V0 go_is_no_brk_impl\n            (\\<lambda>v0 s0.\n                if \\<not> go_is_done_impl v0 s0\n                then let s = (None, ginitial_impl v0 s0)\n                     in WHILE\\<^sub>T\\<^bsup>\\<lambda>(brk, s).\n          fgl_invar v0 (oGS_\\<alpha> (goD_impl s0))\n           (brk, snd (gGS_\\<alpha> s))\\<^esup>\n                         (\\<lambda>(brk, s).\n                             brk = None \\<and> \\<not> gpath_is_empty_impl s)\n                         (\\<lambda>(l, s).\n                             gselect_edge_impl s \\<bind>\n                             (\\<lambda>(vo, s).\n                                 case vo of\n                                 None \\<Rightarrow>\n                                   gpop_impl s \\<bind>\n                                   (\\<lambda>s. RETURN (None, s))\n                                 | Some v \\<Rightarrow>\n                                     if gis_on_stack_impl v s\n                                     then gcollapse_impl v s \\<bind>\n    (\\<lambda>s.\n        last_is_acc_impl s \\<bind>\n        (\\<lambda>b. if b then ce_impl s else RETURN (None, s)))\n                                     else if \\<not> gis_done_impl v s\n    then RETURN (None, gpush_impl v s) else RETURN (None, s)))\n                         s \\<bind>\n                        (\\<lambda>(brk, s). RETURN (gto_outer_impl brk s))\n                else RETURN s0)\n            os \\<bind>\n           (\\<lambda>os.\n               stat_stop_nres \\<bind> (\\<lambda>_. RETURN (goBrk_impl os))))\n    \\<le> \\<Down> Id\n           (let os = goinitial\n            in FOREACH\\<^sub>C\\<^bsup>fgl_outer_invar\\<^esup> V0\n                go_is_no_brk\n                (\\<lambda>v0 s0.\n                    if v0 \\<notin> goD s0\n                    then let s = (None, ginitial v0 s0)\n                         in WHILE\\<^sub>T\\<^bsup>\\<lambda>(brk, a, s).\n              fgl_invar v0 (goD s0) (brk, s)\\<^esup>\n                             (\\<lambda>(brk, a, p, D, pE).\n                                 brk = None \\<and> p \\<noteq> [])\n                             (\\<lambda>(uu_, a, p, D, pE).\n                                 gselect_edge (a, p, D, pE) \\<bind>\n                                 (\\<lambda>(vo, a, p, D, pE).\n                                     ASSERT (p \\<noteq> []) \\<bind>\n                                     (\\<lambda>_.\n   case vo of\n   None \\<Rightarrow>\n     ASSERT (pE \\<inter> last p \\<times> UNIV = {}) \\<bind>\n     (\\<lambda>_. RETURN (None, gpop (a, p, D, pE)))\n   | Some v \\<Rightarrow>\n       if v \\<in> \\<Union> (set p)\n       then let (a, p, D, pE) = gcollapse v (a, p, D, pE)\n            in ASSERT (p \\<noteq> []) \\<bind>\n               (\\<lambda>_.\n                   ASSERT (a \\<noteq> []) \\<bind>\n                   (\\<lambda>_.\n                       if last a = {0..<num_acc}\n                       then RETURN\n                             (Some (\\<Union> (set (butlast p)), last p), a,\n                              p, D, pE)\n                       else RETURN (None, a, p, D, pE)))\n       else if v \\<notin> D then RETURN (None, gpush v (a, p, D, pE))\n            else RETURN (None, a, p, D, pE))))\n                             s \\<bind>\n                            (\\<lambda>(brk, a, p, D, pE).\n                                ASSERT\n                                 (brk = None \\<longrightarrow>\n                                  p = [] \\<and> pE = {}) \\<bind>\n                                (\\<lambda>_.\n                                    RETURN (gto_outer brk (a, p, D, pE))))\n                    else RETURN s0)\n                os \\<bind>\n               (\\<lambda>os. RETURN (goBrk os)))", "apply (refine_rcg\n        bind_refine'\n        prod_relI IdI\n        inj_on_id\n\n        gselect_edge_impl_refine gpush_impl_refine \n        oinitial_refine ginitial_impl_refine \n        bind_Let_refine2[OF gcollapse_impl_refine]\n        if_bind_cond_refine[OF last_is_acc_impl_refine]\n        ce_impl_refine\n        goinitial_impl_refine\n        gto_outer_refine\n        goBrk_refine\n        FOREACHci_refine_rcg'[where R=goGS_rel, OF inj_on_id]\n      )"], ["proof (prove)\ngoal (25 subgoals):\n 1. V0 = id ` V0\nA total of 25 subgoals...", "apply refine_dref_type"], ["proof (prove)\ngoal (23 subgoals):\n 1. V0 = id ` V0\nA total of 23 subgoals...", "apply (simp_all add: go_is_no_brk_refine go_is_done_impl_refine)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>it \\<sigma> it' \\<sigma>'.\n       \\<lbrakk>it' = it; it \\<subseteq> V0; fgl_outer_invar it \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> goGS_rel\\<rbrakk>\n       \\<Longrightarrow> fgl_outer_invar it (goGS_\\<alpha> \\<sigma>)\nA total of 5 subgoals...", "apply (auto simp: goGS_rel_def br_def) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x it \\<sigma> x' it' \\<sigma>' xa x'a x1 x2.\n       \\<lbrakk>x' = x; x \\<in> it; it' = it; it \\<subseteq> V0;\n        fgl_outer_invar it (goGS_\\<alpha> \\<sigma>);\n        fgl_outer_invar it \\<sigma>'; go_is_no_brk \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> goGS_rel; x \\<notin> goD \\<sigma>';\n        ((x1, x2), x'a) \\<in> Id \\<times>\\<^sub>r gGS_rel;\n        case x'a of\n        (brk, a, s) \\<Rightarrow> fgl_invar x (goD \\<sigma>') (brk, s);\n        xa = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> fgl_invar x (oGS_\\<alpha> (goD_impl \\<sigma>))\n                          (x1, snd (gGS_\\<alpha> x2))\nA total of 4 subgoals...", "apply (auto simp: goGS_rel_def br_def goGS_\\<alpha>_def gGS_\\<alpha>_def gGS_rel_def \n                        goD_def goD_impl_def) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma> x' it' \\<sigma>' xa x'a x1 x2 x2a x1b x2b x1c x2c\n       x1d x2d.\n       \\<lbrakk>x' = x; x \\<in> it; it' = it; it \\<subseteq> V0;\n        fgl_outer_invar it (goGS_\\<alpha> \\<sigma>);\n        fgl_outer_invar it \\<sigma>'; go_is_no_brk \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> goGS_rel; x \\<notin> goD \\<sigma>';\n        (x2, x1b, x1c, x1d, x2d) \\<in> gGS_rel;\n        fgl_invar x (oGS_\\<alpha> (goD_impl \\<sigma>))\n         (x1, snd (gGS_\\<alpha> x2));\n        fgl_invar x (goD \\<sigma>') (x1, x1c, x1d, x2d); xa = (x1, x2);\n        x2c = (x1d, x2d); x2b = (x1c, x1d, x2d); x2a = (x1b, x1c, x1d, x2d);\n        x'a = (x1, x1b, x1c, x1d, x2d)\\<rbrakk>\n       \\<Longrightarrow> (x1 = None \\<and> \\<not> gpath_is_empty_impl x2) =\n                         (x1 = None \\<and> x1c \\<noteq> [])\nA total of 3 subgoals...", "apply (auto dest: gpath_is_empty_refine ) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma> x' it' \\<sigma>' xa x'a x2 x1a x2a x1b x2b x1c x2c\n       x2d xb x'b x1e x2e x1f x2f x1g x2g x1h x2h x1i x2i xc.\n       \\<lbrakk>x' = x; x \\<in> it; it' = it; it \\<subseteq> V0;\n        fgl_outer_invar it (goGS_\\<alpha> \\<sigma>);\n        fgl_outer_invar it \\<sigma>'; go_is_no_brk \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> goGS_rel; x \\<notin> goD \\<sigma>';\n        (x2d, x1a, x1b, x1c, x2c) \\<in> gGS_rel;\n        \\<not> gpath_is_empty_impl x2d; x1b \\<noteq> [];\n        fgl_invar x (oGS_\\<alpha> (goD_impl \\<sigma>))\n         (None, snd (gGS_\\<alpha> x2d));\n        fgl_invar x (goD \\<sigma>') (None, x1b, x1c, x2c); x2b = (x1c, x2c);\n        x2a = (x1b, x1c, x2c); x2 = (x1a, x1b, x1c, x2c);\n        x'a = (None, x1a, x1b, x1c, x2c); xa = (None, x2d);\n        (x2i, x1f, x1g, x1h, x2h) \\<in> gGS_rel;\n        inres (gselect_edge_impl x2d) (Some xc, x2i);\n        inres (gselect_edge (x1a, x1b, x1c, x2c))\n         (Some xc, x1f, x1g, x1h, x2h);\n        nofail (gselect_edge_impl x2d);\n        nofail (gselect_edge (x1a, x1b, x1c, x2c)); x2g = (x1h, x2h);\n        x2f = (x1g, x1h, x2h); x2e = (x1f, x1g, x1h, x2h);\n        x'b = (Some xc, x1f, x1g, x1h, x2h); xb = (Some xc, x2i);\n        x1g \\<noteq> []; x1i = Some xc; x1e = Some xc\\<rbrakk>\n       \\<Longrightarrow> gis_on_stack_impl xc x2i =\n                         (\\<exists>x\\<in>set x1g. xc \\<in> x)\nA total of 2 subgoals...", "apply (auto dest: gis_on_stack_refine) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> x' it' \\<sigma>' xa x'a x2 x1a x2a x1b x2b x1c x2c\n       x2d xb x'b x1e x2e x1f x2f x1g x2g x1h x2h x1i x2i xc.\n       \\<lbrakk>x' = x; x \\<in> it; it' = it; it \\<subseteq> V0;\n        fgl_outer_invar it (goGS_\\<alpha> \\<sigma>);\n        fgl_outer_invar it \\<sigma>'; go_is_no_brk \\<sigma>';\n        (\\<sigma>, \\<sigma>') \\<in> goGS_rel; x \\<notin> goD \\<sigma>';\n        (x2d, x1a, x1b, x1c, x2c) \\<in> gGS_rel;\n        \\<not> gpath_is_empty_impl x2d; x1b \\<noteq> [];\n        fgl_invar x (oGS_\\<alpha> (goD_impl \\<sigma>))\n         (None, snd (gGS_\\<alpha> x2d));\n        fgl_invar x (goD \\<sigma>') (None, x1b, x1c, x2c); x2b = (x1c, x2c);\n        x2a = (x1b, x1c, x2c); x2 = (x1a, x1b, x1c, x2c);\n        x'a = (None, x1a, x1b, x1c, x2c); xa = (None, x2d);\n        (x2i, x1f, x1g, x1h, x2h) \\<in> gGS_rel;\n        inres (gselect_edge_impl x2d) (Some xc, x2i);\n        inres (gselect_edge (x1a, x1b, x1c, x2c))\n         (Some xc, x1f, x1g, x1h, x2h);\n        nofail (gselect_edge_impl x2d);\n        nofail (gselect_edge (x1a, x1b, x1c, x2c)); x2g = (x1h, x2h);\n        x2f = (x1g, x1h, x2h); x2e = (x1f, x1g, x1h, x2h);\n        x'b = (Some xc, x1f, x1g, x1h, x2h); xb = (Some xc, x2i);\n        x1g \\<noteq> []; x1i = Some xc; x1e = Some xc;\n        \\<not> gis_on_stack_impl xc x2i;\n        \\<forall>x\\<in>set x1g. xc \\<notin> x\\<rbrakk>\n       \\<Longrightarrow> gis_done_impl xc x2i = (xc \\<in> x1h)", "apply (auto dest: gis_done_refine) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  find_ce_impl \\<le> \\<Down> Id gfind_ce\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "section \\<open>Constructing a Lasso from Counterexample\\<close>"], ["", "subsection \\<open>Lassos in GBAs\\<close>"], ["", "context igb_fr_graph begin"], ["", "definition reconstruct_reach :: \"'Q set \\<Rightarrow> 'Q set \\<Rightarrow> ('Q list \\<times> 'Q) nres\"\n    \\<comment> \\<open>Reconstruct the reaching path of a lasso\\<close>\n    where \"reconstruct_reach Vr Vl \\<equiv> do {\n      res \\<leftarrow> find_path (E\\<inter>Vr\\<times>UNIV) V0 (\\<lambda>v. v\\<in>Vl);\n      ASSERT (res \\<noteq> None);\n      RETURN (the res)\n    }\""], ["", "lemma reconstruct_reach_correct:\n    assumes CEC: \"ce_correct Vr Vl\"\n    shows \"reconstruct_reach Vr Vl \n      \\<le> SPEC (\\<lambda>(pr,va). \\<exists>v0\\<in>V0. path E v0 pr va \\<and> va\\<in>Vl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reconstruct_reach Vr Vl\n    \\<le> SPEC\n           (\\<lambda>(pr, va).\n               \\<exists>v0\\<in>V0. path E v0 pr va \\<and> va \\<in> Vl)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. reconstruct_reach Vr Vl\n    \\<le> SPEC\n           (\\<lambda>(pr, va).\n               \\<exists>v0\\<in>V0. path E v0 pr va \\<and> va \\<in> Vl)", "have FIN_aux: \"finite ((E \\<inter> Vr \\<times> UNIV)\\<^sup>* `` V0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ((E \\<inter> Vr \\<times> UNIV)\\<^sup>* `` V0)", "by (metis finite_reachableE_V0 finite_subset inf_sup_ord(1) inf_sup_ord(2)\n        inf_top.left_neutral reachable_mono)"], ["proof (state)\nthis:\n  finite ((E \\<inter> Vr \\<times> UNIV)\\<^sup>* `` V0)\n\ngoal (1 subgoal):\n 1. reconstruct_reach Vr Vl\n    \\<le> SPEC\n           (\\<lambda>(pr, va).\n               \\<exists>v0\\<in>V0. path E v0 pr va \\<and> va \\<in> Vl)", "{"], ["proof (state)\nthis:\n  finite ((E \\<inter> Vr \\<times> UNIV)\\<^sup>* `` V0)\n\ngoal (1 subgoal):\n 1. reconstruct_reach Vr Vl\n    \\<le> SPEC\n           (\\<lambda>(pr, va).\n               \\<exists>v0\\<in>V0. path E v0 pr va \\<and> va \\<in> Vl)", "fix u p v"], ["proof (state)\ngoal (1 subgoal):\n 1. reconstruct_reach Vr Vl\n    \\<le> SPEC\n           (\\<lambda>(pr, va).\n               \\<exists>v0\\<in>V0. path E v0 pr va \\<and> va \\<in> Vl)", "assume P: \"path E u p v\" and SS: \"set p \\<subseteq> Vr\""], ["proof (state)\nthis:\n  path E u p v\n  set p \\<subseteq> Vr\n\ngoal (1 subgoal):\n 1. reconstruct_reach Vr Vl\n    \\<le> SPEC\n           (\\<lambda>(pr, va).\n               \\<exists>v0\\<in>V0. path E v0 pr va \\<and> va \\<in> Vl)", "have \"path (E \\<inter> Vr\\<times>UNIV) u p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (E \\<inter> Vr \\<times> UNIV) u p v", "apply (rule path_mono[OF _ path_restrict[OF P]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<inter> set p \\<times> insert v (set (tl p))\n    \\<subseteq> E \\<inter> Vr \\<times> UNIV", "using SS"], ["proof (prove)\nusing this:\n  set p \\<subseteq> Vr\n\ngoal (1 subgoal):\n 1. E \\<inter> set p \\<times> insert v (set (tl p))\n    \\<subseteq> E \\<inter> Vr \\<times> UNIV", "by auto"], ["proof (state)\nthis:\n  path (E \\<inter> Vr \\<times> UNIV) u p v\n\ngoal (1 subgoal):\n 1. reconstruct_reach Vr Vl\n    \\<le> SPEC\n           (\\<lambda>(pr, va).\n               \\<exists>v0\\<in>V0. path E v0 pr va \\<and> va \\<in> Vl)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>path E ?u6 ?p6 ?v6; set ?p6 \\<subseteq> Vr\\<rbrakk>\n  \\<Longrightarrow> path (E \\<inter> Vr \\<times> UNIV) ?u6 ?p6 ?v6\n\ngoal (1 subgoal):\n 1. reconstruct_reach Vr Vl\n    \\<le> SPEC\n           (\\<lambda>(pr, va).\n               \\<exists>v0\\<in>V0. path E v0 pr va \\<and> va \\<in> Vl)", "note P_CONV=this"], ["proof (state)\nthis:\n  \\<lbrakk>path E ?u6 ?p6 ?v6; set ?p6 \\<subseteq> Vr\\<rbrakk>\n  \\<Longrightarrow> path (E \\<inter> Vr \\<times> UNIV) ?u6 ?p6 ?v6\n\ngoal (1 subgoal):\n 1. reconstruct_reach Vr Vl\n    \\<le> SPEC\n           (\\<lambda>(pr, va).\n               \\<exists>v0\\<in>V0. path E v0 pr va \\<and> va \\<in> Vl)", "from CEC"], ["proof (chain)\npicking this:\n  ce_correct Vr Vl", "obtain v0 \"pr\" va where \"v0\\<in>V0\" \"set pr \\<subseteq> Vr\" \"va\\<in>Vl\" \n      \"path (E \\<inter> Vr\\<times>UNIV) v0 pr va\""], ["proof (prove)\nusing this:\n  ce_correct Vr Vl\n\ngoal (1 subgoal):\n 1. (\\<And>v0 pr va.\n        \\<lbrakk>v0 \\<in> V0; set pr \\<subseteq> Vr; va \\<in> Vl;\n         path (E \\<inter> Vr \\<times> UNIV) v0 pr va\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ce_correct_def is_lasso_prpl_def is_lasso_prpl_pre_def"], ["proof (prove)\nusing this:\n  \\<exists>pr pl.\n     Vr \\<subseteq> reachable \\<and>\n     Vl \\<subseteq> reachable \\<and>\n     set pr \\<subseteq> Vr \\<and>\n     set pl \\<subseteq> Vl \\<and>\n     Vl \\<times> Vl \\<subseteq> (Restr E Vl)\\<^sup>* \\<and>\n     Vl \\<times> Vl \\<inter> E \\<noteq> {} \\<and>\n     (case (pr, pl) of\n      (pr, pl) \\<Rightarrow>\n        \\<exists>v0 va.\n           v0 \\<in> V0 \\<and>\n           pl \\<noteq> [] \\<and>\n           path E v0 pr va \\<and> path E va pl va) \\<and>\n     (\\<forall>i<num_acc. \\<exists>q\\<in>set (snd (pr, pl)). i \\<in> acc q)\n\ngoal (1 subgoal):\n 1. (\\<And>v0 pr va.\n        \\<lbrakk>v0 \\<in> V0; set pr \\<subseteq> Vr; va \\<in> Vl;\n         path (E \\<inter> Vr \\<times> UNIV) v0 pr va\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (force simp: neq_Nil_conv path_simps dest: P_CONV)"], ["proof (state)\nthis:\n  v0 \\<in> V0\n  set pr \\<subseteq> Vr\n  va \\<in> Vl\n  path (E \\<inter> Vr \\<times> UNIV) v0 pr va\n\ngoal (1 subgoal):\n 1. reconstruct_reach Vr Vl\n    \\<le> SPEC\n           (\\<lambda>(pr, va).\n               \\<exists>v0\\<in>V0. path E v0 pr va \\<and> va \\<in> Vl)", "hence 1: \"va \\<in> (E \\<inter> Vr \\<times> UNIV)\\<^sup>* `` V0\""], ["proof (prove)\nusing this:\n  v0 \\<in> V0\n  set pr \\<subseteq> Vr\n  va \\<in> Vl\n  path (E \\<inter> Vr \\<times> UNIV) v0 pr va\n\ngoal (1 subgoal):\n 1. va \\<in> (E \\<inter> Vr \\<times> UNIV)\\<^sup>* `` V0", "by (auto dest: path_is_rtrancl)"], ["proof (state)\nthis:\n  va \\<in> (E \\<inter> Vr \\<times> UNIV)\\<^sup>* `` V0\n\ngoal (1 subgoal):\n 1. reconstruct_reach Vr Vl\n    \\<le> SPEC\n           (\\<lambda>(pr, va).\n               \\<exists>v0\\<in>V0. path E v0 pr va \\<and> va \\<in> Vl)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. reconstruct_reach Vr Vl\n    \\<le> SPEC\n           (\\<lambda>(pr, va).\n               \\<exists>v0\\<in>V0. path E v0 pr va \\<and> va \\<in> Vl)", "using assms"], ["proof (prove)\nusing this:\n  ce_correct Vr Vl\n\ngoal (1 subgoal):\n 1. reconstruct_reach Vr Vl\n    \\<le> SPEC\n           (\\<lambda>(pr, va).\n               \\<exists>v0\\<in>V0. path E v0 pr va \\<and> va \\<in> Vl)", "unfolding reconstruct_reach_def"], ["proof (prove)\nusing this:\n  ce_correct Vr Vl\n\ngoal (1 subgoal):\n 1. find_path (E \\<inter> Vr \\<times> UNIV) V0\n     (\\<lambda>v. v \\<in> Vl) \\<bind>\n    (\\<lambda>res.\n        ASSERT (res \\<noteq> None) \\<bind> (\\<lambda>_. RETURN (the res)))\n    \\<le> SPEC\n           (\\<lambda>(pr, va).\n               \\<exists>v0\\<in>V0. path E v0 pr va \\<and> va \\<in> Vl)", "apply (refine_rcg refine_vcg order_trans[OF find_path_ex_rule])"], ["proof (prove)\ngoal (5 subgoals):\n 1. ce_correct Vr Vl \\<Longrightarrow> finite V0\n 2. ce_correct Vr Vl \\<Longrightarrow>\n    finite ((E \\<inter> Vr \\<times> UNIV)\\<^sup>* `` V0)\n 3. ce_correct Vr Vl \\<Longrightarrow>\n    \\<exists>v\\<in>(E \\<inter> Vr \\<times> UNIV)\\<^sup>* `` V0. v \\<in> Vl\n 4. \\<And>x.\n       \\<lbrakk>ce_correct Vr Vl;\n        \\<exists>p v.\n           x = Some (p, v) \\<and>\n           v \\<in> Vl \\<and>\n           (\\<forall>v\\<in>set p. v \\<notin> Vl) \\<and>\n           (\\<exists>u0\\<in>V0.\n               path (E \\<inter> Vr \\<times> UNIV) u0 p v)\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> None\n 5. \\<And>x x1 x2.\n       \\<lbrakk>ce_correct Vr Vl;\n        \\<exists>p v.\n           x = Some (p, v) \\<and>\n           v \\<in> Vl \\<and>\n           (\\<forall>v\\<in>set p. v \\<notin> Vl) \\<and>\n           (\\<exists>u0\\<in>V0. path (E \\<inter> Vr \\<times> UNIV) u0 p v);\n        x \\<noteq> None; the x = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v0\\<in>V0.\n                            path E v0 x1 x2 \\<and> x2 \\<in> Vl", "apply (clarsimp_all simp: FIN_aux finite_V0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ce_correct Vr Vl \\<Longrightarrow>\n    \\<exists>v\\<in>(E \\<inter> Vr \\<times> UNIV)\\<^sup>* `` V0. v \\<in> Vl\n 2. \\<And>x1 x2 u0.\n       \\<lbrakk>ce_correct Vr Vl; x2 \\<in> Vl;\n        \\<forall>v\\<in>set x1. v \\<notin> Vl; u0 \\<in> V0;\n        path (E \\<inter> Vr \\<times> UNIV) u0 x1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v0\\<in>V0. path E v0 x1 x2", "using \\<open>va\\<in>Vl\\<close> 1"], ["proof (prove)\nusing this:\n  va \\<in> Vl\n  va \\<in> (E \\<inter> Vr \\<times> UNIV)\\<^sup>* `` V0\n\ngoal (2 subgoals):\n 1. ce_correct Vr Vl \\<Longrightarrow>\n    \\<exists>v\\<in>(E \\<inter> Vr \\<times> UNIV)\\<^sup>* `` V0. v \\<in> Vl\n 2. \\<And>x1 x2 u0.\n       \\<lbrakk>ce_correct Vr Vl; x2 \\<in> Vl;\n        \\<forall>v\\<in>set x1. v \\<notin> Vl; u0 \\<in> V0;\n        path (E \\<inter> Vr \\<times> UNIV) u0 x1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v0\\<in>V0. path E v0 x1 x2", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 u0.\n       \\<lbrakk>ce_correct Vr Vl; x2 \\<in> Vl;\n        \\<forall>v\\<in>set x1. v \\<notin> Vl; u0 \\<in> V0;\n        path (E \\<inter> Vr \\<times> UNIV) u0 x1 x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v0\\<in>V0. path E v0 x1 x2", "apply (auto dest: path_mono[of \"E \\<inter> Vr \\<times> UNIV\" E, simplified]) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  reconstruct_reach Vr Vl\n  \\<le> SPEC\n         (\\<lambda>(pr, va).\n             \\<exists>v0\\<in>V0. path E v0 pr va \\<and> va \\<in> Vl)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"rec_loop_invar Vl va s \\<equiv> let (v,p,cS) = s in \n    va \\<in> E\\<^sup>*``V0 \\<and>\n    path E va p v \\<and>\n    cS = acc v \\<union> (\\<Union>(acc`set p)) \\<and>\n    va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl\""], ["", "definition reconstruct_lasso :: \"'Q set \\<Rightarrow> 'Q set \\<Rightarrow> ('Q list \\<times> 'Q list) nres\"\n    \\<comment> \\<open>Reconstruct lasso\\<close>\n    where \"reconstruct_lasso Vr Vl \\<equiv> do {\n    (pr,va) \\<leftarrow> reconstruct_reach Vr Vl;\n    \n    let cS_full = {0..<num_acc};\n    let E = E \\<inter> UNIV\\<times>Vl;\n    \n    (vd,p,_) \\<leftarrow> WHILEIT (rec_loop_invar Vl va) \n      (\\<lambda>(_,_,cS). cS \\<noteq> cS_full) \n      (\\<lambda>(v,p,cS). do {\n        ASSERT (\\<exists>v'. (v,v')\\<in>E\\<^sup>* \\<and> \\<not> (acc v' \\<subseteq> cS));\n        sr \\<leftarrow> find_path E {v} (\\<lambda>v. \\<not> (acc v \\<subseteq> cS));\n        ASSERT (sr \\<noteq> None);\n        let (p_seg,v) = the sr;\n        RETURN (v,p@p_seg,cS \\<union> acc v)\n      }) (va,[],acc va);\n\n    p_close_r \\<leftarrow> (if p=[] then \n        find_path1 E vd ((=) va)\n      else\n        find_path E {vd} ((=) va));\n\n    ASSERT (p_close_r \\<noteq> None);\n    let (p_close,_) = the p_close_r;\n\n    RETURN (pr, p@p_close)\n  }\""], ["", "lemma (in igb_fr_graph) reconstruct_lasso_correct:\n  assumes CEC: \"ce_correct Vr Vl\"\n  shows \"reconstruct_lasso Vr Vl \\<le> SPEC (is_lasso_prpl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "let ?E = \"E \\<inter> UNIV \\<times> Vl\""], ["proof (state)\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "have E_SS: \"E \\<inter> Vl \\<times> Vl \\<subseteq> ?E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Restr E Vl \\<subseteq> E \\<inter> UNIV \\<times> Vl", "by auto"], ["proof (state)\nthis:\n  Restr E Vl \\<subseteq> E \\<inter> UNIV \\<times> Vl\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "from CEC"], ["proof (chain)\npicking this:\n  ce_correct Vr Vl", "have\n    REACH: \"Vl \\<subseteq> E\\<^sup>*``V0\"\n    and CONN: \"Vl\\<times>Vl \\<subseteq> (E \\<inter> Vl\\<times>Vl)\\<^sup>*\"\n    and NONTRIV: \"Vl\\<times>Vl \\<inter> E \\<noteq> {}\"\n    and NES[simp]: \"Vl\\<noteq>{}\"\n    and ALL: \"\\<Union>(acc`Vl) = {0..<num_acc}\""], ["proof (prove)\nusing this:\n  ce_correct Vr Vl\n\ngoal (1 subgoal):\n 1. (Vl \\<subseteq> reachable &&&\n     Vl \\<times> Vl \\<subseteq> (Restr E Vl)\\<^sup>*) &&&\n    Vl \\<times> Vl \\<inter> E \\<noteq> {} &&&\n    Vl \\<noteq> {} &&& \\<Union> (acc ` Vl) = {0..<num_acc}", "unfolding ce_correct_def is_lasso_prpl_def"], ["proof (prove)\nusing this:\n  \\<exists>pr pl.\n     Vr \\<subseteq> reachable \\<and>\n     Vl \\<subseteq> reachable \\<and>\n     set pr \\<subseteq> Vr \\<and>\n     set pl \\<subseteq> Vl \\<and>\n     Vl \\<times> Vl \\<subseteq> (Restr E Vl)\\<^sup>* \\<and>\n     Vl \\<times> Vl \\<inter> E \\<noteq> {} \\<and>\n     is_lasso_prpl_pre (pr, pl) \\<and>\n     (\\<forall>i<num_acc. \\<exists>q\\<in>set (snd (pr, pl)). i \\<in> acc q)\n\ngoal (1 subgoal):\n 1. (Vl \\<subseteq> reachable &&&\n     Vl \\<times> Vl \\<subseteq> (Restr E Vl)\\<^sup>*) &&&\n    Vl \\<times> Vl \\<inter> E \\<noteq> {} &&&\n    Vl \\<noteq> {} &&& \\<Union> (acc ` Vl) = {0..<num_acc}", "apply clarsimp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b pr pl.\n       \\<lbrakk>Vr \\<subseteq> reachable; a \\<in> Vl; b \\<in> Vl;\n        Vl \\<subseteq> reachable; set pr \\<subseteq> Vr;\n        set pl \\<subseteq> Vl;\n        Vl \\<times> Vl \\<subseteq> (Restr E Vl)\\<^sup>*;\n        Vl \\<times> Vl \\<inter> E \\<noteq> {}; is_lasso_prpl_pre (pr, pl);\n        \\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> (Restr E Vl)\\<^sup>*\n 2. \\<And>pr pl.\n       \\<lbrakk>Vr \\<subseteq> reachable; Vl \\<subseteq> reachable;\n        set pr \\<subseteq> Vr; set pl \\<subseteq> Vl;\n        Vl \\<times> Vl \\<subseteq> (Restr E Vl)\\<^sup>*;\n        Vl \\<times> Vl \\<inter> E \\<noteq> {}; is_lasso_prpl_pre (pr, pl);\n        \\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (acc ` Vl) = {0..<num_acc}", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pr pl.\n       \\<lbrakk>Vr \\<subseteq> reachable; Vl \\<subseteq> reachable;\n        set pr \\<subseteq> Vr; set pl \\<subseteq> Vl;\n        Vl \\<times> Vl \\<subseteq> (Restr E Vl)\\<^sup>*;\n        Vl \\<times> Vl \\<inter> E \\<noteq> {}; is_lasso_prpl_pre (pr, pl);\n        \\<forall>i<num_acc. \\<exists>q\\<in>set pl. i \\<in> acc q\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (acc ` Vl) = {0..<num_acc}", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Vl \\<subseteq> reachable\n  Vl \\<times> Vl \\<subseteq> (Restr E Vl)\\<^sup>*\n  Vl \\<times> Vl \\<inter> E \\<noteq> {}\n  Vl \\<noteq> {}\n  \\<Union> (acc ` Vl) = {0..<num_acc}\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "define term_rel\n    where \"term_rel = (inv_image (finite_psupset {0..<num_acc}) (\\<lambda>(_::'Q,_::'Q list,cS). cS))\""], ["proof (state)\nthis:\n  term_rel =\n  inv_image (finite_psupset {0..<num_acc}) (\\<lambda>(uu_, uu_, cS). cS)\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "hence WF: \"wf term_rel\""], ["proof (prove)\nusing this:\n  term_rel =\n  inv_image (finite_psupset {0..<num_acc}) (\\<lambda>(uu_, uu_, cS). cS)\n\ngoal (1 subgoal):\n 1. wf term_rel", "by simp"], ["proof (state)\nthis:\n  wf term_rel\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "{"], ["proof (state)\nthis:\n  wf term_rel\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "fix va"], ["proof (state)\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "assume \"va \\<in> Vl\""], ["proof (state)\nthis:\n  va \\<in> Vl\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "hence \"rec_loop_invar Vl va (va, [], acc va)\""], ["proof (prove)\nusing this:\n  va \\<in> Vl\n\ngoal (1 subgoal):\n 1. rec_loop_invar Vl va (va, [], acc va)", "unfolding rec_loop_invar_def"], ["proof (prove)\nusing this:\n  va \\<in> Vl\n\ngoal (1 subgoal):\n 1. let (v, p, cS) = (va, [], acc va)\n    in va \\<in> reachable \\<and>\n       path E va p v \\<and>\n       cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n       va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl", "using REACH"], ["proof (prove)\nusing this:\n  va \\<in> Vl\n  Vl \\<subseteq> reachable\n\ngoal (1 subgoal):\n 1. let (v, p, cS) = (va, [], acc va)\n    in va \\<in> reachable \\<and>\n       path E va p v \\<and>\n       cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n       va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl", "by auto"], ["proof (state)\nthis:\n  rec_loop_invar Vl va (va, [], acc va)\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "}"], ["proof (state)\nthis:\n  ?va6 \\<in> Vl \\<Longrightarrow>\n  rec_loop_invar Vl ?va6 (?va6, [], acc ?va6)\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "note INVAR_INITIAL = this"], ["proof (state)\nthis:\n  ?va6 \\<in> Vl \\<Longrightarrow>\n  rec_loop_invar Vl ?va6 (?va6, [], acc ?va6)\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "{"], ["proof (state)\nthis:\n  ?va6 \\<in> Vl \\<Longrightarrow>\n  rec_loop_invar Vl ?va6 (?va6, [], acc ?va6)\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "fix v p cS va"], ["proof (state)\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "assume \"rec_loop_invar Vl va (v, p, cS)\""], ["proof (state)\nthis:\n  rec_loop_invar Vl va (v, p, cS)\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "hence \"finite ((?E)\\<^sup>* `` {v})\""], ["proof (prove)\nusing this:\n  rec_loop_invar Vl va (v, p, cS)\n\ngoal (1 subgoal):\n 1. finite ((E \\<inter> UNIV \\<times> Vl)\\<^sup>* `` {v})", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_loop_invar Vl va (v, p, cS) \\<Longrightarrow>\n    finite ((E \\<inter> UNIV \\<times> Vl)\\<^sup>* `` {v})", "apply (rule finite_subset[where B=\"E\\<^sup>*``V0\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. rec_loop_invar Vl va (v, p, cS) \\<Longrightarrow>\n    (E \\<inter> UNIV \\<times> Vl)\\<^sup>* `` {v} \\<subseteq> reachable\n 2. rec_loop_invar Vl va (v, p, cS) \\<Longrightarrow> finite reachable", "unfolding rec_loop_invar_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. let (v, p, cS) = (v, p, cS)\n    in va \\<in> reachable \\<and>\n       path E va p v \\<and>\n       cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n       va \\<in> Vl \\<and>\n       v \\<in> Vl \\<and> set p \\<subseteq> Vl \\<Longrightarrow>\n    (E \\<inter> UNIV \\<times> Vl)\\<^sup>* `` {v} \\<subseteq> reachable\n 2. let (v, p, cS) = (v, p, cS)\n    in va \\<in> reachable \\<and>\n       path E va p v \\<and>\n       cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n       va \\<in> Vl \\<and>\n       v \\<in> Vl \\<and> set p \\<subseteq> Vl \\<Longrightarrow>\n    finite reachable", "using REACH"], ["proof (prove)\nusing this:\n  Vl \\<subseteq> reachable\n\ngoal (2 subgoals):\n 1. let (v, p, cS) = (v, p, cS)\n    in va \\<in> reachable \\<and>\n       path E va p v \\<and>\n       cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n       va \\<in> Vl \\<and>\n       v \\<in> Vl \\<and> set p \\<subseteq> Vl \\<Longrightarrow>\n    (E \\<inter> UNIV \\<times> Vl)\\<^sup>* `` {v} \\<subseteq> reachable\n 2. let (v, p, cS) = (v, p, cS)\n    in va \\<in> reachable \\<and>\n       path E va p v \\<and>\n       cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n       va \\<in> Vl \\<and>\n       v \\<in> Vl \\<and> set p \\<subseteq> Vl \\<Longrightarrow>\n    finite reachable", "apply (clarsimp_all dest!: path_is_rtrancl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xb.\n       \\<lbrakk>Vl \\<subseteq> reachable;\n        (v, x) \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>*;\n        (xb, va) \\<in> E\\<^sup>*; xb \\<in> V0; (va, v) \\<in> E\\<^sup>*;\n        cS = acc v \\<union> \\<Union> (acc ` set p); va \\<in> Vl; v \\<in> Vl;\n        set p \\<subseteq> Vl\\<rbrakk>\n       \\<Longrightarrow> x \\<in> reachable", "apply (drule rtrancl_mono_mp[where U=\"?E\" and V=E, rotated], (auto) [])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xb.\n       \\<lbrakk>Vl \\<subseteq> reachable; (xb, va) \\<in> E\\<^sup>*;\n        xb \\<in> V0; (va, v) \\<in> E\\<^sup>*;\n        cS = acc v \\<union> \\<Union> (acc ` set p); va \\<in> Vl; v \\<in> Vl;\n        set p \\<subseteq> Vl; (v, x) \\<in> E\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> x \\<in> reachable", "by (metis rev_ImageI rtrancl_trans)"], ["proof (state)\nthis:\n  finite ((E \\<inter> UNIV \\<times> Vl)\\<^sup>* `` {v})\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "}"], ["proof (state)\nthis:\n  rec_loop_invar Vl ?va6 (?v6, ?p6, ?cS6) \\<Longrightarrow>\n  finite ((E \\<inter> UNIV \\<times> Vl)\\<^sup>* `` {?v6})\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "note FIN1 = this"], ["proof (state)\nthis:\n  rec_loop_invar Vl ?va6 (?v6, ?p6, ?cS6) \\<Longrightarrow>\n  finite ((E \\<inter> UNIV \\<times> Vl)\\<^sup>* `` {?v6})\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "{"], ["proof (state)\nthis:\n  rec_loop_invar Vl ?va6 (?v6, ?p6, ?cS6) \\<Longrightarrow>\n  finite ((E \\<inter> UNIV \\<times> Vl)\\<^sup>* `` {?v6})\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "fix va v :: 'Q and p cS"], ["proof (state)\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "assume INV: \"rec_loop_invar Vl va (v,p,cS)\"\n      and NC: \"cS \\<noteq> {0..<num_acc}\""], ["proof (state)\nthis:\n  rec_loop_invar Vl va (v, p, cS)\n  cS \\<noteq> {0..<num_acc}\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "from NC INV"], ["proof (chain)\npicking this:\n  cS \\<noteq> {0..<num_acc}\n  rec_loop_invar Vl va (v, p, cS)", "obtain i where \"i<num_acc\" \"i\\<notin>cS\""], ["proof (prove)\nusing this:\n  cS \\<noteq> {0..<num_acc}\n  rec_loop_invar Vl va (v, p, cS)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < num_acc; i \\<notin> cS\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding rec_loop_invar_def"], ["proof (prove)\nusing this:\n  cS \\<noteq> {0..<num_acc}\n  let (v, p, cS) = (v, p, cS)\n  in va \\<in> reachable \\<and>\n     path E va p v \\<and>\n     cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n     va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < num_acc; i \\<notin> cS\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto blast"], ["proof (state)\nthis:\n  i < num_acc\n  i \\<notin> cS\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "with ALL"], ["proof (chain)\npicking this:\n  \\<Union> (acc ` Vl) = {0..<num_acc}\n  i < num_acc\n  i \\<notin> cS", "obtain v' where \"v'\\<in>Vl\" \"\\<not> acc v' \\<subseteq> cS\""], ["proof (prove)\nusing this:\n  \\<Union> (acc ` Vl) = {0..<num_acc}\n  i < num_acc\n  i \\<notin> cS\n\ngoal (1 subgoal):\n 1. (\\<And>v'.\n        \\<lbrakk>v' \\<in> Vl; \\<not> acc v' \\<subseteq> cS\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp (smt UN_iff atLeastLessThan_iff le0 subsetCE)"], ["proof (state)\nthis:\n  v' \\<in> Vl\n  \\<not> acc v' \\<subseteq> cS\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "moreover"], ["proof (state)\nthis:\n  v' \\<in> Vl\n  \\<not> acc v' \\<subseteq> cS\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "with CONN INV"], ["proof (chain)\npicking this:\n  Vl \\<times> Vl \\<subseteq> (Restr E Vl)\\<^sup>*\n  rec_loop_invar Vl va (v, p, cS)\n  v' \\<in> Vl\n  \\<not> acc v' \\<subseteq> cS", "have \"(v,v')\\<in>(E \\<inter> Vl \\<times> Vl)\\<^sup>*\""], ["proof (prove)\nusing this:\n  Vl \\<times> Vl \\<subseteq> (Restr E Vl)\\<^sup>*\n  rec_loop_invar Vl va (v, p, cS)\n  v' \\<in> Vl\n  \\<not> acc v' \\<subseteq> cS\n\ngoal (1 subgoal):\n 1. (v, v') \\<in> (Restr E Vl)\\<^sup>*", "unfolding rec_loop_invar_def"], ["proof (prove)\nusing this:\n  Vl \\<times> Vl \\<subseteq> (Restr E Vl)\\<^sup>*\n  let (v, p, cS) = (v, p, cS)\n  in va \\<in> reachable \\<and>\n     path E va p v \\<and>\n     cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n     va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl\n  v' \\<in> Vl\n  \\<not> acc v' \\<subseteq> cS\n\ngoal (1 subgoal):\n 1. (v, v') \\<in> (Restr E Vl)\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (v, v') \\<in> (Restr E Vl)\\<^sup>*\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "hence \"(v,v')\\<in>?E\\<^sup>*\""], ["proof (prove)\nusing this:\n  (v, v') \\<in> (Restr E Vl)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (v, v') \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>*", "using rtrancl_mono_mp[OF E_SS]"], ["proof (prove)\nusing this:\n  (v, v') \\<in> (Restr E Vl)\\<^sup>*\n  ?x \\<in> (Restr E Vl)\\<^sup>* \\<Longrightarrow>\n  ?x \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (v, v') \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>*", "by blast"], ["proof (state)\nthis:\n  (v, v') \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>*\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "ultimately"], ["proof (chain)\npicking this:\n  v' \\<in> Vl\n  \\<not> acc v' \\<subseteq> cS\n  (v, v') \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>*", "have \"\\<exists>v'. (v,v')\\<in>(?E)\\<^sup>* \\<and> \\<not> acc v' \\<subseteq> cS\""], ["proof (prove)\nusing this:\n  v' \\<in> Vl\n  \\<not> acc v' \\<subseteq> cS\n  (v, v') \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>v'.\n       (v, v') \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>* \\<and>\n       \\<not> acc v' \\<subseteq> cS", "by auto"], ["proof (state)\nthis:\n  \\<exists>v'.\n     (v, v') \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>* \\<and>\n     \\<not> acc v' \\<subseteq> cS\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "}"], ["proof (state)\nthis:\n  \\<lbrakk>rec_loop_invar Vl ?va6 (?v6, ?p6, ?cS6);\n   ?cS6 \\<noteq> {0..<num_acc}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v'.\n                       (?v6, v')\n                       \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>* \\<and>\n                       \\<not> acc v' \\<subseteq> ?cS6\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "note ASSERT1 = this"], ["proof (state)\nthis:\n  \\<lbrakk>rec_loop_invar Vl ?va6 (?v6, ?p6, ?cS6);\n   ?cS6 \\<noteq> {0..<num_acc}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v'.\n                       (?v6, v')\n                       \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>* \\<and>\n                       \\<not> acc v' \\<subseteq> ?cS6\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "{"], ["proof (state)\nthis:\n  \\<lbrakk>rec_loop_invar Vl ?va6 (?v6, ?p6, ?cS6);\n   ?cS6 \\<noteq> {0..<num_acc}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v'.\n                       (?v6, v')\n                       \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>* \\<and>\n                       \\<not> acc v' \\<subseteq> ?cS6\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "fix va v p cS v' p'"], ["proof (state)\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "assume \"rec_loop_invar Vl va (v, p, cS)\"\n    and \"path (?E) v p' v'\"\n    and \"\\<not> (acc v' \\<subseteq> cS)\"\n    and \"\\<forall>v\\<in>set p'. acc v \\<subseteq> cS\""], ["proof (state)\nthis:\n  rec_loop_invar Vl va (v, p, cS)\n  path (E \\<inter> UNIV \\<times> Vl) v p' v'\n  \\<not> acc v' \\<subseteq> cS\n  \\<forall>v\\<in>set p'. acc v \\<subseteq> cS\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "hence \"rec_loop_invar Vl va (v', p@p', cS \\<union> acc v')\""], ["proof (prove)\nusing this:\n  rec_loop_invar Vl va (v, p, cS)\n  path (E \\<inter> UNIV \\<times> Vl) v p' v'\n  \\<not> acc v' \\<subseteq> cS\n  \\<forall>v\\<in>set p'. acc v \\<subseteq> cS\n\ngoal (1 subgoal):\n 1. rec_loop_invar Vl va (v', p @ p', cS \\<union> acc v')", "unfolding rec_loop_invar_def"], ["proof (prove)\nusing this:\n  let (v, p, cS) = (v, p, cS)\n  in va \\<in> reachable \\<and>\n     path E va p v \\<and>\n     cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n     va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl\n  path (E \\<inter> UNIV \\<times> Vl) v p' v'\n  \\<not> acc v' \\<subseteq> cS\n  \\<forall>v\\<in>set p'. acc v \\<subseteq> cS\n\ngoal (1 subgoal):\n 1. let (v, p, cS) = (v', p @ p', cS \\<union> acc v')\n    in va \\<in> reachable \\<and>\n       path E va p v \\<and>\n       cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n       va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>va \\<in> reachable \\<and>\n             path E va p v \\<and>\n             cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n             va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl;\n     path (E \\<inter> UNIV \\<times> Vl) v p' v';\n     \\<not> acc v' \\<subseteq> acc v \\<union> \\<Union> (acc ` set p);\n     \\<forall>va\\<in>set p'.\n        acc va \\<subseteq> acc v \\<union> \\<Union> (acc ` set p)\\<rbrakk>\n    \\<Longrightarrow> path E va (p @ p') v' \\<and>\n                      acc v \\<union> \\<Union> (acc ` set p) \\<union>\n                      acc v' =\n                      acc v' \\<union>\n                      (\\<Union> (acc ` set p) \\<union>\n                       \\<Union> (acc ` set p')) \\<and>\n                      v' \\<in> Vl \\<and> set p' \\<subseteq> Vl", "apply (intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>va \\<in> reachable \\<and>\n             path E va p v \\<and>\n             cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n             va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl;\n     path (E \\<inter> UNIV \\<times> Vl) v p' v';\n     \\<not> acc v' \\<subseteq> acc v \\<union> \\<Union> (acc ` set p);\n     \\<forall>va\\<in>set p'.\n        acc va \\<subseteq> acc v \\<union> \\<Union> (acc ` set p)\\<rbrakk>\n    \\<Longrightarrow> path E va (p @ p') v'\n 2. \\<lbrakk>va \\<in> reachable \\<and>\n             path E va p v \\<and>\n             cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n             va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl;\n     path (E \\<inter> UNIV \\<times> Vl) v p' v';\n     \\<not> acc v' \\<subseteq> acc v \\<union> \\<Union> (acc ` set p);\n     \\<forall>va\\<in>set p'.\n        acc va \\<subseteq> acc v \\<union> \\<Union> (acc ` set p)\\<rbrakk>\n    \\<Longrightarrow> acc v \\<union> \\<Union> (acc ` set p) \\<union>\n                      acc v' =\n                      acc v' \\<union>\n                      (\\<Union> (acc ` set p) \\<union>\n                       \\<Union> (acc ` set p'))\n 3. \\<lbrakk>va \\<in> reachable \\<and>\n             path E va p v \\<and>\n             cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n             va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl;\n     path (E \\<inter> UNIV \\<times> Vl) v p' v';\n     \\<not> acc v' \\<subseteq> acc v \\<union> \\<Union> (acc ` set p);\n     \\<forall>va\\<in>set p'.\n        acc va \\<subseteq> acc v \\<union> \\<Union> (acc ` set p)\\<rbrakk>\n    \\<Longrightarrow> v' \\<in> Vl\n 4. \\<lbrakk>va \\<in> reachable \\<and>\n             path E va p v \\<and>\n             cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n             va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl;\n     path (E \\<inter> UNIV \\<times> Vl) v p' v';\n     \\<not> acc v' \\<subseteq> acc v \\<union> \\<Union> (acc ` set p);\n     \\<forall>va\\<in>set p'.\n        acc va \\<subseteq> acc v \\<union> \\<Union> (acc ` set p)\\<rbrakk>\n    \\<Longrightarrow> set p' \\<subseteq> Vl", "apply (auto simp: path_simps dest: path_mono[of \"?E\" E, simplified]) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>va \\<in> reachable \\<and>\n             path E va p v \\<and>\n             cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n             va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl;\n     path (E \\<inter> UNIV \\<times> Vl) v p' v';\n     \\<not> acc v' \\<subseteq> acc v \\<union> \\<Union> (acc ` set p);\n     \\<forall>va\\<in>set p'.\n        acc va \\<subseteq> acc v \\<union> \\<Union> (acc ` set p)\\<rbrakk>\n    \\<Longrightarrow> acc v \\<union> \\<Union> (acc ` set p) \\<union>\n                      acc v' =\n                      acc v' \\<union>\n                      (\\<Union> (acc ` set p) \\<union>\n                       \\<Union> (acc ` set p'))\n 2. \\<lbrakk>va \\<in> reachable \\<and>\n             path E va p v \\<and>\n             cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n             va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl;\n     path (E \\<inter> UNIV \\<times> Vl) v p' v';\n     \\<not> acc v' \\<subseteq> acc v \\<union> \\<Union> (acc ` set p);\n     \\<forall>va\\<in>set p'.\n        acc va \\<subseteq> acc v \\<union> \\<Union> (acc ` set p)\\<rbrakk>\n    \\<Longrightarrow> v' \\<in> Vl\n 3. \\<lbrakk>va \\<in> reachable \\<and>\n             path E va p v \\<and>\n             cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n             va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl;\n     path (E \\<inter> UNIV \\<times> Vl) v p' v';\n     \\<not> acc v' \\<subseteq> acc v \\<union> \\<Union> (acc ` set p);\n     \\<forall>va\\<in>set p'.\n        acc va \\<subseteq> acc v \\<union> \\<Union> (acc ` set p)\\<rbrakk>\n    \\<Longrightarrow> set p' \\<subseteq> Vl", "apply (cases p')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>va \\<in> reachable \\<and>\n             path E va p v \\<and>\n             cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n             va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl;\n     path (E \\<inter> UNIV \\<times> Vl) v p' v';\n     \\<not> acc v' \\<subseteq> acc v \\<union> \\<Union> (acc ` set p);\n     \\<forall>va\\<in>set p'.\n        acc va \\<subseteq> acc v \\<union> \\<Union> (acc ` set p);\n     p' = []\\<rbrakk>\n    \\<Longrightarrow> acc v \\<union> \\<Union> (acc ` set p) \\<union>\n                      acc v' =\n                      acc v' \\<union>\n                      (\\<Union> (acc ` set p) \\<union>\n                       \\<Union> (acc ` set p'))\n 2. \\<And>a list.\n       \\<lbrakk>va \\<in> reachable \\<and>\n                path E va p v \\<and>\n                cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n                va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl;\n        path (E \\<inter> UNIV \\<times> Vl) v p' v';\n        \\<not> acc v' \\<subseteq> acc v \\<union> \\<Union> (acc ` set p);\n        \\<forall>va\\<in>set p'.\n           acc va \\<subseteq> acc v \\<union> \\<Union> (acc ` set p);\n        p' = a # list\\<rbrakk>\n       \\<Longrightarrow> acc v \\<union> \\<Union> (acc ` set p) \\<union>\n                         acc v' =\n                         acc v' \\<union>\n                         (\\<Union> (acc ` set p) \\<union>\n                          \\<Union> (acc ` set p'))\n 3. \\<lbrakk>va \\<in> reachable \\<and>\n             path E va p v \\<and>\n             cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n             va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl;\n     path (E \\<inter> UNIV \\<times> Vl) v p' v';\n     \\<not> acc v' \\<subseteq> acc v \\<union> \\<Union> (acc ` set p);\n     \\<forall>va\\<in>set p'.\n        acc va \\<subseteq> acc v \\<union> \\<Union> (acc ` set p)\\<rbrakk>\n    \\<Longrightarrow> v' \\<in> Vl\n 4. \\<lbrakk>va \\<in> reachable \\<and>\n             path E va p v \\<and>\n             cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n             va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl;\n     path (E \\<inter> UNIV \\<times> Vl) v p' v';\n     \\<not> acc v' \\<subseteq> acc v \\<union> \\<Union> (acc ` set p);\n     \\<forall>va\\<in>set p'.\n        acc va \\<subseteq> acc v \\<union> \\<Union> (acc ` set p)\\<rbrakk>\n    \\<Longrightarrow> set p' \\<subseteq> Vl", "apply (auto simp: path_simps) [2]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>va \\<in> reachable \\<and>\n             path E va p v \\<and>\n             cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n             va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl;\n     path (E \\<inter> UNIV \\<times> Vl) v p' v';\n     \\<not> acc v' \\<subseteq> acc v \\<union> \\<Union> (acc ` set p);\n     \\<forall>va\\<in>set p'.\n        acc va \\<subseteq> acc v \\<union> \\<Union> (acc ` set p)\\<rbrakk>\n    \\<Longrightarrow> v' \\<in> Vl\n 2. \\<lbrakk>va \\<in> reachable \\<and>\n             path E va p v \\<and>\n             cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n             va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl;\n     path (E \\<inter> UNIV \\<times> Vl) v p' v';\n     \\<not> acc v' \\<subseteq> acc v \\<union> \\<Union> (acc ` set p);\n     \\<forall>va\\<in>set p'.\n        acc va \\<subseteq> acc v \\<union> \\<Union> (acc ` set p)\\<rbrakk>\n    \\<Longrightarrow> set p' \\<subseteq> Vl", "apply (cases p' rule: rev_cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>va \\<in> reachable \\<and>\n             path E va p v \\<and>\n             cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n             va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl;\n     path (E \\<inter> UNIV \\<times> Vl) v p' v';\n     \\<not> acc v' \\<subseteq> acc v \\<union> \\<Union> (acc ` set p);\n     \\<forall>va\\<in>set p'.\n        acc va \\<subseteq> acc v \\<union> \\<Union> (acc ` set p);\n     p' = []\\<rbrakk>\n    \\<Longrightarrow> v' \\<in> Vl\n 2. \\<And>ys y.\n       \\<lbrakk>va \\<in> reachable \\<and>\n                path E va p v \\<and>\n                cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n                va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl;\n        path (E \\<inter> UNIV \\<times> Vl) v p' v';\n        \\<not> acc v' \\<subseteq> acc v \\<union> \\<Union> (acc ` set p);\n        \\<forall>va\\<in>set p'.\n           acc va \\<subseteq> acc v \\<union> \\<Union> (acc ` set p);\n        p' = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> Vl\n 3. \\<lbrakk>va \\<in> reachable \\<and>\n             path E va p v \\<and>\n             cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n             va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl;\n     path (E \\<inter> UNIV \\<times> Vl) v p' v';\n     \\<not> acc v' \\<subseteq> acc v \\<union> \\<Union> (acc ` set p);\n     \\<forall>va\\<in>set p'.\n        acc va \\<subseteq> acc v \\<union> \\<Union> (acc ` set p)\\<rbrakk>\n    \\<Longrightarrow> set p' \\<subseteq> Vl", "apply (auto simp: path_simps) [2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>va \\<in> reachable \\<and>\n             path E va p v \\<and>\n             cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n             va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl;\n     path (E \\<inter> UNIV \\<times> Vl) v p' v';\n     \\<not> acc v' \\<subseteq> acc v \\<union> \\<Union> (acc ` set p);\n     \\<forall>va\\<in>set p'.\n        acc va \\<subseteq> acc v \\<union> \\<Union> (acc ` set p)\\<rbrakk>\n    \\<Longrightarrow> set p' \\<subseteq> Vl", "apply (erule path_set_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>va \\<in> reachable \\<and>\n             path E va p v \\<and>\n             cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n             va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl;\n     \\<not> acc v' \\<subseteq> acc v \\<union> \\<Union> (acc ` set p);\n     \\<forall>va\\<in>set p'.\n        acc va \\<subseteq> acc v \\<union> \\<Union> (acc ` set p)\\<rbrakk>\n    \\<Longrightarrow> v \\<in> Vl\n 2. \\<lbrakk>va \\<in> reachable \\<and>\n             path E va p v \\<and>\n             cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n             va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl;\n     \\<not> acc v' \\<subseteq> acc v \\<union> \\<Union> (acc ` set p);\n     \\<forall>va\\<in>set p'.\n        acc va \\<subseteq> acc v \\<union> \\<Union> (acc ` set p)\\<rbrakk>\n    \\<Longrightarrow> (E \\<inter> UNIV \\<times> Vl) `` Vl \\<subseteq> Vl", "apply auto [2]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  rec_loop_invar Vl va (v', p @ p', cS \\<union> acc v')\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "}"], ["proof (state)\nthis:\n  \\<lbrakk>rec_loop_invar Vl ?va6 (?v6, ?p6, ?cS6);\n   path (E \\<inter> UNIV \\<times> Vl) ?v6 ?p'6 ?v'6;\n   \\<not> acc ?v'6 \\<subseteq> ?cS6;\n   \\<forall>v\\<in>set ?p'6. acc v \\<subseteq> ?cS6\\<rbrakk>\n  \\<Longrightarrow> rec_loop_invar Vl ?va6\n                     (?v'6, ?p6 @ ?p'6, ?cS6 \\<union> acc ?v'6)\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "note INV_PRES = this"], ["proof (state)\nthis:\n  \\<lbrakk>rec_loop_invar Vl ?va6 (?v6, ?p6, ?cS6);\n   path (E \\<inter> UNIV \\<times> Vl) ?v6 ?p'6 ?v'6;\n   \\<not> acc ?v'6 \\<subseteq> ?cS6;\n   \\<forall>v\\<in>set ?p'6. acc v \\<subseteq> ?cS6\\<rbrakk>\n  \\<Longrightarrow> rec_loop_invar Vl ?va6\n                     (?v'6, ?p6 @ ?p'6, ?cS6 \\<union> acc ?v'6)\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "{"], ["proof (state)\nthis:\n  \\<lbrakk>rec_loop_invar Vl ?va6 (?v6, ?p6, ?cS6);\n   path (E \\<inter> UNIV \\<times> Vl) ?v6 ?p'6 ?v'6;\n   \\<not> acc ?v'6 \\<subseteq> ?cS6;\n   \\<forall>v\\<in>set ?p'6. acc v \\<subseteq> ?cS6\\<rbrakk>\n  \\<Longrightarrow> rec_loop_invar Vl ?va6\n                     (?v'6, ?p6 @ ?p'6, ?cS6 \\<union> acc ?v'6)\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "fix va v p cS v' p'"], ["proof (state)\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "assume \"rec_loop_invar Vl va (v, p, cS)\"\n      and \"path ?E v p' v'\"\n      and \"\\<not> (acc v' \\<subseteq> cS)\"\n      and \"\\<forall>v\\<in>set p'. acc v \\<subseteq> cS\""], ["proof (state)\nthis:\n  rec_loop_invar Vl va (v, p, cS)\n  path (E \\<inter> UNIV \\<times> Vl) v p' v'\n  \\<not> acc v' \\<subseteq> cS\n  \\<forall>v\\<in>set p'. acc v \\<subseteq> cS\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "hence \"((v', p@p', cS \\<union> acc v'), (v,p,cS)) \\<in> term_rel\""], ["proof (prove)\nusing this:\n  rec_loop_invar Vl va (v, p, cS)\n  path (E \\<inter> UNIV \\<times> Vl) v p' v'\n  \\<not> acc v' \\<subseteq> cS\n  \\<forall>v\\<in>set p'. acc v \\<subseteq> cS\n\ngoal (1 subgoal):\n 1. ((v', p @ p', cS \\<union> acc v'), v, p, cS) \\<in> term_rel", "unfolding term_rel_def rec_loop_invar_def"], ["proof (prove)\nusing this:\n  let (v, p, cS) = (v, p, cS)\n  in va \\<in> reachable \\<and>\n     path E va p v \\<and>\n     cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n     va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl\n  path (E \\<inter> UNIV \\<times> Vl) v p' v'\n  \\<not> acc v' \\<subseteq> cS\n  \\<forall>v\\<in>set p'. acc v \\<subseteq> cS\n\ngoal (1 subgoal):\n 1. ((v', p @ p', cS \\<union> acc v'), v, p, cS)\n    \\<in> inv_image (finite_psupset {0..<num_acc})\n           (\\<lambda>(uu_, uu_, cS). cS)", "by (auto simp: finite_psupset_def)"], ["proof (state)\nthis:\n  ((v', p @ p', cS \\<union> acc v'), v, p, cS) \\<in> term_rel\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "}"], ["proof (state)\nthis:\n  \\<lbrakk>rec_loop_invar Vl ?va6 (?v6, ?p6, ?cS6);\n   path (E \\<inter> UNIV \\<times> Vl) ?v6 ?p'6 ?v'6;\n   \\<not> acc ?v'6 \\<subseteq> ?cS6;\n   \\<forall>v\\<in>set ?p'6. acc v \\<subseteq> ?cS6\\<rbrakk>\n  \\<Longrightarrow> ((?v'6, ?p6 @ ?p'6, ?cS6 \\<union> acc ?v'6), ?v6, ?p6,\n                     ?cS6)\n                    \\<in> term_rel\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "note VAR = this"], ["proof (state)\nthis:\n  \\<lbrakk>rec_loop_invar Vl ?va6 (?v6, ?p6, ?cS6);\n   path (E \\<inter> UNIV \\<times> Vl) ?v6 ?p'6 ?v'6;\n   \\<not> acc ?v'6 \\<subseteq> ?cS6;\n   \\<forall>v\\<in>set ?p'6. acc v \\<subseteq> ?cS6\\<rbrakk>\n  \\<Longrightarrow> ((?v'6, ?p6 @ ?p'6, ?cS6 \\<union> acc ?v'6), ?v6, ?p6,\n                     ?cS6)\n                    \\<in> term_rel\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "have CONN1: \"Vl \\<times> Vl \\<subseteq> (?E)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Vl \\<times> Vl \\<subseteq> (E \\<inter> UNIV \\<times> Vl)\\<^sup>+", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> Vl; b \\<in> Vl\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>+", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> Vl; b \\<in> Vl\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>+", "assume \"a\\<in>Vl\" \"b\\<in>Vl\""], ["proof (state)\nthis:\n  a \\<in> Vl\n  b \\<in> Vl\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> Vl; b \\<in> Vl\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>+", "from NONTRIV"], ["proof (chain)\npicking this:\n  Vl \\<times> Vl \\<inter> E \\<noteq> {}", "obtain u v where E: \"(u,v)\\<in>(E \\<inter> Vl\\<times>Vl)\""], ["proof (prove)\nusing this:\n  Vl \\<times> Vl \\<inter> E \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>u v.\n        (u, v) \\<in> Restr E Vl \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (u, v) \\<in> Restr E Vl\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> Vl; b \\<in> Vl\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>+", "from CONN \\<open>a\\<in>Vl\\<close> E"], ["proof (chain)\npicking this:\n  Vl \\<times> Vl \\<subseteq> (Restr E Vl)\\<^sup>*\n  a \\<in> Vl\n  (u, v) \\<in> Restr E Vl", "have \"(a,u)\\<in>(E\\<inter>Vl\\<times>Vl)\\<^sup>*\""], ["proof (prove)\nusing this:\n  Vl \\<times> Vl \\<subseteq> (Restr E Vl)\\<^sup>*\n  a \\<in> Vl\n  (u, v) \\<in> Restr E Vl\n\ngoal (1 subgoal):\n 1. (a, u) \\<in> (Restr E Vl)\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (a, u) \\<in> (Restr E Vl)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> Vl; b \\<in> Vl\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>+", "also"], ["proof (state)\nthis:\n  (a, u) \\<in> (Restr E Vl)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> Vl; b \\<in> Vl\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>+", "note E"], ["proof (state)\nthis:\n  (u, v) \\<in> Restr E Vl\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> Vl; b \\<in> Vl\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>+", "also (rtrancl_into_trancl1)"], ["proof (state)\nthis:\n  (u, v) \\<in> Restr E Vl\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> Vl; b \\<in> Vl\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>+", "from CONN \\<open>b\\<in>Vl\\<close> E"], ["proof (chain)\npicking this:\n  Vl \\<times> Vl \\<subseteq> (Restr E Vl)\\<^sup>*\n  b \\<in> Vl\n  (u, v) \\<in> Restr E Vl", "have \"(v,b)\\<in>(E\\<inter>Vl\\<times>Vl)\\<^sup>*\""], ["proof (prove)\nusing this:\n  Vl \\<times> Vl \\<subseteq> (Restr E Vl)\\<^sup>*\n  b \\<in> Vl\n  (u, v) \\<in> Restr E Vl\n\ngoal (1 subgoal):\n 1. (v, b) \\<in> (Restr E Vl)\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (v, b) \\<in> (Restr E Vl)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> Vl; b \\<in> Vl\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>+", "finally"], ["proof (chain)\npicking this:\n  (a, b) \\<in> (Restr E Vl)\\<^sup>+", "show \"(a,b)\\<in>(?E)\\<^sup>+\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> (Restr E Vl)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>+", "using trancl_mono[OF _ E_SS]"], ["proof (prove)\nusing this:\n  (a, b) \\<in> (Restr E Vl)\\<^sup>+\n  ?p \\<in> (Restr E Vl)\\<^sup>+ \\<Longrightarrow>\n  ?p \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (a, b) \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  (a, b) \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Vl \\<times> Vl \\<subseteq> (E \\<inter> UNIV \\<times> Vl)\\<^sup>+\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "{"], ["proof (state)\nthis:\n  Vl \\<times> Vl \\<subseteq> (E \\<inter> UNIV \\<times> Vl)\\<^sup>+\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "fix va v p cS"], ["proof (state)\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "assume \"rec_loop_invar Vl va (v, p, cS)\""], ["proof (state)\nthis:\n  rec_loop_invar Vl va (v, p, cS)\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "hence \"(v,va) \\<in> (?E)\\<^sup>+\""], ["proof (prove)\nusing this:\n  rec_loop_invar Vl va (v, p, cS)\n\ngoal (1 subgoal):\n 1. (v, va) \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>+", "unfolding rec_loop_invar_def"], ["proof (prove)\nusing this:\n  let (v, p, cS) = (v, p, cS)\n  in va \\<in> reachable \\<and>\n     path E va p v \\<and>\n     cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n     va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl\n\ngoal (1 subgoal):\n 1. (v, va) \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>+", "using CONN1"], ["proof (prove)\nusing this:\n  let (v, p, cS) = (v, p, cS)\n  in va \\<in> reachable \\<and>\n     path E va p v \\<and>\n     cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n     va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl\n  Vl \\<times> Vl \\<subseteq> (E \\<inter> UNIV \\<times> Vl)\\<^sup>+\n\ngoal (1 subgoal):\n 1. (v, va) \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  (v, va) \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>+\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "}"], ["proof (state)\nthis:\n  rec_loop_invar Vl ?va6 (?v6, ?p6, ?cS6) \\<Longrightarrow>\n  (?v6, ?va6) \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>+\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "note CLOSE1 = this"], ["proof (state)\nthis:\n  rec_loop_invar Vl ?va6 (?v6, ?p6, ?cS6) \\<Longrightarrow>\n  (?v6, ?va6) \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>+\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "{"], ["proof (state)\nthis:\n  rec_loop_invar Vl ?va6 (?v6, ?p6, ?cS6) \\<Longrightarrow>\n  (?v6, ?va6) \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>+\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "fix va v p cS"], ["proof (state)\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "assume \"rec_loop_invar Vl va (v, p, cS)\""], ["proof (state)\nthis:\n  rec_loop_invar Vl va (v, p, cS)\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "hence \"(v,va) \\<in> (?E)\\<^sup>*\""], ["proof (prove)\nusing this:\n  rec_loop_invar Vl va (v, p, cS)\n\ngoal (1 subgoal):\n 1. (v, va) \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>*", "unfolding rec_loop_invar_def"], ["proof (prove)\nusing this:\n  let (v, p, cS) = (v, p, cS)\n  in va \\<in> reachable \\<and>\n     path E va p v \\<and>\n     cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n     va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl\n\ngoal (1 subgoal):\n 1. (v, va) \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>*", "using CONN rtrancl_mono[OF E_SS]"], ["proof (prove)\nusing this:\n  let (v, p, cS) = (v, p, cS)\n  in va \\<in> reachable \\<and>\n     path E va p v \\<and>\n     cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n     va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl\n  Vl \\<times> Vl \\<subseteq> (Restr E Vl)\\<^sup>*\n  (Restr E Vl)\\<^sup>* \\<subseteq> (E \\<inter> UNIV \\<times> Vl)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (v, va) \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (v, va) \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>*\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "}"], ["proof (state)\nthis:\n  rec_loop_invar Vl ?va6 (?v6, ?p6, ?cS6) \\<Longrightarrow>\n  (?v6, ?va6) \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>*\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "note CLOSE2 = this"], ["proof (state)\nthis:\n  rec_loop_invar Vl ?va6 (?v6, ?p6, ?cS6) \\<Longrightarrow>\n  (?v6, ?va6) \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>*\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "{"], ["proof (state)\nthis:\n  rec_loop_invar Vl ?va6 (?v6, ?p6, ?cS6) \\<Longrightarrow>\n  (?v6, ?va6) \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>*\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "fix \"pr\" vd pl va v0"], ["proof (state)\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "assume \"rec_loop_invar Vl va (vd, [], {0..<num_acc})\" \"va \\<in> Vl\" \"v0 \\<in> V0\"\n      \"path E v0 pr va\" \"pl \\<noteq> []\" \"path ?E vd pl va\""], ["proof (state)\nthis:\n  rec_loop_invar Vl va (vd, [], {0..<num_acc})\n  va \\<in> Vl\n  v0 \\<in> V0\n  path E v0 pr va\n  pl \\<noteq> []\n  path (E \\<inter> UNIV \\<times> Vl) vd pl va\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "hence \"is_lasso_prpl (pr, pl)\""], ["proof (prove)\nusing this:\n  rec_loop_invar Vl va (vd, [], {0..<num_acc})\n  va \\<in> Vl\n  v0 \\<in> V0\n  path E v0 pr va\n  pl \\<noteq> []\n  path (E \\<inter> UNIV \\<times> Vl) vd pl va\n\ngoal (1 subgoal):\n 1. is_lasso_prpl (pr, pl)", "unfolding is_lasso_prpl_def is_lasso_prpl_pre_def rec_loop_invar_def"], ["proof (prove)\nusing this:\n  let (v, p, cS) = (vd, [], {0..<num_acc})\n  in va \\<in> reachable \\<and>\n     path E va p v \\<and>\n     cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n     va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl\n  va \\<in> Vl\n  v0 \\<in> V0\n  path E v0 pr va\n  pl \\<noteq> []\n  path (E \\<inter> UNIV \\<times> Vl) vd pl va\n\ngoal (1 subgoal):\n 1. (case (pr, pl) of\n     (pr, pl) \\<Rightarrow>\n       \\<exists>v0 va.\n          v0 \\<in> V0 \\<and>\n          pl \\<noteq> [] \\<and>\n          path E v0 pr va \\<and> path E va pl va) \\<and>\n    (\\<forall>i<num_acc. \\<exists>q\\<in>set (snd (pr, pl)). i \\<in> acc q)", "by (auto simp: neq_Nil_conv path_simps\n        dest!: path_mono[of \"?E\" E, simplified]) []"], ["proof (state)\nthis:\n  is_lasso_prpl (pr, pl)\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "}"], ["proof (state)\nthis:\n  \\<lbrakk>rec_loop_invar Vl ?va6 (?vd6, [], {0..<num_acc}); ?va6 \\<in> Vl;\n   ?v0.6 \\<in> V0; path E ?v0.6 ?pr6 ?va6; ?pl6 \\<noteq> [];\n   path (E \\<inter> UNIV \\<times> Vl) ?vd6 ?pl6 ?va6\\<rbrakk>\n  \\<Longrightarrow> is_lasso_prpl (?pr6, ?pl6)\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "note INV_POST1 = this"], ["proof (state)\nthis:\n  \\<lbrakk>rec_loop_invar Vl ?va6 (?vd6, [], {0..<num_acc}); ?va6 \\<in> Vl;\n   ?v0.6 \\<in> V0; path E ?v0.6 ?pr6 ?va6; ?pl6 \\<noteq> [];\n   path (E \\<inter> UNIV \\<times> Vl) ?vd6 ?pl6 ?va6\\<rbrakk>\n  \\<Longrightarrow> is_lasso_prpl (?pr6, ?pl6)\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "{"], ["proof (state)\nthis:\n  \\<lbrakk>rec_loop_invar Vl ?va6 (?vd6, [], {0..<num_acc}); ?va6 \\<in> Vl;\n   ?v0.6 \\<in> V0; path E ?v0.6 ?pr6 ?va6; ?pl6 \\<noteq> [];\n   path (E \\<inter> UNIV \\<times> Vl) ?vd6 ?pl6 ?va6\\<rbrakk>\n  \\<Longrightarrow> is_lasso_prpl (?pr6, ?pl6)\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "fix va v p p' \"pr\" v0"], ["proof (state)\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "assume INV: \"rec_loop_invar Vl va (v,p,{0..<num_acc})\" \n      and 1: \"p\\<noteq>[]\" \"path ?E v p' va\"\n      and PR: \"v0\\<in>V0\" \"path E v0 pr va\""], ["proof (state)\nthis:\n  rec_loop_invar Vl va (v, p, {0..<num_acc})\n  p \\<noteq> []\n  path (E \\<inter> UNIV \\<times> Vl) v p' va\n  v0 \\<in> V0\n  path E v0 pr va\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "from INV"], ["proof (chain)\npicking this:\n  rec_loop_invar Vl va (v, p, {0..<num_acc})", "have \"\\<forall>i<num_acc. \\<exists>q\\<in>insert v (set p). i \\<in> acc q\""], ["proof (prove)\nusing this:\n  rec_loop_invar Vl va (v, p, {0..<num_acc})\n\ngoal (1 subgoal):\n 1. \\<forall>i<num_acc. \\<exists>q\\<in>insert v (set p). i \\<in> acc q", "unfolding rec_loop_invar_def"], ["proof (prove)\nusing this:\n  let (v, p, cS) = (v, p, {0..<num_acc})\n  in va \\<in> reachable \\<and>\n     path E va p v \\<and>\n     cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n     va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl\n\ngoal (1 subgoal):\n 1. \\<forall>i<num_acc. \\<exists>q\\<in>insert v (set p). i \\<in> acc q", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<num_acc. \\<exists>q\\<in>insert v (set p). i \\<in> acc q\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "moreover"], ["proof (state)\nthis:\n  \\<forall>i<num_acc. \\<exists>q\\<in>insert v (set p). i \\<in> acc q\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "from INV 1"], ["proof (chain)\npicking this:\n  rec_loop_invar Vl va (v, p, {0..<num_acc})\n  p \\<noteq> []\n  path (E \\<inter> UNIV \\<times> Vl) v p' va", "have \"insert v (set p) \\<subseteq> set p \\<union> set p'\""], ["proof (prove)\nusing this:\n  rec_loop_invar Vl va (v, p, {0..<num_acc})\n  p \\<noteq> []\n  path (E \\<inter> UNIV \\<times> Vl) v p' va\n\ngoal (1 subgoal):\n 1. insert v (set p) \\<subseteq> set p \\<union> set p'", "unfolding rec_loop_invar_def"], ["proof (prove)\nusing this:\n  let (v, p, cS) = (v, p, {0..<num_acc})\n  in va \\<in> reachable \\<and>\n     path E va p v \\<and>\n     cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n     va \\<in> Vl \\<and> v \\<in> Vl \\<and> set p \\<subseteq> Vl\n  p \\<noteq> []\n  path (E \\<inter> UNIV \\<times> Vl) v p' va\n\ngoal (1 subgoal):\n 1. insert v (set p) \\<subseteq> set p \\<union> set p'", "apply (cases p, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>let (v, p, cS) = (v, p, {0..<num_acc})\n                in va \\<in> reachable \\<and>\n                   path E va p v \\<and>\n                   cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n                   va \\<in> Vl \\<and>\n                   v \\<in> Vl \\<and> set p \\<subseteq> Vl;\n        p \\<noteq> []; path (E \\<inter> UNIV \\<times> Vl) v p' va;\n        p = a # list\\<rbrakk>\n       \\<Longrightarrow> insert v (set p) \\<subseteq> set p \\<union> set p'", "apply (cases p')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list.\n       \\<lbrakk>let (v, p, cS) = (v, p, {0..<num_acc})\n                in va \\<in> reachable \\<and>\n                   path E va p v \\<and>\n                   cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n                   va \\<in> Vl \\<and>\n                   v \\<in> Vl \\<and> set p \\<subseteq> Vl;\n        p \\<noteq> []; path (E \\<inter> UNIV \\<times> Vl) v p' va;\n        p = a # list; p' = []\\<rbrakk>\n       \\<Longrightarrow> insert v (set p) \\<subseteq> set p \\<union> set p'\n 2. \\<And>a list aa lista.\n       \\<lbrakk>let (v, p, cS) = (v, p, {0..<num_acc})\n                in va \\<in> reachable \\<and>\n                   path E va p v \\<and>\n                   cS = acc v \\<union> \\<Union> (acc ` set p) \\<and>\n                   va \\<in> Vl \\<and>\n                   v \\<in> Vl \\<and> set p \\<subseteq> Vl;\n        p \\<noteq> []; path (E \\<inter> UNIV \\<times> Vl) v p' va;\n        p = a # list; p' = aa # lista\\<rbrakk>\n       \\<Longrightarrow> insert v (set p) \\<subseteq> set p \\<union> set p'", "apply (auto simp: path_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  insert v (set p) \\<subseteq> set p \\<union> set p'\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>i<num_acc. \\<exists>q\\<in>insert v (set p). i \\<in> acc q\n  insert v (set p) \\<subseteq> set p \\<union> set p'", "have ACC: \"\\<forall>i<num_acc. \\<exists>q\\<in>set p \\<union> set p'. i \\<in> acc q\""], ["proof (prove)\nusing this:\n  \\<forall>i<num_acc. \\<exists>q\\<in>insert v (set p). i \\<in> acc q\n  insert v (set p) \\<subseteq> set p \\<union> set p'\n\ngoal (1 subgoal):\n 1. \\<forall>i<num_acc. \\<exists>q\\<in>set p \\<union> set p'. i \\<in> acc q", "by blast"], ["proof (state)\nthis:\n  \\<forall>i<num_acc. \\<exists>q\\<in>set p \\<union> set p'. i \\<in> acc q\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "from INV 1"], ["proof (chain)\npicking this:\n  rec_loop_invar Vl va (v, p, {0..<num_acc})\n  p \\<noteq> []\n  path (E \\<inter> UNIV \\<times> Vl) v p' va", "have PL: \"path E va (p @ p') va\""], ["proof (prove)\nusing this:\n  rec_loop_invar Vl va (v, p, {0..<num_acc})\n  p \\<noteq> []\n  path (E \\<inter> UNIV \\<times> Vl) v p' va\n\ngoal (1 subgoal):\n 1. path E va (p @ p') va", "by (auto simp: rec_loop_invar_def path_simps \n        dest!: path_mono[of \"?E\" E, simplified]) []"], ["proof (state)\nthis:\n  path E va (p @ p') va\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "have \"is_lasso_prpl (pr,p@p')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_lasso_prpl (pr, p @ p')", "unfolding is_lasso_prpl_def is_lasso_prpl_pre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (pr, p @ p') of\n     (pr, pl) \\<Rightarrow>\n       \\<exists>v0 va.\n          v0 \\<in> V0 \\<and>\n          pl \\<noteq> [] \\<and>\n          path E v0 pr va \\<and> path E va pl va) \\<and>\n    (\\<forall>i<num_acc.\n        \\<exists>q\\<in>set (snd (pr, p @ p')). i \\<in> acc q)", "apply (clarsimp simp: ACC)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v0.\n       v0 \\<in> V0 \\<and>\n       (p = [] \\<longrightarrow> p' \\<noteq> []) \\<and>\n       (\\<exists>va. path E v0 pr va \\<and> path E va (p @ p') va)", "using PR PL \\<open>p\\<noteq>[]\\<close>"], ["proof (prove)\nusing this:\n  v0 \\<in> V0\n  path E v0 pr va\n  path E va (p @ p') va\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>v0.\n       v0 \\<in> V0 \\<and>\n       (p = [] \\<longrightarrow> p' \\<noteq> []) \\<and>\n       (\\<exists>va. path E v0 pr va \\<and> path E va (p @ p') va)", "by auto"], ["proof (state)\nthis:\n  is_lasso_prpl (pr, p @ p')\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "}"], ["proof (state)\nthis:\n  \\<lbrakk>rec_loop_invar Vl ?va6 (?v6, ?p6, {0..<num_acc});\n   ?p6 \\<noteq> []; path (E \\<inter> UNIV \\<times> Vl) ?v6 ?p'6 ?va6;\n   ?v0.6 \\<in> V0; path E ?v0.6 ?pr6 ?va6\\<rbrakk>\n  \\<Longrightarrow> is_lasso_prpl (?pr6, ?p6 @ ?p'6)\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "note INV_POST2 = this"], ["proof (state)\nthis:\n  \\<lbrakk>rec_loop_invar Vl ?va6 (?v6, ?p6, {0..<num_acc});\n   ?p6 \\<noteq> []; path (E \\<inter> UNIV \\<times> Vl) ?v6 ?p'6 ?va6;\n   ?v0.6 \\<in> V0; path E ?v0.6 ?pr6 ?va6\\<rbrakk>\n  \\<Longrightarrow> is_lasso_prpl (?pr6, ?p6 @ ?p'6)\n\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl", "unfolding reconstruct_lasso_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. reconstruct_reach Vr Vl \\<bind>\n    (\\<lambda>(pr, va).\n        let cS_full = {0..<num_acc}; E = E \\<inter> UNIV \\<times> Vl\n        in WHILE\\<^sub>T\\<^bsup>rec_loop_invar Vl va\\<^esup>\n            (\\<lambda>(uu_, uu_, cS). cS \\<noteq> cS_full)\n            (\\<lambda>(v, p, cS).\n                ASSERT\n                 (\\<exists>v'.\n                     (v, v') \\<in> E\\<^sup>* \\<and>\n                     \\<not> acc v' \\<subseteq> cS) \\<bind>\n                (\\<lambda>_.\n                    find_path E {v}\n                     (\\<lambda>v. \\<not> acc v \\<subseteq> cS) \\<bind>\n                    (\\<lambda>sr.\n                        ASSERT (sr \\<noteq> None) \\<bind>\n                        (\\<lambda>_.\n                            let (p_seg, v) = the sr\n                            in RETURN (v, p @ p_seg, cS \\<union> acc v)))))\n            (va, [], acc va) \\<bind>\n           (\\<lambda>(vd, p, uu_).\n               (if p = [] then find_path1 E vd ((=) va)\n                else find_path E {vd} ((=) va)) \\<bind>\n               (\\<lambda>p_close_r.\n                   ASSERT (p_close_r \\<noteq> None) \\<bind>\n                   (\\<lambda>_.\n                       let (p_close, uu_) = the p_close_r\n                       in RETURN (pr, p @ p_close)))))\n    \\<le> SPEC is_lasso_prpl", "apply (refine_rcg \n      WF\n      order_trans[OF reconstruct_reach_correct]\n      order_trans[OF find_path_ex_rule]\n      order_trans[OF find_path1_ex_rule]\n      refine_vcg \n    )"], ["proof (prove)\ngoal (18 subgoals):\n 1. ce_correct Vr Vl\n 2. \\<And>x a b.\n       \\<lbrakk>case x of\n                (pr, va) \\<Rightarrow>\n                  \\<exists>v0\\<in>V0. path E v0 pr va \\<and> va \\<in> Vl;\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> rec_loop_invar Vl b (b, [], acc b)\n 3. \\<And>x a b s aa ba ab bb.\n       \\<lbrakk>case x of\n                (pr, va) \\<Rightarrow>\n                  \\<exists>v0\\<in>V0. path E v0 pr va \\<and> va \\<in> Vl;\n        x = (a, b); rec_loop_invar Vl b s;\n        case s of (uu_, uua_, cS) \\<Rightarrow> cS \\<noteq> {0..<num_acc};\n        s = (aa, ba); ba = (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'.\n                            (aa, v')\n                            \\<in> (E \\<inter>\n                                   UNIV \\<times> Vl)\\<^sup>* \\<and>\n                            \\<not> acc v' \\<subseteq> bb\n 4. \\<And>x a b s aa ba ab bb.\n       \\<lbrakk>case x of\n                (pr, va) \\<Rightarrow>\n                  \\<exists>v0\\<in>V0. path E v0 pr va \\<and> va \\<in> Vl;\n        x = (a, b); rec_loop_invar Vl b s;\n        case s of (uu_, uua_, cS) \\<Rightarrow> cS \\<noteq> {0..<num_acc};\n        s = (aa, ba); ba = (ab, bb);\n        \\<exists>v'.\n           (aa, v') \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>* \\<and>\n           \\<not> acc v' \\<subseteq> bb\\<rbrakk>\n       \\<Longrightarrow> finite {aa}\n 5. \\<And>x a b s aa ba ab bb.\n       \\<lbrakk>case x of\n                (pr, va) \\<Rightarrow>\n                  \\<exists>v0\\<in>V0. path E v0 pr va \\<and> va \\<in> Vl;\n        x = (a, b); rec_loop_invar Vl b s;\n        case s of (uu_, uua_, cS) \\<Rightarrow> cS \\<noteq> {0..<num_acc};\n        s = (aa, ba); ba = (ab, bb);\n        \\<exists>v'.\n           (aa, v') \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>* \\<and>\n           \\<not> acc v' \\<subseteq> bb\\<rbrakk>\n       \\<Longrightarrow> finite\n                          ((E \\<inter> UNIV \\<times> Vl)\\<^sup>* `` {aa})\n 6. \\<And>x a b s aa ba ab bb.\n       \\<lbrakk>case x of\n                (pr, va) \\<Rightarrow>\n                  \\<exists>v0\\<in>V0. path E v0 pr va \\<and> va \\<in> Vl;\n        x = (a, b); rec_loop_invar Vl b s;\n        case s of (uu_, uua_, cS) \\<Rightarrow> cS \\<noteq> {0..<num_acc};\n        s = (aa, ba); ba = (ab, bb);\n        \\<exists>v'.\n           (aa, v') \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>* \\<and>\n           \\<not> acc v' \\<subseteq> bb\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<in>(E \\<inter>\n   UNIV \\<times> Vl)\\<^sup>* ``\n  {aa}.\n                            \\<not> acc v \\<subseteq> bb\n 7. \\<And>x a b s aa ba ab bb xa.\n       \\<lbrakk>case x of\n                (pr, va) \\<Rightarrow>\n                  \\<exists>v0\\<in>V0. path E v0 pr va \\<and> va \\<in> Vl;\n        x = (a, b); rec_loop_invar Vl b s;\n        case s of (uu_, uua_, cS) \\<Rightarrow> cS \\<noteq> {0..<num_acc};\n        s = (aa, ba); ba = (ab, bb);\n        \\<exists>v'.\n           (aa, v') \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>* \\<and>\n           \\<not> acc v' \\<subseteq> bb;\n        \\<exists>p v.\n           xa = Some (p, v) \\<and>\n           \\<not> acc v \\<subseteq> bb \\<and>\n           (\\<forall>v\\<in>set p. \\<not> \\<not> acc v \\<subseteq> bb) \\<and>\n           (\\<exists>u0\\<in>{aa}.\n               path (E \\<inter> UNIV \\<times> Vl) u0 p v)\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> None\n 8. \\<And>x a b s aa ba ab bb xa ac bc.\n       \\<lbrakk>case x of\n                (pr, va) \\<Rightarrow>\n                  \\<exists>v0\\<in>V0. path E v0 pr va \\<and> va \\<in> Vl;\n        x = (a, b); rec_loop_invar Vl b s;\n        case s of (uu_, uua_, cS) \\<Rightarrow> cS \\<noteq> {0..<num_acc};\n        s = (aa, ba); ba = (ab, bb);\n        \\<exists>v'.\n           (aa, v') \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>* \\<and>\n           \\<not> acc v' \\<subseteq> bb;\n        \\<exists>p v.\n           xa = Some (p, v) \\<and>\n           \\<not> acc v \\<subseteq> bb \\<and>\n           (\\<forall>v\\<in>set p. \\<not> \\<not> acc v \\<subseteq> bb) \\<and>\n           (\\<exists>u0\\<in>{aa}.\n               path (E \\<inter> UNIV \\<times> Vl) u0 p v);\n        xa \\<noteq> None; the xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> rec_loop_invar Vl b\n                          (bc, ab @ ac, bb \\<union> acc bc)\n 9. \\<And>x a b s aa ba ab bb xa ac bc.\n       \\<lbrakk>case x of\n                (pr, va) \\<Rightarrow>\n                  \\<exists>v0\\<in>V0. path E v0 pr va \\<and> va \\<in> Vl;\n        x = (a, b); rec_loop_invar Vl b s;\n        case s of (uu_, uua_, cS) \\<Rightarrow> cS \\<noteq> {0..<num_acc};\n        s = (aa, ba); ba = (ab, bb);\n        \\<exists>v'.\n           (aa, v') \\<in> (E \\<inter> UNIV \\<times> Vl)\\<^sup>* \\<and>\n           \\<not> acc v' \\<subseteq> bb;\n        \\<exists>p v.\n           xa = Some (p, v) \\<and>\n           \\<not> acc v \\<subseteq> bb \\<and>\n           (\\<forall>v\\<in>set p. \\<not> \\<not> acc v \\<subseteq> bb) \\<and>\n           (\\<exists>u0\\<in>{aa}.\n               path (E \\<inter> UNIV \\<times> Vl) u0 p v);\n        xa \\<noteq> None; the xa = (ac, bc)\\<rbrakk>\n       \\<Longrightarrow> ((bc, ab @ ac, bb \\<union> acc bc), s)\n                         \\<in> term_rel\n 10. \\<And>x a b s aa ba ab bb.\n        \\<lbrakk>case x of\n                 (pr, va) \\<Rightarrow>\n                   \\<exists>v0\\<in>V0. path E v0 pr va \\<and> va \\<in> Vl;\n         x = (a, b); rec_loop_invar Vl b s;\n         \\<not> (case s of\n                 (uu_, uua_, cS) \\<Rightarrow> cS \\<noteq> {0..<num_acc});\n         s = (aa, ba); ba = (ab, bb); ab = []\\<rbrakk>\n        \\<Longrightarrow> finite\n                           ((E \\<inter> UNIV \\<times> Vl)\\<^sup>* `` {aa})\nA total of 18 subgoals...", "apply (vc_solve \n      del: subsetI\n      solve: ASSERT1 INV_PRES asm_rl VAR CLOSE1 CLOSE2 INV_POST1 INV_POST2\n      simp: INVAR_INITIAL FIN1 CEC)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  reconstruct_lasso Vr Vl \\<le> SPEC is_lasso_prpl\n\ngoal:\nNo subgoals!", "qed"], ["", "definition find_lasso where \"find_lasso \\<equiv> do {\n  ce \\<leftarrow> find_ce_spec;\n  case ce of \n    None \\<Rightarrow> RETURN None\n  | Some (Vr,Vl) \\<Rightarrow> do {\n      l \\<leftarrow> reconstruct_lasso Vr Vl;\n      RETURN (Some l)\n    }\n}\""], ["", "lemma (in igb_fr_graph) find_lasso_correct: \"find_lasso \\<le> find_lasso_spec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_lasso \\<le> find_lasso_spec", "unfolding find_lasso_spec_def find_lasso_def find_ce_spec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. SPEC\n     (\\<lambda>r.\n         case r of\n         None \\<Rightarrow> \\<forall>prpl. \\<not> is_lasso_prpl prpl\n         | Some (x, xa) \\<Rightarrow> ce_correct x xa) \\<bind>\n    (\\<lambda>ce.\n        case ce of None \\<Rightarrow> RETURN None\n        | Some (Vr, Vl) \\<Rightarrow>\n            reconstruct_lasso Vr Vl \\<bind> (\\<lambda>l. RETURN (Some l)))\n    \\<le> SPEC\n           (\\<lambda>r.\n               case r of\n               None \\<Rightarrow> \\<forall>prpl. \\<not> is_lasso_prpl prpl\n               | Some x \\<Rightarrow> is_lasso_prpl x)", "apply (refine_rcg refine_vcg order_trans[OF reconstruct_lasso_correct])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>case x of\n                None \\<Rightarrow> \\<forall>prpl. \\<not> is_lasso_prpl prpl\n                | Some (x, xa) \\<Rightarrow> ce_correct x xa;\n        x = None\\<rbrakk>\n       \\<Longrightarrow> case None of\n                         None \\<Rightarrow>\n                           \\<forall>prpl. \\<not> is_lasso_prpl prpl\n                         | Some x \\<Rightarrow> is_lasso_prpl x\n 2. \\<And>x xa a b.\n       \\<lbrakk>case x of\n                None \\<Rightarrow> \\<forall>prpl. \\<not> is_lasso_prpl prpl\n                | Some (x, xa) \\<Rightarrow> ce_correct x xa;\n        x = Some xa; xa = (a, b)\\<rbrakk>\n       \\<Longrightarrow> ce_correct a b\n 3. \\<And>x xa a b xb.\n       \\<lbrakk>case x of\n                None \\<Rightarrow> \\<forall>prpl. \\<not> is_lasso_prpl prpl\n                | Some (x, xa) \\<Rightarrow> ce_correct x xa;\n        x = Some xa; xa = (a, b); is_lasso_prpl xb\\<rbrakk>\n       \\<Longrightarrow> case Some xb of\n                         None \\<Rightarrow>\n                           \\<forall>prpl. \\<not> is_lasso_prpl prpl\n                         | Some x \\<Rightarrow> is_lasso_prpl x", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}