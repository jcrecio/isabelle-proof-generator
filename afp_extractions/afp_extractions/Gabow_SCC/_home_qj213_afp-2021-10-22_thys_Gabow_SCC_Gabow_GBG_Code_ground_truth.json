{"file_name": "/home/qj213/afp-2021-10-22/thys/Gabow_SCC/Gabow_GBG_Code.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Gabow_SCC", "problem_names": ["lemma locale_this: \"impl_lasso_loc mrel node_rel node_eq_impl node_hash_impl node_def_hash_size G_impl G\"", "lemma [autoref_op_pat]: \n      \"goinitial_impl \\<equiv> OP goinitial_impl\"\n      \"ginitial_impl \\<equiv> OP ginitial_impl\"\n      \"gpath_is_empty_impl \\<equiv> OP gpath_is_empty_impl\"\n      \"gselect_edge_impl \\<equiv> OP gselect_edge_impl\"\n      \"gis_on_stack_impl \\<equiv> OP gis_on_stack_impl\"\n      \"gcollapse_impl \\<equiv> OP gcollapse_impl\"\n      \"last_is_acc_impl \\<equiv> OP last_is_acc_impl\"\n      \"ce_impl \\<equiv> OP ce_impl\"\n      \"gis_done_impl \\<equiv> OP gis_done_impl\"\n      \"gpush_impl \\<equiv> OP gpush_impl\"\n      \"gpop_impl \\<equiv> OP gpop_impl\"\n      \"goBrk_impl \\<equiv> OP goBrk_impl\" \n      \"gto_outer_impl \\<equiv> OP gto_outer_impl\"\n      \"go_is_done_impl \\<equiv> OP go_is_done_impl\"\n      \"is_done_oimpl \\<equiv> OP is_done_oimpl\"\n      \"go_is_no_brk_impl \\<equiv> OP go_is_no_brk_impl\"", "lemmas [autoref_rules] = goinitial_code.refine[OF locale_this]", "lemmas [autoref_rules] = ginitial_code.refine[OF locale_this]", "lemmas [autoref_rules] = gpath_is_empty_code.refine[OF locale_this]", "lemmas [autoref_rules] = goBrk_code.refine[OF locale_this]", "lemmas [autoref_rules] = gto_outer_code.refine[OF locale_this]", "lemmas [autoref_rules] = go_is_done_code.refine[OF locale_this]", "lemmas [autoref_rules] = go_is_no_brk_code.refine[OF locale_this]", "lemmas [autoref_rules] = gselect_edge_code.refine[OF locale_this]", "lemmas [autoref_rules] = gis_on_stack_code.refine[OF locale_this]", "lemmas [autoref_rules] = gcollapse_code.refine[OF locale_this]", "lemmas [autoref_rules] = last_is_acc_code.refine[OF locale_this]", "lemmas [autoref_rules] = ce_code.refine[OF locale_this]", "lemmas [autoref_rules] = gis_done_code.refine[OF locale_this]", "lemmas [autoref_rules] = gpush_code.refine[OF locale_this]", "lemmas [autoref_rules] = gpop_code.refine[OF locale_this]", "lemmas [autoref_rules] = find_ce_code.refine[OF locale_this]", "lemmas [refine_transfer] = find_ce_tr.refine[OF locale_this]", "lemma [autoref_op_pat]: \n      \"find_ce_spec \\<equiv> OP find_ce_spec\"", "theorem find_ce_autoref[autoref_rules]:\n    \\<comment> \\<open>Main Correctness theorem (inside locale)\\<close>\n    shows \"(find_ce_code node_eq_impl node_hash_impl node_def_hash_size G_impl, find_ce_spec) \\<in> \\<langle>ce_rel node_rel\\<rangle>nres_rel\"", "lemma [autoref_op_pat]: \n      \"reconstruct_reach \\<equiv> OP reconstruct_reach\"\n      \"reconstruct_lasso \\<equiv> OP reconstruct_lasso\"", "lemmas [autoref_rules] = reconstruct_reach_code.refine[OF locale_this]", "lemmas [autoref_rules] = reconstruct_lasso_code.refine[OF locale_this]", "lemmas [refine_transfer] = reconstruct_lasso_tr.refine[OF locale_this]", "lemmas [autoref_rules] = find_lasso_code.refine[OF locale_this]", "lemmas [refine_transfer] = find_lasso_tr.refine[OF locale_this]", "theorem find_lasso_tr_correct:\n  \\<comment> \\<open>Correctness theorem for the constant we extracted to SML\\<close>\n  fixes Re and node_rel :: \"('vi \\<times> 'v) set\"\n  assumes A: \"(G_impl,G)\\<in>igbg_impl_rel_ext Re node_rel\"\n      and node_eq_refine: \"(node_eq_impl, (=)) \\<in> node_rel \\<rightarrow> node_rel \\<rightarrow> bool_rel\"\n      and node_hash: \"is_bounded_hashcode node_rel node_eq_impl node_hash_impl\"\n      and node_hash_def_size: \"(is_valid_def_hm_size TYPE('vi) node_def_hash_size)\"\n  \n  assumes B: \"igb_fr_graph G\"\n  shows \"RETURN (find_lasso_tr node_eq_impl node_hash_impl node_def_hash_size G_impl) \n  \\<le> \\<Down>(fl_rel node_rel) (igb_graph.find_lasso_spec G)\"", "lemma [autoref_op_pat]: \"igb_graph.find_lasso_spec \\<equiv> op_find_lasso_spec\"", "lemma [autoref_itype]: \n  \"op_find_lasso_spec \n    ::\\<^sub>i i_igbg Ie I \\<rightarrow>\\<^sub>i \\<langle>\\<langle>\\<langle>\\<langle>I\\<rangle>\\<^sub>ii_list, \\<langle>I\\<rangle>\\<^sub>ii_list\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_option\\<rangle>\\<^sub>ii_nres\"", "lemma find_lasso_spec_autoref[autoref_rules_raw]:\n  fixes Re and node_rel :: \"('vi \\<times> 'v) set\" \n  assumes GR: \"SIDE_PRECOND (igb_fr_graph G)\"\n  assumes eq: \"GEN_OP node_eq_impl (=) (node_rel\\<rightarrow>node_rel\\<rightarrow>bool_rel)\"\n  assumes hash: \"SIDE_GEN_ALGO (is_bounded_hashcode node_rel node_eq_impl node_hash_impl)\"\n  assumes hash_dsz: \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('vi) node_def_hash_size)\"\n  assumes Gi: \"(G_impl,G)\\<in>igbg_impl_rel_ext Re node_rel\"\n  shows \"(RETURN (find_lasso_tr node_eq_impl node_hash_impl node_def_hash_size G_impl), \n    (OP op_find_lasso_spec \n      ::: igbg_impl_rel_ext Re node_rel \\<rightarrow> \\<langle>fl_rel node_rel\\<rangle>nres_rel)$G) \\<in> \\<langle>fl_rel node_rel\\<rangle>nres_rel\""], "translations": [["", "lemma locale_this: \"impl_lasso_loc mrel node_rel node_eq_impl node_hash_impl node_def_hash_size G_impl G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. impl_lasso_loc mrel node_rel node_eq_impl node_hash_impl\n     node_def_hash_size G_impl G", "by unfold_locales"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma [autoref_op_pat]: \n      \"goinitial_impl \\<equiv> OP goinitial_impl\"\n      \"ginitial_impl \\<equiv> OP ginitial_impl\"\n      \"gpath_is_empty_impl \\<equiv> OP gpath_is_empty_impl\"\n      \"gselect_edge_impl \\<equiv> OP gselect_edge_impl\"\n      \"gis_on_stack_impl \\<equiv> OP gis_on_stack_impl\"\n      \"gcollapse_impl \\<equiv> OP gcollapse_impl\"\n      \"last_is_acc_impl \\<equiv> OP last_is_acc_impl\"\n      \"ce_impl \\<equiv> OP ce_impl\"\n      \"gis_done_impl \\<equiv> OP gis_done_impl\"\n      \"gpush_impl \\<equiv> OP gpush_impl\"\n      \"gpop_impl \\<equiv> OP gpop_impl\"\n      \"goBrk_impl \\<equiv> OP goBrk_impl\" \n      \"gto_outer_impl \\<equiv> OP gto_outer_impl\"\n      \"go_is_done_impl \\<equiv> OP go_is_done_impl\"\n      \"is_done_oimpl \\<equiv> OP is_done_oimpl\"\n      \"go_is_no_brk_impl \\<equiv> OP go_is_no_brk_impl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((((goinitial_impl \\<equiv> OP goinitial_impl) &&&\n       ginitial_impl \\<equiv> OP ginitial_impl) &&&\n      (gpath_is_empty_impl \\<equiv> OP gpath_is_empty_impl) &&&\n      gselect_edge_impl \\<equiv> OP gselect_edge_impl) &&&\n     ((gis_on_stack_impl \\<equiv> OP gis_on_stack_impl) &&&\n      gcollapse_impl \\<equiv> OP gcollapse_impl) &&&\n     (last_is_acc_impl \\<equiv> OP last_is_acc_impl) &&&\n     ce_impl \\<equiv> OP ce_impl) &&&\n    (((gis_done_impl \\<equiv> OP gis_done_impl) &&&\n      gpush_impl \\<equiv> OP gpush_impl) &&&\n     (gpop_impl \\<equiv> OP gpop_impl) &&&\n     goBrk_impl \\<equiv> OP goBrk_impl) &&&\n    ((gto_outer_impl \\<equiv> OP gto_outer_impl) &&&\n     go_is_done_impl \\<equiv> OP go_is_done_impl) &&&\n    (is_done_oimpl \\<equiv> OP is_done_oimpl) &&&\n    go_is_no_brk_impl \\<equiv> OP go_is_no_brk_impl", "by simp_all"], ["", "end"], ["", "abbreviation \"gGSi_rel \\<equiv> \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r GSi_rel\""], ["", "abbreviation (in -) \"ce_rel node_rel \\<equiv> \\<langle>\\<langle>node_rel\\<rangle>fun_set_rel \\<times>\\<^sub>r \\<langle>node_rel\\<rangle>fun_set_rel\\<rangle>option_rel\""], ["", "abbreviation \"goGSi_rel \\<equiv> ce_rel node_rel \\<times>\\<^sub>r oGSi_rel\""], ["", "end"], ["", "section \\<open>Automatic Refinement\\<close>"], ["", "context impl_lasso_loc\nbegin"], ["", "schematic_goal goinitial_code_aux: \"(?c,goinitial_impl)\\<in>goGSi_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, goinitial_impl) \\<in> ce_rel node_rel \\<times>\\<^sub>r oGSi_rel", "unfolding goinitial_impl_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, None, Map.empty) \\<in> ce_rel node_rel \\<times>\\<^sub>r oGSi_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, None, Map.empty) \\<in> ce_rel node_rel \\<times>\\<^sub>r oGSi_rel", "by (autoref (trace,keep_goal))"], ["", "concrete_definition (in -) goinitial_code \n    uses impl_lasso_loc.goinitial_code_aux"], ["", "lemmas [autoref_rules] = goinitial_code.refine[OF locale_this]"], ["", "term ginitial_impl"], ["", "schematic_goal ginitial_code_aux: \n    \"(?c,ginitial_impl)\\<in>node_rel \\<rightarrow> goGSi_rel \\<rightarrow> gGSi_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, ginitial_impl)\n    \\<in> node_rel \\<rightarrow>\n          ce_rel node_rel \\<times>\\<^sub>r oGSi_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel", "unfolding ginitial_impl_def[abs_def] initial_impl_def GS_initial_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>v0 s0.\n        ([acc v0], [v0], [0], snd s0(v0 \\<mapsto> STACK 0),\n         if E `` {v0} = {} then [] else [(0, E `` {v0})]))\n    \\<in> node_rel \\<rightarrow>\n          ce_rel node_rel \\<times>\\<^sub>r oGSi_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel", "(* TODO: Declare autoref-rule for initial*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>v0 s0.\n        ([acc v0], [v0], [0], snd s0(v0 \\<mapsto> STACK 0),\n         if E `` {v0} = {} then [] else [(0, E `` {v0})]))\n    \\<in> node_rel \\<rightarrow>\n          ce_rel node_rel \\<times>\\<^sub>r oGSi_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>v0 s0.\n        ([acc v0], [v0], [0], snd s0(v0 \\<mapsto> STACK 0),\n         if E `` {v0} = {} then [] else [(0, E `` {v0})]))\n    \\<in> node_rel \\<rightarrow>\n          ce_rel node_rel \\<times>\\<^sub>r oGSi_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel", "by (autoref (trace,keep_goal))"], ["", "concrete_definition (in -) ginitial_code uses impl_lasso_loc.ginitial_code_aux"], ["", "lemmas [autoref_rules] = ginitial_code.refine[OF locale_this]"], ["", "schematic_goal gpath_is_empty_code_aux: \n    \"(?c,gpath_is_empty_impl)\\<in>gGSi_rel\\<rightarrow>bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, gpath_is_empty_impl)\n    \\<in> \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          bool_rel", "unfolding gpath_is_empty_impl_def[abs_def] path_is_empty_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, \\<lambda>s. GS.S (snd s) = [])\n    \\<in> \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          bool_rel", "(* TODO: Declare autoref-rule for path_is_empty*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, \\<lambda>s. GS.S (snd s) = [])\n    \\<in> \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          bool_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, \\<lambda>s. GS.S (snd s) = [])\n    \\<in> \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          bool_rel", "by (autoref (trace,keep_goal))"], ["", "concrete_definition (in -) gpath_is_empty_code \n    uses impl_lasso_loc.gpath_is_empty_code_aux"], ["", "lemmas [autoref_rules] = gpath_is_empty_code.refine[OF locale_this]"], ["", "term goBrk"], ["", "schematic_goal goBrk_code_aux: \"(?c,goBrk_impl)\\<in>goGSi_rel\\<rightarrow>ce_rel node_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, goBrk_impl)\n    \\<in> ce_rel node_rel \\<times>\\<^sub>r oGSi_rel \\<rightarrow>\n          ce_rel node_rel", "unfolding goBrk_impl_def[abs_def] goBrk_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, fst)\n    \\<in> ce_rel node_rel \\<times>\\<^sub>r oGSi_rel \\<rightarrow>\n          ce_rel node_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, fst)\n    \\<in> ce_rel node_rel \\<times>\\<^sub>r oGSi_rel \\<rightarrow>\n          ce_rel node_rel", "by (autoref (trace,keep_goal))"], ["", "concrete_definition (in -) goBrk_code uses impl_lasso_loc.goBrk_code_aux"], ["", "lemmas [autoref_rules] = goBrk_code.refine[OF locale_this]"], ["", "thm autoref_itype(1)"], ["", "term gto_outer_impl"], ["", "schematic_goal gto_outer_code_aux: \n    \"(?c,gto_outer_impl)\\<in>ce_rel node_rel \\<rightarrow> gGSi_rel\\<rightarrow>goGSi_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, gto_outer_impl)\n    \\<in> ce_rel node_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          ce_rel node_rel \\<times>\\<^sub>r oGSi_rel", "unfolding gto_outer_impl_def[abs_def] gto_outer_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, \\<lambda>brk s. let (A, S, B, I, P) = s in (brk, I))\n    \\<in> ce_rel node_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          ce_rel node_rel \\<times>\\<^sub>r oGSi_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, \\<lambda>brk s. let (A, S, B, I, P) = s in (brk, I))\n    \\<in> ce_rel node_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          ce_rel node_rel \\<times>\\<^sub>r oGSi_rel", "by (autoref (trace,keep_goal))"], ["", "concrete_definition (in -) gto_outer_code \n    uses impl_lasso_loc.gto_outer_code_aux"], ["", "lemmas [autoref_rules] = gto_outer_code.refine[OF locale_this]"], ["", "term go_is_done_impl"], ["", "schematic_goal go_is_done_code_aux: \n    \"(?c,go_is_done_impl)\\<in>node_rel \\<rightarrow> goGSi_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, go_is_done_impl)\n    \\<in> node_rel \\<rightarrow>\n          ce_rel node_rel \\<times>\\<^sub>r oGSi_rel \\<rightarrow> bool_rel", "unfolding go_is_done_impl_def[abs_def] is_done_oimpl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>v s.\n        case snd s v of None \\<Rightarrow> False\n        | Some (STACK nat) \\<Rightarrow> False\n        | Some DONE \\<Rightarrow> True)\n    \\<in> node_rel \\<rightarrow>\n          ce_rel node_rel \\<times>\\<^sub>r oGSi_rel \\<rightarrow> bool_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>v s.\n        case snd s v of None \\<Rightarrow> False\n        | Some (STACK nat) \\<Rightarrow> False\n        | Some DONE \\<Rightarrow> True)\n    \\<in> node_rel \\<rightarrow>\n          ce_rel node_rel \\<times>\\<^sub>r oGSi_rel \\<rightarrow> bool_rel", "by (autoref (trace,keep_goal))"], ["", "concrete_definition (in -) go_is_done_code \n    uses impl_lasso_loc.go_is_done_code_aux"], ["", "lemmas [autoref_rules] = go_is_done_code.refine[OF locale_this]"], ["", "schematic_goal go_is_no_brk_code_aux: \n    \"(?c,go_is_no_brk_impl)\\<in>goGSi_rel\\<rightarrow>bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, go_is_no_brk_impl)\n    \\<in> ce_rel node_rel \\<times>\\<^sub>r oGSi_rel \\<rightarrow> bool_rel", "unfolding go_is_no_brk_impl_def[abs_def] go_is_no_brk_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, \\<lambda>s. fst s = None)\n    \\<in> ce_rel node_rel \\<times>\\<^sub>r oGSi_rel \\<rightarrow> bool_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, \\<lambda>s. fst s = None)\n    \\<in> ce_rel node_rel \\<times>\\<^sub>r oGSi_rel \\<rightarrow> bool_rel", "by (autoref (trace,keep_goal))"], ["", "concrete_definition (in -) go_is_no_brk_code \n    uses impl_lasso_loc.go_is_no_brk_code_aux"], ["", "lemmas [autoref_rules] = go_is_no_brk_code.refine[OF locale_this]"], ["", "(*\n  schematic_lemma XXX_code_aux: \"(?c,XXX_impl)\\<in>goGSi_rel\\<rightarrow>ce_rel\"\n    unfolding XXX_impl_def[abs_def] XXX_impl_def\n    using [[autoref_trace_failed_id]]\n    by (autoref (trace,keep_goal))\n  concrete_definition (in -) XXX_code uses impl_lasso_loc.XXX_code_aux\n  lemmas [autoref_rules] = XXX_code.refine[OF locale_this]\n*)"], ["", "schematic_goal gselect_edge_code_aux: \"(?c,gselect_edge_impl)\n    \\<in> gGSi_rel \\<rightarrow> \\<langle>\\<langle>node_rel\\<rangle>option_rel \\<times>\\<^sub>r gGSi_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, gselect_edge_impl)\n    \\<in> \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>\\<langle>node_rel\\<rangle>option_rel \\<times>\\<^sub>r\n                   \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   oGSi_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel \\<times>\\<^sub>r\n                            \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel\\<rangle>nres_rel", "unfolding gselect_edge_impl_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>s.\n        let (a, s) = s\n        in select_edge_impl s \\<bind> (\\<lambda>(vo, s). RETURN (vo, a, s)))\n    \\<in> \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>\\<langle>node_rel\\<rangle>option_rel \\<times>\\<^sub>r\n                   \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   oGSi_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel \\<times>\\<^sub>r\n                            \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel\\<rangle>nres_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>s.\n        let (a, s) = s\n        in select_edge_impl s \\<bind> (\\<lambda>(vo, s). RETURN (vo, a, s)))\n    \\<in> \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>\\<langle>node_rel\\<rangle>option_rel \\<times>\\<^sub>r\n                   \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   oGSi_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel \\<times>\\<^sub>r\n                            \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel\\<rangle>nres_rel", "by (autoref (trace,keep_goal))"], ["", "concrete_definition (in -) gselect_edge_code \n    uses impl_lasso_loc.gselect_edge_code_aux"], ["", "lemmas [autoref_rules] = gselect_edge_code.refine[OF locale_this]"], ["", "term gis_on_stack_impl"], ["", "schematic_goal gis_on_stack_code_aux: \n    \"(?c,gis_on_stack_impl)\\<in>node_rel \\<rightarrow> gGSi_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, gis_on_stack_impl)\n    \\<in> node_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          bool_rel", "unfolding gis_on_stack_impl_def[abs_def] is_on_stack_impl_def[abs_def] \n      GS.is_on_stack_impl_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>v s.\n        case GS.I (snd s) v of None \\<Rightarrow> False\n        | Some (STACK xa) \\<Rightarrow> True\n        | Some DONE \\<Rightarrow> False)\n    \\<in> node_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          bool_rel", "(* TODO: Declare autoref-rule for is_on_stack*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>v s.\n        case GS.I (snd s) v of None \\<Rightarrow> False\n        | Some (STACK xa) \\<Rightarrow> True\n        | Some DONE \\<Rightarrow> False)\n    \\<in> node_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          bool_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>v s.\n        case GS.I (snd s) v of None \\<Rightarrow> False\n        | Some (STACK xa) \\<Rightarrow> True\n        | Some DONE \\<Rightarrow> False)\n    \\<in> node_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          bool_rel", "by (autoref (trace,keep_goal))"], ["", "concrete_definition (in -) gis_on_stack_code \n    uses impl_lasso_loc.gis_on_stack_code_aux"], ["", "lemmas [autoref_rules] = gis_on_stack_code.refine[OF locale_this]"], ["", "term gcollapse_impl"], ["", "schematic_goal gcollapse_code_aux: \"(?c,gcollapse_impl)\\<in>node_rel \\<rightarrow> gGSi_rel \n    \\<rightarrow> \\<langle>gGSi_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, gcollapse_impl)\n    \\<in> node_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   oGSi_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel \\<times>\\<^sub>r\n                            \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel\\<rangle>nres_rel", "unfolding gcollapse_impl_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>v s.\n        let (A, S, B, I, P) = s\n        in GS.idx_of_impl (S, B, I, P) v \\<bind>\n           (\\<lambda>i.\n               ASSERT (i + 1 \\<le> length B) \\<bind>\n               (\\<lambda>_.\n                   let B = take (i + 1) B\n                   in ASSERT (i < length A) \\<bind>\n                      (\\<lambda>_.\n                          Un_set_drop_impl i A \\<bind>\n                          (\\<lambda>us.\n                              let A = take i A @ [us]\n                              in RETURN (A, S, B, I, P))))))\n    \\<in> node_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   oGSi_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel \\<times>\\<^sub>r\n                            \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel\\<rangle>nres_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>v s.\n        let (A, S, B, I, P) = s\n        in GS.idx_of_impl (S, B, I, P) v \\<bind>\n           (\\<lambda>i.\n               ASSERT (i + 1 \\<le> length B) \\<bind>\n               (\\<lambda>_.\n                   let B = take (i + 1) B\n                   in ASSERT (i < length A) \\<bind>\n                      (\\<lambda>_.\n                          Un_set_drop_impl i A \\<bind>\n                          (\\<lambda>us.\n                              let A = take i A @ [us]\n                              in RETURN (A, S, B, I, P))))))\n    \\<in> node_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   oGSi_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel \\<times>\\<^sub>r\n                            \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel\\<rangle>nres_rel", "by (autoref (trace,keep_goal))"], ["", "concrete_definition (in -) gcollapse_code \n    uses impl_lasso_loc.gcollapse_code_aux"], ["", "lemmas [autoref_rules] = gcollapse_code.refine[OF locale_this]"], ["", "schematic_goal last_is_acc_code_aux: \n    \"(?c,last_is_acc_impl)\\<in>gGSi_rel\\<rightarrow>\\<langle>bool_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, last_is_acc_impl)\n    \\<in> \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>bool_rel\\<rangle>nres_rel", "unfolding last_is_acc_impl_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>s.\n        let (a, uu_) = s\n        in ASSERT (a \\<noteq> []) \\<bind>\n           (\\<lambda>_. RETURN (\\<forall>i<num_acc. i \\<in> last a)))\n    \\<in> \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>bool_rel\\<rangle>nres_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>s.\n        let (a, uu_) = s\n        in ASSERT (a \\<noteq> []) \\<bind>\n           (\\<lambda>_. RETURN (\\<forall>i<num_acc. i \\<in> last a)))\n    \\<in> \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>bool_rel\\<rangle>nres_rel", "by (autoref (trace,keep_goal))"], ["", "concrete_definition (in -) last_is_acc_code \n    uses impl_lasso_loc.last_is_acc_code_aux"], ["", "lemmas [autoref_rules] = last_is_acc_code.refine[OF locale_this]"], ["", "schematic_goal ce_code_aux: \"(?c,ce_impl)\n    \\<in>gGSi_rel\\<rightarrow>\\<langle>ce_rel node_rel \\<times>\\<^sub>r gGSi_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, ce_impl)\n    \\<in> \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>ce_rel node_rel \\<times>\\<^sub>r\n                   \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   oGSi_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel \\<times>\\<^sub>r\n                            \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel\\<rangle>nres_rel", "unfolding ce_impl_def[abs_def] on_stack_less_def[abs_def] \n      on_stack_ge_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>s.\n        let (a, S, B, I, P) = s\n        in ASSERT (B \\<noteq> []) \\<bind>\n           (\\<lambda>_.\n               let bls =\n                     {v. case I v of None \\<Rightarrow> False\n                         | Some (STACK j) \\<Rightarrow> j < last B\n                         | Some DONE \\<Rightarrow> False};\n                   ls = {v. case I v of None \\<Rightarrow> False\n                            | Some (STACK xa) \\<Rightarrow> last B \\<le> xa\n                            | Some DONE \\<Rightarrow> False}\n               in RETURN (Some (bls, ls), a, S, B, I, P)))\n    \\<in> \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>ce_rel node_rel \\<times>\\<^sub>r\n                   \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   oGSi_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel \\<times>\\<^sub>r\n                            \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel\\<rangle>nres_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>s.\n        let (a, S, B, I, P) = s\n        in ASSERT (B \\<noteq> []) \\<bind>\n           (\\<lambda>_.\n               let bls =\n                     {v. case I v of None \\<Rightarrow> False\n                         | Some (STACK j) \\<Rightarrow> j < last B\n                         | Some DONE \\<Rightarrow> False};\n                   ls = {v. case I v of None \\<Rightarrow> False\n                            | Some (STACK xa) \\<Rightarrow> last B \\<le> xa\n                            | Some DONE \\<Rightarrow> False}\n               in RETURN (Some (bls, ls), a, S, B, I, P)))\n    \\<in> \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>ce_rel node_rel \\<times>\\<^sub>r\n                   \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   oGSi_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel \\<times>\\<^sub>r\n                            \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel\\<rangle>nres_rel", "by (autoref (trace,keep_goal))"], ["", "concrete_definition (in -) ce_code uses impl_lasso_loc.ce_code_aux"], ["", "lemmas [autoref_rules] = ce_code.refine[OF locale_this]"], ["", "schematic_goal gis_done_code_aux: \n    \"(?c,gis_done_impl)\\<in>node_rel\\<rightarrow>gGSi_rel\\<rightarrow>bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, gis_done_impl)\n    \\<in> node_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          bool_rel", "unfolding gis_done_impl_def[abs_def] is_done_impl_def GS.is_done_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>v s.\n        case GS.I (snd s) v of None \\<Rightarrow> False\n        | Some (STACK nat) \\<Rightarrow> False\n        | Some DONE \\<Rightarrow> True)\n    \\<in> node_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          bool_rel", "(* TODO: Autoref rule for is_done *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>v s.\n        case GS.I (snd s) v of None \\<Rightarrow> False\n        | Some (STACK nat) \\<Rightarrow> False\n        | Some DONE \\<Rightarrow> True)\n    \\<in> node_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          bool_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>v s.\n        case GS.I (snd s) v of None \\<Rightarrow> False\n        | Some (STACK nat) \\<Rightarrow> False\n        | Some DONE \\<Rightarrow> True)\n    \\<in> node_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          bool_rel", "by (autoref (trace,keep_goal))"], ["", "concrete_definition (in -) gis_done_code uses impl_lasso_loc.gis_done_code_aux"], ["", "lemmas [autoref_rules] = gis_done_code.refine[OF locale_this]"], ["", "schematic_goal gpush_code_aux: \n    \"(?c,gpush_impl)\\<in>node_rel \\<rightarrow> gGSi_rel\\<rightarrow>gGSi_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, gpush_impl)\n    \\<in> node_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel", "unfolding gpush_impl_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, \\<lambda>v s. let (a, s) = s in (a @ [acc v], push_impl v s))\n    \\<in> node_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, \\<lambda>v s. let (a, s) = s in (a @ [acc v], push_impl v s))\n    \\<in> node_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel", "by (autoref (trace,keep_goal))"], ["", "concrete_definition (in -) gpush_code uses impl_lasso_loc.gpush_code_aux"], ["", "lemmas [autoref_rules] = gpush_code.refine[OF locale_this]"], ["", "schematic_goal gpop_code_aux: \"(?c,gpop_impl)\\<in>gGSi_rel\\<rightarrow>\\<langle>gGSi_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, gpop_impl)\n    \\<in> \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   oGSi_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel \\<times>\\<^sub>r\n                            \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel\\<rangle>nres_rel", "unfolding gpop_impl_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>s.\n        let (a, s) = s\n        in pop_impl s \\<bind>\n           (\\<lambda>s.\n               ASSERT (a \\<noteq> []) \\<bind>\n               (\\<lambda>_. let a = butlast a in RETURN (a, s))))\n    \\<in> \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   oGSi_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel \\<times>\\<^sub>r\n                            \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel\\<rangle>nres_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>s.\n        let (a, s) = s\n        in pop_impl s \\<bind>\n           (\\<lambda>s.\n               ASSERT (a \\<noteq> []) \\<bind>\n               (\\<lambda>_. let a = butlast a in RETURN (a, s))))\n    \\<in> \\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n          oGSi_rel \\<times>\\<^sub>r\n          \\<langle>nat_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel \\<rightarrow>\n          \\<langle>\\<langle>\\<langle>nat_rel\\<rangle>bs_set_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel\\<rangle>as_rel \\<times>\\<^sub>r\n                   oGSi_rel \\<times>\\<^sub>r\n                   \\<langle>nat_rel \\<times>\\<^sub>r\n                            \\<langle>node_rel\\<rangle>list_set_rel\\<rangle>as_rel\\<rangle>nres_rel", "by (autoref (trace,keep_goal))"], ["", "concrete_definition (in -) gpop_code uses impl_lasso_loc.gpop_code_aux"], ["", "lemmas [autoref_rules] = gpop_code.refine[OF locale_this]"], ["", "schematic_goal find_ce_code_aux: \"(?c,find_ce_impl)\\<in>\\<langle>ce_rel node_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, find_ce_impl) \\<in> \\<langle>ce_rel node_rel\\<rangle>nres_rel", "unfolding find_ce_impl_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     stat_start_nres \\<bind>\n     (\\<lambda>_.\n         let os = goinitial_impl\n         in FOREACH\\<^sub>C\\<^bsup>\\<lambda>it os.\nfgl_outer_invar it (goGS_\\<alpha> os)\\<^esup>\n             V0 go_is_no_brk_impl\n             (\\<lambda>v0 s0.\n                 if \\<not> go_is_done_impl v0 s0\n                 then let s = (None, ginitial_impl v0 s0)\n                      in WHILE\\<^sub>T\\<^bsup>\\<lambda>(brk, s).\n           fgl_invar v0 (oGS_\\<alpha> (goD_impl s0))\n            (brk, snd (gGS_\\<alpha> s))\\<^esup>\n                          (\\<lambda>(brk, s).\n                              brk = None \\<and>\n                              \\<not> gpath_is_empty_impl s)\n                          (\\<lambda>(l, s).\n                              gselect_edge_impl s \\<bind>\n                              (\\<lambda>(vo, s).\n                                  case vo of\n                                  None \\<Rightarrow>\n                                    gpop_impl s \\<bind>\n                                    (\\<lambda>s. RETURN (None, s))\n                                  | Some v \\<Rightarrow>\nif gis_on_stack_impl v s\nthen gcollapse_impl v s \\<bind>\n     (\\<lambda>s.\n         last_is_acc_impl s \\<bind>\n         (\\<lambda>b. if b then ce_impl s else RETURN (None, s)))\nelse if \\<not> gis_done_impl v s then RETURN (None, gpush_impl v s)\n     else RETURN (None, s)))\n                          s \\<bind>\n                         (\\<lambda>(brk, s). RETURN (gto_outer_impl brk s))\n                 else RETURN s0)\n             os \\<bind>\n            (\\<lambda>os.\n                stat_stop_nres \\<bind>\n                (\\<lambda>_. RETURN (goBrk_impl os)))))\n    \\<in> \\<langle>ce_rel node_rel\\<rangle>nres_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     stat_start_nres \\<bind>\n     (\\<lambda>_.\n         let os = goinitial_impl\n         in FOREACH\\<^sub>C\\<^bsup>\\<lambda>it os.\nfgl_outer_invar it (goGS_\\<alpha> os)\\<^esup>\n             V0 go_is_no_brk_impl\n             (\\<lambda>v0 s0.\n                 if \\<not> go_is_done_impl v0 s0\n                 then let s = (None, ginitial_impl v0 s0)\n                      in WHILE\\<^sub>T\\<^bsup>\\<lambda>(brk, s).\n           fgl_invar v0 (oGS_\\<alpha> (goD_impl s0))\n            (brk, snd (gGS_\\<alpha> s))\\<^esup>\n                          (\\<lambda>(brk, s).\n                              brk = None \\<and>\n                              \\<not> gpath_is_empty_impl s)\n                          (\\<lambda>(l, s).\n                              gselect_edge_impl s \\<bind>\n                              (\\<lambda>(vo, s).\n                                  case vo of\n                                  None \\<Rightarrow>\n                                    gpop_impl s \\<bind>\n                                    (\\<lambda>s. RETURN (None, s))\n                                  | Some v \\<Rightarrow>\nif gis_on_stack_impl v s\nthen gcollapse_impl v s \\<bind>\n     (\\<lambda>s.\n         last_is_acc_impl s \\<bind>\n         (\\<lambda>b. if b then ce_impl s else RETURN (None, s)))\nelse if \\<not> gis_done_impl v s then RETURN (None, gpush_impl v s)\n     else RETURN (None, s)))\n                          s \\<bind>\n                         (\\<lambda>(brk, s). RETURN (gto_outer_impl brk s))\n                 else RETURN s0)\n             os \\<bind>\n            (\\<lambda>os.\n                stat_stop_nres \\<bind>\n                (\\<lambda>_. RETURN (goBrk_impl os)))))\n    \\<in> \\<langle>ce_rel node_rel\\<rangle>nres_rel", "apply (autoref (trace,keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition (in -) find_ce_code \n    uses impl_lasso_loc.find_ce_code_aux"], ["", "lemmas [autoref_rules] = find_ce_code.refine[OF locale_this]"], ["", "schematic_goal find_ce_tr_aux: \"RETURN ?c \\<le> find_ce_code node_eq_impl node_hash_impl node_def_hash_size G_impl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> find_ce_code node_eq_impl node_hash_impl node_def_hash_size G_impl", "unfolding\n      find_ce_code_def\n      ginitial_code_def\n      gpath_is_empty_code_def\n      gselect_edge_code_def\n      gis_on_stack_code_def\n      gcollapse_code_def\n      last_is_acc_code_def\n      ce_code_def\n      gis_done_code_def\n      gpush_code_def\n      gpop_code_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> stat_start_nres \\<bind>\n          (\\<lambda>x.\n              let y' = goinitial_code node_def_hash_size\n              in LIST_FOREACH' (RETURN (id (gi_V0 G_impl)))\n                  go_is_no_brk_code\n                  (\\<lambda>xa xb.\n                      if \\<not> go_is_done_code node_eq_impl node_hash_impl\n                                 xa xb\n                      then let y'a =\n                                 (None, as_singleton (igbgi_acc G_impl xa),\n                                  as_singleton xa, as_singleton 0,\n                                  Impl_Array_Hash_Map.ahm_update\n                                   node_eq_impl node_hash_impl xa (int 0)\n                                   (snd xb),\n                                  if is_Nil (gi_E G_impl xa)\n                                  then as_empty ()\n                                  else as_singleton (0, gi_E G_impl xa))\n                           in WHILE\\<^sub>T\n                               (\\<lambda>(xd, xe).\n                                   is_None xd \\<and>\n                                   \\<not> as_is_empty\n     (case snd xe of (xa, xb, xca, xd) \\<Rightarrow> xa))\n                               (\\<lambda>(xd, xe).\n                                   (let (xa, xb) = xe\n                                    in select_edge_code node_eq_impl\n  xb \\<bind>\n (\\<lambda>(xc, xd). RETURN (xc, xa, xd))) \\<bind>\n                                   (\\<lambda>(xf, xg).\n case xf of\n None \\<Rightarrow>\n   (let (xa, xb) = xg\n    in pop_code node_eq_impl node_hash_impl xb \\<bind>\n       (\\<lambda>xc. let y'a = as_pop xa in RETURN (y'a, xc))) \\<bind>\n   (\\<lambda>xh. RETURN (None, xh))\n | Some xh \\<Rightarrow>\n     if case Impl_Array_Hash_Map.ahm_lookup node_eq_impl node_hash_impl xh\n              (case snd xg of (xb, xc, xd, xe) \\<Rightarrow> xd) of\n        None \\<Rightarrow> False\n        | Some i \\<Rightarrow> if 0 \\<le> i then True else False\n     then (let (xb, xc, xd, xe, xf) = xg\n           in idx_of_code node_eq_impl node_hash_impl (xc, xd, xe, xf)\n               xh \\<bind>\n              (\\<lambda>xg.\n                  let y'a = as_take (xg + 1) xd\n                  in RETURN\n                      (Un_set_drop_tr (bs_empty ()) bs_union xg xb) \\<bind>\n                     (\\<lambda>xh.\n                         let y'b = as_push (as_take xg xb) xh\n                         in RETURN (y'b, xc, y'a, xe, xf)))) \\<bind>\n          (\\<lambda>xi.\n              (let (xa, xb) = xi\n               in RETURN\n                   (List.all_interval_nat\n                     (\\<lambda>xc. bs_mem xc (as_top xa)) 0\n                     (igbgi_num_acc G_impl))) \\<bind>\n              (\\<lambda>xj.\n                  if xj\n                  then let (xa, xb, xc, xd, xe) = xi;\n                           y'a =\n                             \\<lambda>xf.\n                                case Impl_Array_Hash_Map.ahm_lookup\nnode_eq_impl node_hash_impl xf xd of\n                                None \\<Rightarrow> False\n                                | Some i \\<Rightarrow>\n                                    if 0 \\<le> i then nat i < as_top xc\n                                    else False;\n                           y'b =\n                             \\<lambda>xf.\n                                case Impl_Array_Hash_Map.ahm_lookup\nnode_eq_impl node_hash_impl xf xd of\n                                None \\<Rightarrow> False\n                                | Some i \\<Rightarrow>\n                                    if 0 \\<le> i then as_top xc \\<le> nat i\n                                    else False\n                       in RETURN (Some (y'a, y'b), xa, xb, xc, xd, xe)\n                  else RETURN (None, xi)))\n     else if \\<not> (case Impl_Array_Hash_Map.ahm_lookup node_eq_impl\n                           node_hash_impl xh\n                           (case snd xg of\n                            (xb, xc, xd, xe) \\<Rightarrow> xd) of\n                     None \\<Rightarrow> False\n                     | Some i \\<Rightarrow>\n                         if 0 \\<le> i then False else True)\n          then RETURN\n                (None,\n                 let (xb, xc) = xg\n                 in (as_push xb (igbgi_acc G_impl xh),\n                     push_code node_eq_impl node_hash_impl G_impl xh xc))\n          else RETURN (None, xg)))\n                               y'a \\<bind>\n                              (\\<lambda>(xc, xd).\n                                  RETURN (gto_outer_code xc xd))\n                      else RETURN xb)\n                  y' \\<bind>\n                 (\\<lambda>xa.\n                     stat_stop_nres \\<bind>\n                     (\\<lambda>xb. RETURN (goBrk_code xa))))", "apply refine_transfer"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition (in -) find_ce_tr for G_impl\n    uses impl_lasso_loc.find_ce_tr_aux"], ["", "lemmas [refine_transfer] = find_ce_tr.refine[OF locale_this]"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma [autoref_op_pat]: \n      \"find_ce_spec \\<equiv> OP find_ce_spec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_ce_spec \\<equiv> OP find_ce_spec", "by auto"], ["", "end"], ["", "theorem find_ce_autoref[autoref_rules]:\n    \\<comment> \\<open>Main Correctness theorem (inside locale)\\<close>\n    shows \"(find_ce_code node_eq_impl node_hash_impl node_def_hash_size G_impl, find_ce_spec) \\<in> \\<langle>ce_rel node_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (find_ce_code node_eq_impl node_hash_impl node_def_hash_size G_impl,\n     find_ce_spec)\n    \\<in> \\<langle>ce_rel node_rel\\<rangle>nres_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (find_ce_code node_eq_impl node_hash_impl node_def_hash_size G_impl,\n     find_ce_spec)\n    \\<in> \\<langle>ce_rel node_rel\\<rangle>nres_rel", "note find_ce_code.refine[OF locale_this, THEN nres_relD]"], ["proof (state)\nthis:\n  find_ce_code node_eq_impl node_hash_impl node_def_hash_size G_impl\n  \\<le> \\<Down> (ce_rel node_rel) find_ce_impl\n\ngoal (1 subgoal):\n 1. (find_ce_code node_eq_impl node_hash_impl node_def_hash_size G_impl,\n     find_ce_spec)\n    \\<in> \\<langle>ce_rel node_rel\\<rangle>nres_rel", "also"], ["proof (state)\nthis:\n  find_ce_code node_eq_impl node_hash_impl node_def_hash_size G_impl\n  \\<le> \\<Down> (ce_rel node_rel) find_ce_impl\n\ngoal (1 subgoal):\n 1. (find_ce_code node_eq_impl node_hash_impl node_def_hash_size G_impl,\n     find_ce_spec)\n    \\<in> \\<langle>ce_rel node_rel\\<rangle>nres_rel", "note find_ce_impl_refine"], ["proof (state)\nthis:\n  find_ce_impl \\<le> \\<Down> Id gfind_ce\n\ngoal (1 subgoal):\n 1. (find_ce_code node_eq_impl node_hash_impl node_def_hash_size G_impl,\n     find_ce_spec)\n    \\<in> \\<langle>ce_rel node_rel\\<rangle>nres_rel", "also"], ["proof (state)\nthis:\n  find_ce_impl \\<le> \\<Down> Id gfind_ce\n\ngoal (1 subgoal):\n 1. (find_ce_code node_eq_impl node_hash_impl node_def_hash_size G_impl,\n     find_ce_spec)\n    \\<in> \\<langle>ce_rel node_rel\\<rangle>nres_rel", "note find_ce_refine"], ["proof (state)\nthis:\n  gfind_ce \\<le> \\<Down> Id find_ce\n\ngoal (1 subgoal):\n 1. (find_ce_code node_eq_impl node_hash_impl node_def_hash_size G_impl,\n     find_ce_spec)\n    \\<in> \\<langle>ce_rel node_rel\\<rangle>nres_rel", "also"], ["proof (state)\nthis:\n  gfind_ce \\<le> \\<Down> Id find_ce\n\ngoal (1 subgoal):\n 1. (find_ce_code node_eq_impl node_hash_impl node_def_hash_size G_impl,\n     find_ce_spec)\n    \\<in> \\<langle>ce_rel node_rel\\<rangle>nres_rel", "note find_ce_correct"], ["proof (state)\nthis:\n  find_ce \\<le> find_ce_spec\n\ngoal (1 subgoal):\n 1. (find_ce_code node_eq_impl node_hash_impl node_def_hash_size G_impl,\n     find_ce_spec)\n    \\<in> \\<langle>ce_rel node_rel\\<rangle>nres_rel", "finally"], ["proof (chain)\npicking this:\n  find_ce_code node_eq_impl node_hash_impl node_def_hash_size G_impl\n  \\<le> \\<Down> (ce_rel node_rel) find_ce_spec", "show ?thesis"], ["proof (prove)\nusing this:\n  find_ce_code node_eq_impl node_hash_impl node_def_hash_size G_impl\n  \\<le> \\<Down> (ce_rel node_rel) find_ce_spec\n\ngoal (1 subgoal):\n 1. (find_ce_code node_eq_impl node_hash_impl node_def_hash_size G_impl,\n     find_ce_spec)\n    \\<in> \\<langle>ce_rel node_rel\\<rangle>nres_rel", "by (auto intro: nres_relI)"], ["proof (state)\nthis:\n  (find_ce_code node_eq_impl node_hash_impl node_def_hash_size G_impl,\n   find_ce_spec)\n  \\<in> \\<langle>ce_rel node_rel\\<rangle>nres_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context impl_lasso_loc\nbegin"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma [autoref_op_pat]: \n      \"reconstruct_reach \\<equiv> OP reconstruct_reach\"\n      \"reconstruct_lasso \\<equiv> OP reconstruct_lasso\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (reconstruct_reach \\<equiv> OP reconstruct_reach) &&&\n    reconstruct_lasso \\<equiv> OP reconstruct_lasso", "by auto"], ["", "end"], ["", "schematic_goal reconstruct_reach_code_aux:\n    shows \"(?c, reconstruct_reach)\\<in>\\<langle>node_rel\\<rangle>fun_set_rel \\<rightarrow>\n    \\<langle>node_rel\\<rangle>fun_set_rel \\<rightarrow>\n    \\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r node_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, reconstruct_reach)\n    \\<in> \\<langle>node_rel\\<rangle>fun_set_rel \\<rightarrow>\n          \\<langle>node_rel\\<rangle>fun_set_rel \\<rightarrow>\n          \\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                   node_rel\\<rangle>nres_rel", "unfolding reconstruct_lasso_def[abs_def] reconstruct_reach_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>Vr Vl.\n        find_path (E \\<inter> Vr \\<times> UNIV) V0\n         (\\<lambda>v. v \\<in> Vl) \\<bind>\n        (\\<lambda>res.\n            ASSERT (res \\<noteq> None) \\<bind>\n            (\\<lambda>_. RETURN (the res))))\n    \\<in> \\<langle>node_rel\\<rangle>fun_set_rel \\<rightarrow>\n          \\<langle>node_rel\\<rangle>fun_set_rel \\<rightarrow>\n          \\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                   node_rel\\<rangle>nres_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>Vr Vl.\n        find_path (E \\<inter> Vr \\<times> UNIV) V0\n         (\\<lambda>v. v \\<in> Vl) \\<bind>\n        (\\<lambda>res.\n            ASSERT (res \\<noteq> None) \\<bind>\n            (\\<lambda>_. RETURN (the res))))\n    \\<in> \\<langle>node_rel\\<rangle>fun_set_rel \\<rightarrow>\n          \\<langle>node_rel\\<rangle>fun_set_rel \\<rightarrow>\n          \\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                   node_rel\\<rangle>nres_rel", "apply (autoref (keep_goal, trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition (in -) reconstruct_reach_code \n    uses impl_lasso_loc.reconstruct_reach_code_aux"], ["", "lemmas [autoref_rules] = reconstruct_reach_code.refine[OF locale_this]"], ["", "schematic_goal reconstruct_lasso_code_aux:\n    shows \"(?c, reconstruct_lasso)\\<in>\\<langle>node_rel\\<rangle>fun_set_rel \\<rightarrow>\n    \\<langle>node_rel\\<rangle>fun_set_rel \\<rightarrow>\n    \\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r \\<langle>node_rel\\<rangle>list_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, reconstruct_lasso)\n    \\<in> \\<langle>node_rel\\<rangle>fun_set_rel \\<rightarrow>\n          \\<langle>node_rel\\<rangle>fun_set_rel \\<rightarrow>\n          \\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_rel\\<rangle>nres_rel", "unfolding reconstruct_lasso_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>Vr Vl.\n        reconstruct_reach Vr Vl \\<bind>\n        (\\<lambda>(pr, va).\n            let cS_full = {0..<num_acc}; E = E \\<inter> UNIV \\<times> Vl\n            in WHILE\\<^sub>T\\<^bsup>rec_loop_invar Vl va\\<^esup>\n                (\\<lambda>(uu_, uu_, cS). cS \\<noteq> cS_full)\n                (\\<lambda>(v, p, cS).\n                    ASSERT\n                     (\\<exists>v'.\n                         (v, v') \\<in> E\\<^sup>* \\<and>\n                         \\<not> acc v' \\<subseteq> cS) \\<bind>\n                    (\\<lambda>_.\n                        find_path E {v}\n                         (\\<lambda>v. \\<not> acc v \\<subseteq> cS) \\<bind>\n                        (\\<lambda>sr.\n                            ASSERT (sr \\<noteq> None) \\<bind>\n                            (\\<lambda>_.\n                                let (p_seg, v) = the sr\n                                in RETURN\n                                    (v, p @ p_seg, cS \\<union> acc v)))))\n                (va, [], acc va) \\<bind>\n               (\\<lambda>(vd, p, uu_).\n                   (if p = [] then find_path1 E vd ((=) va)\n                    else find_path E {vd} ((=) va)) \\<bind>\n                   (\\<lambda>p_close_r.\n                       ASSERT (p_close_r \\<noteq> None) \\<bind>\n                       (\\<lambda>_.\n                           let (p_close, uu_) = the p_close_r\n                           in RETURN (pr, p @ p_close))))))\n    \\<in> \\<langle>node_rel\\<rangle>fun_set_rel \\<rightarrow>\n          \\<langle>node_rel\\<rangle>fun_set_rel \\<rightarrow>\n          \\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_rel\\<rangle>nres_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>Vr Vl.\n        reconstruct_reach Vr Vl \\<bind>\n        (\\<lambda>(pr, va).\n            let cS_full = {0..<num_acc}; E = E \\<inter> UNIV \\<times> Vl\n            in WHILE\\<^sub>T\\<^bsup>rec_loop_invar Vl va\\<^esup>\n                (\\<lambda>(uu_, uu_, cS). cS \\<noteq> cS_full)\n                (\\<lambda>(v, p, cS).\n                    ASSERT\n                     (\\<exists>v'.\n                         (v, v') \\<in> E\\<^sup>* \\<and>\n                         \\<not> acc v' \\<subseteq> cS) \\<bind>\n                    (\\<lambda>_.\n                        find_path E {v}\n                         (\\<lambda>v. \\<not> acc v \\<subseteq> cS) \\<bind>\n                        (\\<lambda>sr.\n                            ASSERT (sr \\<noteq> None) \\<bind>\n                            (\\<lambda>_.\n                                let (p_seg, v) = the sr\n                                in RETURN\n                                    (v, p @ p_seg, cS \\<union> acc v)))))\n                (va, [], acc va) \\<bind>\n               (\\<lambda>(vd, p, uu_).\n                   (if p = [] then find_path1 E vd ((=) va)\n                    else find_path E {vd} ((=) va)) \\<bind>\n                   (\\<lambda>p_close_r.\n                       ASSERT (p_close_r \\<noteq> None) \\<bind>\n                       (\\<lambda>_.\n                           let (p_close, uu_) = the p_close_r\n                           in RETURN (pr, p @ p_close))))))\n    \\<in> \\<langle>node_rel\\<rangle>fun_set_rel \\<rightarrow>\n          \\<langle>node_rel\\<rangle>fun_set_rel \\<rightarrow>\n          \\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r\n                   \\<langle>node_rel\\<rangle>list_rel\\<rangle>nres_rel", "apply (autoref (keep_goal, trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition (in -) reconstruct_lasso_code \n    uses impl_lasso_loc.reconstruct_lasso_code_aux"], ["", "lemmas [autoref_rules] = reconstruct_lasso_code.refine[OF locale_this]"], ["", "schematic_goal reconstruct_lasso_tr_aux: \n    \"RETURN ?c \\<le> reconstruct_lasso_code eqi hi dszi G_impl Vr Vl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c \\<le> reconstruct_lasso_code eqi hi dszi G_impl Vr Vl", "unfolding reconstruct_lasso_code_def reconstruct_reach_code_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> wset_find_path_impl hi dszi eqi\n           (graph_restrict_left_impl (\\<lambda>x f. f x) Vr (gi_E G_impl))\n           (gi_V0 G_impl) Vl \\<bind>\n          (\\<lambda>xb. RETURN (the xb)) \\<bind>\n          (\\<lambda>(xb, xc).\n              let y' = atLeastLessThan_tr (bs_empty ()) bs_insert 0\n                        (igbgi_num_acc G_impl);\n                  y'a =\n                    graph_restrict_right_impl (\\<lambda>x f. f x) Vl\n                     (gi_E G_impl)\n              in WHILE\\<^sub>T (\\<lambda>(xe, xf, xg). \\<not> bs_eq xg y')\n                  (\\<lambda>(xe, xf, xg).\n                      wset_find_path_impl hi dszi eqi y'a [xe]\n                       (\\<lambda>xh.\n                           \\<not> bs_subset_eq (igbgi_acc G_impl xh)\n                                   xg) \\<bind>\n                      (\\<lambda>xh.\n                          let (xi, xj) = the xh\n                          in RETURN\n                              (xj, xf @ xi,\n                               bs_union xg (igbgi_acc G_impl xj))))\n                  (xc, [], igbgi_acc G_impl xc) \\<bind>\n                 (\\<lambda>(xd, xe, xf).\n                     (if is_Nil xe\n                      then find_path1_impl eqi hi dszi y'a xd (eqi xc)\n                      else wset_find_path_impl hi dszi eqi y'a [xd]\n                            (eqi xc)) \\<bind>\n                     (\\<lambda>xg.\n                         let (xh, xi) = the xg in RETURN (xb, xe @ xh))))", "apply (refine_transfer (post))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition (in -) reconstruct_lasso_tr for G_impl\n    uses impl_lasso_loc.reconstruct_lasso_tr_aux"], ["", "lemmas [refine_transfer] = reconstruct_lasso_tr.refine[OF locale_this]"], ["", "schematic_goal find_lasso_code_aux:\n    shows \"(?c::?'c, find_lasso)\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, find_lasso) \\<in> ?R", "unfolding find_lasso_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     find_ce_spec \\<bind>\n     (\\<lambda>ce.\n         case ce of None \\<Rightarrow> RETURN None\n         | Some (Vr, Vl) \\<Rightarrow>\n             reconstruct_lasso Vr Vl \\<bind> (\\<lambda>l. RETURN (Some l))))\n    \\<in> ?R", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     find_ce_spec \\<bind>\n     (\\<lambda>ce.\n         case ce of None \\<Rightarrow> RETURN None\n         | Some (Vr, Vl) \\<Rightarrow>\n             reconstruct_lasso Vr Vl \\<bind> (\\<lambda>l. RETURN (Some l))))\n    \\<in> ?R", "apply (autoref (keep_goal, trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition (in -) find_lasso_code \n    uses impl_lasso_loc.find_lasso_code_aux"], ["", "lemmas [autoref_rules] = find_lasso_code.refine[OF locale_this]"], ["", "schematic_goal find_lasso_tr_aux: \n    \"RETURN ?c \\<le> find_lasso_code node_eq_impl node_hash_impl node_def_hash_size G_impl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> find_lasso_code node_eq_impl node_hash_impl node_def_hash_size\n           G_impl", "unfolding find_lasso_code_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> find_ce_code node_eq_impl node_hash_impl node_def_hash_size\n           G_impl \\<bind>\n          case_option (RETURN None)\n           (\\<lambda>(x, xa).\n               reconstruct_lasso_code node_eq_impl node_hash_impl\n                node_def_hash_size G_impl x xa \\<bind>\n               (\\<lambda>xb. RETURN (Some xb)))", "apply (refine_transfer (post))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition (in -) find_lasso_tr for G_impl\n    uses impl_lasso_loc.find_lasso_tr_aux"], ["", "lemmas [refine_transfer] = find_lasso_tr.refine[OF locale_this]"], ["", "end"], ["", "export_code find_lasso_tr checking SML"], ["", "section \\<open>Main Correctness Theorem\\<close>"], ["", "abbreviation fl_rel :: \"_ \\<Rightarrow> (_ \\<times> ('a list \\<times> 'a list) option) set\" where  \n  \"fl_rel node_rel \\<equiv> \\<langle>\\<langle>node_rel\\<rangle>list_rel \\<times>\\<^sub>r \\<langle>node_rel\\<rangle>list_rel\\<rangle>Relators.option_rel\""], ["", "theorem find_lasso_tr_correct:\n  \\<comment> \\<open>Correctness theorem for the constant we extracted to SML\\<close>\n  fixes Re and node_rel :: \"('vi \\<times> 'v) set\"\n  assumes A: \"(G_impl,G)\\<in>igbg_impl_rel_ext Re node_rel\"\n      and node_eq_refine: \"(node_eq_impl, (=)) \\<in> node_rel \\<rightarrow> node_rel \\<rightarrow> bool_rel\"\n      and node_hash: \"is_bounded_hashcode node_rel node_eq_impl node_hash_impl\"\n      and node_hash_def_size: \"(is_valid_def_hm_size TYPE('vi) node_def_hash_size)\"\n  \n  assumes B: \"igb_fr_graph G\"\n  shows \"RETURN (find_lasso_tr node_eq_impl node_hash_impl node_def_hash_size G_impl) \n  \\<le> \\<Down>(fl_rel node_rel) (igb_graph.find_lasso_spec G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN\n     (find_lasso_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n    \\<le> \\<Down> (fl_rel node_rel) (igb_graph.find_lasso_spec G)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. RETURN\n     (find_lasso_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n    \\<le> \\<Down> (fl_rel node_rel) (igb_graph.find_lasso_spec G)", "from B"], ["proof (chain)\npicking this:\n  igb_fr_graph G", "interpret igb_fr_graph G"], ["proof (prove)\nusing this:\n  igb_fr_graph G\n\ngoal (1 subgoal):\n 1. igb_fr_graph G", "."], ["proof (state)\ngoal (1 subgoal):\n 1. RETURN\n     (find_lasso_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n    \\<le> \\<Down> (fl_rel node_rel) find_lasso_spec", "have I: \"impl_lasso_loc Re node_rel node_eq_impl node_hash_impl node_def_hash_size G_impl G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. impl_lasso_loc Re node_rel node_eq_impl node_hash_impl\n     node_def_hash_size G_impl G", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. (G_impl, G) \\<in> igbg_impl_rel_ext Re node_rel\n 2. (node_eq_impl, (=))\n    \\<in> node_rel \\<rightarrow> node_rel \\<rightarrow> bool_rel\n 3. is_bounded_hashcode node_rel node_eq_impl node_hash_impl\n 4. is_valid_def_hm_size TYPE('vi) node_def_hash_size", "by fact+"], ["proof (state)\nthis:\n  impl_lasso_loc Re node_rel node_eq_impl node_hash_impl node_def_hash_size\n   G_impl G\n\ngoal (1 subgoal):\n 1. RETURN\n     (find_lasso_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n    \\<le> \\<Down> (fl_rel node_rel) find_lasso_spec", "then"], ["proof (chain)\npicking this:\n  impl_lasso_loc Re node_rel node_eq_impl node_hash_impl node_def_hash_size\n   G_impl G", "interpret impl_lasso_loc Re node_rel node_eq_impl node_hash_impl node_def_hash_size G_impl G"], ["proof (prove)\nusing this:\n  impl_lasso_loc Re node_rel node_eq_impl node_hash_impl node_def_hash_size\n   G_impl G\n\ngoal (1 subgoal):\n 1. impl_lasso_loc Re node_rel node_eq_impl node_hash_impl\n     node_def_hash_size G_impl G", "."], ["proof (state)\ngoal (1 subgoal):\n 1. RETURN\n     (find_lasso_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n    \\<le> \\<Down> (fl_rel node_rel) find_lasso_spec", "note find_lasso_tr.refine[OF I]"], ["proof (state)\nthis:\n  RETURN\n   (find_lasso_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n  \\<le> find_lasso_code node_eq_impl node_hash_impl node_def_hash_size\n         G_impl\n\ngoal (1 subgoal):\n 1. RETURN\n     (find_lasso_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n    \\<le> \\<Down> (fl_rel node_rel) find_lasso_spec", "also"], ["proof (state)\nthis:\n  RETURN\n   (find_lasso_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n  \\<le> find_lasso_code node_eq_impl node_hash_impl node_def_hash_size\n         G_impl\n\ngoal (1 subgoal):\n 1. RETURN\n     (find_lasso_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n    \\<le> \\<Down> (fl_rel node_rel) find_lasso_spec", "note find_lasso_code.refine[OF I, THEN nres_relD]"], ["proof (state)\nthis:\n  find_lasso_code node_eq_impl node_hash_impl node_def_hash_size G_impl\n  \\<le> \\<Down> (fl_rel node_rel) find_lasso\n\ngoal (1 subgoal):\n 1. RETURN\n     (find_lasso_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n    \\<le> \\<Down> (fl_rel node_rel) find_lasso_spec", "also"], ["proof (state)\nthis:\n  find_lasso_code node_eq_impl node_hash_impl node_def_hash_size G_impl\n  \\<le> \\<Down> (fl_rel node_rel) find_lasso\n\ngoal (1 subgoal):\n 1. RETURN\n     (find_lasso_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n    \\<le> \\<Down> (fl_rel node_rel) find_lasso_spec", "note find_lasso_correct"], ["proof (state)\nthis:\n  find_lasso \\<le> find_lasso_spec\n\ngoal (1 subgoal):\n 1. RETURN\n     (find_lasso_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n    \\<le> \\<Down> (fl_rel node_rel) find_lasso_spec", "finally"], ["proof (chain)\npicking this:\n  RETURN\n   (find_lasso_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n  \\<le> \\<Down> (fl_rel node_rel) find_lasso_spec", "show ?thesis"], ["proof (prove)\nusing this:\n  RETURN\n   (find_lasso_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n  \\<le> \\<Down> (fl_rel node_rel) find_lasso_spec\n\ngoal (1 subgoal):\n 1. RETURN\n     (find_lasso_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n    \\<le> \\<Down> (fl_rel node_rel) find_lasso_spec", "."], ["proof (state)\nthis:\n  RETURN\n   (find_lasso_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n  \\<le> \\<Down> (fl_rel node_rel) find_lasso_spec\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Autoref Setup for \\<open>igb_graph.find_lasso_spec\\<close>\\<close>"], ["", "text \\<open>Setup for Autoref, such that \\<open>igb_graph.find_lasso_spec\\<close> \n  can be used\\<close>"], ["", "definition [simp]: \"op_find_lasso_spec \\<equiv> igb_graph.find_lasso_spec\""], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma [autoref_op_pat]: \"igb_graph.find_lasso_spec \\<equiv> op_find_lasso_spec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. igb_graph.find_lasso_spec \\<equiv> op_find_lasso_spec", "by simp"], ["", "term op_find_lasso_spec"], ["", "lemma [autoref_itype]: \n  \"op_find_lasso_spec \n    ::\\<^sub>i i_igbg Ie I \\<rightarrow>\\<^sub>i \\<langle>\\<langle>\\<langle>\\<langle>I\\<rangle>\\<^sub>ii_list, \\<langle>I\\<rangle>\\<^sub>ii_list\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_option\\<rangle>\\<^sub>ii_nres\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_find_lasso_spec ::\\<^sub>i\n    i_igbg Ie I \\<rightarrow>\\<^sub>i\n    \\<langle>\\<langle>\\<langle>\\<langle>I\\<rangle>\\<^sub>ii_list,\n    \\<langle>I\\<rangle>\\<^sub>ii_list\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_option\\<rangle>\\<^sub>ii_nres", "by simp"], ["", "lemma find_lasso_spec_autoref[autoref_rules_raw]:\n  fixes Re and node_rel :: \"('vi \\<times> 'v) set\" \n  assumes GR: \"SIDE_PRECOND (igb_fr_graph G)\"\n  assumes eq: \"GEN_OP node_eq_impl (=) (node_rel\\<rightarrow>node_rel\\<rightarrow>bool_rel)\"\n  assumes hash: \"SIDE_GEN_ALGO (is_bounded_hashcode node_rel node_eq_impl node_hash_impl)\"\n  assumes hash_dsz: \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('vi) node_def_hash_size)\"\n  assumes Gi: \"(G_impl,G)\\<in>igbg_impl_rel_ext Re node_rel\"\n  shows \"(RETURN (find_lasso_tr node_eq_impl node_hash_impl node_def_hash_size G_impl), \n    (OP op_find_lasso_spec \n      ::: igbg_impl_rel_ext Re node_rel \\<rightarrow> \\<langle>fl_rel node_rel\\<rangle>nres_rel)$G) \\<in> \\<langle>fl_rel node_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN\n      (find_lasso_tr node_eq_impl node_hash_impl node_def_hash_size G_impl),\n     (OP op_find_lasso_spec :::\n      igbg_impl_rel_ext Re node_rel \\<rightarrow>\n      \\<langle>fl_rel node_rel\\<rangle>nres_rel) $\n     G)\n    \\<in> \\<langle>fl_rel node_rel\\<rangle>nres_rel", "using find_lasso_tr_correct[OF Gi GEN_OP_D[OF eq] SIDE_GEN_ALGO_D[OF hash] SIDE_GEN_ALGO_D[OF hash_dsz]]"], ["proof (prove)\nusing this:\n  igb_fr_graph G \\<Longrightarrow>\n  RETURN\n   (find_lasso_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n  \\<le> \\<Down> (fl_rel node_rel) (igb_graph.find_lasso_spec G)\n\ngoal (1 subgoal):\n 1. (RETURN\n      (find_lasso_tr node_eq_impl node_hash_impl node_def_hash_size G_impl),\n     (OP op_find_lasso_spec :::\n      igbg_impl_rel_ext Re node_rel \\<rightarrow>\n      \\<langle>fl_rel node_rel\\<rangle>nres_rel) $\n     G)\n    \\<in> \\<langle>fl_rel node_rel\\<rangle>nres_rel", "using GR"], ["proof (prove)\nusing this:\n  igb_fr_graph G \\<Longrightarrow>\n  RETURN\n   (find_lasso_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n  \\<le> \\<Down> (fl_rel node_rel) (igb_graph.find_lasso_spec G)\n  SIDE_PRECOND (igb_fr_graph G)\n\ngoal (1 subgoal):\n 1. (RETURN\n      (find_lasso_tr node_eq_impl node_hash_impl node_def_hash_size G_impl),\n     (OP op_find_lasso_spec :::\n      igbg_impl_rel_ext Re node_rel \\<rightarrow>\n      \\<langle>fl_rel node_rel\\<rangle>nres_rel) $\n     G)\n    \\<in> \\<langle>fl_rel node_rel\\<rangle>nres_rel", "apply (fastforce intro!: nres_relI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}