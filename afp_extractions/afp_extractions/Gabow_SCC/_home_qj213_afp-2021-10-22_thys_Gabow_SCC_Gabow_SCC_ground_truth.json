{"file_name": "/home/qj213/afp-2021-10-22/thys/Gabow_SCC/Gabow_SCC.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Gabow_SCC", "problem_names": ["lemma l_no_empty: \"{}\\<notin>set l\"", "lemma locale_this: \"cscc_outer_invar_loc G it l D\"", "lemma abs_outer_this: \"outer_invar_loc G it D\"", "lemma locale_this: \"cscc_invar_loc G v0 D0 l p D pE\"", "lemma invar_this: \"invar_loc G v0 D0 p D pE\"", "lemma l_disjoint: \n    assumes A: \"i<j\" \"j<length l\"\n    shows \"l!i \\<inter> l!j = {}\"", "lemma cscc_invarI[intro?]:\n    assumes \"invar v0 D0 PDPE\"\n    assumes \"invar v0 D0 PDPE \\<Longrightarrow> cscc_invar_part (l,PDPE)\"\n    shows \"cscc_invar v0 D0 (l,PDPE)\"", "lemma cscc_outer_invarI[intro?]:\n    assumes \"outer_invar it D\"\n    assumes \"outer_invar it D \\<Longrightarrow> cscc_invar_ext G l D\"\n    shows \"cscc_outer_invar it (l,D)\"", "lemma cscc_invar_initial[simp, intro!]:\n    assumes A: \"v0\\<in>it\" \"v0\\<notin>D0\"\n    assumes INV: \"cscc_outer_invar it (l,D0)\"\n    shows \"cscc_invar_part (l,initial v0 D0)\"", "lemma cscc_invar_pop:\n    assumes INV: \"cscc_invar v0 D0 (l,p,D,pE)\"\n    assumes \"invar v0 D0 (pop (p,D,pE))\"\n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes NO': \"pE \\<inter> (last p \\<times> UNIV) = {}\"\n    shows \"cscc_invar_part (last p # l, pop (p,D,pE))\"", "lemma cscc_invar_unchanged: \n    assumes INV: \"cscc_invar v0 D0 (l,p,D,pE)\"\n    shows \"cscc_invar_part (l,p',D,pE')\"", "lemma cscc_outer_invar_initial: \"cscc_invar_ext G [] {}\"", "lemma cscc_invar_outer_newnode:\n    assumes A: \"v0\\<notin>D0\" \"v0\\<in>it\" \n    assumes OINV: \"cscc_outer_invar it (l,D0)\"\n    assumes INV: \"cscc_invar v0 D0 (l',[],D',pE)\"\n    shows \"cscc_invar_ext G l' D'\"", "lemma cscc_invar_outer_Dnode:\n    assumes \"cscc_outer_invar it (l, D)\"\n    shows \"cscc_invar_ext G l D\"", "lemmas cscc_invar_preserve = invar_preserve\n    cscc_invar_initial\n    cscc_invar_pop cscc_invar_collapse cscc_invar_push cscc_invar_unchanged \n    cscc_outer_invar_initial cscc_invar_outer_newnode cscc_invar_outer_Dnode", "lemma cscc_finI:\n    assumes INV: \"cscc_outer_invar {} (l,D)\"\n    shows fin_l_is_scc: \"\\<lbrakk>U\\<in>set l\\<rbrakk> \\<Longrightarrow> is_scc E U\"\n    and fin_l_distinct: \"distinct l\"\n    and fin_l_is_reachable: \"\\<Union>(set l) = E\\<^sup>* `` V0\"\n    and fin_l_no_fwd: \"\\<lbrakk>i<j; j<length l\\<rbrakk> \\<Longrightarrow> l!j \\<times>l!i \\<inter> E\\<^sup>* = {}\"", "lemma invar_from_cscc_invarI: \"cscc_invar v0 D0 (L,PDPE) \\<Longrightarrow> invar v0 D0 PDPE\"", "lemma outer_invar_from_cscc_invarI: \n    \"cscc_outer_invar it (L,D) \\<Longrightarrow>outer_invar it D\"", "theorem compute_SCC_correct: \"compute_SCC \\<le> compute_SCC_spec\"", "theorem \"compute_SCC \\<le> compute_SCC_spec\"", "lemma seg_set_impl_aux:\n    fixes l u\n    shows \"\\<lbrakk>l<u; u\\<le>length S; distinct S\\<rbrakk> \\<Longrightarrow> seg_set_impl l u \n    \\<le> SPEC (\\<lambda>r. r = {S!j | j. l\\<le>j \\<and> j<u})\"", "lemma (in GS_invar) seg_set_impl_correct:\n    assumes \"i<length B\"\n    shows \"seg_set_impl (seg_start i) (seg_end i) \\<le> SPEC (\\<lambda>r. r=p_\\<alpha>!i)\"", "lemma (in GS_invar) last_seg_impl_correct:\n    assumes \"p_\\<alpha> \\<noteq> []\"\n    shows \"last_seg_impl \\<le> SPEC (\\<lambda>r. r=last p_\\<alpha>)\"", "lemmas last_seg_impl_def_opt = \n    last_seg_impl_def[abs_def, THEN opt_GSdef, \n      unfolded GS.last_seg_impl_def GS.seg_set_impl_def \n    GS.seg_start_def GS.seg_end_def GS_sel_simps]", "lemma last_seg_impl_refine: \n    assumes A: \"(s,(p,D,pE))\\<in>GS_rel\"\n    assumes NE: \"p\\<noteq>[]\"\n    shows \"last_seg_impl s \\<le> \\<Down>Id (RETURN (last p))\"", "lemma compute_SCC_impl_refine: \"compute_SCC_impl \\<le> \\<Down>Id compute_SCC\""], "translations": [["", "lemma l_no_empty: \"{}\\<notin>set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<notin> set l", "using l_scc"], ["proof (prove)\nusing this:\n  set l \\<subseteq> Collect (is_scc E)\n\ngoal (1 subgoal):\n 1. {} \\<notin> set l", "by (auto simp: in_set_conv_decomp)"], ["", "end"], ["", "locale cscc_outer_invar_loc = outer_invar_loc G it D + cscc_invar_ext G l D\n  for G :: \"('v,'more) graph_rec_scheme\" and it l D \nbegin"], ["", "lemma locale_this: \"cscc_outer_invar_loc G it l D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cscc_outer_invar_loc G it l D", "by unfold_locales"], ["", "lemma abs_outer_this: \"outer_invar_loc G it D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_invar_loc G it D", "by unfold_locales"], ["", "end"], ["", "locale cscc_invar_loc = invar_loc G v0 D0 p D pE + cscc_invar_ext G l D\n  for G :: \"('v,'more) graph_rec_scheme\" and v0 D0 and l :: \"'v set list\" \n  and p D pE\nbegin"], ["", "lemma locale_this: \"cscc_invar_loc G v0 D0 l p D pE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cscc_invar_loc G v0 D0 l p D pE", "by unfold_locales"], ["", "lemma invar_this: \"invar_loc G v0 D0 p D pE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_loc G v0 D0 p D pE", "by unfold_locales"], ["", "end"], ["", "context fr_graph\nbegin"], ["", "definition \"cscc_outer_invar \\<equiv> \\<lambda>it (l,D). cscc_outer_invar_loc G it l D\""], ["", "definition \"cscc_invar \\<equiv> \\<lambda>v0 D0 (l,p,D,pE). cscc_invar_loc G v0 D0 l p D pE\""], ["", "end"], ["", "section \\<open>Definition of the SCC-Algorithm\\<close>"], ["", "context fr_graph\nbegin"], ["", "definition compute_SCC :: \"'v set list nres\" where\n    \"compute_SCC \\<equiv> do {\n      let so = ([],{});\n      (l,D) \\<leftarrow> FOREACHi cscc_outer_invar V0 (\\<lambda>v0 (l,D0). do {\n        if v0\\<notin>D0 then do {\n          let s = (l,initial v0 D0);\n\n          (l,p,D,pE) \\<leftarrow>\n          WHILEIT (cscc_invar v0 D0)\n            (\\<lambda>(l,p,D,pE). p \\<noteq> []) (\\<lambda>(l,p,D,pE). \n          do {\n            \\<comment> \\<open>Select edge from end of path\\<close>\n            (vo,(p,D,pE)) \\<leftarrow> select_edge (p,D,pE);\n\n            ASSERT (p\\<noteq>[]);\n            case vo of \n              Some v \\<Rightarrow> do {\n                if v \\<in> \\<Union>(set p) then do {\n                  \\<comment> \\<open>Collapse\\<close>\n                  RETURN (l,collapse v (p,D,pE))\n                } else if v\\<notin>D then do {\n                  \\<comment> \\<open>Edge to new node. Append to path\\<close>\n                  RETURN (l,push v (p,D,pE))\n                } else RETURN (l,p,D,pE)\n              }\n            | None \\<Rightarrow> do {\n                \\<comment> \\<open>No more outgoing edges from current node on path\\<close>\n                ASSERT (pE \\<inter> last p \\<times> UNIV = {});\n                let V = last p;\n                let (p,D,pE) = pop (p,D,pE);\n                let l = V#l;\n                RETURN (l,p,D,pE)\n              }\n          }) s;\n          ASSERT (p=[] \\<and> pE={});\n          RETURN (l,D)\n        } else\n          RETURN (l,D0)\n      }) so;\n      RETURN l\n    }\""], ["", "end"], ["", "section \\<open>Preservation of Invariant Extension\\<close>"], ["", "context cscc_invar_ext\nbegin"], ["", "lemma l_disjoint: \n    assumes A: \"i<j\" \"j<length l\"\n    shows \"l!i \\<inter> l!j = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l ! i \\<inter> l ! j = {}", "proof (rule disjointI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> l ! i; x \\<in> l ! j\\<rbrakk>\n       \\<Longrightarrow> False", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> l ! i; x \\<in> l ! j\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"u\\<in>l!i\" \"u\\<in>l!j\""], ["proof (state)\nthis:\n  u \\<in> l ! i\n  u \\<in> l ! j\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> l ! i; x \\<in> l ! j\\<rbrakk>\n       \\<Longrightarrow> False", "with l_no_fwd A"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i < ?j; ?j < length l\\<rbrakk>\n  \\<Longrightarrow> l ! ?j \\<times> l ! ?i \\<inter> E\\<^sup>* = {}\n  i < j\n  j < length l\n  u \\<in> l ! i\n  u \\<in> l ! j", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < ?j; ?j < length l\\<rbrakk>\n  \\<Longrightarrow> l ! ?j \\<times> l ! ?i \\<inter> E\\<^sup>* = {}\n  i < j\n  j < length l\n  u \\<in> l ! i\n  u \\<in> l ! j\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary l_distinct: \"distinct l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct l", "using l_disjoint l_no_empty"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < ?j; ?j < length l\\<rbrakk>\n  \\<Longrightarrow> l ! ?i \\<inter> l ! ?j = {}\n  {} \\<notin> set l\n\ngoal (1 subgoal):\n 1. distinct l", "by (metis distinct_conv_nth inf_idem linorder_cases nth_mem)"], ["", "end"], ["", "context fr_graph\nbegin"], ["", "definition \"cscc_invar_part \\<equiv> \\<lambda>(l,p,D,pE). cscc_invar_ext G l D\""], ["", "lemma cscc_invarI[intro?]:\n    assumes \"invar v0 D0 PDPE\"\n    assumes \"invar v0 D0 PDPE \\<Longrightarrow> cscc_invar_part (l,PDPE)\"\n    shows \"cscc_invar v0 D0 (l,PDPE)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cscc_invar v0 D0 (l, PDPE)", "using assms"], ["proof (prove)\nusing this:\n  invar v0 D0 PDPE\n  invar v0 D0 PDPE \\<Longrightarrow> cscc_invar_part (l, PDPE)\n\ngoal (1 subgoal):\n 1. cscc_invar v0 D0 (l, PDPE)", "unfolding initial_def cscc_invar_def invar_def"], ["proof (prove)\nusing this:\n  case PDPE of (p, xa, xb) \\<Rightarrow> invar_loc G v0 D0 p xa xb\n  case PDPE of\n  (p, xa, xb) \\<Rightarrow> invar_loc G v0 D0 p xa xb \\<Longrightarrow>\n  cscc_invar_part (l, PDPE)\n\ngoal (1 subgoal):\n 1. case (l, PDPE) of\n    (l, p, x, xb) \\<Rightarrow> cscc_invar_loc G v0 D0 l p x xb", "apply (simp split: prod.split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>cscc_invar_part (l, x1, x1a, x2a); PDPE = (x1, x1a, x2a);\n        x2 = (x1a, x2a); invar_loc G v0 D0 x1 x1a x2a\\<rbrakk>\n       \\<Longrightarrow> cscc_invar_loc G v0 D0 l x1 x1a x2a", "apply intro_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>cscc_invar_part (l, x1, x1a, x2a); PDPE = (x1, x1a, x2a);\n        x2 = (x1a, x2a); invar_loc G v0 D0 x1 x1a x2a\\<rbrakk>\n       \\<Longrightarrow> invar_loc_axioms G v0 D0 x1 x1a x2a\n 2. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>cscc_invar_part (l, x1, x1a, x2a); PDPE = (x1, x1a, x2a);\n        x2 = (x1a, x2a); invar_loc G v0 D0 x1 x1a x2a\\<rbrakk>\n       \\<Longrightarrow> cscc_invar_ext_axioms G l x1a", "apply (simp add: invar_loc_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>cscc_invar_part (l, x1, x1a, x2a); PDPE = (x1, x1a, x2a);\n        x2 = (x1a, x2a); invar_loc G v0 D0 x1 x1a x2a\\<rbrakk>\n       \\<Longrightarrow> cscc_invar_ext_axioms G l x1a", "apply (simp add: cscc_invar_part_def cscc_invar_ext_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "thm cscc_invarI[of v_0 D_0 s l]"], ["", "lemma cscc_outer_invarI[intro?]:\n    assumes \"outer_invar it D\"\n    assumes \"outer_invar it D \\<Longrightarrow> cscc_invar_ext G l D\"\n    shows \"cscc_outer_invar it (l,D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cscc_outer_invar it (l, D)", "using assms"], ["proof (prove)\nusing this:\n  outer_invar it D\n  outer_invar it D \\<Longrightarrow> cscc_invar_ext G l D\n\ngoal (1 subgoal):\n 1. cscc_outer_invar it (l, D)", "unfolding initial_def cscc_outer_invar_def outer_invar_def"], ["proof (prove)\nusing this:\n  outer_invar_loc G it D\n  outer_invar_loc G it D \\<Longrightarrow> cscc_invar_ext G l D\n\ngoal (1 subgoal):\n 1. case (l, D) of (x, xa) \\<Rightarrow> cscc_outer_invar_loc G it x xa", "apply (simp split: prod.split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>outer_invar_loc G it D; cscc_invar_ext G l D\\<rbrakk>\n    \\<Longrightarrow> cscc_outer_invar_loc G it l D", "apply intro_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>outer_invar_loc G it D; cscc_invar_ext G l D\\<rbrakk>\n    \\<Longrightarrow> outer_invar_loc_axioms G it D\n 2. \\<lbrakk>outer_invar_loc G it D; cscc_invar_ext G l D\\<rbrakk>\n    \\<Longrightarrow> cscc_invar_ext_axioms G l D", "apply (simp add: outer_invar_loc_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>outer_invar_loc G it D; cscc_invar_ext G l D\\<rbrakk>\n    \\<Longrightarrow> cscc_invar_ext_axioms G l D", "apply (simp add: cscc_invar_ext_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cscc_invar_initial[simp, intro!]:\n    assumes A: \"v0\\<in>it\" \"v0\\<notin>D0\"\n    assumes INV: \"cscc_outer_invar it (l,D0)\"\n    shows \"cscc_invar_part (l,initial v0 D0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cscc_invar_part (l, initial v0 D0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cscc_invar_part (l, initial v0 D0)", "from INV"], ["proof (chain)\npicking this:\n  cscc_outer_invar it (l, D0)", "interpret cscc_outer_invar_loc G it l D0"], ["proof (prove)\nusing this:\n  cscc_outer_invar it (l, D0)\n\ngoal (1 subgoal):\n 1. cscc_outer_invar_loc G it l D0", "unfolding cscc_outer_invar_def"], ["proof (prove)\nusing this:\n  case (l, D0) of (x, xa) \\<Rightarrow> cscc_outer_invar_loc G it x xa\n\ngoal (1 subgoal):\n 1. cscc_outer_invar_loc G it l D0", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. cscc_invar_part (l, initial v0 D0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cscc_invar_part (l, initial v0 D0)", "unfolding cscc_invar_part_def initial_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case (l, [{v0}], D0, E \\<inter> {v0} \\<times> UNIV) of\n    (l, p, D, pE) \\<Rightarrow> cscc_invar_ext G l D", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. cscc_invar_ext G l D0", "by unfold_locales"], ["proof (state)\nthis:\n  cscc_invar_part (l, initial v0 D0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cscc_invar_pop:\n    assumes INV: \"cscc_invar v0 D0 (l,p,D,pE)\"\n    assumes \"invar v0 D0 (pop (p,D,pE))\"\n    assumes NE[simp]: \"p\\<noteq>[]\"\n    assumes NO': \"pE \\<inter> (last p \\<times> UNIV) = {}\"\n    shows \"cscc_invar_part (last p # l, pop (p,D,pE))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cscc_invar_part (last p # l, pop (p, D, pE))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cscc_invar_part (last p # l, pop (p, D, pE))", "from INV"], ["proof (chain)\npicking this:\n  cscc_invar v0 D0 (l, p, D, pE)", "interpret cscc_invar_loc G v0 D0 l p D pE"], ["proof (prove)\nusing this:\n  cscc_invar v0 D0 (l, p, D, pE)\n\ngoal (1 subgoal):\n 1. cscc_invar_loc G v0 D0 l p D pE", "unfolding cscc_invar_def"], ["proof (prove)\nusing this:\n  case (l, p, D, pE) of\n  (l, p, x, xb) \\<Rightarrow> cscc_invar_loc G v0 D0 l p x xb\n\ngoal (1 subgoal):\n 1. cscc_invar_loc G v0 D0 l p D pE", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. cscc_invar_part (last p # l, pop (p, D, pE))", "have AUX_l_scc: \"is_scc E (last p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_scc E (last p)", "unfolding is_scc_pointwise"], ["proof (prove)\ngoal (1 subgoal):\n 1. last p \\<noteq> {} \\<and>\n    (\\<forall>u\\<in>last p.\n        \\<forall>v\\<in>last p.\n           (u, v) \\<in> (Restr E (last p))\\<^sup>*) \\<and>\n    (\\<forall>u\\<in>last p.\n        \\<forall>v.\n           v \\<notin> last p \\<and> (u, v) \\<in> E\\<^sup>* \\<longrightarrow>\n           (\\<forall>u'\\<in>last p. (v, u') \\<notin> E\\<^sup>*))", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. last p = {} \\<Longrightarrow> False\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> last p; v \\<in> last p\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> (Restr E (last p))\\<^sup>*\n 3. \\<And>u v u'.\n       \\<lbrakk>u \\<in> last p; u' \\<in> last p; v \\<notin> last p;\n        (u, v) \\<in> E\\<^sup>*; (v, u') \\<in> E\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> False", "{"], ["proof (state)\ngoal (3 subgoals):\n 1. last p = {} \\<Longrightarrow> False\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> last p; v \\<in> last p\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> (Restr E (last p))\\<^sup>*\n 3. \\<And>u v u'.\n       \\<lbrakk>u \\<in> last p; u' \\<in> last p; v \\<notin> last p;\n        (u, v) \\<in> E\\<^sup>*; (v, u') \\<in> E\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"last p = {}\""], ["proof (state)\nthis:\n  last p = {}\n\ngoal (3 subgoals):\n 1. last p = {} \\<Longrightarrow> False\n 2. \\<And>u v.\n       \\<lbrakk>u \\<in> last p; v \\<in> last p\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> (Restr E (last p))\\<^sup>*\n 3. \\<And>u v u'.\n       \\<lbrakk>u \\<in> last p; u' \\<in> last p; v \\<notin> last p;\n        (u, v) \\<in> E\\<^sup>*; (v, u') \\<in> E\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  last p = {}\n\ngoal (1 subgoal):\n 1. False", "using p_no_empty"], ["proof (prove)\nusing this:\n  last p = {}\n  {} \\<notin> set p\n\ngoal (1 subgoal):\n 1. False", "by (cases p rule: rev_cases) auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> last p; v \\<in> last p\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> (Restr E (last p))\\<^sup>*\n 2. \\<And>u v u'.\n       \\<lbrakk>u \\<in> last p; u' \\<in> last p; v \\<notin> last p;\n        (u, v) \\<in> E\\<^sup>*; (v, u') \\<in> E\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  last p = {} \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> last p; v \\<in> last p\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> (Restr E (last p))\\<^sup>*\n 2. \\<And>u v u'.\n       \\<lbrakk>u \\<in> last p; u' \\<in> last p; v \\<notin> last p;\n        (u, v) \\<in> E\\<^sup>*; (v, u') \\<in> E\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> False", "fix u v"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> last p; v \\<in> last p\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> (Restr E (last p))\\<^sup>*\n 2. \\<And>u v u'.\n       \\<lbrakk>u \\<in> last p; u' \\<in> last p; v \\<notin> last p;\n        (u, v) \\<in> E\\<^sup>*; (v, u') \\<in> E\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"u\\<in>last p\" \"v\\<in>last p\""], ["proof (state)\nthis:\n  u \\<in> last p\n  v \\<in> last p\n\ngoal (2 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> last p; v \\<in> last p\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> (Restr E (last p))\\<^sup>*\n 2. \\<And>u v u'.\n       \\<lbrakk>u \\<in> last p; u' \\<in> last p; v \\<notin> last p;\n        (u, v) \\<in> E\\<^sup>*; (v, u') \\<in> E\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> False", "with p_sc[of \"last p\"]"], ["proof (chain)\npicking this:\n  last p \\<in> set p \\<Longrightarrow>\n  last p \\<times> last p \\<subseteq> (Restr lvE (last p))\\<^sup>*\n  u \\<in> last p\n  v \\<in> last p", "have \"(u,v) \\<in> (lvE \\<inter> last p \\<times> last p)\\<^sup>*\""], ["proof (prove)\nusing this:\n  last p \\<in> set p \\<Longrightarrow>\n  last p \\<times> last p \\<subseteq> (Restr lvE (last p))\\<^sup>*\n  u \\<in> last p\n  v \\<in> last p\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> (Restr lvE (last p))\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (u, v) \\<in> (Restr lvE (last p))\\<^sup>*\n\ngoal (2 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>u \\<in> last p; v \\<in> last p\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> (Restr E (last p))\\<^sup>*\n 2. \\<And>u v u'.\n       \\<lbrakk>u \\<in> last p; u' \\<in> last p; v \\<notin> last p;\n        (u, v) \\<in> E\\<^sup>*; (v, u') \\<in> E\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> False", "with lvE_ss_E"], ["proof (chain)\npicking this:\n  lvE \\<subseteq> E\n  (u, v) \\<in> (Restr lvE (last p))\\<^sup>*", "show \"(u,v)\\<in>(E \\<inter> last p \\<times> last p)\\<^sup>*\""], ["proof (prove)\nusing this:\n  lvE \\<subseteq> E\n  (u, v) \\<in> (Restr lvE (last p))\\<^sup>*\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> (Restr E (last p))\\<^sup>*", "by (metis Int_mono equalityE rtrancl_mono_mp)"], ["proof (state)\nthis:\n  (u, v) \\<in> (Restr E (last p))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>u v u'.\n       \\<lbrakk>u \\<in> last p; u' \\<in> last p; v \\<notin> last p;\n        (u, v) \\<in> E\\<^sup>*; (v, u') \\<in> E\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> False", "fix u'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u v u'.\n       \\<lbrakk>u \\<in> last p; u' \\<in> last p; v \\<notin> last p;\n        (u, v) \\<in> E\\<^sup>*; (v, u') \\<in> E\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"u'\\<notin>last p\" \"(u,u')\\<in>E\\<^sup>*\" \"(u',v)\\<in>E\\<^sup>*\""], ["proof (state)\nthis:\n  u' \\<notin> last p\n  (u, u') \\<in> E\\<^sup>*\n  (u', v) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>u v u'.\n       \\<lbrakk>u \\<in> last p; u' \\<in> last p; v \\<notin> last p;\n        (u, v) \\<in> E\\<^sup>*; (v, u') \\<in> E\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>u'\\<notin>last p\\<close> \\<open>u\\<in>last p\\<close> \\<open>(u,u')\\<in>E\\<^sup>*\\<close>\n        and rtrancl_reachable_induct[OF order_refl lastp_un_D_closed[OF NE NO']]"], ["proof (chain)\npicking this:\n  u' \\<notin> last p\n  u \\<in> last p\n  (u, u') \\<in> E\\<^sup>*\n  E\\<^sup>* `` (last p \\<union> D) \\<subseteq> last p \\<union> D", "have \"u'\\<in>D\""], ["proof (prove)\nusing this:\n  u' \\<notin> last p\n  u \\<in> last p\n  (u, u') \\<in> E\\<^sup>*\n  E\\<^sup>* `` (last p \\<union> D) \\<subseteq> last p \\<union> D\n\ngoal (1 subgoal):\n 1. u' \\<in> D", "by auto"], ["proof (state)\nthis:\n  u' \\<in> D\n\ngoal (1 subgoal):\n 1. \\<And>u v u'.\n       \\<lbrakk>u \\<in> last p; u' \\<in> last p; v \\<notin> last p;\n        (u, v) \\<in> E\\<^sup>*; (v, u') \\<in> E\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>(u',v)\\<in>E\\<^sup>*\\<close> and rtrancl_reachable_induct[OF order_refl D_closed]"], ["proof (chain)\npicking this:\n  (u', v) \\<in> E\\<^sup>*\n  E\\<^sup>* `` D \\<subseteq> D\n  u' \\<in> D", "have \"v\\<in>D\""], ["proof (prove)\nusing this:\n  (u', v) \\<in> E\\<^sup>*\n  E\\<^sup>* `` D \\<subseteq> D\n  u' \\<in> D\n\ngoal (1 subgoal):\n 1. v \\<in> D", "by auto"], ["proof (state)\nthis:\n  v \\<in> D\n\ngoal (1 subgoal):\n 1. \\<And>u v u'.\n       \\<lbrakk>u \\<in> last p; u' \\<in> last p; v \\<notin> last p;\n        (u, v) \\<in> E\\<^sup>*; (v, u') \\<in> E\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> False", "with \\<open>v\\<in>last p\\<close> p_not_D"], ["proof (chain)\npicking this:\n  v \\<in> last p\n  \\<Union> (set p) \\<inter> D = {}\n  v \\<in> D", "show False"], ["proof (prove)\nusing this:\n  v \\<in> last p\n  \\<Union> (set p) \\<inter> D = {}\n  v \\<in> D\n\ngoal (1 subgoal):\n 1. False", "by (cases p rule: rev_cases) auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_scc E (last p)\n\ngoal (1 subgoal):\n 1. cscc_invar_part (last p # l, pop (p, D, pE))", "{"], ["proof (state)\nthis:\n  is_scc E (last p)\n\ngoal (1 subgoal):\n 1. cscc_invar_part (last p # l, pop (p, D, pE))", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. cscc_invar_part (last p # l, pop (p, D, pE))", "assume A: \"i<j\" \"j<Suc (length l)\""], ["proof (state)\nthis:\n  i < j\n  j < Suc (length l)\n\ngoal (1 subgoal):\n 1. cscc_invar_part (last p # l, pop (p, D, pE))", "have \"l ! (j - Suc 0) \\<times> (last p # l) ! i \\<inter> E\\<^sup>* = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l ! (j - Suc 0) \\<times> (last p # l) ! i \\<inter> E\\<^sup>* = {}", "proof (rule disjointI, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> E\\<^sup>*; a \\<in> l ! (j - Suc 0);\n        b \\<in> (last p # l) ! i\\<rbrakk>\n       \\<Longrightarrow> False", "fix u v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> E\\<^sup>*; a \\<in> l ! (j - Suc 0);\n        b \\<in> (last p # l) ! i\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"(u, v) \\<in> E\\<^sup>*\" \"u \\<in> l ! (j - Suc 0)\" \"v \\<in> (last p # l) ! i\""], ["proof (state)\nthis:\n  (u, v) \\<in> E\\<^sup>*\n  u \\<in> l ! (j - Suc 0)\n  v \\<in> (last p # l) ! i\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> E\\<^sup>*; a \\<in> l ! (j - Suc 0);\n        b \\<in> (last p # l) ! i\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>u \\<in> l ! (j - Suc 0)\\<close> A"], ["proof (chain)\npicking this:\n  u \\<in> l ! (j - Suc 0)\n  i < j\n  j < Suc (length l)", "have \"u\\<in>\\<Union>(set l)\""], ["proof (prove)\nusing this:\n  u \\<in> l ! (j - Suc 0)\n  i < j\n  j < Suc (length l)\n\ngoal (1 subgoal):\n 1. u \\<in> \\<Union> (set l)", "by (metis Ex_list_of_length Suc_pred UnionI length_greater_0_conv \n            less_nat_zero_code not_less_eq nth_mem)"], ["proof (state)\nthis:\n  u \\<in> \\<Union> (set l)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> E\\<^sup>*; a \\<in> l ! (j - Suc 0);\n        b \\<in> (last p # l) ! i\\<rbrakk>\n       \\<Longrightarrow> False", "with l_is_D"], ["proof (chain)\npicking this:\n  \\<Union> (set l) = D\n  u \\<in> \\<Union> (set l)", "have \"u\\<in>D\""], ["proof (prove)\nusing this:\n  \\<Union> (set l) = D\n  u \\<in> \\<Union> (set l)\n\ngoal (1 subgoal):\n 1. u \\<in> D", "by simp"], ["proof (state)\nthis:\n  u \\<in> D\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> E\\<^sup>*; a \\<in> l ! (j - Suc 0);\n        b \\<in> (last p # l) ! i\\<rbrakk>\n       \\<Longrightarrow> False", "with rtrancl_reachable_induct[OF order_refl D_closed] \\<open>(u,v)\\<in>E\\<^sup>*\\<close>"], ["proof (chain)\npicking this:\n  E\\<^sup>* `` D \\<subseteq> D\n  (u, v) \\<in> E\\<^sup>*\n  u \\<in> D", "have \"v\\<in>D\""], ["proof (prove)\nusing this:\n  E\\<^sup>* `` D \\<subseteq> D\n  (u, v) \\<in> E\\<^sup>*\n  u \\<in> D\n\ngoal (1 subgoal):\n 1. v \\<in> D", "by auto"], ["proof (state)\nthis:\n  v \\<in> D\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> E\\<^sup>*; a \\<in> l ! (j - Suc 0);\n        b \\<in> (last p # l) ! i\\<rbrakk>\n       \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "assume \"i=0\""], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "hence \"v\\<in>last p\""], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. v \\<in> last p", "using \\<open>v \\<in> (last p # l) ! i\\<close>"], ["proof (prove)\nusing this:\n  i = 0\n  v \\<in> (last p # l) ! i\n\ngoal (1 subgoal):\n 1. v \\<in> last p", "by simp"], ["proof (state)\nthis:\n  v \\<in> last p\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "with p_not_D \\<open>v\\<in>D\\<close>"], ["proof (chain)\npicking this:\n  \\<Union> (set p) \\<inter> D = {}\n  v \\<in> D\n  v \\<in> last p", "show False"], ["proof (prove)\nusing this:\n  \\<Union> (set p) \\<inter> D = {}\n  v \\<in> D\n  v \\<in> last p\n\ngoal (1 subgoal):\n 1. False", "by (cases p rule: rev_cases) auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> False", "assume \"i\\<noteq>0\""], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> False", "with \\<open>v \\<in> (last p # l) ! i\\<close>"], ["proof (chain)\npicking this:\n  v \\<in> (last p # l) ! i\n  i \\<noteq> 0", "have \"v\\<in>l!(i - 1)\""], ["proof (prove)\nusing this:\n  v \\<in> (last p # l) ! i\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. v \\<in> l ! (i - 1)", "by auto"], ["proof (state)\nthis:\n  v \\<in> l ! (i - 1)\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> False", "with l_no_fwd[of \"i - 1\" \"j - 1\"] \n            and \\<open>u \\<in> l ! (j - Suc 0)\\<close> \\<open>(u, v) \\<in> E\\<^sup>*\\<close> \\<open>i\\<noteq>0\\<close> A"], ["proof (chain)\npicking this:\n  \\<lbrakk>i - 1 < j - 1; j - 1 < length l\\<rbrakk>\n  \\<Longrightarrow> l ! (j - 1) \\<times> l ! (i - 1) \\<inter> E\\<^sup>* = {}\n  u \\<in> l ! (j - Suc 0)\n  (u, v) \\<in> E\\<^sup>*\n  i \\<noteq> 0\n  i < j\n  j < Suc (length l)\n  v \\<in> l ! (i - 1)", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>i - 1 < j - 1; j - 1 < length l\\<rbrakk>\n  \\<Longrightarrow> l ! (j - 1) \\<times> l ! (i - 1) \\<inter> E\\<^sup>* = {}\n  u \\<in> l ! (j - Suc 0)\n  (u, v) \\<in> E\\<^sup>*\n  i \\<noteq> 0\n  i < j\n  j < Suc (length l)\n  v \\<in> l ! (i - 1)\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  l ! (j - Suc 0) \\<times> (last p # l) ! i \\<inter> E\\<^sup>* = {}\n\ngoal (1 subgoal):\n 1. cscc_invar_part (last p # l, pop (p, D, pE))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i3 < ?j3; ?j3 < Suc (length l)\\<rbrakk>\n  \\<Longrightarrow> l ! (?j3 - Suc 0) \\<times> (last p # l) ! ?i3 \\<inter>\n                    E\\<^sup>* =\n                    {}\n\ngoal (1 subgoal):\n 1. cscc_invar_part (last p # l, pop (p, D, pE))", "note AUX_l_no_fwd = this"], ["proof (state)\nthis:\n  \\<lbrakk>?i3 < ?j3; ?j3 < Suc (length l)\\<rbrakk>\n  \\<Longrightarrow> l ! (?j3 - Suc 0) \\<times> (last p # l) ! ?i3 \\<inter>\n                    E\\<^sup>* =\n                    {}\n\ngoal (1 subgoal):\n 1. cscc_invar_part (last p # l, pop (p, D, pE))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cscc_invar_part (last p # l, pop (p, D, pE))", "unfolding cscc_invar_part_def pop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case (last p # l,\n          let (p, D, pE) = (p, D, pE); (p, V) = (butlast p, last p);\n              D = V \\<union> D\n          in (p, D, pE)) of\n    (l, p, D, pE) \\<Rightarrow> cscc_invar_ext G l D", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. cscc_invar_ext G (last p # l) (last p \\<union> D)", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<Union> (set (last p # l)) = last p \\<union> D\n 2. set (last p # l) \\<subseteq> Collect (is_scc E)\n 3. \\<And>i j.\n       \\<lbrakk>i < j; j < length (last p # l)\\<rbrakk>\n       \\<Longrightarrow> (last p # l) ! j \\<times> (last p # l) ! i \\<inter>\n                         E\\<^sup>* =\n                         {}", "apply clarsimp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. last p \\<union> \\<Union> (set l) = last p \\<union> D\n 2. is_scc E (last p) \\<and> set l \\<subseteq> Collect (is_scc E)\n 3. \\<And>i j.\n       \\<lbrakk>i < j; j < Suc (length l)\\<rbrakk>\n       \\<Longrightarrow> l ! (j - Suc 0) \\<times> (last p # l) ! i \\<inter>\n                         E\\<^sup>* =\n                         {}", "using l_is_D"], ["proof (prove)\nusing this:\n  \\<Union> (set l) = D\n\ngoal (3 subgoals):\n 1. last p \\<union> \\<Union> (set l) = last p \\<union> D\n 2. is_scc E (last p) \\<and> set l \\<subseteq> Collect (is_scc E)\n 3. \\<And>i j.\n       \\<lbrakk>i < j; j < Suc (length l)\\<rbrakk>\n       \\<Longrightarrow> l ! (j - Suc 0) \\<times> (last p # l) ! i \\<inter>\n                         E\\<^sup>* =\n                         {}", "apply auto []"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_scc E (last p) \\<and> set l \\<subseteq> Collect (is_scc E)\n 2. \\<And>i j.\n       \\<lbrakk>i < j; j < Suc (length l)\\<rbrakk>\n       \\<Longrightarrow> l ! (j - Suc 0) \\<times> (last p # l) ! i \\<inter>\n                         E\\<^sup>* =\n                         {}", "using l_scc AUX_l_scc"], ["proof (prove)\nusing this:\n  set l \\<subseteq> Collect (is_scc E)\n  is_scc E (last p)\n\ngoal (2 subgoals):\n 1. is_scc E (last p) \\<and> set l \\<subseteq> Collect (is_scc E)\n 2. \\<And>i j.\n       \\<lbrakk>i < j; j < Suc (length l)\\<rbrakk>\n       \\<Longrightarrow> l ! (j - Suc 0) \\<times> (last p # l) ! i \\<inter>\n                         E\\<^sup>* =\n                         {}", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < j; j < Suc (length l)\\<rbrakk>\n       \\<Longrightarrow> l ! (j - Suc 0) \\<times> (last p # l) ! i \\<inter>\n                         E\\<^sup>* =\n                         {}", "apply (rule AUX_l_no_fwd, assumption+) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  cscc_invar_part (last p # l, pop (p, D, pE))\n\ngoal:\nNo subgoals!", "qed"], ["", "thm cscc_invar_pop[of v_0 D_0 l p D pE]"], ["", "lemma cscc_invar_unchanged: \n    assumes INV: \"cscc_invar v0 D0 (l,p,D,pE)\"\n    shows \"cscc_invar_part (l,p',D,pE')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cscc_invar_part (l, p', D, pE')", "using INV"], ["proof (prove)\nusing this:\n  cscc_invar v0 D0 (l, p, D, pE)\n\ngoal (1 subgoal):\n 1. cscc_invar_part (l, p', D, pE')", "unfolding cscc_invar_def cscc_invar_part_def cscc_invar_loc_def"], ["proof (prove)\nusing this:\n  case (l, p, D, pE) of\n  (l, p, D, pE) \\<Rightarrow>\n    invar_loc G v0 D0 p D pE \\<and> cscc_invar_ext G l D\n\ngoal (1 subgoal):\n 1. case (l, p', D, pE') of (l, p, D, pE) \\<Rightarrow> cscc_invar_ext G l D", "by simp"], ["", "corollary cscc_invar_collapse:\n    assumes INV: \"cscc_invar v0 D0 (l,p,D,pE)\"\n    shows \"cscc_invar_part (l,collapse v (p',D,pE'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cscc_invar_part (l, collapse v (p', D, pE'))", "unfolding collapse_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cscc_invar_part\n     (l, let (p, D, pE) = (p', D, pE'); i = idx_of p v; p = collapse_aux p i\n         in (p, D, pE))", "by (simp add: cscc_invar_unchanged[OF INV])"], ["", "corollary cscc_invar_push:\n    assumes INV: \"cscc_invar v0 D0 (l,p,D,pE)\"\n    shows \"cscc_invar_part (l,push v (p',D,pE'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cscc_invar_part (l, push v (p', D, pE'))", "unfolding push_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cscc_invar_part\n     (l, let (p, D, pE) = (p', D, pE'); p = p @ [{v}];\n             pE = pE \\<union> E \\<inter> {v} \\<times> UNIV\n         in (p, D, pE))", "by (simp add: cscc_invar_unchanged[OF INV])"], ["", "lemma cscc_outer_invar_initial: \"cscc_invar_ext G [] {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cscc_invar_ext G [] {}", "by unfold_locales auto"], ["", "lemma cscc_invar_outer_newnode:\n    assumes A: \"v0\\<notin>D0\" \"v0\\<in>it\" \n    assumes OINV: \"cscc_outer_invar it (l,D0)\"\n    assumes INV: \"cscc_invar v0 D0 (l',[],D',pE)\"\n    shows \"cscc_invar_ext G l' D'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cscc_invar_ext G l' D'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cscc_invar_ext G l' D'", "from OINV"], ["proof (chain)\npicking this:\n  cscc_outer_invar it (l, D0)", "interpret cscc_outer_invar_loc G it l D0"], ["proof (prove)\nusing this:\n  cscc_outer_invar it (l, D0)\n\ngoal (1 subgoal):\n 1. cscc_outer_invar_loc G it l D0", "unfolding cscc_outer_invar_def"], ["proof (prove)\nusing this:\n  case (l, D0) of (x, xa) \\<Rightarrow> cscc_outer_invar_loc G it x xa\n\ngoal (1 subgoal):\n 1. cscc_outer_invar_loc G it l D0", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. cscc_invar_ext G l' D'", "from INV"], ["proof (chain)\npicking this:\n  cscc_invar v0 D0 (l', [], D', pE)", "interpret inv: cscc_invar_loc G v0 D0 l' \"[]\" D' pE"], ["proof (prove)\nusing this:\n  cscc_invar v0 D0 (l', [], D', pE)\n\ngoal (1 subgoal):\n 1. cscc_invar_loc G v0 D0 l' [] D' pE", "unfolding cscc_invar_def"], ["proof (prove)\nusing this:\n  case (l', [], D', pE) of\n  (l, p, x, xb) \\<Rightarrow> cscc_invar_loc G v0 D0 l p x xb\n\ngoal (1 subgoal):\n 1. cscc_invar_loc G v0 D0 l' [] D' pE", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. cscc_invar_ext G l' D'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cscc_invar_ext G l' D'", "by unfold_locales"], ["proof (state)\nthis:\n  cscc_invar_ext G l' D'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cscc_invar_outer_Dnode:\n    assumes \"cscc_outer_invar it (l, D)\"\n    shows \"cscc_invar_ext G l D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cscc_invar_ext G l D", "using assms"], ["proof (prove)\nusing this:\n  cscc_outer_invar it (l, D)\n\ngoal (1 subgoal):\n 1. cscc_invar_ext G l D", "by (simp add: cscc_outer_invar_def cscc_outer_invar_loc_def)"], ["", "lemmas cscc_invar_preserve = invar_preserve\n    cscc_invar_initial\n    cscc_invar_pop cscc_invar_collapse cscc_invar_push cscc_invar_unchanged \n    cscc_outer_invar_initial cscc_invar_outer_newnode cscc_invar_outer_Dnode"], ["", "text \\<open>On termination, the invariant implies the specification\\<close>"], ["", "lemma cscc_finI:\n    assumes INV: \"cscc_outer_invar {} (l,D)\"\n    shows fin_l_is_scc: \"\\<lbrakk>U\\<in>set l\\<rbrakk> \\<Longrightarrow> is_scc E U\"\n    and fin_l_distinct: \"distinct l\"\n    and fin_l_is_reachable: \"\\<Union>(set l) = E\\<^sup>* `` V0\"\n    and fin_l_no_fwd: \"\\<lbrakk>i<j; j<length l\\<rbrakk> \\<Longrightarrow> l!j \\<times>l!i \\<inter> E\\<^sup>* = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((U \\<in> set l \\<Longrightarrow> is_scc E U) &&& distinct l) &&&\n    \\<Union> (set l) = reachable &&&\n    (\\<lbrakk>i < j; j < length l\\<rbrakk>\n     \\<Longrightarrow> l ! j \\<times> l ! i \\<inter> E\\<^sup>* = {})", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. U \\<in> set l \\<Longrightarrow> is_scc E U\n 2. distinct l\n 3. \\<Union> (set l) = reachable\n 4. \\<lbrakk>i < j; j < length l\\<rbrakk>\n    \\<Longrightarrow> l ! j \\<times> l ! i \\<inter> E\\<^sup>* = {}", "from INV"], ["proof (chain)\npicking this:\n  cscc_outer_invar {} (l, D)", "interpret cscc_outer_invar_loc G \"{}\" l D"], ["proof (prove)\nusing this:\n  cscc_outer_invar {} (l, D)\n\ngoal (1 subgoal):\n 1. cscc_outer_invar_loc G {} l D", "unfolding cscc_outer_invar_def"], ["proof (prove)\nusing this:\n  case (l, D) of (x, xa) \\<Rightarrow> cscc_outer_invar_loc G {} x xa\n\ngoal (1 subgoal):\n 1. cscc_outer_invar_loc G {} l D", "by simp"], ["proof (state)\ngoal (4 subgoals):\n 1. U \\<in> set l \\<Longrightarrow> is_scc E U\n 2. distinct l\n 3. \\<Union> (set l) = reachable\n 4. \\<lbrakk>i < j; j < length l\\<rbrakk>\n    \\<Longrightarrow> l ! j \\<times> l ! i \\<inter> E\\<^sup>* = {}", "show \"\\<lbrakk>U\\<in>set l\\<rbrakk> \\<Longrightarrow> is_scc E U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<in> set l \\<Longrightarrow> is_scc E U", "using l_scc"], ["proof (prove)\nusing this:\n  set l \\<subseteq> Collect (is_scc E)\n\ngoal (1 subgoal):\n 1. U \\<in> set l \\<Longrightarrow> is_scc E U", "by auto"], ["proof (state)\nthis:\n  U \\<in> set l \\<Longrightarrow> is_scc E U\n\ngoal (3 subgoals):\n 1. distinct l\n 2. \\<Union> (set l) = reachable\n 3. \\<lbrakk>i < j; j < length l\\<rbrakk>\n    \\<Longrightarrow> l ! j \\<times> l ! i \\<inter> E\\<^sup>* = {}", "show \"distinct l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct l", "by (rule l_distinct)"], ["proof (state)\nthis:\n  distinct l\n\ngoal (2 subgoals):\n 1. \\<Union> (set l) = reachable\n 2. \\<lbrakk>i < j; j < length l\\<rbrakk>\n    \\<Longrightarrow> l ! j \\<times> l ! i \\<inter> E\\<^sup>* = {}", "show \"\\<Union>(set l) = E\\<^sup>* `` V0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (set l) = reachable", "using fin_outer_D_is_reachable[OF outer_invar_this] l_is_D"], ["proof (prove)\nusing this:\n  D = reachable\n  \\<Union> (set l) = D\n\ngoal (1 subgoal):\n 1. \\<Union> (set l) = reachable", "by auto"], ["proof (state)\nthis:\n  \\<Union> (set l) = reachable\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < j; j < length l\\<rbrakk>\n    \\<Longrightarrow> l ! j \\<times> l ! i \\<inter> E\\<^sup>* = {}", "show \"\\<lbrakk>i<j; j<length l\\<rbrakk> \\<Longrightarrow> l!j \\<times>l!i \\<inter> E\\<^sup>* = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < j; j < length l\\<rbrakk>\n    \\<Longrightarrow> l ! j \\<times> l ! i \\<inter> E\\<^sup>* = {}", "by (rule l_no_fwd)"], ["proof (state)\nthis:\n  \\<lbrakk>i < j; j < length l\\<rbrakk>\n  \\<Longrightarrow> l ! j \\<times> l ! i \\<inter> E\\<^sup>* = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "section \\<open>Main Correctness Proof\\<close>"], ["", "context fr_graph \nbegin"], ["", "lemma invar_from_cscc_invarI: \"cscc_invar v0 D0 (L,PDPE) \\<Longrightarrow> invar v0 D0 PDPE\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cscc_invar v0 D0 (L, PDPE) \\<Longrightarrow> invar v0 D0 PDPE", "unfolding cscc_invar_def invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case (L, PDPE) of\n    (l, p, x, xb) \\<Rightarrow>\n      cscc_invar_loc G v0 D0 l p x xb \\<Longrightarrow>\n    case PDPE of (p, xa, xb) \\<Rightarrow> invar_loc G v0 D0 p xa xb", "apply (simp split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>PDPE = (x1, x1a, x2a); x2 = (x1a, x2a);\n        cscc_invar_loc G v0 D0 L x1 x1a x2a\\<rbrakk>\n       \\<Longrightarrow> invar_loc G v0 D0 x1 x1a x2a", "unfolding cscc_invar_loc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x1a x2a.\n       \\<lbrakk>PDPE = (x1, x1a, x2a); x2 = (x1a, x2a);\n        invar_loc G v0 D0 x1 x1a x2a \\<and> cscc_invar_ext G L x1a\\<rbrakk>\n       \\<Longrightarrow> invar_loc G v0 D0 x1 x1a x2a", "by simp"], ["", "lemma outer_invar_from_cscc_invarI: \n    \"cscc_outer_invar it (L,D) \\<Longrightarrow>outer_invar it D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cscc_outer_invar it (L, D) \\<Longrightarrow> outer_invar it D", "unfolding cscc_outer_invar_def outer_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case (L, D) of\n    (x, xa) \\<Rightarrow> cscc_outer_invar_loc G it x xa \\<Longrightarrow>\n    outer_invar_loc G it D", "apply (simp split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cscc_outer_invar_loc G it L D \\<Longrightarrow> outer_invar_loc G it D", "unfolding cscc_outer_invar_loc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. outer_invar_loc G it D \\<and> cscc_invar_ext G L D \\<Longrightarrow>\n    outer_invar_loc G it D", "by simp"], ["", "text \\<open>With the extended invariant and the auxiliary lemmas, the actual \n    correctness proof is straightforward:\\<close>"], ["", "theorem compute_SCC_correct: \"compute_SCC \\<le> compute_SCC_spec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compute_SCC \\<le> compute_SCC_spec", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. compute_SCC \\<le> compute_SCC_spec", "note [[goals_limit = 2]]"], ["proof (state)\nthis:\n  TERM _\n\ngoal (1 subgoal):\n 1. compute_SCC \\<le> compute_SCC_spec", "note [simp del] = Union_iff"], ["proof (state)\nthis:\n  (?A \\<in> \\<Union> ?C) = (\\<exists>X\\<in>?C. ?A \\<in> X)\n\ngoal (1 subgoal):\n 1. compute_SCC \\<le> compute_SCC_spec", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. compute_SCC \\<le> compute_SCC_spec", "unfolding compute_SCC_def compute_SCC_spec_def select_edge_def select_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let so = ([], {})\n     in FOREACH\\<^bsup>cscc_outer_invar\\<^esup> V0\n         (\\<lambda>v0 (l, D0).\n             if v0 \\<notin> D0\n             then let s = (l, initial v0 D0)\n                  in WHILE\\<^sub>T\\<^bsup>cscc_invar v0 D0\\<^esup>\n                      (\\<lambda>(l, p, D, pE). p \\<noteq> [])\n                      (\\<lambda>(l, p, D, pE).\n                          (let (p, D, pE) = (p, D, pE)\n                           in SELECT\n                               (\\<lambda>e.\n                                   e \\<in> pE \\<inter>\n     last p \\<times> UNIV) \\<bind>\n                              (\\<lambda>e.\n                                  case e of\n                                  None \\<Rightarrow> RETURN (None, p, D, pE)\n                                  | Some (u, v) \\<Rightarrow>\nRETURN (Some v, p, D, pE - {(u, v)}))) \\<bind>\n                          (\\<lambda>(vo, p, D, pE).\n                              ASSERT (p \\<noteq> []) \\<bind>\n                              (\\<lambda>_.\n                                  case vo of\n                                  None \\<Rightarrow>\n                                    ASSERT\n                                     (pE \\<inter> last p \\<times> UNIV =\n{}) \\<bind>\n                                    (\\<lambda>_.\n  let V = last p; (p, D, pE) = pop (p, D, pE); l = V # l\n  in RETURN (l, p, D, pE))\n                                  | Some v \\<Rightarrow>\nif v \\<in> \\<Union> (set p) then RETURN (l, collapse v (p, D, pE))\nelse if v \\<notin> D then RETURN (l, push v (p, D, pE))\n     else RETURN (l, p, D, pE))))\n                      s \\<bind>\n                     (\\<lambda>(l, p, D, pE).\n                         ASSERT (p = [] \\<and> pE = {}) \\<bind>\n                         (\\<lambda>_. RETURN (l, D)))\n             else RETURN (l, D0))\n         so \\<bind>\n        (\\<lambda>(l, D). RETURN l))\n    \\<le> SPEC\n           (\\<lambda>l.\n               distinct l \\<and>\n               \\<Union> (set l) = reachable \\<and>\n               (\\<forall>U\\<in>set l. is_scc E U) \\<and>\n               (\\<forall>i j.\n                   i < j \\<and> j < length l \\<longrightarrow>\n                   l ! j \\<times> l ! i \\<inter> E\\<^sup>* = {}))", "apply (refine_rcg\n        WHILEIT_rule[where R=\"inv_image (abs_wf_rel v0) snd\" for v0]\n        refine_vcg \n      )"], ["proof (prove)\ngoal (52 subgoals):\n 1. finite V0\n 2. cscc_outer_invar V0 ([], {})\nA total of 52 subgoals...", "apply (vc_solve\n        rec: cscc_invarI cscc_outer_invarI\n        solve: cscc_invar_preserve cscc_finI\n        intro: invar_from_cscc_invarI outer_invar_from_cscc_invarI\n        dest!: sym[of \"pop A\" for A]\n        simp: pE_fin'[OF invar_from_cscc_invarI] finite_V0\n      )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x it aa ba aaa aca bca ada.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> V0; cscc_outer_invar it (aa, ba);\n        x \\<notin> ba; cscc_invar x ba (aaa, ada, aca, bca);\n        \\<forall>a.\n           (\\<exists>b. (a, b) \\<in> bca) \\<longrightarrow>\n           a \\<notin> last ada;\n        ada \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> bca \\<inter> last ada \\<times> UNIV = {}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  compute_SCC \\<le> compute_SCC_spec\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Simple proof, for presentation\\<close>"], ["", "context \n    notes [refine]=refine_vcg\n    notes [[goals_limit = 1]]\n  begin"], ["", "theorem \"compute_SCC \\<le> compute_SCC_spec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compute_SCC \\<le> compute_SCC_spec", "unfolding compute_SCC_def compute_SCC_spec_def select_edge_def select_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let so = ([], {})\n     in FOREACH\\<^bsup>cscc_outer_invar\\<^esup> V0\n         (\\<lambda>v0 (l, D0).\n             if v0 \\<notin> D0\n             then let s = (l, initial v0 D0)\n                  in WHILE\\<^sub>T\\<^bsup>cscc_invar v0 D0\\<^esup>\n                      (\\<lambda>(l, p, D, pE). p \\<noteq> [])\n                      (\\<lambda>(l, p, D, pE).\n                          (let (p, D, pE) = (p, D, pE)\n                           in SELECT\n                               (\\<lambda>e.\n                                   e \\<in> pE \\<inter>\n     last p \\<times> UNIV) \\<bind>\n                              (\\<lambda>e.\n                                  case e of\n                                  None \\<Rightarrow> RETURN (None, p, D, pE)\n                                  | Some (u, v) \\<Rightarrow>\nRETURN (Some v, p, D, pE - {(u, v)}))) \\<bind>\n                          (\\<lambda>(vo, p, D, pE).\n                              ASSERT (p \\<noteq> []) \\<bind>\n                              (\\<lambda>_.\n                                  case vo of\n                                  None \\<Rightarrow>\n                                    ASSERT\n                                     (pE \\<inter> last p \\<times> UNIV =\n{}) \\<bind>\n                                    (\\<lambda>_.\n  let V = last p; (p, D, pE) = pop (p, D, pE); l = V # l\n  in RETURN (l, p, D, pE))\n                                  | Some v \\<Rightarrow>\nif v \\<in> \\<Union> (set p) then RETURN (l, collapse v (p, D, pE))\nelse if v \\<notin> D then RETURN (l, push v (p, D, pE))\n     else RETURN (l, p, D, pE))))\n                      s \\<bind>\n                     (\\<lambda>(l, p, D, pE).\n                         ASSERT (p = [] \\<and> pE = {}) \\<bind>\n                         (\\<lambda>_. RETURN (l, D)))\n             else RETURN (l, D0))\n         so \\<bind>\n        (\\<lambda>(l, D). RETURN l))\n    \\<le> SPEC\n           (\\<lambda>l.\n               distinct l \\<and>\n               \\<Union> (set l) = reachable \\<and>\n               (\\<forall>U\\<in>set l. is_scc E U) \\<and>\n               (\\<forall>i j.\n                   i < j \\<and> j < length l \\<longrightarrow>\n                   l ! j \\<times> l ! i \\<inter> E\\<^sup>* = {}))", "by (refine_rcg \n        WHILEIT_rule[where R=\"inv_image (abs_wf_rel v0) snd\" for v0])\n      (vc_solve \n        rec: cscc_invarI cscc_outer_invarI solve: cscc_invar_preserve cscc_finI\n        intro: invar_from_cscc_invarI outer_invar_from_cscc_invarI\n        dest!: sym[of \"pop A\" for A]\n        simp: pE_fin'[OF invar_from_cscc_invarI] finite_V0, auto)"], ["", "end"], ["", "end"], ["", "section \\<open>Refinement to Gabow's Data Structure\\<close>"], ["", "context GS begin"], ["", "definition \"seg_set_impl l u \\<equiv> do {\n    (_,res) \\<leftarrow> WHILET\n      (\\<lambda>(l,_). l<u) \n      (\\<lambda>(l,res). do { \n        ASSERT (l<length S); \n        let x = S!l;\n        ASSERT (x\\<notin>res); \n        RETURN (Suc l,insert x res)\n      }) \n      (l,{});\n      \n    RETURN res\n  }\""], ["", "lemma seg_set_impl_aux:\n    fixes l u\n    shows \"\\<lbrakk>l<u; u\\<le>length S; distinct S\\<rbrakk> \\<Longrightarrow> seg_set_impl l u \n    \\<le> SPEC (\\<lambda>r. r = {S!j | j. l\\<le>j \\<and> j<u})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l < u; u \\<le> length S; distinct S\\<rbrakk>\n    \\<Longrightarrow> seg_set_impl l u\n                      \\<le> SPEC\n                             (\\<lambda>r.\n                                 r = {S ! j |j. l \\<le> j \\<and> j < u})", "unfolding seg_set_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l < u; u \\<le> length S; distinct S\\<rbrakk>\n    \\<Longrightarrow> WHILE\\<^sub>T (\\<lambda>(l, uu_). l < u)\n                       (\\<lambda>(l, res).\n                           ASSERT (l < length S) \\<bind>\n                           (\\<lambda>_.\n                               let x = S ! l\n                               in ASSERT (x \\<notin> res) \\<bind>\n                                  (\\<lambda>_.\nRETURN (Suc l, insert x res))))\n                       (l, {}) \\<bind>\n                      (\\<lambda>(uu_, res). RETURN res)\n                      \\<le> SPEC\n                             (\\<lambda>r.\n                                 r = {S ! j |j. l \\<le> j \\<and> j < u})", "apply (refine_rcg \n      WHILET_rule[where \n        I=\"\\<lambda>(l',res). res = {S!j | j. l\\<le>j \\<and> j<l'} \\<and> l\\<le>l' \\<and> l'\\<le>u\"\n        and R=\"measure (\\<lambda>(l',_). u-l')\" \n      ]\n      refine_vcg)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<lbrakk>l < u; u \\<le> length S; distinct S\\<rbrakk>\n    \\<Longrightarrow> wf (measure (\\<lambda>(l', uu_). u - l'))\n 2. \\<And>x1 x2.\n       \\<lbrakk>l < u; u \\<le> length S; distinct S;\n        (l, {}) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2 = {S ! j |j. l \\<le> j \\<and> j < x1}\n 3. \\<And>x1 x2.\n       \\<lbrakk>l < u; u \\<le> length S; distinct S;\n        (l, {}) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> l \\<le> x1\n 4. \\<And>x1 x2.\n       \\<lbrakk>l < u; u \\<le> length S; distinct S;\n        (l, {}) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 \\<le> u\n 5. \\<And>s a b.\n       \\<lbrakk>l < u; u \\<le> length S; distinct S;\n        case s of\n        (l', res) \\<Rightarrow>\n          res = {S ! j |j. l \\<le> j \\<and> j < l'} \\<and>\n          l \\<le> l' \\<and> l' \\<le> u;\n        case s of (l, uu_) \\<Rightarrow> l < u; s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> a < length S\n 6. \\<And>s a b.\n       \\<lbrakk>l < u; u \\<le> length S; distinct S;\n        case s of\n        (l', res) \\<Rightarrow>\n          res = {S ! j |j. l \\<le> j \\<and> j < l'} \\<and>\n          l \\<le> l' \\<and> l' \\<le> u;\n        case s of (l, uu_) \\<Rightarrow> l < u; s = (a, b);\n        a < length S\\<rbrakk>\n       \\<Longrightarrow> S ! a \\<notin> b\n 7. \\<And>s a b x1 x2.\n       \\<lbrakk>l < u; u \\<le> length S; distinct S;\n        case s of\n        (l', res) \\<Rightarrow>\n          res = {S ! j |j. l \\<le> j \\<and> j < l'} \\<and>\n          l \\<le> l' \\<and> l' \\<le> u;\n        case s of (l, uu_) \\<Rightarrow> l < u; s = (a, b); a < length S;\n        S ! a \\<notin> b; (Suc a, insert (S ! a) b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2 = {S ! j |j. l \\<le> j \\<and> j < x1}\n 8. \\<And>s a b x1 x2.\n       \\<lbrakk>l < u; u \\<le> length S; distinct S;\n        case s of\n        (l', res) \\<Rightarrow>\n          res = {S ! j |j. l \\<le> j \\<and> j < l'} \\<and>\n          l \\<le> l' \\<and> l' \\<le> u;\n        case s of (l, uu_) \\<Rightarrow> l < u; s = (a, b); a < length S;\n        S ! a \\<notin> b; (Suc a, insert (S ! a) b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> l \\<le> x1\n 9. \\<And>s a b x1 x2.\n       \\<lbrakk>l < u; u \\<le> length S; distinct S;\n        case s of\n        (l', res) \\<Rightarrow>\n          res = {S ! j |j. l \\<le> j \\<and> j < l'} \\<and>\n          l \\<le> l' \\<and> l' \\<le> u;\n        case s of (l, uu_) \\<Rightarrow> l < u; s = (a, b); a < length S;\n        S ! a \\<notin> b; (Suc a, insert (S ! a) b) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x1 \\<le> u\n 10. \\<And>s a b.\n        \\<lbrakk>l < u; u \\<le> length S; distinct S;\n         case s of\n         (l', res) \\<Rightarrow>\n           res = {S ! j |j. l \\<le> j \\<and> j < l'} \\<and>\n           l \\<le> l' \\<and> l' \\<le> u;\n         case s of (l, uu_) \\<Rightarrow> l < u; s = (a, b); a < length S;\n         S ! a \\<notin> b\\<rbrakk>\n        \\<Longrightarrow> ((Suc a, insert (S ! a) b), s)\n                          \\<in> measure (\\<lambda>(l', uu_). u - l')\nA total of 11 subgoals...", "apply (auto simp: less_Suc_eq nth_eq_iff_index_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in GS_invar) seg_set_impl_correct:\n    assumes \"i<length B\"\n    shows \"seg_set_impl (seg_start i) (seg_end i) \\<le> SPEC (\\<lambda>r. r=p_\\<alpha>!i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seg_set_impl (seg_start i) (seg_end i)\n    \\<le> SPEC (\\<lambda>r. r = p_\\<alpha> ! i)", "apply (refine_rcg order_trans[OF seg_set_impl_aux] refine_vcg)"], ["proof (prove)\ngoal (4 subgoals):\n 1. seg_start i < seg_end i\n 2. seg_end i \\<le> length S\n 3. distinct S\n 4. \\<And>x.\n       x =\n       {S ! j |j.\n        seg_start i \\<le> j \\<and> j < seg_end i} \\<Longrightarrow>\n       x = p_\\<alpha> ! i", "using assms"], ["proof (prove)\nusing this:\n  i < length B\n\ngoal (4 subgoals):\n 1. seg_start i < seg_end i\n 2. seg_end i \\<le> length S\n 3. distinct S\n 4. \\<And>x.\n       x =\n       {S ! j |j.\n        seg_start i \\<le> j \\<and> j < seg_end i} \\<Longrightarrow>\n       x = p_\\<alpha> ! i", "apply (simp_all add: seg_start_less_end seg_end_bound S_distinct) [3]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x =\n       {S ! j |j.\n        seg_start i \\<le> j \\<and> j < seg_end i} \\<Longrightarrow>\n       x = p_\\<alpha> ! i", "apply (auto simp: p_\\<alpha>_def assms seg_def) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"last_seg_impl \n    \\<equiv> do {\n      ASSERT (length B - 1 < length B);\n      seg_set_impl (seg_start (length B - 1)) (seg_end (length B - 1))\n    }\""], ["", "lemma (in GS_invar) last_seg_impl_correct:\n    assumes \"p_\\<alpha> \\<noteq> []\"\n    shows \"last_seg_impl \\<le> SPEC (\\<lambda>r. r=last p_\\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last_seg_impl \\<le> SPEC (\\<lambda>r. r = last p_\\<alpha>)", "unfolding last_seg_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (length B - 1 < length B) \\<bind>\n    (\\<lambda>_.\n        seg_set_impl (seg_start (length B - 1)) (seg_end (length B - 1)))\n    \\<le> SPEC (\\<lambda>r. r = last p_\\<alpha>)", "apply (refine_rcg order_trans[OF seg_set_impl_correct] refine_vcg)"], ["proof (prove)\ngoal (2 subgoals):\n 1. length B - 1 < length B\n 2. \\<And>x.\n       \\<lbrakk>length B - 1 < length B;\n        x = p_\\<alpha> ! (length B - 1)\\<rbrakk>\n       \\<Longrightarrow> x = last p_\\<alpha>", "using assms"], ["proof (prove)\nusing this:\n  p_\\<alpha> \\<noteq> []\n\ngoal (2 subgoals):\n 1. length B - 1 < length B\n 2. \\<And>x.\n       \\<lbrakk>length B - 1 < length B;\n        x = p_\\<alpha> ! (length B - 1)\\<rbrakk>\n       \\<Longrightarrow> x = last p_\\<alpha>", "apply (auto simp add: p_\\<alpha>_def last_conv_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "context fr_graph\nbegin"], ["", "definition \"last_seg_impl s \\<equiv> GS.last_seg_impl s\""], ["", "lemmas last_seg_impl_def_opt = \n    last_seg_impl_def[abs_def, THEN opt_GSdef, \n      unfolded GS.last_seg_impl_def GS.seg_set_impl_def \n    GS.seg_start_def GS.seg_end_def GS_sel_simps]"], ["", "(* TODO: Some potential for optimization here: the assertion \n      guarantees that length B - 1 + 1 = length B !*)"], ["", "lemma last_seg_impl_refine: \n    assumes A: \"(s,(p,D,pE))\\<in>GS_rel\"\n    assumes NE: \"p\\<noteq>[]\"\n    shows \"last_seg_impl s \\<le> \\<Down>Id (RETURN (last p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last_seg_impl s \\<le> \\<Down> Id (RETURN (last p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. last_seg_impl s \\<le> \\<Down> Id (RETURN (last p))", "from A"], ["proof (chain)\npicking this:\n  (s, p, D, pE) \\<in> GS_rel", "have \n      [simp]: \"p=GS.p_\\<alpha> s \\<and> D=GS.D_\\<alpha> s \\<and> pE=GS.pE_\\<alpha> s\" \n        and INV: \"GS_invar s\""], ["proof (prove)\nusing this:\n  (s, p, D, pE) \\<in> GS_rel\n\ngoal (1 subgoal):\n 1. p = GS.p_\\<alpha> s \\<and>\n    D = GS.D_\\<alpha> s \\<and> pE = GS.pE_\\<alpha> s &&&\n    GS_invar s", "by (auto simp add: GS_rel_def br_def GS_\\<alpha>_split)"], ["proof (state)\nthis:\n  p = GS.p_\\<alpha> s \\<and>\n  D = GS.D_\\<alpha> s \\<and> pE = GS.pE_\\<alpha> s\n  GS_invar s\n\ngoal (1 subgoal):\n 1. last_seg_impl s \\<le> \\<Down> Id (RETURN (last p))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. last_seg_impl s \\<le> \\<Down> Id (RETURN (last p))", "unfolding last_seg_impl_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. GS.last_seg_impl s \\<le> \\<Down> Id (RETURN (last p))", "apply (rule order_trans[OF GS_invar.last_seg_impl_correct])"], ["proof (prove)\ngoal (3 subgoals):\n 1. GS_invar s\n 2. GS.p_\\<alpha> s \\<noteq> []\n 3. SPEC (\\<lambda>r. r = last (GS.p_\\<alpha> s))\n    \\<le> \\<Down> Id (RETURN (last p))", "using INV NE"], ["proof (prove)\nusing this:\n  GS_invar s\n  p \\<noteq> []\n\ngoal (3 subgoals):\n 1. GS_invar s\n 2. GS.p_\\<alpha> s \\<noteq> []\n 3. SPEC (\\<lambda>r. r = last (GS.p_\\<alpha> s))\n    \\<le> \\<Down> Id (RETURN (last p))", "apply (simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  last_seg_impl s \\<le> \\<Down> Id (RETURN (last p))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition compute_SCC_impl :: \"'v set list nres\" where\n    \"compute_SCC_impl \\<equiv> do {\n      stat_start_nres;\n      let so = ([],Map.empty);\n      (l,D) \\<leftarrow> FOREACHi (\\<lambda>it (l,s). cscc_outer_invar it (l,oGS_\\<alpha> s)) \n        V0 (\\<lambda>v0 (l,I0). do {\n          if \\<not>is_done_oimpl v0 I0 then do {\n            let ls = (l,initial_impl v0 I0);\n\n            (l,(S,B,I,P))\\<leftarrow>WHILEIT (\\<lambda>(l,s). cscc_invar v0 (oGS_\\<alpha> I0) (l,GS.\\<alpha> s))\n              (\\<lambda>(l,s). \\<not>path_is_empty_impl s) (\\<lambda>(l,s).\n            do {\n              \\<comment> \\<open>Select edge from end of path\\<close>\n              (vo,s) \\<leftarrow> select_edge_impl s;\n\n              case vo of \n                Some v \\<Rightarrow> do {\n                  if is_on_stack_impl v s then do {\n                    s\\<leftarrow>collapse_impl v s;\n                    RETURN (l,s)\n                  } else if \\<not>is_done_impl v s then do {\n                    \\<comment> \\<open>Edge to new node. Append to path\\<close>\n                    RETURN (l,push_impl v s)\n                  } else do {\n                    \\<comment> \\<open>Edge to done node. Skip\\<close>\n                    RETURN (l,s)\n                  }\n                }\n              | None \\<Rightarrow> do {\n                  \\<comment> \\<open>No more outgoing edges from current node on path\\<close>\n                  scc \\<leftarrow> last_seg_impl s;\n                  s\\<leftarrow>pop_impl s;\n                  let l = scc#l;\n                  RETURN (l,s)\n                }\n            }) (ls);\n            RETURN (l,I)\n          } else RETURN (l,I0)\n      }) so;\n      stat_stop_nres;\n      RETURN l\n    }\""], ["", "lemma compute_SCC_impl_refine: \"compute_SCC_impl \\<le> \\<Down>Id compute_SCC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compute_SCC_impl \\<le> \\<Down> Id compute_SCC", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. compute_SCC_impl \\<le> \\<Down> Id compute_SCC", "note [refine2] = bind_Let_refine2[OF last_seg_impl_refine]"], ["proof (state)\nthis:\n  \\<lbrakk>(?s1, ?p1, ?D1, ?pE1) \\<in> GS_rel; ?p1 \\<noteq> [];\n   \\<And>x'.\n      \\<lbrakk>inres (last_seg_impl ?s1) x';\n       (x', last ?p1) \\<in> Id\\<rbrakk>\n      \\<Longrightarrow> ?f' x' \\<le> \\<Down> ?R (?f (last ?p1))\\<rbrakk>\n  \\<Longrightarrow> last_seg_impl ?s1 \\<bind> ?f'\n                    \\<le> \\<Down> ?R (Let (last ?p1) ?f)\n\ngoal (1 subgoal):\n 1. compute_SCC_impl \\<le> \\<Down> Id compute_SCC", "have [refine2]: \"\\<And>s' p D pE l' l v' v. \\<lbrakk>\n      (s',(p,D,pE))\\<in>GS_rel;\n      (l',l)\\<in>Id;\n      (v',v)\\<in>Id;\n      v\\<in>\\<Union>(set p)\n    \\<rbrakk> \\<Longrightarrow> do { s'\\<leftarrow>collapse_impl v' s'; RETURN (l',s') } \n      \\<le> \\<Down>(Id \\<times>\\<^sub>r GS_rel) (RETURN (l,collapse v (p,D,pE)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s' p D pE l' l v' v.\n       \\<lbrakk>(s', p, D, pE) \\<in> GS_rel; (l', l) \\<in> Id;\n        (v', v) \\<in> Id; v \\<in> \\<Union> (set p)\\<rbrakk>\n       \\<Longrightarrow> collapse_impl v' s' \\<bind>\n                         (\\<lambda>s'. RETURN (l', s'))\n                         \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n                                (RETURN (l, collapse v (p, D, pE)))", "apply (refine_rcg order_trans[OF collapse_refine] refine_vcg)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s' p D pE l' l v' v.\n       \\<lbrakk>(s', p, D, pE) \\<in> GS_rel; (l', l) \\<in> Id;\n        (v', v) \\<in> Id; v \\<in> \\<Union> (set p)\\<rbrakk>\n       \\<Longrightarrow> (s', ?p3 s' p D pE l' l v' v,\n                          ?D3 s' p D pE l' l v' v, ?pE3 s' p D pE l' l v' v)\n                         \\<in> GS_rel\n 2. \\<And>s' p D pE l' l v' v.\n       \\<lbrakk>(s', p, D, pE) \\<in> GS_rel; (l', l) \\<in> Id;\n        (v', v) \\<in> Id; v \\<in> \\<Union> (set p)\\<rbrakk>\n       \\<Longrightarrow> (v', ?v'3 s' p D pE l' l v' v) \\<in> Id\n 3. \\<And>s' p D pE l' l v' v.\n       \\<lbrakk>(s', p, D, pE) \\<in> GS_rel; (l', l) \\<in> Id;\n        (v', v) \\<in> Id; v \\<in> \\<Union> (set p)\\<rbrakk>\n       \\<Longrightarrow> ?v'3 s' p D pE l' l v' v\n                         \\<in> \\<Union> (set (?p3 s' p D pE l' l v' v))\n 4. \\<And>s' p D pE l' l v' v.\n       \\<lbrakk>(s', p, D, pE) \\<in> GS_rel; (l', l) \\<in> Id;\n        (v', v) \\<in> Id; v \\<in> \\<Union> (set p)\\<rbrakk>\n       \\<Longrightarrow> \\<Down> GS_rel\n                          (RETURN\n                            (collapse (?v'3 s' p D pE l' l v' v)\n                              (?p3 s' p D pE l' l v' v,\n                               ?D3 s' p D pE l' l v' v,\n                               ?pE3 s' p D pE l' l v' v)))\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    RETURN (l', s')\n                                    \\<le> SPEC\n     (\\<lambda>c.\n         (c, l, collapse v (p, D, pE)) \\<in> Id \\<times>\\<^sub>r GS_rel))", "apply assumption+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s' p D pE l' l v' v.\n       \\<lbrakk>(s', p, D, pE) \\<in> GS_rel; (l', l) \\<in> Id;\n        (v', v) \\<in> Id; v \\<in> \\<Union> (set p)\\<rbrakk>\n       \\<Longrightarrow> \\<Down> GS_rel (RETURN (collapse v (p, D, pE)))\n                         \\<le> SPEC\n                                (\\<lambda>s'.\n                                    RETURN (l', s')\n                                    \\<le> SPEC\n     (\\<lambda>c.\n         (c, l, collapse v (p, D, pE)) \\<in> Id \\<times>\\<^sub>r GS_rel))", "apply (auto simp add: pw_le_iff refine_pw_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>(?s'1, ?p1, ?D1, ?pE1) \\<in> GS_rel; (?l'1, ?l1) \\<in> Id;\n   (?v'1, ?v1) \\<in> Id; ?v1 \\<in> \\<Union> (set ?p1)\\<rbrakk>\n  \\<Longrightarrow> collapse_impl ?v'1 ?s'1 \\<bind>\n                    (\\<lambda>s'. RETURN (?l'1, s'))\n                    \\<le> \\<Down> (Id \\<times>\\<^sub>r GS_rel)\n                           (RETURN (?l1, collapse ?v1 (?p1, ?D1, ?pE1)))\n\ngoal (1 subgoal):\n 1. compute_SCC_impl \\<le> \\<Down> Id compute_SCC", "note [[goals_limit = 1]]"], ["proof (state)\nthis:\n  TERM _\n\ngoal (1 subgoal):\n 1. compute_SCC_impl \\<le> \\<Down> Id compute_SCC", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. compute_SCC_impl \\<le> \\<Down> Id compute_SCC", "unfolding compute_SCC_impl_def compute_SCC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. stat_start_nres \\<bind>\n    (\\<lambda>_.\n        let so = ([], Map.empty)\n        in FOREACH\\<^bsup>\\<lambda>it (l, s).\n                             cscc_outer_invar it (l, oGS_\\<alpha> s)\\<^esup>\n            V0 (\\<lambda>v0 (l, I0).\n                   if \\<not> is_done_oimpl v0 I0\n                   then let ls = (l, initial_impl v0 I0)\n                        in WHILE\\<^sub>T\\<^bsup>\\<lambda>(l, s).\n             cscc_invar v0 (oGS_\\<alpha> I0) (l, GS.\\<alpha> s)\\<^esup>\n                            (\\<lambda>(l, s). \\<not> path_is_empty_impl s)\n                            (\\<lambda>(l, s).\n                                select_edge_impl s \\<bind>\n                                (\\<lambda>(vo, s).\n                                    case vo of\n                                    None \\<Rightarrow>\nlast_seg_impl s \\<bind>\n(\\<lambda>scc.\n    pop_impl s \\<bind> (\\<lambda>s. let l = scc # l in RETURN (l, s)))\n                                    | Some v \\<Rightarrow>\n  if is_on_stack_impl v s\n  then collapse_impl v s \\<bind> (\\<lambda>s. RETURN (l, s))\n  else if \\<not> is_done_impl v s then RETURN (l, push_impl v s)\n       else RETURN (l, s)))\n                            ls \\<bind>\n                           (\\<lambda>(l, S, B, I, P). RETURN (l, I))\n                   else RETURN (l, I0))\n            so \\<bind>\n           (\\<lambda>(l, D). stat_stop_nres \\<bind> (\\<lambda>_. RETURN l)))\n    \\<le> \\<Down> Id\n           (let so = ([], {})\n            in FOREACH\\<^bsup>cscc_outer_invar\\<^esup> V0\n                (\\<lambda>v0 (l, D0).\n                    if v0 \\<notin> D0\n                    then let s = (l, initial v0 D0)\n                         in WHILE\\<^sub>T\\<^bsup>cscc_invar v0 D0\\<^esup>\n                             (\\<lambda>(l, p, D, pE). p \\<noteq> [])\n                             (\\<lambda>(l, p, D, pE).\n                                 select_edge (p, D, pE) \\<bind>\n                                 (\\<lambda>(vo, p, D, pE).\n                                     ASSERT (p \\<noteq> []) \\<bind>\n                                     (\\<lambda>_.\n   case vo of\n   None \\<Rightarrow>\n     ASSERT (pE \\<inter> last p \\<times> UNIV = {}) \\<bind>\n     (\\<lambda>_.\n         let V = last p; (p, D, pE) = pop (p, D, pE); l = V # l\n         in RETURN (l, p, D, pE))\n   | Some v \\<Rightarrow>\n       if v \\<in> \\<Union> (set p) then RETURN (l, collapse v (p, D, pE))\n       else if v \\<notin> D then RETURN (l, push v (p, D, pE))\n            else RETURN (l, p, D, pE))))\n                             s \\<bind>\n                            (\\<lambda>(l, p, D, pE).\n                                ASSERT (p = [] \\<and> pE = {}) \\<bind>\n                                (\\<lambda>_. RETURN (l, D)))\n                    else RETURN (l, D0))\n                so \\<bind>\n               (\\<lambda>(l, D). RETURN l))", "apply (refine_rcg\n        bind_refine'\n        select_edge_refine push_refine \n        pop_refine\n        (*collapse_refine*) \n        initial_refine\n        oinitial_refine\n        (*last_seg_impl_refine*)\n        prod_relI IdI\n        inj_on_id\n      )"], ["proof (prove)\ngoal (32 subgoals):\n 1. V0 = id ` V0\nA total of 32 subgoals...", "apply refine_dref_type"], ["proof (prove)\ngoal (30 subgoals):\n 1. V0 = id ` V0\nA total of 30 subgoals...", "apply (vc_solve (nopre) solve: asm_rl I_to_outer\n        simp: GS_rel_def br_def GS.\\<alpha>_def oGS_rel_def oGS_\\<alpha>_def \n        is_on_stack_refine path_is_empty_refine is_done_refine is_done_orefine\n      )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  compute_SCC_impl \\<le> \\<Down> Id compute_SCC\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}