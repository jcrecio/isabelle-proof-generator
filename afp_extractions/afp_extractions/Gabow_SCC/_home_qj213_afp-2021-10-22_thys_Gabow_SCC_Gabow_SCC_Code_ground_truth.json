{"file_name": "/home/qj213/afp-2021-10-22/thys/Gabow_SCC/Gabow_SCC_Code.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Gabow_SCC", "problem_names": ["lemmas [autoref_rules] = last_seg_code.refine[OF locale_this]", "lemma [autoref_op_pat]: \n      \"last_seg_impl \\<equiv> OP last_seg_impl\"", "lemmas [autoref_rules] = compute_SCC_code.refine[OF locale_this]", "lemmas [refine_transfer] = last_seg_tr.refine[OF locale_this]", "lemmas [refine_transfer] = compute_SCC_tr.refine[OF locale_this]", "theorem compute_SCC_tr_correct:\n  \\<comment> \\<open>Correctness theorem for the constant we extracted to SML\\<close>\n  fixes Re and node_rel :: \"('vi \\<times> 'v) set\"\n  fixes G :: \"('v,'more) graph_rec_scheme\"\n  assumes A: \n      \"(G_impl,G)\\<in>\\<langle>Re,node_rel\\<rangle>g_impl_rel_ext\"\n      \"(node_eq_impl, (=)) \\<in> node_rel \\<rightarrow> node_rel \\<rightarrow> bool_rel\"\n      \"is_bounded_hashcode node_rel node_eq_impl node_hash_impl\"\n      \"(is_valid_def_hm_size TYPE('vi) node_def_hash_size)\"\n  \n  assumes C: \"fr_graph G\"\n  shows \"RETURN (compute_SCC_tr node_eq_impl node_hash_impl node_def_hash_size G_impl) \n  \\<le> \\<Down>(\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel) (fr_graph.compute_SCC_spec G)\""], "translations": [["", "lemmas [autoref_rules] = last_seg_code.refine[OF locale_this]"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma [autoref_op_pat]: \n      \"last_seg_impl \\<equiv> OP last_seg_impl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last_seg_impl \\<equiv> OP last_seg_impl", "by simp_all"], ["", "end"], ["", "schematic_goal compute_SCC_code_aux:\n    \"(?c,compute_SCC_impl) \\<in> \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, compute_SCC_impl)\n    \\<in> \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel\\<rangle>nres_rel", "unfolding compute_SCC_impl_def[abs_def] initial_impl_def GS_initial_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     stat_start_nres \\<bind>\n     (\\<lambda>_.\n         let so = ([], Map.empty)\n         in FOREACH\\<^bsup>\\<lambda>it (l, s).\n                              cscc_outer_invar it\n                               (l, oGS_\\<alpha> s)\\<^esup>\n             V0 (\\<lambda>v0 (l, I0).\n                    if \\<not> is_done_oimpl v0 I0\n                    then let ls = (l, [v0], [0], I0(v0 \\<mapsto> STACK 0),\n                                   if E `` {v0} = {} then []\n                                   else [(0, E `` {v0})])\n                         in WHILE\\<^sub>T\\<^bsup>\\<lambda>(l, s).\n              cscc_invar v0 (oGS_\\<alpha> I0) (l, GS.\\<alpha> s)\\<^esup>\n                             (\\<lambda>(l, s). \\<not> path_is_empty_impl s)\n                             (\\<lambda>(l, s).\n                                 select_edge_impl s \\<bind>\n                                 (\\<lambda>(vo, s).\n                                     case vo of\n                                     None \\<Rightarrow>\n last_seg_impl s \\<bind>\n (\\<lambda>scc.\n     pop_impl s \\<bind> (\\<lambda>s. let l = scc # l in RETURN (l, s)))\n                                     | Some v \\<Rightarrow>\n   if is_on_stack_impl v s\n   then collapse_impl v s \\<bind> (\\<lambda>s. RETURN (l, s))\n   else if \\<not> is_done_impl v s then RETURN (l, push_impl v s)\n        else RETURN (l, s)))\n                             ls \\<bind>\n                            (\\<lambda>(l, S, B, I, P). RETURN (l, I))\n                    else RETURN (l, I0))\n             so \\<bind>\n            (\\<lambda>(l, D).\n                stat_stop_nres \\<bind> (\\<lambda>_. RETURN l))))\n    \\<in> \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel\\<rangle>nres_rel", "unfolding path_is_empty_impl_def is_on_stack_impl_def is_done_impl_def \n      is_done_oimpl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     stat_start_nres \\<bind>\n     (\\<lambda>_.\n         let so = ([], Map.empty)\n         in FOREACH\\<^bsup>\\<lambda>it (l, s).\n                              cscc_outer_invar it\n                               (l, oGS_\\<alpha> s)\\<^esup>\n             V0 (\\<lambda>v0 (l, I0).\n                    if \\<not> (case I0 v0 of None \\<Rightarrow> False\n                               | Some (STACK nat) \\<Rightarrow> False\n                               | Some DONE \\<Rightarrow> True)\n                    then let ls = (l, [v0], [0], I0(v0 \\<mapsto> STACK 0),\n                                   if E `` {v0} = {} then []\n                                   else [(0, E `` {v0})])\n                         in WHILE\\<^sub>T\\<^bsup>\\<lambda>(l, s).\n              cscc_invar v0 (oGS_\\<alpha> I0) (l, GS.\\<alpha> s)\\<^esup>\n                             (\\<lambda>(l, s). GS.S s \\<noteq> [])\n                             (\\<lambda>(l, s).\n                                 select_edge_impl s \\<bind>\n                                 (\\<lambda>(vo, s).\n                                     case vo of\n                                     None \\<Rightarrow>\n last_seg_impl s \\<bind>\n (\\<lambda>scc.\n     pop_impl s \\<bind> (\\<lambda>s. let l = scc # l in RETURN (l, s)))\n                                     | Some v \\<Rightarrow>\n   if GS.is_on_stack_impl s v\n   then collapse_impl v s \\<bind> (\\<lambda>s. RETURN (l, s))\n   else if \\<not> GS.is_done_impl s v then RETURN (l, push_impl v s)\n        else RETURN (l, s)))\n                             ls \\<bind>\n                            (\\<lambda>(l, S, B, I, P). RETURN (l, I))\n                    else RETURN (l, I0))\n             so \\<bind>\n            (\\<lambda>(l, D).\n                stat_stop_nres \\<bind> (\\<lambda>_. RETURN l))))\n    \\<in> \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel\\<rangle>nres_rel", "unfolding GS.is_on_stack_impl_def GS.is_done_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     stat_start_nres \\<bind>\n     (\\<lambda>_.\n         let so = ([], Map.empty)\n         in FOREACH\\<^bsup>\\<lambda>it (l, s).\n                              cscc_outer_invar it\n                               (l, oGS_\\<alpha> s)\\<^esup>\n             V0 (\\<lambda>v0 (l, I0).\n                    if \\<not> (case I0 v0 of None \\<Rightarrow> False\n                               | Some (STACK nat) \\<Rightarrow> False\n                               | Some DONE \\<Rightarrow> True)\n                    then let ls = (l, [v0], [0], I0(v0 \\<mapsto> STACK 0),\n                                   if E `` {v0} = {} then []\n                                   else [(0, E `` {v0})])\n                         in WHILE\\<^sub>T\\<^bsup>\\<lambda>(l, s).\n              cscc_invar v0 (oGS_\\<alpha> I0) (l, GS.\\<alpha> s)\\<^esup>\n                             (\\<lambda>(l, s). GS.S s \\<noteq> [])\n                             (\\<lambda>(l, s).\n                                 select_edge_impl s \\<bind>\n                                 (\\<lambda>(vo, s).\n                                     case vo of\n                                     None \\<Rightarrow>\n last_seg_impl s \\<bind>\n (\\<lambda>scc.\n     pop_impl s \\<bind> (\\<lambda>s. let l = scc # l in RETURN (l, s)))\n                                     | Some v \\<Rightarrow>\n   if case GS.I s v of None \\<Rightarrow> False\n      | Some (STACK x) \\<Rightarrow> True | Some DONE \\<Rightarrow> False\n   then collapse_impl v s \\<bind> (\\<lambda>s. RETURN (l, s))\n   else if \\<not> (case GS.I s v of None \\<Rightarrow> False\n                   | Some (STACK nat) \\<Rightarrow> False\n                   | Some DONE \\<Rightarrow> True)\n        then RETURN (l, push_impl v s) else RETURN (l, s)))\n                             ls \\<bind>\n                            (\\<lambda>(l, S, B, I, P). RETURN (l, I))\n                    else RETURN (l, I0))\n             so \\<bind>\n            (\\<lambda>(l, D).\n                stat_stop_nres \\<bind> (\\<lambda>_. RETURN l))))\n    \\<in> \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel\\<rangle>nres_rel", "using [[autoref_trace_failed_id]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     stat_start_nres \\<bind>\n     (\\<lambda>_.\n         let so = ([], Map.empty)\n         in FOREACH\\<^bsup>\\<lambda>it (l, s).\n                              cscc_outer_invar it\n                               (l, oGS_\\<alpha> s)\\<^esup>\n             V0 (\\<lambda>v0 (l, I0).\n                    if \\<not> (case I0 v0 of None \\<Rightarrow> False\n                               | Some (STACK nat) \\<Rightarrow> False\n                               | Some DONE \\<Rightarrow> True)\n                    then let ls = (l, [v0], [0], I0(v0 \\<mapsto> STACK 0),\n                                   if E `` {v0} = {} then []\n                                   else [(0, E `` {v0})])\n                         in WHILE\\<^sub>T\\<^bsup>\\<lambda>(l, s).\n              cscc_invar v0 (oGS_\\<alpha> I0) (l, GS.\\<alpha> s)\\<^esup>\n                             (\\<lambda>(l, s). GS.S s \\<noteq> [])\n                             (\\<lambda>(l, s).\n                                 select_edge_impl s \\<bind>\n                                 (\\<lambda>(vo, s).\n                                     case vo of\n                                     None \\<Rightarrow>\n last_seg_impl s \\<bind>\n (\\<lambda>scc.\n     pop_impl s \\<bind> (\\<lambda>s. let l = scc # l in RETURN (l, s)))\n                                     | Some v \\<Rightarrow>\n   if case GS.I s v of None \\<Rightarrow> False\n      | Some (STACK x) \\<Rightarrow> True | Some DONE \\<Rightarrow> False\n   then collapse_impl v s \\<bind> (\\<lambda>s. RETURN (l, s))\n   else if \\<not> (case GS.I s v of None \\<Rightarrow> False\n                   | Some (STACK nat) \\<Rightarrow> False\n                   | Some DONE \\<Rightarrow> True)\n        then RETURN (l, push_impl v s) else RETURN (l, s)))\n                             ls \\<bind>\n                            (\\<lambda>(l, S, B, I, P). RETURN (l, I))\n                    else RETURN (l, I0))\n             so \\<bind>\n            (\\<lambda>(l, D).\n                stat_stop_nres \\<bind> (\\<lambda>_. RETURN l))))\n    \\<in> \\<langle>\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel\\<rangle>nres_rel", "apply (autoref (keep_goal,trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition (in -) compute_SCC_code \n    uses fr_graph_impl_loc.compute_SCC_code_aux"], ["", "lemmas [autoref_rules] = compute_SCC_code.refine[OF locale_this]"], ["", "schematic_goal last_seg_tr_aux: \"RETURN ?c \\<le> last_seg_code s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c \\<le> last_seg_code s", "unfolding last_seg_code_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> (case s of\n           (x, xaa, xba, xc) \\<Rightarrow>\n             WHILE\\<^sub>T\n              (\\<lambda>(xe, xf).\n                  xe < (if as_length xaa - 1 + 1 = as_length xaa\n                        then as_length x\n                        else as_get xaa (as_length xaa - 1 + 1)))\n              (\\<lambda>(xe, xf).\n                  let y' = as_get x xe in RETURN (Suc xe, y' # xf))\n              (as_get xaa (as_length xaa - 1), []) \\<bind>\n             (\\<lambda>(xd, y). RETURN y))", "by refine_transfer"], ["", "concrete_definition (in -) last_seg_tr uses fr_graph_impl_loc.last_seg_tr_aux"], ["", "lemmas [refine_transfer] = last_seg_tr.refine[OF locale_this]"], ["", "schematic_goal compute_SCC_tr_aux: \"RETURN ?c \\<le> compute_SCC_code node_eq_impl node_hash_impl node_def_hash_size g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> compute_SCC_code node_eq_impl node_hash_impl node_def_hash_size g", "unfolding compute_SCC_code_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> stat_start_nres \\<bind>\n          (\\<lambda>x.\n              let y' = ([],\n                        Impl_Array_Hash_Map.ahm_empty node_def_hash_size)\n              in LIST_FOREACH' (RETURN (id (gi_V0 g))) (\\<lambda>xa. True)\n                  (\\<lambda>xa (xb, xc).\n                      if \\<not> (case Impl_Array_Hash_Map.ahm_lookup\n node_eq_impl node_hash_impl xa xc of\n                                 None \\<Rightarrow> False\n                                 | Some i \\<Rightarrow>\n                                     if 0 \\<le> i then False else True)\n                      then let y'a =\n                                 (xb, as_singleton xa, as_singleton 0,\n                                  Impl_Array_Hash_Map.ahm_update\n                                   node_eq_impl node_hash_impl xa (int 0)\n                                   xc,\n                                  if is_Nil (gi_E g xa) then as_empty ()\n                                  else as_singleton (0, gi_E g xa))\n                           in WHILE\\<^sub>T\n                               (\\<lambda>(xe, xf).\n                                   \\<not> as_is_empty\n     (case xf of (xg, xh, xi, xj) \\<Rightarrow> xg))\n                               (\\<lambda>(xe, xf).\n                                   select_edge_code node_eq_impl xf \\<bind>\n                                   (\\<lambda>(xg, xh).\n case xg of\n None \\<Rightarrow>\n   last_seg_code xh \\<bind>\n   (\\<lambda>xi.\n       pop_code node_eq_impl node_hash_impl xh \\<bind>\n       (\\<lambda>xj. let y'b = xi # xe in RETURN (y'b, xj)))\n | Some xi \\<Rightarrow>\n     if case Impl_Array_Hash_Map.ahm_lookup node_eq_impl node_hash_impl xi\n              (case xh of (xj, xk, xl, xm) \\<Rightarrow> xl) of\n        None \\<Rightarrow> False\n        | Some i \\<Rightarrow> if 0 \\<le> i then True else False\n     then collapse_code node_eq_impl node_hash_impl xi xh \\<bind>\n          (\\<lambda>xj. RETURN (xe, xj))\n     else if \\<not> (case Impl_Array_Hash_Map.ahm_lookup node_eq_impl\n                           node_hash_impl xi\n                           (case xh of (xj, xk, xl, xm) \\<Rightarrow> xl) of\n                     None \\<Rightarrow> False\n                     | Some i \\<Rightarrow>\n                         if 0 \\<le> i then False else True)\n          then RETURN (xe, push_code node_eq_impl node_hash_impl g xi xh)\n          else RETURN (xe, xh)))\n                               y'a \\<bind>\n                              (\\<lambda>(xd, xe, xf, xg, xh).\n                                  RETURN (xd, xg))\n                      else RETURN (xb, xc))\n                  y' \\<bind>\n                 (\\<lambda>(xa, xb).\n                     stat_stop_nres \\<bind> (\\<lambda>xc. RETURN xa)))", "by refine_transfer"], ["", "concrete_definition (in -) compute_SCC_tr \n    uses fr_graph_impl_loc.compute_SCC_tr_aux"], ["", "lemmas [refine_transfer] = compute_SCC_tr.refine[OF locale_this]"], ["", "end"], ["", "export_code compute_SCC_tr checking SML"], ["", "section \\<open>Correctness Theorem\\<close>"], ["", "theorem compute_SCC_tr_correct:\n  \\<comment> \\<open>Correctness theorem for the constant we extracted to SML\\<close>\n  fixes Re and node_rel :: \"('vi \\<times> 'v) set\"\n  fixes G :: \"('v,'more) graph_rec_scheme\"\n  assumes A: \n      \"(G_impl,G)\\<in>\\<langle>Re,node_rel\\<rangle>g_impl_rel_ext\"\n      \"(node_eq_impl, (=)) \\<in> node_rel \\<rightarrow> node_rel \\<rightarrow> bool_rel\"\n      \"is_bounded_hashcode node_rel node_eq_impl node_hash_impl\"\n      \"(is_valid_def_hm_size TYPE('vi) node_def_hash_size)\"\n  \n  assumes C: \"fr_graph G\"\n  shows \"RETURN (compute_SCC_tr node_eq_impl node_hash_impl node_def_hash_size G_impl) \n  \\<le> \\<Down>(\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel) (fr_graph.compute_SCC_spec G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN\n     (compute_SCC_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n    \\<le> \\<Down>\n           (\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel)\n           (fr_graph.compute_SCC_spec G)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. RETURN\n     (compute_SCC_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n    \\<le> \\<Down>\n           (\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel)\n           (fr_graph.compute_SCC_spec G)", "from C"], ["proof (chain)\npicking this:\n  fr_graph G", "interpret fr_graph G"], ["proof (prove)\nusing this:\n  fr_graph G\n\ngoal (1 subgoal):\n 1. fr_graph G", "."], ["proof (state)\ngoal (1 subgoal):\n 1. RETURN\n     (compute_SCC_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n    \\<le> \\<Down>\n           (\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel)\n           compute_SCC_spec", "have I: \"fr_graph_impl_loc Re node_rel node_eq_impl node_hash_impl node_def_hash_size G_impl G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fr_graph_impl_loc Re node_rel node_eq_impl node_hash_impl\n     node_def_hash_size G_impl G", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. (G_impl, G) \\<in> \\<langle>Re, node_rel\\<rangle>g_impl_rel_ext\n 2. (node_eq_impl, (=))\n    \\<in> node_rel \\<rightarrow> node_rel \\<rightarrow> bool_rel\n 3. is_bounded_hashcode node_rel node_eq_impl node_hash_impl\n 4. is_valid_def_hm_size TYPE('vi) node_def_hash_size", "using A"], ["proof (prove)\nusing this:\n  (G_impl, G) \\<in> \\<langle>Re, node_rel\\<rangle>g_impl_rel_ext\n  (node_eq_impl, (=))\n  \\<in> node_rel \\<rightarrow> node_rel \\<rightarrow> bool_rel\n  is_bounded_hashcode node_rel node_eq_impl node_hash_impl\n  is_valid_def_hm_size TYPE('vi) node_def_hash_size\n\ngoal (4 subgoals):\n 1. (G_impl, G) \\<in> \\<langle>Re, node_rel\\<rangle>g_impl_rel_ext\n 2. (node_eq_impl, (=))\n    \\<in> node_rel \\<rightarrow> node_rel \\<rightarrow> bool_rel\n 3. is_bounded_hashcode node_rel node_eq_impl node_hash_impl\n 4. is_valid_def_hm_size TYPE('vi) node_def_hash_size", "."], ["proof (state)\nthis:\n  fr_graph_impl_loc Re node_rel node_eq_impl node_hash_impl\n   node_def_hash_size G_impl G\n\ngoal (1 subgoal):\n 1. RETURN\n     (compute_SCC_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n    \\<le> \\<Down>\n           (\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel)\n           compute_SCC_spec", "then"], ["proof (chain)\npicking this:\n  fr_graph_impl_loc Re node_rel node_eq_impl node_hash_impl\n   node_def_hash_size G_impl G", "interpret fr_graph_impl_loc Re node_rel node_eq_impl node_hash_impl node_def_hash_size G_impl G"], ["proof (prove)\nusing this:\n  fr_graph_impl_loc Re node_rel node_eq_impl node_hash_impl\n   node_def_hash_size G_impl G\n\ngoal (1 subgoal):\n 1. fr_graph_impl_loc Re node_rel node_eq_impl node_hash_impl\n     node_def_hash_size G_impl G", "."], ["proof (state)\ngoal (1 subgoal):\n 1. RETURN\n     (compute_SCC_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n    \\<le> \\<Down>\n           (\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel)\n           compute_SCC_spec", "note compute_SCC_tr.refine[OF I]"], ["proof (state)\nthis:\n  RETURN (compute_SCC_tr node_eq_impl node_hash_impl node_def_hash_size ?g)\n  \\<le> compute_SCC_code node_eq_impl node_hash_impl node_def_hash_size ?g\n\ngoal (1 subgoal):\n 1. RETURN\n     (compute_SCC_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n    \\<le> \\<Down>\n           (\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel)\n           compute_SCC_spec", "also"], ["proof (state)\nthis:\n  RETURN (compute_SCC_tr node_eq_impl node_hash_impl node_def_hash_size ?g)\n  \\<le> compute_SCC_code node_eq_impl node_hash_impl node_def_hash_size ?g\n\ngoal (1 subgoal):\n 1. RETURN\n     (compute_SCC_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n    \\<le> \\<Down>\n           (\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel)\n           compute_SCC_spec", "note compute_SCC_code.refine[OF I, THEN nres_relD]"], ["proof (state)\nthis:\n  compute_SCC_code node_eq_impl node_hash_impl node_def_hash_size G_impl\n  \\<le> \\<Down>\n         (\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel)\n         compute_SCC_impl\n\ngoal (1 subgoal):\n 1. RETURN\n     (compute_SCC_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n    \\<le> \\<Down>\n           (\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel)\n           compute_SCC_spec", "also"], ["proof (state)\nthis:\n  compute_SCC_code node_eq_impl node_hash_impl node_def_hash_size G_impl\n  \\<le> \\<Down>\n         (\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel)\n         compute_SCC_impl\n\ngoal (1 subgoal):\n 1. RETURN\n     (compute_SCC_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n    \\<le> \\<Down>\n           (\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel)\n           compute_SCC_spec", "note compute_SCC_impl_refine"], ["proof (state)\nthis:\n  compute_SCC_impl \\<le> \\<Down> Id compute_SCC\n\ngoal (1 subgoal):\n 1. RETURN\n     (compute_SCC_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n    \\<le> \\<Down>\n           (\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel)\n           compute_SCC_spec", "also"], ["proof (state)\nthis:\n  compute_SCC_impl \\<le> \\<Down> Id compute_SCC\n\ngoal (1 subgoal):\n 1. RETURN\n     (compute_SCC_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n    \\<le> \\<Down>\n           (\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel)\n           compute_SCC_spec", "note compute_SCC_correct"], ["proof (state)\nthis:\n  compute_SCC \\<le> compute_SCC_spec\n\ngoal (1 subgoal):\n 1. RETURN\n     (compute_SCC_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n    \\<le> \\<Down>\n           (\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel)\n           compute_SCC_spec", "finally"], ["proof (chain)\npicking this:\n  RETURN\n   (compute_SCC_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n  \\<le> \\<Down>\n         (\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel)\n         compute_SCC_spec", "show ?thesis"], ["proof (prove)\nusing this:\n  RETURN\n   (compute_SCC_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n  \\<le> \\<Down>\n         (\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel)\n         compute_SCC_spec\n\ngoal (1 subgoal):\n 1. RETURN\n     (compute_SCC_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n    \\<le> \\<Down>\n           (\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel)\n           compute_SCC_spec", "using A"], ["proof (prove)\nusing this:\n  RETURN\n   (compute_SCC_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n  \\<le> \\<Down>\n         (\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel)\n         compute_SCC_spec\n  (G_impl, G) \\<in> \\<langle>Re, node_rel\\<rangle>g_impl_rel_ext\n  (node_eq_impl, (=))\n  \\<in> node_rel \\<rightarrow> node_rel \\<rightarrow> bool_rel\n  is_bounded_hashcode node_rel node_eq_impl node_hash_impl\n  is_valid_def_hm_size TYPE('vi) node_def_hash_size\n\ngoal (1 subgoal):\n 1. RETURN\n     (compute_SCC_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n    \\<le> \\<Down>\n           (\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel)\n           compute_SCC_spec", "by simp"], ["proof (state)\nthis:\n  RETURN\n   (compute_SCC_tr node_eq_impl node_hash_impl node_def_hash_size G_impl)\n  \\<le> \\<Down>\n         (\\<langle>\\<langle>node_rel\\<rangle>list_set_rel\\<rangle>list_rel)\n         compute_SCC_spec\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Extraction of Benchmark Code\\<close>"], ["", "schematic_goal list_set_of_list_aux: \n  \"(?c,set)\\<in>\\<langle>nat_rel\\<rangle>list_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, set)\n    \\<in> \\<langle>nat_rel\\<rangle>list_rel \\<rightarrow>\n          \\<langle>nat_rel\\<rangle>list_set_rel", "by autoref"], ["", "concrete_definition list_set_of_list uses list_set_of_list_aux"], ["", "term compute_SCC_tr"], ["", "definition compute_SCC_tr_nat :: \"_ \\<Rightarrow> _ \\<Rightarrow> _ \\<Rightarrow> _ \\<Rightarrow> nat list list\"\n  where \"compute_SCC_tr_nat \\<equiv> compute_SCC_tr\""], ["", "(*export_code \n  compute_SCC_tr_nat\n  succ_of_list_impl\n  nat_of_integer\n  integer_of_nat\n  list_set_of_list\n  in SML module_name CSCC_Gabow\n  file \"Gabow_Benchmark/cscc_gabow.sml\"\n*)"], ["", "end"]]}