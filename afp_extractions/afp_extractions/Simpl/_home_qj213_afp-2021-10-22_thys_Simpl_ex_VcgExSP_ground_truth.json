{"file_name": "/home/qj213/afp-2021-10-22/thys/Simpl/ex/VcgExSP.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Simpl", "problem_names": ["lemma (in state_space)\"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>N = n\\<rbrace> LOC \\<acute>N :== 10;; \\<acute>N :== \\<acute>N + 2 COL \\<lbrace>\\<acute>N = n\\<rbrace>\"", "lemma (in state_space) \"\\<Gamma>\\<turnstile> {|\\<acute>N = 5|} \\<acute>N :== 2 * \\<acute>N {|\\<acute>N = 10|}\"", "lemma (in state_space) \"\\<Gamma>\\<turnstile> \\<lbrace>True\\<rbrace> \\<acute>N :== 10 \\<lbrace>\\<acute>N = 10\\<rbrace>\"", "lemma (in state_space) \"\\<Gamma>\\<turnstile> \\<lbrace>2 * \\<acute>N = 10\\<rbrace> \\<acute>N :== 2 * \\<acute>N \\<lbrace>\\<acute>N = 10\\<rbrace>\"", "lemma (in state_space) \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>N = 5\\<rbrace> \\<acute>N :== 2 * \\<acute>N \\<lbrace>\\<acute>N = 10\\<rbrace>\"", "lemma (in state_space) \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>N + 1 = a + 1\\<rbrace> \\<acute>N :== \\<acute>N + 1 \\<lbrace>\\<acute>N = a + 1\\<rbrace>\"", "lemma (in state_space) \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>N = a\\<rbrace> \\<acute>N :== \\<acute>N + 1 \\<lbrace>\\<acute>N = a + 1\\<rbrace>\"", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>a = a \\<and> b = b\\<rbrace> \\<acute>M :== a;; \\<acute>N :== b \\<lbrace>\\<acute>M = a \\<and> \\<acute>N = b\\<rbrace>\"", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>True\\<rbrace> \\<acute>M :== a;; \\<acute>N :== b \\<lbrace>\\<acute>M = a \\<and> \\<acute>N = b\\<rbrace>\"", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>M = a \\<and> \\<acute>N = b\\<rbrace>\n                \\<acute>I :== \\<acute>M;; \\<acute>M :== \\<acute>N;; \\<acute>N :== \\<acute>I\n              \\<lbrace>\\<acute>M = b \\<and> \\<acute>N = a\\<rbrace>\"", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>M = a \\<and> \\<acute>N = b\\<rbrace>\n               \\<acute>I :== \\<acute>M;; \\<acute>M :== \\<acute>N;; \\<acute>N :== \\<acute>I\n              \\<lbrace>\\<acute>M = b \\<and> \\<acute>N = a\\<rbrace>\"", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace> \\<acute>M :== \\<acute>M + 1 \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>\"", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace> \\<acute>M :== \\<acute>M + 1 \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>\"", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace> \\<acute>M :== \\<acute>M + 1 \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>\"", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n      WHILE \\<acute>M \\<noteq> a\n      DO \\<acute>S :== \\<acute>S + b;; \\<acute>M :== \\<acute>M + 1 OD\n      \\<lbrace>\\<acute>S = a * b\\<rbrace>\"", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n          WHILE \\<acute>M \\<noteq> a\n          INV \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>\n          DO \\<acute>S :== \\<acute>S + b;; \\<acute>M :== \\<acute>M + 1 OD\n          \\<lbrace>\\<acute>S = a * b\\<rbrace>\"", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n          TRY\n            WHILE True\n            INV \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>\n            DO IF \\<acute>M = a THEN THROW ELSE \\<acute>S :== \\<acute>S + b;; \\<acute>M :== \\<acute>M + 1 FI OD\n          CATCH\n            SKIP\n          END\n          \\<lbrace>\\<acute>S = a * b\\<rbrace>\"", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n          TRY\n            WHILE True\n            INV \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>\n            DO IF \\<acute>M = a THEN \\<acute>Abr :== ''Break'';;THROW\n               ELSE \\<acute>S :== \\<acute>S + b;; \\<acute>M :== \\<acute>M + 1\n               FI\n            OD\n          CATCH\n            IF \\<acute>Abr = ''Break'' THEN SKIP ELSE Throw FI\n          END\n          \\<lbrace>\\<acute>S = a * b\\<rbrace>\"", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n          \\<lbrace>\\<acute>Abr = ''Break''\\<rbrace>\\<bullet> WHILE True INV \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>\n           DO IF \\<acute>M = a THEN RAISE \\<acute>Abr :== ''Break''\n              ELSE \\<acute>S :== \\<acute>S + b;; \\<acute>M :== \\<acute>M + 1\n              FI\n           OD\n          \\<lbrace>\\<acute>S = a * b\\<rbrace>\"", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n          TRY\n            WHILE True\n            INV \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>\n            DO IF \\<acute>M = a THEN RAISE \\<acute>Abr :== ''Break''\n               ELSE \\<acute>S :== \\<acute>S + b;; \\<acute>M :== \\<acute>M + 1\n               FI\n            OD\n          CATCH\n            IF \\<acute>Abr = ''Break'' THEN SKIP ELSE Throw FI\n          END\n          \\<lbrace>\\<acute>S = a * b\\<rbrace>\"", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n          \\<lbrace>\\<acute>Abr = ''Break''\\<rbrace> \\<bullet> WHILE True\n          INV \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>\n          DO IF \\<acute>M = a THEN RAISE \\<acute>Abr :== ''Break''\n               ELSE \\<acute>S :== \\<acute>S + b;; \\<acute>M :== \\<acute>M + 1\n               FI\n          OD\n          \\<lbrace>\\<acute>S = a * b\\<rbrace>\"", "lemma  (in state_space)\n  shows \"\\<Gamma>\\<turnstile>\\<lbrace>\\<acute>I = i\\<rbrace> LOC \\<acute>I;; \\<acute>I :== 2  COL \\<lbrace>\\<acute>I \\<le> i\\<rbrace>\"", "theorem (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>True\\<rbrace>\n           \\<acute>S :== 0;; \\<acute>I :== 1;;\n           WHILE \\<acute>I \\<noteq> n\n           DO\n             \\<acute>S :== \\<acute>S + \\<acute>I;;\n             \\<acute>I :== \\<acute>I + 1\n           OD\n           \\<lbrace>\\<acute>S = (SUMM j<n. j)\\<rbrace>\"\n  (is \"\\<Gamma>\\<turnstile> _ (_;; ?while) _\")", "theorem (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>True\\<rbrace>\n           \\<acute>S :== 0;; \\<acute>I :== 1;;\n           WHILE \\<acute>I \\<noteq> n\n           INV \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>\n           DO\n             \\<acute>S :== \\<acute>S + \\<acute>I;;\n             \\<acute>I :== \\<acute>I + 1\n           OD\n          \\<lbrace>\\<acute>S = (SUMM j<n. j)\\<rbrace>\"", "theorem (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>True\\<rbrace>\n           \\<acute>S :== 0;; \\<acute>I :== 1;;\n           WHILE \\<acute>I \\<noteq> n\n           INV \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>\n           DO\n             \\<acute>S :== \\<acute>S + \\<acute>I;;\n             \\<acute>I :== \\<acute>I + 1\n           OD\n           \\<lbrace>\\<acute>S = (SUMM j<n. j)\\<rbrace>\"", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>N = 5\\<rbrace> SWITCH \\<acute>B\n                        {True} \\<Rightarrow> \\<acute>N :== 6\n                      | {False} \\<Rightarrow> \\<acute>N :== 7\n                     END\n          \\<lbrace>\\<acute>N > 5\\<rbrace>\"", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>N = 5\\<rbrace> SWITCH \\<acute>N\n                        {v. v < 5} \\<Rightarrow> \\<acute>N :== 6\n                      | {v. v \\<ge> 5} \\<Rightarrow> \\<acute>N :== 7\n                     END\n          \\<lbrace>\\<acute>N > 5\\<rbrace>\"", "lemma fac_simp [simp]: \"0 < i \\<Longrightarrow>  fac i = i * fac (i - 1)\"", "lemma (in Fac_impl) Fac_spec':\n  shows \"\\<forall>\\<sigma>. \\<Gamma>,\\<Theta>\\<turnstile>{\\<sigma>} PROC Fac(\\<acute>N,\\<acute>R) \\<lbrace>\\<acute>R = fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>\"", "lemma (in Fac_impl) Fac_spec1:\n  shows \"\\<forall>\\<sigma>. \\<Gamma>,\\<Theta>\\<turnstile>{\\<sigma>} \\<acute>R :== PROC Fac(\\<acute>N) \\<lbrace>\\<acute>R = fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>\"", "lemma (in Fac_impl) Fac_spec2:\n\n  shows \"\\<forall>\\<sigma>. \\<Gamma>,\\<Theta>\\<turnstile>{\\<sigma>} \\<acute>R :== PROC Fac(\\<acute>N) \\<lbrace>\\<acute>R = fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>\"", "lemma (in Fac_impl) Fac_spec3:\n  shows \"\\<forall>\\<sigma>. \\<Gamma>,\\<Theta>\\<turnstile>{\\<sigma>} \\<acute>R :== PROC Fac(\\<acute>N) \\<lbrace>\\<acute>R = fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>\"\n  (is \"\\<forall>\\<sigma>. \\<Gamma>,\\<Theta>\\<turnstile>(?Pre \\<sigma>) ?Fac (?Post \\<sigma>)\")", "lemma (in Fac_impl) Fac_spec4:\n  shows \"\\<forall>\\<sigma>. \\<Gamma>,\\<Theta>\\<turnstile>{\\<sigma>} \\<acute>R :== PROC Fac(\\<acute>N) \\<lbrace>\\<acute>R = fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>\"\n  (is \"\\<forall>\\<sigma>. \\<Gamma>,\\<Theta>\\<turnstile>(?Pre \\<sigma>) ?Fac (?Post \\<sigma>)\")", "lemma (in odd_even_clique)\n  shows odd_spec: \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>{\\<sigma>} \\<acute>A :== PROC odd(\\<acute>N)\n                  \\<lbrace>(\\<exists>b. \\<^bsup>\\<sigma>\\<^esup>N = 2 * b + \\<acute>A) \\<and> \\<acute>A < 2 \\<rbrace>\" (is ?P1)\n   and even_spec: \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>{\\<sigma>} \\<acute>A :== PROC even(\\<acute>N)\n                  \\<lbrace>(\\<exists>b. \\<^bsup>\\<sigma>\\<^esup>N + 1 = 2 * b + \\<acute>A) \\<and> \\<acute>A < 2 \\<rbrace>\" (is ?P2)", "lemma (in state_space) shows \"\\<Gamma>\\<turnstile> \\<lbrace>True\\<rbrace>\n  \\<acute>N \\<ggreater> n. \\<acute>N :== \\<acute>N + 1 \\<ggreater>\n  \\<acute>M \\<ggreater> m. \\<acute>M :== \\<acute>M + 1 \\<ggreater>\n  \\<acute>R :== n + m\n  \\<lbrace>\\<acute>R = \\<acute>N + \\<acute>M - 2\\<rbrace>\"", "lemma (in Fac_impl) shows\n  \"\\<Gamma>\\<turnstile> \\<lbrace>True\\<rbrace>\n  CALL Fac(\\<acute>N) \\<ggreater> n. CALL Fac(\\<acute>N) \\<ggreater> m.\n  \\<acute>R :== n + m\n  \\<lbrace>\\<acute>R = fac \\<acute>N + fac \\<acute>N\\<rbrace>\"", "lemma (in Fac_impl) shows\n  \"\\<Gamma>\\<turnstile> \\<lbrace>True\\<rbrace>\n  CALL Fac(\\<acute>N) \\<ggreater> n. CALL Fac(n) \\<ggreater> m.\n  \\<acute>R :== m\n  \\<lbrace>\\<acute>R = fac (fac \\<acute>N)\\<rbrace>\"", "lemma (in append_impl) append_spec:\n  shows \"\\<forall>\\<sigma> Ps Qs. \\<Gamma>\\<turnstile>\n            \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next Ps \\<and>  List \\<acute>q \\<acute>next Qs \\<and> set Ps \\<inter> set Qs = {}\\<rbrace>\n                \\<acute>p :== PROC append(\\<acute>p,\\<acute>q)\n            \\<lbrace>List \\<acute>p \\<acute>next (Ps@Qs) \\<and> (\\<forall>x. x\\<notin>set Ps \\<longrightarrow> \\<acute>next x = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>\"", "lemma (in append_impl) shows \"{t. t may_only_modify_globals Z in [next]}\n       =\n       {t. \\<exists>next. globals t=update id id next_' (K_statefun next) (globals Z)}\"", "lemma (in append_impl)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>p=Null \\<and> \\<acute>cont=c\\<rbrace> \\<acute>p :== CALL append(\\<acute>p,Null) \\<lbrace>\\<acute>cont=c\\<rbrace>\"", "lemma (in append_impl) append_modifies:\n  shows\n   \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile> {\\<sigma>} \\<acute>p :== PROC append(\\<acute>p,\\<acute>q){t. t may_only_modify_globals \\<sigma> in [next]}\"", "lemma (in append_impl)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>p=Null \\<and> \\<acute>cont=c\\<rbrace> \\<acute>p\\<rightarrow>\\<acute>next :== CALL append(\\<acute>p,Null) \\<lbrace>\\<acute>cont=c\\<rbrace>\"", "lemma (in insert_impl) insert_modifies:\n  \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile> {\\<sigma>} \\<acute>p :== PROC insert(\\<acute>r,\\<acute>p){t. t may_only_modify_globals \\<sigma> in [next]}\"", "lemma (in insert_impl) insert_spec:\n    \"\\<forall>\\<sigma> Ps . \\<Gamma>\\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next Ps \\<and> sorted (\\<le>) (map \\<acute>cont Ps) \\<and>\n                  \\<acute>r \\<noteq> Null \\<and> \\<acute>r \\<notin> set Ps\\<rbrace>\n         \\<acute>p :== PROC insert(\\<acute>r,\\<acute>p)\n   \\<lbrace>\\<exists>Qs. List \\<acute>p \\<acute>next Qs \\<and> sorted (\\<le>) (map \\<^bsup>\\<sigma>\\<^esup>cont  Qs) \\<and>\n           set Qs = insert \\<^bsup>\\<sigma>\\<^esup>r (set Ps) \\<and>\n           (\\<forall>x. x \\<notin> set Qs \\<longrightarrow> \\<acute>next x = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>\"", "lemma (in insertSort_impl) insertSort_modifies:\n  shows\n   \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile> {\\<sigma>} \\<acute>p :== PROC insertSort(\\<acute>p)\n              {t. t may_only_modify_globals \\<sigma> in [next]}\"", "lemma (in insertSort_impl) insertSort_body_spec:\n  shows \"\\<forall>\\<sigma> Ps. \\<Gamma>,\\<Theta>\\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next Ps \\<rbrace>\n              \\<acute>p :== PROC insertSort(\\<acute>p)\n          \\<lbrace>\\<exists>Qs. List \\<acute>p \\<acute>next Qs \\<and> sorted (\\<le>) (map \\<^bsup>\\<sigma>\\<^esup>cont Qs) \\<and>\n           set Qs = set Ps\\<rbrace>\"", "lemma (in list_alloc)\n shows\n  \"\\<Gamma>,\\<Theta>\\<turnstile> \\<lbrace>\\<acute>i = 0 \\<and> \\<acute>first = Null \\<and> n*sz \\<le> \\<acute>free\\<rbrace>\n       WHILE \\<acute>i < n\n       INV \\<lbrace>\\<exists>Ps. List \\<acute>first \\<acute>next Ps \\<and> length Ps = \\<acute>i \\<and> \\<acute>i \\<le> n \\<and>\n             set Ps \\<subseteq> set \\<acute>alloc \\<and> (n - \\<acute>i)*sz \\<le> \\<acute>free\\<rbrace>\n       DO\n         \\<acute>p :== NEW sz [\\<acute>cont:==0,\\<acute>next:== Null];;\n         \\<acute>p\\<rightarrow>\\<acute>next :== \\<acute>first;;\n         \\<acute>first :== \\<acute>p;;\n         \\<acute>i :== \\<acute>i+ 1\n       OD\n       \\<lbrace>\\<exists>Ps. List \\<acute>first \\<acute>next  Ps \\<and> length Ps = n \\<and> set Ps \\<subseteq> set \\<acute>alloc\\<rbrace>\"", "lemma (in list_alloc)\n shows\n  \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>i = 0 \\<and> \\<acute>first = Null \\<and> n*sz \\<le> \\<acute>free\\<rbrace>\n       WHILE \\<acute>i < n\n       INV \\<lbrace>\\<exists>Ps. List \\<acute>first \\<acute>next Ps \\<and> length Ps = \\<acute>i \\<and> \\<acute>i \\<le> n \\<and>\n             set Ps \\<subseteq> set \\<acute>alloc \\<and> (n - \\<acute>i)*sz \\<le> \\<acute>free\\<rbrace>\n       DO\n         \\<acute>p :== NNEW sz [\\<acute>cont:==0,\\<acute>next:== Null];;\n         \\<acute>p\\<rightarrow>\\<acute>next :== \\<acute>first;;\n         \\<acute>first :== \\<acute>p;;\n         \\<acute>i :== \\<acute>i+ 1\n       OD\n       \\<lbrace>\\<exists>Ps. List \\<acute>first \\<acute>next  Ps \\<and> length Ps = n \\<and> set Ps \\<subseteq> set \\<acute>alloc\\<rbrace>\"", "lemma (in list_alloc) \"\\<Gamma>,\\<Theta>\\<turnstile> \\<lbrace>True\\<rbrace>  \\<lbrace>\\<acute>p\\<noteq>Null\\<rbrace>\\<longmapsto> \\<acute>p\\<rightarrow>\\<acute>next :== \\<acute>p \\<lbrace>True\\<rbrace>\"", "lemma (in list_alloc) \"\\<Gamma>,\\<Theta>\\<turnstile> {}  \\<lbrace>\\<acute>p\\<noteq>Null\\<rbrace>\\<longmapsto> \\<acute>p\\<rightarrow>\\<acute>next :== \\<acute>p \\<lbrace>True\\<rbrace>\"", "lemma (in list_alloc)\n  shows\n  \"\\<Gamma>,\\<Theta>\\<turnstile> \\<lbrace>List \\<acute>p \\<acute>next Ps \\<and> List \\<acute>q \\<acute>next Qs \\<and> set Ps \\<inter> set Qs = {} \\<and>\n       set Ps \\<subseteq> set \\<acute>alloc \\<and> set Qs \\<subseteq> set \\<acute>alloc\\<rbrace>\n  WHILE \\<acute>p \\<noteq> Null\n  INV \\<lbrace>\\<exists>ps qs. List \\<acute>p \\<acute>next  ps \\<and> List \\<acute>q \\<acute>next qs \\<and> set ps \\<inter> set qs = {} \\<and>\n               rev ps @ qs = rev Ps @ Qs \\<and>\n               set ps \\<subseteq> set \\<acute>alloc \\<and> set qs \\<subseteq> set \\<acute>alloc\\<rbrace>\n  DO \\<acute>r :== \\<acute>p;;\n     \\<acute>p :== \\<acute>p\\<rightarrow> \\<acute>next;;\n     \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>q;;\n     \\<acute>q :== \\<acute>r OD\n  \\<lbrace>List \\<acute>q \\<acute>next (rev Ps @ Qs) \\<and> set Ps\\<subseteq> set \\<acute>alloc \\<and> set Qs \\<subseteq> set \\<acute>alloc\\<rbrace>\"", "lemma (in list_alloc)\n  shows\n  \"\\<Gamma>,\\<Theta>\\<turnstile> \\<lbrace>List \\<acute>p \\<acute>next Ps \\<and> List \\<acute>q \\<acute>next Qs \\<and> set Ps \\<inter> set Qs = {} \\<and>\n       set Ps \\<subseteq> set \\<acute>alloc \\<and> set Qs \\<subseteq> set \\<acute>alloc\\<rbrace>\n  WHILE \\<acute>p \\<noteq> Null\n  INV \\<lbrace>\\<exists>ps qs. List \\<acute>p \\<acute>next  ps \\<and> List \\<acute>q \\<acute>next qs \\<and> set ps \\<inter> set qs = {} \\<and>\n               rev ps @ qs = rev Ps @ Qs \\<and>\n               set ps \\<subseteq> set \\<acute>alloc \\<and> set qs \\<subseteq> set \\<acute>alloc\\<rbrace>\n  DO \\<acute>r :== \\<acute>p;;\n     \\<lbrace>\\<acute>p\\<noteq>Null \\<and> \\<acute>p\\<in>set \\<acute>alloc\\<rbrace>\\<longmapsto> \\<acute>p :== \\<acute>p\\<rightarrow> \\<acute>next;;\n     \\<lbrace>\\<acute>r\\<noteq>Null \\<and> \\<acute>r\\<in>set \\<acute>alloc\\<rbrace>\\<longmapsto> \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>q;;\n     \\<acute>q :== \\<acute>r OD\n \\<lbrace>List \\<acute>q \\<acute>next (rev Ps @ Qs) \\<and> set Ps \\<subseteq> set \\<acute>alloc \\<and> set Qs \\<subseteq> set \\<acute>alloc\\<rbrace>\"", "lemma (in list_alloc) rev_noFault:\n  shows\n  \"\\<Gamma>,\\<Theta>\\<turnstile> \\<lbrace>List \\<acute>p \\<acute>next Ps \\<and> List \\<acute>q \\<acute>next Qs \\<and> set Ps \\<inter> set Qs = {} \\<and>\n       set Ps \\<subseteq> set \\<acute>alloc \\<and> set Qs \\<subseteq> set \\<acute>alloc\\<rbrace>\n  WHILE \\<acute>p \\<noteq> Null\n  INV \\<lbrace>\\<exists>ps qs. List \\<acute>p \\<acute>next  ps \\<and> List \\<acute>q \\<acute>next qs \\<and> set ps \\<inter> set qs = {} \\<and>\n               rev ps @ qs = rev Ps @ Qs \\<and>\n               set ps \\<subseteq> set \\<acute>alloc \\<and> set qs \\<subseteq> set \\<acute>alloc\\<rbrace>\n  DO \\<acute>r :== \\<acute>p;;\n     \\<lbrace>\\<acute>p\\<noteq>Null \\<and> \\<acute>p\\<in>set \\<acute>alloc\\<rbrace>\\<longmapsto> \\<acute>p :== \\<acute>p\\<rightarrow> \\<acute>next;;\n     \\<lbrace>\\<acute>r\\<noteq>Null \\<and> \\<acute>r\\<in>set \\<acute>alloc\\<rbrace>\\<longmapsto> \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>q;;\n     \\<acute>q :== \\<acute>r OD\n  UNIV,UNIV\"", "lemma (in list_alloc) rev_moduloGuards:\n\n  shows\n  \"\\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/{True}\\<^esub> \\<lbrace>List \\<acute>p \\<acute>next Ps \\<and> List \\<acute>q \\<acute>next Qs \\<and> set Ps \\<inter> set Qs = {} \\<and>\n       set Ps \\<subseteq> set \\<acute>alloc \\<and> set Qs \\<subseteq> set \\<acute>alloc\\<rbrace>\n  WHILE \\<acute>p \\<noteq> Null\n  INV \\<lbrace>\\<exists>ps qs. List \\<acute>p \\<acute>next  ps \\<and> List \\<acute>q \\<acute>next qs \\<and> set ps \\<inter> set qs = {} \\<and>\n               rev ps @ qs = rev Ps @ Qs \\<and>\n               set ps \\<subseteq> set \\<acute>alloc \\<and> set qs \\<subseteq> set \\<acute>alloc\\<rbrace>\n  DO \\<acute>r :== \\<acute>p;;\n     \\<lbrace>\\<acute>p\\<noteq>Null \\<and> \\<acute>p\\<in>set \\<acute>alloc\\<rbrace>\\<surd> \\<longmapsto> \\<acute>p :== \\<acute>p\\<rightarrow> \\<acute>next;;\n     \\<lbrace>\\<acute>r\\<noteq>Null \\<and> \\<acute>r\\<in>set \\<acute>alloc\\<rbrace>\\<surd> \\<longmapsto> \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>q;;\n     \\<acute>q :== \\<acute>r OD\n \\<lbrace>List \\<acute>q \\<acute>next (rev Ps @ Qs) \\<and> set Ps \\<subseteq> set \\<acute>alloc \\<and> set Qs \\<subseteq> set \\<acute>alloc\\<rbrace>\"", "lemma CombineStrip':\n  assumes deriv: \"\\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F\\<^esub> P c' Q,A\"\n  assumes deriv_strip: \"\\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/{}\\<^esub> P c'' UNIV,UNIV\"\n  assumes c'': \"c''= mark_guards False (strip_guards (-F) c')\"\n  assumes c: \"c = mark_guards False c'\"\n  shows \"\\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/{}\\<^esub> P c Q,A\"", "lemma (in list_alloc)\n  shows\n  \"\\<Gamma>,\\<Theta>\\<turnstile> \\<lbrace>List \\<acute>p \\<acute>next Ps \\<and> List \\<acute>q \\<acute>next Qs \\<and> set Ps \\<inter> set Qs = {} \\<and>\n       set Ps \\<subseteq> set \\<acute>alloc \\<and> set Qs \\<subseteq> set \\<acute>alloc\\<rbrace>\n  WHILE \\<acute>p \\<noteq> Null\n  INV \\<lbrace>\\<exists>ps qs. List \\<acute>p \\<acute>next  ps \\<and> List \\<acute>q \\<acute>next qs \\<and> set ps \\<inter> set qs = {} \\<and>\n               rev ps @ qs = rev Ps @ Qs \\<and>\n               set ps \\<subseteq> set \\<acute>alloc \\<and> set qs \\<subseteq> set \\<acute>alloc\\<rbrace>\n  DO \\<acute>r :== \\<acute>p;;\n     \\<lbrace>\\<acute>p\\<noteq>Null \\<and> \\<acute>p\\<in>set \\<acute>alloc\\<rbrace>\\<longmapsto> \\<acute>p :== \\<acute>p\\<rightarrow> \\<acute>next;;\n     \\<lbrace>\\<acute>r\\<noteq>Null \\<and> \\<acute>r\\<in>set \\<acute>alloc\\<rbrace>\\<longmapsto> \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>q;;\n     \\<acute>q :== \\<acute>r OD\n \\<lbrace>List \\<acute>q \\<acute>next (rev Ps @ Qs) \\<and> set Ps \\<subseteq> set \\<acute>alloc \\<and> set Qs \\<subseteq> set \\<acute>alloc\\<rbrace>\"", "lemma neq_dP: \"\\<lbrakk>p \\<noteq> q; Path p h q Ps; distinct Ps\\<rbrakk> \\<Longrightarrow>\n \\<exists>Qs. p\\<noteq>Null \\<and> Ps = p#Qs \\<and> p \\<notin> set Qs\"", "lemma (in list_alloc) circular_list_rev_I:\n  \"\\<Gamma>,\\<Theta>\\<turnstile> \\<lbrace>\\<acute>root = r \\<and>  distPath \\<acute>root \\<acute>next \\<acute>root (r#Ps)\\<rbrace>\n   \\<acute>p :== \\<acute>root;; \\<acute>q :== \\<acute>root\\<rightarrow>\\<acute>next;;\n  WHILE \\<acute>q \\<noteq> \\<acute>root\n  INV \\<lbrace>\\<exists> ps qs. distPath \\<acute>p \\<acute>next \\<acute>root ps  \\<and> distPath \\<acute>q \\<acute>next \\<acute>root qs \\<and>\n             \\<acute>root = r \\<and> r\\<noteq>Null \\<and> r \\<notin> set Ps  \\<and> set ps \\<inter> set qs = {} \\<and>\n             Ps = (rev ps) @ qs \\<rbrace>\n  DO \\<acute>tmp :== \\<acute>q;; \\<acute>q :== \\<acute>q\\<rightarrow>\\<acute>next;; \\<acute>tmp\\<rightarrow>\\<acute>next :== \\<acute>p;; \\<acute>p:==\\<acute>tmp OD;;\n  \\<acute>root\\<rightarrow>\\<acute>next :== \\<acute>p\n  \\<lbrace>\\<acute>root = r \\<and> distPath \\<acute>root \\<acute>next \\<acute>root (r#rev Ps)\\<rbrace>\"", "lemma path_is_list:\"\\<And>a next b. \\<lbrakk>Path b next a Ps ; a \\<notin> set Ps; a\\<noteq>Null\\<rbrakk>\n\\<Longrightarrow> List b (next(a := Null)) (Ps @ [a])\"", "lemma (in list_alloc) circular_list_rev_II:\n \"\\<Gamma>,\\<Theta>\\<turnstile>\n \\<lbrace>\\<acute>p = r \\<and> distPath \\<acute>p \\<acute>next \\<acute>p (r#Ps)\\<rbrace>\n\\<acute>q:==Null;;\nWHILE \\<acute>p \\<noteq> Null\nINV\n \\<lbrace> ((\\<acute>q = Null) \\<longrightarrow> (\\<exists>ps. distPath \\<acute>p \\<acute>next r ps  \\<and>  ps = r#Ps)) \\<and>\n  ((\\<acute>q \\<noteq> Null) \\<longrightarrow> (\\<exists>ps qs. distPath \\<acute>q \\<acute>next r qs  \\<and> List \\<acute>p \\<acute>next ps  \\<and>\n                   set ps \\<inter> set qs = {} \\<and> rev qs @ ps = Ps@[r])) \\<and>\n  \\<not> (\\<acute>p = Null \\<and> \\<acute>q = Null \\<and> r = Null )\n   \\<rbrace>\nDO\n  \\<acute>tmp :== \\<acute>p;; \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;; \\<acute>tmp\\<rightarrow>\\<acute>next :== \\<acute>q;; \\<acute>q:==\\<acute>tmp\nOD\n \\<lbrace>\\<acute>q = r \\<and> distPath \\<acute>q \\<acute>next \\<acute>q (r # rev Ps)\\<rbrace>\"", "lemma (in state_space) \"\\<Gamma>\\<turnstile> {\\<sigma>}\n            \\<acute>I :== \\<acute>M;;\n            ANNO \\<tau>. \\<lbrace>\\<tau>. \\<acute>I = \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>\n                      \\<acute>M :== \\<acute>N;; \\<acute>N :== \\<acute>I\n                    \\<lbrace>\\<acute>M = \\<^bsup>\\<tau>\\<^esup>N \\<and> \\<acute>N = \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>\n            \\<lbrace>\\<acute>M = \\<^bsup>\\<sigma>\\<^esup>N \\<and> \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>\"", "lemma (in state_space) \"\\<Gamma>\\<turnstile> ({\\<sigma>} \\<inter> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>)\n      (ANNO \\<tau>. ({\\<tau>} \\<inter> \\<lbrace>\\<acute>A=\\<^bsup>\\<sigma>\\<^esup>A \\<and> \\<acute>I=\\<^bsup>\\<sigma>\\<^esup>I \\<and> \\<acute>M=0 \\<and> \\<acute>S=0\\<rbrace>)\n      WHILE \\<acute>M \\<noteq> \\<acute>A\n      INV \\<lbrace>\\<acute>S = \\<acute>M * \\<acute>I \\<and> \\<acute>A=\\<^bsup>\\<tau>\\<^esup>A \\<and> \\<acute>I=\\<^bsup>\\<tau>\\<^esup>I\\<rbrace>\n      DO \\<acute>S :== \\<acute>S + \\<acute>I;; \\<acute>M :== \\<acute>M + 1 OD\n      \\<lbrace>\\<acute>S = \\<^bsup>\\<tau>\\<^esup>A * \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>)\n      \\<lbrace>\\<acute>S = \\<^bsup>\\<sigma>\\<^esup>A * \\<^bsup>\\<sigma>\\<^esup>I\\<rbrace>\"", "lemma (in state_space) \"\\<Gamma>\\<turnstile>\\<lbrace>True\\<rbrace> WHILE \\<lbrace>P \\<acute>N \\<rbrace>\\<surd>, \\<lbrace>Q \\<acute>M\\<rbrace>#, \\<lbrace>R \\<acute>N\\<rbrace>\\<longmapsto> \\<acute>N < \\<acute>M\n                    INV \\<lbrace>\\<acute>N < 2\\<rbrace> DO\n                    \\<acute>N :== \\<acute>M\n                  OD\n           \\<lbrace>hard\\<rbrace>\"", "lemma (in state_space) \"\\<Gamma>\\<turnstile>\\<^bsub>/{True}\\<^esub> \\<lbrace>True\\<rbrace> WHILE \\<lbrace>P \\<acute>N \\<rbrace>\\<surd>, \\<lbrace>Q \\<acute>M\\<rbrace>#, \\<lbrace>R \\<acute>N\\<rbrace>\\<longmapsto> \\<acute>N < \\<acute>M\n                    INV \\<lbrace>\\<acute>N < 2\\<rbrace> DO\n                    \\<acute>N :== \\<acute>M\n                  OD\n           \\<lbrace>hard\\<rbrace>\""], "translations": [["", "lemma (in state_space)\"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>N = n\\<rbrace> LOC \\<acute>N :== 10;; \\<acute>N :== \\<acute>N + 2 COL \\<lbrace>\\<acute>N = n\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>N = n\\<rbrace>\n                     LOC \\<acute>N :== 10;; \\<acute>N :== \\<acute>N + 2 COL\n                    \\<lbrace>\\<acute>N = n\\<rbrace>", "by vcg"], ["", "text \\<open>Internally we decorate the state components in the statespace with the\nsuffix \\<open>_'\\<close>,\nto avoid cluttering the namespace with the simple names that could no longer\nbe used for logical variables otherwise.\n\\<close>"], ["", "text \\<open>We will first consider programs without procedures, later on\nwe will regard procedures without global variables and finally we\nwill get the full pictures: mutually recursive procedures with global\nvariables (including heap).\n\\<close>"], ["", "subsection \\<open>Basic Examples\\<close>"], ["", "text \\<open>\n We look at few trivialities involving assignment and sequential\n composition, in order to get an idea of how to work with our\n formulation of Hoare Logic.\n\\<close>"], ["", "text \\<open>\n Using the basic rule directly is a bit cumbersome.\n\\<close>"], ["", "lemma (in state_space) \"\\<Gamma>\\<turnstile> {|\\<acute>N = 5|} \\<acute>N :== 2 * \\<acute>N {|\\<acute>N = 10|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>N = 5\\<rbrace>\n                    \\<acute>N :== 2 * \\<acute>N\n                    \\<lbrace>\\<acute>N = 10\\<rbrace>", "apply (rule HoarePartial.Basic)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<acute>N = 5\\<rbrace>\n    \\<subseteq> {s. s\\<lparr>locals :=\n                               update project_Nat_nat inject_Nat_nat N_'\n                                (K_statefun\n                                  (2 *\n                                   lookup project_Nat_nat N_' (locals s)))\n                                (locals s)\\<rparr>\n                    \\<in> \\<lbrace>\\<acute>N = 10\\<rbrace>}", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in state_space) \"\\<Gamma>\\<turnstile> \\<lbrace>True\\<rbrace> \\<acute>N :== 10 \\<lbrace>\\<acute>N = 10\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace> \\<acute>N :== 10\n                    \\<lbrace>\\<acute>N = 10\\<rbrace>", "by vcg"], ["", "lemma (in state_space) \"\\<Gamma>\\<turnstile> \\<lbrace>2 * \\<acute>N = 10\\<rbrace> \\<acute>N :== 2 * \\<acute>N \\<lbrace>\\<acute>N = 10\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>2 * \\<acute>N = 10\\<rbrace>\n                    \\<acute>N :== 2 * \\<acute>N\n                    \\<lbrace>\\<acute>N = 10\\<rbrace>", "by vcg"], ["", "lemma (in state_space) \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>N = 5\\<rbrace> \\<acute>N :== 2 * \\<acute>N \\<lbrace>\\<acute>N = 10\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>N = 5\\<rbrace>\n                    \\<acute>N :== 2 * \\<acute>N\n                    \\<lbrace>\\<acute>N = 10\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>N. N = 5 \\<Longrightarrow> 2 * N = 10", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in state_space) \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>N + 1 = a + 1\\<rbrace> \\<acute>N :== \\<acute>N + 1 \\<lbrace>\\<acute>N = a + 1\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>N + 1 = a + 1\\<rbrace>\n                    \\<acute>N :== \\<acute>N + 1\n                    \\<lbrace>\\<acute>N = a + 1\\<rbrace>", "by vcg"], ["", "lemma (in state_space) \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>N = a\\<rbrace> \\<acute>N :== \\<acute>N + 1 \\<lbrace>\\<acute>N = a + 1\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>N = a\\<rbrace>\n                    \\<acute>N :== \\<acute>N + 1\n                    \\<lbrace>\\<acute>N = a + 1\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>N. N + 1 = N + 1", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>a = a \\<and> b = b\\<rbrace> \\<acute>M :== a;; \\<acute>N :== b \\<lbrace>\\<acute>M = a \\<and> \\<acute>N = b\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>a = a \\<and> b = b\\<rbrace>\n                    \\<acute>M :== a;; \\<acute>N :== b\n                    \\<lbrace>\\<acute>M = a \\<and> \\<acute>N = b\\<rbrace>", "by vcg"], ["", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>True\\<rbrace> \\<acute>M :== a;; \\<acute>N :== b \\<lbrace>\\<acute>M = a \\<and> \\<acute>N = b\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace> \\<acute>M :== a;; \\<acute>N :== b\n                    \\<lbrace>\\<acute>M = a \\<and> \\<acute>N = b\\<rbrace>", "by vcg"], ["", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>M = a \\<and> \\<acute>N = b\\<rbrace>\n                \\<acute>I :== \\<acute>M;; \\<acute>M :== \\<acute>N;; \\<acute>N :== \\<acute>I\n              \\<lbrace>\\<acute>M = b \\<and> \\<acute>N = a\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = a \\<and> \\<acute>N = b\\<rbrace>\n                    \\<acute>I :== \\<acute>M;; \\<acute>M :== \\<acute>N;;\n                    \\<acute>N :== \\<acute>I\n                    \\<lbrace>\\<acute>M = b \\<and> \\<acute>N = a\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M N. N = N \\<and> M = M", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\nWe can also perform verification conditions generation step by step by using\nthe \\<open>vcg_step\\<close> method.\n\\<close>"], ["", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>M = a \\<and> \\<acute>N = b\\<rbrace>\n               \\<acute>I :== \\<acute>M;; \\<acute>M :== \\<acute>N;; \\<acute>N :== \\<acute>I\n              \\<lbrace>\\<acute>M = b \\<and> \\<acute>N = a\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = a \\<and> \\<acute>N = b\\<rbrace>\n                    \\<acute>I :== \\<acute>M;; \\<acute>M :== \\<acute>N;;\n                    \\<acute>N :== \\<acute>I\n                    \\<lbrace>\\<acute>M = b \\<and> \\<acute>N = a\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = a \\<and> \\<acute>N = b\\<rbrace>\n                    \\<acute>I :== \\<acute>M;; \\<acute>M :== \\<acute>N\n                    \\<lbrace>\\<acute>M = b \\<and> \\<acute>I = a\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = a \\<and> \\<acute>N = b\\<rbrace>\n                    \\<acute>I :== \\<acute>M\n                    \\<lbrace>\\<acute>N = b \\<and> \\<acute>I = a\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<acute>M = a \\<and> \\<acute>N = b\\<rbrace>\n    \\<subseteq> \\<lbrace>\\<acute>N = b \\<and> \\<acute>M = a\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M N. N = N \\<and> M = M", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n In the following assignments we make use of the consequence rule in\n order to achieve the intended precondition.  Certainly, the\n \\<open>vcg\\<close> method is able to handle this case, too.\n\\<close>"], ["", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace> \\<acute>M :== \\<acute>M + 1 \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace>\n                    \\<acute>M :== \\<acute>M + 1\n                    \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace>\n                    \\<acute>M :== \\<acute>M + 1\n                    \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>", "have \"\\<lbrace>\\<acute>M = \\<acute>N\\<rbrace> \\<subseteq> \\<lbrace>\\<acute>M + 1 \\<noteq> \\<acute>N\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace>\n    \\<subseteq> \\<lbrace>\\<acute>M + 1 \\<noteq> \\<acute>N\\<rbrace>", "by auto"], ["proof (state)\nthis:\n  \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace>\n  \\<subseteq> \\<lbrace>\\<acute>M + 1 \\<noteq> \\<acute>N\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace>\n                    \\<acute>M :== \\<acute>M + 1\n                    \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>", "also"], ["proof (state)\nthis:\n  \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace>\n  \\<subseteq> \\<lbrace>\\<acute>M + 1 \\<noteq> \\<acute>N\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace>\n                    \\<acute>M :== \\<acute>M + 1\n                    \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>", "have \"\\<Gamma>\\<turnstile> \\<dots> \\<acute>M :== \\<acute>M + 1 \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M + 1 \\<noteq> \\<acute>N\\<rbrace>\n                    \\<acute>M :== \\<acute>M + 1\n                    \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>", "by vcg"], ["proof (state)\nthis:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>\\<acute>M + 1 \\<noteq> \\<acute>N\\<rbrace>\n                  \\<acute>M :== \\<acute>M + 1\n                  \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace>\n                    \\<acute>M :== \\<acute>M + 1\n                    \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>", "finally"], ["proof (chain)\npicking this:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace>\n                  \\<acute>M :== \\<acute>M + 1\n                  \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace>\n                  \\<acute>M :== \\<acute>M + 1\n                  \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace>\n                    \\<acute>M :== \\<acute>M + 1\n                    \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>", "."], ["proof (state)\nthis:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace>\n                  \\<acute>M :== \\<acute>M + 1\n                  \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace> \\<acute>M :== \\<acute>M + 1 \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace>\n                    \\<acute>M :== \\<acute>M + 1\n                    \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace>\n                    \\<acute>M :== \\<acute>M + 1\n                    \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>", "have \"\\<And>m n::nat. m = n \\<longrightarrow> m + 1 \\<noteq> n\"\n      \\<comment> \\<open>inclusion of assertions expressed in ``pure'' logic,\\<close>\n      \\<comment> \\<open>without mentioning the state space\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m n. m = n \\<longrightarrow> m + 1 \\<noteq> n", "by simp"], ["proof (state)\nthis:\n  ?m = ?n \\<longrightarrow> ?m + 1 \\<noteq> ?n\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace>\n                    \\<acute>M :== \\<acute>M + 1\n                    \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>", "also"], ["proof (state)\nthis:\n  ?m = ?n \\<longrightarrow> ?m + 1 \\<noteq> ?n\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace>\n                    \\<acute>M :== \\<acute>M + 1\n                    \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>", "have \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>M + 1 \\<noteq> \\<acute>N\\<rbrace> \\<acute>M :== \\<acute>M + 1 \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M + 1 \\<noteq> \\<acute>N\\<rbrace>\n                    \\<acute>M :== \\<acute>M + 1\n                    \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>", "by vcg"], ["proof (state)\nthis:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>\\<acute>M + 1 \\<noteq> \\<acute>N\\<rbrace>\n                  \\<acute>M :== \\<acute>M + 1\n                  \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace>\n                    \\<acute>M :== \\<acute>M + 1\n                    \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>", "finally"], ["proof (chain)\npicking this:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace>\n                  \\<acute>M :== \\<acute>M + 1\n                  \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace>\n                  \\<acute>M :== \\<acute>M + 1\n                  \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace>\n                    \\<acute>M :== \\<acute>M + 1\n                    \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>", "."], ["proof (state)\nthis:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace>\n                  \\<acute>M :== \\<acute>M + 1\n                  \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace> \\<acute>M :== \\<acute>M + 1 \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = \\<acute>N\\<rbrace>\n                    \\<acute>M :== \\<acute>M + 1\n                    \\<lbrace>\\<acute>M \\<noteq> \\<acute>N\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M N. M = N \\<Longrightarrow> M + 1 \\<noteq> N", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Multiplication by Addition\\<close>"], ["", "text \\<open>\n We now do some basic examples of actual \\texttt{WHILE} programs.\n This one is a loop for calculating the product of two natural\n numbers, by iterated addition.  We first give detailed structured\n proof based on single-step Hoare rules.\n\\<close>"], ["", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n      WHILE \\<acute>M \\<noteq> a\n      DO \\<acute>S :== \\<acute>S + b;; \\<acute>M :== \\<acute>M + 1 OD\n      \\<lbrace>\\<acute>S = a * b\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n                    WHILE \\<acute>M \\<noteq> a \n                    DO \\<acute>S :== \\<acute>S + b;;\n                       \\<acute>M :== \\<acute>M + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = a * b\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n                    WHILE \\<acute>M \\<noteq> a \n                    DO \\<acute>S :== \\<acute>S + b;;\n                       \\<acute>M :== \\<acute>M + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = a * b\\<rbrace>", "let \"\\<Gamma>\\<turnstile> _ ?while _\" = ?thesis"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n                    WHILE \\<acute>M \\<noteq> a \n                    DO \\<acute>S :== \\<acute>S + b;;\n                       \\<acute>M :== \\<acute>M + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = a * b\\<rbrace>", "let \"\\<lbrace>\\<acute>?inv\\<rbrace>\" = \"\\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n                    WHILE \\<acute>M \\<noteq> a \n                    DO \\<acute>S :== \\<acute>S + b;;\n                       \\<acute>M :== \\<acute>M + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = a * b\\<rbrace>", "have \"\\<lbrace>\\<acute>M = 0 & \\<acute>S = 0\\<rbrace> \\<subseteq> \\<lbrace>\\<acute>?inv\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n    \\<subseteq> \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>", "by auto"], ["proof (state)\nthis:\n  \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n  \\<subseteq> \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n                    WHILE \\<acute>M \\<noteq> a \n                    DO \\<acute>S :== \\<acute>S + b;;\n                       \\<acute>M :== \\<acute>M + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = a * b\\<rbrace>", "also"], ["proof (state)\nthis:\n  \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n  \\<subseteq> \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n                    WHILE \\<acute>M \\<noteq> a \n                    DO \\<acute>S :== \\<acute>S + b;;\n                       \\<acute>M :== \\<acute>M + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = a * b\\<rbrace>", "have \"\\<Gamma>\\<turnstile> \\<dots> ?while \\<lbrace>\\<acute>?inv \\<and> \\<not> (\\<acute>M \\<noteq> a)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>\n                    WHILE \\<acute>M \\<noteq> a \n                    DO \\<acute>S :== \\<acute>S + b;;\n                       \\<acute>M :== \\<acute>M + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = \\<acute>M * b \\<and>\n                             \\<not> \\<acute>M \\<noteq> a\\<rbrace>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>S = \\<acute>M * b \\<and>\n                             \\<acute>M \\<noteq> a\\<rbrace>\n                    \\<acute>S :== \\<acute>S + b;;\n                    \\<acute>M :== \\<acute>M + 1\n                    \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>", "let ?c = \"\\<acute>S :== \\<acute>S + b;; \\<acute>M :== \\<acute>M + 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>S = \\<acute>M * b \\<and>\n                             \\<acute>M \\<noteq> a\\<rbrace>\n                    \\<acute>S :== \\<acute>S + b;;\n                    \\<acute>M :== \\<acute>M + 1\n                    \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>", "have \"\\<lbrace>\\<acute>?inv \\<and> \\<acute>M \\<noteq> a\\<rbrace> \\<subseteq> \\<lbrace>\\<acute>S + b = (\\<acute>M + 1) * b\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<acute>S = \\<acute>M * b \\<and> \\<acute>M \\<noteq> a\\<rbrace>\n    \\<subseteq> \\<lbrace>\\<acute>S + b = (\\<acute>M + 1) * b\\<rbrace>", "by auto"], ["proof (state)\nthis:\n  \\<lbrace>\\<acute>S = \\<acute>M * b \\<and> \\<acute>M \\<noteq> a\\<rbrace>\n  \\<subseteq> \\<lbrace>\\<acute>S + b = (\\<acute>M + 1) * b\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>S = \\<acute>M * b \\<and>\n                             \\<acute>M \\<noteq> a\\<rbrace>\n                    \\<acute>S :== \\<acute>S + b;;\n                    \\<acute>M :== \\<acute>M + 1\n                    \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>", "also"], ["proof (state)\nthis:\n  \\<lbrace>\\<acute>S = \\<acute>M * b \\<and> \\<acute>M \\<noteq> a\\<rbrace>\n  \\<subseteq> \\<lbrace>\\<acute>S + b = (\\<acute>M + 1) * b\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>S = \\<acute>M * b \\<and>\n                             \\<acute>M \\<noteq> a\\<rbrace>\n                    \\<acute>S :== \\<acute>S + b;;\n                    \\<acute>M :== \\<acute>M + 1\n                    \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>", "have \"\\<Gamma>\\<turnstile> \\<dots> ?c \\<lbrace>\\<acute>?inv\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>S + b = (\\<acute>M + 1) * b\\<rbrace>\n                    \\<acute>S :== \\<acute>S + b;;\n                    \\<acute>M :== \\<acute>M + 1\n                    \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>", "by vcg"], ["proof (state)\nthis:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>\\<acute>S + b = (\\<acute>M + 1) * b\\<rbrace>\n                  \\<acute>S :== \\<acute>S + b;; \\<acute>M :== \\<acute>M + 1\n                  \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>S = \\<acute>M * b \\<and>\n                             \\<acute>M \\<noteq> a\\<rbrace>\n                    \\<acute>S :== \\<acute>S + b;;\n                    \\<acute>M :== \\<acute>M + 1\n                    \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>", "finally"], ["proof (chain)\npicking this:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>\\<acute>S = \\<acute>M * b \\<and>\n                           \\<acute>M \\<noteq> a\\<rbrace>\n                  \\<acute>S :== \\<acute>S + b;; \\<acute>M :== \\<acute>M + 1\n                  \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>", "show \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>?inv \\<and> \\<acute>M \\<noteq> a\\<rbrace> ?c \\<lbrace>\\<acute>?inv\\<rbrace>\""], ["proof (prove)\nusing this:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>\\<acute>S = \\<acute>M * b \\<and>\n                           \\<acute>M \\<noteq> a\\<rbrace>\n                  \\<acute>S :== \\<acute>S + b;; \\<acute>M :== \\<acute>M + 1\n                  \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>S = \\<acute>M * b \\<and>\n                             \\<acute>M \\<noteq> a\\<rbrace>\n                    \\<acute>S :== \\<acute>S + b;;\n                    \\<acute>M :== \\<acute>M + 1\n                    \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>", "."], ["proof (state)\nthis:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>\\<acute>S = \\<acute>M * b \\<and>\n                           \\<acute>M \\<noteq> a\\<rbrace>\n                  \\<acute>S :== \\<acute>S + b;; \\<acute>M :== \\<acute>M + 1\n                  \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>\n                  WHILE \\<acute>M \\<noteq> a \n                  DO \\<acute>S :== \\<acute>S + b;;\n                     \\<acute>M :== \\<acute>M + 1 \n                  OD\n                  \\<lbrace>\\<acute>S = \\<acute>M * b \\<and>\n                           \\<not> \\<acute>M \\<noteq> a\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n                    WHILE \\<acute>M \\<noteq> a \n                    DO \\<acute>S :== \\<acute>S + b;;\n                       \\<acute>M :== \\<acute>M + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = a * b\\<rbrace>", "also"], ["proof (state)\nthis:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>\n                  WHILE \\<acute>M \\<noteq> a \n                  DO \\<acute>S :== \\<acute>S + b;;\n                     \\<acute>M :== \\<acute>M + 1 \n                  OD\n                  \\<lbrace>\\<acute>S = \\<acute>M * b \\<and>\n                           \\<not> \\<acute>M \\<noteq> a\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n                    WHILE \\<acute>M \\<noteq> a \n                    DO \\<acute>S :== \\<acute>S + b;;\n                       \\<acute>M :== \\<acute>M + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = a * b\\<rbrace>", "have \"\\<lbrace>\\<acute>?inv \\<and> \\<not> (\\<acute>M \\<noteq> a)\\<rbrace> \\<subseteq> \\<lbrace>\\<acute>S = a * b\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<acute>S = \\<acute>M * b \\<and>\n             \\<not> \\<acute>M \\<noteq> a\\<rbrace>\n    \\<subseteq> \\<lbrace>\\<acute>S = a * b\\<rbrace>", "by auto"], ["proof (state)\nthis:\n  \\<lbrace>\\<acute>S = \\<acute>M * b \\<and>\n           \\<not> \\<acute>M \\<noteq> a\\<rbrace>\n  \\<subseteq> \\<lbrace>\\<acute>S = a * b\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n                    WHILE \\<acute>M \\<noteq> a \n                    DO \\<acute>S :== \\<acute>S + b;;\n                       \\<acute>M :== \\<acute>M + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = a * b\\<rbrace>", "finally"], ["proof (chain)\npicking this:\n  {} \\<subseteq> ?A \\<Longrightarrow>\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n                  WHILE \\<acute>M \\<noteq> a \n                  DO \\<acute>S :== \\<acute>S + b;;\n                     \\<acute>M :== \\<acute>M + 1 \n                  OD\n                  \\<lbrace>\\<acute>S = a * b\\<rbrace>,?A", "show ?thesis"], ["proof (prove)\nusing this:\n  {} \\<subseteq> ?A \\<Longrightarrow>\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n                  WHILE \\<acute>M \\<noteq> a \n                  DO \\<acute>S :== \\<acute>S + b;;\n                     \\<acute>M :== \\<acute>M + 1 \n                  OD\n                  \\<lbrace>\\<acute>S = a * b\\<rbrace>,?A\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n                    WHILE \\<acute>M \\<noteq> a \n                    DO \\<acute>S :== \\<acute>S + b;;\n                       \\<acute>M :== \\<acute>M + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = a * b\\<rbrace>", "by blast"], ["proof (state)\nthis:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n                  WHILE \\<acute>M \\<noteq> a \n                  DO \\<acute>S :== \\<acute>S + b;;\n                     \\<acute>M :== \\<acute>M + 1 \n                  OD\n                  \\<lbrace>\\<acute>S = a * b\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n The subsequent version of the proof applies the \\<open>vcg\\<close> method\n to reduce the Hoare statement to a purely logical problem that can be\n solved fully automatically.  Note that we have to specify the\n \\texttt{WHILE} loop invariant in the original statement.\n\\<close>"], ["", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n          WHILE \\<acute>M \\<noteq> a\n          INV \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>\n          DO \\<acute>S :== \\<acute>S + b;; \\<acute>M :== \\<acute>M + 1 OD\n          \\<lbrace>\\<acute>S = a * b\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n                    WHILE \\<acute>M \\<noteq> a\n                    INV \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace> \n                    DO \\<acute>S :== \\<acute>S + b;;\n                       \\<acute>M :== \\<acute>M + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = a * b\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>M S. \\<lbrakk>M = 0; S = 0\\<rbrakk> \\<Longrightarrow> S = M * b\n 2. \\<And>M S.\n       \\<lbrakk>S = M * b; M \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> S + b = (M + 1) * b\n 3. \\<And>M S.\n       \\<lbrakk>S = M * b; \\<not> M \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> S = a * b", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Here some examples of ``breaking'' out of a loop\\<close>"], ["", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n          TRY\n            WHILE True\n            INV \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>\n            DO IF \\<acute>M = a THEN THROW ELSE \\<acute>S :== \\<acute>S + b;; \\<acute>M :== \\<acute>M + 1 FI OD\n          CATCH\n            SKIP\n          END\n          \\<lbrace>\\<acute>S = a * b\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n                    TRY WHILE True\n                        INV \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace> \n                        DO IF \\<acute>M = a THEN THROW\n                           ELSE \\<acute>S :== \\<acute>S + b;;\n                             \\<acute>M :== \\<acute>M + 1\n                           FI \n                        OD\n                    CATCH SKIP END\n                    \\<lbrace>\\<acute>S = a * b\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>M S. \\<lbrakk>M = 0; S = 0\\<rbrakk> \\<Longrightarrow> S = M * b\n 2. \\<And>M S.\n       \\<lbrakk>S = M * b; True\\<rbrakk>\n       \\<Longrightarrow> (M = a \\<longrightarrow> S = a * b) \\<and>\n                         (M \\<noteq> a \\<longrightarrow>\n                          S + b = (M + 1) * b)\n 3. \\<And>M S.\n       \\<lbrakk>S = M * b; \\<not> True\\<rbrakk> \\<Longrightarrow> S = a * b", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n          TRY\n            WHILE True\n            INV \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>\n            DO IF \\<acute>M = a THEN \\<acute>Abr :== ''Break'';;THROW\n               ELSE \\<acute>S :== \\<acute>S + b;; \\<acute>M :== \\<acute>M + 1\n               FI\n            OD\n          CATCH\n            IF \\<acute>Abr = ''Break'' THEN SKIP ELSE Throw FI\n          END\n          \\<lbrace>\\<acute>S = a * b\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n                    TRY WHILE True\n                        INV \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace> \n                        DO IF \\<acute>M = a\n                           THEN \\<acute>Abr :== ''Break'';; THROW\n                           ELSE \\<acute>S :== \\<acute>S + b;;\n                             \\<acute>M :== \\<acute>M + 1\n                           FI \n                        OD\n                    CATCH IF \\<acute>Abr = ''Break'' THEN SKIP ELSE THROW FI\n                    END\n                    \\<lbrace>\\<acute>S = a * b\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>M S. \\<lbrakk>M = 0; S = 0\\<rbrakk> \\<Longrightarrow> S = M * b\n 2. \\<And>M S.\n       \\<lbrakk>S = M * b; True\\<rbrakk>\n       \\<Longrightarrow> (M = a \\<longrightarrow>\n                          (''Break'' = ''Break'' \\<longrightarrow>\n                           S = a * b) \\<and>\n                          (''Break'' \\<noteq> ''Break'' \\<longrightarrow>\n                           False)) \\<and>\n                         (M \\<noteq> a \\<longrightarrow>\n                          S + b = (M + 1) * b)\n 3. \\<And>M S.\n       \\<lbrakk>S = M * b; \\<not> True\\<rbrakk> \\<Longrightarrow> S = a * b", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Some more syntactic sugar, the label statement \\<open>\\<dots> \\<bullet> \\<dots>\\<close> as shorthand\nfor the \\<open>TRY-CATCH\\<close> above, and the \\<open>RAISE\\<close> for an state-update followed\nby a \\<open>THROW\\<close>.\n\\<close>"], ["", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n          \\<lbrace>\\<acute>Abr = ''Break''\\<rbrace>\\<bullet> WHILE True INV \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>\n           DO IF \\<acute>M = a THEN RAISE \\<acute>Abr :== ''Break''\n              ELSE \\<acute>S :== \\<acute>S + b;; \\<acute>M :== \\<acute>M + 1\n              FI\n           OD\n          \\<lbrace>\\<acute>S = a * b\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n                    \\<lbrace>\\<acute>Abr = ''Break''\\<rbrace>\\<bullet>\n                    WHILE True\n                    INV \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace> \n                    DO IF \\<acute>M = a THEN RAISE \\<acute>Abr :== ''Break''\n                       ELSE \\<acute>S :== \\<acute>S + b;;\n                         \\<acute>M :== \\<acute>M + 1\n                       FI \n                    OD\n                    \\<lbrace>\\<acute>S = a * b\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>M S. \\<lbrakk>M = 0; S = 0\\<rbrakk> \\<Longrightarrow> S = M * b\n 2. \\<And>M S.\n       \\<lbrakk>S = M * b; True\\<rbrakk>\n       \\<Longrightarrow> (M = a \\<longrightarrow> S = a * b) \\<and>\n                         (M \\<noteq> a \\<longrightarrow>\n                          S + b = (M + 1) * b)\n 3. \\<And>M S.\n       \\<lbrakk>S = M * b; \\<not> True\\<rbrakk> \\<Longrightarrow> S = a * b", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n          TRY\n            WHILE True\n            INV \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>\n            DO IF \\<acute>M = a THEN RAISE \\<acute>Abr :== ''Break''\n               ELSE \\<acute>S :== \\<acute>S + b;; \\<acute>M :== \\<acute>M + 1\n               FI\n            OD\n          CATCH\n            IF \\<acute>Abr = ''Break'' THEN SKIP ELSE Throw FI\n          END\n          \\<lbrace>\\<acute>S = a * b\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n                    TRY WHILE True\n                        INV \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace> \n                        DO IF \\<acute>M = a\n                           THEN RAISE \\<acute>Abr :== ''Break''\n                           ELSE \\<acute>S :== \\<acute>S + b;;\n                             \\<acute>M :== \\<acute>M + 1\n                           FI \n                        OD\n                    CATCH IF \\<acute>Abr = ''Break'' THEN SKIP ELSE THROW FI\n                    END\n                    \\<lbrace>\\<acute>S = a * b\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>M S. \\<lbrakk>M = 0; S = 0\\<rbrakk> \\<Longrightarrow> S = M * b\n 2. \\<And>M S.\n       \\<lbrakk>S = M * b; True\\<rbrakk>\n       \\<Longrightarrow> (M = a \\<longrightarrow> S = a * b) \\<and>\n                         (M \\<noteq> a \\<longrightarrow>\n                          S + b = (M + 1) * b)\n 3. \\<And>M S.\n       \\<lbrakk>S = M * b; \\<not> True\\<rbrakk> \\<Longrightarrow> S = a * b", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n          \\<lbrace>\\<acute>Abr = ''Break''\\<rbrace> \\<bullet> WHILE True\n          INV \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace>\n          DO IF \\<acute>M = a THEN RAISE \\<acute>Abr :== ''Break''\n               ELSE \\<acute>S :== \\<acute>S + b;; \\<acute>M :== \\<acute>M + 1\n               FI\n          OD\n          \\<lbrace>\\<acute>S = a * b\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n                    \\<lbrace>\\<acute>Abr = ''Break''\\<rbrace>\\<bullet>\n                    WHILE True\n                    INV \\<lbrace>\\<acute>S = \\<acute>M * b\\<rbrace> \n                    DO IF \\<acute>M = a THEN RAISE \\<acute>Abr :== ''Break''\n                       ELSE \\<acute>S :== \\<acute>S + b;;\n                         \\<acute>M :== \\<acute>M + 1\n                       FI \n                    OD\n                    \\<lbrace>\\<acute>S = a * b\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>M S. \\<lbrakk>M = 0; S = 0\\<rbrakk> \\<Longrightarrow> S = M * b\n 2. \\<And>M S.\n       \\<lbrakk>S = M * b; True\\<rbrakk>\n       \\<Longrightarrow> (M = a \\<longrightarrow> S = a * b) \\<and>\n                         (M \\<noteq> a \\<longrightarrow>\n                          S + b = (M + 1) * b)\n 3. \\<And>M S.\n       \\<lbrakk>S = M * b; \\<not> True\\<rbrakk> \\<Longrightarrow> S = a * b", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Blocks\\<close>"], ["", "lemma  (in state_space)\n  shows \"\\<Gamma>\\<turnstile>\\<lbrace>\\<acute>I = i\\<rbrace> LOC \\<acute>I;; \\<acute>I :== 2  COL \\<lbrace>\\<acute>I \\<le> i\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>I = i\\<rbrace>\n                     LOC \\<acute>I;; \\<acute>I :== 2 COL\n                    \\<lbrace>\\<acute>I \\<le> i\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I. I \\<le> I", "by simp"], ["", "subsection \\<open>Summing Natural Numbers\\<close>"], ["", "text \\<open>\n We verify an imperative program to sum natural numbers up to a given\n limit.  First some functional definition for proper specification of\n the problem.\n\\<close>"], ["", "primrec\n  sum :: \"(nat => nat) => nat => nat\"\nwhere\n  \"sum f 0 = 0\"\n| \"sum f (Suc n) = f n + sum f n\""], ["", "syntax\n  \"_sum\" :: \"idt => nat => nat => nat\"\n    (\"SUMM _<_. _\" [0, 0, 10] 10)"], ["", "translations\n  \"SUMM j<k. b\" == \"CONST sum (\\<lambda>j. b) k\""], ["", "text \\<open>\n The following proof is quite explicit in the individual steps taken,\n with the \\<open>vcg\\<close> method only applied locally to take care of\n assignment and sequential composition.  Note that we express\n intermediate proof obligation in pure logic, without referring to the\n state space.\n\\<close>"], ["", "theorem (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>True\\<rbrace>\n           \\<acute>S :== 0;; \\<acute>I :== 1;;\n           WHILE \\<acute>I \\<noteq> n\n           DO\n             \\<acute>S :== \\<acute>S + \\<acute>I;;\n             \\<acute>I :== \\<acute>I + 1\n           OD\n           \\<lbrace>\\<acute>S = (SUMM j<n. j)\\<rbrace>\"\n  (is \"\\<Gamma>\\<turnstile> _ (_;; ?while) _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    \\<acute>S :== 0;; \\<acute>I :== 1;;\n                    WHILE \\<acute>I \\<noteq> n \n                    DO \\<acute>S :== \\<acute>S + \\<acute>I;;\n                       \\<acute>I :== \\<acute>I + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = (SUMM j<n. j)\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    \\<acute>S :== 0;; \\<acute>I :== 1;;\n                    WHILE \\<acute>I \\<noteq> n \n                    DO \\<acute>S :== \\<acute>S + \\<acute>I;;\n                       \\<acute>I :== \\<acute>I + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = (SUMM j<n. j)\\<rbrace>", "let ?sum = \"\\<lambda>k. SUMM j<k. j\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    \\<acute>S :== 0;; \\<acute>I :== 1;;\n                    WHILE \\<acute>I \\<noteq> n \n                    DO \\<acute>S :== \\<acute>S + \\<acute>I;;\n                       \\<acute>I :== \\<acute>I + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = (SUMM j<n. j)\\<rbrace>", "let ?inv = \"\\<lambda>s i. s = ?sum i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    \\<acute>S :== 0;; \\<acute>I :== 1;;\n                    WHILE \\<acute>I \\<noteq> n \n                    DO \\<acute>S :== \\<acute>S + \\<acute>I;;\n                       \\<acute>I :== \\<acute>I + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = (SUMM j<n. j)\\<rbrace>", "have \"\\<Gamma>\\<turnstile> \\<lbrace>True\\<rbrace> \\<acute>S :== 0;; \\<acute>I :== 1 \\<lbrace>?inv \\<acute>S \\<acute>I\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace> \\<acute>S :== 0;; \\<acute>I :== 1\n                    \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace> \\<acute>S :== 0;; \\<acute>I :== 1\n                    \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>", "have \"True \\<longrightarrow> 0 = ?sum 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. True \\<longrightarrow> 0 = (SUMM j<1. j)", "by simp"], ["proof (state)\nthis:\n  True \\<longrightarrow> 0 = (SUMM j<1. j)\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace> \\<acute>S :== 0;; \\<acute>I :== 1\n                    \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>", "also"], ["proof (state)\nthis:\n  True \\<longrightarrow> 0 = (SUMM j<1. j)\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace> \\<acute>S :== 0;; \\<acute>I :== 1\n                    \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>", "have \"\\<Gamma>\\<turnstile> \\<lbrace>\\<dots>\\<rbrace> \\<acute>S :== 0;; \\<acute>I :== 1 \\<lbrace>?inv \\<acute>S \\<acute>I\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>0 = (SUMM j<1. j)\\<rbrace>\n                    \\<acute>S :== 0;; \\<acute>I :== 1\n                    \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>", "by vcg"], ["proof (state)\nthis:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>0 = (SUMM j<1. j)\\<rbrace>\n                  \\<acute>S :== 0;; \\<acute>I :== 1\n                  \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace> \\<acute>S :== 0;; \\<acute>I :== 1\n                    \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>", "finally"], ["proof (chain)\npicking this:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>True\\<rbrace> \\<acute>S :== 0;; \\<acute>I :== 1\n                  \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>True\\<rbrace> \\<acute>S :== 0;; \\<acute>I :== 1\n                  \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace> \\<acute>S :== 0;; \\<acute>I :== 1\n                    \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>", "."], ["proof (state)\nthis:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>True\\<rbrace> \\<acute>S :== 0;; \\<acute>I :== 1\n                  \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>True\\<rbrace> \\<acute>S :== 0;; \\<acute>I :== 1\n                  \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    \\<acute>S :== 0;; \\<acute>I :== 1;;\n                    WHILE \\<acute>I \\<noteq> n \n                    DO \\<acute>S :== \\<acute>S + \\<acute>I;;\n                       \\<acute>I :== \\<acute>I + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = (SUMM j<n. j)\\<rbrace>", "also"], ["proof (state)\nthis:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>True\\<rbrace> \\<acute>S :== 0;; \\<acute>I :== 1\n                  \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    \\<acute>S :== 0;; \\<acute>I :== 1;;\n                    WHILE \\<acute>I \\<noteq> n \n                    DO \\<acute>S :== \\<acute>S + \\<acute>I;;\n                       \\<acute>I :== \\<acute>I + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = (SUMM j<n. j)\\<rbrace>", "have \"\\<Gamma>\\<turnstile> \\<lbrace>?inv \\<acute>S \\<acute>I\\<rbrace> ?while \\<lbrace>?inv \\<acute>S \\<acute>I \\<and> \\<not> \\<acute>I \\<noteq> n\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>\n                    WHILE \\<acute>I \\<noteq> n \n                    DO \\<acute>S :== \\<acute>S + \\<acute>I;;\n                       \\<acute>I :== \\<acute>I + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j) \\<and>\n                             \\<not> \\<acute>I \\<noteq> n\\<rbrace>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j) \\<and>\n                             \\<acute>I \\<noteq> n\\<rbrace>\n                    \\<acute>S :== \\<acute>S + \\<acute>I;;\n                    \\<acute>I :== \\<acute>I + 1\n                    \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>", "let ?body = \"\\<acute>S :== \\<acute>S + \\<acute>I;; \\<acute>I :== \\<acute>I + 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j) \\<and>\n                             \\<acute>I \\<noteq> n\\<rbrace>\n                    \\<acute>S :== \\<acute>S + \\<acute>I;;\n                    \\<acute>I :== \\<acute>I + 1\n                    \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>", "have \"\\<And>s i. ?inv s i \\<and> i \\<noteq> n \\<longrightarrow>  ?inv (s + i) (i + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s i.\n       s = (SUMM j<i. j) \\<and> i \\<noteq> n \\<longrightarrow>\n       s + i = (SUMM j<i + 1. j)", "by simp"], ["proof (state)\nthis:\n  ?s1 = (SUMM j<?i1. j) \\<and> ?i1 \\<noteq> n \\<longrightarrow>\n  ?s1 + ?i1 = (SUMM j<?i1 + 1. j)\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j) \\<and>\n                             \\<acute>I \\<noteq> n\\<rbrace>\n                    \\<acute>S :== \\<acute>S + \\<acute>I;;\n                    \\<acute>I :== \\<acute>I + 1\n                    \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>", "also"], ["proof (state)\nthis:\n  ?s1 = (SUMM j<?i1. j) \\<and> ?i1 \\<noteq> n \\<longrightarrow>\n  ?s1 + ?i1 = (SUMM j<?i1 + 1. j)\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j) \\<and>\n                             \\<acute>I \\<noteq> n\\<rbrace>\n                    \\<acute>S :== \\<acute>S + \\<acute>I;;\n                    \\<acute>I :== \\<acute>I + 1\n                    \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>", "have \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>S + \\<acute>I = ?sum (\\<acute>I + 1)\\<rbrace> ?body \\<lbrace>?inv \\<acute>S \\<acute>I\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>S + \\<acute>I =\n                             (SUMM j<\\<acute>I + 1. j)\\<rbrace>\n                    \\<acute>S :== \\<acute>S + \\<acute>I;;\n                    \\<acute>I :== \\<acute>I + 1\n                    \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>", "by vcg"], ["proof (state)\nthis:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>\\<acute>S + \\<acute>I =\n                           (SUMM j<\\<acute>I + 1. j)\\<rbrace>\n                  \\<acute>S :== \\<acute>S + \\<acute>I;;\n                  \\<acute>I :== \\<acute>I + 1\n                  \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j) \\<and>\n                             \\<acute>I \\<noteq> n\\<rbrace>\n                    \\<acute>S :== \\<acute>S + \\<acute>I;;\n                    \\<acute>I :== \\<acute>I + 1\n                    \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>", "finally"], ["proof (chain)\npicking this:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j) \\<and>\n                           \\<acute>I \\<noteq> n\\<rbrace>\n                  \\<acute>S :== \\<acute>S + \\<acute>I;;\n                  \\<acute>I :== \\<acute>I + 1\n                  \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>", "show \"\\<Gamma>\\<turnstile> \\<lbrace>?inv \\<acute>S \\<acute>I \\<and> \\<acute>I \\<noteq> n\\<rbrace> ?body \\<lbrace>?inv \\<acute>S \\<acute>I\\<rbrace>\""], ["proof (prove)\nusing this:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j) \\<and>\n                           \\<acute>I \\<noteq> n\\<rbrace>\n                  \\<acute>S :== \\<acute>S + \\<acute>I;;\n                  \\<acute>I :== \\<acute>I + 1\n                  \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j) \\<and>\n                             \\<acute>I \\<noteq> n\\<rbrace>\n                    \\<acute>S :== \\<acute>S + \\<acute>I;;\n                    \\<acute>I :== \\<acute>I + 1\n                    \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>", "."], ["proof (state)\nthis:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j) \\<and>\n                           \\<acute>I \\<noteq> n\\<rbrace>\n                  \\<acute>S :== \\<acute>S + \\<acute>I;;\n                  \\<acute>I :== \\<acute>I + 1\n                  \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>\n                  WHILE \\<acute>I \\<noteq> n \n                  DO \\<acute>S :== \\<acute>S + \\<acute>I;;\n                     \\<acute>I :== \\<acute>I + 1 \n                  OD\n                  \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j) \\<and>\n                           \\<not> \\<acute>I \\<noteq> n\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    \\<acute>S :== 0;; \\<acute>I :== 1;;\n                    WHILE \\<acute>I \\<noteq> n \n                    DO \\<acute>S :== \\<acute>S + \\<acute>I;;\n                       \\<acute>I :== \\<acute>I + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = (SUMM j<n. j)\\<rbrace>", "also"], ["proof (state)\nthis:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>\n                  WHILE \\<acute>I \\<noteq> n \n                  DO \\<acute>S :== \\<acute>S + \\<acute>I;;\n                     \\<acute>I :== \\<acute>I + 1 \n                  OD\n                  \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j) \\<and>\n                           \\<not> \\<acute>I \\<noteq> n\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    \\<acute>S :== 0;; \\<acute>I :== 1;;\n                    WHILE \\<acute>I \\<noteq> n \n                    DO \\<acute>S :== \\<acute>S + \\<acute>I;;\n                       \\<acute>I :== \\<acute>I + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = (SUMM j<n. j)\\<rbrace>", "have \"\\<And>s i. s = ?sum i \\<and> \\<not> i \\<noteq> n \\<longrightarrow> s = ?sum n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s i.\n       s = (SUMM j<i. j) \\<and> \\<not> i \\<noteq> n \\<longrightarrow>\n       s = (SUMM j<n. j)", "by simp"], ["proof (state)\nthis:\n  ?s = (SUMM j<?i. j) \\<and> \\<not> ?i \\<noteq> n \\<longrightarrow>\n  ?s = (SUMM j<n. j)\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    \\<acute>S :== 0;; \\<acute>I :== 1;;\n                    WHILE \\<acute>I \\<noteq> n \n                    DO \\<acute>S :== \\<acute>S + \\<acute>I;;\n                       \\<acute>I :== \\<acute>I + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = (SUMM j<n. j)\\<rbrace>", "finally"], ["proof (chain)\npicking this:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>True\\<rbrace>\n                  \\<acute>S :== 0;; \\<acute>I :== 1;;\n                  WHILE \\<acute>I \\<noteq> n \n                  DO \\<acute>S :== \\<acute>S + \\<acute>I;;\n                     \\<acute>I :== \\<acute>I + 1 \n                  OD\n                  \\<lbrace>\\<acute>S = (SUMM j<n. j)\\<rbrace>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>True\\<rbrace>\n                  \\<acute>S :== 0;; \\<acute>I :== 1;;\n                  WHILE \\<acute>I \\<noteq> n \n                  DO \\<acute>S :== \\<acute>S + \\<acute>I;;\n                     \\<acute>I :== \\<acute>I + 1 \n                  OD\n                  \\<lbrace>\\<acute>S = (SUMM j<n. j)\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    \\<acute>S :== 0;; \\<acute>I :== 1;;\n                    WHILE \\<acute>I \\<noteq> n \n                    DO \\<acute>S :== \\<acute>S + \\<acute>I;;\n                       \\<acute>I :== \\<acute>I + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = (SUMM j<n. j)\\<rbrace>", "."], ["proof (state)\nthis:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>True\\<rbrace>\n                  \\<acute>S :== 0;; \\<acute>I :== 1;;\n                  WHILE \\<acute>I \\<noteq> n \n                  DO \\<acute>S :== \\<acute>S + \\<acute>I;;\n                     \\<acute>I :== \\<acute>I + 1 \n                  OD\n                  \\<lbrace>\\<acute>S = (SUMM j<n. j)\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n The next version uses the \\<open>vcg\\<close> method, while still explaining\n the resulting proof obligations in an abstract, structured manner.\n\\<close>"], ["", "theorem (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>True\\<rbrace>\n           \\<acute>S :== 0;; \\<acute>I :== 1;;\n           WHILE \\<acute>I \\<noteq> n\n           INV \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>\n           DO\n             \\<acute>S :== \\<acute>S + \\<acute>I;;\n             \\<acute>I :== \\<acute>I + 1\n           OD\n          \\<lbrace>\\<acute>S = (SUMM j<n. j)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    \\<acute>S :== 0;; \\<acute>I :== 1;;\n                    WHILE \\<acute>I \\<noteq> n\n                    INV \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace> \n                    DO \\<acute>S :== \\<acute>S + \\<acute>I;;\n                       \\<acute>I :== \\<acute>I + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = (SUMM j<n. j)\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    \\<acute>S :== 0;; \\<acute>I :== 1;;\n                    WHILE \\<acute>I \\<noteq> n\n                    INV \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace> \n                    DO \\<acute>S :== \\<acute>S + \\<acute>I;;\n                       \\<acute>I :== \\<acute>I + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = (SUMM j<n. j)\\<rbrace>", "let ?sum = \"\\<lambda>k. SUMM j<k. j\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    \\<acute>S :== 0;; \\<acute>I :== 1;;\n                    WHILE \\<acute>I \\<noteq> n\n                    INV \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace> \n                    DO \\<acute>S :== \\<acute>S + \\<acute>I;;\n                       \\<acute>I :== \\<acute>I + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = (SUMM j<n. j)\\<rbrace>", "let ?inv = \"\\<lambda>s i. s = ?sum i\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    \\<acute>S :== 0;; \\<acute>I :== 1;;\n                    WHILE \\<acute>I \\<noteq> n\n                    INV \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace> \n                    DO \\<acute>S :== \\<acute>S + \\<acute>I;;\n                       \\<acute>I :== \\<acute>I + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = (SUMM j<n. j)\\<rbrace>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    \\<acute>S :== 0;; \\<acute>I :== 1;;\n                    WHILE \\<acute>I \\<noteq> n\n                    INV \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace> \n                    DO \\<acute>S :== \\<acute>S + \\<acute>I;;\n                       \\<acute>I :== \\<acute>I + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = (SUMM j<n. j)\\<rbrace>", "proof vcg"], ["proof (state)\ngoal (3 subgoals):\n 1. True \\<Longrightarrow> 0 = (SUMM j<1. j)\n 2. \\<And>I S.\n       \\<lbrakk>S = (SUMM j<I. j); I \\<noteq> n\\<rbrakk>\n       \\<Longrightarrow> S + I = (SUMM j<I + 1. j)\n 3. \\<And>I S.\n       \\<lbrakk>S = (SUMM j<I. j); \\<not> I \\<noteq> n\\<rbrakk>\n       \\<Longrightarrow> S = (SUMM j<n. j)", "show \"?inv 0 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = (SUMM j<1. j)", "by simp"], ["proof (state)\nthis:\n  0 = (SUMM j<1. j)\n\ngoal (2 subgoals):\n 1. \\<And>I S.\n       \\<lbrakk>S = (SUMM j<I. j); I \\<noteq> n\\<rbrakk>\n       \\<Longrightarrow> S + I = (SUMM j<I + 1. j)\n 2. \\<And>I S.\n       \\<lbrakk>S = (SUMM j<I. j); \\<not> I \\<noteq> n\\<rbrakk>\n       \\<Longrightarrow> S = (SUMM j<n. j)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I S.\n       \\<lbrakk>S = (SUMM j<I. j); I \\<noteq> n\\<rbrakk>\n       \\<Longrightarrow> S + I = (SUMM j<I + 1. j)\n 2. \\<And>I S.\n       \\<lbrakk>S = (SUMM j<I. j); \\<not> I \\<noteq> n\\<rbrakk>\n       \\<Longrightarrow> S = (SUMM j<n. j)", "fix i s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I S.\n       \\<lbrakk>S = (SUMM j<I. j); I \\<noteq> n\\<rbrakk>\n       \\<Longrightarrow> S + I = (SUMM j<I + 1. j)\n 2. \\<And>I S.\n       \\<lbrakk>S = (SUMM j<I. j); \\<not> I \\<noteq> n\\<rbrakk>\n       \\<Longrightarrow> S = (SUMM j<n. j)", "assume \"?inv s i\" \"i \\<noteq> n\""], ["proof (state)\nthis:\n  s = (SUMM j<i. j)\n  i \\<noteq> n\n\ngoal (2 subgoals):\n 1. \\<And>I S.\n       \\<lbrakk>S = (SUMM j<I. j); I \\<noteq> n\\<rbrakk>\n       \\<Longrightarrow> S + I = (SUMM j<I + 1. j)\n 2. \\<And>I S.\n       \\<lbrakk>S = (SUMM j<I. j); \\<not> I \\<noteq> n\\<rbrakk>\n       \\<Longrightarrow> S = (SUMM j<n. j)", "thus \"?inv (s + i) (i + 1)\""], ["proof (prove)\nusing this:\n  s = (SUMM j<i. j)\n  i \\<noteq> n\n\ngoal (1 subgoal):\n 1. s + i = (SUMM j<i + 1. j)", "by simp"], ["proof (state)\nthis:\n  s + i = (SUMM j<i + 1. j)\n\ngoal (1 subgoal):\n 1. \\<And>I S.\n       \\<lbrakk>S = (SUMM j<I. j); \\<not> I \\<noteq> n\\<rbrakk>\n       \\<Longrightarrow> S = (SUMM j<n. j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I S.\n       \\<lbrakk>S = (SUMM j<I. j); \\<not> I \\<noteq> n\\<rbrakk>\n       \\<Longrightarrow> S = (SUMM j<n. j)", "fix i s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I S.\n       \\<lbrakk>S = (SUMM j<I. j); \\<not> I \\<noteq> n\\<rbrakk>\n       \\<Longrightarrow> S = (SUMM j<n. j)", "assume x: \"?inv s i\" \"\\<not> i \\<noteq> n\""], ["proof (state)\nthis:\n  s = (SUMM j<i. j)\n  \\<not> i \\<noteq> n\n\ngoal (1 subgoal):\n 1. \\<And>I S.\n       \\<lbrakk>S = (SUMM j<I. j); \\<not> I \\<noteq> n\\<rbrakk>\n       \\<Longrightarrow> S = (SUMM j<n. j)", "thus \"s = ?sum n\""], ["proof (prove)\nusing this:\n  s = (SUMM j<i. j)\n  \\<not> i \\<noteq> n\n\ngoal (1 subgoal):\n 1. s = (SUMM j<n. j)", "by simp"], ["proof (state)\nthis:\n  s = (SUMM j<n. j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>True\\<rbrace>\n                  \\<acute>S :== 0;; \\<acute>I :== 1;;\n                  WHILE \\<acute>I \\<noteq> n\n                  INV \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace> \n                  DO \\<acute>S :== \\<acute>S + \\<acute>I;;\n                     \\<acute>I :== \\<acute>I + 1 \n                  OD\n                  \\<lbrace>\\<acute>S = (SUMM j<n. j)\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n Certainly, this proof may be done fully automatically as well, provided\n that the invariant is given beforehand.\n\\<close>"], ["", "theorem (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>True\\<rbrace>\n           \\<acute>S :== 0;; \\<acute>I :== 1;;\n           WHILE \\<acute>I \\<noteq> n\n           INV \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace>\n           DO\n             \\<acute>S :== \\<acute>S + \\<acute>I;;\n             \\<acute>I :== \\<acute>I + 1\n           OD\n           \\<lbrace>\\<acute>S = (SUMM j<n. j)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    \\<acute>S :== 0;; \\<acute>I :== 1;;\n                    WHILE \\<acute>I \\<noteq> n\n                    INV \\<lbrace>\\<acute>S = (SUMM j<\\<acute>I. j)\\<rbrace> \n                    DO \\<acute>S :== \\<acute>S + \\<acute>I;;\n                       \\<acute>I :== \\<acute>I + 1 \n                    OD\n                    \\<lbrace>\\<acute>S = (SUMM j<n. j)\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. True \\<Longrightarrow> 0 = (SUMM j<1. j)\n 2. \\<And>I S.\n       \\<lbrakk>S = (SUMM j<I. j); I \\<noteq> n\\<rbrakk>\n       \\<Longrightarrow> S + I = (SUMM j<I + 1. j)\n 3. \\<And>I S.\n       \\<lbrakk>S = (SUMM j<I. j); \\<not> I \\<noteq> n\\<rbrakk>\n       \\<Longrightarrow> S = (SUMM j<n. j)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>SWITCH\\<close>"], ["", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>N = 5\\<rbrace> SWITCH \\<acute>B\n                        {True} \\<Rightarrow> \\<acute>N :== 6\n                      | {False} \\<Rightarrow> \\<acute>N :== 7\n                     END\n          \\<lbrace>\\<acute>N > 5\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>N = 5\\<rbrace>\n                     SWITCH \\<acute>B {True}\\<Rightarrow> \\<acute>N :== 6\n                    | {False}\\<Rightarrow> \\<acute>N :== 7 END\n                    \\<lbrace>5 < \\<acute>N\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>B N.\n       N = 5 \\<Longrightarrow>\n       (True = B \\<longrightarrow> 5 < 6) \\<and>\n       (True \\<noteq> B \\<longrightarrow>\n        (False = B \\<longrightarrow> 5 < 7) \\<and>\n        (False \\<noteq> B \\<longrightarrow> 5 < N))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in state_space)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>N = 5\\<rbrace> SWITCH \\<acute>N\n                        {v. v < 5} \\<Rightarrow> \\<acute>N :== 6\n                      | {v. v \\<ge> 5} \\<Rightarrow> \\<acute>N :== 7\n                     END\n          \\<lbrace>\\<acute>N > 5\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>N = 5\\<rbrace>\n                     SWITCH \\<acute>N {v. v < 5}\\<Rightarrow>\n                    \\<acute>N :== 6 | {v. 5 \\<le> v}\\<Rightarrow>\n                    \\<acute>N :== 7 END\n                    \\<lbrace>5 < \\<acute>N\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>N.\n       N = 5 \\<Longrightarrow>\n       (N < 5 \\<longrightarrow> 5 < 6) \\<and>\n       (\\<not> N < 5 \\<longrightarrow>\n        (5 \\<le> N \\<longrightarrow> 5 < 7) \\<and>\n        (\\<not> 5 \\<le> N \\<longrightarrow> 5 < N))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>(Mutually) Recursive Procedures\\<close>"], ["", "subsubsection \\<open>Factorial\\<close>"], ["", "text \\<open>We want to define a procedure for the factorial. We first\ndefine a HOL functions that calculates it to specify the procedure later on.\n\\<close>"], ["", "primrec fac:: \"nat \\<Rightarrow> nat\"\nwhere\n\"fac 0 = 1\" |\n\"fac (Suc n) = (Suc n) * fac n\""], ["", "lemma fac_simp [simp]: \"0 < i \\<Longrightarrow>  fac i = i * fac (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < i \\<Longrightarrow> fac i = i * fac (i - 1)", "by (cases i) simp_all"], ["", "text \\<open>Now we define the procedure\\<close>"], ["", "procedures\n  Fac (N::nat|R::nat)\n  \"IF \\<acute>N = 0 THEN \\<acute>R :== 1\n   ELSE \\<acute>R :== CALL Fac(\\<acute>N - 1);;\n        \\<acute>R :== \\<acute>N * \\<acute>R\n   FI\""], ["", "print_locale Fac_impl"], ["", "text \\<open>\nTo see how a call is syntactically translated you can switch off the\nprinting translation via the configuration option \\<open>hoare_use_call_tr'\\<close>\n\\<close>"], ["", "context Fac_impl\nbegin"], ["", "text \\<open>\n@{term \"CALL Fac(\\<acute>N,\\<acute>R)\"} is internally:\n\\<close>"], ["", "declare [[hoare_use_call_tr' = false]]"], ["", "text \\<open>\n@{term \"CALL Fac(\\<acute>N,\\<acute>R)\"}\n\\<close>"], ["", "term \"CALL Fac(\\<acute>N,\\<acute>R)\""], ["", "declare [[hoare_use_call_tr' = true]]"], ["", "text \\<open>\nNow let us prove that @{term \"Fac\"} meets its specification.\n\\<close>"], ["", "end"], ["", "lemma (in Fac_impl) Fac_spec':\n  shows \"\\<forall>\\<sigma>. \\<Gamma>,\\<Theta>\\<turnstile>{\\<sigma>} PROC Fac(\\<acute>N,\\<acute>R) \\<lbrace>\\<acute>R = fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,\\<Theta>\n          \\<turnstile> {\\<sigma>} \\<acute>R :== PROC Fac(\\<acute>N)\n                       \\<lbrace>\\<acute>R =\n                                fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>", "apply (hoare_rule HoarePartial.ProcRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,\\<Theta> \\<union>\n                (\\<Union>\\<sigma>.\n                    {({\\<sigma>}, Fac_'proc,\n                      \\<lbrace>\\<acute>R =\n                               fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                      {})})\n          \\<turnstile> {\\<sigma>}\n                       IF \\<acute>N = 0 THEN \\<acute>R :== 1\n                       ELSE \\<acute>R :== CALL Fac(\\<acute>N - 1);;\n                         \\<acute>R :== \\<acute>N * \\<acute>R\n                       FI\n                       \\<lbrace>\\<acute>R =\n                                fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>N.\n       (N = 0 \\<longrightarrow> 1 = fac N) \\<and>\n       (N \\<noteq> 0 \\<longrightarrow>\n        (\\<forall>R.\n            R = fac (N - 1) \\<longrightarrow> N * fac (N - 1) = fac N))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\nSince the factorial was implemented recursively,\nthe main ingredient of this proof is, to assume that the specification holds for\nthe recursive call of @{term Fac} and prove the body correct.\nThe assumption for recursive calls is added to the context by\nthe rule @{thm [source] HoarePartial.ProcRec1}\n(also derived from general rule for mutually recursive procedures):\n@{thm [display] HoarePartial.ProcRec1 [no_vars]}\nThe verification condition generator will infer the specification out of the\ncontext when it encounters a recursive call of the factorial.\n\\<close>"], ["", "text \\<open>We can also step through verification condition generation. When\nthe verification condition generator encounters a procedure call it tries to\n  use the rule \\<open>ProcSpec\\<close>. To be successful there must be a specification\nof the procedure in the context.\n\\<close>"], ["", "lemma (in Fac_impl) Fac_spec1:\n  shows \"\\<forall>\\<sigma>. \\<Gamma>,\\<Theta>\\<turnstile>{\\<sigma>} \\<acute>R :== PROC Fac(\\<acute>N) \\<lbrace>\\<acute>R = fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,\\<Theta>\n          \\<turnstile> {\\<sigma>} \\<acute>R :== PROC Fac(\\<acute>N)\n                       \\<lbrace>\\<acute>R =\n                                fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>", "apply (hoare_rule HoarePartial.ProcRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,\\<Theta> \\<union>\n                (\\<Union>\\<sigma>.\n                    {({\\<sigma>}, Fac_'proc,\n                      \\<lbrace>\\<acute>R =\n                               fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                      {})})\n          \\<turnstile> {\\<sigma>}\n                       IF \\<acute>N = 0 THEN \\<acute>R :== 1\n                       ELSE \\<acute>R :== CALL Fac(\\<acute>N - 1);;\n                         \\<acute>R :== \\<acute>N * \\<acute>R\n                       FI\n                       \\<lbrace>\\<acute>R =\n                                fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<Gamma>,\\<Theta> \\<union>\n                (\\<Union>\\<sigma>.\n                    {({\\<sigma>}, Fac_'proc,\n                      \\<lbrace>\\<acute>R =\n                               fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                      {})})\n          \\<turnstile> (?P1.4 \\<sigma>) \\<acute>R :== 1\n                       \\<lbrace>\\<acute>R =\n                                fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>\n 2. \\<And>\\<sigma>.\n       \\<Gamma>,\\<Theta> \\<union>\n                (\\<Union>\\<sigma>.\n                    {({\\<sigma>}, Fac_'proc,\n                      \\<lbrace>\\<acute>R =\n                               fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                      {})})\n          \\<turnstile> (?P2.4 \\<sigma>)\n                       \\<acute>R :== CALL Fac(\\<acute>N - 1);;\n                       \\<acute>R :== \\<acute>N * \\<acute>R\n                       \\<lbrace>\\<acute>R =\n                                fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>\n 3. \\<And>\\<sigma>.\n       {\\<sigma>}\n       \\<subseteq> {s. (s \\<in> \\<lbrace>\\<acute>N =\n   0\\<rbrace> \\<longrightarrow>\n                        s \\<in> ?P1.4 \\<sigma>) \\<and>\n                       (s \\<notin> \\<lbrace>\\<acute>N =\n      0\\<rbrace> \\<longrightarrow>\n                        s \\<in> ?P2.4 \\<sigma>)}", "apply   vcg_step"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<Gamma>,\\<Theta> \\<union>\n                (\\<Union>\\<sigma>.\n                    {({\\<sigma>}, Fac_'proc,\n                      \\<lbrace>\\<acute>R =\n                               fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                      {})})\n          \\<turnstile> (?P2.4 \\<sigma>)\n                       \\<acute>R :== CALL Fac(\\<acute>N - 1);;\n                       \\<acute>R :== \\<acute>N * \\<acute>R\n                       \\<lbrace>\\<acute>R =\n                                fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>\n 2. \\<And>\\<sigma>.\n       {\\<sigma>}\n       \\<subseteq> {s. (s \\<in> \\<lbrace>\\<acute>N =\n   0\\<rbrace> \\<longrightarrow>\n                        s \\<in> \\<lbrace>1 =\n   fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>) \\<and>\n                       (s \\<notin> \\<lbrace>\\<acute>N =\n      0\\<rbrace> \\<longrightarrow>\n                        s \\<in> ?P2.4 \\<sigma>)}", "apply  vcg_step"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<Gamma>,\\<Theta> \\<union>\n                (\\<Union>\\<sigma>.\n                    {({\\<sigma>}, Fac_'proc,\n                      \\<lbrace>\\<acute>R =\n                               fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                      {})})\n          \\<turnstile> (?P2.4 \\<sigma>)\n                       \\<acute>R :== CALL Fac(\\<acute>N - 1)\n                       \\<lbrace>\\<acute>N * \\<acute>R =\n                                fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>\n 2. \\<And>\\<sigma>.\n       {\\<sigma>}\n       \\<subseteq> {s. (s \\<in> \\<lbrace>\\<acute>N =\n   0\\<rbrace> \\<longrightarrow>\n                        s \\<in> \\<lbrace>1 =\n   fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>) \\<and>\n                       (s \\<notin> \\<lbrace>\\<acute>N =\n      0\\<rbrace> \\<longrightarrow>\n                        s \\<in> ?P2.4 \\<sigma>)}", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       {\\<sigma>}\n       \\<subseteq> {s. (s \\<in> \\<lbrace>\\<acute>N =\n   0\\<rbrace> \\<longrightarrow>\n                        s \\<in> \\<lbrace>1 =\n   fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>) \\<and>\n                       (s \\<notin> \\<lbrace>\\<acute>N =\n      0\\<rbrace> \\<longrightarrow>\n                        s \\<in> \\<lbrace>\\<forall>t.\n      \\<^bsup>t\\<^esup>R = fac (\\<acute>N - 1) \\<longrightarrow>\n      \\<acute>N * fac (\\<acute>N - 1) =\n      fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>)}", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>N.\n       (N = 0 \\<longrightarrow> 1 = fac N) \\<and>\n       (N \\<noteq> 0 \\<longrightarrow>\n        (\\<forall>R.\n            R = fac (N - 1) \\<longrightarrow> N * fac (N - 1) = fac N))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Here some Isar style version of the proof\\<close>"], ["", "lemma (in Fac_impl) Fac_spec2:\n\n  shows \"\\<forall>\\<sigma>. \\<Gamma>,\\<Theta>\\<turnstile>{\\<sigma>} \\<acute>R :== PROC Fac(\\<acute>N) \\<lbrace>\\<acute>R = fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,\\<Theta>\n          \\<turnstile> {\\<sigma>} \\<acute>R :== PROC Fac(\\<acute>N)\n                       \\<lbrace>\\<acute>R =\n                                fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>", "proof (hoare_rule HoarePartial.ProcRec1)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,\\<Theta> \\<union>\n                (\\<Union>\\<sigma>.\n                    {({\\<sigma>}, Fac_'proc,\n                      \\<lbrace>\\<acute>R =\n                               fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                      {})})\n          \\<turnstile> {\\<sigma>}\n                       IF \\<acute>N = 0 THEN \\<acute>R :== 1\n                       ELSE \\<acute>R :== CALL Fac(\\<acute>N - 1);;\n                         \\<acute>R :== \\<acute>N * \\<acute>R\n                       FI\n                       \\<lbrace>\\<acute>R =\n                                fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>", "have Fac_spec: \"\\<forall>\\<sigma>. \\<Gamma>,(\\<Theta>\\<union>(\\<Union>\\<sigma>. {({\\<sigma>}, Fac_'proc, \\<lbrace>\\<acute>R = fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,{})}))\n                       \\<turnstile> {\\<sigma>} \\<acute>R :== PROC Fac(\\<acute>N) \\<lbrace>\\<acute>R = fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,\\<Theta> \\<union>\n                (\\<Union>\\<sigma>.\n                    {({\\<sigma>}, Fac_'proc,\n                      \\<lbrace>\\<acute>R =\n                               fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                      {})})\n          \\<turnstile> {\\<sigma>} \\<acute>R :== PROC Fac(\\<acute>N)\n                       \\<lbrace>\\<acute>R =\n                                fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<Gamma>,\\<Theta> \\<union>\n                (\\<Union>\\<sigma>.\n                    {({\\<sigma>}, Fac_'proc,\n                      \\<lbrace>\\<acute>R =\n                               fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                      {})})\n          \\<turnstile> {\\<sigma>} \\<acute>R :== PROC Fac(\\<acute>N)\n                       \\<lbrace>\\<acute>R =\n                                fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>", "apply (rule hoarep.Asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       ({\\<sigma>}, Fac_'proc,\n        \\<lbrace>\\<acute>R = fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>, {})\n       \\<in> \\<Theta> \\<union>\n             (\\<Union>\\<sigma>.\n                 {({\\<sigma>}, Fac_'proc,\n                   \\<lbrace>\\<acute>R =\n                            fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                   {})})", "by simp"], ["proof (state)\nthis:\n  \\<forall>\\<sigma>.\n     \\<Gamma>,\\<Theta> \\<union>\n              (\\<Union>\\<sigma>.\n                  {({\\<sigma>}, Fac_'proc,\n                    \\<lbrace>\\<acute>R =\n                             fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                    {})})\n        \\<turnstile> {\\<sigma>} \\<acute>R :== PROC Fac(\\<acute>N)\n                     \\<lbrace>\\<acute>R =\n                              fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,\\<Theta> \\<union>\n                (\\<Union>\\<sigma>.\n                    {({\\<sigma>}, Fac_'proc,\n                      \\<lbrace>\\<acute>R =\n                               fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                      {})})\n          \\<turnstile> {\\<sigma>}\n                       IF \\<acute>N = 0 THEN \\<acute>R :== 1\n                       ELSE \\<acute>R :== CALL Fac(\\<acute>N - 1);;\n                         \\<acute>R :== \\<acute>N * \\<acute>R\n                       FI\n                       \\<lbrace>\\<acute>R =\n                                fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>", "show \"\\<forall>\\<sigma>. \\<Gamma>,(\\<Theta>\\<union>(\\<Union>\\<sigma>. {({\\<sigma>}, Fac_'proc, \\<lbrace>\\<acute>R = fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,{})}))\n            \\<turnstile> {\\<sigma>} IF \\<acute>N = 0 THEN \\<acute>R :== 1\n            ELSE \\<acute>R :== CALL Fac(\\<acute>N - 1);; \\<acute>R :== \\<acute>N * \\<acute>R FI \\<lbrace>\\<acute>R = fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,\\<Theta> \\<union>\n                (\\<Union>\\<sigma>.\n                    {({\\<sigma>}, Fac_'proc,\n                      \\<lbrace>\\<acute>R =\n                               fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                      {})})\n          \\<turnstile> {\\<sigma>}\n                       IF \\<acute>N = 0 THEN \\<acute>R :== 1\n                       ELSE \\<acute>R :== CALL Fac(\\<acute>N - 1);;\n                         \\<acute>R :== \\<acute>N * \\<acute>R\n                       FI\n                       \\<lbrace>\\<acute>R =\n                                fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>N.\n       (N = 0 \\<longrightarrow> 1 = fac N) \\<and>\n       (N \\<noteq> 0 \\<longrightarrow>\n        (\\<forall>R.\n            R = fac (N - 1) \\<longrightarrow> N * fac (N - 1) = fac N))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>\\<sigma>.\n     \\<Gamma>,\\<Theta> \\<union>\n              (\\<Union>\\<sigma>.\n                  {({\\<sigma>}, Fac_'proc,\n                    \\<lbrace>\\<acute>R =\n                             fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                    {})})\n        \\<turnstile> {\\<sigma>}\n                     IF \\<acute>N = 0 THEN \\<acute>R :== 1\n                     ELSE \\<acute>R :== CALL Fac(\\<acute>N - 1);;\n                       \\<acute>R :== \\<acute>N * \\<acute>R\n                     FI\n                     \\<lbrace>\\<acute>R =\n                              fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>To avoid retyping of potentially large pre and postconditions in\nthe previous proof we can use the casual term abbreviations of the Isar\nlanguage.\n\\<close>"], ["", "lemma (in Fac_impl) Fac_spec3:\n  shows \"\\<forall>\\<sigma>. \\<Gamma>,\\<Theta>\\<turnstile>{\\<sigma>} \\<acute>R :== PROC Fac(\\<acute>N) \\<lbrace>\\<acute>R = fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>\"\n  (is \"\\<forall>\\<sigma>. \\<Gamma>,\\<Theta>\\<turnstile>(?Pre \\<sigma>) ?Fac (?Post \\<sigma>)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,\\<Theta>\n          \\<turnstile> {\\<sigma>} \\<acute>R :== PROC Fac(\\<acute>N)\n                       \\<lbrace>\\<acute>R =\n                                fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>", "proof (hoare_rule HoarePartial.ProcRec1)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,\\<Theta> \\<union>\n                (\\<Union>\\<sigma>.\n                    {({\\<sigma>}, Fac_'proc,\n                      \\<lbrace>\\<acute>R =\n                               fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                      {})})\n          \\<turnstile> {\\<sigma>}\n                       IF \\<acute>N = 0 THEN \\<acute>R :== 1\n                       ELSE \\<acute>R :== CALL Fac(\\<acute>N - 1);;\n                         \\<acute>R :== \\<acute>N * \\<acute>R\n                       FI\n                       \\<lbrace>\\<acute>R =\n                                fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>", "have Fac_spec: \"\\<forall>\\<sigma>. \\<Gamma>,(\\<Theta>\\<union>(\\<Union>\\<sigma>. {(?Pre \\<sigma>, Fac_'proc, ?Post \\<sigma>,{})}))\n                       \\<turnstile>(?Pre \\<sigma>) ?Fac (?Post \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,\\<Theta> \\<union>\n                (\\<Union>\\<sigma>.\n                    {({\\<sigma>}, Fac_'proc,\n                      \\<lbrace>\\<acute>R =\n                               fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                      {})})\n          \\<turnstile> {\\<sigma>} \\<acute>R :== PROC Fac(\\<acute>N)\n                       \\<lbrace>\\<acute>R =\n                                fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<Gamma>,\\<Theta> \\<union>\n                (\\<Union>\\<sigma>.\n                    {({\\<sigma>}, Fac_'proc,\n                      \\<lbrace>\\<acute>R =\n                               fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                      {})})\n          \\<turnstile> {\\<sigma>} \\<acute>R :== PROC Fac(\\<acute>N)\n                       \\<lbrace>\\<acute>R =\n                                fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>", "apply (rule hoarep.Asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       ({\\<sigma>}, Fac_'proc,\n        \\<lbrace>\\<acute>R = fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>, {})\n       \\<in> \\<Theta> \\<union>\n             (\\<Union>\\<sigma>.\n                 {({\\<sigma>}, Fac_'proc,\n                   \\<lbrace>\\<acute>R =\n                            fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                   {})})", "by simp"], ["proof (state)\nthis:\n  \\<forall>\\<sigma>.\n     \\<Gamma>,\\<Theta> \\<union>\n              (\\<Union>\\<sigma>.\n                  {({\\<sigma>}, Fac_'proc,\n                    \\<lbrace>\\<acute>R =\n                             fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                    {})})\n        \\<turnstile> {\\<sigma>} \\<acute>R :== PROC Fac(\\<acute>N)\n                     \\<lbrace>\\<acute>R =\n                              fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,\\<Theta> \\<union>\n                (\\<Union>\\<sigma>.\n                    {({\\<sigma>}, Fac_'proc,\n                      \\<lbrace>\\<acute>R =\n                               fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                      {})})\n          \\<turnstile> {\\<sigma>}\n                       IF \\<acute>N = 0 THEN \\<acute>R :== 1\n                       ELSE \\<acute>R :== CALL Fac(\\<acute>N - 1);;\n                         \\<acute>R :== \\<acute>N * \\<acute>R\n                       FI\n                       \\<lbrace>\\<acute>R =\n                                fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>", "show \"\\<forall>\\<sigma>. \\<Gamma>,(\\<Theta>\\<union>(\\<Union>\\<sigma>. {(?Pre \\<sigma>, Fac_'proc, ?Post \\<sigma>,{})}))\n            \\<turnstile> (?Pre \\<sigma>) IF \\<acute>N = 0 THEN \\<acute>R :== 1\n            ELSE \\<acute>R :== CALL Fac(\\<acute>N - 1);; \\<acute>R :== \\<acute>N * \\<acute>R FI (?Post \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,\\<Theta> \\<union>\n                (\\<Union>\\<sigma>.\n                    {({\\<sigma>}, Fac_'proc,\n                      \\<lbrace>\\<acute>R =\n                               fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                      {})})\n          \\<turnstile> {\\<sigma>}\n                       IF \\<acute>N = 0 THEN \\<acute>R :== 1\n                       ELSE \\<acute>R :== CALL Fac(\\<acute>N - 1);;\n                         \\<acute>R :== \\<acute>N * \\<acute>R\n                       FI\n                       \\<lbrace>\\<acute>R =\n                                fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>N.\n       (N = 0 \\<longrightarrow> 1 = fac N) \\<and>\n       (N \\<noteq> 0 \\<longrightarrow>\n        (\\<forall>R.\n            R = fac (N - 1) \\<longrightarrow> N * fac (N - 1) = fac N))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>\\<sigma>.\n     \\<Gamma>,\\<Theta> \\<union>\n              (\\<Union>\\<sigma>.\n                  {({\\<sigma>}, Fac_'proc,\n                    \\<lbrace>\\<acute>R =\n                             fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                    {})})\n        \\<turnstile> {\\<sigma>}\n                     IF \\<acute>N = 0 THEN \\<acute>R :== 1\n                     ELSE \\<acute>R :== CALL Fac(\\<acute>N - 1);;\n                       \\<acute>R :== \\<acute>N * \\<acute>R\n                     FI\n                     \\<lbrace>\\<acute>R =\n                              fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The previous proof pattern has still some kind of inconvenience.\nThe augmented context is always printed in the proof state. That can\nmess up the state, especially if we have large specifications. This may\nbe annoying if we want to develop single step or structured proofs. In this\ncase it can be a good idea to introduce a new variable for the augmented\ncontext.\n\\<close>"], ["", "lemma (in Fac_impl) Fac_spec4:\n  shows \"\\<forall>\\<sigma>. \\<Gamma>,\\<Theta>\\<turnstile>{\\<sigma>} \\<acute>R :== PROC Fac(\\<acute>N) \\<lbrace>\\<acute>R = fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>\"\n  (is \"\\<forall>\\<sigma>. \\<Gamma>,\\<Theta>\\<turnstile>(?Pre \\<sigma>) ?Fac (?Post \\<sigma>)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,\\<Theta>\n          \\<turnstile> {\\<sigma>} \\<acute>R :== PROC Fac(\\<acute>N)\n                       \\<lbrace>\\<acute>R =\n                                fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>", "proof (hoare_rule HoarePartial.ProcRec1)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,\\<Theta> \\<union>\n                (\\<Union>\\<sigma>.\n                    {({\\<sigma>}, Fac_'proc,\n                      \\<lbrace>\\<acute>R =\n                               fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                      {})})\n          \\<turnstile> {\\<sigma>}\n                       IF \\<acute>N = 0 THEN \\<acute>R :== 1\n                       ELSE \\<acute>R :== CALL Fac(\\<acute>N - 1);;\n                         \\<acute>R :== \\<acute>N * \\<acute>R\n                       FI\n                       \\<lbrace>\\<acute>R =\n                                fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>", "define \\<Theta>' where \"\\<Theta>' = \\<Theta> \\<union> (\\<Union>\\<sigma>. {(?Pre \\<sigma>, Fac_'proc, ?Post \\<sigma>,{})})\""], ["proof (state)\nthis:\n  \\<Theta>' =\n  \\<Theta> \\<union>\n  (\\<Union>\\<sigma>.\n      {({\\<sigma>}, Fac_'proc,\n        \\<lbrace>\\<acute>R = fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>, {})})\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,\\<Theta> \\<union>\n                (\\<Union>\\<sigma>.\n                    {({\\<sigma>}, Fac_'proc,\n                      \\<lbrace>\\<acute>R =\n                               fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                      {})})\n          \\<turnstile> {\\<sigma>}\n                       IF \\<acute>N = 0 THEN \\<acute>R :== 1\n                       ELSE \\<acute>R :== CALL Fac(\\<acute>N - 1);;\n                         \\<acute>R :== \\<acute>N * \\<acute>R\n                       FI\n                       \\<lbrace>\\<acute>R =\n                                fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>", "have Fac_spec: \"\\<forall>\\<sigma>. \\<Gamma>,\\<Theta>'\\<turnstile>(?Pre \\<sigma>) ?Fac (?Post \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,\\<Theta>'\n          \\<turnstile> {\\<sigma>} \\<acute>R :== PROC Fac(\\<acute>N)\n                       \\<lbrace>\\<acute>R =\n                                fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>", "by (unfold \\<Theta>'_def, rule allI, rule hoarep.Asm) simp"], ["proof (state)\nthis:\n  \\<forall>\\<sigma>.\n     \\<Gamma>,\\<Theta>'\n        \\<turnstile> {\\<sigma>} \\<acute>R :== PROC Fac(\\<acute>N)\n                     \\<lbrace>\\<acute>R =\n                              fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,\\<Theta> \\<union>\n                (\\<Union>\\<sigma>.\n                    {({\\<sigma>}, Fac_'proc,\n                      \\<lbrace>\\<acute>R =\n                               fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                      {})})\n          \\<turnstile> {\\<sigma>}\n                       IF \\<acute>N = 0 THEN \\<acute>R :== 1\n                       ELSE \\<acute>R :== CALL Fac(\\<acute>N - 1);;\n                         \\<acute>R :== \\<acute>N * \\<acute>R\n                       FI\n                       \\<lbrace>\\<acute>R =\n                                fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>", "txt \\<open>We have to name the fact \\<open>Fac_spec\\<close>, so that the vcg can\n   use the specification for the recursive call, since it cannot infer it\n   from the opaque @{term \"\\<Theta>'\"}.\\<close>"], ["proof (state)\nthis:\n  \\<forall>\\<sigma>.\n     \\<Gamma>,\\<Theta>'\n        \\<turnstile> {\\<sigma>} \\<acute>R :== PROC Fac(\\<acute>N)\n                     \\<lbrace>\\<acute>R =\n                              fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,\\<Theta> \\<union>\n                (\\<Union>\\<sigma>.\n                    {({\\<sigma>}, Fac_'proc,\n                      \\<lbrace>\\<acute>R =\n                               fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                      {})})\n          \\<turnstile> {\\<sigma>}\n                       IF \\<acute>N = 0 THEN \\<acute>R :== 1\n                       ELSE \\<acute>R :== CALL Fac(\\<acute>N - 1);;\n                         \\<acute>R :== \\<acute>N * \\<acute>R\n                       FI\n                       \\<lbrace>\\<acute>R =\n                                fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>", "show \"\\<forall>\\<sigma>. \\<Gamma>,\\<Theta>'\\<turnstile> (?Pre \\<sigma>) IF \\<acute>N = 0 THEN \\<acute>R :== 1\n            ELSE \\<acute>R :== CALL Fac(\\<acute>N - 1);; \\<acute>R :== \\<acute>N * \\<acute>R FI (?Post \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,\\<Theta>'\n          \\<turnstile> {\\<sigma>}\n                       IF \\<acute>N = 0 THEN \\<acute>R :== 1\n                       ELSE \\<acute>R :== CALL Fac(\\<acute>N - 1);;\n                         \\<acute>R :== \\<acute>N * \\<acute>R\n                       FI\n                       \\<lbrace>\\<acute>R =\n                                fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>N.\n       (N = 0 \\<longrightarrow> 1 = fac N) \\<and>\n       (N \\<noteq> 0 \\<longrightarrow>\n        (\\<forall>R.\n            R = fac (N - 1) \\<longrightarrow> N * fac (N - 1) = fac N))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>\\<sigma>.\n     \\<Gamma>,\\<Theta>'\n        \\<turnstile> {\\<sigma>}\n                     IF \\<acute>N = 0 THEN \\<acute>R :== 1\n                     ELSE \\<acute>R :== CALL Fac(\\<acute>N - 1);;\n                       \\<acute>R :== \\<acute>N * \\<acute>R\n                     FI\n                     \\<lbrace>\\<acute>R =\n                              fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>There are different rules available to prove procedure calls,\ndepending on the kind of postcondition and whether or not the\nprocedure is recursive or even mutually recursive.\nSee for example @{thm [source] HoareTotal.ProcRec1},\n@{thm [source] HoareTotal.ProcNoRec1}.\nThey are all derived from the most general rule\n@{thm [source] HoareTotal.ProcRec}.\nAll of them have some side-conditions concerning the parameter\npassing protocol and its relation to the pre and postcondition. They can be\nsolved in a uniform fashion. Thats why we have created the method\n\\<open>hoare_rule\\<close>, which behaves like the method \\<open>rule\\<close> but automatically\ntries to solve the side-conditions.\n\\<close>"], ["", "subsubsection \\<open>Odd and Even\\<close>"], ["", "text \\<open>Odd and even are defined mutually recursive here. In the\n\\<open>procedures\\<close> command we conjoin both definitions with \\<open>and\\<close>.\n\\<close>"], ["", "procedures\n odd(N::nat | A::nat) \"IF \\<acute>N=0 THEN \\<acute>A:==0\n                     ELSE IF \\<acute>N=1 THEN CALL even (\\<acute>N - 1,\\<acute>A)\n                          ELSE CALL odd (\\<acute>N - 2,\\<acute>A)\n                          FI\n                     FI\"\n\nand\n  even(N::nat | A::nat) \"IF \\<acute>N=0 THEN \\<acute>A:==1\n                        ELSE IF \\<acute>N=1 THEN CALL odd (\\<acute>N - 1,\\<acute>A)\n                             ELSE CALL even (\\<acute>N - 2,\\<acute>A)\n                             FI\n                        FI\""], ["", "print_theorems"], ["", "print_locale! odd_even_clique"], ["", "text \\<open>To prove the procedure calls to @{term \"odd\"} respectively\n@{term \"even\"} correct we first derive a rule to justify that we\ncan assume both specifications to verify the bodies. This rule can\nbe derived from the general @{thm [source] HoareTotal.ProcRec} rule. An ML function will\ndo this work:\n\\<close>"], ["", "ML \\<open>ML_Thms.bind_thm (\"ProcRec2\", Hoare.gen_proc_rec @{context} Hoare.Partial 2)\\<close>"], ["", "lemma (in odd_even_clique)\n  shows odd_spec: \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>{\\<sigma>} \\<acute>A :== PROC odd(\\<acute>N)\n                  \\<lbrace>(\\<exists>b. \\<^bsup>\\<sigma>\\<^esup>N = 2 * b + \\<acute>A) \\<and> \\<acute>A < 2 \\<rbrace>\" (is ?P1)\n   and even_spec: \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>{\\<sigma>} \\<acute>A :== PROC even(\\<acute>N)\n                  \\<lbrace>(\\<exists>b. \\<^bsup>\\<sigma>\\<^esup>N + 1 = 2 * b + \\<acute>A) \\<and> \\<acute>A < 2 \\<rbrace>\" (is ?P2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile> {\\<sigma>} \\<acute>A :== PROC odd(\\<acute>N)\n                       \\<lbrace>(\\<exists>b.\n                                    \\<^bsup>\\<sigma>\\<^esup>N =\n                                    2 * b + \\<acute>A) \\<and>\n                                \\<acute>A < 2\\<rbrace> &&&\n    \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile> {\\<sigma>} \\<acute>A :== PROC even(\\<acute>N)\n                       \\<lbrace>(\\<exists>b.\n                                    \\<^bsup>\\<sigma>\\<^esup>N + 1 =\n                                    2 * b + \\<acute>A) \\<and>\n                                \\<acute>A < 2\\<rbrace>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile> {\\<sigma>} \\<acute>A :== PROC odd(\\<acute>N)\n                       \\<lbrace>(\\<exists>b.\n                                    \\<^bsup>\\<sigma>\\<^esup>N =\n                                    2 * b + \\<acute>A) \\<and>\n                                \\<acute>A < 2\\<rbrace>\n 2. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile> {\\<sigma>} \\<acute>A :== PROC even(\\<acute>N)\n                       \\<lbrace>(\\<exists>b.\n                                    \\<^bsup>\\<sigma>\\<^esup>N + 1 =\n                                    2 * b + \\<acute>A) \\<and>\n                                \\<acute>A < 2\\<rbrace>", "have \"?P1 \\<and> ?P2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<sigma>.\n        \\<Gamma>\n           \\<turnstile> {\\<sigma>} \\<acute>A :== PROC odd(\\<acute>N)\n                        \\<lbrace>(\\<exists>b.\n                                     \\<^bsup>\\<sigma>\\<^esup>N =\n                                     2 * b + \\<acute>A) \\<and>\n                                 \\<acute>A < 2\\<rbrace>) \\<and>\n    (\\<forall>\\<sigma>.\n        \\<Gamma>\n           \\<turnstile> {\\<sigma>} \\<acute>A :== PROC even(\\<acute>N)\n                        \\<lbrace>(\\<exists>b.\n                                     \\<^bsup>\\<sigma>\\<^esup>N + 1 =\n                                     2 * b + \\<acute>A) \\<and>\n                                 \\<acute>A < 2\\<rbrace>)", "apply (hoare_rule ProcRec2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,(\\<Union>\\<sigma>.\n                    {({\\<sigma>}, odd_'proc,\n                      \\<lbrace>(\\<exists>b.\n                                   \\<^bsup>\\<sigma>\\<^esup>N =\n                                   2 * b + \\<acute>A) \\<and>\n                               \\<acute>A < 2\\<rbrace>,\n                      {})}) \\<union>\n                (\\<Union>\\<sigma>.\n                    {({\\<sigma>}, even_'proc,\n                      \\<lbrace>(\\<exists>b.\n                                   \\<^bsup>\\<sigma>\\<^esup>N + 1 =\n                                   2 * b + \\<acute>A) \\<and>\n                               \\<acute>A < 2\\<rbrace>,\n                      {})})\n          \\<turnstile> {\\<sigma>}\n                       IF \\<acute>N = 0 THEN \\<acute>A :== 0\n                       ELSE IF \\<acute>N = 1\n                            THEN \\<acute>A :== CALL even(\\<acute>N - 1)\n                            ELSE \\<acute>A :== CALL odd(\\<acute>N - 2) FI\n                       FI\n                       \\<lbrace>(\\<exists>b.\n                                    \\<^bsup>\\<sigma>\\<^esup>N =\n                                    2 * b + \\<acute>A) \\<and>\n                                \\<acute>A < 2\\<rbrace>\n 2. \\<forall>\\<sigma>.\n       \\<Gamma>,(\\<Union>\\<sigma>.\n                    {({\\<sigma>}, odd_'proc,\n                      \\<lbrace>(\\<exists>b.\n                                   \\<^bsup>\\<sigma>\\<^esup>N =\n                                   2 * b + \\<acute>A) \\<and>\n                               \\<acute>A < 2\\<rbrace>,\n                      {})}) \\<union>\n                (\\<Union>\\<sigma>.\n                    {({\\<sigma>}, even_'proc,\n                      \\<lbrace>(\\<exists>b.\n                                   \\<^bsup>\\<sigma>\\<^esup>N + 1 =\n                                   2 * b + \\<acute>A) \\<and>\n                               \\<acute>A < 2\\<rbrace>,\n                      {})})\n          \\<turnstile> {\\<sigma>}\n                       IF \\<acute>N = 0 THEN \\<acute>A :== 1\n                       ELSE IF \\<acute>N = 1\n                            THEN \\<acute>A :== CALL odd(\\<acute>N - 1)\n                            ELSE \\<acute>A :== CALL even(\\<acute>N - 2) FI\n                       FI\n                       \\<lbrace>(\\<exists>b.\n                                    \\<^bsup>\\<sigma>\\<^esup>N + 1 =\n                                    2 * b + \\<acute>A) \\<and>\n                                \\<acute>A < 2\\<rbrace>", "apply  vcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>N.\n       (N = 0 \\<longrightarrow>\n        (\\<exists>b. N = 2 * b + 0) \\<and> 0 < 2) \\<and>\n       (N \\<noteq> 0 \\<longrightarrow>\n        (N = 1 \\<longrightarrow>\n         (\\<forall>A.\n             (\\<exists>b. N - 1 + 1 = 2 * b + A) \\<and>\n             A < 2 \\<longrightarrow>\n             (\\<exists>b. N = 2 * b + A))) \\<and>\n        (N \\<noteq> 1 \\<longrightarrow>\n         (\\<forall>A.\n             (\\<exists>b. N - 2 = 2 * b + A) \\<and> A < 2 \\<longrightarrow>\n             (\\<exists>b. N = 2 * b + A))))\n 2. \\<forall>\\<sigma>.\n       \\<Gamma>,(\\<Union>\\<sigma>.\n                    {({\\<sigma>}, odd_'proc,\n                      \\<lbrace>(\\<exists>b.\n                                   \\<^bsup>\\<sigma>\\<^esup>N =\n                                   2 * b + \\<acute>A) \\<and>\n                               \\<acute>A < 2\\<rbrace>,\n                      {})}) \\<union>\n                (\\<Union>\\<sigma>.\n                    {({\\<sigma>}, even_'proc,\n                      \\<lbrace>(\\<exists>b.\n                                   \\<^bsup>\\<sigma>\\<^esup>N + 1 =\n                                   2 * b + \\<acute>A) \\<and>\n                               \\<acute>A < 2\\<rbrace>,\n                      {})})\n          \\<turnstile> {\\<sigma>}\n                       IF \\<acute>N = 0 THEN \\<acute>A :== 1\n                       ELSE IF \\<acute>N = 1\n                            THEN \\<acute>A :== CALL odd(\\<acute>N - 1)\n                            ELSE \\<acute>A :== CALL even(\\<acute>N - 2) FI\n                       FI\n                       \\<lbrace>(\\<exists>b.\n                                    \\<^bsup>\\<sigma>\\<^esup>N + 1 =\n                                    2 * b + \\<acute>A) \\<and>\n                                \\<acute>A < 2\\<rbrace>", "apply  clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>N A b.\n       \\<lbrakk>0 < N; N \\<noteq> Suc 0; A < 2; N - 2 = 2 * b + A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. N = 2 * b + A\n 2. \\<forall>\\<sigma>.\n       \\<Gamma>,(\\<Union>\\<sigma>.\n                    {({\\<sigma>}, odd_'proc,\n                      \\<lbrace>(\\<exists>b.\n                                   \\<^bsup>\\<sigma>\\<^esup>N =\n                                   2 * b + \\<acute>A) \\<and>\n                               \\<acute>A < 2\\<rbrace>,\n                      {})}) \\<union>\n                (\\<Union>\\<sigma>.\n                    {({\\<sigma>}, even_'proc,\n                      \\<lbrace>(\\<exists>b.\n                                   \\<^bsup>\\<sigma>\\<^esup>N + 1 =\n                                   2 * b + \\<acute>A) \\<and>\n                               \\<acute>A < 2\\<rbrace>,\n                      {})})\n          \\<turnstile> {\\<sigma>}\n                       IF \\<acute>N = 0 THEN \\<acute>A :== 1\n                       ELSE IF \\<acute>N = 1\n                            THEN \\<acute>A :== CALL odd(\\<acute>N - 1)\n                            ELSE \\<acute>A :== CALL even(\\<acute>N - 2) FI\n                       FI\n                       \\<lbrace>(\\<exists>b.\n                                    \\<^bsup>\\<sigma>\\<^esup>N + 1 =\n                                    2 * b + \\<acute>A) \\<and>\n                                \\<acute>A < 2\\<rbrace>", "apply  (rule_tac x=\"b + 1\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>N A b.\n       \\<lbrakk>0 < N; N \\<noteq> Suc 0; A < 2; N - 2 = 2 * b + A\\<rbrakk>\n       \\<Longrightarrow> N = 2 * (b + 1) + A\n 2. \\<forall>\\<sigma>.\n       \\<Gamma>,(\\<Union>\\<sigma>.\n                    {({\\<sigma>}, odd_'proc,\n                      \\<lbrace>(\\<exists>b.\n                                   \\<^bsup>\\<sigma>\\<^esup>N =\n                                   2 * b + \\<acute>A) \\<and>\n                               \\<acute>A < 2\\<rbrace>,\n                      {})}) \\<union>\n                (\\<Union>\\<sigma>.\n                    {({\\<sigma>}, even_'proc,\n                      \\<lbrace>(\\<exists>b.\n                                   \\<^bsup>\\<sigma>\\<^esup>N + 1 =\n                                   2 * b + \\<acute>A) \\<and>\n                               \\<acute>A < 2\\<rbrace>,\n                      {})})\n          \\<turnstile> {\\<sigma>}\n                       IF \\<acute>N = 0 THEN \\<acute>A :== 1\n                       ELSE IF \\<acute>N = 1\n                            THEN \\<acute>A :== CALL odd(\\<acute>N - 1)\n                            ELSE \\<acute>A :== CALL even(\\<acute>N - 2) FI\n                       FI\n                       \\<lbrace>(\\<exists>b.\n                                    \\<^bsup>\\<sigma>\\<^esup>N + 1 =\n                                    2 * b + \\<acute>A) \\<and>\n                                \\<acute>A < 2\\<rbrace>", "apply  arith"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,(\\<Union>\\<sigma>.\n                    {({\\<sigma>}, odd_'proc,\n                      \\<lbrace>(\\<exists>b.\n                                   \\<^bsup>\\<sigma>\\<^esup>N =\n                                   2 * b + \\<acute>A) \\<and>\n                               \\<acute>A < 2\\<rbrace>,\n                      {})}) \\<union>\n                (\\<Union>\\<sigma>.\n                    {({\\<sigma>}, even_'proc,\n                      \\<lbrace>(\\<exists>b.\n                                   \\<^bsup>\\<sigma>\\<^esup>N + 1 =\n                                   2 * b + \\<acute>A) \\<and>\n                               \\<acute>A < 2\\<rbrace>,\n                      {})})\n          \\<turnstile> {\\<sigma>}\n                       IF \\<acute>N = 0 THEN \\<acute>A :== 1\n                       ELSE IF \\<acute>N = 1\n                            THEN \\<acute>A :== CALL odd(\\<acute>N - 1)\n                            ELSE \\<acute>A :== CALL even(\\<acute>N - 2) FI\n                       FI\n                       \\<lbrace>(\\<exists>b.\n                                    \\<^bsup>\\<sigma>\\<^esup>N + 1 =\n                                    2 * b + \\<acute>A) \\<and>\n                                \\<acute>A < 2\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>N.\n       (N = 0 \\<longrightarrow>\n        (\\<exists>b. N + 1 = 2 * b + 1) \\<and> 1 < 2) \\<and>\n       (N \\<noteq> 0 \\<longrightarrow>\n        (N = 1 \\<longrightarrow>\n         (\\<forall>A.\n             (\\<exists>b. N - 1 = 2 * b + A) \\<and> A < 2 \\<longrightarrow>\n             (\\<exists>b. N + 1 = 2 * b + A))) \\<and>\n        (N \\<noteq> 1 \\<longrightarrow>\n         (\\<forall>A.\n             (\\<exists>b. N - 2 + 1 = 2 * b + A) \\<and>\n             A < 2 \\<longrightarrow>\n             (\\<exists>b. N + 1 = 2 * b + A))))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>N.\n       0 < N \\<Longrightarrow>\n       (N = Suc 0 \\<longrightarrow>\n        (\\<exists>b. Suc (Suc 0) = 2 * b)) \\<and>\n       (N \\<noteq> Suc 0 \\<longrightarrow>\n        (\\<forall>A.\n            (\\<exists>b. Suc (N - 2) = 2 * b + A) \\<and>\n            A < 2 \\<longrightarrow>\n            (\\<exists>b. Suc N = 2 * b + A)))", "apply arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (\\<forall>\\<sigma>.\n      \\<Gamma>\n         \\<turnstile> {\\<sigma>} \\<acute>A :== PROC odd(\\<acute>N)\n                      \\<lbrace>(\\<exists>b.\n                                   \\<^bsup>\\<sigma>\\<^esup>N =\n                                   2 * b + \\<acute>A) \\<and>\n                               \\<acute>A < 2\\<rbrace>) \\<and>\n  (\\<forall>\\<sigma>.\n      \\<Gamma>\n         \\<turnstile> {\\<sigma>} \\<acute>A :== PROC even(\\<acute>N)\n                      \\<lbrace>(\\<exists>b.\n                                   \\<^bsup>\\<sigma>\\<^esup>N + 1 =\n                                   2 * b + \\<acute>A) \\<and>\n                               \\<acute>A < 2\\<rbrace>)\n\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile> {\\<sigma>} \\<acute>A :== PROC odd(\\<acute>N)\n                       \\<lbrace>(\\<exists>b.\n                                    \\<^bsup>\\<sigma>\\<^esup>N =\n                                    2 * b + \\<acute>A) \\<and>\n                                \\<acute>A < 2\\<rbrace>\n 2. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile> {\\<sigma>} \\<acute>A :== PROC even(\\<acute>N)\n                       \\<lbrace>(\\<exists>b.\n                                    \\<^bsup>\\<sigma>\\<^esup>N + 1 =\n                                    2 * b + \\<acute>A) \\<and>\n                                \\<acute>A < 2\\<rbrace>", "thus \"?P1\" \"?P2\""], ["proof (prove)\nusing this:\n  (\\<forall>\\<sigma>.\n      \\<Gamma>\n         \\<turnstile> {\\<sigma>} \\<acute>A :== PROC odd(\\<acute>N)\n                      \\<lbrace>(\\<exists>b.\n                                   \\<^bsup>\\<sigma>\\<^esup>N =\n                                   2 * b + \\<acute>A) \\<and>\n                               \\<acute>A < 2\\<rbrace>) \\<and>\n  (\\<forall>\\<sigma>.\n      \\<Gamma>\n         \\<turnstile> {\\<sigma>} \\<acute>A :== PROC even(\\<acute>N)\n                      \\<lbrace>(\\<exists>b.\n                                   \\<^bsup>\\<sigma>\\<^esup>N + 1 =\n                                   2 * b + \\<acute>A) \\<and>\n                               \\<acute>A < 2\\<rbrace>)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile> {\\<sigma>} \\<acute>A :== PROC odd(\\<acute>N)\n                       \\<lbrace>(\\<exists>b.\n                                    \\<^bsup>\\<sigma>\\<^esup>N =\n                                    2 * b + \\<acute>A) \\<and>\n                                \\<acute>A < 2\\<rbrace> &&&\n    \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile> {\\<sigma>} \\<acute>A :== PROC even(\\<acute>N)\n                       \\<lbrace>(\\<exists>b.\n                                    \\<^bsup>\\<sigma>\\<^esup>N + 1 =\n                                    2 * b + \\<acute>A) \\<and>\n                                \\<acute>A < 2\\<rbrace>", "by iprover+"], ["proof (state)\nthis:\n  \\<forall>\\<sigma>.\n     \\<Gamma>\n        \\<turnstile> {\\<sigma>} \\<acute>A :== PROC odd(\\<acute>N)\n                     \\<lbrace>(\\<exists>b.\n                                  \\<^bsup>\\<sigma>\\<^esup>N =\n                                  2 * b + \\<acute>A) \\<and>\n                              \\<acute>A < 2\\<rbrace>\n  \\<forall>\\<sigma>.\n     \\<Gamma>\n        \\<turnstile> {\\<sigma>} \\<acute>A :== PROC even(\\<acute>N)\n                     \\<lbrace>(\\<exists>b.\n                                  \\<^bsup>\\<sigma>\\<^esup>N + 1 =\n                                  2 * b + \\<acute>A) \\<and>\n                              \\<acute>A < 2\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Expressions With Side Effects\\<close>"], ["", "(* R := N++ + M++*)"], ["", "lemma (in state_space) shows \"\\<Gamma>\\<turnstile> \\<lbrace>True\\<rbrace>\n  \\<acute>N \\<ggreater> n. \\<acute>N :== \\<acute>N + 1 \\<ggreater>\n  \\<acute>M \\<ggreater> m. \\<acute>M :== \\<acute>M + 1 \\<ggreater>\n  \\<acute>R :== n + m\n  \\<lbrace>\\<acute>R = \\<acute>N + \\<acute>M - 2\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    \\<acute>N \\<ggreater> n.\n                    \\<acute>N :== \\<acute>N + 1\\<ggreater>\n                    \\<acute>M \\<ggreater> m.\n                    \\<acute>M :== \\<acute>M + 1\\<ggreater>\n                    \\<acute>R :== n + m\n                    \\<lbrace>\\<acute>R = \\<acute>N + \\<acute>M - 2\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M N. True \\<Longrightarrow> N + M = N + 1 + (M + 1) - 2", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* R := Fac (N) + Fac (N) *)"], ["", "lemma (in Fac_impl) shows\n  \"\\<Gamma>\\<turnstile> \\<lbrace>True\\<rbrace>\n  CALL Fac(\\<acute>N) \\<ggreater> n. CALL Fac(\\<acute>N) \\<ggreater> m.\n  \\<acute>R :== n + m\n  \\<lbrace>\\<acute>R = fac \\<acute>N + fac \\<acute>N\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    CALL Fac(\\<acute>N) \\<ggreater> n.\n                    CALL Fac(\\<acute>N) \\<ggreater> m. \\<acute>R :== n + m\n                    \\<lbrace>\\<acute>R =\n                             fac \\<acute>N + fac \\<acute>N\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    CALL Fac(\\<acute>N) \\<ggreater> n.\n                    CALL Fac(\\<acute>N) \\<ggreater> m. \\<acute>R :== n + m\n                    \\<lbrace>\\<acute>R =\n                             fac \\<acute>N + fac \\<acute>N\\<rbrace>", "note Fac_spec = Fac_spec4"], ["proof (state)\nthis:\n  \\<forall>\\<sigma>.\n     \\<Gamma>,?\\<Theta>\n        \\<turnstile> {\\<sigma>} \\<acute>R :== PROC Fac(\\<acute>N)\n                     \\<lbrace>\\<acute>R =\n                              fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    CALL Fac(\\<acute>N) \\<ggreater> n.\n                    CALL Fac(\\<acute>N) \\<ggreater> m. \\<acute>R :== n + m\n                    \\<lbrace>\\<acute>R =\n                             fac \\<acute>N + fac \\<acute>N\\<rbrace>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    CALL Fac(\\<acute>N) \\<ggreater> n.\n                    CALL Fac(\\<acute>N) \\<ggreater> m. \\<acute>R :== n + m\n                    \\<lbrace>\\<acute>R =\n                             fac \\<acute>N + fac \\<acute>N\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>True\\<rbrace>\n                  CALL Fac(\\<acute>N) \\<ggreater> n.\n                  CALL Fac(\\<acute>N) \\<ggreater> m. \\<acute>R :== n + m\n                  \\<lbrace>\\<acute>R =\n                           fac \\<acute>N + fac \\<acute>N\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["", "(* R := Fac (N) + Fac (M) *)"], ["", "lemma (in Fac_impl) shows\n  \"\\<Gamma>\\<turnstile> \\<lbrace>True\\<rbrace>\n  CALL Fac(\\<acute>N) \\<ggreater> n. CALL Fac(n) \\<ggreater> m.\n  \\<acute>R :== m\n  \\<lbrace>\\<acute>R = fac (fac \\<acute>N)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    CALL Fac(\\<acute>N) \\<ggreater> n.\n                    CALL Fac(n) \\<ggreater> m. \\<acute>R :== m\n                    \\<lbrace>\\<acute>R = fac (fac \\<acute>N)\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    CALL Fac(\\<acute>N) \\<ggreater> n.\n                    CALL Fac(n) \\<ggreater> m. \\<acute>R :== m\n                    \\<lbrace>\\<acute>R = fac (fac \\<acute>N)\\<rbrace>", "note Fac_spec = Fac_spec4"], ["proof (state)\nthis:\n  \\<forall>\\<sigma>.\n     \\<Gamma>,?\\<Theta>\n        \\<turnstile> {\\<sigma>} \\<acute>R :== PROC Fac(\\<acute>N)\n                     \\<lbrace>\\<acute>R =\n                              fac \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    CALL Fac(\\<acute>N) \\<ggreater> n.\n                    CALL Fac(n) \\<ggreater> m. \\<acute>R :== m\n                    \\<lbrace>\\<acute>R = fac (fac \\<acute>N)\\<rbrace>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    CALL Fac(\\<acute>N) \\<ggreater> n.\n                    CALL Fac(n) \\<ggreater> m. \\<acute>R :== m\n                    \\<lbrace>\\<acute>R = fac (fac \\<acute>N)\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<Gamma>\n     \\<turnstile> \\<lbrace>True\\<rbrace>\n                  CALL Fac(\\<acute>N) \\<ggreater> n.\n                  CALL Fac(n) \\<ggreater> m. \\<acute>R :== m\n                  \\<lbrace>\\<acute>R = fac (fac \\<acute>N)\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Global Variables and Heap\\<close>"], ["", "text \\<open>\nNow we will define and verify some procedures on heap-lists. We consider\nlist structures consisting of two fields, a content element @{term \"cont\"} and\na reference to the next list element @{term \"next\"}. We model this by the\nfollowing state space where every field has its own heap.\n\\<close>"], ["", "hoarestate globals_list =\n  \"next\" :: \"ref \\<Rightarrow> ref\"\n  cont :: \"ref \\<Rightarrow> nat\""], ["", "text \\<open>Updates to global components inside a procedure will\nalways be propagated to the caller. This is implicitly done by the\nparameter passing syntax translations. The record containing the global variables must begin with the prefix \"globals\".\n\\<close>"], ["", "text \\<open>We will first define an append function on lists. It takes two\nreferences as parameters. It appends the list referred to by the first\nparameter with the list referred to by the second parameter, and returns\nthe result right into the first parameter.\n\\<close>"], ["", "procedures (imports globals_list)\n  append(p::ref,q::ref|p::ref)\n    \"IF \\<acute>p=Null THEN \\<acute>p :== \\<acute>q ELSE \\<acute>p \\<rightarrow>\\<acute>next:== CALL append(\\<acute>p\\<rightarrow>\\<acute>next,\\<acute>q) FI\""], ["", "declare [[hoare_use_call_tr' = false]]"], ["", "context append_impl\nbegin"], ["", "term \"CALL append(\\<acute>p,\\<acute>q,\\<acute>p\\<rightarrow>\\<acute>next)\""], ["", "end"], ["", "declare [[hoare_use_call_tr' = true]]"], ["", "text \\<open>Below we give two specifications this time..\nThe first one captures the functional behaviour and focuses on the\nentities that are potentially modified by the procedure, the second one\nis a pure frame condition.\nThe list in the modifies clause has to list all global state components that\nmay be changed by the procedure. Note that we know from the modifies clause\nthat the @{term cont} parts of the lists will not be changed. Also a small\nside note on the syntax. We use ordinary brackets in the postcondition\nof the modifies clause, and also the state components do not carry the\nacute, because we explicitly note the state @{term t} here.\n\nThe functional specification now introduces two logical variables besides the\nstate space variable @{term \"\\<sigma>\"}, namely @{term \"Ps\"} and @{term \"Qs\"}.\nThey are universally quantified and range over both the pre and the postcondition, so\nthat we are able to properly instantiate the specification\nduring the proofs. The syntax \\<open>\\<lbrace>\\<sigma>. \\<dots>\\<rbrace>\\<close> is a shorthand to fix the current\nstate: \\<open>{s. \\<sigma> = s \\<dots>}\\<close>.\n\\<close>"], ["", "lemma (in append_impl) append_spec:\n  shows \"\\<forall>\\<sigma> Ps Qs. \\<Gamma>\\<turnstile>\n            \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next Ps \\<and>  List \\<acute>q \\<acute>next Qs \\<and> set Ps \\<inter> set Qs = {}\\<rbrace>\n                \\<acute>p :== PROC append(\\<acute>p,\\<acute>q)\n            \\<lbrace>List \\<acute>p \\<acute>next (Ps@Qs) \\<and> (\\<forall>x. x\\<notin>set Ps \\<longrightarrow> \\<acute>next x = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> Ps Qs.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n     Ps \\<and>\n    List \\<acute>q \\<acute>next Qs \\<and>\n    set Ps \\<inter> set Qs = {}\\<rbrace>\n                       \\<acute>p :== PROC append(\\<acute>p,\\<acute>q)\n                       \\<lbrace>List \\<acute>p \\<acute>next (Ps @ Qs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Ps \\<longrightarrow>\n                                    x\\<rightarrow>\\<acute>next =\n                                    \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>", "apply (hoare_rule HoarePartial.ProcRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> Ps Qs.\n       \\<Gamma>,(\\<Union>\\<sigma> Ps Qs.\n                    {(\\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n    Ps \\<and>\n   List \\<acute>q \\<acute>next Qs \\<and>\n   set Ps \\<inter> set Qs = {}\\<rbrace>,\n                      append_'proc,\n                      \\<lbrace>List \\<acute>p \\<acute>next (Ps @ Qs) \\<and>\n                               (\\<forall>x.\n                                   x \\<notin> set Ps \\<longrightarrow>\n                                   x\\<rightarrow>\\<acute>next =\n                                   \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>,\n                      {})})\n          \\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n     Ps \\<and>\n    List \\<acute>q \\<acute>next Qs \\<and>\n    set Ps \\<inter> set Qs = {}\\<rbrace>\n                       IF \\<acute>p = Null THEN \\<acute>p :== \\<acute>q\n                       ELSE \\<acute>p\\<rightarrow>\\<acute>next :== CALL append(\\<acute>p\\<rightarrow>\\<acute>next,\n                         \\<acute>q)\n                       FI\n                       \\<lbrace>List \\<acute>p \\<acute>next (Ps @ Qs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Ps \\<longrightarrow>\n                                    x\\<rightarrow>\\<acute>next =\n                                    \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps Qs next p q.\n       \\<lbrakk>List p next Ps; List q next Qs;\n        set Ps \\<inter> set Qs = {}\\<rbrakk>\n       \\<Longrightarrow> (p = Null \\<longrightarrow>\n                          List q next (Ps @ Qs) \\<and>\n                          (\\<forall>x.\n                              x \\<notin> set Ps \\<longrightarrow>\n                              next x = next x)) \\<and>\n                         (p \\<noteq> Null \\<longrightarrow>\n                          (\\<exists>Psa.\n                              List (next p) next Psa \\<and>\n                              (\\<exists>Qsa.\n                                  List q next Qsa \\<and>\n                                  set Psa \\<inter> set Qsa = {} \\<and>\n                                  (\\<forall>nexta pa.\nList pa nexta (Psa @ Qsa) \\<and>\n(\\<forall>x.\n    x \\<notin> set Psa \\<longrightarrow> nexta x = next x) \\<longrightarrow>\nList p (nexta(p := pa)) (Ps @ Qs) \\<and>\n(\\<forall>x.\n    x \\<notin> set Ps \\<longrightarrow> (nexta(p := pa)) x = next x)))))", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>The modifies clause is equal to a proper record update specification\nof the following form.\n\\<close>"], ["", "lemma (in append_impl) shows \"{t. t may_only_modify_globals Z in [next]}\n       =\n       {t. \\<exists>next. globals t=update id id next_' (K_statefun next) (globals Z)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. t may_only_modify_globals Z in [next]} =\n    {t. \\<exists>next.\n           globals t = update id id next_' (K_statefun next) (globals Z)}", "apply (unfold mex_def meq_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {t. \\<exists>next_'a.\n           globals t =\n           update id id next_' (K_statefun next_'a) (globals Z)} =\n    {t. \\<exists>next.\n           globals t = update id id next_' (K_statefun next) (globals Z)}", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>If the verification condition generator works on a procedure call\nit checks whether it can find a modifies clause in the context. If one\nis present the procedure call is simplified before the Hoare rule\n@{thm [source] HoareTotal.ProcSpec} is applied. Simplification of the procedure call means,\nthat the ``copy back'' of the global components is simplified. Only those\ncomponents that occur in the modifies clause will actually be copied back.\nThis simplification is justified by the rule @{thm [source] HoareTotal.ProcModifyReturn}.\nSo after this simplification all global components that do not appear in\nthe modifies clause will be treated as local variables.\n\\<close>"], ["", "text \\<open>You can study the effect of the modifies clause on the following two\nexamples, where we want to prove that @{term \"append\"} does not change\nthe @{term \"cont\"} part of the heap.\n\\<close>"], ["", "lemma (in append_impl)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>p=Null \\<and> \\<acute>cont=c\\<rbrace> \\<acute>p :== CALL append(\\<acute>p,Null) \\<lbrace>\\<acute>cont=c\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>p = Null \\<and>\n                             \\<acute>cont = c\\<rbrace>\n                    \\<acute>p :== CALL append(\\<acute>p,Null)\n                    \\<lbrace>\\<acute>cont = c\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cont next p.\n       p = Null \\<Longrightarrow>\n       \\<exists>Ps.\n          List p next Ps \\<and>\n          (\\<exists>Qs.\n              List Null next Qs \\<and>\n              set Ps \\<inter> set Qs = {} \\<and>\n              (\\<forall>conta nexta p.\n                  List p nexta (Ps @ Qs) \\<and>\n                  (\\<forall>x.\n                      x \\<notin> set Ps \\<longrightarrow>\n                      nexta x = next x) \\<longrightarrow>\n                  conta = cont))", "oops"], ["", "text \\<open>To prove the frame condition,\nwe have to tell the verification condition generator to use only the\nmodifies clauses and not to search for functional specifications by\nthe parameter \\<open>spec=modifies\\<close> It will also try to solve the\nverification conditions automatically.\n\\<close>"], ["", "lemma (in append_impl) append_modifies:\n  shows\n   \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile> {\\<sigma>} \\<acute>p :== PROC append(\\<acute>p,\\<acute>q){t. t may_only_modify_globals \\<sigma> in [next]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile> {\\<sigma>}\n                       \\<acute>p :== PROC append(\\<acute>p,\\<acute>q)\n                       {t. t may_only_modify_globals \\<sigma> in [next]}", "apply (hoare_rule HoarePartial.ProcRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,(\\<Union>\\<sigma>.\n                    {({\\<sigma>}, append_'proc,\n                      {t. t may_only_modify_globals \\<sigma> in [next]},\n                      {})})\n          \\<turnstile> {\\<sigma>}\n                       IF \\<acute>p = Null THEN \\<acute>p :== \\<acute>q\n                       ELSE \\<acute>p\\<rightarrow>\\<acute>next :== CALL append(\\<acute>p\\<rightarrow>\\<acute>next,\n                         \\<acute>q)\n                       FI\n                       {t. t may_only_modify_globals \\<sigma> in [next]}", "apply (vcg spec=modifies)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in append_impl)\n  shows \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>p=Null \\<and> \\<acute>cont=c\\<rbrace> \\<acute>p\\<rightarrow>\\<acute>next :== CALL append(\\<acute>p,Null) \\<lbrace>\\<acute>cont=c\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>p = Null \\<and>\n                             \\<acute>cont = c\\<rbrace>\n                    \\<acute>p\\<rightarrow>\\<acute>next :== CALL append(\\<acute>p,\n                    Null)\n                    \\<lbrace>\\<acute>cont = c\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cont next p.\n       p = Null \\<Longrightarrow>\n       \\<exists>Ps.\n          List p next Ps \\<and>\n          (\\<exists>Qs.\n              List Null next Qs \\<and>\n              set Ps \\<inter> set Qs = {} \\<and>\n              (\\<forall>nexta p.\n                  List p nexta (Ps @ Qs) \\<and>\n                  (\\<forall>x.\n                      x \\<notin> set Ps \\<longrightarrow>\n                      nexta x = next x) \\<longrightarrow>\n                  cont = cont))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\nOf course we could add the modifies clause to the functional specification as\nwell. But separating both has the advantage that we split up the verification\nwork. We can make use of the modifies clause before we apply the\nfunctional specification in a fully automatic fashion.\n\\<close>"], ["", "text \\<open>To verify the body of @{term \"append\"} we do not need the modifies\nclause, since the specification does not talk about @{term \"cont\"} at all, and\nwe don't access @{term \"cont\"} inside the body. This may be different for\nmore complex procedures.\n\\<close>"], ["", "text \\<open>\nTo prove that a procedure respects the modifies clause, we only need\nthe modifies clauses of the procedures called in the body. We do not need\nthe functional specifications. So we can always prove the modifies\nclause without functional specifications, but me may need the modifies\nclause to prove the functional specifications.\n\\<close>"], ["", "subsubsection \\<open>Insertion Sort\\<close>"], ["", "primrec sorted:: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a list  \\<Rightarrow> bool\"\nwhere\n\"sorted le [] = True\" |\n\"sorted le (x#xs) = ((\\<forall>y\\<in>set xs. le x y) \\<and> sorted le xs)\""], ["", "procedures (imports globals_list)\n  insert(r::ref,p::ref | p::ref)\n    \"IF \\<acute>r=Null THEN SKIP\n     ELSE IF \\<acute>p=Null THEN \\<acute>p :== \\<acute>r;; \\<acute>p\\<rightarrow>\\<acute>next :== Null\n          ELSE IF \\<acute>r\\<rightarrow>\\<acute>cont \\<le> \\<acute>p\\<rightarrow>\\<acute>cont\n               THEN \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>p;; \\<acute>p:==\\<acute>r\n               ELSE \\<acute>p\\<rightarrow>\\<acute>next :== CALL insert(\\<acute>r,\\<acute>p\\<rightarrow>\\<acute>next)\n               FI\n          FI\n     FI\""], ["", "text \\<open>\nIn the postcondition of the functional specification there is a small but\nimportant subtlety. Whenever we talk about the @{term \"cont\"} part we refer to\nthe one of the pre-state, even in the conclusion of the implication.\nThe reason is, that we have separated out, that @{term \"cont\"} is not modified\nby the procedure, to the modifies clause. So whenever we talk about unmodified\nparts in the postcondition we have to use the pre-state part, or explicitely\nstate an equality in the postcondition.\nThe reason is simple. If the postcondition would talk about \\<open>\\<acute>cont\\<close>\ninstead of \\<open>\\<^bsup>\\<sigma>\\<^esup>cont\\<close>, we will get a new instance of \\<open>cont\\<close> during\nverification and the postcondition would only state something about this\nnew instance. But as the verification condition generator will use the\nmodifies clause the caller of \\<open>insert\\<close> instead will still have the\nold \\<open>cont\\<close> after the call. Thats the sense of the modifies clause.\nSo the caller and the specification will simply talk about two different things,\nwithout being able to relate them (unless an explicit equality is added to\nthe specification).\n\\<close>"], ["", "lemma (in insert_impl) insert_modifies:\n  \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile> {\\<sigma>} \\<acute>p :== PROC insert(\\<acute>r,\\<acute>p){t. t may_only_modify_globals \\<sigma> in [next]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile> {\\<sigma>}\n                       \\<acute>p :== PROC insert(\\<acute>r,\\<acute>p)\n                       {t. t may_only_modify_globals \\<sigma> in [next]}", "apply (hoare_rule HoarePartial.ProcRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,(\\<Union>\\<sigma>.\n                    {({\\<sigma>}, insert_'proc,\n                      {t. t may_only_modify_globals \\<sigma> in [next]},\n                      {})})\n          \\<turnstile> {\\<sigma>}\n                       IF \\<acute>r = Null THEN SKIP\n                       ELSE IF \\<acute>p = Null\n                            THEN \\<acute>p :== \\<acute>r;;\n                              \\<acute>p\\<rightarrow>\\<acute>next :== Null\n                            ELSE IF \\<acute>r\\<rightarrow>\\<acute>cont\n                                    \\<le> \\<acute>p\\<rightarrow>\\<acute>cont\n                                 THEN \\<acute>r\\<rightarrow>\\<acute>next :==\n\\<acute>p;;\n                                   \\<acute>p :== \\<acute>r\n                                 ELSE \\<acute>p\\<rightarrow>\\<acute>next :== CALL insert(\\<acute>r,\n                                   \\<acute>p\\<rightarrow>\\<acute>next)\n                                 FI\n                            FI\n                       FI\n                       {t. t may_only_modify_globals \\<sigma> in [next]}", "apply (vcg spec=modifies)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in insert_impl) insert_spec:\n    \"\\<forall>\\<sigma> Ps . \\<Gamma>\\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next Ps \\<and> sorted (\\<le>) (map \\<acute>cont Ps) \\<and>\n                  \\<acute>r \\<noteq> Null \\<and> \\<acute>r \\<notin> set Ps\\<rbrace>\n         \\<acute>p :== PROC insert(\\<acute>r,\\<acute>p)\n   \\<lbrace>\\<exists>Qs. List \\<acute>p \\<acute>next Qs \\<and> sorted (\\<le>) (map \\<^bsup>\\<sigma>\\<^esup>cont  Qs) \\<and>\n           set Qs = insert \\<^bsup>\\<sigma>\\<^esup>r (set Ps) \\<and>\n           (\\<forall>x. x \\<notin> set Qs \\<longrightarrow> \\<acute>next x = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> Ps.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n     Ps \\<and>\n    VcgExSP.sorted (\\<le>) (map \\<acute>cont Ps) \\<and>\n    \\<acute>r \\<noteq> Null \\<and> \\<acute>r \\<notin> set Ps\\<rbrace>\n                       \\<acute>p :== PROC insert(\\<acute>r,\\<acute>p)\n                       \\<lbrace>\\<exists>Qs.\n                                   List \\<acute>p \\<acute>next Qs \\<and>\n                                   VcgExSP.sorted (\\<le>)\n                                    (map \\<^bsup>\\<sigma>\\<^esup>cont\nQs) \\<and>\n                                   set Qs =\n                                   insert \\<^bsup>\\<sigma>\\<^esup>r\n                                    (set Ps) \\<and>\n                                   (\\<forall>x.\n x \\<notin> set Qs \\<longrightarrow>\n x\\<rightarrow>\\<acute>next = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>", "apply (hoare_rule HoarePartial.ProcRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> Ps.\n       \\<Gamma>,(\\<Union>\\<sigma> Ps.\n                    {(\\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n    Ps \\<and>\n   VcgExSP.sorted (\\<le>) (map \\<acute>cont Ps) \\<and>\n   \\<acute>r \\<noteq> Null \\<and> \\<acute>r \\<notin> set Ps\\<rbrace>,\n                      insert_'proc,\n                      \\<lbrace>\\<exists>Qs.\n                                  List \\<acute>p \\<acute>next Qs \\<and>\n                                  VcgExSP.sorted (\\<le>)\n                                   (map \\<^bsup>\\<sigma>\\<^esup>cont\n                                     Qs) \\<and>\n                                  set Qs =\n                                  insert \\<^bsup>\\<sigma>\\<^esup>r\n                                   (set Ps) \\<and>\n                                  (\\<forall>x.\nx \\<notin> set Qs \\<longrightarrow>\nx\\<rightarrow>\\<acute>next = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>,\n                      {})})\n          \\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n     Ps \\<and>\n    VcgExSP.sorted (\\<le>) (map \\<acute>cont Ps) \\<and>\n    \\<acute>r \\<noteq> Null \\<and> \\<acute>r \\<notin> set Ps\\<rbrace>\n                       IF \\<acute>r = Null THEN SKIP\n                       ELSE IF \\<acute>p = Null\n                            THEN \\<acute>p :== \\<acute>r;;\n                              \\<acute>p\\<rightarrow>\\<acute>next :== Null\n                            ELSE IF \\<acute>r\\<rightarrow>\\<acute>cont\n                                    \\<le> \\<acute>p\\<rightarrow>\\<acute>cont\n                                 THEN \\<acute>r\\<rightarrow>\\<acute>next :==\n\\<acute>p;;\n                                   \\<acute>p :== \\<acute>r\n                                 ELSE \\<acute>p\\<rightarrow>\\<acute>next :== CALL insert(\\<acute>r,\n                                   \\<acute>p\\<rightarrow>\\<acute>next)\n                                 FI\n                            FI\n                       FI\n                       \\<lbrace>\\<exists>Qs.\n                                   List \\<acute>p \\<acute>next Qs \\<and>\n                                   VcgExSP.sorted (\\<le>)\n                                    (map \\<^bsup>\\<sigma>\\<^esup>cont\nQs) \\<and>\n                                   set Qs =\n                                   insert \\<^bsup>\\<sigma>\\<^esup>r\n                                    (set Ps) \\<and>\n                                   (\\<forall>x.\n x \\<notin> set Qs \\<longrightarrow>\n x\\<rightarrow>\\<acute>next = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps cont next p r.\n       \\<lbrakk>List p next Ps; VcgExSP.sorted (\\<le>) (map cont Ps);\n        r \\<noteq> Null; r \\<notin> set Ps\\<rbrakk>\n       \\<Longrightarrow> (r = Null \\<longrightarrow>\n                          (\\<exists>Qs.\n                              List p next Qs \\<and>\n                              VcgExSP.sorted (\\<le>) (map cont Qs) \\<and>\n                              set Qs = insert r (set Ps) \\<and>\n                              (\\<forall>x.\n                                  x \\<notin> set Qs \\<longrightarrow>\n                                  next x = next x))) \\<and>\n                         (r \\<noteq> Null \\<longrightarrow>\n                          (p = Null \\<longrightarrow>\n                           (\\<exists>Qs.\n                               List r (next(r := Null)) Qs \\<and>\n                               VcgExSP.sorted (\\<le>) (map cont Qs) \\<and>\n                               set Qs = insert r (set Ps) \\<and>\n                               (\\<forall>x.\n                                   x \\<notin> set Qs \\<longrightarrow>\n                                   (next(r := Null)) x = next x))) \\<and>\n                          (p \\<noteq> Null \\<longrightarrow>\n                           (cont r \\<le> cont p \\<longrightarrow>\n                            (\\<exists>Qs.\n                                List r (next(r := p)) Qs \\<and>\n                                VcgExSP.sorted (\\<le>) (map cont Qs) \\<and>\n                                set Qs = insert r (set Ps) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Qs \\<longrightarrow>\n                                    (next(r := p)) x = next x))) \\<and>\n                           (\\<not> cont r \\<le> cont p \\<longrightarrow>\n                            (\\<exists>Psa.\n                                List (next p) next Psa \\<and>\n                                VcgExSP.sorted (\\<le>) (map cont Psa) \\<and>\n                                r \\<noteq> Null \\<and>\n                                r \\<notin> set Psa \\<and>\n                                (\\<forall>nexta pa.\n                                    (\\<exists>Qs.\n  List pa nexta Qs \\<and>\n  VcgExSP.sorted (\\<le>) (map cont Qs) \\<and>\n  set Qs = insert r (set Psa) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Qs \\<longrightarrow>\n      nexta x = next x)) \\<longrightarrow>\n                                    (\\<exists>Qs.\n  List p (nexta(p := pa)) Qs \\<and>\n  VcgExSP.sorted (\\<le>) (map cont Qs) \\<and>\n  set Qs = insert r (set Ps) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Qs \\<longrightarrow> (nexta(p := pa)) x = next x)))))))", "apply (intro conjI impI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>Ps cont next p r.\n       \\<lbrakk>List p next Ps; VcgExSP.sorted (\\<le>) (map cont Ps);\n        r \\<noteq> Null; r \\<notin> set Ps; r = Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List p next Qs \\<and>\n                            VcgExSP.sorted (\\<le>) (map cont Qs) \\<and>\n                            set Qs = insert r (set Ps) \\<and>\n                            (\\<forall>x.\n                                x \\<notin> set Qs \\<longrightarrow>\n                                next x = next x)\n 2. \\<And>Ps cont next p r.\n       \\<lbrakk>List p next Ps; VcgExSP.sorted (\\<le>) (map cont Ps);\n        r \\<noteq> Null; r \\<notin> set Ps; r \\<noteq> Null;\n        p = Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List r (next(r := Null)) Qs \\<and>\n                            VcgExSP.sorted (\\<le>) (map cont Qs) \\<and>\n                            set Qs = insert r (set Ps) \\<and>\n                            (\\<forall>x.\n                                x \\<notin> set Qs \\<longrightarrow>\n                                (next(r := Null)) x = next x)\n 3. \\<And>Ps cont next p r.\n       \\<lbrakk>List p next Ps; VcgExSP.sorted (\\<le>) (map cont Ps);\n        r \\<noteq> Null; r \\<notin> set Ps; r \\<noteq> Null;\n        p \\<noteq> Null; cont r \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List r (next(r := p)) Qs \\<and>\n                            VcgExSP.sorted (\\<le>) (map cont Qs) \\<and>\n                            set Qs = insert r (set Ps) \\<and>\n                            (\\<forall>x.\n                                x \\<notin> set Qs \\<longrightarrow>\n                                (next(r := p)) x = next x)\n 4. \\<And>Ps cont next p r.\n       \\<lbrakk>List p next Ps; VcgExSP.sorted (\\<le>) (map cont Ps);\n        r \\<noteq> Null; r \\<notin> set Ps; r \\<noteq> Null;\n        p \\<noteq> Null; \\<not> cont r \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List (next p) next Psa \\<and>\n                            VcgExSP.sorted (\\<le>) (map cont Psa) \\<and>\n                            r \\<noteq> Null \\<and>\n                            r \\<notin> set Psa \\<and>\n                            (\\<forall>nexta pa.\n                                (\\<exists>Qs.\n                                    List pa nexta Qs \\<and>\n                                    VcgExSP.sorted (\\<le>)\n                                     (map cont Qs) \\<and>\n                                    set Qs = insert r (set Psa) \\<and>\n                                    (\\<forall>x.\n  x \\<notin> set Qs \\<longrightarrow> nexta x = next x)) \\<longrightarrow>\n                                (\\<exists>Qs.\n                                    List p (nexta(p := pa)) Qs \\<and>\n                                    VcgExSP.sorted (\\<le>)\n                                     (map cont Qs) \\<and>\n                                    set Qs = insert r (set Ps) \\<and>\n                                    (\\<forall>x.\n  x \\<notin> set Qs \\<longrightarrow> (nexta(p := pa)) x = next x)))", "apply    fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Ps cont next p r.\n       \\<lbrakk>List p next Ps; VcgExSP.sorted (\\<le>) (map cont Ps);\n        r \\<noteq> Null; r \\<notin> set Ps; r \\<noteq> Null;\n        p = Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List r (next(r := Null)) Qs \\<and>\n                            VcgExSP.sorted (\\<le>) (map cont Qs) \\<and>\n                            set Qs = insert r (set Ps) \\<and>\n                            (\\<forall>x.\n                                x \\<notin> set Qs \\<longrightarrow>\n                                (next(r := Null)) x = next x)\n 2. \\<And>Ps cont next p r.\n       \\<lbrakk>List p next Ps; VcgExSP.sorted (\\<le>) (map cont Ps);\n        r \\<noteq> Null; r \\<notin> set Ps; r \\<noteq> Null;\n        p \\<noteq> Null; cont r \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List r (next(r := p)) Qs \\<and>\n                            VcgExSP.sorted (\\<le>) (map cont Qs) \\<and>\n                            set Qs = insert r (set Ps) \\<and>\n                            (\\<forall>x.\n                                x \\<notin> set Qs \\<longrightarrow>\n                                (next(r := p)) x = next x)\n 3. \\<And>Ps cont next p r.\n       \\<lbrakk>List p next Ps; VcgExSP.sorted (\\<le>) (map cont Ps);\n        r \\<noteq> Null; r \\<notin> set Ps; r \\<noteq> Null;\n        p \\<noteq> Null; \\<not> cont r \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List (next p) next Psa \\<and>\n                            VcgExSP.sorted (\\<le>) (map cont Psa) \\<and>\n                            r \\<noteq> Null \\<and>\n                            r \\<notin> set Psa \\<and>\n                            (\\<forall>nexta pa.\n                                (\\<exists>Qs.\n                                    List pa nexta Qs \\<and>\n                                    VcgExSP.sorted (\\<le>)\n                                     (map cont Qs) \\<and>\n                                    set Qs = insert r (set Psa) \\<and>\n                                    (\\<forall>x.\n  x \\<notin> set Qs \\<longrightarrow> nexta x = next x)) \\<longrightarrow>\n                                (\\<exists>Qs.\n                                    List p (nexta(p := pa)) Qs \\<and>\n                                    VcgExSP.sorted (\\<le>)\n                                     (map cont Qs) \\<and>\n                                    set Qs = insert r (set Ps) \\<and>\n                                    (\\<forall>x.\n  x \\<notin> set Qs \\<longrightarrow> (nexta(p := pa)) x = next x)))", "apply   fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Ps cont next p r.\n       \\<lbrakk>List p next Ps; VcgExSP.sorted (\\<le>) (map cont Ps);\n        r \\<noteq> Null; r \\<notin> set Ps; r \\<noteq> Null;\n        p \\<noteq> Null; cont r \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List r (next(r := p)) Qs \\<and>\n                            VcgExSP.sorted (\\<le>) (map cont Qs) \\<and>\n                            set Qs = insert r (set Ps) \\<and>\n                            (\\<forall>x.\n                                x \\<notin> set Qs \\<longrightarrow>\n                                (next(r := p)) x = next x)\n 2. \\<And>Ps cont next p r.\n       \\<lbrakk>List p next Ps; VcgExSP.sorted (\\<le>) (map cont Ps);\n        r \\<noteq> Null; r \\<notin> set Ps; r \\<noteq> Null;\n        p \\<noteq> Null; \\<not> cont r \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List (next p) next Psa \\<and>\n                            VcgExSP.sorted (\\<le>) (map cont Psa) \\<and>\n                            r \\<noteq> Null \\<and>\n                            r \\<notin> set Psa \\<and>\n                            (\\<forall>nexta pa.\n                                (\\<exists>Qs.\n                                    List pa nexta Qs \\<and>\n                                    VcgExSP.sorted (\\<le>)\n                                     (map cont Qs) \\<and>\n                                    set Qs = insert r (set Psa) \\<and>\n                                    (\\<forall>x.\n  x \\<notin> set Qs \\<longrightarrow> nexta x = next x)) \\<longrightarrow>\n                                (\\<exists>Qs.\n                                    List p (nexta(p := pa)) Qs \\<and>\n                                    VcgExSP.sorted (\\<le>)\n                                     (map cont Qs) \\<and>\n                                    set Qs = insert r (set Ps) \\<and>\n                                    (\\<forall>x.\n  x \\<notin> set Qs \\<longrightarrow> (nexta(p := pa)) x = next x)))", "apply  fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps cont next p r.\n       \\<lbrakk>List p next Ps; VcgExSP.sorted (\\<le>) (map cont Ps);\n        r \\<noteq> Null; r \\<notin> set Ps; r \\<noteq> Null;\n        p \\<noteq> Null; \\<not> cont r \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List (next p) next Psa \\<and>\n                            VcgExSP.sorted (\\<le>) (map cont Psa) \\<and>\n                            r \\<noteq> Null \\<and>\n                            r \\<notin> set Psa \\<and>\n                            (\\<forall>nexta pa.\n                                (\\<exists>Qs.\n                                    List pa nexta Qs \\<and>\n                                    VcgExSP.sorted (\\<le>)\n                                     (map cont Qs) \\<and>\n                                    set Qs = insert r (set Psa) \\<and>\n                                    (\\<forall>x.\n  x \\<notin> set Qs \\<longrightarrow> nexta x = next x)) \\<longrightarrow>\n                                (\\<exists>Qs.\n                                    List p (nexta(p := pa)) Qs \\<and>\n                                    VcgExSP.sorted (\\<le>)\n                                     (map cont Qs) \\<and>\n                                    set Qs = insert r (set Ps) \\<and>\n                                    (\\<forall>x.\n  x \\<notin> set Qs \\<longrightarrow> (nexta(p := pa)) x = next x)))", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cont next p r ps nexta pa Qs.\n       \\<lbrakk>r \\<noteq> Null; p \\<noteq> Null;\n        \\<not> cont r \\<le> cont p; List (next p) next ps;\n        \\<forall>x\\<in>set ps. cont p \\<le> cont x;\n        VcgExSP.sorted (\\<le>) (map cont ps); r \\<noteq> p;\n        r \\<notin> set ps; List pa nexta Qs;\n        VcgExSP.sorted (\\<le>) (map cont Qs); set Qs = insert r (set ps);\n        \\<forall>x.\n           x \\<noteq> r \\<and> x \\<notin> set ps \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            (\\<exists>ps.\n                                Qs = p # ps \\<and>\n                                List pa (nexta(p := pa)) ps) \\<and>\n                            VcgExSP.sorted (\\<le>) (map cont Qs) \\<and>\n                            set Qs = insert r (insert p (set ps)) \\<and>\n                            (\\<forall>x.\n                                (x = p \\<longrightarrow>\n                                 p \\<notin> set Qs \\<longrightarrow>\n                                 pa = next p) \\<and>\n                                (x \\<noteq> p \\<longrightarrow>\n                                 x \\<notin> set Qs \\<longrightarrow>\n                                 nexta x = next x))", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "procedures (imports globals_list)\n  insertSort(p::ref | p::ref)\n  where r::ref q::ref\n  in\n    \"\\<acute>r:==Null;;\n     WHILE (\\<acute>p \\<noteq> Null) DO\n       \\<acute>q :== \\<acute>p;;\n       \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n       \\<acute>r :== CALL insert(\\<acute>q,\\<acute>r)\n     OD;;\n     \\<acute>p:==\\<acute>r\""], ["", "print_locale insertSort_impl"], ["", "lemma (in insertSort_impl) insertSort_modifies:\n  shows\n   \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile> {\\<sigma>} \\<acute>p :== PROC insertSort(\\<acute>p)\n              {t. t may_only_modify_globals \\<sigma> in [next]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile> {\\<sigma>} \\<acute>p :== PROC insertSort(\\<acute>p)\n                       {t. t may_only_modify_globals \\<sigma> in [next]}", "apply (hoare_rule HoarePartial.ProcRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,(\\<Union>\\<sigma>.\n                    {({\\<sigma>}, insertSort_'proc,\n                      {t. t may_only_modify_globals \\<sigma> in [next]},\n                      {})})\n          \\<turnstile> {\\<sigma>}\n                       \\<acute>r :== Null;;\n                       WHILE \\<acute>p \\<noteq> Null \n                       DO \\<acute>q :== \\<acute>p;;\n                          \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n                          \\<acute>r :== CALL insert(\\<acute>q,\\<acute>r) \n                       OD;;\n                       \\<acute>p :== \\<acute>r\n                       {t. t may_only_modify_globals \\<sigma> in [next]}", "apply (vcg spec=modifies)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Insertion sort is not implemented recursively here but with a while\nloop. Note that the while loop is not annotated with an invariant in the\nprocedure definition. The invariant only comes into play during verification.\nTherefore we will annotate the body during the proof with the\nrule @{thm [source] HoareTotal.annotateI}.\n\\<close>"], ["", "lemma (in insertSort_impl) insertSort_body_spec:\n  shows \"\\<forall>\\<sigma> Ps. \\<Gamma>,\\<Theta>\\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next Ps \\<rbrace>\n              \\<acute>p :== PROC insertSort(\\<acute>p)\n          \\<lbrace>\\<exists>Qs. List \\<acute>p \\<acute>next Qs \\<and> sorted (\\<le>) (map \\<^bsup>\\<sigma>\\<^esup>cont Qs) \\<and>\n           set Qs = set Ps\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> Ps.\n       \\<Gamma>,\\<Theta>\n          \\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n     Ps\\<rbrace>\n                       \\<acute>p :== PROC insertSort(\\<acute>p)\n                       \\<lbrace>\\<exists>Qs.\n                                   List \\<acute>p \\<acute>next Qs \\<and>\n                                   VcgExSP.sorted (\\<le>)\n                                    (map \\<^bsup>\\<sigma>\\<^esup>cont\nQs) \\<and>\n                                   set Qs = set Ps\\<rbrace>", "apply (hoare_rule HoarePartial.ProcRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> Ps.\n       \\<Gamma>,\\<Theta> \\<union>\n                (\\<Union>\\<sigma> Ps.\n                    {(\\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n    Ps\\<rbrace>,\n                      insertSort_'proc,\n                      \\<lbrace>\\<exists>Qs.\n                                  List \\<acute>p \\<acute>next Qs \\<and>\n                                  VcgExSP.sorted (\\<le>)\n                                   (map \\<^bsup>\\<sigma>\\<^esup>cont\n                                     Qs) \\<and>\n                                  set Qs = set Ps\\<rbrace>,\n                      {})})\n          \\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n     Ps\\<rbrace>\n                       \\<acute>r :== Null;;\n                       WHILE \\<acute>p \\<noteq> Null \n                       DO \\<acute>q :== \\<acute>p;;\n                          \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n                          \\<acute>r :== CALL insert(\\<acute>q,\\<acute>r) \n                       OD;;\n                       \\<acute>p :== \\<acute>r\n                       \\<lbrace>\\<exists>Qs.\n                                   List \\<acute>p \\<acute>next Qs \\<and>\n                                   VcgExSP.sorted (\\<le>)\n                                    (map \\<^bsup>\\<sigma>\\<^esup>cont\nQs) \\<and>\n                                   set Qs = set Ps\\<rbrace>", "apply (hoare_rule anno=\n         \"\\<acute>r :== Null;;\n         WHILE \\<acute>p \\<noteq> Null\n         INV \\<lbrace>\\<exists>Qs Rs. List \\<acute>p \\<acute>next Qs \\<and> List \\<acute>r \\<acute>next Rs \\<and>\n                  set Qs \\<inter> set Rs = {} \\<and>\n                  sorted (\\<le>) (map \\<acute>cont Rs) \\<and> set Qs \\<union> set Rs = set Ps \\<and>\n                  \\<acute>cont = \\<^bsup>\\<sigma>\\<^esup>cont \\<rbrace>\n          DO \\<acute>q :== \\<acute>p;; \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;; \\<acute>r :== CALL insert(\\<acute>q,\\<acute>r) OD;;\n          \\<acute>p :== \\<acute>r\" in HoarePartial.annotateI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> Ps.\n       \\<Gamma>,\\<Theta> \\<union>\n                (\\<Union>\\<sigma> Ps.\n                    {(\\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n    Ps\\<rbrace>,\n                      insertSort_'proc,\n                      \\<lbrace>\\<exists>Qs.\n                                  List \\<acute>p \\<acute>next Qs \\<and>\n                                  VcgExSP.sorted (\\<le>)\n                                   (map \\<^bsup>\\<sigma>\\<^esup>cont\n                                     Qs) \\<and>\n                                  set Qs = set Ps\\<rbrace>,\n                      {})})\n          \\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n     Ps\\<rbrace>\n                       \\<acute>r :== Null;;\n                       WHILE \\<acute>p \\<noteq> Null\n                       INV \\<lbrace>\\<exists>Qs Rs.\n List \\<acute>p \\<acute>next Qs \\<and>\n List \\<acute>r \\<acute>next Rs \\<and>\n set Qs \\<inter> set Rs = {} \\<and>\n VcgExSP.sorted (\\<le>) (map \\<acute>cont Rs) \\<and>\n set Qs \\<union> set Rs = set Ps \\<and>\n \\<acute>cont = \\<^bsup>\\<sigma>\\<^esup>cont\\<rbrace> \n                       DO \\<acute>q :== \\<acute>p;;\n                          \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n                          \\<acute>r :== CALL insert(\\<acute>q,\\<acute>r) \n                       OD;;\n                       \\<acute>p :== \\<acute>r\n                       \\<lbrace>\\<exists>Qs.\n                                   List \\<acute>p \\<acute>next Qs \\<and>\n                                   VcgExSP.sorted (\\<le>)\n                                    (map \\<^bsup>\\<sigma>\\<^esup>cont\nQs) \\<and>\n                                   set Qs = set Ps\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Ps cont next p.\n       List p next Ps \\<Longrightarrow>\n       \\<exists>Qs Rs.\n          List p next Qs \\<and>\n          List Null next Rs \\<and>\n          set Qs \\<inter> set Rs = {} \\<and>\n          VcgExSP.sorted (\\<le>) (map cont Rs) \\<and>\n          set Qs \\<union> set Rs = set Ps \\<and> cont = cont\n 2. \\<And>cont Ps conta next p r.\n       \\<lbrakk>\\<exists>Qs Rs.\n                   List p next Qs \\<and>\n                   List r next Rs \\<and>\n                   set Qs \\<inter> set Rs = {} \\<and>\n                   VcgExSP.sorted (\\<le>) (map conta Rs) \\<and>\n                   set Qs \\<union> set Rs = set Ps \\<and> conta = cont;\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List r next Psa \\<and>\n                            VcgExSP.sorted (\\<le>) (map conta Psa) \\<and>\n                            p \\<noteq> Null \\<and>\n                            p \\<notin> set Psa \\<and>\n                            (\\<forall>nexta pa.\n                                (\\<exists>Qs.\n                                    List pa nexta Qs \\<and>\n                                    VcgExSP.sorted (\\<le>)\n                                     (map conta Qs) \\<and>\n                                    set Qs = insert p (set Psa) \\<and>\n                                    (\\<forall>x.\n  x \\<notin> set Qs \\<longrightarrow> nexta x = next x)) \\<longrightarrow>\n                                (\\<exists>Qs.\n                                    List (next p) nexta Qs \\<and>\n                                    (\\<exists>Rs.\n  List pa nexta Rs \\<and>\n  set Qs \\<inter> set Rs = {} \\<and>\n  VcgExSP.sorted (\\<le>) (map conta Rs) \\<and>\n  set Qs \\<union> set Rs = set Ps \\<and> conta = cont)))\n 3. \\<And>cont Ps conta next p r.\n       \\<lbrakk>\\<exists>Qs Rs.\n                   List p next Qs \\<and>\n                   List r next Rs \\<and>\n                   set Qs \\<inter> set Rs = {} \\<and>\n                   VcgExSP.sorted (\\<le>) (map conta Rs) \\<and>\n                   set Qs \\<union> set Rs = set Ps \\<and> conta = cont;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List r next Qs \\<and>\n                            VcgExSP.sorted (\\<le>) (map cont Qs) \\<and>\n                            set Qs = set Ps", "apply   fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cont Ps conta next p r.\n       \\<lbrakk>\\<exists>Qs Rs.\n                   List p next Qs \\<and>\n                   List r next Rs \\<and>\n                   set Qs \\<inter> set Rs = {} \\<and>\n                   VcgExSP.sorted (\\<le>) (map conta Rs) \\<and>\n                   set Qs \\<union> set Rs = set Ps \\<and> conta = cont;\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List r next Psa \\<and>\n                            VcgExSP.sorted (\\<le>) (map conta Psa) \\<and>\n                            p \\<noteq> Null \\<and>\n                            p \\<notin> set Psa \\<and>\n                            (\\<forall>nexta pa.\n                                (\\<exists>Qs.\n                                    List pa nexta Qs \\<and>\n                                    VcgExSP.sorted (\\<le>)\n                                     (map conta Qs) \\<and>\n                                    set Qs = insert p (set Psa) \\<and>\n                                    (\\<forall>x.\n  x \\<notin> set Qs \\<longrightarrow> nexta x = next x)) \\<longrightarrow>\n                                (\\<exists>Qs.\n                                    List (next p) nexta Qs \\<and>\n                                    (\\<exists>Rs.\n  List pa nexta Rs \\<and>\n  set Qs \\<inter> set Rs = {} \\<and>\n  VcgExSP.sorted (\\<le>) (map conta Rs) \\<and>\n  set Qs \\<union> set Rs = set Ps \\<and> conta = cont)))\n 2. \\<And>cont Ps conta next p r.\n       \\<lbrakk>\\<exists>Qs Rs.\n                   List p next Qs \\<and>\n                   List r next Rs \\<and>\n                   set Qs \\<inter> set Rs = {} \\<and>\n                   VcgExSP.sorted (\\<le>) (map conta Rs) \\<and>\n                   set Qs \\<union> set Rs = set Ps \\<and> conta = cont;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List r next Qs \\<and>\n                            VcgExSP.sorted (\\<le>) (map cont Qs) \\<and>\n                            set Qs = set Ps", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>cont Ps conta next p r.\n       \\<lbrakk>\\<exists>Qs Rs.\n                   List p next Qs \\<and>\n                   List r next Rs \\<and>\n                   set Qs \\<inter> set Rs = {} \\<and>\n                   VcgExSP.sorted (\\<le>) (map conta Rs) \\<and>\n                   set Qs \\<union> set Rs = set Ps \\<and> conta = cont;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List r next Qs \\<and>\n                            VcgExSP.sorted (\\<le>) (map cont Qs) \\<and>\n                            set Qs = set Ps\n 2. \\<And>cont Ps conta next p r.\n       \\<lbrakk>\\<exists>Qs Rs.\n                   List p next Qs \\<and>\n                   List r next Rs \\<and>\n                   set Qs \\<inter> set Rs = {} \\<and>\n                   VcgExSP.sorted (\\<le>) (map conta Rs) \\<and>\n                   set Qs \\<union> set Rs = set Ps \\<and> conta = cont;\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List r next Psa \\<and>\n                            VcgExSP.sorted (\\<le>) (map conta Psa) \\<and>\n                            p \\<noteq> Null \\<and>\n                            p \\<notin> set Psa \\<and>\n                            (\\<forall>nexta pa.\n                                (\\<exists>Qs.\n                                    List pa nexta Qs \\<and>\n                                    VcgExSP.sorted (\\<le>)\n                                     (map conta Qs) \\<and>\n                                    set Qs = insert p (set Psa) \\<and>\n                                    (\\<forall>x.\n  x \\<notin> set Qs \\<longrightarrow> nexta x = next x)) \\<longrightarrow>\n                                (\\<exists>Qs.\n                                    List (next p) nexta Qs \\<and>\n                                    (\\<exists>Rs.\n  List pa nexta Rs \\<and>\n  set Qs \\<inter> set Rs = {} \\<and>\n  VcgExSP.sorted (\\<le>) (map conta Rs) \\<and>\n  set Qs \\<union> set Rs = set Ps \\<and> conta = cont)))", "apply  fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cont Ps conta next p r.\n       \\<lbrakk>\\<exists>Qs Rs.\n                   List p next Qs \\<and>\n                   List r next Rs \\<and>\n                   set Qs \\<inter> set Rs = {} \\<and>\n                   VcgExSP.sorted (\\<le>) (map conta Rs) \\<and>\n                   set Qs \\<union> set Rs = set Ps \\<and> conta = cont;\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List r next Psa \\<and>\n                            VcgExSP.sorted (\\<le>) (map conta Psa) \\<and>\n                            p \\<noteq> Null \\<and>\n                            p \\<notin> set Psa \\<and>\n                            (\\<forall>nexta pa.\n                                (\\<exists>Qs.\n                                    List pa nexta Qs \\<and>\n                                    VcgExSP.sorted (\\<le>)\n                                     (map conta Qs) \\<and>\n                                    set Qs = insert p (set Psa) \\<and>\n                                    (\\<forall>x.\n  x \\<notin> set Qs \\<longrightarrow> nexta x = next x)) \\<longrightarrow>\n                                (\\<exists>Qs.\n                                    List (next p) nexta Qs \\<and>\n                                    (\\<exists>Rs.\n  List pa nexta Rs \\<and>\n  set Qs \\<inter> set Rs = {} \\<and>\n  VcgExSP.sorted (\\<le>) (map conta Rs) \\<and>\n  set Qs \\<union> set Rs = set Ps \\<and> conta = cont)))", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        VcgExSP.sorted (\\<le>) (map cont Rs);\n        insert p (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        VcgExSP.sorted (\\<le>) (map cont Qs); set Qs = insert p (set Rs);\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List (next p) nexta Qs \\<and>\n                            p \\<notin> set Qs \\<and>\n                            set Qs \\<inter> set Rs = {} \\<and>\n                            insert p (set Qs \\<union> set Rs) = set Ps", "apply (rule_tac x=ps in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        VcgExSP.sorted (\\<le>) (map cont Rs);\n        insert p (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        VcgExSP.sorted (\\<le>) (map cont Qs); set Qs = insert p (set Rs);\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> List (next p) nexta ps \\<and>\n                         p \\<notin> set ps \\<and>\n                         set ps \\<inter> set Rs = {} \\<and>\n                         insert p (set ps \\<union> set Rs) = set Ps", "apply (intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        VcgExSP.sorted (\\<le>) (map cont Rs);\n        insert p (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        VcgExSP.sorted (\\<le>) (map cont Qs); set Qs = insert p (set Rs);\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> List (next p) nexta ps\n 2. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        VcgExSP.sorted (\\<le>) (map cont Rs);\n        insert p (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        VcgExSP.sorted (\\<le>) (map cont Qs); set Qs = insert p (set Rs);\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> p \\<notin> set ps\n 3. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        VcgExSP.sorted (\\<le>) (map cont Rs);\n        insert p (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        VcgExSP.sorted (\\<le>) (map cont Qs); set Qs = insert p (set Rs);\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> set ps \\<inter> set Rs = {}\n 4. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        VcgExSP.sorted (\\<le>) (map cont Rs);\n        insert p (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        VcgExSP.sorted (\\<le>) (map cont Qs); set Qs = insert p (set Rs);\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> insert p (set ps \\<union> set Rs) = set Ps", "apply    (rule heap_eq_ListI1)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        VcgExSP.sorted (\\<le>) (map cont Rs);\n        insert p (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        VcgExSP.sorted (\\<le>) (map cont Qs); set Qs = insert p (set Rs);\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> List (next p)\n                          (?h161 cont Ps next p r ps Rs nexta pa Qs) ps\n 2. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        VcgExSP.sorted (\\<le>) (map cont Rs);\n        insert p (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        VcgExSP.sorted (\\<le>) (map cont Qs); set Qs = insert p (set Rs);\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set ps.\n                            nexta x =\n                            ?h161 cont Ps next p r ps Rs nexta pa Qs x\n 3. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        VcgExSP.sorted (\\<le>) (map cont Rs);\n        insert p (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        VcgExSP.sorted (\\<le>) (map cont Qs); set Qs = insert p (set Rs);\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> p \\<notin> set ps\n 4. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        VcgExSP.sorted (\\<le>) (map cont Rs);\n        insert p (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        VcgExSP.sorted (\\<le>) (map cont Qs); set Qs = insert p (set Rs);\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> set ps \\<inter> set Rs = {}\n 5. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        VcgExSP.sorted (\\<le>) (map cont Rs);\n        insert p (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        VcgExSP.sorted (\\<le>) (map cont Qs); set Qs = insert p (set Rs);\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> insert p (set ps \\<union> set Rs) = set Ps", "apply     assumption"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        VcgExSP.sorted (\\<le>) (map cont Rs);\n        insert p (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        VcgExSP.sorted (\\<le>) (map cont Qs); set Qs = insert p (set Rs);\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set ps. nexta x = next x\n 2. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        VcgExSP.sorted (\\<le>) (map cont Rs);\n        insert p (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        VcgExSP.sorted (\\<le>) (map cont Qs); set Qs = insert p (set Rs);\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> p \\<notin> set ps\n 3. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        VcgExSP.sorted (\\<le>) (map cont Rs);\n        insert p (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        VcgExSP.sorted (\\<le>) (map cont Qs); set Qs = insert p (set Rs);\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> set ps \\<inter> set Rs = {}\n 4. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        VcgExSP.sorted (\\<le>) (map cont Rs);\n        insert p (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        VcgExSP.sorted (\\<le>) (map cont Qs); set Qs = insert p (set Rs);\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> insert p (set ps \\<union> set Rs) = set Ps", "apply    clarsimp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>cont Ps next p r ps Rs nexta pa Qs x.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        VcgExSP.sorted (\\<le>) (map cont Rs);\n        insert p (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        VcgExSP.sorted (\\<le>) (map cont Qs); set Qs = insert p (set Rs);\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x;\n        x \\<in> set ps\\<rbrakk>\n       \\<Longrightarrow> nexta x = next x\n 2. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        VcgExSP.sorted (\\<le>) (map cont Rs);\n        insert p (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        VcgExSP.sorted (\\<le>) (map cont Qs); set Qs = insert p (set Rs);\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> p \\<notin> set ps\n 3. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        VcgExSP.sorted (\\<le>) (map cont Rs);\n        insert p (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        VcgExSP.sorted (\\<le>) (map cont Qs); set Qs = insert p (set Rs);\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> set ps \\<inter> set Rs = {}\n 4. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        VcgExSP.sorted (\\<le>) (map cont Rs);\n        insert p (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        VcgExSP.sorted (\\<le>) (map cont Qs); set Qs = insert p (set Rs);\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> insert p (set ps \\<union> set Rs) = set Ps", "apply    (subgoal_tac \"x\\<noteq>p \\<and> x \\<notin> set Rs\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>cont Ps next p r ps Rs nexta pa Qs x.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        VcgExSP.sorted (\\<le>) (map cont Rs);\n        insert p (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        VcgExSP.sorted (\\<le>) (map cont Qs); set Qs = insert p (set Rs);\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x;\n        x \\<in> set ps; x \\<noteq> p \\<and> x \\<notin> set Rs\\<rbrakk>\n       \\<Longrightarrow> nexta x = next x\n 2. \\<And>cont Ps next p r ps Rs nexta pa Qs x.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        VcgExSP.sorted (\\<le>) (map cont Rs);\n        insert p (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        VcgExSP.sorted (\\<le>) (map cont Qs); set Qs = insert p (set Rs);\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x;\n        x \\<in> set ps\\<rbrakk>\n       \\<Longrightarrow> x \\<noteq> p \\<and> x \\<notin> set Rs\n 3. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        VcgExSP.sorted (\\<le>) (map cont Rs);\n        insert p (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        VcgExSP.sorted (\\<le>) (map cont Qs); set Qs = insert p (set Rs);\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> p \\<notin> set ps\n 4. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        VcgExSP.sorted (\\<le>) (map cont Rs);\n        insert p (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        VcgExSP.sorted (\\<le>) (map cont Qs); set Qs = insert p (set Rs);\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> set ps \\<inter> set Rs = {}\n 5. \\<And>cont Ps next p r ps Rs nexta pa Qs.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List r next Rs;\n        VcgExSP.sorted (\\<le>) (map cont Rs);\n        insert p (set ps \\<union> set Rs) = set Ps; p \\<notin> set Rs;\n        set ps \\<inter> set Rs = {}; List pa nexta Qs;\n        VcgExSP.sorted (\\<le>) (map cont Qs); set Qs = insert p (set Rs);\n        \\<forall>x.\n           x \\<noteq> p \\<and> x \\<notin> set Rs \\<longrightarrow>\n           nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> insert p (set ps \\<union> set Rs) = set Ps", "apply     auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \"Memory Allocation and Deallocation\""], ["", "text \\<open>The basic idea of memory management is to keep a list of allocated\nreferences in the state space. Allocation of a new reference adds a\nnew reference to the list deallocation removes a reference. Moreover\nwe keep a counter \"free\" for the free memory.\n\\<close>"], ["", "(*\nrecord globals_list_alloc = globals_list +\n  alloc_'::\"ref list\"\n  free_'::nat\n\nrecord 'g list_vars' = \"'g list_vars\" +\n  i_'::nat\n  first_'::ref\n*)"], ["", "hoarestate globals_list_alloc =\n  alloc::\"ref list\"\n  free::nat\n  \"next\"::\"ref \\<Rightarrow> ref\"\n  cont::\"ref \\<Rightarrow> nat\""], ["", "hoarestate locals_list_alloc =\n  i::nat\n  first::ref\n  p::ref\n  q::ref\n  r::ref\n  root::ref\n  tmp::ref"], ["", "locale list_alloc = globals_list_alloc + locals_list_alloc"], ["", "definition \"sz = (2::nat)\""], ["", "lemma (in list_alloc)\n shows\n  \"\\<Gamma>,\\<Theta>\\<turnstile> \\<lbrace>\\<acute>i = 0 \\<and> \\<acute>first = Null \\<and> n*sz \\<le> \\<acute>free\\<rbrace>\n       WHILE \\<acute>i < n\n       INV \\<lbrace>\\<exists>Ps. List \\<acute>first \\<acute>next Ps \\<and> length Ps = \\<acute>i \\<and> \\<acute>i \\<le> n \\<and>\n             set Ps \\<subseteq> set \\<acute>alloc \\<and> (n - \\<acute>i)*sz \\<le> \\<acute>free\\<rbrace>\n       DO\n         \\<acute>p :== NEW sz [\\<acute>cont:==0,\\<acute>next:== Null];;\n         \\<acute>p\\<rightarrow>\\<acute>next :== \\<acute>first;;\n         \\<acute>first :== \\<acute>p;;\n         \\<acute>i :== \\<acute>i+ 1\n       OD\n       \\<lbrace>\\<exists>Ps. List \\<acute>first \\<acute>next  Ps \\<and> length Ps = n \\<and> set Ps \\<subseteq> set \\<acute>alloc\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile> \\<lbrace>\\<acute>i = 0 \\<and>\n                             \\<acute>first = Null \\<and>\n                             n * sz \\<le> \\<acute>free\\<rbrace>\n                    WHILE \\<acute>i < n\n                    INV \\<lbrace>\\<exists>Ps.\n                                    List \\<acute>first \\<acute>next\n                                     Ps \\<and>\n                                    length Ps = \\<acute>i \\<and>\n                                    \\<acute>i \\<le> n \\<and>\n                                    set Ps\n                                    \\<subseteq> set \\<acute>alloc \\<and>\n                                    (n - \\<acute>i) * sz\n                                    \\<le> \\<acute>free\\<rbrace> \n                    DO \\<acute>p :==\n                        NEW sz [\\<acute>cont :== 0, \\<acute>next :== Null];;\n                       \\<acute>p\\<rightarrow>\\<acute>next :==\n                       \\<acute>first;;\n                       \\<acute>first :== \\<acute>p;;\n                       \\<acute>i :== \\<acute>i + 1 \n                    OD\n                    \\<lbrace>\\<exists>Ps.\n                                List \\<acute>first \\<acute>next Ps \\<and>\n                                length Ps = n \\<and>\n                                set Ps\n                                \\<subseteq> set \\<acute>alloc\\<rbrace>", "apply (vcg)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>alloc free next first i.\n       \\<lbrakk>i = 0; first = Null; n * sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps.\n                            List first next Ps \\<and>\n                            length Ps = i \\<and>\n                            i \\<le> n \\<and>\n                            set Ps \\<subseteq> set alloc \\<and>\n                            (n - i) * sz \\<le> free\n 2. \\<And>alloc free next first i.\n       \\<lbrakk>\\<exists>Ps.\n                   List first next Ps \\<and>\n                   length Ps = i \\<and>\n                   i \\<le> n \\<and>\n                   set Ps \\<subseteq> set alloc \\<and>\n                   (n - i) * sz \\<le> free;\n        i < n\\<rbrakk>\n       \\<Longrightarrow> (sz \\<le> free \\<longrightarrow>\n                          (\\<exists>Ps.\n                              List (new (set alloc))\n                               (next\n                                (new (set alloc) := Null,\n                                 new (set alloc) := first))\n                               Ps \\<and>\n                              length Ps = i + 1 \\<and>\n                              i + 1 \\<le> n \\<and>\n                              set Ps\n                              \\<subseteq> set\n     (new (set alloc) # alloc) \\<and>\n                              (n - (i + 1)) * sz \\<le> free - sz)) \\<and>\n                         (\\<not> sz \\<le> free \\<longrightarrow>\n                          (\\<exists>Ps.\n                              List Null (next(Null := first)) Ps \\<and>\n                              length Ps = i + 1 \\<and>\n                              i + 1 \\<le> n \\<and>\n                              set Ps \\<subseteq> set alloc \\<and>\n                              (n - (i + 1)) * sz \\<le> free))\n 3. \\<And>alloc free next first i.\n       \\<lbrakk>\\<exists>Ps.\n                   List first next Ps \\<and>\n                   length Ps = i \\<and>\n                   i \\<le> n \\<and>\n                   set Ps \\<subseteq> set alloc \\<and>\n                   (n - i) * sz \\<le> free;\n        \\<not> i < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps.\n                            List first next Ps \\<and>\n                            length Ps = n \\<and>\n                            set Ps \\<subseteq> set alloc", "apply   simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>alloc free next first i.\n       \\<lbrakk>\\<exists>Ps.\n                   List first next Ps \\<and>\n                   length Ps = i \\<and>\n                   i \\<le> n \\<and>\n                   set Ps \\<subseteq> set alloc \\<and>\n                   (n - i) * sz \\<le> free;\n        i < n\\<rbrakk>\n       \\<Longrightarrow> (sz \\<le> free \\<longrightarrow>\n                          (\\<exists>Ps.\n                              List (new (set alloc))\n                               (next\n                                (new (set alloc) := Null,\n                                 new (set alloc) := first))\n                               Ps \\<and>\n                              length Ps = i + 1 \\<and>\n                              i + 1 \\<le> n \\<and>\n                              set Ps\n                              \\<subseteq> set\n     (new (set alloc) # alloc) \\<and>\n                              (n - (i + 1)) * sz \\<le> free - sz)) \\<and>\n                         (\\<not> sz \\<le> free \\<longrightarrow>\n                          (\\<exists>Ps.\n                              List Null (next(Null := first)) Ps \\<and>\n                              length Ps = i + 1 \\<and>\n                              i + 1 \\<le> n \\<and>\n                              set Ps \\<subseteq> set alloc \\<and>\n                              (n - (i + 1)) * sz \\<le> free))\n 2. \\<And>alloc free next first i.\n       \\<lbrakk>\\<exists>Ps.\n                   List first next Ps \\<and>\n                   length Ps = i \\<and>\n                   i \\<le> n \\<and>\n                   set Ps \\<subseteq> set alloc \\<and>\n                   (n - i) * sz \\<le> free;\n        \\<not> i < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps.\n                            List first next Ps \\<and>\n                            length Ps = n \\<and>\n                            set Ps \\<subseteq> set alloc", "apply  clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc;\n        (n - length Ps) * sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> (sz \\<le> free \\<longrightarrow>\n                          (\\<exists>Psa.\n                              (\\<exists>ps.\n                                  Psa = new (set alloc) # ps \\<and>\n                                  List first\n                                   (next(new (set alloc) := first))\n                                   ps) \\<and>\n                              length Psa = Suc (length Ps) \\<and>\n                              set Psa\n                              \\<subseteq> insert (new (set alloc))\n     (set alloc) \\<and>\n                              (n - Suc (length Ps)) * sz\n                              \\<le> free - sz)) \\<and>\n                         sz \\<le> free\n 2. \\<And>alloc free next first i.\n       \\<lbrakk>\\<exists>Ps.\n                   List first next Ps \\<and>\n                   length Ps = i \\<and>\n                   i \\<le> n \\<and>\n                   set Ps \\<subseteq> set alloc \\<and>\n                   (n - i) * sz \\<le> free;\n        \\<not> i < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps.\n                            List first next Ps \\<and>\n                            length Ps = n \\<and>\n                            set Ps \\<subseteq> set alloc", "apply  (rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc;\n        (n - length Ps) * sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> sz \\<le> free \\<longrightarrow>\n                         (\\<exists>Psa.\n                             (\\<exists>ps.\n                                 Psa = new (set alloc) # ps \\<and>\n                                 List first (next(new (set alloc) := first))\n                                  ps) \\<and>\n                             length Psa = Suc (length Ps) \\<and>\n                             set Psa\n                             \\<subseteq> insert (new (set alloc))\n    (set alloc) \\<and>\n                             (n - Suc (length Ps)) * sz \\<le> free - sz)\n 2. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc;\n        (n - length Ps) * sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> sz \\<le> free\n 3. \\<And>alloc free next first i.\n       \\<lbrakk>\\<exists>Ps.\n                   List first next Ps \\<and>\n                   length Ps = i \\<and>\n                   i \\<le> n \\<and>\n                   set Ps \\<subseteq> set alloc \\<and>\n                   (n - i) * sz \\<le> free;\n        \\<not> i < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps.\n                            List first next Ps \\<and>\n                            length Ps = n \\<and>\n                            set Ps \\<subseteq> set alloc", "apply   clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc; (n - length Ps) * sz \\<le> free;\n        sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            (\\<exists>ps.\n                                Psa = new (set alloc) # ps \\<and>\n                                List first (next(new (set alloc) := first))\n                                 ps) \\<and>\n                            length Psa = Suc (length Ps) \\<and>\n                            set Psa\n                            \\<subseteq> insert (new (set alloc))\n   (set alloc) \\<and>\n                            (n - Suc (length Ps)) * sz \\<le> free - sz\n 2. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc;\n        (n - length Ps) * sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> sz \\<le> free\n 3. \\<And>alloc free next first i.\n       \\<lbrakk>\\<exists>Ps.\n                   List first next Ps \\<and>\n                   length Ps = i \\<and>\n                   i \\<le> n \\<and>\n                   set Ps \\<subseteq> set alloc \\<and>\n                   (n - i) * sz \\<le> free;\n        \\<not> i < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps.\n                            List first next Ps \\<and>\n                            length Ps = n \\<and>\n                            set Ps \\<subseteq> set alloc", "apply   (rule_tac x=\"new (set alloc)#Ps\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc; (n - length Ps) * sz \\<le> free;\n        sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ps.\n                             new (set alloc) # Ps =\n                             new (set alloc) # ps \\<and>\n                             List first (next(new (set alloc) := first))\n                              ps) \\<and>\n                         length (new (set alloc) # Ps) =\n                         Suc (length Ps) \\<and>\n                         set (new (set alloc) # Ps)\n                         \\<subseteq> insert (new (set alloc))\n(set alloc) \\<and>\n                         (n - Suc (length Ps)) * sz \\<le> free - sz\n 2. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc;\n        (n - length Ps) * sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> sz \\<le> free\n 3. \\<And>alloc free next first i.\n       \\<lbrakk>\\<exists>Ps.\n                   List first next Ps \\<and>\n                   length Ps = i \\<and>\n                   i \\<le> n \\<and>\n                   set Ps \\<subseteq> set alloc \\<and>\n                   (n - i) * sz \\<le> free;\n        \\<not> i < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps.\n                            List first next Ps \\<and>\n                            length Ps = n \\<and>\n                            set Ps \\<subseteq> set alloc", "apply   clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc; (n - length Ps) * sz \\<le> free;\n        sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> set Ps\n                         \\<subseteq> insert (new (set alloc))\n(set alloc) \\<and>\n                         (n - Suc (length Ps)) * sz \\<le> free - sz\n 2. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc;\n        (n - length Ps) * sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> sz \\<le> free\n 3. \\<And>alloc free next first i.\n       \\<lbrakk>\\<exists>Ps.\n                   List first next Ps \\<and>\n                   length Ps = i \\<and>\n                   i \\<le> n \\<and>\n                   set Ps \\<subseteq> set alloc \\<and>\n                   (n - i) * sz \\<le> free;\n        \\<not> i < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps.\n                            List first next Ps \\<and>\n                            length Ps = n \\<and>\n                            set Ps \\<subseteq> set alloc", "apply   (rule conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc; (n - length Ps) * sz \\<le> free;\n        sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> set Ps\n                         \\<subseteq> insert (new (set alloc)) (set alloc)\n 2. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc; (n - length Ps) * sz \\<le> free;\n        sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> (n - Suc (length Ps)) * sz \\<le> free - sz\n 3. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc;\n        (n - length Ps) * sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> sz \\<le> free\n 4. \\<And>alloc free next first i.\n       \\<lbrakk>\\<exists>Ps.\n                   List first next Ps \\<and>\n                   length Ps = i \\<and>\n                   i \\<le> n \\<and>\n                   set Ps \\<subseteq> set alloc \\<and>\n                   (n - i) * sz \\<le> free;\n        \\<not> i < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps.\n                            List first next Ps \\<and>\n                            length Ps = n \\<and>\n                            set Ps \\<subseteq> set alloc", "apply    fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc; (n - length Ps) * sz \\<le> free;\n        sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> (n - Suc (length Ps)) * sz \\<le> free - sz\n 2. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc;\n        (n - length Ps) * sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> sz \\<le> free\n 3. \\<And>alloc free next first i.\n       \\<lbrakk>\\<exists>Ps.\n                   List first next Ps \\<and>\n                   length Ps = i \\<and>\n                   i \\<le> n \\<and>\n                   set Ps \\<subseteq> set alloc \\<and>\n                   (n - i) * sz \\<le> free;\n        \\<not> i < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps.\n                            List first next Ps \\<and>\n                            length Ps = n \\<and>\n                            set Ps \\<subseteq> set alloc", "apply   (simp add: sz_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc;\n        (n - length Ps) * sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> sz \\<le> free\n 2. \\<And>alloc free next first i.\n       \\<lbrakk>\\<exists>Ps.\n                   List first next Ps \\<and>\n                   length Ps = i \\<and>\n                   i \\<le> n \\<and>\n                   set Ps \\<subseteq> set alloc \\<and>\n                   (n - i) * sz \\<le> free;\n        \\<not> i < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps.\n                            List first next Ps \\<and>\n                            length Ps = n \\<and>\n                            set Ps \\<subseteq> set alloc", "apply  (simp add: sz_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>alloc free next first i.\n       \\<lbrakk>\\<exists>Ps.\n                   List first next Ps \\<and>\n                   length Ps = i \\<and>\n                   i \\<le> n \\<and>\n                   set Ps \\<subseteq> set alloc \\<and>\n                   (n - i) * sz \\<le> free;\n        \\<not> i < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps.\n                            List first next Ps \\<and>\n                            length Ps = n \\<and>\n                            set Ps \\<subseteq> set alloc", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in list_alloc)\n shows\n  \"\\<Gamma>\\<turnstile> \\<lbrace>\\<acute>i = 0 \\<and> \\<acute>first = Null \\<and> n*sz \\<le> \\<acute>free\\<rbrace>\n       WHILE \\<acute>i < n\n       INV \\<lbrace>\\<exists>Ps. List \\<acute>first \\<acute>next Ps \\<and> length Ps = \\<acute>i \\<and> \\<acute>i \\<le> n \\<and>\n             set Ps \\<subseteq> set \\<acute>alloc \\<and> (n - \\<acute>i)*sz \\<le> \\<acute>free\\<rbrace>\n       DO\n         \\<acute>p :== NNEW sz [\\<acute>cont:==0,\\<acute>next:== Null];;\n         \\<acute>p\\<rightarrow>\\<acute>next :== \\<acute>first;;\n         \\<acute>first :== \\<acute>p;;\n         \\<acute>i :== \\<acute>i+ 1\n       OD\n       \\<lbrace>\\<exists>Ps. List \\<acute>first \\<acute>next  Ps \\<and> length Ps = n \\<and> set Ps \\<subseteq> set \\<acute>alloc\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>\\<acute>i = 0 \\<and>\n                             \\<acute>first = Null \\<and>\n                             n * sz \\<le> \\<acute>free\\<rbrace>\n                    WHILE \\<acute>i < n\n                    INV \\<lbrace>\\<exists>Ps.\n                                    List \\<acute>first \\<acute>next\n                                     Ps \\<and>\n                                    length Ps = \\<acute>i \\<and>\n                                    \\<acute>i \\<le> n \\<and>\n                                    set Ps\n                                    \\<subseteq> set \\<acute>alloc \\<and>\n                                    (n - \\<acute>i) * sz\n                                    \\<le> \\<acute>free\\<rbrace> \n                    DO \\<acute>p :==\n                        NNEW sz [\\<acute>cont :== 0,\n                         \\<acute>next :== Null];;\n                       \\<acute>p\\<rightarrow>\\<acute>next :==\n                       \\<acute>first;;\n                       \\<acute>first :== \\<acute>p;;\n                       \\<acute>i :== \\<acute>i + 1 \n                    OD\n                    \\<lbrace>\\<exists>Ps.\n                                List \\<acute>first \\<acute>next Ps \\<and>\n                                length Ps = n \\<and>\n                                set Ps\n                                \\<subseteq> set \\<acute>alloc\\<rbrace>", "apply (vcg)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>alloc free next first i.\n       \\<lbrakk>i = 0; first = Null; n * sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps.\n                            List first next Ps \\<and>\n                            length Ps = i \\<and>\n                            i \\<le> n \\<and>\n                            set Ps \\<subseteq> set alloc \\<and>\n                            (n - i) * sz \\<le> free\n 2. \\<And>alloc free next first i.\n       \\<lbrakk>\\<exists>Ps.\n                   List first next Ps \\<and>\n                   length Ps = i \\<and>\n                   i \\<le> n \\<and>\n                   set Ps \\<subseteq> set alloc \\<and>\n                   (n - i) * sz \\<le> free;\n        i < n\\<rbrakk>\n       \\<Longrightarrow> (sz \\<le> free \\<longrightarrow>\n                          (\\<exists>Ps.\n                              List (new (set alloc))\n                               (next\n                                (new (set alloc) := Null,\n                                 new (set alloc) := first))\n                               Ps \\<and>\n                              length Ps = i + 1 \\<and>\n                              i + 1 \\<le> n \\<and>\n                              set Ps\n                              \\<subseteq> set\n     (new (set alloc) # alloc) \\<and>\n                              (n - (i + 1)) * sz \\<le> free - sz)) \\<and>\n                         (\\<not> sz \\<le> free \\<longrightarrow>\n                          (\\<exists>Ps.\n                              List Null (next(Null := first)) Ps \\<and>\n                              length Ps = i + 1 \\<and>\n                              i + 1 \\<le> n \\<and>\n                              set Ps \\<subseteq> set alloc \\<and>\n                              (n - (i + 1)) * sz \\<le> free) \\<and>\n                          (\\<exists>Ps.\n                              List (new (set alloc))\n                               (next\n                                (new (set alloc) := Null,\n                                 new (set alloc) := first))\n                               Ps \\<and>\n                              length Ps = i + 1 \\<and>\n                              i + 1 \\<le> n \\<and>\n                              set Ps\n                              \\<subseteq> set\n     (new (set alloc) # alloc) \\<and>\n                              (n - (i + 1)) * sz \\<le> free - sz))\n 3. \\<And>alloc free next first i.\n       \\<lbrakk>\\<exists>Ps.\n                   List first next Ps \\<and>\n                   length Ps = i \\<and>\n                   i \\<le> n \\<and>\n                   set Ps \\<subseteq> set alloc \\<and>\n                   (n - i) * sz \\<le> free;\n        \\<not> i < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps.\n                            List first next Ps \\<and>\n                            length Ps = n \\<and>\n                            set Ps \\<subseteq> set alloc", "apply   simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>alloc free next first i.\n       \\<lbrakk>\\<exists>Ps.\n                   List first next Ps \\<and>\n                   length Ps = i \\<and>\n                   i \\<le> n \\<and>\n                   set Ps \\<subseteq> set alloc \\<and>\n                   (n - i) * sz \\<le> free;\n        i < n\\<rbrakk>\n       \\<Longrightarrow> (sz \\<le> free \\<longrightarrow>\n                          (\\<exists>Ps.\n                              List (new (set alloc))\n                               (next\n                                (new (set alloc) := Null,\n                                 new (set alloc) := first))\n                               Ps \\<and>\n                              length Ps = i + 1 \\<and>\n                              i + 1 \\<le> n \\<and>\n                              set Ps\n                              \\<subseteq> set\n     (new (set alloc) # alloc) \\<and>\n                              (n - (i + 1)) * sz \\<le> free - sz)) \\<and>\n                         (\\<not> sz \\<le> free \\<longrightarrow>\n                          (\\<exists>Ps.\n                              List Null (next(Null := first)) Ps \\<and>\n                              length Ps = i + 1 \\<and>\n                              i + 1 \\<le> n \\<and>\n                              set Ps \\<subseteq> set alloc \\<and>\n                              (n - (i + 1)) * sz \\<le> free) \\<and>\n                          (\\<exists>Ps.\n                              List (new (set alloc))\n                               (next\n                                (new (set alloc) := Null,\n                                 new (set alloc) := first))\n                               Ps \\<and>\n                              length Ps = i + 1 \\<and>\n                              i + 1 \\<le> n \\<and>\n                              set Ps\n                              \\<subseteq> set\n     (new (set alloc) # alloc) \\<and>\n                              (n - (i + 1)) * sz \\<le> free - sz))\n 2. \\<And>alloc free next first i.\n       \\<lbrakk>\\<exists>Ps.\n                   List first next Ps \\<and>\n                   length Ps = i \\<and>\n                   i \\<le> n \\<and>\n                   set Ps \\<subseteq> set alloc \\<and>\n                   (n - i) * sz \\<le> free;\n        \\<not> i < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps.\n                            List first next Ps \\<and>\n                            length Ps = n \\<and>\n                            set Ps \\<subseteq> set alloc", "apply  clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc;\n        (n - length Ps) * sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> (sz \\<le> free \\<longrightarrow>\n                          (\\<exists>Psa.\n                              (\\<exists>ps.\n                                  Psa = new (set alloc) # ps \\<and>\n                                  List first\n                                   (next(new (set alloc) := first))\n                                   ps) \\<and>\n                              length Psa = Suc (length Ps) \\<and>\n                              set Psa\n                              \\<subseteq> insert (new (set alloc))\n     (set alloc) \\<and>\n                              (n - Suc (length Ps)) * sz\n                              \\<le> free - sz)) \\<and>\n                         sz \\<le> free\n 2. \\<And>alloc free next first i.\n       \\<lbrakk>\\<exists>Ps.\n                   List first next Ps \\<and>\n                   length Ps = i \\<and>\n                   i \\<le> n \\<and>\n                   set Ps \\<subseteq> set alloc \\<and>\n                   (n - i) * sz \\<le> free;\n        \\<not> i < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps.\n                            List first next Ps \\<and>\n                            length Ps = n \\<and>\n                            set Ps \\<subseteq> set alloc", "apply  (rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc;\n        (n - length Ps) * sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> sz \\<le> free \\<longrightarrow>\n                         (\\<exists>Psa.\n                             (\\<exists>ps.\n                                 Psa = new (set alloc) # ps \\<and>\n                                 List first (next(new (set alloc) := first))\n                                  ps) \\<and>\n                             length Psa = Suc (length Ps) \\<and>\n                             set Psa\n                             \\<subseteq> insert (new (set alloc))\n    (set alloc) \\<and>\n                             (n - Suc (length Ps)) * sz \\<le> free - sz)\n 2. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc;\n        (n - length Ps) * sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> sz \\<le> free\n 3. \\<And>alloc free next first i.\n       \\<lbrakk>\\<exists>Ps.\n                   List first next Ps \\<and>\n                   length Ps = i \\<and>\n                   i \\<le> n \\<and>\n                   set Ps \\<subseteq> set alloc \\<and>\n                   (n - i) * sz \\<le> free;\n        \\<not> i < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps.\n                            List first next Ps \\<and>\n                            length Ps = n \\<and>\n                            set Ps \\<subseteq> set alloc", "apply   clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc; (n - length Ps) * sz \\<le> free;\n        sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            (\\<exists>ps.\n                                Psa = new (set alloc) # ps \\<and>\n                                List first (next(new (set alloc) := first))\n                                 ps) \\<and>\n                            length Psa = Suc (length Ps) \\<and>\n                            set Psa\n                            \\<subseteq> insert (new (set alloc))\n   (set alloc) \\<and>\n                            (n - Suc (length Ps)) * sz \\<le> free - sz\n 2. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc;\n        (n - length Ps) * sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> sz \\<le> free\n 3. \\<And>alloc free next first i.\n       \\<lbrakk>\\<exists>Ps.\n                   List first next Ps \\<and>\n                   length Ps = i \\<and>\n                   i \\<le> n \\<and>\n                   set Ps \\<subseteq> set alloc \\<and>\n                   (n - i) * sz \\<le> free;\n        \\<not> i < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps.\n                            List first next Ps \\<and>\n                            length Ps = n \\<and>\n                            set Ps \\<subseteq> set alloc", "apply   (rule_tac x=\"new (set alloc)#Ps\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc; (n - length Ps) * sz \\<le> free;\n        sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ps.\n                             new (set alloc) # Ps =\n                             new (set alloc) # ps \\<and>\n                             List first (next(new (set alloc) := first))\n                              ps) \\<and>\n                         length (new (set alloc) # Ps) =\n                         Suc (length Ps) \\<and>\n                         set (new (set alloc) # Ps)\n                         \\<subseteq> insert (new (set alloc))\n(set alloc) \\<and>\n                         (n - Suc (length Ps)) * sz \\<le> free - sz\n 2. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc;\n        (n - length Ps) * sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> sz \\<le> free\n 3. \\<And>alloc free next first i.\n       \\<lbrakk>\\<exists>Ps.\n                   List first next Ps \\<and>\n                   length Ps = i \\<and>\n                   i \\<le> n \\<and>\n                   set Ps \\<subseteq> set alloc \\<and>\n                   (n - i) * sz \\<le> free;\n        \\<not> i < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps.\n                            List first next Ps \\<and>\n                            length Ps = n \\<and>\n                            set Ps \\<subseteq> set alloc", "apply   clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc; (n - length Ps) * sz \\<le> free;\n        sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> set Ps\n                         \\<subseteq> insert (new (set alloc))\n(set alloc) \\<and>\n                         (n - Suc (length Ps)) * sz \\<le> free - sz\n 2. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc;\n        (n - length Ps) * sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> sz \\<le> free\n 3. \\<And>alloc free next first i.\n       \\<lbrakk>\\<exists>Ps.\n                   List first next Ps \\<and>\n                   length Ps = i \\<and>\n                   i \\<le> n \\<and>\n                   set Ps \\<subseteq> set alloc \\<and>\n                   (n - i) * sz \\<le> free;\n        \\<not> i < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps.\n                            List first next Ps \\<and>\n                            length Ps = n \\<and>\n                            set Ps \\<subseteq> set alloc", "apply   (rule conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc; (n - length Ps) * sz \\<le> free;\n        sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> set Ps\n                         \\<subseteq> insert (new (set alloc)) (set alloc)\n 2. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc; (n - length Ps) * sz \\<le> free;\n        sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> (n - Suc (length Ps)) * sz \\<le> free - sz\n 3. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc;\n        (n - length Ps) * sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> sz \\<le> free\n 4. \\<And>alloc free next first i.\n       \\<lbrakk>\\<exists>Ps.\n                   List first next Ps \\<and>\n                   length Ps = i \\<and>\n                   i \\<le> n \\<and>\n                   set Ps \\<subseteq> set alloc \\<and>\n                   (n - i) * sz \\<le> free;\n        \\<not> i < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps.\n                            List first next Ps \\<and>\n                            length Ps = n \\<and>\n                            set Ps \\<subseteq> set alloc", "apply    fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc; (n - length Ps) * sz \\<le> free;\n        sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> (n - Suc (length Ps)) * sz \\<le> free - sz\n 2. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc;\n        (n - length Ps) * sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> sz \\<le> free\n 3. \\<And>alloc free next first i.\n       \\<lbrakk>\\<exists>Ps.\n                   List first next Ps \\<and>\n                   length Ps = i \\<and>\n                   i \\<le> n \\<and>\n                   set Ps \\<subseteq> set alloc \\<and>\n                   (n - i) * sz \\<le> free;\n        \\<not> i < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps.\n                            List first next Ps \\<and>\n                            length Ps = n \\<and>\n                            set Ps \\<subseteq> set alloc", "apply   (simp add: sz_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>alloc free next first Ps.\n       \\<lbrakk>length Ps < n; List first next Ps;\n        set Ps \\<subseteq> set alloc;\n        (n - length Ps) * sz \\<le> free\\<rbrakk>\n       \\<Longrightarrow> sz \\<le> free\n 2. \\<And>alloc free next first i.\n       \\<lbrakk>\\<exists>Ps.\n                   List first next Ps \\<and>\n                   length Ps = i \\<and>\n                   i \\<le> n \\<and>\n                   set Ps \\<subseteq> set alloc \\<and>\n                   (n - i) * sz \\<le> free;\n        \\<not> i < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps.\n                            List first next Ps \\<and>\n                            length Ps = n \\<and>\n                            set Ps \\<subseteq> set alloc", "apply  (simp add: sz_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>alloc free next first i.\n       \\<lbrakk>\\<exists>Ps.\n                   List first next Ps \\<and>\n                   length Ps = i \\<and>\n                   i \\<le> n \\<and>\n                   set Ps \\<subseteq> set alloc \\<and>\n                   (n - i) * sz \\<le> free;\n        \\<not> i < n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps.\n                            List first next Ps \\<and>\n                            length Ps = n \\<and>\n                            set Ps \\<subseteq> set alloc", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Fault Avoiding Semantics\\<close>"], ["", "text \\<open>\nIf we want to ensure that no runtime errors occur we can insert guards into\nthe code. We will not be able to prove any nontrivial Hoare triple\nabout code with guards, if we cannot show that the guards will never fail.\nA trivial Hoare triple is one with an empty precondtion.\n\\<close>"], ["", "lemma (in list_alloc) \"\\<Gamma>,\\<Theta>\\<turnstile> \\<lbrace>True\\<rbrace>  \\<lbrace>\\<acute>p\\<noteq>Null\\<rbrace>\\<longmapsto> \\<acute>p\\<rightarrow>\\<acute>next :== \\<acute>p \\<lbrace>True\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    (False, \\<lbrace>\\<acute>p \\<noteq> Null\\<rbrace>)\n                    \\<longmapsto> \\<acute>p\\<rightarrow>\\<acute>next :==\n                                  \\<acute>p\n                    \\<lbrace>True\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p. True \\<Longrightarrow> p \\<noteq> Null", "oops"], ["", "lemma (in list_alloc) \"\\<Gamma>,\\<Theta>\\<turnstile> {}  \\<lbrace>\\<acute>p\\<noteq>Null\\<rbrace>\\<longmapsto> \\<acute>p\\<rightarrow>\\<acute>next :== \\<acute>p \\<lbrace>True\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile> {} (False, \\<lbrace>\\<acute>p \\<noteq> Null\\<rbrace>)\n                       \\<longmapsto> \\<acute>p\\<rightarrow>\\<acute>next :==\n                                     \\<acute>p\n                    \\<lbrace>True\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Let us consider this small program that reverts a list. At\nfirst without guards.\n\\<close>"], ["", "lemma (in list_alloc)\n  shows\n  \"\\<Gamma>,\\<Theta>\\<turnstile> \\<lbrace>List \\<acute>p \\<acute>next Ps \\<and> List \\<acute>q \\<acute>next Qs \\<and> set Ps \\<inter> set Qs = {} \\<and>\n       set Ps \\<subseteq> set \\<acute>alloc \\<and> set Qs \\<subseteq> set \\<acute>alloc\\<rbrace>\n  WHILE \\<acute>p \\<noteq> Null\n  INV \\<lbrace>\\<exists>ps qs. List \\<acute>p \\<acute>next  ps \\<and> List \\<acute>q \\<acute>next qs \\<and> set ps \\<inter> set qs = {} \\<and>\n               rev ps @ qs = rev Ps @ Qs \\<and>\n               set ps \\<subseteq> set \\<acute>alloc \\<and> set qs \\<subseteq> set \\<acute>alloc\\<rbrace>\n  DO \\<acute>r :== \\<acute>p;;\n     \\<acute>p :== \\<acute>p\\<rightarrow> \\<acute>next;;\n     \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>q;;\n     \\<acute>q :== \\<acute>r OD\n  \\<lbrace>List \\<acute>q \\<acute>next (rev Ps @ Qs) \\<and> set Ps\\<subseteq> set \\<acute>alloc \\<and> set Qs \\<subseteq> set \\<acute>alloc\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile> \\<lbrace>List \\<acute>p \\<acute>next Ps \\<and>\n                             List \\<acute>q \\<acute>next Qs \\<and>\n                             set Ps \\<inter> set Qs = {} \\<and>\n                             set Ps \\<subseteq> set \\<acute>alloc \\<and>\n                             set Qs \\<subseteq> set \\<acute>alloc\\<rbrace>\n                    WHILE \\<acute>p \\<noteq> Null\n                    INV \\<lbrace>\\<exists>ps qs.\n                                    List \\<acute>p \\<acute>next ps \\<and>\n                                    List \\<acute>q \\<acute>next qs \\<and>\n                                    set ps \\<inter> set qs = {} \\<and>\n                                    rev ps @ qs = rev Ps @ Qs \\<and>\n                                    set ps\n                                    \\<subseteq> set \\<acute>alloc \\<and>\n                                    set qs\n                                    \\<subseteq> set \\<acute>alloc\\<rbrace> \n                    DO \\<acute>r :== \\<acute>p;;\n                       \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n                       \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>q;;\n                       \\<acute>q :== \\<acute>r \n                    OD\n                    \\<lbrace>List \\<acute>q \\<acute>next\n                              (rev Ps @ Qs) \\<and>\n                             set Ps \\<subseteq> set \\<acute>alloc \\<and>\n                             set Qs \\<subseteq> set \\<acute>alloc\\<rbrace>", "apply (vcg)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>alloc next p q.\n       \\<lbrakk>List p next Ps; List q next Qs; set Ps \\<inter> set Qs = {};\n        set Ps \\<subseteq> set alloc; set Qs \\<subseteq> set alloc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps qs.\n                            List p next ps \\<and>\n                            List q next qs \\<and>\n                            set ps \\<inter> set qs = {} \\<and>\n                            rev ps @ qs = rev Ps @ Qs \\<and>\n                            set ps \\<subseteq> set alloc \\<and>\n                            set qs \\<subseteq> set alloc\n 2. \\<And>alloc next p q.\n       \\<lbrakk>\\<exists>ps qs.\n                   List p next ps \\<and>\n                   List q next qs \\<and>\n                   set ps \\<inter> set qs = {} \\<and>\n                   rev ps @ qs = rev Ps @ Qs \\<and>\n                   set ps \\<subseteq> set alloc \\<and>\n                   set qs \\<subseteq> set alloc;\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps qs.\n                            List (next p) (next(p := q)) ps \\<and>\n                            List p (next(p := q)) qs \\<and>\n                            set ps \\<inter> set qs = {} \\<and>\n                            rev ps @ qs = rev Ps @ Qs \\<and>\n                            set ps \\<subseteq> set alloc \\<and>\n                            set qs \\<subseteq> set alloc\n 3. \\<And>alloc next p q.\n       \\<lbrakk>\\<exists>ps qs.\n                   List p next ps \\<and>\n                   List q next qs \\<and>\n                   set ps \\<inter> set qs = {} \\<and>\n                   rev ps @ qs = rev Ps @ Qs \\<and>\n                   set ps \\<subseteq> set alloc \\<and>\n                   set qs \\<subseteq> set alloc;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps @ Qs) \\<and>\n                         set Ps \\<subseteq> set alloc \\<and>\n                         set Qs \\<subseteq> set alloc", "apply fastforce+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>If we want to ensure that we do not dereference @{term \"Null\"} or\naccess unallocated memory, we have to add some guards.\n\\<close>"], ["", "lemma (in list_alloc)\n  shows\n  \"\\<Gamma>,\\<Theta>\\<turnstile> \\<lbrace>List \\<acute>p \\<acute>next Ps \\<and> List \\<acute>q \\<acute>next Qs \\<and> set Ps \\<inter> set Qs = {} \\<and>\n       set Ps \\<subseteq> set \\<acute>alloc \\<and> set Qs \\<subseteq> set \\<acute>alloc\\<rbrace>\n  WHILE \\<acute>p \\<noteq> Null\n  INV \\<lbrace>\\<exists>ps qs. List \\<acute>p \\<acute>next  ps \\<and> List \\<acute>q \\<acute>next qs \\<and> set ps \\<inter> set qs = {} \\<and>\n               rev ps @ qs = rev Ps @ Qs \\<and>\n               set ps \\<subseteq> set \\<acute>alloc \\<and> set qs \\<subseteq> set \\<acute>alloc\\<rbrace>\n  DO \\<acute>r :== \\<acute>p;;\n     \\<lbrace>\\<acute>p\\<noteq>Null \\<and> \\<acute>p\\<in>set \\<acute>alloc\\<rbrace>\\<longmapsto> \\<acute>p :== \\<acute>p\\<rightarrow> \\<acute>next;;\n     \\<lbrace>\\<acute>r\\<noteq>Null \\<and> \\<acute>r\\<in>set \\<acute>alloc\\<rbrace>\\<longmapsto> \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>q;;\n     \\<acute>q :== \\<acute>r OD\n \\<lbrace>List \\<acute>q \\<acute>next (rev Ps @ Qs) \\<and> set Ps \\<subseteq> set \\<acute>alloc \\<and> set Qs \\<subseteq> set \\<acute>alloc\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile> \\<lbrace>List \\<acute>p \\<acute>next Ps \\<and>\n                             List \\<acute>q \\<acute>next Qs \\<and>\n                             set Ps \\<inter> set Qs = {} \\<and>\n                             set Ps \\<subseteq> set \\<acute>alloc \\<and>\n                             set Qs \\<subseteq> set \\<acute>alloc\\<rbrace>\n                    WHILE \\<acute>p \\<noteq> Null\n                    INV \\<lbrace>\\<exists>ps qs.\n                                    List \\<acute>p \\<acute>next ps \\<and>\n                                    List \\<acute>q \\<acute>next qs \\<and>\n                                    set ps \\<inter> set qs = {} \\<and>\n                                    rev ps @ qs = rev Ps @ Qs \\<and>\n                                    set ps\n                                    \\<subseteq> set \\<acute>alloc \\<and>\n                                    set qs\n                                    \\<subseteq> set \\<acute>alloc\\<rbrace> \n                    DO \\<acute>r :== \\<acute>p;;\n                       (False,\n                        \\<lbrace>\\<acute>p \\<noteq> Null \\<and>\n                                 \\<acute>p \\<in> set \\<acute>alloc\\<rbrace>)\n                       \\<longmapsto> \\<acute>p :==\n                                     \\<acute>p\\<rightarrow>\\<acute>next;;\n                       (False,\n                        \\<lbrace>\\<acute>r \\<noteq> Null \\<and>\n                                 \\<acute>r \\<in> set \\<acute>alloc\\<rbrace>)\n                       \\<longmapsto> \\<acute>r\\<rightarrow>\\<acute>next :==\n                                     \\<acute>q;;\n                       \\<acute>q :== \\<acute>r \n                    OD\n                    \\<lbrace>List \\<acute>q \\<acute>next\n                              (rev Ps @ Qs) \\<and>\n                             set Ps \\<subseteq> set \\<acute>alloc \\<and>\n                             set Qs \\<subseteq> set \\<acute>alloc\\<rbrace>", "apply (vcg)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>alloc next p q.\n       \\<lbrakk>List p next Ps; List q next Qs; set Ps \\<inter> set Qs = {};\n        set Ps \\<subseteq> set alloc; set Qs \\<subseteq> set alloc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps qs.\n                            List p next ps \\<and>\n                            List q next qs \\<and>\n                            set ps \\<inter> set qs = {} \\<and>\n                            rev ps @ qs = rev Ps @ Qs \\<and>\n                            set ps \\<subseteq> set alloc \\<and>\n                            set qs \\<subseteq> set alloc\n 2. \\<And>alloc next p q.\n       \\<lbrakk>\\<exists>ps qs.\n                   List p next ps \\<and>\n                   List q next qs \\<and>\n                   set ps \\<inter> set qs = {} \\<and>\n                   rev ps @ qs = rev Ps @ Qs \\<and>\n                   set ps \\<subseteq> set alloc \\<and>\n                   set qs \\<subseteq> set alloc;\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> p \\<noteq> Null \\<and>\n                         p \\<in> set alloc \\<and>\n                         p \\<noteq> Null \\<and>\n                         p \\<in> set alloc \\<and>\n                         (\\<exists>ps qs.\n                             List (next p) (next(p := q)) ps \\<and>\n                             List p (next(p := q)) qs \\<and>\n                             set ps \\<inter> set qs = {} \\<and>\n                             rev ps @ qs = rev Ps @ Qs \\<and>\n                             set ps \\<subseteq> set alloc \\<and>\n                             set qs \\<subseteq> set alloc)\n 3. \\<And>alloc next p q.\n       \\<lbrakk>\\<exists>ps qs.\n                   List p next ps \\<and>\n                   List q next qs \\<and>\n                   set ps \\<inter> set qs = {} \\<and>\n                   rev ps @ qs = rev Ps @ Qs \\<and>\n                   set ps \\<subseteq> set alloc \\<and>\n                   set qs \\<subseteq> set alloc;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps @ Qs) \\<and>\n                         set Ps \\<subseteq> set alloc \\<and>\n                         set Qs \\<subseteq> set alloc", "apply fastforce+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>We can also just prove that no faults will occur, by giving the\ntrivial postcondition.\n\\<close>"], ["", "lemma (in list_alloc) rev_noFault:\n  shows\n  \"\\<Gamma>,\\<Theta>\\<turnstile> \\<lbrace>List \\<acute>p \\<acute>next Ps \\<and> List \\<acute>q \\<acute>next Qs \\<and> set Ps \\<inter> set Qs = {} \\<and>\n       set Ps \\<subseteq> set \\<acute>alloc \\<and> set Qs \\<subseteq> set \\<acute>alloc\\<rbrace>\n  WHILE \\<acute>p \\<noteq> Null\n  INV \\<lbrace>\\<exists>ps qs. List \\<acute>p \\<acute>next  ps \\<and> List \\<acute>q \\<acute>next qs \\<and> set ps \\<inter> set qs = {} \\<and>\n               rev ps @ qs = rev Ps @ Qs \\<and>\n               set ps \\<subseteq> set \\<acute>alloc \\<and> set qs \\<subseteq> set \\<acute>alloc\\<rbrace>\n  DO \\<acute>r :== \\<acute>p;;\n     \\<lbrace>\\<acute>p\\<noteq>Null \\<and> \\<acute>p\\<in>set \\<acute>alloc\\<rbrace>\\<longmapsto> \\<acute>p :== \\<acute>p\\<rightarrow> \\<acute>next;;\n     \\<lbrace>\\<acute>r\\<noteq>Null \\<and> \\<acute>r\\<in>set \\<acute>alloc\\<rbrace>\\<longmapsto> \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>q;;\n     \\<acute>q :== \\<acute>r OD\n  UNIV,UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile> \\<lbrace>List \\<acute>p \\<acute>next Ps \\<and>\n                             List \\<acute>q \\<acute>next Qs \\<and>\n                             set Ps \\<inter> set Qs = {} \\<and>\n                             set Ps \\<subseteq> set \\<acute>alloc \\<and>\n                             set Qs \\<subseteq> set \\<acute>alloc\\<rbrace>\n                    WHILE \\<acute>p \\<noteq> Null\n                    INV \\<lbrace>\\<exists>ps qs.\n                                    List \\<acute>p \\<acute>next ps \\<and>\n                                    List \\<acute>q \\<acute>next qs \\<and>\n                                    set ps \\<inter> set qs = {} \\<and>\n                                    rev ps @ qs = rev Ps @ Qs \\<and>\n                                    set ps\n                                    \\<subseteq> set \\<acute>alloc \\<and>\n                                    set qs\n                                    \\<subseteq> set \\<acute>alloc\\<rbrace> \n                    DO \\<acute>r :== \\<acute>p;;\n                       (False,\n                        \\<lbrace>\\<acute>p \\<noteq> Null \\<and>\n                                 \\<acute>p \\<in> set \\<acute>alloc\\<rbrace>)\n                       \\<longmapsto> \\<acute>p :==\n                                     \\<acute>p\\<rightarrow>\\<acute>next;;\n                       (False,\n                        \\<lbrace>\\<acute>r \\<noteq> Null \\<and>\n                                 \\<acute>r \\<in> set \\<acute>alloc\\<rbrace>)\n                       \\<longmapsto> \\<acute>r\\<rightarrow>\\<acute>next :==\n                                     \\<acute>q;;\n                       \\<acute>q :== \\<acute>r \n                    OD\n                    UNIV,UNIV", "apply (vcg)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>alloc next p q.\n       \\<lbrakk>List p next Ps; List q next Qs; set Ps \\<inter> set Qs = {};\n        set Ps \\<subseteq> set alloc; set Qs \\<subseteq> set alloc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps qs.\n                            List p next ps \\<and>\n                            List q next qs \\<and>\n                            set ps \\<inter> set qs = {} \\<and>\n                            rev ps @ qs = rev Ps @ Qs \\<and>\n                            set ps \\<subseteq> set alloc \\<and>\n                            set qs \\<subseteq> set alloc\n 2. \\<And>alloc next p q.\n       \\<lbrakk>\\<exists>ps qs.\n                   List p next ps \\<and>\n                   List q next qs \\<and>\n                   set ps \\<inter> set qs = {} \\<and>\n                   rev ps @ qs = rev Ps @ Qs \\<and>\n                   set ps \\<subseteq> set alloc \\<and>\n                   set qs \\<subseteq> set alloc;\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> p \\<noteq> Null \\<and>\n                         p \\<in> set alloc \\<and>\n                         p \\<noteq> Null \\<and>\n                         p \\<in> set alloc \\<and>\n                         (\\<exists>ps qs.\n                             List (next p) (next(p := q)) ps \\<and>\n                             List p (next(p := q)) qs \\<and>\n                             set ps \\<inter> set qs = {} \\<and>\n                             rev ps @ qs = rev Ps @ Qs \\<and>\n                             set ps \\<subseteq> set alloc \\<and>\n                             set qs \\<subseteq> set alloc)\n 3. \\<lbrace>(\\<exists>ps qs.\n                 List \\<acute>p \\<acute>next ps \\<and>\n                 List \\<acute>q \\<acute>next qs \\<and>\n                 set ps \\<inter> set qs = {} \\<and>\n                 rev ps @ qs = rev Ps @ Qs \\<and>\n                 set ps \\<subseteq> set \\<acute>alloc \\<and>\n                 set qs \\<subseteq> set \\<acute>alloc) \\<and>\n             \\<not> \\<acute>p \\<noteq> Null\\<rbrace>\n    \\<subseteq> UNIV", "apply fastforce+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in list_alloc) rev_moduloGuards:\n\n  shows\n  \"\\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/{True}\\<^esub> \\<lbrace>List \\<acute>p \\<acute>next Ps \\<and> List \\<acute>q \\<acute>next Qs \\<and> set Ps \\<inter> set Qs = {} \\<and>\n       set Ps \\<subseteq> set \\<acute>alloc \\<and> set Qs \\<subseteq> set \\<acute>alloc\\<rbrace>\n  WHILE \\<acute>p \\<noteq> Null\n  INV \\<lbrace>\\<exists>ps qs. List \\<acute>p \\<acute>next  ps \\<and> List \\<acute>q \\<acute>next qs \\<and> set ps \\<inter> set qs = {} \\<and>\n               rev ps @ qs = rev Ps @ Qs \\<and>\n               set ps \\<subseteq> set \\<acute>alloc \\<and> set qs \\<subseteq> set \\<acute>alloc\\<rbrace>\n  DO \\<acute>r :== \\<acute>p;;\n     \\<lbrace>\\<acute>p\\<noteq>Null \\<and> \\<acute>p\\<in>set \\<acute>alloc\\<rbrace>\\<surd> \\<longmapsto> \\<acute>p :== \\<acute>p\\<rightarrow> \\<acute>next;;\n     \\<lbrace>\\<acute>r\\<noteq>Null \\<and> \\<acute>r\\<in>set \\<acute>alloc\\<rbrace>\\<surd> \\<longmapsto> \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>q;;\n     \\<acute>q :== \\<acute>r OD\n \\<lbrace>List \\<acute>q \\<acute>next (rev Ps @ Qs) \\<and> set Ps \\<subseteq> set \\<acute>alloc \\<and> set Qs \\<subseteq> set \\<acute>alloc\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile>\\<^bsub>/{True}\\<^esub> \\<lbrace>List \\<acute>p\n               \\<acute>next Ps \\<and>\n              List \\<acute>q \\<acute>next Qs \\<and>\n              set Ps \\<inter> set Qs = {} \\<and>\n              set Ps \\<subseteq> set \\<acute>alloc \\<and>\n              set Qs \\<subseteq> set \\<acute>alloc\\<rbrace>\n     WHILE \\<acute>p \\<noteq> Null\n     INV \\<lbrace>\\<exists>ps qs.\n                     List \\<acute>p \\<acute>next ps \\<and>\n                     List \\<acute>q \\<acute>next qs \\<and>\n                     set ps \\<inter> set qs = {} \\<and>\n                     rev ps @ qs = rev Ps @ Qs \\<and>\n                     set ps \\<subseteq> set \\<acute>alloc \\<and>\n                     set qs \\<subseteq> set \\<acute>alloc\\<rbrace> \n     DO \\<acute>r :== \\<acute>p;;\n        (True,\n         \\<lbrace>\\<acute>p \\<noteq> Null \\<and>\n                  \\<acute>p \\<in> set \\<acute>alloc\\<rbrace>)\n        \\<longmapsto> \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n        (True,\n         \\<lbrace>\\<acute>r \\<noteq> Null \\<and>\n                  \\<acute>r \\<in> set \\<acute>alloc\\<rbrace>)\n        \\<longmapsto> \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>q;;\n        \\<acute>q :== \\<acute>r \n     OD\n     \\<lbrace>List \\<acute>q \\<acute>next (rev Ps @ Qs) \\<and>\n              set Ps \\<subseteq> set \\<acute>alloc \\<and>\n              set Qs \\<subseteq> set \\<acute>alloc\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>alloc next p q.\n       \\<lbrakk>List p next Ps; List q next Qs; set Ps \\<inter> set Qs = {};\n        set Ps \\<subseteq> set alloc; set Qs \\<subseteq> set alloc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps qs.\n                            List p next ps \\<and>\n                            List q next qs \\<and>\n                            set ps \\<inter> set qs = {} \\<and>\n                            rev ps @ qs = rev Ps @ Qs \\<and>\n                            set ps \\<subseteq> set alloc \\<and>\n                            set qs \\<subseteq> set alloc\n 2. \\<And>alloc next p q.\n       \\<lbrakk>\\<exists>ps qs.\n                   List p next ps \\<and>\n                   List q next qs \\<and>\n                   set ps \\<inter> set qs = {} \\<and>\n                   rev ps @ qs = rev Ps @ Qs \\<and>\n                   set ps \\<subseteq> set alloc \\<and>\n                   set qs \\<subseteq> set alloc;\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> p \\<noteq> Null \\<and>\n                         p \\<in> set alloc \\<longrightarrow>\n                         p \\<noteq> Null \\<and>\n                         p \\<in> set alloc \\<longrightarrow>\n                         (\\<exists>ps qs.\n                             List (next p) (next(p := q)) ps \\<and>\n                             List p (next(p := q)) qs \\<and>\n                             set ps \\<inter> set qs = {} \\<and>\n                             rev ps @ qs = rev Ps @ Qs \\<and>\n                             set ps \\<subseteq> set alloc \\<and>\n                             set qs \\<subseteq> set alloc)\n 3. \\<And>alloc next p q.\n       \\<lbrakk>\\<exists>ps qs.\n                   List p next ps \\<and>\n                   List q next qs \\<and>\n                   set ps \\<inter> set qs = {} \\<and>\n                   rev ps @ qs = rev Ps @ Qs \\<and>\n                   set ps \\<subseteq> set alloc \\<and>\n                   set qs \\<subseteq> set alloc;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps @ Qs) \\<and>\n                         set Ps \\<subseteq> set alloc \\<and>\n                         set Qs \\<subseteq> set alloc", "apply fastforce+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma CombineStrip':\n  assumes deriv: \"\\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F\\<^esub> P c' Q,A\"\n  assumes deriv_strip: \"\\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/{}\\<^esub> P c'' UNIV,UNIV\"\n  assumes c'': \"c''= mark_guards False (strip_guards (-F) c')\"\n  assumes c: \"c = mark_guards False c'\"\n  shows \"\\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/{}\\<^esub> P c Q,A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\\<turnstile> P c Q,A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\\<turnstile> P c Q,A", "from deriv_strip [simplified c'']"], ["proof (chain)\npicking this:\n  \\<Gamma>,\\<Theta>\n     \\<turnstile> P mark_guards False (strip_guards (- F) c') UNIV,UNIV", "have \"\\<Gamma>,\\<Theta>\\<turnstile> P (strip_guards (- F) c') UNIV,UNIV\""], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<Theta>\n     \\<turnstile> P mark_guards False (strip_guards (- F) c') UNIV,UNIV\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\\<turnstile> P strip_guards (- F) c' UNIV,UNIV", "by (rule HoarePartialProps.MarkGuardsD)"], ["proof (state)\nthis:\n  \\<Gamma>,\\<Theta>\\<turnstile> P strip_guards (- F) c' UNIV,UNIV\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\\<turnstile> P c Q,A", "with deriv"], ["proof (chain)\npicking this:\n  \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F \\<^esub>P c' Q,A\n  \\<Gamma>,\\<Theta>\\<turnstile> P strip_guards (- F) c' UNIV,UNIV", "have \"\\<Gamma>,\\<Theta>\\<turnstile> P c' Q,A\""], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F \\<^esub>P c' Q,A\n  \\<Gamma>,\\<Theta>\\<turnstile> P strip_guards (- F) c' UNIV,UNIV\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\\<turnstile> P c' Q,A", "by (rule HoarePartialProps.CombineStrip)"], ["proof (state)\nthis:\n  \\<Gamma>,\\<Theta>\\<turnstile> P c' Q,A\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\\<turnstile> P c Q,A", "hence \"\\<Gamma>,\\<Theta>\\<turnstile> P mark_guards False c' Q,A\""], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<Theta>\\<turnstile> P c' Q,A\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\\<turnstile> P mark_guards False c' Q,A", "by (rule HoarePartialProps.MarkGuardsI)"], ["proof (state)\nthis:\n  \\<Gamma>,\\<Theta>\\<turnstile> P mark_guards False c' Q,A\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\\<turnstile> P c Q,A", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<Theta>\\<turnstile> P mark_guards False c' Q,A\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\\<turnstile> P c Q,A", "by (simp add: c)"], ["proof (state)\nthis:\n  \\<Gamma>,\\<Theta>\\<turnstile> P c Q,A\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We can then combine the prove that no fault will occur with the\nfunctional prove of the programm without guards to get the full proove by\nthe rule @{thm HoarePartialProps.CombineStrip}\n\\<close>"], ["", "lemma (in list_alloc)\n  shows\n  \"\\<Gamma>,\\<Theta>\\<turnstile> \\<lbrace>List \\<acute>p \\<acute>next Ps \\<and> List \\<acute>q \\<acute>next Qs \\<and> set Ps \\<inter> set Qs = {} \\<and>\n       set Ps \\<subseteq> set \\<acute>alloc \\<and> set Qs \\<subseteq> set \\<acute>alloc\\<rbrace>\n  WHILE \\<acute>p \\<noteq> Null\n  INV \\<lbrace>\\<exists>ps qs. List \\<acute>p \\<acute>next  ps \\<and> List \\<acute>q \\<acute>next qs \\<and> set ps \\<inter> set qs = {} \\<and>\n               rev ps @ qs = rev Ps @ Qs \\<and>\n               set ps \\<subseteq> set \\<acute>alloc \\<and> set qs \\<subseteq> set \\<acute>alloc\\<rbrace>\n  DO \\<acute>r :== \\<acute>p;;\n     \\<lbrace>\\<acute>p\\<noteq>Null \\<and> \\<acute>p\\<in>set \\<acute>alloc\\<rbrace>\\<longmapsto> \\<acute>p :== \\<acute>p\\<rightarrow> \\<acute>next;;\n     \\<lbrace>\\<acute>r\\<noteq>Null \\<and> \\<acute>r\\<in>set \\<acute>alloc\\<rbrace>\\<longmapsto> \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>q;;\n     \\<acute>q :== \\<acute>r OD\n \\<lbrace>List \\<acute>q \\<acute>next (rev Ps @ Qs) \\<and> set Ps \\<subseteq> set \\<acute>alloc \\<and> set Qs \\<subseteq> set \\<acute>alloc\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile> \\<lbrace>List \\<acute>p \\<acute>next Ps \\<and>\n                             List \\<acute>q \\<acute>next Qs \\<and>\n                             set Ps \\<inter> set Qs = {} \\<and>\n                             set Ps \\<subseteq> set \\<acute>alloc \\<and>\n                             set Qs \\<subseteq> set \\<acute>alloc\\<rbrace>\n                    WHILE \\<acute>p \\<noteq> Null\n                    INV \\<lbrace>\\<exists>ps qs.\n                                    List \\<acute>p \\<acute>next ps \\<and>\n                                    List \\<acute>q \\<acute>next qs \\<and>\n                                    set ps \\<inter> set qs = {} \\<and>\n                                    rev ps @ qs = rev Ps @ Qs \\<and>\n                                    set ps\n                                    \\<subseteq> set \\<acute>alloc \\<and>\n                                    set qs\n                                    \\<subseteq> set \\<acute>alloc\\<rbrace> \n                    DO \\<acute>r :== \\<acute>p;;\n                       (False,\n                        \\<lbrace>\\<acute>p \\<noteq> Null \\<and>\n                                 \\<acute>p \\<in> set \\<acute>alloc\\<rbrace>)\n                       \\<longmapsto> \\<acute>p :==\n                                     \\<acute>p\\<rightarrow>\\<acute>next;;\n                       (False,\n                        \\<lbrace>\\<acute>r \\<noteq> Null \\<and>\n                                 \\<acute>r \\<in> set \\<acute>alloc\\<rbrace>)\n                       \\<longmapsto> \\<acute>r\\<rightarrow>\\<acute>next :==\n                                     \\<acute>q;;\n                       \\<acute>q :== \\<acute>r \n                    OD\n                    \\<lbrace>List \\<acute>q \\<acute>next\n                              (rev Ps @ Qs) \\<and>\n                             set Ps \\<subseteq> set \\<acute>alloc \\<and>\n                             set Qs \\<subseteq> set \\<acute>alloc\\<rbrace>", "apply (rule CombineStrip' [OF rev_moduloGuards rev_noFault])"], ["proof (prove)\ngoal (2 subgoals):\n 1. WHILE \\<acute>p \\<noteq> Null\n    INV \\<lbrace>\\<exists>ps qs.\n                    List \\<acute>p \\<acute>next ps \\<and>\n                    List \\<acute>q \\<acute>next qs \\<and>\n                    set ps \\<inter> set qs = {} \\<and>\n                    rev ps @ qs = rev Ps @ Qs \\<and>\n                    set ps \\<subseteq> set \\<acute>alloc \\<and>\n                    set qs \\<subseteq> set \\<acute>alloc\\<rbrace> \n    DO \\<acute>r :== \\<acute>p;;\n       (False,\n        \\<lbrace>\\<acute>p \\<noteq> Null \\<and>\n                 \\<acute>p \\<in> set \\<acute>alloc\\<rbrace>)\n       \\<longmapsto> \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n       (False,\n        \\<lbrace>\\<acute>r \\<noteq> Null \\<and>\n                 \\<acute>r \\<in> set \\<acute>alloc\\<rbrace>)\n       \\<longmapsto> \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>q;;\n       \\<acute>q :== \\<acute>r \n    OD =\n    mark_guards False\n     (strip_guards (- {True})\n       (WHILE \\<acute>p \\<noteq> Null\n        INV \\<lbrace>\\<exists>ps qs.\n                        List \\<acute>p \\<acute>next ps \\<and>\n                        List \\<acute>q \\<acute>next qs \\<and>\n                        set ps \\<inter> set qs = {} \\<and>\n                        rev ps @ qs = rev Ps @ Qs \\<and>\n                        set ps \\<subseteq> set \\<acute>alloc \\<and>\n                        set qs \\<subseteq> set \\<acute>alloc\\<rbrace> \n        DO \\<acute>r :== \\<acute>p;;\n           (True,\n            \\<lbrace>\\<acute>p \\<noteq> Null \\<and>\n                     \\<acute>p \\<in> set \\<acute>alloc\\<rbrace>)\n           \\<longmapsto> \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n           (True,\n            \\<lbrace>\\<acute>r \\<noteq> Null \\<and>\n                     \\<acute>r \\<in> set \\<acute>alloc\\<rbrace>)\n           \\<longmapsto> \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>q;;\n           \\<acute>q :== \\<acute>r \n        OD))\n 2. WHILE \\<acute>p \\<noteq> Null\n    INV \\<lbrace>\\<exists>ps qs.\n                    List \\<acute>p \\<acute>next ps \\<and>\n                    List \\<acute>q \\<acute>next qs \\<and>\n                    set ps \\<inter> set qs = {} \\<and>\n                    rev ps @ qs = rev Ps @ Qs \\<and>\n                    set ps \\<subseteq> set \\<acute>alloc \\<and>\n                    set qs \\<subseteq> set \\<acute>alloc\\<rbrace> \n    DO \\<acute>r :== \\<acute>p;;\n       (False,\n        \\<lbrace>\\<acute>p \\<noteq> Null \\<and>\n                 \\<acute>p \\<in> set \\<acute>alloc\\<rbrace>)\n       \\<longmapsto> \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n       (False,\n        \\<lbrace>\\<acute>r \\<noteq> Null \\<and>\n                 \\<acute>r \\<in> set \\<acute>alloc\\<rbrace>)\n       \\<longmapsto> \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>q;;\n       \\<acute>q :== \\<acute>r \n    OD =\n    mark_guards False\n     (WHILE \\<acute>p \\<noteq> Null\n      INV \\<lbrace>\\<exists>ps qs.\n                      List \\<acute>p \\<acute>next ps \\<and>\n                      List \\<acute>q \\<acute>next qs \\<and>\n                      set ps \\<inter> set qs = {} \\<and>\n                      rev ps @ qs = rev Ps @ Qs \\<and>\n                      set ps \\<subseteq> set \\<acute>alloc \\<and>\n                      set qs \\<subseteq> set \\<acute>alloc\\<rbrace> \n      DO \\<acute>r :== \\<acute>p;;\n         (True,\n          \\<lbrace>\\<acute>p \\<noteq> Null \\<and>\n                   \\<acute>p \\<in> set \\<acute>alloc\\<rbrace>)\n         \\<longmapsto> \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n         (True,\n          \\<lbrace>\\<acute>r \\<noteq> Null \\<and>\n                   \\<acute>r \\<in> set \\<acute>alloc\\<rbrace>)\n         \\<longmapsto> \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>q;;\n         \\<acute>q :== \\<acute>r \n      OD)", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE \\<acute>p \\<noteq> Null\n    INV \\<lbrace>\\<exists>ps qs.\n                    List \\<acute>p \\<acute>next ps \\<and>\n                    List \\<acute>q \\<acute>next qs \\<and>\n                    set ps \\<inter> set qs = {} \\<and>\n                    rev ps @ qs = rev Ps @ Qs \\<and>\n                    set ps \\<subseteq> set \\<acute>alloc \\<and>\n                    set qs \\<subseteq> set \\<acute>alloc\\<rbrace> \n    DO \\<acute>r :== \\<acute>p;;\n       (False,\n        \\<lbrace>\\<acute>p \\<noteq> Null \\<and>\n                 \\<acute>p \\<in> set \\<acute>alloc\\<rbrace>)\n       \\<longmapsto> \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n       (False,\n        \\<lbrace>\\<acute>r \\<noteq> Null \\<and>\n                 \\<acute>r \\<in> set \\<acute>alloc\\<rbrace>)\n       \\<longmapsto> \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>q;;\n       \\<acute>q :== \\<acute>r \n    OD =\n    mark_guards False\n     (WHILE \\<acute>p \\<noteq> Null\n      INV \\<lbrace>\\<exists>ps qs.\n                      List \\<acute>p \\<acute>next ps \\<and>\n                      List \\<acute>q \\<acute>next qs \\<and>\n                      set ps \\<inter> set qs = {} \\<and>\n                      rev ps @ qs = rev Ps @ Qs \\<and>\n                      set ps \\<subseteq> set \\<acute>alloc \\<and>\n                      set qs \\<subseteq> set \\<acute>alloc\\<rbrace> \n      DO \\<acute>r :== \\<acute>p;;\n         (True,\n          \\<lbrace>\\<acute>p \\<noteq> Null \\<and>\n                   \\<acute>p \\<in> set \\<acute>alloc\\<rbrace>)\n         \\<longmapsto> \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n         (True,\n          \\<lbrace>\\<acute>r \\<noteq> Null \\<and>\n                   \\<acute>r \\<in> set \\<acute>alloc\\<rbrace>)\n         \\<longmapsto> \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>q;;\n         \\<acute>q :== \\<acute>r \n      OD)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>In the previous example the effort to split up the prove did not\nreally pay off. But when we think of programs with a lot of guards and\ncomplicated specifications it may be better to first focus on a prove without\nthe messy guards. Maybe it is possible to automate the no fault proofs so\nthat it suffices to focus on the stripped program.\n\\<close>"], ["", "context list_alloc\nbegin"], ["", "text \\<open>\nThe purpose of guards is to watch for faults that can occur during\nevaluation of expressions. In the example before we watched for null pointer\ndereferencing or memory faults. We can also look for array index bounds or\ndivision by zero. As the condition of a while loop is evaluated in each\niteration we cannot just add a guard before the while loop. Instead we need\na special guard for the condition.\nExample: @{term \"WHILE  \\<lbrace>\\<acute>p\\<noteq>Null\\<rbrace>\\<longmapsto> \\<acute>p\\<rightarrow>\\<acute>next\\<noteq>Null DO SKIP OD\"}\n\\<close>"], ["", "end"], ["", "subsection \\<open>Cicular Lists\\<close>"], ["", "definition\n  distPath :: \"ref \\<Rightarrow> (ref \\<Rightarrow> ref) \\<Rightarrow> ref \\<Rightarrow> ref list \\<Rightarrow> bool\" where\n  \"distPath x next y as = (Path x next y as  \\<and>  distinct as)\""], ["", "lemma neq_dP: \"\\<lbrakk>p \\<noteq> q; Path p h q Ps; distinct Ps\\<rbrakk> \\<Longrightarrow>\n \\<exists>Qs. p\\<noteq>Null \\<and> Ps = p#Qs \\<and> p \\<notin> set Qs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> q; Path p h q Ps; distinct Ps\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Qs.\n                         p \\<noteq> Null \\<and>\n                         Ps = p # Qs \\<and> p \\<notin> set Qs", "by (cases Ps, auto)"], ["", "lemma (in list_alloc) circular_list_rev_I:\n  \"\\<Gamma>,\\<Theta>\\<turnstile> \\<lbrace>\\<acute>root = r \\<and>  distPath \\<acute>root \\<acute>next \\<acute>root (r#Ps)\\<rbrace>\n   \\<acute>p :== \\<acute>root;; \\<acute>q :== \\<acute>root\\<rightarrow>\\<acute>next;;\n  WHILE \\<acute>q \\<noteq> \\<acute>root\n  INV \\<lbrace>\\<exists> ps qs. distPath \\<acute>p \\<acute>next \\<acute>root ps  \\<and> distPath \\<acute>q \\<acute>next \\<acute>root qs \\<and>\n             \\<acute>root = r \\<and> r\\<noteq>Null \\<and> r \\<notin> set Ps  \\<and> set ps \\<inter> set qs = {} \\<and>\n             Ps = (rev ps) @ qs \\<rbrace>\n  DO \\<acute>tmp :== \\<acute>q;; \\<acute>q :== \\<acute>q\\<rightarrow>\\<acute>next;; \\<acute>tmp\\<rightarrow>\\<acute>next :== \\<acute>p;; \\<acute>p:==\\<acute>tmp OD;;\n  \\<acute>root\\<rightarrow>\\<acute>next :== \\<acute>p\n  \\<lbrace>\\<acute>root = r \\<and> distPath \\<acute>root \\<acute>next \\<acute>root (r#rev Ps)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile> \\<lbrace>\\<acute>root = r \\<and>\n                             distPath \\<acute>root \\<acute>next \\<acute>root\n                              (r # Ps)\\<rbrace>\n                    \\<acute>p :== \\<acute>root;;\n                    \\<acute>q :== \\<acute>root\\<rightarrow>\\<acute>next;;\n                    WHILE \\<acute>q \\<noteq> \\<acute>root\n                    INV \\<lbrace>\\<exists>ps qs.\n                                    distPath \\<acute>p \\<acute>next\n                                     \\<acute>root ps \\<and>\n                                    distPath \\<acute>q \\<acute>next\n                                     \\<acute>root qs \\<and>\n                                    \\<acute>root = r \\<and>\n                                    r \\<noteq> Null \\<and>\n                                    r \\<notin> set Ps \\<and>\n                                    set ps \\<inter> set qs = {} \\<and>\n                                    Ps = rev ps @ qs\\<rbrace> \n                    DO \\<acute>tmp :== \\<acute>q;;\n                       \\<acute>q :== \\<acute>q\\<rightarrow>\\<acute>next;;\n                       \\<acute>tmp\\<rightarrow>\\<acute>next :== \\<acute>p;;\n                       \\<acute>p :== \\<acute>tmp \n                    OD;;\n                    \\<acute>root\\<rightarrow>\\<acute>next :== \\<acute>p\n                    \\<lbrace>\\<acute>root = r \\<and>\n                             distPath \\<acute>root \\<acute>next \\<acute>root\n                              (r # rev Ps)\\<rbrace>", "apply (simp only:distPath_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile> \\<lbrace>\\<acute>root = r \\<and>\n                             Path \\<acute>root \\<acute>next \\<acute>root\n                              (r # Ps) \\<and>\n                             distinct (r # Ps)\\<rbrace>\n                    \\<acute>p :== \\<acute>root;;\n                    \\<acute>q :== \\<acute>root\\<rightarrow>\\<acute>next;;\n                    WHILE \\<acute>q \\<noteq> \\<acute>root\n                    INV \\<lbrace>\\<exists>ps qs.\n                                    (Path \\<acute>p \\<acute>next\n\\<acute>root ps \\<and>\n                                     distinct ps) \\<and>\n                                    (Path \\<acute>q \\<acute>next\n\\<acute>root qs \\<and>\n                                     distinct qs) \\<and>\n                                    \\<acute>root = r \\<and>\n                                    r \\<noteq> Null \\<and>\n                                    r \\<notin> set Ps \\<and>\n                                    set ps \\<inter> set qs = {} \\<and>\n                                    Ps = rev ps @ qs\\<rbrace> \n                    DO \\<acute>tmp :== \\<acute>q;;\n                       \\<acute>q :== \\<acute>q\\<rightarrow>\\<acute>next;;\n                       \\<acute>tmp\\<rightarrow>\\<acute>next :== \\<acute>p;;\n                       \\<acute>p :== \\<acute>tmp \n                    OD;;\n                    \\<acute>root\\<rightarrow>\\<acute>next :== \\<acute>p\n                    \\<lbrace>\\<acute>root = r \\<and>\n                             Path \\<acute>root \\<acute>next \\<acute>root\n                              (r # rev Ps) \\<and>\n                             distinct (r # rev Ps)\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>next root.\n       \\<lbrakk>Path root next root (root # Ps);\n        distinct (root # Ps)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps qs.\n                            Path root next root ps \\<and>\n                            distinct ps \\<and>\n                            Path (next root) next root qs \\<and>\n                            distinct qs \\<and>\n                            root = root \\<and>\n                            root \\<noteq> Null \\<and>\n                            root \\<notin> set Ps \\<and>\n                            set ps \\<inter> set qs = {} \\<and>\n                            Ps = rev ps @ qs\n 2. \\<And>next p q root.\n       \\<lbrakk>\\<exists>ps qs.\n                   Path p next root ps \\<and>\n                   distinct ps \\<and>\n                   Path q next root qs \\<and>\n                   distinct qs \\<and>\n                   root = r \\<and>\n                   r \\<noteq> Null \\<and>\n                   r \\<notin> set Ps \\<and>\n                   set ps \\<inter> set qs = {} \\<and> Ps = rev ps @ qs;\n        q \\<noteq> root\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps qs.\n                            Path q (next(q := p)) root ps \\<and>\n                            distinct ps \\<and>\n                            Path (next q) (next(q := p)) root qs \\<and>\n                            distinct qs \\<and>\n                            root = r \\<and>\n                            r \\<noteq> Null \\<and>\n                            r \\<notin> set Ps \\<and>\n                            set ps \\<inter> set qs = {} \\<and>\n                            Ps = rev ps @ qs\n 3. \\<And>next p q root.\n       \\<lbrakk>\\<exists>ps qs.\n                   Path p next root ps \\<and>\n                   distinct ps \\<and>\n                   Path q next root qs \\<and>\n                   distinct qs \\<and>\n                   root = r \\<and>\n                   r \\<noteq> Null \\<and>\n                   r \\<notin> set Ps \\<and>\n                   set ps \\<inter> set qs = {} \\<and> Ps = rev ps @ qs;\n        \\<not> q \\<noteq> root\\<rbrakk>\n       \\<Longrightarrow> root = r \\<and>\n                         Path root (next(root := p)) root\n                          (r # rev Ps) \\<and>\n                         distinct (r # rev Ps)", "apply   (rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>next root.\n       \\<lbrakk>Path root next root (root # Ps);\n        distinct (root # Ps)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>qs.\n                            Path root next root [] \\<and>\n                            distinct [] \\<and>\n                            Path (next root) next root qs \\<and>\n                            distinct qs \\<and>\n                            root = root \\<and>\n                            root \\<noteq> Null \\<and>\n                            root \\<notin> set Ps \\<and>\n                            set [] \\<inter> set qs = {} \\<and>\n                            Ps = rev [] @ qs\n 2. \\<And>next p q root.\n       \\<lbrakk>\\<exists>ps qs.\n                   Path p next root ps \\<and>\n                   distinct ps \\<and>\n                   Path q next root qs \\<and>\n                   distinct qs \\<and>\n                   root = r \\<and>\n                   r \\<noteq> Null \\<and>\n                   r \\<notin> set Ps \\<and>\n                   set ps \\<inter> set qs = {} \\<and> Ps = rev ps @ qs;\n        q \\<noteq> root\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps qs.\n                            Path q (next(q := p)) root ps \\<and>\n                            distinct ps \\<and>\n                            Path (next q) (next(q := p)) root qs \\<and>\n                            distinct qs \\<and>\n                            root = r \\<and>\n                            r \\<noteq> Null \\<and>\n                            r \\<notin> set Ps \\<and>\n                            set ps \\<inter> set qs = {} \\<and>\n                            Ps = rev ps @ qs\n 3. \\<And>next p q root.\n       \\<lbrakk>\\<exists>ps qs.\n                   Path p next root ps \\<and>\n                   distinct ps \\<and>\n                   Path q next root qs \\<and>\n                   distinct qs \\<and>\n                   root = r \\<and>\n                   r \\<noteq> Null \\<and>\n                   r \\<notin> set Ps \\<and>\n                   set ps \\<inter> set qs = {} \\<and> Ps = rev ps @ qs;\n        \\<not> q \\<noteq> root\\<rbrakk>\n       \\<Longrightarrow> root = r \\<and>\n                         Path root (next(root := p)) root\n                          (r # rev Ps) \\<and>\n                         distinct (r # rev Ps)", "apply   fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next p q root.\n       \\<lbrakk>\\<exists>ps qs.\n                   Path p next root ps \\<and>\n                   distinct ps \\<and>\n                   Path q next root qs \\<and>\n                   distinct qs \\<and>\n                   root = r \\<and>\n                   r \\<noteq> Null \\<and>\n                   r \\<notin> set Ps \\<and>\n                   set ps \\<inter> set qs = {} \\<and> Ps = rev ps @ qs;\n        q \\<noteq> root\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps qs.\n                            Path q (next(q := p)) root ps \\<and>\n                            distinct ps \\<and>\n                            Path (next q) (next(q := p)) root qs \\<and>\n                            distinct qs \\<and>\n                            root = r \\<and>\n                            r \\<noteq> Null \\<and>\n                            r \\<notin> set Ps \\<and>\n                            set ps \\<inter> set qs = {} \\<and>\n                            Ps = rev ps @ qs\n 2. \\<And>next p q root.\n       \\<lbrakk>\\<exists>ps qs.\n                   Path p next root ps \\<and>\n                   distinct ps \\<and>\n                   Path q next root qs \\<and>\n                   distinct qs \\<and>\n                   root = r \\<and>\n                   r \\<noteq> Null \\<and>\n                   r \\<notin> set Ps \\<and>\n                   set ps \\<inter> set qs = {} \\<and> Ps = rev ps @ qs;\n        \\<not> q \\<noteq> root\\<rbrakk>\n       \\<Longrightarrow> root = r \\<and>\n                         Path root (next(root := p)) root\n                          (r # rev Ps) \\<and>\n                         distinct (r # rev Ps)", "apply  clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next p q ps qs.\n       \\<lbrakk>q \\<noteq> r; Path p next r ps; distinct ps;\n        Path q next r qs; distinct qs; r \\<noteq> Null;\n        set ps \\<inter> set qs = {}; Ps = rev ps @ qs; r \\<notin> set ps;\n        r \\<notin> set qs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>psa.\n                            Path q (next(q := p)) r psa \\<and>\n                            distinct psa \\<and>\n                            (\\<exists>qsa.\n                                Path (next q) (next(q := p)) r qsa \\<and>\n                                distinct qsa \\<and>\n                                set psa \\<inter> set qsa = {} \\<and>\n                                rev ps @ qs = rev psa @ qsa)\n 2. \\<And>next p q root.\n       \\<lbrakk>\\<exists>ps qs.\n                   Path p next root ps \\<and>\n                   distinct ps \\<and>\n                   Path q next root qs \\<and>\n                   distinct qs \\<and>\n                   root = r \\<and>\n                   r \\<noteq> Null \\<and>\n                   r \\<notin> set Ps \\<and>\n                   set ps \\<inter> set qs = {} \\<and> Ps = rev ps @ qs;\n        \\<not> q \\<noteq> root\\<rbrakk>\n       \\<Longrightarrow> root = r \\<and>\n                         Path root (next(root := p)) root\n                          (r # rev Ps) \\<and>\n                         distinct (r # rev Ps)", "apply  (drule (2) neq_dP)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next p q ps qs.\n       \\<lbrakk>Path p next r ps; distinct ps; Path q next r qs;\n        distinct qs; r \\<noteq> Null; set ps \\<inter> set qs = {};\n        Ps = rev ps @ qs; r \\<notin> set ps; r \\<notin> set qs;\n        \\<exists>Qs.\n           q \\<noteq> Null \\<and>\n           qs = q # Qs \\<and> q \\<notin> set Qs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>psa.\n                            Path q (next(q := p)) r psa \\<and>\n                            distinct psa \\<and>\n                            (\\<exists>qsa.\n                                Path (next q) (next(q := p)) r qsa \\<and>\n                                distinct qsa \\<and>\n                                set psa \\<inter> set qsa = {} \\<and>\n                                rev ps @ qs = rev psa @ qsa)\n 2. \\<And>next p q root.\n       \\<lbrakk>\\<exists>ps qs.\n                   Path p next root ps \\<and>\n                   distinct ps \\<and>\n                   Path q next root qs \\<and>\n                   distinct qs \\<and>\n                   root = r \\<and>\n                   r \\<noteq> Null \\<and>\n                   r \\<notin> set Ps \\<and>\n                   set ps \\<inter> set qs = {} \\<and> Ps = rev ps @ qs;\n        \\<not> q \\<noteq> root\\<rbrakk>\n       \\<Longrightarrow> root = r \\<and>\n                         Path root (next(root := p)) root\n                          (r # rev Ps) \\<and>\n                         distinct (r # rev Ps)", "apply  (rule_tac x=\"q # ps\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next p q ps qs.\n       \\<lbrakk>Path p next r ps; distinct ps; Path q next r qs;\n        distinct qs; r \\<noteq> Null; set ps \\<inter> set qs = {};\n        Ps = rev ps @ qs; r \\<notin> set ps; r \\<notin> set qs;\n        \\<exists>Qs.\n           q \\<noteq> Null \\<and>\n           qs = q # Qs \\<and> q \\<notin> set Qs\\<rbrakk>\n       \\<Longrightarrow> Path q (next(q := p)) r (q # ps) \\<and>\n                         distinct (q # ps) \\<and>\n                         (\\<exists>qsa.\n                             Path (next q) (next(q := p)) r qsa \\<and>\n                             distinct qsa \\<and>\n                             set (q # ps) \\<inter> set qsa = {} \\<and>\n                             rev ps @ qs = rev (q # ps) @ qsa)\n 2. \\<And>next p q root.\n       \\<lbrakk>\\<exists>ps qs.\n                   Path p next root ps \\<and>\n                   distinct ps \\<and>\n                   Path q next root qs \\<and>\n                   distinct qs \\<and>\n                   root = r \\<and>\n                   r \\<noteq> Null \\<and>\n                   r \\<notin> set Ps \\<and>\n                   set ps \\<inter> set qs = {} \\<and> Ps = rev ps @ qs;\n        \\<not> q \\<noteq> root\\<rbrakk>\n       \\<Longrightarrow> root = r \\<and>\n                         Path root (next(root := p)) root\n                          (r # rev Ps) \\<and>\n                         distinct (r # rev Ps)", "apply  clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>next p q root.\n       \\<lbrakk>\\<exists>ps qs.\n                   Path p next root ps \\<and>\n                   distinct ps \\<and>\n                   Path q next root qs \\<and>\n                   distinct qs \\<and>\n                   root = r \\<and>\n                   r \\<noteq> Null \\<and>\n                   r \\<notin> set Ps \\<and>\n                   set ps \\<inter> set qs = {} \\<and> Ps = rev ps @ qs;\n        \\<not> q \\<noteq> root\\<rbrakk>\n       \\<Longrightarrow> root = r \\<and>\n                         Path root (next(root := p)) root\n                          (r # rev Ps) \\<and>\n                         distinct (r # rev Ps)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma path_is_list:\"\\<And>a next b. \\<lbrakk>Path b next a Ps ; a \\<notin> set Ps; a\\<noteq>Null\\<rbrakk>\n\\<Longrightarrow> List b (next(a := Null)) (Ps @ [a])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a next b.\n       \\<lbrakk>Path b next a Ps; a \\<notin> set Ps;\n        a \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List b (next(a := Null)) (Ps @ [a])", "apply (induct Ps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a next b.\n       \\<lbrakk>Path b next a []; a \\<notin> set [];\n        a \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List b (next(a := Null)) ([] @ [a])\n 2. \\<And>a Ps aa next b.\n       \\<lbrakk>\\<And>a next b.\n                   \\<lbrakk>Path b next a Ps; a \\<notin> set Ps;\n                    a \\<noteq> Null\\<rbrakk>\n                   \\<Longrightarrow> List b (next(a := Null)) (Ps @ [a]);\n        Path b next aa (a # Ps); aa \\<notin> set (a # Ps);\n        aa \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List b (next(aa := Null)) ((a # Ps) @ [aa])", "apply (auto simp add:fun_upd_apply)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\nThe simple algorithm for acyclic list reversal, with modified\nannotations, works for cyclic lists as well.:\n\\<close>"], ["", "lemma (in list_alloc) circular_list_rev_II:\n \"\\<Gamma>,\\<Theta>\\<turnstile>\n \\<lbrace>\\<acute>p = r \\<and> distPath \\<acute>p \\<acute>next \\<acute>p (r#Ps)\\<rbrace>\n\\<acute>q:==Null;;\nWHILE \\<acute>p \\<noteq> Null\nINV\n \\<lbrace> ((\\<acute>q = Null) \\<longrightarrow> (\\<exists>ps. distPath \\<acute>p \\<acute>next r ps  \\<and>  ps = r#Ps)) \\<and>\n  ((\\<acute>q \\<noteq> Null) \\<longrightarrow> (\\<exists>ps qs. distPath \\<acute>q \\<acute>next r qs  \\<and> List \\<acute>p \\<acute>next ps  \\<and>\n                   set ps \\<inter> set qs = {} \\<and> rev qs @ ps = Ps@[r])) \\<and>\n  \\<not> (\\<acute>p = Null \\<and> \\<acute>q = Null \\<and> r = Null )\n   \\<rbrace>\nDO\n  \\<acute>tmp :== \\<acute>p;; \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;; \\<acute>tmp\\<rightarrow>\\<acute>next :== \\<acute>q;; \\<acute>q:==\\<acute>tmp\nOD\n \\<lbrace>\\<acute>q = r \\<and> distPath \\<acute>q \\<acute>next \\<acute>q (r # rev Ps)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile> \\<lbrace>\\<acute>p = r \\<and>\n                             distPath \\<acute>p \\<acute>next \\<acute>p\n                              (r # Ps)\\<rbrace>\n                    \\<acute>q :== Null;;\n                    WHILE \\<acute>p \\<noteq> Null\n                    INV \\<lbrace>(\\<acute>q = Null \\<longrightarrow>\n                                  (\\<exists>ps.\ndistPath \\<acute>p \\<acute>next r ps \\<and> ps = r # Ps)) \\<and>\n                                 (\\<acute>q \\<noteq> Null \\<longrightarrow>\n                                  (\\<exists>ps qs.\ndistPath \\<acute>q \\<acute>next r qs \\<and>\nList \\<acute>p \\<acute>next ps \\<and>\nset ps \\<inter> set qs = {} \\<and> rev qs @ ps = Ps @ [r])) \\<and>\n                                 \\<not> (\\<acute>p = Null \\<and>\n   \\<acute>q = Null \\<and> r = Null)\\<rbrace> \n                    DO \\<acute>tmp :== \\<acute>p;;\n                       \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n                       \\<acute>tmp\\<rightarrow>\\<acute>next :== \\<acute>q;;\n                       \\<acute>q :== \\<acute>tmp \n                    OD\n                    \\<lbrace>\\<acute>q = r \\<and>\n                             distPath \\<acute>q \\<acute>next \\<acute>q\n                              (r # rev Ps)\\<rbrace>", "apply (simp only:distPath_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile> \\<lbrace>\\<acute>p = r \\<and>\n                             Path \\<acute>p \\<acute>next \\<acute>p\n                              (r # Ps) \\<and>\n                             distinct (r # Ps)\\<rbrace>\n                    \\<acute>q :== Null;;\n                    WHILE \\<acute>p \\<noteq> Null\n                    INV \\<lbrace>(\\<acute>q = Null \\<longrightarrow>\n                                  (\\<exists>ps.\n(Path \\<acute>p \\<acute>next r ps \\<and> distinct ps) \\<and>\nps = r # Ps)) \\<and>\n                                 (\\<acute>q \\<noteq> Null \\<longrightarrow>\n                                  (\\<exists>ps qs.\n(Path \\<acute>q \\<acute>next r qs \\<and> distinct qs) \\<and>\nList \\<acute>p \\<acute>next ps \\<and>\nset ps \\<inter> set qs = {} \\<and> rev qs @ ps = Ps @ [r])) \\<and>\n                                 \\<not> (\\<acute>p = Null \\<and>\n   \\<acute>q = Null \\<and> r = Null)\\<rbrace> \n                    DO \\<acute>tmp :== \\<acute>p;;\n                       \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n                       \\<acute>tmp\\<rightarrow>\\<acute>next :== \\<acute>q;;\n                       \\<acute>q :== \\<acute>tmp \n                    OD\n                    \\<lbrace>\\<acute>q = r \\<and>\n                             Path \\<acute>q \\<acute>next \\<acute>q\n                              (r # rev Ps) \\<and>\n                             distinct (r # rev Ps)\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>next p.\n       \\<lbrakk>Path p next p (p # Ps); distinct (p # Ps)\\<rbrakk>\n       \\<Longrightarrow> (Null = Null \\<longrightarrow>\n                          (\\<exists>ps.\n                              Path p next p ps \\<and>\n                              distinct ps \\<and> ps = p # Ps)) \\<and>\n                         (Null \\<noteq> Null \\<longrightarrow>\n                          (\\<exists>ps qs.\n                              Path Null next p qs \\<and>\n                              distinct qs \\<and>\n                              List p next ps \\<and>\n                              set ps \\<inter> set qs = {} \\<and>\n                              rev qs @ ps = Ps @ [p])) \\<and>\n                         \\<not> (p = Null \\<and>\n                                 Null = Null \\<and> p = Null)\n 2. \\<And>next p q.\n       \\<lbrakk>q = Null \\<longrightarrow>\n                (\\<exists>ps.\n                    Path p next r ps \\<and> distinct ps \\<and> ps = r # Ps);\n        q \\<noteq> Null \\<longrightarrow>\n        (\\<exists>ps qs.\n            Path q next r qs \\<and>\n            distinct qs \\<and>\n            List p next ps \\<and>\n            set ps \\<inter> set qs = {} \\<and> rev qs @ ps = Ps @ [r]);\n        \\<not> (p = Null \\<and> q = Null \\<and> r = Null);\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> (p = Null \\<longrightarrow>\n                          (\\<exists>ps.\n                              Path (next p) (next(p := q)) r ps \\<and>\n                              distinct ps \\<and> ps = r # Ps)) \\<and>\n                         (p \\<noteq> Null \\<longrightarrow>\n                          (\\<exists>ps qs.\n                              Path p (next(p := q)) r qs \\<and>\n                              distinct qs \\<and>\n                              List (next p) (next(p := q)) ps \\<and>\n                              set ps \\<inter> set qs = {} \\<and>\n                              rev qs @ ps = Ps @ [r])) \\<and>\n                         \\<not> (next p = Null \\<and>\n                                 p = Null \\<and> r = Null)\n 3. \\<And>next p q.\n       \\<lbrakk>q = Null \\<longrightarrow>\n                (\\<exists>ps.\n                    Path p next r ps \\<and> distinct ps \\<and> ps = r # Ps);\n        q \\<noteq> Null \\<longrightarrow>\n        (\\<exists>ps qs.\n            Path q next r qs \\<and>\n            distinct qs \\<and>\n            List p next ps \\<and>\n            set ps \\<inter> set qs = {} \\<and> rev qs @ ps = Ps @ [r]);\n        \\<not> (p = Null \\<and> q = Null \\<and> r = Null);\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> q = r \\<and>\n                         Path q next q (r # rev Ps) \\<and>\n                         distinct (r # rev Ps)", "apply   clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next p q.\n       \\<lbrakk>q = Null \\<longrightarrow>\n                (\\<exists>ps.\n                    Path p next r ps \\<and> distinct ps \\<and> ps = r # Ps);\n        q \\<noteq> Null \\<longrightarrow>\n        (\\<exists>ps qs.\n            Path q next r qs \\<and>\n            distinct qs \\<and>\n            List p next ps \\<and>\n            set ps \\<inter> set qs = {} \\<and> rev qs @ ps = Ps @ [r]);\n        \\<not> (p = Null \\<and> q = Null \\<and> r = Null);\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> (p = Null \\<longrightarrow>\n                          (\\<exists>ps.\n                              Path (next p) (next(p := q)) r ps \\<and>\n                              distinct ps \\<and> ps = r # Ps)) \\<and>\n                         (p \\<noteq> Null \\<longrightarrow>\n                          (\\<exists>ps qs.\n                              Path p (next(p := q)) r qs \\<and>\n                              distinct qs \\<and>\n                              List (next p) (next(p := q)) ps \\<and>\n                              set ps \\<inter> set qs = {} \\<and>\n                              rev qs @ ps = Ps @ [r])) \\<and>\n                         \\<not> (next p = Null \\<and>\n                                 p = Null \\<and> r = Null)\n 2. \\<And>next p q.\n       \\<lbrakk>q = Null \\<longrightarrow>\n                (\\<exists>ps.\n                    Path p next r ps \\<and> distinct ps \\<and> ps = r # Ps);\n        q \\<noteq> Null \\<longrightarrow>\n        (\\<exists>ps qs.\n            Path q next r qs \\<and>\n            distinct qs \\<and>\n            List p next ps \\<and>\n            set ps \\<inter> set qs = {} \\<and> rev qs @ ps = Ps @ [r]);\n        \\<not> (p = Null \\<and> q = Null \\<and> r = Null);\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> q = r \\<and>\n                         Path q next q (r # rev Ps) \\<and>\n                         distinct (r # rev Ps)", "apply  clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next p q.\n       \\<lbrakk>q = Null \\<longrightarrow>\n                r = p \\<and>\n                Path (next p) next r Ps \\<and>\n                r \\<notin> set Ps \\<and> distinct Ps;\n        q \\<noteq> Null \\<longrightarrow>\n        (\\<exists>ps qs.\n            (qs = [] \\<and> r = q \\<or>\n             (\\<exists>ps.\n                 qs = q # ps \\<and> Path (next q) next r ps)) \\<and>\n            distinct qs \\<and>\n            (\\<exists>psa.\n                ps = p # psa \\<and> List (next p) next psa) \\<and>\n            set ps \\<inter> set qs = {} \\<and> rev qs @ ps = Ps @ [r]);\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps qs.\n                            (qs = [] \\<and> r = p \\<or>\n                             (\\<exists>ps.\n                                 qs = p # ps \\<and>\n                                 Path q (next(p := q)) r ps)) \\<and>\n                            distinct qs \\<and>\n                            List (next p) (next(p := q)) ps \\<and>\n                            set ps \\<inter> set qs = {} \\<and>\n                            rev qs @ ps = Ps @ [r]\n 2. \\<And>next p q.\n       \\<lbrakk>q = Null \\<longrightarrow>\n                (\\<exists>ps.\n                    Path p next r ps \\<and> distinct ps \\<and> ps = r # Ps);\n        q \\<noteq> Null \\<longrightarrow>\n        (\\<exists>ps qs.\n            Path q next r qs \\<and>\n            distinct qs \\<and>\n            List p next ps \\<and>\n            set ps \\<inter> set qs = {} \\<and> rev qs @ ps = Ps @ [r]);\n        \\<not> (p = Null \\<and> q = Null \\<and> r = Null);\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> q = r \\<and>\n                         Path q next q (r # rev Ps) \\<and>\n                         distinct (r # rev Ps)", "apply  (case_tac \"(q = Null)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>next p q.\n       \\<lbrakk>q = Null \\<longrightarrow>\n                r = p \\<and>\n                Path (next p) next r Ps \\<and>\n                r \\<notin> set Ps \\<and> distinct Ps;\n        q \\<noteq> Null \\<longrightarrow>\n        (\\<exists>ps qs.\n            (qs = [] \\<and> r = q \\<or>\n             (\\<exists>ps.\n                 qs = q # ps \\<and> Path (next q) next r ps)) \\<and>\n            distinct qs \\<and>\n            (\\<exists>psa.\n                ps = p # psa \\<and> List (next p) next psa) \\<and>\n            set ps \\<inter> set qs = {} \\<and> rev qs @ ps = Ps @ [r]);\n        p \\<noteq> Null; q = Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps qs.\n                            (qs = [] \\<and> r = p \\<or>\n                             (\\<exists>ps.\n                                 qs = p # ps \\<and>\n                                 Path q (next(p := q)) r ps)) \\<and>\n                            distinct qs \\<and>\n                            List (next p) (next(p := q)) ps \\<and>\n                            set ps \\<inter> set qs = {} \\<and>\n                            rev qs @ ps = Ps @ [r]\n 2. \\<And>next p q.\n       \\<lbrakk>q = Null \\<longrightarrow>\n                r = p \\<and>\n                Path (next p) next r Ps \\<and>\n                r \\<notin> set Ps \\<and> distinct Ps;\n        q \\<noteq> Null \\<longrightarrow>\n        (\\<exists>ps qs.\n            (qs = [] \\<and> r = q \\<or>\n             (\\<exists>ps.\n                 qs = q # ps \\<and> Path (next q) next r ps)) \\<and>\n            distinct qs \\<and>\n            (\\<exists>psa.\n                ps = p # psa \\<and> List (next p) next psa) \\<and>\n            set ps \\<inter> set qs = {} \\<and> rev qs @ ps = Ps @ [r]);\n        p \\<noteq> Null; q \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps qs.\n                            (qs = [] \\<and> r = p \\<or>\n                             (\\<exists>ps.\n                                 qs = p # ps \\<and>\n                                 Path q (next(p := q)) r ps)) \\<and>\n                            distinct qs \\<and>\n                            List (next p) (next(p := q)) ps \\<and>\n                            set ps \\<inter> set qs = {} \\<and>\n                            rev qs @ ps = Ps @ [r]\n 3. \\<And>next p q.\n       \\<lbrakk>q = Null \\<longrightarrow>\n                (\\<exists>ps.\n                    Path p next r ps \\<and> distinct ps \\<and> ps = r # Ps);\n        q \\<noteq> Null \\<longrightarrow>\n        (\\<exists>ps qs.\n            Path q next r qs \\<and>\n            distinct qs \\<and>\n            List p next ps \\<and>\n            set ps \\<inter> set qs = {} \\<and> rev qs @ ps = Ps @ [r]);\n        \\<not> (p = Null \\<and> q = Null \\<and> r = Null);\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> q = r \\<and>\n                         Path q next q (r # rev Ps) \\<and>\n                         distinct (r # rev Ps)", "apply   (fastforce intro: path_is_list)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next p q.\n       \\<lbrakk>q = Null \\<longrightarrow>\n                r = p \\<and>\n                Path (next p) next r Ps \\<and>\n                r \\<notin> set Ps \\<and> distinct Ps;\n        q \\<noteq> Null \\<longrightarrow>\n        (\\<exists>ps qs.\n            (qs = [] \\<and> r = q \\<or>\n             (\\<exists>ps.\n                 qs = q # ps \\<and> Path (next q) next r ps)) \\<and>\n            distinct qs \\<and>\n            (\\<exists>psa.\n                ps = p # psa \\<and> List (next p) next psa) \\<and>\n            set ps \\<inter> set qs = {} \\<and> rev qs @ ps = Ps @ [r]);\n        p \\<noteq> Null; q \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps qs.\n                            (qs = [] \\<and> r = p \\<or>\n                             (\\<exists>ps.\n                                 qs = p # ps \\<and>\n                                 Path q (next(p := q)) r ps)) \\<and>\n                            distinct qs \\<and>\n                            List (next p) (next(p := q)) ps \\<and>\n                            set ps \\<inter> set qs = {} \\<and>\n                            rev qs @ ps = Ps @ [r]\n 2. \\<And>next p q.\n       \\<lbrakk>q = Null \\<longrightarrow>\n                (\\<exists>ps.\n                    Path p next r ps \\<and> distinct ps \\<and> ps = r # Ps);\n        q \\<noteq> Null \\<longrightarrow>\n        (\\<exists>ps qs.\n            Path q next r qs \\<and>\n            distinct qs \\<and>\n            List p next ps \\<and>\n            set ps \\<inter> set qs = {} \\<and> rev qs @ ps = Ps @ [r]);\n        \\<not> (p = Null \\<and> q = Null \\<and> r = Null);\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> q = r \\<and>\n                         Path q next q (r # rev Ps) \\<and>\n                         distinct (r # rev Ps)", "apply  clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next p q ps qs psa.\n       \\<lbrakk>q = Null \\<longrightarrow>\n                r = p \\<and>\n                Path (next p) next r Ps \\<and>\n                r \\<notin> set Ps \\<and> distinct Ps;\n        p \\<noteq> Null; q \\<noteq> Null;\n        qs = [] \\<and> r = q \\<or>\n        (\\<exists>ps. qs = q # ps \\<and> Path (next q) next r ps);\n        distinct qs; set (p # psa) \\<inter> set qs = {};\n        rev qs @ p # psa = Ps @ [r]; List (next p) next psa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ps qs.\n                            (qs = [] \\<and> r = p \\<or>\n                             (\\<exists>ps.\n                                 qs = p # ps \\<and>\n                                 Path q (next(p := q)) r ps)) \\<and>\n                            distinct qs \\<and>\n                            List (next p) (next(p := q)) ps \\<and>\n                            set ps \\<inter> set qs = {} \\<and>\n                            rev qs @ ps = Ps @ [r]\n 2. \\<And>next p q.\n       \\<lbrakk>q = Null \\<longrightarrow>\n                (\\<exists>ps.\n                    Path p next r ps \\<and> distinct ps \\<and> ps = r # Ps);\n        q \\<noteq> Null \\<longrightarrow>\n        (\\<exists>ps qs.\n            Path q next r qs \\<and>\n            distinct qs \\<and>\n            List p next ps \\<and>\n            set ps \\<inter> set qs = {} \\<and> rev qs @ ps = Ps @ [r]);\n        \\<not> (p = Null \\<and> q = Null \\<and> r = Null);\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> q = r \\<and>\n                         Path q next q (r # rev Ps) \\<and>\n                         distinct (r # rev Ps)", "apply  (rule_tac x=\"psa\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next p q ps qs psa.\n       \\<lbrakk>q = Null \\<longrightarrow>\n                r = p \\<and>\n                Path (next p) next r Ps \\<and>\n                r \\<notin> set Ps \\<and> distinct Ps;\n        p \\<noteq> Null; q \\<noteq> Null;\n        qs = [] \\<and> r = q \\<or>\n        (\\<exists>ps. qs = q # ps \\<and> Path (next q) next r ps);\n        distinct qs; set (p # psa) \\<inter> set qs = {};\n        rev qs @ p # psa = Ps @ [r]; List (next p) next psa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>qs.\n                            (qs = [] \\<and> r = p \\<or>\n                             (\\<exists>ps.\n                                 qs = p # ps \\<and>\n                                 Path q (next(p := q)) r ps)) \\<and>\n                            distinct qs \\<and>\n                            List (next p) (next(p := q)) psa \\<and>\n                            set psa \\<inter> set qs = {} \\<and>\n                            rev qs @ psa = Ps @ [r]\n 2. \\<And>next p q.\n       \\<lbrakk>q = Null \\<longrightarrow>\n                (\\<exists>ps.\n                    Path p next r ps \\<and> distinct ps \\<and> ps = r # Ps);\n        q \\<noteq> Null \\<longrightarrow>\n        (\\<exists>ps qs.\n            Path q next r qs \\<and>\n            distinct qs \\<and>\n            List p next ps \\<and>\n            set ps \\<inter> set qs = {} \\<and> rev qs @ ps = Ps @ [r]);\n        \\<not> (p = Null \\<and> q = Null \\<and> r = Null);\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> q = r \\<and>\n                         Path q next q (r # rev Ps) \\<and>\n                         distinct (r # rev Ps)", "apply  (rule_tac x=\" p # qs\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next p q ps qs psa.\n       \\<lbrakk>q = Null \\<longrightarrow>\n                r = p \\<and>\n                Path (next p) next r Ps \\<and>\n                r \\<notin> set Ps \\<and> distinct Ps;\n        p \\<noteq> Null; q \\<noteq> Null;\n        qs = [] \\<and> r = q \\<or>\n        (\\<exists>ps. qs = q # ps \\<and> Path (next q) next r ps);\n        distinct qs; set (p # psa) \\<inter> set qs = {};\n        rev qs @ p # psa = Ps @ [r]; List (next p) next psa\\<rbrakk>\n       \\<Longrightarrow> (p # qs = [] \\<and> r = p \\<or>\n                          (\\<exists>ps.\n                              p # qs = p # ps \\<and>\n                              Path q (next(p := q)) r ps)) \\<and>\n                         distinct (p # qs) \\<and>\n                         List (next p) (next(p := q)) psa \\<and>\n                         set psa \\<inter> set (p # qs) = {} \\<and>\n                         rev (p # qs) @ psa = Ps @ [r]\n 2. \\<And>next p q.\n       \\<lbrakk>q = Null \\<longrightarrow>\n                (\\<exists>ps.\n                    Path p next r ps \\<and> distinct ps \\<and> ps = r # Ps);\n        q \\<noteq> Null \\<longrightarrow>\n        (\\<exists>ps qs.\n            Path q next r qs \\<and>\n            distinct qs \\<and>\n            List p next ps \\<and>\n            set ps \\<inter> set qs = {} \\<and> rev qs @ ps = Ps @ [r]);\n        \\<not> (p = Null \\<and> q = Null \\<and> r = Null);\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> q = r \\<and>\n                         Path q next q (r # rev Ps) \\<and>\n                         distinct (r # rev Ps)", "apply  force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>next p q.\n       \\<lbrakk>q = Null \\<longrightarrow>\n                (\\<exists>ps.\n                    Path p next r ps \\<and> distinct ps \\<and> ps = r # Ps);\n        q \\<noteq> Null \\<longrightarrow>\n        (\\<exists>ps qs.\n            Path q next r qs \\<and>\n            distinct qs \\<and>\n            List p next ps \\<and>\n            set ps \\<inter> set qs = {} \\<and> rev qs @ ps = Ps @ [r]);\n        \\<not> (p = Null \\<and> q = Null \\<and> r = Null);\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> q = r \\<and>\n                         Path q next q (r # rev Ps) \\<and>\n                         distinct (r # rev Ps)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Although the above algorithm is more succinct, its invariant\nlooks more involved. The reason for the case distinction on @{term q}\nis due to the fact that during execution, the pointer variables can\npoint to either cyclic or acyclic structures.\n\\<close>"], ["", "text \\<open>\nWhen working on lists, its sometimes better to remove\n@{thm[source] fun_upd_apply} from the simpset, and instead include @{thm[source] fun_upd_same} and @{thm[source] fun_upd_other} to\nthe simpset\n\\<close>"], ["", "(*\ndeclare fun_upd_apply[simp del]fun_upd_same[simp] fun_upd_other[simp]\n*)"], ["", "lemma (in state_space) \"\\<Gamma>\\<turnstile> {\\<sigma>}\n            \\<acute>I :== \\<acute>M;;\n            ANNO \\<tau>. \\<lbrace>\\<tau>. \\<acute>I = \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>\n                      \\<acute>M :== \\<acute>N;; \\<acute>N :== \\<acute>I\n                    \\<lbrace>\\<acute>M = \\<^bsup>\\<tau>\\<^esup>N \\<and> \\<acute>N = \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>\n            \\<lbrace>\\<acute>M = \\<^bsup>\\<sigma>\\<^esup>N \\<and> \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> {\\<sigma>}\n                    \\<acute>I :== \\<acute>M;;\n                    ANNO \\<tau>. \\<lbrace>\\<tau>. \\<acute>I =\n            \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>\n                    \\<acute>M :== \\<acute>N;; \\<acute>N :== \\<acute>I\n                    \\<lbrace>\\<acute>M = \\<^bsup>\\<tau>\\<^esup>N \\<and>\n                             \\<acute>N = \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>,\n                    {}\n                    \\<lbrace>\\<acute>M = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                             \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>M N.\n       M = M \\<and>\n       (\\<forall>Ma Na.\n           Ma = N \\<and> Na = M \\<longrightarrow> N = N \\<and> M = M)\n 2. \\<And>M I N. I = M \\<Longrightarrow> N = N \\<and> I = I", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context state_space\nbegin"], ["", "term \"ANNO (\\<tau>,m,k). (\\<lbrace>\\<tau>. \\<acute>M = m\\<rbrace>) \\<acute>M :== \\<acute>N;; \\<acute>N :== \\<acute>I \\<lbrace>\\<acute>M = \\<^bsup> \\<tau>\\<^esup>N & \\<acute>N = \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>,{}\""], ["", "end"], ["", "lemma (in state_space) \"\\<Gamma>\\<turnstile> ({\\<sigma>} \\<inter> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>)\n      (ANNO \\<tau>. ({\\<tau>} \\<inter> \\<lbrace>\\<acute>A=\\<^bsup>\\<sigma>\\<^esup>A \\<and> \\<acute>I=\\<^bsup>\\<sigma>\\<^esup>I \\<and> \\<acute>M=0 \\<and> \\<acute>S=0\\<rbrace>)\n      WHILE \\<acute>M \\<noteq> \\<acute>A\n      INV \\<lbrace>\\<acute>S = \\<acute>M * \\<acute>I \\<and> \\<acute>A=\\<^bsup>\\<tau>\\<^esup>A \\<and> \\<acute>I=\\<^bsup>\\<tau>\\<^esup>I\\<rbrace>\n      DO \\<acute>S :== \\<acute>S + \\<acute>I;; \\<acute>M :== \\<acute>M + 1 OD\n      \\<lbrace>\\<acute>S = \\<^bsup>\\<tau>\\<^esup>A * \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>)\n      \\<lbrace>\\<acute>S = \\<^bsup>\\<sigma>\\<^esup>A * \\<^bsup>\\<sigma>\\<^esup>I\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> ({\\<sigma>} \\<inter>\n                     \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>)\n                    ANNO \\<tau>. ({\\<tau>} \\<inter>\n                                  \\<lbrace>\\<acute>A =\n     \\<^bsup>\\<sigma>\\<^esup>A \\<and>\n     \\<acute>I = \\<^bsup>\\<sigma>\\<^esup>I \\<and>\n     \\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>)\n                    WHILE \\<acute>M \\<noteq> \\<acute>A\n                    INV \\<lbrace>\\<acute>S = \\<acute>M * \\<acute>I \\<and>\n                                 \\<acute>A = \\<^bsup>\\<tau>\\<^esup>A \\<and>\n                                 \\<acute>I =\n                                 \\<^bsup>\\<tau>\\<^esup>I\\<rbrace> \n                    DO \\<acute>S :== \\<acute>S + \\<acute>I;;\n                       \\<acute>M :== \\<acute>M + 1 \n                    OD\n                    \\<lbrace>\\<acute>S =\n                             \\<^bsup>\\<tau>\\<^esup>A *\n                             \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>,\n                    {}\n                    \\<lbrace>\\<acute>S =\n                             \\<^bsup>\\<sigma>\\<^esup>A *\n                             \\<^bsup>\\<sigma>\\<^esup>I\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (2 subgoals):\n 1. {\\<sigma>} \\<inter> \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n    \\<subseteq> \\<lbrace>\\<acute>A = \\<^bsup>\\<sigma>\\<^esup>A \\<and>\n                         \\<acute>I = \\<^bsup>\\<sigma>\\<^esup>I \\<and>\n                         \\<acute>M = 0 \\<and>\n                         \\<acute>S = 0 \\<and>\n                         (\\<forall>t.\n                             \\<^bsup>t\\<^esup>S =\n                             \\<acute>A * \\<acute>I \\<longrightarrow>\n                             \\<acute>A * \\<acute>I =\n                             \\<^bsup>\\<sigma>\\<^esup>A *\n                             \\<^bsup>\\<sigma>\\<^esup>I)\\<rbrace>\n 2. \\<And>\\<tau>.\n       \\<Gamma>\n          \\<turnstile> ({\\<tau>} \\<inter>\n                        \\<lbrace>\\<acute>A =\n                                 \\<^bsup>\\<sigma>\\<^esup>A \\<and>\n                                 \\<acute>I =\n                                 \\<^bsup>\\<sigma>\\<^esup>I \\<and>\n                                 \\<acute>M = 0 \\<and>\n                                 \\<acute>S = 0\\<rbrace>)\n                       WHILE \\<acute>M \\<noteq> \\<acute>A\n                       INV \\<lbrace>\\<acute>S = \\<acute>M * \\<acute>I \\<and>\n                                    \\<acute>A =\n                                    \\<^bsup>\\<tau>\\<^esup>A \\<and>\n                                    \\<acute>I =\n                                    \\<^bsup>\\<tau>\\<^esup>I\\<rbrace> \n                       DO \\<acute>S :== \\<acute>S + \\<acute>I;;\n                          \\<acute>M :== \\<acute>M + 1 \n                       OD\n                       \\<lbrace>\\<acute>S =\n                                \\<^bsup>\\<tau>\\<^esup>A *\n                                \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A I M S.\n       \\<lbrakk>M = 0; S = 0\\<rbrakk>\n       \\<Longrightarrow> A = A \\<and>\n                         I = I \\<and>\n                         M = 0 \\<and>\n                         S = 0 \\<and>\n                         (\\<forall>S.\n                             S = A * I \\<longrightarrow> A * I = A * I)\n 2. \\<And>\\<tau>.\n       \\<Gamma>\n          \\<turnstile> ({\\<tau>} \\<inter>\n                        \\<lbrace>\\<acute>A =\n                                 \\<^bsup>\\<sigma>\\<^esup>A \\<and>\n                                 \\<acute>I =\n                                 \\<^bsup>\\<sigma>\\<^esup>I \\<and>\n                                 \\<acute>M = 0 \\<and>\n                                 \\<acute>S = 0\\<rbrace>)\n                       WHILE \\<acute>M \\<noteq> \\<acute>A\n                       INV \\<lbrace>\\<acute>S = \\<acute>M * \\<acute>I \\<and>\n                                    \\<acute>A =\n                                    \\<^bsup>\\<tau>\\<^esup>A \\<and>\n                                    \\<acute>I =\n                                    \\<^bsup>\\<tau>\\<^esup>I\\<rbrace> \n                       DO \\<acute>S :== \\<acute>S + \\<acute>I;;\n                          \\<acute>M :== \\<acute>M + 1 \n                       OD\n                       \\<lbrace>\\<acute>S =\n                                \\<^bsup>\\<tau>\\<^esup>A *\n                                \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       \\<Gamma>\n          \\<turnstile> ({\\<tau>} \\<inter>\n                        \\<lbrace>\\<acute>A =\n                                 \\<^bsup>\\<sigma>\\<^esup>A \\<and>\n                                 \\<acute>I =\n                                 \\<^bsup>\\<sigma>\\<^esup>I \\<and>\n                                 \\<acute>M = 0 \\<and>\n                                 \\<acute>S = 0\\<rbrace>)\n                       WHILE \\<acute>M \\<noteq> \\<acute>A\n                       INV \\<lbrace>\\<acute>S = \\<acute>M * \\<acute>I \\<and>\n                                    \\<acute>A =\n                                    \\<^bsup>\\<tau>\\<^esup>A \\<and>\n                                    \\<acute>I =\n                                    \\<^bsup>\\<tau>\\<^esup>I\\<rbrace> \n                       DO \\<acute>S :== \\<acute>S + \\<acute>I;;\n                          \\<acute>M :== \\<acute>M + 1 \n                       OD\n                       \\<lbrace>\\<acute>S =\n                                \\<^bsup>\\<tau>\\<^esup>A *\n                                \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<tau>.\n       \\<lbrace>\\<tau>. \\<acute>A = \\<^bsup>\\<sigma>\\<^esup>A \\<and>\n                        \\<acute>I = \\<^bsup>\\<sigma>\\<^esup>I \\<and>\n                        \\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n       \\<subseteq> \\<lbrace>\\<acute>S = \\<acute>M * \\<acute>I \\<and>\n                            \\<acute>A = \\<^bsup>\\<tau>\\<^esup>A \\<and>\n                            \\<acute>I = \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>\n 2. \\<And>\\<tau>.\n       \\<Gamma>\n          \\<turnstile> (\\<lbrace>\\<acute>S = \\<acute>M * \\<acute>I \\<and>\n                                 \\<acute>A = \\<^bsup>\\<tau>\\<^esup>A \\<and>\n                                 \\<acute>I =\n                                 \\<^bsup>\\<tau>\\<^esup>I\\<rbrace> \\<inter>\n                        \\<lbrace>\\<acute>M \\<noteq> \\<acute>A\\<rbrace>)\n                       \\<acute>S :== \\<acute>S + \\<acute>I;;\n                       \\<acute>M :== \\<acute>M + 1\n                       \\<lbrace>\\<acute>S = \\<acute>M * \\<acute>I \\<and>\n                                \\<acute>A = \\<^bsup>\\<tau>\\<^esup>A \\<and>\n                                \\<acute>I = \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>\n 3. \\<And>\\<tau>.\n       \\<lbrace>\\<acute>S = \\<acute>M * \\<acute>I \\<and>\n                \\<acute>A = \\<^bsup>\\<tau>\\<^esup>A \\<and>\n                \\<acute>I = \\<^bsup>\\<tau>\\<^esup>I \\<and>\n                \\<not> \\<acute>M \\<noteq> \\<acute>A\\<rbrace>\n       \\<subseteq> \\<lbrace>\\<acute>S =\n                            \\<^bsup>\\<tau>\\<^esup>A *\n                            \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>A I Aa Ia M S.\n       \\<lbrakk>Aa = A; Ia = I; M = 0; S = 0\\<rbrakk>\n       \\<Longrightarrow> S = M * Ia \\<and> Aa = Aa \\<and> Ia = Ia\n 2. \\<And>\\<tau>.\n       \\<Gamma>\n          \\<turnstile> (\\<lbrace>\\<acute>S = \\<acute>M * \\<acute>I \\<and>\n                                 \\<acute>A = \\<^bsup>\\<tau>\\<^esup>A \\<and>\n                                 \\<acute>I =\n                                 \\<^bsup>\\<tau>\\<^esup>I\\<rbrace> \\<inter>\n                        \\<lbrace>\\<acute>M \\<noteq> \\<acute>A\\<rbrace>)\n                       \\<acute>S :== \\<acute>S + \\<acute>I;;\n                       \\<acute>M :== \\<acute>M + 1\n                       \\<lbrace>\\<acute>S = \\<acute>M * \\<acute>I \\<and>\n                                \\<acute>A = \\<^bsup>\\<tau>\\<^esup>A \\<and>\n                                \\<acute>I = \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>\n 3. \\<And>\\<tau>.\n       \\<lbrace>\\<acute>S = \\<acute>M * \\<acute>I \\<and>\n                \\<acute>A = \\<^bsup>\\<tau>\\<^esup>A \\<and>\n                \\<acute>I = \\<^bsup>\\<tau>\\<^esup>I \\<and>\n                \\<not> \\<acute>M \\<noteq> \\<acute>A\\<rbrace>\n       \\<subseteq> \\<lbrace>\\<acute>S =\n                            \\<^bsup>\\<tau>\\<^esup>A *\n                            \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau>.\n       \\<Gamma>\n          \\<turnstile> (\\<lbrace>\\<acute>S = \\<acute>M * \\<acute>I \\<and>\n                                 \\<acute>A = \\<^bsup>\\<tau>\\<^esup>A \\<and>\n                                 \\<acute>I =\n                                 \\<^bsup>\\<tau>\\<^esup>I\\<rbrace> \\<inter>\n                        \\<lbrace>\\<acute>M \\<noteq> \\<acute>A\\<rbrace>)\n                       \\<acute>S :== \\<acute>S + \\<acute>I;;\n                       \\<acute>M :== \\<acute>M + 1\n                       \\<lbrace>\\<acute>S = \\<acute>M * \\<acute>I \\<and>\n                                \\<acute>A = \\<^bsup>\\<tau>\\<^esup>A \\<and>\n                                \\<acute>I = \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>\n 2. \\<And>\\<tau>.\n       \\<lbrace>\\<acute>S = \\<acute>M * \\<acute>I \\<and>\n                \\<acute>A = \\<^bsup>\\<tau>\\<^esup>A \\<and>\n                \\<acute>I = \\<^bsup>\\<tau>\\<^esup>I \\<and>\n                \\<not> \\<acute>M \\<noteq> \\<acute>A\\<rbrace>\n       \\<subseteq> \\<lbrace>\\<acute>S =\n                            \\<^bsup>\\<tau>\\<^esup>A *\n                            \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A I Aa Ia M S.\n       \\<lbrakk>S = M * Ia; Aa = A; Ia = I; M \\<noteq> Aa\\<rbrakk>\n       \\<Longrightarrow> S + Ia = (M + 1) * Ia \\<and> Aa = A \\<and> Ia = I\n 2. \\<And>\\<tau>.\n       \\<lbrace>\\<acute>S = \\<acute>M * \\<acute>I \\<and>\n                \\<acute>A = \\<^bsup>\\<tau>\\<^esup>A \\<and>\n                \\<acute>I = \\<^bsup>\\<tau>\\<^esup>I \\<and>\n                \\<not> \\<acute>M \\<noteq> \\<acute>A\\<rbrace>\n       \\<subseteq> \\<lbrace>\\<acute>S =\n                            \\<^bsup>\\<tau>\\<^esup>A *\n                            \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       \\<lbrace>\\<acute>S = \\<acute>M * \\<acute>I \\<and>\n                \\<acute>A = \\<^bsup>\\<tau>\\<^esup>A \\<and>\n                \\<acute>I = \\<^bsup>\\<tau>\\<^esup>I \\<and>\n                \\<not> \\<acute>M \\<noteq> \\<acute>A\\<rbrace>\n       \\<subseteq> \\<lbrace>\\<acute>S =\n                            \\<^bsup>\\<tau>\\<^esup>A *\n                            \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       \\<lbrace>\\<acute>S = \\<acute>M * \\<acute>I \\<and>\n                \\<acute>A = \\<^bsup>\\<tau>\\<^esup>A \\<and>\n                \\<acute>I = \\<^bsup>\\<tau>\\<^esup>I \\<and>\n                \\<acute>M = \\<acute>A\\<rbrace>\n       \\<subseteq> \\<lbrace>\\<acute>S =\n                            \\<^bsup>\\<tau>\\<^esup>A *\n                            \\<^bsup>\\<tau>\\<^esup>I\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A I Aa Ia M S.\n       \\<lbrakk>S = M * Ia; Aa = A; Ia = I; M = Aa\\<rbrakk>\n       \\<Longrightarrow> S = A * I", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Just some test on marked, guards\\<close>"], ["", "lemma (in state_space) \"\\<Gamma>\\<turnstile>\\<lbrace>True\\<rbrace> WHILE \\<lbrace>P \\<acute>N \\<rbrace>\\<surd>, \\<lbrace>Q \\<acute>M\\<rbrace>#, \\<lbrace>R \\<acute>N\\<rbrace>\\<longmapsto> \\<acute>N < \\<acute>M\n                    INV \\<lbrace>\\<acute>N < 2\\<rbrace> DO\n                    \\<acute>N :== \\<acute>M\n                  OD\n           \\<lbrace>hard\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>True\\<rbrace>\n                    WHILE (True, \\<lbrace>P \\<acute>N\\<rbrace>),\n                          \\<lbrace>Q \\<acute>M\\<rbrace>#,\n                          (False, \\<lbrace>R \\<acute>N\\<rbrace>)\n                          \\<longmapsto> \\<acute>N\n  < \\<acute>M INV \\<lbrace>\\<acute>N < 2\\<rbrace> \n                    DO \\<acute>N :== \\<acute>M OD\n                    \\<lbrace>hard\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>M N.\n       True \\<Longrightarrow>\n       P N \\<and>\n       Q M \\<and> R N \\<and> P N \\<and> Q M \\<and> R N \\<and> N < 2\n 2. \\<And>M N.\n       \\<lbrakk>P N; Q M; R N; N < 2; N < M\\<rbrakk>\n       \\<Longrightarrow> P M \\<and>\n                         Q M \\<and>\n                         R M \\<and> P M \\<and> Q M \\<and> R M \\<and> M < 2\n 3. \\<And>M N.\n       \\<lbrakk>P N; Q M; R N; N < 2; \\<not> N < M\\<rbrakk>\n       \\<Longrightarrow> hard", "oops"], ["", "lemma (in state_space) \"\\<Gamma>\\<turnstile>\\<^bsub>/{True}\\<^esub> \\<lbrace>True\\<rbrace> WHILE \\<lbrace>P \\<acute>N \\<rbrace>\\<surd>, \\<lbrace>Q \\<acute>M\\<rbrace>#, \\<lbrace>R \\<acute>N\\<rbrace>\\<longmapsto> \\<acute>N < \\<acute>M\n                    INV \\<lbrace>\\<acute>N < 2\\<rbrace> DO\n                    \\<acute>N :== \\<acute>M\n                  OD\n           \\<lbrace>hard\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile>\\<^bsub>/{True}\\<^esub> \\<lbrace>True\\<rbrace>\n     WHILE (True, \\<lbrace>P \\<acute>N\\<rbrace>),\n           \\<lbrace>Q \\<acute>M\\<rbrace>#,\n           (False, \\<lbrace>R \\<acute>N\\<rbrace>)\n           \\<longmapsto> \\<acute>N\n                         < \\<acute>M INV \\<lbrace>\\<acute>N < 2\\<rbrace> \n     DO \\<acute>N :== \\<acute>M OD\n     \\<lbrace>hard\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>N. True \\<Longrightarrow> P N \\<longrightarrow> R N \\<and> N < 2\n 2. \\<And>M N.\n       \\<lbrakk>P N; R N; N < 2; N < M\\<rbrakk>\n       \\<Longrightarrow> P M \\<longrightarrow> R M \\<and> M < 2\n 3. \\<And>M N.\n       \\<lbrakk>P N; R N; N < 2; \\<not> N < M\\<rbrakk>\n       \\<Longrightarrow> hard", "oops"], ["", "end"]]}