{"file_name": "/home/qj213/afp-2021-10-22/thys/Simpl/ex/Closure.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Simpl", "problem_names": ["lemma dynCallClosure_sound:\nassumes adapt:\n  \"P \\<subseteq> {s. \\<exists>P' Q' A'. \\<forall>n. \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F \\<^esub> P' (callClosure upd (cl s)) Q',A' \\<and>\n                  init s \\<in> P' \\<and>\n                  (\\<forall>t \\<in> Q'. return s t \\<in> R s t) \\<and>\n                  (\\<forall>t \\<in> A'. return s t \\<in> A)}\"\nassumes res: \"\\<forall>s t n. \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub> (R s t) (c s t) Q,A\"\nshows\n\"\\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F \\<^esub>P (dynCallClosure init upd cl return c) Q,A\"", "lemma dynCallClosure:\nassumes adapt: \"P \\<subseteq> {s. \\<exists>P' Q' A'. \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F \\<^esub> P' (callClosure upd (cl s)) Q',A' \\<and>\n                  init s \\<in> P' \\<and>\n                  (\\<forall>t \\<in> Q'. return s t \\<in> R s t) \\<and>\n                  (\\<forall>t \\<in> A'. return s t \\<in> A)}\"\nassumes res: \"\\<forall>s t. \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F\\<^esub> (R s t) (c s t) Q,A\"\nshows\n\"\\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F \\<^esub>P (dynCallClosure init upd cl return c) Q,A\"", "lemma in_subsetD: \"\\<lbrakk>P \\<subseteq> P'; x \\<in> P\\<rbrakk> \\<Longrightarrow> x \\<in> P'\"", "lemma dynCallClosureFix:\nassumes adapt: \"P \\<subseteq> {s. \\<exists>Z. cl'=cl s \\<and>\n                  init s \\<in> P' Z \\<and>\n                  (\\<forall>t \\<in> Q' Z. return s t \\<in> R s t) \\<and>\n                  (\\<forall>t \\<in> A' Z. return s t \\<in> A)}\"\nassumes res: \"\\<forall>s t. \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F\\<^esub> (R s t) (c s t) Q,A\"\nassumes spec: \"\\<forall>Z. \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F \\<^esub> (P' Z) (callClosure upd cl') (Q' Z),(A' Z)\"\nshows\n\"\\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F \\<^esub>P (dynCallClosure init upd cl return c) Q,A\"", "lemma conseq_extract_pre:\n             \"\\<lbrakk>\\<forall>s \\<in> P. \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F\\<^esub> ({s}) c Q,A\\<rbrakk>\n              \\<Longrightarrow>\n              \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F\\<^esub> P c Q,A\"", "lemma app_closure_sound:\n  assumes adapt: \"P \\<subseteq> {s. \\<exists>P' Q' A'. \\<forall>n. \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P' (callClosure upd (e',p)) Q',A' \\<and>\n                           upd x s \\<in> P' \\<and> Q' \\<subseteq> Q \\<and> A' \\<subseteq> A}\"\n  assumes ap: \"upd e = upd e' \\<circ> upd x\"\n  shows \"\\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P (callClosure upd (e,p)) Q,A\"", "lemma app_closure:\n  assumes adapt: \"P \\<subseteq> {s. \\<exists>P' Q' A'. \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F\\<^esub> P' (callClosure upd (e',p)) Q',A' \\<and>\n                           upd x s \\<in> P' \\<and> Q' \\<subseteq> Q \\<and> A' \\<subseteq> A}\"\n  assumes ap: \"upd e = upd e' \\<circ> upd x\"\n  shows \"\\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F\\<^esub> P (callClosure upd (e,p)) Q,A\"", "lemma app_closure_spec:\n  assumes adapt: \"P \\<subseteq> {s. \\<exists>Z. upd x s \\<in> P' Z \\<and> Q' Z \\<subseteq> Q \\<and> A' Z \\<subseteq> A}\"\n  assumes ap: \"upd e = upd e' \\<circ> upd x\"\n  assumes spec: \"\\<forall>Z. \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F\\<^esub> (P' Z) (callClosure upd (e',p)) (Q' Z),(A' Z)\"\n  shows \"\\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F\\<^esub> P (callClosure upd (e,p)) Q,A\"", "lemma gen_upd_app: \"\\<And>es'. gen_upd var (es@es') = gen_upd var es' \\<circ> gen_upd var es\"", "lemma gen_upd_ap:\n  \"gen_upd var (fst (ap es (es',p))) = gen_upd var es' \\<circ> gen_upd var es\"", "lemma ap_closure:\n  assumes adapt: \"P \\<subseteq> {s. \\<exists>P' Q' A'. \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F\\<^esub> P' (callClosure (gen_upd var) c) Q',A' \\<and>\n                           gen_upd var es s \\<in> P' \\<and> Q' \\<subseteq> Q \\<and> A' \\<subseteq> A}\"\n  shows \"\\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F\\<^esub> P (callClosure (gen_upd var) (ap es c)) Q,A\"", "lemma ap_closure_spec:\n  assumes adapt: \"P \\<subseteq> {s. \\<exists>Z. gen_upd var es s \\<in> P' Z \\<and> Q' Z \\<subseteq> Q \\<and> A' Z \\<subseteq> A}\"\n  assumes spec: \"\\<forall>Z. \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F\\<^esub> (P' Z) (callClosure (gen_upd var) c) (Q' Z),(A' Z)\"\n  shows \"\\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F\\<^esub> P (callClosure (gen_upd var) (ap es c)) Q,A\""], "translations": [["", "lemma dynCallClosure_sound:\nassumes adapt:\n  \"P \\<subseteq> {s. \\<exists>P' Q' A'. \\<forall>n. \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F \\<^esub> P' (callClosure upd (cl s)) Q',A' \\<and>\n                  init s \\<in> P' \\<and>\n                  (\\<forall>t \\<in> Q'. return s t \\<in> R s t) \\<and>\n                  (\\<forall>t \\<in> A'. return s t \\<in> A)}\"\nassumes res: \"\\<forall>s t n. \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub> (R s t) (c s t) Q,A\"\nshows\n\"\\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F \\<^esub>P (dynCallClosure init upd cl return c) Q,A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub>\n    P dynCallClosure init upd cl return c Q,A", "proof (rule cnvalidI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>(P, p, Q, A)\\<in>\\<Theta>.\n                   \\<Gamma>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P Call p Q,A;\n        \\<Gamma>\\<turnstile> \\<langle>dynCallClosure init upd cl return\n c,Normal s\\<rangle> =n\\<Rightarrow> t;\n        s \\<in> P; t \\<notin> Fault ` F\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "fix s t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>(P, p, Q, A)\\<in>\\<Theta>.\n                   \\<Gamma>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P Call p Q,A;\n        \\<Gamma>\\<turnstile> \\<langle>dynCallClosure init upd cl return\n c,Normal s\\<rangle> =n\\<Rightarrow> t;\n        s \\<in> P; t \\<notin> Fault ` F\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "assume ctxt: \"\\<forall>(P, p, Q, A)\\<in>\\<Theta>. \\<Gamma>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P Call p Q,A\""], ["proof (state)\nthis:\n  \\<forall>(P, p, Q, A)\\<in>\\<Theta>.\n     \\<Gamma>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P Call p Q,A\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>(P, p, Q, A)\\<in>\\<Theta>.\n                   \\<Gamma>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P Call p Q,A;\n        \\<Gamma>\\<turnstile> \\<langle>dynCallClosure init upd cl return\n c,Normal s\\<rangle> =n\\<Rightarrow> t;\n        s \\<in> P; t \\<notin> Fault ` F\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "assume exec: \"\\<Gamma>\\<turnstile> \\<langle>dynCallClosure init upd cl return c,Normal s\\<rangle> =n\\<Rightarrow> t\""], ["proof (state)\nthis:\n  \\<Gamma>\\<turnstile> \\<langle>dynCallClosure init upd cl return\n                                 c,Normal s\\<rangle> =n\\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>(P, p, Q, A)\\<in>\\<Theta>.\n                   \\<Gamma>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P Call p Q,A;\n        \\<Gamma>\\<turnstile> \\<langle>dynCallClosure init upd cl return\n c,Normal s\\<rangle> =n\\<Rightarrow> t;\n        s \\<in> P; t \\<notin> Fault ` F\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "from execn.Basic [where f=\"(upd (fst (cl s)))\" and s=\"(init s)\"]"], ["proof (chain)\npicking this:\n  ?\\<Gamma>\\<turnstile> \\<langle>Basic\n                                  (upd (fst\n   (cl s))),Normal\n             (init\n               s)\\<rangle> =?n\\<Rightarrow> Normal\n       (upd (fst (cl s)) (init s))", "have exec_upd: \"\\<Gamma>\\<turnstile>\\<langle>Basic (upd (fst (cl s))),Normal (init s)\\<rangle> =n\\<Rightarrow>\n             Normal (((upd (fst (cl s))) \\<circ> init) s)\""], ["proof (prove)\nusing this:\n  ?\\<Gamma>\\<turnstile> \\<langle>Basic\n                                  (upd (fst\n   (cl s))),Normal\n             (init\n               s)\\<rangle> =?n\\<Rightarrow> Normal\n       (upd (fst (cl s)) (init s))\n\ngoal (1 subgoal):\n 1. \\<Gamma>\\<turnstile> \\<langle>Basic\n                                   (upd (fst\n    (cl s))),Normal\n              (init\n                s)\\<rangle> =n\\<Rightarrow> Normal\n       ((upd (fst (cl s)) \\<circ> init) s)", "by auto"], ["proof (state)\nthis:\n  \\<Gamma>\\<turnstile> \\<langle>Basic\n                                 (upd (fst\n  (cl s))),Normal\n            (init\n              s)\\<rangle> =n\\<Rightarrow> Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>(P, p, Q, A)\\<in>\\<Theta>.\n                   \\<Gamma>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P Call p Q,A;\n        \\<Gamma>\\<turnstile> \\<langle>dynCallClosure init upd cl return\n c,Normal s\\<rangle> =n\\<Rightarrow> t;\n        s \\<in> P; t \\<notin> Fault ` F\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "assume P: \"s \\<in> P\""], ["proof (state)\nthis:\n  s \\<in> P\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>(P, p, Q, A)\\<in>\\<Theta>.\n                   \\<Gamma>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P Call p Q,A;\n        \\<Gamma>\\<turnstile> \\<langle>dynCallClosure init upd cl return\n c,Normal s\\<rangle> =n\\<Rightarrow> t;\n        s \\<in> P; t \\<notin> Fault ` F\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "from P adapt"], ["proof (chain)\npicking this:\n  s \\<in> P\n  P \\<subseteq> {s. \\<exists>P' Q' A'.\n                       \\<forall>n.\n                          \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub>\n                          P' callClosure upd (cl s) Q',A' \\<and>\n                          init s \\<in> P' \\<and>\n                          (\\<forall>t\\<in>Q'. return s t \\<in> R s t) \\<and>\n                          (\\<forall>t\\<in>A'. return s t \\<in> A)}", "obtain P' Q' A'\n      where\n      valid: \"\\<forall>n. \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F \\<^esub> P' (callClosure upd (cl s)) Q',A'\" and\n      init_P': \"init s \\<in> P'\"  and\n      R: \"(\\<forall>t \\<in> Q'. return s t \\<in> R s t)\" and\n      A: \"(\\<forall>t \\<in> A'. return s t \\<in> A)\""], ["proof (prove)\nusing this:\n  s \\<in> P\n  P \\<subseteq> {s. \\<exists>P' Q' A'.\n                       \\<forall>n.\n                          \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub>\n                          P' callClosure upd (cl s) Q',A' \\<and>\n                          init s \\<in> P' \\<and>\n                          (\\<forall>t\\<in>Q'. return s t \\<in> R s t) \\<and>\n                          (\\<forall>t\\<in>A'. return s t \\<in> A)}\n\ngoal (1 subgoal):\n 1. (\\<And>P' Q' A'.\n        \\<lbrakk>\\<forall>n.\n                    \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub>\n                    P' callClosure upd (cl s) Q',A';\n         init s \\<in> P'; \\<forall>t\\<in>Q'. return s t \\<in> R s t;\n         \\<forall>t\\<in>A'. return s t \\<in> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>n. \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub>\n     P' callClosure upd (cl s) Q',A'\n  init s \\<in> P'\n  \\<forall>t\\<in>Q'. return s t \\<in> R s t\n  \\<forall>t\\<in>A'. return s t \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>(P, p, Q, A)\\<in>\\<Theta>.\n                   \\<Gamma>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P Call p Q,A;\n        \\<Gamma>\\<turnstile> \\<langle>dynCallClosure init upd cl return\n c,Normal s\\<rangle> =n\\<Rightarrow> t;\n        s \\<in> P; t \\<notin> Fault ` F\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "assume t_notin_F: \"t \\<notin> Fault ` F\""], ["proof (state)\nthis:\n  t \\<notin> Fault ` F\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>(P, p, Q, A)\\<in>\\<Theta>.\n                   \\<Gamma>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P Call p Q,A;\n        \\<Gamma>\\<turnstile> \\<langle>dynCallClosure init upd cl return\n c,Normal s\\<rangle> =n\\<Rightarrow> t;\n        s \\<in> P; t \\<notin> Fault ` F\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "from exec [simplified dynCallClosure_def]"], ["proof (chain)\npicking this:\n  \\<Gamma>\\<turnstile> \\<langle>DynCom\n                                 (\\<lambda>s.\n                                     call (upd (fst (cl s)) \\<circ> init)\n(snd (cl s)) return c),Normal s\\<rangle> =n\\<Rightarrow> t", "have exec_call:\n      \"\\<Gamma>\\<turnstile>\\<langle>call (upd (fst (cl s)) \\<circ> init) (snd (cl s)) return c,Normal s\\<rangle> =n\\<Rightarrow> t\""], ["proof (prove)\nusing this:\n  \\<Gamma>\\<turnstile> \\<langle>DynCom\n                                 (\\<lambda>s.\n                                     call (upd (fst (cl s)) \\<circ> init)\n(snd (cl s)) return c),Normal s\\<rangle> =n\\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<Gamma>\\<turnstile> \\<langle>call (upd (fst (cl s)) \\<circ> init)\n                                   (snd (cl s)) return\n                                   c,Normal s\\<rangle> =n\\<Rightarrow> t", "by cases"], ["proof (state)\nthis:\n  \\<Gamma>\\<turnstile> \\<langle>call (upd (fst (cl s)) \\<circ> init)\n                                 (snd (cl s)) return\n                                 c,Normal s\\<rangle> =n\\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>(P, p, Q, A)\\<in>\\<Theta>.\n                   \\<Gamma>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P Call p Q,A;\n        \\<Gamma>\\<turnstile> \\<langle>dynCallClosure init upd cl return\n c,Normal s\\<rangle> =n\\<Rightarrow> t;\n        s \\<in> P; t \\<notin> Fault ` F\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "then"], ["proof (chain)\npicking this:\n  \\<Gamma>\\<turnstile> \\<langle>call (upd (fst (cl s)) \\<circ> init)\n                                 (snd (cl s)) return\n                                 c,Normal s\\<rangle> =n\\<Rightarrow> t", "show \"t \\<in> Normal ` Q \\<union> Abrupt ` A\""], ["proof (prove)\nusing this:\n  \\<Gamma>\\<turnstile> \\<langle>call (upd (fst (cl s)) \\<circ> init)\n                                 (snd (cl s)) return\n                                 c,Normal s\\<rangle> =n\\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. t \\<in> Normal ` Q \\<union> Abrupt ` A", "proof (cases rule: execn_call_Normal_elim)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Normal t';\n        \\<Gamma>\\<turnstile> \\<langle>c s\n t',Normal (return s t')\\<rangle> =Suc i\\<Rightarrow> t;\n        n = Suc i\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Abrupt t';\n        n = Suc i; t = Abrupt (return s t')\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 4. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 5. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "fix bdy m t'"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Normal t';\n        \\<Gamma>\\<turnstile> \\<langle>c s\n t',Normal (return s t')\\<rangle> =Suc i\\<Rightarrow> t;\n        n = Suc i\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Abrupt t';\n        n = Suc i; t = Abrupt (return s t')\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 4. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 5. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "assume bdy: \"\\<Gamma> (snd (cl s)) = Some bdy\""], ["proof (state)\nthis:\n  \\<Gamma> (snd (cl s)) = Some bdy\n\ngoal (5 subgoals):\n 1. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Normal t';\n        \\<Gamma>\\<turnstile> \\<langle>c s\n t',Normal (return s t')\\<rangle> =Suc i\\<Rightarrow> t;\n        n = Suc i\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Abrupt t';\n        n = Suc i; t = Abrupt (return s t')\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 4. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 5. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "assume exec_body: \"\\<Gamma>\\<turnstile>\\<langle>bdy,Normal ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =m\\<Rightarrow> Normal t'\""], ["proof (state)\nthis:\n  \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n                                     ((upd (fst (cl s)) \\<circ> init)\n s)\\<rangle> =m\\<Rightarrow> Normal t'\n\ngoal (5 subgoals):\n 1. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Normal t';\n        \\<Gamma>\\<turnstile> \\<langle>c s\n t',Normal (return s t')\\<rangle> =Suc i\\<Rightarrow> t;\n        n = Suc i\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Abrupt t';\n        n = Suc i; t = Abrupt (return s t')\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 4. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 5. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "assume exec_c: \"\\<Gamma>\\<turnstile>\\<langle>c s t',Normal (return s t')\\<rangle> =Suc m\\<Rightarrow> t\""], ["proof (state)\nthis:\n  \\<Gamma>\\<turnstile> \\<langle>c s t',Normal\n  (return s t')\\<rangle> =Suc m\\<Rightarrow> t\n\ngoal (5 subgoals):\n 1. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Normal t';\n        \\<Gamma>\\<turnstile> \\<langle>c s\n t',Normal (return s t')\\<rangle> =Suc i\\<Rightarrow> t;\n        n = Suc i\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Abrupt t';\n        n = Suc i; t = Abrupt (return s t')\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 4. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 5. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "assume n: \"n = Suc m\""], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (5 subgoals):\n 1. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Normal t';\n        \\<Gamma>\\<turnstile> \\<langle>c s\n t',Normal (return s t')\\<rangle> =Suc i\\<Rightarrow> t;\n        n = Suc i\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Abrupt t';\n        n = Suc i; t = Abrupt (return s t')\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 4. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 5. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "have \"\\<Gamma>\\<turnstile>\\<langle>Basic init,Normal s\\<rangle> =m\\<Rightarrow> Normal (init s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\\<turnstile> \\<langle>Basic\n                                   init,Normal\n   s\\<rangle> =m\\<Rightarrow> Normal (init s)", "by (rule execn.Basic)"], ["proof (state)\nthis:\n  \\<Gamma>\\<turnstile> \\<langle>Basic\n                                 init,Normal\n s\\<rangle> =m\\<Rightarrow> Normal (init s)\n\ngoal (5 subgoals):\n 1. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Normal t';\n        \\<Gamma>\\<turnstile> \\<langle>c s\n t',Normal (return s t')\\<rangle> =Suc i\\<Rightarrow> t;\n        n = Suc i\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Abrupt t';\n        n = Suc i; t = Abrupt (return s t')\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 4. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 5. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "from bdy exec_body"], ["proof (chain)\npicking this:\n  \\<Gamma> (snd (cl s)) = Some bdy\n  \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n                                     ((upd (fst (cl s)) \\<circ> init)\n s)\\<rangle> =m\\<Rightarrow> Normal t'", "have exec_callC:\n      \"\\<Gamma>\\<turnstile>\\<langle>Call (snd (cl s)),Normal ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =Suc m\\<Rightarrow> Normal t'\""], ["proof (prove)\nusing this:\n  \\<Gamma> (snd (cl s)) = Some bdy\n  \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n                                     ((upd (fst (cl s)) \\<circ> init)\n s)\\<rangle> =m\\<Rightarrow> Normal t'\n\ngoal (1 subgoal):\n 1. \\<Gamma>\\<turnstile> \\<langle>Call\n                                   (snd (cl\n    s)),Normal\n         ((upd (fst (cl s)) \\<circ> init)\n           s)\\<rangle> =Suc m\\<Rightarrow> Normal t'", "by (rule execn.Call)"], ["proof (state)\nthis:\n  \\<Gamma>\\<turnstile> \\<langle>Call\n                                 (snd (cl\n  s)),Normal\n       ((upd (fst (cl s)) \\<circ> init)\n         s)\\<rangle> =Suc m\\<Rightarrow> Normal t'\n\ngoal (5 subgoals):\n 1. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Normal t';\n        \\<Gamma>\\<turnstile> \\<langle>c s\n t',Normal (return s t')\\<rangle> =Suc i\\<Rightarrow> t;\n        n = Suc i\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Abrupt t';\n        n = Suc i; t = Abrupt (return s t')\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 4. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 5. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "from execn.Seq [OF exec_upd [simplified n]exec_callC]"], ["proof (chain)\npicking this:\n  \\<Gamma>\\<turnstile> \\<langle>Seq (Basic (upd (fst (cl s))))\n                                 (Call\n                                   (snd (cl\n    s))),Normal (init s)\\<rangle> =Suc m\\<Rightarrow> Normal t'", "have exec_closure: \"\\<Gamma>\\<turnstile> \\<langle>callClosure upd (cl s),Normal (init s)\\<rangle> =n\\<Rightarrow> Normal t'\""], ["proof (prove)\nusing this:\n  \\<Gamma>\\<turnstile> \\<langle>Seq (Basic (upd (fst (cl s))))\n                                 (Call\n                                   (snd (cl\n    s))),Normal (init s)\\<rangle> =Suc m\\<Rightarrow> Normal t'\n\ngoal (1 subgoal):\n 1. \\<Gamma>\\<turnstile> \\<langle>callClosure upd\n                                   (cl s),Normal\n     (init s)\\<rangle> =n\\<Rightarrow> Normal t'", "by (simp add: callClosure_def n)"], ["proof (state)\nthis:\n  \\<Gamma>\\<turnstile> \\<langle>callClosure upd\n                                 (cl s),Normal\n   (init s)\\<rangle> =n\\<Rightarrow> Normal t'\n\ngoal (5 subgoals):\n 1. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Normal t';\n        \\<Gamma>\\<turnstile> \\<langle>c s\n t',Normal (return s t')\\<rangle> =Suc i\\<Rightarrow> t;\n        n = Suc i\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Abrupt t';\n        n = Suc i; t = Abrupt (return s t')\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 4. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 5. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "from cnvalidD [OF valid [rule_format] ctxt exec_closure init_P']"], ["proof (chain)\npicking this:\n  Normal t' \\<notin> Fault ` F \\<Longrightarrow>\n  Normal t' \\<in> Normal ` Q' \\<union> Abrupt ` A'", "have \"t' \\<in> Q'\""], ["proof (prove)\nusing this:\n  Normal t' \\<notin> Fault ` F \\<Longrightarrow>\n  Normal t' \\<in> Normal ` Q' \\<union> Abrupt ` A'\n\ngoal (1 subgoal):\n 1. t' \\<in> Q'", "by auto"], ["proof (state)\nthis:\n  t' \\<in> Q'\n\ngoal (5 subgoals):\n 1. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Normal t';\n        \\<Gamma>\\<turnstile> \\<langle>c s\n t',Normal (return s t')\\<rangle> =Suc i\\<Rightarrow> t;\n        n = Suc i\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Abrupt t';\n        n = Suc i; t = Abrupt (return s t')\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 4. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 5. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "with R"], ["proof (chain)\npicking this:\n  \\<forall>t\\<in>Q'. return s t \\<in> R s t\n  t' \\<in> Q'", "have \"return s t' \\<in> R s t'\""], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>Q'. return s t \\<in> R s t\n  t' \\<in> Q'\n\ngoal (1 subgoal):\n 1. return s t' \\<in> R s t'", "by auto"], ["proof (state)\nthis:\n  return s t' \\<in> R s t'\n\ngoal (5 subgoals):\n 1. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Normal t';\n        \\<Gamma>\\<turnstile> \\<langle>c s\n t',Normal (return s t')\\<rangle> =Suc i\\<Rightarrow> t;\n        n = Suc i\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Abrupt t';\n        n = Suc i; t = Abrupt (return s t')\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 4. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 5. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "from cnvalidD [OF res [rule_format] ctxt exec_c [simplified n[symmetric]] this\n         t_notin_F]"], ["proof (chain)\npicking this:\n  t \\<in> Normal ` Q \\<union> Abrupt ` A", "show ?thesis"], ["proof (prove)\nusing this:\n  t \\<in> Normal ` Q \\<union> Abrupt ` A\n\ngoal (1 subgoal):\n 1. t \\<in> Normal ` Q \\<union> Abrupt ` A", "by auto"], ["proof (state)\nthis:\n  t \\<in> Normal ` Q \\<union> Abrupt ` A\n\ngoal (4 subgoals):\n 1. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Abrupt t';\n        n = Suc i; t = Abrupt (return s t')\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 4. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Abrupt t';\n        n = Suc i; t = Abrupt (return s t')\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 4. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "fix bdy m t'"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Abrupt t';\n        n = Suc i; t = Abrupt (return s t')\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 4. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "assume bdy: \"\\<Gamma> (snd (cl s)) = Some bdy\""], ["proof (state)\nthis:\n  \\<Gamma> (snd (cl s)) = Some bdy\n\ngoal (4 subgoals):\n 1. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Abrupt t';\n        n = Suc i; t = Abrupt (return s t')\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 4. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "assume exec_body: \"\\<Gamma>\\<turnstile>\\<langle>bdy,Normal ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =m\\<Rightarrow> Abrupt t'\""], ["proof (state)\nthis:\n  \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n                                     ((upd (fst (cl s)) \\<circ> init)\n s)\\<rangle> =m\\<Rightarrow> Abrupt t'\n\ngoal (4 subgoals):\n 1. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Abrupt t';\n        n = Suc i; t = Abrupt (return s t')\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 4. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "assume t: \"t=Abrupt (return s t')\""], ["proof (state)\nthis:\n  t = Abrupt (return s t')\n\ngoal (4 subgoals):\n 1. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Abrupt t';\n        n = Suc i; t = Abrupt (return s t')\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 4. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "assume n: \"n = Suc m\""], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (4 subgoals):\n 1. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Abrupt t';\n        n = Suc i; t = Abrupt (return s t')\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 4. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "from bdy exec_body"], ["proof (chain)\npicking this:\n  \\<Gamma> (snd (cl s)) = Some bdy\n  \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n                                     ((upd (fst (cl s)) \\<circ> init)\n s)\\<rangle> =m\\<Rightarrow> Abrupt t'", "have exec_callC:\n      \"\\<Gamma>\\<turnstile>\\<langle>Call (snd (cl s)),Normal ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =Suc m\\<Rightarrow> Abrupt t'\""], ["proof (prove)\nusing this:\n  \\<Gamma> (snd (cl s)) = Some bdy\n  \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n                                     ((upd (fst (cl s)) \\<circ> init)\n s)\\<rangle> =m\\<Rightarrow> Abrupt t'\n\ngoal (1 subgoal):\n 1. \\<Gamma>\\<turnstile> \\<langle>Call\n                                   (snd (cl\n    s)),Normal\n         ((upd (fst (cl s)) \\<circ> init)\n           s)\\<rangle> =Suc m\\<Rightarrow> Abrupt t'", "by (rule execn.Call)"], ["proof (state)\nthis:\n  \\<Gamma>\\<turnstile> \\<langle>Call\n                                 (snd (cl\n  s)),Normal\n       ((upd (fst (cl s)) \\<circ> init)\n         s)\\<rangle> =Suc m\\<Rightarrow> Abrupt t'\n\ngoal (4 subgoals):\n 1. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Abrupt t';\n        n = Suc i; t = Abrupt (return s t')\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 4. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "from execn.Seq [OF exec_upd [simplified n] exec_callC]"], ["proof (chain)\npicking this:\n  \\<Gamma>\\<turnstile> \\<langle>Seq (Basic (upd (fst (cl s))))\n                                 (Call\n                                   (snd (cl\n    s))),Normal (init s)\\<rangle> =Suc m\\<Rightarrow> Abrupt t'", "have exec_closure: \"\\<Gamma>\\<turnstile> \\<langle>callClosure upd (cl s),Normal (init s)\\<rangle> =n\\<Rightarrow> Abrupt t'\""], ["proof (prove)\nusing this:\n  \\<Gamma>\\<turnstile> \\<langle>Seq (Basic (upd (fst (cl s))))\n                                 (Call\n                                   (snd (cl\n    s))),Normal (init s)\\<rangle> =Suc m\\<Rightarrow> Abrupt t'\n\ngoal (1 subgoal):\n 1. \\<Gamma>\\<turnstile> \\<langle>callClosure upd\n                                   (cl s),Normal\n     (init s)\\<rangle> =n\\<Rightarrow> Abrupt t'", "by (simp add: callClosure_def n)"], ["proof (state)\nthis:\n  \\<Gamma>\\<turnstile> \\<langle>callClosure upd\n                                 (cl s),Normal\n   (init s)\\<rangle> =n\\<Rightarrow> Abrupt t'\n\ngoal (4 subgoals):\n 1. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Abrupt t';\n        n = Suc i; t = Abrupt (return s t')\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 4. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "from cnvalidD [OF valid [rule_format] ctxt exec_closure init_P']"], ["proof (chain)\npicking this:\n  Abrupt t' \\<notin> Fault ` F \\<Longrightarrow>\n  Abrupt t' \\<in> Normal ` Q' \\<union> Abrupt ` A'", "have \"t' \\<in> A'\""], ["proof (prove)\nusing this:\n  Abrupt t' \\<notin> Fault ` F \\<Longrightarrow>\n  Abrupt t' \\<in> Normal ` Q' \\<union> Abrupt ` A'\n\ngoal (1 subgoal):\n 1. t' \\<in> A'", "by auto"], ["proof (state)\nthis:\n  t' \\<in> A'\n\ngoal (4 subgoals):\n 1. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Abrupt t';\n        n = Suc i; t = Abrupt (return s t')\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 4. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "with A"], ["proof (chain)\npicking this:\n  \\<forall>t\\<in>A'. return s t \\<in> A\n  t' \\<in> A'", "have \"return s t' \\<in> A\""], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>A'. return s t \\<in> A\n  t' \\<in> A'\n\ngoal (1 subgoal):\n 1. return s t' \\<in> A", "by auto"], ["proof (state)\nthis:\n  return s t' \\<in> A\n\ngoal (4 subgoals):\n 1. \\<And>bdy i t'.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Abrupt t';\n        n = Suc i; t = Abrupt (return s t')\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 4. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "with t"], ["proof (chain)\npicking this:\n  t = Abrupt (return s t')\n  return s t' \\<in> A", "show ?thesis"], ["proof (prove)\nusing this:\n  t = Abrupt (return s t')\n  return s t' \\<in> A\n\ngoal (1 subgoal):\n 1. t \\<in> Normal ` Q \\<union> Abrupt ` A", "by auto"], ["proof (state)\nthis:\n  t \\<in> Normal ` Q \\<union> Abrupt ` A\n\ngoal (3 subgoals):\n 1. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "fix bdy m f"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "assume bdy: \"\\<Gamma> (snd (cl s)) = Some bdy\""], ["proof (state)\nthis:\n  \\<Gamma> (snd (cl s)) = Some bdy\n\ngoal (3 subgoals):\n 1. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "assume exec_body: \"\\<Gamma>\\<turnstile>\\<langle>bdy,Normal ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =m\\<Rightarrow> Fault f\""], ["proof (state)\nthis:\n  \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n                                     ((upd (fst (cl s)) \\<circ> init)\n s)\\<rangle> =m\\<Rightarrow> Fault f\n\ngoal (3 subgoals):\n 1. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "assume t: \"t=Fault f\""], ["proof (state)\nthis:\n  t = Fault f\n\ngoal (3 subgoals):\n 1. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "assume n: \"n = Suc m\""], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (3 subgoals):\n 1. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "from bdy exec_body"], ["proof (chain)\npicking this:\n  \\<Gamma> (snd (cl s)) = Some bdy\n  \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n                                     ((upd (fst (cl s)) \\<circ> init)\n s)\\<rangle> =m\\<Rightarrow> Fault f", "have exec_callC:\n      \"\\<Gamma>\\<turnstile>\\<langle>Call (snd (cl s)),Normal ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =Suc m\\<Rightarrow> Fault f\""], ["proof (prove)\nusing this:\n  \\<Gamma> (snd (cl s)) = Some bdy\n  \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n                                     ((upd (fst (cl s)) \\<circ> init)\n s)\\<rangle> =m\\<Rightarrow> Fault f\n\ngoal (1 subgoal):\n 1. \\<Gamma>\\<turnstile> \\<langle>Call\n                                   (snd (cl\n    s)),Normal\n         ((upd (fst (cl s)) \\<circ> init)\n           s)\\<rangle> =Suc m\\<Rightarrow> Fault f", "by (rule execn.Call)"], ["proof (state)\nthis:\n  \\<Gamma>\\<turnstile> \\<langle>Call\n                                 (snd (cl\n  s)),Normal\n       ((upd (fst (cl s)) \\<circ> init)\n         s)\\<rangle> =Suc m\\<Rightarrow> Fault f\n\ngoal (3 subgoals):\n 1. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "from execn.Seq [OF exec_upd [simplified n] exec_callC]"], ["proof (chain)\npicking this:\n  \\<Gamma>\\<turnstile> \\<langle>Seq (Basic (upd (fst (cl s))))\n                                 (Call\n                                   (snd (cl\n    s))),Normal (init s)\\<rangle> =Suc m\\<Rightarrow> Fault f", "have exec_closure: \"\\<Gamma>\\<turnstile> \\<langle>callClosure upd (cl s),Normal (init s)\\<rangle> =n\\<Rightarrow> Fault f\""], ["proof (prove)\nusing this:\n  \\<Gamma>\\<turnstile> \\<langle>Seq (Basic (upd (fst (cl s))))\n                                 (Call\n                                   (snd (cl\n    s))),Normal (init s)\\<rangle> =Suc m\\<Rightarrow> Fault f\n\ngoal (1 subgoal):\n 1. \\<Gamma>\\<turnstile> \\<langle>callClosure upd\n                                   (cl s),Normal\n     (init s)\\<rangle> =n\\<Rightarrow> Fault f", "by (simp add: callClosure_def n)"], ["proof (state)\nthis:\n  \\<Gamma>\\<turnstile> \\<langle>callClosure upd\n                                 (cl s),Normal\n   (init s)\\<rangle> =n\\<Rightarrow> Fault f\n\ngoal (3 subgoals):\n 1. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "from cnvalidD [OF valid [rule_format] ctxt exec_closure init_P'] t_notin_F t"], ["proof (chain)\npicking this:\n  Fault f \\<notin> Fault ` F \\<Longrightarrow>\n  Fault f \\<in> Normal ` Q' \\<union> Abrupt ` A'\n  t \\<notin> Fault ` F\n  t = Fault f", "have False"], ["proof (prove)\nusing this:\n  Fault f \\<notin> Fault ` F \\<Longrightarrow>\n  Fault f \\<in> Normal ` Q' \\<union> Abrupt ` A'\n  t \\<notin> Fault ` F\n  t = Fault f\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>bdy i f.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Fault f;\n        n = Suc i; t = Fault f\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 3. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. t \\<in> Normal ` Q \\<union> Abrupt ` A", ".."], ["proof (state)\nthis:\n  t \\<in> Normal ` Q \\<union> Abrupt ` A\n\ngoal (2 subgoals):\n 1. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "fix bdy m"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "assume bdy: \"\\<Gamma> (snd (cl s)) = Some bdy\""], ["proof (state)\nthis:\n  \\<Gamma> (snd (cl s)) = Some bdy\n\ngoal (2 subgoals):\n 1. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "assume exec_body: \"\\<Gamma>\\<turnstile>\\<langle>bdy,Normal ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =m\\<Rightarrow> Stuck\""], ["proof (state)\nthis:\n  \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n                                     ((upd (fst (cl s)) \\<circ> init)\n s)\\<rangle> =m\\<Rightarrow> Stuck\n\ngoal (2 subgoals):\n 1. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "assume t: \"t=Stuck\""], ["proof (state)\nthis:\n  t = Stuck\n\ngoal (2 subgoals):\n 1. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "assume n: \"n = Suc m\""], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (2 subgoals):\n 1. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "from execn.Basic [where f=\"(upd (fst (cl s)))\" and s=\"(init s)\"]"], ["proof (chain)\npicking this:\n  ?\\<Gamma>\\<turnstile> \\<langle>Basic\n                                  (upd (fst\n   (cl s))),Normal\n             (init\n               s)\\<rangle> =?n\\<Rightarrow> Normal\n       (upd (fst (cl s)) (init s))", "have exec_upd: \"\\<Gamma>\\<turnstile>\\<langle>Basic (upd (fst (cl s))),Normal (init s)\\<rangle> =Suc m\\<Rightarrow>\n             Normal (((upd (fst (cl s))) \\<circ> init) s)\""], ["proof (prove)\nusing this:\n  ?\\<Gamma>\\<turnstile> \\<langle>Basic\n                                  (upd (fst\n   (cl s))),Normal\n             (init\n               s)\\<rangle> =?n\\<Rightarrow> Normal\n       (upd (fst (cl s)) (init s))\n\ngoal (1 subgoal):\n 1. \\<Gamma>\\<turnstile> \\<langle>Basic\n                                   (upd (fst\n    (cl s))),Normal\n              (init\n                s)\\<rangle> =Suc m\\<Rightarrow> Normal\n           ((upd (fst (cl s)) \\<circ> init) s)", "by auto"], ["proof (state)\nthis:\n  \\<Gamma>\\<turnstile> \\<langle>Basic\n                                 (upd (fst\n  (cl s))),Normal\n            (init\n              s)\\<rangle> =Suc m\\<Rightarrow> Normal\n         ((upd (fst (cl s)) \\<circ> init) s)\n\ngoal (2 subgoals):\n 1. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "from bdy exec_body"], ["proof (chain)\npicking this:\n  \\<Gamma> (snd (cl s)) = Some bdy\n  \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n                                     ((upd (fst (cl s)) \\<circ> init)\n s)\\<rangle> =m\\<Rightarrow> Stuck", "have exec_callC:\n      \"\\<Gamma>\\<turnstile>\\<langle>Call (snd (cl s)),Normal ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =Suc m\\<Rightarrow> Stuck\""], ["proof (prove)\nusing this:\n  \\<Gamma> (snd (cl s)) = Some bdy\n  \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n                                     ((upd (fst (cl s)) \\<circ> init)\n s)\\<rangle> =m\\<Rightarrow> Stuck\n\ngoal (1 subgoal):\n 1. \\<Gamma>\\<turnstile> \\<langle>Call\n                                   (snd (cl\n    s)),Normal\n         ((upd (fst (cl s)) \\<circ> init)\n           s)\\<rangle> =Suc m\\<Rightarrow> Stuck", "by (rule execn.Call)"], ["proof (state)\nthis:\n  \\<Gamma>\\<turnstile> \\<langle>Call\n                                 (snd (cl\n  s)),Normal\n       ((upd (fst (cl s)) \\<circ> init)\n         s)\\<rangle> =Suc m\\<Rightarrow> Stuck\n\ngoal (2 subgoals):\n 1. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "from execn.Seq [OF exec_upd [simplified n] exec_callC]"], ["proof (chain)\npicking this:\n  \\<Gamma>\\<turnstile> \\<langle>Seq (Basic (upd (fst (cl s))))\n                                 (Call\n                                   (snd (cl\n    s))),Normal (init s)\\<rangle> =Suc m\\<Rightarrow> Stuck", "have exec_closure: \"\\<Gamma>\\<turnstile> \\<langle>callClosure upd (cl s),Normal (init s)\\<rangle> =n\\<Rightarrow> Stuck\""], ["proof (prove)\nusing this:\n  \\<Gamma>\\<turnstile> \\<langle>Seq (Basic (upd (fst (cl s))))\n                                 (Call\n                                   (snd (cl\n    s))),Normal (init s)\\<rangle> =Suc m\\<Rightarrow> Stuck\n\ngoal (1 subgoal):\n 1. \\<Gamma>\\<turnstile> \\<langle>callClosure upd\n                                   (cl s),Normal\n     (init s)\\<rangle> =n\\<Rightarrow> Stuck", "by (simp add: callClosure_def n)"], ["proof (state)\nthis:\n  \\<Gamma>\\<turnstile> \\<langle>callClosure upd\n                                 (cl s),Normal\n   (init s)\\<rangle> =n\\<Rightarrow> Stuck\n\ngoal (2 subgoals):\n 1. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "from cnvalidD [OF valid [rule_format] ctxt exec_closure init_P'] t_notin_F t"], ["proof (chain)\npicking this:\n  Stuck \\<notin> Fault ` F \\<Longrightarrow>\n  Stuck \\<in> Normal ` Q' \\<union> Abrupt ` A'\n  t \\<notin> Fault ` F\n  t = Stuck", "have False"], ["proof (prove)\nusing this:\n  Stuck \\<notin> Fault ` F \\<Longrightarrow>\n  Stuck \\<in> Normal ` Q' \\<union> Abrupt ` A'\n  t \\<notin> Fault ` F\n  t = Stuck\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>bdy i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = Some bdy;\n        \\<Gamma>\\<turnstile> \\<langle>bdy,Normal\n     ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =i\\<Rightarrow> Stuck;\n        n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A\n 2. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. t \\<in> Normal ` Q \\<union> Abrupt ` A", ".."], ["proof (state)\nthis:\n  t \\<in> Normal ` Q \\<union> Abrupt ` A\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "assume no_bdy: \"\\<Gamma> (snd (cl s)) = None\""], ["proof (state)\nthis:\n  \\<Gamma> (snd (cl s)) = None\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "assume t: \"t=Stuck\""], ["proof (state)\nthis:\n  t = Stuck\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "assume n: \"n = Suc m\""], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "from no_bdy"], ["proof (chain)\npicking this:\n  \\<Gamma> (snd (cl s)) = None", "have exec_callC:\n      \"\\<Gamma>\\<turnstile>\\<langle>Call (snd (cl s)),Normal ((upd (fst (cl s)) \\<circ> init) s)\\<rangle> =Suc m\\<Rightarrow> Stuck\""], ["proof (prove)\nusing this:\n  \\<Gamma> (snd (cl s)) = None\n\ngoal (1 subgoal):\n 1. \\<Gamma>\\<turnstile> \\<langle>Call\n                                   (snd (cl\n    s)),Normal\n         ((upd (fst (cl s)) \\<circ> init)\n           s)\\<rangle> =Suc m\\<Rightarrow> Stuck", "by (rule execn.CallUndefined)"], ["proof (state)\nthis:\n  \\<Gamma>\\<turnstile> \\<langle>Call\n                                 (snd (cl\n  s)),Normal\n       ((upd (fst (cl s)) \\<circ> init)\n         s)\\<rangle> =Suc m\\<Rightarrow> Stuck\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "from execn.Seq [OF exec_upd [simplified n]exec_callC]"], ["proof (chain)\npicking this:\n  \\<Gamma>\\<turnstile> \\<langle>Seq (Basic (upd (fst (cl s))))\n                                 (Call\n                                   (snd (cl\n    s))),Normal (init s)\\<rangle> =Suc m\\<Rightarrow> Stuck", "have exec_closure: \"\\<Gamma>\\<turnstile> \\<langle>callClosure upd (cl s),Normal (init s)\\<rangle> =n\\<Rightarrow> Stuck\""], ["proof (prove)\nusing this:\n  \\<Gamma>\\<turnstile> \\<langle>Seq (Basic (upd (fst (cl s))))\n                                 (Call\n                                   (snd (cl\n    s))),Normal (init s)\\<rangle> =Suc m\\<Rightarrow> Stuck\n\ngoal (1 subgoal):\n 1. \\<Gamma>\\<turnstile> \\<langle>callClosure upd\n                                   (cl s),Normal\n     (init s)\\<rangle> =n\\<Rightarrow> Stuck", "by (simp add: callClosure_def n)"], ["proof (state)\nthis:\n  \\<Gamma>\\<turnstile> \\<langle>callClosure upd\n                                 (cl s),Normal\n   (init s)\\<rangle> =n\\<Rightarrow> Stuck\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "from cnvalidD [OF valid [rule_format] ctxt exec_closure init_P'] t_notin_F t"], ["proof (chain)\npicking this:\n  Stuck \\<notin> Fault ` F \\<Longrightarrow>\n  Stuck \\<in> Normal ` Q' \\<union> Abrupt ` A'\n  t \\<notin> Fault ` F\n  t = Stuck", "have False"], ["proof (prove)\nusing this:\n  Stuck \\<notin> Fault ` F \\<Longrightarrow>\n  Stuck \\<in> Normal ` Q' \\<union> Abrupt ` A'\n  t \\<notin> Fault ` F\n  t = Stuck\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<Gamma> (snd (cl s)) = None; n = Suc i; t = Stuck\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. t \\<in> Normal ` Q \\<union> Abrupt ` A", ".."], ["proof (state)\nthis:\n  t \\<in> Normal ` Q \\<union> Abrupt ` A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<in> Normal ` Q \\<union> Abrupt ` A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dynCallClosure:\nassumes adapt: \"P \\<subseteq> {s. \\<exists>P' Q' A'. \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F \\<^esub> P' (callClosure upd (cl s)) Q',A' \\<and>\n                  init s \\<in> P' \\<and>\n                  (\\<forall>t \\<in> Q'. return s t \\<in> R s t) \\<and>\n                  (\\<forall>t \\<in> A'. return s t \\<in> A)}\"\nassumes res: \"\\<forall>s t. \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F\\<^esub> (R s t) (c s t) Q,A\"\nshows\n\"\\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F \\<^esub>P (dynCallClosure init upd cl return c) Q,A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile>\\<^bsub>/F \\<^esub>P dynCallClosure init upd cl return c\nQ,A", "apply (rule hoare_complete')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub>\n       P dynCallClosure init upd cl return c Q,A", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub>\n       P dynCallClosure init upd cl return c Q,A", "apply (rule dynCallClosure_sound [where R=R])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       P \\<subseteq> {s. \\<exists>P' Q' A'.\n                            \\<forall>n.\n                               \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub>\n                               P' callClosure upd (cl s) Q',A' \\<and>\n                               init s \\<in> P' \\<and>\n                               (\\<forall>t\\<in>Q'.\n                                   return s t \\<in> R s t) \\<and>\n                               (\\<forall>t\\<in>A'. return s t \\<in> A)}\n 2. \\<And>n.\n       \\<forall>s t n. \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub>\n          (R s t) c s t Q,A", "using adapt"], ["proof (prove)\nusing this:\n  P \\<subseteq> {s. \\<exists>P' Q' A'.\n                       \\<Gamma>,\\<Theta>\n                          \\<turnstile>\\<^bsub>/F \\<^esub>P'\n                   callClosure upd (cl s) Q',A' \\<and>\n                       init s \\<in> P' \\<and>\n                       (\\<forall>t\\<in>Q'. return s t \\<in> R s t) \\<and>\n                       (\\<forall>t\\<in>A'. return s t \\<in> A)}\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       P \\<subseteq> {s. \\<exists>P' Q' A'.\n                            \\<forall>n.\n                               \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub>\n                               P' callClosure upd (cl s) Q',A' \\<and>\n                               init s \\<in> P' \\<and>\n                               (\\<forall>t\\<in>Q'.\n                                   return s t \\<in> R s t) \\<and>\n                               (\\<forall>t\\<in>A'. return s t \\<in> A)}\n 2. \\<And>n.\n       \\<forall>s t n. \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub>\n          (R s t) c s t Q,A", "apply (blast intro: hoare_cnvalid)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>s t n. \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub>\n          (R s t) c s t Q,A", "using res"], ["proof (prove)\nusing this:\n  \\<forall>s t.\n     \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F \\<^esub>(R s t) c s t Q,A\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<forall>s t n. \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub>\n          (R s t) c s t Q,A", "apply (blast intro: hoare_cnvalid)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma in_subsetD: \"\\<lbrakk>P \\<subseteq> P'; x \\<in> P\\<rbrakk> \\<Longrightarrow> x \\<in> P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P \\<subseteq> P'; x \\<in> P\\<rbrakk>\n    \\<Longrightarrow> x \\<in> P'", "by blast"], ["", "lemma dynCallClosureFix:\nassumes adapt: \"P \\<subseteq> {s. \\<exists>Z. cl'=cl s \\<and>\n                  init s \\<in> P' Z \\<and>\n                  (\\<forall>t \\<in> Q' Z. return s t \\<in> R s t) \\<and>\n                  (\\<forall>t \\<in> A' Z. return s t \\<in> A)}\"\nassumes res: \"\\<forall>s t. \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F\\<^esub> (R s t) (c s t) Q,A\"\nassumes spec: \"\\<forall>Z. \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F \\<^esub> (P' Z) (callClosure upd cl') (Q' Z),(A' Z)\"\nshows\n\"\\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F \\<^esub>P (dynCallClosure init upd cl return c) Q,A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile>\\<^bsub>/F \\<^esub>P dynCallClosure init upd cl return c\nQ,A", "apply (rule dynCallClosure [OF _ res])"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<subseteq> {s. \\<exists>P' Q' A'.\n                         \\<Gamma>,\\<Theta>\n                            \\<turnstile>\\<^bsub>/F \\<^esub>P'\n                     callClosure upd (cl s) Q',A' \\<and>\n                         init s \\<in> P' \\<and>\n                         (\\<forall>t\\<in>Q'. return s t \\<in> R s t) \\<and>\n                         (\\<forall>t\\<in>A'. return s t \\<in> A)}", "using adapt spec"], ["proof (prove)\nusing this:\n  P \\<subseteq> {s. \\<exists>Z.\n                       cl' = cl s \\<and>\n                       init s \\<in> P' Z \\<and>\n                       (\\<forall>t\\<in>Q' Z. return s t \\<in> R s t) \\<and>\n                       (\\<forall>t\\<in>A' Z. return s t \\<in> A)}\n  \\<forall>Z.\n     \\<Gamma>,\\<Theta>\n        \\<turnstile>\\<^bsub>/F \\<^esub>(P' Z) callClosure upd cl' (Q' Z),\n (A' Z)\n\ngoal (1 subgoal):\n 1. P \\<subseteq> {s. \\<exists>P' Q' A'.\n                         \\<Gamma>,\\<Theta>\n                            \\<turnstile>\\<^bsub>/F \\<^esub>P'\n                     callClosure upd (cl s) Q',A' \\<and>\n                         init s \\<in> P' \\<and>\n                         (\\<forall>t\\<in>Q'. return s t \\<in> R s t) \\<and>\n                         (\\<forall>t\\<in>A'. return s t \\<in> A)}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>P \\<subseteq> {s. cl' = cl s \\<and>\n                                  (\\<exists>Z.\ninit s \\<in> P' Z \\<and>\n(\\<forall>t\\<in>Q' Z. return s t \\<in> R s t) \\<and>\n(\\<forall>t\\<in>A' Z. return s t \\<in> A))};\n        \\<forall>Z.\n           \\<Gamma>,\\<Theta>\n              \\<turnstile>\\<^bsub>/F \\<^esub>(P' Z) callClosure upd cl'\n       (Q' Z),(A' Z);\n        x \\<in> P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P' Q' A'.\n                            \\<Gamma>,\\<Theta>\n                               \\<turnstile>\\<^bsub>/F \\<^esub>P'\n                        callClosure upd (cl x) Q',A' \\<and>\n                            init x \\<in> P' \\<and>\n                            (\\<forall>t\\<in>Q'.\n                                return x t \\<in> R x t) \\<and>\n                            (\\<forall>t\\<in>A'. return x t \\<in> A)", "apply (drule (1) in_subsetD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>Z.\n                   \\<Gamma>,\\<Theta>\n                      \\<turnstile>\\<^bsub>/F \\<^esub>(P' Z)\n               callClosure upd cl' (Q' Z),(A' Z);\n        x \\<in> P;\n        x \\<in> {s. cl' = cl s \\<and>\n                    (\\<exists>Z.\n                        init s \\<in> P' Z \\<and>\n                        (\\<forall>t\\<in>Q' Z. return s t \\<in> R s t) \\<and>\n                        (\\<forall>t\\<in>A' Z. return s t \\<in> A))}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P' Q' A'.\n                            \\<Gamma>,\\<Theta>\n                               \\<turnstile>\\<^bsub>/F \\<^esub>P'\n                        callClosure upd (cl x) Q',A' \\<and>\n                            init x \\<in> P' \\<and>\n                            (\\<forall>t\\<in>Q'.\n                                return x t \\<in> R x t) \\<and>\n                            (\\<forall>t\\<in>A'. return x t \\<in> A)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x Z.\n       \\<lbrakk>\\<forall>Z.\n                   \\<Gamma>,\\<Theta>\n                      \\<turnstile>\\<^bsub>/F \\<^esub>(P' Z)\n               callClosure upd (cl x) (Q' Z),(A' Z);\n        x \\<in> P; cl' = cl x; init x \\<in> P' Z;\n        \\<forall>t\\<in>Q' Z. return x t \\<in> R x t;\n        \\<forall>t\\<in>A' Z. return x t \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P' Q' A'.\n                            \\<Gamma>,\\<Theta>\n                               \\<turnstile>\\<^bsub>/F \\<^esub>P'\n                        callClosure upd (cl x) Q',A' \\<and>\n                            init x \\<in> P' \\<and>\n                            (\\<forall>t\\<in>Q'.\n                                return x t \\<in> R x t) \\<and>\n                            (\\<forall>t\\<in>A'. return x t \\<in> A)", "apply (rule_tac x=\"P' Z\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x Z.\n       \\<lbrakk>\\<forall>Z.\n                   \\<Gamma>,\\<Theta>\n                      \\<turnstile>\\<^bsub>/F \\<^esub>(P' Z)\n               callClosure upd (cl x) (Q' Z),(A' Z);\n        x \\<in> P; cl' = cl x; init x \\<in> P' Z;\n        \\<forall>t\\<in>Q' Z. return x t \\<in> R x t;\n        \\<forall>t\\<in>A' Z. return x t \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' A'.\n                            \\<Gamma>,\\<Theta>\n                               \\<turnstile>\\<^bsub>/F \\<^esub>(P' Z)\n                        callClosure upd (cl x) Q',A' \\<and>\n                            init x \\<in> P' Z \\<and>\n                            (\\<forall>t\\<in>Q'.\n                                return x t \\<in> R x t) \\<and>\n                            (\\<forall>t\\<in>A'. return x t \\<in> A)", "apply (rule_tac x=\"Q' Z\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x Z.\n       \\<lbrakk>\\<forall>Z.\n                   \\<Gamma>,\\<Theta>\n                      \\<turnstile>\\<^bsub>/F \\<^esub>(P' Z)\n               callClosure upd (cl x) (Q' Z),(A' Z);\n        x \\<in> P; cl' = cl x; init x \\<in> P' Z;\n        \\<forall>t\\<in>Q' Z. return x t \\<in> R x t;\n        \\<forall>t\\<in>A' Z. return x t \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A'.\n                            \\<Gamma>,\\<Theta>\n                               \\<turnstile>\\<^bsub>/F \\<^esub>(P' Z)\n                        callClosure upd (cl x) (Q' Z),A' \\<and>\n                            init x \\<in> P' Z \\<and>\n                            (\\<forall>t\\<in>Q' Z.\n                                return x t \\<in> R x t) \\<and>\n                            (\\<forall>t\\<in>A'. return x t \\<in> A)", "apply (rule_tac x=\"A' Z\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x Z.\n       \\<lbrakk>\\<forall>Z.\n                   \\<Gamma>,\\<Theta>\n                      \\<turnstile>\\<^bsub>/F \\<^esub>(P' Z)\n               callClosure upd (cl x) (Q' Z),(A' Z);\n        x \\<in> P; cl' = cl x; init x \\<in> P' Z;\n        \\<forall>t\\<in>Q' Z. return x t \\<in> R x t;\n        \\<forall>t\\<in>A' Z. return x t \\<in> A\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<Theta>\n                            \\<turnstile>\\<^bsub>/F \\<^esub>(P' Z)\n                     callClosure upd (cl x) (Q' Z),(A' Z) \\<and>\n                         init x \\<in> P' Z \\<and>\n                         (\\<forall>t\\<in>Q' Z.\n                             return x t \\<in> R x t) \\<and>\n                         (\\<forall>t\\<in>A' Z. return x t \\<in> A)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma conseq_extract_pre:\n             \"\\<lbrakk>\\<forall>s \\<in> P. \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F\\<^esub> ({s}) c Q,A\\<rbrakk>\n              \\<Longrightarrow>\n              \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F\\<^esub> P c Q,A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>P.\n       \\<Gamma>,\\<Theta>\n          \\<turnstile>\\<^bsub>/F \\<^esub>{s} c Q,A \\<Longrightarrow>\n    \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F \\<^esub>P c Q,A", "apply (rule hoarep.Conseq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>P.\n       \\<Gamma>,\\<Theta>\n          \\<turnstile>\\<^bsub>/F \\<^esub>{s} c Q,A \\<Longrightarrow>\n    \\<forall>s\\<in>P.\n       \\<exists>P' Q' A'.\n          \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F \\<^esub>P' c Q',A' \\<and>\n          s \\<in> P' \\<and> Q' \\<subseteq> Q \\<and> A' \\<subseteq> A", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<forall>s\\<in>P.\n                   \\<Gamma>,\\<Theta>\n                      \\<turnstile>\\<^bsub>/F \\<^esub>{s} c Q,A;\n        s \\<in> P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P' Q' A'.\n                            \\<Gamma>,\\<Theta>\n                               \\<turnstile>\\<^bsub>/F \\<^esub>P' c Q',\n                        A' \\<and>\n                            s \\<in> P' \\<and>\n                            Q' \\<subseteq> Q \\<and> A' \\<subseteq> A", "apply (rule_tac x=\"{s}\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<forall>s\\<in>P.\n                   \\<Gamma>,\\<Theta>\n                      \\<turnstile>\\<^bsub>/F \\<^esub>{s} c Q,A;\n        s \\<in> P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' A'.\n                            \\<Gamma>,\\<Theta>\n                               \\<turnstile>\\<^bsub>/F \\<^esub>{s} c Q',\n                        A' \\<and>\n                            s \\<in> {s} \\<and>\n                            Q' \\<subseteq> Q \\<and> A' \\<subseteq> A", "apply (rule_tac x=\"Q\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<forall>s\\<in>P.\n                   \\<Gamma>,\\<Theta>\n                      \\<turnstile>\\<^bsub>/F \\<^esub>{s} c Q,A;\n        s \\<in> P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A'.\n                            \\<Gamma>,\\<Theta>\n                               \\<turnstile>\\<^bsub>/F \\<^esub>{s} c Q,\n                        A' \\<and>\n                            s \\<in> {s} \\<and>\n                            Q \\<subseteq> Q \\<and> A' \\<subseteq> A", "apply (rule_tac x=\"A\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<forall>s\\<in>P.\n                   \\<Gamma>,\\<Theta>\n                      \\<turnstile>\\<^bsub>/F \\<^esub>{s} c Q,A;\n        s \\<in> P\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<Theta>\n                            \\<turnstile>\\<^bsub>/F \\<^esub>{s} c Q,A \\<and>\n                         s \\<in> {s} \\<and>\n                         Q \\<subseteq> Q \\<and> A \\<subseteq> A", "by simp"], ["", "lemma app_closure_sound:\n  assumes adapt: \"P \\<subseteq> {s. \\<exists>P' Q' A'. \\<forall>n. \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P' (callClosure upd (e',p)) Q',A' \\<and>\n                           upd x s \\<in> P' \\<and> Q' \\<subseteq> Q \\<and> A' \\<subseteq> A}\"\n  assumes ap: \"upd e = upd e' \\<circ> upd x\"\n  shows \"\\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P (callClosure upd (e,p)) Q,A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub>\n    P callClosure upd (e, p) Q,A", "proof (rule cnvalidI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>(P, p, Q, A)\\<in>\\<Theta>.\n                   \\<Gamma>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P Call p Q,A;\n        \\<Gamma>\\<turnstile> \\<langle>callClosure upd\n (e, p),Normal s\\<rangle> =n\\<Rightarrow> t;\n        s \\<in> P; t \\<notin> Fault ` F\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "fix s t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>(P, p, Q, A)\\<in>\\<Theta>.\n                   \\<Gamma>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P Call p Q,A;\n        \\<Gamma>\\<turnstile> \\<langle>callClosure upd\n (e, p),Normal s\\<rangle> =n\\<Rightarrow> t;\n        s \\<in> P; t \\<notin> Fault ` F\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "assume ctxt: \"\\<forall>(P, p, Q, A)\\<in>\\<Theta>. \\<Gamma>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P Call p Q,A\""], ["proof (state)\nthis:\n  \\<forall>(P, p, Q, A)\\<in>\\<Theta>.\n     \\<Gamma>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P Call p Q,A\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>(P, p, Q, A)\\<in>\\<Theta>.\n                   \\<Gamma>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P Call p Q,A;\n        \\<Gamma>\\<turnstile> \\<langle>callClosure upd\n (e, p),Normal s\\<rangle> =n\\<Rightarrow> t;\n        s \\<in> P; t \\<notin> Fault ` F\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "assume exec_e: \"\\<Gamma>\\<turnstile> \\<langle>callClosure upd (e, p),Normal s\\<rangle> =n\\<Rightarrow> t\""], ["proof (state)\nthis:\n  \\<Gamma>\\<turnstile> \\<langle>callClosure upd\n                                 (e, p),Normal s\\<rangle> =n\\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>(P, p, Q, A)\\<in>\\<Theta>.\n                   \\<Gamma>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P Call p Q,A;\n        \\<Gamma>\\<turnstile> \\<langle>callClosure upd\n (e, p),Normal s\\<rangle> =n\\<Rightarrow> t;\n        s \\<in> P; t \\<notin> Fault ` F\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "assume P: \"s \\<in> P\""], ["proof (state)\nthis:\n  s \\<in> P\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>(P, p, Q, A)\\<in>\\<Theta>.\n                   \\<Gamma>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P Call p Q,A;\n        \\<Gamma>\\<turnstile> \\<langle>callClosure upd\n (e, p),Normal s\\<rangle> =n\\<Rightarrow> t;\n        s \\<in> P; t \\<notin> Fault ` F\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "assume t: \"t \\<notin> Fault ` F\""], ["proof (state)\nthis:\n  t \\<notin> Fault ` F\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>(P, p, Q, A)\\<in>\\<Theta>.\n                   \\<Gamma>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P Call p Q,A;\n        \\<Gamma>\\<turnstile> \\<langle>callClosure upd\n (e, p),Normal s\\<rangle> =n\\<Rightarrow> t;\n        s \\<in> P; t \\<notin> Fault ` F\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "from P adapt"], ["proof (chain)\npicking this:\n  s \\<in> P\n  P \\<subseteq> {s. \\<exists>P' Q' A'.\n                       \\<forall>n.\n                          \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub>\n                          P' callClosure upd (e', p) Q',A' \\<and>\n                          upd x s \\<in> P' \\<and>\n                          Q' \\<subseteq> Q \\<and> A' \\<subseteq> A}", "obtain P' Q' A'\n    where\n    valid: \"\\<forall>n. \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F \\<^esub> P' (callClosure upd (e',p)) Q',A'\" and\n    init_P': \"upd x s \\<in> P'\"  and\n    Q: \"Q' \\<subseteq> Q\" and\n    A: \"A' \\<subseteq> A\""], ["proof (prove)\nusing this:\n  s \\<in> P\n  P \\<subseteq> {s. \\<exists>P' Q' A'.\n                       \\<forall>n.\n                          \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub>\n                          P' callClosure upd (e', p) Q',A' \\<and>\n                          upd x s \\<in> P' \\<and>\n                          Q' \\<subseteq> Q \\<and> A' \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. (\\<And>P' Q' A'.\n        \\<lbrakk>\\<forall>n.\n                    \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub>\n                    P' callClosure upd (e', p) Q',A';\n         upd x s \\<in> P'; Q' \\<subseteq> Q; A' \\<subseteq> A\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>n. \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub>\n     P' callClosure upd (e', p) Q',A'\n  upd x s \\<in> P'\n  Q' \\<subseteq> Q\n  A' \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>(P, p, Q, A)\\<in>\\<Theta>.\n                   \\<Gamma>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P Call p Q,A;\n        \\<Gamma>\\<turnstile> \\<langle>callClosure upd\n (e, p),Normal s\\<rangle> =n\\<Rightarrow> t;\n        s \\<in> P; t \\<notin> Fault ` F\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "from exec_e [simplified callClosure_def]"], ["proof (chain)\npicking this:\n  \\<Gamma>\\<turnstile> \\<langle>Seq (Basic (upd (fst (e, p))))\n                                 (Call\n                                   (snd (e,\n   p))),Normal s\\<rangle> =n\\<Rightarrow> t", "obtain s'\n    where\n    exec_e: \"\\<Gamma>\\<turnstile> \\<langle>Basic (upd (fst (e, p))),Normal s\\<rangle> =n\\<Rightarrow> s'\"and\n    exec_p: \"\\<Gamma>\\<turnstile> \\<langle>Call (snd (e, p)),s'\\<rangle> =n\\<Rightarrow> t\""], ["proof (prove)\nusing this:\n  \\<Gamma>\\<turnstile> \\<langle>Seq (Basic (upd (fst (e, p))))\n                                 (Call\n                                   (snd (e,\n   p))),Normal s\\<rangle> =n\\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>\\<Gamma>\\<turnstile> \\<langle>Basic\n          (upd (fst (e, p))),Normal s\\<rangle> =n\\<Rightarrow> s';\n         \\<Gamma>\\<turnstile> \\<langle>Call\n  (snd (e, p)),s'\\<rangle> =n\\<Rightarrow> t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by cases"], ["proof (state)\nthis:\n  \\<Gamma>\\<turnstile> \\<langle>Basic\n                                 (upd (fst\n  (e, p))),Normal s\\<rangle> =n\\<Rightarrow> s'\n  \\<Gamma>\\<turnstile> \\<langle>Call\n                                 (snd (e, p)),s'\\<rangle> =n\\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>(P, p, Q, A)\\<in>\\<Theta>.\n                   \\<Gamma>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P Call p Q,A;\n        \\<Gamma>\\<turnstile> \\<langle>callClosure upd\n (e, p),Normal s\\<rangle> =n\\<Rightarrow> t;\n        s \\<in> P; t \\<notin> Fault ` F\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "from exec_e [simplified]"], ["proof (chain)\npicking this:\n  \\<Gamma>\\<turnstile> \\<langle>Basic\n                                 (upd e),Normal\n    s\\<rangle> =n\\<Rightarrow> s'", "have s': \"s'=Normal (upd e s)\""], ["proof (prove)\nusing this:\n  \\<Gamma>\\<turnstile> \\<langle>Basic\n                                 (upd e),Normal\n    s\\<rangle> =n\\<Rightarrow> s'\n\ngoal (1 subgoal):\n 1. s' = Normal (upd e s)", "by cases simp"], ["proof (state)\nthis:\n  s' = Normal (upd e s)\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>(P, p, Q, A)\\<in>\\<Theta>.\n                   \\<Gamma>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P Call p Q,A;\n        \\<Gamma>\\<turnstile> \\<langle>callClosure upd\n (e, p),Normal s\\<rangle> =n\\<Rightarrow> t;\n        s \\<in> P; t \\<notin> Fault ` F\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "from ap"], ["proof (chain)\npicking this:\n  upd e = upd e' \\<circ> upd x", "obtain s'' where\n   s'': \"upd x s = s''\" and upd_e': \"upd e' s''=upd e s\""], ["proof (prove)\nusing this:\n  upd e = upd e' \\<circ> upd x\n\ngoal (1 subgoal):\n 1. (\\<And>s''.\n        \\<lbrakk>upd x s = s''; upd e' s'' = upd e s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  upd x s = s''\n  upd e' s'' = upd e s\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>(P, p, Q, A)\\<in>\\<Theta>.\n                   \\<Gamma>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P Call p Q,A;\n        \\<Gamma>\\<turnstile> \\<langle>callClosure upd\n (e, p),Normal s\\<rangle> =n\\<Rightarrow> t;\n        s \\<in> P; t \\<notin> Fault ` F\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "from ap s' execn.Basic [where f=\"(upd (fst (e', p)))\" and s=\"upd x s\" and \\<Gamma>=\\<Gamma>]"], ["proof (chain)\npicking this:\n  upd e = upd e' \\<circ> upd x\n  s' = Normal (upd e s)\n  \\<Gamma>\\<turnstile> \\<langle>Basic\n                                 (upd (fst\n  (e',\n   p))),Normal\n         (upd x\n           s)\\<rangle> =?n\\<Rightarrow> Normal (upd (fst (e', p)) (upd x s))", "have exec_e': \"\\<Gamma>\\<turnstile> \\<langle>Basic (upd (fst (e', p))),Normal (upd x s)\\<rangle> =n\\<Rightarrow> s'\""], ["proof (prove)\nusing this:\n  upd e = upd e' \\<circ> upd x\n  s' = Normal (upd e s)\n  \\<Gamma>\\<turnstile> \\<langle>Basic\n                                 (upd (fst\n  (e',\n   p))),Normal\n         (upd x\n           s)\\<rangle> =?n\\<Rightarrow> Normal (upd (fst (e', p)) (upd x s))\n\ngoal (1 subgoal):\n 1. \\<Gamma>\\<turnstile> \\<langle>Basic\n                                   (upd (fst\n    (e', p))),Normal (upd x s)\\<rangle> =n\\<Rightarrow> s'", "by simp"], ["proof (state)\nthis:\n  \\<Gamma>\\<turnstile> \\<langle>Basic\n                                 (upd (fst\n  (e', p))),Normal (upd x s)\\<rangle> =n\\<Rightarrow> s'\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>(P, p, Q, A)\\<in>\\<Theta>.\n                   \\<Gamma>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P Call p Q,A;\n        \\<Gamma>\\<turnstile> \\<langle>callClosure upd\n (e, p),Normal s\\<rangle> =n\\<Rightarrow> t;\n        s \\<in> P; t \\<notin> Fault ` F\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "with exec_p"], ["proof (chain)\npicking this:\n  \\<Gamma>\\<turnstile> \\<langle>Call\n                                 (snd (e, p)),s'\\<rangle> =n\\<Rightarrow> t\n  \\<Gamma>\\<turnstile> \\<langle>Basic\n                                 (upd (fst\n  (e', p))),Normal (upd x s)\\<rangle> =n\\<Rightarrow> s'", "have \"\\<Gamma>\\<turnstile> \\<langle>callClosure upd (e', p),Normal (upd x s)\\<rangle> =n\\<Rightarrow> t\""], ["proof (prove)\nusing this:\n  \\<Gamma>\\<turnstile> \\<langle>Call\n                                 (snd (e, p)),s'\\<rangle> =n\\<Rightarrow> t\n  \\<Gamma>\\<turnstile> \\<langle>Basic\n                                 (upd (fst\n  (e', p))),Normal (upd x s)\\<rangle> =n\\<Rightarrow> s'\n\ngoal (1 subgoal):\n 1. \\<Gamma>\\<turnstile> \\<langle>callClosure upd\n                                   (e',\n                                    p),Normal\n  (upd x s)\\<rangle> =n\\<Rightarrow> t", "by (auto simp add: callClosure_def intro: execn.Seq)"], ["proof (state)\nthis:\n  \\<Gamma>\\<turnstile> \\<langle>callClosure upd\n                                 (e',\n                                  p),Normal\n(upd x s)\\<rangle> =n\\<Rightarrow> t\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>\\<forall>(P, p, Q, A)\\<in>\\<Theta>.\n                   \\<Gamma>\\<Turnstile>n:\\<^bsub>/F\\<^esub> P Call p Q,A;\n        \\<Gamma>\\<turnstile> \\<langle>callClosure upd\n (e, p),Normal s\\<rangle> =n\\<Rightarrow> t;\n        s \\<in> P; t \\<notin> Fault ` F\\<rbrakk>\n       \\<Longrightarrow> t \\<in> Normal ` Q \\<union> Abrupt ` A", "from cnvalidD [OF valid [rule_format] ctxt this init_P'] t Q A"], ["proof (chain)\npicking this:\n  t \\<notin> Fault ` F \\<Longrightarrow>\n  t \\<in> Normal ` Q' \\<union> Abrupt ` A'\n  t \\<notin> Fault ` F\n  Q' \\<subseteq> Q\n  A' \\<subseteq> A", "show \"t \\<in> Normal ` Q \\<union> Abrupt ` A\""], ["proof (prove)\nusing this:\n  t \\<notin> Fault ` F \\<Longrightarrow>\n  t \\<in> Normal ` Q' \\<union> Abrupt ` A'\n  t \\<notin> Fault ` F\n  Q' \\<subseteq> Q\n  A' \\<subseteq> A\n\ngoal (1 subgoal):\n 1. t \\<in> Normal ` Q \\<union> Abrupt ` A", "by auto"], ["proof (state)\nthis:\n  t \\<in> Normal ` Q \\<union> Abrupt ` A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma app_closure:\n  assumes adapt: \"P \\<subseteq> {s. \\<exists>P' Q' A'. \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F\\<^esub> P' (callClosure upd (e',p)) Q',A' \\<and>\n                           upd x s \\<in> P' \\<and> Q' \\<subseteq> Q \\<and> A' \\<subseteq> A}\"\n  assumes ap: \"upd e = upd e' \\<circ> upd x\"\n  shows \"\\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F\\<^esub> P (callClosure upd (e,p)) Q,A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile>\\<^bsub>/F \\<^esub>P callClosure upd (e, p) Q,A", "apply (rule hoare_complete')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub>\n       P callClosure upd (e, p) Q,A", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub>\n       P callClosure upd (e, p) Q,A", "apply (rule app_closure_sound [where x=x and e'=e', OF _ ap])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       P \\<subseteq> {s. \\<exists>P' Q' A'.\n                            \\<forall>n.\n                               \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub>\n                               P' callClosure upd (e', p) Q',A' \\<and>\n                               upd x s \\<in> P' \\<and>\n                               Q' \\<subseteq> Q \\<and> A' \\<subseteq> A}", "using adapt"], ["proof (prove)\nusing this:\n  P \\<subseteq> {s. \\<exists>P' Q' A'.\n                       \\<Gamma>,\\<Theta>\n                          \\<turnstile>\\<^bsub>/F \\<^esub>P'\n                   callClosure upd (e', p) Q',A' \\<and>\n                       upd x s \\<in> P' \\<and>\n                       Q' \\<subseteq> Q \\<and> A' \\<subseteq> A}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       P \\<subseteq> {s. \\<exists>P' Q' A'.\n                            \\<forall>n.\n                               \\<Gamma>,\\<Theta>\\<Turnstile>n:\\<^bsub>/F\\<^esub>\n                               P' callClosure upd (e', p) Q',A' \\<and>\n                               upd x s \\<in> P' \\<and>\n                               Q' \\<subseteq> Q \\<and> A' \\<subseteq> A}", "apply (blast intro: hoare_cnvalid)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma app_closure_spec:\n  assumes adapt: \"P \\<subseteq> {s. \\<exists>Z. upd x s \\<in> P' Z \\<and> Q' Z \\<subseteq> Q \\<and> A' Z \\<subseteq> A}\"\n  assumes ap: \"upd e = upd e' \\<circ> upd x\"\n  assumes spec: \"\\<forall>Z. \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F\\<^esub> (P' Z) (callClosure upd (e',p)) (Q' Z),(A' Z)\"\n  shows \"\\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F\\<^esub> P (callClosure upd (e,p)) Q,A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile>\\<^bsub>/F \\<^esub>P callClosure upd (e, p) Q,A", "apply (rule app_closure [OF _ ap])"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<subseteq> {s. \\<exists>P' Q' A'.\n                         \\<Gamma>,\\<Theta>\n                            \\<turnstile>\\<^bsub>/F \\<^esub>P'\n                     callClosure upd (e', p) Q',A' \\<and>\n                         upd x s \\<in> P' \\<and>\n                         Q' \\<subseteq> Q \\<and> A' \\<subseteq> A}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> P \\<Longrightarrow>\n       \\<exists>P' Q' A'.\n          \\<Gamma>,\\<Theta>\n             \\<turnstile>\\<^bsub>/F \\<^esub>P' callClosure upd (e', p) Q',\n      A' \\<and>\n          upd x xa \\<in> P' \\<and> Q' \\<subseteq> Q \\<and> A' \\<subseteq> A", "using adapt spec"], ["proof (prove)\nusing this:\n  P \\<subseteq> {s. \\<exists>Z.\n                       upd x s \\<in> P' Z \\<and>\n                       Q' Z \\<subseteq> Q \\<and> A' Z \\<subseteq> A}\n  \\<forall>Z.\n     \\<Gamma>,\\<Theta>\n        \\<turnstile>\\<^bsub>/F \\<^esub>(P' Z) callClosure upd (e', p)\n (Q' Z),(A' Z)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> P \\<Longrightarrow>\n       \\<exists>P' Q' A'.\n          \\<Gamma>,\\<Theta>\n             \\<turnstile>\\<^bsub>/F \\<^esub>P' callClosure upd (e', p) Q',\n      A' \\<and>\n          upd x xa \\<in> P' \\<and> Q' \\<subseteq> Q \\<and> A' \\<subseteq> A", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> P;\n        P \\<subseteq> {s. \\<exists>Z.\n                             upd x s \\<in> P' Z \\<and>\n                             Q' Z \\<subseteq> Q \\<and> A' Z \\<subseteq> A};\n        \\<forall>Z.\n           \\<Gamma>,\\<Theta>\n              \\<turnstile>\\<^bsub>/F \\<^esub>(P' Z) callClosure upd (e', p)\n       (Q' Z),(A' Z)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P' Q' A'.\n                            \\<Gamma>,\\<Theta>\n                               \\<turnstile>\\<^bsub>/F \\<^esub>P'\n                        callClosure upd (e', p) Q',A' \\<and>\n                            upd x xa \\<in> P' \\<and>\n                            Q' \\<subseteq> Q \\<and> A' \\<subseteq> A", "apply (drule (1) in_subsetD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> P;\n        \\<forall>Z.\n           \\<Gamma>,\\<Theta>\n              \\<turnstile>\\<^bsub>/F \\<^esub>(P' Z) callClosure upd (e', p)\n       (Q' Z),(A' Z);\n        xa \\<in> {s. \\<exists>Z.\n                        upd x s \\<in> P' Z \\<and>\n                        Q' Z \\<subseteq> Q \\<and>\n                        A' Z \\<subseteq> A}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P' Q' A'.\n                            \\<Gamma>,\\<Theta>\n                               \\<turnstile>\\<^bsub>/F \\<^esub>P'\n                        callClosure upd (e', p) Q',A' \\<and>\n                            upd x xa \\<in> P' \\<and>\n                            Q' \\<subseteq> Q \\<and> A' \\<subseteq> A", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa Z.\n       \\<lbrakk>xa \\<in> P;\n        \\<forall>Z.\n           \\<Gamma>,\\<Theta>\n              \\<turnstile>\\<^bsub>/F \\<^esub>(P' Z) callClosure upd (e', p)\n       (Q' Z),(A' Z);\n        upd x xa \\<in> P' Z; Q' Z \\<subseteq> Q; A' Z \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P' Q' A'.\n                            \\<Gamma>,\\<Theta>\n                               \\<turnstile>\\<^bsub>/F \\<^esub>P'\n                        callClosure upd (e', p) Q',A' \\<and>\n                            upd x xa \\<in> P' \\<and>\n                            Q' \\<subseteq> Q \\<and> A' \\<subseteq> A", "apply (rule_tac x=\"P' Z\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa Z.\n       \\<lbrakk>xa \\<in> P;\n        \\<forall>Z.\n           \\<Gamma>,\\<Theta>\n              \\<turnstile>\\<^bsub>/F \\<^esub>(P' Z) callClosure upd (e', p)\n       (Q' Z),(A' Z);\n        upd x xa \\<in> P' Z; Q' Z \\<subseteq> Q; A' Z \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' A'.\n                            \\<Gamma>,\\<Theta>\n                               \\<turnstile>\\<^bsub>/F \\<^esub>(P' Z)\n                        callClosure upd (e', p) Q',A' \\<and>\n                            upd x xa \\<in> P' Z \\<and>\n                            Q' \\<subseteq> Q \\<and> A' \\<subseteq> A", "apply (rule_tac x=\"Q' Z\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa Z.\n       \\<lbrakk>xa \\<in> P;\n        \\<forall>Z.\n           \\<Gamma>,\\<Theta>\n              \\<turnstile>\\<^bsub>/F \\<^esub>(P' Z) callClosure upd (e', p)\n       (Q' Z),(A' Z);\n        upd x xa \\<in> P' Z; Q' Z \\<subseteq> Q; A' Z \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A'.\n                            \\<Gamma>,\\<Theta>\n                               \\<turnstile>\\<^bsub>/F \\<^esub>(P' Z)\n                        callClosure upd (e', p) (Q' Z),A' \\<and>\n                            upd x xa \\<in> P' Z \\<and>\n                            Q' Z \\<subseteq> Q \\<and> A' \\<subseteq> A", "apply (rule_tac x=\"A' Z\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa Z.\n       \\<lbrakk>xa \\<in> P;\n        \\<forall>Z.\n           \\<Gamma>,\\<Theta>\n              \\<turnstile>\\<^bsub>/F \\<^esub>(P' Z) callClosure upd (e', p)\n       (Q' Z),(A' Z);\n        upd x xa \\<in> P' Z; Q' Z \\<subseteq> Q; A' Z \\<subseteq> A\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>,\\<Theta>\n                            \\<turnstile>\\<^bsub>/F \\<^esub>(P' Z)\n                     callClosure upd (e', p) (Q' Z),(A' Z) \\<and>\n                         upd x xa \\<in> P' Z \\<and>\n                         Q' Z \\<subseteq> Q \\<and> A' Z \\<subseteq> A", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Implementation of closures as association lists.\\<close>"], ["", "definition \"gen_upd var es s = foldl (\\<lambda>s (x,i). the (var x) i s) s es\""], ["", "definition \"ap es c \\<equiv> (es@fst c,snd c)\""], ["", "lemma gen_upd_app: \"\\<And>es'. gen_upd var (es@es') = gen_upd var es' \\<circ> gen_upd var es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>es'.\n       gen_upd var (es @ es') = gen_upd var es' \\<circ> gen_upd var es", "apply (induct es)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>es'.\n       gen_upd var ([] @ es') = gen_upd var es' \\<circ> gen_upd var []\n 2. \\<And>a es es'.\n       (\\<And>es'.\n           gen_upd var (es @ es') =\n           gen_upd var es' \\<circ> gen_upd var es) \\<Longrightarrow>\n       gen_upd var ((a # es) @ es') =\n       gen_upd var es' \\<circ> gen_upd var (a # es)", "apply  (rule ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>es' x.\n       gen_upd var ([] @ es') x = (gen_upd var es' \\<circ> gen_upd var []) x\n 2. \\<And>a es es'.\n       (\\<And>es'.\n           gen_upd var (es @ es') =\n           gen_upd var es' \\<circ> gen_upd var es) \\<Longrightarrow>\n       gen_upd var ((a # es) @ es') =\n       gen_upd var es' \\<circ> gen_upd var (a # es)", "apply  (simp add: gen_upd_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a es es'.\n       (\\<And>es'.\n           gen_upd var (es @ es') =\n           gen_upd var es' \\<circ> gen_upd var es) \\<Longrightarrow>\n       gen_upd var ((a # es) @ es') =\n       gen_upd var es' \\<circ> gen_upd var (a # es)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a es es' x.\n       (\\<And>es'.\n           gen_upd var (es @ es') =\n           gen_upd var es' \\<circ> gen_upd var es) \\<Longrightarrow>\n       gen_upd var ((a # es) @ es') x =\n       (gen_upd var es' \\<circ> gen_upd var (a # es)) x", "apply (simp add: gen_upd_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma gen_upd_ap:\n  \"gen_upd var (fst (ap es (es',p))) = gen_upd var es' \\<circ> gen_upd var es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_upd var (fst (ap es (es', p))) =\n    gen_upd var es' \\<circ> gen_upd var es", "by (simp add: gen_upd_app ap_def)"], ["", "lemma ap_closure:\n  assumes adapt: \"P \\<subseteq> {s. \\<exists>P' Q' A'. \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F\\<^esub> P' (callClosure (gen_upd var) c) Q',A' \\<and>\n                           gen_upd var es s \\<in> P' \\<and> Q' \\<subseteq> Q \\<and> A' \\<subseteq> A}\"\n  shows \"\\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F\\<^esub> P (callClosure (gen_upd var) (ap es c)) Q,A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile>\\<^bsub>/F \\<^esub>P callClosure (gen_upd var) (ap es c)\nQ,A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile>\\<^bsub>/F \\<^esub>P callClosure (gen_upd var) (ap es c)\nQ,A", "obtain es' p where c: \"c=(es',p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>es' p. c = (es', p) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases c)"], ["proof (state)\nthis:\n  c = (es', p)\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile>\\<^bsub>/F \\<^esub>P callClosure (gen_upd var) (ap es c)\nQ,A", "have \"gen_upd var (fst (ap es (es',p))) = gen_upd var es' \\<circ> gen_upd var es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_upd var (fst (ap es (es', p))) =\n    gen_upd var es' \\<circ> gen_upd var es", "by (simp add: gen_upd_ap)"], ["proof (state)\nthis:\n  gen_upd var (fst (ap es (es', p))) =\n  gen_upd var es' \\<circ> gen_upd var es\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile>\\<^bsub>/F \\<^esub>P callClosure (gen_upd var) (ap es c)\nQ,A", "from app_closure [OF adapt [simplified c] this]"], ["proof (chain)\npicking this:\n  \\<Gamma>,\\<Theta>\n     \\<turnstile>\\<^bsub>/F \\<^esub>P callClosure (gen_upd var)\n (fst (ap es (es', p)), p)\n                                    Q,A", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<Theta>\n     \\<turnstile>\\<^bsub>/F \\<^esub>P callClosure (gen_upd var)\n (fst (ap es (es', p)), p)\n                                    Q,A\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile>\\<^bsub>/F \\<^esub>P callClosure (gen_upd var) (ap es c)\nQ,A", "by (simp add: c ap_def)"], ["proof (state)\nthis:\n  \\<Gamma>,\\<Theta>\n     \\<turnstile>\\<^bsub>/F \\<^esub>P callClosure (gen_upd var) (ap es c) Q,\n                                    A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ap_closure_spec:\n  assumes adapt: \"P \\<subseteq> {s. \\<exists>Z. gen_upd var es s \\<in> P' Z \\<and> Q' Z \\<subseteq> Q \\<and> A' Z \\<subseteq> A}\"\n  assumes spec: \"\\<forall>Z. \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F\\<^esub> (P' Z) (callClosure (gen_upd var) c) (Q' Z),(A' Z)\"\n  shows \"\\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F\\<^esub> P (callClosure (gen_upd var) (ap es c)) Q,A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile>\\<^bsub>/F \\<^esub>P callClosure (gen_upd var) (ap es c)\nQ,A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile>\\<^bsub>/F \\<^esub>P callClosure (gen_upd var) (ap es c)\nQ,A", "obtain es' p where c: \"c=(es',p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>es' p. c = (es', p) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases c)"], ["proof (state)\nthis:\n  c = (es', p)\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile>\\<^bsub>/F \\<^esub>P callClosure (gen_upd var) (ap es c)\nQ,A", "have \"gen_upd var (fst (ap es (es',p))) = gen_upd var es' \\<circ> gen_upd var es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gen_upd var (fst (ap es (es', p))) =\n    gen_upd var es' \\<circ> gen_upd var es", "by (simp add: gen_upd_ap)"], ["proof (state)\nthis:\n  gen_upd var (fst (ap es (es', p))) =\n  gen_upd var es' \\<circ> gen_upd var es\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile>\\<^bsub>/F \\<^esub>P callClosure (gen_upd var) (ap es c)\nQ,A", "from app_closure_spec [OF adapt [simplified c] this spec [simplified c]]"], ["proof (chain)\npicking this:\n  \\<Gamma>,\\<Theta>\n     \\<turnstile>\\<^bsub>/F \\<^esub>P callClosure (gen_upd var)\n (fst (ap es (es', p)), p)\n                                    Q,A", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Gamma>,\\<Theta>\n     \\<turnstile>\\<^bsub>/F \\<^esub>P callClosure (gen_upd var)\n (fst (ap es (es', p)), p)\n                                    Q,A\n\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile>\\<^bsub>/F \\<^esub>P callClosure (gen_upd var) (ap es c)\nQ,A", "by (simp add: c ap_def)"], ["proof (state)\nthis:\n  \\<Gamma>,\\<Theta>\n     \\<turnstile>\\<^bsub>/F \\<^esub>P callClosure (gen_upd var) (ap es c) Q,\n                                    A\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}