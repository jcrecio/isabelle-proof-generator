{"file_name": "/home/qj213/afp-2021-10-22/thys/Simpl/Language.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Simpl", "problem_names": ["lemma fst_guaranteeStripPair: \"fst (guaranteeStripPair f g) = f\"", "lemma snd_guaranteeStripPair: \"snd (guaranteeStripPair f g) = g\"", "lemma flatten_nonEmpty: \"flatten c \\<noteq> []\"", "lemma flatten_single: \"\\<forall>c \\<in> set (flatten c'). flatten c = [c]\"", "lemma flatten_sequence_id:\n  \"\\<lbrakk>cs\\<noteq>[];\\<forall>c \\<in> set cs. flatten c = [c]\\<rbrakk> \\<Longrightarrow> flatten (sequence Seq cs) = cs\"", "lemma flatten_app:\n  \"flatten (sequence Seq (flatten c1 @ flatten c2)) = flatten c1 @ flatten c2\"", "lemma flatten_sequence_flatten: \"flatten (sequence Seq (flatten c)) = flatten c\"", "lemma sequence_flatten_normalize: \"sequence Seq (flatten (normalize c)) = normalize c\"", "lemma flatten_normalize: \"\\<And>x xs. flatten (normalize c) = x#xs\n       \\<Longrightarrow> (case xs of [] \\<Rightarrow> normalize c = x\n              | (x'#xs') \\<Rightarrow> normalize c= Seq x (sequence Seq xs))\"", "lemma flatten_raise [simp]: \"flatten (raise f) = [Basic f, Throw]\"", "lemma flatten_condCatch [simp]: \"flatten (condCatch c1 b c2) = [condCatch c1 b c2]\"", "lemma flatten_bind [simp]: \"flatten (bind e c) = [bind e c]\"", "lemma flatten_bseq [simp]: \"flatten (bseq c1 c2) = flatten c1 @ flatten c2\"", "lemma flatten_block [simp]:\n  \"flatten (block init bdy return result) = [block init bdy return result]\"", "lemma flatten_call [simp]: \"flatten (call init p return result) = [call init p return result]\"", "lemma flatten_dynCall [simp]: \"flatten (dynCall init p return result) = [dynCall init p return result]\"", "lemma flatten_fcall [simp]: \"flatten (fcall init p return result c) = [fcall init p return result c]\"", "lemma flatten_switch [simp]: \"flatten (switch v Vcs) = [switch v Vcs]\"", "lemma flatten_guaranteeStrip [simp]:\n  \"flatten (guaranteeStrip f g c) = [guaranteeStrip f g c]\"", "lemma flatten_while [simp]: \"flatten (while gs b c) = [while gs b c]\"", "lemma flatten_whileAnno [simp]:\n  \"flatten (whileAnno b I V c) = [whileAnno b I V c]\"", "lemma flatten_whileAnnoG [simp]:\n  \"flatten (whileAnnoG gs b I V c) = [whileAnnoG gs b I V c]\"", "lemma flatten_specAnno [simp]:\n  \"flatten (specAnno P c Q A) = flatten (c undefined)\"", "lemmas flatten_simps = flatten.simps flatten_raise flatten_condCatch flatten_bind\n  flatten_block flatten_call flatten_dynCall flatten_fcall flatten_switch\n  flatten_guaranteeStrip\n  flatten_while flatten_whileAnno flatten_whileAnnoG flatten_specAnno", "lemma normalize_raise [simp]:\n \"normalize (raise f) = raise f\"", "lemma normalize_condCatch [simp]:\n \"normalize (condCatch c1 b c2) = condCatch (normalize c1) b (normalize c2)\"", "lemma normalize_bind [simp]:\n \"normalize (bind e c) = bind e (\\<lambda>v. normalize (c v))\"", "lemma normalize_bseq [simp]:\n \"normalize (bseq c1 c2) = sequence bseq\n                            ((flatten (normalize c1)) @ (flatten (normalize c2)))\"", "lemma normalize_block [simp]: \"normalize (block init bdy return c) =\n                         block init (normalize bdy) return (\\<lambda>s t. normalize (c s t))\"", "lemma normalize_call [simp]:\n  \"normalize (call init p return c) = call init p return (\\<lambda>i t. normalize (c i t))\"", "lemma normalize_dynCall [simp]:\n  \"normalize (dynCall init p return c) =\n    dynCall init p return (\\<lambda>s t. normalize (c s t))\"", "lemma normalize_fcall [simp]:\n  \"normalize (fcall init p return result c) =\n    fcall init p return result (\\<lambda>v. normalize (c v))\"", "lemma normalize_switch [simp]:\n  \"normalize (switch v Vcs) = switch v (map (\\<lambda>(V,c). (V,normalize c)) Vcs)\"", "lemma normalize_guaranteeStrip [simp]:\n  \"normalize (guaranteeStrip f g c) = guaranteeStrip f g (normalize c)\"", "lemma normalize_guards [simp]:\n  \"normalize (guards gs c) = guards gs (normalize c)\"", "lemma normalize_while [simp]:\n  \"normalize (while gs b c) = guards gs\n      (While b (sequence Seq (flatten (normalize c) @ flatten (guards gs Skip))))\"", "lemma normalize_whileAnno [simp]:\n  \"normalize (whileAnno b I V c) = whileAnno b I V (normalize c)\"", "lemma normalize_whileAnnoG [simp]:\n  \"normalize (whileAnnoG gs b I V c) = guards gs\n      (While b (sequence Seq (flatten (normalize c) @ flatten (guards gs Skip))))\"", "lemma normalize_specAnno [simp]:\n  \"normalize (specAnno P c Q A) = specAnno P (\\<lambda>s. normalize (c undefined)) Q A\"", "lemmas normalize_simps =\n  normalize.simps normalize_raise normalize_condCatch normalize_bind\n  normalize_block normalize_call normalize_dynCall normalize_fcall normalize_switch\n  normalize_guaranteeStrip normalize_guards\n  normalize_while normalize_whileAnno normalize_whileAnnoG normalize_specAnno", "lemma strip_simp [simp]: \"(strip F \\<Gamma>) p = map_option (strip_guards F) (\\<Gamma> p)\"", "lemma dom_strip: \"dom (strip F \\<Gamma>) = dom \\<Gamma>\"", "lemma strip_guards_idem: \"strip_guards F (strip_guards F c) = strip_guards F c\"", "lemma strip_idem: \"strip F (strip F \\<Gamma>) = strip F \\<Gamma>\"", "lemma strip_guards_raise [simp]:\n  \"strip_guards F (raise f) = raise f\"", "lemma strip_guards_condCatch [simp]:\n  \"strip_guards F (condCatch c1 b c2) =\n    condCatch (strip_guards F c1) b (strip_guards F c2)\"", "lemma strip_guards_bind [simp]:\n  \"strip_guards F (bind e c) = bind e (\\<lambda>v. strip_guards F (c v))\"", "lemma strip_guards_bseq [simp]:\n  \"strip_guards F (bseq c1 c2) = bseq (strip_guards F c1) (strip_guards F c2)\"", "lemma strip_guards_block [simp]:\n  \"strip_guards F (block init bdy return c) =\n    block init (strip_guards F bdy) return (\\<lambda>s t. strip_guards F (c s t))\"", "lemma strip_guards_call [simp]:\n  \"strip_guards F (call init p return c) =\n     call init p return (\\<lambda>s t. strip_guards F (c s t))\"", "lemma strip_guards_dynCall [simp]:\n  \"strip_guards F (dynCall init p return c) =\n     dynCall init p return (\\<lambda>s t. strip_guards F (c s t))\"", "lemma strip_guards_fcall [simp]:\n  \"strip_guards F (fcall init p return result c) =\n     fcall init p return result (\\<lambda>v. strip_guards F (c v))\"", "lemma strip_guards_switch [simp]:\n  \"strip_guards F (switch v Vc) =\n    switch v (map (\\<lambda>(V,c). (V,strip_guards F c)) Vc)\"", "lemma strip_guards_guaranteeStrip [simp]:\n  \"strip_guards F (guaranteeStrip f g c) =\n    (if f \\<in> F then strip_guards F c\n     else guaranteeStrip f g (strip_guards F c))\"", "lemma guaranteeStripPair_split_conv [simp]: \"case_prod c (guaranteeStripPair f g) = c f g\"", "lemma strip_guards_guards [simp]: \"strip_guards F (guards gs c) =\n        guards (filter (\\<lambda>(f,g). f \\<notin> F) gs) (strip_guards F c)\"", "lemma strip_guards_while [simp]:\n \"strip_guards F (while gs b  c) =\n     while (filter (\\<lambda>(f,g). f \\<notin> F) gs) b (strip_guards F c)\"", "lemma strip_guards_whileAnno [simp]:\n \"strip_guards F (whileAnno b I V c) = whileAnno b I V (strip_guards F c)\"", "lemma strip_guards_whileAnnoG [simp]:\n \"strip_guards F (whileAnnoG gs b I V c) =\n     whileAnnoG (filter (\\<lambda>(f,g). f \\<notin> F) gs) b I V (strip_guards F c)\"", "lemma strip_guards_specAnno [simp]:\n  \"strip_guards F (specAnno P c Q A) =\n    specAnno P (\\<lambda>s. strip_guards F (c undefined)) Q A\"", "lemmas strip_guards_simps = strip_guards.simps strip_guards_raise\n  strip_guards_condCatch strip_guards_bind strip_guards_bseq strip_guards_block\n  strip_guards_dynCall strip_guards_fcall strip_guards_switch\n  strip_guards_guaranteeStrip guaranteeStripPair_split_conv strip_guards_guards\n  strip_guards_while strip_guards_whileAnno strip_guards_whileAnnoG\n  strip_guards_specAnno", "lemma mark_guards_raise: \"mark_guards f (raise g) = raise g\"", "lemma mark_guards_condCatch [simp]:\n  \"mark_guards f (condCatch c1 b c2) =\n    condCatch (mark_guards f c1) b (mark_guards f c2)\"", "lemma mark_guards_bind [simp]:\n  \"mark_guards f (bind e c) = bind e (\\<lambda>v. mark_guards f (c v))\"", "lemma mark_guards_bseq [simp]:\n  \"mark_guards f (bseq c1 c2) = bseq (mark_guards f c1) (mark_guards f c2)\"", "lemma mark_guards_block [simp]:\n  \"mark_guards f (block init bdy return c) =\n    block init (mark_guards f bdy) return (\\<lambda>s t. mark_guards f (c s t))\"", "lemma mark_guards_call [simp]:\n  \"mark_guards f (call init p return c) =\n     call init p return (\\<lambda>s t. mark_guards f (c s t))\"", "lemma mark_guards_dynCall [simp]:\n  \"mark_guards f (dynCall init p return c) =\n     dynCall init p return (\\<lambda>s t. mark_guards f (c s t))\"", "lemma mark_guards_fcall [simp]:\n  \"mark_guards f (fcall init p return result c) =\n     fcall init p return result (\\<lambda>v. mark_guards f (c v))\"", "lemma mark_guards_switch [simp]:\n  \"mark_guards f (switch v vs) =\n     switch v (map (\\<lambda>(V,c). (V,mark_guards f c)) vs)\"", "lemma mark_guards_guaranteeStrip [simp]:\n  \"mark_guards f (guaranteeStrip f' g c) = guaranteeStrip f g (mark_guards f c)\"", "lemma mark_guards_guards [simp]:\n  \"mark_guards f (guards gs c) = guards (map (\\<lambda>(f',g). (f,g)) gs) (mark_guards f c)\"", "lemma mark_guards_while [simp]:\n \"mark_guards f (while gs b c) =\n    while (map (\\<lambda>(f',g). (f,g)) gs) b (mark_guards f c)\"", "lemma mark_guards_whileAnno [simp]:\n \"mark_guards f (whileAnno b I V c) = whileAnno b I V (mark_guards f c)\"", "lemma mark_guards_whileAnnoG [simp]:\n \"mark_guards f (whileAnnoG gs b I V c) =\n    whileAnnoG (map (\\<lambda>(f',g). (f,g)) gs) b I V (mark_guards f c)\"", "lemma mark_guards_specAnno [simp]:\n  \"mark_guards f (specAnno P c Q A) =\n    specAnno P (\\<lambda>s. mark_guards f (c undefined)) Q A\"", "lemmas mark_guards_simps = mark_guards.simps mark_guards_raise\n  mark_guards_condCatch mark_guards_bind mark_guards_bseq mark_guards_block\n  mark_guards_dynCall mark_guards_fcall mark_guards_switch\n  mark_guards_guaranteeStrip guaranteeStripPair_split_conv mark_guards_guards\n  mark_guards_while mark_guards_whileAnno mark_guards_whileAnnoG\n  mark_guards_specAnno", "lemma is_Guard_basic_simps [simp]:\n \"is_Guard Skip = False\"\n \"is_Guard (Basic f) = False\"\n \"is_Guard (Spec r) = False\"\n \"is_Guard (Seq c1 c2) = False\"\n \"is_Guard (Cond b c1 c2) = False\"\n \"is_Guard (While b c) = False\"\n \"is_Guard (Call p) = False\"\n \"is_Guard (DynCom C) = False\"\n \"is_Guard (Guard F g c) = True\"\n \"is_Guard (Throw) = False\"\n \"is_Guard (Catch c1 c2) = False\"\n \"is_Guard (raise f) = False\"\n \"is_Guard (condCatch c1 b c2) = False\"\n \"is_Guard (bind e cv) = False\"\n \"is_Guard (bseq c1 c2) = False\"\n \"is_Guard (block init bdy return cont) = False\"\n \"is_Guard (call init p return cont) = False\"\n \"is_Guard (dynCall init P return cont) = False\"\n \"is_Guard (fcall init p return result cont') = False\"\n \"is_Guard (whileAnno b I V c) = False\"\n \"is_Guard (guaranteeStrip F g c) = True\"", "lemma is_Guard_switch [simp]:\n \"is_Guard (switch v Vc) = False\"", "lemmas is_Guard_simps = is_Guard_basic_simps is_Guard_switch", "lemma dest_Guard_guaranteeStrip [simp]: \"dest_Guard (guaranteeStrip f g c) = (f,g,c)\"", "lemmas dest_Guard_simps = dest_Guard.simps dest_Guard_guaranteeStrip", "lemma merge_guards_res_Skip: \"merge_guards c = Skip \\<Longrightarrow> c = Skip\"", "lemma merge_guards_res_Basic: \"merge_guards c = Basic f \\<Longrightarrow> c = Basic f\"", "lemma merge_guards_res_Spec: \"merge_guards c = Spec r \\<Longrightarrow> c = Spec r\"", "lemma merge_guards_res_Seq: \"merge_guards c = Seq c1 c2 \\<Longrightarrow>\n    \\<exists>c1' c2'. c = Seq c1' c2' \\<and> merge_guards c1' = c1 \\<and> merge_guards c2' = c2\"", "lemma merge_guards_res_Cond: \"merge_guards c = Cond b c1 c2 \\<Longrightarrow>\n    \\<exists>c1' c2'. c = Cond b c1' c2' \\<and> merge_guards c1' = c1 \\<and> merge_guards c2' = c2\"", "lemma merge_guards_res_While: \"merge_guards c = While b c' \\<Longrightarrow>\n    \\<exists>c''. c = While b c''  \\<and> merge_guards c'' = c'\"", "lemma merge_guards_res_Call: \"merge_guards c = Call p \\<Longrightarrow> c = Call p\"", "lemma merge_guards_res_DynCom: \"merge_guards c = DynCom c' \\<Longrightarrow>\n    \\<exists>c''. c = DynCom c''  \\<and> (\\<lambda>s. (merge_guards (c'' s))) = c'\"", "lemma merge_guards_res_Throw: \"merge_guards c = Throw \\<Longrightarrow> c = Throw\"", "lemma merge_guards_res_Catch: \"merge_guards c = Catch c1 c2 \\<Longrightarrow>\n    \\<exists>c1' c2'. c = Catch c1' c2' \\<and> merge_guards c1' = c1 \\<and> merge_guards c2' = c2\"", "lemma merge_guards_res_Guard:\n \"merge_guards c = Guard f g c' \\<Longrightarrow> \\<exists>c'' f' g'. c = Guard f' g' c''\"", "lemmas merge_guards_res_simps = merge_guards_res_Skip merge_guards_res_Basic\n merge_guards_res_Spec merge_guards_res_Seq merge_guards_res_Cond\n merge_guards_res_While merge_guards_res_Call\n merge_guards_res_DynCom merge_guards_res_Throw merge_guards_res_Catch\n merge_guards_res_Guard", "lemma merge_guards_raise: \"merge_guards (raise g) = raise g\"", "lemma merge_guards_condCatch [simp]:\n  \"merge_guards (condCatch c1 b c2) =\n    condCatch (merge_guards c1) b (merge_guards c2)\"", "lemma merge_guards_bind [simp]:\n  \"merge_guards (bind e c) = bind e (\\<lambda>v. merge_guards (c v))\"", "lemma merge_guards_bseq [simp]:\n  \"merge_guards (bseq c1 c2) = bseq (merge_guards c1) (merge_guards c2)\"", "lemma merge_guards_block [simp]:\n  \"merge_guards (block init bdy return c) =\n    block init (merge_guards bdy) return (\\<lambda>s t. merge_guards (c s t))\"", "lemma merge_guards_call [simp]:\n  \"merge_guards (call init p return c) =\n     call init p return (\\<lambda>s t. merge_guards (c s t))\"", "lemma merge_guards_dynCall [simp]:\n  \"merge_guards (dynCall init p return c) =\n     dynCall init p return (\\<lambda>s t. merge_guards (c s t))\"", "lemma merge_guards_fcall [simp]:\n  \"merge_guards (fcall init p return result c) =\n     fcall init p return result (\\<lambda>v. merge_guards (c v))\"", "lemma merge_guards_switch [simp]:\n  \"merge_guards (switch v vs) =\n     switch v (map (\\<lambda>(V,c). (V,merge_guards c)) vs)\"", "lemma merge_guards_guaranteeStrip [simp]:\n  \"merge_guards (guaranteeStrip f g c) =\n    (let c' = (merge_guards c)\n     in if is_Guard c'\n        then let (f',g',c') = dest_Guard c'\n             in if f=f' then Guard f (g \\<inter> g') c'\n                        else Guard f g (Guard f' g' c')\n        else Guard f g c')\"", "lemma merge_guards_whileAnno [simp]:\n \"merge_guards (whileAnno b I V c) = whileAnno b I V (merge_guards c)\"", "lemma merge_guards_specAnno [simp]:\n  \"merge_guards (specAnno P c Q A) =\n    specAnno P (\\<lambda>s. merge_guards (c undefined)) Q A\"", "lemmas merge_guards_simps = merge_guards.simps merge_guards_raise\n  merge_guards_condCatch merge_guards_bind merge_guards_bseq merge_guards_block\n  merge_guards_dynCall merge_guards_fcall merge_guards_switch\n  merge_guards_guaranteeStrip merge_guards_whileAnno merge_guards_specAnno", "lemma noguards_strip_guards: \"noguards (strip_guards UNIV c)\"", "lemma wf_com_rel: \"wf com_rel\"", "lemma inter_guards_strip_eq:\n  \"\\<And>c. (c1 \\<inter>\\<^sub>g c2) = Some c  \\<Longrightarrow>\n    (strip_guards UNIV c = strip_guards UNIV c1) \\<and>\n    (strip_guards UNIV c = strip_guards UNIV c2)\"", "lemma inter_guards_sym: \"\\<And>c. (c1 \\<inter>\\<^sub>g c2) = Some c \\<Longrightarrow> (c2 \\<inter>\\<^sub>g c1) = Some c\"", "lemma inter_guards_Skip: \"(Skip \\<inter>\\<^sub>g c2) = Some c = (c2=Skip \\<and> c=Skip)\"", "lemma inter_guards_Basic:\n  \"((Basic f) \\<inter>\\<^sub>g c2) = Some c = (c2=Basic f \\<and> c=Basic f)\"", "lemma inter_guards_Spec:\n  \"((Spec r) \\<inter>\\<^sub>g c2) = Some c = (c2=Spec r \\<and> c=Spec r)\"", "lemma inter_guards_Seq:\n  \"(Seq a1 a2 \\<inter>\\<^sub>g c2) = Some c =\n     (\\<exists>b1 b2 d1 d2. c2=Seq b1 b2 \\<and> (a1 \\<inter>\\<^sub>g b1) = Some d1 \\<and>\n        (a2 \\<inter>\\<^sub>g b2) = Some d2 \\<and> c=Seq d1 d2)\"", "lemma inter_guards_Cond:\n  \"(Cond cnd t1 e1 \\<inter>\\<^sub>g c2) = Some c =\n     (\\<exists>t2 e2 t e. c2=Cond cnd t2 e2 \\<and> (t1 \\<inter>\\<^sub>g t2) = Some t \\<and>\n        (e1 \\<inter>\\<^sub>g e2) = Some e \\<and> c=Cond cnd t e)\"", "lemma inter_guards_While:\n \"(While cnd bdy1 \\<inter>\\<^sub>g c2) = Some c =\n     (\\<exists>bdy2 bdy. c2 =While cnd bdy2 \\<and> (bdy1 \\<inter>\\<^sub>g bdy2) = Some bdy \\<and>\n       c=While cnd bdy)\"", "lemma inter_guards_Call:\n  \"(Call p \\<inter>\\<^sub>g c2) = Some c =\n     (c2=Call p \\<and> c=Call p)\"", "lemma inter_guards_DynCom:\n  \"(DynCom f1 \\<inter>\\<^sub>g c2) = Some c =\n     (\\<exists>f2. c2=DynCom f2 \\<and> (\\<forall>s. ((f1 s) \\<inter>\\<^sub>g (f2 s)) \\<noteq> None) \\<and>\n      c=DynCom (\\<lambda>s. the ((f1 s) \\<inter>\\<^sub>g (f2 s))))\"", "lemma inter_guards_Guard:\n  \"(Guard f g1 bdy1 \\<inter>\\<^sub>g c2) = Some c =\n     (\\<exists>g2 bdy2 bdy. c2=Guard f g2 bdy2 \\<and> (bdy1 \\<inter>\\<^sub>g bdy2) = Some bdy \\<and>\n       c=Guard f (g1 \\<inter> g2) bdy)\"", "lemma inter_guards_Throw:\n  \"(Throw \\<inter>\\<^sub>g c2) = Some c = (c2=Throw \\<and> c=Throw)\"", "lemma inter_guards_Catch:\n  \"(Catch a1 a2 \\<inter>\\<^sub>g c2) = Some c =\n     (\\<exists>b1 b2 d1 d2. c2=Catch b1 b2 \\<and> (a1 \\<inter>\\<^sub>g b1) = Some d1 \\<and>\n        (a2 \\<inter>\\<^sub>g b2) = Some d2 \\<and> c=Catch d1 d2)\"", "lemmas inter_guards_simps = inter_guards_Skip inter_guards_Basic inter_guards_Spec\n  inter_guards_Seq inter_guards_Cond inter_guards_While inter_guards_Call\n  inter_guards_DynCom inter_guards_Guard inter_guards_Throw\n  inter_guards_Catch", "lemma subseteq_guards_Skip:\n  \"c = Skip\" if \"c \\<subseteq>\\<^sub>g Skip\"", "lemma subseteq_guards_Basic:\n  \"c = Basic f\" if \"c \\<subseteq>\\<^sub>g Basic f\"", "lemma subseteq_guards_Spec:\n  \"c = Spec r\" if \"c \\<subseteq>\\<^sub>g Spec r\"", "lemma subseteq_guards_Seq:\n  \"\\<exists>c1' c2'. c = Seq c1' c2' \\<and> (c1' \\<subseteq>\\<^sub>g c1) \\<and> (c2' \\<subseteq>\\<^sub>g c2)\" if \"c \\<subseteq>\\<^sub>g Seq c1 c2\"", "lemma subseteq_guards_Cond:\n  \"\\<exists>c1' c2'. c=Cond b c1' c2' \\<and> (c1' \\<subseteq>\\<^sub>g c1) \\<and> (c2' \\<subseteq>\\<^sub>g c2)\" if \"c \\<subseteq>\\<^sub>g Cond b c1 c2\"", "lemma subseteq_guards_While:\n  \"\\<exists>c''. c=While b c'' \\<and> (c'' \\<subseteq>\\<^sub>g c')\" if \"c \\<subseteq>\\<^sub>g While b c'\"", "lemma subseteq_guards_Call:\n \"c = Call p\" if \"c \\<subseteq>\\<^sub>g Call p\"", "lemma subseteq_guards_DynCom:\n  \"\\<exists>C'. c=DynCom C' \\<and> (\\<forall>s. C' s \\<subseteq>\\<^sub>g C s)\" if \"c \\<subseteq>\\<^sub>g DynCom C\"", "lemma subseteq_guards_Guard:\n  \"(c \\<subseteq>\\<^sub>g c') \\<or> (\\<exists>c''. c = Guard f g c'' \\<and> (c'' \\<subseteq>\\<^sub>g c'))\" if \"c \\<subseteq>\\<^sub>g Guard f g c'\"", "lemma subseteq_guards_Throw:\n  \"c = Throw\" if \"c \\<subseteq>\\<^sub>g Throw\"", "lemma subseteq_guards_Catch:\n  \"\\<exists>c1' c2'. c = Catch c1' c2' \\<and> (c1' \\<subseteq>\\<^sub>g c1) \\<and> (c2' \\<subseteq>\\<^sub>g c2)\" if \"c \\<subseteq>\\<^sub>g Catch c1 c2\"", "lemmas subseteq_guardsD = subseteq_guards_Skip subseteq_guards_Basic\n subseteq_guards_Spec subseteq_guards_Seq subseteq_guards_Cond subseteq_guards_While\n subseteq_guards_Call subseteq_guards_DynCom subseteq_guards_Guard\n subseteq_guards_Throw subseteq_guards_Catch", "lemma subseteq_guards_Guard':\n  \"\\<exists>f' b' c'. d = Guard f' b' c'\" if \"Guard f b c \\<subseteq>\\<^sub>g d\"", "lemma subseteq_guards_refl: \"c \\<subseteq>\\<^sub>g c\""], "translations": [["", "lemma fst_guaranteeStripPair: \"fst (guaranteeStripPair f g) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (guaranteeStripPair f g) = f", "by (simp add: guaranteeStripPair_def)"], ["", "lemma snd_guaranteeStripPair: \"snd (guaranteeStripPair f g) = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (guaranteeStripPair f g) = g", "by (simp add: guaranteeStripPair_def)"], ["", "subsection \\<open>Operations on Simpl-Syntax\\<close>"], ["", "subsubsection \\<open>Normalisation of Sequential Composition: \\<open>sequence\\<close>, \\<open>flatten\\<close> and \\<open>normalize\\<close>\\<close>"], ["", "primrec flatten:: \"('s,'p,'f) com \\<Rightarrow> ('s,'p,'f) com list\"\nwhere\n\"flatten Skip = [Skip]\" |\n\"flatten (Basic f) = [Basic f]\" |\n\"flatten (Spec r) = [Spec r]\" |\n\"flatten (Seq c\\<^sub>1 c\\<^sub>2)  = flatten c\\<^sub>1 @ flatten c\\<^sub>2\" |\n\"flatten (Cond b c\\<^sub>1 c\\<^sub>2) = [Cond b c\\<^sub>1 c\\<^sub>2]\" |\n\"flatten (While b c) = [While b c]\" |\n\"flatten (Call p) = [Call p]\" |\n\"flatten (DynCom c) = [DynCom c]\" |\n\"flatten (Guard f g c) = [Guard f g c]\" |\n\"flatten Throw = [Throw]\" |\n\"flatten (Catch c\\<^sub>1 c\\<^sub>2) = [Catch c\\<^sub>1 c\\<^sub>2]\""], ["", "primrec sequence:: \"(('s,'p,'f) com \\<Rightarrow> ('s,'p,'f) com \\<Rightarrow> ('s,'p,'f) com) \\<Rightarrow>\n                      ('s,'p,'f) com list \\<Rightarrow> ('s,'p,'f) com\"\nwhere\n\"sequence seq [] = Skip\" |\n\"sequence seq (c#cs) = (case cs of [] \\<Rightarrow> c\n                        | _ \\<Rightarrow> seq c (sequence seq cs))\""], ["", "primrec normalize:: \"('s,'p,'f) com \\<Rightarrow> ('s,'p,'f) com\"\nwhere\n\"normalize Skip = Skip\" |\n\"normalize (Basic f) = Basic f\" |\n\"normalize (Spec r) = Spec r\" |\n\"normalize (Seq c\\<^sub>1 c\\<^sub>2)  = sequence Seq\n                            ((flatten (normalize c\\<^sub>1)) @ (flatten (normalize c\\<^sub>2)))\" |\n\"normalize (Cond b c\\<^sub>1 c\\<^sub>2) = Cond b (normalize c\\<^sub>1) (normalize c\\<^sub>2)\" |\n\"normalize (While b c) = While b (normalize c)\" |\n\"normalize (Call p) = Call p\" |\n\"normalize (DynCom c) = DynCom (\\<lambda>s. (normalize (c s)))\" |\n\"normalize (Guard f g c) = Guard f g (normalize c)\" |\n\"normalize Throw = Throw\" |\n\"normalize (Catch c\\<^sub>1 c\\<^sub>2) = Catch (normalize c\\<^sub>1) (normalize c\\<^sub>2)\""], ["", "lemma flatten_nonEmpty: \"flatten c \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten c \\<noteq> []", "by (induct c) simp_all"], ["", "lemma flatten_single: \"\\<forall>c \\<in> set (flatten c'). flatten c = [c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set (flatten c'). flatten c = [c]", "apply (induct c')"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<forall>c\\<in>set (flatten Skip). flatten c = [c]\n 2. \\<And>x. \\<forall>c\\<in>set (flatten (Basic x)). flatten c = [c]\n 3. \\<And>x. \\<forall>c\\<in>set (flatten (Spec x)). flatten c = [c]\n 4. \\<And>c'1 c'2.\n       \\<lbrakk>\\<forall>c\\<in>set (flatten c'1). flatten c = [c];\n        \\<forall>c\\<in>set (flatten c'2). flatten c = [c]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>set (flatten (Seq c'1 c'2)).\n                            flatten c = [c]\n 5. \\<And>x1 c'1 c'2.\n       \\<lbrakk>\\<forall>c\\<in>set (flatten c'1). flatten c = [c];\n        \\<forall>c\\<in>set (flatten c'2). flatten c = [c]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>set (flatten (Cond x1 c'1 c'2)).\n                            flatten c = [c]\n 6. \\<And>x1 c'.\n       \\<forall>c\\<in>set (flatten c'). flatten c = [c] \\<Longrightarrow>\n       \\<forall>c\\<in>set (flatten (While x1 c')). flatten c = [c]\n 7. \\<And>x. \\<forall>c\\<in>set (flatten (Call x)). flatten c = [c]\n 8. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> range x \\<Longrightarrow>\n           \\<forall>c\\<in>set (flatten xa).\n              flatten c = [c]) \\<Longrightarrow>\n       \\<forall>c\\<in>set (flatten (DynCom x)). flatten c = [c]\n 9. \\<And>x1 x2a c'.\n       \\<forall>c\\<in>set (flatten c'). flatten c = [c] \\<Longrightarrow>\n       \\<forall>c\\<in>set (flatten (Guard x1 x2a c')). flatten c = [c]\n 10. \\<forall>c\\<in>set (flatten Throw). flatten c = [c]\nA total of 11 subgoals...", "apply           simp"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x. \\<forall>c\\<in>set (flatten (Basic x)). flatten c = [c]\n 2. \\<And>x. \\<forall>c\\<in>set (flatten (Spec x)). flatten c = [c]\n 3. \\<And>c'1 c'2.\n       \\<lbrakk>\\<forall>c\\<in>set (flatten c'1). flatten c = [c];\n        \\<forall>c\\<in>set (flatten c'2). flatten c = [c]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>set (flatten (Seq c'1 c'2)).\n                            flatten c = [c]\n 4. \\<And>x1 c'1 c'2.\n       \\<lbrakk>\\<forall>c\\<in>set (flatten c'1). flatten c = [c];\n        \\<forall>c\\<in>set (flatten c'2). flatten c = [c]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>set (flatten (Cond x1 c'1 c'2)).\n                            flatten c = [c]\n 5. \\<And>x1 c'.\n       \\<forall>c\\<in>set (flatten c'). flatten c = [c] \\<Longrightarrow>\n       \\<forall>c\\<in>set (flatten (While x1 c')). flatten c = [c]\n 6. \\<And>x. \\<forall>c\\<in>set (flatten (Call x)). flatten c = [c]\n 7. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> range x \\<Longrightarrow>\n           \\<forall>c\\<in>set (flatten xa).\n              flatten c = [c]) \\<Longrightarrow>\n       \\<forall>c\\<in>set (flatten (DynCom x)). flatten c = [c]\n 8. \\<And>x1 x2a c'.\n       \\<forall>c\\<in>set (flatten c'). flatten c = [c] \\<Longrightarrow>\n       \\<forall>c\\<in>set (flatten (Guard x1 x2a c')). flatten c = [c]\n 9. \\<forall>c\\<in>set (flatten Throw). flatten c = [c]\n 10. \\<And>c'1 c'2.\n        \\<lbrakk>\\<forall>c\\<in>set (flatten c'1). flatten c = [c];\n         \\<forall>c\\<in>set (flatten c'2). flatten c = [c]\\<rbrakk>\n        \\<Longrightarrow> \\<forall>c\\<in>set (flatten (Catch c'1 c'2)).\n                             flatten c = [c]", "apply          simp"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x. \\<forall>c\\<in>set (flatten (Spec x)). flatten c = [c]\n 2. \\<And>c'1 c'2.\n       \\<lbrakk>\\<forall>c\\<in>set (flatten c'1). flatten c = [c];\n        \\<forall>c\\<in>set (flatten c'2). flatten c = [c]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>set (flatten (Seq c'1 c'2)).\n                            flatten c = [c]\n 3. \\<And>x1 c'1 c'2.\n       \\<lbrakk>\\<forall>c\\<in>set (flatten c'1). flatten c = [c];\n        \\<forall>c\\<in>set (flatten c'2). flatten c = [c]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>set (flatten (Cond x1 c'1 c'2)).\n                            flatten c = [c]\n 4. \\<And>x1 c'.\n       \\<forall>c\\<in>set (flatten c'). flatten c = [c] \\<Longrightarrow>\n       \\<forall>c\\<in>set (flatten (While x1 c')). flatten c = [c]\n 5. \\<And>x. \\<forall>c\\<in>set (flatten (Call x)). flatten c = [c]\n 6. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> range x \\<Longrightarrow>\n           \\<forall>c\\<in>set (flatten xa).\n              flatten c = [c]) \\<Longrightarrow>\n       \\<forall>c\\<in>set (flatten (DynCom x)). flatten c = [c]\n 7. \\<And>x1 x2a c'.\n       \\<forall>c\\<in>set (flatten c'). flatten c = [c] \\<Longrightarrow>\n       \\<forall>c\\<in>set (flatten (Guard x1 x2a c')). flatten c = [c]\n 8. \\<forall>c\\<in>set (flatten Throw). flatten c = [c]\n 9. \\<And>c'1 c'2.\n       \\<lbrakk>\\<forall>c\\<in>set (flatten c'1). flatten c = [c];\n        \\<forall>c\\<in>set (flatten c'2). flatten c = [c]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>set (flatten (Catch c'1 c'2)).\n                            flatten c = [c]", "apply         simp"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>c'1 c'2.\n       \\<lbrakk>\\<forall>c\\<in>set (flatten c'1). flatten c = [c];\n        \\<forall>c\\<in>set (flatten c'2). flatten c = [c]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>set (flatten (Seq c'1 c'2)).\n                            flatten c = [c]\n 2. \\<And>x1 c'1 c'2.\n       \\<lbrakk>\\<forall>c\\<in>set (flatten c'1). flatten c = [c];\n        \\<forall>c\\<in>set (flatten c'2). flatten c = [c]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>set (flatten (Cond x1 c'1 c'2)).\n                            flatten c = [c]\n 3. \\<And>x1 c'.\n       \\<forall>c\\<in>set (flatten c'). flatten c = [c] \\<Longrightarrow>\n       \\<forall>c\\<in>set (flatten (While x1 c')). flatten c = [c]\n 4. \\<And>x. \\<forall>c\\<in>set (flatten (Call x)). flatten c = [c]\n 5. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> range x \\<Longrightarrow>\n           \\<forall>c\\<in>set (flatten xa).\n              flatten c = [c]) \\<Longrightarrow>\n       \\<forall>c\\<in>set (flatten (DynCom x)). flatten c = [c]\n 6. \\<And>x1 x2a c'.\n       \\<forall>c\\<in>set (flatten c'). flatten c = [c] \\<Longrightarrow>\n       \\<forall>c\\<in>set (flatten (Guard x1 x2a c')). flatten c = [c]\n 7. \\<forall>c\\<in>set (flatten Throw). flatten c = [c]\n 8. \\<And>c'1 c'2.\n       \\<lbrakk>\\<forall>c\\<in>set (flatten c'1). flatten c = [c];\n        \\<forall>c\\<in>set (flatten c'2). flatten c = [c]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>set (flatten (Catch c'1 c'2)).\n                            flatten c = [c]", "apply        (simp (no_asm_use) )"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>c'1 c'2.\n       \\<lbrakk>\\<forall>c\\<in>set (flatten c'1). flatten c = [c];\n        \\<forall>c\\<in>set (flatten c'2). flatten c = [c]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>set (flatten c'1) \\<union>\n  set (flatten c'2).\n                            flatten c = [c]\n 2. \\<And>x1 c'1 c'2.\n       \\<lbrakk>\\<forall>c\\<in>set (flatten c'1). flatten c = [c];\n        \\<forall>c\\<in>set (flatten c'2). flatten c = [c]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>set (flatten (Cond x1 c'1 c'2)).\n                            flatten c = [c]\n 3. \\<And>x1 c'.\n       \\<forall>c\\<in>set (flatten c'). flatten c = [c] \\<Longrightarrow>\n       \\<forall>c\\<in>set (flatten (While x1 c')). flatten c = [c]\n 4. \\<And>x. \\<forall>c\\<in>set (flatten (Call x)). flatten c = [c]\n 5. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> range x \\<Longrightarrow>\n           \\<forall>c\\<in>set (flatten xa).\n              flatten c = [c]) \\<Longrightarrow>\n       \\<forall>c\\<in>set (flatten (DynCom x)). flatten c = [c]\n 6. \\<And>x1 x2a c'.\n       \\<forall>c\\<in>set (flatten c'). flatten c = [c] \\<Longrightarrow>\n       \\<forall>c\\<in>set (flatten (Guard x1 x2a c')). flatten c = [c]\n 7. \\<forall>c\\<in>set (flatten Throw). flatten c = [c]\n 8. \\<And>c'1 c'2.\n       \\<lbrakk>\\<forall>c\\<in>set (flatten c'1). flatten c = [c];\n        \\<forall>c\\<in>set (flatten c'2). flatten c = [c]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>set (flatten (Catch c'1 c'2)).\n                            flatten c = [c]", "apply        blast"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x1 c'1 c'2.\n       \\<lbrakk>\\<forall>c\\<in>set (flatten c'1). flatten c = [c];\n        \\<forall>c\\<in>set (flatten c'2). flatten c = [c]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>set (flatten (Cond x1 c'1 c'2)).\n                            flatten c = [c]\n 2. \\<And>x1 c'.\n       \\<forall>c\\<in>set (flatten c'). flatten c = [c] \\<Longrightarrow>\n       \\<forall>c\\<in>set (flatten (While x1 c')). flatten c = [c]\n 3. \\<And>x. \\<forall>c\\<in>set (flatten (Call x)). flatten c = [c]\n 4. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> range x \\<Longrightarrow>\n           \\<forall>c\\<in>set (flatten xa).\n              flatten c = [c]) \\<Longrightarrow>\n       \\<forall>c\\<in>set (flatten (DynCom x)). flatten c = [c]\n 5. \\<And>x1 x2a c'.\n       \\<forall>c\\<in>set (flatten c'). flatten c = [c] \\<Longrightarrow>\n       \\<forall>c\\<in>set (flatten (Guard x1 x2a c')). flatten c = [c]\n 6. \\<forall>c\\<in>set (flatten Throw). flatten c = [c]\n 7. \\<And>c'1 c'2.\n       \\<lbrakk>\\<forall>c\\<in>set (flatten c'1). flatten c = [c];\n        \\<forall>c\\<in>set (flatten c'2). flatten c = [c]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>set (flatten (Catch c'1 c'2)).\n                            flatten c = [c]", "apply       (simp (no_asm_use) )"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x1 c'.\n       \\<forall>c\\<in>set (flatten c'). flatten c = [c] \\<Longrightarrow>\n       \\<forall>c\\<in>set (flatten (While x1 c')). flatten c = [c]\n 2. \\<And>x. \\<forall>c\\<in>set (flatten (Call x)). flatten c = [c]\n 3. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> range x \\<Longrightarrow>\n           \\<forall>c\\<in>set (flatten xa).\n              flatten c = [c]) \\<Longrightarrow>\n       \\<forall>c\\<in>set (flatten (DynCom x)). flatten c = [c]\n 4. \\<And>x1 x2a c'.\n       \\<forall>c\\<in>set (flatten c'). flatten c = [c] \\<Longrightarrow>\n       \\<forall>c\\<in>set (flatten (Guard x1 x2a c')). flatten c = [c]\n 5. \\<forall>c\\<in>set (flatten Throw). flatten c = [c]\n 6. \\<And>c'1 c'2.\n       \\<lbrakk>\\<forall>c\\<in>set (flatten c'1). flatten c = [c];\n        \\<forall>c\\<in>set (flatten c'2). flatten c = [c]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>set (flatten (Catch c'1 c'2)).\n                            flatten c = [c]", "apply      (simp (no_asm_use) )"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x. \\<forall>c\\<in>set (flatten (Call x)). flatten c = [c]\n 2. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> range x \\<Longrightarrow>\n           \\<forall>c\\<in>set (flatten xa).\n              flatten c = [c]) \\<Longrightarrow>\n       \\<forall>c\\<in>set (flatten (DynCom x)). flatten c = [c]\n 3. \\<And>x1 x2a c'.\n       \\<forall>c\\<in>set (flatten c'). flatten c = [c] \\<Longrightarrow>\n       \\<forall>c\\<in>set (flatten (Guard x1 x2a c')). flatten c = [c]\n 4. \\<forall>c\\<in>set (flatten Throw). flatten c = [c]\n 5. \\<And>c'1 c'2.\n       \\<lbrakk>\\<forall>c\\<in>set (flatten c'1). flatten c = [c];\n        \\<forall>c\\<in>set (flatten c'2). flatten c = [c]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>set (flatten (Catch c'1 c'2)).\n                            flatten c = [c]", "apply     simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> range x \\<Longrightarrow>\n           \\<forall>c\\<in>set (flatten xa).\n              flatten c = [c]) \\<Longrightarrow>\n       \\<forall>c\\<in>set (flatten (DynCom x)). flatten c = [c]\n 2. \\<And>x1 x2a c'.\n       \\<forall>c\\<in>set (flatten c'). flatten c = [c] \\<Longrightarrow>\n       \\<forall>c\\<in>set (flatten (Guard x1 x2a c')). flatten c = [c]\n 3. \\<forall>c\\<in>set (flatten Throw). flatten c = [c]\n 4. \\<And>c'1 c'2.\n       \\<lbrakk>\\<forall>c\\<in>set (flatten c'1). flatten c = [c];\n        \\<forall>c\\<in>set (flatten c'2). flatten c = [c]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>set (flatten (Catch c'1 c'2)).\n                            flatten c = [c]", "apply    (simp (no_asm_use))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1 x2a c'.\n       \\<forall>c\\<in>set (flatten c'). flatten c = [c] \\<Longrightarrow>\n       \\<forall>c\\<in>set (flatten (Guard x1 x2a c')). flatten c = [c]\n 2. \\<forall>c\\<in>set (flatten Throw). flatten c = [c]\n 3. \\<And>c'1 c'2.\n       \\<lbrakk>\\<forall>c\\<in>set (flatten c'1). flatten c = [c];\n        \\<forall>c\\<in>set (flatten c'2). flatten c = [c]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>set (flatten (Catch c'1 c'2)).\n                            flatten c = [c]", "apply   (simp (no_asm_use))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>c\\<in>set (flatten Throw). flatten c = [c]\n 2. \\<And>c'1 c'2.\n       \\<lbrakk>\\<forall>c\\<in>set (flatten c'1). flatten c = [c];\n        \\<forall>c\\<in>set (flatten c'2). flatten c = [c]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>set (flatten (Catch c'1 c'2)).\n                            flatten c = [c]", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c'1 c'2.\n       \\<lbrakk>\\<forall>c\\<in>set (flatten c'1). flatten c = [c];\n        \\<forall>c\\<in>set (flatten c'2). flatten c = [c]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>set (flatten (Catch c'1 c'2)).\n                            flatten c = [c]", "apply (simp (no_asm_use))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma flatten_sequence_id:\n  \"\\<lbrakk>cs\\<noteq>[];\\<forall>c \\<in> set cs. flatten c = [c]\\<rbrakk> \\<Longrightarrow> flatten (sequence Seq cs) = cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cs \\<noteq> []; \\<forall>c\\<in>set cs. flatten c = [c]\\<rbrakk>\n    \\<Longrightarrow> flatten (sequence Seq cs) = cs", "apply (induct cs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>[] \\<noteq> []; \\<forall>c\\<in>set []. flatten c = [c]\\<rbrakk>\n    \\<Longrightarrow> flatten (sequence Seq []) = []\n 2. \\<And>a cs.\n       \\<lbrakk>\\<lbrakk>cs \\<noteq> [];\n                 \\<forall>c\\<in>set cs. flatten c = [c]\\<rbrakk>\n                \\<Longrightarrow> flatten (sequence Seq cs) = cs;\n        a # cs \\<noteq> [];\n        \\<forall>c\\<in>set (a # cs). flatten c = [c]\\<rbrakk>\n       \\<Longrightarrow> flatten (sequence Seq (a # cs)) = a # cs", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a cs.\n       \\<lbrakk>\\<lbrakk>cs \\<noteq> [];\n                 \\<forall>c\\<in>set cs. flatten c = [c]\\<rbrakk>\n                \\<Longrightarrow> flatten (sequence Seq cs) = cs;\n        a # cs \\<noteq> [];\n        \\<forall>c\\<in>set (a # cs). flatten c = [c]\\<rbrakk>\n       \\<Longrightarrow> flatten (sequence Seq (a # cs)) = a # cs", "apply (case_tac cs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a cs.\n       \\<lbrakk>\\<lbrakk>cs \\<noteq> [];\n                 \\<forall>c\\<in>set cs. flatten c = [c]\\<rbrakk>\n                \\<Longrightarrow> flatten (sequence Seq cs) = cs;\n        a # cs \\<noteq> []; \\<forall>c\\<in>set (a # cs). flatten c = [c];\n        cs = []\\<rbrakk>\n       \\<Longrightarrow> flatten (sequence Seq (a # cs)) = a # cs\n 2. \\<And>a cs aa list.\n       \\<lbrakk>\\<lbrakk>cs \\<noteq> [];\n                 \\<forall>c\\<in>set cs. flatten c = [c]\\<rbrakk>\n                \\<Longrightarrow> flatten (sequence Seq cs) = cs;\n        a # cs \\<noteq> []; \\<forall>c\\<in>set (a # cs). flatten c = [c];\n        cs = aa # list\\<rbrakk>\n       \\<Longrightarrow> flatten (sequence Seq (a # cs)) = a # cs", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a cs aa list.\n       \\<lbrakk>\\<lbrakk>cs \\<noteq> [];\n                 \\<forall>c\\<in>set cs. flatten c = [c]\\<rbrakk>\n                \\<Longrightarrow> flatten (sequence Seq cs) = cs;\n        a # cs \\<noteq> []; \\<forall>c\\<in>set (a # cs). flatten c = [c];\n        cs = aa # list\\<rbrakk>\n       \\<Longrightarrow> flatten (sequence Seq (a # cs)) = a # cs", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma flatten_app:\n  \"flatten (sequence Seq (flatten c1 @ flatten c2)) = flatten c1 @ flatten c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (sequence Seq (flatten c1 @ flatten c2)) =\n    flatten c1 @ flatten c2", "apply (rule flatten_sequence_id)"], ["proof (prove)\ngoal (2 subgoals):\n 1. flatten c1 @ flatten c2 \\<noteq> []\n 2. \\<forall>c\\<in>set (flatten c1 @ flatten c2). flatten c = [c]", "apply (simp add: flatten_nonEmpty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set (flatten c1 @ flatten c2). flatten c = [c]", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set (flatten c1) \\<union> set (flatten c2).\n       flatten c = [c]", "apply (insert flatten_single)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c'.\n        \\<forall>c\\<in>set (flatten c'). flatten c = [c]) \\<Longrightarrow>\n    \\<forall>c\\<in>set (flatten c1) \\<union> set (flatten c2).\n       flatten c = [c]", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma flatten_sequence_flatten: \"flatten (sequence Seq (flatten c)) = flatten c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (sequence Seq (flatten c)) = flatten c", "apply (induct c)"], ["proof (prove)\ngoal (11 subgoals):\n 1. flatten (sequence Seq (flatten Skip)) = flatten Skip\n 2. \\<And>x. flatten (sequence Seq (flatten (Basic x))) = flatten (Basic x)\n 3. \\<And>x. flatten (sequence Seq (flatten (Spec x))) = flatten (Spec x)\n 4. \\<And>c1 c2.\n       \\<lbrakk>flatten (sequence Seq (flatten c1)) = flatten c1;\n        flatten (sequence Seq (flatten c2)) = flatten c2\\<rbrakk>\n       \\<Longrightarrow> flatten (sequence Seq (flatten (Seq c1 c2))) =\n                         flatten (Seq c1 c2)\n 5. \\<And>x1 c1 c2.\n       \\<lbrakk>flatten (sequence Seq (flatten c1)) = flatten c1;\n        flatten (sequence Seq (flatten c2)) = flatten c2\\<rbrakk>\n       \\<Longrightarrow> flatten (sequence Seq (flatten (Cond x1 c1 c2))) =\n                         flatten (Cond x1 c1 c2)\n 6. \\<And>x1 c.\n       flatten (sequence Seq (flatten c)) = flatten c \\<Longrightarrow>\n       flatten (sequence Seq (flatten (While x1 c))) = flatten (While x1 c)\n 7. \\<And>x. flatten (sequence Seq (flatten (Call x))) = flatten (Call x)\n 8. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> range x \\<Longrightarrow>\n           flatten (sequence Seq (flatten xa)) =\n           flatten xa) \\<Longrightarrow>\n       flatten (sequence Seq (flatten (DynCom x))) = flatten (DynCom x)\n 9. \\<And>x1 x2a c.\n       flatten (sequence Seq (flatten c)) = flatten c \\<Longrightarrow>\n       flatten (sequence Seq (flatten (Guard x1 x2a c))) =\n       flatten (Guard x1 x2a c)\n 10. flatten (sequence Seq (flatten Throw)) = flatten Throw\nA total of 11 subgoals...", "apply (auto simp add: flatten_app)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sequence_flatten_normalize: \"sequence Seq (flatten (normalize c)) = normalize c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sequence Seq (flatten (Language.normalize c)) = Language.normalize c", "apply (induct c)"], ["proof (prove)\ngoal (11 subgoals):\n 1. sequence Seq (flatten (Language.normalize Skip)) =\n    Language.normalize Skip\n 2. \\<And>x.\n       sequence Seq (flatten (Language.normalize (Basic x))) =\n       Language.normalize (Basic x)\n 3. \\<And>x.\n       sequence Seq (flatten (Language.normalize (Spec x))) =\n       Language.normalize (Spec x)\n 4. \\<And>c1 c2.\n       \\<lbrakk>sequence Seq (flatten (Language.normalize c1)) =\n                Language.normalize c1;\n        sequence Seq (flatten (Language.normalize c2)) =\n        Language.normalize c2\\<rbrakk>\n       \\<Longrightarrow> sequence Seq\n                          (flatten (Language.normalize (Seq c1 c2))) =\n                         Language.normalize (Seq c1 c2)\n 5. \\<And>x1 c1 c2.\n       \\<lbrakk>sequence Seq (flatten (Language.normalize c1)) =\n                Language.normalize c1;\n        sequence Seq (flatten (Language.normalize c2)) =\n        Language.normalize c2\\<rbrakk>\n       \\<Longrightarrow> sequence Seq\n                          (flatten (Language.normalize (Cond x1 c1 c2))) =\n                         Language.normalize (Cond x1 c1 c2)\n 6. \\<And>x1 c.\n       sequence Seq (flatten (Language.normalize c)) =\n       Language.normalize c \\<Longrightarrow>\n       sequence Seq (flatten (Language.normalize (While x1 c))) =\n       Language.normalize (While x1 c)\n 7. \\<And>x.\n       sequence Seq (flatten (Language.normalize (Call x))) =\n       Language.normalize (Call x)\n 8. \\<And>x.\n       (\\<And>xa.\n           xa \\<in> range x \\<Longrightarrow>\n           sequence Seq (flatten (Language.normalize xa)) =\n           Language.normalize xa) \\<Longrightarrow>\n       sequence Seq (flatten (Language.normalize (DynCom x))) =\n       Language.normalize (DynCom x)\n 9. \\<And>x1 x2a c.\n       sequence Seq (flatten (Language.normalize c)) =\n       Language.normalize c \\<Longrightarrow>\n       sequence Seq (flatten (Language.normalize (Guard x1 x2a c))) =\n       Language.normalize (Guard x1 x2a c)\n 10. sequence Seq (flatten (Language.normalize Throw)) =\n     Language.normalize Throw\nA total of 11 subgoals...", "apply (auto simp add:  flatten_app)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma flatten_normalize: \"\\<And>x xs. flatten (normalize c) = x#xs\n       \\<Longrightarrow> (case xs of [] \\<Rightarrow> normalize c = x\n              | (x'#xs') \\<Rightarrow> normalize c= Seq x (sequence Seq xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       flatten (Language.normalize c) = x # xs \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize c = x\n       | x' # xs' \\<Rightarrow>\n           Language.normalize c = Seq x (sequence Seq xs)", "proof (induct c)"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>x xs.\n       flatten (Language.normalize Skip) = x # xs \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize Skip = x\n       | x' # xs' \\<Rightarrow>\n           Language.normalize Skip = Seq x (sequence Seq xs)\n 2. \\<And>x xa xs.\n       flatten (Language.normalize (Basic x)) = xa # xs \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Basic x) = xa\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Basic x) = Seq xa (sequence Seq xs)\n 3. \\<And>x xa xs.\n       flatten (Language.normalize (Spec x)) = xa # xs \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Spec x) = xa\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Spec x) = Seq xa (sequence Seq xs)\n 4. \\<And>c1 c2 x xs.\n       \\<lbrakk>\\<And>x xs.\n                   flatten (Language.normalize c1) =\n                   x # xs \\<Longrightarrow>\n                   case xs of [] \\<Rightarrow> Language.normalize c1 = x\n                   | x' # xs' \\<Rightarrow>\n                       Language.normalize c1 = Seq x (sequence Seq xs);\n        \\<And>x xs.\n           flatten (Language.normalize c2) = x # xs \\<Longrightarrow>\n           case xs of [] \\<Rightarrow> Language.normalize c2 = x\n           | x' # xs' \\<Rightarrow>\n               Language.normalize c2 = Seq x (sequence Seq xs);\n        flatten (Language.normalize (Seq c1 c2)) = x # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (Seq c1 c2) =\n                             Seq x (sequence Seq xs)\n 5. \\<And>x1 c1 c2 x xs.\n       \\<lbrakk>\\<And>x xs.\n                   flatten (Language.normalize c1) =\n                   x # xs \\<Longrightarrow>\n                   case xs of [] \\<Rightarrow> Language.normalize c1 = x\n                   | x' # xs' \\<Rightarrow>\n                       Language.normalize c1 = Seq x (sequence Seq xs);\n        \\<And>x xs.\n           flatten (Language.normalize c2) = x # xs \\<Longrightarrow>\n           case xs of [] \\<Rightarrow> Language.normalize c2 = x\n           | x' # xs' \\<Rightarrow>\n               Language.normalize c2 = Seq x (sequence Seq xs);\n        flatten (Language.normalize (Cond x1 c1 c2)) = x # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow>\n                           Language.normalize (Cond x1 c1 c2) = x\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (Cond x1 c1 c2) =\n                             Seq x (sequence Seq xs)\n 6. \\<And>x1 c x xs.\n       \\<lbrakk>\\<And>x xs.\n                   flatten (Language.normalize c) = x # xs \\<Longrightarrow>\n                   case xs of [] \\<Rightarrow> Language.normalize c = x\n                   | x' # xs' \\<Rightarrow>\n                       Language.normalize c = Seq x (sequence Seq xs);\n        flatten (Language.normalize (While x1 c)) = x # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow>\n                           Language.normalize (While x1 c) = x\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (While x1 c) =\n                             Seq x (sequence Seq xs)\n 7. \\<And>x xa xs.\n       flatten (Language.normalize (Call x)) = xa # xs \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Call x) = xa\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Call x) = Seq xa (sequence Seq xs)\n 8. \\<And>x xa xs.\n       \\<lbrakk>\\<And>xa xaa xs.\n                   \\<lbrakk>xa \\<in> range x;\n                    flatten (Language.normalize xa) = xaa # xs\\<rbrakk>\n                   \\<Longrightarrow> case xs of\n                                     [] \\<Rightarrow>\n Language.normalize xa = xaa\n                                     | x' # xs' \\<Rightarrow>\n   Language.normalize xa = Seq xaa (sequence Seq xs);\n        flatten (Language.normalize (DynCom x)) = xa # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow> Language.normalize (DynCom x) = xa\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (DynCom x) =\n                             Seq xa (sequence Seq xs)\n 9. \\<And>x1 x2a c x xs.\n       \\<lbrakk>\\<And>x xs.\n                   flatten (Language.normalize c) = x # xs \\<Longrightarrow>\n                   case xs of [] \\<Rightarrow> Language.normalize c = x\n                   | x' # xs' \\<Rightarrow>\n                       Language.normalize c = Seq x (sequence Seq xs);\n        flatten (Language.normalize (Guard x1 x2a c)) = x # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow>\n                           Language.normalize (Guard x1 x2a c) = x\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (Guard x1 x2a c) =\n                             Seq x (sequence Seq xs)\n 10. \\<And>x xs.\n        flatten (Language.normalize Throw) = x # xs \\<Longrightarrow>\n        case xs of [] \\<Rightarrow> Language.normalize Throw = x\n        | x' # xs' \\<Rightarrow>\n            Language.normalize Throw = Seq x (sequence Seq xs)\nA total of 11 subgoals...", "case (Seq c1 c2)"], ["proof (state)\nthis:\n  flatten (Language.normalize c1) = ?x # ?xs \\<Longrightarrow>\n  case ?xs of [] \\<Rightarrow> Language.normalize c1 = ?x\n  | x' # xs' \\<Rightarrow> Language.normalize c1 = Seq ?x (sequence Seq ?xs)\n  flatten (Language.normalize c2) = ?x # ?xs \\<Longrightarrow>\n  case ?xs of [] \\<Rightarrow> Language.normalize c2 = ?x\n  | x' # xs' \\<Rightarrow> Language.normalize c2 = Seq ?x (sequence Seq ?xs)\n  flatten (Language.normalize (Seq c1 c2)) = x # xs\n\ngoal (11 subgoals):\n 1. \\<And>x xs.\n       flatten (Language.normalize Skip) = x # xs \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize Skip = x\n       | x' # xs' \\<Rightarrow>\n           Language.normalize Skip = Seq x (sequence Seq xs)\n 2. \\<And>x xa xs.\n       flatten (Language.normalize (Basic x)) = xa # xs \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Basic x) = xa\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Basic x) = Seq xa (sequence Seq xs)\n 3. \\<And>x xa xs.\n       flatten (Language.normalize (Spec x)) = xa # xs \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Spec x) = xa\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Spec x) = Seq xa (sequence Seq xs)\n 4. \\<And>c1 c2 x xs.\n       \\<lbrakk>\\<And>x xs.\n                   flatten (Language.normalize c1) =\n                   x # xs \\<Longrightarrow>\n                   case xs of [] \\<Rightarrow> Language.normalize c1 = x\n                   | x' # xs' \\<Rightarrow>\n                       Language.normalize c1 = Seq x (sequence Seq xs);\n        \\<And>x xs.\n           flatten (Language.normalize c2) = x # xs \\<Longrightarrow>\n           case xs of [] \\<Rightarrow> Language.normalize c2 = x\n           | x' # xs' \\<Rightarrow>\n               Language.normalize c2 = Seq x (sequence Seq xs);\n        flatten (Language.normalize (Seq c1 c2)) = x # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (Seq c1 c2) =\n                             Seq x (sequence Seq xs)\n 5. \\<And>x1 c1 c2 x xs.\n       \\<lbrakk>\\<And>x xs.\n                   flatten (Language.normalize c1) =\n                   x # xs \\<Longrightarrow>\n                   case xs of [] \\<Rightarrow> Language.normalize c1 = x\n                   | x' # xs' \\<Rightarrow>\n                       Language.normalize c1 = Seq x (sequence Seq xs);\n        \\<And>x xs.\n           flatten (Language.normalize c2) = x # xs \\<Longrightarrow>\n           case xs of [] \\<Rightarrow> Language.normalize c2 = x\n           | x' # xs' \\<Rightarrow>\n               Language.normalize c2 = Seq x (sequence Seq xs);\n        flatten (Language.normalize (Cond x1 c1 c2)) = x # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow>\n                           Language.normalize (Cond x1 c1 c2) = x\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (Cond x1 c1 c2) =\n                             Seq x (sequence Seq xs)\n 6. \\<And>x1 c x xs.\n       \\<lbrakk>\\<And>x xs.\n                   flatten (Language.normalize c) = x # xs \\<Longrightarrow>\n                   case xs of [] \\<Rightarrow> Language.normalize c = x\n                   | x' # xs' \\<Rightarrow>\n                       Language.normalize c = Seq x (sequence Seq xs);\n        flatten (Language.normalize (While x1 c)) = x # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow>\n                           Language.normalize (While x1 c) = x\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (While x1 c) =\n                             Seq x (sequence Seq xs)\n 7. \\<And>x xa xs.\n       flatten (Language.normalize (Call x)) = xa # xs \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Call x) = xa\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Call x) = Seq xa (sequence Seq xs)\n 8. \\<And>x xa xs.\n       \\<lbrakk>\\<And>xa xaa xs.\n                   \\<lbrakk>xa \\<in> range x;\n                    flatten (Language.normalize xa) = xaa # xs\\<rbrakk>\n                   \\<Longrightarrow> case xs of\n                                     [] \\<Rightarrow>\n Language.normalize xa = xaa\n                                     | x' # xs' \\<Rightarrow>\n   Language.normalize xa = Seq xaa (sequence Seq xs);\n        flatten (Language.normalize (DynCom x)) = xa # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow> Language.normalize (DynCom x) = xa\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (DynCom x) =\n                             Seq xa (sequence Seq xs)\n 9. \\<And>x1 x2a c x xs.\n       \\<lbrakk>\\<And>x xs.\n                   flatten (Language.normalize c) = x # xs \\<Longrightarrow>\n                   case xs of [] \\<Rightarrow> Language.normalize c = x\n                   | x' # xs' \\<Rightarrow>\n                       Language.normalize c = Seq x (sequence Seq xs);\n        flatten (Language.normalize (Guard x1 x2a c)) = x # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow>\n                           Language.normalize (Guard x1 x2a c) = x\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (Guard x1 x2a c) =\n                             Seq x (sequence Seq xs)\n 10. \\<And>x xs.\n        flatten (Language.normalize Throw) = x # xs \\<Longrightarrow>\n        case xs of [] \\<Rightarrow> Language.normalize Throw = x\n        | x' # xs' \\<Rightarrow>\n            Language.normalize Throw = Seq x (sequence Seq xs)\nA total of 11 subgoals...", "have \"flatten (normalize (Seq c1 c2)) = x # xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (Language.normalize (Seq c1 c2)) = x # xs", "by fact"], ["proof (state)\nthis:\n  flatten (Language.normalize (Seq c1 c2)) = x # xs\n\ngoal (11 subgoals):\n 1. \\<And>x xs.\n       flatten (Language.normalize Skip) = x # xs \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize Skip = x\n       | x' # xs' \\<Rightarrow>\n           Language.normalize Skip = Seq x (sequence Seq xs)\n 2. \\<And>x xa xs.\n       flatten (Language.normalize (Basic x)) = xa # xs \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Basic x) = xa\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Basic x) = Seq xa (sequence Seq xs)\n 3. \\<And>x xa xs.\n       flatten (Language.normalize (Spec x)) = xa # xs \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Spec x) = xa\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Spec x) = Seq xa (sequence Seq xs)\n 4. \\<And>c1 c2 x xs.\n       \\<lbrakk>\\<And>x xs.\n                   flatten (Language.normalize c1) =\n                   x # xs \\<Longrightarrow>\n                   case xs of [] \\<Rightarrow> Language.normalize c1 = x\n                   | x' # xs' \\<Rightarrow>\n                       Language.normalize c1 = Seq x (sequence Seq xs);\n        \\<And>x xs.\n           flatten (Language.normalize c2) = x # xs \\<Longrightarrow>\n           case xs of [] \\<Rightarrow> Language.normalize c2 = x\n           | x' # xs' \\<Rightarrow>\n               Language.normalize c2 = Seq x (sequence Seq xs);\n        flatten (Language.normalize (Seq c1 c2)) = x # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (Seq c1 c2) =\n                             Seq x (sequence Seq xs)\n 5. \\<And>x1 c1 c2 x xs.\n       \\<lbrakk>\\<And>x xs.\n                   flatten (Language.normalize c1) =\n                   x # xs \\<Longrightarrow>\n                   case xs of [] \\<Rightarrow> Language.normalize c1 = x\n                   | x' # xs' \\<Rightarrow>\n                       Language.normalize c1 = Seq x (sequence Seq xs);\n        \\<And>x xs.\n           flatten (Language.normalize c2) = x # xs \\<Longrightarrow>\n           case xs of [] \\<Rightarrow> Language.normalize c2 = x\n           | x' # xs' \\<Rightarrow>\n               Language.normalize c2 = Seq x (sequence Seq xs);\n        flatten (Language.normalize (Cond x1 c1 c2)) = x # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow>\n                           Language.normalize (Cond x1 c1 c2) = x\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (Cond x1 c1 c2) =\n                             Seq x (sequence Seq xs)\n 6. \\<And>x1 c x xs.\n       \\<lbrakk>\\<And>x xs.\n                   flatten (Language.normalize c) = x # xs \\<Longrightarrow>\n                   case xs of [] \\<Rightarrow> Language.normalize c = x\n                   | x' # xs' \\<Rightarrow>\n                       Language.normalize c = Seq x (sequence Seq xs);\n        flatten (Language.normalize (While x1 c)) = x # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow>\n                           Language.normalize (While x1 c) = x\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (While x1 c) =\n                             Seq x (sequence Seq xs)\n 7. \\<And>x xa xs.\n       flatten (Language.normalize (Call x)) = xa # xs \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Call x) = xa\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Call x) = Seq xa (sequence Seq xs)\n 8. \\<And>x xa xs.\n       \\<lbrakk>\\<And>xa xaa xs.\n                   \\<lbrakk>xa \\<in> range x;\n                    flatten (Language.normalize xa) = xaa # xs\\<rbrakk>\n                   \\<Longrightarrow> case xs of\n                                     [] \\<Rightarrow>\n Language.normalize xa = xaa\n                                     | x' # xs' \\<Rightarrow>\n   Language.normalize xa = Seq xaa (sequence Seq xs);\n        flatten (Language.normalize (DynCom x)) = xa # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow> Language.normalize (DynCom x) = xa\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (DynCom x) =\n                             Seq xa (sequence Seq xs)\n 9. \\<And>x1 x2a c x xs.\n       \\<lbrakk>\\<And>x xs.\n                   flatten (Language.normalize c) = x # xs \\<Longrightarrow>\n                   case xs of [] \\<Rightarrow> Language.normalize c = x\n                   | x' # xs' \\<Rightarrow>\n                       Language.normalize c = Seq x (sequence Seq xs);\n        flatten (Language.normalize (Guard x1 x2a c)) = x # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow>\n                           Language.normalize (Guard x1 x2a c) = x\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (Guard x1 x2a c) =\n                             Seq x (sequence Seq xs)\n 10. \\<And>x xs.\n        flatten (Language.normalize Throw) = x # xs \\<Longrightarrow>\n        case xs of [] \\<Rightarrow> Language.normalize Throw = x\n        | x' # xs' \\<Rightarrow>\n            Language.normalize Throw = Seq x (sequence Seq xs)\nA total of 11 subgoals...", "hence \"flatten (sequence Seq (flatten (normalize c1) @ flatten (normalize c2))) =\n          x#xs\""], ["proof (prove)\nusing this:\n  flatten (Language.normalize (Seq c1 c2)) = x # xs\n\ngoal (1 subgoal):\n 1. flatten\n     (sequence Seq\n       (flatten (Language.normalize c1) @\n        flatten (Language.normalize c2))) =\n    x # xs", "by simp"], ["proof (state)\nthis:\n  flatten\n   (sequence Seq\n     (flatten (Language.normalize c1) @ flatten (Language.normalize c2))) =\n  x # xs\n\ngoal (11 subgoals):\n 1. \\<And>x xs.\n       flatten (Language.normalize Skip) = x # xs \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize Skip = x\n       | x' # xs' \\<Rightarrow>\n           Language.normalize Skip = Seq x (sequence Seq xs)\n 2. \\<And>x xa xs.\n       flatten (Language.normalize (Basic x)) = xa # xs \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Basic x) = xa\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Basic x) = Seq xa (sequence Seq xs)\n 3. \\<And>x xa xs.\n       flatten (Language.normalize (Spec x)) = xa # xs \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Spec x) = xa\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Spec x) = Seq xa (sequence Seq xs)\n 4. \\<And>c1 c2 x xs.\n       \\<lbrakk>\\<And>x xs.\n                   flatten (Language.normalize c1) =\n                   x # xs \\<Longrightarrow>\n                   case xs of [] \\<Rightarrow> Language.normalize c1 = x\n                   | x' # xs' \\<Rightarrow>\n                       Language.normalize c1 = Seq x (sequence Seq xs);\n        \\<And>x xs.\n           flatten (Language.normalize c2) = x # xs \\<Longrightarrow>\n           case xs of [] \\<Rightarrow> Language.normalize c2 = x\n           | x' # xs' \\<Rightarrow>\n               Language.normalize c2 = Seq x (sequence Seq xs);\n        flatten (Language.normalize (Seq c1 c2)) = x # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (Seq c1 c2) =\n                             Seq x (sequence Seq xs)\n 5. \\<And>x1 c1 c2 x xs.\n       \\<lbrakk>\\<And>x xs.\n                   flatten (Language.normalize c1) =\n                   x # xs \\<Longrightarrow>\n                   case xs of [] \\<Rightarrow> Language.normalize c1 = x\n                   | x' # xs' \\<Rightarrow>\n                       Language.normalize c1 = Seq x (sequence Seq xs);\n        \\<And>x xs.\n           flatten (Language.normalize c2) = x # xs \\<Longrightarrow>\n           case xs of [] \\<Rightarrow> Language.normalize c2 = x\n           | x' # xs' \\<Rightarrow>\n               Language.normalize c2 = Seq x (sequence Seq xs);\n        flatten (Language.normalize (Cond x1 c1 c2)) = x # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow>\n                           Language.normalize (Cond x1 c1 c2) = x\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (Cond x1 c1 c2) =\n                             Seq x (sequence Seq xs)\n 6. \\<And>x1 c x xs.\n       \\<lbrakk>\\<And>x xs.\n                   flatten (Language.normalize c) = x # xs \\<Longrightarrow>\n                   case xs of [] \\<Rightarrow> Language.normalize c = x\n                   | x' # xs' \\<Rightarrow>\n                       Language.normalize c = Seq x (sequence Seq xs);\n        flatten (Language.normalize (While x1 c)) = x # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow>\n                           Language.normalize (While x1 c) = x\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (While x1 c) =\n                             Seq x (sequence Seq xs)\n 7. \\<And>x xa xs.\n       flatten (Language.normalize (Call x)) = xa # xs \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Call x) = xa\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Call x) = Seq xa (sequence Seq xs)\n 8. \\<And>x xa xs.\n       \\<lbrakk>\\<And>xa xaa xs.\n                   \\<lbrakk>xa \\<in> range x;\n                    flatten (Language.normalize xa) = xaa # xs\\<rbrakk>\n                   \\<Longrightarrow> case xs of\n                                     [] \\<Rightarrow>\n Language.normalize xa = xaa\n                                     | x' # xs' \\<Rightarrow>\n   Language.normalize xa = Seq xaa (sequence Seq xs);\n        flatten (Language.normalize (DynCom x)) = xa # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow> Language.normalize (DynCom x) = xa\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (DynCom x) =\n                             Seq xa (sequence Seq xs)\n 9. \\<And>x1 x2a c x xs.\n       \\<lbrakk>\\<And>x xs.\n                   flatten (Language.normalize c) = x # xs \\<Longrightarrow>\n                   case xs of [] \\<Rightarrow> Language.normalize c = x\n                   | x' # xs' \\<Rightarrow>\n                       Language.normalize c = Seq x (sequence Seq xs);\n        flatten (Language.normalize (Guard x1 x2a c)) = x # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow>\n                           Language.normalize (Guard x1 x2a c) = x\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (Guard x1 x2a c) =\n                             Seq x (sequence Seq xs)\n 10. \\<And>x xs.\n        flatten (Language.normalize Throw) = x # xs \\<Longrightarrow>\n        case xs of [] \\<Rightarrow> Language.normalize Throw = x\n        | x' # xs' \\<Rightarrow>\n            Language.normalize Throw = Seq x (sequence Seq xs)\nA total of 11 subgoals...", "hence x_xs: \"flatten (normalize c1) @ flatten (normalize c2) = x # xs\""], ["proof (prove)\nusing this:\n  flatten\n   (sequence Seq\n     (flatten (Language.normalize c1) @ flatten (Language.normalize c2))) =\n  x # xs\n\ngoal (1 subgoal):\n 1. flatten (Language.normalize c1) @ flatten (Language.normalize c2) =\n    x # xs", "by (simp add: flatten_app)"], ["proof (state)\nthis:\n  flatten (Language.normalize c1) @ flatten (Language.normalize c2) = x # xs\n\ngoal (11 subgoals):\n 1. \\<And>x xs.\n       flatten (Language.normalize Skip) = x # xs \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize Skip = x\n       | x' # xs' \\<Rightarrow>\n           Language.normalize Skip = Seq x (sequence Seq xs)\n 2. \\<And>x xa xs.\n       flatten (Language.normalize (Basic x)) = xa # xs \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Basic x) = xa\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Basic x) = Seq xa (sequence Seq xs)\n 3. \\<And>x xa xs.\n       flatten (Language.normalize (Spec x)) = xa # xs \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Spec x) = xa\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Spec x) = Seq xa (sequence Seq xs)\n 4. \\<And>c1 c2 x xs.\n       \\<lbrakk>\\<And>x xs.\n                   flatten (Language.normalize c1) =\n                   x # xs \\<Longrightarrow>\n                   case xs of [] \\<Rightarrow> Language.normalize c1 = x\n                   | x' # xs' \\<Rightarrow>\n                       Language.normalize c1 = Seq x (sequence Seq xs);\n        \\<And>x xs.\n           flatten (Language.normalize c2) = x # xs \\<Longrightarrow>\n           case xs of [] \\<Rightarrow> Language.normalize c2 = x\n           | x' # xs' \\<Rightarrow>\n               Language.normalize c2 = Seq x (sequence Seq xs);\n        flatten (Language.normalize (Seq c1 c2)) = x # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (Seq c1 c2) =\n                             Seq x (sequence Seq xs)\n 5. \\<And>x1 c1 c2 x xs.\n       \\<lbrakk>\\<And>x xs.\n                   flatten (Language.normalize c1) =\n                   x # xs \\<Longrightarrow>\n                   case xs of [] \\<Rightarrow> Language.normalize c1 = x\n                   | x' # xs' \\<Rightarrow>\n                       Language.normalize c1 = Seq x (sequence Seq xs);\n        \\<And>x xs.\n           flatten (Language.normalize c2) = x # xs \\<Longrightarrow>\n           case xs of [] \\<Rightarrow> Language.normalize c2 = x\n           | x' # xs' \\<Rightarrow>\n               Language.normalize c2 = Seq x (sequence Seq xs);\n        flatten (Language.normalize (Cond x1 c1 c2)) = x # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow>\n                           Language.normalize (Cond x1 c1 c2) = x\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (Cond x1 c1 c2) =\n                             Seq x (sequence Seq xs)\n 6. \\<And>x1 c x xs.\n       \\<lbrakk>\\<And>x xs.\n                   flatten (Language.normalize c) = x # xs \\<Longrightarrow>\n                   case xs of [] \\<Rightarrow> Language.normalize c = x\n                   | x' # xs' \\<Rightarrow>\n                       Language.normalize c = Seq x (sequence Seq xs);\n        flatten (Language.normalize (While x1 c)) = x # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow>\n                           Language.normalize (While x1 c) = x\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (While x1 c) =\n                             Seq x (sequence Seq xs)\n 7. \\<And>x xa xs.\n       flatten (Language.normalize (Call x)) = xa # xs \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Call x) = xa\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Call x) = Seq xa (sequence Seq xs)\n 8. \\<And>x xa xs.\n       \\<lbrakk>\\<And>xa xaa xs.\n                   \\<lbrakk>xa \\<in> range x;\n                    flatten (Language.normalize xa) = xaa # xs\\<rbrakk>\n                   \\<Longrightarrow> case xs of\n                                     [] \\<Rightarrow>\n Language.normalize xa = xaa\n                                     | x' # xs' \\<Rightarrow>\n   Language.normalize xa = Seq xaa (sequence Seq xs);\n        flatten (Language.normalize (DynCom x)) = xa # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow> Language.normalize (DynCom x) = xa\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (DynCom x) =\n                             Seq xa (sequence Seq xs)\n 9. \\<And>x1 x2a c x xs.\n       \\<lbrakk>\\<And>x xs.\n                   flatten (Language.normalize c) = x # xs \\<Longrightarrow>\n                   case xs of [] \\<Rightarrow> Language.normalize c = x\n                   | x' # xs' \\<Rightarrow>\n                       Language.normalize c = Seq x (sequence Seq xs);\n        flatten (Language.normalize (Guard x1 x2a c)) = x # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow>\n                           Language.normalize (Guard x1 x2a c) = x\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (Guard x1 x2a c) =\n                             Seq x (sequence Seq xs)\n 10. \\<And>x xs.\n        flatten (Language.normalize Throw) = x # xs \\<Longrightarrow>\n        case xs of [] \\<Rightarrow> Language.normalize Throw = x\n        | x' # xs' \\<Rightarrow>\n            Language.normalize Throw = Seq x (sequence Seq xs)\nA total of 11 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n    | x' # xs' \\<Rightarrow>\n        Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)", "proof (cases \"flatten (normalize c1)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. flatten (Language.normalize c1) = [] \\<Longrightarrow>\n    case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n    | x' # xs' \\<Rightarrow>\n        Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)\n 2. \\<And>a list.\n       flatten (Language.normalize c1) = a # list \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)", "case Nil"], ["proof (state)\nthis:\n  flatten (Language.normalize c1) = []\n\ngoal (2 subgoals):\n 1. flatten (Language.normalize c1) = [] \\<Longrightarrow>\n    case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n    | x' # xs' \\<Rightarrow>\n        Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)\n 2. \\<And>a list.\n       flatten (Language.normalize c1) = a # list \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)", "with flatten_nonEmpty"], ["proof (chain)\npicking this:\n  flatten ?c \\<noteq> []\n  flatten (Language.normalize c1) = []", "show ?thesis"], ["proof (prove)\nusing this:\n  flatten ?c \\<noteq> []\n  flatten (Language.normalize c1) = []\n\ngoal (1 subgoal):\n 1. case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n    | x' # xs' \\<Rightarrow>\n        Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)", "by auto"], ["proof (state)\nthis:\n  case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n  | x' # xs' \\<Rightarrow>\n      Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       flatten (Language.normalize c1) = a # list \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       flatten (Language.normalize c1) = a # list \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)", "case (Cons x1 xs1)"], ["proof (state)\nthis:\n  flatten (Language.normalize c1) = x1 # xs1\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       flatten (Language.normalize c1) = a # list \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)", "note Cons_x1_xs1 = this"], ["proof (state)\nthis:\n  flatten (Language.normalize c1) = x1 # xs1\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       flatten (Language.normalize c1) = a # list \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)", "with x_xs"], ["proof (chain)\npicking this:\n  flatten (Language.normalize c1) @ flatten (Language.normalize c2) = x # xs\n  flatten (Language.normalize c1) = x1 # xs1", "obtain\n      x_x1: \"x=x1\" and xs_rest: \"xs=xs1@flatten (normalize c2)\""], ["proof (prove)\nusing this:\n  flatten (Language.normalize c1) @ flatten (Language.normalize c2) = x # xs\n  flatten (Language.normalize c1) = x1 # xs1\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>x = x1; xs = xs1 @ flatten (Language.normalize c2)\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = x1\n  xs = xs1 @ flatten (Language.normalize c2)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       flatten (Language.normalize c1) = a # list \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n    | x' # xs' \\<Rightarrow>\n        Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)", "proof (cases xs1)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs1 = [] \\<Longrightarrow>\n    case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n    | x' # xs' \\<Rightarrow>\n        Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)\n 2. \\<And>a list.\n       xs1 = a # list \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)", "case Nil"], ["proof (state)\nthis:\n  xs1 = []\n\ngoal (2 subgoals):\n 1. xs1 = [] \\<Longrightarrow>\n    case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n    | x' # xs' \\<Rightarrow>\n        Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)\n 2. \\<And>a list.\n       xs1 = a # list \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)", "from Seq.hyps (1) [OF Cons_x1_xs1] Nil"], ["proof (chain)\npicking this:\n  case xs1 of [] \\<Rightarrow> Language.normalize c1 = x1\n  | x' # xs' \\<Rightarrow> Language.normalize c1 = Seq x1 (sequence Seq xs1)\n  xs1 = []", "have \"normalize c1 = x1\""], ["proof (prove)\nusing this:\n  case xs1 of [] \\<Rightarrow> Language.normalize c1 = x1\n  | x' # xs' \\<Rightarrow> Language.normalize c1 = Seq x1 (sequence Seq xs1)\n  xs1 = []\n\ngoal (1 subgoal):\n 1. Language.normalize c1 = x1", "by simp"], ["proof (state)\nthis:\n  Language.normalize c1 = x1\n\ngoal (2 subgoals):\n 1. xs1 = [] \\<Longrightarrow>\n    case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n    | x' # xs' \\<Rightarrow>\n        Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)\n 2. \\<And>a list.\n       xs1 = a # list \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)", "with Cons_x1_xs1 Nil x_x1 xs_rest"], ["proof (chain)\npicking this:\n  flatten (Language.normalize c1) = x1 # xs1\n  xs1 = []\n  x = x1\n  xs = xs1 @ flatten (Language.normalize c2)\n  Language.normalize c1 = x1", "show ?thesis"], ["proof (prove)\nusing this:\n  flatten (Language.normalize c1) = x1 # xs1\n  xs1 = []\n  x = x1\n  xs = xs1 @ flatten (Language.normalize c2)\n  Language.normalize c1 = x1\n\ngoal (1 subgoal):\n 1. case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n    | x' # xs' \\<Rightarrow>\n        Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)", "apply (cases \"flatten (normalize c2)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>flatten (Language.normalize c1) = x1 # xs1; xs1 = []; x = x1;\n     xs = xs1 @ flatten (Language.normalize c2); Language.normalize c1 = x1;\n     flatten (Language.normalize c2) = []\\<rbrakk>\n    \\<Longrightarrow> case xs of\n                      [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n                      | x' # xs' \\<Rightarrow>\n                          Language.normalize (Seq c1 c2) =\n                          Seq x (sequence Seq xs)\n 2. \\<And>a list.\n       \\<lbrakk>flatten (Language.normalize c1) = x1 # xs1; xs1 = [];\n        x = x1; xs = xs1 @ flatten (Language.normalize c2);\n        Language.normalize c1 = x1;\n        flatten (Language.normalize c2) = a # list\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (Seq c1 c2) =\n                             Seq x (sequence Seq xs)", "apply (fastforce simp add: flatten_nonEmpty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>flatten (Language.normalize c1) = x1 # xs1; xs1 = [];\n        x = x1; xs = xs1 @ flatten (Language.normalize c2);\n        Language.normalize c1 = x1;\n        flatten (Language.normalize c2) = a # list\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (Seq c1 c2) =\n                             Seq x (sequence Seq xs)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n  | x' # xs' \\<Rightarrow>\n      Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs1 = a # list \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs1 = a # list \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)", "case Cons"], ["proof (state)\nthis:\n  xs1 = a_ # list_\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs1 = a # list \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)", "from Seq.hyps (1) [OF Cons_x1_xs1] Cons"], ["proof (chain)\npicking this:\n  case xs1 of [] \\<Rightarrow> Language.normalize c1 = x1\n  | x' # xs' \\<Rightarrow> Language.normalize c1 = Seq x1 (sequence Seq xs1)\n  xs1 = a_ # list_", "have \"normalize c1 = Seq x1 (sequence Seq xs1)\""], ["proof (prove)\nusing this:\n  case xs1 of [] \\<Rightarrow> Language.normalize c1 = x1\n  | x' # xs' \\<Rightarrow> Language.normalize c1 = Seq x1 (sequence Seq xs1)\n  xs1 = a_ # list_\n\ngoal (1 subgoal):\n 1. Language.normalize c1 = Seq x1 (sequence Seq xs1)", "by simp"], ["proof (state)\nthis:\n  Language.normalize c1 = Seq x1 (sequence Seq xs1)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs1 = a # list \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)", "with Cons_x1_xs1 Nil x_x1 xs_rest"], ["proof (chain)\npicking this:\n  flatten (Language.normalize c1) = x1 # xs1\n  ([], []) \\<in> listrel ?r\n  x = x1\n  xs = xs1 @ flatten (Language.normalize c2)\n  Language.normalize c1 = Seq x1 (sequence Seq xs1)", "show ?thesis"], ["proof (prove)\nusing this:\n  flatten (Language.normalize c1) = x1 # xs1\n  ([], []) \\<in> listrel ?r\n  x = x1\n  xs = xs1 @ flatten (Language.normalize c2)\n  Language.normalize c1 = Seq x1 (sequence Seq xs1)\n\ngoal (1 subgoal):\n 1. case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n    | x' # xs' \\<Rightarrow>\n        Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)", "apply (cases \"flatten (normalize c2)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>flatten (Language.normalize c1) = x1 # xs1;\n     \\<And>r. ([], []) \\<in> listrel r; x = x1;\n     xs = xs1 @ flatten (Language.normalize c2);\n     Language.normalize c1 = Seq x1 (sequence Seq xs1);\n     flatten (Language.normalize c2) = []\\<rbrakk>\n    \\<Longrightarrow> case xs of\n                      [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n                      | x' # xs' \\<Rightarrow>\n                          Language.normalize (Seq c1 c2) =\n                          Seq x (sequence Seq xs)\n 2. \\<And>a list.\n       \\<lbrakk>flatten (Language.normalize c1) = x1 # xs1;\n        \\<And>r. ([], []) \\<in> listrel r; x = x1;\n        xs = xs1 @ flatten (Language.normalize c2);\n        Language.normalize c1 = Seq x1 (sequence Seq xs1);\n        flatten (Language.normalize c2) = a # list\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (Seq c1 c2) =\n                             Seq x (sequence Seq xs)", "apply (fastforce simp add: flatten_nonEmpty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>flatten (Language.normalize c1) = x1 # xs1;\n        \\<And>r. ([], []) \\<in> listrel r; x = x1;\n        xs = xs1 @ flatten (Language.normalize c2);\n        Language.normalize c1 = Seq x1 (sequence Seq xs1);\n        flatten (Language.normalize c2) = a # list\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (Seq c1 c2) =\n                             Seq x (sequence Seq xs)", "apply (simp split: list.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n  | x' # xs' \\<Rightarrow>\n      Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n  | x' # xs' \\<Rightarrow>\n      Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  case xs of [] \\<Rightarrow> Language.normalize (Seq c1 c2) = x\n  | x' # xs' \\<Rightarrow>\n      Language.normalize (Seq c1 c2) = Seq x (sequence Seq xs)\n\ngoal (10 subgoals):\n 1. \\<And>x xs.\n       flatten (Language.normalize Skip) = x # xs \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize Skip = x\n       | x' # xs' \\<Rightarrow>\n           Language.normalize Skip = Seq x (sequence Seq xs)\n 2. \\<And>x xa xs.\n       flatten (Language.normalize (Basic x)) = xa # xs \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Basic x) = xa\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Basic x) = Seq xa (sequence Seq xs)\n 3. \\<And>x xa xs.\n       flatten (Language.normalize (Spec x)) = xa # xs \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Spec x) = xa\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Spec x) = Seq xa (sequence Seq xs)\n 4. \\<And>x1 c1 c2 x xs.\n       \\<lbrakk>\\<And>x xs.\n                   flatten (Language.normalize c1) =\n                   x # xs \\<Longrightarrow>\n                   case xs of [] \\<Rightarrow> Language.normalize c1 = x\n                   | x' # xs' \\<Rightarrow>\n                       Language.normalize c1 = Seq x (sequence Seq xs);\n        \\<And>x xs.\n           flatten (Language.normalize c2) = x # xs \\<Longrightarrow>\n           case xs of [] \\<Rightarrow> Language.normalize c2 = x\n           | x' # xs' \\<Rightarrow>\n               Language.normalize c2 = Seq x (sequence Seq xs);\n        flatten (Language.normalize (Cond x1 c1 c2)) = x # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow>\n                           Language.normalize (Cond x1 c1 c2) = x\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (Cond x1 c1 c2) =\n                             Seq x (sequence Seq xs)\n 5. \\<And>x1 c x xs.\n       \\<lbrakk>\\<And>x xs.\n                   flatten (Language.normalize c) = x # xs \\<Longrightarrow>\n                   case xs of [] \\<Rightarrow> Language.normalize c = x\n                   | x' # xs' \\<Rightarrow>\n                       Language.normalize c = Seq x (sequence Seq xs);\n        flatten (Language.normalize (While x1 c)) = x # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow>\n                           Language.normalize (While x1 c) = x\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (While x1 c) =\n                             Seq x (sequence Seq xs)\n 6. \\<And>x xa xs.\n       flatten (Language.normalize (Call x)) = xa # xs \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize (Call x) = xa\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (Call x) = Seq xa (sequence Seq xs)\n 7. \\<And>x xa xs.\n       \\<lbrakk>\\<And>xa xaa xs.\n                   \\<lbrakk>xa \\<in> range x;\n                    flatten (Language.normalize xa) = xaa # xs\\<rbrakk>\n                   \\<Longrightarrow> case xs of\n                                     [] \\<Rightarrow>\n Language.normalize xa = xaa\n                                     | x' # xs' \\<Rightarrow>\n   Language.normalize xa = Seq xaa (sequence Seq xs);\n        flatten (Language.normalize (DynCom x)) = xa # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow> Language.normalize (DynCom x) = xa\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (DynCom x) =\n                             Seq xa (sequence Seq xs)\n 8. \\<And>x1 x2a c x xs.\n       \\<lbrakk>\\<And>x xs.\n                   flatten (Language.normalize c) = x # xs \\<Longrightarrow>\n                   case xs of [] \\<Rightarrow> Language.normalize c = x\n                   | x' # xs' \\<Rightarrow>\n                       Language.normalize c = Seq x (sequence Seq xs);\n        flatten (Language.normalize (Guard x1 x2a c)) = x # xs\\<rbrakk>\n       \\<Longrightarrow> case xs of\n                         [] \\<Rightarrow>\n                           Language.normalize (Guard x1 x2a c) = x\n                         | x' # xs' \\<Rightarrow>\n                             Language.normalize (Guard x1 x2a c) =\n                             Seq x (sequence Seq xs)\n 9. \\<And>x xs.\n       flatten (Language.normalize Throw) = x # xs \\<Longrightarrow>\n       case xs of [] \\<Rightarrow> Language.normalize Throw = x\n       | x' # xs' \\<Rightarrow>\n           Language.normalize Throw = Seq x (sequence Seq xs)\n 10. \\<And>c1 c2 x xs.\n        \\<lbrakk>\\<And>x xs.\n                    flatten (Language.normalize c1) =\n                    x # xs \\<Longrightarrow>\n                    case xs of [] \\<Rightarrow> Language.normalize c1 = x\n                    | x' # xs' \\<Rightarrow>\n                        Language.normalize c1 = Seq x (sequence Seq xs);\n         \\<And>x xs.\n            flatten (Language.normalize c2) = x # xs \\<Longrightarrow>\n            case xs of [] \\<Rightarrow> Language.normalize c2 = x\n            | x' # xs' \\<Rightarrow>\n                Language.normalize c2 = Seq x (sequence Seq xs);\n         flatten (Language.normalize (Catch c1 c2)) = x # xs\\<rbrakk>\n        \\<Longrightarrow> case xs of\n                          [] \\<Rightarrow>\n                            Language.normalize (Catch c1 c2) = x\n                          | x' # xs' \\<Rightarrow>\n                              Language.normalize (Catch c1 c2) =\n                              Seq x (sequence Seq xs)", "qed (auto)"], ["", "lemma flatten_raise [simp]: \"flatten (raise f) = [Basic f, Throw]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (raise f) = [Basic f, Throw]", "by (simp add: raise_def)"], ["", "lemma flatten_condCatch [simp]: \"flatten (condCatch c1 b c2) = [condCatch c1 b c2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (condCatch c1 b c2) = [condCatch c1 b c2]", "by (simp add: condCatch_def)"], ["", "lemma flatten_bind [simp]: \"flatten (bind e c) = [bind e c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (bind e c) = [bind e c]", "by (simp add: bind_def)"], ["", "lemma flatten_bseq [simp]: \"flatten (bseq c1 c2) = flatten c1 @ flatten c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (bseq c1 c2) = flatten c1 @ flatten c2", "by (simp add: bseq_def)"], ["", "lemma flatten_block [simp]:\n  \"flatten (block init bdy return result) = [block init bdy return result]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (block init bdy return result) = [block init bdy return result]", "by (simp add: block_def)"], ["", "lemma flatten_call [simp]: \"flatten (call init p return result) = [call init p return result]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (call init p return result) = [call init p return result]", "by (simp add: call_def)"], ["", "lemma flatten_dynCall [simp]: \"flatten (dynCall init p return result) = [dynCall init p return result]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (dynCall init p return result) = [dynCall init p return result]", "by (simp add: dynCall_def)"], ["", "lemma flatten_fcall [simp]: \"flatten (fcall init p return result c) = [fcall init p return result c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (fcall init p return result c) = [fcall init p return result c]", "by (simp add: fcall_def)"], ["", "lemma flatten_switch [simp]: \"flatten (switch v Vcs) = [switch v Vcs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (switch v Vcs) = [switch v Vcs]", "by (cases Vcs) auto"], ["", "lemma flatten_guaranteeStrip [simp]:\n  \"flatten (guaranteeStrip f g c) = [guaranteeStrip f g c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (guaranteeStrip f g c) = [guaranteeStrip f g c]", "by (simp add: guaranteeStrip_def)"], ["", "lemma flatten_while [simp]: \"flatten (while gs b c) = [while gs b c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (while gs b c) = [while gs b c]", "apply (simp add: while_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (guards gs (While b (Seq c (guards gs Skip)))) =\n    [guards gs (While b (Seq c (guards gs Skip)))]", "apply (induct gs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. flatten (guards [] (While b (Seq c (guards [] Skip)))) =\n    [guards [] (While b (Seq c (guards [] Skip)))]\n 2. \\<And>a gs.\n       flatten (guards gs (While b (Seq c (guards gs Skip)))) =\n       [guards gs (While b (Seq c (guards gs Skip)))] \\<Longrightarrow>\n       flatten (guards (a # gs) (While b (Seq c (guards (a # gs) Skip)))) =\n       [guards (a # gs) (While b (Seq c (guards (a # gs) Skip)))]", "apply  auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma flatten_whileAnno [simp]:\n  \"flatten (whileAnno b I V c) = [whileAnno b I V c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (whileAnno b I V c) = [whileAnno b I V c]", "by (simp add: whileAnno_def)"], ["", "lemma flatten_whileAnnoG [simp]:\n  \"flatten (whileAnnoG gs b I V c) = [whileAnnoG gs b I V c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (whileAnnoG gs b I V c) = [whileAnnoG gs b I V c]", "by (simp add: whileAnnoG_def)"], ["", "lemma flatten_specAnno [simp]:\n  \"flatten (specAnno P c Q A) = flatten (c undefined)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flatten (specAnno P c Q A) = flatten (c undefined)", "by (simp add: specAnno_def)"], ["", "lemmas flatten_simps = flatten.simps flatten_raise flatten_condCatch flatten_bind\n  flatten_block flatten_call flatten_dynCall flatten_fcall flatten_switch\n  flatten_guaranteeStrip\n  flatten_while flatten_whileAnno flatten_whileAnnoG flatten_specAnno"], ["", "lemma normalize_raise [simp]:\n \"normalize (raise f) = raise f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Language.normalize (raise f) = raise f", "by (simp add: raise_def)"], ["", "lemma normalize_condCatch [simp]:\n \"normalize (condCatch c1 b c2) = condCatch (normalize c1) b (normalize c2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Language.normalize (condCatch c1 b c2) =\n    condCatch (Language.normalize c1) b (Language.normalize c2)", "by (simp add: condCatch_def)"], ["", "lemma normalize_bind [simp]:\n \"normalize (bind e c) = bind e (\\<lambda>v. normalize (c v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Language.normalize (bind e c) =\n    bind e (\\<lambda>v. Language.normalize (c v))", "by (simp add: bind_def)"], ["", "lemma normalize_bseq [simp]:\n \"normalize (bseq c1 c2) = sequence bseq\n                            ((flatten (normalize c1)) @ (flatten (normalize c2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Language.normalize (bseq c1 c2) =\n    sequence bseq\n     (flatten (Language.normalize c1) @ flatten (Language.normalize c2))", "by (simp add: bseq_def)"], ["", "lemma normalize_block [simp]: \"normalize (block init bdy return c) =\n                         block init (normalize bdy) return (\\<lambda>s t. normalize (c s t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Language.normalize (block init bdy return c) =\n    block init (Language.normalize bdy) return\n     (\\<lambda>s t. Language.normalize (c s t))", "apply (simp add: block_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s.\n        Seq (Catch\n              (case flatten (Language.normalize bdy) of\n               [] \\<Rightarrow> Basic init\n               | a # list \\<Rightarrow>\n                   Seq (Basic init)\n                    (sequence Seq (flatten (Language.normalize bdy))))\n              (Seq (Basic (return s)) Throw))\n         (DynCom\n           (\\<lambda>sa.\n               case flatten (Language.normalize (c s sa)) of\n               [] \\<Rightarrow> Basic (return s)\n               | a # list \\<Rightarrow>\n                   Seq (Basic (return s))\n                    (sequence Seq\n                      (flatten (Language.normalize (c s sa))))))) =\n    (\\<lambda>s.\n        Seq (Catch (Seq (Basic init) (Language.normalize bdy))\n              (Seq (Basic (return s)) Throw))\n         (DynCom\n           (\\<lambda>t.\n               Seq (Basic (return s)) (Language.normalize (c s t)))))", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       Seq (Catch\n             (case flatten (Language.normalize bdy) of\n              [] \\<Rightarrow> Basic init\n              | a # list \\<Rightarrow>\n                  Seq (Basic init)\n                   (sequence Seq (flatten (Language.normalize bdy))))\n             (Seq (Basic (return s)) Throw))\n        (DynCom\n          (\\<lambda>sa.\n              case flatten (Language.normalize (c s sa)) of\n              [] \\<Rightarrow> Basic (return s)\n              | a # list \\<Rightarrow>\n                  Seq (Basic (return s))\n                   (sequence Seq\n                     (flatten (Language.normalize (c s sa)))))) =\n       Seq (Catch (Seq (Basic init) (Language.normalize bdy))\n             (Seq (Basic (return s)) Throw))\n        (DynCom\n          (\\<lambda>t. Seq (Basic (return s)) (Language.normalize (c s t))))", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       (case flatten (Language.normalize bdy) of [] \\<Rightarrow> Basic init\n        | a # list \\<Rightarrow>\n            Seq (Basic init)\n             (sequence Seq (flatten (Language.normalize bdy)))) =\n       Seq (Basic init) (Language.normalize bdy) \\<and>\n       (\\<lambda>sa.\n           case flatten (Language.normalize (c s sa)) of\n           [] \\<Rightarrow> Basic (return s)\n           | a # list \\<Rightarrow>\n               Seq (Basic (return s))\n                (sequence Seq (flatten (Language.normalize (c s sa))))) =\n       (\\<lambda>t. Seq (Basic (return s)) (Language.normalize (c s t)))", "apply (cases \"flatten (normalize bdy)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       flatten (Language.normalize bdy) = [] \\<Longrightarrow>\n       (case flatten (Language.normalize bdy) of [] \\<Rightarrow> Basic init\n        | a # list \\<Rightarrow>\n            Seq (Basic init)\n             (sequence Seq (flatten (Language.normalize bdy)))) =\n       Seq (Basic init) (Language.normalize bdy) \\<and>\n       (\\<lambda>sa.\n           case flatten (Language.normalize (c s sa)) of\n           [] \\<Rightarrow> Basic (return s)\n           | a # list \\<Rightarrow>\n               Seq (Basic (return s))\n                (sequence Seq (flatten (Language.normalize (c s sa))))) =\n       (\\<lambda>t. Seq (Basic (return s)) (Language.normalize (c s t)))\n 2. \\<And>s a list.\n       flatten (Language.normalize bdy) = a # list \\<Longrightarrow>\n       (case flatten (Language.normalize bdy) of [] \\<Rightarrow> Basic init\n        | a # list \\<Rightarrow>\n            Seq (Basic init)\n             (sequence Seq (flatten (Language.normalize bdy)))) =\n       Seq (Basic init) (Language.normalize bdy) \\<and>\n       (\\<lambda>sa.\n           case flatten (Language.normalize (c s sa)) of\n           [] \\<Rightarrow> Basic (return s)\n           | a # list \\<Rightarrow>\n               Seq (Basic (return s))\n                (sequence Seq (flatten (Language.normalize (c s sa))))) =\n       (\\<lambda>t. Seq (Basic (return s)) (Language.normalize (c s t)))", "apply  (simp add: flatten_nonEmpty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s a list.\n       flatten (Language.normalize bdy) = a # list \\<Longrightarrow>\n       (case flatten (Language.normalize bdy) of [] \\<Rightarrow> Basic init\n        | a # list \\<Rightarrow>\n            Seq (Basic init)\n             (sequence Seq (flatten (Language.normalize bdy)))) =\n       Seq (Basic init) (Language.normalize bdy) \\<and>\n       (\\<lambda>sa.\n           case flatten (Language.normalize (c s sa)) of\n           [] \\<Rightarrow> Basic (return s)\n           | a # list \\<Rightarrow>\n               Seq (Basic (return s))\n                (sequence Seq (flatten (Language.normalize (c s sa))))) =\n       (\\<lambda>t. Seq (Basic (return s)) (Language.normalize (c s t)))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s a list.\n       flatten (Language.normalize bdy) = a # list \\<Longrightarrow>\n       (case flatten (Language.normalize bdy) of [] \\<Rightarrow> Basic init\n        | a # list \\<Rightarrow>\n            Seq (Basic init)\n             (sequence Seq (flatten (Language.normalize bdy)))) =\n       Seq (Basic init) (Language.normalize bdy)\n 2. \\<And>s a list.\n       flatten (Language.normalize bdy) = a # list \\<Longrightarrow>\n       (\\<lambda>sa.\n           case flatten (Language.normalize (c s sa)) of\n           [] \\<Rightarrow> Basic (return s)\n           | a # list \\<Rightarrow>\n               Seq (Basic (return s))\n                (sequence Seq (flatten (Language.normalize (c s sa))))) =\n       (\\<lambda>t. Seq (Basic (return s)) (Language.normalize (c s t)))", "apply  simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list.\n       flatten (Language.normalize bdy) = a # list \\<Longrightarrow>\n       (case list of [] \\<Rightarrow> a\n        | aa # lista \\<Rightarrow> Seq a (sequence Seq list)) =\n       Language.normalize bdy\n 2. \\<And>s a list.\n       flatten (Language.normalize bdy) = a # list \\<Longrightarrow>\n       (\\<lambda>sa.\n           case flatten (Language.normalize (c s sa)) of\n           [] \\<Rightarrow> Basic (return s)\n           | a # list \\<Rightarrow>\n               Seq (Basic (return s))\n                (sequence Seq (flatten (Language.normalize (c s sa))))) =\n       (\\<lambda>t. Seq (Basic (return s)) (Language.normalize (c s t)))", "apply  (drule flatten_normalize)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list.\n       case list of [] \\<Rightarrow> Language.normalize bdy = a\n       | x' # xs' \\<Rightarrow>\n           Language.normalize bdy =\n           Seq a (sequence Seq list) \\<Longrightarrow>\n       (case list of [] \\<Rightarrow> a\n        | aa # lista \\<Rightarrow> Seq a (sequence Seq list)) =\n       Language.normalize bdy\n 2. \\<And>s a list.\n       flatten (Language.normalize bdy) = a # list \\<Longrightarrow>\n       (\\<lambda>sa.\n           case flatten (Language.normalize (c s sa)) of\n           [] \\<Rightarrow> Basic (return s)\n           | a # list \\<Rightarrow>\n               Seq (Basic (return s))\n                (sequence Seq (flatten (Language.normalize (c s sa))))) =\n       (\\<lambda>t. Seq (Basic (return s)) (Language.normalize (c s t)))", "apply  (case_tac list)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a list.\n       \\<lbrakk>case list of [] \\<Rightarrow> Language.normalize bdy = a\n                | x' # xs' \\<Rightarrow>\n                    Language.normalize bdy = Seq a (sequence Seq list);\n        list = []\\<rbrakk>\n       \\<Longrightarrow> (case list of [] \\<Rightarrow> a\n                          | aa # lista \\<Rightarrow>\n                              Seq a (sequence Seq list)) =\n                         Language.normalize bdy\n 2. \\<And>a list aa lista.\n       \\<lbrakk>case list of [] \\<Rightarrow> Language.normalize bdy = a\n                | x' # xs' \\<Rightarrow>\n                    Language.normalize bdy = Seq a (sequence Seq list);\n        list = aa # lista\\<rbrakk>\n       \\<Longrightarrow> (case list of [] \\<Rightarrow> a\n                          | aa # lista \\<Rightarrow>\n                              Seq a (sequence Seq list)) =\n                         Language.normalize bdy\n 3. \\<And>s a list.\n       flatten (Language.normalize bdy) = a # list \\<Longrightarrow>\n       (\\<lambda>sa.\n           case flatten (Language.normalize (c s sa)) of\n           [] \\<Rightarrow> Basic (return s)\n           | a # list \\<Rightarrow>\n               Seq (Basic (return s))\n                (sequence Seq (flatten (Language.normalize (c s sa))))) =\n       (\\<lambda>t. Seq (Basic (return s)) (Language.normalize (c s t)))", "apply   simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list aa lista.\n       \\<lbrakk>case list of [] \\<Rightarrow> Language.normalize bdy = a\n                | x' # xs' \\<Rightarrow>\n                    Language.normalize bdy = Seq a (sequence Seq list);\n        list = aa # lista\\<rbrakk>\n       \\<Longrightarrow> (case list of [] \\<Rightarrow> a\n                          | aa # lista \\<Rightarrow>\n                              Seq a (sequence Seq list)) =\n                         Language.normalize bdy\n 2. \\<And>s a list.\n       flatten (Language.normalize bdy) = a # list \\<Longrightarrow>\n       (\\<lambda>sa.\n           case flatten (Language.normalize (c s sa)) of\n           [] \\<Rightarrow> Basic (return s)\n           | a # list \\<Rightarrow>\n               Seq (Basic (return s))\n                (sequence Seq (flatten (Language.normalize (c s sa))))) =\n       (\\<lambda>t. Seq (Basic (return s)) (Language.normalize (c s t)))", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s a list.\n       flatten (Language.normalize bdy) = a # list \\<Longrightarrow>\n       (\\<lambda>sa.\n           case flatten (Language.normalize (c s sa)) of\n           [] \\<Rightarrow> Basic (return s)\n           | a # list \\<Rightarrow>\n               Seq (Basic (return s))\n                (sequence Seq (flatten (Language.normalize (c s sa))))) =\n       (\\<lambda>t. Seq (Basic (return s)) (Language.normalize (c s t)))", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s a list sa.\n       flatten (Language.normalize bdy) = a # list \\<Longrightarrow>\n       (case flatten (Language.normalize (c s sa)) of\n        [] \\<Rightarrow> Basic (return s)\n        | a # list \\<Rightarrow>\n            Seq (Basic (return s))\n             (sequence Seq (flatten (Language.normalize (c s sa))))) =\n       Seq (Basic (return s)) (Language.normalize (c s sa))", "apply (case_tac \"flatten (normalize (c s sa))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s a list sa.\n       \\<lbrakk>flatten (Language.normalize bdy) = a # list;\n        flatten (Language.normalize (c s sa)) = []\\<rbrakk>\n       \\<Longrightarrow> (case flatten (Language.normalize (c s sa)) of\n                          [] \\<Rightarrow> Basic (return s)\n                          | a # list \\<Rightarrow>\n                              Seq (Basic (return s))\n                               (sequence Seq\n                                 (flatten (Language.normalize (c s sa))))) =\n                         Seq (Basic (return s))\n                          (Language.normalize (c s sa))\n 2. \\<And>s a list sa aa lista.\n       \\<lbrakk>flatten (Language.normalize bdy) = a # list;\n        flatten (Language.normalize (c s sa)) = aa # lista\\<rbrakk>\n       \\<Longrightarrow> (case flatten (Language.normalize (c s sa)) of\n                          [] \\<Rightarrow> Basic (return s)\n                          | a # list \\<Rightarrow>\n                              Seq (Basic (return s))\n                               (sequence Seq\n                                 (flatten (Language.normalize (c s sa))))) =\n                         Seq (Basic (return s))\n                          (Language.normalize (c s sa))", "apply  (simp add: flatten_nonEmpty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s a list sa aa lista.\n       \\<lbrakk>flatten (Language.normalize bdy) = a # list;\n        flatten (Language.normalize (c s sa)) = aa # lista\\<rbrakk>\n       \\<Longrightarrow> (case flatten (Language.normalize (c s sa)) of\n                          [] \\<Rightarrow> Basic (return s)\n                          | a # list \\<Rightarrow>\n                              Seq (Basic (return s))\n                               (sequence Seq\n                                 (flatten (Language.normalize (c s sa))))) =\n                         Seq (Basic (return s))\n                          (Language.normalize (c s sa))", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s a list sa aa lista.\n       \\<lbrakk>flatten (Language.normalize bdy) = a # list;\n        flatten (Language.normalize (c s sa)) = aa # lista\\<rbrakk>\n       \\<Longrightarrow> (case lista of [] \\<Rightarrow> aa\n                          | a # list \\<Rightarrow>\n                              Seq aa (sequence Seq lista)) =\n                         Language.normalize (c s sa)", "apply (thin_tac \"flatten (normalize bdy) = P\" for P)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s a list sa aa lista.\n       flatten (Language.normalize (c s sa)) = aa # lista \\<Longrightarrow>\n       (case lista of [] \\<Rightarrow> aa\n        | a # list \\<Rightarrow> Seq aa (sequence Seq lista)) =\n       Language.normalize (c s sa)", "apply (drule flatten_normalize)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s a list sa aa lista.\n       case lista of [] \\<Rightarrow> Language.normalize (c s sa) = aa\n       | x' # xs' \\<Rightarrow>\n           Language.normalize (c s sa) =\n           Seq aa (sequence Seq lista) \\<Longrightarrow>\n       (case lista of [] \\<Rightarrow> aa\n        | a # list \\<Rightarrow> Seq aa (sequence Seq lista)) =\n       Language.normalize (c s sa)", "apply (case_tac lista)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s a list sa aa lista.\n       \\<lbrakk>case lista of\n                [] \\<Rightarrow> Language.normalize (c s sa) = aa\n                | x' # xs' \\<Rightarrow>\n                    Language.normalize (c s sa) =\n                    Seq aa (sequence Seq lista);\n        lista = []\\<rbrakk>\n       \\<Longrightarrow> (case lista of [] \\<Rightarrow> aa\n                          | a # list \\<Rightarrow>\n                              Seq aa (sequence Seq lista)) =\n                         Language.normalize (c s sa)\n 2. \\<And>s a list sa aa lista ab listb.\n       \\<lbrakk>case lista of\n                [] \\<Rightarrow> Language.normalize (c s sa) = aa\n                | x' # xs' \\<Rightarrow>\n                    Language.normalize (c s sa) =\n                    Seq aa (sequence Seq lista);\n        lista = ab # listb\\<rbrakk>\n       \\<Longrightarrow> (case lista of [] \\<Rightarrow> aa\n                          | a # list \\<Rightarrow>\n                              Seq aa (sequence Seq lista)) =\n                         Language.normalize (c s sa)", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s a list sa aa lista ab listb.\n       \\<lbrakk>case lista of\n                [] \\<Rightarrow> Language.normalize (c s sa) = aa\n                | x' # xs' \\<Rightarrow>\n                    Language.normalize (c s sa) =\n                    Seq aa (sequence Seq lista);\n        lista = ab # listb\\<rbrakk>\n       \\<Longrightarrow> (case lista of [] \\<Rightarrow> aa\n                          | a # list \\<Rightarrow>\n                              Seq aa (sequence Seq lista)) =\n                         Language.normalize (c s sa)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma normalize_call [simp]:\n  \"normalize (call init p return c) = call init p return (\\<lambda>i t. normalize (c i t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Language.normalize (call init p return c) =\n    call init p return (\\<lambda>i t. Language.normalize (c i t))", "by (simp add: call_def)"], ["", "lemma normalize_dynCall [simp]:\n  \"normalize (dynCall init p return c) =\n    dynCall init p return (\\<lambda>s t. normalize (c s t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Language.normalize (dynCall init p return c) =\n    dynCall init p return (\\<lambda>s t. Language.normalize (c s t))", "by (simp add: dynCall_def)"], ["", "lemma normalize_fcall [simp]:\n  \"normalize (fcall init p return result c) =\n    fcall init p return result (\\<lambda>v. normalize (c v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Language.normalize (fcall init p return result c) =\n    fcall init p return result (\\<lambda>v. Language.normalize (c v))", "by (simp add: fcall_def)"], ["", "lemma normalize_switch [simp]:\n  \"normalize (switch v Vcs) = switch v (map (\\<lambda>(V,c). (V,normalize c)) Vcs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Language.normalize (switch v Vcs) =\n    switch v (map (\\<lambda>(V, c). (V, Language.normalize c)) Vcs)", "apply (induct Vcs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Language.normalize (switch v []) =\n    switch v\n     (map (\\<lambda>a.\n              case a of (V, c) \\<Rightarrow> (V, Language.normalize c))\n       [])\n 2. \\<And>a Vcs.\n       Language.normalize (switch v Vcs) =\n       switch v\n        (map (\\<lambda>a.\n                 case a of (V, c) \\<Rightarrow> (V, Language.normalize c))\n          Vcs) \\<Longrightarrow>\n       Language.normalize (switch v (a # Vcs)) =\n       switch v\n        (map (\\<lambda>a.\n                 case a of (V, c) \\<Rightarrow> (V, Language.normalize c))\n          (a # Vcs))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma normalize_guaranteeStrip [simp]:\n  \"normalize (guaranteeStrip f g c) = guaranteeStrip f g (normalize c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Language.normalize (guaranteeStrip f g c) =\n    guaranteeStrip f g (Language.normalize c)", "by (simp add: guaranteeStrip_def)"], ["", "lemma normalize_guards [simp]:\n  \"normalize (guards gs c) = guards gs (normalize c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Language.normalize (guards gs c) = guards gs (Language.normalize c)", "by (induct gs) auto"], ["", "text \\<open>Sequencial composition with guards in the body is not preserved by\n        normalize\\<close>"], ["", "lemma normalize_while [simp]:\n  \"normalize (while gs b c) = guards gs\n      (While b (sequence Seq (flatten (normalize c) @ flatten (guards gs Skip))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Language.normalize (while gs b c) =\n    guards gs\n     (While b\n       (sequence Seq\n         (flatten (Language.normalize c) @ flatten (guards gs Skip))))", "by (simp add: while_def)"], ["", "lemma normalize_whileAnno [simp]:\n  \"normalize (whileAnno b I V c) = whileAnno b I V (normalize c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Language.normalize (whileAnno b I V c) =\n    whileAnno b I V (Language.normalize c)", "by (simp add: whileAnno_def)"], ["", "lemma normalize_whileAnnoG [simp]:\n  \"normalize (whileAnnoG gs b I V c) = guards gs\n      (While b (sequence Seq (flatten (normalize c) @ flatten (guards gs Skip))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Language.normalize (whileAnnoG gs b I V c) =\n    guards gs\n     (While b\n       (sequence Seq\n         (flatten (Language.normalize c) @ flatten (guards gs Skip))))", "by (simp add: whileAnnoG_def)"], ["", "lemma normalize_specAnno [simp]:\n  \"normalize (specAnno P c Q A) = specAnno P (\\<lambda>s. normalize (c undefined)) Q A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Language.normalize (specAnno P c Q A) =\n    specAnno P (\\<lambda>s. Language.normalize (c undefined)) Q A", "by (simp add: specAnno_def)"], ["", "lemmas normalize_simps =\n  normalize.simps normalize_raise normalize_condCatch normalize_bind\n  normalize_block normalize_call normalize_dynCall normalize_fcall normalize_switch\n  normalize_guaranteeStrip normalize_guards\n  normalize_while normalize_whileAnno normalize_whileAnnoG normalize_specAnno"], ["", "subsubsection \\<open>Stripping Guards: \\<open>strip_guards\\<close>\\<close>"], ["", "primrec strip_guards:: \"'f set \\<Rightarrow> ('s,'p,'f) com \\<Rightarrow> ('s,'p,'f) com\"\nwhere\n\"strip_guards F Skip = Skip\" |\n\"strip_guards F (Basic f) = Basic f\" |\n\"strip_guards F (Spec r) = Spec r\" |\n\"strip_guards F (Seq c\\<^sub>1 c\\<^sub>2)  = (Seq (strip_guards F c\\<^sub>1) (strip_guards F c\\<^sub>2))\" |\n\"strip_guards F (Cond b c\\<^sub>1 c\\<^sub>2) = Cond b (strip_guards F c\\<^sub>1) (strip_guards F c\\<^sub>2)\" |\n\"strip_guards F (While b c) = While b (strip_guards F c)\" |\n\"strip_guards F (Call p) = Call p\" |\n\"strip_guards F (DynCom c) = DynCom (\\<lambda>s. (strip_guards F (c s)))\" |\n\"strip_guards F (Guard f g c) = (if f \\<in> F then strip_guards F c\n                                  else Guard f g (strip_guards F c))\" |\n\"strip_guards F Throw = Throw\" |\n\"strip_guards F (Catch c\\<^sub>1 c\\<^sub>2) = Catch (strip_guards F c\\<^sub>1) (strip_guards F c\\<^sub>2)\""], ["", "definition strip:: \"'f set \\<Rightarrow>\n                   ('p \\<Rightarrow> ('s,'p,'f) com option) \\<Rightarrow> ('p \\<Rightarrow> ('s,'p,'f) com option)\"\n  where \"strip F \\<Gamma> = (\\<lambda>p. map_option (strip_guards F) (\\<Gamma> p))\""], ["", "lemma strip_simp [simp]: \"(strip F \\<Gamma>) p = map_option (strip_guards F) (\\<Gamma> p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip F \\<Gamma> p = map_option (strip_guards F) (\\<Gamma> p)", "by (simp add: strip_def)"], ["", "lemma dom_strip: \"dom (strip F \\<Gamma>) = dom \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (strip F \\<Gamma>) = dom \\<Gamma>", "by (auto)"], ["", "lemma strip_guards_idem: \"strip_guards F (strip_guards F c) = strip_guards F c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_guards F (strip_guards F c) = strip_guards F c", "by (induct c) auto"], ["", "lemma strip_idem: \"strip F (strip F \\<Gamma>) = strip F \\<Gamma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip F (strip F \\<Gamma>) = strip F \\<Gamma>", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. strip F (strip F \\<Gamma>) x = strip F \\<Gamma> x", "apply (case_tac \"\\<Gamma> x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<Gamma> x = None \\<Longrightarrow>\n       strip F (strip F \\<Gamma>) x = strip F \\<Gamma> x\n 2. \\<And>x a.\n       \\<Gamma> x = Some a \\<Longrightarrow>\n       strip F (strip F \\<Gamma>) x = strip F \\<Gamma> x", "apply (auto simp add: strip_guards_idem strip_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma strip_guards_raise [simp]:\n  \"strip_guards F (raise f) = raise f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_guards F (raise f) = raise f", "by (simp add: raise_def)"], ["", "lemma strip_guards_condCatch [simp]:\n  \"strip_guards F (condCatch c1 b c2) =\n    condCatch (strip_guards F c1) b (strip_guards F c2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_guards F (condCatch c1 b c2) =\n    condCatch (strip_guards F c1) b (strip_guards F c2)", "by (simp add: condCatch_def)"], ["", "lemma strip_guards_bind [simp]:\n  \"strip_guards F (bind e c) = bind e (\\<lambda>v. strip_guards F (c v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_guards F (bind e c) = bind e (\\<lambda>v. strip_guards F (c v))", "by (simp add: bind_def)"], ["", "lemma strip_guards_bseq [simp]:\n  \"strip_guards F (bseq c1 c2) = bseq (strip_guards F c1) (strip_guards F c2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_guards F (bseq c1 c2) =\n    bseq (strip_guards F c1) (strip_guards F c2)", "by (simp add: bseq_def)"], ["", "lemma strip_guards_block [simp]:\n  \"strip_guards F (block init bdy return c) =\n    block init (strip_guards F bdy) return (\\<lambda>s t. strip_guards F (c s t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_guards F (block init bdy return c) =\n    block init (strip_guards F bdy) return\n     (\\<lambda>s t. strip_guards F (c s t))", "by (simp add: block_def)"], ["", "lemma strip_guards_call [simp]:\n  \"strip_guards F (call init p return c) =\n     call init p return (\\<lambda>s t. strip_guards F (c s t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_guards F (call init p return c) =\n    call init p return (\\<lambda>s t. strip_guards F (c s t))", "by (simp add: call_def)"], ["", "lemma strip_guards_dynCall [simp]:\n  \"strip_guards F (dynCall init p return c) =\n     dynCall init p return (\\<lambda>s t. strip_guards F (c s t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_guards F (dynCall init p return c) =\n    dynCall init p return (\\<lambda>s t. strip_guards F (c s t))", "by (simp add: dynCall_def)"], ["", "lemma strip_guards_fcall [simp]:\n  \"strip_guards F (fcall init p return result c) =\n     fcall init p return result (\\<lambda>v. strip_guards F (c v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_guards F (fcall init p return result c) =\n    fcall init p return result (\\<lambda>v. strip_guards F (c v))", "by (simp add: fcall_def)"], ["", "lemma strip_guards_switch [simp]:\n  \"strip_guards F (switch v Vc) =\n    switch v (map (\\<lambda>(V,c). (V,strip_guards F c)) Vc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_guards F (switch v Vc) =\n    switch v (map (\\<lambda>(V, c). (V, strip_guards F c)) Vc)", "by (induct Vc) auto"], ["", "lemma strip_guards_guaranteeStrip [simp]:\n  \"strip_guards F (guaranteeStrip f g c) =\n    (if f \\<in> F then strip_guards F c\n     else guaranteeStrip f g (strip_guards F c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_guards F (guaranteeStrip f g c) =\n    (if f \\<in> F then strip_guards F c\n     else guaranteeStrip f g (strip_guards F c))", "by (simp add: guaranteeStrip_def)"], ["", "lemma guaranteeStripPair_split_conv [simp]: \"case_prod c (guaranteeStripPair f g) = c f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case guaranteeStripPair f g of (x, xa) \\<Rightarrow> c x xa) = c f g", "by (simp add: guaranteeStripPair_def)"], ["", "lemma strip_guards_guards [simp]: \"strip_guards F (guards gs c) =\n        guards (filter (\\<lambda>(f,g). f \\<notin> F) gs) (strip_guards F c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_guards F (guards gs c) =\n    guards (filter (\\<lambda>(f, g). f \\<notin> F) gs) (strip_guards F c)", "by (induct gs) auto"], ["", "lemma strip_guards_while [simp]:\n \"strip_guards F (while gs b  c) =\n     while (filter (\\<lambda>(f,g). f \\<notin> F) gs) b (strip_guards F c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_guards F (while gs b c) =\n    while (filter (\\<lambda>(f, g). f \\<notin> F) gs) b (strip_guards F c)", "by (simp add: while_def)"], ["", "lemma strip_guards_whileAnno [simp]:\n \"strip_guards F (whileAnno b I V c) = whileAnno b I V (strip_guards F c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_guards F (whileAnno b I V c) = whileAnno b I V (strip_guards F c)", "by (simp add: whileAnno_def  while_def)"], ["", "lemma strip_guards_whileAnnoG [simp]:\n \"strip_guards F (whileAnnoG gs b I V c) =\n     whileAnnoG (filter (\\<lambda>(f,g). f \\<notin> F) gs) b I V (strip_guards F c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_guards F (whileAnnoG gs b I V c) =\n    whileAnnoG (filter (\\<lambda>(f, g). f \\<notin> F) gs) b I V\n     (strip_guards F c)", "by (simp add: whileAnnoG_def)"], ["", "lemma strip_guards_specAnno [simp]:\n  \"strip_guards F (specAnno P c Q A) =\n    specAnno P (\\<lambda>s. strip_guards F (c undefined)) Q A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strip_guards F (specAnno P c Q A) =\n    specAnno P (\\<lambda>s. strip_guards F (c undefined)) Q A", "by (simp add: specAnno_def)"], ["", "lemmas strip_guards_simps = strip_guards.simps strip_guards_raise\n  strip_guards_condCatch strip_guards_bind strip_guards_bseq strip_guards_block\n  strip_guards_dynCall strip_guards_fcall strip_guards_switch\n  strip_guards_guaranteeStrip guaranteeStripPair_split_conv strip_guards_guards\n  strip_guards_while strip_guards_whileAnno strip_guards_whileAnnoG\n  strip_guards_specAnno"], ["", "subsubsection \\<open>Marking Guards: \\<open>mark_guards\\<close>\\<close>"], ["", "primrec mark_guards:: \"'f \\<Rightarrow> ('s,'p,'g) com \\<Rightarrow> ('s,'p,'f) com\"\nwhere\n\"mark_guards f Skip = Skip\" |\n\"mark_guards f (Basic g) = Basic g\" |\n\"mark_guards f (Spec r) = Spec r\" |\n\"mark_guards f (Seq c\\<^sub>1 c\\<^sub>2)  = (Seq (mark_guards f c\\<^sub>1) (mark_guards f c\\<^sub>2))\" |\n\"mark_guards f (Cond b c\\<^sub>1 c\\<^sub>2) = Cond b (mark_guards f c\\<^sub>1) (mark_guards f c\\<^sub>2)\" |\n\"mark_guards f (While b c) = While b (mark_guards f c)\" |\n\"mark_guards f (Call p) = Call p\" |\n\"mark_guards f (DynCom c) = DynCom (\\<lambda>s. (mark_guards f (c s)))\" |\n\"mark_guards f (Guard f' g c) = Guard f g (mark_guards f c)\" |\n\"mark_guards f Throw = Throw\" |\n\"mark_guards f (Catch c\\<^sub>1 c\\<^sub>2) = Catch (mark_guards f c\\<^sub>1) (mark_guards f c\\<^sub>2)\""], ["", "lemma mark_guards_raise: \"mark_guards f (raise g) = raise g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mark_guards f (raise g) = raise g", "by (simp add: raise_def)"], ["", "lemma mark_guards_condCatch [simp]:\n  \"mark_guards f (condCatch c1 b c2) =\n    condCatch (mark_guards f c1) b (mark_guards f c2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mark_guards f (condCatch c1 b c2) =\n    condCatch (mark_guards f c1) b (mark_guards f c2)", "by (simp add: condCatch_def)"], ["", "lemma mark_guards_bind [simp]:\n  \"mark_guards f (bind e c) = bind e (\\<lambda>v. mark_guards f (c v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mark_guards f (bind e c) = bind e (\\<lambda>v. mark_guards f (c v))", "by (simp add: bind_def)"], ["", "lemma mark_guards_bseq [simp]:\n  \"mark_guards f (bseq c1 c2) = bseq (mark_guards f c1) (mark_guards f c2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mark_guards f (bseq c1 c2) = bseq (mark_guards f c1) (mark_guards f c2)", "by (simp add: bseq_def)"], ["", "lemma mark_guards_block [simp]:\n  \"mark_guards f (block init bdy return c) =\n    block init (mark_guards f bdy) return (\\<lambda>s t. mark_guards f (c s t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mark_guards f (block init bdy return c) =\n    block init (mark_guards f bdy) return\n     (\\<lambda>s t. mark_guards f (c s t))", "by (simp add: block_def)"], ["", "lemma mark_guards_call [simp]:\n  \"mark_guards f (call init p return c) =\n     call init p return (\\<lambda>s t. mark_guards f (c s t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mark_guards f (call init p return c) =\n    call init p return (\\<lambda>s t. mark_guards f (c s t))", "by (simp add: call_def)"], ["", "lemma mark_guards_dynCall [simp]:\n  \"mark_guards f (dynCall init p return c) =\n     dynCall init p return (\\<lambda>s t. mark_guards f (c s t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mark_guards f (dynCall init p return c) =\n    dynCall init p return (\\<lambda>s t. mark_guards f (c s t))", "by (simp add: dynCall_def)"], ["", "lemma mark_guards_fcall [simp]:\n  \"mark_guards f (fcall init p return result c) =\n     fcall init p return result (\\<lambda>v. mark_guards f (c v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mark_guards f (fcall init p return result c) =\n    fcall init p return result (\\<lambda>v. mark_guards f (c v))", "by (simp add: fcall_def)"], ["", "lemma mark_guards_switch [simp]:\n  \"mark_guards f (switch v vs) =\n     switch v (map (\\<lambda>(V,c). (V,mark_guards f c)) vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mark_guards f (switch v vs) =\n    switch v (map (\\<lambda>(V, c). (V, mark_guards f c)) vs)", "by (induct vs) auto"], ["", "lemma mark_guards_guaranteeStrip [simp]:\n  \"mark_guards f (guaranteeStrip f' g c) = guaranteeStrip f g (mark_guards f c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mark_guards f (guaranteeStrip f' g c) =\n    guaranteeStrip f g (mark_guards f c)", "by (simp add: guaranteeStrip_def)"], ["", "lemma mark_guards_guards [simp]:\n  \"mark_guards f (guards gs c) = guards (map (\\<lambda>(f',g). (f,g)) gs) (mark_guards f c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mark_guards f (guards gs c) =\n    guards (map (\\<lambda>(f', g). (f, g)) gs) (mark_guards f c)", "by (induct gs) auto"], ["", "lemma mark_guards_while [simp]:\n \"mark_guards f (while gs b c) =\n    while (map (\\<lambda>(f',g). (f,g)) gs) b (mark_guards f c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mark_guards f (while gs b c) =\n    while (map (\\<lambda>(f', g). (f, g)) gs) b (mark_guards f c)", "by (simp add: while_def)"], ["", "lemma mark_guards_whileAnno [simp]:\n \"mark_guards f (whileAnno b I V c) = whileAnno b I V (mark_guards f c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mark_guards f (whileAnno b I V c) = whileAnno b I V (mark_guards f c)", "by (simp add: whileAnno_def while_def)"], ["", "lemma mark_guards_whileAnnoG [simp]:\n \"mark_guards f (whileAnnoG gs b I V c) =\n    whileAnnoG (map (\\<lambda>(f',g). (f,g)) gs) b I V (mark_guards f c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mark_guards f (whileAnnoG gs b I V c) =\n    whileAnnoG (map (\\<lambda>(f', g). (f, g)) gs) b I V (mark_guards f c)", "by (simp add: whileAnno_def whileAnnoG_def while_def)"], ["", "lemma mark_guards_specAnno [simp]:\n  \"mark_guards f (specAnno P c Q A) =\n    specAnno P (\\<lambda>s. mark_guards f (c undefined)) Q A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mark_guards f (specAnno P c Q A) =\n    specAnno P (\\<lambda>s. mark_guards f (c undefined)) Q A", "by (simp add: specAnno_def)"], ["", "lemmas mark_guards_simps = mark_guards.simps mark_guards_raise\n  mark_guards_condCatch mark_guards_bind mark_guards_bseq mark_guards_block\n  mark_guards_dynCall mark_guards_fcall mark_guards_switch\n  mark_guards_guaranteeStrip guaranteeStripPair_split_conv mark_guards_guards\n  mark_guards_while mark_guards_whileAnno mark_guards_whileAnnoG\n  mark_guards_specAnno"], ["", "definition is_Guard:: \"('s,'p,'f) com \\<Rightarrow> bool\"\n  where \"is_Guard c = (case c of Guard f g c' \\<Rightarrow> True | _ \\<Rightarrow> False)\""], ["", "lemma is_Guard_basic_simps [simp]:\n \"is_Guard Skip = False\"\n \"is_Guard (Basic f) = False\"\n \"is_Guard (Spec r) = False\"\n \"is_Guard (Seq c1 c2) = False\"\n \"is_Guard (Cond b c1 c2) = False\"\n \"is_Guard (While b c) = False\"\n \"is_Guard (Call p) = False\"\n \"is_Guard (DynCom C) = False\"\n \"is_Guard (Guard F g c) = True\"\n \"is_Guard (Throw) = False\"\n \"is_Guard (Catch c1 c2) = False\"\n \"is_Guard (raise f) = False\"\n \"is_Guard (condCatch c1 b c2) = False\"\n \"is_Guard (bind e cv) = False\"\n \"is_Guard (bseq c1 c2) = False\"\n \"is_Guard (block init bdy return cont) = False\"\n \"is_Guard (call init p return cont) = False\"\n \"is_Guard (dynCall init P return cont) = False\"\n \"is_Guard (fcall init p return result cont') = False\"\n \"is_Guard (whileAnno b I V c) = False\"\n \"is_Guard (guaranteeStrip F g c) = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((is_Guard Skip = False &&& is_Guard (Basic f) = False) &&&\n      is_Guard (Spec r) = False &&&\n      is_Guard (Seq c1 c2) = False &&& is_Guard (Cond b c1 c2) = False) &&&\n     (is_Guard (While b c) = False &&& is_Guard (Call p) = False) &&&\n     is_Guard (DynCom C) = False &&&\n     is_Guard (Guard F g c) = True &&& is_Guard Throw = False) &&&\n    ((is_Guard (Catch c1 c2) = False &&& is_Guard (raise f) = False) &&&\n     is_Guard (condCatch c1 b c2) = False &&&\n     is_Guard (bind e cv) = False &&& is_Guard (bseq c1 c2) = False) &&&\n    (is_Guard (block init bdy return cont) = False &&&\n     is_Guard (call init p return cont) = False &&&\n     is_Guard (dynCall init P return cont) = False) &&&\n    is_Guard (fcall init p return result cont') = False &&&\n    is_Guard (whileAnno b I V c) = False &&&\n    is_Guard (guaranteeStrip F g c) = True", "by (auto simp add: is_Guard_def raise_def condCatch_def bind_def bseq_def\n          block_def call_def dynCall_def fcall_def whileAnno_def guaranteeStrip_def)"], ["", "lemma is_Guard_switch [simp]:\n \"is_Guard (switch v Vc) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Guard (switch v Vc) = False", "by (induct Vc) auto"], ["", "lemmas is_Guard_simps = is_Guard_basic_simps is_Guard_switch"], ["", "primrec dest_Guard:: \"('s,'p,'f) com \\<Rightarrow> ('f \\<times> 's set \\<times> ('s,'p,'f) com)\"\n  where \"dest_Guard (Guard f g c) = (f,g,c)\""], ["", "lemma dest_Guard_guaranteeStrip [simp]: \"dest_Guard (guaranteeStrip f g c) = (f,g,c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dest_Guard (guaranteeStrip f g c) = (f, g, c)", "by (simp add: guaranteeStrip_def)"], ["", "lemmas dest_Guard_simps = dest_Guard.simps dest_Guard_guaranteeStrip"], ["", "subsubsection \\<open>Merging Guards: \\<open>merge_guards\\<close>\\<close>"], ["", "primrec merge_guards:: \"('s,'p,'f) com \\<Rightarrow> ('s,'p,'f) com\"\nwhere\n\"merge_guards Skip = Skip\" |\n\"merge_guards (Basic g) = Basic g\" |\n\"merge_guards (Spec r) = Spec r\" |\n\"merge_guards (Seq c\\<^sub>1 c\\<^sub>2)  = (Seq (merge_guards c\\<^sub>1) (merge_guards c\\<^sub>2))\" |\n\"merge_guards (Cond b c\\<^sub>1 c\\<^sub>2) = Cond b (merge_guards c\\<^sub>1) (merge_guards c\\<^sub>2)\" |\n\"merge_guards (While b c) = While b (merge_guards c)\" |\n\"merge_guards (Call p) = Call p\" |\n\"merge_guards (DynCom c) = DynCom (\\<lambda>s. (merge_guards (c s)))\" |\n(*\"merge_guards (Guard f g c) =\n    (case (merge_guards c) of\n      Guard f' g' c' \\<Rightarrow> if f=f' then Guard f (g \\<inter> g') c'\n                        else Guard f g (Guard f' g' c')\n     | _ \\<Rightarrow>  Guard f g (merge_guards c))\"*)\n(* the following version works better with derived language constructs *)\n\"merge_guards (Guard f g c) =\n    (let c' = (merge_guards c)\n     in if is_Guard c'\n        then let (f',g',c'') = dest_Guard c'\n             in if f=f' then Guard f (g \\<inter> g') c''\n                        else Guard f g (Guard f' g' c'')\n        else Guard f g c')\" |\n\"merge_guards Throw = Throw\" |\n\"merge_guards (Catch c\\<^sub>1 c\\<^sub>2) = Catch (merge_guards c\\<^sub>1) (merge_guards c\\<^sub>2)\""], ["", "lemma merge_guards_res_Skip: \"merge_guards c = Skip \\<Longrightarrow> c = Skip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_guards c = Skip \\<Longrightarrow> c = Skip", "by (cases c) (auto split: com.splits if_split_asm simp add: is_Guard_def Let_def)"], ["", "lemma merge_guards_res_Basic: \"merge_guards c = Basic f \\<Longrightarrow> c = Basic f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_guards c = Basic f \\<Longrightarrow> c = Basic f", "by (cases c) (auto split: com.splits if_split_asm simp add: is_Guard_def Let_def)"], ["", "lemma merge_guards_res_Spec: \"merge_guards c = Spec r \\<Longrightarrow> c = Spec r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_guards c = Spec r \\<Longrightarrow> c = Spec r", "by (cases c) (auto split: com.splits if_split_asm simp add: is_Guard_def Let_def)"], ["", "lemma merge_guards_res_Seq: \"merge_guards c = Seq c1 c2 \\<Longrightarrow>\n    \\<exists>c1' c2'. c = Seq c1' c2' \\<and> merge_guards c1' = c1 \\<and> merge_guards c2' = c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_guards c = Seq c1 c2 \\<Longrightarrow>\n    \\<exists>c1' c2'.\n       c = Seq c1' c2' \\<and>\n       merge_guards c1' = c1 \\<and> merge_guards c2' = c2", "by (cases c) (auto split: com.splits if_split_asm simp add: is_Guard_def Let_def)"], ["", "lemma merge_guards_res_Cond: \"merge_guards c = Cond b c1 c2 \\<Longrightarrow>\n    \\<exists>c1' c2'. c = Cond b c1' c2' \\<and> merge_guards c1' = c1 \\<and> merge_guards c2' = c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_guards c = Cond b c1 c2 \\<Longrightarrow>\n    \\<exists>c1' c2'.\n       c = Cond b c1' c2' \\<and>\n       merge_guards c1' = c1 \\<and> merge_guards c2' = c2", "by (cases c) (auto split: com.splits if_split_asm simp add: is_Guard_def Let_def)"], ["", "lemma merge_guards_res_While: \"merge_guards c = While b c' \\<Longrightarrow>\n    \\<exists>c''. c = While b c''  \\<and> merge_guards c'' = c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_guards c = While b c' \\<Longrightarrow>\n    \\<exists>c''. c = While b c'' \\<and> merge_guards c'' = c'", "by (cases c) (auto split: com.splits if_split_asm simp add: is_Guard_def Let_def)"], ["", "lemma merge_guards_res_Call: \"merge_guards c = Call p \\<Longrightarrow> c = Call p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_guards c = Call p \\<Longrightarrow> c = Call p", "by (cases c) (auto split: com.splits if_split_asm simp add: is_Guard_def Let_def)"], ["", "lemma merge_guards_res_DynCom: \"merge_guards c = DynCom c' \\<Longrightarrow>\n    \\<exists>c''. c = DynCom c''  \\<and> (\\<lambda>s. (merge_guards (c'' s))) = c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_guards c = DynCom c' \\<Longrightarrow>\n    \\<exists>c''.\n       c = DynCom c'' \\<and> (\\<lambda>s. merge_guards (c'' s)) = c'", "by (cases c) (auto split: com.splits if_split_asm simp add: is_Guard_def Let_def)"], ["", "lemma merge_guards_res_Throw: \"merge_guards c = Throw \\<Longrightarrow> c = Throw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_guards c = Throw \\<Longrightarrow> c = Throw", "by (cases c) (auto split: com.splits if_split_asm simp add: is_Guard_def Let_def)"], ["", "lemma merge_guards_res_Catch: \"merge_guards c = Catch c1 c2 \\<Longrightarrow>\n    \\<exists>c1' c2'. c = Catch c1' c2' \\<and> merge_guards c1' = c1 \\<and> merge_guards c2' = c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_guards c = Catch c1 c2 \\<Longrightarrow>\n    \\<exists>c1' c2'.\n       c = Catch c1' c2' \\<and>\n       merge_guards c1' = c1 \\<and> merge_guards c2' = c2", "by (cases c) (auto split: com.splits if_split_asm simp add: is_Guard_def Let_def)"], ["", "lemma merge_guards_res_Guard:\n \"merge_guards c = Guard f g c' \\<Longrightarrow> \\<exists>c'' f' g'. c = Guard f' g' c''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_guards c = Guard f g c' \\<Longrightarrow>\n    \\<exists>c'' f' g'. c = Guard f' g' c''", "by (cases c) (auto split: com.splits if_split_asm simp add: is_Guard_def Let_def)"], ["", "lemmas merge_guards_res_simps = merge_guards_res_Skip merge_guards_res_Basic\n merge_guards_res_Spec merge_guards_res_Seq merge_guards_res_Cond\n merge_guards_res_While merge_guards_res_Call\n merge_guards_res_DynCom merge_guards_res_Throw merge_guards_res_Catch\n merge_guards_res_Guard"], ["", "lemma merge_guards_raise: \"merge_guards (raise g) = raise g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_guards (raise g) = raise g", "by (simp add: raise_def)"], ["", "lemma merge_guards_condCatch [simp]:\n  \"merge_guards (condCatch c1 b c2) =\n    condCatch (merge_guards c1) b (merge_guards c2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_guards (condCatch c1 b c2) =\n    condCatch (merge_guards c1) b (merge_guards c2)", "by (simp add: condCatch_def)"], ["", "lemma merge_guards_bind [simp]:\n  \"merge_guards (bind e c) = bind e (\\<lambda>v. merge_guards (c v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_guards (bind e c) = bind e (\\<lambda>v. merge_guards (c v))", "by (simp add: bind_def)"], ["", "lemma merge_guards_bseq [simp]:\n  \"merge_guards (bseq c1 c2) = bseq (merge_guards c1) (merge_guards c2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_guards (bseq c1 c2) = bseq (merge_guards c1) (merge_guards c2)", "by (simp add: bseq_def)"], ["", "lemma merge_guards_block [simp]:\n  \"merge_guards (block init bdy return c) =\n    block init (merge_guards bdy) return (\\<lambda>s t. merge_guards (c s t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_guards (block init bdy return c) =\n    block init (merge_guards bdy) return\n     (\\<lambda>s t. merge_guards (c s t))", "by (simp add: block_def)"], ["", "lemma merge_guards_call [simp]:\n  \"merge_guards (call init p return c) =\n     call init p return (\\<lambda>s t. merge_guards (c s t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_guards (call init p return c) =\n    call init p return (\\<lambda>s t. merge_guards (c s t))", "by (simp add: call_def)"], ["", "lemma merge_guards_dynCall [simp]:\n  \"merge_guards (dynCall init p return c) =\n     dynCall init p return (\\<lambda>s t. merge_guards (c s t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_guards (dynCall init p return c) =\n    dynCall init p return (\\<lambda>s t. merge_guards (c s t))", "by (simp add: dynCall_def)"], ["", "lemma merge_guards_fcall [simp]:\n  \"merge_guards (fcall init p return result c) =\n     fcall init p return result (\\<lambda>v. merge_guards (c v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_guards (fcall init p return result c) =\n    fcall init p return result (\\<lambda>v. merge_guards (c v))", "by (simp add: fcall_def)"], ["", "lemma merge_guards_switch [simp]:\n  \"merge_guards (switch v vs) =\n     switch v (map (\\<lambda>(V,c). (V,merge_guards c)) vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_guards (switch v vs) =\n    switch v (map (\\<lambda>(V, c). (V, merge_guards c)) vs)", "by (induct vs) auto"], ["", "lemma merge_guards_guaranteeStrip [simp]:\n  \"merge_guards (guaranteeStrip f g c) =\n    (let c' = (merge_guards c)\n     in if is_Guard c'\n        then let (f',g',c') = dest_Guard c'\n             in if f=f' then Guard f (g \\<inter> g') c'\n                        else Guard f g (Guard f' g' c')\n        else Guard f g c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_guards (guaranteeStrip f g c) =\n    (let c' = merge_guards c\n     in if is_Guard c'\n        then let (f', g', c') = dest_Guard c'\n             in if f = f' then Guard f (g \\<inter> g') c'\n                else Guard f g (Guard f' g' c')\n        else Guard f g c')", "by (simp add: guaranteeStrip_def)"], ["", "lemma merge_guards_whileAnno [simp]:\n \"merge_guards (whileAnno b I V c) = whileAnno b I V (merge_guards c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_guards (whileAnno b I V c) = whileAnno b I V (merge_guards c)", "by (simp add: whileAnno_def while_def)"], ["", "lemma merge_guards_specAnno [simp]:\n  \"merge_guards (specAnno P c Q A) =\n    specAnno P (\\<lambda>s. merge_guards (c undefined)) Q A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_guards (specAnno P c Q A) =\n    specAnno P (\\<lambda>s. merge_guards (c undefined)) Q A", "by (simp add: specAnno_def)"], ["", "text \\<open>@{term \"merge_guards\"} for guard-lists as in @{const guards}, @{const while}\n and @{const whileAnnoG} may have funny effects since the guard-list has to\n be merged with the body statement too.\\<close>"], ["", "lemmas merge_guards_simps = merge_guards.simps merge_guards_raise\n  merge_guards_condCatch merge_guards_bind merge_guards_bseq merge_guards_block\n  merge_guards_dynCall merge_guards_fcall merge_guards_switch\n  merge_guards_guaranteeStrip merge_guards_whileAnno merge_guards_specAnno"], ["", "primrec noguards:: \"('s,'p,'f) com \\<Rightarrow> bool\"\nwhere\n\"noguards Skip = True\" |\n\"noguards (Basic f) = True\" |\n\"noguards (Spec r ) = True\" |\n\"noguards (Seq c\\<^sub>1 c\\<^sub>2)  = (noguards c\\<^sub>1 \\<and> noguards c\\<^sub>2)\" |\n\"noguards (Cond b c\\<^sub>1 c\\<^sub>2) = (noguards c\\<^sub>1 \\<and> noguards c\\<^sub>2)\" |\n\"noguards (While b c) = (noguards c)\" |\n\"noguards (Call p) = True\" |\n\"noguards (DynCom c) = (\\<forall>s. noguards (c s))\" |\n\"noguards (Guard f g c) = False\" |\n\"noguards Throw = True\" |\n\"noguards (Catch c\\<^sub>1 c\\<^sub>2) = (noguards c\\<^sub>1 \\<and> noguards c\\<^sub>2)\""], ["", "lemma noguards_strip_guards: \"noguards (strip_guards UNIV c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noguards (strip_guards UNIV c)", "by (induct c) auto"], ["", "primrec nothrows:: \"('s,'p,'f) com \\<Rightarrow> bool\"\nwhere\n\"nothrows Skip = True\" |\n\"nothrows (Basic f) = True\" |\n\"nothrows (Spec r) = True\" |\n\"nothrows (Seq c\\<^sub>1 c\\<^sub>2)  = (nothrows c\\<^sub>1 \\<and> nothrows c\\<^sub>2)\" |\n\"nothrows (Cond b c\\<^sub>1 c\\<^sub>2) = (nothrows c\\<^sub>1 \\<and> nothrows c\\<^sub>2)\" |\n\"nothrows (While b c) = nothrows c\" |\n\"nothrows (Call p) = True\" |\n\"nothrows (DynCom c) = (\\<forall>s. nothrows (c s))\" |\n\"nothrows (Guard f g c) = nothrows c\" |\n\"nothrows Throw = False\" |\n\"nothrows (Catch c\\<^sub>1 c\\<^sub>2) = (nothrows c\\<^sub>1 \\<and> nothrows c\\<^sub>2)\""], ["", "subsubsection \\<open>Intersecting Guards: \\<open>c\\<^sub>1 \\<inter>\\<^sub>g c\\<^sub>2\\<close>\\<close>"], ["", "inductive_set com_rel ::\"(('s,'p,'f) com \\<times> ('s,'p,'f) com) set\"\nwhere\n  \"(c1, Seq c1 c2) \\<in> com_rel\"\n| \"(c2, Seq c1 c2) \\<in> com_rel\"\n| \"(c1, Cond b c1 c2) \\<in> com_rel\"\n| \"(c2, Cond b c1 c2) \\<in> com_rel\"\n| \"(c, While b c) \\<in> com_rel\"\n| \"(c x, DynCom c) \\<in> com_rel\"\n| \"(c, Guard f g c) \\<in> com_rel\"\n| \"(c1, Catch c1 c2) \\<in> com_rel\"\n| \"(c2, Catch c1 c2) \\<in> com_rel\""], ["", "inductive_cases com_rel_elim_cases:\n \"(c, Skip) \\<in> com_rel\"\n \"(c, Basic f) \\<in> com_rel\"\n \"(c, Spec r) \\<in> com_rel\"\n \"(c, Seq c1 c2) \\<in> com_rel\"\n \"(c, Cond b c1 c2) \\<in> com_rel\"\n \"(c, While b c1) \\<in> com_rel\"\n \"(c, Call p) \\<in> com_rel\"\n \"(c, DynCom c1) \\<in> com_rel\"\n \"(c, Guard f g c1) \\<in> com_rel\"\n \"(c, Throw) \\<in> com_rel\"\n \"(c, Catch c1 c2) \\<in> com_rel\""], ["", "lemma wf_com_rel: \"wf com_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf com_rel", "apply (rule wfUNIVI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P x.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> com_rel \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P x", "apply (induct_tac x)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>P x.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> com_rel \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P Skip\n 2. \\<And>P x xa.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> com_rel \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P (Basic xa)\n 3. \\<And>P x xa.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> com_rel \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P (Spec xa)\n 4. \\<And>P x x1 x2a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x1; P x2a\\<rbrakk>\n       \\<Longrightarrow> P (Seq x1 x2a)\n 5. \\<And>P x x1 x2a x3a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x2a; P x3a\\<rbrakk>\n       \\<Longrightarrow> P (Cond x1 x2a x3a)\n 6. \\<And>P x x1 x2a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x2a\\<rbrakk>\n       \\<Longrightarrow> P (While x1 x2a)\n 7. \\<And>P x xa.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> com_rel \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P (Call xa)\n 8. \\<And>P x xa.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        \\<And>xaa. xaa \\<in> range xa \\<Longrightarrow> P xaa\\<rbrakk>\n       \\<Longrightarrow> P (DynCom xa)\n 9. \\<And>P x x1 x2a x3a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x3a\\<rbrakk>\n       \\<Longrightarrow> P (Guard x1 x2a x3a)\n 10. \\<And>P x.\n        \\<forall>x.\n           (\\<forall>y.\n               (y, x) \\<in> com_rel \\<longrightarrow> P y) \\<longrightarrow>\n           P x \\<Longrightarrow>\n        P Throw\nA total of 11 subgoals...", "apply           (erule allE, erule mp, (rule allI impI)+, erule com_rel_elim_cases)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>P x xa.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> com_rel \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P (Basic xa)\n 2. \\<And>P x xa.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> com_rel \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P (Spec xa)\n 3. \\<And>P x x1 x2a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x1; P x2a\\<rbrakk>\n       \\<Longrightarrow> P (Seq x1 x2a)\n 4. \\<And>P x x1 x2a x3a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x2a; P x3a\\<rbrakk>\n       \\<Longrightarrow> P (Cond x1 x2a x3a)\n 5. \\<And>P x x1 x2a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x2a\\<rbrakk>\n       \\<Longrightarrow> P (While x1 x2a)\n 6. \\<And>P x xa.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> com_rel \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P (Call xa)\n 7. \\<And>P x xa.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        \\<And>xaa. xaa \\<in> range xa \\<Longrightarrow> P xaa\\<rbrakk>\n       \\<Longrightarrow> P (DynCom xa)\n 8. \\<And>P x x1 x2a x3a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x3a\\<rbrakk>\n       \\<Longrightarrow> P (Guard x1 x2a x3a)\n 9. \\<And>P x.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> com_rel \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P Throw\n 10. \\<And>P x x1 x2a.\n        \\<lbrakk>\\<forall>x.\n                    (\\<forall>y.\n                        (y, x) \\<in> com_rel \\<longrightarrow>\n                        P y) \\<longrightarrow>\n                    P x;\n         P x1; P x2a\\<rbrakk>\n        \\<Longrightarrow> P (Catch x1 x2a)", "apply          (erule allE, erule mp, (rule allI impI)+, erule com_rel_elim_cases)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>P x xa.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> com_rel \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P (Spec xa)\n 2. \\<And>P x x1 x2a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x1; P x2a\\<rbrakk>\n       \\<Longrightarrow> P (Seq x1 x2a)\n 3. \\<And>P x x1 x2a x3a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x2a; P x3a\\<rbrakk>\n       \\<Longrightarrow> P (Cond x1 x2a x3a)\n 4. \\<And>P x x1 x2a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x2a\\<rbrakk>\n       \\<Longrightarrow> P (While x1 x2a)\n 5. \\<And>P x xa.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> com_rel \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P (Call xa)\n 6. \\<And>P x xa.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        \\<And>xaa. xaa \\<in> range xa \\<Longrightarrow> P xaa\\<rbrakk>\n       \\<Longrightarrow> P (DynCom xa)\n 7. \\<And>P x x1 x2a x3a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x3a\\<rbrakk>\n       \\<Longrightarrow> P (Guard x1 x2a x3a)\n 8. \\<And>P x.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> com_rel \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P Throw\n 9. \\<And>P x x1 x2a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x1; P x2a\\<rbrakk>\n       \\<Longrightarrow> P (Catch x1 x2a)", "apply         (erule allE, erule mp, (rule allI impI)+, erule com_rel_elim_cases)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>P x x1 x2a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x1; P x2a\\<rbrakk>\n       \\<Longrightarrow> P (Seq x1 x2a)\n 2. \\<And>P x x1 x2a x3a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x2a; P x3a\\<rbrakk>\n       \\<Longrightarrow> P (Cond x1 x2a x3a)\n 3. \\<And>P x x1 x2a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x2a\\<rbrakk>\n       \\<Longrightarrow> P (While x1 x2a)\n 4. \\<And>P x xa.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> com_rel \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P (Call xa)\n 5. \\<And>P x xa.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        \\<And>xaa. xaa \\<in> range xa \\<Longrightarrow> P xaa\\<rbrakk>\n       \\<Longrightarrow> P (DynCom xa)\n 6. \\<And>P x x1 x2a x3a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x3a\\<rbrakk>\n       \\<Longrightarrow> P (Guard x1 x2a x3a)\n 7. \\<And>P x.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> com_rel \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P Throw\n 8. \\<And>P x x1 x2a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x1; P x2a\\<rbrakk>\n       \\<Longrightarrow> P (Catch x1 x2a)", "apply        (erule allE, erule mp, (rule allI impI)+, erule com_rel_elim_cases,\n               simp,simp)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>P x x1 x2a x3a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x2a; P x3a\\<rbrakk>\n       \\<Longrightarrow> P (Cond x1 x2a x3a)\n 2. \\<And>P x x1 x2a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x2a\\<rbrakk>\n       \\<Longrightarrow> P (While x1 x2a)\n 3. \\<And>P x xa.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> com_rel \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P (Call xa)\n 4. \\<And>P x xa.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        \\<And>xaa. xaa \\<in> range xa \\<Longrightarrow> P xaa\\<rbrakk>\n       \\<Longrightarrow> P (DynCom xa)\n 5. \\<And>P x x1 x2a x3a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x3a\\<rbrakk>\n       \\<Longrightarrow> P (Guard x1 x2a x3a)\n 6. \\<And>P x.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> com_rel \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P Throw\n 7. \\<And>P x x1 x2a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x1; P x2a\\<rbrakk>\n       \\<Longrightarrow> P (Catch x1 x2a)", "apply       (erule allE, erule mp, (rule allI impI)+, erule com_rel_elim_cases,\n              simp,simp)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>P x x1 x2a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x2a\\<rbrakk>\n       \\<Longrightarrow> P (While x1 x2a)\n 2. \\<And>P x xa.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> com_rel \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P (Call xa)\n 3. \\<And>P x xa.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        \\<And>xaa. xaa \\<in> range xa \\<Longrightarrow> P xaa\\<rbrakk>\n       \\<Longrightarrow> P (DynCom xa)\n 4. \\<And>P x x1 x2a x3a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x3a\\<rbrakk>\n       \\<Longrightarrow> P (Guard x1 x2a x3a)\n 5. \\<And>P x.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> com_rel \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P Throw\n 6. \\<And>P x x1 x2a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x1; P x2a\\<rbrakk>\n       \\<Longrightarrow> P (Catch x1 x2a)", "apply      (erule allE, erule mp, (rule allI impI)+, erule com_rel_elim_cases,simp)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>P x xa.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> com_rel \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P (Call xa)\n 2. \\<And>P x xa.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        \\<And>xaa. xaa \\<in> range xa \\<Longrightarrow> P xaa\\<rbrakk>\n       \\<Longrightarrow> P (DynCom xa)\n 3. \\<And>P x x1 x2a x3a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x3a\\<rbrakk>\n       \\<Longrightarrow> P (Guard x1 x2a x3a)\n 4. \\<And>P x.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> com_rel \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P Throw\n 5. \\<And>P x x1 x2a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x1; P x2a\\<rbrakk>\n       \\<Longrightarrow> P (Catch x1 x2a)", "apply     (erule allE, erule mp, (rule allI impI)+, erule com_rel_elim_cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x xa.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        \\<And>xaa. xaa \\<in> range xa \\<Longrightarrow> P xaa\\<rbrakk>\n       \\<Longrightarrow> P (DynCom xa)\n 2. \\<And>P x x1 x2a x3a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x3a\\<rbrakk>\n       \\<Longrightarrow> P (Guard x1 x2a x3a)\n 3. \\<And>P x.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> com_rel \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P Throw\n 4. \\<And>P x x1 x2a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x1; P x2a\\<rbrakk>\n       \\<Longrightarrow> P (Catch x1 x2a)", "apply    (erule allE, erule mp, (rule allI impI)+, erule com_rel_elim_cases,simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>P x x1 x2a x3a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x3a\\<rbrakk>\n       \\<Longrightarrow> P (Guard x1 x2a x3a)\n 2. \\<And>P x.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> com_rel \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P Throw\n 3. \\<And>P x x1 x2a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x1; P x2a\\<rbrakk>\n       \\<Longrightarrow> P (Catch x1 x2a)", "apply   (erule allE, erule mp, (rule allI impI)+, erule com_rel_elim_cases,simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       \\<forall>x.\n          (\\<forall>y.\n              (y, x) \\<in> com_rel \\<longrightarrow> P y) \\<longrightarrow>\n          P x \\<Longrightarrow>\n       P Throw\n 2. \\<And>P x x1 x2a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x1; P x2a\\<rbrakk>\n       \\<Longrightarrow> P (Catch x1 x2a)", "apply  (erule allE, erule mp, (rule allI impI)+, erule com_rel_elim_cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P x x1 x2a.\n       \\<lbrakk>\\<forall>x.\n                   (\\<forall>y.\n                       (y, x) \\<in> com_rel \\<longrightarrow>\n                       P y) \\<longrightarrow>\n                   P x;\n        P x1; P x2a\\<rbrakk>\n       \\<Longrightarrow> P (Catch x1 x2a)", "apply (erule allE, erule mp, (rule allI impI)+, erule com_rel_elim_cases,simp,simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "consts inter_guards:: \"('s,'p,'f) com \\<times> ('s,'p,'f) com \\<Rightarrow> ('s,'p,'f) com option\""], ["", "abbreviation\n  inter_guards_syntax :: \"('s,'p,'f) com \\<Rightarrow> ('s,'p,'f) com \\<Rightarrow> ('s,'p,'f) com option\"\n           (\"_ \\<inter>\\<^sub>g _\" [20,20] 19)\n  where \"c \\<inter>\\<^sub>g d == inter_guards (c,d)\""], ["", "recdef inter_guards \"inv_image com_rel fst\"\n  \"(Skip \\<inter>\\<^sub>g Skip) = Some Skip\"\n  \"(Basic f1 \\<inter>\\<^sub>g Basic f2) = (if f1 = f2 then Some (Basic f1) else None)\"\n  \"(Spec r1 \\<inter>\\<^sub>g Spec r2) = (if r1 = r2 then Some (Spec r1) else None)\"\n  \"(Seq a1 a2 \\<inter>\\<^sub>g Seq b1 b2) =\n     (case a1 \\<inter>\\<^sub>g b1 of\n        None \\<Rightarrow> None\n      | Some c1 \\<Rightarrow> (case a2 \\<inter>\\<^sub>g b2 of\n          None \\<Rightarrow> None\n        | Some c2 \\<Rightarrow> Some (Seq c1 c2)))\"\n  \"(Cond cnd1 t1 e1 \\<inter>\\<^sub>g Cond cnd2 t2 e2) =\n     (if cnd1 = cnd2\n      then (case t1 \\<inter>\\<^sub>g t2 of\n            None \\<Rightarrow> None\n          | Some t \\<Rightarrow> (case e1 \\<inter>\\<^sub>g e2 of\n              None \\<Rightarrow> None\n            | Some e \\<Rightarrow> Some (Cond cnd1 t e)))\n      else None)\"\n  \"(While cnd1 c1 \\<inter>\\<^sub>g While cnd2 c2) =\n      (if cnd1 = cnd2\n       then (case c1 \\<inter>\\<^sub>g c2 of\n           None \\<Rightarrow> None\n         | Some c \\<Rightarrow> Some (While cnd1 c))\n       else None)\"\n  \"(Call p1 \\<inter>\\<^sub>g Call p2) =\n     (if p1 = p2\n      then Some (Call p1)\n      else None)\"\n  \"(DynCom P1 \\<inter>\\<^sub>g DynCom P2) =\n     (if (\\<forall>s. (P1 s \\<inter>\\<^sub>g P2 s) \\<noteq> None)\n     then Some (DynCom (\\<lambda>s. the (P1 s \\<inter>\\<^sub>g P2 s)))\n     else None)\"\n  \"(Guard m1 g1 c1 \\<inter>\\<^sub>g Guard m2 g2 c2) =\n     (if m1 = m2 then\n       (case c1 \\<inter>\\<^sub>g c2 of\n          None \\<Rightarrow> None\n        | Some c \\<Rightarrow> Some (Guard m1 (g1 \\<inter> g2) c))\n      else None)\"\n  \"(Throw \\<inter>\\<^sub>g Throw) = Some Throw\"\n  \"(Catch a1 a2 \\<inter>\\<^sub>g Catch b1 b2) =\n     (case a1 \\<inter>\\<^sub>g b1 of\n        None \\<Rightarrow> None\n      | Some c1 \\<Rightarrow> (case a2 \\<inter>\\<^sub>g b2 of\n          None \\<Rightarrow> None\n        | Some c2 \\<Rightarrow> Some (Catch c1 c2)))\"\n  \"(c \\<inter>\\<^sub>g d) = None\"\n(hints cong add: option.case_cong if_cong\n       recdef_wf: wf_com_rel simp: com_rel.intros)"], ["", "lemma inter_guards_strip_eq:\n  \"\\<And>c. (c1 \\<inter>\\<^sub>g c2) = Some c  \\<Longrightarrow>\n    (strip_guards UNIV c = strip_guards UNIV c1) \\<and>\n    (strip_guards UNIV c = strip_guards UNIV c2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       (c1 \\<inter>\\<^sub>g c2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV c1 \\<and>\n       strip_guards UNIV c = strip_guards UNIV c2", "apply (induct c1 c2 rule: inter_guards.induct)"], ["proof (prove)\ngoal (121 subgoals):\n 1. \\<And>c.\n       (Skip \\<inter>\\<^sub>g Skip) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV Skip \\<and>\n       strip_guards UNIV c = strip_guards UNIV Skip\n 2. \\<And>f1 f2 c.\n       (Basic f1 \\<inter>\\<^sub>g Basic f2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV (Basic f1) \\<and>\n       strip_guards UNIV c = strip_guards UNIV (Basic f2)\n 3. \\<And>r1 r2 c.\n       (Spec r1 \\<inter>\\<^sub>g Spec r2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV (Spec r1) \\<and>\n       strip_guards UNIV c = strip_guards UNIV (Spec r2)\n 4. \\<And>a1 a2 b1 b2 c.\n       \\<lbrakk>(\\<exists>c1.\n                    (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                (\\<forall>x.\n                    (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV a2 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV b2);\n        \\<And>c.\n           (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n           strip_guards UNIV c = strip_guards UNIV a1 \\<and>\n           strip_guards UNIV c = strip_guards UNIV b1;\n        (Seq a1 a2 \\<inter>\\<^sub>g Seq b1 b2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (Seq a1 a2) \\<and>\n                         strip_guards UNIV c = strip_guards UNIV (Seq b1 b2)\n 5. \\<And>cnd1 t1 e1 cnd2 t2 e2 c.\n       \\<lbrakk>(\\<exists>t. (t1 \\<inter>\\<^sub>g t2) = Some t) \\<and>\n                cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (e1 \\<inter>\\<^sub>g e2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV e1 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV e2);\n        cnd1 = cnd2 \\<longrightarrow>\n        (\\<forall>x.\n            (t1 \\<inter>\\<^sub>g t2) = Some x \\<longrightarrow>\n            strip_guards UNIV x = strip_guards UNIV t1 \\<and>\n            strip_guards UNIV x = strip_guards UNIV t2);\n        (Cond cnd1 t1 e1 \\<inter>\\<^sub>g Cond cnd2 t2 e2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (Cond cnd1 t1 e1) \\<and>\n                         strip_guards UNIV c =\n                         strip_guards UNIV (Cond cnd2 t2 e2)\n 6. \\<And>cnd1 c1 cnd2 c2 c.\n       \\<lbrakk>cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV c1 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV c2);\n        (While cnd1 c1 \\<inter>\\<^sub>g While cnd2 c2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (While cnd1 c1) \\<and>\n                         strip_guards UNIV c =\n                         strip_guards UNIV (While cnd2 c2)\n 7. \\<And>p1 p2 c.\n       (Call p1 \\<inter>\\<^sub>g Call p2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV (Call p1) \\<and>\n       strip_guards UNIV c = strip_guards UNIV (Call p2)\n 8. \\<And>P1 P2 c.\n       \\<lbrakk>(\\<forall>s.\n                    \\<exists>y.\n                       (P1 s \\<inter>\\<^sub>g P2 s) =\n                       Some y) \\<longrightarrow>\n                (\\<forall>:000 x.\n                    (P1 :000 \\<inter>\\<^sub>g P2 :000) =\n                    Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV (P1 :000) \\<and>\n                    strip_guards UNIV x = strip_guards UNIV (P2 :000));\n        \\<And>c.\n           (P1 ?ua \\<inter>\\<^sub>g P2 ?ua) = Some c \\<Longrightarrow>\n           strip_guards UNIV c = strip_guards UNIV (P1 ?ua) \\<and>\n           strip_guards UNIV c = strip_guards UNIV (P2 ?ua);\n        (DynCom P1 \\<inter>\\<^sub>g DynCom P2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (DynCom P1) \\<and>\n                         strip_guards UNIV c = strip_guards UNIV (DynCom P2)\n 9. \\<And>m1 g1 c1 m2 g2 c2 c.\n       \\<lbrakk>m1 = m2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV c1 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV c2);\n        (Guard m1 g1 c1 \\<inter>\\<^sub>g Guard m2 g2 c2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (Guard m1 g1 c1) \\<and>\n                         strip_guards UNIV c =\n                         strip_guards UNIV (Guard m2 g2 c2)\n 10. \\<And>c.\n        (Throw \\<inter>\\<^sub>g Throw) = Some c \\<Longrightarrow>\n        strip_guards UNIV c = strip_guards UNIV Throw \\<and>\n        strip_guards UNIV c = strip_guards UNIV Throw\nA total of 121 subgoals...", "prefer 8"], ["proof (prove)\ngoal (121 subgoals):\n 1. \\<And>P1 P2 c.\n       \\<lbrakk>(\\<forall>s.\n                    \\<exists>y.\n                       (P1 s \\<inter>\\<^sub>g P2 s) =\n                       Some y) \\<longrightarrow>\n                (\\<forall>:000 x.\n                    (P1 :000 \\<inter>\\<^sub>g P2 :000) =\n                    Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV (P1 :000) \\<and>\n                    strip_guards UNIV x = strip_guards UNIV (P2 :000));\n        \\<And>c.\n           (P1 ?ua \\<inter>\\<^sub>g P2 ?ua) = Some c \\<Longrightarrow>\n           strip_guards UNIV c = strip_guards UNIV (P1 ?ua) \\<and>\n           strip_guards UNIV c = strip_guards UNIV (P2 ?ua);\n        (DynCom P1 \\<inter>\\<^sub>g DynCom P2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (DynCom P1) \\<and>\n                         strip_guards UNIV c = strip_guards UNIV (DynCom P2)\n 2. \\<And>c.\n       (Skip \\<inter>\\<^sub>g Skip) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV Skip \\<and>\n       strip_guards UNIV c = strip_guards UNIV Skip\n 3. \\<And>f1 f2 c.\n       (Basic f1 \\<inter>\\<^sub>g Basic f2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV (Basic f1) \\<and>\n       strip_guards UNIV c = strip_guards UNIV (Basic f2)\n 4. \\<And>r1 r2 c.\n       (Spec r1 \\<inter>\\<^sub>g Spec r2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV (Spec r1) \\<and>\n       strip_guards UNIV c = strip_guards UNIV (Spec r2)\n 5. \\<And>a1 a2 b1 b2 c.\n       \\<lbrakk>(\\<exists>c1.\n                    (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                (\\<forall>x.\n                    (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV a2 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV b2);\n        \\<And>c.\n           (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n           strip_guards UNIV c = strip_guards UNIV a1 \\<and>\n           strip_guards UNIV c = strip_guards UNIV b1;\n        (Seq a1 a2 \\<inter>\\<^sub>g Seq b1 b2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (Seq a1 a2) \\<and>\n                         strip_guards UNIV c = strip_guards UNIV (Seq b1 b2)\n 6. \\<And>cnd1 t1 e1 cnd2 t2 e2 c.\n       \\<lbrakk>(\\<exists>t. (t1 \\<inter>\\<^sub>g t2) = Some t) \\<and>\n                cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (e1 \\<inter>\\<^sub>g e2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV e1 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV e2);\n        cnd1 = cnd2 \\<longrightarrow>\n        (\\<forall>x.\n            (t1 \\<inter>\\<^sub>g t2) = Some x \\<longrightarrow>\n            strip_guards UNIV x = strip_guards UNIV t1 \\<and>\n            strip_guards UNIV x = strip_guards UNIV t2);\n        (Cond cnd1 t1 e1 \\<inter>\\<^sub>g Cond cnd2 t2 e2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (Cond cnd1 t1 e1) \\<and>\n                         strip_guards UNIV c =\n                         strip_guards UNIV (Cond cnd2 t2 e2)\n 7. \\<And>cnd1 c1 cnd2 c2 c.\n       \\<lbrakk>cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV c1 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV c2);\n        (While cnd1 c1 \\<inter>\\<^sub>g While cnd2 c2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (While cnd1 c1) \\<and>\n                         strip_guards UNIV c =\n                         strip_guards UNIV (While cnd2 c2)\n 8. \\<And>p1 p2 c.\n       (Call p1 \\<inter>\\<^sub>g Call p2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV (Call p1) \\<and>\n       strip_guards UNIV c = strip_guards UNIV (Call p2)\n 9. \\<And>m1 g1 c1 m2 g2 c2 c.\n       \\<lbrakk>m1 = m2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV c1 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV c2);\n        (Guard m1 g1 c1 \\<inter>\\<^sub>g Guard m2 g2 c2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (Guard m1 g1 c1) \\<and>\n                         strip_guards UNIV c =\n                         strip_guards UNIV (Guard m2 g2 c2)\n 10. \\<And>c.\n        (Throw \\<inter>\\<^sub>g Throw) = Some c \\<Longrightarrow>\n        strip_guards UNIV c = strip_guards UNIV Throw \\<and>\n        strip_guards UNIV c = strip_guards UNIV Throw\nA total of 121 subgoals...", "apply (simp split: if_split_asm)"], ["proof (prove)\ngoal (121 subgoals):\n 1. \\<And>P1 P2 c.\n       \\<lbrakk>\\<forall>:000 x.\n                   (P1 :000 \\<inter>\\<^sub>g P2 :000) =\n                   Some x \\<longrightarrow>\n                   strip_guards UNIV x = strip_guards UNIV (P1 :000) \\<and>\n                   strip_guards UNIV x = strip_guards UNIV (P2 :000);\n        \\<And>c.\n           (P1 ?ua \\<inter>\\<^sub>g P2 ?ua) = Some c \\<Longrightarrow>\n           strip_guards UNIV c = strip_guards UNIV (P1 ?ua) \\<and>\n           strip_guards UNIV c = strip_guards UNIV (P2 ?ua);\n        \\<forall>s. \\<exists>y. (P1 s \\<inter>\\<^sub>g P2 s) = Some y;\n        DynCom (\\<lambda>s. the (P1 s \\<inter>\\<^sub>g P2 s)) = c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         DynCom\n                          (\\<lambda>s. strip_guards UNIV (P1 s)) \\<and>\n                         strip_guards UNIV c =\n                         DynCom (\\<lambda>s. strip_guards UNIV (P2 s))\n 2. \\<And>c.\n       (Skip \\<inter>\\<^sub>g Skip) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV Skip \\<and>\n       strip_guards UNIV c = strip_guards UNIV Skip\n 3. \\<And>f1 f2 c.\n       (Basic f1 \\<inter>\\<^sub>g Basic f2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV (Basic f1) \\<and>\n       strip_guards UNIV c = strip_guards UNIV (Basic f2)\n 4. \\<And>r1 r2 c.\n       (Spec r1 \\<inter>\\<^sub>g Spec r2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV (Spec r1) \\<and>\n       strip_guards UNIV c = strip_guards UNIV (Spec r2)\n 5. \\<And>a1 a2 b1 b2 c.\n       \\<lbrakk>(\\<exists>c1.\n                    (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                (\\<forall>x.\n                    (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV a2 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV b2);\n        \\<And>c.\n           (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n           strip_guards UNIV c = strip_guards UNIV a1 \\<and>\n           strip_guards UNIV c = strip_guards UNIV b1;\n        (Seq a1 a2 \\<inter>\\<^sub>g Seq b1 b2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (Seq a1 a2) \\<and>\n                         strip_guards UNIV c = strip_guards UNIV (Seq b1 b2)\n 6. \\<And>cnd1 t1 e1 cnd2 t2 e2 c.\n       \\<lbrakk>(\\<exists>t. (t1 \\<inter>\\<^sub>g t2) = Some t) \\<and>\n                cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (e1 \\<inter>\\<^sub>g e2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV e1 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV e2);\n        cnd1 = cnd2 \\<longrightarrow>\n        (\\<forall>x.\n            (t1 \\<inter>\\<^sub>g t2) = Some x \\<longrightarrow>\n            strip_guards UNIV x = strip_guards UNIV t1 \\<and>\n            strip_guards UNIV x = strip_guards UNIV t2);\n        (Cond cnd1 t1 e1 \\<inter>\\<^sub>g Cond cnd2 t2 e2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (Cond cnd1 t1 e1) \\<and>\n                         strip_guards UNIV c =\n                         strip_guards UNIV (Cond cnd2 t2 e2)\n 7. \\<And>cnd1 c1 cnd2 c2 c.\n       \\<lbrakk>cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV c1 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV c2);\n        (While cnd1 c1 \\<inter>\\<^sub>g While cnd2 c2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (While cnd1 c1) \\<and>\n                         strip_guards UNIV c =\n                         strip_guards UNIV (While cnd2 c2)\n 8. \\<And>p1 p2 c.\n       (Call p1 \\<inter>\\<^sub>g Call p2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV (Call p1) \\<and>\n       strip_guards UNIV c = strip_guards UNIV (Call p2)\n 9. \\<And>m1 g1 c1 m2 g2 c2 c.\n       \\<lbrakk>m1 = m2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV c1 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV c2);\n        (Guard m1 g1 c1 \\<inter>\\<^sub>g Guard m2 g2 c2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (Guard m1 g1 c1) \\<and>\n                         strip_guards UNIV c =\n                         strip_guards UNIV (Guard m2 g2 c2)\n 10. \\<And>c.\n        (Throw \\<inter>\\<^sub>g Throw) = Some c \\<Longrightarrow>\n        strip_guards UNIV c = strip_guards UNIV Throw \\<and>\n        strip_guards UNIV c = strip_guards UNIV Throw\nA total of 121 subgoals...", "apply hypsubst"], ["proof (prove)\ngoal (121 subgoals):\n 1. \\<And>P1 P2 c.\n       \\<lbrakk>\\<forall>:000 x.\n                   (P1 :000 \\<inter>\\<^sub>g P2 :000) =\n                   Some x \\<longrightarrow>\n                   strip_guards UNIV x = strip_guards UNIV (P1 :000) \\<and>\n                   strip_guards UNIV x = strip_guards UNIV (P2 :000);\n        \\<And>c.\n           (P1 ?ua \\<inter>\\<^sub>g P2 ?ua) = Some c \\<Longrightarrow>\n           strip_guards UNIV c = strip_guards UNIV (P1 ?ua) \\<and>\n           strip_guards UNIV c = strip_guards UNIV (P2 ?ua);\n        \\<forall>s.\n           \\<exists>y. (P1 s \\<inter>\\<^sub>g P2 s) = Some y\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV\n                          (DynCom\n                            (\\<lambda>s.\n                                the (P1 s \\<inter>\\<^sub>g P2 s))) =\n                         DynCom\n                          (\\<lambda>s. strip_guards UNIV (P1 s)) \\<and>\n                         strip_guards UNIV\n                          (DynCom\n                            (\\<lambda>s.\n                                the (P1 s \\<inter>\\<^sub>g P2 s))) =\n                         DynCom (\\<lambda>s. strip_guards UNIV (P2 s))\n 2. \\<And>c.\n       (Skip \\<inter>\\<^sub>g Skip) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV Skip \\<and>\n       strip_guards UNIV c = strip_guards UNIV Skip\n 3. \\<And>f1 f2 c.\n       (Basic f1 \\<inter>\\<^sub>g Basic f2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV (Basic f1) \\<and>\n       strip_guards UNIV c = strip_guards UNIV (Basic f2)\n 4. \\<And>r1 r2 c.\n       (Spec r1 \\<inter>\\<^sub>g Spec r2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV (Spec r1) \\<and>\n       strip_guards UNIV c = strip_guards UNIV (Spec r2)\n 5. \\<And>a1 a2 b1 b2 c.\n       \\<lbrakk>(\\<exists>c1.\n                    (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                (\\<forall>x.\n                    (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV a2 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV b2);\n        \\<And>c.\n           (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n           strip_guards UNIV c = strip_guards UNIV a1 \\<and>\n           strip_guards UNIV c = strip_guards UNIV b1;\n        (Seq a1 a2 \\<inter>\\<^sub>g Seq b1 b2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (Seq a1 a2) \\<and>\n                         strip_guards UNIV c = strip_guards UNIV (Seq b1 b2)\n 6. \\<And>cnd1 t1 e1 cnd2 t2 e2 c.\n       \\<lbrakk>(\\<exists>t. (t1 \\<inter>\\<^sub>g t2) = Some t) \\<and>\n                cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (e1 \\<inter>\\<^sub>g e2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV e1 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV e2);\n        cnd1 = cnd2 \\<longrightarrow>\n        (\\<forall>x.\n            (t1 \\<inter>\\<^sub>g t2) = Some x \\<longrightarrow>\n            strip_guards UNIV x = strip_guards UNIV t1 \\<and>\n            strip_guards UNIV x = strip_guards UNIV t2);\n        (Cond cnd1 t1 e1 \\<inter>\\<^sub>g Cond cnd2 t2 e2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (Cond cnd1 t1 e1) \\<and>\n                         strip_guards UNIV c =\n                         strip_guards UNIV (Cond cnd2 t2 e2)\n 7. \\<And>cnd1 c1 cnd2 c2 c.\n       \\<lbrakk>cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV c1 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV c2);\n        (While cnd1 c1 \\<inter>\\<^sub>g While cnd2 c2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (While cnd1 c1) \\<and>\n                         strip_guards UNIV c =\n                         strip_guards UNIV (While cnd2 c2)\n 8. \\<And>p1 p2 c.\n       (Call p1 \\<inter>\\<^sub>g Call p2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV (Call p1) \\<and>\n       strip_guards UNIV c = strip_guards UNIV (Call p2)\n 9. \\<And>m1 g1 c1 m2 g2 c2 c.\n       \\<lbrakk>m1 = m2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV c1 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV c2);\n        (Guard m1 g1 c1 \\<inter>\\<^sub>g Guard m2 g2 c2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (Guard m1 g1 c1) \\<and>\n                         strip_guards UNIV c =\n                         strip_guards UNIV (Guard m2 g2 c2)\n 10. \\<And>c.\n        (Throw \\<inter>\\<^sub>g Throw) = Some c \\<Longrightarrow>\n        strip_guards UNIV c = strip_guards UNIV Throw \\<and>\n        strip_guards UNIV c = strip_guards UNIV Throw\nA total of 121 subgoals...", "apply simp"], ["proof (prove)\ngoal (121 subgoals):\n 1. \\<And>P1 P2.\n       \\<lbrakk>\\<forall>:000 x.\n                   (P1 :000 \\<inter>\\<^sub>g P2 :000) =\n                   Some x \\<longrightarrow>\n                   strip_guards UNIV x = strip_guards UNIV (P1 :000) \\<and>\n                   strip_guards UNIV x = strip_guards UNIV (P2 :000);\n        \\<And>c.\n           (P1 ?ua \\<inter>\\<^sub>g P2 ?ua) = Some c \\<Longrightarrow>\n           strip_guards UNIV c = strip_guards UNIV (P1 ?ua) \\<and>\n           strip_guards UNIV c = strip_guards UNIV (P2 ?ua);\n        \\<forall>s.\n           \\<exists>y. (P1 s \\<inter>\\<^sub>g P2 s) = Some y\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. strip_guards UNIV (P1 s)) =\n                         (\\<lambda>s. strip_guards UNIV (P2 s))\n 2. \\<And>c.\n       (Skip \\<inter>\\<^sub>g Skip) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV Skip \\<and>\n       strip_guards UNIV c = strip_guards UNIV Skip\n 3. \\<And>f1 f2 c.\n       (Basic f1 \\<inter>\\<^sub>g Basic f2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV (Basic f1) \\<and>\n       strip_guards UNIV c = strip_guards UNIV (Basic f2)\n 4. \\<And>r1 r2 c.\n       (Spec r1 \\<inter>\\<^sub>g Spec r2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV (Spec r1) \\<and>\n       strip_guards UNIV c = strip_guards UNIV (Spec r2)\n 5. \\<And>a1 a2 b1 b2 c.\n       \\<lbrakk>(\\<exists>c1.\n                    (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                (\\<forall>x.\n                    (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV a2 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV b2);\n        \\<And>c.\n           (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n           strip_guards UNIV c = strip_guards UNIV a1 \\<and>\n           strip_guards UNIV c = strip_guards UNIV b1;\n        (Seq a1 a2 \\<inter>\\<^sub>g Seq b1 b2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (Seq a1 a2) \\<and>\n                         strip_guards UNIV c = strip_guards UNIV (Seq b1 b2)\n 6. \\<And>cnd1 t1 e1 cnd2 t2 e2 c.\n       \\<lbrakk>(\\<exists>t. (t1 \\<inter>\\<^sub>g t2) = Some t) \\<and>\n                cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (e1 \\<inter>\\<^sub>g e2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV e1 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV e2);\n        cnd1 = cnd2 \\<longrightarrow>\n        (\\<forall>x.\n            (t1 \\<inter>\\<^sub>g t2) = Some x \\<longrightarrow>\n            strip_guards UNIV x = strip_guards UNIV t1 \\<and>\n            strip_guards UNIV x = strip_guards UNIV t2);\n        (Cond cnd1 t1 e1 \\<inter>\\<^sub>g Cond cnd2 t2 e2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (Cond cnd1 t1 e1) \\<and>\n                         strip_guards UNIV c =\n                         strip_guards UNIV (Cond cnd2 t2 e2)\n 7. \\<And>cnd1 c1 cnd2 c2 c.\n       \\<lbrakk>cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV c1 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV c2);\n        (While cnd1 c1 \\<inter>\\<^sub>g While cnd2 c2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (While cnd1 c1) \\<and>\n                         strip_guards UNIV c =\n                         strip_guards UNIV (While cnd2 c2)\n 8. \\<And>p1 p2 c.\n       (Call p1 \\<inter>\\<^sub>g Call p2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV (Call p1) \\<and>\n       strip_guards UNIV c = strip_guards UNIV (Call p2)\n 9. \\<And>m1 g1 c1 m2 g2 c2 c.\n       \\<lbrakk>m1 = m2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV c1 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV c2);\n        (Guard m1 g1 c1 \\<inter>\\<^sub>g Guard m2 g2 c2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (Guard m1 g1 c1) \\<and>\n                         strip_guards UNIV c =\n                         strip_guards UNIV (Guard m2 g2 c2)\n 10. \\<And>c.\n        (Throw \\<inter>\\<^sub>g Throw) = Some c \\<Longrightarrow>\n        strip_guards UNIV c = strip_guards UNIV Throw \\<and>\n        strip_guards UNIV c = strip_guards UNIV Throw\nA total of 121 subgoals...", "apply (rule ext)"], ["proof (prove)\ngoal (121 subgoals):\n 1. \\<And>P1 P2 s.\n       \\<lbrakk>\\<forall>:000 x.\n                   (P1 :000 \\<inter>\\<^sub>g P2 :000) =\n                   Some x \\<longrightarrow>\n                   strip_guards UNIV x = strip_guards UNIV (P1 :000) \\<and>\n                   strip_guards UNIV x = strip_guards UNIV (P2 :000);\n        \\<And>c.\n           (P1 ?ua \\<inter>\\<^sub>g P2 ?ua) = Some c \\<Longrightarrow>\n           strip_guards UNIV c = strip_guards UNIV (P1 ?ua) \\<and>\n           strip_guards UNIV c = strip_guards UNIV (P2 ?ua);\n        \\<forall>s.\n           \\<exists>y. (P1 s \\<inter>\\<^sub>g P2 s) = Some y\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV (P1 s) = strip_guards UNIV (P2 s)\n 2. \\<And>c.\n       (Skip \\<inter>\\<^sub>g Skip) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV Skip \\<and>\n       strip_guards UNIV c = strip_guards UNIV Skip\n 3. \\<And>f1 f2 c.\n       (Basic f1 \\<inter>\\<^sub>g Basic f2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV (Basic f1) \\<and>\n       strip_guards UNIV c = strip_guards UNIV (Basic f2)\n 4. \\<And>r1 r2 c.\n       (Spec r1 \\<inter>\\<^sub>g Spec r2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV (Spec r1) \\<and>\n       strip_guards UNIV c = strip_guards UNIV (Spec r2)\n 5. \\<And>a1 a2 b1 b2 c.\n       \\<lbrakk>(\\<exists>c1.\n                    (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                (\\<forall>x.\n                    (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV a2 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV b2);\n        \\<And>c.\n           (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n           strip_guards UNIV c = strip_guards UNIV a1 \\<and>\n           strip_guards UNIV c = strip_guards UNIV b1;\n        (Seq a1 a2 \\<inter>\\<^sub>g Seq b1 b2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (Seq a1 a2) \\<and>\n                         strip_guards UNIV c = strip_guards UNIV (Seq b1 b2)\n 6. \\<And>cnd1 t1 e1 cnd2 t2 e2 c.\n       \\<lbrakk>(\\<exists>t. (t1 \\<inter>\\<^sub>g t2) = Some t) \\<and>\n                cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (e1 \\<inter>\\<^sub>g e2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV e1 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV e2);\n        cnd1 = cnd2 \\<longrightarrow>\n        (\\<forall>x.\n            (t1 \\<inter>\\<^sub>g t2) = Some x \\<longrightarrow>\n            strip_guards UNIV x = strip_guards UNIV t1 \\<and>\n            strip_guards UNIV x = strip_guards UNIV t2);\n        (Cond cnd1 t1 e1 \\<inter>\\<^sub>g Cond cnd2 t2 e2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (Cond cnd1 t1 e1) \\<and>\n                         strip_guards UNIV c =\n                         strip_guards UNIV (Cond cnd2 t2 e2)\n 7. \\<And>cnd1 c1 cnd2 c2 c.\n       \\<lbrakk>cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV c1 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV c2);\n        (While cnd1 c1 \\<inter>\\<^sub>g While cnd2 c2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (While cnd1 c1) \\<and>\n                         strip_guards UNIV c =\n                         strip_guards UNIV (While cnd2 c2)\n 8. \\<And>p1 p2 c.\n       (Call p1 \\<inter>\\<^sub>g Call p2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV (Call p1) \\<and>\n       strip_guards UNIV c = strip_guards UNIV (Call p2)\n 9. \\<And>m1 g1 c1 m2 g2 c2 c.\n       \\<lbrakk>m1 = m2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV c1 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV c2);\n        (Guard m1 g1 c1 \\<inter>\\<^sub>g Guard m2 g2 c2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (Guard m1 g1 c1) \\<and>\n                         strip_guards UNIV c =\n                         strip_guards UNIV (Guard m2 g2 c2)\n 10. \\<And>c.\n        (Throw \\<inter>\\<^sub>g Throw) = Some c \\<Longrightarrow>\n        strip_guards UNIV c = strip_guards UNIV Throw \\<and>\n        strip_guards UNIV c = strip_guards UNIV Throw\nA total of 121 subgoals...", "apply (erule_tac x=s in allE, erule exE)"], ["proof (prove)\ngoal (121 subgoals):\n 1. \\<And>P1 P2 s y.\n       \\<lbrakk>\\<forall>:000 x.\n                   (P1 :000 \\<inter>\\<^sub>g P2 :000) =\n                   Some x \\<longrightarrow>\n                   strip_guards UNIV x = strip_guards UNIV (P1 :000) \\<and>\n                   strip_guards UNIV x = strip_guards UNIV (P2 :000);\n        \\<And>c.\n           (P1 ?ua \\<inter>\\<^sub>g P2 ?ua) = Some c \\<Longrightarrow>\n           strip_guards UNIV c = strip_guards UNIV (P1 ?ua) \\<and>\n           strip_guards UNIV c = strip_guards UNIV (P2 ?ua);\n        (P1 s \\<inter>\\<^sub>g P2 s) = Some y\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV (P1 s) = strip_guards UNIV (P2 s)\n 2. \\<And>c.\n       (Skip \\<inter>\\<^sub>g Skip) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV Skip \\<and>\n       strip_guards UNIV c = strip_guards UNIV Skip\n 3. \\<And>f1 f2 c.\n       (Basic f1 \\<inter>\\<^sub>g Basic f2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV (Basic f1) \\<and>\n       strip_guards UNIV c = strip_guards UNIV (Basic f2)\n 4. \\<And>r1 r2 c.\n       (Spec r1 \\<inter>\\<^sub>g Spec r2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV (Spec r1) \\<and>\n       strip_guards UNIV c = strip_guards UNIV (Spec r2)\n 5. \\<And>a1 a2 b1 b2 c.\n       \\<lbrakk>(\\<exists>c1.\n                    (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                (\\<forall>x.\n                    (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV a2 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV b2);\n        \\<And>c.\n           (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n           strip_guards UNIV c = strip_guards UNIV a1 \\<and>\n           strip_guards UNIV c = strip_guards UNIV b1;\n        (Seq a1 a2 \\<inter>\\<^sub>g Seq b1 b2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (Seq a1 a2) \\<and>\n                         strip_guards UNIV c = strip_guards UNIV (Seq b1 b2)\n 6. \\<And>cnd1 t1 e1 cnd2 t2 e2 c.\n       \\<lbrakk>(\\<exists>t. (t1 \\<inter>\\<^sub>g t2) = Some t) \\<and>\n                cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (e1 \\<inter>\\<^sub>g e2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV e1 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV e2);\n        cnd1 = cnd2 \\<longrightarrow>\n        (\\<forall>x.\n            (t1 \\<inter>\\<^sub>g t2) = Some x \\<longrightarrow>\n            strip_guards UNIV x = strip_guards UNIV t1 \\<and>\n            strip_guards UNIV x = strip_guards UNIV t2);\n        (Cond cnd1 t1 e1 \\<inter>\\<^sub>g Cond cnd2 t2 e2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (Cond cnd1 t1 e1) \\<and>\n                         strip_guards UNIV c =\n                         strip_guards UNIV (Cond cnd2 t2 e2)\n 7. \\<And>cnd1 c1 cnd2 c2 c.\n       \\<lbrakk>cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV c1 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV c2);\n        (While cnd1 c1 \\<inter>\\<^sub>g While cnd2 c2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (While cnd1 c1) \\<and>\n                         strip_guards UNIV c =\n                         strip_guards UNIV (While cnd2 c2)\n 8. \\<And>p1 p2 c.\n       (Call p1 \\<inter>\\<^sub>g Call p2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV (Call p1) \\<and>\n       strip_guards UNIV c = strip_guards UNIV (Call p2)\n 9. \\<And>m1 g1 c1 m2 g2 c2 c.\n       \\<lbrakk>m1 = m2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV c1 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV c2);\n        (Guard m1 g1 c1 \\<inter>\\<^sub>g Guard m2 g2 c2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (Guard m1 g1 c1) \\<and>\n                         strip_guards UNIV c =\n                         strip_guards UNIV (Guard m2 g2 c2)\n 10. \\<And>c.\n        (Throw \\<inter>\\<^sub>g Throw) = Some c \\<Longrightarrow>\n        strip_guards UNIV c = strip_guards UNIV Throw \\<and>\n        strip_guards UNIV c = strip_guards UNIV Throw\nA total of 121 subgoals...", "apply (erule_tac x=s in allE)"], ["proof (prove)\ngoal (121 subgoals):\n 1. \\<And>P1 P2 s y.\n       \\<lbrakk>\\<And>c.\n                   (P1 ?ua \\<inter>\\<^sub>g P2 ?ua) =\n                   Some c \\<Longrightarrow>\n                   strip_guards UNIV c = strip_guards UNIV (P1 ?ua) \\<and>\n                   strip_guards UNIV c = strip_guards UNIV (P2 ?ua);\n        (P1 s \\<inter>\\<^sub>g P2 s) = Some y;\n        \\<forall>x.\n           (P1 s \\<inter>\\<^sub>g P2 s) = Some x \\<longrightarrow>\n           strip_guards UNIV x = strip_guards UNIV (P1 s) \\<and>\n           strip_guards UNIV x = strip_guards UNIV (P2 s)\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV (P1 s) = strip_guards UNIV (P2 s)\n 2. \\<And>c.\n       (Skip \\<inter>\\<^sub>g Skip) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV Skip \\<and>\n       strip_guards UNIV c = strip_guards UNIV Skip\n 3. \\<And>f1 f2 c.\n       (Basic f1 \\<inter>\\<^sub>g Basic f2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV (Basic f1) \\<and>\n       strip_guards UNIV c = strip_guards UNIV (Basic f2)\n 4. \\<And>r1 r2 c.\n       (Spec r1 \\<inter>\\<^sub>g Spec r2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV (Spec r1) \\<and>\n       strip_guards UNIV c = strip_guards UNIV (Spec r2)\n 5. \\<And>a1 a2 b1 b2 c.\n       \\<lbrakk>(\\<exists>c1.\n                    (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                (\\<forall>x.\n                    (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV a2 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV b2);\n        \\<And>c.\n           (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n           strip_guards UNIV c = strip_guards UNIV a1 \\<and>\n           strip_guards UNIV c = strip_guards UNIV b1;\n        (Seq a1 a2 \\<inter>\\<^sub>g Seq b1 b2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (Seq a1 a2) \\<and>\n                         strip_guards UNIV c = strip_guards UNIV (Seq b1 b2)\n 6. \\<And>cnd1 t1 e1 cnd2 t2 e2 c.\n       \\<lbrakk>(\\<exists>t. (t1 \\<inter>\\<^sub>g t2) = Some t) \\<and>\n                cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (e1 \\<inter>\\<^sub>g e2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV e1 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV e2);\n        cnd1 = cnd2 \\<longrightarrow>\n        (\\<forall>x.\n            (t1 \\<inter>\\<^sub>g t2) = Some x \\<longrightarrow>\n            strip_guards UNIV x = strip_guards UNIV t1 \\<and>\n            strip_guards UNIV x = strip_guards UNIV t2);\n        (Cond cnd1 t1 e1 \\<inter>\\<^sub>g Cond cnd2 t2 e2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (Cond cnd1 t1 e1) \\<and>\n                         strip_guards UNIV c =\n                         strip_guards UNIV (Cond cnd2 t2 e2)\n 7. \\<And>cnd1 c1 cnd2 c2 c.\n       \\<lbrakk>cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV c1 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV c2);\n        (While cnd1 c1 \\<inter>\\<^sub>g While cnd2 c2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (While cnd1 c1) \\<and>\n                         strip_guards UNIV c =\n                         strip_guards UNIV (While cnd2 c2)\n 8. \\<And>p1 p2 c.\n       (Call p1 \\<inter>\\<^sub>g Call p2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV (Call p1) \\<and>\n       strip_guards UNIV c = strip_guards UNIV (Call p2)\n 9. \\<And>m1 g1 c1 m2 g2 c2 c.\n       \\<lbrakk>m1 = m2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV c1 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV c2);\n        (Guard m1 g1 c1 \\<inter>\\<^sub>g Guard m2 g2 c2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (Guard m1 g1 c1) \\<and>\n                         strip_guards UNIV c =\n                         strip_guards UNIV (Guard m2 g2 c2)\n 10. \\<And>c.\n        (Throw \\<inter>\\<^sub>g Throw) = Some c \\<Longrightarrow>\n        strip_guards UNIV c = strip_guards UNIV Throw \\<and>\n        strip_guards UNIV c = strip_guards UNIV Throw\nA total of 121 subgoals...", "apply fastforce"], ["proof (prove)\ngoal (120 subgoals):\n 1. \\<And>c.\n       (Skip \\<inter>\\<^sub>g Skip) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV Skip \\<and>\n       strip_guards UNIV c = strip_guards UNIV Skip\n 2. \\<And>f1 f2 c.\n       (Basic f1 \\<inter>\\<^sub>g Basic f2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV (Basic f1) \\<and>\n       strip_guards UNIV c = strip_guards UNIV (Basic f2)\n 3. \\<And>r1 r2 c.\n       (Spec r1 \\<inter>\\<^sub>g Spec r2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV (Spec r1) \\<and>\n       strip_guards UNIV c = strip_guards UNIV (Spec r2)\n 4. \\<And>a1 a2 b1 b2 c.\n       \\<lbrakk>(\\<exists>c1.\n                    (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                (\\<forall>x.\n                    (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV a2 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV b2);\n        \\<And>c.\n           (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n           strip_guards UNIV c = strip_guards UNIV a1 \\<and>\n           strip_guards UNIV c = strip_guards UNIV b1;\n        (Seq a1 a2 \\<inter>\\<^sub>g Seq b1 b2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (Seq a1 a2) \\<and>\n                         strip_guards UNIV c = strip_guards UNIV (Seq b1 b2)\n 5. \\<And>cnd1 t1 e1 cnd2 t2 e2 c.\n       \\<lbrakk>(\\<exists>t. (t1 \\<inter>\\<^sub>g t2) = Some t) \\<and>\n                cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (e1 \\<inter>\\<^sub>g e2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV e1 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV e2);\n        cnd1 = cnd2 \\<longrightarrow>\n        (\\<forall>x.\n            (t1 \\<inter>\\<^sub>g t2) = Some x \\<longrightarrow>\n            strip_guards UNIV x = strip_guards UNIV t1 \\<and>\n            strip_guards UNIV x = strip_guards UNIV t2);\n        (Cond cnd1 t1 e1 \\<inter>\\<^sub>g Cond cnd2 t2 e2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (Cond cnd1 t1 e1) \\<and>\n                         strip_guards UNIV c =\n                         strip_guards UNIV (Cond cnd2 t2 e2)\n 6. \\<And>cnd1 c1 cnd2 c2 c.\n       \\<lbrakk>cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV c1 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV c2);\n        (While cnd1 c1 \\<inter>\\<^sub>g While cnd2 c2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (While cnd1 c1) \\<and>\n                         strip_guards UNIV c =\n                         strip_guards UNIV (While cnd2 c2)\n 7. \\<And>p1 p2 c.\n       (Call p1 \\<inter>\\<^sub>g Call p2) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV (Call p1) \\<and>\n       strip_guards UNIV c = strip_guards UNIV (Call p2)\n 8. \\<And>m1 g1 c1 m2 g2 c2 c.\n       \\<lbrakk>m1 = m2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    strip_guards UNIV x = strip_guards UNIV c1 \\<and>\n                    strip_guards UNIV x = strip_guards UNIV c2);\n        (Guard m1 g1 c1 \\<inter>\\<^sub>g Guard m2 g2 c2) = Some c\\<rbrakk>\n       \\<Longrightarrow> strip_guards UNIV c =\n                         strip_guards UNIV (Guard m1 g1 c1) \\<and>\n                         strip_guards UNIV c =\n                         strip_guards UNIV (Guard m2 g2 c2)\n 9. \\<And>c.\n       (Throw \\<inter>\\<^sub>g Throw) = Some c \\<Longrightarrow>\n       strip_guards UNIV c = strip_guards UNIV Throw \\<and>\n       strip_guards UNIV c = strip_guards UNIV Throw\n 10. \\<And>a1 a2 b1 b2 c.\n        \\<lbrakk>(\\<exists>c1.\n                     (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                 (\\<forall>x.\n                     (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                     strip_guards UNIV x = strip_guards UNIV a2 \\<and>\n                     strip_guards UNIV x = strip_guards UNIV b2);\n         \\<And>c.\n            (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n            strip_guards UNIV c = strip_guards UNIV a1 \\<and>\n            strip_guards UNIV c = strip_guards UNIV b1;\n         (Catch a1 a2 \\<inter>\\<^sub>g Catch b1 b2) = Some c\\<rbrakk>\n        \\<Longrightarrow> strip_guards UNIV c =\n                          strip_guards UNIV (Catch a1 a2) \\<and>\n                          strip_guards UNIV c =\n                          strip_guards UNIV (Catch b1 b2)\nA total of 120 subgoals...", "apply (fastforce split: option.splits if_split_asm)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inter_guards_sym: \"\\<And>c. (c1 \\<inter>\\<^sub>g c2) = Some c \\<Longrightarrow> (c2 \\<inter>\\<^sub>g c1) = Some c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       (c1 \\<inter>\\<^sub>g c2) = Some c \\<Longrightarrow>\n       (c2 \\<inter>\\<^sub>g c1) = Some c", "apply (induct c1 c2 rule: inter_guards.induct)"], ["proof (prove)\ngoal (121 subgoals):\n 1. \\<And>c.\n       (Skip \\<inter>\\<^sub>g Skip) = Some c \\<Longrightarrow>\n       (Skip \\<inter>\\<^sub>g Skip) = Some c\n 2. \\<And>f1 f2 c.\n       (Basic f1 \\<inter>\\<^sub>g Basic f2) = Some c \\<Longrightarrow>\n       (Basic f2 \\<inter>\\<^sub>g Basic f1) = Some c\n 3. \\<And>r1 r2 c.\n       (Spec r1 \\<inter>\\<^sub>g Spec r2) = Some c \\<Longrightarrow>\n       (Spec r2 \\<inter>\\<^sub>g Spec r1) = Some c\n 4. \\<And>a1 a2 b1 b2 c.\n       \\<lbrakk>(\\<exists>c1.\n                    (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                (\\<forall>x.\n                    (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                    (b2 \\<inter>\\<^sub>g a2) = Some x);\n        \\<And>c.\n           (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n           (b1 \\<inter>\\<^sub>g a1) = Some c;\n        (Seq a1 a2 \\<inter>\\<^sub>g Seq b1 b2) = Some c\\<rbrakk>\n       \\<Longrightarrow> (Seq b1 b2 \\<inter>\\<^sub>g Seq a1 a2) = Some c\n 5. \\<And>cnd1 t1 e1 cnd2 t2 e2 c.\n       \\<lbrakk>(\\<exists>t. (t1 \\<inter>\\<^sub>g t2) = Some t) \\<and>\n                cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (e1 \\<inter>\\<^sub>g e2) = Some x \\<longrightarrow>\n                    (e2 \\<inter>\\<^sub>g e1) = Some x);\n        cnd1 = cnd2 \\<longrightarrow>\n        (\\<forall>x.\n            (t1 \\<inter>\\<^sub>g t2) = Some x \\<longrightarrow>\n            (t2 \\<inter>\\<^sub>g t1) = Some x);\n        (Cond cnd1 t1 e1 \\<inter>\\<^sub>g Cond cnd2 t2 e2) = Some c\\<rbrakk>\n       \\<Longrightarrow> (Cond cnd2 t2\n                           e2 \\<inter>\\<^sub>g Cond cnd1 t1 e1) =\n                         Some c\n 6. \\<And>cnd1 c1 cnd2 c2 c.\n       \\<lbrakk>cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    (c2 \\<inter>\\<^sub>g c1) = Some x);\n        (While cnd1 c1 \\<inter>\\<^sub>g While cnd2 c2) = Some c\\<rbrakk>\n       \\<Longrightarrow> (While cnd2 c2 \\<inter>\\<^sub>g While cnd1 c1) =\n                         Some c\n 7. \\<And>p1 p2 c.\n       (Call p1 \\<inter>\\<^sub>g Call p2) = Some c \\<Longrightarrow>\n       (Call p2 \\<inter>\\<^sub>g Call p1) = Some c\n 8. \\<And>P1 P2 c.\n       \\<lbrakk>(\\<forall>s.\n                    \\<exists>y.\n                       (P1 s \\<inter>\\<^sub>g P2 s) =\n                       Some y) \\<longrightarrow>\n                (\\<forall>:000 x.\n                    (P1 :000 \\<inter>\\<^sub>g P2 :000) =\n                    Some x \\<longrightarrow>\n                    (P2 :000 \\<inter>\\<^sub>g P1 :000) = Some x);\n        \\<And>c.\n           (P1 ?ua \\<inter>\\<^sub>g P2 ?ua) = Some c \\<Longrightarrow>\n           (P2 ?ua \\<inter>\\<^sub>g P1 ?ua) = Some c;\n        (DynCom P1 \\<inter>\\<^sub>g DynCom P2) = Some c\\<rbrakk>\n       \\<Longrightarrow> (DynCom P2 \\<inter>\\<^sub>g DynCom P1) = Some c\n 9. \\<And>m1 g1 c1 m2 g2 c2 c.\n       \\<lbrakk>m1 = m2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    (c2 \\<inter>\\<^sub>g c1) = Some x);\n        (Guard m1 g1 c1 \\<inter>\\<^sub>g Guard m2 g2 c2) = Some c\\<rbrakk>\n       \\<Longrightarrow> (Guard m2 g2 c2 \\<inter>\\<^sub>g Guard m1 g1 c1) =\n                         Some c\n 10. \\<And>c.\n        (Throw \\<inter>\\<^sub>g Throw) = Some c \\<Longrightarrow>\n        (Throw \\<inter>\\<^sub>g Throw) = Some c\nA total of 121 subgoals...", "apply (simp_all)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>f1 f2 c.\n       (if f1 = f2 then Some (Basic f2) else None) =\n       Some c \\<Longrightarrow>\n       (f2 = f1 \\<longrightarrow> Basic f1 = c) \\<and> f2 = f1\n 2. \\<And>r1 r2 c.\n       (if r1 = r2 then Some (Spec r2) else None) = Some c \\<Longrightarrow>\n       (r2 = r1 \\<longrightarrow> Spec r1 = c) \\<and> r2 = r1\n 3. \\<And>a1 a2 b1 b2 c.\n       \\<lbrakk>(\\<exists>c1.\n                    (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                (\\<forall>x.\n                    (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                    (b2 \\<inter>\\<^sub>g a2) = Some x);\n        \\<And>c.\n           (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n           (b1 \\<inter>\\<^sub>g a1) = Some c;\n        (case a1 \\<inter>\\<^sub>g b1 of None \\<Rightarrow> None\n         | Some c1 \\<Rightarrow>\n             case a2 \\<inter>\\<^sub>g b2 of None \\<Rightarrow> None\n             | Some c2 \\<Rightarrow> Some (Seq c1 c2)) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (case b1 \\<inter>\\<^sub>g a1 of\n                          None \\<Rightarrow> None\n                          | Some c1 \\<Rightarrow>\n                              case b2 \\<inter>\\<^sub>g a2 of\n                              None \\<Rightarrow> None\n                              | Some c2 \\<Rightarrow> Some (Seq c1 c2)) =\n                         Some c\n 4. \\<And>cnd1 t1 e1 cnd2 t2 e2 c.\n       \\<lbrakk>(\\<exists>t. (t1 \\<inter>\\<^sub>g t2) = Some t) \\<and>\n                cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (e1 \\<inter>\\<^sub>g e2) = Some x \\<longrightarrow>\n                    (e2 \\<inter>\\<^sub>g e1) = Some x);\n        cnd1 = cnd2 \\<longrightarrow>\n        (\\<forall>x.\n            (t1 \\<inter>\\<^sub>g t2) = Some x \\<longrightarrow>\n            (t2 \\<inter>\\<^sub>g t1) = Some x);\n        (if cnd1 = cnd2\n         then case t1 \\<inter>\\<^sub>g t2 of None \\<Rightarrow> None\n              | Some t \\<Rightarrow>\n                  case e1 \\<inter>\\<^sub>g e2 of None \\<Rightarrow> None\n                  | Some e \\<Rightarrow> Some (Cond cnd2 t e)\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (cnd2 = cnd1 \\<longrightarrow>\n                          (case t2 \\<inter>\\<^sub>g t1 of\n                           None \\<Rightarrow> None\n                           | Some t \\<Rightarrow>\n                               case e2 \\<inter>\\<^sub>g e1 of\n                               None \\<Rightarrow> None\n                               | Some e \\<Rightarrow>\n                                   Some (Cond cnd1 t e)) =\n                          Some c) \\<and>\n                         cnd2 = cnd1\n 5. \\<And>cnd1 c1 cnd2 c2 c.\n       \\<lbrakk>cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    (c2 \\<inter>\\<^sub>g c1) = Some x);\n        (if cnd1 = cnd2\n         then case c1 \\<inter>\\<^sub>g c2 of None \\<Rightarrow> None\n              | Some c \\<Rightarrow> Some (While cnd2 c)\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (cnd2 = cnd1 \\<longrightarrow>\n                          (case c2 \\<inter>\\<^sub>g c1 of\n                           None \\<Rightarrow> None\n                           | Some c \\<Rightarrow> Some (While cnd1 c)) =\n                          Some c) \\<and>\n                         cnd2 = cnd1\n 6. \\<And>p1 p2 c.\n       (if p1 = p2 then Some (Call p2) else None) = Some c \\<Longrightarrow>\n       (p2 = p1 \\<longrightarrow> Call p1 = c) \\<and> p2 = p1\n 7. \\<And>P1 P2 c.\n       \\<lbrakk>(\\<forall>s.\n                    \\<exists>y.\n                       (P1 s \\<inter>\\<^sub>g P2 s) =\n                       Some y) \\<longrightarrow>\n                (\\<forall>:000 x.\n                    (P1 :000 \\<inter>\\<^sub>g P2 :000) =\n                    Some x \\<longrightarrow>\n                    (P2 :000 \\<inter>\\<^sub>g P1 :000) = Some x);\n        \\<And>c.\n           (P1 ?ua \\<inter>\\<^sub>g P2 ?ua) = Some c \\<Longrightarrow>\n           (P2 ?ua \\<inter>\\<^sub>g P1 ?ua) = Some c;\n        (if \\<forall>s. \\<exists>y. (P1 s \\<inter>\\<^sub>g P2 s) = Some y\n         then Some (DynCom (\\<lambda>s. the (P1 s \\<inter>\\<^sub>g P2 s)))\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>s.\n                              \\<exists>y.\n                                 (P2 s \\<inter>\\<^sub>g P1 s) =\n                                 Some y) \\<longrightarrow>\n                          DynCom\n                           (\\<lambda>s. the (P2 s \\<inter>\\<^sub>g P1 s)) =\n                          c) \\<and>\n                         (\\<forall>s.\n                             \\<exists>y.\n                                (P2 s \\<inter>\\<^sub>g P1 s) = Some y)\n 8. \\<And>m1 g1 c1 m2 g2 c2 c.\n       \\<lbrakk>m1 = m2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    (c2 \\<inter>\\<^sub>g c1) = Some x);\n        (if m1 = m2\n         then case c1 \\<inter>\\<^sub>g c2 of None \\<Rightarrow> None\n              | Some c \\<Rightarrow> Some (Guard m2 (g1 \\<inter> g2) c)\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (m2 = m1 \\<longrightarrow>\n                          (case c2 \\<inter>\\<^sub>g c1 of\n                           None \\<Rightarrow> None\n                           | Some c \\<Rightarrow>\n                               Some (Guard m1 (g2 \\<inter> g1) c)) =\n                          Some c) \\<and>\n                         m2 = m1\n 9. \\<And>a1 a2 b1 b2 c.\n       \\<lbrakk>(\\<exists>c1.\n                    (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                (\\<forall>x.\n                    (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                    (b2 \\<inter>\\<^sub>g a2) = Some x);\n        \\<And>c.\n           (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n           (b1 \\<inter>\\<^sub>g a1) = Some c;\n        (case a1 \\<inter>\\<^sub>g b1 of None \\<Rightarrow> None\n         | Some c1 \\<Rightarrow>\n             case a2 \\<inter>\\<^sub>g b2 of None \\<Rightarrow> None\n             | Some c2 \\<Rightarrow> Some (Catch c1 c2)) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (case b1 \\<inter>\\<^sub>g a1 of\n                          None \\<Rightarrow> None\n                          | Some c1 \\<Rightarrow>\n                              case b2 \\<inter>\\<^sub>g a2 of\n                              None \\<Rightarrow> None\n                              | Some c2 \\<Rightarrow> Some (Catch c1 c2)) =\n                         Some c", "prefer 7"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>P1 P2 c.\n       \\<lbrakk>(\\<forall>s.\n                    \\<exists>y.\n                       (P1 s \\<inter>\\<^sub>g P2 s) =\n                       Some y) \\<longrightarrow>\n                (\\<forall>:000 x.\n                    (P1 :000 \\<inter>\\<^sub>g P2 :000) =\n                    Some x \\<longrightarrow>\n                    (P2 :000 \\<inter>\\<^sub>g P1 :000) = Some x);\n        \\<And>c.\n           (P1 ?ua \\<inter>\\<^sub>g P2 ?ua) = Some c \\<Longrightarrow>\n           (P2 ?ua \\<inter>\\<^sub>g P1 ?ua) = Some c;\n        (if \\<forall>s. \\<exists>y. (P1 s \\<inter>\\<^sub>g P2 s) = Some y\n         then Some (DynCom (\\<lambda>s. the (P1 s \\<inter>\\<^sub>g P2 s)))\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>s.\n                              \\<exists>y.\n                                 (P2 s \\<inter>\\<^sub>g P1 s) =\n                                 Some y) \\<longrightarrow>\n                          DynCom\n                           (\\<lambda>s. the (P2 s \\<inter>\\<^sub>g P1 s)) =\n                          c) \\<and>\n                         (\\<forall>s.\n                             \\<exists>y.\n                                (P2 s \\<inter>\\<^sub>g P1 s) = Some y)\n 2. \\<And>f1 f2 c.\n       (if f1 = f2 then Some (Basic f2) else None) =\n       Some c \\<Longrightarrow>\n       (f2 = f1 \\<longrightarrow> Basic f1 = c) \\<and> f2 = f1\n 3. \\<And>r1 r2 c.\n       (if r1 = r2 then Some (Spec r2) else None) = Some c \\<Longrightarrow>\n       (r2 = r1 \\<longrightarrow> Spec r1 = c) \\<and> r2 = r1\n 4. \\<And>a1 a2 b1 b2 c.\n       \\<lbrakk>(\\<exists>c1.\n                    (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                (\\<forall>x.\n                    (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                    (b2 \\<inter>\\<^sub>g a2) = Some x);\n        \\<And>c.\n           (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n           (b1 \\<inter>\\<^sub>g a1) = Some c;\n        (case a1 \\<inter>\\<^sub>g b1 of None \\<Rightarrow> None\n         | Some c1 \\<Rightarrow>\n             case a2 \\<inter>\\<^sub>g b2 of None \\<Rightarrow> None\n             | Some c2 \\<Rightarrow> Some (Seq c1 c2)) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (case b1 \\<inter>\\<^sub>g a1 of\n                          None \\<Rightarrow> None\n                          | Some c1 \\<Rightarrow>\n                              case b2 \\<inter>\\<^sub>g a2 of\n                              None \\<Rightarrow> None\n                              | Some c2 \\<Rightarrow> Some (Seq c1 c2)) =\n                         Some c\n 5. \\<And>cnd1 t1 e1 cnd2 t2 e2 c.\n       \\<lbrakk>(\\<exists>t. (t1 \\<inter>\\<^sub>g t2) = Some t) \\<and>\n                cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (e1 \\<inter>\\<^sub>g e2) = Some x \\<longrightarrow>\n                    (e2 \\<inter>\\<^sub>g e1) = Some x);\n        cnd1 = cnd2 \\<longrightarrow>\n        (\\<forall>x.\n            (t1 \\<inter>\\<^sub>g t2) = Some x \\<longrightarrow>\n            (t2 \\<inter>\\<^sub>g t1) = Some x);\n        (if cnd1 = cnd2\n         then case t1 \\<inter>\\<^sub>g t2 of None \\<Rightarrow> None\n              | Some t \\<Rightarrow>\n                  case e1 \\<inter>\\<^sub>g e2 of None \\<Rightarrow> None\n                  | Some e \\<Rightarrow> Some (Cond cnd2 t e)\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (cnd2 = cnd1 \\<longrightarrow>\n                          (case t2 \\<inter>\\<^sub>g t1 of\n                           None \\<Rightarrow> None\n                           | Some t \\<Rightarrow>\n                               case e2 \\<inter>\\<^sub>g e1 of\n                               None \\<Rightarrow> None\n                               | Some e \\<Rightarrow>\n                                   Some (Cond cnd1 t e)) =\n                          Some c) \\<and>\n                         cnd2 = cnd1\n 6. \\<And>cnd1 c1 cnd2 c2 c.\n       \\<lbrakk>cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    (c2 \\<inter>\\<^sub>g c1) = Some x);\n        (if cnd1 = cnd2\n         then case c1 \\<inter>\\<^sub>g c2 of None \\<Rightarrow> None\n              | Some c \\<Rightarrow> Some (While cnd2 c)\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (cnd2 = cnd1 \\<longrightarrow>\n                          (case c2 \\<inter>\\<^sub>g c1 of\n                           None \\<Rightarrow> None\n                           | Some c \\<Rightarrow> Some (While cnd1 c)) =\n                          Some c) \\<and>\n                         cnd2 = cnd1\n 7. \\<And>p1 p2 c.\n       (if p1 = p2 then Some (Call p2) else None) = Some c \\<Longrightarrow>\n       (p2 = p1 \\<longrightarrow> Call p1 = c) \\<and> p2 = p1\n 8. \\<And>m1 g1 c1 m2 g2 c2 c.\n       \\<lbrakk>m1 = m2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    (c2 \\<inter>\\<^sub>g c1) = Some x);\n        (if m1 = m2\n         then case c1 \\<inter>\\<^sub>g c2 of None \\<Rightarrow> None\n              | Some c \\<Rightarrow> Some (Guard m2 (g1 \\<inter> g2) c)\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (m2 = m1 \\<longrightarrow>\n                          (case c2 \\<inter>\\<^sub>g c1 of\n                           None \\<Rightarrow> None\n                           | Some c \\<Rightarrow>\n                               Some (Guard m1 (g2 \\<inter> g1) c)) =\n                          Some c) \\<and>\n                         m2 = m1\n 9. \\<And>a1 a2 b1 b2 c.\n       \\<lbrakk>(\\<exists>c1.\n                    (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                (\\<forall>x.\n                    (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                    (b2 \\<inter>\\<^sub>g a2) = Some x);\n        \\<And>c.\n           (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n           (b1 \\<inter>\\<^sub>g a1) = Some c;\n        (case a1 \\<inter>\\<^sub>g b1 of None \\<Rightarrow> None\n         | Some c1 \\<Rightarrow>\n             case a2 \\<inter>\\<^sub>g b2 of None \\<Rightarrow> None\n             | Some c2 \\<Rightarrow> Some (Catch c1 c2)) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (case b1 \\<inter>\\<^sub>g a1 of\n                          None \\<Rightarrow> None\n                          | Some c1 \\<Rightarrow>\n                              case b2 \\<inter>\\<^sub>g a2 of\n                              None \\<Rightarrow> None\n                              | Some c2 \\<Rightarrow> Some (Catch c1 c2)) =\n                         Some c", "apply (simp split: if_split_asm add: not_None_eq)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>P1 P2 c.\n       \\<lbrakk>\\<forall>:000 x.\n                   (P1 :000 \\<inter>\\<^sub>g P2 :000) =\n                   Some x \\<longrightarrow>\n                   (P2 :000 \\<inter>\\<^sub>g P1 :000) = Some x;\n        \\<And>c.\n           (P1 ?ua \\<inter>\\<^sub>g P2 ?ua) = Some c \\<Longrightarrow>\n           (P2 ?ua \\<inter>\\<^sub>g P1 ?ua) = Some c;\n        \\<forall>s. \\<exists>y. (P1 s \\<inter>\\<^sub>g P2 s) = Some y;\n        DynCom (\\<lambda>s. the (P1 s \\<inter>\\<^sub>g P2 s)) = c\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>s.\n                              \\<exists>y.\n                                 (P2 s \\<inter>\\<^sub>g P1 s) =\n                                 Some y) \\<longrightarrow>\n                          DynCom\n                           (\\<lambda>s. the (P2 s \\<inter>\\<^sub>g P1 s)) =\n                          c) \\<and>\n                         (\\<forall>s.\n                             \\<exists>y.\n                                (P2 s \\<inter>\\<^sub>g P1 s) = Some y)\n 2. \\<And>f1 f2 c.\n       (if f1 = f2 then Some (Basic f2) else None) =\n       Some c \\<Longrightarrow>\n       (f2 = f1 \\<longrightarrow> Basic f1 = c) \\<and> f2 = f1\n 3. \\<And>r1 r2 c.\n       (if r1 = r2 then Some (Spec r2) else None) = Some c \\<Longrightarrow>\n       (r2 = r1 \\<longrightarrow> Spec r1 = c) \\<and> r2 = r1\n 4. \\<And>a1 a2 b1 b2 c.\n       \\<lbrakk>(\\<exists>c1.\n                    (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                (\\<forall>x.\n                    (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                    (b2 \\<inter>\\<^sub>g a2) = Some x);\n        \\<And>c.\n           (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n           (b1 \\<inter>\\<^sub>g a1) = Some c;\n        (case a1 \\<inter>\\<^sub>g b1 of None \\<Rightarrow> None\n         | Some c1 \\<Rightarrow>\n             case a2 \\<inter>\\<^sub>g b2 of None \\<Rightarrow> None\n             | Some c2 \\<Rightarrow> Some (Seq c1 c2)) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (case b1 \\<inter>\\<^sub>g a1 of\n                          None \\<Rightarrow> None\n                          | Some c1 \\<Rightarrow>\n                              case b2 \\<inter>\\<^sub>g a2 of\n                              None \\<Rightarrow> None\n                              | Some c2 \\<Rightarrow> Some (Seq c1 c2)) =\n                         Some c\n 5. \\<And>cnd1 t1 e1 cnd2 t2 e2 c.\n       \\<lbrakk>(\\<exists>t. (t1 \\<inter>\\<^sub>g t2) = Some t) \\<and>\n                cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (e1 \\<inter>\\<^sub>g e2) = Some x \\<longrightarrow>\n                    (e2 \\<inter>\\<^sub>g e1) = Some x);\n        cnd1 = cnd2 \\<longrightarrow>\n        (\\<forall>x.\n            (t1 \\<inter>\\<^sub>g t2) = Some x \\<longrightarrow>\n            (t2 \\<inter>\\<^sub>g t1) = Some x);\n        (if cnd1 = cnd2\n         then case t1 \\<inter>\\<^sub>g t2 of None \\<Rightarrow> None\n              | Some t \\<Rightarrow>\n                  case e1 \\<inter>\\<^sub>g e2 of None \\<Rightarrow> None\n                  | Some e \\<Rightarrow> Some (Cond cnd2 t e)\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (cnd2 = cnd1 \\<longrightarrow>\n                          (case t2 \\<inter>\\<^sub>g t1 of\n                           None \\<Rightarrow> None\n                           | Some t \\<Rightarrow>\n                               case e2 \\<inter>\\<^sub>g e1 of\n                               None \\<Rightarrow> None\n                               | Some e \\<Rightarrow>\n                                   Some (Cond cnd1 t e)) =\n                          Some c) \\<and>\n                         cnd2 = cnd1\n 6. \\<And>cnd1 c1 cnd2 c2 c.\n       \\<lbrakk>cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    (c2 \\<inter>\\<^sub>g c1) = Some x);\n        (if cnd1 = cnd2\n         then case c1 \\<inter>\\<^sub>g c2 of None \\<Rightarrow> None\n              | Some c \\<Rightarrow> Some (While cnd2 c)\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (cnd2 = cnd1 \\<longrightarrow>\n                          (case c2 \\<inter>\\<^sub>g c1 of\n                           None \\<Rightarrow> None\n                           | Some c \\<Rightarrow> Some (While cnd1 c)) =\n                          Some c) \\<and>\n                         cnd2 = cnd1\n 7. \\<And>p1 p2 c.\n       (if p1 = p2 then Some (Call p2) else None) = Some c \\<Longrightarrow>\n       (p2 = p1 \\<longrightarrow> Call p1 = c) \\<and> p2 = p1\n 8. \\<And>m1 g1 c1 m2 g2 c2 c.\n       \\<lbrakk>m1 = m2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    (c2 \\<inter>\\<^sub>g c1) = Some x);\n        (if m1 = m2\n         then case c1 \\<inter>\\<^sub>g c2 of None \\<Rightarrow> None\n              | Some c \\<Rightarrow> Some (Guard m2 (g1 \\<inter> g2) c)\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (m2 = m1 \\<longrightarrow>\n                          (case c2 \\<inter>\\<^sub>g c1 of\n                           None \\<Rightarrow> None\n                           | Some c \\<Rightarrow>\n                               Some (Guard m1 (g2 \\<inter> g1) c)) =\n                          Some c) \\<and>\n                         m2 = m1\n 9. \\<And>a1 a2 b1 b2 c.\n       \\<lbrakk>(\\<exists>c1.\n                    (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                (\\<forall>x.\n                    (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                    (b2 \\<inter>\\<^sub>g a2) = Some x);\n        \\<And>c.\n           (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n           (b1 \\<inter>\\<^sub>g a1) = Some c;\n        (case a1 \\<inter>\\<^sub>g b1 of None \\<Rightarrow> None\n         | Some c1 \\<Rightarrow>\n             case a2 \\<inter>\\<^sub>g b2 of None \\<Rightarrow> None\n             | Some c2 \\<Rightarrow> Some (Catch c1 c2)) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (case b1 \\<inter>\\<^sub>g a1 of\n                          None \\<Rightarrow> None\n                          | Some c1 \\<Rightarrow>\n                              case b2 \\<inter>\\<^sub>g a2 of\n                              None \\<Rightarrow> None\n                              | Some c2 \\<Rightarrow> Some (Catch c1 c2)) =\n                         Some c", "apply (rule conjI)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>P1 P2 c.\n       \\<lbrakk>\\<forall>:000 x.\n                   (P1 :000 \\<inter>\\<^sub>g P2 :000) =\n                   Some x \\<longrightarrow>\n                   (P2 :000 \\<inter>\\<^sub>g P1 :000) = Some x;\n        \\<And>c.\n           (P1 ?ua \\<inter>\\<^sub>g P2 ?ua) = Some c \\<Longrightarrow>\n           (P2 ?ua \\<inter>\\<^sub>g P1 ?ua) = Some c;\n        \\<forall>s. \\<exists>y. (P1 s \\<inter>\\<^sub>g P2 s) = Some y;\n        DynCom (\\<lambda>s. the (P1 s \\<inter>\\<^sub>g P2 s)) = c\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>s.\n                             \\<exists>y.\n                                (P2 s \\<inter>\\<^sub>g P1 s) =\n                                Some y) \\<longrightarrow>\n                         DynCom\n                          (\\<lambda>s. the (P2 s \\<inter>\\<^sub>g P1 s)) =\n                         c\n 2. \\<And>P1 P2 c.\n       \\<lbrakk>\\<forall>:000 x.\n                   (P1 :000 \\<inter>\\<^sub>g P2 :000) =\n                   Some x \\<longrightarrow>\n                   (P2 :000 \\<inter>\\<^sub>g P1 :000) = Some x;\n        \\<And>c.\n           (P1 ?ua \\<inter>\\<^sub>g P2 ?ua) = Some c \\<Longrightarrow>\n           (P2 ?ua \\<inter>\\<^sub>g P1 ?ua) = Some c;\n        \\<forall>s. \\<exists>y. (P1 s \\<inter>\\<^sub>g P2 s) = Some y;\n        DynCom (\\<lambda>s. the (P1 s \\<inter>\\<^sub>g P2 s)) = c\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s.\n                            \\<exists>y.\n                               (P2 s \\<inter>\\<^sub>g P1 s) = Some y\n 3. \\<And>f1 f2 c.\n       (if f1 = f2 then Some (Basic f2) else None) =\n       Some c \\<Longrightarrow>\n       (f2 = f1 \\<longrightarrow> Basic f1 = c) \\<and> f2 = f1\n 4. \\<And>r1 r2 c.\n       (if r1 = r2 then Some (Spec r2) else None) = Some c \\<Longrightarrow>\n       (r2 = r1 \\<longrightarrow> Spec r1 = c) \\<and> r2 = r1\n 5. \\<And>a1 a2 b1 b2 c.\n       \\<lbrakk>(\\<exists>c1.\n                    (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                (\\<forall>x.\n                    (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                    (b2 \\<inter>\\<^sub>g a2) = Some x);\n        \\<And>c.\n           (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n           (b1 \\<inter>\\<^sub>g a1) = Some c;\n        (case a1 \\<inter>\\<^sub>g b1 of None \\<Rightarrow> None\n         | Some c1 \\<Rightarrow>\n             case a2 \\<inter>\\<^sub>g b2 of None \\<Rightarrow> None\n             | Some c2 \\<Rightarrow> Some (Seq c1 c2)) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (case b1 \\<inter>\\<^sub>g a1 of\n                          None \\<Rightarrow> None\n                          | Some c1 \\<Rightarrow>\n                              case b2 \\<inter>\\<^sub>g a2 of\n                              None \\<Rightarrow> None\n                              | Some c2 \\<Rightarrow> Some (Seq c1 c2)) =\n                         Some c\n 6. \\<And>cnd1 t1 e1 cnd2 t2 e2 c.\n       \\<lbrakk>(\\<exists>t. (t1 \\<inter>\\<^sub>g t2) = Some t) \\<and>\n                cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (e1 \\<inter>\\<^sub>g e2) = Some x \\<longrightarrow>\n                    (e2 \\<inter>\\<^sub>g e1) = Some x);\n        cnd1 = cnd2 \\<longrightarrow>\n        (\\<forall>x.\n            (t1 \\<inter>\\<^sub>g t2) = Some x \\<longrightarrow>\n            (t2 \\<inter>\\<^sub>g t1) = Some x);\n        (if cnd1 = cnd2\n         then case t1 \\<inter>\\<^sub>g t2 of None \\<Rightarrow> None\n              | Some t \\<Rightarrow>\n                  case e1 \\<inter>\\<^sub>g e2 of None \\<Rightarrow> None\n                  | Some e \\<Rightarrow> Some (Cond cnd2 t e)\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (cnd2 = cnd1 \\<longrightarrow>\n                          (case t2 \\<inter>\\<^sub>g t1 of\n                           None \\<Rightarrow> None\n                           | Some t \\<Rightarrow>\n                               case e2 \\<inter>\\<^sub>g e1 of\n                               None \\<Rightarrow> None\n                               | Some e \\<Rightarrow>\n                                   Some (Cond cnd1 t e)) =\n                          Some c) \\<and>\n                         cnd2 = cnd1\n 7. \\<And>cnd1 c1 cnd2 c2 c.\n       \\<lbrakk>cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    (c2 \\<inter>\\<^sub>g c1) = Some x);\n        (if cnd1 = cnd2\n         then case c1 \\<inter>\\<^sub>g c2 of None \\<Rightarrow> None\n              | Some c \\<Rightarrow> Some (While cnd2 c)\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (cnd2 = cnd1 \\<longrightarrow>\n                          (case c2 \\<inter>\\<^sub>g c1 of\n                           None \\<Rightarrow> None\n                           | Some c \\<Rightarrow> Some (While cnd1 c)) =\n                          Some c) \\<and>\n                         cnd2 = cnd1\n 8. \\<And>p1 p2 c.\n       (if p1 = p2 then Some (Call p2) else None) = Some c \\<Longrightarrow>\n       (p2 = p1 \\<longrightarrow> Call p1 = c) \\<and> p2 = p1\n 9. \\<And>m1 g1 c1 m2 g2 c2 c.\n       \\<lbrakk>m1 = m2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    (c2 \\<inter>\\<^sub>g c1) = Some x);\n        (if m1 = m2\n         then case c1 \\<inter>\\<^sub>g c2 of None \\<Rightarrow> None\n              | Some c \\<Rightarrow> Some (Guard m2 (g1 \\<inter> g2) c)\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (m2 = m1 \\<longrightarrow>\n                          (case c2 \\<inter>\\<^sub>g c1 of\n                           None \\<Rightarrow> None\n                           | Some c \\<Rightarrow>\n                               Some (Guard m1 (g2 \\<inter> g1) c)) =\n                          Some c) \\<and>\n                         m2 = m1\n 10. \\<And>a1 a2 b1 b2 c.\n        \\<lbrakk>(\\<exists>c1.\n                     (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                 (\\<forall>x.\n                     (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                     (b2 \\<inter>\\<^sub>g a2) = Some x);\n         \\<And>c.\n            (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n            (b1 \\<inter>\\<^sub>g a1) = Some c;\n         (case a1 \\<inter>\\<^sub>g b1 of None \\<Rightarrow> None\n          | Some c1 \\<Rightarrow>\n              case a2 \\<inter>\\<^sub>g b2 of None \\<Rightarrow> None\n              | Some c2 \\<Rightarrow> Some (Catch c1 c2)) =\n         Some c\\<rbrakk>\n        \\<Longrightarrow> (case b1 \\<inter>\\<^sub>g a1 of\n                           None \\<Rightarrow> None\n                           | Some c1 \\<Rightarrow>\n                               case b2 \\<inter>\\<^sub>g a2 of\n                               None \\<Rightarrow> None\n                               | Some c2 \\<Rightarrow> Some (Catch c1 c2)) =\n                          Some c", "apply  (clarsimp)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>P1 P2.\n       \\<lbrakk>\\<forall>:000 x.\n                   (P1 :000 \\<inter>\\<^sub>g P2 :000) =\n                   Some x \\<longrightarrow>\n                   (P2 :000 \\<inter>\\<^sub>g P1 :000) = Some x;\n        \\<And>c.\n           (P1 ?ua \\<inter>\\<^sub>g P2 ?ua) = Some c \\<Longrightarrow>\n           (P2 ?ua \\<inter>\\<^sub>g P1 ?ua) = Some c;\n        \\<forall>s. \\<exists>y. (P1 s \\<inter>\\<^sub>g P2 s) = Some y;\n        \\<forall>s.\n           \\<exists>y. (P2 s \\<inter>\\<^sub>g P1 s) = Some y\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. the (P2 s \\<inter>\\<^sub>g P1 s)) =\n                         (\\<lambda>s. the (P1 s \\<inter>\\<^sub>g P2 s))\n 2. \\<And>P1 P2 c.\n       \\<lbrakk>\\<forall>:000 x.\n                   (P1 :000 \\<inter>\\<^sub>g P2 :000) =\n                   Some x \\<longrightarrow>\n                   (P2 :000 \\<inter>\\<^sub>g P1 :000) = Some x;\n        \\<And>c.\n           (P1 ?ua \\<inter>\\<^sub>g P2 ?ua) = Some c \\<Longrightarrow>\n           (P2 ?ua \\<inter>\\<^sub>g P1 ?ua) = Some c;\n        \\<forall>s. \\<exists>y. (P1 s \\<inter>\\<^sub>g P2 s) = Some y;\n        DynCom (\\<lambda>s. the (P1 s \\<inter>\\<^sub>g P2 s)) = c\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s.\n                            \\<exists>y.\n                               (P2 s \\<inter>\\<^sub>g P1 s) = Some y\n 3. \\<And>f1 f2 c.\n       (if f1 = f2 then Some (Basic f2) else None) =\n       Some c \\<Longrightarrow>\n       (f2 = f1 \\<longrightarrow> Basic f1 = c) \\<and> f2 = f1\n 4. \\<And>r1 r2 c.\n       (if r1 = r2 then Some (Spec r2) else None) = Some c \\<Longrightarrow>\n       (r2 = r1 \\<longrightarrow> Spec r1 = c) \\<and> r2 = r1\n 5. \\<And>a1 a2 b1 b2 c.\n       \\<lbrakk>(\\<exists>c1.\n                    (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                (\\<forall>x.\n                    (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                    (b2 \\<inter>\\<^sub>g a2) = Some x);\n        \\<And>c.\n           (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n           (b1 \\<inter>\\<^sub>g a1) = Some c;\n        (case a1 \\<inter>\\<^sub>g b1 of None \\<Rightarrow> None\n         | Some c1 \\<Rightarrow>\n             case a2 \\<inter>\\<^sub>g b2 of None \\<Rightarrow> None\n             | Some c2 \\<Rightarrow> Some (Seq c1 c2)) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (case b1 \\<inter>\\<^sub>g a1 of\n                          None \\<Rightarrow> None\n                          | Some c1 \\<Rightarrow>\n                              case b2 \\<inter>\\<^sub>g a2 of\n                              None \\<Rightarrow> None\n                              | Some c2 \\<Rightarrow> Some (Seq c1 c2)) =\n                         Some c\n 6. \\<And>cnd1 t1 e1 cnd2 t2 e2 c.\n       \\<lbrakk>(\\<exists>t. (t1 \\<inter>\\<^sub>g t2) = Some t) \\<and>\n                cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (e1 \\<inter>\\<^sub>g e2) = Some x \\<longrightarrow>\n                    (e2 \\<inter>\\<^sub>g e1) = Some x);\n        cnd1 = cnd2 \\<longrightarrow>\n        (\\<forall>x.\n            (t1 \\<inter>\\<^sub>g t2) = Some x \\<longrightarrow>\n            (t2 \\<inter>\\<^sub>g t1) = Some x);\n        (if cnd1 = cnd2\n         then case t1 \\<inter>\\<^sub>g t2 of None \\<Rightarrow> None\n              | Some t \\<Rightarrow>\n                  case e1 \\<inter>\\<^sub>g e2 of None \\<Rightarrow> None\n                  | Some e \\<Rightarrow> Some (Cond cnd2 t e)\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (cnd2 = cnd1 \\<longrightarrow>\n                          (case t2 \\<inter>\\<^sub>g t1 of\n                           None \\<Rightarrow> None\n                           | Some t \\<Rightarrow>\n                               case e2 \\<inter>\\<^sub>g e1 of\n                               None \\<Rightarrow> None\n                               | Some e \\<Rightarrow>\n                                   Some (Cond cnd1 t e)) =\n                          Some c) \\<and>\n                         cnd2 = cnd1\n 7. \\<And>cnd1 c1 cnd2 c2 c.\n       \\<lbrakk>cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    (c2 \\<inter>\\<^sub>g c1) = Some x);\n        (if cnd1 = cnd2\n         then case c1 \\<inter>\\<^sub>g c2 of None \\<Rightarrow> None\n              | Some c \\<Rightarrow> Some (While cnd2 c)\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (cnd2 = cnd1 \\<longrightarrow>\n                          (case c2 \\<inter>\\<^sub>g c1 of\n                           None \\<Rightarrow> None\n                           | Some c \\<Rightarrow> Some (While cnd1 c)) =\n                          Some c) \\<and>\n                         cnd2 = cnd1\n 8. \\<And>p1 p2 c.\n       (if p1 = p2 then Some (Call p2) else None) = Some c \\<Longrightarrow>\n       (p2 = p1 \\<longrightarrow> Call p1 = c) \\<and> p2 = p1\n 9. \\<And>m1 g1 c1 m2 g2 c2 c.\n       \\<lbrakk>m1 = m2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    (c2 \\<inter>\\<^sub>g c1) = Some x);\n        (if m1 = m2\n         then case c1 \\<inter>\\<^sub>g c2 of None \\<Rightarrow> None\n              | Some c \\<Rightarrow> Some (Guard m2 (g1 \\<inter> g2) c)\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (m2 = m1 \\<longrightarrow>\n                          (case c2 \\<inter>\\<^sub>g c1 of\n                           None \\<Rightarrow> None\n                           | Some c \\<Rightarrow>\n                               Some (Guard m1 (g2 \\<inter> g1) c)) =\n                          Some c) \\<and>\n                         m2 = m1\n 10. \\<And>a1 a2 b1 b2 c.\n        \\<lbrakk>(\\<exists>c1.\n                     (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                 (\\<forall>x.\n                     (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                     (b2 \\<inter>\\<^sub>g a2) = Some x);\n         \\<And>c.\n            (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n            (b1 \\<inter>\\<^sub>g a1) = Some c;\n         (case a1 \\<inter>\\<^sub>g b1 of None \\<Rightarrow> None\n          | Some c1 \\<Rightarrow>\n              case a2 \\<inter>\\<^sub>g b2 of None \\<Rightarrow> None\n              | Some c2 \\<Rightarrow> Some (Catch c1 c2)) =\n         Some c\\<rbrakk>\n        \\<Longrightarrow> (case b1 \\<inter>\\<^sub>g a1 of\n                           None \\<Rightarrow> None\n                           | Some c1 \\<Rightarrow>\n                               case b2 \\<inter>\\<^sub>g a2 of\n                               None \\<Rightarrow> None\n                               | Some c2 \\<Rightarrow> Some (Catch c1 c2)) =\n                          Some c", "apply  (rule ext)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>P1 P2 s.\n       \\<lbrakk>\\<forall>:000 x.\n                   (P1 :000 \\<inter>\\<^sub>g P2 :000) =\n                   Some x \\<longrightarrow>\n                   (P2 :000 \\<inter>\\<^sub>g P1 :000) = Some x;\n        \\<And>c.\n           (P1 ?ua \\<inter>\\<^sub>g P2 ?ua) = Some c \\<Longrightarrow>\n           (P2 ?ua \\<inter>\\<^sub>g P1 ?ua) = Some c;\n        \\<forall>s. \\<exists>y. (P1 s \\<inter>\\<^sub>g P2 s) = Some y;\n        \\<forall>s.\n           \\<exists>y. (P2 s \\<inter>\\<^sub>g P1 s) = Some y\\<rbrakk>\n       \\<Longrightarrow> the (P2 s \\<inter>\\<^sub>g P1 s) =\n                         the (P1 s \\<inter>\\<^sub>g P2 s)\n 2. \\<And>P1 P2 c.\n       \\<lbrakk>\\<forall>:000 x.\n                   (P1 :000 \\<inter>\\<^sub>g P2 :000) =\n                   Some x \\<longrightarrow>\n                   (P2 :000 \\<inter>\\<^sub>g P1 :000) = Some x;\n        \\<And>c.\n           (P1 ?ua \\<inter>\\<^sub>g P2 ?ua) = Some c \\<Longrightarrow>\n           (P2 ?ua \\<inter>\\<^sub>g P1 ?ua) = Some c;\n        \\<forall>s. \\<exists>y. (P1 s \\<inter>\\<^sub>g P2 s) = Some y;\n        DynCom (\\<lambda>s. the (P1 s \\<inter>\\<^sub>g P2 s)) = c\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s.\n                            \\<exists>y.\n                               (P2 s \\<inter>\\<^sub>g P1 s) = Some y\n 3. \\<And>f1 f2 c.\n       (if f1 = f2 then Some (Basic f2) else None) =\n       Some c \\<Longrightarrow>\n       (f2 = f1 \\<longrightarrow> Basic f1 = c) \\<and> f2 = f1\n 4. \\<And>r1 r2 c.\n       (if r1 = r2 then Some (Spec r2) else None) = Some c \\<Longrightarrow>\n       (r2 = r1 \\<longrightarrow> Spec r1 = c) \\<and> r2 = r1\n 5. \\<And>a1 a2 b1 b2 c.\n       \\<lbrakk>(\\<exists>c1.\n                    (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                (\\<forall>x.\n                    (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                    (b2 \\<inter>\\<^sub>g a2) = Some x);\n        \\<And>c.\n           (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n           (b1 \\<inter>\\<^sub>g a1) = Some c;\n        (case a1 \\<inter>\\<^sub>g b1 of None \\<Rightarrow> None\n         | Some c1 \\<Rightarrow>\n             case a2 \\<inter>\\<^sub>g b2 of None \\<Rightarrow> None\n             | Some c2 \\<Rightarrow> Some (Seq c1 c2)) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (case b1 \\<inter>\\<^sub>g a1 of\n                          None \\<Rightarrow> None\n                          | Some c1 \\<Rightarrow>\n                              case b2 \\<inter>\\<^sub>g a2 of\n                              None \\<Rightarrow> None\n                              | Some c2 \\<Rightarrow> Some (Seq c1 c2)) =\n                         Some c\n 6. \\<And>cnd1 t1 e1 cnd2 t2 e2 c.\n       \\<lbrakk>(\\<exists>t. (t1 \\<inter>\\<^sub>g t2) = Some t) \\<and>\n                cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (e1 \\<inter>\\<^sub>g e2) = Some x \\<longrightarrow>\n                    (e2 \\<inter>\\<^sub>g e1) = Some x);\n        cnd1 = cnd2 \\<longrightarrow>\n        (\\<forall>x.\n            (t1 \\<inter>\\<^sub>g t2) = Some x \\<longrightarrow>\n            (t2 \\<inter>\\<^sub>g t1) = Some x);\n        (if cnd1 = cnd2\n         then case t1 \\<inter>\\<^sub>g t2 of None \\<Rightarrow> None\n              | Some t \\<Rightarrow>\n                  case e1 \\<inter>\\<^sub>g e2 of None \\<Rightarrow> None\n                  | Some e \\<Rightarrow> Some (Cond cnd2 t e)\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (cnd2 = cnd1 \\<longrightarrow>\n                          (case t2 \\<inter>\\<^sub>g t1 of\n                           None \\<Rightarrow> None\n                           | Some t \\<Rightarrow>\n                               case e2 \\<inter>\\<^sub>g e1 of\n                               None \\<Rightarrow> None\n                               | Some e \\<Rightarrow>\n                                   Some (Cond cnd1 t e)) =\n                          Some c) \\<and>\n                         cnd2 = cnd1\n 7. \\<And>cnd1 c1 cnd2 c2 c.\n       \\<lbrakk>cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    (c2 \\<inter>\\<^sub>g c1) = Some x);\n        (if cnd1 = cnd2\n         then case c1 \\<inter>\\<^sub>g c2 of None \\<Rightarrow> None\n              | Some c \\<Rightarrow> Some (While cnd2 c)\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (cnd2 = cnd1 \\<longrightarrow>\n                          (case c2 \\<inter>\\<^sub>g c1 of\n                           None \\<Rightarrow> None\n                           | Some c \\<Rightarrow> Some (While cnd1 c)) =\n                          Some c) \\<and>\n                         cnd2 = cnd1\n 8. \\<And>p1 p2 c.\n       (if p1 = p2 then Some (Call p2) else None) = Some c \\<Longrightarrow>\n       (p2 = p1 \\<longrightarrow> Call p1 = c) \\<and> p2 = p1\n 9. \\<And>m1 g1 c1 m2 g2 c2 c.\n       \\<lbrakk>m1 = m2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    (c2 \\<inter>\\<^sub>g c1) = Some x);\n        (if m1 = m2\n         then case c1 \\<inter>\\<^sub>g c2 of None \\<Rightarrow> None\n              | Some c \\<Rightarrow> Some (Guard m2 (g1 \\<inter> g2) c)\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (m2 = m1 \\<longrightarrow>\n                          (case c2 \\<inter>\\<^sub>g c1 of\n                           None \\<Rightarrow> None\n                           | Some c \\<Rightarrow>\n                               Some (Guard m1 (g2 \\<inter> g1) c)) =\n                          Some c) \\<and>\n                         m2 = m1\n 10. \\<And>a1 a2 b1 b2 c.\n        \\<lbrakk>(\\<exists>c1.\n                     (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                 (\\<forall>x.\n                     (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                     (b2 \\<inter>\\<^sub>g a2) = Some x);\n         \\<And>c.\n            (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n            (b1 \\<inter>\\<^sub>g a1) = Some c;\n         (case a1 \\<inter>\\<^sub>g b1 of None \\<Rightarrow> None\n          | Some c1 \\<Rightarrow>\n              case a2 \\<inter>\\<^sub>g b2 of None \\<Rightarrow> None\n              | Some c2 \\<Rightarrow> Some (Catch c1 c2)) =\n         Some c\\<rbrakk>\n        \\<Longrightarrow> (case b1 \\<inter>\\<^sub>g a1 of\n                           None \\<Rightarrow> None\n                           | Some c1 \\<Rightarrow>\n                               case b2 \\<inter>\\<^sub>g a2 of\n                               None \\<Rightarrow> None\n                               | Some c2 \\<Rightarrow> Some (Catch c1 c2)) =\n                          Some c", "apply  (erule_tac x=s in allE)+"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>P1 P2 s.\n       \\<lbrakk>\\<And>c.\n                   (P1 ?ua \\<inter>\\<^sub>g P2 ?ua) =\n                   Some c \\<Longrightarrow>\n                   (P2 ?ua \\<inter>\\<^sub>g P1 ?ua) = Some c;\n        \\<forall>x.\n           (P1 s \\<inter>\\<^sub>g P2 s) = Some x \\<longrightarrow>\n           (P2 s \\<inter>\\<^sub>g P1 s) = Some x;\n        \\<exists>y. (P1 s \\<inter>\\<^sub>g P2 s) = Some y;\n        \\<exists>y. (P2 s \\<inter>\\<^sub>g P1 s) = Some y\\<rbrakk>\n       \\<Longrightarrow> the (P2 s \\<inter>\\<^sub>g P1 s) =\n                         the (P1 s \\<inter>\\<^sub>g P2 s)\n 2. \\<And>P1 P2 c.\n       \\<lbrakk>\\<forall>:000 x.\n                   (P1 :000 \\<inter>\\<^sub>g P2 :000) =\n                   Some x \\<longrightarrow>\n                   (P2 :000 \\<inter>\\<^sub>g P1 :000) = Some x;\n        \\<And>c.\n           (P1 ?ua \\<inter>\\<^sub>g P2 ?ua) = Some c \\<Longrightarrow>\n           (P2 ?ua \\<inter>\\<^sub>g P1 ?ua) = Some c;\n        \\<forall>s. \\<exists>y. (P1 s \\<inter>\\<^sub>g P2 s) = Some y;\n        DynCom (\\<lambda>s. the (P1 s \\<inter>\\<^sub>g P2 s)) = c\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s.\n                            \\<exists>y.\n                               (P2 s \\<inter>\\<^sub>g P1 s) = Some y\n 3. \\<And>f1 f2 c.\n       (if f1 = f2 then Some (Basic f2) else None) =\n       Some c \\<Longrightarrow>\n       (f2 = f1 \\<longrightarrow> Basic f1 = c) \\<and> f2 = f1\n 4. \\<And>r1 r2 c.\n       (if r1 = r2 then Some (Spec r2) else None) = Some c \\<Longrightarrow>\n       (r2 = r1 \\<longrightarrow> Spec r1 = c) \\<and> r2 = r1\n 5. \\<And>a1 a2 b1 b2 c.\n       \\<lbrakk>(\\<exists>c1.\n                    (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                (\\<forall>x.\n                    (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                    (b2 \\<inter>\\<^sub>g a2) = Some x);\n        \\<And>c.\n           (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n           (b1 \\<inter>\\<^sub>g a1) = Some c;\n        (case a1 \\<inter>\\<^sub>g b1 of None \\<Rightarrow> None\n         | Some c1 \\<Rightarrow>\n             case a2 \\<inter>\\<^sub>g b2 of None \\<Rightarrow> None\n             | Some c2 \\<Rightarrow> Some (Seq c1 c2)) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (case b1 \\<inter>\\<^sub>g a1 of\n                          None \\<Rightarrow> None\n                          | Some c1 \\<Rightarrow>\n                              case b2 \\<inter>\\<^sub>g a2 of\n                              None \\<Rightarrow> None\n                              | Some c2 \\<Rightarrow> Some (Seq c1 c2)) =\n                         Some c\n 6. \\<And>cnd1 t1 e1 cnd2 t2 e2 c.\n       \\<lbrakk>(\\<exists>t. (t1 \\<inter>\\<^sub>g t2) = Some t) \\<and>\n                cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (e1 \\<inter>\\<^sub>g e2) = Some x \\<longrightarrow>\n                    (e2 \\<inter>\\<^sub>g e1) = Some x);\n        cnd1 = cnd2 \\<longrightarrow>\n        (\\<forall>x.\n            (t1 \\<inter>\\<^sub>g t2) = Some x \\<longrightarrow>\n            (t2 \\<inter>\\<^sub>g t1) = Some x);\n        (if cnd1 = cnd2\n         then case t1 \\<inter>\\<^sub>g t2 of None \\<Rightarrow> None\n              | Some t \\<Rightarrow>\n                  case e1 \\<inter>\\<^sub>g e2 of None \\<Rightarrow> None\n                  | Some e \\<Rightarrow> Some (Cond cnd2 t e)\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (cnd2 = cnd1 \\<longrightarrow>\n                          (case t2 \\<inter>\\<^sub>g t1 of\n                           None \\<Rightarrow> None\n                           | Some t \\<Rightarrow>\n                               case e2 \\<inter>\\<^sub>g e1 of\n                               None \\<Rightarrow> None\n                               | Some e \\<Rightarrow>\n                                   Some (Cond cnd1 t e)) =\n                          Some c) \\<and>\n                         cnd2 = cnd1\n 7. \\<And>cnd1 c1 cnd2 c2 c.\n       \\<lbrakk>cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    (c2 \\<inter>\\<^sub>g c1) = Some x);\n        (if cnd1 = cnd2\n         then case c1 \\<inter>\\<^sub>g c2 of None \\<Rightarrow> None\n              | Some c \\<Rightarrow> Some (While cnd2 c)\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (cnd2 = cnd1 \\<longrightarrow>\n                          (case c2 \\<inter>\\<^sub>g c1 of\n                           None \\<Rightarrow> None\n                           | Some c \\<Rightarrow> Some (While cnd1 c)) =\n                          Some c) \\<and>\n                         cnd2 = cnd1\n 8. \\<And>p1 p2 c.\n       (if p1 = p2 then Some (Call p2) else None) = Some c \\<Longrightarrow>\n       (p2 = p1 \\<longrightarrow> Call p1 = c) \\<and> p2 = p1\n 9. \\<And>m1 g1 c1 m2 g2 c2 c.\n       \\<lbrakk>m1 = m2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    (c2 \\<inter>\\<^sub>g c1) = Some x);\n        (if m1 = m2\n         then case c1 \\<inter>\\<^sub>g c2 of None \\<Rightarrow> None\n              | Some c \\<Rightarrow> Some (Guard m2 (g1 \\<inter> g2) c)\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (m2 = m1 \\<longrightarrow>\n                          (case c2 \\<inter>\\<^sub>g c1 of\n                           None \\<Rightarrow> None\n                           | Some c \\<Rightarrow>\n                               Some (Guard m1 (g2 \\<inter> g1) c)) =\n                          Some c) \\<and>\n                         m2 = m1\n 10. \\<And>a1 a2 b1 b2 c.\n        \\<lbrakk>(\\<exists>c1.\n                     (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                 (\\<forall>x.\n                     (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                     (b2 \\<inter>\\<^sub>g a2) = Some x);\n         \\<And>c.\n            (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n            (b1 \\<inter>\\<^sub>g a1) = Some c;\n         (case a1 \\<inter>\\<^sub>g b1 of None \\<Rightarrow> None\n          | Some c1 \\<Rightarrow>\n              case a2 \\<inter>\\<^sub>g b2 of None \\<Rightarrow> None\n              | Some c2 \\<Rightarrow> Some (Catch c1 c2)) =\n         Some c\\<rbrakk>\n        \\<Longrightarrow> (case b1 \\<inter>\\<^sub>g a1 of\n                           None \\<Rightarrow> None\n                           | Some c1 \\<Rightarrow>\n                               case b2 \\<inter>\\<^sub>g a2 of\n                               None \\<Rightarrow> None\n                               | Some c2 \\<Rightarrow> Some (Catch c1 c2)) =\n                          Some c", "apply  fastforce"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>P1 P2 c.\n       \\<lbrakk>\\<forall>:000 x.\n                   (P1 :000 \\<inter>\\<^sub>g P2 :000) =\n                   Some x \\<longrightarrow>\n                   (P2 :000 \\<inter>\\<^sub>g P1 :000) = Some x;\n        \\<And>c.\n           (P1 ?ua \\<inter>\\<^sub>g P2 ?ua) = Some c \\<Longrightarrow>\n           (P2 ?ua \\<inter>\\<^sub>g P1 ?ua) = Some c;\n        \\<forall>s. \\<exists>y. (P1 s \\<inter>\\<^sub>g P2 s) = Some y;\n        DynCom (\\<lambda>s. the (P1 s \\<inter>\\<^sub>g P2 s)) = c\\<rbrakk>\n       \\<Longrightarrow> \\<forall>s.\n                            \\<exists>y.\n                               (P2 s \\<inter>\\<^sub>g P1 s) = Some y\n 2. \\<And>f1 f2 c.\n       (if f1 = f2 then Some (Basic f2) else None) =\n       Some c \\<Longrightarrow>\n       (f2 = f1 \\<longrightarrow> Basic f1 = c) \\<and> f2 = f1\n 3. \\<And>r1 r2 c.\n       (if r1 = r2 then Some (Spec r2) else None) = Some c \\<Longrightarrow>\n       (r2 = r1 \\<longrightarrow> Spec r1 = c) \\<and> r2 = r1\n 4. \\<And>a1 a2 b1 b2 c.\n       \\<lbrakk>(\\<exists>c1.\n                    (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                (\\<forall>x.\n                    (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                    (b2 \\<inter>\\<^sub>g a2) = Some x);\n        \\<And>c.\n           (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n           (b1 \\<inter>\\<^sub>g a1) = Some c;\n        (case a1 \\<inter>\\<^sub>g b1 of None \\<Rightarrow> None\n         | Some c1 \\<Rightarrow>\n             case a2 \\<inter>\\<^sub>g b2 of None \\<Rightarrow> None\n             | Some c2 \\<Rightarrow> Some (Seq c1 c2)) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (case b1 \\<inter>\\<^sub>g a1 of\n                          None \\<Rightarrow> None\n                          | Some c1 \\<Rightarrow>\n                              case b2 \\<inter>\\<^sub>g a2 of\n                              None \\<Rightarrow> None\n                              | Some c2 \\<Rightarrow> Some (Seq c1 c2)) =\n                         Some c\n 5. \\<And>cnd1 t1 e1 cnd2 t2 e2 c.\n       \\<lbrakk>(\\<exists>t. (t1 \\<inter>\\<^sub>g t2) = Some t) \\<and>\n                cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (e1 \\<inter>\\<^sub>g e2) = Some x \\<longrightarrow>\n                    (e2 \\<inter>\\<^sub>g e1) = Some x);\n        cnd1 = cnd2 \\<longrightarrow>\n        (\\<forall>x.\n            (t1 \\<inter>\\<^sub>g t2) = Some x \\<longrightarrow>\n            (t2 \\<inter>\\<^sub>g t1) = Some x);\n        (if cnd1 = cnd2\n         then case t1 \\<inter>\\<^sub>g t2 of None \\<Rightarrow> None\n              | Some t \\<Rightarrow>\n                  case e1 \\<inter>\\<^sub>g e2 of None \\<Rightarrow> None\n                  | Some e \\<Rightarrow> Some (Cond cnd2 t e)\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (cnd2 = cnd1 \\<longrightarrow>\n                          (case t2 \\<inter>\\<^sub>g t1 of\n                           None \\<Rightarrow> None\n                           | Some t \\<Rightarrow>\n                               case e2 \\<inter>\\<^sub>g e1 of\n                               None \\<Rightarrow> None\n                               | Some e \\<Rightarrow>\n                                   Some (Cond cnd1 t e)) =\n                          Some c) \\<and>\n                         cnd2 = cnd1\n 6. \\<And>cnd1 c1 cnd2 c2 c.\n       \\<lbrakk>cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    (c2 \\<inter>\\<^sub>g c1) = Some x);\n        (if cnd1 = cnd2\n         then case c1 \\<inter>\\<^sub>g c2 of None \\<Rightarrow> None\n              | Some c \\<Rightarrow> Some (While cnd2 c)\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (cnd2 = cnd1 \\<longrightarrow>\n                          (case c2 \\<inter>\\<^sub>g c1 of\n                           None \\<Rightarrow> None\n                           | Some c \\<Rightarrow> Some (While cnd1 c)) =\n                          Some c) \\<and>\n                         cnd2 = cnd1\n 7. \\<And>p1 p2 c.\n       (if p1 = p2 then Some (Call p2) else None) = Some c \\<Longrightarrow>\n       (p2 = p1 \\<longrightarrow> Call p1 = c) \\<and> p2 = p1\n 8. \\<And>m1 g1 c1 m2 g2 c2 c.\n       \\<lbrakk>m1 = m2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    (c2 \\<inter>\\<^sub>g c1) = Some x);\n        (if m1 = m2\n         then case c1 \\<inter>\\<^sub>g c2 of None \\<Rightarrow> None\n              | Some c \\<Rightarrow> Some (Guard m2 (g1 \\<inter> g2) c)\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (m2 = m1 \\<longrightarrow>\n                          (case c2 \\<inter>\\<^sub>g c1 of\n                           None \\<Rightarrow> None\n                           | Some c \\<Rightarrow>\n                               Some (Guard m1 (g2 \\<inter> g1) c)) =\n                          Some c) \\<and>\n                         m2 = m1\n 9. \\<And>a1 a2 b1 b2 c.\n       \\<lbrakk>(\\<exists>c1.\n                    (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                (\\<forall>x.\n                    (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                    (b2 \\<inter>\\<^sub>g a2) = Some x);\n        \\<And>c.\n           (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n           (b1 \\<inter>\\<^sub>g a1) = Some c;\n        (case a1 \\<inter>\\<^sub>g b1 of None \\<Rightarrow> None\n         | Some c1 \\<Rightarrow>\n             case a2 \\<inter>\\<^sub>g b2 of None \\<Rightarrow> None\n             | Some c2 \\<Rightarrow> Some (Catch c1 c2)) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (case b1 \\<inter>\\<^sub>g a1 of\n                          None \\<Rightarrow> None\n                          | Some c1 \\<Rightarrow>\n                              case b2 \\<inter>\\<^sub>g a2 of\n                              None \\<Rightarrow> None\n                              | Some c2 \\<Rightarrow> Some (Catch c1 c2)) =\n                         Some c", "apply fastforce"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>f1 f2 c.\n       (if f1 = f2 then Some (Basic f2) else None) =\n       Some c \\<Longrightarrow>\n       (f2 = f1 \\<longrightarrow> Basic f1 = c) \\<and> f2 = f1\n 2. \\<And>r1 r2 c.\n       (if r1 = r2 then Some (Spec r2) else None) = Some c \\<Longrightarrow>\n       (r2 = r1 \\<longrightarrow> Spec r1 = c) \\<and> r2 = r1\n 3. \\<And>a1 a2 b1 b2 c.\n       \\<lbrakk>(\\<exists>c1.\n                    (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                (\\<forall>x.\n                    (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                    (b2 \\<inter>\\<^sub>g a2) = Some x);\n        \\<And>c.\n           (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n           (b1 \\<inter>\\<^sub>g a1) = Some c;\n        (case a1 \\<inter>\\<^sub>g b1 of None \\<Rightarrow> None\n         | Some c1 \\<Rightarrow>\n             case a2 \\<inter>\\<^sub>g b2 of None \\<Rightarrow> None\n             | Some c2 \\<Rightarrow> Some (Seq c1 c2)) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (case b1 \\<inter>\\<^sub>g a1 of\n                          None \\<Rightarrow> None\n                          | Some c1 \\<Rightarrow>\n                              case b2 \\<inter>\\<^sub>g a2 of\n                              None \\<Rightarrow> None\n                              | Some c2 \\<Rightarrow> Some (Seq c1 c2)) =\n                         Some c\n 4. \\<And>cnd1 t1 e1 cnd2 t2 e2 c.\n       \\<lbrakk>(\\<exists>t. (t1 \\<inter>\\<^sub>g t2) = Some t) \\<and>\n                cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (e1 \\<inter>\\<^sub>g e2) = Some x \\<longrightarrow>\n                    (e2 \\<inter>\\<^sub>g e1) = Some x);\n        cnd1 = cnd2 \\<longrightarrow>\n        (\\<forall>x.\n            (t1 \\<inter>\\<^sub>g t2) = Some x \\<longrightarrow>\n            (t2 \\<inter>\\<^sub>g t1) = Some x);\n        (if cnd1 = cnd2\n         then case t1 \\<inter>\\<^sub>g t2 of None \\<Rightarrow> None\n              | Some t \\<Rightarrow>\n                  case e1 \\<inter>\\<^sub>g e2 of None \\<Rightarrow> None\n                  | Some e \\<Rightarrow> Some (Cond cnd2 t e)\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (cnd2 = cnd1 \\<longrightarrow>\n                          (case t2 \\<inter>\\<^sub>g t1 of\n                           None \\<Rightarrow> None\n                           | Some t \\<Rightarrow>\n                               case e2 \\<inter>\\<^sub>g e1 of\n                               None \\<Rightarrow> None\n                               | Some e \\<Rightarrow>\n                                   Some (Cond cnd1 t e)) =\n                          Some c) \\<and>\n                         cnd2 = cnd1\n 5. \\<And>cnd1 c1 cnd2 c2 c.\n       \\<lbrakk>cnd1 = cnd2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    (c2 \\<inter>\\<^sub>g c1) = Some x);\n        (if cnd1 = cnd2\n         then case c1 \\<inter>\\<^sub>g c2 of None \\<Rightarrow> None\n              | Some c \\<Rightarrow> Some (While cnd2 c)\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (cnd2 = cnd1 \\<longrightarrow>\n                          (case c2 \\<inter>\\<^sub>g c1 of\n                           None \\<Rightarrow> None\n                           | Some c \\<Rightarrow> Some (While cnd1 c)) =\n                          Some c) \\<and>\n                         cnd2 = cnd1\n 6. \\<And>p1 p2 c.\n       (if p1 = p2 then Some (Call p2) else None) = Some c \\<Longrightarrow>\n       (p2 = p1 \\<longrightarrow> Call p1 = c) \\<and> p2 = p1\n 7. \\<And>m1 g1 c1 m2 g2 c2 c.\n       \\<lbrakk>m1 = m2 \\<longrightarrow>\n                (\\<forall>x.\n                    (c1 \\<inter>\\<^sub>g c2) = Some x \\<longrightarrow>\n                    (c2 \\<inter>\\<^sub>g c1) = Some x);\n        (if m1 = m2\n         then case c1 \\<inter>\\<^sub>g c2 of None \\<Rightarrow> None\n              | Some c \\<Rightarrow> Some (Guard m2 (g1 \\<inter> g2) c)\n         else None) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (m2 = m1 \\<longrightarrow>\n                          (case c2 \\<inter>\\<^sub>g c1 of\n                           None \\<Rightarrow> None\n                           | Some c \\<Rightarrow>\n                               Some (Guard m1 (g2 \\<inter> g1) c)) =\n                          Some c) \\<and>\n                         m2 = m1\n 8. \\<And>a1 a2 b1 b2 c.\n       \\<lbrakk>(\\<exists>c1.\n                    (a1 \\<inter>\\<^sub>g b1) = Some c1) \\<longrightarrow>\n                (\\<forall>x.\n                    (a2 \\<inter>\\<^sub>g b2) = Some x \\<longrightarrow>\n                    (b2 \\<inter>\\<^sub>g a2) = Some x);\n        \\<And>c.\n           (a1 \\<inter>\\<^sub>g b1) = Some c \\<Longrightarrow>\n           (b1 \\<inter>\\<^sub>g a1) = Some c;\n        (case a1 \\<inter>\\<^sub>g b1 of None \\<Rightarrow> None\n         | Some c1 \\<Rightarrow>\n             case a2 \\<inter>\\<^sub>g b2 of None \\<Rightarrow> None\n             | Some c2 \\<Rightarrow> Some (Catch c1 c2)) =\n        Some c\\<rbrakk>\n       \\<Longrightarrow> (case b1 \\<inter>\\<^sub>g a1 of\n                          None \\<Rightarrow> None\n                          | Some c1 \\<Rightarrow>\n                              case b2 \\<inter>\\<^sub>g a2 of\n                              None \\<Rightarrow> None\n                              | Some c2 \\<Rightarrow> Some (Catch c1 c2)) =\n                         Some c", "apply (fastforce split: option.splits if_split_asm)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inter_guards_Skip: \"(Skip \\<inter>\\<^sub>g c2) = Some c = (c2=Skip \\<and> c=Skip)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Skip \\<inter>\\<^sub>g c2) = Some c) = (c2 = Skip \\<and> c = Skip)", "by (cases c2) auto"], ["", "lemma inter_guards_Basic:\n  \"((Basic f) \\<inter>\\<^sub>g c2) = Some c = (c2=Basic f \\<and> c=Basic f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Basic f \\<inter>\\<^sub>g c2) = Some c) =\n    (c2 = Basic f \\<and> c = Basic f)", "by (cases c2) auto"], ["", "lemma inter_guards_Spec:\n  \"((Spec r) \\<inter>\\<^sub>g c2) = Some c = (c2=Spec r \\<and> c=Spec r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Spec r \\<inter>\\<^sub>g c2) = Some c) =\n    (c2 = Spec r \\<and> c = Spec r)", "by (cases c2) auto"], ["", "lemma inter_guards_Seq:\n  \"(Seq a1 a2 \\<inter>\\<^sub>g c2) = Some c =\n     (\\<exists>b1 b2 d1 d2. c2=Seq b1 b2 \\<and> (a1 \\<inter>\\<^sub>g b1) = Some d1 \\<and>\n        (a2 \\<inter>\\<^sub>g b2) = Some d2 \\<and> c=Seq d1 d2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Seq a1 a2 \\<inter>\\<^sub>g c2) = Some c) =\n    (\\<exists>b1 b2 d1 d2.\n        c2 = Seq b1 b2 \\<and>\n        (a1 \\<inter>\\<^sub>g b1) = Some d1 \\<and>\n        (a2 \\<inter>\\<^sub>g b2) = Some d2 \\<and> c = Seq d1 d2)", "by (cases c2) (auto split: option.splits)"], ["", "lemma inter_guards_Cond:\n  \"(Cond cnd t1 e1 \\<inter>\\<^sub>g c2) = Some c =\n     (\\<exists>t2 e2 t e. c2=Cond cnd t2 e2 \\<and> (t1 \\<inter>\\<^sub>g t2) = Some t \\<and>\n        (e1 \\<inter>\\<^sub>g e2) = Some e \\<and> c=Cond cnd t e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Cond cnd t1 e1 \\<inter>\\<^sub>g c2) = Some c) =\n    (\\<exists>t2 e2 t e.\n        c2 = Cond cnd t2 e2 \\<and>\n        (t1 \\<inter>\\<^sub>g t2) = Some t \\<and>\n        (e1 \\<inter>\\<^sub>g e2) = Some e \\<and> c = Cond cnd t e)", "by (cases c2) (auto split: option.splits)"], ["", "lemma inter_guards_While:\n \"(While cnd bdy1 \\<inter>\\<^sub>g c2) = Some c =\n     (\\<exists>bdy2 bdy. c2 =While cnd bdy2 \\<and> (bdy1 \\<inter>\\<^sub>g bdy2) = Some bdy \\<and>\n       c=While cnd bdy)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((While cnd bdy1 \\<inter>\\<^sub>g c2) = Some c) =\n    (\\<exists>bdy2 bdy.\n        c2 = While cnd bdy2 \\<and>\n        (bdy1 \\<inter>\\<^sub>g bdy2) = Some bdy \\<and> c = While cnd bdy)", "by (cases c2) (auto split: option.splits if_split_asm)"], ["", "lemma inter_guards_Call:\n  \"(Call p \\<inter>\\<^sub>g c2) = Some c =\n     (c2=Call p \\<and> c=Call p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Call p \\<inter>\\<^sub>g c2) = Some c) =\n    (c2 = Call p \\<and> c = Call p)", "by (cases c2) (auto split: if_split_asm)"], ["", "lemma inter_guards_DynCom:\n  \"(DynCom f1 \\<inter>\\<^sub>g c2) = Some c =\n     (\\<exists>f2. c2=DynCom f2 \\<and> (\\<forall>s. ((f1 s) \\<inter>\\<^sub>g (f2 s)) \\<noteq> None) \\<and>\n      c=DynCom (\\<lambda>s. the ((f1 s) \\<inter>\\<^sub>g (f2 s))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((DynCom f1 \\<inter>\\<^sub>g c2) = Some c) =\n    (\\<exists>f2.\n        c2 = DynCom f2 \\<and>\n        (\\<forall>s. (f1 s \\<inter>\\<^sub>g f2 s) \\<noteq> None) \\<and>\n        c = DynCom (\\<lambda>s. the (f1 s \\<inter>\\<^sub>g f2 s)))", "by (cases c2) (auto split: if_split_asm)"], ["", "lemma inter_guards_Guard:\n  \"(Guard f g1 bdy1 \\<inter>\\<^sub>g c2) = Some c =\n     (\\<exists>g2 bdy2 bdy. c2=Guard f g2 bdy2 \\<and> (bdy1 \\<inter>\\<^sub>g bdy2) = Some bdy \\<and>\n       c=Guard f (g1 \\<inter> g2) bdy)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Guard f g1 bdy1 \\<inter>\\<^sub>g c2) = Some c) =\n    (\\<exists>g2 bdy2 bdy.\n        c2 = Guard f g2 bdy2 \\<and>\n        (bdy1 \\<inter>\\<^sub>g bdy2) = Some bdy \\<and>\n        c = Guard f (g1 \\<inter> g2) bdy)", "by (cases c2) (auto split: option.splits)"], ["", "lemma inter_guards_Throw:\n  \"(Throw \\<inter>\\<^sub>g c2) = Some c = (c2=Throw \\<and> c=Throw)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Throw \\<inter>\\<^sub>g c2) = Some c) = (c2 = Throw \\<and> c = Throw)", "by (cases c2) auto"], ["", "lemma inter_guards_Catch:\n  \"(Catch a1 a2 \\<inter>\\<^sub>g c2) = Some c =\n     (\\<exists>b1 b2 d1 d2. c2=Catch b1 b2 \\<and> (a1 \\<inter>\\<^sub>g b1) = Some d1 \\<and>\n        (a2 \\<inter>\\<^sub>g b2) = Some d2 \\<and> c=Catch d1 d2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Catch a1 a2 \\<inter>\\<^sub>g c2) = Some c) =\n    (\\<exists>b1 b2 d1 d2.\n        c2 = Catch b1 b2 \\<and>\n        (a1 \\<inter>\\<^sub>g b1) = Some d1 \\<and>\n        (a2 \\<inter>\\<^sub>g b2) = Some d2 \\<and> c = Catch d1 d2)", "by (cases c2) (auto split: option.splits)"], ["", "lemmas inter_guards_simps = inter_guards_Skip inter_guards_Basic inter_guards_Spec\n  inter_guards_Seq inter_guards_Cond inter_guards_While inter_guards_Call\n  inter_guards_DynCom inter_guards_Guard inter_guards_Throw\n  inter_guards_Catch"], ["", "subsubsection \\<open>Subset on Guards: \\<open>c\\<^sub>1 \\<subseteq>\\<^sub>g c\\<^sub>2\\<close>\\<close>"], ["", "inductive subseteq_guards :: \"('s,'p,'f) com \\<Rightarrow> ('s,'p,'f) com \\<Rightarrow> bool\"\n  (\"_ \\<subseteq>\\<^sub>g _\" [20,20] 19) where\n  \"Skip \\<subseteq>\\<^sub>g Skip\"\n| \"f1 = f2 \\<Longrightarrow> Basic f1 \\<subseteq>\\<^sub>g Basic f2\"\n| \"r1 = r2 \\<Longrightarrow> Spec r1 \\<subseteq>\\<^sub>g Spec r2\"\n| \"a1 \\<subseteq>\\<^sub>g b1 \\<Longrightarrow> a2 \\<subseteq>\\<^sub>g b2 \\<Longrightarrow> Seq a1 a2 \\<subseteq>\\<^sub>g Seq b1 b2\"\n| \"cnd1 = cnd2 \\<Longrightarrow> t1 \\<subseteq>\\<^sub>g t2 \\<Longrightarrow> e1 \\<subseteq>\\<^sub>g e2 \\<Longrightarrow> Cond cnd1 t1 e1 \\<subseteq>\\<^sub>g Cond cnd2 t2 e2\"\n| \"cnd1 = cnd2 \\<Longrightarrow> c1 \\<subseteq>\\<^sub>g c2 \\<Longrightarrow> While cnd1 c1 \\<subseteq>\\<^sub>g While cnd2 c2\"\n| \"p1 = p2 \\<Longrightarrow> Call p1 \\<subseteq>\\<^sub>g Call p2\"\n| \"(\\<And>s. P1 s \\<subseteq>\\<^sub>g P2 s) \\<Longrightarrow> DynCom P1 \\<subseteq>\\<^sub>g DynCom P2\"\n| \"m1 = m2 \\<Longrightarrow> g1 = g2 \\<Longrightarrow> c1 \\<subseteq>\\<^sub>g c2 \\<Longrightarrow> Guard m1 g1 c1 \\<subseteq>\\<^sub>g Guard m2 g2 c2\"\n| \"c1 \\<subseteq>\\<^sub>g c2 \\<Longrightarrow> c1 \\<subseteq>\\<^sub>g Guard m2 g2 c2\"\n| \"Throw \\<subseteq>\\<^sub>g Throw\"\n| \"a1 \\<subseteq>\\<^sub>g b1 \\<Longrightarrow> a2 \\<subseteq>\\<^sub>g b2 \\<Longrightarrow> Catch a1 a2 \\<subseteq>\\<^sub>g Catch b1 b2\""], ["", "lemma subseteq_guards_Skip:\n  \"c = Skip\" if \"c \\<subseteq>\\<^sub>g Skip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c = Skip", "using that"], ["proof (prove)\nusing this:\n  c \\<subseteq>\\<^sub>g Skip\n\ngoal (1 subgoal):\n 1. c = Skip", "by cases"], ["", "lemma subseteq_guards_Basic:\n  \"c = Basic f\" if \"c \\<subseteq>\\<^sub>g Basic f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c = Basic f", "using that"], ["proof (prove)\nusing this:\n  c \\<subseteq>\\<^sub>g Basic f\n\ngoal (1 subgoal):\n 1. c = Basic f", "by cases simp"], ["", "lemma subseteq_guards_Spec:\n  \"c = Spec r\" if \"c \\<subseteq>\\<^sub>g Spec r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c = Spec r", "using that"], ["proof (prove)\nusing this:\n  c \\<subseteq>\\<^sub>g Spec r\n\ngoal (1 subgoal):\n 1. c = Spec r", "by cases simp"], ["", "lemma subseteq_guards_Seq:\n  \"\\<exists>c1' c2'. c = Seq c1' c2' \\<and> (c1' \\<subseteq>\\<^sub>g c1) \\<and> (c2' \\<subseteq>\\<^sub>g c2)\" if \"c \\<subseteq>\\<^sub>g Seq c1 c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c1' c2'.\n       c = Seq c1' c2' \\<and>\n       (c1' \\<subseteq>\\<^sub>g c1) \\<and> (c2' \\<subseteq>\\<^sub>g c2)", "using that"], ["proof (prove)\nusing this:\n  c \\<subseteq>\\<^sub>g Seq c1 c2\n\ngoal (1 subgoal):\n 1. \\<exists>c1' c2'.\n       c = Seq c1' c2' \\<and>\n       (c1' \\<subseteq>\\<^sub>g c1) \\<and> (c2' \\<subseteq>\\<^sub>g c2)", "by cases simp"], ["", "lemma subseteq_guards_Cond:\n  \"\\<exists>c1' c2'. c=Cond b c1' c2' \\<and> (c1' \\<subseteq>\\<^sub>g c1) \\<and> (c2' \\<subseteq>\\<^sub>g c2)\" if \"c \\<subseteq>\\<^sub>g Cond b c1 c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c1' c2'.\n       c = Cond b c1' c2' \\<and>\n       (c1' \\<subseteq>\\<^sub>g c1) \\<and> (c2' \\<subseteq>\\<^sub>g c2)", "using that"], ["proof (prove)\nusing this:\n  c \\<subseteq>\\<^sub>g Cond b c1 c2\n\ngoal (1 subgoal):\n 1. \\<exists>c1' c2'.\n       c = Cond b c1' c2' \\<and>\n       (c1' \\<subseteq>\\<^sub>g c1) \\<and> (c2' \\<subseteq>\\<^sub>g c2)", "by cases simp"], ["", "lemma subseteq_guards_While:\n  \"\\<exists>c''. c=While b c'' \\<and> (c'' \\<subseteq>\\<^sub>g c')\" if \"c \\<subseteq>\\<^sub>g While b c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c''. c = While b c'' \\<and> (c'' \\<subseteq>\\<^sub>g c')", "using that"], ["proof (prove)\nusing this:\n  c \\<subseteq>\\<^sub>g While b c'\n\ngoal (1 subgoal):\n 1. \\<exists>c''. c = While b c'' \\<and> (c'' \\<subseteq>\\<^sub>g c')", "by cases simp"], ["", "lemma subseteq_guards_Call:\n \"c = Call p\" if \"c \\<subseteq>\\<^sub>g Call p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c = Call p", "using that"], ["proof (prove)\nusing this:\n  c \\<subseteq>\\<^sub>g Call p\n\ngoal (1 subgoal):\n 1. c = Call p", "by cases simp"], ["", "lemma subseteq_guards_DynCom:\n  \"\\<exists>C'. c=DynCom C' \\<and> (\\<forall>s. C' s \\<subseteq>\\<^sub>g C s)\" if \"c \\<subseteq>\\<^sub>g DynCom C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C'.\n       c = DynCom C' \\<and> (\\<forall>s. C' s \\<subseteq>\\<^sub>g C s)", "using that"], ["proof (prove)\nusing this:\n  c \\<subseteq>\\<^sub>g DynCom C\n\ngoal (1 subgoal):\n 1. \\<exists>C'.\n       c = DynCom C' \\<and> (\\<forall>s. C' s \\<subseteq>\\<^sub>g C s)", "by cases simp"], ["", "lemma subseteq_guards_Guard:\n  \"(c \\<subseteq>\\<^sub>g c') \\<or> (\\<exists>c''. c = Guard f g c'' \\<and> (c'' \\<subseteq>\\<^sub>g c'))\" if \"c \\<subseteq>\\<^sub>g Guard f g c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c \\<subseteq>\\<^sub>g c') \\<or>\n    (\\<exists>c''. c = Guard f g c'' \\<and> (c'' \\<subseteq>\\<^sub>g c'))", "using that"], ["proof (prove)\nusing this:\n  c \\<subseteq>\\<^sub>g Guard f g c'\n\ngoal (1 subgoal):\n 1. (c \\<subseteq>\\<^sub>g c') \\<or>\n    (\\<exists>c''. c = Guard f g c'' \\<and> (c'' \\<subseteq>\\<^sub>g c'))", "by cases simp_all"], ["", "lemma subseteq_guards_Throw:\n  \"c = Throw\" if \"c \\<subseteq>\\<^sub>g Throw\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c = Throw", "using that"], ["proof (prove)\nusing this:\n  c \\<subseteq>\\<^sub>g Throw\n\ngoal (1 subgoal):\n 1. c = Throw", "by cases"], ["", "lemma subseteq_guards_Catch:\n  \"\\<exists>c1' c2'. c = Catch c1' c2' \\<and> (c1' \\<subseteq>\\<^sub>g c1) \\<and> (c2' \\<subseteq>\\<^sub>g c2)\" if \"c \\<subseteq>\\<^sub>g Catch c1 c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c1' c2'.\n       c = Catch c1' c2' \\<and>\n       (c1' \\<subseteq>\\<^sub>g c1) \\<and> (c2' \\<subseteq>\\<^sub>g c2)", "using that"], ["proof (prove)\nusing this:\n  c \\<subseteq>\\<^sub>g Catch c1 c2\n\ngoal (1 subgoal):\n 1. \\<exists>c1' c2'.\n       c = Catch c1' c2' \\<and>\n       (c1' \\<subseteq>\\<^sub>g c1) \\<and> (c2' \\<subseteq>\\<^sub>g c2)", "by cases simp"], ["", "lemmas subseteq_guardsD = subseteq_guards_Skip subseteq_guards_Basic\n subseteq_guards_Spec subseteq_guards_Seq subseteq_guards_Cond subseteq_guards_While\n subseteq_guards_Call subseteq_guards_DynCom subseteq_guards_Guard\n subseteq_guards_Throw subseteq_guards_Catch"], ["", "lemma subseteq_guards_Guard':\n  \"\\<exists>f' b' c'. d = Guard f' b' c'\" if \"Guard f b c \\<subseteq>\\<^sub>g d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f' b' c'. d = Guard f' b' c'", "using that"], ["proof (prove)\nusing this:\n  Guard f b c \\<subseteq>\\<^sub>g d\n\ngoal (1 subgoal):\n 1. \\<exists>f' b' c'. d = Guard f' b' c'", "by cases auto"], ["", "lemma subseteq_guards_refl: \"c \\<subseteq>\\<^sub>g c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<subseteq>\\<^sub>g c", "by (induct c) (auto intro: subseteq_guards.intros)"], ["", "(* Antisymmetry and transitivity should hold as well\\<dots> *)"], ["", "end"]]}