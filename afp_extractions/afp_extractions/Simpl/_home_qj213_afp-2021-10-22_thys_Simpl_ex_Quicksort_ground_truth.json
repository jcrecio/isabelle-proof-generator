{"file_name": "/home/qj213/afp-2021-10-22/thys/Simpl/ex/Quicksort.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Simpl", "problem_names": ["lemma (in append_impl) append_modifies:\n  shows\n   \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile> {\\<sigma>} \\<acute>p :== PROC append(\\<acute>p,\\<acute>q){t. t may_only_modify_globals \\<sigma> in [next]}\"", "lemma (in append_impl) append_spec:\n  shows \"\\<forall>\\<sigma> Ps Qs. \\<Gamma>\\<turnstile>\n            \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next Ps \\<and>  List \\<acute>q \\<acute>next Qs \\<and> set Ps \\<inter> set Qs = {}\\<rbrace>\n                \\<acute>p :== PROC append(\\<acute>p,\\<acute>q)\n            \\<lbrace>List \\<acute>p \\<acute>next (Ps@Qs) \\<and> (\\<forall>x. x\\<notin>set Ps \\<longrightarrow> \\<acute>next x = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>\"", "lemma perm_set_eq:\n  assumes perm: \"xs <~~> ys\"\n  shows \"set xs = set ys\"", "lemma perm_Cons_eq [iff]: \"x#xs <~~> x#ys = (xs <~~> ys)\"", "lemma perm_app_Cons_eq1 : \"xs@y#ys <~~> zs = (y#xs@ys <~~> zs)\"", "lemma perm_app_Cons_eq2 : \"zs <~~> xs@y#ys = (zs <~~> y#xs@ys)\"", "lemmas perm_app_Cons_simps = perm_app_Cons_eq1 [THEN sym]\n                             perm_app_Cons_eq2 [THEN sym]", "lemma sorted_append[simp]:\n \"sorted le (xs@ys) = (sorted le xs \\<and> sorted le ys \\<and>\n                       (\\<forall>x \\<in> set xs. \\<forall>y \\<in> set ys. le x y))\"", "lemma perm_append_blocks:\n  assumes ws_ys: \"ws <~~> ys\"\n  assumes xs_zs: \"xs <~~> zs\"\n  shows \"ws@xs <~~> ys@zs\"", "lemma (in quickSort_impl) quickSort_modifies:\n  shows\n  \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile> {\\<sigma>} \\<acute>p :== PROC quickSort(\\<acute>p) {t. t may_only_modify_globals \\<sigma> in [next]}\"", "lemma (in quickSort_impl) quickSort_spec:\nshows\n  \"\\<forall>\\<sigma> Ps. \\<Gamma>\\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next Ps\\<rbrace>\n                  \\<acute>p :== PROC quickSort(\\<acute>p)\n                \\<lbrace>(\\<exists>sortedPs. List \\<acute>p \\<acute>next sortedPs \\<and>\n                 sorted (\\<le>) (map \\<^bsup>\\<sigma>\\<^esup>cont sortedPs) \\<and>\n                 Ps <~~> sortedPs) \\<and>\n                 (\\<forall>x. x\\<notin>set Ps \\<longrightarrow> \\<acute>next x = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>\""], "translations": [["", "lemma (in append_impl) append_modifies:\n  shows\n   \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile> {\\<sigma>} \\<acute>p :== PROC append(\\<acute>p,\\<acute>q){t. t may_only_modify_globals \\<sigma> in [next]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile> {\\<sigma>}\n                       \\<acute>p :== PROC append(\\<acute>p,\\<acute>q)\n                       {t. t may_only_modify_globals \\<sigma> in [next]}", "apply (hoare_rule HoarePartial.ProcRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,(\\<Union>\\<sigma>.\n                    {({\\<sigma>}, append_'proc,\n                      {t. t may_only_modify_globals \\<sigma> in [next]},\n                      {})})\n          \\<turnstile> {\\<sigma>}\n                       IF \\<acute>p = Null THEN \\<acute>p :== \\<acute>q\n                       ELSE \\<acute>p\\<rightarrow>\\<acute>next :== CALL append(\\<acute>p\\<rightarrow>\\<acute>next,\n                         \\<acute>q)\n                       FI\n                       {t. t may_only_modify_globals \\<sigma> in [next]}", "apply (vcg spec=modifies)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in append_impl) append_spec:\n  shows \"\\<forall>\\<sigma> Ps Qs. \\<Gamma>\\<turnstile>\n            \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next Ps \\<and>  List \\<acute>q \\<acute>next Qs \\<and> set Ps \\<inter> set Qs = {}\\<rbrace>\n                \\<acute>p :== PROC append(\\<acute>p,\\<acute>q)\n            \\<lbrace>List \\<acute>p \\<acute>next (Ps@Qs) \\<and> (\\<forall>x. x\\<notin>set Ps \\<longrightarrow> \\<acute>next x = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> Ps Qs.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n     Ps \\<and>\n    List \\<acute>q \\<acute>next Qs \\<and>\n    set Ps \\<inter> set Qs = {}\\<rbrace>\n                       \\<acute>p :== PROC append(\\<acute>p,\\<acute>q)\n                       \\<lbrace>List \\<acute>p \\<acute>next (Ps @ Qs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Ps \\<longrightarrow>\n                                    x\\<rightarrow>\\<acute>next =\n                                    \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>", "apply (hoare_rule HoarePartial.ProcRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> Ps Qs.\n       \\<Gamma>,(\\<Union>\\<sigma> Ps Qs.\n                    {(\\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n    Ps \\<and>\n   List \\<acute>q \\<acute>next Qs \\<and>\n   set Ps \\<inter> set Qs = {}\\<rbrace>,\n                      append_'proc,\n                      \\<lbrace>List \\<acute>p \\<acute>next (Ps @ Qs) \\<and>\n                               (\\<forall>x.\n                                   x \\<notin> set Ps \\<longrightarrow>\n                                   x\\<rightarrow>\\<acute>next =\n                                   \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>,\n                      {})})\n          \\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n     Ps \\<and>\n    List \\<acute>q \\<acute>next Qs \\<and>\n    set Ps \\<inter> set Qs = {}\\<rbrace>\n                       IF \\<acute>p = Null THEN \\<acute>p :== \\<acute>q\n                       ELSE \\<acute>p\\<rightarrow>\\<acute>next :== CALL append(\\<acute>p\\<rightarrow>\\<acute>next,\n                         \\<acute>q)\n                       FI\n                       \\<lbrace>List \\<acute>p \\<acute>next (Ps @ Qs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Ps \\<longrightarrow>\n                                    x\\<rightarrow>\\<acute>next =\n                                    \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps Qs next p q.\n       \\<lbrakk>List p next Ps; List q next Qs;\n        set Ps \\<inter> set Qs = {}\\<rbrakk>\n       \\<Longrightarrow> (p = Null \\<longrightarrow>\n                          List q next (Ps @ Qs) \\<and>\n                          (\\<forall>x.\n                              x \\<notin> set Ps \\<longrightarrow>\n                              next x = next x)) \\<and>\n                         (p \\<noteq> Null \\<longrightarrow>\n                          (\\<exists>Psa.\n                              List (next p) next Psa \\<and>\n                              (\\<exists>Qsa.\n                                  List q next Qsa \\<and>\n                                  set Psa \\<inter> set Qsa = {} \\<and>\n                                  (\\<forall>nexta pa.\nList pa nexta (Psa @ Qsa) \\<and>\n(\\<forall>x.\n    x \\<notin> set Psa \\<longrightarrow> nexta x = next x) \\<longrightarrow>\nList p (nexta(p := pa)) (Ps @ Qs) \\<and>\n(\\<forall>x.\n    x \\<notin> set Ps \\<longrightarrow> (nexta(p := pa)) x = next x)))))", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "primrec sorted:: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a list  \\<Rightarrow> bool\"\nwhere\n\"sorted le [] = True\" |\n\"sorted le (x#xs) = ((\\<forall>y\\<in>set xs. le x y) \\<and> sorted le xs)\""], ["", "lemma perm_set_eq:\n  assumes perm: \"xs <~~> ys\"\n  shows \"set xs = set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs = set ys", "using perm"], ["proof (prove)\nusing this:\n  xs <~~> ys\n\ngoal (1 subgoal):\n 1. set xs = set ys", "by induct auto"], ["", "lemma perm_Cons_eq [iff]: \"x#xs <~~> x#ys = (xs <~~> ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x # xs <~~> x # ys) = (xs <~~> ys)", "by auto"], ["", "lemma perm_app_Cons_eq1 : \"xs@y#ys <~~> zs = (y#xs@ys <~~> zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ y # ys <~~> zs) = (y # xs @ ys <~~> zs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (xs @ y # ys <~~> zs) = (y # xs @ ys <~~> zs)", "have app_Cons: \"xs@y#ys <~~> y#xs@ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ y # ys <~~> y # xs @ ys", "by (rule perm_sym, rule perm_append_Cons)"], ["proof (state)\nthis:\n  xs @ y # ys <~~> y # xs @ ys\n\ngoal (1 subgoal):\n 1. (xs @ y # ys <~~> zs) = (y # xs @ ys <~~> zs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ y # ys <~~> zs) = (y # xs @ ys <~~> zs)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. xs @ y # ys <~~> zs \\<Longrightarrow> y # xs @ ys <~~> zs\n 2. y # xs @ ys <~~> zs \\<Longrightarrow> xs @ y # ys <~~> zs", "assume \"xs@y#ys <~~> zs\""], ["proof (state)\nthis:\n  xs @ y # ys <~~> zs\n\ngoal (2 subgoals):\n 1. xs @ y # ys <~~> zs \\<Longrightarrow> y # xs @ ys <~~> zs\n 2. y # xs @ ys <~~> zs \\<Longrightarrow> xs @ y # ys <~~> zs", "with app_Cons [THEN perm_sym]"], ["proof (chain)\npicking this:\n  y # xs @ ys <~~> xs @ y # ys\n  xs @ y # ys <~~> zs", "show \"y#xs@ys <~~> zs\""], ["proof (prove)\nusing this:\n  y # xs @ ys <~~> xs @ y # ys\n  xs @ y # ys <~~> zs\n\ngoal (1 subgoal):\n 1. y # xs @ ys <~~> zs", "by (rule perm.trans)"], ["proof (state)\nthis:\n  y # xs @ ys <~~> zs\n\ngoal (1 subgoal):\n 1. y # xs @ ys <~~> zs \\<Longrightarrow> xs @ y # ys <~~> zs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y # xs @ ys <~~> zs \\<Longrightarrow> xs @ y # ys <~~> zs", "assume \" y#xs@ys <~~> zs\""], ["proof (state)\nthis:\n  y # xs @ ys <~~> zs\n\ngoal (1 subgoal):\n 1. y # xs @ ys <~~> zs \\<Longrightarrow> xs @ y # ys <~~> zs", "with app_Cons"], ["proof (chain)\npicking this:\n  xs @ y # ys <~~> y # xs @ ys\n  y # xs @ ys <~~> zs", "show \"xs@y#ys <~~> zs\""], ["proof (prove)\nusing this:\n  xs @ y # ys <~~> y # xs @ ys\n  y # xs @ ys <~~> zs\n\ngoal (1 subgoal):\n 1. xs @ y # ys <~~> zs", "by (rule perm.trans)"], ["proof (state)\nthis:\n  xs @ y # ys <~~> zs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (xs @ y # ys <~~> zs) = (y # xs @ ys <~~> zs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma perm_app_Cons_eq2 : \"zs <~~> xs@y#ys = (zs <~~> y#xs@ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (zs <~~> xs @ y # ys) = (zs <~~> y # xs @ ys)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (zs <~~> xs @ y # ys) = (zs <~~> y # xs @ ys)", "have \"xs@y#ys <~~> zs = (y#xs@ys <~~> zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ y # ys <~~> zs) = (y # xs @ ys <~~> zs)", "by (rule perm_app_Cons_eq1)"], ["proof (state)\nthis:\n  (xs @ y # ys <~~> zs) = (y # xs @ ys <~~> zs)\n\ngoal (1 subgoal):\n 1. (zs <~~> xs @ y # ys) = (zs <~~> y # xs @ ys)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (xs @ y # ys <~~> zs) = (y # xs @ ys <~~> zs)\n\ngoal (1 subgoal):\n 1. (zs <~~> xs @ y # ys) = (zs <~~> y # xs @ ys)", "by (iprover intro: perm_sym)"], ["proof (state)\nthis:\n  (zs <~~> xs @ y # ys) = (zs <~~> y # xs @ ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas perm_app_Cons_simps = perm_app_Cons_eq1 [THEN sym]\n                             perm_app_Cons_eq2 [THEN sym]"], ["", "lemma sorted_append[simp]:\n \"sorted le (xs@ys) = (sorted le xs \\<and> sorted le ys \\<and>\n                       (\\<forall>x \\<in> set xs. \\<forall>y \\<in> set ys. le x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Quicksort.sorted le (xs @ ys) =\n    (Quicksort.sorted le xs \\<and>\n     Quicksort.sorted le ys \\<and>\n     (\\<forall>x\\<in>set xs. \\<forall>y\\<in>set ys. le x y))", "by (induct xs, auto)"], ["", "lemma perm_append_blocks:\n  assumes ws_ys: \"ws <~~> ys\"\n  assumes xs_zs: \"xs <~~> zs\"\n  shows \"ws@xs <~~> ys@zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ws @ xs <~~> ys @ zs", "using ws_ys"], ["proof (prove)\nusing this:\n  ws <~~> ys\n\ngoal (1 subgoal):\n 1. ws @ xs <~~> ys @ zs", "proof (induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. [] @ xs <~~> [] @ zs\n 2. \\<And>y x l. (y # x # l) @ xs <~~> (x # y # l) @ zs\n 3. \\<And>xsa ys z.\n       \\<lbrakk>xsa <~~> ys; xsa @ xs <~~> ys @ zs\\<rbrakk>\n       \\<Longrightarrow> (z # xsa) @ xs <~~> (z # ys) @ zs\n 4. \\<And>xsa ys zsa.\n       \\<lbrakk>xsa <~~> ys; xsa @ xs <~~> ys @ zs; ys <~~> zsa;\n        ys @ xs <~~> zsa @ zs\\<rbrakk>\n       \\<Longrightarrow> xsa @ xs <~~> zsa @ zs", "case (swap l x y)"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. [] @ xs <~~> [] @ zs\n 2. \\<And>y x l. (y # x # l) @ xs <~~> (x # y # l) @ zs\n 3. \\<And>xsa ys z.\n       \\<lbrakk>xsa <~~> ys; xsa @ xs <~~> ys @ zs\\<rbrakk>\n       \\<Longrightarrow> (z # xsa) @ xs <~~> (z # ys) @ zs\n 4. \\<And>xsa ys zsa.\n       \\<lbrakk>xsa <~~> ys; xsa @ xs <~~> ys @ zs; ys <~~> zsa;\n        ys @ xs <~~> zsa @ zs\\<rbrakk>\n       \\<Longrightarrow> xsa @ xs <~~> zsa @ zs", "from xs_zs"], ["proof (chain)\npicking this:\n  xs <~~> zs", "show \"(l # x # y) @ xs <~~> (x # l # y) @ zs\""], ["proof (prove)\nusing this:\n  xs <~~> zs\n\ngoal (1 subgoal):\n 1. (l # x # y) @ xs <~~> (x # l # y) @ zs", "by (induct) auto"], ["proof (state)\nthis:\n  (l # x # y) @ xs <~~> (x # l # y) @ zs\n\ngoal (3 subgoals):\n 1. [] @ xs <~~> [] @ zs\n 2. \\<And>xsa ys z.\n       \\<lbrakk>xsa <~~> ys; xsa @ xs <~~> ys @ zs\\<rbrakk>\n       \\<Longrightarrow> (z # xsa) @ xs <~~> (z # ys) @ zs\n 3. \\<And>xsa ys zsa.\n       \\<lbrakk>xsa <~~> ys; xsa @ xs <~~> ys @ zs; ys <~~> zsa;\n        ys @ xs <~~> zsa @ zs\\<rbrakk>\n       \\<Longrightarrow> xsa @ xs <~~> zsa @ zs", "qed (insert xs_zs , auto)"], ["", "procedures quickSort(p|p) =\n \"IF \\<acute>p=Null THEN SKIP\n  ELSE \\<acute>tl :== \\<acute>p\\<rightarrow>\\<acute>next;;\n       \\<acute>le :== Null;;\n       \\<acute>gt :== Null;;\n       WHILE \\<acute>tl\\<noteq>Null DO\n         \\<acute>hd :== \\<acute>tl;;\n         \\<acute>tl :== \\<acute>tl\\<rightarrow>\\<acute>next;;\n         IF \\<acute>hd\\<rightarrow>\\<acute>cont \\<le> \\<acute>p\\<rightarrow>\\<acute>cont\n         THEN \\<acute>hd\\<rightarrow>\\<acute>next :== \\<acute>le;;\n              \\<acute>le :== \\<acute>hd\n         ELSE \\<acute>hd\\<rightarrow>\\<acute>next :== \\<acute>gt;;\n              \\<acute>gt :== \\<acute>hd\n         FI\n       OD;;\n       \\<acute>le :== CALL quickSort(\\<acute>le);;\n       \\<acute>gt :== CALL quickSort(\\<acute>gt);;\n       \\<acute>p\\<rightarrow>\\<acute>next :== \\<acute>gt;;\n       \\<acute>le :== CALL append(\\<acute>le,\\<acute>p);;\n       \\<acute>p :== \\<acute>le\n  FI\"\n\n  quickSort_spec:\n  \"\\<forall>\\<sigma> Ps. \\<Gamma>\\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next Ps\\<rbrace> \\<acute>p :== PROC quickSort(\\<acute>p)\n       \\<lbrace>(\\<exists>sortedPs. List \\<acute>p \\<acute>next sortedPs \\<and>\n        sorted (\\<le>) (map \\<^bsup>\\<sigma>\\<^esup>cont sortedPs) \\<and>\n        Ps <~~> sortedPs) \\<and>\n        (\\<forall>x. x\\<notin>set Ps \\<longrightarrow> \\<acute>next x = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>\"\n\n  quickSort_modifies:\n  \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile> {\\<sigma>} \\<acute>p :== PROC quickSort(\\<acute>p) {t. t may_only_modify_globals \\<sigma> in [next]}\""], ["", "lemma (in quickSort_impl) quickSort_modifies:\n  shows\n  \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile> {\\<sigma>} \\<acute>p :== PROC quickSort(\\<acute>p) {t. t may_only_modify_globals \\<sigma> in [next]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile> {\\<sigma>} \\<acute>p :== PROC quickSort(\\<acute>p)\n                       {t. t may_only_modify_globals \\<sigma> in [next]}", "apply (hoare_rule HoarePartial.ProcRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,(\\<Union>\\<sigma>.\n                    {({\\<sigma>}, quickSort_'proc,\n                      {t. t may_only_modify_globals \\<sigma> in [next]},\n                      {})})\n          \\<turnstile> {\\<sigma>}\n                       IF \\<acute>p = Null THEN SKIP\n                       ELSE \\<acute>tl :==\n                            \\<acute>p\\<rightarrow>\\<acute>next;;\n                         \\<acute>le :== Null;; \\<acute>gt :== Null;;\n                         WHILE \\<acute>tl \\<noteq> Null \n                         DO \\<acute>hd :== \\<acute>tl;;\n                            \\<acute>tl :==\n                            \\<acute>tl\\<rightarrow>\\<acute>next;;\n                            IF \\<acute>hd\\<rightarrow>\\<acute>cont\n                               \\<le> \\<acute>p\\<rightarrow>\\<acute>cont\n                            THEN \\<acute>hd\\<rightarrow>\\<acute>next :==\n                                 \\<acute>le;;\n                              \\<acute>le :== \\<acute>hd\n                            ELSE \\<acute>hd\\<rightarrow>\\<acute>next :==\n                                 \\<acute>gt;;\n                              \\<acute>gt :== \\<acute>hd\n                            FI \n                         OD;;\n                         \\<acute>le :== CALL quickSort(\\<acute>le);;\n                         \\<acute>gt :== CALL quickSort(\\<acute>gt);;\n                         \\<acute>p\\<rightarrow>\\<acute>next :== \\<acute>gt;;\n                         \\<acute>le :== CALL append(\\<acute>le,\\<acute>p);;\n                         \\<acute>p :== \\<acute>le\n                       FI\n                       {t. t may_only_modify_globals \\<sigma> in [next]}", "apply (vcg spec=modifies)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in quickSort_impl) quickSort_spec:\nshows\n  \"\\<forall>\\<sigma> Ps. \\<Gamma>\\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next Ps\\<rbrace>\n                  \\<acute>p :== PROC quickSort(\\<acute>p)\n                \\<lbrace>(\\<exists>sortedPs. List \\<acute>p \\<acute>next sortedPs \\<and>\n                 sorted (\\<le>) (map \\<^bsup>\\<sigma>\\<^esup>cont sortedPs) \\<and>\n                 Ps <~~> sortedPs) \\<and>\n                 (\\<forall>x. x\\<notin>set Ps \\<longrightarrow> \\<acute>next x = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> Ps.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n     Ps\\<rbrace>\n                       \\<acute>p :== PROC quickSort(\\<acute>p)\n                       \\<lbrace>(\\<exists>sortedPs.\n                                    List \\<acute>p \\<acute>next\n                                     sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map \\<^bsup>\\<sigma>\\<^esup>cont\n sortedPs) \\<and>\n                                    Ps <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Ps \\<longrightarrow>\n                                    x\\<rightarrow>\\<acute>next =\n                                    \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>", "apply (hoare_rule HoarePartial.ProcRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> Ps.\n       \\<Gamma>,(\\<Union>\\<sigma> Ps.\n                    {(\\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n    Ps\\<rbrace>,\n                      quickSort_'proc,\n                      \\<lbrace>(\\<exists>sortedPs.\n                                   List \\<acute>p \\<acute>next\n                                    sortedPs \\<and>\n                                   Quicksort.sorted (\\<le>)\n                                    (map \\<^bsup>\\<sigma>\\<^esup>cont\nsortedPs) \\<and>\n                                   Ps <~~> sortedPs) \\<and>\n                               (\\<forall>x.\n                                   x \\<notin> set Ps \\<longrightarrow>\n                                   x\\<rightarrow>\\<acute>next =\n                                   \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>,\n                      {})})\n          \\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n     Ps\\<rbrace>\n                       IF \\<acute>p = Null THEN SKIP\n                       ELSE \\<acute>tl :==\n                            \\<acute>p\\<rightarrow>\\<acute>next;;\n                         \\<acute>le :== Null;; \\<acute>gt :== Null;;\n                         WHILE \\<acute>tl \\<noteq> Null \n                         DO \\<acute>hd :== \\<acute>tl;;\n                            \\<acute>tl :==\n                            \\<acute>tl\\<rightarrow>\\<acute>next;;\n                            IF \\<acute>hd\\<rightarrow>\\<acute>cont\n                               \\<le> \\<acute>p\\<rightarrow>\\<acute>cont\n                            THEN \\<acute>hd\\<rightarrow>\\<acute>next :==\n                                 \\<acute>le;;\n                              \\<acute>le :== \\<acute>hd\n                            ELSE \\<acute>hd\\<rightarrow>\\<acute>next :==\n                                 \\<acute>gt;;\n                              \\<acute>gt :== \\<acute>hd\n                            FI \n                         OD;;\n                         \\<acute>le :== CALL quickSort(\\<acute>le);;\n                         \\<acute>gt :== CALL quickSort(\\<acute>gt);;\n                         \\<acute>p\\<rightarrow>\\<acute>next :== \\<acute>gt;;\n                         \\<acute>le :== CALL append(\\<acute>le,\\<acute>p);;\n                         \\<acute>p :== \\<acute>le\n                       FI\n                       \\<lbrace>(\\<exists>sortedPs.\n                                    List \\<acute>p \\<acute>next\n                                     sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map \\<^bsup>\\<sigma>\\<^esup>cont\n sortedPs) \\<and>\n                                    Ps <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Ps \\<longrightarrow>\n                                    x\\<rightarrow>\\<acute>next =\n                                    \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>", "apply (hoare_rule anno =\n \"IF \\<acute>p=Null THEN SKIP\n  ELSE \\<acute>tl :== \\<acute>p\\<rightarrow>\\<acute>next;;\n       \\<acute>le :== Null;;\n       \\<acute>gt :== Null;;\n       WHILE \\<acute>tl\\<noteq>Null\n       INV \\<lbrace> (\\<exists>les grs tls. List \\<acute>le \\<acute>next les \\<and> List \\<acute>gt \\<acute>next grs \\<and>\n               List \\<acute>tl \\<acute>next tls \\<and>\n               Ps <~~> \\<acute>p#tls@les@grs \\<and>\n               distinct(\\<acute>p#tls@les@grs) \\<and>\n               (\\<forall>x\\<in>set les. x\\<rightarrow>\\<acute>cont \\<le> \\<acute>p\\<rightarrow>\\<acute>cont) \\<and>\n               (\\<forall>x\\<in>set grs. \\<acute>p\\<rightarrow>\\<acute>cont < x\\<rightarrow>\\<acute>cont)) \\<and>\n               \\<acute>p=\\<^bsup>\\<sigma>\\<^esup>p \\<and>\n               \\<acute>cont=\\<^bsup>\\<sigma>\\<^esup>cont \\<and>\n               List \\<^bsup>\\<sigma>\\<^esup>p \\<^bsup>\\<sigma>\\<^esup>next Ps \\<and>\n               (\\<forall>x. x\\<notin>set Ps \\<longrightarrow> \\<acute>next x = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>\n       DO\n         \\<acute>hd :== \\<acute>tl;;\n         \\<acute>tl :== \\<acute>tl\\<rightarrow>\\<acute>next;;\n         IF \\<acute>hd\\<rightarrow>\\<acute>cont \\<le> \\<acute>p\\<rightarrow>\\<acute>cont\n         THEN \\<acute>hd\\<rightarrow>\\<acute>next :== \\<acute>le;;\n              \\<acute>le :== \\<acute>hd\n         ELSE \\<acute>hd\\<rightarrow>\\<acute>next :== \\<acute>gt;;\n              \\<acute>gt :== \\<acute>hd\n         FI\n       OD;;\n       \\<acute>le :== CALL quickSort(\\<acute>le);;\n       \\<acute>gt :== CALL quickSort(\\<acute>gt);;\n       \\<acute>p\\<rightarrow>\\<acute>next :== \\<acute>gt;;\n       \\<acute>le :== CALL append(\\<acute>le,\\<acute>p);;\n       \\<acute>p :== \\<acute>le\n  FI\" in HoarePartial.annotateI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> Ps.\n       \\<Gamma>,(\\<Union>\\<sigma> Ps.\n                    {(\\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n    Ps\\<rbrace>,\n                      quickSort_'proc,\n                      \\<lbrace>(\\<exists>sortedPs.\n                                   List \\<acute>p \\<acute>next\n                                    sortedPs \\<and>\n                                   Quicksort.sorted (\\<le>)\n                                    (map \\<^bsup>\\<sigma>\\<^esup>cont\nsortedPs) \\<and>\n                                   Ps <~~> sortedPs) \\<and>\n                               (\\<forall>x.\n                                   x \\<notin> set Ps \\<longrightarrow>\n                                   x\\<rightarrow>\\<acute>next =\n                                   \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>,\n                      {})})\n          \\<turnstile> \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next\n     Ps\\<rbrace>\n                       IF \\<acute>p = Null THEN SKIP\n                       ELSE \\<acute>tl :==\n                            \\<acute>p\\<rightarrow>\\<acute>next;;\n                         \\<acute>le :== Null;; \\<acute>gt :== Null;;\n                         WHILE \\<acute>tl \\<noteq> Null\n                         INV \\<lbrace>(\\<exists>les grs tls.\n    List \\<acute>le \\<acute>next les \\<and>\n    List \\<acute>gt \\<acute>next grs \\<and>\n    List \\<acute>tl \\<acute>next tls \\<and>\n    Ps <~~> \\<acute>p # tls @ les @ grs \\<and>\n    distinct (\\<acute>p # tls @ les @ grs) \\<and>\n    (\\<forall>x\\<in>set les.\n        x\\<rightarrow>\\<acute>cont\n        \\<le> \\<acute>p\\<rightarrow>\\<acute>cont) \\<and>\n    (\\<forall>x\\<in>set grs.\n        \\<acute>p\\<rightarrow>\\<acute>cont\n        < x\\<rightarrow>\\<acute>cont)) \\<and>\n\\<acute>p = \\<^bsup>\\<sigma>\\<^esup>p \\<and>\n\\<acute>cont = \\<^bsup>\\<sigma>\\<^esup>cont \\<and>\nList \\<^bsup>\\<sigma>\\<^esup>p \\<^bsup>\\<sigma>\\<^esup>next Ps \\<and>\n(\\<forall>x.\n    x \\<notin> set Ps \\<longrightarrow>\n    x\\<rightarrow>\\<acute>next = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace> \n                         DO \\<acute>hd :== \\<acute>tl;;\n                            \\<acute>tl :==\n                            \\<acute>tl\\<rightarrow>\\<acute>next;;\n                            IF \\<acute>hd\\<rightarrow>\\<acute>cont\n                               \\<le> \\<acute>p\\<rightarrow>\\<acute>cont\n                            THEN \\<acute>hd\\<rightarrow>\\<acute>next :==\n                                 \\<acute>le;;\n                              \\<acute>le :== \\<acute>hd\n                            ELSE \\<acute>hd\\<rightarrow>\\<acute>next :==\n                                 \\<acute>gt;;\n                              \\<acute>gt :== \\<acute>hd\n                            FI \n                         OD;;\n                         \\<acute>le :== CALL quickSort(\\<acute>le);;\n                         \\<acute>gt :== CALL quickSort(\\<acute>gt);;\n                         \\<acute>p\\<rightarrow>\\<acute>next :== \\<acute>gt;;\n                         \\<acute>le :== CALL append(\\<acute>le,\\<acute>p);;\n                         \\<acute>p :== \\<acute>le\n                       FI\n                       \\<lbrace>(\\<exists>sortedPs.\n                                    List \\<acute>p \\<acute>next\n                                     sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map \\<^bsup>\\<sigma>\\<^esup>cont\n sortedPs) \\<and>\n                                    Ps <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Ps \\<longrightarrow>\n                                    x\\<rightarrow>\\<acute>next =\n                                    \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Ps next cont p.\n       List p next Ps \\<Longrightarrow>\n       (p = Null \\<longrightarrow>\n        (\\<exists>sortedPs.\n            List p next sortedPs \\<and>\n            Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n            Ps <~~> sortedPs) \\<and>\n        (\\<forall>x.\n            x \\<notin> set Ps \\<longrightarrow> next x = next x)) \\<and>\n       (p \\<noteq> Null \\<longrightarrow>\n        (\\<exists>les grs tls.\n            List Null next les \\<and>\n            List Null next grs \\<and>\n            List (next p) next tls \\<and>\n            Ps <~~> p # tls @ les @ grs \\<and>\n            distinct (p # tls @ les @ grs) \\<and>\n            (\\<forall>x\\<in>set les. cont x \\<le> cont p) \\<and>\n            (\\<forall>x\\<in>set grs. cont p < cont x)) \\<and>\n        p = p \\<and>\n        cont = cont \\<and>\n        List p next Ps \\<and>\n        (\\<forall>x. x \\<notin> set Ps \\<longrightarrow> next x = next x))\n 2. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> (conta tl \\<le> conta pa \\<longrightarrow>\n                          (\\<exists>les grs tls.\n                              List tl (nexta(tl := le)) les \\<and>\n                              List gt (nexta(tl := le)) grs \\<and>\n                              List (nexta tl) (nexta(tl := le)) tls \\<and>\n                              Ps <~~> pa # tls @ les @ grs \\<and>\n                              distinct (pa # tls @ les @ grs) \\<and>\n                              (\\<forall>x\\<in>set les.\n                                  conta x \\<le> conta pa) \\<and>\n                              (\\<forall>x\\<in>set grs.\n                                  conta pa < conta x)) \\<and>\n                          pa = p \\<and>\n                          conta = cont \\<and>\n                          List p next Ps \\<and>\n                          (\\<forall>x.\n                              x \\<notin> set Ps \\<longrightarrow>\n                              (nexta(tl := le)) x = next x)) \\<and>\n                         (\\<not> conta tl \\<le> conta pa \\<longrightarrow>\n                          (\\<exists>les grs tls.\n                              List le (nexta(tl := gt)) les \\<and>\n                              List tl (nexta(tl := gt)) grs \\<and>\n                              List (nexta tl) (nexta(tl := gt)) tls \\<and>\n                              Ps <~~> pa # tls @ les @ grs \\<and>\n                              distinct (pa # tls @ les @ grs) \\<and>\n                              (\\<forall>x\\<in>set les.\n                                  conta x \\<le> conta pa) \\<and>\n                              (\\<forall>x\\<in>set grs.\n                                  conta pa < conta x)) \\<and>\n                          pa = p \\<and>\n                          conta = cont \\<and>\n                          List p next Ps \\<and>\n                          (\\<forall>x.\n                              x \\<notin> set Ps \\<longrightarrow>\n                              (nexta(tl := gt)) x = next x))\n 3. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply   fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> (conta tl \\<le> conta pa \\<longrightarrow>\n                          (\\<exists>les grs tls.\n                              List tl (nexta(tl := le)) les \\<and>\n                              List gt (nexta(tl := le)) grs \\<and>\n                              List (nexta tl) (nexta(tl := le)) tls \\<and>\n                              Ps <~~> pa # tls @ les @ grs \\<and>\n                              distinct (pa # tls @ les @ grs) \\<and>\n                              (\\<forall>x\\<in>set les.\n                                  conta x \\<le> conta pa) \\<and>\n                              (\\<forall>x\\<in>set grs.\n                                  conta pa < conta x)) \\<and>\n                          pa = p \\<and>\n                          conta = cont \\<and>\n                          List p next Ps \\<and>\n                          (\\<forall>x.\n                              x \\<notin> set Ps \\<longrightarrow>\n                              (nexta(tl := le)) x = next x)) \\<and>\n                         (\\<not> conta tl \\<le> conta pa \\<longrightarrow>\n                          (\\<exists>les grs tls.\n                              List le (nexta(tl := gt)) les \\<and>\n                              List tl (nexta(tl := gt)) grs \\<and>\n                              List (nexta tl) (nexta(tl := gt)) tls \\<and>\n                              Ps <~~> pa # tls @ les @ grs \\<and>\n                              distinct (pa # tls @ les @ grs) \\<and>\n                              (\\<forall>x\\<in>set les.\n                                  conta x \\<le> conta pa) \\<and>\n                              (\\<forall>x\\<in>set grs.\n                                  conta pa < conta x)) \\<and>\n                          pa = p \\<and>\n                          conta = cont \\<and>\n                          List p next Ps \\<and>\n                          (\\<forall>x.\n                              x \\<notin> set Ps \\<longrightarrow>\n                              (nexta(tl := gt)) x = next x))\n 2. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply  clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {}\\<rbrakk>\n       \\<Longrightarrow> (cont tl \\<le> cont p \\<longrightarrow>\n                          (\\<exists>les.\n                              (\\<exists>ps.\n                                  les = tl # ps \\<and>\n                                  List le (nexta(tl := le)) ps) \\<and>\n                              (\\<exists>grs.\n                                  List gt (nexta(tl := le)) grs \\<and>\n                                  (\\<exists>tls.\nList (nexta tl) (nexta(tl := le)) tls \\<and>\nPs <~~> p # tls @ les @ grs \\<and>\np \\<notin> set tls \\<and>\np \\<notin> set les \\<and>\np \\<notin> set grs \\<and>\ndistinct tls \\<and>\ndistinct les \\<and>\ndistinct grs \\<and>\nset les \\<inter> set grs = {} \\<and>\nset tls \\<inter> (set les \\<union> set grs) = {} \\<and>\n(\\<forall>x\\<in>set les. cont x \\<le> cont p) \\<and>\n(\\<forall>x\\<in>set grs. cont p < cont x)))) \\<and>\n                          (tl \\<notin> set Ps \\<longrightarrow>\n                           le = next tl)) \\<and>\n                         (\\<not> cont tl \\<le> cont p \\<longrightarrow>\n                          (\\<exists>les.\n                              List le (nexta(tl := gt)) les \\<and>\n                              (\\<exists>grs.\n                                  (\\<exists>ps.\ngrs = tl # ps \\<and> List gt (nexta(tl := gt)) ps) \\<and>\n                                  (\\<exists>tls.\nList (nexta tl) (nexta(tl := gt)) tls \\<and>\nPs <~~> p # tls @ les @ grs \\<and>\np \\<notin> set tls \\<and>\np \\<notin> set les \\<and>\np \\<notin> set grs \\<and>\ndistinct tls \\<and>\ndistinct les \\<and>\ndistinct grs \\<and>\nset les \\<inter> set grs = {} \\<and>\nset tls \\<inter> (set les \\<union> set grs) = {} \\<and>\n(\\<forall>x\\<in>set les. cont x \\<le> cont p) \\<and>\n(\\<forall>x\\<in>set grs. cont p < cont x)))) \\<and>\n                          (tl \\<notin> set Ps \\<longrightarrow>\n                           gt = next tl))\n 2. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply  (rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {}\\<rbrakk>\n       \\<Longrightarrow> cont tl \\<le> cont p \\<longrightarrow>\n                         (\\<exists>les.\n                             (\\<exists>ps.\n                                 les = tl # ps \\<and>\n                                 List le (nexta(tl := le)) ps) \\<and>\n                             (\\<exists>grs.\n                                 List gt (nexta(tl := le)) grs \\<and>\n                                 (\\<exists>tls.\n                                     List (nexta tl) (nexta(tl := le))\ntls \\<and>\n                                     Ps <~~> p # tls @ les @ grs \\<and>\n                                     p \\<notin> set tls \\<and>\n                                     p \\<notin> set les \\<and>\n                                     p \\<notin> set grs \\<and>\n                                     distinct tls \\<and>\n                                     distinct les \\<and>\n                                     distinct grs \\<and>\n                                     set les \\<inter> set grs = {} \\<and>\n                                     set tls \\<inter>\n                                     (set les \\<union> set grs) =\n                                     {} \\<and>\n                                     (\\<forall>x\\<in>set les.\n   cont x \\<le> cont p) \\<and>\n                                     (\\<forall>x\\<in>set grs.\n   cont p < cont x)))) \\<and>\n                         (tl \\<notin> set Ps \\<longrightarrow> le = next tl)\n 2. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<not> cont tl \\<le> cont p \\<longrightarrow>\n                         (\\<exists>les.\n                             List le (nexta(tl := gt)) les \\<and>\n                             (\\<exists>grs.\n                                 (\\<exists>ps.\n                                     grs = tl # ps \\<and>\n                                     List gt (nexta(tl := gt)) ps) \\<and>\n                                 (\\<exists>tls.\n                                     List (nexta tl) (nexta(tl := gt))\ntls \\<and>\n                                     Ps <~~> p # tls @ les @ grs \\<and>\n                                     p \\<notin> set tls \\<and>\n                                     p \\<notin> set les \\<and>\n                                     p \\<notin> set grs \\<and>\n                                     distinct tls \\<and>\n                                     distinct les \\<and>\n                                     distinct grs \\<and>\n                                     set les \\<inter> set grs = {} \\<and>\n                                     set tls \\<inter>\n                                     (set les \\<union> set grs) =\n                                     {} \\<and>\n                                     (\\<forall>x\\<in>set les.\n   cont x \\<le> cont p) \\<and>\n                                     (\\<forall>x\\<in>set grs.\n   cont p < cont x)))) \\<and>\n                         (tl \\<notin> set Ps \\<longrightarrow> gt = next tl)\n 3. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply   clarify"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>les.\n                             (\\<exists>ps.\n                                 les = tl # ps \\<and>\n                                 List le (nexta(tl := le)) ps) \\<and>\n                             (\\<exists>grs.\n                                 List gt (nexta(tl := le)) grs \\<and>\n                                 (\\<exists>tls.\n                                     List (nexta tl) (nexta(tl := le))\ntls \\<and>\n                                     Ps <~~> p # tls @ les @ grs \\<and>\n                                     p \\<notin> set tls \\<and>\n                                     p \\<notin> set les \\<and>\n                                     p \\<notin> set grs \\<and>\n                                     distinct tls \\<and>\n                                     distinct les \\<and>\n                                     distinct grs \\<and>\n                                     set les \\<inter> set grs = {} \\<and>\n                                     set tls \\<inter>\n                                     (set les \\<union> set grs) =\n                                     {} \\<and>\n                                     (\\<forall>x\\<in>set les.\n   cont x \\<le> cont p) \\<and>\n                                     (\\<forall>x\\<in>set grs.\n   cont p < cont x)))) \\<and>\n                         (tl \\<notin> set Ps \\<longrightarrow> le = next tl)\n 2. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<not> cont tl \\<le> cont p \\<longrightarrow>\n                         (\\<exists>les.\n                             List le (nexta(tl := gt)) les \\<and>\n                             (\\<exists>grs.\n                                 (\\<exists>ps.\n                                     grs = tl # ps \\<and>\n                                     List gt (nexta(tl := gt)) ps) \\<and>\n                                 (\\<exists>tls.\n                                     List (nexta tl) (nexta(tl := gt))\ntls \\<and>\n                                     Ps <~~> p # tls @ les @ grs \\<and>\n                                     p \\<notin> set tls \\<and>\n                                     p \\<notin> set les \\<and>\n                                     p \\<notin> set grs \\<and>\n                                     distinct tls \\<and>\n                                     distinct les \\<and>\n                                     distinct grs \\<and>\n                                     set les \\<inter> set grs = {} \\<and>\n                                     set tls \\<inter>\n                                     (set les \\<union> set grs) =\n                                     {} \\<and>\n                                     (\\<forall>x\\<in>set les.\n   cont x \\<le> cont p) \\<and>\n                                     (\\<forall>x\\<in>set grs.\n   cont p < cont x)))) \\<and>\n                         (tl \\<notin> set Ps \\<longrightarrow> gt = next tl)\n 3. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply   (rule conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>les.\n                            (\\<exists>ps.\n                                les = tl # ps \\<and>\n                                List le (nexta(tl := le)) ps) \\<and>\n                            (\\<exists>grs.\n                                List gt (nexta(tl := le)) grs \\<and>\n                                (\\<exists>tls.\n                                    List (nexta tl) (nexta(tl := le))\n                                     tls \\<and>\n                                    Ps <~~> p # tls @ les @ grs \\<and>\n                                    p \\<notin> set tls \\<and>\n                                    p \\<notin> set les \\<and>\n                                    p \\<notin> set grs \\<and>\n                                    distinct tls \\<and>\n                                    distinct les \\<and>\n                                    distinct grs \\<and>\n                                    set les \\<inter> set grs = {} \\<and>\n                                    set tls \\<inter>\n                                    (set les \\<union> set grs) =\n                                    {} \\<and>\n                                    (\\<forall>x\\<in>set les.\n  cont x \\<le> cont p) \\<and>\n                                    (\\<forall>x\\<in>set grs.\n  cont p < cont x)))\n 2. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> tl \\<notin> set Ps \\<longrightarrow> le = next tl\n 3. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<not> cont tl \\<le> cont p \\<longrightarrow>\n                         (\\<exists>les.\n                             List le (nexta(tl := gt)) les \\<and>\n                             (\\<exists>grs.\n                                 (\\<exists>ps.\n                                     grs = tl # ps \\<and>\n                                     List gt (nexta(tl := gt)) ps) \\<and>\n                                 (\\<exists>tls.\n                                     List (nexta tl) (nexta(tl := gt))\ntls \\<and>\n                                     Ps <~~> p # tls @ les @ grs \\<and>\n                                     p \\<notin> set tls \\<and>\n                                     p \\<notin> set les \\<and>\n                                     p \\<notin> set grs \\<and>\n                                     distinct tls \\<and>\n                                     distinct les \\<and>\n                                     distinct grs \\<and>\n                                     set les \\<inter> set grs = {} \\<and>\n                                     set tls \\<inter>\n                                     (set les \\<union> set grs) =\n                                     {} \\<and>\n                                     (\\<forall>x\\<in>set les.\n   cont x \\<le> cont p) \\<and>\n                                     (\\<forall>x\\<in>set grs.\n   cont p < cont x)))) \\<and>\n                         (tl \\<notin> set Ps \\<longrightarrow> gt = next tl)\n 4. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply    (rule_tac x=\"tl#les\" in exI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ps.\n                             tl # les = tl # ps \\<and>\n                             List le (nexta(tl := le)) ps) \\<and>\n                         (\\<exists>grs.\n                             List gt (nexta(tl := le)) grs \\<and>\n                             (\\<exists>tls.\n                                 List (nexta tl) (nexta(tl := le))\n                                  tls \\<and>\n                                 Ps <~~> p # tls @ (tl # les) @ grs \\<and>\n                                 p \\<notin> set tls \\<and>\n                                 p \\<notin> set (tl # les) \\<and>\n                                 p \\<notin> set grs \\<and>\n                                 distinct tls \\<and>\n                                 distinct (tl # les) \\<and>\n                                 distinct grs \\<and>\n                                 set (tl # les) \\<inter> set grs = {} \\<and>\n                                 set tls \\<inter>\n                                 (set (tl # les) \\<union> set grs) =\n                                 {} \\<and>\n                                 (\\<forall>x\\<in>set (tl # les).\n                                     cont x \\<le> cont p) \\<and>\n                                 (\\<forall>x\\<in>set grs. cont p < cont x)))\n 2. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> tl \\<notin> set Ps \\<longrightarrow> le = next tl\n 3. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<not> cont tl \\<le> cont p \\<longrightarrow>\n                         (\\<exists>les.\n                             List le (nexta(tl := gt)) les \\<and>\n                             (\\<exists>grs.\n                                 (\\<exists>ps.\n                                     grs = tl # ps \\<and>\n                                     List gt (nexta(tl := gt)) ps) \\<and>\n                                 (\\<exists>tls.\n                                     List (nexta tl) (nexta(tl := gt))\ntls \\<and>\n                                     Ps <~~> p # tls @ les @ grs \\<and>\n                                     p \\<notin> set tls \\<and>\n                                     p \\<notin> set les \\<and>\n                                     p \\<notin> set grs \\<and>\n                                     distinct tls \\<and>\n                                     distinct les \\<and>\n                                     distinct grs \\<and>\n                                     set les \\<inter> set grs = {} \\<and>\n                                     set tls \\<inter>\n                                     (set les \\<union> set grs) =\n                                     {} \\<and>\n                                     (\\<forall>x\\<in>set les.\n   cont x \\<le> cont p) \\<and>\n                                     (\\<forall>x\\<in>set grs.\n   cont p < cont x)))) \\<and>\n                         (tl \\<notin> set Ps \\<longrightarrow> gt = next tl)\n 4. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply    simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>grs.\n                            List gt (nexta(tl := le)) grs \\<and>\n                            (\\<exists>tls.\n                                List (nexta tl) (nexta(tl := le)) tls \\<and>\n                                Ps <~~> p # tls @ tl # les @ grs \\<and>\n                                p \\<notin> set tls \\<and>\n                                p \\<notin> set grs \\<and>\n                                distinct tls \\<and>\n                                distinct grs \\<and>\n                                tl \\<notin> set grs \\<and>\n                                set les \\<inter> set grs = {} \\<and>\n                                tl \\<notin> set tls \\<and>\n                                set tls \\<inter>\n                                (set les \\<union> set grs) =\n                                {} \\<and>\n                                (\\<forall>x\\<in>set grs. cont p < cont x))\n 2. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> tl \\<notin> set Ps \\<longrightarrow> le = next tl\n 3. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<not> cont tl \\<le> cont p \\<longrightarrow>\n                         (\\<exists>les.\n                             List le (nexta(tl := gt)) les \\<and>\n                             (\\<exists>grs.\n                                 (\\<exists>ps.\n                                     grs = tl # ps \\<and>\n                                     List gt (nexta(tl := gt)) ps) \\<and>\n                                 (\\<exists>tls.\n                                     List (nexta tl) (nexta(tl := gt))\ntls \\<and>\n                                     Ps <~~> p # tls @ les @ grs \\<and>\n                                     p \\<notin> set tls \\<and>\n                                     p \\<notin> set les \\<and>\n                                     p \\<notin> set grs \\<and>\n                                     distinct tls \\<and>\n                                     distinct les \\<and>\n                                     distinct grs \\<and>\n                                     set les \\<inter> set grs = {} \\<and>\n                                     set tls \\<inter>\n                                     (set les \\<union> set grs) =\n                                     {} \\<and>\n                                     (\\<forall>x\\<in>set les.\n   cont x \\<le> cont p) \\<and>\n                                     (\\<forall>x\\<in>set grs.\n   cont p < cont x)))) \\<and>\n                         (tl \\<notin> set Ps \\<longrightarrow> gt = next tl)\n 4. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply    (rule_tac x=\"grs\" in exI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> List gt (nexta(tl := le)) grs \\<and>\n                         (\\<exists>tls.\n                             List (nexta tl) (nexta(tl := le)) tls \\<and>\n                             Ps <~~> p # tls @ tl # les @ grs \\<and>\n                             p \\<notin> set tls \\<and>\n                             p \\<notin> set grs \\<and>\n                             distinct tls \\<and>\n                             distinct grs \\<and>\n                             tl \\<notin> set grs \\<and>\n                             set les \\<inter> set grs = {} \\<and>\n                             tl \\<notin> set tls \\<and>\n                             set tls \\<inter> (set les \\<union> set grs) =\n                             {} \\<and>\n                             (\\<forall>x\\<in>set grs. cont p < cont x))\n 2. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> tl \\<notin> set Ps \\<longrightarrow> le = next tl\n 3. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<not> cont tl \\<le> cont p \\<longrightarrow>\n                         (\\<exists>les.\n                             List le (nexta(tl := gt)) les \\<and>\n                             (\\<exists>grs.\n                                 (\\<exists>ps.\n                                     grs = tl # ps \\<and>\n                                     List gt (nexta(tl := gt)) ps) \\<and>\n                                 (\\<exists>tls.\n                                     List (nexta tl) (nexta(tl := gt))\ntls \\<and>\n                                     Ps <~~> p # tls @ les @ grs \\<and>\n                                     p \\<notin> set tls \\<and>\n                                     p \\<notin> set les \\<and>\n                                     p \\<notin> set grs \\<and>\n                                     distinct tls \\<and>\n                                     distinct les \\<and>\n                                     distinct grs \\<and>\n                                     set les \\<inter> set grs = {} \\<and>\n                                     set tls \\<inter>\n                                     (set les \\<union> set grs) =\n                                     {} \\<and>\n                                     (\\<forall>x\\<in>set les.\n   cont x \\<le> cont p) \\<and>\n                                     (\\<forall>x\\<in>set grs.\n   cont p < cont x)))) \\<and>\n                         (tl \\<notin> set Ps \\<longrightarrow> gt = next tl)\n 4. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply    simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls.\n                            List (nexta tl) (nexta(tl := le)) tls \\<and>\n                            Ps <~~> p # tls @ tl # les @ grs \\<and>\n                            p \\<notin> set tls \\<and>\n                            distinct tls \\<and>\n                            tl \\<notin> set tls \\<and>\n                            set tls \\<inter> (set les \\<union> set grs) = {}\n 2. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> tl \\<notin> set Ps \\<longrightarrow> le = next tl\n 3. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<not> cont tl \\<le> cont p \\<longrightarrow>\n                         (\\<exists>les.\n                             List le (nexta(tl := gt)) les \\<and>\n                             (\\<exists>grs.\n                                 (\\<exists>ps.\n                                     grs = tl # ps \\<and>\n                                     List gt (nexta(tl := gt)) ps) \\<and>\n                                 (\\<exists>tls.\n                                     List (nexta tl) (nexta(tl := gt))\ntls \\<and>\n                                     Ps <~~> p # tls @ les @ grs \\<and>\n                                     p \\<notin> set tls \\<and>\n                                     p \\<notin> set les \\<and>\n                                     p \\<notin> set grs \\<and>\n                                     distinct tls \\<and>\n                                     distinct les \\<and>\n                                     distinct grs \\<and>\n                                     set les \\<inter> set grs = {} \\<and>\n                                     set tls \\<inter>\n                                     (set les \\<union> set grs) =\n                                     {} \\<and>\n                                     (\\<forall>x\\<in>set les.\n   cont x \\<le> cont p) \\<and>\n                                     (\\<forall>x\\<in>set grs.\n   cont p < cont x)))) \\<and>\n                         (tl \\<notin> set Ps \\<longrightarrow> gt = next tl)\n 4. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply    (rule_tac x=\"ps\" in exI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> List (nexta tl) (nexta(tl := le)) ps \\<and>\n                         Ps <~~> p # ps @ tl # les @ grs \\<and>\n                         p \\<notin> set ps \\<and>\n                         distinct ps \\<and>\n                         tl \\<notin> set ps \\<and>\n                         set ps \\<inter> (set les \\<union> set grs) = {}\n 2. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> tl \\<notin> set Ps \\<longrightarrow> le = next tl\n 3. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<not> cont tl \\<le> cont p \\<longrightarrow>\n                         (\\<exists>les.\n                             List le (nexta(tl := gt)) les \\<and>\n                             (\\<exists>grs.\n                                 (\\<exists>ps.\n                                     grs = tl # ps \\<and>\n                                     List gt (nexta(tl := gt)) ps) \\<and>\n                                 (\\<exists>tls.\n                                     List (nexta tl) (nexta(tl := gt))\ntls \\<and>\n                                     Ps <~~> p # tls @ les @ grs \\<and>\n                                     p \\<notin> set tls \\<and>\n                                     p \\<notin> set les \\<and>\n                                     p \\<notin> set grs \\<and>\n                                     distinct tls \\<and>\n                                     distinct les \\<and>\n                                     distinct grs \\<and>\n                                     set les \\<inter> set grs = {} \\<and>\n                                     set tls \\<inter>\n                                     (set les \\<union> set grs) =\n                                     {} \\<and>\n                                     (\\<forall>x\\<in>set les.\n   cont x \\<le> cont p) \\<and>\n                                     (\\<forall>x\\<in>set grs.\n   cont p < cont x)))) \\<and>\n                         (tl \\<notin> set Ps \\<longrightarrow> gt = next tl)\n 4. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply    simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> Ps <~~> p # ps @ tl # les @ grs\n 2. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> tl \\<notin> set Ps \\<longrightarrow> le = next tl\n 3. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<not> cont tl \\<le> cont p \\<longrightarrow>\n                         (\\<exists>les.\n                             List le (nexta(tl := gt)) les \\<and>\n                             (\\<exists>grs.\n                                 (\\<exists>ps.\n                                     grs = tl # ps \\<and>\n                                     List gt (nexta(tl := gt)) ps) \\<and>\n                                 (\\<exists>tls.\n                                     List (nexta tl) (nexta(tl := gt))\ntls \\<and>\n                                     Ps <~~> p # tls @ les @ grs \\<and>\n                                     p \\<notin> set tls \\<and>\n                                     p \\<notin> set les \\<and>\n                                     p \\<notin> set grs \\<and>\n                                     distinct tls \\<and>\n                                     distinct les \\<and>\n                                     distinct grs \\<and>\n                                     set les \\<inter> set grs = {} \\<and>\n                                     set tls \\<inter>\n                                     (set les \\<union> set grs) =\n                                     {} \\<and>\n                                     (\\<forall>x\\<in>set les.\n   cont x \\<le> cont p) \\<and>\n                                     (\\<forall>x\\<in>set grs.\n   cont p < cont x)))) \\<and>\n                         (tl \\<notin> set Ps \\<longrightarrow> gt = next tl)\n 4. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply    (erule perm.trans)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        List (nexta tl) nexta ps; p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> p # tl # ps @ les @ grs <~~>\n                         p # ps @ tl # les @ grs\n 2. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> tl \\<notin> set Ps \\<longrightarrow> le = next tl\n 3. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<not> cont tl \\<le> cont p \\<longrightarrow>\n                         (\\<exists>les.\n                             List le (nexta(tl := gt)) les \\<and>\n                             (\\<exists>grs.\n                                 (\\<exists>ps.\n                                     grs = tl # ps \\<and>\n                                     List gt (nexta(tl := gt)) ps) \\<and>\n                                 (\\<exists>tls.\n                                     List (nexta tl) (nexta(tl := gt))\ntls \\<and>\n                                     Ps <~~> p # tls @ les @ grs \\<and>\n                                     p \\<notin> set tls \\<and>\n                                     p \\<notin> set les \\<and>\n                                     p \\<notin> set grs \\<and>\n                                     distinct tls \\<and>\n                                     distinct les \\<and>\n                                     distinct grs \\<and>\n                                     set les \\<inter> set grs = {} \\<and>\n                                     set tls \\<inter>\n                                     (set les \\<union> set grs) =\n                                     {} \\<and>\n                                     (\\<forall>x\\<in>set les.\n   cont x \\<le> cont p) \\<and>\n                                     (\\<forall>x\\<in>set grs.\n   cont p < cont x)))) \\<and>\n                         (tl \\<notin> set Ps \\<longrightarrow> gt = next tl)\n 4. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply    simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        List (nexta tl) nexta ps; p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> tl # ps @ les @ grs <~~> ps @ tl # les @ grs\n 2. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> tl \\<notin> set Ps \\<longrightarrow> le = next tl\n 3. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<not> cont tl \\<le> cont p \\<longrightarrow>\n                         (\\<exists>les.\n                             List le (nexta(tl := gt)) les \\<and>\n                             (\\<exists>grs.\n                                 (\\<exists>ps.\n                                     grs = tl # ps \\<and>\n                                     List gt (nexta(tl := gt)) ps) \\<and>\n                                 (\\<exists>tls.\n                                     List (nexta tl) (nexta(tl := gt))\ntls \\<and>\n                                     Ps <~~> p # tls @ les @ grs \\<and>\n                                     p \\<notin> set tls \\<and>\n                                     p \\<notin> set les \\<and>\n                                     p \\<notin> set grs \\<and>\n                                     distinct tls \\<and>\n                                     distinct les \\<and>\n                                     distinct grs \\<and>\n                                     set les \\<inter> set grs = {} \\<and>\n                                     set tls \\<inter>\n                                     (set les \\<union> set grs) =\n                                     {} \\<and>\n                                     (\\<forall>x\\<in>set les.\n   cont x \\<le> cont p) \\<and>\n                                     (\\<forall>x\\<in>set grs.\n   cont p < cont x)))) \\<and>\n                         (tl \\<notin> set Ps \\<longrightarrow> gt = next tl)\n 4. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply    (simp add: perm_app_Cons_simps)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> tl \\<notin> set Ps \\<longrightarrow> le = next tl\n 2. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<not> cont tl \\<le> cont p \\<longrightarrow>\n                         (\\<exists>les.\n                             List le (nexta(tl := gt)) les \\<and>\n                             (\\<exists>grs.\n                                 (\\<exists>ps.\n                                     grs = tl # ps \\<and>\n                                     List gt (nexta(tl := gt)) ps) \\<and>\n                                 (\\<exists>tls.\n                                     List (nexta tl) (nexta(tl := gt))\ntls \\<and>\n                                     Ps <~~> p # tls @ les @ grs \\<and>\n                                     p \\<notin> set tls \\<and>\n                                     p \\<notin> set les \\<and>\n                                     p \\<notin> set grs \\<and>\n                                     distinct tls \\<and>\n                                     distinct les \\<and>\n                                     distinct grs \\<and>\n                                     set les \\<inter> set grs = {} \\<and>\n                                     set tls \\<inter>\n                                     (set les \\<union> set grs) =\n                                     {} \\<and>\n                                     (\\<forall>x\\<in>set les.\n   cont x \\<le> cont p) \\<and>\n                                     (\\<forall>x\\<in>set grs.\n   cont p < cont x)))) \\<and>\n                         (tl \\<notin> set Ps \\<longrightarrow> gt = next tl)\n 3. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply   (simp add: perm_set_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<not> cont tl \\<le> cont p \\<longrightarrow>\n                         (\\<exists>les.\n                             List le (nexta(tl := gt)) les \\<and>\n                             (\\<exists>grs.\n                                 (\\<exists>ps.\n                                     grs = tl # ps \\<and>\n                                     List gt (nexta(tl := gt)) ps) \\<and>\n                                 (\\<exists>tls.\n                                     List (nexta tl) (nexta(tl := gt))\ntls \\<and>\n                                     Ps <~~> p # tls @ les @ grs \\<and>\n                                     p \\<notin> set tls \\<and>\n                                     p \\<notin> set les \\<and>\n                                     p \\<notin> set grs \\<and>\n                                     distinct tls \\<and>\n                                     distinct les \\<and>\n                                     distinct grs \\<and>\n                                     set les \\<inter> set grs = {} \\<and>\n                                     set tls \\<inter>\n                                     (set les \\<union> set grs) =\n                                     {} \\<and>\n                                     (\\<forall>x\\<in>set les.\n   cont x \\<le> cont p) \\<and>\n                                     (\\<forall>x\\<in>set grs.\n   cont p < cont x)))) \\<and>\n                         (tl \\<notin> set Ps \\<longrightarrow> gt = next tl)\n 2. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply  clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        \\<not> cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>les.\n                             List le (nexta(tl := gt)) les \\<and>\n                             (\\<exists>grs.\n                                 (\\<exists>ps.\n                                     grs = tl # ps \\<and>\n                                     List gt (nexta(tl := gt)) ps) \\<and>\n                                 (\\<exists>tls.\n                                     List (nexta tl) (nexta(tl := gt))\ntls \\<and>\n                                     Ps <~~> p # tls @ les @ grs \\<and>\n                                     p \\<notin> set tls \\<and>\n                                     p \\<notin> set les \\<and>\n                                     p \\<notin> set grs \\<and>\n                                     distinct tls \\<and>\n                                     distinct les \\<and>\n                                     distinct grs \\<and>\n                                     set les \\<inter> set grs = {} \\<and>\n                                     set tls \\<inter>\n                                     (set les \\<union> set grs) =\n                                     {} \\<and>\n                                     (\\<forall>x\\<in>set les.\n   cont x \\<le> cont p) \\<and>\n                                     (\\<forall>x\\<in>set grs.\n   cont p < cont x)))) \\<and>\n                         (tl \\<notin> set Ps \\<longrightarrow> gt = next tl)\n 2. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply  (rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        \\<not> cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>les.\n                            List le (nexta(tl := gt)) les \\<and>\n                            (\\<exists>grs.\n                                (\\<exists>ps.\n                                    grs = tl # ps \\<and>\n                                    List gt (nexta(tl := gt)) ps) \\<and>\n                                (\\<exists>tls.\n                                    List (nexta tl) (nexta(tl := gt))\n                                     tls \\<and>\n                                    Ps <~~> p # tls @ les @ grs \\<and>\n                                    p \\<notin> set tls \\<and>\n                                    p \\<notin> set les \\<and>\n                                    p \\<notin> set grs \\<and>\n                                    distinct tls \\<and>\n                                    distinct les \\<and>\n                                    distinct grs \\<and>\n                                    set les \\<inter> set grs = {} \\<and>\n                                    set tls \\<inter>\n                                    (set les \\<union> set grs) =\n                                    {} \\<and>\n                                    (\\<forall>x\\<in>set les.\n  cont x \\<le> cont p) \\<and>\n                                    (\\<forall>x\\<in>set grs.\n  cont p < cont x)))\n 2. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        \\<not> cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> tl \\<notin> set Ps \\<longrightarrow> gt = next tl\n 3. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply   (rule_tac x=\"les\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        \\<not> cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> List le (nexta(tl := gt)) les \\<and>\n                         (\\<exists>grs.\n                             (\\<exists>ps.\n                                 grs = tl # ps \\<and>\n                                 List gt (nexta(tl := gt)) ps) \\<and>\n                             (\\<exists>tls.\n                                 List (nexta tl) (nexta(tl := gt))\n                                  tls \\<and>\n                                 Ps <~~> p # tls @ les @ grs \\<and>\n                                 p \\<notin> set tls \\<and>\n                                 p \\<notin> set les \\<and>\n                                 p \\<notin> set grs \\<and>\n                                 distinct tls \\<and>\n                                 distinct les \\<and>\n                                 distinct grs \\<and>\n                                 set les \\<inter> set grs = {} \\<and>\n                                 set tls \\<inter>\n                                 (set les \\<union> set grs) =\n                                 {} \\<and>\n                                 (\\<forall>x\\<in>set les.\n                                     cont x \\<le> cont p) \\<and>\n                                 (\\<forall>x\\<in>set grs. cont p < cont x)))\n 2. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        \\<not> cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> tl \\<notin> set Ps \\<longrightarrow> gt = next tl\n 3. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply   simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        \\<not> cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>grs.\n                            (\\<exists>ps.\n                                grs = tl # ps \\<and>\n                                List gt (nexta(tl := gt)) ps) \\<and>\n                            (\\<exists>tls.\n                                List (nexta tl) (nexta(tl := gt)) tls \\<and>\n                                Ps <~~> p # tls @ les @ grs \\<and>\n                                p \\<notin> set tls \\<and>\n                                p \\<notin> set grs \\<and>\n                                distinct tls \\<and>\n                                distinct grs \\<and>\n                                set les \\<inter> set grs = {} \\<and>\n                                set tls \\<inter>\n                                (set les \\<union> set grs) =\n                                {} \\<and>\n                                (\\<forall>x\\<in>set grs. cont p < cont x))\n 2. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        \\<not> cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> tl \\<notin> set Ps \\<longrightarrow> gt = next tl\n 3. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply   (rule_tac x=\"tl#grs\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        \\<not> cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>ps.\n                             tl # grs = tl # ps \\<and>\n                             List gt (nexta(tl := gt)) ps) \\<and>\n                         (\\<exists>tls.\n                             List (nexta tl) (nexta(tl := gt)) tls \\<and>\n                             Ps <~~> p # tls @ les @ tl # grs \\<and>\n                             p \\<notin> set tls \\<and>\n                             p \\<notin> set (tl # grs) \\<and>\n                             distinct tls \\<and>\n                             distinct (tl # grs) \\<and>\n                             set les \\<inter> set (tl # grs) = {} \\<and>\n                             set tls \\<inter>\n                             (set les \\<union> set (tl # grs)) =\n                             {} \\<and>\n                             (\\<forall>x\\<in>set (tl # grs).\n                                 cont p < cont x))\n 2. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        \\<not> cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> tl \\<notin> set Ps \\<longrightarrow> gt = next tl\n 3. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply   simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        \\<not> cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tls.\n                            List (nexta tl) (nexta(tl := gt)) tls \\<and>\n                            Ps <~~> p # tls @ les @ tl # grs \\<and>\n                            p \\<notin> set tls \\<and>\n                            distinct tls \\<and>\n                            tl \\<notin> set tls \\<and>\n                            set tls \\<inter> (set les \\<union> set grs) = {}\n 2. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        \\<not> cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> tl \\<notin> set Ps \\<longrightarrow> gt = next tl\n 3. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply   (rule_tac x=\"ps\" in exI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        \\<not> cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> List (nexta tl) (nexta(tl := gt)) ps \\<and>\n                         Ps <~~> p # ps @ les @ tl # grs \\<and>\n                         p \\<notin> set ps \\<and>\n                         distinct ps \\<and>\n                         tl \\<notin> set ps \\<and>\n                         set ps \\<inter> (set les \\<union> set grs) = {}\n 2. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        \\<not> cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> tl \\<notin> set Ps \\<longrightarrow> gt = next tl\n 3. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply   simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        \\<not> cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> Ps <~~> p # ps @ les @ tl # grs\n 2. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        \\<not> cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> tl \\<notin> set Ps \\<longrightarrow> gt = next tl\n 3. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply   (erule perm.trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        List (nexta tl) nexta ps; p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        \\<not> cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> p # tl # ps @ les @ grs <~~>\n                         p # ps @ les @ tl # grs\n 2. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        \\<not> cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> tl \\<notin> set Ps \\<longrightarrow> gt = next tl\n 3. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply   simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        List (nexta tl) nexta ps; p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        \\<not> cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> tl # ps @ les @ grs <~~> ps @ les @ tl # grs\n 2. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        \\<not> cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> tl \\<notin> set Ps \\<longrightarrow> gt = next tl\n 3. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply   (simp add: perm_app_Cons_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next cont p Ps nexta le gt tl les grs ps.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        tl \\<noteq> Null; List le nexta les; List gt nexta grs;\n        Ps <~~> p # tl # ps @ les @ grs; List (nexta tl) nexta ps;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; p \\<noteq> tl;\n        p \\<notin> set ps; tl \\<notin> set les; tl \\<notin> set grs;\n        set ps \\<inter> (set les \\<union> set grs) = {};\n        \\<not> cont tl \\<le> cont p\\<rbrakk>\n       \\<Longrightarrow> tl \\<notin> set Ps \\<longrightarrow> gt = next tl\n 2. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply  (simp add: perm_set_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>next cont p Ps nexta conta pa le gt tl.\n       \\<lbrakk>\\<exists>les grs tls.\n                   List le nexta les \\<and>\n                   List gt nexta grs \\<and>\n                   List tl nexta tls \\<and>\n                   Ps <~~> pa # tls @ les @ grs \\<and>\n                   distinct (pa # tls @ les @ grs) \\<and>\n                   (\\<forall>x\\<in>set les. conta x \\<le> conta pa) \\<and>\n                   (\\<forall>x\\<in>set grs. conta pa < conta x);\n        pa = p; conta = cont; List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        \\<not> tl \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List le nexta Psa \\<and>\n                            (\\<forall>nextb p.\n                                (\\<exists>sortedPs.\n                                    List p nextb sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map conta sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nextb x = nexta x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List gt nextb Psa \\<and>\n                                    (\\<forall>nexta pb.\n  (\\<exists>sortedPs.\n      List pb nexta sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map conta sortedPs) \\<and>\n      Psa <~~> sortedPs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Psa \\<longrightarrow>\n      nexta x = nextb x) \\<longrightarrow>\n  (\\<exists>Psa.\n      List p (nexta(pa := pb)) Psa \\<and>\n      (\\<exists>Qs.\n          List pa (nexta(pa := pb)) Qs \\<and>\n          set Psa \\<inter> set Qs = {} \\<and>\n          (\\<forall>nextb p.\n              List p nextb (Psa @ Qs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Psa \\<longrightarrow>\n                  nextb x = (nexta(pa := pb)) x) \\<longrightarrow>\n              (\\<exists>sortedPs.\n                  List p nextb sortedPs \\<and>\n                  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n                  Ps <~~> sortedPs) \\<and>\n              (\\<forall>x.\n                  x \\<notin> set Ps \\<longrightarrow>\n                  nextb x = next x)))))))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs);\n        les <~~> sortedPs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List gt nextb Psa \\<and>\n                            (\\<forall>nexta pb.\n                                (\\<exists>sortedPs.\n                                    List pb nexta sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map cont sortedPs) \\<and>\n                                    Psa <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Psa \\<longrightarrow>\n                                    nexta x = nextb x) \\<longrightarrow>\n                                (\\<exists>Psa.\n                                    List pa (nexta(p := pb)) Psa \\<and>\n                                    (\\<exists>Qs.\n  List p (nexta(p := pb)) Qs \\<and>\n  set Psa \\<inter> set Qs = {} \\<and>\n  (\\<forall>nextb pa.\n      List pa nextb (Psa @ Qs) \\<and>\n      (\\<forall>x.\n          (x = p \\<longrightarrow>\n           p \\<notin> set Psa \\<longrightarrow> nextb p = pb) \\<and>\n          (x \\<noteq> p \\<longrightarrow>\n           x \\<notin> set Psa \\<longrightarrow>\n           nextb x = nexta x)) \\<longrightarrow>\n      (\\<exists>sortedPs.\n          List pa nextb sortedPs \\<and>\n          Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n          Ps <~~> sortedPs) \\<and>\n      (\\<forall>x. x \\<notin> set Ps \\<longrightarrow> nextb x = next x)))))", "apply (rule_tac ?x=grs in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs);\n        les <~~> sortedPs\\<rbrakk>\n       \\<Longrightarrow> List gt nextb grs \\<and>\n                         (\\<forall>nexta pb.\n                             (\\<exists>sortedPs.\n                                 List pb nexta sortedPs \\<and>\n                                 Quicksort.sorted (\\<le>)\n                                  (map cont sortedPs) \\<and>\n                                 grs <~~> sortedPs) \\<and>\n                             (\\<forall>x.\n                                 x \\<notin> set grs \\<longrightarrow>\n                                 nexta x = nextb x) \\<longrightarrow>\n                             (\\<exists>Psa.\n                                 List pa (nexta(p := pb)) Psa \\<and>\n                                 (\\<exists>Qs.\n                                     List p (nexta(p := pb)) Qs \\<and>\n                                     set Psa \\<inter> set Qs = {} \\<and>\n                                     (\\<forall>nextb pa.\n   List pa nextb (Psa @ Qs) \\<and>\n   (\\<forall>x.\n       (x = p \\<longrightarrow>\n        p \\<notin> set Psa \\<longrightarrow> nextb p = pb) \\<and>\n       (x \\<noteq> p \\<longrightarrow>\n        x \\<notin> set Psa \\<longrightarrow>\n        nextb x = nexta x)) \\<longrightarrow>\n   (\\<exists>sortedPs.\n       List pa nextb sortedPs \\<and>\n       Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n       Ps <~~> sortedPs) \\<and>\n   (\\<forall>x. x \\<notin> set Ps \\<longrightarrow> nextb x = next x)))))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs);\n        les <~~> sortedPs\\<rbrakk>\n       \\<Longrightarrow> List gt nextb grs\n 2. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs);\n        les <~~> sortedPs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>nexta pb.\n                            (\\<exists>sortedPs.\n                                List pb nexta sortedPs \\<and>\n                                Quicksort.sorted (\\<le>)\n                                 (map cont sortedPs) \\<and>\n                                grs <~~> sortedPs) \\<and>\n                            (\\<forall>x.\n                                x \\<notin> set grs \\<longrightarrow>\n                                nexta x = nextb x) \\<longrightarrow>\n                            (\\<exists>Psa.\n                                List pa (nexta(p := pb)) Psa \\<and>\n                                (\\<exists>Qs.\n                                    List p (nexta(p := pb)) Qs \\<and>\n                                    set Psa \\<inter> set Qs = {} \\<and>\n                                    (\\<forall>nextb pa.\n  List pa nextb (Psa @ Qs) \\<and>\n  (\\<forall>x.\n      (x = p \\<longrightarrow>\n       p \\<notin> set Psa \\<longrightarrow> nextb p = pb) \\<and>\n      (x \\<noteq> p \\<longrightarrow>\n       x \\<notin> set Psa \\<longrightarrow>\n       nextb x = nexta x)) \\<longrightarrow>\n  (\\<exists>sortedPs.\n      List pa nextb sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n      Ps <~~> sortedPs) \\<and>\n  (\\<forall>x. x \\<notin> set Ps \\<longrightarrow> nextb x = next x))))", "apply  (erule heap_eq_ListI1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; Ps <~~> p # les @ grs; p \\<notin> set les;\n        p \\<notin> set grs; set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs);\n        les <~~> sortedPs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set grs. nextb x = nexta x\n 2. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs);\n        les <~~> sortedPs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>nexta pb.\n                            (\\<exists>sortedPs.\n                                List pb nexta sortedPs \\<and>\n                                Quicksort.sorted (\\<le>)\n                                 (map cont sortedPs) \\<and>\n                                grs <~~> sortedPs) \\<and>\n                            (\\<forall>x.\n                                x \\<notin> set grs \\<longrightarrow>\n                                nexta x = nextb x) \\<longrightarrow>\n                            (\\<exists>Psa.\n                                List pa (nexta(p := pb)) Psa \\<and>\n                                (\\<exists>Qs.\n                                    List p (nexta(p := pb)) Qs \\<and>\n                                    set Psa \\<inter> set Qs = {} \\<and>\n                                    (\\<forall>nextb pa.\n  List pa nextb (Psa @ Qs) \\<and>\n  (\\<forall>x.\n      (x = p \\<longrightarrow>\n       p \\<notin> set Psa \\<longrightarrow> nextb p = pb) \\<and>\n      (x \\<noteq> p \\<longrightarrow>\n       x \\<notin> set Psa \\<longrightarrow>\n       nextb x = nexta x)) \\<longrightarrow>\n  (\\<exists>sortedPs.\n      List pa nextb sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n      Ps <~~> sortedPs) \\<and>\n  (\\<forall>x. x \\<notin> set Ps \\<longrightarrow> nextb x = next x))))", "apply  clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs x.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; Ps <~~> p # les @ grs; p \\<notin> set les;\n        p \\<notin> set grs; set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        x \\<in> set grs\\<rbrakk>\n       \\<Longrightarrow> nextb x = nexta x\n 2. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs);\n        les <~~> sortedPs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>nexta pb.\n                            (\\<exists>sortedPs.\n                                List pb nexta sortedPs \\<and>\n                                Quicksort.sorted (\\<le>)\n                                 (map cont sortedPs) \\<and>\n                                grs <~~> sortedPs) \\<and>\n                            (\\<forall>x.\n                                x \\<notin> set grs \\<longrightarrow>\n                                nexta x = nextb x) \\<longrightarrow>\n                            (\\<exists>Psa.\n                                List pa (nexta(p := pb)) Psa \\<and>\n                                (\\<exists>Qs.\n                                    List p (nexta(p := pb)) Qs \\<and>\n                                    set Psa \\<inter> set Qs = {} \\<and>\n                                    (\\<forall>nextb pa.\n  List pa nextb (Psa @ Qs) \\<and>\n  (\\<forall>x.\n      (x = p \\<longrightarrow>\n       p \\<notin> set Psa \\<longrightarrow> nextb p = pb) \\<and>\n      (x \\<noteq> p \\<longrightarrow>\n       x \\<notin> set Psa \\<longrightarrow>\n       nextb x = nexta x)) \\<longrightarrow>\n  (\\<exists>sortedPs.\n      List pa nextb sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n      Ps <~~> sortedPs) \\<and>\n  (\\<forall>x. x \\<notin> set Ps \\<longrightarrow> nextb x = next x))))", "apply  (erule_tac x=x in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs x.\n       \\<lbrakk>List p next Ps; List le nexta les; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        x \\<in> set grs;\n        x \\<notin> set Ps \\<longrightarrow> nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> nextb x = nexta x\n 2. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs);\n        les <~~> sortedPs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>nexta pb.\n                            (\\<exists>sortedPs.\n                                List pb nexta sortedPs \\<and>\n                                Quicksort.sorted (\\<le>)\n                                 (map cont sortedPs) \\<and>\n                                grs <~~> sortedPs) \\<and>\n                            (\\<forall>x.\n                                x \\<notin> set grs \\<longrightarrow>\n                                nexta x = nextb x) \\<longrightarrow>\n                            (\\<exists>Psa.\n                                List pa (nexta(p := pb)) Psa \\<and>\n                                (\\<exists>Qs.\n                                    List p (nexta(p := pb)) Qs \\<and>\n                                    set Psa \\<inter> set Qs = {} \\<and>\n                                    (\\<forall>nextb pa.\n  List pa nextb (Psa @ Qs) \\<and>\n  (\\<forall>x.\n      (x = p \\<longrightarrow>\n       p \\<notin> set Psa \\<longrightarrow> nextb p = pb) \\<and>\n      (x \\<noteq> p \\<longrightarrow>\n       x \\<notin> set Psa \\<longrightarrow>\n       nextb x = nexta x)) \\<longrightarrow>\n  (\\<exists>sortedPs.\n      List pa nextb sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n      Ps <~~> sortedPs) \\<and>\n  (\\<forall>x. x \\<notin> set Ps \\<longrightarrow> nextb x = next x))))", "back"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs x.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; Ps <~~> p # les @ grs; p \\<notin> set les;\n        p \\<notin> set grs; set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        x \\<in> set grs;\n        x \\<notin> set les \\<longrightarrow> nextb x = nexta x\\<rbrakk>\n       \\<Longrightarrow> nextb x = nexta x\n 2. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs);\n        les <~~> sortedPs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>nexta pb.\n                            (\\<exists>sortedPs.\n                                List pb nexta sortedPs \\<and>\n                                Quicksort.sorted (\\<le>)\n                                 (map cont sortedPs) \\<and>\n                                grs <~~> sortedPs) \\<and>\n                            (\\<forall>x.\n                                x \\<notin> set grs \\<longrightarrow>\n                                nexta x = nextb x) \\<longrightarrow>\n                            (\\<exists>Psa.\n                                List pa (nexta(p := pb)) Psa \\<and>\n                                (\\<exists>Qs.\n                                    List p (nexta(p := pb)) Qs \\<and>\n                                    set Psa \\<inter> set Qs = {} \\<and>\n                                    (\\<forall>nextb pa.\n  List pa nextb (Psa @ Qs) \\<and>\n  (\\<forall>x.\n      (x = p \\<longrightarrow>\n       p \\<notin> set Psa \\<longrightarrow> nextb p = pb) \\<and>\n      (x \\<noteq> p \\<longrightarrow>\n       x \\<notin> set Psa \\<longrightarrow>\n       nextb x = nexta x)) \\<longrightarrow>\n  (\\<exists>sortedPs.\n      List pa nextb sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n      Ps <~~> sortedPs) \\<and>\n  (\\<forall>x. x \\<notin> set Ps \\<longrightarrow> nextb x = next x))))", "apply  blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs);\n        les <~~> sortedPs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>nexta pb.\n                            (\\<exists>sortedPs.\n                                List pb nexta sortedPs \\<and>\n                                Quicksort.sorted (\\<le>)\n                                 (map cont sortedPs) \\<and>\n                                grs <~~> sortedPs) \\<and>\n                            (\\<forall>x.\n                                x \\<notin> set grs \\<longrightarrow>\n                                nexta x = nextb x) \\<longrightarrow>\n                            (\\<exists>Psa.\n                                List pa (nexta(p := pb)) Psa \\<and>\n                                (\\<exists>Qs.\n                                    List p (nexta(p := pb)) Qs \\<and>\n                                    set Psa \\<inter> set Qs = {} \\<and>\n                                    (\\<forall>nextb pa.\n  List pa nextb (Psa @ Qs) \\<and>\n  (\\<forall>x.\n      (x = p \\<longrightarrow>\n       p \\<notin> set Psa \\<longrightarrow> nextb p = pb) \\<and>\n      (x \\<noteq> p \\<longrightarrow>\n       x \\<notin> set Psa \\<longrightarrow>\n       nextb x = nexta x)) \\<longrightarrow>\n  (\\<exists>sortedPs.\n      List pa nextb sortedPs \\<and>\n      Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n      Ps <~~> sortedPs) \\<and>\n  (\\<forall>x. x \\<notin> set Ps \\<longrightarrow> nextb x = next x))))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa);\n        grs <~~> sortedPsa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Psa.\n                            List pa (nextc(p := pb)) Psa \\<and>\n                            (\\<exists>Qs.\n                                List p (nextc(p := pb)) Qs \\<and>\n                                set Psa \\<inter> set Qs = {} \\<and>\n                                (\\<forall>nexta pa.\n                                    List pa nexta (Psa @ Qs) \\<and>\n                                    (\\<forall>x.\n  (x = p \\<longrightarrow>\n   p \\<notin> set Psa \\<longrightarrow> nexta p = pb) \\<and>\n  (x \\<noteq> p \\<longrightarrow>\n   x \\<notin> set Psa \\<longrightarrow>\n   nexta x = nextc x)) \\<longrightarrow>\n                                    (\\<exists>sortedPs.\n  List pa nexta sortedPs \\<and>\n  Quicksort.sorted (\\<le>) (map cont sortedPs) \\<and>\n  Ps <~~> sortedPs) \\<and>\n                                    (\\<forall>x.\n  x \\<notin> set Ps \\<longrightarrow> nexta x = next x)))", "apply (rule_tac x=\"sortedPs\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa);\n        grs <~~> sortedPsa\\<rbrakk>\n       \\<Longrightarrow> List pa (nextc(p := pb)) sortedPs \\<and>\n                         (\\<exists>Qs.\n                             List p (nextc(p := pb)) Qs \\<and>\n                             set sortedPs \\<inter> set Qs = {} \\<and>\n                             (\\<forall>nexta pa.\n                                 List pa nexta (sortedPs @ Qs) \\<and>\n                                 (\\<forall>x.\n                                     (x = p \\<longrightarrow>\np \\<notin> set sortedPs \\<longrightarrow> nexta p = pb) \\<and>\n                                     (x \\<noteq> p \\<longrightarrow>\nx \\<notin> set sortedPs \\<longrightarrow>\nnexta x = nextc x)) \\<longrightarrow>\n                                 (\\<exists>sortedPs.\n                                     List pa nexta sortedPs \\<and>\n                                     Quicksort.sorted (\\<le>)\n(map cont sortedPs) \\<and>\n                                     Ps <~~> sortedPs) \\<and>\n                                 (\\<forall>x.\n                                     x \\<notin> set Ps \\<longrightarrow>\n                                     nexta x = next x)))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa);\n        grs <~~> sortedPsa\\<rbrakk>\n       \\<Longrightarrow> List pa (nextc(p := pb)) sortedPs\n 2. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa);\n        grs <~~> sortedPsa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List p (nextc(p := pb)) Qs \\<and>\n                            set sortedPs \\<inter> set Qs = {} \\<and>\n                            (\\<forall>nexta pa.\n                                List pa nexta (sortedPs @ Qs) \\<and>\n                                (\\<forall>x.\n                                    (x = p \\<longrightarrow>\n                                     p \\<notin> set\n           sortedPs \\<longrightarrow>\n                                     nexta p = pb) \\<and>\n                                    (x \\<noteq> p \\<longrightarrow>\n                                     x \\<notin> set\n           sortedPs \\<longrightarrow>\n                                     nexta x = nextc x)) \\<longrightarrow>\n                                (\\<exists>sortedPs.\n                                    List pa nexta sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map cont sortedPs) \\<and>\n                                    Ps <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Ps \\<longrightarrow>\n                                    nexta x = next x))", "apply  (erule heap_eq_ListI1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa);\n        grs <~~> sortedPsa\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set sortedPs.\n                            (nextc(p := pb)) x = nextb x\n 2. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa);\n        grs <~~> sortedPsa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List p (nextc(p := pb)) Qs \\<and>\n                            set sortedPs \\<inter> set Qs = {} \\<and>\n                            (\\<forall>nexta pa.\n                                List pa nexta (sortedPs @ Qs) \\<and>\n                                (\\<forall>x.\n                                    (x = p \\<longrightarrow>\n                                     p \\<notin> set\n           sortedPs \\<longrightarrow>\n                                     nexta p = pb) \\<and>\n                                    (x \\<noteq> p \\<longrightarrow>\n                                     x \\<notin> set\n           sortedPs \\<longrightarrow>\n                                     nexta x = nextc x)) \\<longrightarrow>\n                                (\\<exists>sortedPs.\n                                    List pa nexta sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map cont sortedPs) \\<and>\n                                    Ps <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Ps \\<longrightarrow>\n                                    nexta x = next x))", "apply  (clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb sortedPs nextc pb\n       sortedPsa x.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa); grs <~~> sortedPsa;\n        x \\<in> set sortedPs\\<rbrakk>\n       \\<Longrightarrow> (x = p \\<longrightarrow> pb = nexta p) \\<and>\n                         (x \\<noteq> p \\<longrightarrow> nextc x = nextb x)\n 2. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa);\n        grs <~~> sortedPsa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List p (nextc(p := pb)) Qs \\<and>\n                            set sortedPs \\<inter> set Qs = {} \\<and>\n                            (\\<forall>nexta pa.\n                                List pa nexta (sortedPs @ Qs) \\<and>\n                                (\\<forall>x.\n                                    (x = p \\<longrightarrow>\n                                     p \\<notin> set\n           sortedPs \\<longrightarrow>\n                                     nexta p = pb) \\<and>\n                                    (x \\<noteq> p \\<longrightarrow>\n                                     x \\<notin> set\n           sortedPs \\<longrightarrow>\n                                     nexta x = nextc x)) \\<longrightarrow>\n                                (\\<exists>sortedPs.\n                                    List pa nexta sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map cont sortedPs) \\<and>\n                                    Ps <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Ps \\<longrightarrow>\n                                    nexta x = next x))", "apply  (erule_tac x=x in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb sortedPs nextc pb\n       sortedPsa x.\n       \\<lbrakk>List p next Ps; List le nexta les; List gt nexta grs;\n        Ps <~~> p # les @ grs; p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa); grs <~~> sortedPsa;\n        x \\<in> set sortedPs;\n        x \\<notin> set Ps \\<longrightarrow> nexta x = next x\\<rbrakk>\n       \\<Longrightarrow> (x = p \\<longrightarrow> pb = nexta p) \\<and>\n                         (x \\<noteq> p \\<longrightarrow> nextc x = nextb x)\n 2. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa);\n        grs <~~> sortedPsa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List p (nextc(p := pb)) Qs \\<and>\n                            set sortedPs \\<inter> set Qs = {} \\<and>\n                            (\\<forall>nexta pa.\n                                List pa nexta (sortedPs @ Qs) \\<and>\n                                (\\<forall>x.\n                                    (x = p \\<longrightarrow>\n                                     p \\<notin> set\n           sortedPs \\<longrightarrow>\n                                     nexta p = pb) \\<and>\n                                    (x \\<noteq> p \\<longrightarrow>\n                                     x \\<notin> set\n           sortedPs \\<longrightarrow>\n                                     nexta x = nextc x)) \\<longrightarrow>\n                                (\\<exists>sortedPs.\n                                    List pa nexta sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map cont sortedPs) \\<and>\n                                    Ps <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Ps \\<longrightarrow>\n                                    nexta x = next x))", "back"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb sortedPs nextc pb\n       sortedPsa x.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa); grs <~~> sortedPsa;\n        x \\<in> set sortedPs;\n        x \\<notin> set les \\<longrightarrow> nextb x = nexta x\\<rbrakk>\n       \\<Longrightarrow> (x = p \\<longrightarrow> pb = nexta p) \\<and>\n                         (x \\<noteq> p \\<longrightarrow> nextc x = nextb x)\n 2. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa);\n        grs <~~> sortedPsa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List p (nextc(p := pb)) Qs \\<and>\n                            set sortedPs \\<inter> set Qs = {} \\<and>\n                            (\\<forall>nexta pa.\n                                List pa nexta (sortedPs @ Qs) \\<and>\n                                (\\<forall>x.\n                                    (x = p \\<longrightarrow>\n                                     p \\<notin> set\n           sortedPs \\<longrightarrow>\n                                     nexta p = pb) \\<and>\n                                    (x \\<noteq> p \\<longrightarrow>\n                                     x \\<notin> set\n           sortedPs \\<longrightarrow>\n                                     nexta x = nextc x)) \\<longrightarrow>\n                                (\\<exists>sortedPs.\n                                    List pa nexta sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map cont sortedPs) \\<and>\n                                    Ps <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Ps \\<longrightarrow>\n                                    nexta x = next x))", "back"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb sortedPs nextc pb\n       sortedPsa x.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa); grs <~~> sortedPsa;\n        x \\<in> set sortedPs;\n        x \\<notin> set grs \\<longrightarrow> nextc x = nextb x\\<rbrakk>\n       \\<Longrightarrow> (x = p \\<longrightarrow> pb = nexta p) \\<and>\n                         (x \\<noteq> p \\<longrightarrow> nextc x = nextb x)\n 2. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa);\n        grs <~~> sortedPsa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List p (nextc(p := pb)) Qs \\<and>\n                            set sortedPs \\<inter> set Qs = {} \\<and>\n                            (\\<forall>nexta pa.\n                                List pa nexta (sortedPs @ Qs) \\<and>\n                                (\\<forall>x.\n                                    (x = p \\<longrightarrow>\n                                     p \\<notin> set\n           sortedPs \\<longrightarrow>\n                                     nexta p = pb) \\<and>\n                                    (x \\<noteq> p \\<longrightarrow>\n                                     x \\<notin> set\n           sortedPs \\<longrightarrow>\n                                     nexta x = nextc x)) \\<longrightarrow>\n                                (\\<exists>sortedPs.\n                                    List pa nexta sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map cont sortedPs) \\<and>\n                                    Ps <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Ps \\<longrightarrow>\n                                    nexta x = next x))", "apply  (fast dest!: perm_set_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa);\n        grs <~~> sortedPsa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qs.\n                            List p (nextc(p := pb)) Qs \\<and>\n                            set sortedPs \\<inter> set Qs = {} \\<and>\n                            (\\<forall>nexta pa.\n                                List pa nexta (sortedPs @ Qs) \\<and>\n                                (\\<forall>x.\n                                    (x = p \\<longrightarrow>\n                                     p \\<notin> set\n           sortedPs \\<longrightarrow>\n                                     nexta p = pb) \\<and>\n                                    (x \\<noteq> p \\<longrightarrow>\n                                     x \\<notin> set\n           sortedPs \\<longrightarrow>\n                                     nexta x = nextc x)) \\<longrightarrow>\n                                (\\<exists>sortedPs.\n                                    List pa nexta sortedPs \\<and>\n                                    Quicksort.sorted (\\<le>)\n                                     (map cont sortedPs) \\<and>\n                                    Ps <~~> sortedPs) \\<and>\n                                (\\<forall>x.\n                                    x \\<notin> set Ps \\<longrightarrow>\n                                    nexta x = next x))", "apply (rule_tac x=\"p#sortedPsa\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa);\n        grs <~~> sortedPsa\\<rbrakk>\n       \\<Longrightarrow> List p (nextc(p := pb)) (p # sortedPsa) \\<and>\n                         set sortedPs \\<inter> set (p # sortedPsa) =\n                         {} \\<and>\n                         (\\<forall>nexta pa.\n                             List pa nexta (sortedPs @ p # sortedPsa) \\<and>\n                             (\\<forall>x.\n                                 (x = p \\<longrightarrow>\n                                  p \\<notin> set sortedPs \\<longrightarrow>\n                                  nexta p = pb) \\<and>\n                                 (x \\<noteq> p \\<longrightarrow>\n                                  x \\<notin> set sortedPs \\<longrightarrow>\n                                  nexta x = nextc x)) \\<longrightarrow>\n                             (\\<exists>sortedPs.\n                                 List pa nexta sortedPs \\<and>\n                                 Quicksort.sorted (\\<le>)\n                                  (map cont sortedPs) \\<and>\n                                 Ps <~~> sortedPs) \\<and>\n                             (\\<forall>x.\n                                 x \\<notin> set Ps \\<longrightarrow>\n                                 nexta x = next x))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa);\n        grs <~~> sortedPsa\\<rbrakk>\n       \\<Longrightarrow> List p (nextc(p := pb)) (p # sortedPsa)\n 2. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa);\n        grs <~~> sortedPsa\\<rbrakk>\n       \\<Longrightarrow> set sortedPs \\<inter> set (p # sortedPsa) =\n                         {} \\<and>\n                         (\\<forall>nexta pa.\n                             List pa nexta (sortedPs @ p # sortedPsa) \\<and>\n                             (\\<forall>x.\n                                 (x = p \\<longrightarrow>\n                                  p \\<notin> set sortedPs \\<longrightarrow>\n                                  nexta p = pb) \\<and>\n                                 (x \\<noteq> p \\<longrightarrow>\n                                  x \\<notin> set sortedPs \\<longrightarrow>\n                                  nexta x = nextc x)) \\<longrightarrow>\n                             (\\<exists>sortedPs.\n                                 List pa nexta sortedPs \\<and>\n                                 Quicksort.sorted (\\<le>)\n                                  (map cont sortedPs) \\<and>\n                                 Ps <~~> sortedPs) \\<and>\n                             (\\<forall>x.\n                                 x \\<notin> set Ps \\<longrightarrow>\n                                 nexta x = next x))", "apply  (fastforce dest!: perm_set_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa);\n        grs <~~> sortedPsa\\<rbrakk>\n       \\<Longrightarrow> set sortedPs \\<inter> set (p # sortedPsa) =\n                         {} \\<and>\n                         (\\<forall>nexta pa.\n                             List pa nexta (sortedPs @ p # sortedPsa) \\<and>\n                             (\\<forall>x.\n                                 (x = p \\<longrightarrow>\n                                  p \\<notin> set sortedPs \\<longrightarrow>\n                                  nexta p = pb) \\<and>\n                                 (x \\<noteq> p \\<longrightarrow>\n                                  x \\<notin> set sortedPs \\<longrightarrow>\n                                  nexta x = nextc x)) \\<longrightarrow>\n                             (\\<exists>sortedPs.\n                                 List pa nexta sortedPs \\<and>\n                                 Quicksort.sorted (\\<le>)\n                                  (map cont sortedPs) \\<and>\n                                 Ps <~~> sortedPs) \\<and>\n                             (\\<forall>x.\n                                 x \\<notin> set Ps \\<longrightarrow>\n                                 nexta x = next x))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa);\n        grs <~~> sortedPsa\\<rbrakk>\n       \\<Longrightarrow> set sortedPs \\<inter> set (p # sortedPsa) = {}\n 2. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa);\n        grs <~~> sortedPsa\\<rbrakk>\n       \\<Longrightarrow> \\<forall>nexta pa.\n                            List pa nexta (sortedPs @ p # sortedPsa) \\<and>\n                            (\\<forall>x.\n                                (x = p \\<longrightarrow>\n                                 p \\<notin> set sortedPs \\<longrightarrow>\n                                 nexta p = pb) \\<and>\n                                (x \\<noteq> p \\<longrightarrow>\n                                 x \\<notin> set sortedPs \\<longrightarrow>\n                                 nexta x = nextc x)) \\<longrightarrow>\n                            (\\<exists>sortedPs.\n                                List pa nexta sortedPs \\<and>\n                                Quicksort.sorted (\\<le>)\n                                 (map cont sortedPs) \\<and>\n                                Ps <~~> sortedPs) \\<and>\n                            (\\<forall>x.\n                                x \\<notin> set Ps \\<longrightarrow>\n                                nexta x = next x)", "apply  (force dest!: perm_set_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa);\n        grs <~~> sortedPsa\\<rbrakk>\n       \\<Longrightarrow> \\<forall>nexta pa.\n                            List pa nexta (sortedPs @ p # sortedPsa) \\<and>\n                            (\\<forall>x.\n                                (x = p \\<longrightarrow>\n                                 p \\<notin> set sortedPs \\<longrightarrow>\n                                 nexta p = pb) \\<and>\n                                (x \\<noteq> p \\<longrightarrow>\n                                 x \\<notin> set sortedPs \\<longrightarrow>\n                                 nexta x = nextc x)) \\<longrightarrow>\n                            (\\<exists>sortedPs.\n                                List pa nexta sortedPs \\<and>\n                                Quicksort.sorted (\\<le>)\n                                 (map cont sortedPs) \\<and>\n                                Ps <~~> sortedPs) \\<and>\n                            (\\<forall>x.\n                                x \\<notin> set Ps \\<longrightarrow>\n                                nexta x = next x)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa nextd pc.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa); grs <~~> sortedPsa;\n        List pc nextd (sortedPs @ p # sortedPsa);\n        \\<forall>x.\n           (x = p \\<longrightarrow>\n            p \\<notin> set sortedPs \\<longrightarrow> nextd p = pb) \\<and>\n           (x \\<noteq> p \\<longrightarrow>\n            x \\<notin> set sortedPs \\<longrightarrow>\n            nextd x = nextc x)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>set sortedPsa.\n                             cont p \\<le> cont x) \\<and>\n                         (\\<forall>x\\<in>set sortedPs.\n                             cont x \\<le> cont p \\<and>\n                             (\\<forall>xa\\<in>set sortedPsa.\n                                 cont x \\<le> cont xa)) \\<and>\n                         Ps <~~> sortedPs @ p # sortedPsa \\<and>\n                         (\\<forall>x.\n                             x \\<notin> set Ps \\<longrightarrow>\n                             nextd x = next x)", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa nextd pc.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa); grs <~~> sortedPsa;\n        List pc nextd (sortedPs @ p # sortedPsa);\n        \\<forall>x.\n           (x = p \\<longrightarrow>\n            p \\<notin> set sortedPs \\<longrightarrow> nextd p = pb) \\<and>\n           (x \\<noteq> p \\<longrightarrow>\n            x \\<notin> set sortedPs \\<longrightarrow>\n            nextd x = nextc x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set sortedPsa. cont p \\<le> cont x\n 2. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa nextd pc.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa); grs <~~> sortedPsa;\n        List pc nextd (sortedPs @ p # sortedPsa);\n        \\<forall>x.\n           (x = p \\<longrightarrow>\n            p \\<notin> set sortedPs \\<longrightarrow> nextd p = pb) \\<and>\n           (x \\<noteq> p \\<longrightarrow>\n            x \\<notin> set sortedPs \\<longrightarrow>\n            nextd x = nextc x)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>set sortedPs.\n                             cont x \\<le> cont p \\<and>\n                             (\\<forall>xa\\<in>set sortedPsa.\n                                 cont x \\<le> cont xa)) \\<and>\n                         Ps <~~> sortedPs @ p # sortedPsa \\<and>\n                         (\\<forall>x.\n                             x \\<notin> set Ps \\<longrightarrow>\n                             nextd x = next x)", "apply  (fastforce dest!: perm_set_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa nextd pc.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa); grs <~~> sortedPsa;\n        List pc nextd (sortedPs @ p # sortedPsa);\n        \\<forall>x.\n           (x = p \\<longrightarrow>\n            p \\<notin> set sortedPs \\<longrightarrow> nextd p = pb) \\<and>\n           (x \\<noteq> p \\<longrightarrow>\n            x \\<notin> set sortedPs \\<longrightarrow>\n            nextd x = nextc x)\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>set sortedPs.\n                             cont x \\<le> cont p \\<and>\n                             (\\<forall>xa\\<in>set sortedPsa.\n                                 cont x \\<le> cont xa)) \\<and>\n                         Ps <~~> sortedPs @ p # sortedPsa \\<and>\n                         (\\<forall>x.\n                             x \\<notin> set Ps \\<longrightarrow>\n                             nextd x = next x)", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa nextd pc.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa); grs <~~> sortedPsa;\n        List pc nextd (sortedPs @ p # sortedPsa);\n        \\<forall>x.\n           (x = p \\<longrightarrow>\n            p \\<notin> set sortedPs \\<longrightarrow> nextd p = pb) \\<and>\n           (x \\<noteq> p \\<longrightarrow>\n            x \\<notin> set sortedPs \\<longrightarrow>\n            nextd x = nextc x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set sortedPs.\n                            cont x \\<le> cont p \\<and>\n                            (\\<forall>xa\\<in>set sortedPsa.\n                                cont x \\<le> cont xa)\n 2. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa nextd pc.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa); grs <~~> sortedPsa;\n        List pc nextd (sortedPs @ p # sortedPsa);\n        \\<forall>x.\n           (x = p \\<longrightarrow>\n            p \\<notin> set sortedPs \\<longrightarrow> nextd p = pb) \\<and>\n           (x \\<noteq> p \\<longrightarrow>\n            x \\<notin> set sortedPs \\<longrightarrow>\n            nextd x = nextc x)\\<rbrakk>\n       \\<Longrightarrow> Ps <~~> sortedPs @ p # sortedPsa \\<and>\n                         (\\<forall>x.\n                             x \\<notin> set Ps \\<longrightarrow>\n                             nextd x = next x)", "apply  (fastforce dest!: perm_set_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa nextd pc.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa); grs <~~> sortedPsa;\n        List pc nextd (sortedPs @ p # sortedPsa);\n        \\<forall>x.\n           (x = p \\<longrightarrow>\n            p \\<notin> set sortedPs \\<longrightarrow> nextd p = pb) \\<and>\n           (x \\<noteq> p \\<longrightarrow>\n            x \\<notin> set sortedPs \\<longrightarrow>\n            nextd x = nextc x)\\<rbrakk>\n       \\<Longrightarrow> Ps <~~> sortedPs @ p # sortedPsa \\<and>\n                         (\\<forall>x.\n                             x \\<notin> set Ps \\<longrightarrow>\n                             nextd x = next x)", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa nextd pc.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa); grs <~~> sortedPsa;\n        List pc nextd (sortedPs @ p # sortedPsa);\n        \\<forall>x.\n           (x = p \\<longrightarrow>\n            p \\<notin> set sortedPs \\<longrightarrow> nextd p = pb) \\<and>\n           (x \\<noteq> p \\<longrightarrow>\n            x \\<notin> set sortedPs \\<longrightarrow>\n            nextd x = nextc x)\\<rbrakk>\n       \\<Longrightarrow> Ps <~~> sortedPs @ p # sortedPsa\n 2. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa nextd pc.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa); grs <~~> sortedPsa;\n        List pc nextd (sortedPs @ p # sortedPsa);\n        \\<forall>x.\n           (x = p \\<longrightarrow>\n            p \\<notin> set sortedPs \\<longrightarrow> nextd p = pb) \\<and>\n           (x \\<noteq> p \\<longrightarrow>\n            x \\<notin> set sortedPs \\<longrightarrow>\n            nextd x = nextc x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            x \\<notin> set Ps \\<longrightarrow>\n                            nextd x = next x", "apply  (erule perm.trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa nextd pc.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; p \\<notin> set les;\n        p \\<notin> set grs; set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa); grs <~~> sortedPsa;\n        List pc nextd (sortedPs @ p # sortedPsa);\n        \\<forall>x.\n           (x = p \\<longrightarrow>\n            p \\<notin> set sortedPs \\<longrightarrow> nextd p = pb) \\<and>\n           (x \\<noteq> p \\<longrightarrow>\n            x \\<notin> set sortedPs \\<longrightarrow>\n            nextd x = nextc x)\\<rbrakk>\n       \\<Longrightarrow> p # les @ grs <~~> sortedPs @ p # sortedPsa\n 2. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa nextd pc.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa); grs <~~> sortedPsa;\n        List pc nextd (sortedPs @ p # sortedPsa);\n        \\<forall>x.\n           (x = p \\<longrightarrow>\n            p \\<notin> set sortedPs \\<longrightarrow> nextd p = pb) \\<and>\n           (x \\<noteq> p \\<longrightarrow>\n            x \\<notin> set sortedPs \\<longrightarrow>\n            nextd x = nextc x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            x \\<notin> set Ps \\<longrightarrow>\n                            nextd x = next x", "apply  (simp add:  perm_app_Cons_simps list_all_iff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa nextd pc.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; p \\<notin> set les;\n        p \\<notin> set grs; set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa); grs <~~> sortedPsa;\n        List pc nextd (sortedPs @ p # sortedPsa);\n        \\<forall>x.\n           (x = p \\<longrightarrow>\n            p \\<notin> set sortedPs \\<longrightarrow> nextd p = pb) \\<and>\n           (x \\<noteq> p \\<longrightarrow>\n            x \\<notin> set sortedPs \\<longrightarrow>\n            nextd x = nextc x)\\<rbrakk>\n       \\<Longrightarrow> les @ p # grs <~~> sortedPs @ p # sortedPsa\n 2. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa nextd pc.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa); grs <~~> sortedPsa;\n        List pc nextd (sortedPs @ p # sortedPsa);\n        \\<forall>x.\n           (x = p \\<longrightarrow>\n            p \\<notin> set sortedPs \\<longrightarrow> nextd p = pb) \\<and>\n           (x \\<noteq> p \\<longrightarrow>\n            x \\<notin> set sortedPs \\<longrightarrow>\n            nextd x = nextc x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            x \\<notin> set Ps \\<longrightarrow>\n                            nextd x = next x", "apply  (fastforce intro!: perm_append_blocks)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa nextd pc.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa); grs <~~> sortedPsa;\n        List pc nextd (sortedPs @ p # sortedPsa);\n        \\<forall>x.\n           (x = p \\<longrightarrow>\n            p \\<notin> set sortedPs \\<longrightarrow> nextd p = pb) \\<and>\n           (x \\<noteq> p \\<longrightarrow>\n            x \\<notin> set sortedPs \\<longrightarrow>\n            nextd x = nextc x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            x \\<notin> set Ps \\<longrightarrow>\n                            nextd x = next x", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa nextd pc x.\n       \\<lbrakk>List p next Ps;\n        \\<forall>x. x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        List le nexta les; List gt nexta grs; Ps <~~> p # les @ grs;\n        p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x;\n        \\<forall>x. x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        \\<forall>x. x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa); grs <~~> sortedPsa;\n        List pc nextd (sortedPs @ p # sortedPsa);\n        \\<forall>x.\n           (x = p \\<longrightarrow>\n            p \\<notin> set sortedPs \\<longrightarrow> nextd p = pb) \\<and>\n           (x \\<noteq> p \\<longrightarrow>\n            x \\<notin> set sortedPs \\<longrightarrow> nextd x = nextc x);\n        x \\<notin> set Ps\\<rbrakk>\n       \\<Longrightarrow> nextd x = next x", "apply (erule_tac x=x in allE)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>next cont p Ps nexta le gt les grs nextb pa sortedPs nextc pb\n       sortedPsa nextd pc x.\n       \\<lbrakk>List p next Ps; List le nexta les; List gt nexta grs;\n        Ps <~~> p # les @ grs; p \\<notin> set les; p \\<notin> set grs;\n        set les \\<inter> set grs = {};\n        \\<forall>x\\<in>set les. cont x \\<le> cont p;\n        \\<forall>x\\<in>set grs. cont p < cont x; List pa nextb sortedPs;\n        Quicksort.sorted (\\<le>) (map cont sortedPs); les <~~> sortedPs;\n        List pb nextc sortedPsa;\n        Quicksort.sorted (\\<le>) (map cont sortedPsa); grs <~~> sortedPsa;\n        List pc nextd (sortedPs @ p # sortedPsa); x \\<notin> set Ps;\n        x \\<notin> set Ps \\<longrightarrow> nexta x = next x;\n        x \\<notin> set les \\<longrightarrow> nextb x = nexta x;\n        x \\<notin> set grs \\<longrightarrow> nextc x = nextb x;\n        (x = p \\<longrightarrow>\n         p \\<notin> set sortedPs \\<longrightarrow> nextd p = pb) \\<and>\n        (x \\<noteq> p \\<longrightarrow>\n         x \\<notin> set sortedPs \\<longrightarrow>\n         nextd x = nextc x)\\<rbrakk>\n       \\<Longrightarrow> nextd x = next x", "apply (force dest!: perm_set_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}