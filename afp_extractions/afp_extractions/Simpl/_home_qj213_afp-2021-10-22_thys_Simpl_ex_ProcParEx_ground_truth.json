{"file_name": "/home/qj213/afp-2021-10-22/thys/Simpl/ex/ProcParEx.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Simpl", "problem_names": ["lemma DynProcProcPar':\n assumes adapt: \"P \\<subseteq> {s. p s = q \\<and>\n         (\\<exists>Z. init s \\<in> P' Z \\<and>\n              (\\<forall>t \\<in> Q' Z. return s t \\<in> R s t) \\<and>\n              (\\<forall>t \\<in> A' Z. return s t \\<in> A))}\"\n assumes result: \"\\<forall>s t. \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F \\<^esub>(R s t) result s t Q,A\"\n assumes q: \"\\<forall>Z. \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F \\<^esub>(P' Z) Call q (Q' Z),(A' Z)\"\n shows \"\\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F \\<^esub>P dynCall init p return result Q,A\"", "lemma conseq_exploit_pre':\n             \"\\<lbrakk>\\<forall>s \\<in> S. \\<Gamma>,\\<Theta> \\<turnstile> ({s} \\<inter> P) c Q,A\\<rbrakk>\n              \\<Longrightarrow>\n              \\<Gamma>,\\<Theta>\\<turnstile> (P \\<inter> S)c Q,A\"", "lemma conseq_exploit_pre'':\n             \"\\<lbrakk>\\<forall>Z. \\<forall>s \\<in> S Z.  \\<Gamma>,\\<Theta> \\<turnstile> ({s} \\<inter> P Z) c (Q Z),(A Z)\\<rbrakk>\n              \\<Longrightarrow>\n              \\<forall>Z. \\<Gamma>,\\<Theta>\\<turnstile> (P Z \\<inter> S Z)c (Q Z),(A Z)\"", "lemma conseq_exploit_pre''':\n             \"\\<lbrakk>\\<forall>s \\<in> S. \\<forall>Z. \\<Gamma>,\\<Theta> \\<turnstile> ({s} \\<inter> P Z) c (Q Z),(A Z)\\<rbrakk>\n              \\<Longrightarrow>\n              \\<forall>Z. \\<Gamma>,\\<Theta>\\<turnstile> (P Z \\<inter> S)c (Q Z),(A Z)\"", "lemma (in Max_impl ) Max_spec1:\nshows\n\"\\<forall>\\<sigma> leq. \\<Gamma>\\<turnstile>\n  ({\\<sigma>} \\<inter> \\<lbrace> (\\<forall>\\<tau>. \\<Gamma>\\<turnstile>{\\<tau>} \\<acute>b :== PROC \\<acute>compare(\\<acute>n,\\<acute>m) \\<lbrace>\\<acute>b = (leq \\<^bsup>\\<tau>\\<^esup>n \\<^bsup>\\<tau>\\<^esup>m)\\<rbrace>) \\<and>\n      (\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>b :== PROC \\<acute>compare(\\<acute>n,\\<acute>m) {t. t may_only_modify_globals \\<tau> in []})\\<rbrace>)\n    \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\\<acute>m)\n  \\<lbrace>\\<acute>k = mx leq \\<^bsup>\\<sigma>\\<^esup>n \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>\"", "lemma (in Max_impl) Max_spec2:\nshows\n\"\\<forall>\\<sigma> leq. \\<Gamma>\\<turnstile>\n  ({\\<sigma>} \\<inter> \\<lbrace>(\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>b :== PROC \\<acute>compare(\\<acute>n,\\<acute>m) \\<lbrace>\\<acute>b = (leq \\<^bsup>\\<tau>\\<^esup>n \\<^bsup>\\<tau>\\<^esup>m)\\<rbrace>) \\<and>\n      (\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>b :== PROC \\<acute>compare(\\<acute>n,\\<acute>m) {t. t may_only_modify_globals \\<tau> in []})\\<rbrace>)\n    \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\\<acute>m)\n  \\<lbrace>\\<acute>k = mx leq \\<^bsup>\\<sigma>\\<^esup>n \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>\"", "lemma (in Max_impl) Max_spec3:\nshows\n\"\\<forall>n m leq. \\<Gamma>\\<turnstile>\n  (\\<lbrace>\\<acute>n=n \\<and> \\<acute>m=m\\<rbrace>  \\<inter>\n   \\<lbrace>(\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>b :== PROC \\<acute>compare(\\<acute>n,\\<acute>m) \\<lbrace>\\<acute>b = (leq \\<^bsup>\\<tau>\\<^esup>n \\<^bsup>\\<tau>\\<^esup>m)\\<rbrace>) \\<and>\n     (\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>b :== PROC \\<acute>compare(\\<acute>n,\\<acute>m) {t. t may_only_modify_globals \\<tau> in []})\\<rbrace>)\n    \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\\<acute>m)\n  \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>\"", "lemma (in Max_impl) Max_spec4:\nshows\n\"\\<forall>n m leq. \\<Gamma>\\<turnstile>\n  (\\<lbrace>\\<acute>n=n \\<and> \\<acute>m=m\\<rbrace> \\<inter> \\<lbrace>\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>b :== PROC \\<acute>compare(\\<acute>n,\\<acute>m) \\<lbrace>\\<acute>b = (leq \\<^bsup>\\<tau>\\<^esup>n \\<^bsup>\\<tau>\\<^esup>m)\\<rbrace>\\<rbrace>)\n    \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\\<acute>m)\n  \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>\"", "lemma (in Max_test)\n\n  shows\n  \"\\<Gamma>\\<turnstile> {\\<sigma>} \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m) \\<lbrace>\\<acute>k = mx (\\<le>) \\<^bsup>\\<sigma>\\<^esup>n \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>\"", "lemma (in Max_impl) Max_spec5:\nshows\n\"\\<forall>n m leq. \\<Gamma>\\<turnstile>\n  (\\<lbrace>\\<acute>n=n \\<and> \\<acute>m=m\\<rbrace> \\<inter> \\<lbrace>\\<forall>n' m'. \\<Gamma>\\<turnstile> \\<lbrace>\\<acute>n=n' \\<and> \\<acute>m=m'\\<rbrace> \\<acute>b :== PROC \\<acute>compare(\\<acute>n,\\<acute>m) \\<lbrace>\\<acute>b = (leq n' m')\\<rbrace>\\<rbrace>)\n    \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\\<acute>m)\n  \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>\"", "lemma (in LEQ_impl)\n LEQ_spec: \"\\<forall>n m. \\<Gamma>\\<turnstile> \\<lbrace>\\<acute>n=n \\<and> \\<acute>m=m\\<rbrace>  PROC LEQ(\\<acute>n,\\<acute>m,\\<acute>b) \\<lbrace>\\<acute>b = (n \\<le> m)\\<rbrace>\"", "lemma (in Max_test')\n  shows\n  \"\\<forall>n m. \\<Gamma>\\<turnstile> \\<lbrace>\\<acute>n=n \\<and> \\<acute>m=m\\<rbrace> \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m) \\<lbrace>\\<acute>k = mx (\\<le>) n m\\<rbrace>\""], "translations": [["", "lemma DynProcProcPar':\n assumes adapt: \"P \\<subseteq> {s. p s = q \\<and>\n         (\\<exists>Z. init s \\<in> P' Z \\<and>\n              (\\<forall>t \\<in> Q' Z. return s t \\<in> R s t) \\<and>\n              (\\<forall>t \\<in> A' Z. return s t \\<in> A))}\"\n assumes result: \"\\<forall>s t. \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F \\<^esub>(R s t) result s t Q,A\"\n assumes q: \"\\<forall>Z. \\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F \\<^esub>(P' Z) Call q (Q' Z),(A' Z)\"\n shows \"\\<Gamma>,\\<Theta>\\<turnstile>\\<^bsub>/F \\<^esub>P dynCall init p return result Q,A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>,\\<Theta>\n       \\<turnstile>\\<^bsub>/F \\<^esub>P dynCall init p return result Q,A", "apply (rule HoarePartial.DynProcProcPar [OF _ result q])"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<subseteq> {s. p s = q \\<and>\n                      (\\<exists>Z.\n                          init s \\<in> P' Z \\<and>\n                          (\\<forall>\\<tau>.\n                              \\<tau> \\<in> Q' Z \\<longrightarrow>\n                              return s \\<tau> \\<in> R s \\<tau>) \\<and>\n                          (\\<forall>\\<tau>.\n                              \\<tau> \\<in> A' Z \\<longrightarrow>\n                              return s \\<tau> \\<in> A))}", "apply (insert adapt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<subseteq> {s. p s = q \\<and>\n                      (\\<exists>Z.\n                          init s \\<in> P' Z \\<and>\n                          (\\<forall>t\\<in>Q' Z.\n                              return s t \\<in> R s t) \\<and>\n                          (\\<forall>t\\<in>A' Z.\n                              return s t \\<in> A))} \\<Longrightarrow>\n    P \\<subseteq> {s. p s = q \\<and>\n                      (\\<exists>Z.\n                          init s \\<in> P' Z \\<and>\n                          (\\<forall>\\<tau>.\n                              \\<tau> \\<in> Q' Z \\<longrightarrow>\n                              return s \\<tau> \\<in> R s \\<tau>) \\<and>\n                          (\\<forall>\\<tau>.\n                              \\<tau> \\<in> A' Z \\<longrightarrow>\n                              return s \\<tau> \\<in> A))}", "apply fast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma conseq_exploit_pre':\n             \"\\<lbrakk>\\<forall>s \\<in> S. \\<Gamma>,\\<Theta> \\<turnstile> ({s} \\<inter> P) c Q,A\\<rbrakk>\n              \\<Longrightarrow>\n              \\<Gamma>,\\<Theta>\\<turnstile> (P \\<inter> S)c Q,A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S.\n       \\<Gamma>,\\<Theta>\n          \\<turnstile> ({s} \\<inter> P) c Q,A \\<Longrightarrow>\n    \\<Gamma>,\\<Theta>\\<turnstile> (P \\<inter> S) c Q,A", "apply (rule HoarePartialDef.Conseq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S.\n       \\<Gamma>,\\<Theta>\n          \\<turnstile> ({s} \\<inter> P) c Q,A \\<Longrightarrow>\n    \\<forall>s\\<in>P \\<inter> S.\n       \\<exists>P' Q' A'.\n          \\<Gamma>,\\<Theta>\\<turnstile> P' c Q',A' \\<and>\n          s \\<in> P' \\<and> Q' \\<subseteq> Q \\<and> A' \\<subseteq> A", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<forall>s\\<in>S.\n                   \\<Gamma>,\\<Theta>\\<turnstile> ({s} \\<inter> P) c Q,A;\n        s \\<in> P; s \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P' Q' A'.\n                            \\<Gamma>,\\<Theta>\\<turnstile> P' c Q',A' \\<and>\n                            s \\<in> P' \\<and>\n                            Q' \\<subseteq> Q \\<and> A' \\<subseteq> A", "by (metis IntI insertI1 subset_refl)"], ["", "lemma conseq_exploit_pre'':\n             \"\\<lbrakk>\\<forall>Z. \\<forall>s \\<in> S Z.  \\<Gamma>,\\<Theta> \\<turnstile> ({s} \\<inter> P Z) c (Q Z),(A Z)\\<rbrakk>\n              \\<Longrightarrow>\n              \\<forall>Z. \\<Gamma>,\\<Theta>\\<turnstile> (P Z \\<inter> S Z)c (Q Z),(A Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Z.\n       \\<forall>s\\<in>S Z.\n          \\<Gamma>,\\<Theta>\n             \\<turnstile> ({s} \\<inter> P Z) c (Q Z),(A Z) \\<Longrightarrow>\n    \\<forall>Z.\n       \\<Gamma>,\\<Theta>\\<turnstile> (P Z \\<inter> S Z) c (Q Z),(A Z)", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Z.\n       \\<forall>Z.\n          \\<forall>s\\<in>S Z.\n             \\<Gamma>,\\<Theta>\n                \\<turnstile> ({s} \\<inter> P Z) c (Q Z),\n                             (A Z) \\<Longrightarrow>\n       \\<Gamma>,\\<Theta>\\<turnstile> (P Z \\<inter> S Z) c (Q Z),(A Z)", "apply (rule conseq_exploit_pre')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Z.\n       \\<forall>Z.\n          \\<forall>s\\<in>S Z.\n             \\<Gamma>,\\<Theta>\n                \\<turnstile> ({s} \\<inter> P Z) c (Q Z),\n                             (A Z) \\<Longrightarrow>\n       \\<forall>s\\<in>S Z.\n          \\<Gamma>,\\<Theta>\\<turnstile> ({s} \\<inter> P Z) c (Q Z),(A Z)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma conseq_exploit_pre''':\n             \"\\<lbrakk>\\<forall>s \\<in> S. \\<forall>Z. \\<Gamma>,\\<Theta> \\<turnstile> ({s} \\<inter> P Z) c (Q Z),(A Z)\\<rbrakk>\n              \\<Longrightarrow>\n              \\<forall>Z. \\<Gamma>,\\<Theta>\\<turnstile> (P Z \\<inter> S)c (Q Z),(A Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>S.\n       \\<forall>Z.\n          \\<Gamma>,\\<Theta>\n             \\<turnstile> ({s} \\<inter> P Z) c (Q Z),(A Z) \\<Longrightarrow>\n    \\<forall>Z. \\<Gamma>,\\<Theta>\\<turnstile> (P Z \\<inter> S) c (Q Z),(A Z)", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Z.\n       \\<forall>s\\<in>S.\n          \\<forall>Z.\n             \\<Gamma>,\\<Theta>\n                \\<turnstile> ({s} \\<inter> P Z) c (Q Z),\n                             (A Z) \\<Longrightarrow>\n       \\<Gamma>,\\<Theta>\\<turnstile> (P Z \\<inter> S) c (Q Z),(A Z)", "apply (rule conseq_exploit_pre')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Z.\n       \\<forall>s\\<in>S.\n          \\<forall>Z.\n             \\<Gamma>,\\<Theta>\n                \\<turnstile> ({s} \\<inter> P Z) c (Q Z),\n                             (A Z) \\<Longrightarrow>\n       \\<forall>s\\<in>S.\n          \\<Gamma>,\\<Theta>\\<turnstile> ({s} \\<inter> P Z) c (Q Z),(A Z)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "record 'g vars = \"'g state\" +\n  compare_' :: string\n  n_'   :: nat\n  m_'   :: nat\n  b_'   :: bool\n  k_'  :: nat"], ["", "procedures compare(n,m|b) = \"NoBody\""], ["", "print_locale! compare_signature"], ["", "context compare_signature\nbegin"], ["", "declare [[hoare_use_call_tr' = false]]"], ["", "term \"\\<acute>b :== CALL compare(\\<acute>n,\\<acute>m)\""], ["", "term \"\\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\\<acute>m)\""], ["", "declare [[hoare_use_call_tr' = true]]"], ["", "term \"\\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\\<acute>m)\""], ["", "end"], ["", "procedures\n  LEQ (n,m | b) = \"\\<acute>b :== \\<acute>n \\<le> \\<acute>m\"\n  LEQ_spec: \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile> {\\<sigma>}  PROC LEQ(\\<acute>n,\\<acute>m,\\<acute>b) \\<lbrace>\\<acute>b = (\\<^bsup>\\<sigma>\\<^esup>n \\<le> \\<^bsup>\\<sigma>\\<^esup>m)\\<rbrace>\"\n  LEQ_modifies: \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile> {\\<sigma>} PROC LEQ(\\<acute>n,\\<acute>m,\\<acute>b) {t. t may_only_modify_globals \\<sigma> in []}\""], ["", "definition mx:: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> 'a\"\n  where \"mx leq a b = (if leq a b then a else b)\""], ["", "procedures\n  Max (compare, n, m | k) =\n  \"\\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\\<acute>m);;\n   IF \\<acute>b THEN \\<acute>k :== \\<acute>n ELSE \\<acute>k :== \\<acute>m FI\"\n\n  Max_spec: \"\\<And>leq. \\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\n  ({\\<sigma>} \\<inter> {s. (\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>b :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>n,\\<acute>m) \\<lbrace>\\<acute>b = (leq \\<^bsup>\\<tau>\\<^esup>n \\<^bsup>\\<tau>\\<^esup>m)\\<rbrace>) \\<and>\n              (\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>b :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>n,\\<acute>m) {t. t may_only_modify_globals \\<tau> in []})})\n    PROC Max(\\<acute>compare,\\<acute>n,\\<acute>m,\\<acute>k)\n  \\<lbrace>\\<acute>k = mx leq \\<^bsup>\\<sigma>\\<^esup>n \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>\""], ["", "lemma (in Max_impl ) Max_spec1:\nshows\n\"\\<forall>\\<sigma> leq. \\<Gamma>\\<turnstile>\n  ({\\<sigma>} \\<inter> \\<lbrace> (\\<forall>\\<tau>. \\<Gamma>\\<turnstile>{\\<tau>} \\<acute>b :== PROC \\<acute>compare(\\<acute>n,\\<acute>m) \\<lbrace>\\<acute>b = (leq \\<^bsup>\\<tau>\\<^esup>n \\<^bsup>\\<tau>\\<^esup>m)\\<rbrace>) \\<and>\n      (\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>b :== PROC \\<acute>compare(\\<acute>n,\\<acute>m) {t. t may_only_modify_globals \\<tau> in []})\\<rbrace>)\n    \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\\<acute>m)\n  \\<lbrace>\\<acute>k = mx leq \\<^bsup>\\<sigma>\\<^esup>n \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> leq.\n       \\<Gamma>\n          \\<turnstile> ({\\<sigma>} \\<inter>\n                        \\<lbrace>(\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {s. \\<^bsup>s\\<^esup>b =\n                   leq \\<^bsup>\\<tau>\\<^esup>n\n                    \\<^bsup>\\<tau>\\<^esup>m}) \\<and>\n                                 (\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {t. t may_not_modify_globals \\<tau>})\\<rbrace>)\n                       \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\n                       \\<acute>m)\n                       \\<lbrace>\\<acute>k =\n                                mx leq \\<^bsup>\\<sigma>\\<^esup>n\n                                 \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "apply (hoare_rule HoarePartial.ProcNoRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> leq.\n       \\<Gamma>\n          \\<turnstile> ({\\<sigma>} \\<inter>\n                        \\<lbrace>(\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {s. \\<^bsup>s\\<^esup>b =\n                   leq \\<^bsup>\\<tau>\\<^esup>n\n                    \\<^bsup>\\<tau>\\<^esup>m}) \\<and>\n                                 (\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {t. t may_not_modify_globals \\<tau>})\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k =\n                                mx leq \\<^bsup>\\<sigma>\\<^esup>n\n                                 \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "apply (intro allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> leq.\n       \\<Gamma>\n          \\<turnstile> ({\\<sigma>} \\<inter>\n                        \\<lbrace>(\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {s. \\<^bsup>s\\<^esup>b =\n                   leq \\<^bsup>\\<tau>\\<^esup>n\n                    \\<^bsup>\\<tau>\\<^esup>m}) \\<and>\n                                 (\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {t. t may_not_modify_globals \\<tau>})\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k =\n                                mx leq \\<^bsup>\\<sigma>\\<^esup>n\n                                 \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "apply (rule conseq_exploit_pre')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> leq.\n       \\<forall>s\\<in>\\<lbrace>(\\<forall>\\<tau>.\n                                   \\<Gamma>\n\\<turnstile> {\\<tau>} Call \\<acute>compare\n             {s. \\<^bsup>s\\<^esup>b =\n                 leq \\<^bsup>\\<tau>\\<^esup>n\n                  \\<^bsup>\\<tau>\\<^esup>m}) \\<and>\n                               (\\<forall>\\<tau>.\n                                   \\<Gamma>\n\\<turnstile> {\\<tau>} Call \\<acute>compare\n             {t. t may_not_modify_globals \\<tau>})\\<rbrace>.\n          \\<Gamma>\n             \\<turnstile> ({s} \\<inter> {\\<sigma>})\n                          \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                          \\<acute>m);;\n                          IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                          ELSE \\<acute>k :== \\<acute>m FI\n                          \\<lbrace>\\<acute>k =\n                                   mx leq \\<^bsup>\\<sigma>\\<^esup>n\n                                    \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "apply (rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> leq s.\n       s \\<in> \\<lbrace>(\\<forall>\\<tau>.\n                            \\<Gamma>\n                               \\<turnstile> {\\<tau>} Call \\<acute>compare\n      {s. \\<^bsup>s\\<^esup>b =\n          leq \\<^bsup>\\<tau>\\<^esup>n \\<^bsup>\\<tau>\\<^esup>m}) \\<and>\n                        (\\<forall>\\<tau>.\n                            \\<Gamma>\n                               \\<turnstile> {\\<tau>} Call \\<acute>compare\n      {t. t may_not_modify_globals \\<tau>})\\<rbrace> \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> ({s} \\<inter> {\\<sigma>})\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k =\n                                mx leq \\<^bsup>\\<sigma>\\<^esup>n\n                                 \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> leq s.\n       \\<lbrakk>\\<forall>\\<tau>.\n                   \\<Gamma>\n                      \\<turnstile> {\\<tau>}\n                                   \\<acute>b :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>n,\n                                   \\<acute>m)\n                                   \\<lbrace>\\<acute>b =\n      leq \\<^bsup>\\<tau>\\<^esup>n \\<^bsup>\\<tau>\\<^esup>m\\<rbrace>;\n        \\<forall>\\<tau>.\n           \\<Gamma>\n              \\<turnstile> {\\<tau>}\n                           \\<acute>b :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>n,\n                           \\<acute>m)\n                           {t. t may_not_modify_globals \\<tau>}\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> ({s} \\<inter> {\\<sigma>})\n   \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\\<acute>m);;\n   IF \\<acute>b THEN \\<acute>k :== \\<acute>n ELSE \\<acute>k :== \\<acute>m FI\n   \\<lbrace>\\<acute>k =\n            mx leq \\<^bsup>\\<sigma>\\<^esup>n\n             \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> leq s.\n       \\<lbrakk>\\<forall>\\<tau>.\n                   \\<Gamma>\n                      \\<turnstile> {\\<tau>}\n                                   \\<acute>b :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>n,\n                                   \\<acute>m)\n                                   \\<lbrace>\\<acute>b =\n      leq \\<^bsup>\\<tau>\\<^esup>n \\<^bsup>\\<tau>\\<^esup>m\\<rbrace>;\n        \\<forall>\\<tau>.\n           \\<Gamma>\n              \\<turnstile> {\\<tau>}\n                           \\<acute>b :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>n,\n                           \\<acute>m)\n                           {t. t may_not_modify_globals \\<tau>}\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> ({s} \\<inter> {\\<sigma>})\n   \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\\<acute>m);;\n   IF \\<acute>b THEN \\<acute>k :== \\<acute>n ELSE \\<acute>k :== \\<acute>m FI\n   \\<lbrace>\\<acute>k =\n            mx leq \\<^bsup>\\<sigma>\\<^esup>n\n             \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "fix \\<sigma>:: \"('a,'b) vars_scheme\" and s::\"('a,'b) vars_scheme\" and leq"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> leq s.\n       \\<lbrakk>\\<forall>\\<tau>.\n                   \\<Gamma>\n                      \\<turnstile> {\\<tau>}\n                                   \\<acute>b :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>n,\n                                   \\<acute>m)\n                                   \\<lbrace>\\<acute>b =\n      leq \\<^bsup>\\<tau>\\<^esup>n \\<^bsup>\\<tau>\\<^esup>m\\<rbrace>;\n        \\<forall>\\<tau>.\n           \\<Gamma>\n              \\<turnstile> {\\<tau>}\n                           \\<acute>b :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>n,\n                           \\<acute>m)\n                           {t. t may_not_modify_globals \\<tau>}\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> ({s} \\<inter> {\\<sigma>})\n   \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\\<acute>m);;\n   IF \\<acute>b THEN \\<acute>k :== \\<acute>n ELSE \\<acute>k :== \\<acute>m FI\n   \\<lbrace>\\<acute>k =\n            mx leq \\<^bsup>\\<sigma>\\<^esup>n\n             \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "assume compare_spec:\n       \"\\<forall>\\<tau>. \\<Gamma>\\<turnstile>{\\<tau>} \\<acute>b :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>n,\\<acute>m) \\<lbrace>\\<acute>b = leq \\<^bsup>\\<tau>\\<^esup>n \\<^bsup>\\<tau>\\<^esup>m\\<rbrace>\""], ["proof (state)\nthis:\n  \\<forall>\\<tau>.\n     \\<Gamma>\n        \\<turnstile> {\\<tau>}\n                     \\<acute>b :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>n,\n                     \\<acute>m)\n                     \\<lbrace>\\<acute>b =\n                              leq \\<^bsup>\\<tau>\\<^esup>n\n                               \\<^bsup>\\<tau>\\<^esup>m\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> leq s.\n       \\<lbrakk>\\<forall>\\<tau>.\n                   \\<Gamma>\n                      \\<turnstile> {\\<tau>}\n                                   \\<acute>b :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>n,\n                                   \\<acute>m)\n                                   \\<lbrace>\\<acute>b =\n      leq \\<^bsup>\\<tau>\\<^esup>n \\<^bsup>\\<tau>\\<^esup>m\\<rbrace>;\n        \\<forall>\\<tau>.\n           \\<Gamma>\n              \\<turnstile> {\\<tau>}\n                           \\<acute>b :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>n,\n                           \\<acute>m)\n                           {t. t may_not_modify_globals \\<tau>}\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> ({s} \\<inter> {\\<sigma>})\n   \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\\<acute>m);;\n   IF \\<acute>b THEN \\<acute>k :== \\<acute>n ELSE \\<acute>k :== \\<acute>m FI\n   \\<lbrace>\\<acute>k =\n            mx leq \\<^bsup>\\<sigma>\\<^esup>n\n             \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "assume compare_modifies:\n        \"\\<forall>\\<tau>. \\<Gamma>\\<turnstile>{\\<tau>} \\<acute>b :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>n,\\<acute>m)\n                {t. t may_only_modify_globals \\<tau> in []}\""], ["proof (state)\nthis:\n  \\<forall>\\<tau>.\n     \\<Gamma>\n        \\<turnstile> {\\<tau>}\n                     \\<acute>b :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>n,\n                     \\<acute>m)\n                     {t. t may_not_modify_globals \\<tau>}\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> leq s.\n       \\<lbrakk>\\<forall>\\<tau>.\n                   \\<Gamma>\n                      \\<turnstile> {\\<tau>}\n                                   \\<acute>b :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>n,\n                                   \\<acute>m)\n                                   \\<lbrace>\\<acute>b =\n      leq \\<^bsup>\\<tau>\\<^esup>n \\<^bsup>\\<tau>\\<^esup>m\\<rbrace>;\n        \\<forall>\\<tau>.\n           \\<Gamma>\n              \\<turnstile> {\\<tau>}\n                           \\<acute>b :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>n,\n                           \\<acute>m)\n                           {t. t may_not_modify_globals \\<tau>}\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> ({s} \\<inter> {\\<sigma>})\n   \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\\<acute>m);;\n   IF \\<acute>b THEN \\<acute>k :== \\<acute>n ELSE \\<acute>k :== \\<acute>m FI\n   \\<lbrace>\\<acute>k =\n            mx leq \\<^bsup>\\<sigma>\\<^esup>n\n             \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "show \"\\<Gamma>\\<turnstile>({s} \\<inter> {\\<sigma>})\n            \\<acute>b :== DYNCALL \\<acute>compare (\\<acute>n,\\<acute>m);;\n            IF \\<acute>b THEN \\<acute>k :== \\<acute>n ELSE \\<acute>k :== \\<acute>m FI\n            \\<lbrace>\\<acute>k = mx leq \\<^bsup>\\<sigma>\\<^esup>n \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> ({s} \\<inter> {\\<sigma>})\n                    \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                    \\<acute>m);;\n                    IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                    ELSE \\<acute>k :== \\<acute>m FI\n                    \\<lbrace>\\<acute>k =\n                             mx leq \\<^bsup>\\<sigma>\\<^esup>n\n                              \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>compare n m.\n       compare = compare \\<and>\n       (\\<forall>b.\n           b = leq n m \\<longrightarrow>\n           (leq n m \\<longrightarrow> n = mx leq n m) \\<and>\n           (\\<not> leq n m \\<longrightarrow> m = mx leq n m))", "apply (clarsimp simp add: mx_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<Gamma>\n     \\<turnstile> ({s} \\<inter> {\\<sigma>})\n                  \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                  \\<acute>m);;\n                  IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                  ELSE \\<acute>k :== \\<acute>m FI\n                  \\<lbrace>\\<acute>k =\n                           mx leq \\<^bsup>\\<sigma>\\<^esup>n\n                            \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in Max_impl) Max_spec2:\nshows\n\"\\<forall>\\<sigma> leq. \\<Gamma>\\<turnstile>\n  ({\\<sigma>} \\<inter> \\<lbrace>(\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>b :== PROC \\<acute>compare(\\<acute>n,\\<acute>m) \\<lbrace>\\<acute>b = (leq \\<^bsup>\\<tau>\\<^esup>n \\<^bsup>\\<tau>\\<^esup>m)\\<rbrace>) \\<and>\n      (\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>b :== PROC \\<acute>compare(\\<acute>n,\\<acute>m) {t. t may_only_modify_globals \\<tau> in []})\\<rbrace>)\n    \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\\<acute>m)\n  \\<lbrace>\\<acute>k = mx leq \\<^bsup>\\<sigma>\\<^esup>n \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> leq.\n       \\<Gamma>\n          \\<turnstile> ({\\<sigma>} \\<inter>\n                        \\<lbrace>(\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {s. \\<^bsup>s\\<^esup>b =\n                   leq \\<^bsup>\\<tau>\\<^esup>n\n                    \\<^bsup>\\<tau>\\<^esup>m}) \\<and>\n                                 (\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {t. t may_not_modify_globals \\<tau>})\\<rbrace>)\n                       \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\n                       \\<acute>m)\n                       \\<lbrace>\\<acute>k =\n                                mx leq \\<^bsup>\\<sigma>\\<^esup>n\n                                 \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "apply (hoare_rule HoarePartial.ProcNoRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> leq.\n       \\<Gamma>\n          \\<turnstile> ({\\<sigma>} \\<inter>\n                        \\<lbrace>(\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {s. \\<^bsup>s\\<^esup>b =\n                   leq \\<^bsup>\\<tau>\\<^esup>n\n                    \\<^bsup>\\<tau>\\<^esup>m}) \\<and>\n                                 (\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {t. t may_not_modify_globals \\<tau>})\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k =\n                                mx leq \\<^bsup>\\<sigma>\\<^esup>n\n                                 \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "apply (intro allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> leq.\n       \\<Gamma>\n          \\<turnstile> ({\\<sigma>} \\<inter>\n                        \\<lbrace>(\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {s. \\<^bsup>s\\<^esup>b =\n                   leq \\<^bsup>\\<tau>\\<^esup>n\n                    \\<^bsup>\\<tau>\\<^esup>m}) \\<and>\n                                 (\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {t. t may_not_modify_globals \\<tau>})\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k =\n                                mx leq \\<^bsup>\\<sigma>\\<^esup>n\n                                 \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "apply (rule conseq_exploit_pre')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> leq.\n       \\<forall>s\\<in>\\<lbrace>(\\<forall>\\<tau>.\n                                   \\<Gamma>\n\\<turnstile> {\\<tau>} Call \\<acute>compare\n             {s. \\<^bsup>s\\<^esup>b =\n                 leq \\<^bsup>\\<tau>\\<^esup>n\n                  \\<^bsup>\\<tau>\\<^esup>m}) \\<and>\n                               (\\<forall>\\<tau>.\n                                   \\<Gamma>\n\\<turnstile> {\\<tau>} Call \\<acute>compare\n             {t. t may_not_modify_globals \\<tau>})\\<rbrace>.\n          \\<Gamma>\n             \\<turnstile> ({s} \\<inter> {\\<sigma>})\n                          \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                          \\<acute>m);;\n                          IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                          ELSE \\<acute>k :== \\<acute>m FI\n                          \\<lbrace>\\<acute>k =\n                                   mx leq \\<^bsup>\\<sigma>\\<^esup>n\n                                    \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "apply (rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> leq s.\n       s \\<in> \\<lbrace>(\\<forall>\\<tau>.\n                            \\<Gamma>\n                               \\<turnstile> {\\<tau>} Call \\<acute>compare\n      {s. \\<^bsup>s\\<^esup>b =\n          leq \\<^bsup>\\<tau>\\<^esup>n \\<^bsup>\\<tau>\\<^esup>m}) \\<and>\n                        (\\<forall>\\<tau>.\n                            \\<Gamma>\n                               \\<turnstile> {\\<tau>} Call \\<acute>compare\n      {t. t may_not_modify_globals \\<tau>})\\<rbrace> \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> ({s} \\<inter> {\\<sigma>})\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k =\n                                mx leq \\<^bsup>\\<sigma>\\<^esup>n\n                                 \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> leq s.\n       \\<lbrakk>\\<forall>\\<tau>.\n                   \\<Gamma>\n                      \\<turnstile> {\\<tau>}\n                                   \\<acute>b :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>n,\n                                   \\<acute>m)\n                                   \\<lbrace>\\<acute>b =\n      leq \\<^bsup>\\<tau>\\<^esup>n \\<^bsup>\\<tau>\\<^esup>m\\<rbrace>;\n        \\<forall>\\<tau>.\n           \\<Gamma>\n              \\<turnstile> {\\<tau>}\n                           \\<acute>b :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>n,\n                           \\<acute>m)\n                           {t. t may_not_modify_globals \\<tau>}\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> ({s} \\<inter> {\\<sigma>})\n   \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\\<acute>m);;\n   IF \\<acute>b THEN \\<acute>k :== \\<acute>n ELSE \\<acute>k :== \\<acute>m FI\n   \\<lbrace>\\<acute>k =\n            mx leq \\<^bsup>\\<sigma>\\<^esup>n\n             \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>leq compare n m.\n       \\<lbrakk>\\<forall>\\<tau>.\n                   \\<Gamma>\n                      \\<turnstile> {\\<tau>} Call compare\n                                   \\<lbrace>\\<acute>b =\n      leq \\<^bsup>\\<tau>\\<^esup>n \\<^bsup>\\<tau>\\<^esup>m\\<rbrace>;\n        \\<forall>\\<tau>.\n           \\<Gamma>\n              \\<turnstile> {\\<tau>} Call compare\n                           {t. t may_not_modify_globals \\<tau>}\\<rbrakk>\n       \\<Longrightarrow> compare = compare \\<and>\n                         (\\<forall>b.\n                             b = leq n m \\<longrightarrow>\n                             (leq n m \\<longrightarrow>\n                              n = mx leq n m) \\<and>\n                             (\\<not> leq n m \\<longrightarrow>\n                              m = mx leq n m))", "apply (clarsimp simp add: mx_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in Max_impl) Max_spec3:\nshows\n\"\\<forall>n m leq. \\<Gamma>\\<turnstile>\n  (\\<lbrace>\\<acute>n=n \\<and> \\<acute>m=m\\<rbrace>  \\<inter>\n   \\<lbrace>(\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>b :== PROC \\<acute>compare(\\<acute>n,\\<acute>m) \\<lbrace>\\<acute>b = (leq \\<^bsup>\\<tau>\\<^esup>n \\<^bsup>\\<tau>\\<^esup>m)\\<rbrace>) \\<and>\n     (\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>b :== PROC \\<acute>compare(\\<acute>n,\\<acute>m) {t. t may_only_modify_globals \\<tau> in []})\\<rbrace>)\n    \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\\<acute>m)\n  \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n m leq.\n       \\<Gamma>\n          \\<turnstile> (\\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace> \\<inter>\n                        \\<lbrace>(\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {s. \\<^bsup>s\\<^esup>b =\n                   leq \\<^bsup>\\<tau>\\<^esup>n\n                    \\<^bsup>\\<tau>\\<^esup>m}) \\<and>\n                                 (\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {t. t may_not_modify_globals \\<tau>})\\<rbrace>)\n                       \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\n                       \\<acute>m)\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply (hoare_rule HoarePartial.ProcNoRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n m leq.\n       \\<Gamma>\n          \\<turnstile> (\\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace> \\<inter>\n                        \\<lbrace>(\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {s. \\<^bsup>s\\<^esup>b =\n                   leq \\<^bsup>\\<tau>\\<^esup>n\n                    \\<^bsup>\\<tau>\\<^esup>m}) \\<and>\n                                 (\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {t. t may_not_modify_globals \\<tau>})\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply (intro allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m leq.\n       \\<Gamma>\n          \\<turnstile> (\\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace> \\<inter>\n                        \\<lbrace>(\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {s. \\<^bsup>s\\<^esup>b =\n                   leq \\<^bsup>\\<tau>\\<^esup>n\n                    \\<^bsup>\\<tau>\\<^esup>m}) \\<and>\n                                 (\\<forall>\\<tau>.\n                                     \\<Gamma>\n  \\<turnstile> {\\<tau>} Call \\<acute>compare\n               {t. t may_not_modify_globals \\<tau>})\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply (rule conseq_exploit_pre')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m leq.\n       \\<forall>s\\<in>\\<lbrace>(\\<forall>\\<tau>.\n                                   \\<Gamma>\n\\<turnstile> {\\<tau>} Call \\<acute>compare\n             {s. \\<^bsup>s\\<^esup>b =\n                 leq \\<^bsup>\\<tau>\\<^esup>n\n                  \\<^bsup>\\<tau>\\<^esup>m}) \\<and>\n                               (\\<forall>\\<tau>.\n                                   \\<Gamma>\n\\<turnstile> {\\<tau>} Call \\<acute>compare\n             {t. t may_not_modify_globals \\<tau>})\\<rbrace>.\n          \\<Gamma>\n             \\<turnstile> ({s} \\<inter>\n                           \\<lbrace>\\<acute>n = n \\<and>\n                                    \\<acute>m = m\\<rbrace>)\n                          \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                          \\<acute>m);;\n                          IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                          ELSE \\<acute>k :== \\<acute>m FI\n                          \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply (rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m leq s.\n       s \\<in> \\<lbrace>(\\<forall>\\<tau>.\n                            \\<Gamma>\n                               \\<turnstile> {\\<tau>} Call \\<acute>compare\n      {s. \\<^bsup>s\\<^esup>b =\n          leq \\<^bsup>\\<tau>\\<^esup>n \\<^bsup>\\<tau>\\<^esup>m}) \\<and>\n                        (\\<forall>\\<tau>.\n                            \\<Gamma>\n                               \\<turnstile> {\\<tau>} Call \\<acute>compare\n      {t. t may_not_modify_globals \\<tau>})\\<rbrace> \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> ({s} \\<inter>\n                        \\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m leq s.\n       \\<lbrakk>\\<forall>\\<tau>.\n                   \\<Gamma>\n                      \\<turnstile> {\\<tau>}\n                                   \\<acute>b :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>n,\n                                   \\<acute>m)\n                                   \\<lbrace>\\<acute>b =\n      leq \\<^bsup>\\<tau>\\<^esup>n \\<^bsup>\\<tau>\\<^esup>m\\<rbrace>;\n        \\<forall>\\<tau>.\n           \\<Gamma>\n              \\<turnstile> {\\<tau>}\n                           \\<acute>b :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>n,\n                           \\<acute>m)\n                           {t. t may_not_modify_globals \\<tau>}\\<rbrakk>\n       \\<Longrightarrow> \\<Gamma>\n                            \\<turnstile> ({s} \\<inter>\n    \\<lbrace>\\<acute>n = n \\<and> \\<acute>m = m\\<rbrace>)\n   \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\\<acute>m);;\n   IF \\<acute>b THEN \\<acute>k :== \\<acute>n ELSE \\<acute>k :== \\<acute>m FI\n   \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>leq compare n m.\n       \\<lbrakk>\\<forall>\\<tau>.\n                   \\<Gamma>\n                      \\<turnstile> {\\<tau>} Call compare\n                                   \\<lbrace>\\<acute>b =\n      leq \\<^bsup>\\<tau>\\<^esup>n \\<^bsup>\\<tau>\\<^esup>m\\<rbrace>;\n        \\<forall>\\<tau>.\n           \\<Gamma>\n              \\<turnstile> {\\<tau>} Call compare\n                           {t. t may_not_modify_globals \\<tau>}\\<rbrakk>\n       \\<Longrightarrow> compare = compare \\<and>\n                         (\\<forall>b.\n                             b = leq n m \\<longrightarrow>\n                             (leq n m \\<longrightarrow>\n                              n = mx leq n m) \\<and>\n                             (\\<not> leq n m \\<longrightarrow>\n                              m = mx leq n m))", "apply (clarsimp simp add: mx_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in Max_impl) Max_spec4:\nshows\n\"\\<forall>n m leq. \\<Gamma>\\<turnstile>\n  (\\<lbrace>\\<acute>n=n \\<and> \\<acute>m=m\\<rbrace> \\<inter> \\<lbrace>\\<forall>\\<tau>. \\<Gamma>\\<turnstile> {\\<tau>} \\<acute>b :== PROC \\<acute>compare(\\<acute>n,\\<acute>m) \\<lbrace>\\<acute>b = (leq \\<^bsup>\\<tau>\\<^esup>n \\<^bsup>\\<tau>\\<^esup>m)\\<rbrace>\\<rbrace>)\n    \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\\<acute>m)\n  \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n m leq.\n       \\<Gamma>\n          \\<turnstile> (\\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace> \\<inter>\n                        \\<lbrace>\\<forall>\\<tau>.\n                                    \\<Gamma>\n \\<turnstile> {\\<tau>} Call \\<acute>compare\n              {s. \\<^bsup>s\\<^esup>b =\n                  leq \\<^bsup>\\<tau>\\<^esup>n\n                   \\<^bsup>\\<tau>\\<^esup>m}\\<rbrace>)\n                       \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\n                       \\<acute>m)\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply (hoare_rule HoarePartial.ProcNoRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n m leq.\n       \\<Gamma>\n          \\<turnstile> (\\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace> \\<inter>\n                        \\<lbrace>\\<forall>\\<tau>.\n                                    \\<Gamma>\n \\<turnstile> {\\<tau>} Call \\<acute>compare\n              {s. \\<^bsup>s\\<^esup>b =\n                  leq \\<^bsup>\\<tau>\\<^esup>n\n                   \\<^bsup>\\<tau>\\<^esup>m}\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply (intro allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m leq.\n       \\<Gamma>\n          \\<turnstile> (\\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace> \\<inter>\n                        \\<lbrace>\\<forall>\\<tau>.\n                                    \\<Gamma>\n \\<turnstile> {\\<tau>} Call \\<acute>compare\n              {s. \\<^bsup>s\\<^esup>b =\n                  leq \\<^bsup>\\<tau>\\<^esup>n\n                   \\<^bsup>\\<tau>\\<^esup>m}\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply (rule conseq_exploit_pre')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m leq.\n       \\<forall>s\\<in>\\<lbrace>\\<forall>\\<tau>.\n                                  \\<Gamma>\n                                     \\<turnstile> {\\<tau>}\n            Call \\<acute>compare\n            {s. \\<^bsup>s\\<^esup>b =\n                leq \\<^bsup>\\<tau>\\<^esup>n\n                 \\<^bsup>\\<tau>\\<^esup>m}\\<rbrace>.\n          \\<Gamma>\n             \\<turnstile> ({s} \\<inter>\n                           \\<lbrace>\\<acute>n = n \\<and>\n                                    \\<acute>m = m\\<rbrace>)\n                          \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                          \\<acute>m);;\n                          IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                          ELSE \\<acute>k :== \\<acute>m FI\n                          \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply (rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m leq s.\n       s \\<in> \\<lbrace>\\<forall>\\<tau>.\n                           \\<Gamma>\n                              \\<turnstile> {\\<tau>} Call \\<acute>compare\n     {s. \\<^bsup>s\\<^esup>b =\n         leq \\<^bsup>\\<tau>\\<^esup>n\n          \\<^bsup>\\<tau>\\<^esup>m}\\<rbrace> \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> ({s} \\<inter>\n                        \\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m leq s.\n       \\<forall>\\<tau>.\n          \\<Gamma>\n             \\<turnstile> {\\<tau>}\n                          \\<acute>b :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>n,\n                          \\<acute>m)\n                          \\<lbrace>\\<acute>b =\n                                   leq \\<^bsup>\\<tau>\\<^esup>n\n                                    \\<^bsup>\\<tau>\\<^esup>m\\<rbrace> \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> ({s} \\<inter>\n                        \\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>leq compare n m.\n       \\<forall>\\<tau>.\n          \\<Gamma>\n             \\<turnstile> {\\<tau>} Call compare\n                          \\<lbrace>\\<acute>b =\n                                   leq \\<^bsup>\\<tau>\\<^esup>n\n                                    \\<^bsup>\\<tau>\\<^esup>m\\<rbrace> \\<Longrightarrow>\n       compare = compare \\<and>\n       (\\<forall>b.\n           b = leq n m \\<longrightarrow>\n           (leq n m \\<longrightarrow> n = mx leq n m) \\<and>\n           (\\<not> leq n m \\<longrightarrow> m = mx leq n m))", "apply (clarsimp simp add: mx_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "locale Max_test = Max_spec + LEQ_spec + LEQ_modifies"], ["", "lemma (in Max_test)\n\n  shows\n  \"\\<Gamma>\\<turnstile> {\\<sigma>} \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m) \\<lbrace>\\<acute>k = mx (\\<le>) \\<^bsup>\\<sigma>\\<^esup>n \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> {\\<sigma>}\n                    \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m)\n                    \\<lbrace>\\<acute>k =\n                             mx (\\<le>) \\<^bsup>\\<sigma>\\<^esup>n\n                              \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> {\\<sigma>}\n                    \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m)\n                    \\<lbrace>\\<acute>k =\n                             mx (\\<le>) \\<^bsup>\\<sigma>\\<^esup>n\n                              \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "note Max_spec = Max_spec [where leq=\"(\\<le>)\"]"], ["proof (state)\nthis:\n  \\<forall>\\<sigma>.\n     \\<Gamma>\n        \\<turnstile> ({\\<sigma>} \\<inter>\n                      \\<lbrace>(\\<forall>\\<tau>.\n                                   \\<Gamma>\n\\<turnstile> {\\<tau>} Call \\<acute>compare\n             {s. \\<^bsup>s\\<^esup>b =\n                 (\\<^bsup>\\<tau>\\<^esup>n\n                  \\<le> \\<^bsup>\\<tau>\\<^esup>m)}) \\<and>\n                               (\\<forall>\\<tau>.\n                                   \\<Gamma>\n\\<turnstile> {\\<tau>} Call \\<acute>compare\n             {t. t may_not_modify_globals \\<tau>})\\<rbrace>)\n                     \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\n                     \\<acute>m)\n                     \\<lbrace>\\<acute>k =\n                              mx (\\<le>) \\<^bsup>\\<sigma>\\<^esup>n\n                               \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> {\\<sigma>}\n                    \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m)\n                    \\<lbrace>\\<acute>k =\n                             mx (\\<le>) \\<^bsup>\\<sigma>\\<^esup>n\n                              \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> {\\<sigma>}\n                    \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m)\n                    \\<lbrace>\\<acute>k =\n                             mx (\\<le>) \\<^bsup>\\<sigma>\\<^esup>n\n                              \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m.\n       (\\<forall>\\<tau>.\n           \\<Gamma>\n              \\<turnstile> (Collect ((=) \\<tau>))\n                           \\<acute>b :== PROC LEQ(\\<acute>n,\\<acute>m)\n                           \\<lbrace>\\<acute>b =\n                                    (\\<^bsup>\\<tau>\\<^esup>n\n                                     \\<le> \\<^bsup>\\<tau>\\<^esup>m)\\<rbrace>) \\<and>\n       (\\<forall>\\<tau>.\n           \\<Gamma>\n              \\<turnstile> (Collect ((=) \\<tau>))\n                           \\<acute>b :== PROC LEQ(\\<acute>n,\\<acute>m)\n                           {t. t may_not_modify_globals \\<tau>}) \\<and>\n       (\\<forall>k.\n           k = mx (\\<le>) n m \\<longrightarrow>\n           mx (\\<le>) n m = mx (\\<le>) n m)", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<tau>.\n        \\<Gamma>\n           \\<turnstile> {\\<tau>} \\<acute>b :== PROC LEQ(\\<acute>n,\\<acute>m)\n                        \\<lbrace>\\<acute>b =\n                                 (\\<^bsup>\\<tau>\\<^esup>n\n                                  \\<le> \\<^bsup>\\<tau>\\<^esup>m)\\<rbrace>) \\<and>\n    (\\<forall>\\<tau>.\n        \\<Gamma>\n           \\<turnstile> {\\<tau>} \\<acute>b :== PROC LEQ(\\<acute>n,\\<acute>m)\n                        {t. t may_not_modify_globals \\<tau>})", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<tau>.\n       \\<Gamma>\n          \\<turnstile> {\\<tau>} \\<acute>b :== PROC LEQ(\\<acute>n,\\<acute>m)\n                       \\<lbrace>\\<acute>b =\n                                (\\<^bsup>\\<tau>\\<^esup>n\n                                 \\<le> \\<^bsup>\\<tau>\\<^esup>m)\\<rbrace>\n 2. \\<forall>\\<tau>.\n       \\<Gamma>\n          \\<turnstile> {\\<tau>} \\<acute>b :== PROC LEQ(\\<acute>n,\\<acute>m)\n                       {t. t may_not_modify_globals \\<tau>}", "apply (rule LEQ_spec [simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<tau>.\n       \\<Gamma>\n          \\<turnstile> {\\<tau>} \\<acute>b :== PROC LEQ(\\<acute>n,\\<acute>m)\n                       {t. t may_not_modify_globals \\<tau>}", "apply (rule LEQ_modifies [simplified])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<Gamma>\n     \\<turnstile> {\\<sigma>}\n                  \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m)\n                  \\<lbrace>\\<acute>k =\n                           mx (\\<le>) \\<^bsup>\\<sigma>\\<^esup>n\n                            \\<^bsup>\\<sigma>\\<^esup>m\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in Max_impl) Max_spec5:\nshows\n\"\\<forall>n m leq. \\<Gamma>\\<turnstile>\n  (\\<lbrace>\\<acute>n=n \\<and> \\<acute>m=m\\<rbrace> \\<inter> \\<lbrace>\\<forall>n' m'. \\<Gamma>\\<turnstile> \\<lbrace>\\<acute>n=n' \\<and> \\<acute>m=m'\\<rbrace> \\<acute>b :== PROC \\<acute>compare(\\<acute>n,\\<acute>m) \\<lbrace>\\<acute>b = (leq n' m')\\<rbrace>\\<rbrace>)\n    \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\\<acute>m)\n  \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n m leq.\n       \\<Gamma>\n          \\<turnstile> (\\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace> \\<inter>\n                        \\<lbrace>\\<forall>n' m'.\n                                    \\<Gamma>\n \\<turnstile> {s. \\<^bsup>s\\<^esup>n = n' \\<and> \\<^bsup>s\\<^esup>m = m'}\n              Call \\<acute>compare\n              {s. \\<^bsup>s\\<^esup>b = leq n' m'}\\<rbrace>)\n                       \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\n                       \\<acute>m)\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "term \"\\<lbrace>{s. \\<^bsup>s\\<^esup>n = n' \\<and> \\<^bsup>s\\<^esup>m = m'} = X\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n m leq.\n       \\<Gamma>\n          \\<turnstile> (\\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace> \\<inter>\n                        \\<lbrace>\\<forall>n' m'.\n                                    \\<Gamma>\n \\<turnstile> {s. \\<^bsup>s\\<^esup>n = n' \\<and> \\<^bsup>s\\<^esup>m = m'}\n              Call \\<acute>compare\n              {s. \\<^bsup>s\\<^esup>b = leq n' m'}\\<rbrace>)\n                       \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\n                       \\<acute>m)\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply (hoare_rule HoarePartial.ProcNoRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n m leq.\n       \\<Gamma>\n          \\<turnstile> (\\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace> \\<inter>\n                        \\<lbrace>\\<forall>n' m'.\n                                    \\<Gamma>\n \\<turnstile> {s. \\<^bsup>s\\<^esup>n = n' \\<and> \\<^bsup>s\\<^esup>m = m'}\n              Call \\<acute>compare\n              {s. \\<^bsup>s\\<^esup>b = leq n' m'}\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply (intro allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m leq.\n       \\<Gamma>\n          \\<turnstile> (\\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace> \\<inter>\n                        \\<lbrace>\\<forall>n' m'.\n                                    \\<Gamma>\n \\<turnstile> {s. \\<^bsup>s\\<^esup>n = n' \\<and> \\<^bsup>s\\<^esup>m = m'}\n              Call \\<acute>compare\n              {s. \\<^bsup>s\\<^esup>b = leq n' m'}\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply (rule conseq_exploit_pre')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m leq.\n       \\<forall>s\\<in>\\<lbrace>\\<forall>n' m'.\n                                  \\<Gamma>\n                                     \\<turnstile> {s.\n             \\<^bsup>s\\<^esup>n = n' \\<and> \\<^bsup>s\\<^esup>m = m'}\n            Call \\<acute>compare\n            {s. \\<^bsup>s\\<^esup>b = leq n' m'}\\<rbrace>.\n          \\<Gamma>\n             \\<turnstile> ({s} \\<inter>\n                           \\<lbrace>\\<acute>n = n \\<and>\n                                    \\<acute>m = m\\<rbrace>)\n                          \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                          \\<acute>m);;\n                          IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                          ELSE \\<acute>k :== \\<acute>m FI\n                          \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply (rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m leq s.\n       s \\<in> \\<lbrace>\\<forall>n' m'.\n                           \\<Gamma>\n                              \\<turnstile> {s.\n      \\<^bsup>s\\<^esup>n = n' \\<and> \\<^bsup>s\\<^esup>m = m'}\n     Call \\<acute>compare\n     {s. \\<^bsup>s\\<^esup>b = leq n' m'}\\<rbrace> \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> ({s} \\<inter>\n                        \\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m leq s.\n       \\<forall>n' m'.\n          \\<Gamma>\n             \\<turnstile> \\<lbrace>\\<acute>n = n' \\<and>\n                                   \\<acute>m = m'\\<rbrace>\n                          \\<acute>b :== PROC \\<^bsup>s\\<^esup>compare(\\<acute>n,\n                          \\<acute>m)\n                          \\<lbrace>\\<acute>b =\n                                   leq n' m'\\<rbrace> \\<Longrightarrow>\n       \\<Gamma>\n          \\<turnstile> ({s} \\<inter>\n                        \\<lbrace>\\<acute>n = n \\<and>\n                                 \\<acute>m = m\\<rbrace>)\n                       \\<acute>b :== DYNCALL \\<acute>compare(\\<acute>n,\n                       \\<acute>m);;\n                       IF \\<acute>b THEN \\<acute>k :== \\<acute>n\n                       ELSE \\<acute>k :== \\<acute>m FI\n                       \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>leq compare n m.\n       \\<forall>n' m'.\n          \\<Gamma>\n             \\<turnstile> \\<lbrace>\\<acute>n = n' \\<and>\n                                   \\<acute>m = m'\\<rbrace>\n                          Call compare\n                          \\<lbrace>\\<acute>b =\n                                   leq n' m'\\<rbrace> \\<Longrightarrow>\n       compare = compare \\<and>\n       (\\<forall>b.\n           b = leq n m \\<longrightarrow>\n           (leq n m \\<longrightarrow> n = mx leq n m) \\<and>\n           (\\<not> leq n m \\<longrightarrow> m = mx leq n m))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>leq compare n m.\n       \\<forall>n' m'.\n          \\<Gamma>\n             \\<turnstile> \\<lbrace>\\<acute>n = n' \\<and>\n                                   \\<acute>m = m'\\<rbrace>\n                          Call compare\n                          \\<lbrace>\\<acute>b =\n                                   leq n' m'\\<rbrace> \\<Longrightarrow>\n       (leq n m \\<longrightarrow> n = mx leq n m) \\<and>\n       (\\<not> leq n m \\<longrightarrow> m = mx leq n m)", "apply (clarsimp simp add: mx_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in LEQ_impl)\n LEQ_spec: \"\\<forall>n m. \\<Gamma>\\<turnstile> \\<lbrace>\\<acute>n=n \\<and> \\<acute>m=m\\<rbrace>  PROC LEQ(\\<acute>n,\\<acute>m,\\<acute>b) \\<lbrace>\\<acute>b = (n \\<le> m)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n m.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<acute>n = n \\<and> \\<acute>m = m\\<rbrace>\n                       \\<acute>b :== PROC LEQ(\\<acute>n,\\<acute>m)\n                       \\<lbrace>\\<acute>b = (n \\<le> m)\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "locale Max_test' = Max_impl + LEQ_impl"], ["", "lemma (in Max_test')\n  shows\n  \"\\<forall>n m. \\<Gamma>\\<turnstile> \\<lbrace>\\<acute>n=n \\<and> \\<acute>m=m\\<rbrace> \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m) \\<lbrace>\\<acute>k = mx (\\<le>) n m\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n m.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<acute>n = n \\<and> \\<acute>m = m\\<rbrace>\n                       \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m)\n                       \\<lbrace>\\<acute>k = mx (\\<le>) n m\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>n m.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<acute>n = n \\<and> \\<acute>m = m\\<rbrace>\n                       \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m)\n                       \\<lbrace>\\<acute>k = mx (\\<le>) n m\\<rbrace>", "note Max_spec = Max_spec5"], ["proof (state)\nthis:\n  \\<forall>n m leq.\n     \\<Gamma>\n        \\<turnstile> (\\<lbrace>\\<acute>n = n \\<and>\n                               \\<acute>m = m\\<rbrace> \\<inter>\n                      \\<lbrace>\\<forall>n' m'.\n                                  \\<Gamma>\n                                     \\<turnstile> {s.\n             \\<^bsup>s\\<^esup>n = n' \\<and> \\<^bsup>s\\<^esup>m = m'}\n            Call \\<acute>compare\n            {s. \\<^bsup>s\\<^esup>b = leq n' m'}\\<rbrace>)\n                     \\<acute>k :== PROC Max(\\<acute>compare,\\<acute>n,\n                     \\<acute>m)\n                     \\<lbrace>\\<acute>k = mx leq n m\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<forall>n m.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<acute>n = n \\<and> \\<acute>m = m\\<rbrace>\n                       \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m)\n                       \\<lbrace>\\<acute>k = mx (\\<le>) n m\\<rbrace>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n m.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<acute>n = n \\<and> \\<acute>m = m\\<rbrace>\n                       \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m)\n                       \\<lbrace>\\<acute>k = mx (\\<le>) n m\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<exists>leq.\n          (\\<forall>n' m'.\n              \\<Gamma>\n                 \\<turnstile> \\<lbrace>\\<acute>n = n' \\<and>\n \\<acute>m = m'\\<rbrace>\n                              \\<acute>b :== PROC LEQ(\\<acute>n,\\<acute>m)\n                              \\<lbrace>\\<acute>b =\n leq n' m'\\<rbrace>) \\<and>\n          (\\<forall>k.\n              k = mx leq n m \\<longrightarrow> mx leq n m = mx (\\<le>) n m)", "apply (rule_tac x=\"(\\<le>)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m.\n       (\\<forall>n' m'.\n           \\<Gamma>\n              \\<turnstile> \\<lbrace>\\<acute>n = n' \\<and>\n                                    \\<acute>m = m'\\<rbrace>\n                           \\<acute>b :== PROC LEQ(\\<acute>n,\\<acute>m)\n                           \\<lbrace>\\<acute>b =\n                                    (n' \\<le> m')\\<rbrace>) \\<and>\n       (\\<forall>k.\n           k = mx (\\<le>) n m \\<longrightarrow>\n           mx (\\<le>) n m = mx (\\<le>) n m)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n' m'.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>\\<acute>n = n' \\<and>\n                                \\<acute>m = m'\\<rbrace>\n                       \\<acute>b :== PROC LEQ(\\<acute>n,\\<acute>m)\n                       \\<lbrace>\\<acute>b = (n' \\<le> m')\\<rbrace>", "apply (rule LEQ_spec [rule_format])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>n m.\n     \\<Gamma>\n        \\<turnstile> \\<lbrace>\\<acute>n = n \\<and> \\<acute>m = m\\<rbrace>\n                     \\<acute>k :== CALL Max(LEQ_'proc,\\<acute>n,\\<acute>m)\n                     \\<lbrace>\\<acute>k = mx (\\<le>) n m\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}