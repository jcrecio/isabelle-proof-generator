{"file_name": "/home/qj213/afp-2021-10-22/thys/Simpl/HeapList.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Simpl", "problem_names": ["lemma Path_Null_iff [iff]: \"Path Null h y xs  = (xs = [] \\<and> y = Null)\"", "lemma Path_not_Null_iff [simp]: \"p\\<noteq>Null \\<Longrightarrow>\n  Path p h q as = (as = [] \\<and> q = p  \\<or>  (\\<exists>ps. as = p#ps \\<and> Path (h p) h q ps ))\"", "lemma Path_append [simp]:\n  \"\\<And>p. Path p f q (as@bs)  = (\\<exists>y. Path p f y as \\<and> Path y f q bs)\"", "lemma notin_Path_update[simp]:\n \"\\<And>p. u \\<notin> set ps \\<Longrightarrow> Path p (f(u := v)) q ps  = Path p f q ps \"", "lemma Path_upd_same [simp]:\n  \"Path p (f(p:=p)) q qs =\n      ((p=Null \\<and> q=Null \\<and> qs = []) \\<or> (p\\<noteq>Null \\<and> q=p \\<and> (\\<forall>x\\<in>set qs. x=p)))\"", "lemma notin_Path_updateI [intro]:\n \"\\<lbrakk>Path p h q ps ; r \\<notin> set ps\\<rbrakk> \\<Longrightarrow> Path p (h(r := y)) q ps \"", "lemma Path_update_new [simp]: \"\\<lbrakk>set ps \\<subseteq> set alloc\\<rbrakk>\n     \\<Longrightarrow> Path p (f(new (set alloc) := x)) q ps  = Path p f q ps \"", "lemma Null_notin_Path [simp,intro]:\n\"\\<And>p. Path p f q ps \\<Longrightarrow> Null \\<notin> set ps\"", "lemma Path_snoc:\n \"\\<lbrakk>Path p (f(a := q)) a as ; a\\<noteq>Null\\<rbrakk> \\<Longrightarrow> Path p (f(a := q)) q (as @ [a])\"", "lemma List_empty [simp]: \"List p h [] = (p = Null)\"", "lemma List_cons [simp]: \"List p h (a#ps) = (p = a \\<and> p\\<noteq>Null \\<and> List (h p) h ps)\"", "lemma List_Null [simp]: \"List Null h ps = (ps = [])\"", "lemma List_not_Null [simp]: \"p\\<noteq>Null \\<Longrightarrow>\n  List p h as = (\\<exists>ps. as = p#ps \\<and> List (h p) h ps)\"", "lemma Null_notin_List [simp,intro]: \"\\<And>p. List p h ps \\<Longrightarrow> Null \\<notin> set ps\"", "theorem notin_List_update[simp]:\n \"\\<And>p. q \\<notin> set ps \\<Longrightarrow> List p (h(q := y)) ps = List p h ps\"", "lemma List_upd_same_lemma: \"\\<And>p.  p \\<noteq> Null \\<Longrightarrow> \\<not> List p (h(p := p)) ps\"", "lemma List_upd_same [simp]: \"List p (h(p:=p)) ps = (p = Null \\<and> ps = [])\"", "lemma  List_update_new [simp]: \"\\<lbrakk>set ps \\<subseteq> set alloc\\<rbrakk>\n     \\<Longrightarrow> List p (h(new (set alloc) := x)) ps = List p h ps\"", "lemma List_updateI [intro]:\n \"\\<lbrakk>List p h ps; q \\<notin> set ps\\<rbrakk> \\<Longrightarrow> List p (h(q := y)) ps\"", "lemma List_unique: \"\\<And>p bs. List p h as \\<Longrightarrow> List p h bs \\<Longrightarrow> as = bs\"", "lemma List_unique1: \"List p h as \\<Longrightarrow> \\<exists>!as. List p h as\"", "lemma List_app: \"\\<And>p. List p h (as@bs) = (\\<exists>y. Path p h y as \\<and> List y h bs)\"", "lemma List_hd_not_in_tl[simp]: \"List (h p) h ps \\<Longrightarrow> p \\<notin> set ps\"", "lemma List_distinct[simp]: \"\\<And>p. List p h ps \\<Longrightarrow> distinct ps\"", "lemma heap_eq_List_eq:\n  \"\\<And>p. \\<forall>x \\<in> set ps. h x = g x \\<Longrightarrow> List p h ps = List p g ps\"", "lemma heap_eq_ListI:\n  assumes list: \"List p h ps\"\n  assumes hp_eq: \"\\<forall>x \\<in> set ps. h x = g x\"\n  shows \"List p g ps\"", "lemma heap_eq_ListI1:\n  assumes list: \"List p h ps\"\n  assumes hp_eq: \"\\<forall>x \\<in> set ps. g x = h x\"\n  shows \"List p g ps\"", "lemma conj_impl_simp: \"(P \\<and> Q \\<longrightarrow> K) = (P \\<longrightarrow> Q \\<longrightarrow> K)\"", "lemma  List_unique_all_impl_simp [simp]:\n \"List p h ps \\<Longrightarrow> (\\<forall>ps. List p h ps \\<longrightarrow> P ps) = P ps\"", "lemma List_unique_ex_conj_simp [simp]:\n\"List p h ps \\<Longrightarrow> (\\<exists>ps. List p h ps \\<and> P ps) = P ps\"", "lemma List_conv_islist_list: \"List p h ps = (islist p h \\<and> ps = list p h)\"", "lemma List_islist [intro]:\n  \"List p h ps \\<Longrightarrow> islist p h\"", "lemma List_list:\n  \"List p h ps \\<Longrightarrow> list p h = ps\"", "lemma [simp]: \"islist Null h\"", "lemma [simp]: \"p\\<noteq>Null \\<Longrightarrow> islist (h p) h = islist p h\"", "lemma [simp]: \"list Null h = []\"", "lemma list_Ref_conv[simp]:\n \"\\<lbrakk>islist (h p) h; p\\<noteq>Null \\<rbrakk> \\<Longrightarrow> list p h = p # list (h p) h\"", "lemma [simp]: \"islist (h p) h \\<Longrightarrow> p \\<notin> set(list (h p) h)\"", "lemma list_upd_conv[simp]:\n \"islist p h \\<Longrightarrow> y \\<notin> set(list p h) \\<Longrightarrow> list p (h(y := q)) = list p h\"", "lemma islist_upd[simp]:\n \"islist p h \\<Longrightarrow> y \\<notin> set(list p h) \\<Longrightarrow> islist p (h(y := q))\"", "lemma list_distinct[simp]: \"islist p h \\<Longrightarrow> distinct (list p h)\"", "lemma Null_notin_list [simp,intro]: \"islist p h \\<Longrightarrow> Null \\<notin> set (list p h)\""], "translations": [["", "lemma Path_Null_iff [iff]: \"Path Null h y xs  = (xs = [] \\<and> y = Null)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Path Null h y xs = (xs = [] \\<and> y = Null)", "apply(case_tac xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> Path Null h y xs = (xs = [] \\<and> y = Null)\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Path Null h y xs = (xs = [] \\<and> y = Null)", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Path Null h y xs = (xs = [] \\<and> y = Null)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Path_not_Null_iff [simp]: \"p\\<noteq>Null \\<Longrightarrow>\n  Path p h q as = (as = [] \\<and> q = p  \\<or>  (\\<exists>ps. as = p#ps \\<and> Path (h p) h q ps ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> Null \\<Longrightarrow>\n    Path p h q as =\n    (as = [] \\<and> q = p \\<or>\n     (\\<exists>ps. as = p # ps \\<and> Path (h p) h q ps))", "apply(case_tac as)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> Null; as = []\\<rbrakk>\n    \\<Longrightarrow> Path p h q as =\n                      (as = [] \\<and> q = p \\<or>\n                       (\\<exists>ps. as = p # ps \\<and> Path (h p) h q ps))\n 2. \\<And>a list.\n       \\<lbrakk>p \\<noteq> Null; as = a # list\\<rbrakk>\n       \\<Longrightarrow> Path p h q as =\n                         (as = [] \\<and> q = p \\<or>\n                          (\\<exists>ps.\n                              as = p # ps \\<and> Path (h p) h q ps))", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>p \\<noteq> Null; as = a # list\\<rbrakk>\n       \\<Longrightarrow> Path p h q as =\n                         (as = [] \\<and> q = p \\<or>\n                          (\\<exists>ps.\n                              as = p # ps \\<and> Path (h p) h q ps))", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Path_append [simp]:\n  \"\\<And>p. Path p f q (as@bs)  = (\\<exists>y. Path p f y as \\<and> Path y f q bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       Path p f q (as @ bs) =\n       (\\<exists>y. Path p f y as \\<and> Path y f q bs)", "by(induct as, simp+)"], ["", "lemma notin_Path_update[simp]:\n \"\\<And>p. u \\<notin> set ps \\<Longrightarrow> Path p (f(u := v)) q ps  = Path p f q ps \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       u \\<notin> set ps \\<Longrightarrow>\n       Path p (f(u := v)) q ps = Path p f q ps", "by(induct ps, simp, simp add:eq_sym_conv)"], ["", "lemma Path_upd_same [simp]:\n  \"Path p (f(p:=p)) q qs =\n      ((p=Null \\<and> q=Null \\<and> qs = []) \\<or> (p\\<noteq>Null \\<and> q=p \\<and> (\\<forall>x\\<in>set qs. x=p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Path p (f(p := p)) q qs =\n    (p = Null \\<and> q = Null \\<and> qs = [] \\<or>\n     p \\<noteq> Null \\<and> q = p \\<and> (\\<forall>x\\<in>set qs. x = p))", "by (induct qs) auto"], ["", "text \\<open>@{thm[source] Path_upd_same} prevents\n@{term \"p\\<noteq>Null \\<Longrightarrow> Path p (f(p:=p)) q qs = X\"} from looping, because of\n@{thm[source] Path_not_Null_iff} and @{thm[source]fun_upd_apply}.\n\\<close>"], ["", "lemma notin_Path_updateI [intro]:\n \"\\<lbrakk>Path p h q ps ; r \\<notin> set ps\\<rbrakk> \\<Longrightarrow> Path p (h(r := y)) q ps \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Path p h q ps; r \\<notin> set ps\\<rbrakk>\n    \\<Longrightarrow> Path p (h(r := y)) q ps", "by simp"], ["", "lemma Path_update_new [simp]: \"\\<lbrakk>set ps \\<subseteq> set alloc\\<rbrakk>\n     \\<Longrightarrow> Path p (f(new (set alloc) := x)) q ps  = Path p f q ps \""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ps \\<subseteq> set alloc \\<Longrightarrow>\n    Path p (f(new (set alloc) := x)) q ps = Path p f q ps", "by (rule notin_Path_update) fastforce"], ["", "lemma Null_notin_Path [simp,intro]:\n\"\\<And>p. Path p f q ps \\<Longrightarrow> Null \\<notin> set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p. Path p f q ps \\<Longrightarrow> Null \\<notin> set ps", "by(induct ps) auto"], ["", "lemma Path_snoc:\n \"\\<lbrakk>Path p (f(a := q)) a as ; a\\<noteq>Null\\<rbrakk> \\<Longrightarrow> Path p (f(a := q)) q (as @ [a])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Path p (f(a := q)) a as; a \\<noteq> Null\\<rbrakk>\n    \\<Longrightarrow> Path p (f(a := q)) q (as @ [a])", "by simp"], ["", "subsection \"Lists on The Heap\""], ["", "subsubsection \"Relational Abstraction\""], ["", "definition\n List :: \"ref \\<Rightarrow> (ref \\<Rightarrow> ref) \\<Rightarrow> ref list \\<Rightarrow> bool\" where\n\"List p h ps = Path p h Null ps \""], ["", "lemma List_empty [simp]: \"List p h [] = (p = Null)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List p h [] = (p = Null)", "by(simp add:List_def)"], ["", "lemma List_cons [simp]: \"List p h (a#ps) = (p = a \\<and> p\\<noteq>Null \\<and> List (h p) h ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List p h (a # ps) =\n    (p = a \\<and> p \\<noteq> Null \\<and> List (h p) h ps)", "by(simp add:List_def)"], ["", "lemma List_Null [simp]: \"List Null h ps = (ps = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List Null h ps = (ps = [])", "by(case_tac ps, simp_all)"], ["", "lemma List_not_Null [simp]: \"p\\<noteq>Null \\<Longrightarrow>\n  List p h as = (\\<exists>ps. as = p#ps \\<and> List (h p) h ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> Null \\<Longrightarrow>\n    List p h as = (\\<exists>ps. as = p # ps \\<and> List (h p) h ps)", "by(case_tac as, simp_all, fast)"], ["", "lemma Null_notin_List [simp,intro]: \"\\<And>p. List p h ps \\<Longrightarrow> Null \\<notin> set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p. List p h ps \\<Longrightarrow> Null \\<notin> set ps", "by (simp add : List_def)"], ["", "theorem notin_List_update[simp]:\n \"\\<And>p. q \\<notin> set ps \\<Longrightarrow> List p (h(q := y)) ps = List p h ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       q \\<notin> set ps \\<Longrightarrow>\n       List p (h(q := y)) ps = List p h ps", "apply(induct ps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p.\n       q \\<notin> set [] \\<Longrightarrow>\n       List p (h(q := y)) [] = List p h []\n 2. \\<And>a ps p.\n       \\<lbrakk>\\<And>p.\n                   q \\<notin> set ps \\<Longrightarrow>\n                   List p (h(q := y)) ps = List p h ps;\n        q \\<notin> set (a # ps)\\<rbrakk>\n       \\<Longrightarrow> List p (h(q := y)) (a # ps) = List p h (a # ps)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ps p.\n       \\<lbrakk>\\<And>p.\n                   q \\<notin> set ps \\<Longrightarrow>\n                   List p (h(q := y)) ps = List p h ps;\n        q \\<notin> set (a # ps)\\<rbrakk>\n       \\<Longrightarrow> List p (h(q := y)) (a # ps) = List p h (a # ps)", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma List_upd_same_lemma: \"\\<And>p.  p \\<noteq> Null \\<Longrightarrow> \\<not> List p (h(p := p)) ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p. p \\<noteq> Null \\<Longrightarrow> \\<not> List p (h(p := p)) ps", "apply (induct ps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p. p \\<noteq> Null \\<Longrightarrow> \\<not> List p (h(p := p)) []\n 2. \\<And>a ps p.\n       \\<lbrakk>\\<And>p.\n                   p \\<noteq> Null \\<Longrightarrow>\n                   \\<not> List p (h(p := p)) ps;\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<not> List p (h(p := p)) (a # ps)", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ps p.\n       \\<lbrakk>\\<And>p.\n                   p \\<noteq> Null \\<Longrightarrow>\n                   \\<not> List p (h(p := p)) ps;\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<not> List p (h(p := p)) (a # ps)", "apply (simp (no_asm_simp) del: fun_upd_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ps p.\n       \\<lbrakk>\\<And>p.\n                   p \\<noteq> Null \\<Longrightarrow>\n                   \\<not> List p (h(p := p)) ps;\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> p = a \\<longrightarrow>\n                         \\<not> List ((h(a := a)) a) (h(a := a)) ps", "apply (simp (no_asm_simp) only: fun_upd_apply refl if_True)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ps p.\n       \\<lbrakk>\\<And>p.\n                   p \\<noteq> Null \\<Longrightarrow>\n                   \\<not> List p (h(p := p)) ps;\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> p = a \\<longrightarrow>\n                         \\<not> List a (h(a := a)) ps", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma List_upd_same [simp]: \"List p (h(p:=p)) ps = (p = Null \\<and> ps = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List p (h(p := p)) ps = (p = Null \\<and> ps = [])", "apply (cases \"p=Null\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. p = Null \\<Longrightarrow>\n    List p (h(p := p)) ps = (p = Null \\<and> ps = [])\n 2. p \\<noteq> Null \\<Longrightarrow>\n    List p (h(p := p)) ps = (p = Null \\<and> ps = [])", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> Null \\<Longrightarrow>\n    List p (h(p := p)) ps = (p = Null \\<and> ps = [])", "apply (fast dest: List_upd_same_lemma)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>@{thm[source] List_upd_same} prevents\n@{term \"p\\<noteq>Null \\<Longrightarrow> List p (h(p:=p)) as = X\"} from looping, because of\n@{thm[source] List_not_Null} and @{thm[source] fun_upd_apply}.\n\\<close>"], ["", "lemma  List_update_new [simp]: \"\\<lbrakk>set ps \\<subseteq> set alloc\\<rbrakk>\n     \\<Longrightarrow> List p (h(new (set alloc) := x)) ps = List p h ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set ps \\<subseteq> set alloc \\<Longrightarrow>\n    List p (h(new (set alloc) := x)) ps = List p h ps", "by (rule notin_List_update) fastforce"], ["", "lemma List_updateI [intro]:\n \"\\<lbrakk>List p h ps; q \\<notin> set ps\\<rbrakk> \\<Longrightarrow> List p (h(q := y)) ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>List p h ps; q \\<notin> set ps\\<rbrakk>\n    \\<Longrightarrow> List p (h(q := y)) ps", "by simp"], ["", "lemma List_unique: \"\\<And>p bs. List p h as \\<Longrightarrow> List p h bs \\<Longrightarrow> as = bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p bs.\n       \\<lbrakk>List p h as; List p h bs\\<rbrakk> \\<Longrightarrow> as = bs", "by(induct as, simp, clarsimp)"], ["", "lemma List_unique1: \"List p h as \\<Longrightarrow> \\<exists>!as. List p h as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List p h as \\<Longrightarrow> \\<exists>!as. List p h as", "by(blast intro:List_unique)"], ["", "lemma List_app: \"\\<And>p. List p h (as@bs) = (\\<exists>y. Path p h y as \\<and> List y h bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       List p h (as @ bs) = (\\<exists>y. Path p h y as \\<and> List y h bs)", "by(induct as, simp, clarsimp)"], ["", "lemma List_hd_not_in_tl[simp]: \"List (h p) h ps \\<Longrightarrow> p \\<notin> set ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List (h p) h ps \\<Longrightarrow> p \\<notin> set ps", "apply (clarsimp simp add:in_set_conv_decomp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>List (h p) h (ys @ p # zs); ps = ys @ p # zs\\<rbrakk>\n       \\<Longrightarrow> False", "apply(frule List_app[THEN iffD1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>List (h p) h (ys @ p # zs); ps = ys @ p # zs;\n        \\<exists>y. Path (h p) h y ys \\<and> List y h (p # zs)\\<rbrakk>\n       \\<Longrightarrow> False", "apply(fastforce dest: List_unique)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma List_distinct[simp]: \"\\<And>p. List p h ps \\<Longrightarrow> distinct ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p. List p h ps \\<Longrightarrow> distinct ps", "apply(induct ps, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ps p.\n       \\<lbrakk>\\<And>p. List p h ps \\<Longrightarrow> distinct ps;\n        List p h (a # ps)\\<rbrakk>\n       \\<Longrightarrow> distinct (a # ps)", "apply(fastforce dest:List_hd_not_in_tl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma heap_eq_List_eq:\n  \"\\<And>p. \\<forall>x \\<in> set ps. h x = g x \\<Longrightarrow> List p h ps = List p g ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<forall>x\\<in>set ps. h x = g x \\<Longrightarrow>\n       List p h ps = List p g ps", "by (induct ps) auto"], ["", "lemma heap_eq_ListI:\n  assumes list: \"List p h ps\"\n  assumes hp_eq: \"\\<forall>x \\<in> set ps. h x = g x\"\n  shows \"List p g ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List p g ps", "using list"], ["proof (prove)\nusing this:\n  List p h ps\n\ngoal (1 subgoal):\n 1. List p g ps", "by (simp add: heap_eq_List_eq [OF hp_eq])"], ["", "lemma heap_eq_ListI1:\n  assumes list: \"List p h ps\"\n  assumes hp_eq: \"\\<forall>x \\<in> set ps. g x = h x\"\n  shows \"List p g ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List p g ps", "using list"], ["proof (prove)\nusing this:\n  List p h ps\n\ngoal (1 subgoal):\n 1. List p g ps", "by (simp add: heap_eq_List_eq [OF hp_eq])"], ["", "text \\<open>The following lemmata are usefull for the simplifier to instantiate\nbound variables in the assumptions resp. conclusion, using the uniqueness\nof the List predicate\\<close>"], ["", "lemma conj_impl_simp: \"(P \\<and> Q \\<longrightarrow> K) = (P \\<longrightarrow> Q \\<longrightarrow> K)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P \\<and> Q \\<longrightarrow> K) =\n    (P \\<longrightarrow> Q \\<longrightarrow> K)", "by auto"], ["", "lemma  List_unique_all_impl_simp [simp]:\n \"List p h ps \\<Longrightarrow> (\\<forall>ps. List p h ps \\<longrightarrow> P ps) = P ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List p h ps \\<Longrightarrow>\n    (\\<forall>ps. List p h ps \\<longrightarrow> P ps) = P ps", "by (auto dest: List_unique)"], ["", "(*\nlemma  List_unique_all_impl_simp1 [simp]:\n \"List p h ps \\<Longrightarrow> (\\<forall>ps. Q ps \\<longrightarrow> List p h ps \\<longrightarrow> P ps) = Q ps \\<longrightarrow> P ps\"\nby (auto dest: List_unique)\n*)"], ["", "lemma List_unique_ex_conj_simp [simp]:\n\"List p h ps \\<Longrightarrow> (\\<exists>ps. List p h ps \\<and> P ps) = P ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List p h ps \\<Longrightarrow>\n    (\\<exists>ps. List p h ps \\<and> P ps) = P ps", "by (auto dest: List_unique)"], ["", "subsection \"Functional abstraction\""], ["", "definition\n islist :: \"ref \\<Rightarrow> (ref \\<Rightarrow> ref) \\<Rightarrow> bool\" where\n\"islist p h = (\\<exists>ps. List p h ps)\""], ["", "definition\n list :: \"ref \\<Rightarrow> (ref \\<Rightarrow> ref) \\<Rightarrow> ref list\" where\n\"list p h = (THE ps. List p h ps)\""], ["", "lemma List_conv_islist_list: \"List p h ps = (islist p h \\<and> ps = list p h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List p h ps = (islist p h \\<and> ps = list p h)", "apply(simp add:islist_def list_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. List p h ps =\n    ((\\<exists>ps. List p h ps) \\<and> ps = (THE ps. List p h ps))", "apply(rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. List p h ps \\<Longrightarrow>\n    (\\<exists>ps. List p h ps) \\<and> ps = (THE ps. List p h ps)\n 2. (\\<exists>ps. List p h ps) \\<and>\n    ps = (THE ps. List p h ps) \\<Longrightarrow>\n    List p h ps", "apply(rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. List p h ps \\<Longrightarrow> \\<exists>ps. List p h ps\n 2. List p h ps \\<Longrightarrow> ps = (THE ps. List p h ps)\n 3. (\\<exists>ps. List p h ps) \\<and>\n    ps = (THE ps. List p h ps) \\<Longrightarrow>\n    List p h ps", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. List p h ps \\<Longrightarrow> ps = (THE ps. List p h ps)\n 2. (\\<exists>ps. List p h ps) \\<and>\n    ps = (THE ps. List p h ps) \\<Longrightarrow>\n    List p h ps", "apply(subst the1_equality)"], ["proof (prove)\ngoal (4 subgoals):\n 1. List p h ps \\<Longrightarrow> Ex1 (List p h)\n 2. List p h ps \\<Longrightarrow> List p h ?y13\n 3. List p h ps \\<Longrightarrow> ps = ?y13\n 4. (\\<exists>ps. List p h ps) \\<and>\n    ps = (THE ps. List p h ps) \\<Longrightarrow>\n    List p h ps", "apply(erule List_unique1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. List p h ps \\<Longrightarrow> List p h ?y13\n 2. List p h ps \\<Longrightarrow> ps = ?y13\n 3. (\\<exists>ps. List p h ps) \\<and>\n    ps = (THE ps. List p h ps) \\<Longrightarrow>\n    List p h ps", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. List p h ps \\<Longrightarrow> ps = ps\n 2. (\\<exists>ps. List p h ps) \\<and>\n    ps = (THE ps. List p h ps) \\<Longrightarrow>\n    List p h ps", "apply(rule refl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>ps. List p h ps) \\<and>\n    ps = (THE ps. List p h ps) \\<Longrightarrow>\n    List p h ps", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>ps. List p h ps) \\<and>\n    ps = (THE ps. List p h ps) \\<Longrightarrow>\n    List p h (THE ps. List p h ps)", "apply (clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>psa.\n       \\<lbrakk>ps = (THE ps. List p h ps); List p h psa\\<rbrakk>\n       \\<Longrightarrow> List p h (THE ps. List p h ps)", "apply (rule theI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>psa.\n       \\<lbrakk>ps = (THE ps. List p h ps); List p h psa\\<rbrakk>\n       \\<Longrightarrow> List p h (?a19 psa)\n 2. \\<And>psa psaa.\n       \\<lbrakk>ps = (THE ps. List p h ps); List p h psa;\n        List p h psaa\\<rbrakk>\n       \\<Longrightarrow> psaa = ?a19 psa", "apply  assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>psa psaa.\n       \\<lbrakk>ps = (THE ps. List p h ps); List p h psa;\n        List p h psaa\\<rbrakk>\n       \\<Longrightarrow> psaa = psa", "by (rule List_unique)"], ["", "lemma List_islist [intro]:\n  \"List p h ps \\<Longrightarrow> islist p h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List p h ps \\<Longrightarrow> islist p h", "apply (simp add: List_conv_islist_list)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma List_list:\n  \"List p h ps \\<Longrightarrow> list p h = ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List p h ps \\<Longrightarrow> list p h = ps", "apply (simp only: List_conv_islist_list)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [simp]: \"islist Null h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. islist Null h", "by(simp add:islist_def)"], ["", "lemma [simp]: \"p\\<noteq>Null \\<Longrightarrow> islist (h p) h = islist p h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> Null \\<Longrightarrow> islist (h p) h = islist p h", "by(simp add:islist_def)"], ["", "lemma [simp]: \"list Null h = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list Null h = []", "by(simp add:list_def)"], ["", "lemma list_Ref_conv[simp]:\n \"\\<lbrakk>islist (h p) h; p\\<noteq>Null \\<rbrakk> \\<Longrightarrow> list p h = p # list (h p) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>islist (h p) h; p \\<noteq> Null\\<rbrakk>\n    \\<Longrightarrow> list p h = p # list (h p) h", "apply(insert List_not_Null[of _ h])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>islist (h p) h; p \\<noteq> Null;\n     \\<And>p as.\n        p \\<noteq> Null \\<Longrightarrow>\n        List p h as =\n        (\\<exists>ps. as = p # ps \\<and> List (h p) h ps)\\<rbrakk>\n    \\<Longrightarrow> list p h = p # list (h p) h", "apply(fastforce simp:List_conv_islist_list)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [simp]: \"islist (h p) h \\<Longrightarrow> p \\<notin> set(list (h p) h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. islist (h p) h \\<Longrightarrow> p \\<notin> set (list (h p) h)", "apply(insert List_hd_not_in_tl[of h])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>islist (h p) h;\n     \\<And>p ps.\n        List (h p) h ps \\<Longrightarrow> p \\<notin> set ps\\<rbrakk>\n    \\<Longrightarrow> p \\<notin> set (list (h p) h)", "apply(simp add:List_conv_islist_list)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_upd_conv[simp]:\n \"islist p h \\<Longrightarrow> y \\<notin> set(list p h) \\<Longrightarrow> list p (h(y := q)) = list p h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>islist p h; y \\<notin> set (list p h)\\<rbrakk>\n    \\<Longrightarrow> list p (h(y := q)) = list p h", "apply(drule notin_List_update[of _ _ p h q])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>islist p h;\n     List p (h(y := q)) (list p h) = List p h (list p h)\\<rbrakk>\n    \\<Longrightarrow> list p (h(y := q)) = list p h", "apply(simp add:List_conv_islist_list)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma islist_upd[simp]:\n \"islist p h \\<Longrightarrow> y \\<notin> set(list p h) \\<Longrightarrow> islist p (h(y := q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>islist p h; y \\<notin> set (list p h)\\<rbrakk>\n    \\<Longrightarrow> islist p (h(y := q))", "apply(frule notin_List_update[of _ _ p h q])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>islist p h; y \\<notin> set (list p h);\n     List p (h(y := q)) (list p h) = List p h (list p h)\\<rbrakk>\n    \\<Longrightarrow> islist p (h(y := q))", "apply(simp add:List_conv_islist_list)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_distinct[simp]: \"islist p h \\<Longrightarrow> distinct (list p h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. islist p h \\<Longrightarrow> distinct (list p h)", "apply (clarsimp simp add: list_def islist_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps. List p h ps \\<Longrightarrow> distinct (THE ps. List p h ps)", "apply (frule List_unique1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps.\n       \\<lbrakk>List p h ps; \\<exists>!as. List p h as\\<rbrakk>\n       \\<Longrightarrow> distinct (THE ps. List p h ps)", "apply (drule (1) the1_equality)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps.\n       \\<lbrakk>List p h ps; (THE as. List p h as) = ps\\<rbrakk>\n       \\<Longrightarrow> distinct (THE ps. List p h ps)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Null_notin_list [simp,intro]: \"islist p h \\<Longrightarrow> Null \\<notin> set (list p h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. islist p h \\<Longrightarrow> Null \\<notin> set (list p h)", "apply (clarsimp simp add: list_def islist_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps.\n       \\<lbrakk>List p h ps; Null \\<in> set (THE ps. List p h ps)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (frule List_unique1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps.\n       \\<lbrakk>List p h ps; Null \\<in> set (THE ps. List p h ps);\n        \\<exists>!as. List p h as\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule (1) the1_equality)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ps.\n       \\<lbrakk>List p h ps; Null \\<in> set (THE ps. List p h ps);\n        (THE as. List p h as) = ps\\<rbrakk>\n       \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}