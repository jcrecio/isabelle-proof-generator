{"file_name": "/home/qj213/afp-2021-10-22/thys/Simpl/ex/ComposeEx.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Simpl", "problem_names": ["lemma (in Rev_impl)\n Rev_modifies:\n  \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^bsub>/UNIV \\<^esub>{\\<sigma>} \\<acute>sl_q :== PROC Rev(\\<acute>p) {t. t may_only_modify_globals \\<sigma> in [next]}\"", "lemma (in Rev_impl) shows\n Rev_spec:\n  \"\\<forall>Ps. \\<Gamma>\\<turnstile> \\<lbrace>List \\<acute>p \\<acute>next Ps\\<rbrace> \\<acute>sl_q :== PROC Rev(\\<acute>p) \\<lbrace>List \\<acute>sl_q \\<acute>next (rev Ps)\\<rbrace>\"", "lemma globals_inject_project_str_commutes:\n  \"inject_globals_str G (project_globals_str G) = G\"", "lemma inject_project_str_commutes: \"inject_str S (project_str S) = S\"", "lemma globals_project_inject_str_commutes:\n  \"project_globals_str (inject_globals_str G g) = g\"", "lemma project_inject_str_commutes: \"project_str (inject_str S s) = s\"", "lemma globals_inject_str_last:\n  \"inject_globals_str (inject_globals_str G g) g' = inject_globals_str G g'\"", "lemma inject_str_last:\n  \"inject_str (inject_str S s) s' = inject_str S s'\"", "lemmas Rev_lift_spec = ex.lift_hoarep' [OF Rev_impl.Rev_spec,simplified lift\\<^sub>s_def\n project_str_def project_globals_str_def,simplified, of _ \"''Rev''\"]", "lemmas Rev_lift_spec' =\n  Rev_lift_spec [of \"[''Rev''\\<mapsto>Rev_body.Rev_body]\" ,\n     simplified Rev_impl_def Rev_clique_def,simplified]", "lemma Rev_lift_spec'':\n  \"\\<forall>Ps. lift\\<^sub>e [''Rev'' \\<mapsto> Rev_body.Rev_body]\n       \\<turnstile> \\<lbrace>List \\<acute>str \\<acute>strnext Ps\\<rbrace> Call ''Rev'' \\<lbrace>List \\<acute>q \\<acute>strnext (rev Ps)\\<rbrace>\"", "lemma (in RevStr_impl) \\<N>_ok:\n\"\\<forall>p bdy. (lift\\<^sub>e [''Rev'' \\<mapsto> Rev_body.Rev_body]) p = Some bdy \\<longrightarrow>\n     \\<Gamma> (\\<N> RevStr_'proc p) = Some (rename (\\<N> RevStr_'proc) bdy)\"", "lemmas (in RevStr_impl) RevStr_spec =\n  hoare_to_hoare_rename' [OF _ Rev_lift_spec'', OF \\<N>_ok,\n  simplified \\<N>_def, simplified ]", "lemma (in RevStr_impl) RevStr_spec':\n\"\\<forall>Ps. \\<Gamma>\\<turnstile> \\<lbrace>List \\<acute>str \\<acute>strnext Ps\\<rbrace> \\<acute>q :== PROC RevStr(\\<acute>str)\n          \\<lbrace>List \\<acute>q \\<acute>strnext (rev Ps)\\<rbrace>\"", "lemmas Rev_modifies' =\n  Rev_impl.Rev_modifies [of \"[''Rev''\\<mapsto>Rev_body.Rev_body]\", simplified Rev_impl_def,\n   simplified]", "lemmas RevStr_modifies' =\n  hoare_to_hoare_rename' [OF _ ex.hoare_lift_modifies' [OF Rev_modifies'],\n         OF \\<N>_ok, of \"''Rev''\", simplified \\<N>_def Rev_clique_def,simplified]", "lemma (in RevStr_impl) RevStr_modifies:\n\"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^bsub>/UNIV \\<^esub>{\\<sigma>} \\<acute>str :== PROC RevStr(\\<acute>str)\n  {t. t may_only_modify_globals \\<sigma> in [strnext]}\""], "translations": [["", "lemma (in Rev_impl)\n Rev_modifies:\n  \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^bsub>/UNIV \\<^esub>{\\<sigma>} \\<acute>sl_q :== PROC Rev(\\<acute>p) {t. t may_only_modify_globals \\<sigma> in [next]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^bsub>/UNIV\\<^esub> {\\<sigma>}\n      \\<acute>sl_q :== PROC Rev(\\<acute>p)\n      {t. t may_only_modify_globals \\<sigma> in [next]}", "apply (hoare_rule HoarePartial.ProcNoRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^bsub>/UNIV\\<^esub> {\\<sigma>}\n      \\<acute>sl_q :== Null;;\n      WHILE \\<acute>p \\<noteq> Null \n      DO \\<acute>r :== \\<acute>p;;\n         (False, \\<lbrace>\\<acute>p \\<noteq> Null\\<rbrace>)\n         \\<longmapsto> \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n         (False, \\<lbrace>\\<acute>r \\<noteq> Null\\<rbrace>)\n         \\<longmapsto> \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>sl_q;;\n         \\<acute>sl_q :== \\<acute>r \n      OD\n      {t. t may_only_modify_globals \\<sigma> in [next]}", "apply (vcg spec=modifies)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in Rev_impl) shows\n Rev_spec:\n  \"\\<forall>Ps. \\<Gamma>\\<turnstile> \\<lbrace>List \\<acute>p \\<acute>next Ps\\<rbrace> \\<acute>sl_q :== PROC Rev(\\<acute>p) \\<lbrace>List \\<acute>sl_q \\<acute>next (rev Ps)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Ps.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>List \\<acute>p \\<acute>next Ps\\<rbrace>\n                       \\<acute>sl_q :== PROC Rev(\\<acute>p)\n                       \\<lbrace>List \\<acute>sl_q \\<acute>next\n                                 (rev Ps)\\<rbrace>", "apply (hoare_rule HoarePartial.ProcNoRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Ps.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>List \\<acute>p \\<acute>next Ps\\<rbrace>\n                       \\<acute>sl_q :== Null;;\n                       WHILE \\<acute>p \\<noteq> Null \n                       DO \\<acute>r :== \\<acute>p;;\n                          (False, \\<lbrace>\\<acute>p \\<noteq> Null\\<rbrace>)\n                          \\<longmapsto> \\<acute>p :==\n  \\<acute>p\\<rightarrow>\\<acute>next;;\n                          (False, \\<lbrace>\\<acute>r \\<noteq> Null\\<rbrace>)\n                          \\<longmapsto> \\<acute>r\\<rightarrow>\\<acute>next :==\n  \\<acute>sl_q;;\n                          \\<acute>sl_q :== \\<acute>r \n                       OD\n                       \\<lbrace>List \\<acute>sl_q \\<acute>next\n                                 (rev Ps)\\<rbrace>", "apply (hoare_rule anno =\n       \"\\<acute>sl_q :== Null;;\n       WHILE \\<acute>p \\<noteq> Null INV \\<lbrace>\\<exists>Ps' Qs'. List \\<acute>p \\<acute>next Ps' \\<and> List \\<acute>sl_q \\<acute>next Qs' \\<and>\n                             set Ps' \\<inter> set Qs' = {} \\<and>\n                             rev Ps' @ Qs' = rev Ps\\<rbrace>\n        DO\n         \\<acute>r :== \\<acute>p;; \\<lbrace>\\<acute>p \\<noteq> Null\\<rbrace>\\<longmapsto>\\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n         \\<lbrace>\\<acute>r \\<noteq> Null\\<rbrace>\\<longmapsto> \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>sl_q;; \\<acute>sl_q :== \\<acute>r\n       OD\" in HoarePartial.annotateI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>List \\<acute>p \\<acute>next Ps\\<rbrace>\n                       \\<acute>sl_q :== Null;;\n                       WHILE \\<acute>p \\<noteq> Null\n                       INV \\<lbrace>\\<exists>Ps' Qs'.\n List \\<acute>p \\<acute>next Ps' \\<and>\n List \\<acute>sl_q \\<acute>next Qs' \\<and>\n set Ps' \\<inter> set Qs' = {} \\<and> rev Ps' @ Qs' = rev Ps\\<rbrace> \n                       DO \\<acute>r :== \\<acute>p;;\n                          (False, \\<lbrace>\\<acute>p \\<noteq> Null\\<rbrace>)\n                          \\<longmapsto> \\<acute>p :==\n  \\<acute>p\\<rightarrow>\\<acute>next;;\n                          (False, \\<lbrace>\\<acute>r \\<noteq> Null\\<rbrace>)\n                          \\<longmapsto> \\<acute>r\\<rightarrow>\\<acute>next :==\n  \\<acute>sl_q;;\n                          \\<acute>sl_q :== \\<acute>r \n                       OD\n                       \\<lbrace>List \\<acute>sl_q \\<acute>next\n                                 (rev Ps)\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Ps next p.\n       List p next Ps \\<Longrightarrow>\n       \\<exists>Ps' Qs'.\n          List p next Ps' \\<and>\n          List Null next Qs' \\<and>\n          set Ps' \\<inter> set Qs' = {} \\<and> rev Ps' @ Qs' = rev Ps\n 2. \\<And>Ps next p sl_q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List sl_q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> p \\<noteq> Null \\<and>\n                         p \\<noteq> Null \\<and>\n                         (\\<exists>Ps' Qs'.\n                             List (next p) (next(p := sl_q)) Ps' \\<and>\n                             List p (next(p := sl_q)) Qs' \\<and>\n                             set Ps' \\<inter> set Qs' = {} \\<and>\n                             rev Ps' @ Qs' = rev Ps)\n 3. \\<And>Ps next p sl_q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List sl_q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List sl_q next (rev Ps)", "apply   clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Ps next p sl_q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List sl_q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> p \\<noteq> Null \\<and>\n                         p \\<noteq> Null \\<and>\n                         (\\<exists>Ps' Qs'.\n                             List (next p) (next(p := sl_q)) Ps' \\<and>\n                             List p (next(p := sl_q)) Qs' \\<and>\n                             set Ps' \\<inter> set Qs' = {} \\<and>\n                             rev Ps' @ Qs' = rev Ps)\n 2. \\<And>Ps next p sl_q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List sl_q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List sl_q next (rev Ps)", "apply  fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps next p sl_q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List sl_q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List sl_q next (rev Ps)", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare [[names_unique = false]]"], ["", "record globals =\n  strnext_'   :: \"ref \\<Rightarrow> ref\"\n  chr_'    :: \"ref \\<Rightarrow> char\"\n\n  qnext_' :: \"ref \\<Rightarrow> ref\"\n  cont_'   :: \"ref \\<Rightarrow> int\""], ["", "record state = \"globals state\" +\n  str_'  :: \"ref\"\n  queue_':: \"ref\"\n  q_'    :: \"ref\"\n  r_'    :: \"ref\""], ["", "definition project_globals_str:: \"globals \\<Rightarrow> globals_list\"\n  where \"project_globals_str g = \\<lparr>next_' = strnext_' g\\<rparr>\""], ["", "definition project_str:: \"state \\<Rightarrow> state_list\"\nwhere\n\"project_str s =\n  \\<lparr>globals = project_globals_str (globals s),\n   state_list.p_' = str_' s, sl_q_' = q_' s, state_list.r_' = r_' s\\<rparr>\""], ["", "definition inject_globals_str::\n  \"globals \\<Rightarrow> globals_list \\<Rightarrow> globals\"\nwhere\n  \"inject_globals_str G g =\n   G\\<lparr>strnext_' := next_' g\\<rparr>\""], ["", "definition \"inject_str\"::\"state \\<Rightarrow> state_list \\<Rightarrow> state\" where\n\"inject_str S s = S\\<lparr>globals := inject_globals_str (globals S) (globals s),\n                str_' := state_list.p_' s, q_' := sl_q_' s,\n                r_' := state_list.r_' s\\<rparr>\""], ["", "lemma globals_inject_project_str_commutes:\n  \"inject_globals_str G (project_globals_str G) = G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inject_globals_str G (project_globals_str G) = G", "by (simp add: inject_globals_str_def project_globals_str_def)"], ["", "lemma inject_project_str_commutes: \"inject_str S (project_str S) = S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inject_str S (project_str S) = S", "by (simp add: inject_str_def project_str_def globals_inject_project_str_commutes)"], ["", "lemma globals_project_inject_str_commutes:\n  \"project_globals_str (inject_globals_str G g) = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. project_globals_str (inject_globals_str G g) = g", "by (simp add: inject_globals_str_def project_globals_str_def)"], ["", "lemma project_inject_str_commutes: \"project_str (inject_str S s) = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. project_str (inject_str S s) = s", "by (simp add: inject_str_def project_str_def globals_project_inject_str_commutes)"], ["", "lemma globals_inject_str_last:\n  \"inject_globals_str (inject_globals_str G g) g' = inject_globals_str G g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inject_globals_str (inject_globals_str G g) g' = inject_globals_str G g'", "by (simp add: inject_globals_str_def)"], ["", "lemma inject_str_last:\n  \"inject_str (inject_str S s) s' = inject_str S s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inject_str (inject_str S s) s' = inject_str S s'", "by (simp add: inject_str_def globals_inject_str_last)"], ["", "definition\n  \"lift\\<^sub>e = (\\<lambda>\\<Gamma> p. map_option (lift\\<^sub>c project_str inject_str) (\\<Gamma> p))\""], ["", "print_locale lift_state_space"], ["", "interpretation ex: lift_state_space project_str inject_str\n  \"xstate_map project_str\" lift\\<^sub>e \"lift\\<^sub>c project_str inject_str\"\n  \"lift\\<^sub>f project_str inject_str\" \"lift\\<^sub>s project_str\"\n  \"lift\\<^sub>r project_str inject_str\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lift_state_space project_str inject_str &&&\n     (lift\\<^sub>c project_str inject_str \\<equiv>\n      lift\\<^sub>c project_str inject_str) &&&\n     xstate_map project_str \\<equiv> xstate_map project_str) &&&\n    ((lift\\<^sub>e \\<equiv>\n      \\<lambda>\\<Gamma> p.\n         map_option (lift\\<^sub>c project_str inject_str) (\\<Gamma> p)) &&&\n     lift\\<^sub>f project_str inject_str \\<equiv>\n     lift\\<^sub>f project_str inject_str) &&&\n    (lift\\<^sub>s project_str \\<equiv> lift\\<^sub>s project_str) &&&\n    lift\\<^sub>r project_str inject_str \\<equiv>\n    lift\\<^sub>r project_str inject_str", "apply -"], ["proof (prove)\ngoal (7 subgoals):\n 1. lift_state_space project_str inject_str\n 2. lift\\<^sub>c project_str inject_str \\<equiv>\n    lift\\<^sub>c project_str inject_str\n 3. xstate_map project_str \\<equiv> xstate_map project_str\n 4. lift\\<^sub>e \\<equiv>\n    \\<lambda>\\<Gamma> p.\n       map_option (lift\\<^sub>c project_str inject_str) (\\<Gamma> p)\n 5. lift\\<^sub>f project_str inject_str \\<equiv>\n    lift\\<^sub>f project_str inject_str\n 6. lift\\<^sub>s project_str \\<equiv> lift\\<^sub>s project_str\n 7. lift\\<^sub>r project_str inject_str \\<equiv>\n    lift\\<^sub>r project_str inject_str", "apply       (rule lift_state_space.intro)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>S s. project_str (inject_str S s) = s\n 2. lift\\<^sub>c project_str inject_str \\<equiv>\n    lift\\<^sub>c project_str inject_str\n 3. xstate_map project_str \\<equiv> xstate_map project_str\n 4. lift\\<^sub>e \\<equiv>\n    \\<lambda>\\<Gamma> p.\n       map_option (lift\\<^sub>c project_str inject_str) (\\<Gamma> p)\n 5. lift\\<^sub>f project_str inject_str \\<equiv>\n    lift\\<^sub>f project_str inject_str\n 6. lift\\<^sub>s project_str \\<equiv> lift\\<^sub>s project_str\n 7. lift\\<^sub>r project_str inject_str \\<equiv>\n    lift\\<^sub>r project_str inject_str", "apply       (rule project_inject_str_commutes)"], ["proof (prove)\ngoal (6 subgoals):\n 1. lift\\<^sub>c project_str inject_str \\<equiv>\n    lift\\<^sub>c project_str inject_str\n 2. xstate_map project_str \\<equiv> xstate_map project_str\n 3. lift\\<^sub>e \\<equiv>\n    \\<lambda>\\<Gamma> p.\n       map_option (lift\\<^sub>c project_str inject_str) (\\<Gamma> p)\n 4. lift\\<^sub>f project_str inject_str \\<equiv>\n    lift\\<^sub>f project_str inject_str\n 5. lift\\<^sub>s project_str \\<equiv> lift\\<^sub>s project_str\n 6. lift\\<^sub>r project_str inject_str \\<equiv>\n    lift\\<^sub>r project_str inject_str", "apply      simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. xstate_map project_str \\<equiv> xstate_map project_str\n 2. lift\\<^sub>e \\<equiv>\n    \\<lambda>\\<Gamma> p.\n       map_option (lift\\<^sub>c project_str inject_str) (\\<Gamma> p)\n 3. lift\\<^sub>f project_str inject_str \\<equiv>\n    lift\\<^sub>f project_str inject_str\n 4. lift\\<^sub>s project_str \\<equiv> lift\\<^sub>s project_str\n 5. lift\\<^sub>r project_str inject_str \\<equiv>\n    lift\\<^sub>r project_str inject_str", "apply     simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. lift\\<^sub>e \\<equiv>\n    \\<lambda>\\<Gamma> p.\n       map_option (lift\\<^sub>c project_str inject_str) (\\<Gamma> p)\n 2. lift\\<^sub>f project_str inject_str \\<equiv>\n    lift\\<^sub>f project_str inject_str\n 3. lift\\<^sub>s project_str \\<equiv> lift\\<^sub>s project_str\n 4. lift\\<^sub>r project_str inject_str \\<equiv>\n    lift\\<^sub>r project_str inject_str", "apply    (simp add: lift\\<^sub>e_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. lift\\<^sub>f project_str inject_str \\<equiv>\n    lift\\<^sub>f project_str inject_str\n 2. lift\\<^sub>s project_str \\<equiv> lift\\<^sub>s project_str\n 3. lift\\<^sub>r project_str inject_str \\<equiv>\n    lift\\<^sub>r project_str inject_str", "apply   simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. lift\\<^sub>s project_str \\<equiv> lift\\<^sub>s project_str\n 2. lift\\<^sub>r project_str inject_str \\<equiv>\n    lift\\<^sub>r project_str inject_str", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. lift\\<^sub>r project_str inject_str \\<equiv>\n    lift\\<^sub>r project_str inject_str", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation ex: lift_state_space_ext project_str inject_str\n  \"xstate_map project_str\" lift\\<^sub>e \"lift\\<^sub>c project_str inject_str\"\n  \"lift\\<^sub>f project_str inject_str\" \"lift\\<^sub>s project_str\"\n  \"lift\\<^sub>r project_str inject_str\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lift_state_space_ext project_str inject_str &&&\n     (lift\\<^sub>c project_str inject_str \\<equiv>\n      lift\\<^sub>c project_str inject_str) &&&\n     xstate_map project_str \\<equiv> xstate_map project_str) &&&\n    ((lift\\<^sub>e \\<equiv>\n      \\<lambda>\\<Gamma> p.\n         map_option (lift\\<^sub>c project_str inject_str) (\\<Gamma> p)) &&&\n     lift\\<^sub>f project_str inject_str \\<equiv>\n     lift\\<^sub>f project_str inject_str) &&&\n    (lift\\<^sub>s project_str \\<equiv> lift\\<^sub>s project_str) &&&\n    lift\\<^sub>r project_str inject_str \\<equiv>\n    lift\\<^sub>r project_str inject_str", "(*  project_str \"inject_str\" _ lift\\<^sub>e *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (lift_state_space_ext project_str inject_str &&&\n     (lift\\<^sub>c project_str inject_str \\<equiv>\n      lift\\<^sub>c project_str inject_str) &&&\n     xstate_map project_str \\<equiv> xstate_map project_str) &&&\n    ((lift\\<^sub>e \\<equiv>\n      \\<lambda>\\<Gamma> p.\n         map_option (lift\\<^sub>c project_str inject_str) (\\<Gamma> p)) &&&\n     lift\\<^sub>f project_str inject_str \\<equiv>\n     lift\\<^sub>f project_str inject_str) &&&\n    (lift\\<^sub>s project_str \\<equiv> lift\\<^sub>s project_str) &&&\n    lift\\<^sub>r project_str inject_str \\<equiv>\n    lift\\<^sub>r project_str inject_str", "apply -"], ["proof (prove)\ngoal (7 subgoals):\n 1. lift_state_space_ext project_str inject_str\n 2. lift\\<^sub>c project_str inject_str \\<equiv>\n    lift\\<^sub>c project_str inject_str\n 3. xstate_map project_str \\<equiv> xstate_map project_str\n 4. lift\\<^sub>e \\<equiv>\n    \\<lambda>\\<Gamma> p.\n       map_option (lift\\<^sub>c project_str inject_str) (\\<Gamma> p)\n 5. lift\\<^sub>f project_str inject_str \\<equiv>\n    lift\\<^sub>f project_str inject_str\n 6. lift\\<^sub>s project_str \\<equiv> lift\\<^sub>s project_str\n 7. lift\\<^sub>r project_str inject_str \\<equiv>\n    lift\\<^sub>r project_str inject_str", "apply intro_locales [1]"], ["proof (prove)\ngoal (7 subgoals):\n 1. lift_state_space_ext_axioms project_str inject_str\n 2. lift\\<^sub>c project_str inject_str \\<equiv>\n    lift\\<^sub>c project_str inject_str\n 3. xstate_map project_str \\<equiv> xstate_map project_str\n 4. lift\\<^sub>e \\<equiv>\n    \\<lambda>\\<Gamma> p.\n       map_option (lift\\<^sub>c project_str inject_str) (\\<Gamma> p)\n 5. lift\\<^sub>f project_str inject_str \\<equiv>\n    lift\\<^sub>f project_str inject_str\n 6. lift\\<^sub>s project_str \\<equiv> lift\\<^sub>s project_str\n 7. lift\\<^sub>r project_str inject_str \\<equiv>\n    lift\\<^sub>r project_str inject_str", "apply (rule lift_state_space_ext_axioms.intro)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>S. inject_str S (project_str S) = S\n 2. \\<And>S s t. inject_str (inject_str S s) t = inject_str S t\n 3. lift\\<^sub>c project_str inject_str \\<equiv>\n    lift\\<^sub>c project_str inject_str\n 4. xstate_map project_str \\<equiv> xstate_map project_str\n 5. lift\\<^sub>e \\<equiv>\n    \\<lambda>\\<Gamma> p.\n       map_option (lift\\<^sub>c project_str inject_str) (\\<Gamma> p)\n 6. lift\\<^sub>f project_str inject_str \\<equiv>\n    lift\\<^sub>f project_str inject_str\n 7. lift\\<^sub>s project_str \\<equiv> lift\\<^sub>s project_str\n 8. lift\\<^sub>r project_str inject_str \\<equiv>\n    lift\\<^sub>r project_str inject_str", "apply  (rule inject_project_str_commutes)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>S s t. inject_str (inject_str S s) t = inject_str S t\n 2. lift\\<^sub>c project_str inject_str \\<equiv>\n    lift\\<^sub>c project_str inject_str\n 3. xstate_map project_str \\<equiv> xstate_map project_str\n 4. lift\\<^sub>e \\<equiv>\n    \\<lambda>\\<Gamma> p.\n       map_option (lift\\<^sub>c project_str inject_str) (\\<Gamma> p)\n 5. lift\\<^sub>f project_str inject_str \\<equiv>\n    lift\\<^sub>f project_str inject_str\n 6. lift\\<^sub>s project_str \\<equiv> lift\\<^sub>s project_str\n 7. lift\\<^sub>r project_str inject_str \\<equiv>\n    lift\\<^sub>r project_str inject_str", "apply (rule inject_str_last)"], ["proof (prove)\ngoal (6 subgoals):\n 1. lift\\<^sub>c project_str inject_str \\<equiv>\n    lift\\<^sub>c project_str inject_str\n 2. xstate_map project_str \\<equiv> xstate_map project_str\n 3. lift\\<^sub>e \\<equiv>\n    \\<lambda>\\<Gamma> p.\n       map_option (lift\\<^sub>c project_str inject_str) (\\<Gamma> p)\n 4. lift\\<^sub>f project_str inject_str \\<equiv>\n    lift\\<^sub>f project_str inject_str\n 5. lift\\<^sub>s project_str \\<equiv> lift\\<^sub>s project_str\n 6. lift\\<^sub>r project_str inject_str \\<equiv>\n    lift\\<^sub>r project_str inject_str", "apply (simp_all add: lift\\<^sub>e_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*\n  apply (intro_locales)\n  apply (rule lift_state_space_ext_axioms.intro)\n  apply  (rule inject_project_str_commutes)\n  apply (rule inject_str_last)\n  done\n*)\n\n(*\ndeclare lift_set_def [simp] project_def [simp] project_globals_def [simp]\n*)"], ["", "lemmas Rev_lift_spec = ex.lift_hoarep' [OF Rev_impl.Rev_spec,simplified lift\\<^sub>s_def\n project_str_def project_globals_str_def,simplified, of _ \"''Rev''\"]"], ["", "print_theorems"], ["", "definition \"\\<N> p' p = (if p=''Rev'' then p' else '''')\""], ["", "procedures RevStr(str|q) = \"rename (\\<N> RevStr_'proc)\n                (lift\\<^sub>c project_str inject_str (Rev_body.Rev_body))\""], ["", "lemmas Rev_lift_spec' =\n  Rev_lift_spec [of \"[''Rev''\\<mapsto>Rev_body.Rev_body]\" ,\n     simplified Rev_impl_def Rev_clique_def,simplified]"], ["", "thm Rev_lift_spec'"], ["", "lemma Rev_lift_spec'':\n  \"\\<forall>Ps. lift\\<^sub>e [''Rev'' \\<mapsto> Rev_body.Rev_body]\n       \\<turnstile> \\<lbrace>List \\<acute>str \\<acute>strnext Ps\\<rbrace> Call ''Rev'' \\<lbrace>List \\<acute>q \\<acute>strnext (rev Ps)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Ps.\n       lift\\<^sub>e [''Rev'' \\<mapsto> Rev_body.Rev_body]\n          \\<turnstile> \\<lbrace>List \\<acute>str \\<acute>strnext Ps\\<rbrace>\n                       Call ''Rev''\n                       \\<lbrace>List \\<acute>q \\<acute>strnext\n                                 (rev Ps)\\<rbrace>", "by (rule Rev_lift_spec')"], ["", "lemma (in RevStr_impl) \\<N>_ok:\n\"\\<forall>p bdy. (lift\\<^sub>e [''Rev'' \\<mapsto> Rev_body.Rev_body]) p = Some bdy \\<longrightarrow>\n     \\<Gamma> (\\<N> RevStr_'proc p) = Some (rename (\\<N> RevStr_'proc) bdy)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p bdy.\n       lift\\<^sub>e [''Rev'' \\<mapsto> Rev_body.Rev_body] p =\n       Some bdy \\<longrightarrow>\n       \\<Gamma> (\\<N> RevStr_'proc p) =\n       Some (rename (\\<N> RevStr_'proc) bdy)", "apply (insert RevStr_impl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma> RevStr_'proc = Some RevStr_body \\<Longrightarrow>\n    \\<forall>p bdy.\n       lift\\<^sub>e [''Rev'' \\<mapsto> Rev_body.Rev_body] p =\n       Some bdy \\<longrightarrow>\n       \\<Gamma> (\\<N> RevStr_'proc p) =\n       Some (rename (\\<N> RevStr_'proc) bdy)", "apply (auto simp add: RevStr_body_def lift\\<^sub>e_def \\<N>_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context RevStr_impl\nbegin"], ["", "thm hoare_to_hoare_rename'[OF _ Rev_lift_spec'', OF \\<N>_ok,\n  simplified \\<N>_def, simplified ]"], ["", "end"], ["", "lemmas (in RevStr_impl) RevStr_spec =\n  hoare_to_hoare_rename' [OF _ Rev_lift_spec'', OF \\<N>_ok,\n  simplified \\<N>_def, simplified ]"], ["", "lemma (in RevStr_impl) RevStr_spec':\n\"\\<forall>Ps. \\<Gamma>\\<turnstile> \\<lbrace>List \\<acute>str \\<acute>strnext Ps\\<rbrace> \\<acute>q :== PROC RevStr(\\<acute>str)\n          \\<lbrace>List \\<acute>q \\<acute>strnext (rev Ps)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Ps.\n       \\<Gamma>\n          \\<turnstile> \\<lbrace>List \\<acute>str \\<acute>strnext Ps\\<rbrace>\n                       \\<acute>q :== PROC RevStr(\\<acute>str)\n                       \\<lbrace>List \\<acute>q \\<acute>strnext\n                                 (rev Ps)\\<rbrace>", "by (rule RevStr_spec)"], ["", "lemmas Rev_modifies' =\n  Rev_impl.Rev_modifies [of \"[''Rev''\\<mapsto>Rev_body.Rev_body]\", simplified Rev_impl_def,\n   simplified]"], ["", "thm Rev_modifies'"], ["", "context RevStr_impl\nbegin"], ["", "lemmas RevStr_modifies' =\n  hoare_to_hoare_rename' [OF _ ex.hoare_lift_modifies' [OF Rev_modifies'],\n         OF \\<N>_ok, of \"''Rev''\", simplified \\<N>_def Rev_clique_def,simplified]"], ["", "end"], ["", "lemma (in RevStr_impl) RevStr_modifies:\n\"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^bsub>/UNIV \\<^esub>{\\<sigma>} \\<acute>str :== PROC RevStr(\\<acute>str)\n  {t. t may_only_modify_globals \\<sigma> in [strnext]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^bsub>/UNIV\\<^esub> {\\<sigma>}\n      \\<acute>q :== PROC RevStr(\\<acute>str)\n      {t. t may_only_modify_globals \\<sigma> in [strnext]}", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^bsub>/UNIV\\<^esub> {\\<sigma>}\n      \\<acute>q :== PROC RevStr(\\<acute>str)\n      {t. t may_only_modify_globals \\<sigma> in [strnext]}", "apply (rule HoarePartialProps.ConseqMGT [OF RevStr_modifies'])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> s.\n       s \\<in> {\\<sigma>} \\<Longrightarrow>\n       s \\<in> {s} \\<and>\n       (\\<forall>t.\n           t \\<in> {T \\<in> lift\\<^sub>s project_str\n                             {t. mex (\\<lambda>next_'.\n   t may_not_modify_globals globals (project_str s))}.\n                    \\<exists>T'. T = inject_str s T'} \\<longrightarrow>\n           t \\<in> {t. t may_only_modify_globals \\<sigma> in [strnext]}) \\<and>\n       (\\<forall>t.\n           t \\<in> {T \\<in> lift\\<^sub>s project_str {}.\n                    \\<exists>T'. T = inject_str s T'} \\<longrightarrow>\n           t \\<in> {})", "apply (clarsimp simp add:\n  lift\\<^sub>s_def mex_def meq_def\n  project_str_def inject_str_def project_globals_str_def inject_globals_str_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> T'.\n       \\<exists>strnext_'.\n          globals \\<sigma>\\<lparr>strnext_' := next_' (globals T')\\<rparr> =\n          globals \\<sigma>\\<lparr>strnext_' := strnext_'\\<rparr>", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}