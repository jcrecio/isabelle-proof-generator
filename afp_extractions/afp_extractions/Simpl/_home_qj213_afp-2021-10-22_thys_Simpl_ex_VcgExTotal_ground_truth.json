{"file_name": "/home/qj213/afp-2021-10-22/thys/Simpl/ex/VcgExTotal.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Simpl", "problem_names": ["lemma \"\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n          WHILE \\<acute>M \\<noteq> a\n          INV \\<lbrace>\\<acute>S = \\<acute>M * b \\<and> \\<acute>M \\<le> a\\<rbrace>\n          VAR MEASURE a - \\<acute>M\n          DO \\<acute>S :== \\<acute>S + b;; \\<acute>M :== \\<acute>M + 1 OD\n          \\<lbrace>\\<acute>S = a * b\\<rbrace>\"", "lemma \"\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>\\<acute>I \\<le> 3\\<rbrace>\n     WHILE \\<acute>I < 10 INV \\<lbrace>\\<acute>I\\<le> 10\\<rbrace> VAR MEASURE 10 - \\<acute>I\n     DO\n       \\<acute>I :== \\<acute>I + 1\n     OD\n  \\<lbrace>\\<acute>I = 10\\<rbrace>\"", "lemma \"\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>\\<acute>M=0 \\<and> \\<acute>N=0\\<rbrace>\n      WHILE (\\<acute>M < i)\n      INV \\<lbrace>\\<acute>M \\<le> i \\<and> (\\<acute>M \\<noteq> 0 \\<longrightarrow> \\<acute>N = j) \\<and> \\<acute>N \\<le> j\\<rbrace>\n      VAR MEASURE (i - \\<acute>M)\n      DO\n         \\<acute>N :== 0;;\n         WHILE (\\<acute>N < j)\n         FIX m.\n         INV \\<lbrace>\\<acute>M=m \\<and> \\<acute>N \\<le> j\\<rbrace>\n         VAR MEASURE (j - \\<acute>N)\n         DO\n           \\<acute>N :== \\<acute>N + 1\n         OD;;\n       \\<acute>M :== \\<acute>M + 1\n       OD\n       \\<lbrace>\\<acute>M=i \\<and> (\\<acute>M\\<noteq>0 \\<longrightarrow> \\<acute>N=j)\\<rbrace>\"", "lemma fac_simp [simp]: \"0 < i \\<Longrightarrow>  fac i = i * fac (i - 1)\"", "lemma (in Fac_impl) Fac_spec:\n  shows \"\\<forall>n. \\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>\\<acute>N=n\\<rbrace> \\<acute>R :== PROC Fac(\\<acute>N) \\<lbrace>\\<acute>R = fac n\\<rbrace>\"", "lemma (in p91_impl) p91_spec:\n  shows \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^sub>t {\\<sigma>} \\<acute>R :== PROC p91(\\<acute>R,\\<acute>N)\n                       \\<lbrace>if 100 < \\<^bsup>\\<sigma>\\<^esup>N then \\<acute>R = \\<^bsup>\\<sigma>\\<^esup>N - 10 else \\<acute>R = 91\\<rbrace>,{}\"", "lemma (in append_impl)\n  shows\n   \"\\<forall>\\<sigma> Ps Qs. \\<Gamma>\\<turnstile>\\<^sub>t\n      \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next Ps \\<and>  List \\<acute>q \\<acute>next Qs \\<and> set Ps \\<inter> set Qs = {} \\<rbrace>\n       \\<acute>p :== PROC append(\\<acute>p,\\<acute>q)\n      \\<lbrace>List \\<acute>p \\<acute>next (Ps@Qs) \\<and> (\\<forall>x. x\\<notin>set Ps \\<longrightarrow> \\<acute>next x = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>\"", "lemma (in append_impl)\n  shows\n   \"\\<forall>\\<sigma> Ps Qs. \\<Gamma>\\<turnstile>\\<^sub>t\n      \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next Ps \\<and>  List \\<acute>q \\<acute>next Qs \\<and> set Ps \\<inter> set Qs = {} \\<rbrace>\n       \\<acute>p :== PROC append(\\<acute>p,\\<acute>q)\n      \\<lbrace>List \\<acute>p \\<acute>next (Ps@Qs) \\<and> (\\<forall>x. x\\<notin>set Ps \\<longrightarrow> \\<acute>next x = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>\"", "lemma (in append_impl)\n  shows\n  append_spec:\n   \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> \\<lbrace>islist \\<acute>p \\<acute>next\\<rbrace>)  \\<acute>p :== PROC append(\\<acute>p,\\<acute>q)\n    \\<lbrace>\\<forall>Ps Qs. List \\<^bsup>\\<sigma>\\<^esup>p \\<^bsup>\\<sigma>\\<^esup>next Ps \\<and>  List \\<^bsup>\\<sigma>\\<^esup>q \\<^bsup>\\<sigma>\\<^esup>next Qs \\<and> set Ps \\<inter> set Qs = {}\n     \\<longrightarrow>\n     List \\<acute>p \\<acute>next (Ps@Qs) \\<and> (\\<forall>x. x\\<notin>set Ps \\<longrightarrow> \\<acute>next x = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>\"", "lemma \"\\<Gamma>\\<turnstile>\\<lbrace>List \\<acute>p \\<acute>next Ps\\<rbrace>\n       \\<acute>q :== Null;;\n       WHILE \\<acute>p \\<noteq> Null INV \\<lbrace>\\<exists>Ps' Qs'. List \\<acute>p \\<acute>next Ps' \\<and> List \\<acute>q \\<acute>next Qs' \\<and>\n                             set Ps' \\<inter> set Qs' = {} \\<and>\n                             rev Ps' @ Qs' = rev Ps\\<rbrace>\n        DO\n         \\<acute>r :== \\<acute>p;; \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n         \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>q;; \\<acute>q :== \\<acute>r\n       OD;;\n       \\<acute>p :==\\<acute>q\n       \\<lbrace>List \\<acute>p \\<acute>next (rev Ps)\\<rbrace> \"", "lemma conjI2: \"\\<lbrakk>Q; Q \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P \\<and> Q\"", "lemma upd_hd_next:\n  assumes p_ps: \"List p next (p#ps)\"\n  shows \"List (next p) (next(p := q)) ps\"", "lemma (in Rev_impl) shows\n Rev_spec:\n  \"\\<forall>Ps. \\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>List \\<acute>p \\<acute>next Ps\\<rbrace> \\<acute>p :== PROC Rev(\\<acute>p) \\<lbrace>List \\<acute>p \\<acute>next (rev Ps)\\<rbrace>\"", "lemma (in Rev_impl) shows\n Rev_modifies:\n  \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^bsub>/UNIV \\<^esub>{\\<sigma>} \\<acute>p :== PROC Rev(\\<acute>p) {t. t may_only_modify_globals \\<sigma> in [next]}\"", "lemma \"\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>List \\<acute>p \\<acute>next Ps\\<rbrace>\n       \\<acute>q :== Null;;\n       WHILE \\<acute>p \\<noteq> Null INV \\<lbrace>\\<exists>Ps' Qs'. List \\<acute>p \\<acute>next Ps' \\<and> List \\<acute>q \\<acute>next Qs' \\<and>\n                             set Ps' \\<inter> set Qs' = {} \\<and>\n                             rev Ps' @ Qs' = rev Ps\\<rbrace>\n       VAR MEASURE (length (list \\<acute>p \\<acute>next) )\n        DO\n         \\<acute>r :== \\<acute>p;; \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n         \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>q;; \\<acute>q :== \\<acute>r\n       OD;;\n       \\<acute>p :==\\<acute>q\n       \\<lbrace>List \\<acute>p \\<acute>next (rev Ps)\\<rbrace> \"", "lemma (in pedal_coast_clique)\n  shows \"(\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace>  PROC pedal(\\<acute>N,\\<acute>M) \\<lbrace>True\\<rbrace>) \\<and>\n         (\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace> PROC coast(\\<acute>N,\\<acute>M) \\<lbrace>True\\<rbrace>)\"", "lemma (in pedal_coast_clique)\n  shows \"(\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace> PROC pedal(\\<acute>N,\\<acute>M) \\<lbrace>True\\<rbrace>) \\<and>\n         (\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace> PROC coast(\\<acute>N,\\<acute>M) \\<lbrace>True\\<rbrace>)\"", "lemma (in pedal_coast_clique)\n  shows \"(\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace> PROC pedal(\\<acute>N,\\<acute>M) \\<lbrace>True\\<rbrace>) \\<and>\n         (\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace> PROC coast(\\<acute>N,\\<acute>M) \\<lbrace>True\\<rbrace>)\"", "lemma (in pedal_coast_clique)\n  shows \"(\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace> PROC pedal(\\<acute>N,\\<acute>M) \\<lbrace>True\\<rbrace>) \\<and>\n         (\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace> PROC coast(\\<acute>N,\\<acute>M) \\<lbrace>True\\<rbrace>)\"", "lemma (in pedal_coast_clique)\n  shows \"(\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace> PROC pedal(\\<acute>N,\\<acute>M) \\<lbrace>True\\<rbrace>) \\<and>\n         (\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace> PROC coast(\\<acute>N,\\<acute>M) \\<lbrace>True\\<rbrace>)\""], "translations": [["", "lemma \"\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>\\<acute>M = 0 \\<and> \\<acute>S = 0\\<rbrace>\n          WHILE \\<acute>M \\<noteq> a\n          INV \\<lbrace>\\<acute>S = \\<acute>M * b \\<and> \\<acute>M \\<le> a\\<rbrace>\n          VAR MEASURE a - \\<acute>M\n          DO \\<acute>S :== \\<acute>S + b;; \\<acute>M :== \\<acute>M + 1 OD\n          \\<lbrace>\\<acute>S = a * b\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile>\\<^sub>t \\<lbrace>\\<acute>M = 0 \\<and>\n                                     \\<acute>S = 0\\<rbrace>\n                            WHILE \\<acute>M \\<noteq> a\n                            INV \\<lbrace>\\<acute>S = \\<acute>M * b \\<and>\n   \\<acute>M \\<le> a\\<rbrace>\n                            VAR MEASURE a - \\<acute>M \n                            DO \\<acute>S :== \\<acute>S + b;;\n                               \\<acute>M :== \\<acute>M + 1 \n                            OD\n                            \\<lbrace>\\<acute>S = a * b\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>M S.\n       \\<lbrakk>M = 0; S = 0\\<rbrakk>\n       \\<Longrightarrow> S = M * b \\<and> M \\<le> a\n 2. \\<And>M S.\n       \\<lbrakk>S = M * b; M \\<le> a; M \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> a - (M + 1) < a - M \\<and>\n                         S + b = (M + 1) * b \\<and> M + 1 \\<le> a\n 3. \\<And>M S.\n       \\<lbrakk>S = M * b; M \\<le> a; \\<not> M \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> S = a * b", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>\\<acute>I \\<le> 3\\<rbrace>\n     WHILE \\<acute>I < 10 INV \\<lbrace>\\<acute>I\\<le> 10\\<rbrace> VAR MEASURE 10 - \\<acute>I\n     DO\n       \\<acute>I :== \\<acute>I + 1\n     OD\n  \\<lbrace>\\<acute>I = 10\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile>\\<^sub>t \\<lbrace>\\<acute>I \\<le> 3\\<rbrace>\n                            WHILE \\<acute>I < 10\n                            INV \\<lbrace>\\<acute>I \\<le> 10\\<rbrace>\n                            VAR MEASURE 10 - \\<acute>I \n                            DO \\<acute>I :== \\<acute>I + 1 OD\n                            \\<lbrace>\\<acute>I = 10\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>I. I \\<le> 3 \\<Longrightarrow> I \\<le> 10\n 2. \\<And>I.\n       \\<lbrakk>I \\<le> 10; I < 10\\<rbrakk>\n       \\<Longrightarrow> 10 - (I + 1) < 10 - I \\<and> I + 1 \\<le> 10\n 3. \\<And>I.\n       \\<lbrakk>I \\<le> 10; \\<not> I < 10\\<rbrakk> \\<Longrightarrow> I = 10", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Total correctness of a nested loop. In the inner loop we have to\nexpress that the loop variable of the outer loop is not changed. We use\n\\<open>FIX\\<close> to introduce a new logical variable\n\\<close>"], ["", "lemma \"\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>\\<acute>M=0 \\<and> \\<acute>N=0\\<rbrace>\n      WHILE (\\<acute>M < i)\n      INV \\<lbrace>\\<acute>M \\<le> i \\<and> (\\<acute>M \\<noteq> 0 \\<longrightarrow> \\<acute>N = j) \\<and> \\<acute>N \\<le> j\\<rbrace>\n      VAR MEASURE (i - \\<acute>M)\n      DO\n         \\<acute>N :== 0;;\n         WHILE (\\<acute>N < j)\n         FIX m.\n         INV \\<lbrace>\\<acute>M=m \\<and> \\<acute>N \\<le> j\\<rbrace>\n         VAR MEASURE (j - \\<acute>N)\n         DO\n           \\<acute>N :== \\<acute>N + 1\n         OD;;\n       \\<acute>M :== \\<acute>M + 1\n       OD\n       \\<lbrace>\\<acute>M=i \\<and> (\\<acute>M\\<noteq>0 \\<longrightarrow> \\<acute>N=j)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile>\\<^sub>t \\<lbrace>\\<acute>M = 0 \\<and>\n                                     \\<acute>N = 0\\<rbrace>\n                            WHILE \\<acute>M < i\n                            INV \\<lbrace>\\<acute>M \\<le> i \\<and>\n   (\\<acute>M \\<noteq> 0 \\<longrightarrow> \\<acute>N = j) \\<and>\n   \\<acute>N \\<le> j\\<rbrace>\n                            VAR MEASURE i - \\<acute>M \n                            DO \\<acute>N :== 0;;\n                               WHILE \\<lbrace>\\<acute>N < j\\<rbrace> FIX m.\n                               INV \\<lbrace>\\<acute>M = m \\<and>\n      \\<acute>N \\<le> j\\<rbrace>\n                               VAR MEASURE j - \\<acute>N \n                               (\\<acute>N :== \\<acute>N + 1);;\n                               \\<acute>M :== \\<acute>M + 1 \n                            OD\n                            \\<lbrace>\\<acute>M = i \\<and>\n                                     (\\<acute>M \\<noteq> 0 \\<longrightarrow>\n\\<acute>N = j)\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>M N.\n       \\<lbrakk>M = 0; N = 0\\<rbrakk>\n       \\<Longrightarrow> M \\<le> i \\<and>\n                         (M \\<noteq> 0 \\<longrightarrow> N = j) \\<and>\n                         N \\<le> j\n 2. \\<And>M N.\n       \\<lbrakk>M \\<le> i; M \\<noteq> 0 \\<longrightarrow> N = j; N \\<le> j;\n        M < i\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> j \\<and>\n                         (\\<forall>Ma N.\n                             Ma = M \\<and>\n                             N \\<le> j \\<and> \\<not> N < j \\<longrightarrow>\n                             i - (M + 1) < i - M \\<and>\n                             M + 1 \\<le> i \\<and>\n                             (M + 1 \\<noteq> 0 \\<longrightarrow> N = j))\n 3. \\<And>M N.\n       \\<lbrakk>N \\<le> j; N < j\\<rbrakk>\n       \\<Longrightarrow> j - (N + 1) < j - N \\<and>\n                         M = M \\<and> N + 1 \\<le> j\n 4. \\<And>M N.\n       \\<lbrakk>M \\<le> i; M \\<noteq> 0 \\<longrightarrow> N = j; N \\<le> j;\n        \\<not> M < i\\<rbrakk>\n       \\<Longrightarrow> M = i \\<and> (M \\<noteq> 0 \\<longrightarrow> N = j)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>M N.\n       \\<lbrakk>0 < M \\<longrightarrow> N = j; N \\<le> j; M < i\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>N\\<le>j. \\<not> N < j) \\<longrightarrow>\n                         i - Suc M < i - M", "apply arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "primrec fac:: \"nat \\<Rightarrow> nat\"\nwhere\n\"fac 0 = 1\" |\n\"fac (Suc n) = (Suc n) * fac n\""], ["", "lemma fac_simp [simp]: \"0 < i \\<Longrightarrow>  fac i = i * fac (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < i \\<Longrightarrow> fac i = i * fac (i - 1)", "by (cases i) simp_all"], ["", "procedures\n  Fac (N | R) = \"IF \\<acute>N = 0 THEN \\<acute>R :== 1\n                       ELSE CALL Fac(\\<acute>N - 1,\\<acute>R);;\n                            \\<acute>R :== \\<acute>N * \\<acute>R\n                       FI\""], ["", "lemma (in Fac_impl) Fac_spec:\n  shows \"\\<forall>n. \\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>\\<acute>N=n\\<rbrace> \\<acute>R :== PROC Fac(\\<acute>N) \\<lbrace>\\<acute>R = fac n\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<acute>N = n\\<rbrace>\n                               \\<acute>R :== PROC Fac(\\<acute>N)\n                               \\<lbrace>\\<acute>R = fac n\\<rbrace>", "apply (hoare_rule HoareTotal.ProcRec1 [where r=\"measure (\\<lambda>(s,p). \\<^bsup>s\\<^esup>N)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> n.\n       \\<Gamma>,(\\<Union>n.\n                    {(\\<lbrace>\\<acute>N = n\\<rbrace> \\<inter>\n                      \\<lbrace>\\<acute>N\n                               < \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                      Fac_'proc, \\<lbrace>\\<acute>R = fac n\\<rbrace>, {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter>\n                                \\<lbrace>\\<acute>N = n\\<rbrace>)\n                               IF \\<acute>N = 0 THEN \\<acute>R :== 1\n                               ELSE \\<acute>R :== CALL Fac(\\<acute>N - 1);;\n                                 \\<acute>R :== \\<acute>N * \\<acute>R\n                               FI\n                               \\<lbrace>\\<acute>R = fac n\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>N.\n       (N = 0 \\<longrightarrow> 1 = fac N) \\<and>\n       (N \\<noteq> 0 \\<longrightarrow>\n        N - 1 < N \\<and>\n        (\\<forall>R.\n            R = fac (N - 1) \\<longrightarrow> N * fac (N - 1) = fac N))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "procedures\n  p91(R,N | R) = \"IF 100 < \\<acute>N THEN \\<acute>R :== \\<acute>N - 10\n                      ELSE \\<acute>R :== CALL p91(\\<acute>R,\\<acute>N+11);;\n                           \\<acute>R :== CALL p91(\\<acute>R,\\<acute>R) FI\"\n\n\n  p91_spec: \"\\<forall>n. \\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>\\<acute>N=n\\<rbrace> \\<acute>R :== PROC p91(\\<acute>R,\\<acute>N)\n                        \\<lbrace>if 100 < n then \\<acute>R = n - 10 else \\<acute>R = 91\\<rbrace>,{}\""], ["", "lemma (in p91_impl) p91_spec:\n  shows \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^sub>t {\\<sigma>} \\<acute>R :== PROC p91(\\<acute>R,\\<acute>N)\n                       \\<lbrace>if 100 < \\<^bsup>\\<sigma>\\<^esup>N then \\<acute>R = \\<^bsup>\\<sigma>\\<^esup>N - 10 else \\<acute>R = 91\\<rbrace>,{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t {\\<sigma>}\n                               \\<acute>R :== PROC p91(\\<acute>R,\\<acute>N)\n                               \\<lbrace>if 100 < \\<^bsup>\\<sigma>\\<^esup>N\n  then \\<acute>R = \\<^bsup>\\<sigma>\\<^esup>N - 10\n  else \\<acute>R = 91\\<rbrace>", "apply (hoare_rule HoareTotal.ProcRec1 [where r=\"measure (\\<lambda>(s,p). 101 - \\<^bsup>s\\<^esup>N)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>101 - \\<acute>N\n                               < 101 - \\<^bsup>\\<sigma>\\<^esup>N\\<rbrace>,\n                      p91_'proc,\n                      \\<lbrace>if 100 < \\<^bsup>\\<sigma>'\\<^esup>N\n                               then \\<acute>R =\n                                    \\<^bsup>\\<sigma>'\\<^esup>N - 10\n                               else \\<acute>R = 91\\<rbrace>,\n                      {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> {\\<sigma>'})\n                               IF 100 < \\<acute>N\n                               THEN \\<acute>R :== \\<acute>N - 10\n                               ELSE \\<acute>R :== CALL p91(\\<acute>R,\n                                 \\<acute>N + 11);;\n                                 \\<acute>R :== CALL p91(\\<acute>R,\\<acute>R)\n                               FI\n                               \\<lbrace>if 100 < \\<^bsup>\\<sigma>'\\<^esup>N\n  then \\<acute>R = \\<^bsup>\\<sigma>'\\<^esup>N - 10\n  else \\<acute>R = 91\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>N.\n       (100 < N \\<longrightarrow>\n        (if 100 < N then N - 10 = N - 10 else N - 10 = 91)) \\<and>\n       (\\<not> 100 < N \\<longrightarrow>\n        101 - (N + 11) < 101 - N \\<and>\n        (\\<forall>R.\n            (if 100 < N + 11 then R = N + 11 - 10\n             else R = 91) \\<longrightarrow>\n            101 - R < 101 - N \\<and>\n            (\\<forall>Ra.\n                (if 100 < R then Ra = R - 10 else Ra = 91) \\<longrightarrow>\n                (if 100 < N then Ra = N - 10 else Ra = 91))))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>N.\n       \\<not> 100 < N \\<Longrightarrow>\n       90 - N < 101 - N \\<and>\n       (\\<forall>R.\n           (89 < N \\<longrightarrow>\n            R = Suc N \\<longrightarrow>\n            100 - N < 101 - N \\<and>\n            (99 < N \\<longrightarrow> N - 9 = 91)) \\<and>\n           (\\<not> 89 < N \\<longrightarrow>\n            R = 91 \\<longrightarrow> 10 < 101 - N))", "apply arith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "record globals_list =\n  next_' :: \"ref \\<Rightarrow> ref\"\n  cont_' :: \"ref \\<Rightarrow> nat\""], ["", "record 'g list_vars = \"'g state\" +\n  p_'    :: \"ref\"\n  q_'    :: \"ref\"\n  r_'    :: \"ref\"\n  root_' :: \"ref\"\n  tmp_'  :: \"ref\""], ["", "procedures\n  append(p,q|p) =\n    \"IF \\<acute>p=Null THEN \\<acute>p :== \\<acute>q ELSE \\<acute>p\\<rightarrow>\\<acute>next :== CALL append(\\<acute>p\\<rightarrow>\\<acute>next,\\<acute>q) FI\""], ["", "lemma (in append_impl)\n  shows\n   \"\\<forall>\\<sigma> Ps Qs. \\<Gamma>\\<turnstile>\\<^sub>t\n      \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next Ps \\<and>  List \\<acute>q \\<acute>next Qs \\<and> set Ps \\<inter> set Qs = {} \\<rbrace>\n       \\<acute>p :== PROC append(\\<acute>p,\\<acute>q)\n      \\<lbrace>List \\<acute>p \\<acute>next (Ps@Qs) \\<and> (\\<forall>x. x\\<notin>set Ps \\<longrightarrow> \\<acute>next x = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> Ps Qs.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. List \\<acute>p\n             \\<acute>next Ps \\<and>\n            List \\<acute>q \\<acute>next Qs \\<and>\n            set Ps \\<inter> set Qs = {}\\<rbrace>\n                               \\<acute>p :== PROC append(\\<acute>p,\n                               \\<acute>q)\n                               \\<lbrace>List \\<acute>p \\<acute>next\n   (Ps @ Qs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Ps \\<longrightarrow>\n      x\\<rightarrow>\\<acute>next = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>", "apply (hoare_rule HoareTotal.ProcRec1\n            [where r=\"measure (\\<lambda>(s,p). length (list \\<^bsup>s\\<^esup>p \\<^bsup>s\\<^esup>next))\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> \\<sigma>' Ps Qs.\n       \\<Gamma>,(\\<Union>\\<sigma>' Ps Qs.\n                    {(\\<lbrace>\\<sigma>'. List \\<acute>p \\<acute>next\n     Ps \\<and>\n    List \\<acute>q \\<acute>next Qs \\<and>\n    set Ps \\<inter> set Qs = {}\\<rbrace> \\<inter>\n                      \\<lbrace>length (list \\<acute>p \\<acute>next)\n                               < length\n                                  (list \\<^bsup>\\<sigma>\\<^esup>p\n                                    \\<^bsup>\\<sigma>\\<^esup>next)\\<rbrace>,\n                      append_'proc,\n                      \\<lbrace>List \\<acute>p \\<acute>next (Ps @ Qs) \\<and>\n                               (\\<forall>x.\n                                   x \\<notin> set Ps \\<longrightarrow>\n                                   x\\<rightarrow>\\<acute>next =\n                                   \\<^bsup>\\<sigma>'\\<^esup>next\n                                    x)\\<rbrace>,\n                      {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter>\n                                \\<lbrace>\\<sigma>'. List \\<acute>p\n               \\<acute>next Ps \\<and>\n              List \\<acute>q \\<acute>next Qs \\<and>\n              set Ps \\<inter> set Qs = {}\\<rbrace>)\n                               IF \\<acute>p = Null\n                               THEN \\<acute>p :== \\<acute>q\n                               ELSE \\<acute>p\\<rightarrow>\\<acute>next :== CALL append(\\<acute>p\\<rightarrow>\\<acute>next,\n                                 \\<acute>q)\n                               FI\n                               \\<lbrace>List \\<acute>p \\<acute>next\n   (Ps @ Qs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Ps \\<longrightarrow>\n      x\\<rightarrow>\\<acute>next = \\<^bsup>\\<sigma>'\\<^esup>next x)\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps Qs next p q.\n       \\<lbrakk>List p next Ps; List q next Qs;\n        set Ps \\<inter> set Qs = {}\\<rbrakk>\n       \\<Longrightarrow> (p = Null \\<longrightarrow>\n                          List q next (Ps @ Qs) \\<and>\n                          (\\<forall>x.\n                              x \\<notin> set Ps \\<longrightarrow>\n                              next x = next x)) \\<and>\n                         (p \\<noteq> Null \\<longrightarrow>\n                          (\\<exists>Psa.\n                              List (next p) next Psa \\<and>\n                              (\\<exists>Qsa.\n                                  List q next Qsa \\<and>\n                                  set Psa \\<inter> set Qsa = {} \\<and>\n                                  length (list (next p) next)\n                                  < length (list p next) \\<and>\n                                  (\\<forall>nexta pa.\nList pa nexta (Psa @ Qsa) \\<and>\n(\\<forall>x.\n    x \\<notin> set Psa \\<longrightarrow> nexta x = next x) \\<longrightarrow>\nList p (nexta(p := pa)) (Ps @ Qs) \\<and>\n(\\<forall>x.\n    x \\<notin> set Ps \\<longrightarrow> (nexta(p := pa)) x = next x)))))", "apply (fastforce  simp add: List_list)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in append_impl)\n  shows\n   \"\\<forall>\\<sigma> Ps Qs. \\<Gamma>\\<turnstile>\\<^sub>t\n      \\<lbrace>\\<sigma>. List \\<acute>p \\<acute>next Ps \\<and>  List \\<acute>q \\<acute>next Qs \\<and> set Ps \\<inter> set Qs = {} \\<rbrace>\n       \\<acute>p :== PROC append(\\<acute>p,\\<acute>q)\n      \\<lbrace>List \\<acute>p \\<acute>next (Ps@Qs) \\<and> (\\<forall>x. x\\<notin>set Ps \\<longrightarrow> \\<acute>next x = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> Ps Qs.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. List \\<acute>p\n             \\<acute>next Ps \\<and>\n            List \\<acute>q \\<acute>next Qs \\<and>\n            set Ps \\<inter> set Qs = {}\\<rbrace>\n                               \\<acute>p :== PROC append(\\<acute>p,\n                               \\<acute>q)\n                               \\<lbrace>List \\<acute>p \\<acute>next\n   (Ps @ Qs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Ps \\<longrightarrow>\n      x\\<rightarrow>\\<acute>next = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>", "apply (hoare_rule HoareTotal.ProcRec1\n            [where r=\"measure (\\<lambda>(s,p). length (list \\<^bsup>s\\<^esup>p \\<^bsup>s\\<^esup>next))\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> \\<sigma>' Ps Qs.\n       \\<Gamma>,(\\<Union>\\<sigma>' Ps Qs.\n                    {(\\<lbrace>\\<sigma>'. List \\<acute>p \\<acute>next\n     Ps \\<and>\n    List \\<acute>q \\<acute>next Qs \\<and>\n    set Ps \\<inter> set Qs = {}\\<rbrace> \\<inter>\n                      \\<lbrace>length (list \\<acute>p \\<acute>next)\n                               < length\n                                  (list \\<^bsup>\\<sigma>\\<^esup>p\n                                    \\<^bsup>\\<sigma>\\<^esup>next)\\<rbrace>,\n                      append_'proc,\n                      \\<lbrace>List \\<acute>p \\<acute>next (Ps @ Qs) \\<and>\n                               (\\<forall>x.\n                                   x \\<notin> set Ps \\<longrightarrow>\n                                   x\\<rightarrow>\\<acute>next =\n                                   \\<^bsup>\\<sigma>'\\<^esup>next\n                                    x)\\<rbrace>,\n                      {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter>\n                                \\<lbrace>\\<sigma>'. List \\<acute>p\n               \\<acute>next Ps \\<and>\n              List \\<acute>q \\<acute>next Qs \\<and>\n              set Ps \\<inter> set Qs = {}\\<rbrace>)\n                               IF \\<acute>p = Null\n                               THEN \\<acute>p :== \\<acute>q\n                               ELSE \\<acute>p\\<rightarrow>\\<acute>next :== CALL append(\\<acute>p\\<rightarrow>\\<acute>next,\n                                 \\<acute>q)\n                               FI\n                               \\<lbrace>List \\<acute>p \\<acute>next\n   (Ps @ Qs) \\<and>\n  (\\<forall>x.\n      x \\<notin> set Ps \\<longrightarrow>\n      x\\<rightarrow>\\<acute>next = \\<^bsup>\\<sigma>'\\<^esup>next x)\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps Qs next p q.\n       \\<lbrakk>List p next Ps; List q next Qs;\n        set Ps \\<inter> set Qs = {}\\<rbrakk>\n       \\<Longrightarrow> (p = Null \\<longrightarrow>\n                          List q next (Ps @ Qs) \\<and>\n                          (\\<forall>x.\n                              x \\<notin> set Ps \\<longrightarrow>\n                              next x = next x)) \\<and>\n                         (p \\<noteq> Null \\<longrightarrow>\n                          (\\<exists>Psa.\n                              List (next p) next Psa \\<and>\n                              (\\<exists>Qsa.\n                                  List q next Qsa \\<and>\n                                  set Psa \\<inter> set Qsa = {} \\<and>\n                                  length (list (next p) next)\n                                  < length (list p next) \\<and>\n                                  (\\<forall>nexta pa.\nList pa nexta (Psa @ Qsa) \\<and>\n(\\<forall>x.\n    x \\<notin> set Psa \\<longrightarrow> nexta x = next x) \\<longrightarrow>\nList p (nexta(p := pa)) (Ps @ Qs) \\<and>\n(\\<forall>x.\n    x \\<notin> set Ps \\<longrightarrow> (nexta(p := pa)) x = next x)))))", "apply (fastforce  simp add: List_list)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in append_impl)\n  shows\n  append_spec:\n   \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> \\<lbrace>islist \\<acute>p \\<acute>next\\<rbrace>)  \\<acute>p :== PROC append(\\<acute>p,\\<acute>q)\n    \\<lbrace>\\<forall>Ps Qs. List \\<^bsup>\\<sigma>\\<^esup>p \\<^bsup>\\<sigma>\\<^esup>next Ps \\<and>  List \\<^bsup>\\<sigma>\\<^esup>q \\<^bsup>\\<sigma>\\<^esup>next Qs \\<and> set Ps \\<inter> set Qs = {}\n     \\<longrightarrow>\n     List \\<acute>p \\<acute>next (Ps@Qs) \\<and> (\\<forall>x. x\\<notin>set Ps \\<longrightarrow> \\<acute>next x = \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter>\n                                \\<lbrace>islist \\<acute>p\n    \\<acute>next\\<rbrace>)\n                               \\<acute>p :== PROC append(\\<acute>p,\n                               \\<acute>q)\n                               \\<lbrace>\\<forall>Ps Qs.\n     List \\<^bsup>\\<sigma>\\<^esup>p \\<^bsup>\\<sigma>\\<^esup>next Ps \\<and>\n     List \\<^bsup>\\<sigma>\\<^esup>q \\<^bsup>\\<sigma>\\<^esup>next Qs \\<and>\n     set Ps \\<inter> set Qs = {} \\<longrightarrow>\n     List \\<acute>p \\<acute>next (Ps @ Qs) \\<and>\n     (\\<forall>x.\n         x \\<notin> set Ps \\<longrightarrow>\n         x\\<rightarrow>\\<acute>next =\n         \\<^bsup>\\<sigma>\\<^esup>next x)\\<rbrace>", "apply (hoare_rule HoareTotal.ProcRec1\n            [where r=\"measure (\\<lambda>(s,p). length (list \\<^bsup>s\\<^esup>p \\<^bsup>s\\<^esup>next))\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> \\<sigma>'.\n       \\<Gamma>,(\\<Union>\\<sigma>'.\n                    {({\\<sigma>'} \\<inter>\n                      \\<lbrace>islist \\<acute>p\n                                \\<acute>next\\<rbrace> \\<inter>\n                      \\<lbrace>length (list \\<acute>p \\<acute>next)\n                               < length\n                                  (list \\<^bsup>\\<sigma>\\<^esup>p\n                                    \\<^bsup>\\<sigma>\\<^esup>next)\\<rbrace>,\n                      append_'proc,\n                      \\<lbrace>\\<forall>Ps Qs.\n                                  List \\<^bsup>\\<sigma>'\\<^esup>p\n                                   \\<^bsup>\\<sigma>'\\<^esup>next Ps \\<and>\n                                  List \\<^bsup>\\<sigma>'\\<^esup>q\n                                   \\<^bsup>\\<sigma>'\\<^esup>next Qs \\<and>\n                                  set Ps \\<inter> set Qs =\n                                  {} \\<longrightarrow>\n                                  List \\<acute>p \\<acute>next\n                                   (Ps @ Qs) \\<and>\n                                  (\\<forall>x.\nx \\<notin> set Ps \\<longrightarrow>\nx\\<rightarrow>\\<acute>next = \\<^bsup>\\<sigma>'\\<^esup>next x)\\<rbrace>,\n                      {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter>\n                                ({\\<sigma>'} \\<inter>\n                                 \\<lbrace>islist \\<acute>p\n     \\<acute>next\\<rbrace>))\n                               IF \\<acute>p = Null\n                               THEN \\<acute>p :== \\<acute>q\n                               ELSE \\<acute>p\\<rightarrow>\\<acute>next :== CALL append(\\<acute>p\\<rightarrow>\\<acute>next,\n                                 \\<acute>q)\n                               FI\n                               \\<lbrace>\\<forall>Ps Qs.\n     List \\<^bsup>\\<sigma>'\\<^esup>p \\<^bsup>\\<sigma>'\\<^esup>next Ps \\<and>\n     List \\<^bsup>\\<sigma>'\\<^esup>q \\<^bsup>\\<sigma>'\\<^esup>next Qs \\<and>\n     set Ps \\<inter> set Qs = {} \\<longrightarrow>\n     List \\<acute>p \\<acute>next (Ps @ Qs) \\<and>\n     (\\<forall>x.\n         x \\<notin> set Ps \\<longrightarrow>\n         x\\<rightarrow>\\<acute>next =\n         \\<^bsup>\\<sigma>'\\<^esup>next x)\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>next p q.\n       islist p next \\<Longrightarrow>\n       (p = Null \\<longrightarrow>\n        (\\<forall>Ps Qs.\n            List p next Ps \\<and>\n            List q next Qs \\<and>\n            set Ps \\<inter> set Qs = {} \\<longrightarrow>\n            List q next (Ps @ Qs) \\<and>\n            (\\<forall>x.\n                x \\<notin> set Ps \\<longrightarrow>\n                next x = next x))) \\<and>\n       (p \\<noteq> Null \\<longrightarrow>\n        islist (next p) next \\<and>\n        length (list (next p) next) < length (list p next) \\<and>\n        (\\<forall>nexta pa.\n            (\\<forall>Ps Qs.\n                List (next p) next Ps \\<and>\n                List q next Qs \\<and>\n                set Ps \\<inter> set Qs = {} \\<longrightarrow>\n                List pa nexta (Ps @ Qs) \\<and>\n                (\\<forall>x.\n                    x \\<notin> set Ps \\<longrightarrow>\n                    nexta x = next x)) \\<longrightarrow>\n            (\\<forall>Ps Qs.\n                List p next Ps \\<and>\n                List q next Qs \\<and>\n                set Ps \\<inter> set Qs = {} \\<longrightarrow>\n                List p (nexta(p := pa)) (Ps @ Qs) \\<and>\n                (\\<forall>x.\n                    x \\<notin> set Ps \\<longrightarrow>\n                    (nexta(p := pa)) x = next x))))", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"\\<Gamma>\\<turnstile>\\<lbrace>List \\<acute>p \\<acute>next Ps\\<rbrace>\n       \\<acute>q :== Null;;\n       WHILE \\<acute>p \\<noteq> Null INV \\<lbrace>\\<exists>Ps' Qs'. List \\<acute>p \\<acute>next Ps' \\<and> List \\<acute>q \\<acute>next Qs' \\<and>\n                             set Ps' \\<inter> set Qs' = {} \\<and>\n                             rev Ps' @ Qs' = rev Ps\\<rbrace>\n        DO\n         \\<acute>r :== \\<acute>p;; \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n         \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>q;; \\<acute>q :== \\<acute>r\n       OD;;\n       \\<acute>p :==\\<acute>q\n       \\<lbrace>List \\<acute>p \\<acute>next (rev Ps)\\<rbrace> \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile> \\<lbrace>List \\<acute>p \\<acute>next Ps\\<rbrace>\n                    \\<acute>q :== Null;;\n                    WHILE \\<acute>p \\<noteq> Null\n                    INV \\<lbrace>\\<exists>Ps' Qs'.\n                                    List \\<acute>p \\<acute>next Ps' \\<and>\n                                    List \\<acute>q \\<acute>next Qs' \\<and>\n                                    set Ps' \\<inter> set Qs' = {} \\<and>\n                                    rev Ps' @ Qs' = rev Ps\\<rbrace> \n                    DO \\<acute>r :== \\<acute>p;;\n                       \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n                       \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>q;;\n                       \\<acute>q :== \\<acute>r \n                    OD;;\n                    \\<acute>p :== \\<acute>q\n                    \\<lbrace>List \\<acute>p \\<acute>next (rev Ps)\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>next p.\n       List p next Ps \\<Longrightarrow>\n       \\<exists>Ps' Qs'.\n          List p next Ps' \\<and>\n          List Null next Qs' \\<and>\n          set Ps' \\<inter> set Qs' = {} \\<and> rev Ps' @ Qs' = rev Ps\n 2. \\<And>next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps' Qs'.\n                            List (next p) (next(p := q)) Ps' \\<and>\n                            List p (next(p := q)) Qs' \\<and>\n                            set Ps' \\<inter> set Qs' = {} \\<and>\n                            rev Ps' @ Qs' = rev Ps\n 3. \\<And>next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "apply   clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps' Qs'.\n                            List (next p) (next(p := q)) Ps' \\<and>\n                            List p (next(p := q)) Qs' \\<and>\n                            set Ps' \\<inter> set Qs' = {} \\<and>\n                            rev Ps' @ Qs' = rev Ps\n 2. \\<And>next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "apply  clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next p q ps Qs'.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List q next Qs';\n        rev ps @ p # Qs' = rev Ps; p \\<notin> set Qs';\n        set ps \\<inter> set Qs' = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps'.\n                            List (next p) (next(p := q)) Ps' \\<and>\n                            (\\<exists>Qs'.\n                                (\\<exists>ps.\n                                    Qs' = p # ps \\<and>\n                                    List q (next(p := q)) ps) \\<and>\n                                set Ps' \\<inter> set Qs' = {} \\<and>\n                                rev Ps' @ Qs' = rev Ps)\n 2. \\<And>next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma conjI2: \"\\<lbrakk>Q; Q \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P \\<and> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q; Q \\<Longrightarrow> P\\<rbrakk> \\<Longrightarrow> P \\<and> Q", "by blast"], ["", "procedures Rev(p|p) =\n      \"\\<acute>q :== Null;;\n       WHILE \\<acute>p \\<noteq> Null\n       DO\n         \\<acute>r :== \\<acute>p;; \\<lbrace>\\<acute>p \\<noteq> Null\\<rbrace>\\<longmapsto> \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n         \\<lbrace>\\<acute>r \\<noteq> Null\\<rbrace>\\<longmapsto> \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>q;; \\<acute>q :== \\<acute>r\n       OD;;\n       \\<acute>p :==\\<acute>q\"\n Rev_spec:\n  \"\\<forall>Ps. \\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>List \\<acute>p \\<acute>next Ps\\<rbrace> \\<acute>p :== PROC Rev(\\<acute>p) \\<lbrace>List \\<acute>p \\<acute>next (rev Ps)\\<rbrace>\"\n Rev_modifies:\n  \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^bsub>/UNIV\\<^esub> {\\<sigma>} \\<acute>p :== PROC Rev(\\<acute>p) {t. t may_only_modify_globals \\<sigma> in [next]}\""], ["", "text \\<open>We only need partial correctness of modifies clause!\\<close>"], ["", "lemma upd_hd_next:\n  assumes p_ps: \"List p next (p#ps)\"\n  shows \"List (next p) (next(p := q)) ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List (next p) (next(p := q)) ps", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. List (next p) (next(p := q)) ps", "from p_ps"], ["proof (chain)\npicking this:\n  List p next (p # ps)", "have \"p \\<notin> set ps\""], ["proof (prove)\nusing this:\n  List p next (p # ps)\n\ngoal (1 subgoal):\n 1. p \\<notin> set ps", "by auto"], ["proof (state)\nthis:\n  p \\<notin> set ps\n\ngoal (1 subgoal):\n 1. List (next p) (next(p := q)) ps", "with p_ps"], ["proof (chain)\npicking this:\n  List p next (p # ps)\n  p \\<notin> set ps", "show ?thesis"], ["proof (prove)\nusing this:\n  List p next (p # ps)\n  p \\<notin> set ps\n\ngoal (1 subgoal):\n 1. List (next p) (next(p := q)) ps", "by simp"], ["proof (state)\nthis:\n  List (next p) (next(p := q)) ps\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in Rev_impl) shows\n Rev_spec:\n  \"\\<forall>Ps. \\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>List \\<acute>p \\<acute>next Ps\\<rbrace> \\<acute>p :== PROC Rev(\\<acute>p) \\<lbrace>List \\<acute>p \\<acute>next (rev Ps)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Ps.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>List \\<acute>p \\<acute>next\n   Ps\\<rbrace>\n                               \\<acute>p :== PROC Rev(\\<acute>p)\n                               \\<lbrace>List \\<acute>p \\<acute>next\n   (rev Ps)\\<rbrace>", "apply (hoare_rule HoareTotal.ProcNoRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>Ps.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>List \\<acute>p \\<acute>next\n   Ps\\<rbrace>\n                               \\<acute>q :== Null;;\n                               WHILE \\<acute>p \\<noteq> Null \n                               DO \\<acute>r :== \\<acute>p;;\n                                  (False,\n                                   \\<lbrace>\\<acute>p \\<noteq>\n      Null\\<rbrace>)\n                                  \\<longmapsto> \\<acute>p :==\n          \\<acute>p\\<rightarrow>\\<acute>next;;\n                                  (False,\n                                   \\<lbrace>\\<acute>r \\<noteq>\n      Null\\<rbrace>)\n                                  \\<longmapsto> \\<acute>r\\<rightarrow>\\<acute>next :==\n          \\<acute>q;;\n                                  \\<acute>q :== \\<acute>r \n                               OD;;\n                               \\<acute>p :== \\<acute>q\n                               \\<lbrace>List \\<acute>p \\<acute>next\n   (rev Ps)\\<rbrace>", "apply (hoare_rule anno =\n       \"\\<acute>q :== Null;;\n       WHILE \\<acute>p \\<noteq> Null INV \\<lbrace>\\<exists>Ps' Qs'. List \\<acute>p \\<acute>next Ps' \\<and> List \\<acute>q \\<acute>next Qs' \\<and>\n                             set Ps' \\<inter> set Qs' = {} \\<and>\n                             rev Ps' @ Qs' = rev Ps\\<rbrace>\n       VAR MEASURE (length (list \\<acute>p \\<acute>next) )\n        DO\n         \\<acute>r :== \\<acute>p;; \\<lbrace>\\<acute>p \\<noteq> Null\\<rbrace>\\<longmapsto>\\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n         \\<lbrace>\\<acute>r \\<noteq> Null\\<rbrace>\\<longmapsto>\\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>q;; \\<acute>q :== \\<acute>r\n       OD;;\n       \\<acute>p :==\\<acute>q\" in HoareTotal.annotateI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps.\n       \\<Gamma>\n          \\<turnstile>\\<^sub>t \\<lbrace>List \\<acute>p \\<acute>next\n   Ps\\<rbrace>\n                               \\<acute>q :== Null;;\n                               WHILE \\<acute>p \\<noteq> Null\n                               INV \\<lbrace>\\<exists>Ps' Qs'.\n         List \\<acute>p \\<acute>next Ps' \\<and>\n         List \\<acute>q \\<acute>next Qs' \\<and>\n         set Ps' \\<inter> set Qs' = {} \\<and>\n         rev Ps' @ Qs' = rev Ps\\<rbrace>\n                               VAR MEASURE length\n      (list \\<acute>p \\<acute>next) \n                               DO \\<acute>r :== \\<acute>p;;\n                                  (False,\n                                   \\<lbrace>\\<acute>p \\<noteq>\n      Null\\<rbrace>)\n                                  \\<longmapsto> \\<acute>p :==\n          \\<acute>p\\<rightarrow>\\<acute>next;;\n                                  (False,\n                                   \\<lbrace>\\<acute>r \\<noteq>\n      Null\\<rbrace>)\n                                  \\<longmapsto> \\<acute>r\\<rightarrow>\\<acute>next :==\n          \\<acute>q;;\n                                  \\<acute>q :== \\<acute>r \n                               OD;;\n                               \\<acute>p :== \\<acute>q\n                               \\<lbrace>List \\<acute>p \\<acute>next\n   (rev Ps)\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Ps next p.\n       List p next Ps \\<Longrightarrow>\n       \\<exists>Ps' Qs'.\n          List p next Ps' \\<and>\n          List Null next Qs' \\<and>\n          set Ps' \\<inter> set Qs' = {} \\<and> rev Ps' @ Qs' = rev Ps\n 2. \\<And>Ps next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> p \\<noteq> Null \\<and>\n                         p \\<noteq> Null \\<and>\n                         length (list (next p) (next(p := q)))\n                         < length (list p next) \\<and>\n                         (\\<exists>Ps' Qs'.\n                             List (next p) (next(p := q)) Ps' \\<and>\n                             List p (next(p := q)) Qs' \\<and>\n                             set Ps' \\<inter> set Qs' = {} \\<and>\n                             rev Ps' @ Qs' = rev Ps)\n 3. \\<And>Ps next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "apply   clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Ps next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> p \\<noteq> Null \\<and>\n                         p \\<noteq> Null \\<and>\n                         length (list (next p) (next(p := q)))\n                         < length (list p next) \\<and>\n                         (\\<exists>Ps' Qs'.\n                             List (next p) (next(p := q)) Ps' \\<and>\n                             List p (next(p := q)) Qs' \\<and>\n                             set Ps' \\<inter> set Qs' = {} \\<and>\n                             rev Ps' @ Qs' = rev Ps)\n 2. \\<And>Ps next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "apply  clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Ps next p q ps Qs'.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List q next Qs';\n        rev ps @ p # Qs' = rev Ps; p \\<notin> set Qs';\n        set ps \\<inter> set Qs' = {}\\<rbrakk>\n       \\<Longrightarrow> length (list (next p) (next(p := q)))\n                         < length (list p next) \\<and>\n                         (\\<exists>Ps'.\n                             List (next p) (next(p := q)) Ps' \\<and>\n                             (\\<exists>Qs'.\n                                 (\\<exists>ps.\n                                     Qs' = p # ps \\<and>\n                                     List q (next(p := q)) ps) \\<and>\n                                 set Ps' \\<inter> set Qs' = {} \\<and>\n                                 rev Ps' @ Qs' = rev Ps))\n 2. \\<And>Ps next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "apply  (rule conjI2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Ps next p q ps Qs'.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List q next Qs';\n        rev ps @ p # Qs' = rev Ps; p \\<notin> set Qs';\n        set ps \\<inter> set Qs' = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps'.\n                            List (next p) (next(p := q)) Ps' \\<and>\n                            (\\<exists>Qs'.\n                                (\\<exists>ps.\n                                    Qs' = p # ps \\<and>\n                                    List q (next(p := q)) ps) \\<and>\n                                set Ps' \\<inter> set Qs' = {} \\<and>\n                                rev Ps' @ Qs' = rev Ps)\n 2. \\<And>Ps next p q ps Qs'.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List q next Qs';\n        rev ps @ p # Qs' = rev Ps; p \\<notin> set Qs';\n        set ps \\<inter> set Qs' = {};\n        \\<exists>Ps'.\n           List (next p) (next(p := q)) Ps' \\<and>\n           (\\<exists>Qs'.\n               (\\<exists>ps.\n                   Qs' = p # ps \\<and> List q (next(p := q)) ps) \\<and>\n               set Ps' \\<inter> set Qs' = {} \\<and>\n               rev Ps' @ Qs' = rev Ps)\\<rbrakk>\n       \\<Longrightarrow> length (list (next p) (next(p := q)))\n                         < length (list p next)\n 3. \\<And>Ps next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "apply   force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Ps next p q ps Qs'.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List q next Qs';\n        rev ps @ p # Qs' = rev Ps; p \\<notin> set Qs';\n        set ps \\<inter> set Qs' = {};\n        \\<exists>Ps'.\n           List (next p) (next(p := q)) Ps' \\<and>\n           (\\<exists>Qs'.\n               (\\<exists>ps.\n                   Qs' = p # ps \\<and> List q (next(p := q)) ps) \\<and>\n               set Ps' \\<inter> set Qs' = {} \\<and>\n               rev Ps' @ Qs' = rev Ps)\\<rbrakk>\n       \\<Longrightarrow> length (list (next p) (next(p := q)))\n                         < length (list p next)\n 2. \\<And>Ps next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "apply  clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Ps next p q ps Qs' Ps' psa.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List q next Qs';\n        rev ps @ p # Qs' = rev Ps; p \\<notin> set Qs';\n        set ps \\<inter> set Qs' = {}; List (next p) next Ps';\n        set Ps' \\<inter> set psa = {}; rev Ps' @ p # psa = rev Ps;\n        List q (next(p := q)) psa\\<rbrakk>\n       \\<Longrightarrow> length (list (next p) (next(p := q)))\n                         < length (list p next)\n 2. \\<And>Ps next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "apply  (subgoal_tac \"List p next (p#ps)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Ps next p q ps Qs' Ps' psa.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List q next Qs';\n        rev ps @ p # Qs' = rev Ps; p \\<notin> set Qs';\n        set ps \\<inter> set Qs' = {}; List (next p) next Ps';\n        set Ps' \\<inter> set psa = {}; rev Ps' @ p # psa = rev Ps;\n        List q (next(p := q)) psa; List p next (p # ps)\\<rbrakk>\n       \\<Longrightarrow> length (list (next p) (next(p := q)))\n                         < length (list p next)\n 2. \\<And>Ps next p q ps Qs' Ps' psa.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List q next Qs';\n        rev ps @ p # Qs' = rev Ps; p \\<notin> set Qs';\n        set ps \\<inter> set Qs' = {}; List (next p) next Ps';\n        set Ps' \\<inter> set psa = {}; rev Ps' @ p # psa = rev Ps;\n        List q (next(p := q)) psa\\<rbrakk>\n       \\<Longrightarrow> List p next (p # ps)\n 3. \\<And>Ps next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Ps next p q ps Qs' Ps' psa.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List q next Qs';\n        rev ps @ p # Qs' = rev Ps; p \\<notin> set Qs';\n        set ps \\<inter> set Qs' = {}; List (next p) next Ps';\n        set Ps' \\<inter> set psa = {}; rev Ps' @ p # psa = rev Ps;\n        List q (next(p := q)) psa\\<rbrakk>\n       \\<Longrightarrow> List p next (p # ps)\n 2. \\<And>Ps next p q ps Qs' Ps' psa.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List q next Qs';\n        rev ps @ p # Qs' = rev Ps; p \\<notin> set Qs';\n        set ps \\<inter> set Qs' = {}; List (next p) next Ps';\n        set Ps' \\<inter> set psa = {}; rev Ps' @ p # psa = rev Ps;\n        List q (next(p := q)) psa; List p next (p # ps)\\<rbrakk>\n       \\<Longrightarrow> length (list (next p) (next(p := q)))\n                         < length (list p next)\n 3. \\<And>Ps next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Ps next p q ps Qs' Ps' psa.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List q next Qs';\n        rev ps @ p # Qs' = rev Ps; p \\<notin> set Qs';\n        set ps \\<inter> set Qs' = {}; List (next p) next Ps';\n        set Ps' \\<inter> set psa = {}; rev Ps' @ p # psa = rev Ps;\n        List q (next(p := q)) psa; List p next (p # ps)\\<rbrakk>\n       \\<Longrightarrow> length (list (next p) (next(p := q)))\n                         < length (list p next)\n 2. \\<And>Ps next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "apply  (frule_tac q=q in upd_hd_next)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Ps next p q ps Qs' Ps' psa.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List q next Qs';\n        rev ps @ p # Qs' = rev Ps; p \\<notin> set Qs';\n        set ps \\<inter> set Qs' = {}; List (next p) next Ps';\n        set Ps' \\<inter> set psa = {}; rev Ps' @ p # psa = rev Ps;\n        List q (next(p := q)) psa; List p next (p # ps);\n        List (next p) (next(p := q)) ps\\<rbrakk>\n       \\<Longrightarrow> length (list (next p) (next(p := q)))\n                         < length (list p next)\n 2. \\<And>Ps next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "apply  (simp only: List_list)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Ps next p q ps Qs' Ps' psa.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List q next Qs';\n        rev ps @ p # Qs' = rev Ps; p \\<notin> set Qs';\n        set ps \\<inter> set Qs' = {}; List (next p) next Ps';\n        set Ps' \\<inter> set psa = {}; rev Ps' @ p # psa = rev Ps;\n        List q (next(p := q)) psa; List p next (p # ps);\n        List (next p) (next(p := q)) ps\\<rbrakk>\n       \\<Longrightarrow> length ps < length (p # ps)\n 2. \\<And>Ps next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Ps next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in Rev_impl) shows\n Rev_modifies:\n  \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>\\<^bsub>/UNIV \\<^esub>{\\<sigma>} \\<acute>p :== PROC Rev(\\<acute>p) {t. t may_only_modify_globals \\<sigma> in [next]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^bsub>/UNIV\\<^esub> {\\<sigma>}\n      \\<acute>p :== PROC Rev(\\<acute>p)\n      {t. t may_only_modify_globals \\<sigma> in [next]}", "apply (hoare_rule HoarePartial.ProcNoRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile>\\<^bsub>/UNIV\\<^esub> {\\<sigma>}\n      \\<acute>q :== Null;;\n      WHILE \\<acute>p \\<noteq> Null \n      DO \\<acute>r :== \\<acute>p;;\n         (False, \\<lbrace>\\<acute>p \\<noteq> Null\\<rbrace>)\n         \\<longmapsto> \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n         (False, \\<lbrace>\\<acute>r \\<noteq> Null\\<rbrace>)\n         \\<longmapsto> \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>q;;\n         \\<acute>q :== \\<acute>r \n      OD;;\n      \\<acute>p :== \\<acute>q\n      {t. t may_only_modify_globals \\<sigma> in [next]}", "apply (vcg spec=modifies)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>List \\<acute>p \\<acute>next Ps\\<rbrace>\n       \\<acute>q :== Null;;\n       WHILE \\<acute>p \\<noteq> Null INV \\<lbrace>\\<exists>Ps' Qs'. List \\<acute>p \\<acute>next Ps' \\<and> List \\<acute>q \\<acute>next Qs' \\<and>\n                             set Ps' \\<inter> set Qs' = {} \\<and>\n                             rev Ps' @ Qs' = rev Ps\\<rbrace>\n       VAR MEASURE (length (list \\<acute>p \\<acute>next) )\n        DO\n         \\<acute>r :== \\<acute>p;; \\<acute>p :== \\<acute>p\\<rightarrow>\\<acute>next;;\n         \\<acute>r\\<rightarrow>\\<acute>next :== \\<acute>q;; \\<acute>q :== \\<acute>r\n       OD;;\n       \\<acute>p :==\\<acute>q\n       \\<lbrace>List \\<acute>p \\<acute>next (rev Ps)\\<rbrace> \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile>\\<^sub>t \\<lbrace>List \\<acute>p \\<acute>next Ps\\<rbrace>\n                            \\<acute>q :== Null;;\n                            WHILE \\<acute>p \\<noteq> Null\n                            INV \\<lbrace>\\<exists>Ps' Qs'.\n      List \\<acute>p \\<acute>next Ps' \\<and>\n      List \\<acute>q \\<acute>next Qs' \\<and>\n      set Ps' \\<inter> set Qs' = {} \\<and> rev Ps' @ Qs' = rev Ps\\<rbrace>\n                            VAR MEASURE length\n   (list \\<acute>p \\<acute>next) \n                            DO \\<acute>r :== \\<acute>p;;\n                               \\<acute>p :==\n                               \\<acute>p\\<rightarrow>\\<acute>next;;\n                               \\<acute>r\\<rightarrow>\\<acute>next :==\n                               \\<acute>q;;\n                               \\<acute>q :== \\<acute>r \n                            OD;;\n                            \\<acute>p :== \\<acute>q\n                            \\<lbrace>List \\<acute>p \\<acute>next\n(rev Ps)\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>next p.\n       List p next Ps \\<Longrightarrow>\n       \\<exists>Ps' Qs'.\n          List p next Ps' \\<and>\n          List Null next Qs' \\<and>\n          set Ps' \\<inter> set Qs' = {} \\<and> rev Ps' @ Qs' = rev Ps\n 2. \\<And>next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> length (list (next p) (next(p := q)))\n                         < length (list p next) \\<and>\n                         (\\<exists>Ps' Qs'.\n                             List (next p) (next(p := q)) Ps' \\<and>\n                             List p (next(p := q)) Qs' \\<and>\n                             set Ps' \\<inter> set Qs' = {} \\<and>\n                             rev Ps' @ Qs' = rev Ps)\n 3. \\<And>next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "apply   clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> length (list (next p) (next(p := q)))\n                         < length (list p next) \\<and>\n                         (\\<exists>Ps' Qs'.\n                             List (next p) (next(p := q)) Ps' \\<and>\n                             List p (next(p := q)) Qs' \\<and>\n                             set Ps' \\<inter> set Qs' = {} \\<and>\n                             rev Ps' @ Qs' = rev Ps)\n 2. \\<And>next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "apply  clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next p q ps Qs'.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List q next Qs';\n        rev ps @ p # Qs' = rev Ps; p \\<notin> set Qs';\n        set ps \\<inter> set Qs' = {}\\<rbrakk>\n       \\<Longrightarrow> length (list (next p) (next(p := q)))\n                         < length (list p next) \\<and>\n                         (\\<exists>Ps'.\n                             List (next p) (next(p := q)) Ps' \\<and>\n                             (\\<exists>Qs'.\n                                 (\\<exists>ps.\n                                     Qs' = p # ps \\<and>\n                                     List q (next(p := q)) ps) \\<and>\n                                 set Ps' \\<inter> set Qs' = {} \\<and>\n                                 rev Ps' @ Qs' = rev Ps))\n 2. \\<And>next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "apply  (rule conjI2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>next p q ps Qs'.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List q next Qs';\n        rev ps @ p # Qs' = rev Ps; p \\<notin> set Qs';\n        set ps \\<inter> set Qs' = {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Ps'.\n                            List (next p) (next(p := q)) Ps' \\<and>\n                            (\\<exists>Qs'.\n                                (\\<exists>ps.\n                                    Qs' = p # ps \\<and>\n                                    List q (next(p := q)) ps) \\<and>\n                                set Ps' \\<inter> set Qs' = {} \\<and>\n                                rev Ps' @ Qs' = rev Ps)\n 2. \\<And>next p q ps Qs'.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List q next Qs';\n        rev ps @ p # Qs' = rev Ps; p \\<notin> set Qs';\n        set ps \\<inter> set Qs' = {};\n        \\<exists>Ps'.\n           List (next p) (next(p := q)) Ps' \\<and>\n           (\\<exists>Qs'.\n               (\\<exists>ps.\n                   Qs' = p # ps \\<and> List q (next(p := q)) ps) \\<and>\n               set Ps' \\<inter> set Qs' = {} \\<and>\n               rev Ps' @ Qs' = rev Ps)\\<rbrakk>\n       \\<Longrightarrow> length (list (next p) (next(p := q)))\n                         < length (list p next)\n 3. \\<And>next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "apply   force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next p q ps Qs'.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List q next Qs';\n        rev ps @ p # Qs' = rev Ps; p \\<notin> set Qs';\n        set ps \\<inter> set Qs' = {};\n        \\<exists>Ps'.\n           List (next p) (next(p := q)) Ps' \\<and>\n           (\\<exists>Qs'.\n               (\\<exists>ps.\n                   Qs' = p # ps \\<and> List q (next(p := q)) ps) \\<and>\n               set Ps' \\<inter> set Qs' = {} \\<and>\n               rev Ps' @ Qs' = rev Ps)\\<rbrakk>\n       \\<Longrightarrow> length (list (next p) (next(p := q)))\n                         < length (list p next)\n 2. \\<And>next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "apply  clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next p q ps Qs' Ps' psa.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List q next Qs';\n        rev ps @ p # Qs' = rev Ps; p \\<notin> set Qs';\n        set ps \\<inter> set Qs' = {}; List (next p) next Ps';\n        set Ps' \\<inter> set psa = {}; rev Ps' @ p # psa = rev Ps;\n        List q (next(p := q)) psa\\<rbrakk>\n       \\<Longrightarrow> length (list (next p) (next(p := q)))\n                         < length (list p next)\n 2. \\<And>next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "apply  (subgoal_tac \"List p next (p#ps)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>next p q ps Qs' Ps' psa.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List q next Qs';\n        rev ps @ p # Qs' = rev Ps; p \\<notin> set Qs';\n        set ps \\<inter> set Qs' = {}; List (next p) next Ps';\n        set Ps' \\<inter> set psa = {}; rev Ps' @ p # psa = rev Ps;\n        List q (next(p := q)) psa; List p next (p # ps)\\<rbrakk>\n       \\<Longrightarrow> length (list (next p) (next(p := q)))\n                         < length (list p next)\n 2. \\<And>next p q ps Qs' Ps' psa.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List q next Qs';\n        rev ps @ p # Qs' = rev Ps; p \\<notin> set Qs';\n        set ps \\<inter> set Qs' = {}; List (next p) next Ps';\n        set Ps' \\<inter> set psa = {}; rev Ps' @ p # psa = rev Ps;\n        List q (next(p := q)) psa\\<rbrakk>\n       \\<Longrightarrow> List p next (p # ps)\n 3. \\<And>next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>next p q ps Qs' Ps' psa.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List q next Qs';\n        rev ps @ p # Qs' = rev Ps; p \\<notin> set Qs';\n        set ps \\<inter> set Qs' = {}; List (next p) next Ps';\n        set Ps' \\<inter> set psa = {}; rev Ps' @ p # psa = rev Ps;\n        List q (next(p := q)) psa\\<rbrakk>\n       \\<Longrightarrow> List p next (p # ps)\n 2. \\<And>next p q ps Qs' Ps' psa.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List q next Qs';\n        rev ps @ p # Qs' = rev Ps; p \\<notin> set Qs';\n        set ps \\<inter> set Qs' = {}; List (next p) next Ps';\n        set Ps' \\<inter> set psa = {}; rev Ps' @ p # psa = rev Ps;\n        List q (next(p := q)) psa; List p next (p # ps)\\<rbrakk>\n       \\<Longrightarrow> length (list (next p) (next(p := q)))\n                         < length (list p next)\n 3. \\<And>next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next p q ps Qs' Ps' psa.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List q next Qs';\n        rev ps @ p # Qs' = rev Ps; p \\<notin> set Qs';\n        set ps \\<inter> set Qs' = {}; List (next p) next Ps';\n        set Ps' \\<inter> set psa = {}; rev Ps' @ p # psa = rev Ps;\n        List q (next(p := q)) psa; List p next (p # ps)\\<rbrakk>\n       \\<Longrightarrow> length (list (next p) (next(p := q)))\n                         < length (list p next)\n 2. \\<And>next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "apply  (frule_tac q=q in upd_hd_next)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next p q ps Qs' Ps' psa.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List q next Qs';\n        rev ps @ p # Qs' = rev Ps; p \\<notin> set Qs';\n        set ps \\<inter> set Qs' = {}; List (next p) next Ps';\n        set Ps' \\<inter> set psa = {}; rev Ps' @ p # psa = rev Ps;\n        List q (next(p := q)) psa; List p next (p # ps);\n        List (next p) (next(p := q)) ps\\<rbrakk>\n       \\<Longrightarrow> length (list (next p) (next(p := q)))\n                         < length (list p next)\n 2. \\<And>next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "apply  (simp only: List_list)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>next p q ps Qs' Ps' psa.\n       \\<lbrakk>p \\<noteq> Null; List (next p) next ps; List q next Qs';\n        rev ps @ p # Qs' = rev Ps; p \\<notin> set Qs';\n        set ps \\<inter> set Qs' = {}; List (next p) next Ps';\n        set Ps' \\<inter> set psa = {}; rev Ps' @ p # psa = rev Ps;\n        List q (next(p := q)) psa; List p next (p # ps);\n        List (next p) (next(p := q)) ps\\<rbrakk>\n       \\<Longrightarrow> length ps < length (p # ps)\n 2. \\<And>next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>next p q.\n       \\<lbrakk>\\<exists>Ps' Qs'.\n                   List p next Ps' \\<and>\n                   List q next Qs' \\<and>\n                   set Ps' \\<inter> set Qs' = {} \\<and>\n                   rev Ps' @ Qs' = rev Ps;\n        \\<not> p \\<noteq> Null\\<rbrakk>\n       \\<Longrightarrow> List q next (rev Ps)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "procedures\n  pedal(N,M) = \"IF 0 < \\<acute>N THEN\n                            IF 0 < \\<acute>M THEN CALL coast(\\<acute>N- 1,\\<acute>M- 1) FI;;\n                            CALL pedal(\\<acute>N- 1,\\<acute>M)\n                         FI\"\n\nand\n\n  coast(N,M) = \"CALL pedal(\\<acute>N,\\<acute>M);;\n                         IF 0 < \\<acute>M THEN CALL coast(\\<acute>N,\\<acute>M- 1) FI\""], ["", "ML \\<open>ML_Thms.bind_thm (\"HoareTotal_ProcRec2\", Hoare.gen_proc_rec @{context} Hoare.Total 2)\\<close>"], ["", "lemma (in pedal_coast_clique)\n  shows \"(\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace>  PROC pedal(\\<acute>N,\\<acute>M) \\<lbrace>True\\<rbrace>) \\<and>\n         (\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace> PROC coast(\\<acute>N,\\<acute>M) \\<lbrace>True\\<rbrace>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace>\n                            PROC pedal(\\<acute>N,\\<acute>M)\n                            \\<lbrace>True\\<rbrace> \\<and>\n    \\<Gamma>\n       \\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace>\n                            PROC coast(\\<acute>N,\\<acute>M)\n                            \\<lbrace>True\\<rbrace>", "apply (hoare_rule HoareTotal_ProcRec2\n          [where ?r= \"inv_image (measure (\\<lambda>m. m) <*lex*>\n                                  measure (\\<lambda>p. if p = coast_'proc then 1 else 0))\n                      (\\<lambda>(s,p). (\\<^bsup>s\\<^esup>N + \\<^bsup>s\\<^esup>M,p))\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,{(\\<lbrace>True\\<rbrace> \\<inter>\n                  \\<lbrace>\\<acute>N + \\<acute>M\n                           < \\<^bsup>\\<sigma>\\<^esup>N +\n                             \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                           \\<acute>N + \\<acute>M =\n                           \\<^bsup>\\<sigma>\\<^esup>N +\n                           \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                           (if pedal_'proc = coast_'proc then 1 else 0)\n                           < (if pedal_'proc = coast_'proc then 1\n                              else 0)\\<rbrace>,\n                  pedal_'proc, \\<lbrace>True\\<rbrace>, {})} \\<union>\n                {(\\<lbrace>True\\<rbrace> \\<inter>\n                  \\<lbrace>\\<acute>N + \\<acute>M\n                           < \\<^bsup>\\<sigma>\\<^esup>N +\n                             \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                           \\<acute>N + \\<acute>M =\n                           \\<^bsup>\\<sigma>\\<^esup>N +\n                           \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                           (if coast_'proc = coast_'proc then 1 else 0)\n                           < (if pedal_'proc = coast_'proc then 1\n                              else 0)\\<rbrace>,\n                  coast_'proc, \\<lbrace>True\\<rbrace>, {})}\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> \\<lbrace>True\\<rbrace>)\n                               IF 0 < \\<acute>N\n                               THEN IF 0 < \\<acute>M\n                                    THEN CALL coast(\\<acute>N - 1,\n\\<acute>M - 1)\n                                    FI;;\n                                 CALL pedal(\\<acute>N - 1,\\<acute>M)\n                               FI\n                               \\<lbrace>True\\<rbrace>\n 2. \\<forall>\\<sigma>.\n       \\<Gamma>,{(\\<lbrace>True\\<rbrace> \\<inter>\n                  \\<lbrace>\\<acute>N + \\<acute>M\n                           < \\<^bsup>\\<sigma>\\<^esup>N +\n                             \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                           \\<acute>N + \\<acute>M =\n                           \\<^bsup>\\<sigma>\\<^esup>N +\n                           \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                           (if pedal_'proc = coast_'proc then 1 else 0)\n                           < (if coast_'proc = coast_'proc then 1\n                              else 0)\\<rbrace>,\n                  pedal_'proc, \\<lbrace>True\\<rbrace>, {})} \\<union>\n                {(\\<lbrace>True\\<rbrace> \\<inter>\n                  \\<lbrace>\\<acute>N + \\<acute>M\n                           < \\<^bsup>\\<sigma>\\<^esup>N +\n                             \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                           \\<acute>N + \\<acute>M =\n                           \\<^bsup>\\<sigma>\\<^esup>N +\n                           \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                           (if coast_'proc = coast_'proc then 1 else 0)\n                           < (if coast_'proc = coast_'proc then 1\n                              else 0)\\<rbrace>,\n                  coast_'proc, \\<lbrace>True\\<rbrace>, {})}\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> \\<lbrace>True\\<rbrace>)\n                               CALL pedal(\\<acute>N,\\<acute>M);;\n                               IF 0 < \\<acute>M\n                               THEN CALL coast(\\<acute>N,\\<acute>M - 1) FI\n                               \\<lbrace>True\\<rbrace>", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,{(\\<lbrace>\\<acute>N + \\<acute>M\n                           < \\<^bsup>\\<sigma>\\<^esup>N +\n                             \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                  coast_'proc, UNIV, {}),\n                 (\\<lbrace>\\<acute>N + \\<acute>M\n                           < \\<^bsup>\\<sigma>\\<^esup>N +\n                             \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                  pedal_'proc, UNIV, {})}\n          \\<turnstile>\\<^sub>t {\\<sigma>}\n                               IF 0 < \\<acute>N\n                               THEN IF 0 < \\<acute>M\n                                    THEN CALL coast(\\<acute>N - Suc 0,\n\\<acute>M - Suc 0)\n                                    FI;;\n                                 CALL pedal(\\<acute>N - Suc 0)\n                               FI\n                               UNIV\n 2. \\<forall>\\<sigma>.\n       \\<Gamma>,{(\\<lbrace>\\<acute>N + \\<acute>M\n                           < \\<^bsup>\\<sigma>\\<^esup>N +\n                             \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                  coast_'proc, UNIV, {}),\n                 (\\<lbrace>\\<acute>N + \\<acute>M\n                           < \\<^bsup>\\<sigma>\\<^esup>N +\n                             \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                           \\<acute>N + \\<acute>M =\n                           \\<^bsup>\\<sigma>\\<^esup>N +\n                           \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                  pedal_'proc, UNIV, {})}\n          \\<turnstile>\\<^sub>t {\\<sigma>}\n                               CALL pedal();;\n                               IF 0 < \\<acute>M\n                               THEN CALL coast(\\<acute>M - Suc 0) FI\n                               UNIV", "apply (vcg,force)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in pedal_coast_clique)\n  shows \"(\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace> PROC pedal(\\<acute>N,\\<acute>M) \\<lbrace>True\\<rbrace>) \\<and>\n         (\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace> PROC coast(\\<acute>N,\\<acute>M) \\<lbrace>True\\<rbrace>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace>\n                            PROC pedal(\\<acute>N,\\<acute>M)\n                            \\<lbrace>True\\<rbrace> \\<and>\n    \\<Gamma>\n       \\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace>\n                            PROC coast(\\<acute>N,\\<acute>M)\n                            \\<lbrace>True\\<rbrace>", "apply (hoare_rule HoareTotal_ProcRec2\n          [where ?r= \"inv_image (measure (\\<lambda>m. m) <*lex*>\n                                  measure (\\<lambda>p. if p = coast_'proc then 1 else 0))\n                      (\\<lambda>(s,p). (\\<^bsup>s\\<^esup>N + \\<^bsup>s\\<^esup>M,p))\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,{(\\<lbrace>True\\<rbrace> \\<inter>\n                  \\<lbrace>\\<acute>N + \\<acute>M\n                           < \\<^bsup>\\<sigma>\\<^esup>N +\n                             \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                           \\<acute>N + \\<acute>M =\n                           \\<^bsup>\\<sigma>\\<^esup>N +\n                           \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                           (if pedal_'proc = coast_'proc then 1 else 0)\n                           < (if pedal_'proc = coast_'proc then 1\n                              else 0)\\<rbrace>,\n                  pedal_'proc, \\<lbrace>True\\<rbrace>, {})} \\<union>\n                {(\\<lbrace>True\\<rbrace> \\<inter>\n                  \\<lbrace>\\<acute>N + \\<acute>M\n                           < \\<^bsup>\\<sigma>\\<^esup>N +\n                             \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                           \\<acute>N + \\<acute>M =\n                           \\<^bsup>\\<sigma>\\<^esup>N +\n                           \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                           (if coast_'proc = coast_'proc then 1 else 0)\n                           < (if pedal_'proc = coast_'proc then 1\n                              else 0)\\<rbrace>,\n                  coast_'proc, \\<lbrace>True\\<rbrace>, {})}\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> \\<lbrace>True\\<rbrace>)\n                               IF 0 < \\<acute>N\n                               THEN IF 0 < \\<acute>M\n                                    THEN CALL coast(\\<acute>N - 1,\n\\<acute>M - 1)\n                                    FI;;\n                                 CALL pedal(\\<acute>N - 1,\\<acute>M)\n                               FI\n                               \\<lbrace>True\\<rbrace>\n 2. \\<forall>\\<sigma>.\n       \\<Gamma>,{(\\<lbrace>True\\<rbrace> \\<inter>\n                  \\<lbrace>\\<acute>N + \\<acute>M\n                           < \\<^bsup>\\<sigma>\\<^esup>N +\n                             \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                           \\<acute>N + \\<acute>M =\n                           \\<^bsup>\\<sigma>\\<^esup>N +\n                           \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                           (if pedal_'proc = coast_'proc then 1 else 0)\n                           < (if coast_'proc = coast_'proc then 1\n                              else 0)\\<rbrace>,\n                  pedal_'proc, \\<lbrace>True\\<rbrace>, {})} \\<union>\n                {(\\<lbrace>True\\<rbrace> \\<inter>\n                  \\<lbrace>\\<acute>N + \\<acute>M\n                           < \\<^bsup>\\<sigma>\\<^esup>N +\n                             \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                           \\<acute>N + \\<acute>M =\n                           \\<^bsup>\\<sigma>\\<^esup>N +\n                           \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                           (if coast_'proc = coast_'proc then 1 else 0)\n                           < (if coast_'proc = coast_'proc then 1\n                              else 0)\\<rbrace>,\n                  coast_'proc, \\<lbrace>True\\<rbrace>, {})}\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> \\<lbrace>True\\<rbrace>)\n                               CALL pedal(\\<acute>N,\\<acute>M);;\n                               IF 0 < \\<acute>M\n                               THEN CALL coast(\\<acute>N,\\<acute>M - 1) FI\n                               \\<lbrace>True\\<rbrace>", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,{(\\<lbrace>\\<acute>N + \\<acute>M\n                           < \\<^bsup>\\<sigma>\\<^esup>N +\n                             \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                  coast_'proc, UNIV, {}),\n                 (\\<lbrace>\\<acute>N + \\<acute>M\n                           < \\<^bsup>\\<sigma>\\<^esup>N +\n                             \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                  pedal_'proc, UNIV, {})}\n          \\<turnstile>\\<^sub>t {\\<sigma>}\n                               IF 0 < \\<acute>N\n                               THEN IF 0 < \\<acute>M\n                                    THEN CALL coast(\\<acute>N - Suc 0,\n\\<acute>M - Suc 0)\n                                    FI;;\n                                 CALL pedal(\\<acute>N - Suc 0)\n                               FI\n                               UNIV\n 2. \\<forall>\\<sigma>.\n       \\<Gamma>,{(\\<lbrace>\\<acute>N + \\<acute>M\n                           < \\<^bsup>\\<sigma>\\<^esup>N +\n                             \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                  coast_'proc, UNIV, {}),\n                 (\\<lbrace>\\<acute>N + \\<acute>M\n                           < \\<^bsup>\\<sigma>\\<^esup>N +\n                             \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                           \\<acute>N + \\<acute>M =\n                           \\<^bsup>\\<sigma>\\<^esup>N +\n                           \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                  pedal_'proc, UNIV, {})}\n          \\<turnstile>\\<^sub>t {\\<sigma>}\n                               CALL pedal();;\n                               IF 0 < \\<acute>M\n                               THEN CALL coast(\\<acute>M - Suc 0) FI\n                               UNIV", "apply (vcg,force)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in pedal_coast_clique)\n  shows \"(\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace> PROC pedal(\\<acute>N,\\<acute>M) \\<lbrace>True\\<rbrace>) \\<and>\n         (\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace> PROC coast(\\<acute>N,\\<acute>M) \\<lbrace>True\\<rbrace>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace>\n                            PROC pedal(\\<acute>N,\\<acute>M)\n                            \\<lbrace>True\\<rbrace> \\<and>\n    \\<Gamma>\n       \\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace>\n                            PROC coast(\\<acute>N,\\<acute>M)\n                            \\<lbrace>True\\<rbrace>", "apply(hoare_rule HoareTotal_ProcRec2\n     [where ?r= \"measure (\\<lambda>(s,p). \\<^bsup>s\\<^esup>N + \\<^bsup>s\\<^esup>M + (if p = coast_'proc then 1 else 0))\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,{(\\<lbrace>True\\<rbrace> \\<inter>\n                  \\<lbrace>\\<acute>N + \\<acute>M +\n                           (if pedal_'proc = coast_'proc then 1 else 0)\n                           < \\<^bsup>\\<sigma>\\<^esup>N +\n                             \\<^bsup>\\<sigma>\\<^esup>M +\n                             (if pedal_'proc = coast_'proc then 1\n                              else 0)\\<rbrace>,\n                  pedal_'proc, \\<lbrace>True\\<rbrace>, {})} \\<union>\n                {(\\<lbrace>True\\<rbrace> \\<inter>\n                  \\<lbrace>\\<acute>N + \\<acute>M +\n                           (if coast_'proc = coast_'proc then 1 else 0)\n                           < \\<^bsup>\\<sigma>\\<^esup>N +\n                             \\<^bsup>\\<sigma>\\<^esup>M +\n                             (if pedal_'proc = coast_'proc then 1\n                              else 0)\\<rbrace>,\n                  coast_'proc, \\<lbrace>True\\<rbrace>, {})}\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> \\<lbrace>True\\<rbrace>)\n                               IF 0 < \\<acute>N\n                               THEN IF 0 < \\<acute>M\n                                    THEN CALL coast(\\<acute>N - 1,\n\\<acute>M - 1)\n                                    FI;;\n                                 CALL pedal(\\<acute>N - 1,\\<acute>M)\n                               FI\n                               \\<lbrace>True\\<rbrace>\n 2. \\<forall>\\<sigma>.\n       \\<Gamma>,{(\\<lbrace>True\\<rbrace> \\<inter>\n                  \\<lbrace>\\<acute>N + \\<acute>M +\n                           (if pedal_'proc = coast_'proc then 1 else 0)\n                           < \\<^bsup>\\<sigma>\\<^esup>N +\n                             \\<^bsup>\\<sigma>\\<^esup>M +\n                             (if coast_'proc = coast_'proc then 1\n                              else 0)\\<rbrace>,\n                  pedal_'proc, \\<lbrace>True\\<rbrace>, {})} \\<union>\n                {(\\<lbrace>True\\<rbrace> \\<inter>\n                  \\<lbrace>\\<acute>N + \\<acute>M +\n                           (if coast_'proc = coast_'proc then 1 else 0)\n                           < \\<^bsup>\\<sigma>\\<^esup>N +\n                             \\<^bsup>\\<sigma>\\<^esup>M +\n                             (if coast_'proc = coast_'proc then 1\n                              else 0)\\<rbrace>,\n                  coast_'proc, \\<lbrace>True\\<rbrace>, {})}\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> \\<lbrace>True\\<rbrace>)\n                               CALL pedal(\\<acute>N,\\<acute>M);;\n                               IF 0 < \\<acute>M\n                               THEN CALL coast(\\<acute>N,\\<acute>M - 1) FI\n                               \\<lbrace>True\\<rbrace>", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,{(\\<lbrace>Suc (\\<acute>N + \\<acute>M)\n                           < \\<^bsup>\\<sigma>\\<^esup>N +\n                             \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                  coast_'proc, UNIV, {}),\n                 (\\<lbrace>\\<acute>N + \\<acute>M\n                           < \\<^bsup>\\<sigma>\\<^esup>N +\n                             \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                  pedal_'proc, UNIV, {})}\n          \\<turnstile>\\<^sub>t {\\<sigma>}\n                               IF 0 < \\<acute>N\n                               THEN IF 0 < \\<acute>M\n                                    THEN CALL coast(\\<acute>N - Suc 0,\n\\<acute>M - Suc 0)\n                                    FI;;\n                                 CALL pedal(\\<acute>N - Suc 0)\n                               FI\n                               UNIV\n 2. \\<forall>\\<sigma>.\n       \\<Gamma>,{(\\<lbrace>\\<acute>N + \\<acute>M\n                           < \\<^bsup>\\<sigma>\\<^esup>N +\n                             \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                  coast_'proc, UNIV, {}),\n                 (\\<lbrace>\\<acute>N + \\<acute>M\n                           < Suc (\\<^bsup>\\<sigma>\\<^esup>N +\n                                  \\<^bsup>\\<sigma>\\<^esup>M)\\<rbrace>,\n                  pedal_'proc, UNIV, {})}\n          \\<turnstile>\\<^sub>t {\\<sigma>}\n                               CALL pedal();;\n                               IF 0 < \\<acute>M\n                               THEN CALL coast(\\<acute>M - Suc 0) FI\n                               UNIV", "apply (vcg,force)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in pedal_coast_clique)\n  shows \"(\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace> PROC pedal(\\<acute>N,\\<acute>M) \\<lbrace>True\\<rbrace>) \\<and>\n         (\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace> PROC coast(\\<acute>N,\\<acute>M) \\<lbrace>True\\<rbrace>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace>\n                            PROC pedal(\\<acute>N,\\<acute>M)\n                            \\<lbrace>True\\<rbrace> \\<and>\n    \\<Gamma>\n       \\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace>\n                            PROC coast(\\<acute>N,\\<acute>M)\n                            \\<lbrace>True\\<rbrace>", "apply(hoare_rule HoareTotal_ProcRec2\n     [where ?r= \"(\\<lambda>(s,p). \\<^bsup>s\\<^esup>N) <*mlex*> (\\<lambda>(s,p). \\<^bsup>s\\<^esup>M) <*mlex*>\n                 measure (\\<lambda>(s,p). if p = coast_'proc then 1 else 0)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,{(\\<lbrace>True\\<rbrace> \\<inter>\n                  \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                           \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                           (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                            \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                            (if pedal_'proc = coast_'proc then 1 else 0)\n                            < (if pedal_'proc = coast_'proc then 1\n                               else 0))\\<rbrace>,\n                  pedal_'proc, \\<lbrace>True\\<rbrace>, {})} \\<union>\n                {(\\<lbrace>True\\<rbrace> \\<inter>\n                  \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                           \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                           (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                            \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                            (if coast_'proc = coast_'proc then 1 else 0)\n                            < (if pedal_'proc = coast_'proc then 1\n                               else 0))\\<rbrace>,\n                  coast_'proc, \\<lbrace>True\\<rbrace>, {})}\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> \\<lbrace>True\\<rbrace>)\n                               IF 0 < \\<acute>N\n                               THEN IF 0 < \\<acute>M\n                                    THEN CALL coast(\\<acute>N - 1,\n\\<acute>M - 1)\n                                    FI;;\n                                 CALL pedal(\\<acute>N - 1,\\<acute>M)\n                               FI\n                               \\<lbrace>True\\<rbrace>\n 2. \\<forall>\\<sigma>.\n       \\<Gamma>,{(\\<lbrace>True\\<rbrace> \\<inter>\n                  \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                           \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                           (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                            \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                            (if pedal_'proc = coast_'proc then 1 else 0)\n                            < (if coast_'proc = coast_'proc then 1\n                               else 0))\\<rbrace>,\n                  pedal_'proc, \\<lbrace>True\\<rbrace>, {})} \\<union>\n                {(\\<lbrace>True\\<rbrace> \\<inter>\n                  \\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                           \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                           (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                            \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M \\<and>\n                            (if coast_'proc = coast_'proc then 1 else 0)\n                            < (if coast_'proc = coast_'proc then 1\n                               else 0))\\<rbrace>,\n                  coast_'proc, \\<lbrace>True\\<rbrace>, {})}\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> \\<lbrace>True\\<rbrace>)\n                               CALL pedal(\\<acute>N,\\<acute>M);;\n                               IF 0 < \\<acute>M\n                               THEN CALL coast(\\<acute>N,\\<acute>M - 1) FI\n                               \\<lbrace>True\\<rbrace>", "apply  simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,{(\\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                           \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                           \\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                  coast_'proc, UNIV, {}),\n                 (\\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                           \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                           \\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                  pedal_'proc, UNIV, {})}\n          \\<turnstile>\\<^sub>t {\\<sigma>}\n                               IF 0 < \\<acute>N\n                               THEN IF 0 < \\<acute>M\n                                    THEN CALL coast(\\<acute>N - Suc 0,\n\\<acute>M - Suc 0)\n                                    FI;;\n                                 CALL pedal(\\<acute>N - Suc 0)\n                               FI\n                               UNIV\n 2. \\<forall>\\<sigma>.\n       \\<Gamma>,{(\\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                           \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                           \\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                  coast_'proc, UNIV, {}),\n                 (\\<lbrace>\\<acute>N < \\<^bsup>\\<sigma>\\<^esup>N \\<or>\n                           \\<acute>N = \\<^bsup>\\<sigma>\\<^esup>N \\<and>\n                           (\\<acute>M < \\<^bsup>\\<sigma>\\<^esup>M \\<or>\n                            \\<acute>M = \\<^bsup>\\<sigma>\\<^esup>M)\\<rbrace>,\n                  pedal_'proc, UNIV, {})}\n          \\<turnstile>\\<^sub>t {\\<sigma>}\n                               CALL pedal();;\n                               IF 0 < \\<acute>M\n                               THEN CALL coast(\\<acute>M - Suc 0) FI\n                               UNIV", "apply (vcg,force)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in pedal_coast_clique)\n  shows \"(\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace> PROC pedal(\\<acute>N,\\<acute>M) \\<lbrace>True\\<rbrace>) \\<and>\n         (\\<Gamma>\\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace> PROC coast(\\<acute>N,\\<acute>M) \\<lbrace>True\\<rbrace>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\n       \\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace>\n                            PROC pedal(\\<acute>N,\\<acute>M)\n                            \\<lbrace>True\\<rbrace> \\<and>\n    \\<Gamma>\n       \\<turnstile>\\<^sub>t \\<lbrace>True\\<rbrace>\n                            PROC coast(\\<acute>N,\\<acute>M)\n                            \\<lbrace>True\\<rbrace>", "apply(hoare_rule HoareTotal_ProcRec2\n     [where ?r= \"measure (\\<lambda>s. \\<^bsup>s\\<^esup>N + \\<^bsup>s\\<^esup>M) <*lex*>\n                 measure (\\<lambda>p. if p = coast_'proc then 1 else 0)\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,{(\\<lbrace>True\\<rbrace> \\<inter>\n                  {s. N_' s + M_' s < N_' \\<sigma> + M_' \\<sigma> \\<or>\n                      s = \\<sigma> \\<and>\n                      (if pedal_'proc = coast_'proc then 1 else 0)\n                      < (if pedal_'proc = coast_'proc then 1 else 0)},\n                  pedal_'proc, \\<lbrace>True\\<rbrace>, {})} \\<union>\n                {(\\<lbrace>True\\<rbrace> \\<inter>\n                  {s. N_' s + M_' s < N_' \\<sigma> + M_' \\<sigma> \\<or>\n                      s = \\<sigma> \\<and>\n                      (if coast_'proc = coast_'proc then 1 else 0)\n                      < (if pedal_'proc = coast_'proc then 1 else 0)},\n                  coast_'proc, \\<lbrace>True\\<rbrace>, {})}\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> \\<lbrace>True\\<rbrace>)\n                               IF 0 < \\<acute>N\n                               THEN IF 0 < \\<acute>M\n                                    THEN CALL coast(\\<acute>N - 1,\n\\<acute>M - 1)\n                                    FI;;\n                                 CALL pedal(\\<acute>N - 1,\\<acute>M)\n                               FI\n                               \\<lbrace>True\\<rbrace>\n 2. \\<forall>\\<sigma>.\n       \\<Gamma>,{(\\<lbrace>True\\<rbrace> \\<inter>\n                  {s. N_' s + M_' s < N_' \\<sigma> + M_' \\<sigma> \\<or>\n                      s = \\<sigma> \\<and>\n                      (if pedal_'proc = coast_'proc then 1 else 0)\n                      < (if coast_'proc = coast_'proc then 1 else 0)},\n                  pedal_'proc, \\<lbrace>True\\<rbrace>, {})} \\<union>\n                {(\\<lbrace>True\\<rbrace> \\<inter>\n                  {s. N_' s + M_' s < N_' \\<sigma> + M_' \\<sigma> \\<or>\n                      s = \\<sigma> \\<and>\n                      (if coast_'proc = coast_'proc then 1 else 0)\n                      < (if coast_'proc = coast_'proc then 1 else 0)},\n                  coast_'proc, \\<lbrace>True\\<rbrace>, {})}\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter> \\<lbrace>True\\<rbrace>)\n                               CALL pedal(\\<acute>N,\\<acute>M);;\n                               IF 0 < \\<acute>M\n                               THEN CALL coast(\\<acute>N,\\<acute>M - 1) FI\n                               \\<lbrace>True\\<rbrace>", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,{(\\<lbrace>\\<acute>N + \\<acute>M\n                           < \\<^bsup>\\<sigma>\\<^esup>N +\n                             \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                  coast_'proc, UNIV, {}),\n                 (\\<lbrace>\\<acute>N + \\<acute>M\n                           < \\<^bsup>\\<sigma>\\<^esup>N +\n                             \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                  pedal_'proc, UNIV, {})}\n          \\<turnstile>\\<^sub>t {\\<sigma>}\n                               IF 0 < \\<acute>N\n                               THEN IF 0 < \\<acute>M\n                                    THEN CALL coast(\\<acute>N - Suc 0,\n\\<acute>M - Suc 0)\n                                    FI;;\n                                 CALL pedal(\\<acute>N - Suc 0)\n                               FI\n                               UNIV\n 2. \\<forall>\\<sigma>.\n       \\<Gamma>,{(\\<lbrace>\\<acute>N + \\<acute>M\n                           < \\<^bsup>\\<sigma>\\<^esup>N +\n                             \\<^bsup>\\<sigma>\\<^esup>M\\<rbrace>,\n                  coast_'proc, UNIV, {}),\n                 ({s. N_' s + M_' s < N_' \\<sigma> + M_' \\<sigma> \\<or>\n                      s = \\<sigma>},\n                  pedal_'proc, UNIV, {})}\n          \\<turnstile>\\<^sub>t {\\<sigma>}\n                               CALL pedal();;\n                               IF 0 < \\<acute>M\n                               THEN CALL coast(\\<acute>M - Suc 0) FI\n                               UNIV", "apply (vcg,force)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}